<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/34571">
    <body>
      <group id="34571">
        <trans-unit id="f74e6e1dd54190d3d7fae8f5e96f21fb78828a1c" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; lets you look into &lt;code&gt;private&lt;/code&gt; methods. The same thing applies for
  &lt;code&gt;getDeclaredField&lt;/code&gt;.</source>
          <target state="translated">1. &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; 사용하면 &lt;code&gt;private&lt;/code&gt; 메소드를 조사 할 수 있습니다. &lt;code&gt;getDeclaredField&lt;/code&gt; 도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f4cc2a945e6a4c9cbf53136a3c39c4f241d9f273" translate="yes" xml:space="preserve">
          <source>2. The &lt;code&gt;setAccessible(true)&lt;/code&gt; is required to play around with privates.</source>
          <target state="translated">2. &lt;code&gt;setAccessible(true)&lt;/code&gt; 은 개인과 장난을하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="80637c7eb7c5bf4678572b0409559fa57c032965" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BoundBox&lt;/strong&gt; makes it easy to test private/protected fields, methods and constructors. You can even access stuff that is hidden by inheritance. Indeed, BoundBox breaks encapsulation. It will give you access to all that through reflection, &lt;strong&gt;BUT&lt;/strong&gt; everything is checked at compile time.</source>
          <target state="translated">&lt;strong&gt;BoundBox를&lt;/strong&gt; 사용하면 개인 / 보호 필드, 메서드 및 생성자를 쉽게 테스트 할 수 있습니다. 상속에 의해 숨겨져있는 것들에 접근 할 수도 있습니다. 실제로 BoundBox는 캡슐화를 중단합니다. 리플렉션을 통해 모든 것에 액세스 할 수 &lt;strong&gt;있지만&lt;/strong&gt; 컴파일 타임에 모든 것이 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="0c965907d2371e2e657952ec6ec3ce4cc3d0164e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;호출 메소드, 예를 들어 &lt;code&gt;private void method(String s)&lt;/code&gt; -Java 리플렉션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aee3ea62516774cc4584c0e8794c9a0a9ff8a6b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;호출 메소드, 예 : &lt;code&gt;private void method(String s)&lt;/code&gt; -by Picklock&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="667a59955051009a0f32a003c2e1f6aeaf7043bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creating an SDK&lt;/strong&gt; for community
consumption. Here public takes on a
wholly different meaning, since this
is code that the whole world may see
(not just internal to my application). I put
code into private methods if I don't
want the SDK users to see it - I
don't see this as code smell, merely
as how SDK programming works. But of
course I still need to test my
private methods, and they are where
the functionality of my SDK actually
lives.</source>
          <target state="translated">커뮤니티 소비를 &lt;strong&gt;위한 SDK 작성&lt;/strong&gt; 여기에서 대중은 완전히 다른 의미를 취합니다. 전 세계가 볼 수있는 코드이기 때문에 (내 응용 프로그램의 내부가 아니라). SDK 사용자가 그것을보고 싶지 않으면 코드를 개인 메소드에 넣습니다. SDK 프로그래밍이 작동하는 방식으로 코드 냄새로 보지 않습니다. 그러나 물론 여전히 개인 메서드를 테스트해야하며 SDK의 기능이 실제로 존재하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="6b22ef7e1373ec5f2ed54ae4759f376b1b1ee360" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decryption routines&lt;/strong&gt; - I would not
want to make them visible to anyone to see just for
the sake of testing, else anyone can
use them to decrypt. But they are
intrinsic to the code, complicated,
and need to always work (the obvious exception is reflection which can be used to view even private methods in most cases, when &lt;code&gt;SecurityManager&lt;/code&gt; is not configured to prevent this).</source>
          <target state="translated">&lt;strong&gt;해독 루틴&lt;/strong&gt; -테스트 목적으로 만 볼 수 있도록 다른 사람이 볼 수 있도록하고 싶지 않으면 다른 사람이 해독을 위해 사용할 수 있습니다. 그러나 이들은 코드에 내재되어 있고 복잡하며 항상 작동해야합니다 (보안 예외가이를 방지하도록 구성되지 않은 경우 대부분의 경우 개인 메소드조차 볼 수있는 리플렉션은 명백한 예외입니다).</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00ccefff1cbb81b8564fd74ef5534ed942a1e40f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;private BigInteger amount;&lt;/code&gt; 과 같은 필드 설정 ;&lt;/strong&gt; &lt;strong&gt;-자바 리플렉션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4836ec35d6655b402cb0aeff0cc2d9be8bcd9902" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;private BigInteger amount;&lt;/code&gt; 과 같은 필드 설정 ;&lt;/strong&gt; &lt;strong&gt;-Picklock 제작&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a14ff6d0d2545a4fd033426dd9eb1bca74f4bd7" translate="yes" xml:space="preserve">
          <source>A private method is only to be accessed within the same class. So there is no way to test a &amp;ldquo;private&amp;rdquo; method of a target class from any test class. A way out is that you can perform unit testing manually or can change your method from &amp;ldquo;private&amp;rdquo; to &amp;ldquo;protected&amp;rdquo;.</source>
          <target state="translated">개인 메소드는 동일한 클래스 내에서만 액세스 할 수 있습니다. 따라서 테스트 클래스에서 대상 클래스의 &quot;비공개&quot;메소드를 테스트 할 방법이 없습니다. 방법은 단위 테스트를 수동으로 수행하거나 분석법을 &quot;비공개&quot;에서 &quot;보호됨&quot;으로 변경할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c9f143cb14712f08a4e4970f0a574a82e563a424" translate="yes" xml:space="preserve">
          <source>Advantages:</source>
          <target state="translated">Advantages:</target>
        </trans-unit>
        <trans-unit id="2221efbf6965fac587b30d46e7724828ceb3edb5" translate="yes" xml:space="preserve">
          <source>And for fields:</source>
          <target state="translated">그리고 필드의 경우 :</target>
        </trans-unit>
        <trans-unit id="c8c30bf3f7e13ff579f2d44836856a1df45a19af" translate="yes" xml:space="preserve">
          <source>And then a protected method can only be accessed within the same package where the class is defined. So, testing a protected method of a target class means we need to define your test class in the same package as the target class.</source>
          <target state="translated">그런 다음 보호 된 메소드는 클래스가 정의 된 동일한 패키지 내에서만 액세스 할 수 있습니다. 따라서 대상 클래스의 보호 된 메소드를 테스트한다는 것은 대상 클래스와 동일한 패키지에서 테스트 클래스를 정의해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="441792634ac4afd259f6c658a390705cde49193e" translate="yes" xml:space="preserve">
          <source>Another approach I have used is to change a private method to package private or protected then complement it with the &lt;strong&gt;@VisibleForTesting&lt;/strong&gt; annotation of the Google Guava library.</source>
          <target state="translated">내가 사용한 또 다른 방법은 개인 또는 보호 된 패키지로 개인 메서드를 변경 한 다음 Google Guava 라이브러리의 &lt;strong&gt;@VisibleForTesting&lt;/strong&gt; 주석으로 보완하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1301fc79049e7c65b4bbcf0ba6a61f5931687552" translate="yes" xml:space="preserve">
          <source>As many above have suggested, a good way is to test them via your public interfaces.</source>
          <target state="translated">위의 많은 사람들이 제안했듯이 좋은 방법은 공용 인터페이스를 통해 테스트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c13f7ca769cb85f3221127a40fbd5279f00e0fe7" translate="yes" xml:space="preserve">
          <source>As others have said... don't test private methods directly. Here are a few thoughts:</source>
          <target state="translated">다른 사람들이 말했듯이 개인적인 방법을 직접 테스트하지 마십시오. 다음은 몇 가지 생각입니다.</target>
        </trans-unit>
        <trans-unit id="00cf60dde25747bce8c2e44c6fa9ab92a1635c71" translate="yes" xml:space="preserve">
          <source>But if you must...</source>
          <target state="translated">그러나 당신이해야한다면 ...</target>
        </trans-unit>
        <trans-unit id="f0a8bb1ef2a081f480e91c8e34564927ff144af5" translate="yes" xml:space="preserve">
          <source>Can test to a finer granularity</source>
          <target state="translated">더 세밀하게 테스트 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0c069424ea8e8618c40b30af58a3b6dd3f06183b" translate="yes" xml:space="preserve">
          <source>Creating a test with access to private members and methods can test areas of code which are difficult to target specifically with access only to public methods. If a public method has several steps involved, it can consist of several private methods, which can then be tested individually.</source>
          <target state="translated">비공개 멤버 및 메소드에 액세스하여 테스트를 작성하면 공개 메소드에만 액세스하여 구체적으로 타겟팅하기 어려운 코드 영역을 테스트 할 수 있습니다. 공용 메소드에 여러 단계가 포함 된 경우 여러 개인 메소드로 구성되어 개별적으로 테스트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c472a51872469dd7221cdb8ed81b476216096187" translate="yes" xml:space="preserve">
          <source>Disadvantages:</source>
          <target state="translated">Disadvantages:</target>
        </trans-unit>
        <trans-unit id="c9c9e5c85c1bd842957bfd2bf60f5c54670f8662" translate="yes" xml:space="preserve">
          <source>Don't test private methods.</source>
          <target state="translated">개인용 메소드를 테스트하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="da1688d4291f35c06929635ff89a47756bee4936" translate="yes" xml:space="preserve">
          <source>First, I'll throw this question out: Why do your private members need isolated testing? Are they that complex, providing such complicated behaviors as to require testing apart from the public surface? It's unit testing, not 'line-of-code' testing. Don't sweat the small stuff.</source>
          <target state="translated">먼저,이 질문을 던질 것입니다 : 왜 당신의 개인 회원들이 고립 된 테스트를 필요로합니까? 공공 장소와는 별도로 테스트가 필요한 복잡한 행동을 제공하는 것이 복잡합니까? '코드 라인'테스트가 아니라 단위 테스트입니다. 작은 물건을 땀 흘리지 마십시오.</target>
        </trans-unit>
        <trans-unit id="488ba946d622fc383a6720a0de399a291c4a6365" translate="yes" xml:space="preserve">
          <source>For example, if a method to be tested is in &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; then your test call should be placed in &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt;. That way, you got access to the test method in your test class.</source>
          <target state="translated">예를 들어, 테스트 할 메소드가 &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; 에 있으면 테스트 호출은 &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt; 에 배치되어야합니다. 이렇게하면 테스트 클래스의 테스트 메소드에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c046b725299d827b1b1cfbff5b6ff9701d5b447f" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;Testing Private Methods with JUnit and SuiteRunner&lt;/a&gt; (Bill Venners), you basically have 4 options:</source>
          <target state="translated">이 기사 : &lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;JUnit 및 SuiteRunner&lt;/a&gt; (빌 벤너)를 사용 하여 개인 메소드 테스트 에는 기본적으로 4 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8c15b3105382053e62cc365916933eb7995b28" translate="yes" xml:space="preserve">
          <source>Generally a unit test is intended to exercise the public interface of a class or unit. Therefore, private methods are implementation detail that you would not expect to test explicitly.</source>
          <target state="translated">일반적으로 단위 테스트는 클래스 또는 단위의 공용 인터페이스를 연습하기위한 것입니다. 따라서 개인 메소드는 명시 적으로 테스트하지 않을 구현 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="21f944c5c0cd9b55951029e9c48346ad8ecaccfc" translate="yes" xml:space="preserve">
          <source>Give the methods package access.</source>
          <target state="translated">메소드 패키지 액세스를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="3ea99547c530ccc60cd2d951a1059ecc58a082c9" translate="yes" xml:space="preserve">
          <source>Having tried Cem Catikkas' &lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;solution using reflection&lt;/a&gt; for Java, I'd have to say his was a more elegant solution than I have described here. However, if you're looking for an alternative to using reflection, and have access to the source you're testing, this will still be an option.</source>
          <target state="translated">Java 용 &lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;리플렉션&lt;/a&gt; 을 사용하여 Cem Catikkas의 솔루션을 사용해 본 결과 , 여기에 설명 된 것보다 더 우아한 솔루션이라고 말할 수 있습니다. 그러나 리플렉션 사용에 대한 대안을 찾고 있고 테스트중인 소스에 액세스 할 수있는 경우 여전히 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="738ac079cb2720eec3fc2ea83fa03d06c4e24357" translate="yes" xml:space="preserve">
          <source>Here is a convoluted example of how this would work:</source>
          <target state="translated">이것이 어떻게 작동하는지에 대한 복잡한 예입니다.</target>
        </trans-unit>
        <trans-unit id="bad99404aed0664a20ca51067abe49d23d05a388" translate="yes" xml:space="preserve">
          <source>Here is my generic function to test private fields:</source>
          <target state="translated">개인 필드를 테스트하는 일반적인 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf1020a5e41eab9e99f445355aec8da27a8d8c7f" translate="yes" xml:space="preserve">
          <source>How do I test a private function or a class that has private methods, fields or inner classes</source>
          <target state="translated">개인 함수, 개인 메서드, 필드 또는 내부 클래스가있는 클래스를 테스트하는 방법</target>
        </trans-unit>
        <trans-unit id="0de14c706b029a054d6bb30db817984dba502ac6" translate="yes" xml:space="preserve">
          <source>How do I unit test (using xUnit) a class that has internal private methods, fields or nested classes? Or a function that is made private by having &lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;internal linkage&lt;/a&gt; (&lt;code&gt;static&lt;/code&gt; in C/C++) or is in a private (&lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;anonymous&lt;/a&gt;) namespace?</source>
          <target state="translated">내부 개인 메서드, 필드 또는 중첩 클래스가있는 클래스를 단위 테스트 (xUnit 사용)하려면 어떻게합니까? 또는 &lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;내부 연결&lt;/a&gt; (C / C ++에서 &lt;code&gt;static&lt;/code&gt; )을 사용하여 개인용으로 만들거나 개인용 ( &lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;익명&lt;/a&gt; ) 네임 스페이스에있는 함수입니까?</target>
        </trans-unit>
        <trans-unit id="bc255ea980bb0a2a256131036675cc23632ebedb" translate="yes" xml:space="preserve">
          <source>However, if continuous testing requires this method, it may be a signal that the private methods should be extracted, which could be tested in the traditional, public way.</source>
          <target state="translated">그러나 지속적인 테스트에이 방법이 필요한 경우 개인 방법을 추출해야한다는 신호일 수 있습니다.이 방법은 전통적인 공개 방법으로 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ab4d98c5b0b5ae62722cd5daba84f9fc5d09e2" translate="yes" xml:space="preserve">
          <source>I have used &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; to do this for Java in the past, and in my opinion it was a big mistake.</source>
          <target state="translated">과거에 Java에 대해이 작업을 수행하기 위해 &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;리플렉션&lt;/a&gt; 을 사용했으며 내 의견으로는 큰 실수였습니다.</target>
        </trans-unit>
        <trans-unit id="b3f669f5a4850db8ae087533d316d74f7d18ef39" translate="yes" xml:space="preserve">
          <source>I personally believe it is better to create classes using TDD; creating the public method stubs, then generating unit tests with &lt;strong&gt;all&lt;/strong&gt; the assertions defined in advance, so the expected outcome of the method is determined before you code it. This way, you don't go down the wrong path of making the unit test assertions fit the results. Your class is then robust and meets requirements when all your unit tests pass.</source>
          <target state="translated">개인적으로 TDD를 사용하여 클래스를 작성하는 것이 더 좋다고 생각합니다. 퍼블릭 메소드 스텁을 작성한 후, 사전에 정의 된 &lt;strong&gt;모든&lt;/strong&gt; 어설 션으로 단위 테스트를 생성하므로 메소드의 예상 결과는 코딩 전에 결정됩니다. 이렇게하면 단위 테스트 어설 션이 결과에 적합하게 만드는 잘못된 경로를 밟지 않아도됩니다. 그러면 수업은 견고하며 모든 단위 테스트를 통과하면 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="e36b52cb9fdfbb3e329d1441d178206837d71b2c" translate="yes" xml:space="preserve">
          <source>I recently had this problem and wrote a little tool, called &lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;Picklock&lt;/a&gt;, that avoids the problems of explicitly using the Java reflection API, two examples:</source>
          <target state="translated">나는 최근 에이 문제가 있었고 Java 반사 API를 명시 적으로 사용하는 문제를 피하는 &lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;Picklock&lt;/a&gt; 이라는 작은 도구를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="7d99726e2e6121e3f90a851753d372ae38b3621b" translate="yes" xml:space="preserve">
          <source>I tend not to test private methods.  There lies madness.  Personally, I believe you should only test your publicly exposed interfaces (and that includes protected and internal methods).</source>
          <target state="translated">나는 개인적인 방법을 테스트하지 않는 경향이 있습니다. 광기가 있습니다. 개인적으로, 공개적으로 노출 된 인터페이스 (보호 및 내부 방법 포함) 만 테스트해야한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="5f07dd3769ec6c1f05bf2a35c0526f8b0b85e8f1" translate="yes" xml:space="preserve">
          <source>I understand the idea of only testing the &quot;contract&quot;. But I don't see one can advocate actually not testing code - your mileage may vary.</source>
          <target state="translated">&quot;계약&quot;만 테스트한다는 생각을 이해합니다. 그러나 실제로 코드를 테스트하지 말라고 주장 할 수는 없습니다. 마일리지는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ef42a47a405d6ea0d40445563542edd3714ab0" translate="yes" xml:space="preserve">
          <source>I use the &lt;strong&gt;junitx.util.PrivateAccessor&lt;/strong&gt;-package for Java . Lots of helpful one-liners for accessing private methods and private fields.</source>
          <target state="translated">Java 용 &lt;strong&gt;junitx.util.PrivateAccessor-package를&lt;/strong&gt; 사용합니다. 개인 메소드 및 개인 필드에 액세스하는 데 도움이되는 많은 원 라이너.</target>
        </trans-unit>
        <trans-unit id="42bb9d6ad7029d11852bf236c965500fd6aeb10a" translate="yes" xml:space="preserve">
          <source>I would suggest you refactoring your code a little bit. When you have to start thinking about using reflection or other kind of stuff, for just testing your code, something is going wrong with your code.</source>
          <target state="translated">코드를 약간 리팩토링하는 것이 좋습니다. 코드를 테스트하기 위해 리플렉션 또는 다른 종류의 물건을 사용하는 것에 대해 생각해야 할 때 코드에 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c18c5a0c0257d22e6651f930fb4b67ab6d6430" translate="yes" xml:space="preserve">
          <source>I'd have used this:</source>
          <target state="translated">나는 이것을 사용했을 것이다 :</target>
        </trans-unit>
        <trans-unit id="856f0a021ec6929f0585d3353794587bc738b479" translate="yes" xml:space="preserve">
          <source>If all the above does not suits your requirement, use &lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;the  reflection way&lt;/strong&gt;&lt;/a&gt; to access the private method.</source>
          <target state="translated">위의 모든 사항이 요구 사항에 맞지 않으면 &lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;리플렉션 방법&lt;/strong&gt;&lt;/a&gt; 을 사용하여 개인 방법에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="2908c85ab8d5229462900d545e121dbae5bc5f33" translate="yes" xml:space="preserve">
          <source>If refactoring is inappropriate or infeasible, can you use the strategy pattern to replace access to these private member functions / member classes when under unit test? Under unit test, the strategy would provide added validation, but in release builds it would be simple passthrough.</source>
          <target state="translated">리팩토링이 부적절하거나 실행 불가능한 경우, 단위 테스트 중에 전략 패턴을 사용하여 이러한 개인 멤버 함수 / 멤버 클래스에 대한 액세스를 대체 할 수 있습니까? 단위 테스트에서 전략은 추가 검증을 제공하지만 릴리스 빌드에서는 간단한 통과입니다.</target>
        </trans-unit>
        <trans-unit id="b50c21d867d9f45732d608b976f552d6b804fae5" translate="yes" xml:space="preserve">
          <source>If the class's design is still flexible, and you've got a complicated private method that you'd like to test separately, I suggest you pull it out into a separate class and test that class separately. This doesn't have to change the public interface of the original class; it can internally create an instance of the helper class and call the helper method.</source>
          <target state="translated">클래스 디자인이 여전히 유연하고 개별적으로 테스트하려는 복잡한 개인 메소드가있는 경우 별도의 클래스로 가져 와서 해당 클래스를 개별적으로 테스트하는 것이 좋습니다. 원래 클래스의 공용 인터페이스를 변경할 필요는 없습니다. 내부적으로 헬퍼 클래스의 인스턴스를 작성하고 헬퍼 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f91aaf05eb0d0047f2110ff5981712e3f94e2098" translate="yes" xml:space="preserve">
          <source>If they are that big, big enough that these private members are each a 'unit' large in complexity -- consider refactoring such private members out of this class.</source>
          <target state="translated">이들이 개인 구성원이 복잡 할 정도로 큰 '단위'가 될만큼 충분히 크고 큰 경우-개인 구성원을이 클래스에서 리팩토링하는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="afa066ad607390e7196812b766cdf27e86c8c154" translate="yes" xml:space="preserve">
          <source>If using Spring, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;ReflectionTestUtils&lt;/a&gt; provides some handy tools that help out here with minimal effort. For example, to set up a mock on a private member without being forced to add an undesirable public setter:</source>
          <target state="translated">Spring을 사용하는 경우 &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;ReflectionTestUtils&lt;/a&gt; 는 최소한의 노력으로 여기에 도움이되는 편리한 도구를 제공합니다. 예를 들어, 바람직하지 않은 공개 설정자를 추가하지 않고 개인 구성원에 모형을 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="83193c16ef655f324fc282cd1969a12136199cf8" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.3 or higher, you can use reflection to subvert
  the access control mechanism with the aid of the &lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;PrivilegedAccessor&lt;/a&gt;.
  For details on how to use it, read &lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">JDK 1.3 이상을 사용하는 경우 &lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;PrivilegedAccessor&lt;/a&gt; 의 도움으로 리플렉션을 사용하여 액세스 제어 메커니즘을 파괴 할 수 있습니다. 사용 방법에 대한 자세한 내용은 &lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;이 기사를&lt;/a&gt; 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="82c0d1bf8945f5975a8f462f666b9a4e0e5e127d" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.6 or higher and you annotate your tests with
  @Test, you can use &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; to inject reflection in your test methods. For
  details on how to use it, see &lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;this test script&lt;/a&gt;.</source>
          <target state="translated">JDK 1.6 이상을 사용하고 @Test로 테스트에 주석을 달 경우 &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; 를 사용하여 테스트 방법에 리플렉션을 주입 할 수 있습니다. 사용 방법에 대한 자세한 내용은 &lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;이 테스트 스크립트를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b31f8facdbfd1bfa9d19d56f79ad1c75fa0d34e" translate="yes" xml:space="preserve">
          <source>If you do this, it's a good idea to use a code coverage tool (like Emma) to see if your private methods are in fact being executed from your tests.</source>
          <target state="translated">이 작업을 수행하는 경우 코드와 같은 코드 적용 도구 (Emma와 같은)를 사용하여 개인 메서드가 실제로 테스트에서 실행되고 있는지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="231ced4c5a18aefc12b359da49c26b919a67fbb9" translate="yes" xml:space="preserve">
          <source>If you got some code with private methods or fields or constructors, you can use &lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;BoundBox&lt;/strong&gt;&lt;/a&gt;. It does exactly what you are looking for.
Here below is an example of a test that accesses two private fields of an Android activity to test it:</source>
          <target state="translated">개인 메소드 또는 필드 또는 생성자가있는 코드가 있으면 &lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;BoundBox&lt;/strong&gt;&lt;/a&gt; 를 사용할 수 있습니다. 당신이 찾고있는 것을 정확하게 수행합니다. 다음은 테스트를 위해 Android 활동의 두 개인 필드에 액세스하는 테스트의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c79881c26b4f45425fd6ff0dd1d27b095fb2240a" translate="yes" xml:space="preserve">
          <source>If you have somewhat of a legacy &lt;strong&gt;Java&lt;/strong&gt; application, and you're not allowed to change the visibility of your methods, the best way to test private methods is to use &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt;.</source>
          <target state="translated">레거시 &lt;strong&gt;Java&lt;/strong&gt; 애플리케이션이 있고 메소드의 가시성을 변경할 수없는 경우 개인 메소드를 테스트하는 가장 좋은 방법은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; 을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b48c353a1610aa6f526142112c3e4e924cf08d8d" translate="yes" xml:space="preserve">
          <source>If you want to test difficult error conditions coming from the helper method, you can go a step further. Extract an interface from the helper class, add a public getter and setter to the original class to inject the helper class (used through its interface), and then inject a mock version of the helper class into the original class to test how the original class responds to exceptions from the helper. This approach is also helpful if you want to test the original class without also testing the helper class.</source>
          <target state="translated">헬퍼 메소드에서 오는 어려운 오류 조건을 테스트하려는 경우 한 단계 더 나아갈 수 있습니다. 헬퍼 클래스에서 인터페이스를 추출하고 공용 getter 및 setter를 원래 클래스에 추가하여 헬퍼 클래스 (인터페이스를 통해 사용됨)를 주입 한 다음 모의 버전의 헬퍼 클래스를 원래 클래스에 주입하여 원래 클래스의 방법을 테스트하십시오. 도우미의 예외에 응답합니다. 이 방법은 도우미 클래스를 테스트하지 않고 원래 클래스를 테스트하려는 경우에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fe75670323f07c2b037bcc439be60b5d49e84c28" translate="yes" xml:space="preserve">
          <source>If you want to test private methods of a legacy application where you can't change the code, one option for Java is &lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;jMockit&lt;/a&gt;, which will allow you to create mocks to an object even when they're private to the class.</source>
          <target state="translated">코드를 변경할 수없는 레거시 응용 프로그램의 전용 메서드를 테스트하려는 경우 Java의 한 가지 옵션은 &lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;jMockit&lt;/a&gt; 이며, 클래스 전용 인 경우에도 객체에 대한 모의 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e52fa6e1a9545b518febc8820865af20b96e14" translate="yes" xml:space="preserve">
          <source>If you're trying to test existing code that you're reluctant or unable to change, reflection is a good choice.</source>
          <target state="translated">당신이 꺼리거나 변경할 수없는 기존 코드를 테스트하려는 경우 리플렉션이 좋은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d792406ad753323d672f9c3416735627210a6784" translate="yes" xml:space="preserve">
          <source>If you're using JUnit, have a look at &lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;junit-addons&lt;/a&gt;. It has the ability to ignore the Java security model and access private methods and attributes.</source>
          <target state="translated">JUnit을 사용하는 경우 &lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;junit-addons를&lt;/a&gt; 살펴보십시오. Java 보안 모델을 무시하고 개인용 메소드 및 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d28be3040a66843e9a8b31893a7a596588eb062b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;Spring Framework&lt;/a&gt; you can test private methods using this method:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;스프링 프레임 워크&lt;/a&gt; 에서이 메소드를 사용하여 개인 메소드를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fc74da23c19b1981c07b1448e7f5db47a487f28" translate="yes" xml:space="preserve">
          <source>Internally we're using helpers to get/set &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; variables as well as invoke &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; methods. The following patterns will let you do pretty much anything related to the private methods and fields. Of course, you can't change &lt;code&gt;private static final&lt;/code&gt; variables through reflection.</source>
          <target state="translated">내부적으로 우리는 도우미를 사용하여 &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;private static&lt;/code&gt; 변수를 가져 오거나 설정하고 &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;private static&lt;/code&gt; 메소드를 호출합니다. 다음 패턴을 사용하면 개인 메소드 및 필드와 관련된 거의 모든 작업을 수행 할 수 있습니다. 물론 리플렉션을 통해 &lt;code&gt;private static final&lt;/code&gt; 변수를 변경할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ced52e68cb80f32738bfe343adbf16629c4c90b" translate="yes" xml:space="preserve">
          <source>It is ideal for testing some legacy code. Use it carefully. ;)</source>
          <target state="translated">일부 레거시 코드를 테스트하는 데 이상적입니다. 조심해서 사용하십시오. ;)</target>
        </trans-unit>
        <trans-unit id="2fa9f5af925c4287d94f324d2dd236645502165a" translate="yes" xml:space="preserve">
          <source>It seems bad to change the access modifier for a method or function just to be able to run a test.</source>
          <target state="translated">테스트를 실행할 수 있도록 메소드 또는 함수의 액세스 수정자를 변경하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e654ed1f3d726168497b0172d3d23035e3917b98" translate="yes" xml:space="preserve">
          <source>Just two examples of where I would want to test a private method:</source>
          <target state="translated">개인 메소드를 테스트하려는 위치의 두 가지 예 :</target>
        </trans-unit>
        <trans-unit id="d4e47f0274a3c52708f822a10e289c3e99775b5d" translate="yes" xml:space="preserve">
          <source>Keep all methods small and focused (easy to test, easy to find what is wrong)</source>
          <target state="translated">모든 방법을 작고 집중적으로 유지하십시오 (테스트하기 쉽고 잘못된 것을 쉽게 찾을 수 있음)</target>
        </trans-unit>
        <trans-unit id="9adf46953726191943242b998a6a02cbbf4fca14" translate="yes" xml:space="preserve">
          <source>Mostly all that I wrote looks like it's a dependency injection pattern. In my personal experience it's really useful while testing, and I think that this kind of code is cleaner and will be easier to maintain. I'd say the same about nested classes. If a nested class contains heavy logic it would be better if you'd moved it as a package private class and have injected it into a class needing it.</source>
          <target state="translated">내가 쓴 대부분은 의존성 주입 패턴 인 것처럼 보입니다. 내 개인적인 경험에서는 테스트하는 동안 정말 유용하며 이러한 종류의 코드는 더 깨끗하고 유지 관리하기가 더 쉽다고 생각합니다. 중첩 클래스에 대해서도 마찬가지입니다. 중첩 클래스에 무거운 논리가 포함되어 있으면 패키지 개인 클래스로 이동하여 필요한 클래스에 주입하면 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="30205722f087baf2291cb886209e83bbd9803fe4" translate="yes" xml:space="preserve">
          <source>My usual approach to addressing such issues is to tease out a new class that contains the interesting bits.  Often, this method and the fields it interacts with, and maybe another method or two can be extracted in to a new class.</source>
          <target state="translated">이러한 문제를 해결하기위한 나의 일반적인 접근 방식은 흥미로운 부분을 포함하는 새로운 클래스를 만드는 것입니다. 종종,이 방법과 그것이 상호 작용하는 필드, 그리고 아마도 다른 방법 또는 두 개가 새로운 클래스로 추출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dc80e7fd583fd5394b42b7828b62bcf68608597" translate="yes" xml:space="preserve">
          <source>Note that I'm not suggesting that people create classes without using their brain! The point here is to use the forces of unit testing to help you find good new classes.</source>
          <target state="translated">사람들이 자신의 두뇌를 사용하지 않고 수업을 만들 것을 제안하지는 않습니다. 여기서 중요한 점은 좋은 새 수업을 찾는 데 도움이되는 단위 테스트의 힘을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2fe26b2c16fe9cee75070a2fc030c171634bc7bf" translate="yes" xml:space="preserve">
          <source>Now about private methods. In my personal experience when you have to stub a private method for testing, then that method has nothing to do in that class. A common pattern, in that case, would be to &lt;em&gt;wrap&lt;/em&gt; it within an interface, like &lt;code&gt;Callable&lt;/code&gt; and then you pass in that interface also in the constructor (with that multiple constructor trick):</source>
          <target state="translated">이제 개인 메소드에 대해 개인적인 경험에서 테스트를 위해 개인 메소드를 스텁 해야하는 경우 해당 메소드는 해당 클래스에서 아무 관련이 없습니다. 이 경우 일반적인 패턴은 &lt;code&gt;Callable&lt;/code&gt; 과 같은 인터페이스 내에서 &lt;em&gt;랩핑&lt;/em&gt; 한 다음 생성자에서도 해당 인터페이스를 전달하는 것입니다 (여러 생성자 트릭 포함).</target>
        </trans-unit>
        <trans-unit id="777cc4ad4d28cf7c02b892fe5111983c770aebf9" translate="yes" xml:space="preserve">
          <source>Now you can directly pass the object which has the private method, method name to be called, and additional parameters as below.</source>
          <target state="translated">이제 private 메소드, 호출 할 메소드 이름 및 추가 매개 변수가있는 오브젝트를 아래와 같이 직접 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49a4661efd1819dad49a68ff125c5dfdef8c3ea9" translate="yes" xml:space="preserve">
          <source>P.S. I'm the main contributor to &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt;, ask &lt;a href=&quot;https://stackoverflow.com/users/300248&quot;&gt;me&lt;/a&gt; if you need help. :)</source>
          <target state="translated">추신 : 저는 &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; 의 주요 기고자입니다. 도움이 필요한지 물어보십시오. :)</target>
        </trans-unit>
        <trans-unit id="5f43d2331301eb02496c0c805bc3f87c3a2c7307" translate="yes" xml:space="preserve">
          <source>Please see below for an example;</source>
          <target state="translated">예를 들어 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5fe8c532739285df240daf07b928efebea907d0a" translate="yes" xml:space="preserve">
          <source>PowerMockito is made for this.
Use maven dependency</source>
          <target state="translated">이를 위해 PowerMockito가 만들어졌습니다. 메이븐 의존성 사용</target>
        </trans-unit>
        <trans-unit id="497baeb3b5ee74d2b4d986eb47ed0293a6ada2a0" translate="yes" xml:space="preserve">
          <source>Private methods are consumed by public ones. Otherwise, they're dead code. That's why you test the public method, asserting the expected results of the public method and thereby, the private methods it consumes.</source>
          <target state="translated">비공개 메소드는 공개 메소드에 의해 소비됩니다. 그렇지 않으면 죽은 코드입니다. 그렇기 때문에 공개 메소드를 테스트하여 공개 메소드의 예상 결과와 그에 사용되는 개인 메소드를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="83d6d608b54d120b904dee27b0513327bd8a3adc" translate="yes" xml:space="preserve">
          <source>Run the code coverage on the unit tests. If you see that methods are not fully tested add to the tests to get the coverage up. Aim for 100% code coverage, but realize that you probably won't get it.</source>
          <target state="translated">단위 테스트에서 코드 적용 범위를 실행하십시오. 방법이 완전히 테스트되지 않은 경우 테스트를 추가하여 적용 범위를 늘리십시오. 100 % 코드 적용 범위를 목표로하지만 달성하지 못할 수도 있음을 인식하십시오.</target>
        </trans-unit>
        <trans-unit id="f33de1aa1bafbeb284338b42c053c4ecb4dbcf05" translate="yes" xml:space="preserve">
          <source>See also: &lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;Java Tip 106: Static inner classes for fun and profit&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">참조 : &lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;Java 팁 106 : 재미와 이익을위한 정적 내부 클래스&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b710af9a932bb8b3407780d42ea95e9d3c2c9c68" translate="yes" xml:space="preserve">
          <source>Similarly with .class output files, they must remain within the same package as declared in source code</source>
          <target state="translated">.class 출력 파일과 마찬가지로 소스 코드에 선언 된 것과 동일한 패키지 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="40ef678cea4286c297bccc879a9c3c11a47c9b03" translate="yes" xml:space="preserve">
          <source>So don't test private methods.</source>
          <target state="translated">따라서 개인 메소드를 테스트하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="204733d7cb2b813d677976ecf1b798415058621d" translate="yes" xml:space="preserve">
          <source>So my tradeoff involves complicating the JUnits with reflection, rather than compromising my security &amp;amp; SDK.</source>
          <target state="translated">그래서 내 장단점은 보안 및 SDK를 손상시키지 않고 JUnit을 반영하여 복잡하게 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1dc726b4f0600a6162d0a5fec0ac442b107c4f85" translate="yes" xml:space="preserve">
          <source>Some 10 years later perhaps the best way to test a private method, or any inaccessible member, is via &lt;strong&gt;&lt;code&gt;@Jailbreak&lt;/code&gt;&lt;/strong&gt; from the &lt;a href=&quot;https://manifold.systems&quot;&gt;Manifold&lt;/a&gt; framework.</source>
          <target state="translated">약 10 년 후 아마도 개인용 메서드 또는 액세스 할 수없는 멤버를 테스트하는 가장 좋은 방법은 &lt;a href=&quot;https://manifold.systems&quot;&gt;매니 폴드&lt;/a&gt; 프레임 워크에서 &lt;strong&gt; &lt;code&gt;@Jailbreak&lt;/code&gt; &lt;/strong&gt; 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="93fcf1e45142f4bf2b769ec5b5d2448cc5a335d7" translate="yes" xml:space="preserve">
          <source>Strictly speaking, you should &lt;em&gt;not&lt;/em&gt; be writing unit tests that directly test private methods. What you &lt;em&gt;should&lt;/em&gt; be testing is the public contract that the class has with other objects; you should never directly test an object's internals. If another developer wants to make a small internal change to the class, which doesn't affect the classes public contract, he/she then has to modify your reflection based test to ensure that it works. If you do this repeatedly throughout a project, unit tests then stop being a useful measurement of code health, and start to become a hindrance to development, and an annoyance to the development team.</source>
          <target state="translated">엄밀히 말하면 개인 메소드를 직접 테스트하는 단위 테스트를 작성해서는 &lt;em&gt;안됩니다&lt;/em&gt; . 테스트 &lt;em&gt;해야&lt;/em&gt; 할 것은 클래스가 다른 객체와 갖는 공개 계약입니다. 객체의 내부를 직접 테스트해서는 안됩니다. 다른 개발자가 클래스의 내부 계약에 영향을 미치지 않는 클래스의 작은 내부 변경을 원할 경우 리플렉션 기반 테스트를 수정하여 작동하는지 확인해야합니다. 프로젝트 전체에서이 작업을 반복적으로 수행하면 단위 테스트가 코드 상태의 유용한 측정을 중단하고 개발에 방해가되고 개발 팀에 성가심이되기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e60b23b6cc258fd2f3050f01d48f369e96d22536" translate="yes" xml:space="preserve">
          <source>Test code must reside in the same
file as source code, which can be
more difficult to maintain</source>
          <target state="translated">테스트 코드는 소스 코드와 동일한 파일에 있어야하므로 관리하기가 더 어려울 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e628bb4ef6d2f95c51a2e0fabdc7e6570882e841" translate="yes" xml:space="preserve">
          <source>Testing private methods breaks the encapsulation of your class because every time you change the internal implementation you break client code (in this case, the tests).</source>
          <target state="translated">내부 구현을 변경할 때마다 클라이언트 코드 (이 경우 테스트)가 중단되므로 전용 메서드를 테스트하면 클래스 캡슐화가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="b08d94828e924f3c44bdad7d49d7a9e8126f9b82" translate="yes" xml:space="preserve">
          <source>Testing private methods should be tested by debugging before running your unit tests on public methods.</source>
          <target state="translated">공용 메소드에서 단위 테스트를 실행하기 전에 디버깅하여 개인 메소드 테스트를 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="99ac885a2c04ce23f9e9dee57055ba4db55f0ba2" translate="yes" xml:space="preserve">
          <source>The answer from &lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;JUnit.org FAQ page&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;JUnit.org FAQ 페이지&lt;/a&gt; 의 답변 :</target>
        </trans-unit>
        <trans-unit id="612f347cc8d13e68510dabfe438c3934b0e32ab6" translate="yes" xml:space="preserve">
          <source>The best way to test a private method is via another public method. If this cannot be done, then one of the following conditions is true:</source>
          <target state="translated">개인용 메서드를 테스트하는 가장 좋은 방법은 다른 공용 메서드를 사용하는 것입니다. 이를 수행 할 수없는 경우 다음 조건 중 하나에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="bd734d3c315faa6945e06b553d5414ada763a534" translate="yes" xml:space="preserve">
          <source>The following import statement should be added:</source>
          <target state="translated">다음 import 문을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="85834fcc9380e9b0ac91e5af41b0a87baae505d9" translate="yes" xml:space="preserve">
          <source>The inner class would be compiled to &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt;.</source>
          <target state="translated">내부 클래스는 &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt; 로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="fe9916a66d8aaef8076e5a9c5eb90320bb058a1d" translate="yes" xml:space="preserve">
          <source>The method that you are trying to test should not be private</source>
          <target state="translated">테스트하려는 방법은 비공개가 아니어야합니다</target>
        </trans-unit>
        <trans-unit id="9660255e33ec7d540aff4829d9d77f76b4f97dd1" translate="yes" xml:space="preserve">
          <source>The new class exposes these methods as 'public', so they're accessible for unit testing.  The new and old classes are now both simpler than the original class, which is great for me (I need to keep things simple, or I get lost!).</source>
          <target state="translated">새 클래스는 이러한 메소드를 '공개'로 노출하므로 단위 테스트에 액세스 할 수 있습니다. 새 클래스와 기존 클래스는 이제 원래 클래스보다 간단합니다. 이는 간단합니다 (물건을 단순하게 유지해야하거나 길을 잃을 수 있습니다!).</target>
        </trans-unit>
        <trans-unit id="e7a5f083811631d013af462cec5f70ee62d8c80c" translate="yes" xml:space="preserve">
          <source>The private method is dead code</source>
          <target state="translated">전용 메소드는 데드 코드입니다</target>
        </trans-unit>
        <trans-unit id="d4f0e9f95df601d6fc574b0d6b9281cadcdeb404" translate="yes" xml:space="preserve">
          <source>The private methods are called by a public method, so the inputs to your public methods should also test private methods that are called by those public methods. When a public method fails, then that could be a failure in the private method.</source>
          <target state="translated">개인용 메소드는 공용 메소드에 의해 호출되므로 공용 메소드에 대한 입력은 해당 공용 메소드에 의해 호출 된 개인용 메소드도 테스트해야합니다. 공용 메소드가 실패하면 개인 메소드에서 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e801c066ad4c06126ee0faa678e75d5b639e6837" translate="yes" xml:space="preserve">
          <source>Then you can do</source>
          <target state="translated">그럼 넌 할 수있어</target>
        </trans-unit>
        <trans-unit id="6810d88f67449ede60291b3105c90bd696c31a2a" translate="yes" xml:space="preserve">
          <source>There are also several other design patterns which I have used while refactoring and maintaining legacy code, but it all depends on cases of your code to test. Using reflection mostly is not a problem, but when you have an enterprise application which is heavily tested and tests are run before every deployment everything gets really slow (it's just annoying and I don't like that kind of stuff).</source>
          <target state="translated">레거시 코드를 리팩토링하고 유지 관리하는 데 사용한 몇 가지 다른 디자인 패턴도 있지만 테스트 할 코드의 경우에 따라 다릅니다. 리플렉션을 사용하는 것은 문제가되지 않지만 모든 배포 전에 테스트를 많이 수행하고 테스트를 수행하는 엔터프라이즈 응용 프로그램을 사용하는 경우 모든 작업이 실제로 느려집니다 (성가 시며 그런 종류는 좋아하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="e294098a8dfea7a5c3635278eddc4336d7bbca52" translate="yes" xml:space="preserve">
          <source>There is a design smell near the class that you are testing</source>
          <target state="translated">테스트중인 클래스 근처에 디자인 냄새가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1961b3194f3eceb534220dec7cfd0658a13c79d1" translate="yes" xml:space="preserve">
          <source>There is also setter injection, but I wouldn't recommended using it. I'd better stick with a constructor and initialize everything when it's really necessary, leaving the possibility for injecting necessary dependencies.</source>
          <target state="translated">세터 주입도 있지만 사용하지 않는 것이 좋습니다. 생성자를 고수하고 실제로 필요할 때 모든 것을 초기화하여 필요한 종속성을 주입 할 가능성을 남겨 두는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a0630fa58840584312f8324a97af6d5961e771b5" translate="yes" xml:space="preserve">
          <source>There is possible merit in testing private methods of a class, particularly with &lt;a href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;, where you would like to design small tests before you write any code.</source>
          <target state="translated">코드를 작성하기 전에 작은 테스트를 디자인하려는 테스트 전용 개발을 통해 클래스의 전용 메서드를 테스트하는 것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="086b75748a5099b73be65ec37188606e7a210e65" translate="yes" xml:space="preserve">
          <source>They may also be debugged using test-driven development, debugging your unit tests until all your assertions are met.</source>
          <target state="translated">또한 테스트 중심 개발을 사용하여 디버깅 할 수 있으며 모든 어설 션이 충족 될 때까지 단위 테스트를 디버깅합니다.</target>
        </trans-unit>
        <trans-unit id="0d7e7626c0f234d5a4b1eefebb7e04bb6f95324f" translate="yes" xml:space="preserve">
          <source>This way your code remains type-safe and readable.  No design compromises, no overexposing methods and fields for the sake of tests.</source>
          <target state="translated">이런 식으로 코드를 안전하게 입력하고 읽을 수 있습니다. 테스트를위한 디자인 타협, 과도한 노출 방법 및 필드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="311f5e6a4e3dcb5323e8e594812c473e08551089" translate="yes" xml:space="preserve">
          <source>This will tell anybody using this method to take caution and not access it directly even in a package. Also a test class need not be in same package &lt;strong&gt;physically&lt;/strong&gt;, but in the same package under the &lt;strong&gt;test&lt;/strong&gt; folder.</source>
          <target state="translated">이렇게하면이 방법을 사용하는 사람에게주의를 기울이고 패키지에서도 직접 액세스하지 않도록 지시합니다. 또한 테스트 클래스는 &lt;strong&gt;물리적&lt;/strong&gt; 으로 동일한 패키지에있을 필요는 없지만 &lt;strong&gt;테스트&lt;/strong&gt; 폴더 아래의 동일한 패키지에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8bb20e26f0bfdeceed068608989a507c169de4d" translate="yes" xml:space="preserve">
          <source>This won't be a problem even with some legacy code. Old code will be using an empty constructor, and if you ask me, refactored code will look cleaner, and you'll be able to inject necessary values in test without reflection.</source>
          <target state="translated">일부 레거시 코드에서도 문제가되지 않습니다. 오래된 코드는 빈 생성자를 사용하므로 요청하면 리팩토링 된 코드가 더 깨끗 해 보일 것입니다. 반복없이 테스트에 필요한 값을 주입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f55b0f7d6249aa7de09959544b0f0feda938a90d" translate="yes" xml:space="preserve">
          <source>To test legacy code with large and quirky classes, it is often very helpful to be able to test the one private (or public) method I'm writing &lt;em&gt;right now&lt;/em&gt;.</source>
          <target state="translated">크고 기발한 클래스로 레거시 코드를 테스트하려면 지금 쓰고있는 하나의 개인 (또는 공개) 방법을 테스트하는 것이 매우 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="2dd43ad23f4bf7d3a51fa427ec672d9bd6a01af6" translate="yes" xml:space="preserve">
          <source>Today, I pushed a Java library to help testing private methods and fields. It has been designed with Android in mind, but it can really be used for any Java project.</source>
          <target state="translated">오늘은 개인 메소드 및 필드 테스트를 돕기 위해 Java 라이브러리를 푸시했습니다. Android를 염두에두고 설계되었지만 모든 Java 프로젝트에 실제로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34159cd5d97b03db44c72acff5f46f6a24c21c8c" translate="yes" xml:space="preserve">
          <source>Use a nested test class.</source>
          <target state="translated">중첩 된 테스트 클래스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f1e1383d50d27720fe116324eabd453138603022" translate="yes" xml:space="preserve">
          <source>Use code coverage tools. I like &lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;Cobertura&lt;/a&gt; (oh happy day, looks like a new version is out!)</source>
          <target state="translated">코드 적용 도구를 사용하십시오. 나는 &lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;Cobertura를&lt;/a&gt; 좋아한다 (오 행복한 날, 새로운 버전이 나온 것 같습니다!)</target>
        </trans-unit>
        <trans-unit id="fa15115704d2ddf22825eb507327d9d92e328b27" translate="yes" xml:space="preserve">
          <source>Use reflection.</source>
          <target state="translated">반사를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0736ff73d779714c30c887cd895cba51ef05c5d2" translate="yes" xml:space="preserve">
          <source>What I recommend doing instead is using a code coverage tool such as Cobertura, to ensure that the unit tests you write provide decent coverage of the code in private methods. That way, you indirectly test what the private methods are doing, and maintain a higher level of agility.</source>
          <target state="translated">대신 내가 권장하는 것은 Cobertura와 같은 코드 커버리지 도구를 사용하여 작성하는 단위 테스트가 개인 방법으로 코드의 적절한 커버리지를 제공하는지 확인하는 것입니다. 이렇게하면 개인 방법이 수행하는 작업을 간접적으로 테스트하고 더 높은 민첩성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee409982c9dae5ad88c914fa57f08415903fa09c" translate="yes" xml:space="preserve">
          <source>When I have private methods in a class that are sufficiently complicated that I feel the need to test the private methods directly, that is a code smell: my class is too complicated.</source>
          <target state="translated">개인 메서드를 직접 테스트해야 할 정도로 충분히 복잡한 클래스에 개인 메서드가 있으면 코드 냄새가납니다. 클래스가 너무 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="263c36a6dc28d5740e02d9585bf8aa9bcba9f12d" translate="yes" xml:space="preserve">
          <source>You mentioned different types of problems. Let's start with private fields. In case of private fields I would have added a new constructor and injected fields into that. Instead of this:</source>
          <target state="translated">다른 유형의 문제를 언급했습니다. 개인 필드부터 시작하겠습니다. 개인 필드의 경우 새 생성자를 추가하고 필드를 주입했습니다. 이 대신에 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
