<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/34571">
    <body>
      <group id="34571">
        <trans-unit id="f74e6e1dd54190d3d7fae8f5e96f21fb78828a1c" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; lets you look into &lt;code&gt;private&lt;/code&gt; methods. The same thing applies for
  &lt;code&gt;getDeclaredField&lt;/code&gt;.</source>
          <target state="translated">1. &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; позволяет вам изучить &lt;code&gt;private&lt;/code&gt; методы. То же самое относится и к &lt;code&gt;getDeclaredField&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4cc2a945e6a4c9cbf53136a3c39c4f241d9f273" translate="yes" xml:space="preserve">
          <source>2. The &lt;code&gt;setAccessible(true)&lt;/code&gt; is required to play around with privates.</source>
          <target state="translated">2. &lt;code&gt;setAccessible(true)&lt;/code&gt; требуется для игры с рядовыми.</target>
        </trans-unit>
        <trans-unit id="80637c7eb7c5bf4678572b0409559fa57c032965" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BoundBox&lt;/strong&gt; makes it easy to test private/protected fields, methods and constructors. You can even access stuff that is hidden by inheritance. Indeed, BoundBox breaks encapsulation. It will give you access to all that through reflection, &lt;strong&gt;BUT&lt;/strong&gt; everything is checked at compile time.</source>
          <target state="translated">&lt;strong&gt;BoundBox&lt;/strong&gt; позволяет легко тестировать приватные / защищенные поля, методы и конструкторы. Вы даже можете получить доступ к вещам, которые скрыты по наследству. Действительно, BoundBox нарушает инкапсуляцию. Это даст вам доступ ко всему этому через рефлексию, &lt;strong&gt;НО&lt;/strong&gt; все проверяется во время компиляции.</target>
        </trans-unit>
        <trans-unit id="0c965907d2371e2e657952ec6ec3ce4cc3d0164e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вызов методов, например, &lt;code&gt;private void method(String s)&lt;/code&gt; - с помощью отражения Java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aee3ea62516774cc4584c0e8794c9a0a9ff8a6b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вызов методов, например, &lt;code&gt;private void method(String s)&lt;/code&gt; - от Picklock&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="667a59955051009a0f32a003c2e1f6aeaf7043bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creating an SDK&lt;/strong&gt; for community
consumption. Here public takes on a
wholly different meaning, since this
is code that the whole world may see
(not just internal to my application). I put
code into private methods if I don't
want the SDK users to see it - I
don't see this as code smell, merely
as how SDK programming works. But of
course I still need to test my
private methods, and they are where
the functionality of my SDK actually
lives.</source>
          <target state="translated">&lt;strong&gt;Создание SDK&lt;/strong&gt; для общественного потребления. Здесь публика принимает совершенно иное значение, поскольку это код, который может видеть весь мир (не только внутренний для моего приложения). Я помещаю код в приватные методы, если не хочу, чтобы пользователи SDK видели его - я не вижу в этом запаха кода, а просто как работает программирование SDK. Но, конечно же, мне все еще нужно протестировать свои частные методы, и именно там они действительно функционируют.</target>
        </trans-unit>
        <trans-unit id="6b22ef7e1373ec5f2ed54ae4759f376b1b1ee360" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decryption routines&lt;/strong&gt; - I would not
want to make them visible to anyone to see just for
the sake of testing, else anyone can
use them to decrypt. But they are
intrinsic to the code, complicated,
and need to always work (the obvious exception is reflection which can be used to view even private methods in most cases, when &lt;code&gt;SecurityManager&lt;/code&gt; is not configured to prevent this).</source>
          <target state="translated">&lt;strong&gt;Процедуры дешифрования&lt;/strong&gt; - я бы не хотел, чтобы их кто-то видел, чтобы их можно было увидеть только для тестирования, иначе любой может использовать их для расшифровки. Но они свойственны коду, сложны и должны работать всегда (очевидное исключение - отражение, которое может использоваться для просмотра даже частных методов в большинстве случаев, когда &lt;code&gt;SecurityManager&lt;/code&gt; не настроен для предотвращения этого).</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00ccefff1cbb81b8564fd74ef5534ed942a1e40f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Настройка полей, например, &lt;code&gt;private BigInteger amount;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;- с помощью отражения Java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4836ec35d6655b402cb0aeff0cc2d9be8bcd9902" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Настройка полей, например, &lt;code&gt;private BigInteger amount;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;- Пиклоком&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a14ff6d0d2545a4fd033426dd9eb1bca74f4bd7" translate="yes" xml:space="preserve">
          <source>A private method is only to be accessed within the same class. So there is no way to test a &amp;ldquo;private&amp;rdquo; method of a target class from any test class. A way out is that you can perform unit testing manually or can change your method from &amp;ldquo;private&amp;rdquo; to &amp;ldquo;protected&amp;rdquo;.</source>
          <target state="translated">Закрытый метод доступен только в пределах одного класса. Таким образом, нет способа протестировать &amp;laquo;закрытый&amp;raquo; метод целевого класса из любого тестового класса. Выход состоит в том, что вы можете выполнить модульное тестирование вручную или изменить свой метод с &amp;laquo;частного&amp;raquo; на &amp;laquo;защищенный&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c9f143cb14712f08a4e4970f0a574a82e563a424" translate="yes" xml:space="preserve">
          <source>Advantages:</source>
          <target state="translated">Advantages:</target>
        </trans-unit>
        <trans-unit id="2221efbf6965fac587b30d46e7724828ceb3edb5" translate="yes" xml:space="preserve">
          <source>And for fields:</source>
          <target state="translated">И для полей:</target>
        </trans-unit>
        <trans-unit id="c8c30bf3f7e13ff579f2d44836856a1df45a19af" translate="yes" xml:space="preserve">
          <source>And then a protected method can only be accessed within the same package where the class is defined. So, testing a protected method of a target class means we need to define your test class in the same package as the target class.</source>
          <target state="translated">И тогда защищенный метод может быть доступен только в том же пакете,в котором определен класс.Таким образом,тестирование защищенного метода целевого класса означает,что нам необходимо определить ваш тестовый класс в том же пакете,что и целевой класс.</target>
        </trans-unit>
        <trans-unit id="441792634ac4afd259f6c658a390705cde49193e" translate="yes" xml:space="preserve">
          <source>Another approach I have used is to change a private method to package private or protected then complement it with the &lt;strong&gt;@VisibleForTesting&lt;/strong&gt; annotation of the Google Guava library.</source>
          <target state="translated">Другой подход, который я использовал, - это изменить приватный метод для упаковки приватного или защищенного, а затем дополнить его аннотацией &lt;strong&gt;@VisibleForTesting&lt;/strong&gt; библиотеки Google Guava.</target>
        </trans-unit>
        <trans-unit id="1301fc79049e7c65b4bbcf0ba6a61f5931687552" translate="yes" xml:space="preserve">
          <source>As many above have suggested, a good way is to test them via your public interfaces.</source>
          <target state="translated">Как многие из вышеперечисленных предложений,хорошим способом является их тестирование через ваши публичные интерфейсы.</target>
        </trans-unit>
        <trans-unit id="c13f7ca769cb85f3221127a40fbd5279f00e0fe7" translate="yes" xml:space="preserve">
          <source>As others have said... don't test private methods directly. Here are a few thoughts:</source>
          <target state="translated">Как говорили другие...не тестируйте частные методы напрямую.Вот несколько мыслей:</target>
        </trans-unit>
        <trans-unit id="00cf60dde25747bce8c2e44c6fa9ab92a1635c71" translate="yes" xml:space="preserve">
          <source>But if you must...</source>
          <target state="translated">Но если тебе нужно...</target>
        </trans-unit>
        <trans-unit id="f0a8bb1ef2a081f480e91c8e34564927ff144af5" translate="yes" xml:space="preserve">
          <source>Can test to a finer granularity</source>
          <target state="translated">Может проверить на более тонкую гранулярность</target>
        </trans-unit>
        <trans-unit id="0c069424ea8e8618c40b30af58a3b6dd3f06183b" translate="yes" xml:space="preserve">
          <source>Creating a test with access to private members and methods can test areas of code which are difficult to target specifically with access only to public methods. If a public method has several steps involved, it can consist of several private methods, which can then be tested individually.</source>
          <target state="translated">Создание теста с доступом к приватным членам и методам может проверить области кода,которые трудно целенаправленно нацелить,имея доступ только к публичным методам.Если публичный метод состоит из нескольких этапов,он может состоять из нескольких частных методов,которые затем могут быть протестированы в индивидуальном порядке.</target>
        </trans-unit>
        <trans-unit id="c472a51872469dd7221cdb8ed81b476216096187" translate="yes" xml:space="preserve">
          <source>Disadvantages:</source>
          <target state="translated">Disadvantages:</target>
        </trans-unit>
        <trans-unit id="c9c9e5c85c1bd842957bfd2bf60f5c54670f8662" translate="yes" xml:space="preserve">
          <source>Don't test private methods.</source>
          <target state="translated">Не тестируйте частные методы.</target>
        </trans-unit>
        <trans-unit id="da1688d4291f35c06929635ff89a47756bee4936" translate="yes" xml:space="preserve">
          <source>First, I'll throw this question out: Why do your private members need isolated testing? Are they that complex, providing such complicated behaviors as to require testing apart from the public surface? It's unit testing, not 'line-of-code' testing. Don't sweat the small stuff.</source>
          <target state="translated">Сначала я выкину этот вопрос:Почему ваши личные члены нуждаются в изолированном тестировании? Неужели они настолько сложны,обеспечивая такое сложное поведение,что требуют тестирования отдельно от публичной поверхности? Это единичное тестирование,а не тестирование &quot;линии кодов&quot;.Не переживай по мелочам.</target>
        </trans-unit>
        <trans-unit id="488ba946d622fc383a6720a0de399a291c4a6365" translate="yes" xml:space="preserve">
          <source>For example, if a method to be tested is in &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; then your test call should be placed in &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt;. That way, you got access to the test method in your test class.</source>
          <target state="translated">Например, если тестируемый метод находится в &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; , то ваш тестовый вызов должен быть помещен в &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt; . Таким образом, вы получили доступ к тестовому методу в вашем тестовом классе.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="c046b725299d827b1b1cfbff5b6ff9701d5b447f" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;Testing Private Methods with JUnit and SuiteRunner&lt;/a&gt; (Bill Venners), you basically have 4 options:</source>
          <target state="translated">Из этой статьи: &lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;Тестирование частных методов с помощью JUnit и SuiteRunner&lt;/a&gt; (Билл Веннерс), у вас в основном есть 4 варианта:</target>
        </trans-unit>
        <trans-unit id="ae8c15b3105382053e62cc365916933eb7995b28" translate="yes" xml:space="preserve">
          <source>Generally a unit test is intended to exercise the public interface of a class or unit. Therefore, private methods are implementation detail that you would not expect to test explicitly.</source>
          <target state="translated">Как правило,единичный тест предназначен для выполнения публичного интерфейса класса или единицы.Поэтому модульные методы являются деталями реализации,которые вы не ожидали бы тестировать явно.</target>
        </trans-unit>
        <trans-unit id="21f944c5c0cd9b55951029e9c48346ad8ecaccfc" translate="yes" xml:space="preserve">
          <source>Give the methods package access.</source>
          <target state="translated">Дайте доступ к пакету методов.</target>
        </trans-unit>
        <trans-unit id="3ea99547c530ccc60cd2d951a1059ecc58a082c9" translate="yes" xml:space="preserve">
          <source>Having tried Cem Catikkas' &lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;solution using reflection&lt;/a&gt; for Java, I'd have to say his was a more elegant solution than I have described here. However, if you're looking for an alternative to using reflection, and have access to the source you're testing, this will still be an option.</source>
          <target state="translated">Попробовав &lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;решение&lt;/a&gt; Cem Catikkas с использованием рефлексии для Java, я бы сказал, что это было более элегантное решение, чем я описал здесь. Однако, если вы ищете альтернативу использованию отражения и имеете доступ к тестируемому источнику, это все равно будет вариант.</target>
        </trans-unit>
        <trans-unit id="738ac079cb2720eec3fc2ea83fa03d06c4e24357" translate="yes" xml:space="preserve">
          <source>Here is a convoluted example of how this would work:</source>
          <target state="translated">Вот запутанный пример того,как это будет работать:</target>
        </trans-unit>
        <trans-unit id="bad99404aed0664a20ca51067abe49d23d05a388" translate="yes" xml:space="preserve">
          <source>Here is my generic function to test private fields:</source>
          <target state="translated">Вот моя общая функция для тестирования частных полей:</target>
        </trans-unit>
        <trans-unit id="cf1020a5e41eab9e99f445355aec8da27a8d8c7f" translate="yes" xml:space="preserve">
          <source>How do I test a private function or a class that has private methods, fields or inner classes</source>
          <target state="translated">Как протестировать приватную функцию или класс,в котором есть приватные методы,поля или внутренние классы</target>
        </trans-unit>
        <trans-unit id="0de14c706b029a054d6bb30db817984dba502ac6" translate="yes" xml:space="preserve">
          <source>How do I unit test (using xUnit) a class that has internal private methods, fields or nested classes? Or a function that is made private by having &lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;internal linkage&lt;/a&gt; (&lt;code&gt;static&lt;/code&gt; in C/C++) or is in a private (&lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;anonymous&lt;/a&gt;) namespace?</source>
          <target state="translated">Как выполнить модульное тестирование (с использованием xUnit) класса, который имеет внутренние закрытые методы, поля или вложенные классы? Или функция, которая делается частной благодаря наличию &lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;внутренней связи&lt;/a&gt; ( &lt;code&gt;static&lt;/code&gt; в C / C ++) или находится в закрытом ( &lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;анонимном&lt;/a&gt; ) пространстве имен?</target>
        </trans-unit>
        <trans-unit id="bc255ea980bb0a2a256131036675cc23632ebedb" translate="yes" xml:space="preserve">
          <source>However, if continuous testing requires this method, it may be a signal that the private methods should be extracted, which could be tested in the traditional, public way.</source>
          <target state="translated">Однако,если непрерывное тестирование требует этого метода,это может быть сигналом о том,что следует извлечь частные методы,которые можно было бы протестировать традиционным,публичным способом.</target>
        </trans-unit>
        <trans-unit id="e4ab4d98c5b0b5ae62722cd5daba84f9fc5d09e2" translate="yes" xml:space="preserve">
          <source>I have used &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; to do this for Java in the past, and in my opinion it was a big mistake.</source>
          <target state="translated">В прошлом я использовал &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;рефлексию,&lt;/a&gt; чтобы сделать это для Java, и, на мой взгляд, это было большой ошибкой.</target>
        </trans-unit>
        <trans-unit id="b3f669f5a4850db8ae087533d316d74f7d18ef39" translate="yes" xml:space="preserve">
          <source>I personally believe it is better to create classes using TDD; creating the public method stubs, then generating unit tests with &lt;strong&gt;all&lt;/strong&gt; the assertions defined in advance, so the expected outcome of the method is determined before you code it. This way, you don't go down the wrong path of making the unit test assertions fit the results. Your class is then robust and meets requirements when all your unit tests pass.</source>
          <target state="translated">Я лично считаю, что лучше создавать классы с использованием TDD; создание открытых заглушек метода, а затем генерация модульных тестов со &lt;strong&gt;всеми&lt;/strong&gt; заранее определенными утверждениями, поэтому ожидаемый результат метода определяется до его кодирования. Таким образом, вы не идете по неверному пути, чтобы утверждения модульного теста соответствовали результатам. Ваш класс будет устойчивым и соответствует требованиям, когда пройдут все ваши юнит-тесты.</target>
        </trans-unit>
        <trans-unit id="e36b52cb9fdfbb3e329d1441d178206837d71b2c" translate="yes" xml:space="preserve">
          <source>I recently had this problem and wrote a little tool, called &lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;Picklock&lt;/a&gt;, that avoids the problems of explicitly using the Java reflection API, two examples:</source>
          <target state="translated">Недавно я столкнулся с этой проблемой и написал небольшой инструмент под названием &lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;Picklock&lt;/a&gt; , который позволяет избежать проблем явного использования API отражения Java, два примера:</target>
        </trans-unit>
        <trans-unit id="7d99726e2e6121e3f90a851753d372ae38b3621b" translate="yes" xml:space="preserve">
          <source>I tend not to test private methods.  There lies madness.  Personally, I believe you should only test your publicly exposed interfaces (and that includes protected and internal methods).</source>
          <target state="translated">Я склонен не тестировать частные методы.Там лежит безумие.Лично я считаю,что вы должны тестировать только публично открытые интерфейсы (и это включает в себя защищенные и внутренние методы).</target>
        </trans-unit>
        <trans-unit id="5f07dd3769ec6c1f05bf2a35c0526f8b0b85e8f1" translate="yes" xml:space="preserve">
          <source>I understand the idea of only testing the &quot;contract&quot;. But I don't see one can advocate actually not testing code - your mileage may vary.</source>
          <target state="translated">Я понимаю идею проверки только &quot;контракта&quot;.Но я не вижу,чтобы кто-то мог выступить в защиту того,чтобы не тестировать код-ваш пробег может быть разным.</target>
        </trans-unit>
        <trans-unit id="86ef42a47a405d6ea0d40445563542edd3714ab0" translate="yes" xml:space="preserve">
          <source>I use the &lt;strong&gt;junitx.util.PrivateAccessor&lt;/strong&gt;-package for Java . Lots of helpful one-liners for accessing private methods and private fields.</source>
          <target state="translated">Я использую &lt;strong&gt;пакет junitx.util.PrivateAccessor&lt;/strong&gt; для Java. Много полезных однострочников для доступа к приватным методам и приватным полям.</target>
        </trans-unit>
        <trans-unit id="42bb9d6ad7029d11852bf236c965500fd6aeb10a" translate="yes" xml:space="preserve">
          <source>I would suggest you refactoring your code a little bit. When you have to start thinking about using reflection or other kind of stuff, for just testing your code, something is going wrong with your code.</source>
          <target state="translated">Я бы посоветовал тебе немного рефакторить свой код.Когда приходится начинать думать об использовании рефлексии или чего-то еще,для простого тестирования кода,что-то не так с вашим кодом.</target>
        </trans-unit>
        <trans-unit id="e5c18c5a0c0257d22e6651f930fb4b67ab6d6430" translate="yes" xml:space="preserve">
          <source>I'd have used this:</source>
          <target state="translated">Я бы использовал это:</target>
        </trans-unit>
        <trans-unit id="856f0a021ec6929f0585d3353794587bc738b479" translate="yes" xml:space="preserve">
          <source>If all the above does not suits your requirement, use &lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;the  reflection way&lt;/strong&gt;&lt;/a&gt; to access the private method.</source>
          <target state="translated">Если все вышеперечисленное не соответствует вашим требованиям, используйте &lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;способ отражения&lt;/strong&gt;&lt;/a&gt; для доступа к приватному методу.</target>
        </trans-unit>
        <trans-unit id="2908c85ab8d5229462900d545e121dbae5bc5f33" translate="yes" xml:space="preserve">
          <source>If refactoring is inappropriate or infeasible, can you use the strategy pattern to replace access to these private member functions / member classes when under unit test? Under unit test, the strategy would provide added validation, but in release builds it would be simple passthrough.</source>
          <target state="translated">Если рефакторинг неуместен или невозможен,можете ли вы использовать шаблон стратегии для замены доступа к этим закрытым классам членов функций-членов при юнит-тестировании? Под единичным тестированием,стратегия будет обеспечивать добавленную проверку,но в релизе строит это будет простой проход.</target>
        </trans-unit>
        <trans-unit id="b50c21d867d9f45732d608b976f552d6b804fae5" translate="yes" xml:space="preserve">
          <source>If the class's design is still flexible, and you've got a complicated private method that you'd like to test separately, I suggest you pull it out into a separate class and test that class separately. This doesn't have to change the public interface of the original class; it can internally create an instance of the helper class and call the helper method.</source>
          <target state="translated">Если дизайн класса все еще гибкий,и у вас есть сложный частный метод,который вы хотели бы протестировать отдельно,я предлагаю вам вытащить его в отдельный класс и протестировать этот класс отдельно.При этом не нужно менять публичный интерфейс исходного класса,он может внутренне создать экземпляр вспомогательного класса и вызвать вспомогательный метод.</target>
        </trans-unit>
        <trans-unit id="f91aaf05eb0d0047f2110ff5981712e3f94e2098" translate="yes" xml:space="preserve">
          <source>If they are that big, big enough that these private members are each a 'unit' large in complexity -- consider refactoring such private members out of this class.</source>
          <target state="translated">Если они настолько велики,что каждый из этих частных членов является &quot;единицей&quot; большой сложности-подумайте о рефакторинге таких частных членов из этого класса.</target>
        </trans-unit>
        <trans-unit id="afa066ad607390e7196812b766cdf27e86c8c154" translate="yes" xml:space="preserve">
          <source>If using Spring, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;ReflectionTestUtils&lt;/a&gt; provides some handy tools that help out here with minimal effort. For example, to set up a mock on a private member without being forced to add an undesirable public setter:</source>
          <target state="translated">При использовании Spring &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;ReflectionTestUtils&lt;/a&gt; предоставляет несколько удобных инструментов, которые помогут здесь с минимальными усилиями. Например, чтобы установить макет на приватном члене без необходимости добавлять нежелательный публичный установщик:</target>
        </trans-unit>
        <trans-unit id="83193c16ef655f324fc282cd1969a12136199cf8" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.3 or higher, you can use reflection to subvert
  the access control mechanism with the aid of the &lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;PrivilegedAccessor&lt;/a&gt;.
  For details on how to use it, read &lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">Если вы используете JDK 1.3 или выше, вы можете использовать отражение, чтобы подорвать механизм контроля доступа с помощью &lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;PrivilegedAccessor&lt;/a&gt; . Подробнее о том, как его использовать, читайте в &lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;этой статье&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82c0d1bf8945f5975a8f462f666b9a4e0e5e127d" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.6 or higher and you annotate your tests with
  @Test, you can use &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; to inject reflection in your test methods. For
  details on how to use it, see &lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;this test script&lt;/a&gt;.</source>
          <target state="translated">Если вы используете JDK 1.6 или выше и аннотируете свои тесты с помощью @Test, вы можете использовать &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; для добавления отражения в ваши методы тестирования. Подробнее о том, как его использовать, смотрите в &lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;этом тестовом скрипте&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b31f8facdbfd1bfa9d19d56f79ad1c75fa0d34e" translate="yes" xml:space="preserve">
          <source>If you do this, it's a good idea to use a code coverage tool (like Emma) to see if your private methods are in fact being executed from your tests.</source>
          <target state="translated">Если вы это сделаете,то хорошо использовать инструмент покрытия кода (например,Emma),чтобы проверить,действительно ли ваши частные методы выполняются из ваших тестов.</target>
        </trans-unit>
        <trans-unit id="231ced4c5a18aefc12b359da49c26b919a67fbb9" translate="yes" xml:space="preserve">
          <source>If you got some code with private methods or fields or constructors, you can use &lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;BoundBox&lt;/strong&gt;&lt;/a&gt;. It does exactly what you are looking for.
Here below is an example of a test that accesses two private fields of an Android activity to test it:</source>
          <target state="translated">Если у вас есть код с закрытыми методами, полями или конструкторами, вы можете использовать &lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;BoundBox&lt;/strong&gt;&lt;/a&gt; . Это именно то, что вы ищете. Ниже приведен пример теста, который обращается к двум закрытым полям действия Android для его проверки:</target>
        </trans-unit>
        <trans-unit id="c79881c26b4f45425fd6ff0dd1d27b095fb2240a" translate="yes" xml:space="preserve">
          <source>If you have somewhat of a legacy &lt;strong&gt;Java&lt;/strong&gt; application, and you're not allowed to change the visibility of your methods, the best way to test private methods is to use &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть какое-то устаревшее &lt;strong&gt;Java-&lt;/strong&gt; приложение, и вы не можете изменять видимость ваших методов, лучший способ протестировать частные методы - это использовать &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;отражение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b48c353a1610aa6f526142112c3e4e924cf08d8d" translate="yes" xml:space="preserve">
          <source>If you want to test difficult error conditions coming from the helper method, you can go a step further. Extract an interface from the helper class, add a public getter and setter to the original class to inject the helper class (used through its interface), and then inject a mock version of the helper class into the original class to test how the original class responds to exceptions from the helper. This approach is also helpful if you want to test the original class without also testing the helper class.</source>
          <target state="translated">Если вы хотите протестировать сложные условия ошибок,вытекающие из вспомогательного метода,вы можете сделать еще один шаг вперед.Извлечь интерфейс из помощника класса,добавить общественный getter и сеттер к исходному классу,чтобы ввести помощник класса (используется через его интерфейс),а затем введите поддельные версии помощника класса в исходный класс,чтобы проверить,как исходный класс реагирует на исключения из помощника.Этот подход также полезен,если вы хотите проверить оригинальный класс без тестирования хелперов класса.</target>
        </trans-unit>
        <trans-unit id="fe75670323f07c2b037bcc439be60b5d49e84c28" translate="yes" xml:space="preserve">
          <source>If you want to test private methods of a legacy application where you can't change the code, one option for Java is &lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;jMockit&lt;/a&gt;, which will allow you to create mocks to an object even when they're private to the class.</source>
          <target state="translated">Если вы хотите протестировать приватные методы унаследованного приложения, в котором вы не можете изменить код, одним из вариантов для Java является &lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;jMockit&lt;/a&gt; , который позволит вам создавать макеты для объекта, даже когда они являются закрытыми для класса.</target>
        </trans-unit>
        <trans-unit id="72e52fa6e1a9545b518febc8820865af20b96e14" translate="yes" xml:space="preserve">
          <source>If you're trying to test existing code that you're reluctant or unable to change, reflection is a good choice.</source>
          <target state="translated">Если вы пытаетесь протестировать существующий код,который вы не хотите или не можете изменить,рефлексия является хорошим выбором.</target>
        </trans-unit>
        <trans-unit id="d792406ad753323d672f9c3416735627210a6784" translate="yes" xml:space="preserve">
          <source>If you're using JUnit, have a look at &lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;junit-addons&lt;/a&gt;. It has the ability to ignore the Java security model and access private methods and attributes.</source>
          <target state="translated">Если вы используете JUnit, взгляните на &lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;junit-addons&lt;/a&gt; . Он имеет возможность игнорировать модель безопасности Java и получать доступ к закрытым методам и атрибутам.</target>
        </trans-unit>
        <trans-unit id="d28be3040a66843e9a8b31893a7a596588eb062b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;Spring Framework&lt;/a&gt; you can test private methods using this method:</source>
          <target state="translated">В &lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;Spring Framework&lt;/a&gt; вы можете протестировать закрытые методы, используя этот метод:</target>
        </trans-unit>
        <trans-unit id="1fc74da23c19b1981c07b1448e7f5db47a487f28" translate="yes" xml:space="preserve">
          <source>Internally we're using helpers to get/set &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; variables as well as invoke &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; methods. The following patterns will let you do pretty much anything related to the private methods and fields. Of course, you can't change &lt;code&gt;private static final&lt;/code&gt; variables through reflection.</source>
          <target state="translated">Внутри мы используем помощники для получения / установки &lt;code&gt;private&lt;/code&gt; и &lt;code&gt;private static&lt;/code&gt; переменных, а также для вызова &lt;code&gt;private&lt;/code&gt; и &lt;code&gt;private static&lt;/code&gt; методов. Следующие шаблоны позволят вам делать практически все, что связано с закрытыми методами и полями. Конечно, вы не можете изменить &lt;code&gt;private static final&lt;/code&gt; переменные посредством отражения.</target>
        </trans-unit>
        <trans-unit id="9ced52e68cb80f32738bfe343adbf16629c4c90b" translate="yes" xml:space="preserve">
          <source>It is ideal for testing some legacy code. Use it carefully. ;)</source>
          <target state="translated">Он идеально подходит для тестирования некоторого унаследованного кода.Используйте его аккуратно.;)</target>
        </trans-unit>
        <trans-unit id="2fa9f5af925c4287d94f324d2dd236645502165a" translate="yes" xml:space="preserve">
          <source>It seems bad to change the access modifier for a method or function just to be able to run a test.</source>
          <target state="translated">Плохо бы менять модификатор доступа для метода или функции только для того,чтобы иметь возможность запустить тест.</target>
        </trans-unit>
        <trans-unit id="e654ed1f3d726168497b0172d3d23035e3917b98" translate="yes" xml:space="preserve">
          <source>Just two examples of where I would want to test a private method:</source>
          <target state="translated">Всего два примера,где я хотел бы протестировать частный метод:</target>
        </trans-unit>
        <trans-unit id="d4e47f0274a3c52708f822a10e289c3e99775b5d" translate="yes" xml:space="preserve">
          <source>Keep all methods small and focused (easy to test, easy to find what is wrong)</source>
          <target state="translated">Сохраняйте все методы небольшими и сфокусированными (легко тестируемыми,легко находить то,что не так).</target>
        </trans-unit>
        <trans-unit id="9adf46953726191943242b998a6a02cbbf4fca14" translate="yes" xml:space="preserve">
          <source>Mostly all that I wrote looks like it's a dependency injection pattern. In my personal experience it's really useful while testing, and I think that this kind of code is cleaner and will be easier to maintain. I'd say the same about nested classes. If a nested class contains heavy logic it would be better if you'd moved it as a package private class and have injected it into a class needing it.</source>
          <target state="translated">В основном все,что я написал,выглядит так,как будто это укол зависимости.По моему личному опыту он действительно полезен при тестировании,и я думаю,что такой код чище и его будет проще поддерживать.Я бы сказал то же самое о вложенных классах.Если вложенный класс содержит тяжелую логику,то было бы лучше,если бы вы переместили его как пакетный приватный класс и ввели его в класс,которому он нужен.</target>
        </trans-unit>
        <trans-unit id="30205722f087baf2291cb886209e83bbd9803fe4" translate="yes" xml:space="preserve">
          <source>My usual approach to addressing such issues is to tease out a new class that contains the interesting bits.  Often, this method and the fields it interacts with, and maybe another method or two can be extracted in to a new class.</source>
          <target state="translated">Мой обычный подход к решению таких проблем-выманить новый класс,содержащий интересные биты.Часто этот метод и поля,с которыми он взаимодействует,и,возможно,другой метод или два могут быть извлечены в новом классе.</target>
        </trans-unit>
        <trans-unit id="2dc80e7fd583fd5394b42b7828b62bcf68608597" translate="yes" xml:space="preserve">
          <source>Note that I'm not suggesting that people create classes without using their brain! The point here is to use the forces of unit testing to help you find good new classes.</source>
          <target state="translated">Обратите внимание,что я не предлагаю людям создавать классы,не используя свой мозг! Смысл здесь в том,чтобы использовать силы юнит-тестирования,чтобы помочь вам найти хорошие новые классы.</target>
        </trans-unit>
        <trans-unit id="2fe26b2c16fe9cee75070a2fc030c171634bc7bf" translate="yes" xml:space="preserve">
          <source>Now about private methods. In my personal experience when you have to stub a private method for testing, then that method has nothing to do in that class. A common pattern, in that case, would be to &lt;em&gt;wrap&lt;/em&gt; it within an interface, like &lt;code&gt;Callable&lt;/code&gt; and then you pass in that interface also in the constructor (with that multiple constructor trick):</source>
          <target state="translated">Теперь о частных методах. По моему личному опыту, когда вам нужно заглушить приватный метод для тестирования, тогда этот метод не имеет ничего общего с этим классом. В этом случае распространенным шаблоном будет заключаться в том, чтобы &lt;em&gt;обернуть&lt;/em&gt; его в интерфейс, такой как &lt;code&gt;Callable&lt;/code&gt; , а затем передать этот интерфейс также в конструктор (с помощью этого трюка с несколькими конструкторами):</target>
        </trans-unit>
        <trans-unit id="777cc4ad4d28cf7c02b892fe5111983c770aebf9" translate="yes" xml:space="preserve">
          <source>Now you can directly pass the object which has the private method, method name to be called, and additional parameters as below.</source>
          <target state="translated">Теперь вы можете напрямую передать объект,у которого есть приватный метод,имя метода для вызова и дополнительные параметры,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="49a4661efd1819dad49a68ff125c5dfdef8c3ea9" translate="yes" xml:space="preserve">
          <source>P.S. I'm the main contributor to &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt;, ask &lt;a href=&quot;https://stackoverflow.com/users/300248&quot;&gt;me&lt;/a&gt; if you need help. :)</source>
          <target state="translated">PS Я основной участник &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; , спросите &lt;a href=&quot;https://stackoverflow.com/users/300248&quot;&gt;меня,&lt;/a&gt; если вам нужна помощь. :)</target>
        </trans-unit>
        <trans-unit id="5f43d2331301eb02496c0c805bc3f87c3a2c7307" translate="yes" xml:space="preserve">
          <source>Please see below for an example;</source>
          <target state="translated">Пожалуйста,см.пример ниже;</target>
        </trans-unit>
        <trans-unit id="5fe8c532739285df240daf07b928efebea907d0a" translate="yes" xml:space="preserve">
          <source>PowerMockito is made for this.
Use maven dependency</source>
          <target state="translated">ПауэрМокито создан для этого.Использовать зависимость от мужчин</target>
        </trans-unit>
        <trans-unit id="497baeb3b5ee74d2b4d986eb47ed0293a6ada2a0" translate="yes" xml:space="preserve">
          <source>Private methods are consumed by public ones. Otherwise, they're dead code. That's why you test the public method, asserting the expected results of the public method and thereby, the private methods it consumes.</source>
          <target state="translated">Частные методы потребляются государственными.В противном случае,это мертвый код.Поэтому вы тестируете публичный метод,утверждая ожидаемые результаты публичного метода и,таким образом,частные методы,которые он потребляет.</target>
        </trans-unit>
        <trans-unit id="83d6d608b54d120b904dee27b0513327bd8a3adc" translate="yes" xml:space="preserve">
          <source>Run the code coverage on the unit tests. If you see that methods are not fully tested add to the tests to get the coverage up. Aim for 100% code coverage, but realize that you probably won't get it.</source>
          <target state="translated">Запустите кодовое покрытие на модульных тестах.Если вы видите,что методы не полностью протестированы,добавьте в тесты,чтобы получить покрытие.Прицельтесь на 100% покрытие кода,но поймите,что,скорее всего,не получите его.</target>
        </trans-unit>
        <trans-unit id="f33de1aa1bafbeb284338b42c053c4ecb4dbcf05" translate="yes" xml:space="preserve">
          <source>See also: &lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;Java Tip 106: Static inner classes for fun and profit&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">См. Также: &lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;Java Совет 106: статические внутренние классы для удовольствия и выгоды&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b710af9a932bb8b3407780d42ea95e9d3c2c9c68" translate="yes" xml:space="preserve">
          <source>Similarly with .class output files, they must remain within the same package as declared in source code</source>
          <target state="translated">Подобно выходным файлам .class,они должны оставаться в том же пакете,который был объявлен в исходном тексте.</target>
        </trans-unit>
        <trans-unit id="40ef678cea4286c297bccc879a9c3c11a47c9b03" translate="yes" xml:space="preserve">
          <source>So don't test private methods.</source>
          <target state="translated">Так что не тестируйте частные методы.</target>
        </trans-unit>
        <trans-unit id="204733d7cb2b813d677976ecf1b798415058621d" translate="yes" xml:space="preserve">
          <source>So my tradeoff involves complicating the JUnits with reflection, rather than compromising my security &amp;amp; SDK.</source>
          <target state="translated">Поэтому мой компромисс заключается в том, чтобы усложнить JUnits отражением, а не поставить под угрозу мою безопасность и SDK.</target>
        </trans-unit>
        <trans-unit id="1dc726b4f0600a6162d0a5fec0ac442b107c4f85" translate="yes" xml:space="preserve">
          <source>Some 10 years later perhaps the best way to test a private method, or any inaccessible member, is via &lt;strong&gt;&lt;code&gt;@Jailbreak&lt;/code&gt;&lt;/strong&gt; from the &lt;a href=&quot;https://manifold.systems&quot;&gt;Manifold&lt;/a&gt; framework.</source>
          <target state="translated">Примерно через 10 лет, возможно, лучший способ протестировать закрытый метод или любого недоступного члена - через &lt;strong&gt; &lt;code&gt;@Jailbreak&lt;/code&gt; &lt;/strong&gt; из &lt;strong&gt;среды&lt;/strong&gt; &lt;a href=&quot;https://manifold.systems&quot;&gt;Manifold&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93fcf1e45142f4bf2b769ec5b5d2448cc5a335d7" translate="yes" xml:space="preserve">
          <source>Strictly speaking, you should &lt;em&gt;not&lt;/em&gt; be writing unit tests that directly test private methods. What you &lt;em&gt;should&lt;/em&gt; be testing is the public contract that the class has with other objects; you should never directly test an object's internals. If another developer wants to make a small internal change to the class, which doesn't affect the classes public contract, he/she then has to modify your reflection based test to ensure that it works. If you do this repeatedly throughout a project, unit tests then stop being a useful measurement of code health, and start to become a hindrance to development, and an annoyance to the development team.</source>
          <target state="translated">Строго говоря, вы &lt;em&gt;не&lt;/em&gt; должны писать модульные тесты, которые напрямую тестируют частные методы. То, что вы &lt;em&gt;должны&lt;/em&gt; тестировать, это публичный контракт, который класс имеет с другими объектами; Вы никогда не должны напрямую проверять внутренности объекта. Если другой разработчик хочет внести небольшое внутреннее изменение в класс, которое не влияет на публичный контракт классов, он / она должен изменить ваш тест на основе отражения, чтобы убедиться, что он работает. Если вы будете делать это многократно в течение всего проекта, модульные тесты перестанут быть полезным измерением работоспособности кода и станут препятствием для разработки и раздражением для команды разработчиков.</target>
        </trans-unit>
        <trans-unit id="e60b23b6cc258fd2f3050f01d48f369e96d22536" translate="yes" xml:space="preserve">
          <source>Test code must reside in the same
file as source code, which can be
more difficult to maintain</source>
          <target state="translated">Тестовый код должен находиться в том же файле,что и исходный код,что может быть сложнее обслуживать</target>
        </trans-unit>
        <trans-unit id="e628bb4ef6d2f95c51a2e0fabdc7e6570882e841" translate="yes" xml:space="preserve">
          <source>Testing private methods breaks the encapsulation of your class because every time you change the internal implementation you break client code (in this case, the tests).</source>
          <target state="translated">Тестирование частных методов нарушает инкапсуляцию вашего класса,так как каждый раз при изменении внутренней реализации нарушается клиентский код (в данном случае-тесты).</target>
        </trans-unit>
        <trans-unit id="b08d94828e924f3c44bdad7d49d7a9e8126f9b82" translate="yes" xml:space="preserve">
          <source>Testing private methods should be tested by debugging before running your unit tests on public methods.</source>
          <target state="translated">Тестирование частных методов должно быть протестировано путем отладки перед запуском юнит-тестов на публичных методах.</target>
        </trans-unit>
        <trans-unit id="99ac885a2c04ce23f9e9dee57055ba4db55f0ba2" translate="yes" xml:space="preserve">
          <source>The answer from &lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;JUnit.org FAQ page&lt;/a&gt;:</source>
          <target state="translated">Ответ со &lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;страницы часто задаваемых вопросов JUnit.org&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="612f347cc8d13e68510dabfe438c3934b0e32ab6" translate="yes" xml:space="preserve">
          <source>The best way to test a private method is via another public method. If this cannot be done, then one of the following conditions is true:</source>
          <target state="translated">Лучший способ протестировать частный метод-это другой открытый метод.Если это невозможно,то одно из следующих условий верно:</target>
        </trans-unit>
        <trans-unit id="bd734d3c315faa6945e06b553d5414ada763a534" translate="yes" xml:space="preserve">
          <source>The following import statement should be added:</source>
          <target state="translated">Необходимо добавить следующую справку об импорте:</target>
        </trans-unit>
        <trans-unit id="85834fcc9380e9b0ac91e5af41b0a87baae505d9" translate="yes" xml:space="preserve">
          <source>The inner class would be compiled to &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt;.</source>
          <target state="translated">Внутренний класс будет скомпилирован в &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe9916a66d8aaef8076e5a9c5eb90320bb058a1d" translate="yes" xml:space="preserve">
          <source>The method that you are trying to test should not be private</source>
          <target state="translated">Метод,который вы пытаетесь проверить,не должен быть частным.</target>
        </trans-unit>
        <trans-unit id="9660255e33ec7d540aff4829d9d77f76b4f97dd1" translate="yes" xml:space="preserve">
          <source>The new class exposes these methods as 'public', so they're accessible for unit testing.  The new and old classes are now both simpler than the original class, which is great for me (I need to keep things simple, or I get lost!).</source>
          <target state="translated">Новый класс раскрывает эти методы как &quot;публичные&quot;,поэтому они доступны для юнит-тестирования.Новый и старый классы теперь оба проще,чем оригинальный класс,что для меня замечательно (мне нужно,чтобы все было просто,иначе я потеряюсь!).</target>
        </trans-unit>
        <trans-unit id="e7a5f083811631d013af462cec5f70ee62d8c80c" translate="yes" xml:space="preserve">
          <source>The private method is dead code</source>
          <target state="translated">Частный метод-мертвый код</target>
        </trans-unit>
        <trans-unit id="d4f0e9f95df601d6fc574b0d6b9281cadcdeb404" translate="yes" xml:space="preserve">
          <source>The private methods are called by a public method, so the inputs to your public methods should also test private methods that are called by those public methods. When a public method fails, then that could be a failure in the private method.</source>
          <target state="translated">Частные методы вызываются публичным методом,поэтому входные данные для ваших публичных методов также должны тестировать частные методы,которые вызываются этими публичными методами.Если публичный метод дает сбой,то это может быть сбой частного метода.</target>
        </trans-unit>
        <trans-unit id="e801c066ad4c06126ee0faa678e75d5b639e6837" translate="yes" xml:space="preserve">
          <source>Then you can do</source>
          <target state="translated">Тогда ты сможешь сделать</target>
        </trans-unit>
        <trans-unit id="6810d88f67449ede60291b3105c90bd696c31a2a" translate="yes" xml:space="preserve">
          <source>There are also several other design patterns which I have used while refactoring and maintaining legacy code, but it all depends on cases of your code to test. Using reflection mostly is not a problem, but when you have an enterprise application which is heavily tested and tests are run before every deployment everything gets really slow (it's just annoying and I don't like that kind of stuff).</source>
          <target state="translated">Есть также несколько других шаблонов дизайна,которые я использовал при рефакторинге и сопровождении старого кода,но все зависит от случаев,когда ваш код должен быть протестирован.Использование рефлексии в основном не является проблемой,но когда у вас есть корпоративное приложение,которое интенсивно тестируется и тесты запускаются перед каждым внедрением,все становится действительно медленным (это просто раздражает,и мне не нравятся такие вещи).</target>
        </trans-unit>
        <trans-unit id="e294098a8dfea7a5c3635278eddc4336d7bbca52" translate="yes" xml:space="preserve">
          <source>There is a design smell near the class that you are testing</source>
          <target state="translated">Рядом с классом есть запах дизайна,который вы тестируете.</target>
        </trans-unit>
        <trans-unit id="1961b3194f3eceb534220dec7cfd0658a13c79d1" translate="yes" xml:space="preserve">
          <source>There is also setter injection, but I wouldn't recommended using it. I'd better stick with a constructor and initialize everything when it's really necessary, leaving the possibility for injecting necessary dependencies.</source>
          <target state="translated">Есть также инъекция сеттера,но я бы не рекомендовал его использовать.Лучше придерживаться конструктора и инициализировать все,когда это действительно необходимо,оставляя возможность введения необходимых зависимостей.</target>
        </trans-unit>
        <trans-unit id="a0630fa58840584312f8324a97af6d5961e771b5" translate="yes" xml:space="preserve">
          <source>There is possible merit in testing private methods of a class, particularly with &lt;a href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;, where you would like to design small tests before you write any code.</source>
          <target state="translated">Возможно, есть преимущество в тестировании частных методов класса, особенно в &lt;a href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;разработке&lt;/a&gt; , управляемой тестами , где вы хотели бы создавать небольшие тесты, прежде чем писать какой-либо код.</target>
        </trans-unit>
        <trans-unit id="086b75748a5099b73be65ec37188606e7a210e65" translate="yes" xml:space="preserve">
          <source>They may also be debugged using test-driven development, debugging your unit tests until all your assertions are met.</source>
          <target state="translated">Они также могут быть отлажены с помощью тестовых разработок,отлаживая юнит-тесты до тех пор,пока все ваши утверждения не будут выполнены.</target>
        </trans-unit>
        <trans-unit id="0d7e7626c0f234d5a4b1eefebb7e04bb6f95324f" translate="yes" xml:space="preserve">
          <source>This way your code remains type-safe and readable.  No design compromises, no overexposing methods and fields for the sake of tests.</source>
          <target state="translated">Таким образом,ваш код остается безопасным для печати и читаемым.Никаких компромиссов при проектировании,никаких переэкспонированных методов и полей ради испытаний.</target>
        </trans-unit>
        <trans-unit id="311f5e6a4e3dcb5323e8e594812c473e08551089" translate="yes" xml:space="preserve">
          <source>This will tell anybody using this method to take caution and not access it directly even in a package. Also a test class need not be in same package &lt;strong&gt;physically&lt;/strong&gt;, but in the same package under the &lt;strong&gt;test&lt;/strong&gt; folder.</source>
          <target state="translated">Это скажет любому, кто использует этот метод, быть осторожным и не иметь к нему прямого доступа даже в пакете. Кроме того, тестовый класс не обязательно должен находиться в том же пакете &lt;strong&gt;физически&lt;/strong&gt; , но в том же пакете в папке &lt;strong&gt;тестов&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b8bb20e26f0bfdeceed068608989a507c169de4d" translate="yes" xml:space="preserve">
          <source>This won't be a problem even with some legacy code. Old code will be using an empty constructor, and if you ask me, refactored code will look cleaner, and you'll be able to inject necessary values in test without reflection.</source>
          <target state="translated">Это не будет проблемой даже с каким-нибудь старым кодом.Старый код будет использовать пустой конструктор,и если вы спросите меня,рефакторинговый код будет выглядеть чище,и вы сможете вводить необходимые значения в тесте без отражения.</target>
        </trans-unit>
        <trans-unit id="f55b0f7d6249aa7de09959544b0f0feda938a90d" translate="yes" xml:space="preserve">
          <source>To test legacy code with large and quirky classes, it is often very helpful to be able to test the one private (or public) method I'm writing &lt;em&gt;right now&lt;/em&gt;.</source>
          <target state="translated">Для тестирования унаследованного кода с большими и причудливыми классами часто очень полезно иметь возможность протестировать один приватный (или публичный) метод, который я пишу &lt;em&gt;прямо сейчас&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2dd43ad23f4bf7d3a51fa427ec672d9bd6a01af6" translate="yes" xml:space="preserve">
          <source>Today, I pushed a Java library to help testing private methods and fields. It has been designed with Android in mind, but it can really be used for any Java project.</source>
          <target state="translated">Сегодня я подтолкнул библиотеку Java,чтобы помочь в тестировании частных методов и полей.Она была спроектирована с учетом Android,но на самом деле может быть использована для любого Java проекта.</target>
        </trans-unit>
        <trans-unit id="34159cd5d97b03db44c72acff5f46f6a24c21c8c" translate="yes" xml:space="preserve">
          <source>Use a nested test class.</source>
          <target state="translated">Используйте вложенный класс испытаний.</target>
        </trans-unit>
        <trans-unit id="f1e1383d50d27720fe116324eabd453138603022" translate="yes" xml:space="preserve">
          <source>Use code coverage tools. I like &lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;Cobertura&lt;/a&gt; (oh happy day, looks like a new version is out!)</source>
          <target state="translated">Используйте инструменты покрытия кода. Мне нравится &lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;Cobertura&lt;/a&gt; (о, счастливый день, похоже, вышла новая версия!)</target>
        </trans-unit>
        <trans-unit id="fa15115704d2ddf22825eb507327d9d92e328b27" translate="yes" xml:space="preserve">
          <source>Use reflection.</source>
          <target state="translated">Используй отражение.</target>
        </trans-unit>
        <trans-unit id="0736ff73d779714c30c887cd895cba51ef05c5d2" translate="yes" xml:space="preserve">
          <source>What I recommend doing instead is using a code coverage tool such as Cobertura, to ensure that the unit tests you write provide decent coverage of the code in private methods. That way, you indirectly test what the private methods are doing, and maintain a higher level of agility.</source>
          <target state="translated">Вместо этого я рекомендую использовать инструмент покрытия кода,такой как Cobertura,чтобы гарантировать,что юнит-тесты,которые вы пишете,обеспечивают достойное покрытие кода частными методами.Таким образом,вы косвенно тестируете,что делают частные методы,и поддерживаете более высокий уровень маневренности.</target>
        </trans-unit>
        <trans-unit id="ee409982c9dae5ad88c914fa57f08415903fa09c" translate="yes" xml:space="preserve">
          <source>When I have private methods in a class that are sufficiently complicated that I feel the need to test the private methods directly, that is a code smell: my class is too complicated.</source>
          <target state="translated">Когда у меня в классе есть приватные методы,которые достаточно сложны,и я чувствую необходимость напрямую тестировать приватные методы,то есть запах кода:мой класс слишком сложный.</target>
        </trans-unit>
        <trans-unit id="263c36a6dc28d5740e02d9585bf8aa9bcba9f12d" translate="yes" xml:space="preserve">
          <source>You mentioned different types of problems. Let's start with private fields. In case of private fields I would have added a new constructor and injected fields into that. Instead of this:</source>
          <target state="translated">Вы упомянули разные типы проблем.Давайте начнем с частных полей.В случае приватных полей я бы добавил новый конструктор и вставил в него поля.Вместо этого:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
