<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/29482">
    <body>
      <group id="29482">
        <trans-unit id="a6b4c34af36c3a26b9050e38700b2fae77e146b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Usage:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Usage:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81a72c38deebcc445e6e0b866809a7c979479e5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FYI:&lt;/strong&gt;  The question was about integers, which nobody mentioned will also explicitly convert in Enum.TryParse()</source>
          <target state="translated">&lt;strong&gt;참고 사항 :&lt;/strong&gt; 정수에 관한 문제는 언급 한 사람이 Enum.TryParse ()에서 명시 적으로 변환하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eed27dac7346464d428cbb3ad292a3ac60f63205" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How stuff works&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;작동 원리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e973dcf220dd2052dbaad0156f4e3d9d0f1782da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N.B:&lt;/strong&gt; Here I try to parse value into int, because enum is by default &lt;strong&gt;int&lt;/strong&gt;
If you define enum like this which is &lt;strong&gt;byte&lt;/strong&gt; type.</source>
          <target state="translated">&lt;strong&gt;NB :&lt;/strong&gt; 여기에서는 enum이 기본적으로 &lt;strong&gt;int&lt;/strong&gt; 이기 때문에 값을 int로 구문 분석하려고합니다. &lt;strong&gt;바이트&lt;/strong&gt; 유형 인 enum을 이와 같이 정의하면.</target>
        </trans-unit>
        <trans-unit id="3379b289640323b42df642694c64588c9345c6d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;대답&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e2cee577f891dfa999a3a3c8e44916d9a7d5301" translate="yes" xml:space="preserve">
          <source>Also note that I'm explicit about the underlying type of the enum, even though the compiler actually checks this. I'm doing this to ensure I don't run into any surprises down the road. To see these surprises in action, you can use the following code (actually I've seen this happen a lot in database code):</source>
          <target state="translated">또한 컴파일러가 실제로 이것을 확인하더라도 기본 유형의 열거 형에 대해 명시 적입니다. 나는 길을 놀라게하지 않도록하기 위해 이것을하고 있습니다. 이러한 놀라움을 실제로보기 위해 다음 코드를 사용할 수 있습니다 (실제로 데이터베이스 코드에서 이런 일이 많이 발생하는 것을 보았습니다).</target>
        </trans-unit>
        <trans-unit id="af726d70297878295862d1b77096a1ca802e71c5" translate="yes" xml:space="preserve">
          <source>Alternatively, use an extension method instead of a one-liner:</source>
          <target state="translated">또는 한 줄짜리 대신 확장 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="30118d3b1c1343d010562aeede775b3215539795" translate="yes" xml:space="preserve">
          <source>An enum in .NET is a structure that maps a set of values (fields) to a basic type (the default is &lt;code&gt;int&lt;/code&gt;). However, you can actually choose the integral type that your enum maps to:</source>
          <target state="translated">.NET의 열거 형은 일련의 값 (필드)을 기본 유형 (기본값은 &lt;code&gt;int&lt;/code&gt; )으로 매핑하는 구조입니다. 그러나 실제로 열거 형에 매핑되는 정수 유형을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b916f7a25f55c5eb6520db15c0b76814186e35ef" translate="yes" xml:space="preserve">
          <source>At this point I'd like to point out that &lt;code&gt;System.Enum&lt;/code&gt; is a value type, which basically means that &lt;code&gt;BarFlag&lt;/code&gt; will take up 4 bytes in memory and &lt;code&gt;Foo&lt;/code&gt; will take up 2 -- e.g. the size of the underlying type (it's actually more complicated than that, but hey...).</source>
          <target state="translated">이 시점에서 &lt;code&gt;System.Enum&lt;/code&gt; 은 값 유형이며 기본적으로 &lt;code&gt;BarFlag&lt;/code&gt; 는 메모리에서 4 바이트를 차지하고 &lt;code&gt;Foo&lt;/code&gt; 는 2를 차지합니다 (예 : 기본 유형의 크기). 그것보다 복잡하지만 이봐 ...).</target>
        </trans-unit>
        <trans-unit id="c0413c5f086e8cdb2bfd487f989b2746f23f64a8" translate="yes" xml:space="preserve">
          <source>Below is a nice utility class for Enums</source>
          <target state="translated">아래는 Enums에 대한 유용한 유틸리티 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c7a47f219b33d30b71c37b2d6cedfd8e57764dcc" translate="yes" xml:space="preserve">
          <source>Different ways to cast &lt;strong&gt;to and from&lt;/strong&gt;&lt;code&gt;Enum&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; &lt;strong&gt;과주고받는&lt;/strong&gt; 다양한 방법</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7779fd1817467dd8f6953f720534704f90c6ddd5" translate="yes" xml:space="preserve">
          <source>Following is slightly better extension method</source>
          <target state="translated">다음은 약간 더 나은 확장 방법입니다</target>
        </trans-unit>
        <trans-unit id="5ae38008949e7b592153d6dcf436b9d69ba3e6df" translate="yes" xml:space="preserve">
          <source>For numeric values, this is safer as it will return an object no matter what:</source>
          <target state="translated">숫자 값의 경우 다음에 관계없이 객체를 반환하므로 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="c2ef2caf9f686790ead807567c0c38452b3e7637" translate="yes" xml:space="preserve">
          <source>From a string:</source>
          <target state="translated">문자열에서 :</target>
        </trans-unit>
        <trans-unit id="cbcb27e94932b1692382c6be1ee06baefc40110b" translate="yes" xml:space="preserve">
          <source>From a string: (Enum.Parse is out of Date, use Enum.TryParse)</source>
          <target state="translated">문자열에서 : (Enum.Parse가 오래되었습니다. Enum.TryParse를 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="12b5562011271b407c2a07a49b4ce89ba1ce76cf" translate="yes" xml:space="preserve">
          <source>From an int:</source>
          <target state="translated">정수에서 :</target>
        </trans-unit>
        <trans-unit id="d6e762db23f1b10e1af14cabc983c5d6512a41ef" translate="yes" xml:space="preserve">
          <source>From number you can also</source>
          <target state="translated">번호에서 당신은 또한 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f137a65c013374c3b55924d030a077022c736fe7" translate="yes" xml:space="preserve">
          <source>Here's an extension method that casts &lt;code&gt;Int32&lt;/code&gt; to &lt;code&gt;Enum&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;Int32&lt;/code&gt; 를 &lt;code&gt;Enum&lt;/code&gt; 으로 캐스팅하는 확장 방법입니다.</target>
        </trans-unit>
        <trans-unit id="47794330eb800548debab157559b2fc0f4e83f59" translate="yes" xml:space="preserve">
          <source>Here's my WCF Class.</source>
          <target state="translated">여기 내 WCF 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9deb0ddaed7c3d92f5ab73d23b1e00a58d3f529f" translate="yes" xml:space="preserve">
          <source>Here's the Extension method that gets the Description from the Enum.</source>
          <target state="translated">다음은 Enum에서 Description을 가져 오는 Extension 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6e2185fd5ad4957e164bfc5cd8182ea7426ad0d" translate="yes" xml:space="preserve">
          <source>How can an &lt;code&gt;int&lt;/code&gt; be cast to an &lt;code&gt;enum&lt;/code&gt; in C#?</source>
          <target state="translated">C #에서 &lt;code&gt;int&lt;/code&gt; 를 &lt;code&gt;enum&lt;/code&gt; 으로 캐스팅 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="9ad1aa9a3f6e0c785db5f620ebedd2435fc941f5" translate="yes" xml:space="preserve">
          <source>How to cast int to enum</source>
          <target state="translated">int를 enum에 캐스팅하는 방법</target>
        </trans-unit>
        <trans-unit id="1d8e36314d06b04e852b52096b3001ab6ef713bd" translate="yes" xml:space="preserve">
          <source>I am using this piece of code to cast int to my enum:</source>
          <target state="translated">이 코드를 사용하여 int에 int를 캐스팅하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e24428ad78c068750f7ef484b43a7e9a4fe1cfa6" translate="yes" xml:space="preserve">
          <source>I check my method for following inputs</source>
          <target state="translated">입력을 따르는 방법을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ef81821754c4e47ec08734c09c477e8ac9757fe6" translate="yes" xml:space="preserve">
          <source>I don't know anymore where I get the part of this enum extension, but it is from stackoverflow. I am sorry for this! But I took this one and modified it for enums with Flags. 
For enums with Flags I did this:</source>
          <target state="translated">이 열거 형 확장의 일부를 어디에서 얻는 지 더 이상 알지 못하지만 stackoverflow에서 온 것입니다. 죄송합니다! 그러나 나는 이것을 가지고 플래그로 열거 형을 위해 그것을 수정했다. 플래그가있는 열거 형의 경우 다음과 같이했습니다.</target>
        </trans-unit>
        <trans-unit id="457bca1c0a85aef6bdce1d0f33ebb2509ed1ceb5" translate="yes" xml:space="preserve">
          <source>I find it the best solution.</source>
          <target state="translated">최선의 해결책이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="c1abcbaa6defe875aae077f24bbffd1ba2a91b12" translate="yes" xml:space="preserve">
          <source>I think to get a complete answer, people have to know how enums work internally in .NET.</source>
          <target state="translated">완전한 대답을 얻으려면 사람들이 열거 형이 .NET에서 내부적으로 어떻게 작동하는지 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="74b835001d4e6bc62e1f790cf0d31fbc11c56484" translate="yes" xml:space="preserve">
          <source>If that's not what you intended, use &lt;code&gt;Enum.IsDefined(typeof(MyEnum), 6)&lt;/code&gt; to check if the value you are casting maps to a defined enum.</source>
          <target state="translated">의도하지 않은 경우 &lt;code&gt;Enum.IsDefined(typeof(MyEnum), 6)&lt;/code&gt; 을 사용하여 캐스팅하는 값이 정의 된 열거 형에 매핑되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bf4ab29a7d928709689495b0cf054a253bc70f58" translate="yes" xml:space="preserve">
          <source>If you have an integer that acts as a bitmask and could represent one or more values in a [Flags] enumeration, you can use this code to parse the individual flag values into a list:</source>
          <target state="translated">비트 마스크 역할을하고 [Flags] 열거에서 하나 이상의 값을 나타낼 수있는 정수가있는 경우이 코드를 사용하여 개별 플래그 값을 목록으로 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c77c5c6c4624bf56bf3ab881363e00f95d0138bf" translate="yes" xml:space="preserve">
          <source>If you look at it from a IL point of view, a (normal, int) enum looks like this:</source>
          <target state="translated">IL 관점에서 보면 (normal, int) 열거 형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25c3f82e417c33466d85a7e97298a6e16ee7b4fb" translate="yes" xml:space="preserve">
          <source>If you're ready for the 4.0 &lt;a href=&quot;http://en.wikipedia.org/wiki/.NET_Framework&quot;&gt;.NET&lt;/a&gt; Framework, there's a new &lt;em&gt;Enum.TryParse()&lt;/em&gt; function that's very useful and plays well with the [Flags] attribute. See &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd783499.aspx&quot;&gt;Enum.TryParse Method (String, TEnum%)&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">4.0 &lt;a href=&quot;http://en.wikipedia.org/wiki/.NET_Framework&quot;&gt;.NET&lt;/a&gt; Framework를 사용할 준비가되면 매우 유용하고 [Flags] 특성과 잘 작동하는 새로운 &lt;em&gt;Enum.TryParse ()&lt;/em&gt; 함수가 있습니다. &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd783499.aspx&quot;&gt;Enum.TryParse 메서드 (String, TEnum %)를&lt;/a&gt;&lt;/em&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d71bedbf598c6cb2ef567aed0bcbc08631a830d" translate="yes" xml:space="preserve">
          <source>Implementation:</source>
          <target state="translated">Implementation:</target>
        </trans-unit>
        <trans-unit id="36b8f0807dd5d7178d8b25b6cb15fd0a7aa1cc47" translate="yes" xml:space="preserve">
          <source>In my case, I needed to return the enum from a WCF service.  I also needed a friendly name, not just the enum.ToString().</source>
          <target state="translated">필자의 경우 WCF 서비스에서 열거 형을 반환해야했습니다. enum.ToString ()뿐만 아니라 친숙한 이름도 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="d62b78a00e6ea80925fcd64e5da7c05277653560" translate="yes" xml:space="preserve">
          <source>In this case the enum is mapped to the &lt;code&gt;short&lt;/code&gt; data type, which means it will be stored in memory as a short and will behave as a short when you cast and use it.</source>
          <target state="translated">이 경우 열거 형은 &lt;code&gt;short&lt;/code&gt; 데이터 형식에 매핑됩니다. 즉 , 열거 형은 메모리에 짧게 저장되며 캐스팅 및 사용시 짧게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="d2802b271f3bb077fa0c3629ce77db289d06e1a8" translate="yes" xml:space="preserve">
          <source>It can help you to convert any input data to user desired &lt;strong&gt;enum&lt;/strong&gt;. Suppose you have an enum like below which by default &lt;strong&gt;int&lt;/strong&gt;. Please add a &lt;strong&gt;Default&lt;/strong&gt; value at first of your enum. Which is used at helpers medthod when there is no match found with input value.</source>
          <target state="translated">입력 데이터를 사용자가 원하는 &lt;strong&gt;enum&lt;/strong&gt; 으로 변환하는 데 도움이됩니다. 기본적으로 &lt;strong&gt;int&lt;/strong&gt; 와 같은 열거 형이 있다고 가정하십시오. 열거 형의 처음에 &lt;strong&gt;기본값을&lt;/strong&gt; 추가하십시오. 입력 값과 일치하는 항목이 없을 때 헬퍼 방법에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="33937f92c8a23f78b931b80e06bc320e4b039228" translate="yes" xml:space="preserve">
          <source>It honors bitwise flags even when the value is higher than the maximum possible. For example if you have an enum with possibilities &lt;em&gt;1&lt;/em&gt;, &lt;em&gt;2&lt;/em&gt;, and &lt;em&gt;4&lt;/em&gt;, but the int is &lt;em&gt;9&lt;/em&gt;, it understands that as &lt;em&gt;1&lt;/em&gt; in absence of an &lt;em&gt;8&lt;/em&gt;. This lets you make data updates ahead of code updates.</source>
          <target state="translated">값이 최대 값보다 높은 경우에도 비트 단위 플래그를 사용합니다. 예를 들어 가능성이 &lt;em&gt;1&lt;/em&gt; , &lt;em&gt;2&lt;/em&gt; 및 &lt;em&gt;4&lt;/em&gt; 인 열거 형이 있지만 int가 &lt;em&gt;9&lt;/em&gt; 인 경우 &lt;em&gt;8이&lt;/em&gt; 없으면 &lt;em&gt;1&lt;/em&gt; 로 이해합니다. 이를 통해 코드 업데이트보다 먼저 데이터를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="669c26b60d45316558ef147c15c0c09988d60fc8" translate="yes" xml:space="preserve">
          <source>Just cast it:</source>
          <target state="translated">그냥 캐스트 :</target>
        </trans-unit>
        <trans-unit id="2c773194ea026cc993e378f1446632013f32a420" translate="yes" xml:space="preserve">
          <source>Note that casting to &lt;code&gt;e2&lt;/code&gt; also works! From the compiler perspective above this makes sense: the &lt;code&gt;value__&lt;/code&gt; field is simply filled with either 5 or 6 and when &lt;code&gt;Console.WriteLine&lt;/code&gt; calls &lt;code&gt;ToString()&lt;/code&gt;, the name of &lt;code&gt;e1&lt;/code&gt; is resolved while the name of &lt;code&gt;e2&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;e2&lt;/code&gt; 로 전송하는 것도 가능합니다! 위의 컴파일러 관점에서 이것은 의미가 있습니다. &lt;code&gt;value__&lt;/code&gt; 필드는 단순히 5 또는 6으로 채워지고 &lt;code&gt;Console.WriteLine&lt;/code&gt; 이 &lt;code&gt;ToString()&lt;/code&gt; 호출하면 &lt;code&gt;e1&lt;/code&gt; 의 이름은 확인되지만 &lt;code&gt;e2&lt;/code&gt; 의 이름은 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="569ada5fc09d3eeddae46ad081c41b68fabf7331" translate="yes" xml:space="preserve">
          <source>Note that this assumes that the underlying type of the &lt;code&gt;enum&lt;/code&gt; is a signed 32-bit integer. If it were a different numerical type, you'd have to change the hardcoded 32 to reflect the bits in that type (or programatically derive it using &lt;code&gt;Enum.GetUnderlyingType()&lt;/code&gt;)</source>
          <target state="translated">이것은 &lt;code&gt;enum&lt;/code&gt; 형의 기본 유형이 부호있는 32 비트 정수라고 가정합니다. 다른 숫자 유형 인 경우 해당 유형의 비트를 반영하도록 하드 코딩 된 32를 변경해야합니다 (또는 프로그래밍 방식으로 &lt;code&gt;Enum.GetUnderlyingType()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b3179c75c3fd8315efa725c8e57bb612845936a4" translate="yes" xml:space="preserve">
          <source>Note that using IsDefined is costly and even more than just casting, so it depends on your implementation to decide to use it or not.</source>
          <target state="translated">IsDefined를 사용하는 것은 캐스팅하는 것보다 비용이 많이 들고 훨씬 더 많은 비용이 소요되므로 사용 여부를 결정하는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="cb46ab1740f0e8d608e38f895692a452d2b8b436" translate="yes" xml:space="preserve">
          <source>Obviously, some of the enum type functionality will be lost, but for storing a bunch of database id constants, it seems like a pretty tidy solution.</source>
          <target state="translated">분명히 열거 형 유형 기능 중 일부가 손실되지만 많은 데이터베이스 ID 상수를 저장하는 경우 꽤 깔끔한 솔루션처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="2787dadf2ebcf4ca566176af819017f9f6a66212" translate="yes" xml:space="preserve">
          <source>Slightly getting away from the original question, but I found &lt;a href=&quot;https://stackoverflow.com/a/11057004/429973&quot;&gt;an answer to Stack&amp;nbsp;Overflow question &lt;em&gt;Get int value from enum&lt;/em&gt;&lt;/a&gt; useful. Create a static class with &lt;code&gt;public const int&lt;/code&gt; properties, allowing you to easily collect together a bunch of related &lt;code&gt;int&lt;/code&gt; constants, and then not have to cast them to &lt;code&gt;int&lt;/code&gt; when using them.</source>
          <target state="translated">원래 질문에서 약간 벗어 났지만 &lt;a href=&quot;https://stackoverflow.com/a/11057004/429973&quot;&gt;스택 오버플로 질문에 대한 답변을&lt;/a&gt; 찾았 습니다 . &lt;code&gt;public const int&lt;/code&gt; 속성을 사용하여 정적 클래스를 생성하면 관련된 &lt;code&gt;int&lt;/code&gt; 상수를 쉽게 모을 수 있으며 사용할 때 &lt;code&gt;int&lt;/code&gt; 로 캐스팅 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="41341fed4fc5135c7817e04c2934f4db99145db9" translate="yes" xml:space="preserve">
          <source>So, if you have an integer that you want to map to an enum, the runtime only has to do 2 things: copy the 4 bytes and name it something else (the name of the enum). Copying is implicit because the data is stored as value type - this basically means that if you use unmanaged code, you can simply interchange enums and integers without copying data.</source>
          <target state="translated">따라서 열거 형에 매핑하려는 정수가있는 경우 런타임은 두 가지 작업 만 수행하면됩니다 .4 바이트를 복사하고 다른 이름 (열거 이름)을 지정하십시오. 데이터는 값 유형으로 저장되므로 복사는 암시 적입니다. 이는 기본적으로 관리되지 않는 코드를 사용하면 데이터를 복사하지 않고 열거 형과 정수를 간단히 교환 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="545ab5091363b3b680b64a4657255d140cb67922" translate="yes" xml:space="preserve">
          <source>Sometimes you have an object to the &lt;code&gt;MyEnum&lt;/code&gt; type. Like</source>
          <target state="translated">때로는 &lt;code&gt;MyEnum&lt;/code&gt; 유형의 객체가 있습니다. 처럼</target>
        </trans-unit>
        <trans-unit id="4e5c1cb438afe66a7a3ce7f0162632afd0f40816" translate="yes" xml:space="preserve">
          <source>Take the following example:</source>
          <target state="translated">다음 예를 보자.</target>
        </trans-unit>
        <trans-unit id="2d77855a284dd03f6fdaf1a7d511a263b8079230" translate="yes" xml:space="preserve">
          <source>Test Case</source>
          <target state="translated">테스트 사례</target>
        </trans-unit>
        <trans-unit id="4be24070f4f24438345c01c626b6fdfd6542d435" translate="yes" xml:space="preserve">
          <source>The code goes as shown below where &quot;red&quot; is the string and &quot;MyColors&quot; is the color ENUM which has the color constants.</source>
          <target state="translated">&quot;red&quot;는 문자열이고 &quot;MyColors&quot;는 색상 상수가있는 색상 ENUM입니다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="e1ceff90c2d44b022434871989ecfc3d783a6af6" translate="yes" xml:space="preserve">
          <source>This is an flags enumeration aware safe convert method:</source>
          <target state="translated">다음은 플래그 열거 형 안전 변환 방법입니다.</target>
        </trans-unit>
        <trans-unit id="2f886dad395648b4e15cc32acf1f9703992e4e5b" translate="yes" xml:space="preserve">
          <source>This parses integers or strings to a target enum with partial matching in dot.NET 4.0 using generics like in Tawani's utility class above.  I am using it to convert command-line switch variables which may be incomplete.  Since an enum cannot be null, you should logically provide a default value.  It can be called like this:</source>
          <target state="translated">위의 Tawani 유틸리티 클래스와 같은 제네릭을 사용하여 dot.NET 4.0에서 부분 일치하는 정수 또는 문자열을 대상 열거 형으로 구문 분석합니다. 불완전 할 수있는 명령 줄 스위치 변수를 변환하는 데 사용하고 있습니다. 열거 형은 null 일 수 없으므로 논리적으로 기본값을 제공해야합니다. 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e19c993984f6dd6f758fe2a09db7defa6fe45d59" translate="yes" xml:space="preserve">
          <source>To convert a string to ENUM or int to ENUM constant we need to use Enum.Parse function. Here is a youtube video &lt;a href=&quot;https://www.youtube.com/watch?v=4nhx4VwdRDk&quot;&gt;https://www.youtube.com/watch?v=4nhx4VwdRDk&lt;/a&gt;  which actually demonstrate's with string and the same applies for int.</source>
          <target state="translated">문자열을 ENUM 또는 int를 ENUM 상수로 변환하려면 Enum.Parse 함수를 사용해야합니다. 다음은 실제로 문자열이 있고 int에 적용되는 YouTube 비디오 &lt;a href=&quot;https://www.youtube.com/watch?v=4nhx4VwdRDk&quot;&gt;https://www.youtube.com/watch?v=4nhx4VwdRDk&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a68345d4247855f0ef61c33db7f1d7fc5da8f76c" translate="yes" xml:space="preserve">
          <source>To make it safe, I think it's a best practice to &lt;strong&gt;know that the underlying types are the same or implicitly convertible&lt;/strong&gt; and to ensure the enum values exist (they aren't checked by default!).</source>
          <target state="translated">안전을 기하기 위해 &lt;strong&gt;기본 유형이 동일하거나 암시 적으로 변환 가능하다는&lt;/strong&gt; 것을 &lt;strong&gt;알고&lt;/strong&gt; 열거 형 값이 존재하는지 확인하는 것이 가장 좋습니다 (기본적으로 확인되지 않음).</target>
        </trans-unit>
        <trans-unit id="23a5d50f7d560683b09aeb6eb136065dad2c6c30" translate="yes" xml:space="preserve">
          <source>To make sure that you only cast the right values ​​and that you can throw an exception otherwise:</source>
          <target state="translated">올바른 값만 캐스트하고 그렇지 않으면 예외를 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47face85db7011031f48f02a22cd9a272203d89f" translate="yes" xml:space="preserve">
          <source>To see how this works, try the following code:</source>
          <target state="translated">이것이 어떻게 작동하는지 보려면 다음 코드를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="fe32a38f013c13127d95cbb21b75c9f2a3ff7ff0" translate="yes" xml:space="preserve">
          <source>What should get your attention here is that the &lt;code&gt;value__&lt;/code&gt; is stored separately from the enum values. In the case of the enum &lt;code&gt;Foo&lt;/code&gt; above, the type of &lt;code&gt;value__&lt;/code&gt; is int16. This basically means that you can store whatever you want in an enum, &lt;strong&gt;as long as the types match&lt;/strong&gt;.</source>
          <target state="translated">여기서 주목해야 할 것은 &lt;code&gt;value__&lt;/code&gt; 은 열거 형 값과 별도로 저장된다는 것입니다. 위의 열거 형 &lt;code&gt;Foo&lt;/code&gt; 의 경우 &lt;code&gt;value__&lt;/code&gt; 유형은 int16입니다. 이것은 기본적으로 &lt;strong&gt;유형이 일치&lt;/strong&gt; 하는 한 열거 형에 원하는 것을 저장할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="75195f05ea43ea70c38131eb9ea13a4996f5e578" translate="yes" xml:space="preserve">
          <source>You can check if it's in range using &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.enum.isdefined.aspx&quot;&gt;Enum.IsDefined&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.enum.isdefined.aspx&quot;&gt;Enum.IsDefined&lt;/a&gt; 사용하여 범위 내에 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de1bc194347a91c21a17c2e5bfacb51ce958521" translate="yes" xml:space="preserve">
          <source>You just do like below:</source>
          <target state="translated">당신은 아래처럼 좋아합니다 :</target>
        </trans-unit>
        <trans-unit id="6994803e241f1afbcedb1ae8f1f21f8c4838e50b" translate="yes" xml:space="preserve">
          <source>You need to change parsing at helper method from</source>
          <target state="translated">도우미 메소드에서 구문 분석을</target>
        </trans-unit>
        <trans-unit id="a0c0f2e9958eee84b504206d7affb17281468c3c" translate="yes" xml:space="preserve">
          <source>You should build in some type matching relaxation to be more robust.</source>
          <target state="translated">좀 더 견고하게하려면 어떤 유형의 일치 완화를 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="60a7352b0fac243c1417c6c97b157eab5c9c4dc2" translate="yes" xml:space="preserve">
          <source>You simply use &lt;strong&gt;Explicit conversion&lt;/strong&gt; Cast int to enum or enum to int</source>
          <target state="translated">&lt;strong&gt;명시 적 변환&lt;/strong&gt; Cast int를 enum으로 또는 enum을 int로</target>
        </trans-unit>
        <trans-unit id="26c332d9cd21581be5a14d1f84b9f1527eaca082" translate="yes" xml:space="preserve">
          <source>sorry for my english</source>
          <target state="translated">내 영어 죄송합니다</target>
        </trans-unit>
        <trans-unit id="1d21a26520b48d93a5e79674e2985df9e6cc8bee" translate="yes" xml:space="preserve">
          <source>the easy and clear way for casting an int to enum in c#:</source>
          <target state="translated">int를 C #으로 열거하기위한 쉽고 명확한 방법 :</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
