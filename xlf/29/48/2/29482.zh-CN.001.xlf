<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/29482">
    <body>
      <group id="29482">
        <trans-unit id="a6b4c34af36c3a26b9050e38700b2fae77e146b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Usage:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Usage:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81a72c38deebcc445e6e0b866809a7c979479e5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FYI:&lt;/strong&gt;  The question was about integers, which nobody mentioned will also explicitly convert in Enum.TryParse()</source>
          <target state="translated">&lt;strong&gt;仅供参考：&lt;/strong&gt;问题是关于整数的，没有人提到过也会在Enum.TryParse（）中进行显式转换</target>
        </trans-unit>
        <trans-unit id="eed27dac7346464d428cbb3ad292a3ac60f63205" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How stuff works&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;事情怎么样&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e973dcf220dd2052dbaad0156f4e3d9d0f1782da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N.B:&lt;/strong&gt; Here I try to parse value into int, because enum is by default &lt;strong&gt;int&lt;/strong&gt;
If you define enum like this which is &lt;strong&gt;byte&lt;/strong&gt; type.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这里我尝试将值解析为int，因为默认情况下enum是&lt;strong&gt;int&lt;/strong&gt;如果您这样定义枚举（ &lt;strong&gt;字节&lt;/strong&gt;类型）。</target>
        </trans-unit>
        <trans-unit id="3379b289640323b42df642694c64588c9345c6d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;答案&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e2cee577f891dfa999a3a3c8e44916d9a7d5301" translate="yes" xml:space="preserve">
          <source>Also note that I'm explicit about the underlying type of the enum, even though the compiler actually checks this. I'm doing this to ensure I don't run into any surprises down the road. To see these surprises in action, you can use the following code (actually I've seen this happen a lot in database code):</source>
          <target state="translated">另外要注意的是,我明确指出了 enum 的底层类型,尽管编译器实际上是在检查这一点。我这样做是为了确保我不会遇到任何意外。要查看这些惊喜,你可以使用下面的代码(实际上我在数据库代码中经常看到这种情况)。</target>
        </trans-unit>
        <trans-unit id="af726d70297878295862d1b77096a1ca802e71c5" translate="yes" xml:space="preserve">
          <source>Alternatively, use an extension method instead of a one-liner:</source>
          <target state="translated">或者用扩展方法代替单行本的方法。</target>
        </trans-unit>
        <trans-unit id="30118d3b1c1343d010562aeede775b3215539795" translate="yes" xml:space="preserve">
          <source>An enum in .NET is a structure that maps a set of values (fields) to a basic type (the default is &lt;code&gt;int&lt;/code&gt;). However, you can actually choose the integral type that your enum maps to:</source>
          <target state="translated">.NET中的枚举是一种将一组值（字段）映射到基本类型（默认值为 &lt;code&gt;int&lt;/code&gt; ）的结构。 但是，您实际上可以选择枚举映射到的整数类型：</target>
        </trans-unit>
        <trans-unit id="b916f7a25f55c5eb6520db15c0b76814186e35ef" translate="yes" xml:space="preserve">
          <source>At this point I'd like to point out that &lt;code&gt;System.Enum&lt;/code&gt; is a value type, which basically means that &lt;code&gt;BarFlag&lt;/code&gt; will take up 4 bytes in memory and &lt;code&gt;Foo&lt;/code&gt; will take up 2 -- e.g. the size of the underlying type (it's actually more complicated than that, but hey...).</source>
          <target state="translated">在这一点上，我想指出 &lt;code&gt;System.Enum&lt;/code&gt; 是一个值类型，这基本上意味着 &lt;code&gt;BarFlag&lt;/code&gt; 将占用4个字节的内存，而 &lt;code&gt;Foo&lt;/code&gt; 将占用2个字节-例如，基础类型的大小（实际上更多比那复杂，但是嘿...）。</target>
        </trans-unit>
        <trans-unit id="c0413c5f086e8cdb2bfd487f989b2746f23f64a8" translate="yes" xml:space="preserve">
          <source>Below is a nice utility class for Enums</source>
          <target state="translated">下面是一个不错的Enums实用类</target>
        </trans-unit>
        <trans-unit id="c7a47f219b33d30b71c37b2d6cedfd8e57764dcc" translate="yes" xml:space="preserve">
          <source>Different ways to cast &lt;strong&gt;to and from&lt;/strong&gt;&lt;code&gt;Enum&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; &lt;strong&gt;和&lt;/strong&gt; 枚举的不同方式</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7779fd1817467dd8f6953f720534704f90c6ddd5" translate="yes" xml:space="preserve">
          <source>Following is slightly better extension method</source>
          <target state="translated">以下是稍好的扩展方法</target>
        </trans-unit>
        <trans-unit id="5ae38008949e7b592153d6dcf436b9d69ba3e6df" translate="yes" xml:space="preserve">
          <source>For numeric values, this is safer as it will return an object no matter what:</source>
          <target state="translated">对于数字值来说,这个比较安全,因为无论如何都会返回一个对象。</target>
        </trans-unit>
        <trans-unit id="c2ef2caf9f686790ead807567c0c38452b3e7637" translate="yes" xml:space="preserve">
          <source>From a string:</source>
          <target state="translated">从一串。</target>
        </trans-unit>
        <trans-unit id="cbcb27e94932b1692382c6be1ee06baefc40110b" translate="yes" xml:space="preserve">
          <source>From a string: (Enum.Parse is out of Date, use Enum.TryParse)</source>
          <target state="translated">从一个字符串。(Enum.Parse已过期,请使用Enum.TryParse)</target>
        </trans-unit>
        <trans-unit id="12b5562011271b407c2a07a49b4ce89ba1ce76cf" translate="yes" xml:space="preserve">
          <source>From an int:</source>
          <target state="translated">从一个国际组织来看。</target>
        </trans-unit>
        <trans-unit id="d6e762db23f1b10e1af14cabc983c5d6512a41ef" translate="yes" xml:space="preserve">
          <source>From number you can also</source>
          <target state="translated">从数字中,你还可以</target>
        </trans-unit>
        <trans-unit id="f137a65c013374c3b55924d030a077022c736fe7" translate="yes" xml:space="preserve">
          <source>Here's an extension method that casts &lt;code&gt;Int32&lt;/code&gt; to &lt;code&gt;Enum&lt;/code&gt;.</source>
          <target state="translated">这是将 &lt;code&gt;Int32&lt;/code&gt; 强制转换为 &lt;code&gt;Enum&lt;/code&gt; 的扩展方法。</target>
        </trans-unit>
        <trans-unit id="47794330eb800548debab157559b2fc0f4e83f59" translate="yes" xml:space="preserve">
          <source>Here's my WCF Class.</source>
          <target state="translated">这是我的WCF班。</target>
        </trans-unit>
        <trans-unit id="9deb0ddaed7c3d92f5ab73d23b1e00a58d3f529f" translate="yes" xml:space="preserve">
          <source>Here's the Extension method that gets the Description from the Enum.</source>
          <target state="translated">下面是从Enum中获取Description的扩展方法。</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">代码是这样的。</target>
        </trans-unit>
        <trans-unit id="b6e2185fd5ad4957e164bfc5cd8182ea7426ad0d" translate="yes" xml:space="preserve">
          <source>How can an &lt;code&gt;int&lt;/code&gt; be cast to an &lt;code&gt;enum&lt;/code&gt; in C#?</source>
          <target state="translated">如何将 &lt;code&gt;int&lt;/code&gt; &lt;code&gt;enum&lt;/code&gt; 为C＃中的枚举 ？</target>
        </trans-unit>
        <trans-unit id="9ad1aa9a3f6e0c785db5f620ebedd2435fc941f5" translate="yes" xml:space="preserve">
          <source>How to cast int to enum</source>
          <target state="translated">如何将int投向enum</target>
        </trans-unit>
        <trans-unit id="1d8e36314d06b04e852b52096b3001ab6ef713bd" translate="yes" xml:space="preserve">
          <source>I am using this piece of code to cast int to my enum:</source>
          <target state="translated">我正在使用这段代码将int投给我的enum。</target>
        </trans-unit>
        <trans-unit id="e24428ad78c068750f7ef484b43a7e9a4fe1cfa6" translate="yes" xml:space="preserve">
          <source>I check my method for following inputs</source>
          <target state="translated">我检查我的方法有以下输入</target>
        </trans-unit>
        <trans-unit id="ef81821754c4e47ec08734c09c477e8ac9757fe6" translate="yes" xml:space="preserve">
          <source>I don't know anymore where I get the part of this enum extension, but it is from stackoverflow. I am sorry for this! But I took this one and modified it for enums with Flags. 
For enums with Flags I did this:</source>
          <target state="translated">我已经不知道我从哪里得到这个enum扩展的部分了,但它是从stackoverflow中得到的。这一点我很抱歉! 但是我把这个拿去修改了一下,用于带Flags的enums。对于带Flags的enums,我是这样做的。</target>
        </trans-unit>
        <trans-unit id="457bca1c0a85aef6bdce1d0f33ebb2509ed1ceb5" translate="yes" xml:space="preserve">
          <source>I find it the best solution.</source>
          <target state="translated">我觉得这是最好的解决办法。</target>
        </trans-unit>
        <trans-unit id="c1abcbaa6defe875aae077f24bbffd1ba2a91b12" translate="yes" xml:space="preserve">
          <source>I think to get a complete answer, people have to know how enums work internally in .NET.</source>
          <target state="translated">我想,要想得到一个完整的答案,人们必须知道.NET中的enums是如何在内部工作的。</target>
        </trans-unit>
        <trans-unit id="74b835001d4e6bc62e1f790cf0d31fbc11c56484" translate="yes" xml:space="preserve">
          <source>If that's not what you intended, use &lt;code&gt;Enum.IsDefined(typeof(MyEnum), 6)&lt;/code&gt; to check if the value you are casting maps to a defined enum.</source>
          <target state="translated">如果这不是您想要的，请使用 &lt;code&gt;Enum.IsDefined(typeof(MyEnum), 6)&lt;/code&gt; 检查要转换的值是否映射到已定义的枚举。</target>
        </trans-unit>
        <trans-unit id="bf4ab29a7d928709689495b0cf054a253bc70f58" translate="yes" xml:space="preserve">
          <source>If you have an integer that acts as a bitmask and could represent one or more values in a [Flags] enumeration, you can use this code to parse the individual flag values into a list:</source>
          <target state="translated">如果你有一个作为位掩码的整数,并且可以在[Flags]枚举中表示一个或多个值,你可以使用这段代码将单个标志值解析成一个列表。</target>
        </trans-unit>
        <trans-unit id="c77c5c6c4624bf56bf3ab881363e00f95d0138bf" translate="yes" xml:space="preserve">
          <source>If you look at it from a IL point of view, a (normal, int) enum looks like this:</source>
          <target state="translated">如果你从IL的角度来看,一个(正常的,int)enum看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="25c3f82e417c33466d85a7e97298a6e16ee7b4fb" translate="yes" xml:space="preserve">
          <source>If you're ready for the 4.0 &lt;a href=&quot;http://en.wikipedia.org/wiki/.NET_Framework&quot;&gt;.NET&lt;/a&gt; Framework, there's a new &lt;em&gt;Enum.TryParse()&lt;/em&gt; function that's very useful and plays well with the [Flags] attribute. See &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd783499.aspx&quot;&gt;Enum.TryParse Method (String, TEnum%)&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">如果您准备好使用4.0 &lt;a href=&quot;http://en.wikipedia.org/wiki/.NET_Framework&quot;&gt;.NET&lt;/a&gt; Framework，则有一个新的&lt;em&gt;Enum.TryParse（）&lt;/em&gt;函数，该函数非常有用，并且可以与[Flags]属性配合使用。 请参见&lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd783499.aspx&quot;&gt;Enum.TryParse方法（字符串，TEnum％）&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d71bedbf598c6cb2ef567aed0bcbc08631a830d" translate="yes" xml:space="preserve">
          <source>Implementation:</source>
          <target state="translated">Implementation:</target>
        </trans-unit>
        <trans-unit id="36b8f0807dd5d7178d8b25b6cb15fd0a7aa1cc47" translate="yes" xml:space="preserve">
          <source>In my case, I needed to return the enum from a WCF service.  I also needed a friendly name, not just the enum.ToString().</source>
          <target state="translated">在我的例子中,我需要从WCF服务中返回enum。我还需要一个友好的名字,而不仅仅是enum.ToString()。</target>
        </trans-unit>
        <trans-unit id="d62b78a00e6ea80925fcd64e5da7c05277653560" translate="yes" xml:space="preserve">
          <source>In this case the enum is mapped to the &lt;code&gt;short&lt;/code&gt; data type, which means it will be stored in memory as a short and will behave as a short when you cast and use it.</source>
          <target state="translated">在这种情况下，枚举被映射为 &lt;code&gt;short&lt;/code&gt; 数据类型，这意味着它将以short形式存储在内存中，并且在进行强制转换和使用时表现为short。</target>
        </trans-unit>
        <trans-unit id="d2802b271f3bb077fa0c3629ce77db289d06e1a8" translate="yes" xml:space="preserve">
          <source>It can help you to convert any input data to user desired &lt;strong&gt;enum&lt;/strong&gt;. Suppose you have an enum like below which by default &lt;strong&gt;int&lt;/strong&gt;. Please add a &lt;strong&gt;Default&lt;/strong&gt; value at first of your enum. Which is used at helpers medthod when there is no match found with input value.</source>
          <target state="translated">它可以帮助您将任何输入数据转换为用户所需的&lt;strong&gt;枚举&lt;/strong&gt; 。 假设您有一个像下面这样的枚举，默认为&lt;strong&gt;int&lt;/strong&gt; 。 请在您的枚举的开头添加一个&lt;strong&gt;默认&lt;/strong&gt;值。 找不到与输入值匹配的辅助方法时使用。</target>
        </trans-unit>
        <trans-unit id="33937f92c8a23f78b931b80e06bc320e4b039228" translate="yes" xml:space="preserve">
          <source>It honors bitwise flags even when the value is higher than the maximum possible. For example if you have an enum with possibilities &lt;em&gt;1&lt;/em&gt;, &lt;em&gt;2&lt;/em&gt;, and &lt;em&gt;4&lt;/em&gt;, but the int is &lt;em&gt;9&lt;/em&gt;, it understands that as &lt;em&gt;1&lt;/em&gt; in absence of an &lt;em&gt;8&lt;/em&gt;. This lets you make data updates ahead of code updates.</source>
          <target state="translated">即使值大于最大可能值，它也支持按位标志。 例如，如果您的枚举的可能性为&lt;em&gt;1、2&lt;/em&gt;和&lt;em&gt;4&lt;/em&gt; ，但int为&lt;em&gt;9&lt;/em&gt; ，则它在没有&lt;em&gt;8的&lt;/em&gt;情况下将其理解为&lt;em&gt;1&lt;/em&gt; 。 这使您可以在代码更新之前进行数据更新。</target>
        </trans-unit>
        <trans-unit id="669c26b60d45316558ef147c15c0c09988d60fc8" translate="yes" xml:space="preserve">
          <source>Just cast it:</source>
          <target state="translated">就这样投下去吧。</target>
        </trans-unit>
        <trans-unit id="2c773194ea026cc993e378f1446632013f32a420" translate="yes" xml:space="preserve">
          <source>Note that casting to &lt;code&gt;e2&lt;/code&gt; also works! From the compiler perspective above this makes sense: the &lt;code&gt;value__&lt;/code&gt; field is simply filled with either 5 or 6 and when &lt;code&gt;Console.WriteLine&lt;/code&gt; calls &lt;code&gt;ToString()&lt;/code&gt;, the name of &lt;code&gt;e1&lt;/code&gt; is resolved while the name of &lt;code&gt;e2&lt;/code&gt; is not.</source>
          <target state="translated">请注意，强制转换为 &lt;code&gt;e2&lt;/code&gt; 也可以！ 从上面的编译器角度来看，这是有道理的： &lt;code&gt;value__&lt;/code&gt; 字段仅用 5或6填充，并且当 &lt;code&gt;Console.WriteLine&lt;/code&gt; 调用 &lt;code&gt;ToString()&lt;/code&gt; 时 ，将解析 &lt;code&gt;e1&lt;/code&gt; 的名称，而不会解析 &lt;code&gt;e2&lt;/code&gt; 的名称。</target>
        </trans-unit>
        <trans-unit id="569ada5fc09d3eeddae46ad081c41b68fabf7331" translate="yes" xml:space="preserve">
          <source>Note that this assumes that the underlying type of the &lt;code&gt;enum&lt;/code&gt; is a signed 32-bit integer. If it were a different numerical type, you'd have to change the hardcoded 32 to reflect the bits in that type (or programatically derive it using &lt;code&gt;Enum.GetUnderlyingType()&lt;/code&gt;)</source>
          <target state="translated">请注意，这假定 &lt;code&gt;enum&lt;/code&gt; 的基础类型是带符号的32位整数。 如果它是不同的数字类型，则必须更改硬编码32以反映该类型中的位（或使用 &lt;code&gt;Enum.GetUnderlyingType()&lt;/code&gt; 以编程方式派生它）</target>
        </trans-unit>
        <trans-unit id="b3179c75c3fd8315efa725c8e57bb612845936a4" translate="yes" xml:space="preserve">
          <source>Note that using IsDefined is costly and even more than just casting, so it depends on your implementation to decide to use it or not.</source>
          <target state="translated">需要注意的是,使用IsDefined的成本很高,甚至超过了单纯的铸造,所以要不要使用它,要看你的实现情况来决定。</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="cb46ab1740f0e8d608e38f895692a452d2b8b436" translate="yes" xml:space="preserve">
          <source>Obviously, some of the enum type functionality will be lost, but for storing a bunch of database id constants, it seems like a pretty tidy solution.</source>
          <target state="translated">很明显,一些枚举类型的功能会丢失,但对于存储一堆数据库的id常量来说,这似乎是一个非常整洁的解决方案。</target>
        </trans-unit>
        <trans-unit id="2787dadf2ebcf4ca566176af819017f9f6a66212" translate="yes" xml:space="preserve">
          <source>Slightly getting away from the original question, but I found &lt;a href=&quot;https://stackoverflow.com/a/11057004/429973&quot;&gt;an answer to Stack&amp;nbsp;Overflow question &lt;em&gt;Get int value from enum&lt;/em&gt;&lt;/a&gt; useful. Create a static class with &lt;code&gt;public const int&lt;/code&gt; properties, allowing you to easily collect together a bunch of related &lt;code&gt;int&lt;/code&gt; constants, and then not have to cast them to &lt;code&gt;int&lt;/code&gt; when using them.</source>
          <target state="translated">稍微摆脱了最初的问题，但是我找到&lt;a href=&quot;https://stackoverflow.com/a/11057004/429973&quot;&gt;了一个关于堆栈溢出问题的答案， &lt;em&gt;从枚举中获取int值&lt;/em&gt;&lt;/a&gt;很有用。 创建具有 &lt;code&gt;public const int&lt;/code&gt; 属性的静态类，使您可以轻松地将一堆相关的 &lt;code&gt;int&lt;/code&gt; 常数收集在一起，然后在使用它们时不必将它们 &lt;code&gt;int&lt;/code&gt; 为int 。</target>
        </trans-unit>
        <trans-unit id="41341fed4fc5135c7817e04c2934f4db99145db9" translate="yes" xml:space="preserve">
          <source>So, if you have an integer that you want to map to an enum, the runtime only has to do 2 things: copy the 4 bytes and name it something else (the name of the enum). Copying is implicit because the data is stored as value type - this basically means that if you use unmanaged code, you can simply interchange enums and integers without copying data.</source>
          <target state="translated">所以,如果你有一个整数要映射到一个enum,那么运行时只需要做两件事:复制这4个字节,并给它起个别的名字(enum的名字)。复制是隐含的,因为数据是以值类型存储的,这基本上意味着,如果你使用非管理的代码,你可以简单地交换 enum 和 integer,而不需要复制数据。</target>
        </trans-unit>
        <trans-unit id="545ab5091363b3b680b64a4657255d140cb67922" translate="yes" xml:space="preserve">
          <source>Sometimes you have an object to the &lt;code&gt;MyEnum&lt;/code&gt; type. Like</source>
          <target state="translated">有时您有一个 &lt;code&gt;MyEnum&lt;/code&gt; 类型的对象。 喜欢</target>
        </trans-unit>
        <trans-unit id="4e5c1cb438afe66a7a3ce7f0162632afd0f40816" translate="yes" xml:space="preserve">
          <source>Take the following example:</source>
          <target state="translated">以下面的例子为例。</target>
        </trans-unit>
        <trans-unit id="2d77855a284dd03f6fdaf1a7d511a263b8079230" translate="yes" xml:space="preserve">
          <source>Test Case</source>
          <target state="translated">测试案例</target>
        </trans-unit>
        <trans-unit id="4be24070f4f24438345c01c626b6fdfd6542d435" translate="yes" xml:space="preserve">
          <source>The code goes as shown below where &quot;red&quot; is the string and &quot;MyColors&quot; is the color ENUM which has the color constants.</source>
          <target state="translated">代码如下图所示,其中 &quot;red &quot;是字符串,&quot;MyColors &quot;是具有颜色常量的颜色ENUM。</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="e1ceff90c2d44b022434871989ecfc3d783a6af6" translate="yes" xml:space="preserve">
          <source>This is an flags enumeration aware safe convert method:</source>
          <target state="translated">这是一种标志枚举式的安全转换方法。</target>
        </trans-unit>
        <trans-unit id="2f886dad395648b4e15cc32acf1f9703992e4e5b" translate="yes" xml:space="preserve">
          <source>This parses integers or strings to a target enum with partial matching in dot.NET 4.0 using generics like in Tawani's utility class above.  I am using it to convert command-line switch variables which may be incomplete.  Since an enum cannot be null, you should logically provide a default value.  It can be called like this:</source>
          <target state="translated">在dot.NET 4.0中,它可以将整数或字符串解析成一个具有部分匹配的目标enum,使用类似于上面Tawani的实用程序类中的Generics。我用它来转换命令行开关变量,它可能是不完整的。因为一个enum不能为空,所以逻辑上应该提供一个默认值。它可以这样调用。</target>
        </trans-unit>
        <trans-unit id="e19c993984f6dd6f758fe2a09db7defa6fe45d59" translate="yes" xml:space="preserve">
          <source>To convert a string to ENUM or int to ENUM constant we need to use Enum.Parse function. Here is a youtube video &lt;a href=&quot;https://www.youtube.com/watch?v=4nhx4VwdRDk&quot;&gt;https://www.youtube.com/watch?v=4nhx4VwdRDk&lt;/a&gt;  which actually demonstrate's with string and the same applies for int.</source>
          <target state="translated">要将字符串转换为ENUM或将int转换为ENUM常量，我们需要使用Enum.Parse函数。 这是一个youtube视频&lt;a href=&quot;https://www.youtube.com/watch?v=4nhx4VwdRDk&quot;&gt;https://www.youtube.com/watch?v=4nhx4VwdRDk&lt;/a&gt; ，实际上演示了带有字符串的，并且对于int同样适用。</target>
        </trans-unit>
        <trans-unit id="a68345d4247855f0ef61c33db7f1d7fc5da8f76c" translate="yes" xml:space="preserve">
          <source>To make it safe, I think it's a best practice to &lt;strong&gt;know that the underlying types are the same or implicitly convertible&lt;/strong&gt; and to ensure the enum values exist (they aren't checked by default!).</source>
          <target state="translated">为了安全起见，我认为最好的做法是&lt;strong&gt;知道基础类型是相同的或隐式可转换的，&lt;/strong&gt;并确保枚举值存在（默认情况下不检查它们！）。</target>
        </trans-unit>
        <trans-unit id="23a5d50f7d560683b09aeb6eb136065dad2c6c30" translate="yes" xml:space="preserve">
          <source>To make sure that you only cast the right values ​​and that you can throw an exception otherwise:</source>
          <target state="translated">要确保你只投正确的值,否则可以抛出异常。</target>
        </trans-unit>
        <trans-unit id="47face85db7011031f48f02a22cd9a272203d89f" translate="yes" xml:space="preserve">
          <source>To see how this works, try the following code:</source>
          <target state="translated">要想知道这个方法的工作原理,可以试试下面的代码。</target>
        </trans-unit>
        <trans-unit id="fe32a38f013c13127d95cbb21b75c9f2a3ff7ff0" translate="yes" xml:space="preserve">
          <source>What should get your attention here is that the &lt;code&gt;value__&lt;/code&gt; is stored separately from the enum values. In the case of the enum &lt;code&gt;Foo&lt;/code&gt; above, the type of &lt;code&gt;value__&lt;/code&gt; is int16. This basically means that you can store whatever you want in an enum, &lt;strong&gt;as long as the types match&lt;/strong&gt;.</source>
          <target state="translated">在这里应该引起您注意的是 &lt;code&gt;value__&lt;/code&gt; 与枚举值分开存储。 对于上面的枚举 &lt;code&gt;Foo&lt;/code&gt; ， &lt;code&gt;value__&lt;/code&gt; 的类型为int16。 这基本上意味着&lt;strong&gt;只要类型匹配&lt;/strong&gt; ，您就可以在枚举中存储任何内容。</target>
        </trans-unit>
        <trans-unit id="75195f05ea43ea70c38131eb9ea13a4996f5e578" translate="yes" xml:space="preserve">
          <source>You can check if it's in range using &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.enum.isdefined.aspx&quot;&gt;Enum.IsDefined&lt;/a&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.enum.isdefined.aspx&quot;&gt;Enum.IsDefined&lt;/a&gt;检查它是否在范围内：</target>
        </trans-unit>
        <trans-unit id="0de1bc194347a91c21a17c2e5bfacb51ce958521" translate="yes" xml:space="preserve">
          <source>You just do like below:</source>
          <target state="translated">你只需要像下面这样做。</target>
        </trans-unit>
        <trans-unit id="6994803e241f1afbcedb1ae8f1f21f8c4838e50b" translate="yes" xml:space="preserve">
          <source>You need to change parsing at helper method from</source>
          <target state="translated">你需要将助手方法的解析方式从</target>
        </trans-unit>
        <trans-unit id="a0c0f2e9958eee84b504206d7affb17281468c3c" translate="yes" xml:space="preserve">
          <source>You should build in some type matching relaxation to be more robust.</source>
          <target state="translated">你应该建立在某种类型的匹配放松,这样才能更加稳健。</target>
        </trans-unit>
        <trans-unit id="60a7352b0fac243c1417c6c97b157eab5c9c4dc2" translate="yes" xml:space="preserve">
          <source>You simply use &lt;strong&gt;Explicit conversion&lt;/strong&gt; Cast int to enum or enum to int</source>
          <target state="translated">您只需要使用&lt;strong&gt;显式转换&lt;/strong&gt; Cast int到enum或enum到int</target>
        </trans-unit>
        <trans-unit id="26c332d9cd21581be5a14d1f84b9f1527eaca082" translate="yes" xml:space="preserve">
          <source>sorry for my english</source>
          <target state="translated">对不起,我的英语</target>
        </trans-unit>
        <trans-unit id="1d21a26520b48d93a5e79674e2985df9e6cc8bee" translate="yes" xml:space="preserve">
          <source>the easy and clear way for casting an int to enum in c#:</source>
          <target state="translated">在c#中,将int铸造成enum的简单而清晰的方法。</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
