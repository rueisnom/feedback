<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/29482">
    <body>
      <group id="29482">
        <trans-unit id="a6b4c34af36c3a26b9050e38700b2fae77e146b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Usage:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Usage:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81a72c38deebcc445e6e0b866809a7c979479e5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FYI:&lt;/strong&gt;  The question was about integers, which nobody mentioned will also explicitly convert in Enum.TryParse()</source>
          <target state="translated">&lt;strong&gt;К вашему сведению:&lt;/strong&gt; вопрос был о целых числах, которые никто не упомянул, также будут явно конвертированы в Enum.TryParse ()</target>
        </trans-unit>
        <trans-unit id="eed27dac7346464d428cbb3ad292a3ac60f63205" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How stuff works&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как это работает&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e973dcf220dd2052dbaad0156f4e3d9d0f1782da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N.B:&lt;/strong&gt; Here I try to parse value into int, because enum is by default &lt;strong&gt;int&lt;/strong&gt;
If you define enum like this which is &lt;strong&gt;byte&lt;/strong&gt; type.</source>
          <target state="translated">&lt;strong&gt;NB:&lt;/strong&gt; Здесь я пытаюсь разобрать значение в int, потому что enum по умолчанию &lt;strong&gt;int,&lt;/strong&gt; если вы определили enum как этот, который является &lt;strong&gt;байтовым&lt;/strong&gt; типом.</target>
        </trans-unit>
        <trans-unit id="3379b289640323b42df642694c64588c9345c6d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ответ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e2cee577f891dfa999a3a3c8e44916d9a7d5301" translate="yes" xml:space="preserve">
          <source>Also note that I'm explicit about the underlying type of the enum, even though the compiler actually checks this. I'm doing this to ensure I don't run into any surprises down the road. To see these surprises in action, you can use the following code (actually I've seen this happen a lot in database code):</source>
          <target state="translated">Также обратите внимание,что я прямо говорю о типе,лежащем в основе перечисления,несмотря на то,что компилятор на самом деле это проверяет.Я делаю это,чтобы не наткнуться на сюрпризы.Чтобы увидеть эти сюрпризы в действии,можно воспользоваться следующим кодом (на самом деле я много раз видел,как это происходит в коде базы данных):</target>
        </trans-unit>
        <trans-unit id="af726d70297878295862d1b77096a1ca802e71c5" translate="yes" xml:space="preserve">
          <source>Alternatively, use an extension method instead of a one-liner:</source>
          <target state="translated">В качестве альтернативы,используйте метод расширения вместо одного лайнера:</target>
        </trans-unit>
        <trans-unit id="30118d3b1c1343d010562aeede775b3215539795" translate="yes" xml:space="preserve">
          <source>An enum in .NET is a structure that maps a set of values (fields) to a basic type (the default is &lt;code&gt;int&lt;/code&gt;). However, you can actually choose the integral type that your enum maps to:</source>
          <target state="translated">Перечисление в .NET - это структура, которая отображает набор значений (полей) в базовый тип (по умолчанию &lt;code&gt;int&lt;/code&gt; ). Тем не менее, вы можете выбрать целочисленный тип, который будет отображаться в вашем перечислении:</target>
        </trans-unit>
        <trans-unit id="b916f7a25f55c5eb6520db15c0b76814186e35ef" translate="yes" xml:space="preserve">
          <source>At this point I'd like to point out that &lt;code&gt;System.Enum&lt;/code&gt; is a value type, which basically means that &lt;code&gt;BarFlag&lt;/code&gt; will take up 4 bytes in memory and &lt;code&gt;Foo&lt;/code&gt; will take up 2 -- e.g. the size of the underlying type (it's actually more complicated than that, but hey...).</source>
          <target state="translated">На данный момент я хотел бы отметить, что &lt;code&gt;System.Enum&lt;/code&gt; является типом значения, что в основном означает, что &lt;code&gt;BarFlag&lt;/code&gt; займет 4 байта в памяти, а &lt;code&gt;Foo&lt;/code&gt; - 2 - например, размер базового типа (на самом деле это больше Сложнее, чем это, но эй ...).</target>
        </trans-unit>
        <trans-unit id="c0413c5f086e8cdb2bfd487f989b2746f23f64a8" translate="yes" xml:space="preserve">
          <source>Below is a nice utility class for Enums</source>
          <target state="translated">Ниже приведен хороший утилитарный класс для переписчиков</target>
        </trans-unit>
        <trans-unit id="c7a47f219b33d30b71c37b2d6cedfd8e57764dcc" translate="yes" xml:space="preserve">
          <source>Different ways to cast &lt;strong&gt;to and from&lt;/strong&gt;&lt;code&gt;Enum&lt;/code&gt;</source>
          <target state="translated">Различные способы приведения &lt;strong&gt;в и из&lt;/strong&gt; &lt;code&gt;Enum&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7779fd1817467dd8f6953f720534704f90c6ddd5" translate="yes" xml:space="preserve">
          <source>Following is slightly better extension method</source>
          <target state="translated">Ниже приведены несколько лучшие методы расширения</target>
        </trans-unit>
        <trans-unit id="5ae38008949e7b592153d6dcf436b9d69ba3e6df" translate="yes" xml:space="preserve">
          <source>For numeric values, this is safer as it will return an object no matter what:</source>
          <target state="translated">Для числовых значений это безопаснее,так как возвращает объект,несмотря ни на что:</target>
        </trans-unit>
        <trans-unit id="c2ef2caf9f686790ead807567c0c38452b3e7637" translate="yes" xml:space="preserve">
          <source>From a string:</source>
          <target state="translated">От струны:</target>
        </trans-unit>
        <trans-unit id="cbcb27e94932b1692382c6be1ee06baefc40110b" translate="yes" xml:space="preserve">
          <source>From a string: (Enum.Parse is out of Date, use Enum.TryParse)</source>
          <target state="translated">От струны:(Enum.Parse закончился,используйте Enum.TryParse).</target>
        </trans-unit>
        <trans-unit id="12b5562011271b407c2a07a49b4ce89ba1ce76cf" translate="yes" xml:space="preserve">
          <source>From an int:</source>
          <target state="translated">От интенданта:</target>
        </trans-unit>
        <trans-unit id="d6e762db23f1b10e1af14cabc983c5d6512a41ef" translate="yes" xml:space="preserve">
          <source>From number you can also</source>
          <target state="translated">С номера вы также можете</target>
        </trans-unit>
        <trans-unit id="f137a65c013374c3b55924d030a077022c736fe7" translate="yes" xml:space="preserve">
          <source>Here's an extension method that casts &lt;code&gt;Int32&lt;/code&gt; to &lt;code&gt;Enum&lt;/code&gt;.</source>
          <target state="translated">Вот метод расширения, который приводит &lt;code&gt;Int32&lt;/code&gt; к &lt;code&gt;Enum&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47794330eb800548debab157559b2fc0f4e83f59" translate="yes" xml:space="preserve">
          <source>Here's my WCF Class.</source>
          <target state="translated">Вот мой класс WCF.</target>
        </trans-unit>
        <trans-unit id="9deb0ddaed7c3d92f5ab73d23b1e00a58d3f529f" translate="yes" xml:space="preserve">
          <source>Here's the Extension method that gets the Description from the Enum.</source>
          <target state="translated">Вот метод Extension,который получает Описание из Enum.</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">Вот код:</target>
        </trans-unit>
        <trans-unit id="b6e2185fd5ad4957e164bfc5cd8182ea7426ad0d" translate="yes" xml:space="preserve">
          <source>How can an &lt;code&gt;int&lt;/code&gt; be cast to an &lt;code&gt;enum&lt;/code&gt; in C#?</source>
          <target state="translated">Как можно привести &lt;code&gt;int&lt;/code&gt; к &lt;code&gt;enum&lt;/code&gt; в C #?</target>
        </trans-unit>
        <trans-unit id="9ad1aa9a3f6e0c785db5f620ebedd2435fc941f5" translate="yes" xml:space="preserve">
          <source>How to cast int to enum</source>
          <target state="translated">Как перечислить</target>
        </trans-unit>
        <trans-unit id="1d8e36314d06b04e852b52096b3001ab6ef713bd" translate="yes" xml:space="preserve">
          <source>I am using this piece of code to cast int to my enum:</source>
          <target state="translated">Я использую этот кусок кода,чтобы ввести в свою перепись:</target>
        </trans-unit>
        <trans-unit id="e24428ad78c068750f7ef484b43a7e9a4fe1cfa6" translate="yes" xml:space="preserve">
          <source>I check my method for following inputs</source>
          <target state="translated">Я проверяю свой метод на следующие входы</target>
        </trans-unit>
        <trans-unit id="ef81821754c4e47ec08734c09c477e8ac9757fe6" translate="yes" xml:space="preserve">
          <source>I don't know anymore where I get the part of this enum extension, but it is from stackoverflow. I am sorry for this! But I took this one and modified it for enums with Flags. 
For enums with Flags I did this:</source>
          <target state="translated">Я больше не знаю,откуда у меня эта часть расширения enum,но это из stackoverflow.Простите за это! Но я взял этот и модифицировал его для enums с Flags.Для enums with Flags я сделал это:</target>
        </trans-unit>
        <trans-unit id="457bca1c0a85aef6bdce1d0f33ebb2509ed1ceb5" translate="yes" xml:space="preserve">
          <source>I find it the best solution.</source>
          <target state="translated">Я нахожу это лучшим решением.</target>
        </trans-unit>
        <trans-unit id="c1abcbaa6defe875aae077f24bbffd1ba2a91b12" translate="yes" xml:space="preserve">
          <source>I think to get a complete answer, people have to know how enums work internally in .NET.</source>
          <target state="translated">Я думаю,чтобы получить полный ответ,люди должны знать,как работают перечисления внутри .NET.</target>
        </trans-unit>
        <trans-unit id="74b835001d4e6bc62e1f790cf0d31fbc11c56484" translate="yes" xml:space="preserve">
          <source>If that's not what you intended, use &lt;code&gt;Enum.IsDefined(typeof(MyEnum), 6)&lt;/code&gt; to check if the value you are casting maps to a defined enum.</source>
          <target state="translated">Если это не то, что вы хотели, используйте &lt;code&gt;Enum.IsDefined(typeof(MyEnum), 6)&lt;/code&gt; чтобы проверить, соответствует ли значение, которое вы преобразуете, определенному перечислению.</target>
        </trans-unit>
        <trans-unit id="bf4ab29a7d928709689495b0cf054a253bc70f58" translate="yes" xml:space="preserve">
          <source>If you have an integer that acts as a bitmask and could represent one or more values in a [Flags] enumeration, you can use this code to parse the individual flag values into a list:</source>
          <target state="translated">Если у Вас есть целое число,которое действует как битовая маска и может представлять одно или несколько значений в перечислении [Флаги],Вы можете использовать этот код для разбора отдельных значений флагов в списке:</target>
        </trans-unit>
        <trans-unit id="c77c5c6c4624bf56bf3ab881363e00f95d0138bf" translate="yes" xml:space="preserve">
          <source>If you look at it from a IL point of view, a (normal, int) enum looks like this:</source>
          <target state="translated">Если смотреть на него с точки зрения IL,то перечисление (нормальное,int)выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="25c3f82e417c33466d85a7e97298a6e16ee7b4fb" translate="yes" xml:space="preserve">
          <source>If you're ready for the 4.0 &lt;a href=&quot;http://en.wikipedia.org/wiki/.NET_Framework&quot;&gt;.NET&lt;/a&gt; Framework, there's a new &lt;em&gt;Enum.TryParse()&lt;/em&gt; function that's very useful and plays well with the [Flags] attribute. See &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd783499.aspx&quot;&gt;Enum.TryParse Method (String, TEnum%)&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Если вы готовы к 4.0 &lt;a href=&quot;http://en.wikipedia.org/wiki/.NET_Framework&quot;&gt;.NET&lt;/a&gt; Framework, есть новая &lt;em&gt;функция Enum.TryParse (),&lt;/em&gt; которая очень полезна и хорошо работает с атрибутом [Flags]. См. &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd783499.aspx&quot;&gt;Enum.TryParse Method (String, TEnum%)&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d71bedbf598c6cb2ef567aed0bcbc08631a830d" translate="yes" xml:space="preserve">
          <source>Implementation:</source>
          <target state="translated">Implementation:</target>
        </trans-unit>
        <trans-unit id="36b8f0807dd5d7178d8b25b6cb15fd0a7aa1cc47" translate="yes" xml:space="preserve">
          <source>In my case, I needed to return the enum from a WCF service.  I also needed a friendly name, not just the enum.ToString().</source>
          <target state="translated">В моем случае,мне нужно было вернуть перепись из службы WCF.Также мне нужно было дружественное имя,а не только enum.ToString().</target>
        </trans-unit>
        <trans-unit id="d62b78a00e6ea80925fcd64e5da7c05277653560" translate="yes" xml:space="preserve">
          <source>In this case the enum is mapped to the &lt;code&gt;short&lt;/code&gt; data type, which means it will be stored in memory as a short and will behave as a short when you cast and use it.</source>
          <target state="translated">В этом случае перечисление сопоставляется с &lt;code&gt;short&lt;/code&gt; типом данных, что означает, что оно будет сохранено в памяти как короткое и будет вести себя как короткое, когда вы используете его.</target>
        </trans-unit>
        <trans-unit id="d2802b271f3bb077fa0c3629ce77db289d06e1a8" translate="yes" xml:space="preserve">
          <source>It can help you to convert any input data to user desired &lt;strong&gt;enum&lt;/strong&gt;. Suppose you have an enum like below which by default &lt;strong&gt;int&lt;/strong&gt;. Please add a &lt;strong&gt;Default&lt;/strong&gt; value at first of your enum. Which is used at helpers medthod when there is no match found with input value.</source>
          <target state="translated">Это может помочь вам преобразовать любые входные данные в желаемое пользователем &lt;strong&gt;перечисление&lt;/strong&gt; . Предположим, у вас есть перечисление как ниже, которое по умолчанию &lt;strong&gt;int&lt;/strong&gt; . Пожалуйста, добавьте значение по &lt;strong&gt;умолчанию&lt;/strong&gt; в начале вашего перечисления. Который используется у помощников medthod, когда не найдено совпадений с входным значением.</target>
        </trans-unit>
        <trans-unit id="33937f92c8a23f78b931b80e06bc320e4b039228" translate="yes" xml:space="preserve">
          <source>It honors bitwise flags even when the value is higher than the maximum possible. For example if you have an enum with possibilities &lt;em&gt;1&lt;/em&gt;, &lt;em&gt;2&lt;/em&gt;, and &lt;em&gt;4&lt;/em&gt;, but the int is &lt;em&gt;9&lt;/em&gt;, it understands that as &lt;em&gt;1&lt;/em&gt; in absence of an &lt;em&gt;8&lt;/em&gt;. This lets you make data updates ahead of code updates.</source>
          <target state="translated">Он учитывает побитовые флаги, даже если значение превышает максимально возможное. Например, если у вас есть enum с возможностями &lt;em&gt;1&lt;/em&gt; , &lt;em&gt;2&lt;/em&gt; и &lt;em&gt;4&lt;/em&gt; , но int равен &lt;em&gt;9&lt;/em&gt; , он понимает это как &lt;em&gt;1&lt;/em&gt; при отсутствии &lt;em&gt;8&lt;/em&gt; . Это позволяет обновлять данные до обновления кода.</target>
        </trans-unit>
        <trans-unit id="669c26b60d45316558ef147c15c0c09988d60fc8" translate="yes" xml:space="preserve">
          <source>Just cast it:</source>
          <target state="translated">Просто бросай:</target>
        </trans-unit>
        <trans-unit id="2c773194ea026cc993e378f1446632013f32a420" translate="yes" xml:space="preserve">
          <source>Note that casting to &lt;code&gt;e2&lt;/code&gt; also works! From the compiler perspective above this makes sense: the &lt;code&gt;value__&lt;/code&gt; field is simply filled with either 5 or 6 and when &lt;code&gt;Console.WriteLine&lt;/code&gt; calls &lt;code&gt;ToString()&lt;/code&gt;, the name of &lt;code&gt;e1&lt;/code&gt; is resolved while the name of &lt;code&gt;e2&lt;/code&gt; is not.</source>
          <target state="translated">Обратите внимание, что приведение к &lt;code&gt;e2&lt;/code&gt; также работает! С точки зрения компилятора выше это имеет смысл: поле &lt;code&gt;value__&lt;/code&gt; просто заполняется 5 или 6, и когда &lt;code&gt;Console.WriteLine&lt;/code&gt; вызывает &lt;code&gt;ToString()&lt;/code&gt; , имя &lt;code&gt;e1&lt;/code&gt; разрешается, а имя &lt;code&gt;e2&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="569ada5fc09d3eeddae46ad081c41b68fabf7331" translate="yes" xml:space="preserve">
          <source>Note that this assumes that the underlying type of the &lt;code&gt;enum&lt;/code&gt; is a signed 32-bit integer. If it were a different numerical type, you'd have to change the hardcoded 32 to reflect the bits in that type (or programatically derive it using &lt;code&gt;Enum.GetUnderlyingType()&lt;/code&gt;)</source>
          <target state="translated">Обратите внимание, что это предполагает, что базовый тип &lt;code&gt;enum&lt;/code&gt; является 32-разрядным целым числом со знаком. Если бы это был другой числовой тип, вам пришлось бы изменить жестко закодированный 32, чтобы отразить биты этого типа (или получить его программным путем, используя &lt;code&gt;Enum.GetUnderlyingType()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b3179c75c3fd8315efa725c8e57bb612845936a4" translate="yes" xml:space="preserve">
          <source>Note that using IsDefined is costly and even more than just casting, so it depends on your implementation to decide to use it or not.</source>
          <target state="translated">Обратите внимание,что использование IsDefined дорого и даже больше,чем просто литье,поэтому решение об использовании IsDefined зависит от вашей реализации.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="cb46ab1740f0e8d608e38f895692a452d2b8b436" translate="yes" xml:space="preserve">
          <source>Obviously, some of the enum type functionality will be lost, but for storing a bunch of database id constants, it seems like a pretty tidy solution.</source>
          <target state="translated">Очевидно,что часть функциональности enum-типа будет утеряна,но для хранения кучи идентификационных констант БД это кажется довольно аккуратным решением.</target>
        </trans-unit>
        <trans-unit id="2787dadf2ebcf4ca566176af819017f9f6a66212" translate="yes" xml:space="preserve">
          <source>Slightly getting away from the original question, but I found &lt;a href=&quot;https://stackoverflow.com/a/11057004/429973&quot;&gt;an answer to Stack&amp;nbsp;Overflow question &lt;em&gt;Get int value from enum&lt;/em&gt;&lt;/a&gt; useful. Create a static class with &lt;code&gt;public const int&lt;/code&gt; properties, allowing you to easily collect together a bunch of related &lt;code&gt;int&lt;/code&gt; constants, and then not have to cast them to &lt;code&gt;int&lt;/code&gt; when using them.</source>
          <target state="translated">Немного отойдя от исходного вопроса, но я нашел &lt;a href=&quot;https://stackoverflow.com/a/11057004/429973&quot;&gt;ответ на вопрос переполнения стека.&lt;/a&gt; Полезно &lt;em&gt;получить значение int из enum&lt;/em&gt; . Создайте статический класс с &lt;code&gt;public const int&lt;/code&gt; свойствами const int , что позволит вам легко собирать кучу связанных констант &lt;code&gt;int&lt;/code&gt; , а затем не нужно приводить их к &lt;code&gt;int&lt;/code&gt; при их использовании.</target>
        </trans-unit>
        <trans-unit id="41341fed4fc5135c7817e04c2934f4db99145db9" translate="yes" xml:space="preserve">
          <source>So, if you have an integer that you want to map to an enum, the runtime only has to do 2 things: copy the 4 bytes and name it something else (the name of the enum). Copying is implicit because the data is stored as value type - this basically means that if you use unmanaged code, you can simply interchange enums and integers without copying data.</source>
          <target state="translated">Итак,если у вас есть целое число,которое вы хотите сопоставить с перечислением,то во время выполнения нужно сделать только 2 вещи:скопировать 4 байта и назвать ему что-нибудь другое (имя перечисления).Копирование неявно,потому что данные хранятся как тип значения-это в основном означает,что если вы используете неуправляемый код,вы можете просто обмениваться перечислениями и целыми числами без копирования данных.</target>
        </trans-unit>
        <trans-unit id="545ab5091363b3b680b64a4657255d140cb67922" translate="yes" xml:space="preserve">
          <source>Sometimes you have an object to the &lt;code&gt;MyEnum&lt;/code&gt; type. Like</source>
          <target state="translated">Иногда у вас есть объект типа &lt;code&gt;MyEnum&lt;/code&gt; . подобно</target>
        </trans-unit>
        <trans-unit id="4e5c1cb438afe66a7a3ce7f0162632afd0f40816" translate="yes" xml:space="preserve">
          <source>Take the following example:</source>
          <target state="translated">Возьмем следующий пример:</target>
        </trans-unit>
        <trans-unit id="2d77855a284dd03f6fdaf1a7d511a263b8079230" translate="yes" xml:space="preserve">
          <source>Test Case</source>
          <target state="translated">Тестовый случай</target>
        </trans-unit>
        <trans-unit id="4be24070f4f24438345c01c626b6fdfd6542d435" translate="yes" xml:space="preserve">
          <source>The code goes as shown below where &quot;red&quot; is the string and &quot;MyColors&quot; is the color ENUM which has the color constants.</source>
          <target state="translated">Код выглядит так,как показано ниже,где &quot;red&quot;-строка,а &quot;MyColors&quot;-цвет ENUM,имеющий константы цвета.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="e1ceff90c2d44b022434871989ecfc3d783a6af6" translate="yes" xml:space="preserve">
          <source>This is an flags enumeration aware safe convert method:</source>
          <target state="translated">Это флаг перечисления знает безопасный метод преобразования:</target>
        </trans-unit>
        <trans-unit id="2f886dad395648b4e15cc32acf1f9703992e4e5b" translate="yes" xml:space="preserve">
          <source>This parses integers or strings to a target enum with partial matching in dot.NET 4.0 using generics like in Tawani's utility class above.  I am using it to convert command-line switch variables which may be incomplete.  Since an enum cannot be null, you should logically provide a default value.  It can be called like this:</source>
          <target state="translated">Он разбирает целые числа или строки в целевом перечислении с частичным совпадением в dot.NET 4.0,используя дженерики,как в классе утилит Тавани,описанном выше.Я использую его для преобразования переменных переключателя командной строки,которые могут быть неполными.Поскольку перечисление не может быть нулевым,логически следует указать значение по умолчанию.Оно может быть вызвано следующим образом:</target>
        </trans-unit>
        <trans-unit id="e19c993984f6dd6f758fe2a09db7defa6fe45d59" translate="yes" xml:space="preserve">
          <source>To convert a string to ENUM or int to ENUM constant we need to use Enum.Parse function. Here is a youtube video &lt;a href=&quot;https://www.youtube.com/watch?v=4nhx4VwdRDk&quot;&gt;https://www.youtube.com/watch?v=4nhx4VwdRDk&lt;/a&gt;  which actually demonstrate's with string and the same applies for int.</source>
          <target state="translated">Чтобы преобразовать строку в ENUM или int в константу ENUM, нам нужно использовать функцию Enum.Parse. Вот YouTube видео &lt;a href=&quot;https://www.youtube.com/watch?v=4nhx4VwdRDk&quot;&gt;https://www.youtube.com/watch?v=4nhx4VwdRDk,&lt;/a&gt; которое фактически демонстрирует со строкой, и то же самое относится к int.</target>
        </trans-unit>
        <trans-unit id="a68345d4247855f0ef61c33db7f1d7fc5da8f76c" translate="yes" xml:space="preserve">
          <source>To make it safe, I think it's a best practice to &lt;strong&gt;know that the underlying types are the same or implicitly convertible&lt;/strong&gt; and to ensure the enum values exist (they aren't checked by default!).</source>
          <target state="translated">Чтобы сделать это безопасным, я думаю, что лучше всего &lt;strong&gt;знать, что базовые типы являются одинаковыми или неявно конвертируемыми,&lt;/strong&gt; и гарантировать, что значения перечисления существуют (они не проверяются по умолчанию!).</target>
        </trans-unit>
        <trans-unit id="23a5d50f7d560683b09aeb6eb136065dad2c6c30" translate="yes" xml:space="preserve">
          <source>To make sure that you only cast the right values ​​and that you can throw an exception otherwise:</source>
          <target state="translated">Чтобы убедиться,что вы только бросаете правильные значения и что вы можете бросить исключение в противном случае:</target>
        </trans-unit>
        <trans-unit id="47face85db7011031f48f02a22cd9a272203d89f" translate="yes" xml:space="preserve">
          <source>To see how this works, try the following code:</source>
          <target state="translated">Чтобы посмотреть,как это работает,попробуйте следующий код:</target>
        </trans-unit>
        <trans-unit id="fe32a38f013c13127d95cbb21b75c9f2a3ff7ff0" translate="yes" xml:space="preserve">
          <source>What should get your attention here is that the &lt;code&gt;value__&lt;/code&gt; is stored separately from the enum values. In the case of the enum &lt;code&gt;Foo&lt;/code&gt; above, the type of &lt;code&gt;value__&lt;/code&gt; is int16. This basically means that you can store whatever you want in an enum, &lt;strong&gt;as long as the types match&lt;/strong&gt;.</source>
          <target state="translated">Здесь следует обратить внимание на то, что значение &lt;code&gt;value__&lt;/code&gt; хранится отдельно от значений перечисления. В случае перечисления &lt;code&gt;Foo&lt;/code&gt; , приведенного выше, тип значения &lt;code&gt;value__&lt;/code&gt; int16. По сути, это означает, что вы можете хранить в перечислении все, что хотите, &lt;strong&gt;при условии совпадения типов&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="75195f05ea43ea70c38131eb9ea13a4996f5e578" translate="yes" xml:space="preserve">
          <source>You can check if it's in range using &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.enum.isdefined.aspx&quot;&gt;Enum.IsDefined&lt;/a&gt;:</source>
          <target state="translated">Вы можете проверить, находится ли он в диапазоне, используя &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.enum.isdefined.aspx&quot;&gt;Enum.IsDefined&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0de1bc194347a91c21a17c2e5bfacb51ce958521" translate="yes" xml:space="preserve">
          <source>You just do like below:</source>
          <target state="translated">Ты просто делаешь,как внизу:</target>
        </trans-unit>
        <trans-unit id="6994803e241f1afbcedb1ae8f1f21f8c4838e50b" translate="yes" xml:space="preserve">
          <source>You need to change parsing at helper method from</source>
          <target state="translated">Вам нужно изменить метод разбора в справочнике с</target>
        </trans-unit>
        <trans-unit id="a0c0f2e9958eee84b504206d7affb17281468c3c" translate="yes" xml:space="preserve">
          <source>You should build in some type matching relaxation to be more robust.</source>
          <target state="translated">Вы должны построить в какой-то тип релаксации,чтобы быть более прочным.</target>
        </trans-unit>
        <trans-unit id="60a7352b0fac243c1417c6c97b157eab5c9c4dc2" translate="yes" xml:space="preserve">
          <source>You simply use &lt;strong&gt;Explicit conversion&lt;/strong&gt; Cast int to enum or enum to int</source>
          <target state="translated">Вы просто используете &lt;strong&gt;явное преобразование&lt;/strong&gt; Cast int в enum или enum в int</target>
        </trans-unit>
        <trans-unit id="26c332d9cd21581be5a14d1f84b9f1527eaca082" translate="yes" xml:space="preserve">
          <source>sorry for my english</source>
          <target state="translated">простите за мой английский</target>
        </trans-unit>
        <trans-unit id="1d21a26520b48d93a5e79674e2985df9e6cc8bee" translate="yes" xml:space="preserve">
          <source>the easy and clear way for casting an int to enum in c#:</source>
          <target state="translated">простой и понятный способ отливки int to enum в c#:</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
