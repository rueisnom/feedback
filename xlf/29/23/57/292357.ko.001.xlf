<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/292357">
    <body>
      <group id="292357">
        <trans-unit id="9fa5c5c74bcc28f7ff899434be6d1efa62244365" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; The command above is the equivalent to &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;. In practice, &lt;code&gt;git fetch&lt;/code&gt; maybe more secure because before the merge we can see the changes and decide whether to merge.</source>
          <target state="translated">위의 명령은 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 와 같습니다. 실제로 병합하기 전에 변경 사항을 확인하고 병합할지 여부를 결정할 수 있기 때문에 &lt;code&gt;git fetch&lt;/code&gt; 는 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="32d8acda1dd72cb4e3ce43954e543e4a3da0d07f" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; The commands above mean that download latest version of the main branch from origin from the remote to origin master branch. And then compares the local master branch and origin master branch. Finally, merge.</source>
          <target state="translated">위의 명령은 원점에서 원점 마스터 지점으로 최신 버전의 기본 지점을 다운로드 함을 의미합니다. 그런 다음 로컬 마스터 분기와 원본 마스터 분기를 비교합니다. 마지막으로 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="48f97e1dc3e1ee5a10ffd97cdf92f6d652c37e14" translate="yes" xml:space="preserve">
          <source>(inside-repo operation) &lt;code&gt;remote/origin/master@local &amp;gt;&amp;gt; master@local&lt;/code&gt;</source>
          <target state="translated">(내부 리포지토리 작업) &lt;code&gt;remote/origin/master@local &amp;gt;&amp;gt; master@local&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fa9cf27a8e4a9c6a7b0b129563967146c119b54" translate="yes" xml:space="preserve">
          <source>(repo to repo operation) &lt;code&gt;master@remote &amp;gt;&amp;gt; remote/origin/master@local&lt;/code&gt;</source>
          <target state="translated">(repo to repo operation) &lt;code&gt;master@remote &amp;gt;&amp;gt; remote/origin/master@local&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5432acc46382d221828b84d9bafa1cde6a4ba9bf" translate="yes" xml:space="preserve">
          <source>1) git pull ( rebase will done automatically):</source>
          <target state="translated">1) git pull (리베이스가 자동으로 수행됩니다) :</target>
        </trans-unit>
        <trans-unit id="5a66cdfb6968d483b06aeeba82c490dbf2550d78" translate="yes" xml:space="preserve">
          <source>2) git fetch (need to rebase manually):</source>
          <target state="translated">2) git fetch (수동으로 리베이스해야 함) :</target>
        </trans-unit>
        <trans-unit id="0d3bd84264ca1b2c8f691ecc7555b9bee9c17c48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git clone&lt;/code&gt; clones a repo.</source>
          <target state="translated">&lt;code&gt;git clone&lt;/code&gt; 은 repo를 복제합니다.</target>
        </trans-unit>
        <trans-unit id="5328124c67a16a351ef68bf92f8f591e1c77c394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; brings your local copy of the remote repository up to date. For example, if your remote repository is GitHub - you may want to fetch any changes made in the remote repository to your local copy of it the remote repository. This will allow you to perform operations such as compare or merge.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 는 원격 저장소의 로컬 사본을 최신 상태로 만듭니다. 예를 들어, 원격 저장소가 GitHub 인 경우 원격 저장소에서 작성된 변경 사항을 원격 저장소의 로컬 사본으로 가져 오려고 할 수 있습니다. 이를 통해 비교 또는 병합과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45716d867c97c93141fd633174f0b1e9b5c4f243" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; is similar to &lt;code&gt;pull&lt;/code&gt; but doesn't merge. i.e. it fetches remote updates (&lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;) but your local stays the same (i.e. &lt;code&gt;origin/master&lt;/code&gt; gets updated but &lt;code&gt;master&lt;/code&gt; stays the same) .</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 는 &lt;code&gt;pull&lt;/code&gt; 과 비슷하지만 병합되지 않습니다. 즉, 원격 업데이트 ( &lt;code&gt;refs&lt;/code&gt; 및 &lt;code&gt;objects&lt;/code&gt; )를 가져 오지만 로컬은 동일하게 유지됩니다 (예 : &lt;code&gt;origin/master&lt;/code&gt; 는 업데이트되지만 &lt;code&gt;master&lt;/code&gt; 는 동일 함).</target>
        </trans-unit>
        <trans-unit id="961114afa0561cd3fae7d954b2c0f6de44de1cd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; just &quot;downloads&quot; the changes from the remote to your local repository. &lt;code&gt;git pull&lt;/code&gt; downloads the changes and merges them into your current branch. &quot;In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 는 원격에서 로컬 저장소로 변경 사항을 &quot;다운로드&quot;합니다. &lt;code&gt;git pull&lt;/code&gt; 은 변경 사항을 다운로드하여 현재 분기에 병합합니다. &quot;기본 모드에서 &lt;code&gt;git pull&lt;/code&gt; 은 &lt;code&gt;git fetch&lt;/code&gt; 의 약어이며 &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; 입니다.&quot;</target>
        </trans-unit>
        <trans-unit id="851e511f1a09665acd6e13d5277de7a31c182eb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; only fetches from the remote branch but it does not merge</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 는 원격 브랜치에서만 페치하지만 병합하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ce94279a6dadc28b7a0ecb75dade36111b4a373" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; pulls down the code from the remote server to your tracking branches in your local repository.  If your remote is named &lt;code&gt;origin&lt;/code&gt; (the default) then these branches will be within &lt;code&gt;origin/&lt;/code&gt;, for example &lt;code&gt;origin/master&lt;/code&gt;, &lt;code&gt;origin/mybranch-123&lt;/code&gt;, etc.  These are not your current branches, they are &lt;em&gt;local&lt;/em&gt; copies of those branches from the server.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 는 원격 서버에서 로컬 리포지토리의 추적 분기로 코드를 가져 옵니다. 원격의 이름이 &lt;code&gt;origin&lt;/code&gt; (기본값) 인 경우 이러한 분기는 &lt;code&gt;origin/&lt;/code&gt; 내에 있습니다 (예 : &lt;code&gt;origin/master&lt;/code&gt; , &lt;code&gt;origin/mybranch-123&lt;/code&gt; 등). 현재 분기가 아니며 서버에서 해당 분기의 &lt;em&gt;로컬&lt;/em&gt; 사본입니다. .</target>
        </trans-unit>
        <trans-unit id="80fe18c4b4632e89609525d07897b4e58d6f487a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; will retrieve remote branches so that you can &lt;code&gt;git diff&lt;/code&gt; or &lt;code&gt;git merge&lt;/code&gt; them with the current branch. &lt;code&gt;git pull&lt;/code&gt; will run fetch on the remote brach tracked by the current branch and then merge the result. You can use &lt;code&gt;git fetch&lt;/code&gt; to see if there are any updates to the remote branch without necessary merging them with your local branch.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 는 원격 분기를 검색하여 현재 분기와 &lt;code&gt;git diff&lt;/code&gt; 또는 &lt;code&gt;git merge&lt;/code&gt; 할 수 있습니다. &lt;code&gt;git pull&lt;/code&gt; 은 현재 브랜치에 의해 추적 된 원격 brach에서 페치를 실행 한 다음 결과를 병합합니다. &lt;code&gt;git fetch&lt;/code&gt; 를 사용하면 로컬 브랜치와 병합하지 않고도 원격 브랜치에 대한 업데이트가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3917ec46fc6b54ce2e06c114c3417324b75b2a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; does a &lt;code&gt;git fetch&lt;/code&gt; but then &lt;strong&gt;also&lt;/strong&gt; merges the code from the tracking branch into your current local version of that branch.  If you're not ready for that changes yet, just &lt;code&gt;git fetch&lt;/code&gt; first.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 은 &lt;code&gt;git fetch&lt;/code&gt; 를 수행 하지만 추적 브랜치의 코드를 해당 브랜치의 현재 로컬 버전으로 병합합니다. 아직 변경 사항이 없으면 &lt;code&gt;git fetch&lt;/code&gt; 를 먼저 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="83dddb338f277eb811f3fa092c792988c4cc0880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; is &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 은 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d4710698ef543c45dfe252e6667d70d2de5401d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; on the other hand will bring down the changes in the remote repository to where you keep your own code. Typically, &lt;code&gt;git pull&lt;/code&gt; will do a &lt;code&gt;git fetch&lt;/code&gt; first to bring the local copy of the remote repository up to date, and then it will merge the changes into your own code repository and possibly your working copy.</source>
          <target state="translated">반면에 &lt;code&gt;git pull&lt;/code&gt; 은 원격 저장소의 변경 사항을 자신의 코드를 유지하는 위치로 가져옵니다. 일반적으로 &lt;code&gt;git pull&lt;/code&gt; 은 먼저 &lt;code&gt;git fetch&lt;/code&gt; 를 수행하여 원격 저장소의 로컬 사본을 최신 상태로 가져온 다음 변경 사항을 자신의 코드 저장소 및 작업 사본에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="05df4cf0322b9f13dcf1c7d31f7a70fd4b89be02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; pulls down from a remote and instantly merges.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 은 리모컨에서 당겨져 즉시 합쳐집니다.</target>
        </trans-unit>
        <trans-unit id="b05d4c0fb36f1dc05bc99a501e4370779ab4899c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; pulls from a remote branch and merges it.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 은 원격 브랜치에서 당겨서 병합합니다.</target>
        </trans-unit>
        <trans-unit id="39b7979eb508edf5865501e23b13e6d4fb9fdf23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase&lt;/code&gt; saves stuff from your current branch that isn't in the upstream branch to a temporary area. Your branch is now the same as before you started your changes. So, &lt;code&gt;git pull -rebase&lt;/code&gt; will pull down the remote changes, rewind your local branch, replay your changes over the top of your current branch one by one until you're up-to-date.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; 는 현재 브랜치에서 업스트림 브랜치에없는 것을 임시 영역으로 저장합니다. 이제 브랜치는 변경을 시작하기 전과 동일합니다. 따라서 &lt;code&gt;git pull -rebase&lt;/code&gt; 는 원격 변경 사항을 풀다운하고 로컬 브랜치를 되 감고 최신 브랜치까지 최신 브랜치 상단에서 변경 사항을 하나씩 재생합니다.</target>
        </trans-unit>
        <trans-unit id="4eb4921d4ad3bfa6eaa086e761647f7cd8553d22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ls&lt;/code&gt;. This will show the files &amp;amp; directories. Nothing cool, I know.</source>
          <target state="translated">. 파일 및 디렉토리가 표시됩니다. 시원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca25b56131b611133fad2dd0dd2d7dfa45581e04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any&lt;/em&gt;&lt;code&gt;git fetch&lt;/code&gt; that you do will update items in the &lt;code&gt;/.git/refs/remotes&lt;/code&gt; directory. It won't update anything in the &lt;code&gt;/.git/refs/heads&lt;/code&gt; directory.</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; &lt;code&gt;git fetch&lt;/code&gt; 는 &lt;code&gt;/.git/refs/remotes&lt;/code&gt; 디렉토리의 항목을 업데이트합니다. &lt;code&gt;/.git/refs/heads&lt;/code&gt; 디렉토리의 내용은 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a0c6624b35faf750cddb1f5c5e4877ebc30bedd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any&lt;/em&gt;&lt;code&gt;git pull&lt;/code&gt; will first do the &lt;code&gt;git fetch&lt;/code&gt;, update items in the &lt;code&gt;/.git/refs/remotes&lt;/code&gt; directory, then merge with your local and then change the head inside the &lt;code&gt;/.git/refs/heads&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 은 먼저 &lt;code&gt;git fetch&lt;/code&gt; 를 수행하고 &lt;code&gt;/.git/refs/remotes&lt;/code&gt; 디렉토리의 항목을 업데이트 한 다음 로컬과 병합 한 다음 &lt;code&gt;/.git/refs/heads&lt;/code&gt; 디렉토리 내에서 헤드를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="109168d936934938ef5217cf8bb337f828295f00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Git Fetch-&lt;/strong&gt; This will Download all the changes that have been made to the origin/main branch project which are not present in your local branch. And will wait for the Git Merge command to apply the changes that have been fetched to your Repository or branch.</source>
          <target state="translated">&lt;strong&gt;1. Git Fetch &amp;ndash;&lt;/strong&gt; 로컬 브랜치에없는 원산지 / 본점 프로젝트에 대한 모든 변경 사항을 다운로드합니다. 그리고 Git Merge 명령이 리포지토리 또는 브랜치에 가져온 변경 사항을 적용 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="c5bed844ff8564d2a50b21639fd4cdf812e9f691" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Git Pull-&lt;/strong&gt; This will update your local branch with the origin/main branch i.e. actually what it does is combination of Git Fetch and Git merge one after another.
&lt;em&gt;But this may Cause Conflicts to occur, so it&amp;rsquo;s recommended to use Git Pull with a clean copy.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;2. Git Pull-&lt;/strong&gt; 로컬 브랜치를 원점 / 메인 브랜치로 업데이트합니다. 즉, 실제로 Git Fetch와 Git의 조합이 차례로 수행됩니다. &lt;em&gt;그러나 이로 인해 충돌이 발생할 수 있으므로 깨끗한 복사본과 함께 Git Pull을 사용하는 것이 좋습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bcbfd0fcb10b979a3e0380830ef7bab24a1e334" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git fetch&lt;/code&gt;&lt;/strong&gt; is the command that says &quot;bring my local copy of the remote repository up to date.&quot;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git fetch&lt;/code&gt; &lt;/strong&gt; 는 &quot;원격 저장소의 로컬 사본을 최신으로 가져 오십시오&quot;라는 명령입니다.</target>
        </trans-unit>
        <trans-unit id="8b77648ec75a644255f4be7f9dd3cb5598cd48b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull --rebase&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e785d95f0de347a936e7fda7fa2fa1299834bbee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/strong&gt; says &quot;bring the changes in the remote repository to where I keep my own code.&quot;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull&lt;/code&gt; &lt;/strong&gt; 은 &quot;원격 저장소를 변경하여 자신의 코드를 유지하는 위치로 가져옵니다&quot;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="5cb04c6741b8235615793d873684b0584c2a364e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Briefly&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Briefly&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ad1a5b0818ff680ca2bd9af2799ba236a6251f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Feedback&lt;/strong&gt; about the state of your local repo (for example, I use Atlassian's SourceTree, which will give me a bulb indicating if I'm commits ahead or behind compared to the origin. This information can be updated with a GIT FETCH).</source>
          <target state="translated">로컬 리포지토리의 상태에 대한 &lt;strong&gt;의견&lt;/strong&gt; (예 : Atlassian의 SourceTree을 사용하여 출발지에 비해 앞뒤로 커밋하는지 여부를 나타내는 전구를 제공합니다.이 정보는 GIT FETCH로 업데이트 할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="f0d9c19e498edc94e1533273e0bc1b76808e356c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Git Fetch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;힘내 가져 오기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="014ba1d3cfaa64368fbfa37d5c4581345df5482f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Git Merge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;힘내 병합&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b07aaa0e6c31283c67bd262473d1a745931ce6c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Git Pull&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;힘내 당겨&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c98fe5935ce702c3af246dd6b37f9baf9e499b48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;More&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4071b6245e334d89c25a82984cc4f9f97267d26a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK&lt;/strong&gt;, here are some information about &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt;, so you can understand the actual differences... in few simple words, &lt;strong&gt;fetch&lt;/strong&gt; gets the latest data, but not the code changes and not going to mess with your current  local branch code, but &lt;strong&gt;pull&lt;/strong&gt; get the code changes and merge it your local branch, read on to get more details about each:</source>
          <target state="translated">&lt;strong&gt;OK&lt;/strong&gt; , 여기에 &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git fetch&lt;/code&gt; 에 대한 정보가 있습니다. 그래서 실제 차이점을 이해할 수 있습니다 ... 몇 가지 간단한 단어로 &lt;strong&gt;fetch&lt;/strong&gt; 는 최신 데이터를 가져 오지만 코드 변경은 아니며 현재 로컬 분기 코드를 망칠 수는 없습니다. 코드 변경 사항을 &lt;strong&gt;가져&lt;/strong&gt; 와서 로컬 브랜치와 병합하십시오. 각 코드에 대한 자세한 내용을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="d0ef5f55593d457090b8bc8d4819537557ea3aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt; (scroll through all commits and messages without trying to squeeze it through the network)</source>
          <target state="translated">&lt;strong&gt;성능&lt;/strong&gt; (네트워크를 통해 압축하지 않고 모든 커밋 및 메시지를 스크롤)</target>
        </trans-unit>
        <trans-unit id="3fe24c79e200adaf76506563aeba6a1edd56ce9a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;git pull&lt;/code&gt; is what you would do to bring a local branch up-to-date with its remote version, while also updating your other remote-tracking branches.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 은 원격 버전으로 로컬 브랜치를 최신 상태로 유지하고 다른 원격 추적 브랜치를 업데이트하기 위해 수행하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="6ddcfdae5fbd3c1f28805473e15e964fe04d16f4" translate="yes" xml:space="preserve">
          <source>A simple Graphical Representation for Beginners,</source>
          <target state="translated">초보자를위한 간단한 그래픽 표현</target>
        </trans-unit>
        <trans-unit id="d52324965c9a6e58203263aaced4ecde8fd71b80" translate="yes" xml:space="preserve">
          <source>A very good related answer can also be found in &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27554859/where-does-git-fetch-place-itself/27555444#27555444&quot;&gt;Where does 'git fetch' place itself?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27554859/where-does-git-fetch-place-itself/27555444#27555444&quot;&gt;'git fetch'&lt;/a&gt;&lt;/em&gt; 는 &lt;em&gt;어디에 위치합니까?&lt;/em&gt; 에서 매우 좋은 관련 답변을 찾을 수 있습니다 &lt;em&gt;.&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dc500d77391d46e00d7b5c782a0ab25e90841a89" translate="yes" xml:space="preserve">
          <source>After downloading the updates, let's see the differences:</source>
          <target state="translated">업데이트를 다운로드 한 후 차이점을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="edf3db0309e01a8bcd864ab261176a621ee80299" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;git branch -a&lt;/code&gt; will show you exactly what&amp;rsquo;s going on with all your branches - local and remote.</source>
          <target state="translated">또한 &lt;code&gt;git branch -a&lt;/code&gt; 는 로컬 및 원격의 모든 브랜치에서 진행중인 작업을 정확하게 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="322c738050a772ccaa4aa6d80ca6d3abb420d9f8" translate="yes" xml:space="preserve">
          <source>Also, look for &quot;Slash notation&quot; from the &lt;a href=&quot;http://www.guyroutledge.co.uk/blog/git-branch-naming-conventions/&quot;&gt;Git branch naming conventions&lt;/a&gt; post. It helps you better understand how Git places things in different directories.</source>
          <target state="translated">또한 &lt;a href=&quot;http://www.guyroutledge.co.uk/blog/git-branch-naming-conventions/&quot;&gt;Git 브랜치 명명 규칙&lt;/a&gt; 게시물에서 &quot;슬래시 표기법&quot;을 찾으십시오. Git이 다른 디렉토리에 물건을 배치하는 방법을 더 잘 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="f35d76827c3b43e78eae4be69f5a31adb50d9eed" translate="yes" xml:space="preserve">
          <source>Before pushing your new commits to server, try this command and it will automatically sync latest server changes (with a fetch + merge) and will place your commit at the top in git log. No need to worry about manual pull/merge.</source>
          <target state="translated">새 커밋을 서버로 푸시하기 전에이 명령을 시도하면 최신 서버 변경 사항 (페치 + 병합)을 자동으로 동기화하고 커밋을 git 로그의 맨 위에 놓습니다. 수동 풀 / 병합에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="c20f309c89ab318ccde630455b592cf9a45e630d" translate="yes" xml:space="preserve">
          <source>But that's outdated and incorrect. It's because git will give you feedback solely based on what it knows. It's oblivious to new commits that it hasn't pulled down yet...</source>
          <target state="translated">그러나 그것은 구식이며 틀 렸습니다. git이 알고있는 것에 기초하여 피드백을 제공하기 때문입니다. 아직 풀리지 않은 새로운 커밋은 분명하지 않습니다 ...</target>
        </trans-unit>
        <trans-unit id="32155eafe73839b32c5ef69bafc03d8a5d24c849" translate="yes" xml:space="preserve">
          <source>By default, any tag that points into the histories being fetched is
  also fetched; the effect is to fetch tags that point at branches that
  you are interested in. This default behavior can be changed by using
  the --tags or --no-tags options or by configuring
  remote..tagOpt. By using a refspec that fetches tags explicitly,
  you can fetch tags that do not point into branches you are interested
  in as well.</source>
          <target state="translated">기본적으로 페치되는 히스토리를 가리키는 모든 태그도 페치됩니다. 효과는 원하는 분기를 가리키는 태그를 가져 오는 것입니다.이 기본 동작은 --tags 또는 --no-tags 옵션을 사용하거나 remote..tagOpt를 구성하여 변경할 수 있습니다. 태그를 명시 적으로 가져 오는 참조 사양을 사용하면 관심있는 분기를 가리 키지 않는 태그를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80ad85601183f99deb766161879cf4b25512ba7c" translate="yes" xml:space="preserve">
          <source>Copying new commits from remote branch to copy of this remote branch inside local repo.</source>
          <target state="translated">원격 지사에서 새 커밋을 복사하여 로컬 리포지토리 내의이 원격 지사를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="d537056fde34a1ba692f4e1ab02d8e216af2a6ff" translate="yes" xml:space="preserve">
          <source>Default values for  and  are read from the
  &quot;remote&quot; and &quot;merge&quot; configuration for the current branch as set by
  git-branch --track.</source>
          <target state="translated">git-branch --track에 의해 설정된 현재 분기의 &quot;원격&quot;및 &quot;병합&quot;구성에 대한 기본값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="4d979b1dc2b994c6f4248ba041d7bd399d114087" translate="yes" xml:space="preserve">
          <source>Do &lt;code&gt;cd .git&lt;/code&gt;. This will obviously change your directory.</source>
          <target state="translated">&lt;code&gt;cd .git&lt;/code&gt; 을 수행하십시오 . 이것은 분명히 디렉토리를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b2bcd7ea07d74b72cfb09e7b0c7e43e3d526a0b8" translate="yes" xml:space="preserve">
          <source>Fetch and merge run together often enough that a command that combines the two, pull, was created. Pull does a fetch and then a merge to add the downloaded commits into your local branch.</source>
          <target state="translated">페치 및 병합은 종종 함께 실행되어 두 개의 풀을 결합하는 명령이 작성됩니다. Pull은 페치 한 다음 병합을 다운로드하여 커밋을 로컬 브랜치에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="045598d48170bf40459b9e12cf8ab0455f608647" translate="yes" xml:space="preserve">
          <source>Fetch branches and/or tags (collectively, &quot;refs&quot;) from one or more
  other repositories, along with the objects necessary to complete their
  histories. Remote-tracking branches are updated (see the description
  of  below for ways to control this behavior).</source>
          <target state="translated">히스토리를 완료하는 데 필요한 오브젝트와 함께 하나 이상의 다른 저장소에서 브랜치 및 / 또는 태그 (통칭하여 &quot;참조&quot;)를 가져옵니다. 원격 추적 분기가 업데이트됩니다 (이 동작을 제어하는 ​​방법은 아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="d5f7709dcaf8382e5c15601d64bfe814cf8302eb" translate="yes" xml:space="preserve">
          <source>Fetching is what you do when you want to see what everybody &lt;em&gt;else&lt;/em&gt; has
  been working on. It&amp;rsquo;s similar to SVN update in that it lets you see
  how the central history has progressed, but it doesn&amp;rsquo;t force you to
  actually merge the changes into your repository. Git &lt;strong&gt;isolates
  fetched content as a from existing local content&lt;/strong&gt;, it has absolutely
  &lt;strong&gt;no effect on your local development work&lt;/strong&gt;. Fetched content has to be explicitly checked out using the &lt;code&gt;git checkout&lt;/code&gt; command. This makes
  fetching a safe way to review commits before integrating them with
  your local repository.</source>
          <target state="translated">가져 오기는 &lt;em&gt;다른&lt;/em&gt; 사람들이 작업 한 내용을보고 싶을 때 수행하는 작업입니다. 중앙 기록이 어떻게 진행되었는지 볼 수 있다는 점에서 SVN 업데이트와 비슷하지만 실제로 변경 사항을 저장소에 병합하지는 않습니다. Git은 &lt;strong&gt;가져온 로컬 컨텐츠를 기존 로컬 컨텐츠와 분리&lt;/strong&gt; 하므로 &lt;strong&gt;로컬 개발 작업에는 전혀 영향을 미치지 않습니다&lt;/strong&gt; . 가져온 컨텐츠는 &lt;code&gt;git checkout&lt;/code&gt; 명령을 사용하여 명시 적으로 체크 아웃해야합니다. 이를 통해 커밋을 커밋하여 로컬 리포지토리와 커밋하기 전에 커밋을 검토 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a094f4d7d41c2764c2f031fe68c19f7697500e17" translate="yes" xml:space="preserve">
          <source>Find details at: &lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;http://gitolite.com/git-pull--rebase&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;http://gitolite.com/git-pull--rebase를 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80a2b7deffd7046895901f3b9b3abd6954530694" translate="yes" xml:space="preserve">
          <source>For more on that read &lt;a href=&quot;https://stackoverflow.com/a/56464547/5175709&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">이에 대한 자세한 내용은 &lt;a href=&quot;https://stackoverflow.com/a/56464547/5175709&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오</target>
        </trans-unit>
        <trans-unit id="7f570924ec3541da08b064870361aa101628c76d" translate="yes" xml:space="preserve">
          <source>Fork local branch after last common ancestor and add new commits parallel to commits which are unique to local repository, finalized by merging commit, closing the fork.</source>
          <target state="translated">마지막 공통 조상 다음에 로컬 분기를 포크하고 로컬 저장소에 고유 한 커밋에 병렬로 새 커밋을 추가하고 커밋을 병합하여 포크를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="7d246c9f13b103978089851b748ff4135c885e5a" translate="yes" xml:space="preserve">
          <source>From this awesome &lt;a href=&quot;https://www.atlassian.com/git/tutorials/syncing/git-fetch&quot;&gt;Atlassian tutorial&lt;/a&gt;:</source>
          <target state="translated">이 멋진 &lt;a href=&quot;https://www.atlassian.com/git/tutorials/syncing/git-fetch&quot;&gt;Atlassian 튜토리얼에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c99c3c8141446381e894a09ddb5848bec036afb2" translate="yes" xml:space="preserve">
          <source>Fun tip:</source>
          <target state="translated">재미있는 팁 :</target>
        </trans-unit>
        <trans-unit id="23c19ce9cb1070c0d02d571d4b284d1506a224fc" translate="yes" xml:space="preserve">
          <source>Git allows chronologically older commits to be applied after newer commits.
Because of this, the act of transferring commits between repositories is split into two steps:</source>
          <target state="translated">Git을 사용하면 새로운 커밋 후에 연대순으로 오래된 커밋을 적용 할 수 있습니다. 이 때문에 리포지토리간에 커밋을 전송하는 작업은 두 단계로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="92421bf16a875aff738a77da925b0817f0f4f80a" translate="yes" xml:space="preserve">
          <source>Git documentation &amp;ndash; &lt;a href=&quot;http://git-scm.com/docs/git-pull&quot;&gt;&lt;strong&gt;git pull&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">Git 문서 &amp;ndash; &lt;a href=&quot;http://git-scm.com/docs/git-pull&quot;&gt;&lt;strong&gt;git pull&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fd037a056ee9a0a3ea17523512de78c92b929629" translate="yes" xml:space="preserve">
          <source>Git obtains the branch of the latest version from the remote to the local using two commands:</source>
          <target state="translated">Git은 두 가지 명령을 사용하여 원격에서 로컬로 최신 버전의 분기를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="033bc0378830e2cbf48b95032ab89e679a08ff04" translate="yes" xml:space="preserve">
          <source>Git was designed to support a more distributed model with no need for a central repository (though you can certainly use one if you like). Also git was designed so that the client and the &quot;server&quot; don't need to be online at the same time. Git was designed so that people on an unreliable link could exchange code via email, even. It is possible to work completely disconnected and burn a CD to exchange code via git.</source>
          <target state="translated">Git은 중앙 저장소가 없어도보다 분산 된 모델을 지원하도록 설계되었습니다 (원하는 경우 확실히 사용할 수 있음). 또한 git은 클라이언트와 &quot;서버&quot;가 동시에 온라인 일 필요가 없도록 설계되었습니다. Git은 신뢰할 수없는 링크에있는 사람들이 이메일을 통해 코드를 교환 할 수 있도록 설계되었습니다. 완전히 분리 된 상태로 작업하고 CD를 구워서 git을 통해 코드를 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ce3409127465b71688de3971e312b082f6febd2" translate="yes" xml:space="preserve">
          <source>Great question. It puts it somewhere isolated from your working copy. But again where? Let's find out.</source>
          <target state="translated">좋은 질문입니다. 작업 복사본과 분리되어 있습니다. 그러나 다시 어디? 알아 보자.</target>
        </trans-unit>
        <trans-unit id="89be5c989f1e0a130d56642cfc8383c35bd91fe4" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;http://blog.osteele.com/2008/05/my-git-workflow/&quot;&gt;Oliver Steele's image of how all it all fits together&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://blog.osteele.com/2008/05/my-git-workflow/&quot;&gt;올리버 스틸 (Oliver Steele)의 모든 이미지가 어떻게 조화를 이루고 있는지에 대한 이미지&lt;/a&gt; 는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce46f607307f3b5fb06075c64f8ceab45279bbdf" translate="yes" xml:space="preserve">
          <source>Hmmm...so if I'm not updating the working copy with &lt;code&gt;git fetch&lt;/code&gt;, then where am I making changes? Where does Git fetch store the new commits?</source>
          <target state="translated">흠 ... 그래서 작업 복사본을 &lt;code&gt;git fetch&lt;/code&gt; 로 업데이트하지 않으면 어디에서 변경합니까? Git 페치는 새로운 커밋을 어디에 저장합니까?</target>
        </trans-unit>
        <trans-unit id="4ffdb142a405417c93bea94964a1c2c08c551de2" translate="yes" xml:space="preserve">
          <source>I also create the &lt;strong&gt;visual&lt;/strong&gt; below to show you how &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; working together...</source>
          <target state="translated">또한 아래 &lt;strong&gt;비주얼&lt;/strong&gt; 을 만들어 &lt;code&gt;git fetch&lt;/code&gt; 와 &lt;code&gt;git pull&lt;/code&gt; 이 어떻게 작동하는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="07e7f9e2e81d32cb59143090feeb634ba03b1447" translate="yes" xml:space="preserve">
          <source>I have struggled with this as well.  In fact I got here with a google search of exactly the same question.  Reading all these answers finally painted a picture in my head and I decided to try to get this down looking at the state of the 2 repositories and 1 sandbox and actions performed over time while watching the version of them.  So here is what I came up with.  Please correct me if I messed up anywhere.</source>
          <target state="translated">나는 이것으로도 어려움을 겪었다. 사실 나는 정확히 같은 질문에 대한 Google 검색으로 여기에 도착했습니다. 이 모든 대답을 읽으면서 마침내 내 머리에 그림이 그려졌고 2 개의 저장소와 1 개의 샌드 박스 상태와 시간이 지남에 따라 수행되는 작업을 버전으로 보면서이 문제를 해결하려고했습니다. 그래서 여기에 내가 생각해 낸 것이 있습니다. 내가 어딘가에 엉망이되면 나를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5b18a32757feffb19b768293f3091d29d27efc26" translate="yes" xml:space="preserve">
          <source>I like to have some visual representation of the situation to grasp these things. Maybe other developers would like to see it too, so here's my addition. I'm not totally sure that it all is correct, so please comment if you find any mistakes.</source>
          <target state="translated">이러한 상황을 파악하기 위해 상황을 시각적으로 표현하고 싶습니다. 다른 개발자들도보고 싶을 수도 있으므로 여기에 추가 내용이 있습니다. 나는 그것이 모두 올바른지 완전히 확신하지 못하므로 실수를 발견하면 의견을 말하십시오.</target>
        </trans-unit>
        <trans-unit id="c7489e43761289e99e5d7079c5c877cffd143154" translate="yes" xml:space="preserve">
          <source>I thought I'd update this to show how you'd actually use this in practice.</source>
          <target state="translated">실제로 이것을 실제로 어떻게 사용하는지 보여주기 위해 이것을 업데이트 할 것이라고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="821bc16e59a841d21fe7b78ce9b776cc6e35c5a5" translate="yes" xml:space="preserve">
          <source>If the remote master was updated you'll get a message like this:</source>
          <target state="translated">원격 마스터가 업데이트 된 경우 다음과 같은 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="68a0bdf0085c0a825e5be3356d84929da9c61aa6" translate="yes" xml:space="preserve">
          <source>If there is sufficient interest, I suppose I could update the image to add &lt;code&gt;git clone&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;...</source>
          <target state="translated">관심이 충분하다면 이미지를 업데이트하여 &lt;code&gt;git clone&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 를 추가 할 수 있다고 가정합니다 ...</target>
        </trans-unit>
        <trans-unit id="37251fa3853fcc0155dc49884f3df2ca33eb64f1" translate="yes" xml:space="preserve">
          <source>If you already have a local repository with a remote set up for the desired project, you can grab all branches and tags for the existing remote using git fetch . ... Fetch does not make any changes to local branches, so you will need to merge a remote branch with a paired local branch to incorporate newly fetch changes. &lt;a href=&quot;https://help.github.com/articles/fetching-a-remote&quot;&gt;from github&lt;/a&gt;</source>
          <target state="translated">원하는 프로젝트에 대해 원격으로 설정된 로컬 저장소가 이미있는 경우 git fetch를 사용하여 기존 원격의 모든 분기 및 태그를 가져올 수 있습니다. ... Fetch는 로컬 브랜치를 변경하지 않으므로 새로 페치 된 변경 사항을 통합하려면 원격 브랜치를 페어링 된 로컬 브랜치와 병합해야합니다. &lt;a href=&quot;https://help.github.com/articles/fetching-a-remote&quot;&gt;github에서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1839fcd4628fab1f58094381ce5dd1ea362da0d4" translate="yes" xml:space="preserve">
          <source>If you didn't &lt;code&gt;fetch&lt;/code&gt; and just did &lt;code&gt;git checkout master&lt;/code&gt; then your local git wouldn't know that there are 2 commits added. And it would just say:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 오지 않고 &lt;code&gt;git checkout master&lt;/code&gt; 를 방금했다면 로컬 git은 2 개의 커밋이 추가되었음을 알 수 없습니다. 그리고 그것은 단지 말할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="2d0b0d005c61420fbde841a3633e861f097628fc" translate="yes" xml:space="preserve">
          <source>If you do a &lt;code&gt;git fetch&lt;/code&gt; it will just fetch all the changes in the remote repository (&lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt;) and move the origin/master pointer to &lt;code&gt;HEAD&lt;/code&gt;. Meanwhile your local branch master will keep pointing to where it has.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 를 수행하면 원격 저장소 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt; )의 모든 변경 사항을 가져오고 origin / master 포인터를 &lt;code&gt;HEAD&lt;/code&gt; 로 이동합니다. 그 동안 현지 지점 마스터는 현재 위치를 계속 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="900ae93a7953ff6e0661ac7270d3ba457b6be9a1" translate="yes" xml:space="preserve">
          <source>If you do a &lt;code&gt;git pull&lt;/code&gt;, it will do basically fetch (as explained previously) and merge any new changes to your master branch and move the pointer to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 을 수행하면 기본적으로 (앞서 설명한 바와 같이) 페치를 수행하고 새로운 변경 사항을 마스터 분기에 병합하고 포인터를 &lt;code&gt;HEAD&lt;/code&gt; 로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="616ab200c6c582d81e3203971545ff215f3fd330" translate="yes" xml:space="preserve">
          <source>If you fetched a remote branch e.g. did:</source>
          <target state="translated">원격 브랜치를 가져온 경우 예를 들어 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="162dce9f88948f751bdbb44bdb42efa008599f93" translate="yes" xml:space="preserve">
          <source>If you find yourself in such a situation, you may be tempted to &lt;code&gt;git pull --rebase&lt;/code&gt;. Unless you really, really know what you are doing, I would advise against that. This warning is from the &lt;code&gt;man&lt;/code&gt; page for &lt;code&gt;git-pull&lt;/code&gt;, version &lt;code&gt;2.3.5&lt;/code&gt;:</source>
          <target state="translated">그러한 상황에 처했다면, &lt;code&gt;git pull --rebase&lt;/code&gt; 를 유혹하고 싶을 수도 있습니다. 당신이 정말로, 당신이 무엇을하고 있는지 정말로 알고 있지 않다면, 나는 그것에 반대 할 것을 권합니다. 이 경고는 &lt;code&gt;git-pull&lt;/code&gt; 버전 &lt;code&gt;2.3.5&lt;/code&gt; 의 &lt;code&gt;man&lt;/code&gt; 페이지에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="39c38a4d2906ce12baf53b8235be890ca9c9a7e6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git pull&lt;/code&gt;, you do not need to merge the data to local. If you run &lt;code&gt;git fetch&lt;/code&gt;, it means you must run &lt;code&gt;git merge&lt;/code&gt; for getting the latest code to your local machine. Otherwise, the local machine code would not be changed without merge.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 을 실행하면 데이터를 로컬에 병합 할 필요가 없습니다. &lt;code&gt;git fetch&lt;/code&gt; 를 실행하면 최신 코드를 로컬 컴퓨터로 가져 오기 위해 &lt;code&gt;git merge&lt;/code&gt; 를 실행해야합니다. 그렇지 않으면 로컬 머신 코드는 병합없이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03ceca134f6aec86433fabaa1e2d3cc64a31e825" translate="yes" xml:space="preserve">
          <source>If you're happy with those updates, then merge:</source>
          <target state="translated">해당 업데이트에 만족하면 다음을 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="d8e1f252c15bb34d9198fe09a84d37f5ede75407" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;git&lt;/code&gt; terminology, step 1 is &lt;code&gt;git fetch&lt;/code&gt;, step 2 is &lt;code&gt;git merge&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 용어에서 1 단계는 &lt;code&gt;git fetch&lt;/code&gt; 이고 2 단계는 &lt;code&gt;git merge&lt;/code&gt; 또는 &lt;code&gt;git rebase&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a1bf2ca7db0931ab25be8665ddf93ce855960e77" translate="yes" xml:space="preserve">
          <source>In addition to pulling and pushing, &lt;a href=&quot;https://web.archive.org/web/20150321185928/http://mettadore.com/2011/09/07/the-ever-deployable-github-workflow//&quot;&gt;some workflows&lt;/a&gt; involve &lt;code&gt;git rebase&lt;/code&gt;, such as this one, which I paraphrase from the linked article:</source>
          <target state="translated">당기기와 밀기 외에도 &lt;a href=&quot;https://web.archive.org/web/20150321185928/http://mettadore.com/2011/09/07/the-ever-deployable-github-workflow//&quot;&gt;일부 워크 플로&lt;/a&gt; 에는 &lt;code&gt;git rebase&lt;/code&gt; 가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e40cd3ac234494a2b0cc543cfa7294ec17721210" translate="yes" xml:space="preserve">
          <source>In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.</source>
          <target state="translated">기본 모드에서 &lt;code&gt;git pull&lt;/code&gt; 은 &lt;code&gt;git fetch&lt;/code&gt; 의 약어이며 &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f7e63b5ace32e92fae98a294e280f5810ef0452" translate="yes" xml:space="preserve">
          <source>In order to support this model git maintains a local repository with your code and also an additional local repository that mirrors the state of the remote repository. By keeping a copy of the remote repository locally, git can figure out the changes needed even when the remote repository is not reachable.  Later when you need to send the changes to someone else, git can transfer them as a set of changes from a point in time known to the remote repository.</source>
          <target state="translated">이 모델을 지원하기 위해 git은 코드와 함께 로컬 리포지토리와 원격 리포지토리의 상태를 미러링하는 추가 로컬 리포지토리를 유지 관리합니다. 원격 저장소의 사본을 로컬로 유지함으로써 git은 원격 저장소에 도달 할 수없는 경우에도 필요한 변경 사항을 파악할 수 있습니다. 나중에 변경 사항을 다른 사람에게 보내야 할 때 git은 변경 사항을 원격 저장소에 알려진 특정 시점에서 변경 세트로 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a10a3f8f133b33ad3434b087c4d2fc83bd4dacf" translate="yes" xml:space="preserve">
          <source>In simple terms, if you were about to hop onto a plane without any Internet connection...before departing you could just do &lt;code&gt;git fetch origin &amp;lt;master&amp;gt;&lt;/code&gt;. It would fetch all the changes into your computer, but keep it separate from your local development/workspace.</source>
          <target state="translated">간단히 말해서, 인터넷에 연결하지 않고 비행기를 타려고한다면 출발하기 전에 &lt;code&gt;git fetch origin &amp;lt;master&amp;gt;&lt;/code&gt; 할 수 있습니다. 모든 변경 사항을 컴퓨터로 가져 오지만 로컬 개발 / 작업 공간과 별도로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="bf5cfd3242ed6010b1fce1f3aa3393b0bfbfe46f" translate="yes" xml:space="preserve">
          <source>In speaking of pull &amp;amp; fetch in the above answers, I would like to share an interesting trick,</source>
          <target state="translated">위의 답변에서 pull &amp;amp; fetch에 대해 흥미로운 트릭을 공유하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="1440ef61d3b0c55e8100941f7cbf808f72aa0deb" translate="yes" xml:space="preserve">
          <source>In the simplest terms, &lt;code&gt;git pull&lt;/code&gt; does a &lt;code&gt;git fetch&lt;/code&gt; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">가장 간단한 용어로, &lt;code&gt;git pull&lt;/code&gt; 은 &lt;code&gt;git fetch&lt;/code&gt; 다음에 &lt;code&gt;git merge&lt;/code&gt; 를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="d9cc282a743496a57679827248fa33a56653ca44" translate="yes" xml:space="preserve">
          <source>In your project directory (i.e., where you do your &lt;code&gt;git&lt;/code&gt; commands) do:</source>
          <target state="translated">프로젝트 디렉토리에서 (즉, &lt;code&gt;git&lt;/code&gt; 명령을 수행하는 위치) 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7cd0fe622f2fa6d7cad2751f00997df5822d4092" translate="yes" xml:space="preserve">
          <source>Incorporates changes from a remote repository into the current branch.
  In its default mode, git pull is shorthand for git fetch followed by
  git merge FETCH_HEAD.</source>
          <target state="translated">원격 저장소에서 현재 분기로 변경 사항을 통합합니다. 기본 모드에서 git pull은 git fetch의 약어이며 git merge FETCH_HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="ddab7bca2180329029b2fc8fd232bd55f5286278" translate="yes" xml:space="preserve">
          <source>Insert new commits after last common ancestor and reapply commits unique to local repository.</source>
          <target state="translated">마지막 공통 조상 뒤에 새 커밋을 삽입하고 로컬 리포지토리에 고유 한 커밋을 다시 적용합니다.</target>
        </trans-unit>
        <trans-unit id="334fd4cec82b62628bf7b5a408786f48086b0f6c" translate="yes" xml:space="preserve">
          <source>Integrating new commits to local branch</source>
          <target state="translated">로컬 커밋에 새로운 커밋 통합</target>
        </trans-unit>
        <trans-unit id="3947829b4a816ebf3be376780b6f09ea82ecf1d1" translate="yes" xml:space="preserve">
          <source>Is there any way to see the new changes made in remote while working on the branch locally?</source>
          <target state="translated">지점에서 로컬로 작업하는 동안 원격에서 새로 변경된 내용을 볼 수있는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="a90f009f20779ef043c4c2b9008ab20ca6177bb2" translate="yes" xml:space="preserve">
          <source>It affects your local development.</source>
          <target state="translated">지역 개발에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="0f6ad1f6acc6290c33f3a14bd7e9acc98e2ea785" translate="yes" xml:space="preserve">
          <source>It cost me a little bit to understand what was the difference, but this is a simple explanation. &lt;code&gt;master&lt;/code&gt; in your localhost is a branch.</source>
          <target state="translated">차이점이 무엇인지 이해하는 데 약간의 비용이 들었지만 이것은 간단한 설명입니다. localhost의 &lt;code&gt;master&lt;/code&gt; 는 지점입니다.</target>
        </trans-unit>
        <trans-unit id="c2392417cc36db01685d20f667bd966c4e212a13" translate="yes" xml:space="preserve">
          <source>It doesn't need to be explicitly checked out. Because it implicitly does a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">명시 적으로 체크 아웃 할 필요는 없습니다. 암시 적으로 &lt;code&gt;git merge&lt;/code&gt; 를 수행하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f814b6881b236cbf383bb4fc1485995a7d5b1d8e" translate="yes" xml:space="preserve">
          <source>It is important to contrast the design philosophy of git with the philosophy of a more traditional source control tool like SVN.</source>
          <target state="translated">git의 디자인 철학과 SVN과 같은 전통적인 소스 제어 툴의 철학을 대조하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b6e153c12288f95caa3ff1df1c789423019cba8b" translate="yes" xml:space="preserve">
          <source>It is very important to note that &lt;code&gt;git pull&lt;/code&gt; will &lt;strong&gt;automatically merge whether you like it or not&lt;/strong&gt;. This could, of course, result in merge conflicts. Let's say your remote is &lt;code&gt;origin&lt;/code&gt; and your branch is &lt;code&gt;master&lt;/code&gt;. If you &lt;code&gt;git diff origin/master&lt;/code&gt; before pulling, you should have some idea of potential merge conflicts and could prepare your local branch accordingly.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 은 &lt;strong&gt;원하는지 여부에 관계없이 자동으로 병합됩니다&lt;/strong&gt; . 물론 이로 인해 병합 충돌이 발생할 수 있습니다. 리모컨이 &lt;code&gt;origin&lt;/code&gt; 이고 지점이 &lt;code&gt;master&lt;/code&gt; 라고 가정 해 봅시다. 당기기 전에 &lt;code&gt;git diff origin/master&lt;/code&gt; 를 git 하면 잠재적 인 병합 충돌에 대한 아이디어가 있어야하며 이에 따라 로컬 브랜치를 준비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98ba93bc2857bab25c62222873602c9b7282098e" translate="yes" xml:space="preserve">
          <source>It will apply the changes from &lt;strong&gt;remote&lt;/strong&gt; to the &lt;strong&gt;current branch&lt;/strong&gt; in local...</source>
          <target state="translated">로컬의 &lt;strong&gt;현재 분기&lt;/strong&gt; 에 &lt;strong&gt;원격&lt;/strong&gt; 변경 사항을 적용합니다 ...</target>
        </trans-unit>
        <trans-unit id="2089f5ff30d1f915932544997ca4f31cb09b33ab" translate="yes" xml:space="preserve">
          <source>It will download all &lt;strong&gt;refs&lt;/strong&gt; and &lt;strong&gt;objects&lt;/strong&gt; and any new branches to your local Repository...</source>
          <target state="translated">그것은 모든 &lt;strong&gt;심판&lt;/strong&gt; 과 &lt;strong&gt;객체&lt;/strong&gt; 및 새로운 지점을 로컬 리포지토리에 다운로드합니다 ...</target>
        </trans-unit>
        <trans-unit id="e3692defe3bb907ef3be26614797cff88e4beadd" translate="yes" xml:space="preserve">
          <source>It's basically NOT safe. It's aggressive.</source>
          <target state="translated">기본적으로 안전하지 않습니다. 공격적입니다.</target>
        </trans-unit>
        <trans-unit id="0132137c4a419c936535f54c395be92a1c9ac4b0" translate="yes" xml:space="preserve">
          <source>It's interesting to see what's inside all directories, but let's focus on two of them. &lt;code&gt;heads&lt;/code&gt; and &lt;code&gt;remotes&lt;/code&gt;. Use &lt;code&gt;cd&lt;/code&gt; to check inside them too.</source>
          <target state="translated">모든 디렉토리 안에 무엇이 있는지 보는 것이 흥미롭지 만 그 중 두 가지에 초점을 맞추겠습니다. &lt;code&gt;heads&lt;/code&gt; 와 &lt;code&gt;remotes&lt;/code&gt; . &lt;code&gt;cd&lt;/code&gt; 를 사용하여 내부도 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5b60559fd8e2d2e8e3af93f7c4acc4a9ffbf1885" translate="yes" xml:space="preserve">
          <source>Just do:</source>
          <target state="translated">그냥 해:</target>
        </trans-unit>
        <trans-unit id="3e188073ca4a40a44969a8d4d808539ffc6cabc5" translate="yes" xml:space="preserve">
          <source>Let's take an example that you are working on a project with your team members. So their will be one main Branch of the project and all the contributors must fork it to their own local repository and then work on this local branch to modify/Add modules then push back to the main branch.</source>
          <target state="translated">팀원들과 함께 프로젝트를 진행하고 있음을 예로 들어 보겠습니다. 따라서 이들은 프로젝트의 하나의 주요 지점이 될 것이며 모든 기고자들은 그것을 자신의 로컬 저장소로 분기 한 다음이 로컬 지점에서 작업하여 모듈을 수정 / 추가 한 후 다시 메인 지점으로 푸시해야합니다.</target>
        </trans-unit>
        <trans-unit id="edd3e1409412e78ff0c9eb0c5bb64845286a8e9b" translate="yes" xml:space="preserve">
          <source>More precisely, git pull runs git fetch with the given parameters and
  calls git merge to merge the retrieved branch heads into the current
  branch. With --rebase, it runs git rebase instead of git merge.</source>
          <target state="translated">보다 정확하게는 git pull은 주어진 매개 변수로 git fetch를 실행하고 git merge를 호출하여 검색 된 분기 헤드를 현재 분기로 병합합니다. --rebase를 사용하면 git merge 대신 git rebase를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a2ba818d6ed9eeb75fb53e2017802c7157f637d4" translate="yes" xml:space="preserve">
          <source>Normally &lt;strong&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/strong&gt; does this by doing a &lt;strong&gt;&lt;code&gt;git fetch&lt;/code&gt;&lt;/strong&gt; to bring the local copy of the remote repository up to date, and then merging the changes into your own code repository and possibly your working copy.</source>
          <target state="translated">일반적으로 &lt;strong&gt; &lt;code&gt;git pull&lt;/code&gt; &lt;/strong&gt; 은 &lt;strong&gt; &lt;code&gt;git fetch&lt;/code&gt; &lt;/strong&gt; 를 수행하여 원격 저장소의 로컬 사본을 최신 상태로 만든 다음 변경 사항을 자신의 코드 저장소 및 작업 사본에 병합하여 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="31d7bbcc8cef085a2d26f7ea2b1d782e5569ba33" translate="yes" xml:space="preserve">
          <source>Now comes the fun part; do &lt;code&gt;ls&lt;/code&gt;. You will see a list of directories. We're looking for &lt;code&gt;refs&lt;/code&gt;. Do &lt;code&gt;cd refs&lt;/code&gt;.</source>
          <target state="translated">이제 재미있는 부분이 온다. &lt;code&gt;ls&lt;/code&gt; . 디렉토리 목록이 나타납니다. 우리는 &lt;code&gt;refs&lt;/code&gt; 찾고 있습니다. &lt;code&gt;cd refs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fac4b1246d10c655b4749fcfaf3e582fa75b4dbe" translate="yes" xml:space="preserve">
          <source>Now do &lt;code&gt;ls -a&lt;/code&gt;. This will show &lt;a href=&quot;https://unix.stackexchange.com/questions/21778/whats-so-special-about-directories-whose-names-begin-with-a-dot&quot;&gt;dot files&lt;/a&gt;, i.e., files beginning with &lt;code&gt;.&lt;/code&gt; You will then be able to see a directory named: &lt;code&gt;.git&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;ls -a&lt;/code&gt; 을 수행하십시오 . &lt;a href=&quot;https://unix.stackexchange.com/questions/21778/whats-so-special-about-directories-whose-names-begin-with-a-dot&quot;&gt;도트 파일&lt;/a&gt; , 즉로 시작하는 파일 이 표시됩니다 &lt;code&gt;.&lt;/code&gt; 그러면 &lt;code&gt;.git&lt;/code&gt; 이라는 디렉토리를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73721acace98d4f33af7597d3ca64e03bf13917d" translate="yes" xml:space="preserve">
          <source>Now, you have started working on the new module (suppose &lt;code&gt;D&lt;/code&gt;)  and when you have completed the &lt;code&gt;D&lt;/code&gt; module you want to push it to the main branch, But meanwhile what happens is that one of your teammates has developed new Module &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt; and modified &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">이제 새 모듈 ( &lt;code&gt;D&lt;/code&gt; )에 대한 작업을 시작했으며 &lt;code&gt;D&lt;/code&gt; 모듈을 완료하면 기본 지점으로 푸시하려고하지만 팀원 중 한 명이 새로운 모듈 &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; 및 수정 된 &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42575cb4c2af958800f2814be4eeb10c93d88c70" translate="yes" xml:space="preserve">
          <source>On step 2: For more on diffs between local and remotes, see: &lt;a href=&quot;https://stackoverflow.com/questions/1800783/compare-local-git-branch-with-remote-branch&quot;&gt;How to compare a local git branch with its remote branch?&lt;/a&gt;</source>
          <target state="translated">2 단계 : 로컬과 원격 간의 차이점에 대한 자세한 내용 &lt;a href=&quot;https://stackoverflow.com/questions/1800783/compare-local-git-branch-with-remote-branch&quot;&gt;은 로컬 분기와 원격 분기를 비교하는 방법을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ba10303cc8bc29ae6d60675a38b4b1414538852e" translate="yes" xml:space="preserve">
          <source>On step 3: It's probably more accurate (e.g. on a fast changing repo) to do a &lt;code&gt;git rebase origin&lt;/code&gt; here. See &lt;a href=&quot;https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch#comment16374948_5376768&quot;&gt;@Justin Ohms comment&lt;/a&gt; in another answer.</source>
          <target state="translated">3 단계 : 아마도 &lt;code&gt;git rebase origin&lt;/code&gt; 을 수행하는 것이 더 정확할 것입니다 (예 : 빠르게 변화하는 저장소). 다른 답변에서 &lt;a href=&quot;https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch#comment16374948_5376768&quot;&gt;@Justin Ohms 의견&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6ef3be4cb93c5c3a4ab715204573fa2c48f5d9e" translate="yes" xml:space="preserve">
          <source>On the plane, you could make changes to your local workspace and then merge it with what you've fetched and resolve potential merge conflicts all without a connection to the Internet. And unless someone had made &lt;em&gt;new&lt;/em&gt; conflicting changes to the remote repository then once you arrive at the destination you would do &lt;code&gt;git push origin &amp;lt;branch&amp;gt;&lt;/code&gt; and go get your coffee.</source>
          <target state="translated">비행기에서 로컬 작업 공간을 변경 한 다음 가져온 작업 공간과 병합하고 인터넷에 연결하지 않고도 잠재적 인 병합 충돌을 해결할 수 있습니다. 그리고 누군가 원격 저장소에 &lt;em&gt;새로운&lt;/em&gt; 상충을 변경하지 않았다면 목적지에 도착하면 &lt;code&gt;git push origin &amp;lt;branch&amp;gt;&lt;/code&gt; 를 누르고 커피를 마실 것입니다.</target>
        </trans-unit>
        <trans-unit id="2cd6dde17abde81f58ef155464001d7b9bdcaf42" translate="yes" xml:space="preserve">
          <source>One use case of &lt;code&gt;git fetch&lt;/code&gt; is that the following will tell you any changes in the remote branch since your last pull... so you can check before doing an actual pull, which could change files in your current branch and working copy.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 의 사용 사례 중 하나는 다음과 같이 마지막 풀 이후 원격 브랜치의 변경 사항을 알려줍니다. 실제 풀을 수행하기 전에 확인할 수 있으므로 현재 브랜치 및 작업 복사본의 파일을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ae635968f07616c5219d6807711a230311e03a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&quot;&gt;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&quot;&gt;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c270f0e70944669bd1713d611d6988fa74b8a56" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://git-scm.com/docs/git-diff&quot;&gt;https://git-scm.com/docs/git-diff&lt;/a&gt; regarding double- and triple-dot syntax in the diff command</source>
          <target state="translated">diff 명령의 더블 및 트리플 도트 구문에 대해서는 &lt;a href=&quot;https://git-scm.com/docs/git-diff&quot;&gt;https://git-scm.com/docs/git-diff&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="687ecbf1bdace513420218a49095b8dd9ec63b90" translate="yes" xml:space="preserve">
          <source>So in the Git Gui, when you do fetch, you have to merge the data. Fetch itself won't make the code changes at your local. You can check that when you update the code by fetching
once fetch and see; the code it won't change. Then you merge... You will see the changed code.</source>
          <target state="translated">따라서 Git Gui에서는 가져 오기를 수행 할 때 데이터를 병합해야합니다. 가져 오기 자체는 로컬에서 코드를 변경하지 않습니다. 한 번 페치를 페치하여 코드를 업데이트 할 때이를 확인할 수 있습니다. 변경되지 않는 코드. 그런 다음 병합합니다 ... 변경된 코드가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7a5191917188b0327a691ee3901a3d3f280832ae" translate="yes" xml:space="preserve">
          <source>So now You can carefully monitor the files before merging it to your repository. And you can also modify &lt;code&gt;D&lt;/code&gt; if required because of Modified &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">이제 파일을 리포지토리에 병합하기 전에 파일을 신중하게 모니터링 할 수 있습니다. 그리고 수정 된 &lt;code&gt;C&lt;/code&gt; 때문에 필요한 경우 &lt;code&gt;D&lt;/code&gt; 를 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7d6ea2d421748f38bd60628b104ed7a0bc8b46c" translate="yes" xml:space="preserve">
          <source>So now what has happened is that your local repository is lacking behind the original progress of the project and thus pushing of your changes to main branch can lead to conflict and may cause your Module &lt;code&gt;D&lt;/code&gt; to malfunction.</source>
          <target state="translated">이제 로컬 리포지토리에 프로젝트의 원래 진행률이 부족하여 변경 사항을 기본 지점으로 푸시하면 충돌이 발생하여 모듈 &lt;code&gt;D&lt;/code&gt; 가 오작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e65b7a5f79a6bd25bc0956f180c6958876f5aa3" translate="yes" xml:space="preserve">
          <source>So the difference will be:</source>
          <target state="translated">차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bab2af816ba39862eca729b2dd19f6e2a7dec4aa" translate="yes" xml:space="preserve">
          <source>So, 
&lt;strong&gt;Initial State&lt;/strong&gt; of the two Branches when you forked the main project on your local repository will be like this- (&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; are Modules already completed of the project)</source>
          <target state="translated">따라서 로컬 저장소에서 기본 프로젝트를 분기했을 때 두 지점의 &lt;strong&gt;초기 상태&lt;/strong&gt; 는 다음과 같습니다 ( &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 는 이미 프로젝트에서 완료된 모듈입니다)</target>
        </trans-unit>
        <trans-unit id="c509dfe0d9ecadd21477e5ea89036c82c3331aa1" translate="yes" xml:space="preserve">
          <source>Some IDEs (e.g. Xcode) are super smart and use the result of a &lt;code&gt;git fetch&lt;/code&gt; and can annotate the lines of code that have been changed in remote branch of your current working branch. If that line has been changed by both local changes and remote branch, then that line gets annotated with red. This isn't a merge conflict. It's a &lt;em&gt;potential&lt;/em&gt; merge conflict. It's a headsup that you can use to resolve the future merge conflict before doing &lt;code&gt;git pull&lt;/code&gt; from the remote branch.</source>
          <target state="translated">일부 IDE (예 : Xcode)는 매우 똑똑하며 &lt;code&gt;git fetch&lt;/code&gt; 결과를 사용하며 현재 작업중인 브랜치의 원격 브랜치에서 변경된 코드 줄에 주석을 달 수 있습니다. 해당 회선이 로컬 변경 사항과 원격 지사에 의해 변경된 경우 해당 회선에 빨간색 주석이 표시됩니다. 이것은 병합 충돌이 아닙니다. &lt;em&gt;잠재적 인&lt;/em&gt; 병합 충돌입니다. 원격 브랜치에서 &lt;code&gt;git pull&lt;/code&gt; 을 수행하기 전에 향후 병합 충돌을 해결하는 데 사용할 수있는 헤드 업입니다.</target>
        </trans-unit>
        <trans-unit id="751516aaf56e4a009d9a95473521f2b5e4a91c6b" translate="yes" xml:space="preserve">
          <source>Some major advantages for having a fetched mirror of the remote are:</source>
          <target state="translated">페치 된 미러 미러를 사용하면 다음과 같은 주요 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f116feeed3453af125cc94651d00b568b3382b73" translate="yes" xml:space="preserve">
          <source>Sometimes a visual representation helps.</source>
          <target state="translated">때로는 시각적 인 표현이 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="13de40234719d2a5e55c0bc0833165ebde52b54e" translate="yes" xml:space="preserve">
          <source>Subversion was designed and built with a client/server model. There is a single repository that is the server, and several clients can fetch code from the server, work on it, then commit it back to the server. The assumption is that the client can always contact the server when it needs to perform an operation.</source>
          <target state="translated">Subversion은 클라이언트 / 서버 모델로 설계 및 제작되었습니다. 서버 인 단일 리포지토리가 있으며 여러 클라이언트가 서버에서 코드를 가져 와서 작업 한 다음 서버로 다시 커밋 할 수 있습니다. 클라이언트는 작업을 수행해야 할 때 항상 서버에 연결할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="cbe53d654abeea87d780df2cbb35f48b293f4ab8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fetch&lt;/code&gt; command downloads commits, files, and refs from a
  remote repository into your local repository.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 명령은 커밋, 파일 및 참조를 원격 저장소에서 로컬 저장소로 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="306f6d2083f24839bb90d29d30ccdf4811f10c03" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;git pull&lt;/strong&gt; command is actually a &lt;code&gt;shortcut&lt;/code&gt; for &lt;strong&gt;git fetch&lt;/strong&gt; followed by the &lt;strong&gt;git merge&lt;/strong&gt; or the &lt;strong&gt;git rebase&lt;/strong&gt; command depending on your configuration. You can configure your Git repository so that &lt;strong&gt;git pull&lt;/strong&gt; is a fetch followed by a rebase.</source>
          <target state="translated">&lt;strong&gt;git pull&lt;/strong&gt; 명령은 실제로 구성에 따라 &lt;strong&gt;git fetch&lt;/strong&gt; 의 &lt;code&gt;shortcut&lt;/code&gt; 다음에 &lt;strong&gt;git merge&lt;/strong&gt; 또는 &lt;strong&gt;git rebase&lt;/strong&gt; 명령입니다. &lt;strong&gt;git pull&lt;/strong&gt; 이 페치에 이어 rebase가되도록 Git 리포지토리를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35c94b59a53fa50c4f5c982a81436bdd806fd908" translate="yes" xml:space="preserve">
          <source>The Difference between &lt;strong&gt;GIT Fetch&lt;/strong&gt; and &lt;strong&gt;GIT Pull&lt;/strong&gt; can be explained with the following scenario:
&lt;em&gt;(Keeping in mind that pictures speak louder than words!, I have provided pictorial representation)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;GIT Fetch&lt;/strong&gt; 와 &lt;strong&gt;GIT Pull&lt;/strong&gt; 의 차이점은 다음 시나리오를 통해 설명 할 수 있습니다. &lt;em&gt;(그림이 단어보다 크게 말하는 것을 명심하십시오! 그림을 제공했습니다)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53f91a7e62942e203876dd071752da5d13ec2baf" translate="yes" xml:space="preserve">
          <source>The difference between git pull, git fetch and git clone (and git rebase) - Mike Pearce</source>
          <target state="translated">git pull, git fetch 및 git clone (및 git rebase)의 차이점-Mike Pearce</target>
        </trans-unit>
        <trans-unit id="f9d05bd2faa3f1351a188371811118689f8a1ab7" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names
  they point at, are written to .git/FETCH_HEAD. This information may be
  used by scripts or other git commands, such as git-pull.</source>
          <target state="translated">페치 된 참조 이름은 이들이 가리키는 오브젝트 이름과 함께 .git / FETCH_HEAD에 기록됩니다. 이 정보는 스크립트 또는 git-pull과 같은 다른 git 명령에 의해 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="709e4c591c9ada67d70a258e7e4251499d7ac05f" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt; is that :</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 과 &lt;code&gt;git fetch&lt;/code&gt; 의 유일한 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76daff5996e8269d3dd02ea66d3869e8f9168b82" translate="yes" xml:space="preserve">
          <source>The short and easy answer is that &lt;code&gt;git pull&lt;/code&gt; is simply &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">짧고 쉬운 대답은 &lt;code&gt;git pull&lt;/code&gt; 이 단순히 &lt;code&gt;git fetch&lt;/code&gt; 다음에 &lt;code&gt;git merge&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="51513cadff1ee5095c8df532e4e37c7e6e2a0fb0" translate="yes" xml:space="preserve">
          <source>The take away is to keep in mind that there are often at least &lt;strong&gt;three copies&lt;/strong&gt; of a project on your workstation. One copy is your own repository with your own commit history. The second copy is your working copy where you are editing and building. The third copy is your local &quot;cached&quot; copy of a remote repository.</source>
          <target state="translated">테이크 아웃은 워크 스테이션에 프로젝트 &lt;strong&gt;사본&lt;/strong&gt; 이 &lt;strong&gt;3 개&lt;/strong&gt; 이상 있다는 것을 명심해야합니다. 하나의 사본은 자체 커밋 히스토리가있는 자체 저장소입니다. 두 번째 사본은 편집 및 작성중인 작업 사본입니다. 세 번째 사본은 원격 저장소의 로컬 &quot;캐시 된&quot;사본입니다.</target>
        </trans-unit>
        <trans-unit id="e6efaade8678bbf79f86466455ab8588f51ff88e" translate="yes" xml:space="preserve">
          <source>The three repos with a fetch:</source>
          <target state="translated">페치가있는 세 개의 repos :</target>
        </trans-unit>
        <trans-unit id="96306d9d7afb366db3fd8034aacc498461c28b62" translate="yes" xml:space="preserve">
          <source>The three repos with a pull</source>
          <target state="translated">잡아 당기는 3 개의 repos</target>
        </trans-unit>
        <trans-unit id="a2f54e0cd5a7689c3b9e61f6dd82d101a2ed1953" translate="yes" xml:space="preserve">
          <source>Then this would go into your remotes directory. It's still not available to your local directory. However, it simplifies your checkout to that remote branch by DWIM (Do what I mean):</source>
          <target state="translated">그러면 이것은 remotes 디렉토리로 갈 것입니다. 여전히 로컬 디렉토리에서 사용할 수 없습니다. 그러나 DWIM을 사용하여 해당 원격 지점에 대한 체크 아웃을 단순화합니다 (내가 의미하는 바를 수행).</target>
        </trans-unit>
        <trans-unit id="55a7d6a0db4ebe297f2d43c4272f3114636d3660" translate="yes" xml:space="preserve">
          <source>There are two ways of doing step 2. You can:</source>
          <target state="translated">2 단계를 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="22479224c315e3ac8965a8d67b70537247f8ee88" translate="yes" xml:space="preserve">
          <source>This above command is the most useful command in my git life which saved a lots of time.</source>
          <target state="translated">이 위의 명령은 내 자식 생활에서 가장 유용한 명령으로 많은 시간을 절약했습니다.</target>
        </trans-unit>
        <trans-unit id="d295d38717fafe8c79328dc8ddc3deb6761388e0" translate="yes" xml:space="preserve">
          <source>This blog post was useful:</source>
          <target state="translated">이 블로그 게시물은 유용했습니다.</target>
        </trans-unit>
        <trans-unit id="0a829a2d422289272de5ab855cb5e9577ba60534" translate="yes" xml:space="preserve">
          <source>This helped me understand why a fetch is pretty important.</source>
          <target state="translated">이를 통해 가져 오기가 왜 중요한지 이해할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="5d5082feffe5ba17e1674f6f1a13809963795a02" translate="yes" xml:space="preserve">
          <source>This interactive graphical representation is very helpful in understanging git: &lt;a href=&quot;http://ndpsoftware.com/git-cheatsheet.html&quot;&gt;http://ndpsoftware.com/git-cheatsheet.html&lt;/a&gt;</source>
          <target state="translated">이 대화식 그래픽 표현은 자식을 지체하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c03e8aa568e39354d4fef8b90850b194009b133d" translate="yes" xml:space="preserve">
          <source>This is a potentially dangerous mode of operation. It rewrites
  history, which does not bode well when you published that history
  already. Do not use this option unless you have read git-rebase(1)
  carefully.</source>
          <target state="translated">이것은 잠재적으로 위험한 작동 모드입니다. 기록을 다시 작성하므로 기록을 이미 게시했을 때 제대로 표시되지 않습니다. git-rebase (1)를주의 깊게 읽지 않으면이 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6d4d3f7cd0b544f4693755b4f708541dcaf1fb43" translate="yes" xml:space="preserve">
          <source>This is an example for a remote repository called &lt;code&gt;origin&lt;/code&gt; and a branch called &lt;code&gt;master&lt;/code&gt; tracking the remote branch &lt;code&gt;origin/master&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;origin&lt;/code&gt; 이라는 원격 저장소와 원격 branch &lt;code&gt;origin/master&lt;/code&gt; 를 추적하는 &lt;code&gt;master&lt;/code&gt; 라는 지점의 예입니다.</target>
        </trans-unit>
        <trans-unit id="538591b00fc41f249782e67a77ba3727e103f194" translate="yes" xml:space="preserve">
          <source>This operation never changes any of your own local branches under &lt;code&gt;refs/heads&lt;/code&gt;, and is safe to do without changing your working copy. I have even heard of people running &lt;code&gt;git fetch&lt;/code&gt; periodically in a cron job in the background (although I wouldn't recommend doing this).</source>
          <target state="translated">이 작업은 &lt;code&gt;refs/heads&lt;/code&gt; 아래의 자체 로컬 브랜치를 변경하지 않으며 작업 사본을 변경하지 않고 안전하게 할 수 있습니다. 나는 백그라운드에서 cron 작업에서 &lt;code&gt;git fetch&lt;/code&gt; 를 주기적으로 실행하는 사람들에 대해 들었습니다 (그러나 권장하지는 않지만).</target>
        </trans-unit>
        <trans-unit id="be526cd7b29f7539ab21c31c8d6a75b818a2623e" translate="yes" xml:space="preserve">
          <source>To avoid such issues and to work parallel with the original progress of the project their are Two ways:</source>
          <target state="translated">이러한 문제를 피하고 프로젝트의 원래 진행 상황과 병행하여 작업하는 방법은 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="9cdf14da3817f6628ec1361bea603aa959657fdc" translate="yes" xml:space="preserve">
          <source>To see the actual difference</source>
          <target state="translated">실제 차이를 보려면</target>
        </trans-unit>
        <trans-unit id="e5f1d7a647255e501edc50ce9e6aa00b9187d82d" translate="yes" xml:space="preserve">
          <source>To understand this, you first need to understand that your local git maintains not only your local repository, but it also maintains a local copy of the remote repository.</source>
          <target state="translated">이를 이해하려면 먼저 로컬 자식이 로컬 저장소뿐만 아니라 원격 저장소의 로컬 사본도 유지한다는 것을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffc16a6560848a6d7f779bb9aced6fdf7c588383" translate="yes" xml:space="preserve">
          <source>Trying to be clear and simple.</source>
          <target state="translated">명확하고 단순하게 노력합니다.</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="332032088e32c31d232f02474810d74702bd1d78" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git fetch&lt;/code&gt; where it only affects your &lt;code&gt;.git/refs/remotes&lt;/code&gt;, git pull will affect both your &lt;code&gt;.git/refs/remotes&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;code&gt;.git/refs/heads/&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 가 &lt;code&gt;.git/refs/remotes&lt;/code&gt; 에만 영향을 미치는 git fetch 와 달리 git pull은 &lt;code&gt;.git/refs/remotes&lt;/code&gt; &lt;strong&gt;및&lt;/strong&gt; &lt;code&gt;.git/refs/heads/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d13c88e54fc8efb180fc6b3b27421a7fb284a530" translate="yes" xml:space="preserve">
          <source>Update your local repo from the remote (but don't merge):</source>
          <target state="translated">리모컨에서 로컬 저장소를 업데이트하십시오 (하지만 병합하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="8f6be89be11acde27b9603fe48a423a16c6df9dc" translate="yes" xml:space="preserve">
          <source>We simply say:</source>
          <target state="translated">우리는 단순히 말합니다 :</target>
        </trans-unit>
        <trans-unit id="ea59d40483dcdff606446c1278db4f30b88410e8" translate="yes" xml:space="preserve">
          <source>What are the differences between &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 과 &lt;code&gt;git fetch&lt;/code&gt; 의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f4a4b649621d7f1f61aa3c746531b2f6672b090d" translate="yes" xml:space="preserve">
          <source>What is the difference between 'git pull' and 'git fetch'</source>
          <target state="translated">'git pull'과 'git fetch'의 차이점은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="bc03f833fd7c52d8a1b370a5afba995d1e6fe5f2" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 과 &lt;code&gt;git fetch&lt;/code&gt; 의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b8cf24993f0288b5cc2c819833af209e300e949c" translate="yes" xml:space="preserve">
          <source>When downloading content from a remote repository, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt; commands are available to accomplish the task. You can consider
  &lt;code&gt;git fetch&lt;/code&gt; the 'safe' version of the two commands. It will download
  the remote content, but not update your local repository's working state,
  leaving your current work intact. &lt;code&gt;git pull&lt;/code&gt; is the more aggressive
  alternative, it will download the remote content for the active local
  branch and immediately execute &lt;code&gt;git merge&lt;/code&gt; to create a merge commit
  for the new remote content. If you have pending changes in progress
  this will cause conflicts and kickoff the merge conflict resolution
  flow.</source>
          <target state="translated">원격 저장소에서 컨텐츠를 다운로드 할 때 &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git fetch&lt;/code&gt; 명령을 사용하여 작업을 수행 할 수 있습니다. &lt;code&gt;git fetch&lt;/code&gt; 는 두 명령의 '안전한'버전을 가져 오는 것을 고려할 수 있습니다. 원격 컨텐츠를 다운로드하지만 로컬 저장소의 작업 상태를 업데이트하지 않고 현재 작업을 그대로 유지합니다. &lt;code&gt;git pull&lt;/code&gt; 은 더 적극적인 대안이며 활성 로컬 분기에 대한 원격 컨텐츠를 다운로드하고 즉시 &lt;code&gt;git merge&lt;/code&gt; 를 실행하여 새 원격 컨텐츠에 대한 병합 커밋을 작성합니다. 진행중인 변경 사항이 있으면 충돌이 발생하고 병합 충돌 해결 과정이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="90241fc66dccec755b7f7a1db64386e32d1975aa" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the origin remote will be
  used, unless there&amp;rsquo;s an upstream branch configured for the current
  branch.</source>
          <target state="translated">원격이 지정되지 않은 경우 현재 분기에 대해 업스트림 분기가 구성되어 있지 않으면 기본적으로 오리진 원격이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f29d1d15a178302f133f949f8f12fc0d9c744655" translate="yes" xml:space="preserve">
          <source>When you &lt;code&gt;fetch&lt;/code&gt;, Git gathers any commits from the target branch that do not exist in your current branch and &lt;strong&gt;stores them in your local repository&lt;/strong&gt;. However, &lt;strong&gt;it does not merge them with your current branch&lt;/strong&gt;. This is particularly useful if you need to keep your repository up to date, but are working on something that might break if you update your files. 
To integrate the commits into your master branch, you use &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 오면 Git은 현재 브랜치에 존재하지 않는 대상 브랜치에서 커밋을 수집 &lt;strong&gt;하여 로컬 리포지토리에 저장합니다&lt;/strong&gt; . 그러나 &lt;strong&gt;현재 분기와 병합하지 않습니다&lt;/strong&gt; . 리포지토리를 최신 상태로 유지해야하지만 파일을 업데이트하면 손상 될 수있는 작업을 수행하는 경우 특히 유용합니다. 커밋을 마스터 브랜치에 통합하려면 &lt;code&gt;merge&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2f6b2b23ee6b56459eb33e7764e459ba74679007" translate="yes" xml:space="preserve">
          <source>When you clone a repository you fetch the entire repository to you local host. This means that at that time you have an origin/master pointer to &lt;code&gt;HEAD&lt;/code&gt; and master pointing to the same &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">리포지토리를 복제하면 전체 리포지토리를 로컬 호스트로 가져옵니다. 이것은 그때 &lt;code&gt;HEAD&lt;/code&gt; 에 대한 원점 / 마스터 포인터와 동일한 &lt;code&gt;HEAD&lt;/code&gt; 를 가리키는 마스터가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8ae99188f3ea7c125344fba8a5364f2b481c9542" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;pull&lt;/code&gt;, Git tries to automatically do your work for you. &lt;strong&gt;It is context sensitive&lt;/strong&gt;, so Git will merge any pulled commits into the branch you are currently working in.  &lt;code&gt;pull&lt;/code&gt;&lt;strong&gt;automatically merges the commits without letting you review them first&lt;/strong&gt;. If you don&amp;rsquo;t closely manage your branches, you may run into frequent conflicts.</source>
          <target state="translated">&lt;code&gt;pull&lt;/code&gt; 을 사용하면 Git은 자동으로 작업을 시도합니다. &lt;strong&gt;컨텍스트에 민감&lt;/strong&gt; 하기 때문에 Git은 가져온 커밋을 현재 작업중인 브랜치에 &lt;strong&gt;병합합니다&lt;/strong&gt; . &lt;code&gt;pull&lt;/code&gt; &lt;strong&gt;은 커밋을 먼저 검토하지 않고 커밋을 자동으로 병합합니다&lt;/strong&gt; . 지점을 면밀히 관리하지 않으면 빈번한 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b93bc9367ac04ff57c408636c95b140163378c0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git pull&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="3d83192bff705155cb759eec49d16b9a3257e7a7" translate="yes" xml:space="preserve">
          <source>You can apply changes downloaded through fetch using the merge command. Merge will take the commits retrieved from fetch and try to add them to your local branch. The merge will keep the commit history of your local changes so that when you share your branch with push, Git will know how others can merge your changes.</source>
          <target state="translated">merge 명령을 사용하여 가져 오기를 통해 다운로드 한 변경 사항을 적용 할 수 있습니다. 병합은 페치에서 검색된 커밋을 가져 와서 로컬 브랜치에 추가하려고 시도합니다. 병합은 로컬 변경 사항의 커밋 기록을 유지하므로 푸시와 지점을 공유 할 때 Git은 다른 사람이 변경 내용을 병합하는 방법을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77cc8b703c81ec309bd760da433e26013a43df97" translate="yes" xml:space="preserve">
          <source>You can do a &lt;code&gt;git fetch&lt;/code&gt; at any time to update your remote-tracking branches under &lt;code&gt;refs/remotes/&amp;lt;remote&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">언제든지 &lt;code&gt;git fetch&lt;/code&gt; 를 수행하여 &lt;code&gt;refs/remotes/&amp;lt;remote&amp;gt;/&lt;/code&gt; 에서 원격 추적 분기를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60d4353b41982c20e79e6a617ebff5018b2b3fef" translate="yes" xml:space="preserve">
          <source>You can fetch from a remote repository, see the differences and then pull or merge.</source>
          <target state="translated">원격 저장소에서 가져 와서 차이점을 확인한 다음 끌어 오거나 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9648163d36e5997ca061fecd2f767a9206a1de2a" translate="yes" xml:space="preserve">
          <source>You don't get any isolation.</source>
          <target state="translated">격리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3af21692e399cffc1b0602029c4c529d3a93c542" translate="yes" xml:space="preserve">
          <source>You download changes to your local branch from origin through fetch. Fetch asks the remote repo for all commits that others have made but you don't have on your local repo. Fetch downloads these commits and adds them to the local repository.</source>
          <target state="translated">출발지에서 가져 오기를 통해 변경 사항을 로컬 지점으로 다운로드합니다. Fetch는 다른 사람이 저지른 모든 커밋에 대해 원격 리포지토리를 요청하지만 로컬 리포지토리에는 없습니다. Fetch는 이러한 커밋을 다운로드하여 로컬 리포지토리에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="71deaa7d8f575ab7ed6cd6bbf3334a1461005600" translate="yes" xml:space="preserve">
          <source>You would pull if you want the histories merged, you'd fetch if you just 'want the codez' as some person has been tagging some articles around here.</source>
          <target state="translated">히스토리를 병합하려면 당기고, 누군가가이 기사 주위에 기사를 태그하고 있기 때문에 '코덱을 원하면'가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d0a02932aa479b6aeba6af580331b25d6888fea8" translate="yes" xml:space="preserve">
          <source>and covers &lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git clone&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt;.</source>
          <target state="translated">그리고 &lt;code&gt;git pull&lt;/code&gt; , &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git clone&lt;/code&gt; 및 &lt;code&gt;git rebase&lt;/code&gt; 를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="076889ab0a1a5ea289dc99e4db7f5646876c95f3" translate="yes" xml:space="preserve">
          <source>but in ,</source>
          <target state="translated">그러나에서</target>
        </trans-unit>
        <trans-unit id="338b9d34cef0cc10394bbeb555b6c8652b8ad965" translate="yes" xml:space="preserve">
          <source>eg: i am going to fetch from server master and rebase it in my local master.</source>
          <target state="translated">예 : 서버 마스터에서 가져 와서 로컬 마스터에서 리베이스 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7652ed4e9782162856d4648e8895b3387d9f68e6" translate="yes" xml:space="preserve">
          <source>git fetch</source>
          <target state="translated">자식 가져 오기</target>
        </trans-unit>
        <trans-unit id="a1e51d9e97a083cd4a749ceb74184d3a801ebb5d" translate="yes" xml:space="preserve">
          <source>git fetch can fetch from either a single named repository or URL, or
  from several repositories at once if  is given and there is a
  remotes. entry in the configuration file. (See git-config&lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1&lt;/a&gt;).</source>
          <target state="translated">git fetch는 이름이 지정된 단일 리포지토리 또는 URL 또는 원격이있는 경우 여러 리포지토리에서 한 번에 가져올 수 있습니다. 구성 파일의 항목. (git-config &lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="a6378e53c49a3c9ce8158f63060def312e889cf2" translate="yes" xml:space="preserve">
          <source>git fetch does not changes to local branches.</source>
          <target state="translated">git fetch는 로컬 브랜치로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b19fd74d867e845324d1cc6667583a990caa8b8" translate="yes" xml:space="preserve">
          <source>git fetch: Git is going to get the latest version from remote to local,  but it do not automatically merge.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;code&gt;git fetch origin master&lt;/code&gt;&lt;code&gt;git log -p master..origin/master&lt;/code&gt;&lt;code&gt;git merge origin/master&lt;/code&gt;</source>
          <target state="translated">git fetch : Git은 최신 버전을 원격에서 로컬로 가져 오지만 자동으로 병합되지는 않습니다. &lt;code&gt;git fetch origin master&lt;/code&gt; &lt;code&gt;git log -p master..origin/master&lt;/code&gt; &lt;code&gt;git merge origin/master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d065adf8851333810ea91f5f69a1ea63158b8826" translate="yes" xml:space="preserve">
          <source>git pull</source>
          <target state="translated">자식 풀</target>
        </trans-unit>
        <trans-unit id="7211a49be2c5e530c61f049fc400dec211114d60" translate="yes" xml:space="preserve">
          <source>git pull == ( git fetch + git merge)</source>
          <target state="translated">자식 풀 == (자식 가져 오기 + 자식 병합)</target>
        </trans-unit>
        <trans-unit id="98d57b348afc86b663f71eb34f50f6b73b3d02af" translate="yes" xml:space="preserve">
          <source>git pull: Git is going to get the latest version from the remote and merge into the local.</source>
          <target state="translated">git pull : Git은 원격에서 최신 버전을 가져 와서 로컬로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="4c01625fa313444b2582a58311703d8668a6b3bb" translate="yes" xml:space="preserve">
          <source>here &lt;strong&gt;origin&lt;/strong&gt; is your remote repo &lt;strong&gt;master&lt;/strong&gt; is your branch</source>
          <target state="translated">여기 &lt;strong&gt;원산지&lt;/strong&gt; 는 당신의 원격 저장소 &lt;strong&gt;마스터&lt;/strong&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="f3293b87bc9bb8812771c354181c62eef7b1e271" translate="yes" xml:space="preserve">
          <source>here,</source>
          <target state="translated">here,</target>
        </trans-unit>
        <trans-unit id="3aa005c86b2e48f70aa9c07d41965bad325d9628" translate="yes" xml:space="preserve">
          <source>i.e. git pull = git fetch + git merge ...</source>
          <target state="translated">즉 git pull = git fetch + git merge ...</target>
        </trans-unit>
        <trans-unit id="8abe66c44f7b8696d85a5e265ed9f37769e3e453" translate="yes" xml:space="preserve">
          <source>it will fetch server changes from origin. and it will be in your local until you rebase it on your own. we need to fix conflicts manually by checking codes.</source>
          <target state="translated">서버 변경 사항을 원점에서 가져옵니다. 직접 리베이스 할 때까지 로컬에 있습니다. 코드를 확인하여 수동으로 충돌을 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="77e703902168624324db616363fbd43a7158e819" translate="yes" xml:space="preserve">
          <source>should be the name of a remote repository as passed to
  git-fetch&lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1&lt;/a&gt;.  can name an arbitrary remote ref (for example,
  the name of a tag) or even a collection of refs with corresponding
  remote-tracking branches (e.g., refs/heads/&lt;em&gt;:refs/remotes/origin/&lt;/em&gt;),
  but usually it is the name of a branch in the remote repository.</source>
          <target state="translated">git-fetch &lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1에&lt;/a&gt; 전달 된 원격 저장소의 이름이어야합니다. 임의의 원격 참조 (예 : 태그 이름) 또는 해당 원격 추적 분기 (예 : refs / heads / &lt;em&gt;: refs / remotes / origin /&lt;/em&gt; )가있는 참조 모음의 이름을 지정할 수 있지만 일반적으로 이름입니다. 원격 저장소의 분기</target>
        </trans-unit>
        <trans-unit id="a6e839f3fb69bba683587d3332f5f0020879b4dc" translate="yes" xml:space="preserve">
          <source>this will rebase code into local. before that ensure you're in right branch.</source>
          <target state="translated">이것은 코드를 로컬로 리베이스합니다. 그 전에 올바른 지점에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8fd2b1b8f0afc6bcf95d25c97c52d650bc531b47" translate="yes" xml:space="preserve">
          <source>when you start working and do commits you advance the master pointer to &lt;code&gt;HEAD&lt;/code&gt; + your commits. But the origin/master pointer is still pointing to what it was when you cloned.</source>
          <target state="translated">작업을 시작하고 커밋을 수행하면 마스터 포인터를 &lt;code&gt;HEAD&lt;/code&gt; + 커밋으로 진행합니다. 그러나 원점 / 마스터 포인터는 여전히 복제 할 때의 것을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="c8611464dcef8825f2ef8aa62feb4357dc35ccde" translate="yes" xml:space="preserve">
          <source>will fetch code from repository and rebase with your local... in git pull there is possibility of new commits getting created.</source>
          <target state="translated">저장소에서 코드를 가져 와서 로컬로 리베이스하십시오 ... git pull에서 새로운 커밋이 생성 될 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6492f8b35e6d7766d4dd5492898cb07179aaa87" translate="yes" xml:space="preserve">
          <source>will fetch code from repository and we need to rebase it manually by using &lt;code&gt;git rebase&lt;/code&gt;</source>
          <target state="translated">저장소에서 코드를 가져오고 &lt;code&gt;git rebase&lt;/code&gt; 를 사용하여 수동으로 코드를 리베이스해야합니다.</target>
        </trans-unit>
        <trans-unit id="922ad17f05bbaa394ace87920268f3431e1ccebb" translate="yes" xml:space="preserve">
          <source>you no longer need to do:</source>
          <target state="translated">더 이상 할 필요가 없습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
