<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/292357">
    <body>
      <group id="292357">
        <trans-unit id="9fa5c5c74bcc28f7ff899434be6d1efa62244365" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; The command above is the equivalent to &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;. In practice, &lt;code&gt;git fetch&lt;/code&gt; maybe more secure because before the merge we can see the changes and decide whether to merge.</source>
          <target state="translated">上面的命令等效于 &lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 。 实际上， &lt;code&gt;git fetch&lt;/code&gt; 可能更安全，因为在合并之前，我们可以看到更改并决定是否合并。</target>
        </trans-unit>
        <trans-unit id="32d8acda1dd72cb4e3ce43954e543e4a3da0d07f" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; The commands above mean that download latest version of the main branch from origin from the remote to origin master branch. And then compares the local master branch and origin master branch. Finally, merge.</source>
          <target state="translated">上面的命令意味着从远程将主分支的最新版本从远程下载到起源主分支。 然后比较本地主分支和原始主分支。 最后，合并。</target>
        </trans-unit>
        <trans-unit id="48f97e1dc3e1ee5a10ffd97cdf92f6d652c37e14" translate="yes" xml:space="preserve">
          <source>(inside-repo operation) &lt;code&gt;remote/origin/master@local &amp;gt;&amp;gt; master@local&lt;/code&gt;</source>
          <target state="translated">（内部回购操作） &lt;code&gt;remote/origin/master@local &amp;gt;&amp;gt; master@local&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fa9cf27a8e4a9c6a7b0b129563967146c119b54" translate="yes" xml:space="preserve">
          <source>(repo to repo operation) &lt;code&gt;master@remote &amp;gt;&amp;gt; remote/origin/master@local&lt;/code&gt;</source>
          <target state="translated">（回购到回购操作） &lt;code&gt;master@remote &amp;gt;&amp;gt; remote/origin/master@local&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5432acc46382d221828b84d9bafa1cde6a4ba9bf" translate="yes" xml:space="preserve">
          <source>1) git pull ( rebase will done automatically):</source>
          <target state="translated">1)git pull(rebase会自动完成)。</target>
        </trans-unit>
        <trans-unit id="5a66cdfb6968d483b06aeeba82c490dbf2550d78" translate="yes" xml:space="preserve">
          <source>2) git fetch (need to rebase manually):</source>
          <target state="translated">2)git fetch(需要手动重新建立基础)。</target>
        </trans-unit>
        <trans-unit id="0d3bd84264ca1b2c8f691ecc7555b9bee9c17c48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git clone&lt;/code&gt; clones a repo.</source>
          <target state="translated">&lt;code&gt;git clone&lt;/code&gt; 克隆一个仓库。</target>
        </trans-unit>
        <trans-unit id="5328124c67a16a351ef68bf92f8f591e1c77c394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; brings your local copy of the remote repository up to date. For example, if your remote repository is GitHub - you may want to fetch any changes made in the remote repository to your local copy of it the remote repository. This will allow you to perform operations such as compare or merge.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 使您的远程存储库本地副本保持最新状态。 例如，如果您的远程存储库是GitHub-您可能希望将远程存储库中所做的所有更改都提取到远程存储库的本地副本中。 这将允许您执行比较或合并之类的操作。</target>
        </trans-unit>
        <trans-unit id="45716d867c97c93141fd633174f0b1e9b5c4f243" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; is similar to &lt;code&gt;pull&lt;/code&gt; but doesn't merge. i.e. it fetches remote updates (&lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;) but your local stays the same (i.e. &lt;code&gt;origin/master&lt;/code&gt; gets updated but &lt;code&gt;master&lt;/code&gt; stays the same) .</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 与 &lt;code&gt;pull&lt;/code&gt; 类似，但不会合并。 即，它获取远程更新（ &lt;code&gt;refs&lt;/code&gt; 和 &lt;code&gt;objects&lt;/code&gt; ），但是本地保持不变（即， &lt;code&gt;origin/master&lt;/code&gt; 已更新，但 &lt;code&gt;master&lt;/code&gt; 保持不变）。</target>
        </trans-unit>
        <trans-unit id="961114afa0561cd3fae7d954b2c0f6de44de1cd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; just &quot;downloads&quot; the changes from the remote to your local repository. &lt;code&gt;git pull&lt;/code&gt; downloads the changes and merges them into your current branch. &quot;In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 只是将更改从远程&amp;ldquo;下载&amp;rdquo;到本地存储库。 &lt;code&gt;git pull&lt;/code&gt; 下载更改并将其合并到您当前的分支中。 &amp;ldquo;在默认模式下， &lt;code&gt;git pull&lt;/code&gt; 是 &lt;code&gt;git fetch&lt;/code&gt; 的简写，其次是 &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="851e511f1a09665acd6e13d5277de7a31c182eb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; only fetches from the remote branch but it does not merge</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 仅从远程分支获取，但不合并</target>
        </trans-unit>
        <trans-unit id="9ce94279a6dadc28b7a0ecb75dade36111b4a373" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; pulls down the code from the remote server to your tracking branches in your local repository.  If your remote is named &lt;code&gt;origin&lt;/code&gt; (the default) then these branches will be within &lt;code&gt;origin/&lt;/code&gt;, for example &lt;code&gt;origin/master&lt;/code&gt;, &lt;code&gt;origin/mybranch-123&lt;/code&gt;, etc.  These are not your current branches, they are &lt;em&gt;local&lt;/em&gt; copies of those branches from the server.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 将代码从远程服务器下拉到本地存储库中的跟踪分支。 如果您的远程 &lt;code&gt;origin/master&lt;/code&gt; 被命名为 &lt;code&gt;origin&lt;/code&gt; （默认值），则这些分支将位于 &lt;code&gt;origin/&lt;/code&gt; ，例如origin / master ， &lt;code&gt;origin/mybranch-123&lt;/code&gt; 等。这些不是您当前的分支，它们是服务器中这些分支的&lt;em&gt;本地&lt;/em&gt;副本。 。</target>
        </trans-unit>
        <trans-unit id="80fe18c4b4632e89609525d07897b4e58d6f487a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; will retrieve remote branches so that you can &lt;code&gt;git diff&lt;/code&gt; or &lt;code&gt;git merge&lt;/code&gt; them with the current branch. &lt;code&gt;git pull&lt;/code&gt; will run fetch on the remote brach tracked by the current branch and then merge the result. You can use &lt;code&gt;git fetch&lt;/code&gt; to see if there are any updates to the remote branch without necessary merging them with your local branch.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 将检索远程分支，以便您可以 &lt;code&gt;git diff&lt;/code&gt; 或 &lt;code&gt;git merge&lt;/code&gt; 它们与当前分支合并 。 &lt;code&gt;git pull&lt;/code&gt; 将在当前分支跟踪的远程分支上运行访存，然后合并结果。 您可以使用 &lt;code&gt;git fetch&lt;/code&gt; 来查看远程分支是否有任何更新，而无需将其与本地分支合并。</target>
        </trans-unit>
        <trans-unit id="e3917ec46fc6b54ce2e06c114c3417324b75b2a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; does a &lt;code&gt;git fetch&lt;/code&gt; but then &lt;strong&gt;also&lt;/strong&gt; merges the code from the tracking branch into your current local version of that branch.  If you're not ready for that changes yet, just &lt;code&gt;git fetch&lt;/code&gt; first.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 会执行 &lt;code&gt;git fetch&lt;/code&gt; ,但&lt;strong&gt;还会&lt;/strong&gt;将代码从跟踪分支合并到该分支的当前本地版本中。 如果您尚未准备好进行更改，请先 &lt;code&gt;git fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83dddb338f277eb811f3fa092c792988c4cc0880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; is &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 是 &lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d4710698ef543c45dfe252e6667d70d2de5401d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; on the other hand will bring down the changes in the remote repository to where you keep your own code. Typically, &lt;code&gt;git pull&lt;/code&gt; will do a &lt;code&gt;git fetch&lt;/code&gt; first to bring the local copy of the remote repository up to date, and then it will merge the changes into your own code repository and possibly your working copy.</source>
          <target state="translated">另一方面， &lt;code&gt;git pull&lt;/code&gt; 会将远程存储库中的更改放到保留您自己的代码的位置。 通常， &lt;code&gt;git pull&lt;/code&gt; 将首先执行 &lt;code&gt;git fetch&lt;/code&gt; 以使远程存储库的本地副本保持最新，然后将更改合并到您自己的代码存储库中，并可能合并到您的工作副本中。</target>
        </trans-unit>
        <trans-unit id="05df4cf0322b9f13dcf1c7d31f7a70fd4b89be02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; pulls down from a remote and instantly merges.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 从远程下拉并立即合并。</target>
        </trans-unit>
        <trans-unit id="b05d4c0fb36f1dc05bc99a501e4370779ab4899c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; pulls from a remote branch and merges it.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 从远程分支中提取并合并。</target>
        </trans-unit>
        <trans-unit id="39b7979eb508edf5865501e23b13e6d4fb9fdf23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase&lt;/code&gt; saves stuff from your current branch that isn't in the upstream branch to a temporary area. Your branch is now the same as before you started your changes. So, &lt;code&gt;git pull -rebase&lt;/code&gt; will pull down the remote changes, rewind your local branch, replay your changes over the top of your current branch one by one until you're up-to-date.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; 将当前分支中不在上游分支中的内容保存到临时区域。 现在，您的分支与开始更改之前的分支相同。 因此， &lt;code&gt;git pull -rebase&lt;/code&gt; 将拉下远程更改，倒回本地分支，在当前分支的顶部逐一重放更改，直到最新。</target>
        </trans-unit>
        <trans-unit id="4eb4921d4ad3bfa6eaa086e761647f7cd8553d22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ls&lt;/code&gt;. This will show the files &amp;amp; directories. Nothing cool, I know.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 。 这将显示文件和目录。 没什么好酷的，我知道。</target>
        </trans-unit>
        <trans-unit id="ca25b56131b611133fad2dd0dd2d7dfa45581e04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any&lt;/em&gt;&lt;code&gt;git fetch&lt;/code&gt; that you do will update items in the &lt;code&gt;/.git/refs/remotes&lt;/code&gt; directory. It won't update anything in the &lt;code&gt;/.git/refs/heads&lt;/code&gt; directory.</source>
          <target state="translated">您执行的&lt;em&gt;任何&lt;/em&gt; &lt;code&gt;git fetch&lt;/code&gt; 都会更新 &lt;code&gt;/.git/refs/remotes&lt;/code&gt; 目录中的项目。 它不会更新 &lt;code&gt;/.git/refs/heads&lt;/code&gt; 目录中的任何内容。</target>
        </trans-unit>
        <trans-unit id="7a0c6624b35faf750cddb1f5c5e4877ebc30bedd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any&lt;/em&gt;&lt;code&gt;git pull&lt;/code&gt; will first do the &lt;code&gt;git fetch&lt;/code&gt;, update items in the &lt;code&gt;/.git/refs/remotes&lt;/code&gt; directory, then merge with your local and then change the head inside the &lt;code&gt;/.git/refs/heads&lt;/code&gt; directory.</source>
          <target state="translated">&lt;em&gt;任何&lt;/em&gt; &lt;code&gt;git pull&lt;/code&gt; 都将首先执行 &lt;code&gt;git fetch&lt;/code&gt; ，更新 &lt;code&gt;/.git/refs/remotes&lt;/code&gt; 目录中的项目，然后与本地文件合并，然后更改 &lt;code&gt;/.git/refs/heads&lt;/code&gt; 目录中的文件头。</target>
        </trans-unit>
        <trans-unit id="109168d936934938ef5217cf8bb337f828295f00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Git Fetch-&lt;/strong&gt; This will Download all the changes that have been made to the origin/main branch project which are not present in your local branch. And will wait for the Git Merge command to apply the changes that have been fetched to your Repository or branch.</source>
          <target state="translated">&lt;strong&gt;1. Git Fetch-&lt;/strong&gt;这将下载对&lt;strong&gt;Origin&lt;/strong&gt; / main分支项目所做的所有更改，这些更改在本地分支中不存在。 并且将等待Git Merge命令将已获取的更改应用于您的存储库或分支。</target>
        </trans-unit>
        <trans-unit id="c5bed844ff8564d2a50b21639fd4cdf812e9f691" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Git Pull-&lt;/strong&gt; This will update your local branch with the origin/main branch i.e. actually what it does is combination of Git Fetch and Git merge one after another.
&lt;em&gt;But this may Cause Conflicts to occur, so it&amp;rsquo;s recommended to use Git Pull with a clean copy.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;2. Git Pull-&lt;/strong&gt;这将用origin / main分支更新您的本地分支，即实际上它所做的是Git Fetch和Git的合并。 &lt;em&gt;但这可能会导致发生冲突，因此建议将Git Pull与干净副本一起使用。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bcbfd0fcb10b979a3e0380830ef7bab24a1e334" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git fetch&lt;/code&gt;&lt;/strong&gt; is the command that says &quot;bring my local copy of the remote repository up to date.&quot;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git fetch&lt;/code&gt; &lt;/strong&gt;是这样的命令：&amp;ldquo;使我的远程存储库的本地副本最新。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="8b77648ec75a644255f4be7f9dd3cb5598cd48b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull --rebase&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e785d95f0de347a936e7fda7fa2fa1299834bbee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/strong&gt; says &quot;bring the changes in the remote repository to where I keep my own code.&quot;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull&lt;/code&gt; &lt;/strong&gt;说&amp;ldquo;将远程存储库中的更改带到我自己保存代码的位置。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="5cb04c6741b8235615793d873684b0584c2a364e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Briefly&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Briefly&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ad1a5b0818ff680ca2bd9af2799ba236a6251f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Feedback&lt;/strong&gt; about the state of your local repo (for example, I use Atlassian's SourceTree, which will give me a bulb indicating if I'm commits ahead or behind compared to the origin. This information can be updated with a GIT FETCH).</source>
          <target state="translated">关于您本地仓库状态的&lt;strong&gt;反馈&lt;/strong&gt; （例如，我使用Atlassian的SourceTree，这将为我提供一个灯泡，指示相对于原产地，我是领先还是落后。可以使用GIT FETCH更新此信息）。</target>
        </trans-unit>
        <trans-unit id="f0d9c19e498edc94e1533273e0bc1b76808e356c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Git Fetch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Git获取&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="014ba1d3cfaa64368fbfa37d5c4581345df5482f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Git Merge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Git合并&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b07aaa0e6c31283c67bd262473d1a745931ce6c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Git Pull&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;吉特拉&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c98fe5935ce702c3af246dd6b37f9baf9e499b48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;More&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4071b6245e334d89c25a82984cc4f9f97267d26a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK&lt;/strong&gt;, here are some information about &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt;, so you can understand the actual differences... in few simple words, &lt;strong&gt;fetch&lt;/strong&gt; gets the latest data, but not the code changes and not going to mess with your current  local branch code, but &lt;strong&gt;pull&lt;/strong&gt; get the code changes and merge it your local branch, read on to get more details about each:</source>
          <target state="translated">&lt;strong&gt;好的&lt;/strong&gt; ，这里有一些有关 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git fetch&lt;/code&gt; 的信息 ，因此您可以了解实际的区别...简单来说， &lt;strong&gt;fetch&lt;/strong&gt;可以获取最新数据，但不会更改代码，也不会弄乱您当前的本地分支代码，但请获取代码更改并将其合并到您的本地分支中，继续阅读以获得有关每个代码的更多详细信息：</target>
        </trans-unit>
        <trans-unit id="d0ef5f55593d457090b8bc8d4819537557ea3aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt; (scroll through all commits and messages without trying to squeeze it through the network)</source>
          <target state="translated">&lt;strong&gt;性能&lt;/strong&gt; （滚动所有提交和消息，而无需尝试通过网络进行压缩）</target>
        </trans-unit>
        <trans-unit id="3fe24c79e200adaf76506563aeba6a1edd56ce9a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;git pull&lt;/code&gt; is what you would do to bring a local branch up-to-date with its remote version, while also updating your other remote-tracking branches.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 是您要执行的操作，以使本地分支机构具有其远程版本最新，同时还更新其他远程跟踪分支机构。</target>
        </trans-unit>
        <trans-unit id="6ddcfdae5fbd3c1f28805473e15e964fe04d16f4" translate="yes" xml:space="preserve">
          <source>A simple Graphical Representation for Beginners,</source>
          <target state="translated">初学者的简单图形化表示法。</target>
        </trans-unit>
        <trans-unit id="d52324965c9a6e58203263aaced4ecde8fd71b80" translate="yes" xml:space="preserve">
          <source>A very good related answer can also be found in &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27554859/where-does-git-fetch-place-itself/27555444#27555444&quot;&gt;Where does 'git fetch' place itself?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">一个很好的相关答案也可以在&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27554859/where-does-git-fetch-place-itself/27555444#27555444&quot;&gt;&amp;ldquo; git fetch&amp;rdquo;放置&lt;/a&gt;&lt;/em&gt;在&lt;em&gt;哪里？&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc500d77391d46e00d7b5c782a0ab25e90841a89" translate="yes" xml:space="preserve">
          <source>After downloading the updates, let's see the differences:</source>
          <target state="translated">下载完更新后,我们来看看区别。</target>
        </trans-unit>
        <trans-unit id="edf3db0309e01a8bcd864ab261176a621ee80299" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;git branch -a&lt;/code&gt; will show you exactly what&amp;rsquo;s going on with all your branches - local and remote.</source>
          <target state="translated">另外， &lt;code&gt;git branch -a&lt;/code&gt; 将向您确切显示所有分支（本地和远程）的最新情况。</target>
        </trans-unit>
        <trans-unit id="322c738050a772ccaa4aa6d80ca6d3abb420d9f8" translate="yes" xml:space="preserve">
          <source>Also, look for &quot;Slash notation&quot; from the &lt;a href=&quot;http://www.guyroutledge.co.uk/blog/git-branch-naming-conventions/&quot;&gt;Git branch naming conventions&lt;/a&gt; post. It helps you better understand how Git places things in different directories.</source>
          <target state="translated">另外，从&lt;a href=&quot;http://www.guyroutledge.co.uk/blog/git-branch-naming-conventions/&quot;&gt;Git分支命名约定&lt;/a&gt;文章中查找&amp;ldquo;斜杠表示法&amp;rdquo;。 它可以帮助您更好地了解Git如何将事物放置在不同目录中。</target>
        </trans-unit>
        <trans-unit id="f35d76827c3b43e78eae4be69f5a31adb50d9eed" translate="yes" xml:space="preserve">
          <source>Before pushing your new commits to server, try this command and it will automatically sync latest server changes (with a fetch + merge) and will place your commit at the top in git log. No need to worry about manual pull/merge.</source>
          <target state="translated">在将新提交推送到服务器上之前,尝试一下这个命令,它将自动同步服务器上的最新修改(用取值+合并),并将你的提交放在git日志的顶部。不需要担心手动pullmerge。</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="c20f309c89ab318ccde630455b592cf9a45e630d" translate="yes" xml:space="preserve">
          <source>But that's outdated and incorrect. It's because git will give you feedback solely based on what it knows. It's oblivious to new commits that it hasn't pulled down yet...</source>
          <target state="translated">但这是过时的,也是不正确的。这是因为git会完全根据它所知道的东西给你反馈。它对新的提交还没有拉下的新提交无动于衷......</target>
        </trans-unit>
        <trans-unit id="32155eafe73839b32c5ef69bafc03d8a5d24c849" translate="yes" xml:space="preserve">
          <source>By default, any tag that points into the histories being fetched is
  also fetched; the effect is to fetch tags that point at branches that
  you are interested in. This default behavior can be changed by using
  the --tags or --no-tags options or by configuring
  remote..tagOpt. By using a refspec that fetches tags explicitly,
  you can fetch tags that do not point into branches you are interested
  in as well.</source>
          <target state="translated">默认情况下,任何指向正在获取的历史记录的标记也会被获取;其效果是获取指向你感兴趣的分支的标记。这个默认行为可以通过使用 --tags 或 --no-tags 选项或配置 remote.tagOpt 来改变。通过使用显式提取标记的 refspec,你可以提取不指向你感兴趣的分支的标记。</target>
        </trans-unit>
        <trans-unit id="80ad85601183f99deb766161879cf4b25512ba7c" translate="yes" xml:space="preserve">
          <source>Copying new commits from remote branch to copy of this remote branch inside local repo.</source>
          <target state="translated">从远程分支复制新提交到本地repo内的这个远程分支。</target>
        </trans-unit>
        <trans-unit id="d537056fde34a1ba692f4e1ab02d8e216af2a6ff" translate="yes" xml:space="preserve">
          <source>Default values for  and  are read from the
  &quot;remote&quot; and &quot;merge&quot; configuration for the current branch as set by
  git-branch --track.</source>
          <target state="translated">默认值为和从当前分支的 &quot;远程 &quot;和 &quot;合并 &quot;配置中读出,由git-branch --track设置。</target>
        </trans-unit>
        <trans-unit id="4d979b1dc2b994c6f4248ba041d7bd399d114087" translate="yes" xml:space="preserve">
          <source>Do &lt;code&gt;cd .git&lt;/code&gt;. This will obviously change your directory.</source>
          <target state="translated">做 &lt;code&gt;cd .git&lt;/code&gt; 。 显然，这将更改您的目录。</target>
        </trans-unit>
        <trans-unit id="b2bcd7ea07d74b72cfb09e7b0c7e43e3d526a0b8" translate="yes" xml:space="preserve">
          <source>Fetch and merge run together often enough that a command that combines the two, pull, was created. Pull does a fetch and then a merge to add the downloaded commits into your local branch.</source>
          <target state="translated">Fetch和merge经常一起运行,因此,我们创建了一个将两者结合在一起的命令--pull。Pull会先进行提取,然后合并,将下载的提交添加到你的本地分支中。</target>
        </trans-unit>
        <trans-unit id="045598d48170bf40459b9e12cf8ab0455f608647" translate="yes" xml:space="preserve">
          <source>Fetch branches and/or tags (collectively, &quot;refs&quot;) from one or more
  other repositories, along with the objects necessary to complete their
  histories. Remote-tracking branches are updated (see the description
  of  below for ways to control this behavior).</source>
          <target state="translated">从一个或多个其他资源库中获取分支和或标签(统称为 &quot;refs&quot;),以及完成其历史记录所需的对象。远程跟踪分支被更新(关于控制该行为的方法,请参阅下面的描述)。</target>
        </trans-unit>
        <trans-unit id="d5f7709dcaf8382e5c15601d64bfe814cf8302eb" translate="yes" xml:space="preserve">
          <source>Fetching is what you do when you want to see what everybody &lt;em&gt;else&lt;/em&gt; has
  been working on. It&amp;rsquo;s similar to SVN update in that it lets you see
  how the central history has progressed, but it doesn&amp;rsquo;t force you to
  actually merge the changes into your repository. Git &lt;strong&gt;isolates
  fetched content as a from existing local content&lt;/strong&gt;, it has absolutely
  &lt;strong&gt;no effect on your local development work&lt;/strong&gt;. Fetched content has to be explicitly checked out using the &lt;code&gt;git checkout&lt;/code&gt; command. This makes
  fetching a safe way to review commits before integrating them with
  your local repository.</source>
          <target state="translated">当您想查看&lt;em&gt;其他&lt;/em&gt;所有人正在从事的工作时，获取就是您要做的。 它与SVN更新类似，它使您可以查看中央历史记录的进展情况，但并不会强迫您将更改实际合并到存储库中。 Git &lt;strong&gt;将获取的内容与现有的本地内容隔离开来&lt;/strong&gt; ，它绝对&lt;strong&gt;不会影响您的本地开发工作&lt;/strong&gt; 。 必须使用 &lt;code&gt;git checkout&lt;/code&gt; 命令显式地检出获取的内容。 这使得在将提交与本地存储库集成之前，可以获取一种安全的方式来查看提交。</target>
        </trans-unit>
        <trans-unit id="a094f4d7d41c2764c2f031fe68c19f7697500e17" translate="yes" xml:space="preserve">
          <source>Find details at: &lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;http://gitolite.com/git-pull--rebase&lt;/a&gt;</source>
          <target state="translated">有关详细信息，请访问： &lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;http&lt;/a&gt; : //gitolite.com/git-pull--rebase</target>
        </trans-unit>
        <trans-unit id="80a2b7deffd7046895901f3b9b3abd6954530694" translate="yes" xml:space="preserve">
          <source>For more on that read &lt;a href=&quot;https://stackoverflow.com/a/56464547/5175709&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">有关更多信息，请&lt;a href=&quot;https://stackoverflow.com/a/56464547/5175709&quot;&gt;点击此处&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f570924ec3541da08b064870361aa101628c76d" translate="yes" xml:space="preserve">
          <source>Fork local branch after last common ancestor and add new commits parallel to commits which are unique to local repository, finalized by merging commit, closing the fork.</source>
          <target state="translated">在最后一个共同祖先之后分叉本地分支,并在本地版本库中添加新的提交,与本地版本库中独有的提交并行,通过合并提交,关闭分叉来完成。</target>
        </trans-unit>
        <trans-unit id="7d246c9f13b103978089851b748ff4135c885e5a" translate="yes" xml:space="preserve">
          <source>From this awesome &lt;a href=&quot;https://www.atlassian.com/git/tutorials/syncing/git-fetch&quot;&gt;Atlassian tutorial&lt;/a&gt;:</source>
          <target state="translated">从这个很棒的&lt;a href=&quot;https://www.atlassian.com/git/tutorials/syncing/git-fetch&quot;&gt;Atlassian教程中&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c99c3c8141446381e894a09ddb5848bec036afb2" translate="yes" xml:space="preserve">
          <source>Fun tip:</source>
          <target state="translated">有趣的提示。</target>
        </trans-unit>
        <trans-unit id="23c19ce9cb1070c0d02d571d4b284d1506a224fc" translate="yes" xml:space="preserve">
          <source>Git allows chronologically older commits to be applied after newer commits.
Because of this, the act of transferring commits between repositories is split into two steps:</source>
          <target state="translated">Git 允许在新的提交之后,按时间顺序将旧的提交应用于新的提交。正因为如此,在存储库之间转移提交的行为被分成了两个步骤。</target>
        </trans-unit>
        <trans-unit id="92421bf16a875aff738a77da925b0817f0f4f80a" translate="yes" xml:space="preserve">
          <source>Git documentation &amp;ndash; &lt;a href=&quot;http://git-scm.com/docs/git-pull&quot;&gt;&lt;strong&gt;git pull&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">Git文档&amp;ndash; &lt;a href=&quot;http://git-scm.com/docs/git-pull&quot;&gt;&lt;strong&gt;git pull&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="fd037a056ee9a0a3ea17523512de78c92b929629" translate="yes" xml:space="preserve">
          <source>Git obtains the branch of the latest version from the remote to the local using two commands:</source>
          <target state="translated">Git通过两条命令从远程到本地获取最新版本的分支。</target>
        </trans-unit>
        <trans-unit id="033bc0378830e2cbf48b95032ab89e679a08ff04" translate="yes" xml:space="preserve">
          <source>Git was designed to support a more distributed model with no need for a central repository (though you can certainly use one if you like). Also git was designed so that the client and the &quot;server&quot; don't need to be online at the same time. Git was designed so that people on an unreliable link could exchange code via email, even. It is possible to work completely disconnected and burn a CD to exchange code via git.</source>
          <target state="translated">Git 的设计是为了支持更多的分布式模式,不需要中央仓库(当然如果你愿意的话,你也可以使用中央仓库)。另外,Git 的设计是为了让客户端和 &quot;服务器 &quot;不需要同时在线。git的设计是为了让不可靠的链接上的人可以通过电子邮件交换代码,甚至。可以完全断开连接工作,通过git刻录光盘来交换代码。</target>
        </trans-unit>
        <trans-unit id="9ce3409127465b71688de3971e312b082f6febd2" translate="yes" xml:space="preserve">
          <source>Great question. It puts it somewhere isolated from your working copy. But again where? Let's find out.</source>
          <target state="translated">很好的问题。它把它放在与你的工作副本隔离的地方。但又在哪里?让我们来了解一下。</target>
        </trans-unit>
        <trans-unit id="89be5c989f1e0a130d56642cfc8383c35bd91fe4" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;http://blog.osteele.com/2008/05/my-git-workflow/&quot;&gt;Oliver Steele's image of how all it all fits together&lt;/a&gt;:</source>
          <target state="translated">这是&lt;a href=&quot;http://blog.osteele.com/2008/05/my-git-workflow/&quot;&gt;奥利弗&amp;middot;斯蒂尔&lt;/a&gt; （ Oliver Steele）关于所有事物如何融合的图像 ：</target>
        </trans-unit>
        <trans-unit id="ce46f607307f3b5fb06075c64f8ceab45279bbdf" translate="yes" xml:space="preserve">
          <source>Hmmm...so if I'm not updating the working copy with &lt;code&gt;git fetch&lt;/code&gt;, then where am I making changes? Where does Git fetch store the new commits?</source>
          <target state="translated">嗯...所以，如果我不使用 &lt;code&gt;git fetch&lt;/code&gt; 更新工作副本，那么我在哪里进行更改？ Git提取将新提交存储在哪里？</target>
        </trans-unit>
        <trans-unit id="4ffdb142a405417c93bea94964a1c2c08c551de2" translate="yes" xml:space="preserve">
          <source>I also create the &lt;strong&gt;visual&lt;/strong&gt; below to show you how &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; working together...</source>
          <target state="translated">我还在下面创建了&lt;strong&gt;视觉效果&lt;/strong&gt; ，以向您展示 &lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git pull&lt;/code&gt; 如何协同工作...</target>
        </trans-unit>
        <trans-unit id="07e7f9e2e81d32cb59143090feeb634ba03b1447" translate="yes" xml:space="preserve">
          <source>I have struggled with this as well.  In fact I got here with a google search of exactly the same question.  Reading all these answers finally painted a picture in my head and I decided to try to get this down looking at the state of the 2 repositories and 1 sandbox and actions performed over time while watching the version of them.  So here is what I came up with.  Please correct me if I messed up anywhere.</source>
          <target state="translated">我也有过这样的挣扎。事实上,我在google上搜索到的正是同样的问题。阅读了所有这些答案,终于在我的脑海中画出了一幅图画,我决定尝试着把这个问题弄清楚,看看2个资源库和1个沙盒的状态,以及随着时间的推移,在观看它们的版本时执行的操作。所以,这就是我的想法。如果我有什么地方弄错了,请大家批评指正。</target>
        </trans-unit>
        <trans-unit id="5b18a32757feffb19b768293f3091d29d27efc26" translate="yes" xml:space="preserve">
          <source>I like to have some visual representation of the situation to grasp these things. Maybe other developers would like to see it too, so here's my addition. I'm not totally sure that it all is correct, so please comment if you find any mistakes.</source>
          <target state="translated">我喜欢有一些直观的表现形式来把握这些东西。也许其他开发者也想看,所以我在这里补充一下。我不完全确定这一切都是正确的,所以如果发现有错误的地方,请大家批评指正。</target>
        </trans-unit>
        <trans-unit id="c7489e43761289e99e5d7079c5c877cffd143154" translate="yes" xml:space="preserve">
          <source>I thought I'd update this to show how you'd actually use this in practice.</source>
          <target state="translated">我想我把这个更新一下,让大家看看实际操作中如何使用。</target>
        </trans-unit>
        <trans-unit id="821bc16e59a841d21fe7b78ce9b776cc6e35c5a5" translate="yes" xml:space="preserve">
          <source>If the remote master was updated you'll get a message like this:</source>
          <target state="translated">如果远程主控器被更新,你会收到这样的信息。</target>
        </trans-unit>
        <trans-unit id="68a0bdf0085c0a825e5be3356d84929da9c61aa6" translate="yes" xml:space="preserve">
          <source>If there is sufficient interest, I suppose I could update the image to add &lt;code&gt;git clone&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;...</source>
          <target state="translated">如果有足够的兴趣，我想我可以更新图像以添加 &lt;code&gt;git clone&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="37251fa3853fcc0155dc49884f3df2ca33eb64f1" translate="yes" xml:space="preserve">
          <source>If you already have a local repository with a remote set up for the desired project, you can grab all branches and tags for the existing remote using git fetch . ... Fetch does not make any changes to local branches, so you will need to merge a remote branch with a paired local branch to incorporate newly fetch changes. &lt;a href=&quot;https://help.github.com/articles/fetching-a-remote&quot;&gt;from github&lt;/a&gt;</source>
          <target state="translated">如果您已经有一个本地库，并为所需项目设置了远程设置，则可以使用git fetch获取现有远程设备的所有分支和标签。 ...提取不会对本地分支进行任何更改，因此您需要将远程分支与成对的本地分支合并以合并新的提取更改。 &lt;a href=&quot;https://help.github.com/articles/fetching-a-remote&quot;&gt;来自github&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1839fcd4628fab1f58094381ce5dd1ea362da0d4" translate="yes" xml:space="preserve">
          <source>If you didn't &lt;code&gt;fetch&lt;/code&gt; and just did &lt;code&gt;git checkout master&lt;/code&gt; then your local git wouldn't know that there are 2 commits added. And it would just say:</source>
          <target state="translated">如果您没有 &lt;code&gt;fetch&lt;/code&gt; 而只是 &lt;code&gt;git checkout master&lt;/code&gt; ,那么您本地的git将不会知道添加了2个提交。 它只会说：</target>
        </trans-unit>
        <trans-unit id="2d0b0d005c61420fbde841a3633e861f097628fc" translate="yes" xml:space="preserve">
          <source>If you do a &lt;code&gt;git fetch&lt;/code&gt; it will just fetch all the changes in the remote repository (&lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt;) and move the origin/master pointer to &lt;code&gt;HEAD&lt;/code&gt;. Meanwhile your local branch master will keep pointing to where it has.</source>
          <target state="translated">如果执行 &lt;code&gt;git fetch&lt;/code&gt; ，它将仅获取远程存储库（ &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt; ）中的所有更改，并将origin / master指针移至 &lt;code&gt;HEAD&lt;/code&gt; 。 同时，您的本地分支主管将继续指向其所在位置。</target>
        </trans-unit>
        <trans-unit id="900ae93a7953ff6e0661ac7270d3ba457b6be9a1" translate="yes" xml:space="preserve">
          <source>If you do a &lt;code&gt;git pull&lt;/code&gt;, it will do basically fetch (as explained previously) and merge any new changes to your master branch and move the pointer to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">如果您执行 &lt;code&gt;git pull&lt;/code&gt; ，则基本上会进行提取（如前所述），并将所有新更改合并到您的master分支中，然后将指针移至 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="616ab200c6c582d81e3203971545ff215f3fd330" translate="yes" xml:space="preserve">
          <source>If you fetched a remote branch e.g. did:</source>
          <target state="translated">如果你提取了一个远程分支,比如说:</target>
        </trans-unit>
        <trans-unit id="162dce9f88948f751bdbb44bdb42efa008599f93" translate="yes" xml:space="preserve">
          <source>If you find yourself in such a situation, you may be tempted to &lt;code&gt;git pull --rebase&lt;/code&gt;. Unless you really, really know what you are doing, I would advise against that. This warning is from the &lt;code&gt;man&lt;/code&gt; page for &lt;code&gt;git-pull&lt;/code&gt;, version &lt;code&gt;2.3.5&lt;/code&gt;:</source>
          <target state="translated">如果您发现自己处于这种情况，则可能会尝试 &lt;code&gt;git pull --rebase&lt;/code&gt; 。 除非您真的非常了解自己在做什么，否则我建议您不要这样做。 该警告来自 &lt;code&gt;git-pull&lt;/code&gt; 的 &lt;code&gt;man&lt;/code&gt; 页，版本 &lt;code&gt;2.3.5&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="39c38a4d2906ce12baf53b8235be890ca9c9a7e6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git pull&lt;/code&gt;, you do not need to merge the data to local. If you run &lt;code&gt;git fetch&lt;/code&gt;, it means you must run &lt;code&gt;git merge&lt;/code&gt; for getting the latest code to your local machine. Otherwise, the local machine code would not be changed without merge.</source>
          <target state="translated">如果运行 &lt;code&gt;git pull&lt;/code&gt; ，则不需要将数据合并到本地。 如果您运行 &lt;code&gt;git fetch&lt;/code&gt; ，这意味着您必须运行 &lt;code&gt;git merge&lt;/code&gt; 才能将最新代码获取到本地计算机。 否则，如果不合并，将不会更改本地机器代码。</target>
        </trans-unit>
        <trans-unit id="03ceca134f6aec86433fabaa1e2d3cc64a31e825" translate="yes" xml:space="preserve">
          <source>If you're happy with those updates, then merge:</source>
          <target state="translated">如果你对这些更新感到满意,那就合并。</target>
        </trans-unit>
        <trans-unit id="d8e1f252c15bb34d9198fe09a84d37f5ede75407" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;git&lt;/code&gt; terminology, step 1 is &lt;code&gt;git fetch&lt;/code&gt;, step 2 is &lt;code&gt;git merge&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;git&lt;/code&gt; 术语，第1步是 &lt;code&gt;git fetch&lt;/code&gt; ，第2步是 &lt;code&gt;git merge&lt;/code&gt; 或 &lt;code&gt;git rebase&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1bf2ca7db0931ab25be8665ddf93ce855960e77" translate="yes" xml:space="preserve">
          <source>In addition to pulling and pushing, &lt;a href=&quot;https://web.archive.org/web/20150321185928/http://mettadore.com/2011/09/07/the-ever-deployable-github-workflow//&quot;&gt;some workflows&lt;/a&gt; involve &lt;code&gt;git rebase&lt;/code&gt;, such as this one, which I paraphrase from the linked article:</source>
          <target state="translated">除了拉动和推入之外， &lt;a href=&quot;https://web.archive.org/web/20150321185928/http://mettadore.com/2011/09/07/the-ever-deployable-github-workflow//&quot;&gt;有些工作流程还&lt;/a&gt;涉及 &lt;code&gt;git rebase&lt;/code&gt; ，例如这一工作，我从链接文章中对此进行解释：</target>
        </trans-unit>
        <trans-unit id="e40cd3ac234494a2b0cc543cfa7294ec17721210" translate="yes" xml:space="preserve">
          <source>In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.</source>
          <target state="translated">在其默认模式下， &lt;code&gt;git pull&lt;/code&gt; 是 &lt;code&gt;git fetch&lt;/code&gt; 的简写，后跟 &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f7e63b5ace32e92fae98a294e280f5810ef0452" translate="yes" xml:space="preserve">
          <source>In order to support this model git maintains a local repository with your code and also an additional local repository that mirrors the state of the remote repository. By keeping a copy of the remote repository locally, git can figure out the changes needed even when the remote repository is not reachable.  Later when you need to send the changes to someone else, git can transfer them as a set of changes from a point in time known to the remote repository.</source>
          <target state="translated">为了支持这种模式,git会维护一个包含你的代码的本地版本库,同时也会维护一个镜像远程版本库状态的本地版本库。通过在本地保留一个远程仓库的副本,git即使在远程仓库无法访问的情况下,也能找出需要的修改。后来当你需要将更改发送给其他人时,git可以将其作为一组更改从已知的时间点转移到远程版本库中。</target>
        </trans-unit>
        <trans-unit id="6a10a3f8f133b33ad3434b087c4d2fc83bd4dacf" translate="yes" xml:space="preserve">
          <source>In simple terms, if you were about to hop onto a plane without any Internet connection...before departing you could just do &lt;code&gt;git fetch origin &amp;lt;master&amp;gt;&lt;/code&gt;. It would fetch all the changes into your computer, but keep it separate from your local development/workspace.</source>
          <target state="translated">简单来说，如果您要在没有任何互联网连接的情况下跳上飞机...在出发之前，您可以执行 &lt;code&gt;git fetch origin &amp;lt;master&amp;gt;&lt;/code&gt; 。 它会将所有更改取到您的计算机中，但要使其与本地开发/工作区分开。</target>
        </trans-unit>
        <trans-unit id="bf5cfd3242ed6010b1fce1f3aa3393b0bfbfe46f" translate="yes" xml:space="preserve">
          <source>In speaking of pull &amp;amp; fetch in the above answers, I would like to share an interesting trick,</source>
          <target state="translated">在上述答案中提到&amp;ldquo;拉取&amp;rdquo;时，我想分享一个有趣的技巧，</target>
        </trans-unit>
        <trans-unit id="1440ef61d3b0c55e8100941f7cbf808f72aa0deb" translate="yes" xml:space="preserve">
          <source>In the simplest terms, &lt;code&gt;git pull&lt;/code&gt; does a &lt;code&gt;git fetch&lt;/code&gt; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">用最简单的术语来说， &lt;code&gt;git pull&lt;/code&gt; 进行 &lt;code&gt;git fetch&lt;/code&gt; ,然后进行 &lt;code&gt;git merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9cc282a743496a57679827248fa33a56653ca44" translate="yes" xml:space="preserve">
          <source>In your project directory (i.e., where you do your &lt;code&gt;git&lt;/code&gt; commands) do:</source>
          <target state="translated">在项目目录（即执行 &lt;code&gt;git&lt;/code&gt; 命令的位置）中执行以下操作：</target>
        </trans-unit>
        <trans-unit id="7cd0fe622f2fa6d7cad2751f00997df5822d4092" translate="yes" xml:space="preserve">
          <source>Incorporates changes from a remote repository into the current branch.
  In its default mode, git pull is shorthand for git fetch followed by
  git merge FETCH_HEAD.</source>
          <target state="translated">将远程版本库中的更改合并到当前分支中。在默认模式下,git pull 是 git fetch 的速记,然后是 git merge FETCH_HEAD。</target>
        </trans-unit>
        <trans-unit id="ddab7bca2180329029b2fc8fd232bd55f5286278" translate="yes" xml:space="preserve">
          <source>Insert new commits after last common ancestor and reapply commits unique to local repository.</source>
          <target state="translated">在最后一个共同祖先之后插入新的提交,并重新应用本地版本库独有的提交。</target>
        </trans-unit>
        <trans-unit id="334fd4cec82b62628bf7b5a408786f48086b0f6c" translate="yes" xml:space="preserve">
          <source>Integrating new commits to local branch</source>
          <target state="translated">将新提交整合到本地分支</target>
        </trans-unit>
        <trans-unit id="3947829b4a816ebf3be376780b6f09ea82ecf1d1" translate="yes" xml:space="preserve">
          <source>Is there any way to see the new changes made in remote while working on the branch locally?</source>
          <target state="translated">有什么方法可以在本地工作的同时看到远程的新变化吗?</target>
        </trans-unit>
        <trans-unit id="a90f009f20779ef043c4c2b9008ab20ca6177bb2" translate="yes" xml:space="preserve">
          <source>It affects your local development.</source>
          <target state="translated">会影响到你们当地的发展。</target>
        </trans-unit>
        <trans-unit id="0f6ad1f6acc6290c33f3a14bd7e9acc98e2ea785" translate="yes" xml:space="preserve">
          <source>It cost me a little bit to understand what was the difference, but this is a simple explanation. &lt;code&gt;master&lt;/code&gt; in your localhost is a branch.</source>
          <target state="translated">我花了一点时间来了解有什么区别，但这只是一个简单的解释。 本地 &lt;code&gt;master&lt;/code&gt; 中的master是分支。</target>
        </trans-unit>
        <trans-unit id="c2392417cc36db01685d20f667bd966c4e212a13" translate="yes" xml:space="preserve">
          <source>It doesn't need to be explicitly checked out. Because it implicitly does a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">不需要显式签出。 因为它隐式地进行 &lt;code&gt;git merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f814b6881b236cbf383bb4fc1485995a7d5b1d8e" translate="yes" xml:space="preserve">
          <source>It is important to contrast the design philosophy of git with the philosophy of a more traditional source control tool like SVN.</source>
          <target state="translated">有必要对比一下git的设计理念和SVN等更传统的源码控制工具的理念。</target>
        </trans-unit>
        <trans-unit id="b6e153c12288f95caa3ff1df1c789423019cba8b" translate="yes" xml:space="preserve">
          <source>It is very important to note that &lt;code&gt;git pull&lt;/code&gt; will &lt;strong&gt;automatically merge whether you like it or not&lt;/strong&gt;. This could, of course, result in merge conflicts. Let's say your remote is &lt;code&gt;origin&lt;/code&gt; and your branch is &lt;code&gt;master&lt;/code&gt;. If you &lt;code&gt;git diff origin/master&lt;/code&gt; before pulling, you should have some idea of potential merge conflicts and could prepare your local branch accordingly.</source>
          <target state="translated">请务必注意， &lt;strong&gt;无论您是否喜欢&lt;/strong&gt; &lt;code&gt;git pull&lt;/code&gt; ,它都会&lt;strong&gt;自动合并&lt;/strong&gt; 。 当然，这可能会导致合并冲突。 假设您的远程服务器是 &lt;code&gt;origin&lt;/code&gt; ,而您的分支机构是 &lt;code&gt;master&lt;/code&gt; 。 如果在拉动前 &lt;code&gt;git diff origin/master&lt;/code&gt; ，则应该对潜在的合并冲突有所了解，并可以相应地准备本地分支。</target>
        </trans-unit>
        <trans-unit id="98ba93bc2857bab25c62222873602c9b7282098e" translate="yes" xml:space="preserve">
          <source>It will apply the changes from &lt;strong&gt;remote&lt;/strong&gt; to the &lt;strong&gt;current branch&lt;/strong&gt; in local...</source>
          <target state="translated">它将更改从&lt;strong&gt;远程&lt;/strong&gt;应用于本地的&lt;strong&gt;当前分支&lt;/strong&gt; ...</target>
        </trans-unit>
        <trans-unit id="2089f5ff30d1f915932544997ca4f31cb09b33ab" translate="yes" xml:space="preserve">
          <source>It will download all &lt;strong&gt;refs&lt;/strong&gt; and &lt;strong&gt;objects&lt;/strong&gt; and any new branches to your local Repository...</source>
          <target state="translated">它将所有&lt;strong&gt;参考&lt;/strong&gt;和&lt;strong&gt;对象&lt;/strong&gt;以及任何新分支下载到本地存储库...</target>
        </trans-unit>
        <trans-unit id="e3692defe3bb907ef3be26614797cff88e4beadd" translate="yes" xml:space="preserve">
          <source>It's basically NOT safe. It's aggressive.</source>
          <target state="translated">这基本上是不安全的。它的攻击性很强。</target>
        </trans-unit>
        <trans-unit id="0132137c4a419c936535f54c395be92a1c9ac4b0" translate="yes" xml:space="preserve">
          <source>It's interesting to see what's inside all directories, but let's focus on two of them. &lt;code&gt;heads&lt;/code&gt; and &lt;code&gt;remotes&lt;/code&gt;. Use &lt;code&gt;cd&lt;/code&gt; to check inside them too.</source>
          <target state="translated">看看所有目录中都有什么很有趣，但让我们集中讨论其中两个。 &lt;code&gt;heads&lt;/code&gt; 和 &lt;code&gt;remotes&lt;/code&gt; 。 也使用 &lt;code&gt;cd&lt;/code&gt; 检查它们的内部。</target>
        </trans-unit>
        <trans-unit id="5b60559fd8e2d2e8e3af93f7c4acc4a9ffbf1885" translate="yes" xml:space="preserve">
          <source>Just do:</source>
          <target state="translated">只是做。</target>
        </trans-unit>
        <trans-unit id="3e188073ca4a40a44969a8d4d808539ffc6cabc5" translate="yes" xml:space="preserve">
          <source>Let's take an example that you are working on a project with your team members. So their will be one main Branch of the project and all the contributors must fork it to their own local repository and then work on this local branch to modify/Add modules then push back to the main branch.</source>
          <target state="translated">让我们举个例子,你和你的团队成员一起做一个项目。所以他们的项目将有一个主分支,所有的贡献者必须把它分叉到自己的本地仓库,然后在这个本地分支上修改Add模块,然后推送回主分支。</target>
        </trans-unit>
        <trans-unit id="edd3e1409412e78ff0c9eb0c5bb64845286a8e9b" translate="yes" xml:space="preserve">
          <source>More precisely, git pull runs git fetch with the given parameters and
  calls git merge to merge the retrieved branch heads into the current
  branch. With --rebase, it runs git rebase instead of git merge.</source>
          <target state="translated">更准确地说,git pull使用给定参数运行git fetch,然后调用git merge将检索到的分支头合并到当前分支中。使用 --rebase,它运行 git rebase 而不是 git merge。</target>
        </trans-unit>
        <trans-unit id="a2ba818d6ed9eeb75fb53e2017802c7157f637d4" translate="yes" xml:space="preserve">
          <source>Normally &lt;strong&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/strong&gt; does this by doing a &lt;strong&gt;&lt;code&gt;git fetch&lt;/code&gt;&lt;/strong&gt; to bring the local copy of the remote repository up to date, and then merging the changes into your own code repository and possibly your working copy.</source>
          <target state="translated">通常， &lt;strong&gt; &lt;code&gt;git pull&lt;/code&gt; &lt;/strong&gt;通过执行&lt;strong&gt; &lt;code&gt;git fetch&lt;/code&gt; &lt;/strong&gt;来使远程存储库的本地副本保持最新，然后将更改合并到您自己的代码存储库以及可能的工作副本中来实现。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="31d7bbcc8cef085a2d26f7ea2b1d782e5569ba33" translate="yes" xml:space="preserve">
          <source>Now comes the fun part; do &lt;code&gt;ls&lt;/code&gt;. You will see a list of directories. We're looking for &lt;code&gt;refs&lt;/code&gt;. Do &lt;code&gt;cd refs&lt;/code&gt;.</source>
          <target state="translated">有趣的来了; 做 &lt;code&gt;ls&lt;/code&gt; 。 您将看到目录列表。 我们正在寻找 &lt;code&gt;refs&lt;/code&gt; 。 做 &lt;code&gt;cd refs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fac4b1246d10c655b4749fcfaf3e582fa75b4dbe" translate="yes" xml:space="preserve">
          <source>Now do &lt;code&gt;ls -a&lt;/code&gt;. This will show &lt;a href=&quot;https://unix.stackexchange.com/questions/21778/whats-so-special-about-directories-whose-names-begin-with-a-dot&quot;&gt;dot files&lt;/a&gt;, i.e., files beginning with &lt;code&gt;.&lt;/code&gt; You will then be able to see a directory named: &lt;code&gt;.git&lt;/code&gt;.</source>
          <target state="translated">现在执行 &lt;code&gt;ls -a&lt;/code&gt; 。 这将显示&lt;a href=&quot;https://unix.stackexchange.com/questions/21778/whats-so-special-about-directories-whose-names-begin-with-a-dot&quot;&gt;点文件&lt;/a&gt; ，即以开头的文件 &lt;code&gt;.&lt;/code&gt; 然后，您将能够看到一个名为 &lt;code&gt;.git&lt;/code&gt; 的目录 。</target>
        </trans-unit>
        <trans-unit id="73721acace98d4f33af7597d3ca64e03bf13917d" translate="yes" xml:space="preserve">
          <source>Now, you have started working on the new module (suppose &lt;code&gt;D&lt;/code&gt;)  and when you have completed the &lt;code&gt;D&lt;/code&gt; module you want to push it to the main branch, But meanwhile what happens is that one of your teammates has developed new Module &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt; and modified &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">现在，您已经开始研究新模块（假设 &lt;code&gt;D&lt;/code&gt; ），并在完成 &lt;code&gt;D&lt;/code&gt; 模块后将其推送到主分支，但是同时发生的是，您的一个队友已经开发了新的Module &lt;code&gt;E&lt;/code&gt; ， &lt;code&gt;F&lt;/code&gt; 和修改后的 &lt;code&gt;C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42575cb4c2af958800f2814be4eeb10c93d88c70" translate="yes" xml:space="preserve">
          <source>On step 2: For more on diffs between local and remotes, see: &lt;a href=&quot;https://stackoverflow.com/questions/1800783/compare-local-git-branch-with-remote-branch&quot;&gt;How to compare a local git branch with its remote branch?&lt;/a&gt;</source>
          <target state="translated">关于步骤2：有关本地和远程之间差异的更多信息，请参见： &lt;a href=&quot;https://stackoverflow.com/questions/1800783/compare-local-git-branch-with-remote-branch&quot;&gt;如何将本地git分支与其远程分支进行比较？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba10303cc8bc29ae6d60675a38b4b1414538852e" translate="yes" xml:space="preserve">
          <source>On step 3: It's probably more accurate (e.g. on a fast changing repo) to do a &lt;code&gt;git rebase origin&lt;/code&gt; here. See &lt;a href=&quot;https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch#comment16374948_5376768&quot;&gt;@Justin Ohms comment&lt;/a&gt; in another answer.</source>
          <target state="translated">在第3步：在此处执行 &lt;code&gt;git rebase origin&lt;/code&gt; 可能更准确（例如，在快速更改的仓库上）。 参见&lt;a href=&quot;https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch#comment16374948_5376768&quot;&gt;@Justin Ohms&lt;/a&gt;的其他回答。</target>
        </trans-unit>
        <trans-unit id="a6ef3be4cb93c5c3a4ab715204573fa2c48f5d9e" translate="yes" xml:space="preserve">
          <source>On the plane, you could make changes to your local workspace and then merge it with what you've fetched and resolve potential merge conflicts all without a connection to the Internet. And unless someone had made &lt;em&gt;new&lt;/em&gt; conflicting changes to the remote repository then once you arrive at the destination you would do &lt;code&gt;git push origin &amp;lt;branch&amp;gt;&lt;/code&gt; and go get your coffee.</source>
          <target state="translated">在飞机上，您可以更改本地工作区，然后将其与获取的内容合并，并解决潜在的合并冲突，而无需连接到Internet。 除非有人对远程存储库进行了&lt;em&gt;新的&lt;/em&gt;冲突更改，否则一旦到达目的地，您将执行 &lt;code&gt;git push origin &amp;lt;branch&amp;gt;&lt;/code&gt; 并获取咖啡。</target>
        </trans-unit>
        <trans-unit id="2cd6dde17abde81f58ef155464001d7b9bdcaf42" translate="yes" xml:space="preserve">
          <source>One use case of &lt;code&gt;git fetch&lt;/code&gt; is that the following will tell you any changes in the remote branch since your last pull... so you can check before doing an actual pull, which could change files in your current branch and working copy.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 的一个用例是，以下内容将告诉您自上次拉取以来远程分支中的任何更改...，因此您可以在进行实际拉取之前进行检查，这可能会更改当前分支和工作副本中的文件。</target>
        </trans-unit>
        <trans-unit id="75ae635968f07616c5219d6807711a230311e03a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&quot;&gt;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&lt;/a&gt;</source>
          <target state="translated">另请参阅： &lt;a href=&quot;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&quot;&gt;http&lt;/a&gt; : //longair.net/blog/2009/04/16/git-fetch-and-merge/</target>
        </trans-unit>
        <trans-unit id="8c270f0e70944669bd1713d611d6988fa74b8a56" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://git-scm.com/docs/git-diff&quot;&gt;https://git-scm.com/docs/git-diff&lt;/a&gt; regarding double- and triple-dot syntax in the diff command</source>
          <target state="translated">有关diff命令中的双点和三点语法，请参见： &lt;a href=&quot;https://git-scm.com/docs/git-diff&quot;&gt;https&lt;/a&gt; ://git-scm.com/docs/git-diff</target>
        </trans-unit>
        <trans-unit id="687ecbf1bdace513420218a49095b8dd9ec63b90" translate="yes" xml:space="preserve">
          <source>So in the Git Gui, when you do fetch, you have to merge the data. Fetch itself won't make the code changes at your local. You can check that when you update the code by fetching
once fetch and see; the code it won't change. Then you merge... You will see the changed code.</source>
          <target state="translated">所以在Git Gui中,当你做fetch的时候,你必须要合并数据。Fetch本身不会让你本地的代码发生变化。你可以检查一下,当你更新代码的时候,通过fetch一次fetch,看看;代码它不会改变。然后你再合并.....你会看到修改后的代码。</target>
        </trans-unit>
        <trans-unit id="7a5191917188b0327a691ee3901a3d3f280832ae" translate="yes" xml:space="preserve">
          <source>So now You can carefully monitor the files before merging it to your repository. And you can also modify &lt;code&gt;D&lt;/code&gt; if required because of Modified &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">因此，现在您可以在将文件合并到存储库之前仔细监视文件。 而且，由于修改了 &lt;code&gt;C&lt;/code&gt; ，您还可以根据需要修改 &lt;code&gt;D&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7d6ea2d421748f38bd60628b104ed7a0bc8b46c" translate="yes" xml:space="preserve">
          <source>So now what has happened is that your local repository is lacking behind the original progress of the project and thus pushing of your changes to main branch can lead to conflict and may cause your Module &lt;code&gt;D&lt;/code&gt; to malfunction.</source>
          <target state="translated">因此，现在发生的事情是您的本地存储库缺少项目的原始进度，因此将更改推送到主分支可能会导致冲突，并可能导致模块 &lt;code&gt;D&lt;/code&gt; 发生故障。</target>
        </trans-unit>
        <trans-unit id="6e65b7a5f79a6bd25bc0956f180c6958876f5aa3" translate="yes" xml:space="preserve">
          <source>So the difference will be:</source>
          <target state="translated">所以说,差别将是。</target>
        </trans-unit>
        <trans-unit id="bab2af816ba39862eca729b2dd19f6e2a7dec4aa" translate="yes" xml:space="preserve">
          <source>So, 
&lt;strong&gt;Initial State&lt;/strong&gt; of the two Branches when you forked the main project on your local repository will be like this- (&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; are Modules already completed of the project)</source>
          <target state="translated">因此，当您在本地存储库中分叉主项目时，两个分支的&lt;strong&gt;初始状态&lt;/strong&gt;将如下所示（（ &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 是该项目已完成的模块）</target>
        </trans-unit>
        <trans-unit id="c509dfe0d9ecadd21477e5ea89036c82c3331aa1" translate="yes" xml:space="preserve">
          <source>Some IDEs (e.g. Xcode) are super smart and use the result of a &lt;code&gt;git fetch&lt;/code&gt; and can annotate the lines of code that have been changed in remote branch of your current working branch. If that line has been changed by both local changes and remote branch, then that line gets annotated with red. This isn't a merge conflict. It's a &lt;em&gt;potential&lt;/em&gt; merge conflict. It's a headsup that you can use to resolve the future merge conflict before doing &lt;code&gt;git pull&lt;/code&gt; from the remote branch.</source>
          <target state="translated">某些IDE（例如Xcode）非常智能，并使用 &lt;code&gt;git fetch&lt;/code&gt; 的结果，并且可以注释当前工作分支的远程分支中已更改的代码行。 如果该行已被本地更改和远程分支更改，则该行将用红色注释。 这不是合并冲突。 这是&lt;em&gt;潜在的&lt;/em&gt;合并冲突。 在从远程分支执行 &lt;code&gt;git pull&lt;/code&gt; 之前，可以使用此提示来解决将来的合并冲突。</target>
        </trans-unit>
        <trans-unit id="751516aaf56e4a009d9a95473521f2b5e4a91c6b" translate="yes" xml:space="preserve">
          <source>Some major advantages for having a fetched mirror of the remote are:</source>
          <target state="translated">有了远处的托物镜的一些主要优势是:。</target>
        </trans-unit>
        <trans-unit id="f116feeed3453af125cc94651d00b568b3382b73" translate="yes" xml:space="preserve">
          <source>Sometimes a visual representation helps.</source>
          <target state="translated">有时候,视觉上的表现形式会有帮助。</target>
        </trans-unit>
        <trans-unit id="13de40234719d2a5e55c0bc0833165ebde52b54e" translate="yes" xml:space="preserve">
          <source>Subversion was designed and built with a client/server model. There is a single repository that is the server, and several clients can fetch code from the server, work on it, then commit it back to the server. The assumption is that the client can always contact the server when it needs to perform an operation.</source>
          <target state="translated">Subversion的设计和构建采用了客户端服务器模式。有一个单独的代码库作为服务器,多个客户端可以从服务器上获取代码,并对其进行操作,然后将其提交回服务器。假设是客户端需要执行操作时,可以随时联系服务器。</target>
        </trans-unit>
        <trans-unit id="cbe53d654abeea87d780df2cbb35f48b293f4ab8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fetch&lt;/code&gt; command downloads commits, files, and refs from a
  remote repository into your local repository.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 命令将提交，文件和引用从远程存储库下载到本地存储库。</target>
        </trans-unit>
        <trans-unit id="306f6d2083f24839bb90d29d30ccdf4811f10c03" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;git pull&lt;/strong&gt; command is actually a &lt;code&gt;shortcut&lt;/code&gt; for &lt;strong&gt;git fetch&lt;/strong&gt; followed by the &lt;strong&gt;git merge&lt;/strong&gt; or the &lt;strong&gt;git rebase&lt;/strong&gt; command depending on your configuration. You can configure your Git repository so that &lt;strong&gt;git pull&lt;/strong&gt; is a fetch followed by a rebase.</source>
          <target state="translated">&lt;strong&gt;git pull&lt;/strong&gt;命令实际上是&lt;strong&gt;git fetch&lt;/strong&gt;的 &lt;code&gt;shortcut&lt;/code&gt; ，其后是&lt;strong&gt;git merge&lt;/strong&gt;或&lt;strong&gt;git rebase&lt;/strong&gt;命令，具体取决于您的配置。 您可以配置您的Git存储库，以便&lt;strong&gt;git pull&lt;/strong&gt;是在获取内容后进行重新设置的基础。</target>
        </trans-unit>
        <trans-unit id="35c94b59a53fa50c4f5c982a81436bdd806fd908" translate="yes" xml:space="preserve">
          <source>The Difference between &lt;strong&gt;GIT Fetch&lt;/strong&gt; and &lt;strong&gt;GIT Pull&lt;/strong&gt; can be explained with the following scenario:
&lt;em&gt;(Keeping in mind that pictures speak louder than words!, I have provided pictorial representation)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;GIT Fetch&lt;/strong&gt;和&lt;strong&gt;GIT Pull&lt;/strong&gt;之间的区别可以用以下情况来解释：（ &lt;em&gt;请记住，图片说得比单词要响亮！，我提供了图片表示法）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53f91a7e62942e203876dd071752da5d13ec2baf" translate="yes" xml:space="preserve">
          <source>The difference between git pull, git fetch and git clone (and git rebase) - Mike Pearce</source>
          <target state="translated">git pull、git fetch和git clone(和git rebase)之间的区别-Mike Pearce</target>
        </trans-unit>
        <trans-unit id="f9d05bd2faa3f1351a188371811118689f8a1ab7" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names
  they point at, are written to .git/FETCH_HEAD. This information may be
  used by scripts or other git commands, such as git-pull.</source>
          <target state="translated">被提取的 refs 的名称,以及它们所指向的对象名称都会被写入 .gitFETCH_HEAD。这些信息可以被脚本或其他 git 命令使用,例如 git-pull。</target>
        </trans-unit>
        <trans-unit id="709e4c591c9ada67d70a258e7e4251499d7ac05f" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt; is that :</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git fetch&lt;/code&gt; 之间的唯一区别是：</target>
        </trans-unit>
        <trans-unit id="76daff5996e8269d3dd02ea66d3869e8f9168b82" translate="yes" xml:space="preserve">
          <source>The short and easy answer is that &lt;code&gt;git pull&lt;/code&gt; is simply &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">简短而简单的答案是 &lt;code&gt;git pull&lt;/code&gt; 是 &lt;code&gt;git fetch&lt;/code&gt; ,然后是 &lt;code&gt;git merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51513cadff1ee5095c8df532e4e37c7e6e2a0fb0" translate="yes" xml:space="preserve">
          <source>The take away is to keep in mind that there are often at least &lt;strong&gt;three copies&lt;/strong&gt; of a project on your workstation. One copy is your own repository with your own commit history. The second copy is your working copy where you are editing and building. The third copy is your local &quot;cached&quot; copy of a remote repository.</source>
          <target state="translated">要记住的是，您的工作站上通常至少有&lt;strong&gt;三个&lt;/strong&gt;项目的&lt;strong&gt;副本&lt;/strong&gt; 。 一个副本是您自己的存储库，具有自己的提交历史记录。 第二个副本是您正在编辑和构建的工作副本。 第三个副本是远程存储库的本地&amp;ldquo;缓存&amp;rdquo;副本。</target>
        </trans-unit>
        <trans-unit id="e6efaade8678bbf79f86466455ab8588f51ff88e" translate="yes" xml:space="preserve">
          <source>The three repos with a fetch:</source>
          <target state="translated">这三家的repos有一个取法。</target>
        </trans-unit>
        <trans-unit id="96306d9d7afb366db3fd8034aacc498461c28b62" translate="yes" xml:space="preserve">
          <source>The three repos with a pull</source>
          <target state="translated">这三个版本中,有一个拉动</target>
        </trans-unit>
        <trans-unit id="a2f54e0cd5a7689c3b9e61f6dd82d101a2ed1953" translate="yes" xml:space="preserve">
          <source>Then this would go into your remotes directory. It's still not available to your local directory. However, it simplifies your checkout to that remote branch by DWIM (Do what I mean):</source>
          <target state="translated">那么这个会进入你的远程目录。它仍然无法进入你的本地目录。但是,它可以通过DWIM(Do what I mean)来简化你的结账到那个远程分支。</target>
        </trans-unit>
        <trans-unit id="55a7d6a0db4ebe297f2d43c4272f3114636d3660" translate="yes" xml:space="preserve">
          <source>There are two ways of doing step 2. You can:</source>
          <target state="translated">第2步有两种方法。你可以:</target>
        </trans-unit>
        <trans-unit id="22479224c315e3ac8965a8d67b70537247f8ee88" translate="yes" xml:space="preserve">
          <source>This above command is the most useful command in my git life which saved a lots of time.</source>
          <target state="translated">上面这条命令是我在git生活中最有用的命令,它节省了很多时间。</target>
        </trans-unit>
        <trans-unit id="d295d38717fafe8c79328dc8ddc3deb6761388e0" translate="yes" xml:space="preserve">
          <source>This blog post was useful:</source>
          <target state="translated">这篇博文很有用。</target>
        </trans-unit>
        <trans-unit id="0a829a2d422289272de5ab855cb5e9577ba60534" translate="yes" xml:space="preserve">
          <source>This helped me understand why a fetch is pretty important.</source>
          <target state="translated">这让我明白了为什么拿取是相当重要的。</target>
        </trans-unit>
        <trans-unit id="5d5082feffe5ba17e1674f6f1a13809963795a02" translate="yes" xml:space="preserve">
          <source>This interactive graphical representation is very helpful in understanging git: &lt;a href=&quot;http://ndpsoftware.com/git-cheatsheet.html&quot;&gt;http://ndpsoftware.com/git-cheatsheet.html&lt;/a&gt;</source>
          <target state="translated">这种交互式的图形表示形式对理解git很有帮助： &lt;a href=&quot;http://ndpsoftware.com/git-cheatsheet.html&quot;&gt;http&lt;/a&gt; : //ndpsoftware.com/git-cheatsheet.html</target>
        </trans-unit>
        <trans-unit id="c03e8aa568e39354d4fef8b90850b194009b133d" translate="yes" xml:space="preserve">
          <source>This is a potentially dangerous mode of operation. It rewrites
  history, which does not bode well when you published that history
  already. Do not use this option unless you have read git-rebase(1)
  carefully.</source>
          <target state="translated">这是一种潜在的危险操作模式。它重写了历史记录,当你已经发布了历史记录时,这不是什么好兆头。除非你仔细阅读了 git-rebase(1),否则不要使用这个选项。</target>
        </trans-unit>
        <trans-unit id="6d4d3f7cd0b544f4693755b4f708541dcaf1fb43" translate="yes" xml:space="preserve">
          <source>This is an example for a remote repository called &lt;code&gt;origin&lt;/code&gt; and a branch called &lt;code&gt;master&lt;/code&gt; tracking the remote branch &lt;code&gt;origin/master&lt;/code&gt;:</source>
          <target state="translated">这是一个名为 &lt;code&gt;origin&lt;/code&gt; 的远程存储库和一个名为 &lt;code&gt;master&lt;/code&gt; 的分支的示例，该分支跟踪远程分支的 &lt;code&gt;origin/master&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="538591b00fc41f249782e67a77ba3727e103f194" translate="yes" xml:space="preserve">
          <source>This operation never changes any of your own local branches under &lt;code&gt;refs/heads&lt;/code&gt;, and is safe to do without changing your working copy. I have even heard of people running &lt;code&gt;git fetch&lt;/code&gt; periodically in a cron job in the background (although I wouldn't recommend doing this).</source>
          <target state="translated">此操作绝不会在 &lt;code&gt;refs/heads&lt;/code&gt; 下更改您自己的任何本地分支，并且可以安全地执行而无需更改工作副本。 我什至听说有人在后台执行cron作业中定期运行 &lt;code&gt;git fetch&lt;/code&gt; （尽管我不建议这样做）。</target>
        </trans-unit>
        <trans-unit id="be526cd7b29f7539ab21c31c8d6a75b818a2623e" translate="yes" xml:space="preserve">
          <source>To avoid such issues and to work parallel with the original progress of the project their are Two ways:</source>
          <target state="translated">为了避免这类问题,并与项目的原始进度并行,他们有两种方式。</target>
        </trans-unit>
        <trans-unit id="9cdf14da3817f6628ec1361bea603aa959657fdc" translate="yes" xml:space="preserve">
          <source>To see the actual difference</source>
          <target state="translated">要看实际的区别</target>
        </trans-unit>
        <trans-unit id="e5f1d7a647255e501edc50ce9e6aa00b9187d82d" translate="yes" xml:space="preserve">
          <source>To understand this, you first need to understand that your local git maintains not only your local repository, but it also maintains a local copy of the remote repository.</source>
          <target state="translated">要理解这一点,你首先需要明白,你的本地git不仅维护你的本地版本库,还维护着远程版本库的本地副本。</target>
        </trans-unit>
        <trans-unit id="ffc16a6560848a6d7f779bb9aced6fdf7c588383" translate="yes" xml:space="preserve">
          <source>Trying to be clear and simple.</source>
          <target state="translated">尽量说得简单明了一些。</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="332032088e32c31d232f02474810d74702bd1d78" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git fetch&lt;/code&gt; where it only affects your &lt;code&gt;.git/refs/remotes&lt;/code&gt;, git pull will affect both your &lt;code&gt;.git/refs/remotes&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;code&gt;.git/refs/heads/&lt;/code&gt;</source>
          <target state="translated">不同于 &lt;code&gt;git fetch&lt;/code&gt; 仅会影响您的 &lt;code&gt;.git/refs/remotes&lt;/code&gt; ，而git pull将同时影响您的 &lt;code&gt;.git/refs/remotes&lt;/code&gt; &lt;strong&gt;和&lt;/strong&gt; &lt;code&gt;.git/refs/heads/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d13c88e54fc8efb180fc6b3b27421a7fb284a530" translate="yes" xml:space="preserve">
          <source>Update your local repo from the remote (but don't merge):</source>
          <target state="translated">从远程更新你的本地repo(但不要合并)。</target>
        </trans-unit>
        <trans-unit id="8f6be89be11acde27b9603fe48a423a16c6df9dc" translate="yes" xml:space="preserve">
          <source>We simply say:</source>
          <target state="translated">我们简单地说:</target>
        </trans-unit>
        <trans-unit id="ea59d40483dcdff606446c1278db4f30b88410e8" translate="yes" xml:space="preserve">
          <source>What are the differences between &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git fetch&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="f4a4b649621d7f1f61aa3c746531b2f6672b090d" translate="yes" xml:space="preserve">
          <source>What is the difference between 'git pull' and 'git fetch'</source>
          <target state="translated">git pull &quot;和 &quot;git fetch &quot;有什么区别?</target>
        </trans-unit>
        <trans-unit id="bc03f833fd7c52d8a1b370a5afba995d1e6fe5f2" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git fetch&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="b8cf24993f0288b5cc2c819833af209e300e949c" translate="yes" xml:space="preserve">
          <source>When downloading content from a remote repository, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt; commands are available to accomplish the task. You can consider
  &lt;code&gt;git fetch&lt;/code&gt; the 'safe' version of the two commands. It will download
  the remote content, but not update your local repository's working state,
  leaving your current work intact. &lt;code&gt;git pull&lt;/code&gt; is the more aggressive
  alternative, it will download the remote content for the active local
  branch and immediately execute &lt;code&gt;git merge&lt;/code&gt; to create a merge commit
  for the new remote content. If you have pending changes in progress
  this will cause conflicts and kickoff the merge conflict resolution
  flow.</source>
          <target state="translated">从远程存储库下载内容时，可以使用 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git fetch&lt;/code&gt; 命令来完成任务。 您可以考虑 &lt;code&gt;git fetch&lt;/code&gt; 这两个命令的&amp;ldquo;安全&amp;rdquo;版本。 它将下载远程内容，但不会更新本地存储库的工作状态，而使当前工作保持不变。 &lt;code&gt;git pull&lt;/code&gt; 是更具攻击性的选择，它将为活动的本地分支下载远程内容，并立即执行 &lt;code&gt;git merge&lt;/code&gt; 为新的远程内容创建合并提交。 如果您有待处理的变更，这将导致冲突并启动合并冲突解决流程。</target>
        </trans-unit>
        <trans-unit id="90241fc66dccec755b7f7a1db64386e32d1975aa" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the origin remote will be
  used, unless there&amp;rsquo;s an upstream branch configured for the current
  branch.</source>
          <target state="translated">如果未指定任何远程，默认情况下将使用源远程，除非为当前分支配置了上游分支。</target>
        </trans-unit>
        <trans-unit id="f29d1d15a178302f133f949f8f12fc0d9c744655" translate="yes" xml:space="preserve">
          <source>When you &lt;code&gt;fetch&lt;/code&gt;, Git gathers any commits from the target branch that do not exist in your current branch and &lt;strong&gt;stores them in your local repository&lt;/strong&gt;. However, &lt;strong&gt;it does not merge them with your current branch&lt;/strong&gt;. This is particularly useful if you need to keep your repository up to date, but are working on something that might break if you update your files. 
To integrate the commits into your master branch, you use &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; ，Git从目标分支中收集当前分支中不存在的所有提交，并将&lt;strong&gt;它们存储在本地存储库中&lt;/strong&gt; 。 但是， &lt;strong&gt;它不会将它们与当前分支合并&lt;/strong&gt; 。 如果您需要使存储库保持最新状态，但是正在进行某些可能会在更新文件时中断的工作，则此功能特别有用。 要将提交集成到您的master分支中，请使用 &lt;code&gt;merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f6b2b23ee6b56459eb33e7764e459ba74679007" translate="yes" xml:space="preserve">
          <source>When you clone a repository you fetch the entire repository to you local host. This means that at that time you have an origin/master pointer to &lt;code&gt;HEAD&lt;/code&gt; and master pointing to the same &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">克隆存储库时，会将整个存储库获取到本地主机。 这意味着那时您有一个指向 &lt;code&gt;HEAD&lt;/code&gt; 的原点/主指针和指向同一 &lt;code&gt;HEAD&lt;/code&gt; 的主指针。</target>
        </trans-unit>
        <trans-unit id="8ae99188f3ea7c125344fba8a5364f2b481c9542" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;pull&lt;/code&gt;, Git tries to automatically do your work for you. &lt;strong&gt;It is context sensitive&lt;/strong&gt;, so Git will merge any pulled commits into the branch you are currently working in.  &lt;code&gt;pull&lt;/code&gt;&lt;strong&gt;automatically merges the commits without letting you review them first&lt;/strong&gt;. If you don&amp;rsquo;t closely manage your branches, you may run into frequent conflicts.</source>
          <target state="translated">当您使用 &lt;code&gt;pull&lt;/code&gt; 时 ，Git会尝试自动为您完成工作。 &lt;strong&gt;它是上下文相关的&lt;/strong&gt; ，因此Git会将所有提交的提交合并到您当前正在使用的分支中 &lt;code&gt;pull&lt;/code&gt; &lt;strong&gt;自动合并提交，而无需您先对其进行审查&lt;/strong&gt; 。 如果您不严密管理分支机构，则可能会遇到频繁的冲突。</target>
        </trans-unit>
        <trans-unit id="1b93bc9367ac04ff57c408636c95b140163378c0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git pull&lt;/code&gt;:</source>
          <target state="translated">用 &lt;code&gt;git pull&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3d83192bff705155cb759eec49d16b9a3257e7a7" translate="yes" xml:space="preserve">
          <source>You can apply changes downloaded through fetch using the merge command. Merge will take the commits retrieved from fetch and try to add them to your local branch. The merge will keep the commit history of your local changes so that when you share your branch with push, Git will know how others can merge your changes.</source>
          <target state="translated">你可以使用merge命令应用通过fetch下载的修改。合并将从 fetch 中获取的提交,并尝试将其添加到你的本地分支中。合并将保留本地提交的历史记录,这样当你将分支分享到push时,Git就会知道其他人如何合并你的修改。</target>
        </trans-unit>
        <trans-unit id="77cc8b703c81ec309bd760da433e26013a43df97" translate="yes" xml:space="preserve">
          <source>You can do a &lt;code&gt;git fetch&lt;/code&gt; at any time to update your remote-tracking branches under &lt;code&gt;refs/remotes/&amp;lt;remote&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">您可以随时执行 &lt;code&gt;git fetch&lt;/code&gt; 来更新 &lt;code&gt;refs/remotes/&amp;lt;remote&amp;gt;/&lt;/code&gt; 下的远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="60d4353b41982c20e79e6a617ebff5018b2b3fef" translate="yes" xml:space="preserve">
          <source>You can fetch from a remote repository, see the differences and then pull or merge.</source>
          <target state="translated">你可以从远程资源库中提取,查看差异,然后拉取或合并。</target>
        </trans-unit>
        <trans-unit id="9648163d36e5997ca061fecd2f767a9206a1de2a" translate="yes" xml:space="preserve">
          <source>You don't get any isolation.</source>
          <target state="translated">你不会得到任何隔离。</target>
        </trans-unit>
        <trans-unit id="3af21692e399cffc1b0602029c4c529d3a93c542" translate="yes" xml:space="preserve">
          <source>You download changes to your local branch from origin through fetch. Fetch asks the remote repo for all commits that others have made but you don't have on your local repo. Fetch downloads these commits and adds them to the local repository.</source>
          <target state="translated">你通过fetch从原点下载修改到你的本地分支。Fetch 会询问远程版本库中所有其他人已经提交但你本地版本库中没有的提交。Fetch下载这些提交,并将其添加到本地仓库中。</target>
        </trans-unit>
        <trans-unit id="71deaa7d8f575ab7ed6cd6bbf3334a1461005600" translate="yes" xml:space="preserve">
          <source>You would pull if you want the histories merged, you'd fetch if you just 'want the codez' as some person has been tagging some articles around here.</source>
          <target state="translated">如果你想合并历史记录,你就会拉,如果你只是 &quot;想要代码的&quot;,你就会取,因为有人在这里给一些文章打上了标签。</target>
        </trans-unit>
        <trans-unit id="d0a02932aa479b6aeba6af580331b25d6888fea8" translate="yes" xml:space="preserve">
          <source>and covers &lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git clone&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt;.</source>
          <target state="translated">并涵盖了 &lt;code&gt;git pull&lt;/code&gt; ， &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;git clone&lt;/code&gt; 和 &lt;code&gt;git rebase&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="076889ab0a1a5ea289dc99e4db7f5646876c95f3" translate="yes" xml:space="preserve">
          <source>but in ,</source>
          <target state="translated">但在</target>
        </trans-unit>
        <trans-unit id="338b9d34cef0cc10394bbeb555b6c8652b8ad965" translate="yes" xml:space="preserve">
          <source>eg: i am going to fetch from server master and rebase it in my local master.</source>
          <target state="translated">例如:我打算从服务器主站获取,然后在我的本地主站中重新建立。</target>
        </trans-unit>
        <trans-unit id="7652ed4e9782162856d4648e8895b3387d9f68e6" translate="yes" xml:space="preserve">
          <source>git fetch</source>
          <target state="translated">git fetch</target>
        </trans-unit>
        <trans-unit id="a1e51d9e97a083cd4a749ceb74184d3a801ebb5d" translate="yes" xml:space="preserve">
          <source>git fetch can fetch from either a single named repository or URL, or
  from several repositories at once if  is given and there is a
  remotes. entry in the configuration file. (See git-config&lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1&lt;/a&gt;).</source>
          <target state="translated">git fetch既可以从单个命名存储库或URL进行获取，也可以一次从多个存储库获取（如果给出）并且有一个远程对象。 配置文件中的条目。 （请参阅git-config &lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a6378e53c49a3c9ce8158f63060def312e889cf2" translate="yes" xml:space="preserve">
          <source>git fetch does not changes to local branches.</source>
          <target state="translated">git fetch不会更改到本地分支。</target>
        </trans-unit>
        <trans-unit id="5b19fd74d867e845324d1cc6667583a990caa8b8" translate="yes" xml:space="preserve">
          <source>git fetch: Git is going to get the latest version from remote to local,  but it do not automatically merge.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;code&gt;git fetch origin master&lt;/code&gt;&lt;code&gt;git log -p master..origin/master&lt;/code&gt;&lt;code&gt;git merge origin/master&lt;/code&gt;</source>
          <target state="translated">git fetch：Git将从远程到本地获取最新版本，但是不会自动合并。 &lt;code&gt;git fetch origin master&lt;/code&gt; &lt;code&gt;git log -p master..origin/master&lt;/code&gt; &lt;code&gt;git merge origin/master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d065adf8851333810ea91f5f69a1ea63158b8826" translate="yes" xml:space="preserve">
          <source>git pull</source>
          <target state="translated">吉特拉</target>
        </trans-unit>
        <trans-unit id="7211a49be2c5e530c61f049fc400dec211114d60" translate="yes" xml:space="preserve">
          <source>git pull == ( git fetch + git merge)</source>
          <target state="translated">git pull ==(git fetch+git merge)</target>
        </trans-unit>
        <trans-unit id="98d57b348afc86b663f71eb34f50f6b73b3d02af" translate="yes" xml:space="preserve">
          <source>git pull: Git is going to get the latest version from the remote and merge into the local.</source>
          <target state="translated">git pull。Git要从远程获取最新版本,并合并到本地。</target>
        </trans-unit>
        <trans-unit id="4c01625fa313444b2582a58311703d8668a6b3bb" translate="yes" xml:space="preserve">
          <source>here &lt;strong&gt;origin&lt;/strong&gt; is your remote repo &lt;strong&gt;master&lt;/strong&gt; is your branch</source>
          <target state="translated">这是您的远程仓库&lt;strong&gt;主&lt;/strong&gt;节点，是您的分支机构</target>
        </trans-unit>
        <trans-unit id="f3293b87bc9bb8812771c354181c62eef7b1e271" translate="yes" xml:space="preserve">
          <source>here,</source>
          <target state="translated">here,</target>
        </trans-unit>
        <trans-unit id="3aa005c86b2e48f70aa9c07d41965bad325d9628" translate="yes" xml:space="preserve">
          <source>i.e. git pull = git fetch + git merge ...</source>
          <target state="translated">即git pull=git fetch+git merge ....。</target>
        </trans-unit>
        <trans-unit id="8abe66c44f7b8696d85a5e265ed9f37769e3e453" translate="yes" xml:space="preserve">
          <source>it will fetch server changes from origin. and it will be in your local until you rebase it on your own. we need to fix conflicts manually by checking codes.</source>
          <target state="translated">它将从源码中获取服务器的变化,并且它将在你的本地,直到你自己重新建立它。</target>
        </trans-unit>
        <trans-unit id="77e703902168624324db616363fbd43a7158e819" translate="yes" xml:space="preserve">
          <source>should be the name of a remote repository as passed to
  git-fetch&lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1&lt;/a&gt;.  can name an arbitrary remote ref (for example,
  the name of a tag) or even a collection of refs with corresponding
  remote-tracking branches (e.g., refs/heads/&lt;em&gt;:refs/remotes/origin/&lt;/em&gt;),
  but usually it is the name of a branch in the remote repository.</source>
          <target state="translated">应该是传递给git-fetch &lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1&lt;/a&gt;的远程存储库的名称。 可以命名任意的远程引用（例如，标记名称），甚至可以命名具有相应远程跟踪分支的引用集合（例如refs / heads / &lt;em&gt;：refs / remotes / origin /&lt;/em&gt; ），但通常是名称远程存储库中的分支。</target>
        </trans-unit>
        <trans-unit id="a6e839f3fb69bba683587d3332f5f0020879b4dc" translate="yes" xml:space="preserve">
          <source>this will rebase code into local. before that ensure you're in right branch.</source>
          <target state="translated">这将会把代码转换为本地代码,在这之前,确保你在正确的分支中。</target>
        </trans-unit>
        <trans-unit id="8fd2b1b8f0afc6bcf95d25c97c52d650bc531b47" translate="yes" xml:space="preserve">
          <source>when you start working and do commits you advance the master pointer to &lt;code&gt;HEAD&lt;/code&gt; + your commits. But the origin/master pointer is still pointing to what it was when you cloned.</source>
          <target state="translated">当您开始工作并提交时，您可以将主指针前进到 &lt;code&gt;HEAD&lt;/code&gt; +您的提交。 但是原始/主指针仍然指向克隆时的状态。</target>
        </trans-unit>
        <trans-unit id="c8611464dcef8825f2ef8aa62feb4357dc35ccde" translate="yes" xml:space="preserve">
          <source>will fetch code from repository and rebase with your local... in git pull there is possibility of new commits getting created.</source>
          <target state="translated">将从版本库中获取代码,然后用你的本地版本重新建立...........在git pull中,有可能创建新的提交。</target>
        </trans-unit>
        <trans-unit id="f6492f8b35e6d7766d4dd5492898cb07179aaa87" translate="yes" xml:space="preserve">
          <source>will fetch code from repository and we need to rebase it manually by using &lt;code&gt;git rebase&lt;/code&gt;</source>
          <target state="translated">将从存储库中获取代码，我们需要使用 &lt;code&gt;git rebase&lt;/code&gt; 手动对其重新设置基础</target>
        </trans-unit>
        <trans-unit id="922ad17f05bbaa394ace87920268f3431e1ccebb" translate="yes" xml:space="preserve">
          <source>you no longer need to do:</source>
          <target state="translated">你不需要再做。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
