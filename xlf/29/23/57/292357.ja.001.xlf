<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/292357">
    <body>
      <group id="292357">
        <trans-unit id="9fa5c5c74bcc28f7ff899434be6d1efa62244365" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; The command above is the equivalent to &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;. In practice, &lt;code&gt;git fetch&lt;/code&gt; maybe more secure because before the merge we can see the changes and decide whether to merge.</source>
          <target state="translated">上記のコマンドは、 &lt;code&gt;git fetch&lt;/code&gt; および &lt;code&gt;git merge&lt;/code&gt; と同等です。 実際には、マージの前に変更を確認してマージするかどうかを判断できるため、 &lt;code&gt;git fetch&lt;/code&gt; の方が安全かもしれません。</target>
        </trans-unit>
        <trans-unit id="32d8acda1dd72cb4e3ce43954e543e4a3da0d07f" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; The commands above mean that download latest version of the main branch from origin from the remote to origin master branch. And then compares the local master branch and origin master branch. Finally, merge.</source>
          <target state="translated">上記のコマンドは、リモートからオリジンマスターブランチにオリジンからメインブランチの最新バージョンをダウンロードすることを意味します。 次に、ローカルマスターブランチとオリジンマスターブランチを比較します。 最後に、マージします。</target>
        </trans-unit>
        <trans-unit id="48f97e1dc3e1ee5a10ffd97cdf92f6d652c37e14" translate="yes" xml:space="preserve">
          <source>(inside-repo operation) &lt;code&gt;remote/origin/master@local &amp;gt;&amp;gt; master@local&lt;/code&gt;</source>
          <target state="translated">（inside-repoオペレーション） &lt;code&gt;remote/origin/master@local &amp;gt;&amp;gt; master@local&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fa9cf27a8e4a9c6a7b0b129563967146c119b54" translate="yes" xml:space="preserve">
          <source>(repo to repo operation) &lt;code&gt;master@remote &amp;gt;&amp;gt; remote/origin/master@local&lt;/code&gt;</source>
          <target state="translated">（レポからレポへの操作） &lt;code&gt;master@remote &amp;gt;&amp;gt; remote/origin/master@local&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5432acc46382d221828b84d9bafa1cde6a4ba9bf" translate="yes" xml:space="preserve">
          <source>1) git pull ( rebase will done automatically):</source>
          <target state="translated">1)git pull (リベースは自動的に行われます)。</target>
        </trans-unit>
        <trans-unit id="5a66cdfb6968d483b06aeeba82c490dbf2550d78" translate="yes" xml:space="preserve">
          <source>2) git fetch (need to rebase manually):</source>
          <target state="translated">2)git fetch (手動でリベースする必要があります)。</target>
        </trans-unit>
        <trans-unit id="0d3bd84264ca1b2c8f691ecc7555b9bee9c17c48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git clone&lt;/code&gt; clones a repo.</source>
          <target state="translated">&lt;code&gt;git clone&lt;/code&gt; はリポジトリを複製します。</target>
        </trans-unit>
        <trans-unit id="5328124c67a16a351ef68bf92f8f591e1c77c394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; brings your local copy of the remote repository up to date. For example, if your remote repository is GitHub - you may want to fetch any changes made in the remote repository to your local copy of it the remote repository. This will allow you to perform operations such as compare or merge.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; は、リモートリポジトリのローカルコピーを最新の状態にします。 たとえば、リモートリポジトリがGitHubの場合、リモートリポジトリで行った変更をリモートリポジトリのローカルコピーにフェッチすることができます。 これにより、比較やマージなどの操作を実行できます。</target>
        </trans-unit>
        <trans-unit id="45716d867c97c93141fd633174f0b1e9b5c4f243" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; is similar to &lt;code&gt;pull&lt;/code&gt; but doesn't merge. i.e. it fetches remote updates (&lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;) but your local stays the same (i.e. &lt;code&gt;origin/master&lt;/code&gt; gets updated but &lt;code&gt;master&lt;/code&gt; stays the same) .</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; は &lt;code&gt;pull&lt;/code&gt; に似ていますが、マージされません。 つまり、リモート更新（ &lt;code&gt;refs&lt;/code&gt; と &lt;code&gt;objects&lt;/code&gt; ）をフェッチしますが、ローカルは同じままです（つまり、 &lt;code&gt;origin/master&lt;/code&gt; は更新されますが、 &lt;code&gt;master&lt;/code&gt; は同じままです）。</target>
        </trans-unit>
        <trans-unit id="961114afa0561cd3fae7d954b2c0f6de44de1cd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; just &quot;downloads&quot; the changes from the remote to your local repository. &lt;code&gt;git pull&lt;/code&gt; downloads the changes and merges them into your current branch. &quot;In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; は、リモートからローカルリポジトリに変更を「ダウンロード」するだけです。 &lt;code&gt;git pull&lt;/code&gt; は変更をダウンロードして現在のブランチにマージします。 「デフォルトモードでは、 &lt;code&gt;git pull&lt;/code&gt; は &lt;code&gt;git fetch&lt;/code&gt; の後に &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; が続く形式です。」</target>
        </trans-unit>
        <trans-unit id="851e511f1a09665acd6e13d5277de7a31c182eb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; only fetches from the remote branch but it does not merge</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; はリモートブランチからのみフェッチしますが、マージしません</target>
        </trans-unit>
        <trans-unit id="9ce94279a6dadc28b7a0ecb75dade36111b4a373" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; pulls down the code from the remote server to your tracking branches in your local repository.  If your remote is named &lt;code&gt;origin&lt;/code&gt; (the default) then these branches will be within &lt;code&gt;origin/&lt;/code&gt;, for example &lt;code&gt;origin/master&lt;/code&gt;, &lt;code&gt;origin/mybranch-123&lt;/code&gt;, etc.  These are not your current branches, they are &lt;em&gt;local&lt;/em&gt; copies of those branches from the server.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; は、コードをリモートサーバーからローカルリポジトリのトラッキングブランチにプルダウンします。 リモートの名前が &lt;code&gt;origin&lt;/code&gt; （デフォルト）の場合、これらのブランチは &lt;code&gt;origin/&lt;/code&gt; 内にあります（例： &lt;code&gt;origin/master&lt;/code&gt; 、 &lt;code&gt;origin/mybranch-123&lt;/code&gt; など）。これらは現在のブランチではなく、サーバーからのブランチの&lt;em&gt;ローカル&lt;/em&gt;コピーです。</target>
        </trans-unit>
        <trans-unit id="80fe18c4b4632e89609525d07897b4e58d6f487a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; will retrieve remote branches so that you can &lt;code&gt;git diff&lt;/code&gt; or &lt;code&gt;git merge&lt;/code&gt; them with the current branch. &lt;code&gt;git pull&lt;/code&gt; will run fetch on the remote brach tracked by the current branch and then merge the result. You can use &lt;code&gt;git fetch&lt;/code&gt; to see if there are any updates to the remote branch without necessary merging them with your local branch.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; はリモートブランチを取得するので、 &lt;code&gt;git diff&lt;/code&gt; または &lt;code&gt;git merge&lt;/code&gt; 現在のブランチとマージできます。 &lt;code&gt;git pull&lt;/code&gt; は、現在のブランチによって追跡されているリモート分岐でフェッチを実行し、結果をマージします。 &lt;code&gt;git fetch&lt;/code&gt; を使用すると、ローカルブランチとマージする必要なく、リモートブランチに更新があるかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="e3917ec46fc6b54ce2e06c114c3417324b75b2a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; does a &lt;code&gt;git fetch&lt;/code&gt; but then &lt;strong&gt;also&lt;/strong&gt; merges the code from the tracking branch into your current local version of that branch.  If you're not ready for that changes yet, just &lt;code&gt;git fetch&lt;/code&gt; first.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; は &lt;code&gt;git fetch&lt;/code&gt; を実行しますが、追跡ブランチからのコードをそのブランチの現在のローカルバージョンにマージします。 その変更の準備がまだできていない場合は、最初に &lt;code&gt;git fetch&lt;/code&gt; してください 。</target>
        </trans-unit>
        <trans-unit id="83dddb338f277eb811f3fa092c792988c4cc0880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; is &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; は &lt;code&gt;git fetch&lt;/code&gt; と &lt;code&gt;git merge&lt;/code&gt; です</target>
        </trans-unit>
        <trans-unit id="7d4710698ef543c45dfe252e6667d70d2de5401d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; on the other hand will bring down the changes in the remote repository to where you keep your own code. Typically, &lt;code&gt;git pull&lt;/code&gt; will do a &lt;code&gt;git fetch&lt;/code&gt; first to bring the local copy of the remote repository up to date, and then it will merge the changes into your own code repository and possibly your working copy.</source>
          <target state="translated">一方、 &lt;code&gt;git pull&lt;/code&gt; を実行すると、リモートリポジトリの変更が、独自のコードを保持する場所に反映されます。 通常、 &lt;code&gt;git pull&lt;/code&gt; は最初に &lt;code&gt;git fetch&lt;/code&gt; を実行してリモートリポジトリのローカルコピーを最新の状態にしてから、変更を独自のコードリポジトリと作業コピーにマージします。</target>
        </trans-unit>
        <trans-unit id="05df4cf0322b9f13dcf1c7d31f7a70fd4b89be02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; pulls down from a remote and instantly merges.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; はリモートからプルダウンし、即座にマージします。</target>
        </trans-unit>
        <trans-unit id="b05d4c0fb36f1dc05bc99a501e4370779ab4899c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git pull&lt;/code&gt; pulls from a remote branch and merges it.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; はリモートブランチからプルし、それをマージします。</target>
        </trans-unit>
        <trans-unit id="39b7979eb508edf5865501e23b13e6d4fb9fdf23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rebase&lt;/code&gt; saves stuff from your current branch that isn't in the upstream branch to a temporary area. Your branch is now the same as before you started your changes. So, &lt;code&gt;git pull -rebase&lt;/code&gt; will pull down the remote changes, rewind your local branch, replay your changes over the top of your current branch one by one until you're up-to-date.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; は、現在のブランチから上流のブランチにないものを一時領域に保存します。 これで、ブランチは変更を開始する前と同じになります。 したがって、 &lt;code&gt;git pull -rebase&lt;/code&gt; はリモートの変更をプルダウンし、ローカルブランチを巻き戻し、最新の状態になるまで現在のブランチの上から1つずつ変更を再生します。</target>
        </trans-unit>
        <trans-unit id="4eb4921d4ad3bfa6eaa086e761647f7cd8553d22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ls&lt;/code&gt;. This will show the files &amp;amp; directories. Nothing cool, I know.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 。 ファイルとディレクトリが表示されます。 何もかっこいいと思います。</target>
        </trans-unit>
        <trans-unit id="ca25b56131b611133fad2dd0dd2d7dfa45581e04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any&lt;/em&gt;&lt;code&gt;git fetch&lt;/code&gt; that you do will update items in the &lt;code&gt;/.git/refs/remotes&lt;/code&gt; directory. It won't update anything in the &lt;code&gt;/.git/refs/heads&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; を実行すると、 &lt;code&gt;/.git/refs/remotes&lt;/code&gt; 。 git / refs / remotesディレクトリ内のアイテムが更新されます。 &lt;code&gt;/.git/refs/heads&lt;/code&gt; ディレクトリの内容は更新されません。</target>
        </trans-unit>
        <trans-unit id="7a0c6624b35faf750cddb1f5c5e4877ebc30bedd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any&lt;/em&gt;&lt;code&gt;git pull&lt;/code&gt; will first do the &lt;code&gt;git fetch&lt;/code&gt;, update items in the &lt;code&gt;/.git/refs/remotes&lt;/code&gt; directory, then merge with your local and then change the head inside the &lt;code&gt;/.git/refs/heads&lt;/code&gt; directory.</source>
          <target state="translated">&lt;em&gt;どの&lt;/em&gt; &lt;code&gt;git pull&lt;/code&gt; も最初に &lt;code&gt;git fetch&lt;/code&gt; を実行し、/。 git &lt;code&gt;/.git/refs/remotes&lt;/code&gt; ディレクトリ内のアイテムを更新してから、ローカルとマージしてから、 &lt;code&gt;/.git/refs/heads&lt;/code&gt; 。 git / refs / headsディレクトリ内のヘッドを変更します。</target>
        </trans-unit>
        <trans-unit id="109168d936934938ef5217cf8bb337f828295f00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Git Fetch-&lt;/strong&gt; This will Download all the changes that have been made to the origin/main branch project which are not present in your local branch. And will wait for the Git Merge command to apply the changes that have been fetched to your Repository or branch.</source>
          <target state="translated">&lt;strong&gt;1. Git Fetch-&lt;/strong&gt;これは、ローカルブランチに存在しないorigin / mainブランチプロジェクトに加えられたすべての変更をダウンロードします。 そして、Git Mergeコマンドがリポジトリまたはブランチにフェッチされた変更を適用するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="c5bed844ff8564d2a50b21639fd4cdf812e9f691" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Git Pull-&lt;/strong&gt; This will update your local branch with the origin/main branch i.e. actually what it does is combination of Git Fetch and Git merge one after another.
&lt;em&gt;But this may Cause Conflicts to occur, so it&amp;rsquo;s recommended to use Git Pull with a clean copy.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;2. Git Pull-&lt;/strong&gt;これは、ローカルブランチをorigin / mainブランチで更新します。つまり、実際には、Git FetchとGit mergeを次々に組み合わせています。 &lt;em&gt;ただし、これにより競合が発生する可能性があるため、クリーンコピーでGit Pullを使用することをお勧めします。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bcbfd0fcb10b979a3e0380830ef7bab24a1e334" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git fetch&lt;/code&gt;&lt;/strong&gt; is the command that says &quot;bring my local copy of the remote repository up to date.&quot;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git fetch&lt;/code&gt; &lt;/strong&gt;は、「リモートリポジトリのローカルコピーを最新の状態にする」というコマンドです。</target>
        </trans-unit>
        <trans-unit id="8b77648ec75a644255f4be7f9dd3cb5598cd48b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull --rebase&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e785d95f0de347a936e7fda7fa2fa1299834bbee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/strong&gt; says &quot;bring the changes in the remote repository to where I keep my own code.&quot;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull&lt;/code&gt; &lt;/strong&gt;は「リモートリポジトリの変更を自分のコードを保持する場所に持っていく」と言います。</target>
        </trans-unit>
        <trans-unit id="5cb04c6741b8235615793d873684b0584c2a364e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Briefly&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Briefly&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ad1a5b0818ff680ca2bd9af2799ba236a6251f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Feedback&lt;/strong&gt; about the state of your local repo (for example, I use Atlassian's SourceTree, which will give me a bulb indicating if I'm commits ahead or behind compared to the origin. This information can be updated with a GIT FETCH).</source>
          <target state="translated">ローカルリポジトリの状態に関する&lt;strong&gt;フィードバック&lt;/strong&gt; （たとえば、AtlassianのSourceTreeを使用します。これにより、オリジンと比較してコミットが進んでいるか遅れているかを示す電球が表示されます。この情報はGIT FETCHで更新できます）。</target>
        </trans-unit>
        <trans-unit id="f0d9c19e498edc94e1533273e0bc1b76808e356c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Git Fetch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Gitフェッチ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="014ba1d3cfaa64368fbfa37d5c4581345df5482f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Git Merge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Gitマージ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b07aaa0e6c31283c67bd262473d1a745931ce6c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Git Pull&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Git Pull&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c98fe5935ce702c3af246dd6b37f9baf9e499b48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;More&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4071b6245e334d89c25a82984cc4f9f97267d26a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK&lt;/strong&gt;, here are some information about &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt;, so you can understand the actual differences... in few simple words, &lt;strong&gt;fetch&lt;/strong&gt; gets the latest data, but not the code changes and not going to mess with your current  local branch code, but &lt;strong&gt;pull&lt;/strong&gt; get the code changes and merge it your local branch, read on to get more details about each:</source>
          <target state="translated">&lt;strong&gt;OK&lt;/strong&gt; 、ここに &lt;code&gt;git pull&lt;/code&gt; と &lt;code&gt;git fetch&lt;/code&gt; に関するいくつかの情報があるので、実際の違いを理解できます...簡単な言葉で言うと、 &lt;strong&gt;fetch&lt;/strong&gt;は最新のデータを&lt;strong&gt;取得し&lt;/strong&gt;ますが、コードの変更は&lt;strong&gt;取得&lt;/strong&gt;せず、現在のローカルブランチコードを混乱させません、ただしコードの変更を&lt;strong&gt;プル&lt;/strong&gt;してローカルブランチにマージします。それぞれの詳細を取得するには以下を読みます。</target>
        </trans-unit>
        <trans-unit id="d0ef5f55593d457090b8bc8d4819537557ea3aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt; (scroll through all commits and messages without trying to squeeze it through the network)</source>
          <target state="translated">&lt;strong&gt;パフォーマンス&lt;/strong&gt; （ネットワーク経由で絞り込まずにすべてのコミットとメッセージをスクロールする）</target>
        </trans-unit>
        <trans-unit id="3fe24c79e200adaf76506563aeba6a1edd56ce9a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;git pull&lt;/code&gt; is what you would do to bring a local branch up-to-date with its remote version, while also updating your other remote-tracking branches.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; は、ローカルブランチをリモートバージョンで最新の状態にし、他のリモート追跡ブランチを更新するために行うことです。</target>
        </trans-unit>
        <trans-unit id="6ddcfdae5fbd3c1f28805473e15e964fe04d16f4" translate="yes" xml:space="preserve">
          <source>A simple Graphical Representation for Beginners,</source>
          <target state="translated">初心者のための簡単なグラフ表現。</target>
        </trans-unit>
        <trans-unit id="d52324965c9a6e58203263aaced4ecde8fd71b80" translate="yes" xml:space="preserve">
          <source>A very good related answer can also be found in &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27554859/where-does-git-fetch-place-itself/27555444#27555444&quot;&gt;Where does 'git fetch' place itself?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27554859/where-does-git-fetch-place-itself/27555444#27555444&quot;&gt;「git fetch」&lt;/a&gt;&lt;/em&gt;は&lt;em&gt;どこに配置されていますか？&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc500d77391d46e00d7b5c782a0ab25e90841a89" translate="yes" xml:space="preserve">
          <source>After downloading the updates, let's see the differences:</source>
          <target state="translated">アップデートをダウンロードしたら、違いを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="edf3db0309e01a8bcd864ab261176a621ee80299" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;git branch -a&lt;/code&gt; will show you exactly what&amp;rsquo;s going on with all your branches - local and remote.</source>
          <target state="translated">また、 &lt;code&gt;git branch -a&lt;/code&gt; は、ローカルとリモートのすべてのブランチで何が起こっているかを正確に示します。</target>
        </trans-unit>
        <trans-unit id="322c738050a772ccaa4aa6d80ca6d3abb420d9f8" translate="yes" xml:space="preserve">
          <source>Also, look for &quot;Slash notation&quot; from the &lt;a href=&quot;http://www.guyroutledge.co.uk/blog/git-branch-naming-conventions/&quot;&gt;Git branch naming conventions&lt;/a&gt; post. It helps you better understand how Git places things in different directories.</source>
          <target state="translated">また、 &lt;a href=&quot;http://www.guyroutledge.co.uk/blog/git-branch-naming-conventions/&quot;&gt;Gitブランチの命名規則の&lt;/a&gt;投稿から「スラッシュ表記」を探してください。 Gitがさまざまなディレクトリにどのように配置するかを理解するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="f35d76827c3b43e78eae4be69f5a31adb50d9eed" translate="yes" xml:space="preserve">
          <source>Before pushing your new commits to server, try this command and it will automatically sync latest server changes (with a fetch + merge) and will place your commit at the top in git log. No need to worry about manual pull/merge.</source>
          <target state="translated">新しいコミットをサーバーにプッシュする前に、このコマンドを試してみましょう。手動でプルマージする必要はありません。</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="c20f309c89ab318ccde630455b592cf9a45e630d" translate="yes" xml:space="preserve">
          <source>But that's outdated and incorrect. It's because git will give you feedback solely based on what it knows. It's oblivious to new commits that it hasn't pulled down yet...</source>
          <target state="translated">しかし、それは時代遅れで正しくありません。git は知っていることだけに基づいてフィードバックを与えてくれるからです。まだプルダウンしていない新しいコミットには気づかないのです...。</target>
        </trans-unit>
        <trans-unit id="32155eafe73839b32c5ef69bafc03d8a5d24c849" translate="yes" xml:space="preserve">
          <source>By default, any tag that points into the histories being fetched is
  also fetched; the effect is to fetch tags that point at branches that
  you are interested in. This default behavior can be changed by using
  the --tags or --no-tags options or by configuring
  remote..tagOpt. By using a refspec that fetches tags explicitly,
  you can fetch tags that do not point into branches you are interested
  in as well.</source>
          <target state="translated">デフォルトでは、フェッチされている履歴を指すタグもフェッチされます。このデフォルトの動作は --tags または --no-tags オプションを使用するか、 remote..tagOpt を設定することで変更することができます。明示的にタグをフェッチする refspec を使うことで、興味のあるブランチを指していないタグも同様にフェッチすることができます。</target>
        </trans-unit>
        <trans-unit id="80ad85601183f99deb766161879cf4b25512ba7c" translate="yes" xml:space="preserve">
          <source>Copying new commits from remote branch to copy of this remote branch inside local repo.</source>
          <target state="translated">リモートブランチの新しいコミットをローカルレポ内のこのリモートブランチのコピーにコピーします。</target>
        </trans-unit>
        <trans-unit id="d537056fde34a1ba692f4e1ab02d8e216af2a6ff" translate="yes" xml:space="preserve">
          <source>Default values for  and  are read from the
  &quot;remote&quot; and &quot;merge&quot; configuration for the current branch as set by
  git-branch --track.</source>
          <target state="translated">デフォルト値は、現在のブランチの &quot;remote&quot; および &quot;merge&quot; 設定で git-branch --track で設定したものを読み込みます。</target>
        </trans-unit>
        <trans-unit id="4d979b1dc2b994c6f4248ba041d7bd399d114087" translate="yes" xml:space="preserve">
          <source>Do &lt;code&gt;cd .git&lt;/code&gt;. This will obviously change your directory.</source>
          <target state="translated">&lt;code&gt;cd .git&lt;/code&gt; を実行します。 これは明らかにディレクトリを変更します。</target>
        </trans-unit>
        <trans-unit id="b2bcd7ea07d74b72cfb09e7b0c7e43e3d526a0b8" translate="yes" xml:space="preserve">
          <source>Fetch and merge run together often enough that a command that combines the two, pull, was created. Pull does a fetch and then a merge to add the downloaded commits into your local branch.</source>
          <target state="translated">フェッチとマージはよく一緒に実行されるので、この二つを組み合わせたコマンド pull が作られました。pull はフェッチとマージを行い、ダウンロードしたコミットをローカルブランチに追加します。</target>
        </trans-unit>
        <trans-unit id="045598d48170bf40459b9e12cf8ab0455f608647" translate="yes" xml:space="preserve">
          <source>Fetch branches and/or tags (collectively, &quot;refs&quot;) from one or more
  other repositories, along with the objects necessary to complete their
  histories. Remote-tracking branches are updated (see the description
  of  below for ways to control this behavior).</source>
          <target state="translated">1つ以上の他のリポジトリからブランチやタグ(総称して「refs」)を取得し、それらの履歴を完成させるために必要なオブジェクトと一緒に取得します。リモートトラッキングされたブランチは更新されます (この動作を制御する方法については、以下の説明を参照してください)。</target>
        </trans-unit>
        <trans-unit id="d5f7709dcaf8382e5c15601d64bfe814cf8302eb" translate="yes" xml:space="preserve">
          <source>Fetching is what you do when you want to see what everybody &lt;em&gt;else&lt;/em&gt; has
  been working on. It&amp;rsquo;s similar to SVN update in that it lets you see
  how the central history has progressed, but it doesn&amp;rsquo;t force you to
  actually merge the changes into your repository. Git &lt;strong&gt;isolates
  fetched content as a from existing local content&lt;/strong&gt;, it has absolutely
  &lt;strong&gt;no effect on your local development work&lt;/strong&gt;. Fetched content has to be explicitly checked out using the &lt;code&gt;git checkout&lt;/code&gt; command. This makes
  fetching a safe way to review commits before integrating them with
  your local repository.</source>
          <target state="translated">フェッチとは、 &lt;em&gt;他の&lt;/em&gt;誰&lt;em&gt;も&lt;/em&gt;が取り組んでいることを確認したいときに行うことです。 中央の履歴の進行状況を確認できるという点でSVNの更新と似ていますが、実際に変更をリポジトリにマージする必要はありません。 Gitは、 &lt;strong&gt;フェッチされたコンテンツを既存のローカルコンテンツから分離します&lt;/strong&gt; 。 &lt;strong&gt;ローカルの開発作業に&lt;/strong&gt;はまったく&lt;strong&gt;影響しません&lt;/strong&gt; 。 取得したコンテンツは、 &lt;code&gt;git checkout&lt;/code&gt; コマンドを使用して明示的にチェックアウトする必要があります。 これにより、ローカルリポジトリと統合する前にコミットを確認する安全な方法がフェッチされます。</target>
        </trans-unit>
        <trans-unit id="a094f4d7d41c2764c2f031fe68c19f7697500e17" translate="yes" xml:space="preserve">
          <source>Find details at: &lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;http://gitolite.com/git-pull--rebase&lt;/a&gt;</source>
          <target state="translated">詳細については、 &lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;http&lt;/a&gt; ： //gitolite.com/git-pull--rebaseを参照してください</target>
        </trans-unit>
        <trans-unit id="80a2b7deffd7046895901f3b9b3abd6954530694" translate="yes" xml:space="preserve">
          <source>For more on that read &lt;a href=&quot;https://stackoverflow.com/a/56464547/5175709&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">詳しくは&lt;a href=&quot;https://stackoverflow.com/a/56464547/5175709&quot;&gt;こちらをご覧ください&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f570924ec3541da08b064870361aa101628c76d" translate="yes" xml:space="preserve">
          <source>Fork local branch after last common ancestor and add new commits parallel to commits which are unique to local repository, finalized by merging commit, closing the fork.</source>
          <target state="translated">最後の共通の祖先の後にローカルブランチをフォークし、ローカルリポジトリに固有のコミットと並行して新しいコミットを追加し、コミットをマージしてフォークを終了します。</target>
        </trans-unit>
        <trans-unit id="7d246c9f13b103978089851b748ff4135c885e5a" translate="yes" xml:space="preserve">
          <source>From this awesome &lt;a href=&quot;https://www.atlassian.com/git/tutorials/syncing/git-fetch&quot;&gt;Atlassian tutorial&lt;/a&gt;:</source>
          <target state="translated">この素晴らしい&lt;a href=&quot;https://www.atlassian.com/git/tutorials/syncing/git-fetch&quot;&gt;アトラシアンチュートリアルから&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c99c3c8141446381e894a09ddb5848bec036afb2" translate="yes" xml:space="preserve">
          <source>Fun tip:</source>
          <target state="translated">楽しいチップだ</target>
        </trans-unit>
        <trans-unit id="23c19ce9cb1070c0d02d571d4b284d1506a224fc" translate="yes" xml:space="preserve">
          <source>Git allows chronologically older commits to be applied after newer commits.
Because of this, the act of transferring commits between repositories is split into two steps:</source>
          <target state="translated">Git では、時系列的に古いコミットを新しいコミットの後に適用することができます。このため、リポジトリ間でコミットを転送する作業は2つのステップに分かれています。</target>
        </trans-unit>
        <trans-unit id="92421bf16a875aff738a77da925b0817f0f4f80a" translate="yes" xml:space="preserve">
          <source>Git documentation &amp;ndash; &lt;a href=&quot;http://git-scm.com/docs/git-pull&quot;&gt;&lt;strong&gt;git pull&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">Gitドキュメント&amp;ndash; &lt;a href=&quot;http://git-scm.com/docs/git-pull&quot;&gt;&lt;strong&gt;git pull&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="fd037a056ee9a0a3ea17523512de78c92b929629" translate="yes" xml:space="preserve">
          <source>Git obtains the branch of the latest version from the remote to the local using two commands:</source>
          <target state="translated">Gitは2つのコマンドを使ってリモートからローカルへ最新バージョンのブランチを取得します。</target>
        </trans-unit>
        <trans-unit id="033bc0378830e2cbf48b95032ab89e679a08ff04" translate="yes" xml:space="preserve">
          <source>Git was designed to support a more distributed model with no need for a central repository (though you can certainly use one if you like). Also git was designed so that the client and the &quot;server&quot; don't need to be online at the same time. Git was designed so that people on an unreliable link could exchange code via email, even. It is possible to work completely disconnected and burn a CD to exchange code via git.</source>
          <target state="translated">Git は、中央のリポジトリを必要とせず、より分散したモデルをサポートするように設計されました (お好みであれば、中央のリポジトリを使うこともできますが)。また、git はクライアントと「サーバー」が同時にオンラインである必要がないように設計されています。Git は、信頼性の低いリンク上にいる人たちが電子メールでコードを交換できるように設計されています。完全に切断された状態で作業をして、CDを焼いてgit経由でコードを交換することも可能です。</target>
        </trans-unit>
        <trans-unit id="9ce3409127465b71688de3971e312b082f6febd2" translate="yes" xml:space="preserve">
          <source>Great question. It puts it somewhere isolated from your working copy. But again where? Let's find out.</source>
          <target state="translated">いい質問だ それはあなたの作業コピーから分離された場所に置いています。でもまたどこに?それを見つけよう</target>
        </trans-unit>
        <trans-unit id="89be5c989f1e0a130d56642cfc8383c35bd91fe4" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;http://blog.osteele.com/2008/05/my-git-workflow/&quot;&gt;Oliver Steele's image of how all it all fits together&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://blog.osteele.com/2008/05/my-git-workflow/&quot;&gt;すべてがどのように組み合わさっているのかを示すオリバースティールの画像は&lt;/a&gt;次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ce46f607307f3b5fb06075c64f8ceab45279bbdf" translate="yes" xml:space="preserve">
          <source>Hmmm...so if I'm not updating the working copy with &lt;code&gt;git fetch&lt;/code&gt;, then where am I making changes? Where does Git fetch store the new commits?</source>
          <target state="translated">うーん... &lt;code&gt;git fetch&lt;/code&gt; で作業コピーを更新していない場合、どこで変更しますか？ Gitフェッチは新しいコミットをどこに保存しますか？</target>
        </trans-unit>
        <trans-unit id="4ffdb142a405417c93bea94964a1c2c08c551de2" translate="yes" xml:space="preserve">
          <source>I also create the &lt;strong&gt;visual&lt;/strong&gt; below to show you how &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; working together...</source>
          <target state="translated">以下の&lt;strong&gt;ビジュアル&lt;/strong&gt;も作成して、 &lt;code&gt;git fetch&lt;/code&gt; と &lt;code&gt;git pull&lt;/code&gt; がどのように連携しているかを示します...</target>
        </trans-unit>
        <trans-unit id="07e7f9e2e81d32cb59143090feeb634ba03b1447" translate="yes" xml:space="preserve">
          <source>I have struggled with this as well.  In fact I got here with a google search of exactly the same question.  Reading all these answers finally painted a picture in my head and I decided to try to get this down looking at the state of the 2 repositories and 1 sandbox and actions performed over time while watching the version of them.  So here is what I came up with.  Please correct me if I messed up anywhere.</source>
          <target state="translated">私もこれには苦戦しています。実際、全く同じ質問をグーグルで検索してここにたどり着きました。これらすべての回答を読んで、最終的に私の頭の中に絵が描かれ、私は2つのリポジトリと1つのサンドボックスの状態を見て、それらのバージョンを見ながら時間の経過とともに実行されたアクションを見て、これを取得しようとすることにしました。それで、私が思いついたのは以下のようなものです。どこかで間違っていたら訂正してください。</target>
        </trans-unit>
        <trans-unit id="5b18a32757feffb19b768293f3091d29d27efc26" translate="yes" xml:space="preserve">
          <source>I like to have some visual representation of the situation to grasp these things. Maybe other developers would like to see it too, so here's my addition. I'm not totally sure that it all is correct, so please comment if you find any mistakes.</source>
          <target state="translated">こういったことを把握するために、何かしらの視覚的な表現があるといいなと思っています。もしかしたら他の開発者の方も見てみたいと思うかもしれませんので、ここに追加しました。全てが正しいとは思っていませんので、何か間違いがあればコメントをお願いします。</target>
        </trans-unit>
        <trans-unit id="c7489e43761289e99e5d7079c5c877cffd143154" translate="yes" xml:space="preserve">
          <source>I thought I'd update this to show how you'd actually use this in practice.</source>
          <target state="translated">実際にどうやって使うのかを紹介するために更新しようと思いました。</target>
        </trans-unit>
        <trans-unit id="821bc16e59a841d21fe7b78ce9b776cc6e35c5a5" translate="yes" xml:space="preserve">
          <source>If the remote master was updated you'll get a message like this:</source>
          <target state="translated">リモートマスターが更新された場合は、このようなメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="68a0bdf0085c0a825e5be3356d84929da9c61aa6" translate="yes" xml:space="preserve">
          <source>If there is sufficient interest, I suppose I could update the image to add &lt;code&gt;git clone&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;...</source>
          <target state="translated">十分な関心があれば、イメージを更新して &lt;code&gt;git clone&lt;/code&gt; と &lt;code&gt;git merge&lt;/code&gt; を追加できると思います...</target>
        </trans-unit>
        <trans-unit id="37251fa3853fcc0155dc49884f3df2ca33eb64f1" translate="yes" xml:space="preserve">
          <source>If you already have a local repository with a remote set up for the desired project, you can grab all branches and tags for the existing remote using git fetch . ... Fetch does not make any changes to local branches, so you will need to merge a remote branch with a paired local branch to incorporate newly fetch changes. &lt;a href=&quot;https://help.github.com/articles/fetching-a-remote&quot;&gt;from github&lt;/a&gt;</source>
          <target state="translated">目的のプロジェクトのリモートが設定されたローカルリポジトリがある場合は、git fetchを使用して、既存のリモートのすべてのブランチとタグを取得できます。 ... Fetchはローカルブランチに変更を加えないため、新しくフェッチした変更を組み込むには、リモートブランチをペアのローカルブランチにマージする必要があります。 &lt;a href=&quot;https://help.github.com/articles/fetching-a-remote&quot;&gt;githubから&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1839fcd4628fab1f58094381ce5dd1ea362da0d4" translate="yes" xml:space="preserve">
          <source>If you didn't &lt;code&gt;fetch&lt;/code&gt; and just did &lt;code&gt;git checkout master&lt;/code&gt; then your local git wouldn't know that there are 2 commits added. And it would just say:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; せずに &lt;code&gt;git checkout master&lt;/code&gt; だけを実行した場合、ローカルgitは2つのコミットが追加されたことを認識しません。 そしてそれはただ言うでしょう：</target>
        </trans-unit>
        <trans-unit id="2d0b0d005c61420fbde841a3633e861f097628fc" translate="yes" xml:space="preserve">
          <source>If you do a &lt;code&gt;git fetch&lt;/code&gt; it will just fetch all the changes in the remote repository (&lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt;) and move the origin/master pointer to &lt;code&gt;HEAD&lt;/code&gt;. Meanwhile your local branch master will keep pointing to where it has.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; を実行すると、リモートリポジトリ（ &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt; ）のすべての変更が取得され 、オリジン/マスターポインターが &lt;code&gt;HEAD&lt;/code&gt; に移動します。 その間、あなたのローカルブランチマスターはそれがどこにあるかを指し示し続けます。</target>
        </trans-unit>
        <trans-unit id="900ae93a7953ff6e0661ac7270d3ba457b6be9a1" translate="yes" xml:space="preserve">
          <source>If you do a &lt;code&gt;git pull&lt;/code&gt;, it will do basically fetch (as explained previously) and merge any new changes to your master branch and move the pointer to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; を実行すると、基本的に（前述のように）フェッチが行われ、新しい変更がマスターブランチにマージされ、ポインターが &lt;code&gt;HEAD&lt;/code&gt; に移動します。</target>
        </trans-unit>
        <trans-unit id="616ab200c6c582d81e3203971545ff215f3fd330" translate="yes" xml:space="preserve">
          <source>If you fetched a remote branch e.g. did:</source>
          <target state="translated">リモートブランチをフェッチした場合、例えば did.</target>
        </trans-unit>
        <trans-unit id="162dce9f88948f751bdbb44bdb42efa008599f93" translate="yes" xml:space="preserve">
          <source>If you find yourself in such a situation, you may be tempted to &lt;code&gt;git pull --rebase&lt;/code&gt;. Unless you really, really know what you are doing, I would advise against that. This warning is from the &lt;code&gt;man&lt;/code&gt; page for &lt;code&gt;git-pull&lt;/code&gt;, version &lt;code&gt;2.3.5&lt;/code&gt;:</source>
          <target state="translated">このような状況に陥った場合、 &lt;code&gt;git pull --rebase&lt;/code&gt; を使用したくなるかもしれません。 あなたが本当にあなたが何をしているのか本当にわかっていない限り、私はそれに対して助言します。 この警告は &lt;code&gt;git-pull&lt;/code&gt; 、バージョン &lt;code&gt;2.3.5&lt;/code&gt; の &lt;code&gt;man&lt;/code&gt; ページからのものです：</target>
        </trans-unit>
        <trans-unit id="39c38a4d2906ce12baf53b8235be890ca9c9a7e6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git pull&lt;/code&gt;, you do not need to merge the data to local. If you run &lt;code&gt;git fetch&lt;/code&gt;, it means you must run &lt;code&gt;git merge&lt;/code&gt; for getting the latest code to your local machine. Otherwise, the local machine code would not be changed without merge.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; を実行する場合、データをローカルにマージする必要はありません。 &lt;code&gt;git fetch&lt;/code&gt; を実行する場合は、最新のコードをローカルマシンに取得するために &lt;code&gt;git merge&lt;/code&gt; を実行する必要があります。 そうでない場合、ローカルマシンのコードはマージしないと変更されません。</target>
        </trans-unit>
        <trans-unit id="03ceca134f6aec86433fabaa1e2d3cc64a31e825" translate="yes" xml:space="preserve">
          <source>If you're happy with those updates, then merge:</source>
          <target state="translated">それらの更新に満足しているのであれば、マージしてください。</target>
        </trans-unit>
        <trans-unit id="d8e1f252c15bb34d9198fe09a84d37f5ede75407" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;git&lt;/code&gt; terminology, step 1 is &lt;code&gt;git fetch&lt;/code&gt;, step 2 is &lt;code&gt;git merge&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; の用語では、ステップ1は &lt;code&gt;git fetch&lt;/code&gt; 、ステップ2は &lt;code&gt;git merge&lt;/code&gt; または &lt;code&gt;git rebase&lt;/code&gt; です</target>
        </trans-unit>
        <trans-unit id="a1bf2ca7db0931ab25be8665ddf93ce855960e77" translate="yes" xml:space="preserve">
          <source>In addition to pulling and pushing, &lt;a href=&quot;https://web.archive.org/web/20150321185928/http://mettadore.com/2011/09/07/the-ever-deployable-github-workflow//&quot;&gt;some workflows&lt;/a&gt; involve &lt;code&gt;git rebase&lt;/code&gt;, such as this one, which I paraphrase from the linked article:</source>
          <target state="translated">プルとプッシュに加えて、 &lt;a href=&quot;https://web.archive.org/web/20150321185928/http://mettadore.com/2011/09/07/the-ever-deployable-github-workflow//&quot;&gt;いくつかのワークフローに&lt;/a&gt;は &lt;code&gt;git rebase&lt;/code&gt; が含まれます。これは、リンクされた記事から言い換えると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="e40cd3ac234494a2b0cc543cfa7294ec17721210" translate="yes" xml:space="preserve">
          <source>In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.</source>
          <target state="translated">デフォルトモードでは、 &lt;code&gt;git pull&lt;/code&gt; は &lt;code&gt;git fetch&lt;/code&gt; の後に &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; が続く形式です。</target>
        </trans-unit>
        <trans-unit id="6f7e63b5ace32e92fae98a294e280f5810ef0452" translate="yes" xml:space="preserve">
          <source>In order to support this model git maintains a local repository with your code and also an additional local repository that mirrors the state of the remote repository. By keeping a copy of the remote repository locally, git can figure out the changes needed even when the remote repository is not reachable.  Later when you need to send the changes to someone else, git can transfer them as a set of changes from a point in time known to the remote repository.</source>
          <target state="translated">このモデルをサポートするために、git はあなたのコードを含むローカルリポジトリと、リモートリポジトリの状態をミラーする追加のローカルリポジトリを維持します。リモートリポジトリのコピーをローカルに保持することで、リモートリポジトリにアクセスできない場合でも必要な変更点を把握することができます。後で誰かに変更を送る必要があるときには、git はリモートリポジトリが知っている時点から変更のセットとしてそれを転送することができます。</target>
        </trans-unit>
        <trans-unit id="6a10a3f8f133b33ad3434b087c4d2fc83bd4dacf" translate="yes" xml:space="preserve">
          <source>In simple terms, if you were about to hop onto a plane without any Internet connection...before departing you could just do &lt;code&gt;git fetch origin &amp;lt;master&amp;gt;&lt;/code&gt;. It would fetch all the changes into your computer, but keep it separate from your local development/workspace.</source>
          <target state="translated">簡単に言えば、インターネットに接続せずに飛行機に飛び乗る場合...出発する前に &lt;code&gt;git fetch origin &amp;lt;master&amp;gt;&lt;/code&gt; を実行するだけで済みます。 すべての変更をコンピューターにフェッチしますが、ローカルの開発/ワークスペースから分離します。</target>
        </trans-unit>
        <trans-unit id="bf5cfd3242ed6010b1fce1f3aa3393b0bfbfe46f" translate="yes" xml:space="preserve">
          <source>In speaking of pull &amp;amp; fetch in the above answers, I would like to share an interesting trick,</source>
          <target state="translated">上記の回答のプル＆フェッチと言えば、興味深いトリックを共有したいと思います。</target>
        </trans-unit>
        <trans-unit id="1440ef61d3b0c55e8100941f7cbf808f72aa0deb" translate="yes" xml:space="preserve">
          <source>In the simplest terms, &lt;code&gt;git pull&lt;/code&gt; does a &lt;code&gt;git fetch&lt;/code&gt; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">簡単に言えば、 &lt;code&gt;git pull&lt;/code&gt; は &lt;code&gt;git fetch&lt;/code&gt; に続いて &lt;code&gt;git merge&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="d9cc282a743496a57679827248fa33a56653ca44" translate="yes" xml:space="preserve">
          <source>In your project directory (i.e., where you do your &lt;code&gt;git&lt;/code&gt; commands) do:</source>
          <target state="translated">プロジェクトディレクトリ（つまり、 &lt;code&gt;git&lt;/code&gt; コマンドを実行する場所）で次を実行します。</target>
        </trans-unit>
        <trans-unit id="7cd0fe622f2fa6d7cad2751f00997df5822d4092" translate="yes" xml:space="preserve">
          <source>Incorporates changes from a remote repository into the current branch.
  In its default mode, git pull is shorthand for git fetch followed by
  git merge FETCH_HEAD.</source>
          <target state="translated">リモートリポジトリからの変更を現在のブランチに取り込みます。デフォルトのモードでは、git pull は git fetch の略で、その後に git merge FETCH_HEAD を実行します。</target>
        </trans-unit>
        <trans-unit id="ddab7bca2180329029b2fc8fd232bd55f5286278" translate="yes" xml:space="preserve">
          <source>Insert new commits after last common ancestor and reapply commits unique to local repository.</source>
          <target state="translated">最後の共通の祖先の後に新しいコミットを挿入し、ローカルリポジトリに固有のコミットを再適用します。</target>
        </trans-unit>
        <trans-unit id="334fd4cec82b62628bf7b5a408786f48086b0f6c" translate="yes" xml:space="preserve">
          <source>Integrating new commits to local branch</source>
          <target state="translated">新しいコミットをローカルブランチに統合する</target>
        </trans-unit>
        <trans-unit id="3947829b4a816ebf3be376780b6f09ea82ecf1d1" translate="yes" xml:space="preserve">
          <source>Is there any way to see the new changes made in remote while working on the branch locally?</source>
          <target state="translated">ローカルでブランチを操作しているときに、リモートで行われた新しい変更を見る方法はありますか?</target>
        </trans-unit>
        <trans-unit id="a90f009f20779ef043c4c2b9008ab20ca6177bb2" translate="yes" xml:space="preserve">
          <source>It affects your local development.</source>
          <target state="translated">それはあなたの地域の発展に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="0f6ad1f6acc6290c33f3a14bd7e9acc98e2ea785" translate="yes" xml:space="preserve">
          <source>It cost me a little bit to understand what was the difference, but this is a simple explanation. &lt;code&gt;master&lt;/code&gt; in your localhost is a branch.</source>
          <target state="translated">何が違うのかを理解するには少し時間がかかりましたが、これは簡単な説明です。 ローカルホストの &lt;code&gt;master&lt;/code&gt; はブランチです。</target>
        </trans-unit>
        <trans-unit id="c2392417cc36db01685d20f667bd966c4e212a13" translate="yes" xml:space="preserve">
          <source>It doesn't need to be explicitly checked out. Because it implicitly does a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">明示的にチェックアウトする必要はありません。 暗黙的に &lt;code&gt;git merge&lt;/code&gt; を行うからです。</target>
        </trans-unit>
        <trans-unit id="f814b6881b236cbf383bb4fc1485995a7d5b1d8e" translate="yes" xml:space="preserve">
          <source>It is important to contrast the design philosophy of git with the philosophy of a more traditional source control tool like SVN.</source>
          <target state="translated">git の設計思想と、SVN のようなより伝統的なソース管理ツールの思想を対比させることが重要です。</target>
        </trans-unit>
        <trans-unit id="b6e153c12288f95caa3ff1df1c789423019cba8b" translate="yes" xml:space="preserve">
          <source>It is very important to note that &lt;code&gt;git pull&lt;/code&gt; will &lt;strong&gt;automatically merge whether you like it or not&lt;/strong&gt;. This could, of course, result in merge conflicts. Let's say your remote is &lt;code&gt;origin&lt;/code&gt; and your branch is &lt;code&gt;master&lt;/code&gt;. If you &lt;code&gt;git diff origin/master&lt;/code&gt; before pulling, you should have some idea of potential merge conflicts and could prepare your local branch accordingly.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; は、 好みに関係なく、 &lt;strong&gt;自動的にマージ&lt;/strong&gt;されることに注意してください。 もちろん、これによりマージの競合が発生する可能性があります。 リモートが &lt;code&gt;origin&lt;/code&gt; でブランチが &lt;code&gt;master&lt;/code&gt; であるとしましょう。 プルする前に &lt;code&gt;git diff origin/master&lt;/code&gt; をgitする場合、マージの競合の可能性についてある程度の知識が必要であり、それに応じてローカルブランチを準備できます。</target>
        </trans-unit>
        <trans-unit id="98ba93bc2857bab25c62222873602c9b7282098e" translate="yes" xml:space="preserve">
          <source>It will apply the changes from &lt;strong&gt;remote&lt;/strong&gt; to the &lt;strong&gt;current branch&lt;/strong&gt; in local...</source>
          <target state="translated">&lt;strong&gt;リモート&lt;/strong&gt;からローカルの&lt;strong&gt;現在のブランチ&lt;/strong&gt;への変更を適用します...</target>
        </trans-unit>
        <trans-unit id="2089f5ff30d1f915932544997ca4f31cb09b33ab" translate="yes" xml:space="preserve">
          <source>It will download all &lt;strong&gt;refs&lt;/strong&gt; and &lt;strong&gt;objects&lt;/strong&gt; and any new branches to your local Repository...</source>
          <target state="translated">すべての&lt;strong&gt;参照&lt;/strong&gt;と&lt;strong&gt;オブジェクト&lt;/strong&gt; 、および新しいブランチをローカルリポジトリにダウンロードします...</target>
        </trans-unit>
        <trans-unit id="e3692defe3bb907ef3be26614797cff88e4beadd" translate="yes" xml:space="preserve">
          <source>It's basically NOT safe. It's aggressive.</source>
          <target state="translated">基本的に安全ではない 攻撃的だ</target>
        </trans-unit>
        <trans-unit id="0132137c4a419c936535f54c395be92a1c9ac4b0" translate="yes" xml:space="preserve">
          <source>It's interesting to see what's inside all directories, but let's focus on two of them. &lt;code&gt;heads&lt;/code&gt; and &lt;code&gt;remotes&lt;/code&gt;. Use &lt;code&gt;cd&lt;/code&gt; to check inside them too.</source>
          <target state="translated">すべてのディレクトリの中に何があるかを見るのは興味深いですが、そのうちの2つに注目しましょう。 &lt;code&gt;heads&lt;/code&gt; と &lt;code&gt;remotes&lt;/code&gt; 。 &lt;code&gt;cd&lt;/code&gt; を使用してそれらの内部もチェックします。</target>
        </trans-unit>
        <trans-unit id="5b60559fd8e2d2e8e3af93f7c4acc4a9ffbf1885" translate="yes" xml:space="preserve">
          <source>Just do:</source>
          <target state="translated">そうしてくれ</target>
        </trans-unit>
        <trans-unit id="3e188073ca4a40a44969a8d4d808539ffc6cabc5" translate="yes" xml:space="preserve">
          <source>Let's take an example that you are working on a project with your team members. So their will be one main Branch of the project and all the contributors must fork it to their own local repository and then work on this local branch to modify/Add modules then push back to the main branch.</source>
          <target state="translated">あなたがチームメンバーと一緒にプロジェクトに取り組んでいる場合を例にしてみましょう。プロジェクトのメインブランチが1つになり、すべての貢献者はそれを自分のローカルリポジトリにフォークし、このローカルブランチでAddモジュールを修正してからメインブランチにプッシュしなければなりません。</target>
        </trans-unit>
        <trans-unit id="edd3e1409412e78ff0c9eb0c5bb64845286a8e9b" translate="yes" xml:space="preserve">
          <source>More precisely, git pull runs git fetch with the given parameters and
  calls git merge to merge the retrieved branch heads into the current
  branch. With --rebase, it runs git rebase instead of git merge.</source>
          <target state="translated">より正確には、git pull は与えられたパラメータで git fetch を実行し、git merge をコールして取得したブランチヘッドを現在のブランチにマージします。rebase を指定すると、git merge の代わりに git rebase を実行します。</target>
        </trans-unit>
        <trans-unit id="a2ba818d6ed9eeb75fb53e2017802c7157f637d4" translate="yes" xml:space="preserve">
          <source>Normally &lt;strong&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/strong&gt; does this by doing a &lt;strong&gt;&lt;code&gt;git fetch&lt;/code&gt;&lt;/strong&gt; to bring the local copy of the remote repository up to date, and then merging the changes into your own code repository and possibly your working copy.</source>
          <target state="translated">通常、 &lt;strong&gt; &lt;code&gt;git pull&lt;/code&gt; &lt;/strong&gt;は、 &lt;strong&gt; &lt;code&gt;git fetch&lt;/code&gt; &lt;/strong&gt;を実行してリモートリポジトリのローカルコピーを最新の状態にし、変更を独自のコードリポジトリと作業コピーにマージすることでこれを行います。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="31d7bbcc8cef085a2d26f7ea2b1d782e5569ba33" translate="yes" xml:space="preserve">
          <source>Now comes the fun part; do &lt;code&gt;ls&lt;/code&gt;. You will see a list of directories. We're looking for &lt;code&gt;refs&lt;/code&gt;. Do &lt;code&gt;cd refs&lt;/code&gt;.</source>
          <target state="translated">ここからが楽しい部分です。 &lt;code&gt;ls&lt;/code&gt; を実行します。 ディレクトリのリストが表示されます。 &lt;code&gt;refs&lt;/code&gt; を探しています。 &lt;code&gt;cd refs&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="fac4b1246d10c655b4749fcfaf3e582fa75b4dbe" translate="yes" xml:space="preserve">
          <source>Now do &lt;code&gt;ls -a&lt;/code&gt;. This will show &lt;a href=&quot;https://unix.stackexchange.com/questions/21778/whats-so-special-about-directories-whose-names-begin-with-a-dot&quot;&gt;dot files&lt;/a&gt;, i.e., files beginning with &lt;code&gt;.&lt;/code&gt; You will then be able to see a directory named: &lt;code&gt;.git&lt;/code&gt;.</source>
          <target state="translated">次に &lt;code&gt;ls -a&lt;/code&gt; を実行します。 これにより、 &lt;a href=&quot;https://unix.stackexchange.com/questions/21778/whats-so-special-about-directories-whose-names-begin-with-a-dot&quot;&gt;ドットファイル&lt;/a&gt; 、つまりで始まるファイルが表示されます &lt;code&gt;.&lt;/code&gt; これで、 &lt;code&gt;.git&lt;/code&gt; という名前のディレクトリが表示されます。</target>
        </trans-unit>
        <trans-unit id="73721acace98d4f33af7597d3ca64e03bf13917d" translate="yes" xml:space="preserve">
          <source>Now, you have started working on the new module (suppose &lt;code&gt;D&lt;/code&gt;)  and when you have completed the &lt;code&gt;D&lt;/code&gt; module you want to push it to the main branch, But meanwhile what happens is that one of your teammates has developed new Module &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt; and modified &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">これで、新しいモジュール（ &lt;code&gt;D&lt;/code&gt; を想定）の作業を開始し、 &lt;code&gt;D&lt;/code&gt; モジュールが完成したら、それをメインブランチにプッシュしますが、一方でチームメイトの1人が新しいモジュール &lt;code&gt;E&lt;/code&gt; 、 &lt;code&gt;F&lt;/code&gt; 、変更された &lt;code&gt;C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42575cb4c2af958800f2814be4eeb10c93d88c70" translate="yes" xml:space="preserve">
          <source>On step 2: For more on diffs between local and remotes, see: &lt;a href=&quot;https://stackoverflow.com/questions/1800783/compare-local-git-branch-with-remote-branch&quot;&gt;How to compare a local git branch with its remote branch?&lt;/a&gt;</source>
          <target state="translated">ステップ2：ローカルと&lt;a href=&quot;https://stackoverflow.com/questions/1800783/compare-local-git-branch-with-remote-branch&quot;&gt;リモートの&lt;/a&gt;差分の詳細については、ローカルgitブランチとリモートブランチを比較する方法を参照してください。</target>
        </trans-unit>
        <trans-unit id="ba10303cc8bc29ae6d60675a38b4b1414538852e" translate="yes" xml:space="preserve">
          <source>On step 3: It's probably more accurate (e.g. on a fast changing repo) to do a &lt;code&gt;git rebase origin&lt;/code&gt; here. See &lt;a href=&quot;https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch#comment16374948_5376768&quot;&gt;@Justin Ohms comment&lt;/a&gt; in another answer.</source>
          <target state="translated">ステップ3では、ここで &lt;code&gt;git rebase origin&lt;/code&gt; を行う方がおそらくより正確です（たとえば、急速に変化するリポジトリで）。 別の回答で&lt;a href=&quot;https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch#comment16374948_5376768&quot;&gt;@Justin Ohmsのコメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a6ef3be4cb93c5c3a4ab715204573fa2c48f5d9e" translate="yes" xml:space="preserve">
          <source>On the plane, you could make changes to your local workspace and then merge it with what you've fetched and resolve potential merge conflicts all without a connection to the Internet. And unless someone had made &lt;em&gt;new&lt;/em&gt; conflicting changes to the remote repository then once you arrive at the destination you would do &lt;code&gt;git push origin &amp;lt;branch&amp;gt;&lt;/code&gt; and go get your coffee.</source>
          <target state="translated">飛行機では、ローカルワークスペースに変更を加え、それをフェッチしたものとマージし、インターネットに接続せずに潜在的なマージの競合をすべて解決できます。 そして、誰かがリモートリポジトリに競合する&lt;em&gt;新しい&lt;/em&gt;変更を加えていない限り、目的地に到着したら、 &lt;code&gt;git push origin &amp;lt;branch&amp;gt;&lt;/code&gt; を実行してコーヒーを手に入れます。</target>
        </trans-unit>
        <trans-unit id="2cd6dde17abde81f58ef155464001d7b9bdcaf42" translate="yes" xml:space="preserve">
          <source>One use case of &lt;code&gt;git fetch&lt;/code&gt; is that the following will tell you any changes in the remote branch since your last pull... so you can check before doing an actual pull, which could change files in your current branch and working copy.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; の使用例の1つは、最後のプル以降のリモートブランチの変更を次のように通知することです。そのため、実際のプルを実行する前に確認できるため、現在のブランチと作業コピーのファイルが変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="75ae635968f07616c5219d6807711a230311e03a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&quot;&gt;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&lt;/a&gt;</source>
          <target state="translated">参照： &lt;a href=&quot;http://longair.net/blog/2009/04/16/git-fetch-and-merge/&quot;&gt;http&lt;/a&gt; : //longair.net/blog/2009/04/16/git-fetch-and-merge/</target>
        </trans-unit>
        <trans-unit id="8c270f0e70944669bd1713d611d6988fa74b8a56" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://git-scm.com/docs/git-diff&quot;&gt;https://git-scm.com/docs/git-diff&lt;/a&gt; regarding double- and triple-dot syntax in the diff command</source>
          <target state="translated">参照：diffコマンドのダブルドットおよびトリプルドット構文については、 &lt;a href=&quot;https://git-scm.com/docs/git-diff&quot;&gt;https&lt;/a&gt; ： //git-scm.com/docs/git-diff</target>
        </trans-unit>
        <trans-unit id="687ecbf1bdace513420218a49095b8dd9ec63b90" translate="yes" xml:space="preserve">
          <source>So in the Git Gui, when you do fetch, you have to merge the data. Fetch itself won't make the code changes at your local. You can check that when you update the code by fetching
once fetch and see; the code it won't change. Then you merge... You will see the changed code.</source>
          <target state="translated">そのため、Git Guiでは、fetchをするときにはデータをマージしなければなりません。フェッチ自体はローカルでのコード変更をしません。一度フェッチしてコードを更新すると、コードが変更されないことを確認できます。次にマージすると...変更されたコードが表示されます。</target>
        </trans-unit>
        <trans-unit id="7a5191917188b0327a691ee3901a3d3f280832ae" translate="yes" xml:space="preserve">
          <source>So now You can carefully monitor the files before merging it to your repository. And you can also modify &lt;code&gt;D&lt;/code&gt; if required because of Modified &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">これで、ファイルをリポジトリにマージする前に、ファイルを注意深く監視できます。 また、Modified &lt;code&gt;C&lt;/code&gt; のため、必要に応じて &lt;code&gt;D&lt;/code&gt; を変更することもできます。</target>
        </trans-unit>
        <trans-unit id="e7d6ea2d421748f38bd60628b104ed7a0bc8b46c" translate="yes" xml:space="preserve">
          <source>So now what has happened is that your local repository is lacking behind the original progress of the project and thus pushing of your changes to main branch can lead to conflict and may cause your Module &lt;code&gt;D&lt;/code&gt; to malfunction.</source>
          <target state="translated">つまり、ローカルリポジトリにプロジェクトの元の進捗状況が不足しているため、メインブランチに変更をプッシュすると競合が発生し、モジュール &lt;code&gt;D&lt;/code&gt; が誤動作する可能性があります。</target>
        </trans-unit>
        <trans-unit id="6e65b7a5f79a6bd25bc0956f180c6958876f5aa3" translate="yes" xml:space="preserve">
          <source>So the difference will be:</source>
          <target state="translated">ということで、その差が出てきます。</target>
        </trans-unit>
        <trans-unit id="bab2af816ba39862eca729b2dd19f6e2a7dec4aa" translate="yes" xml:space="preserve">
          <source>So, 
&lt;strong&gt;Initial State&lt;/strong&gt; of the two Branches when you forked the main project on your local repository will be like this- (&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; are Modules already completed of the project)</source>
          <target state="translated">したがって、ローカルリポジトリのメインプロジェクトをフォークしたときの2つのブランチの&lt;strong&gt;初期状態&lt;/strong&gt;は次のようになります（ &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、および &lt;code&gt;C&lt;/code&gt; は、プロジェクトですでに完了しているモジュールです）。</target>
        </trans-unit>
        <trans-unit id="c509dfe0d9ecadd21477e5ea89036c82c3331aa1" translate="yes" xml:space="preserve">
          <source>Some IDEs (e.g. Xcode) are super smart and use the result of a &lt;code&gt;git fetch&lt;/code&gt; and can annotate the lines of code that have been changed in remote branch of your current working branch. If that line has been changed by both local changes and remote branch, then that line gets annotated with red. This isn't a merge conflict. It's a &lt;em&gt;potential&lt;/em&gt; merge conflict. It's a headsup that you can use to resolve the future merge conflict before doing &lt;code&gt;git pull&lt;/code&gt; from the remote branch.</source>
          <target state="translated">一部のIDE（Xcodeなど）は非常にスマートで、 &lt;code&gt;git fetch&lt;/code&gt; の結果を使用し、現在の作業ブランチのリモートブランチで変更されたコード行に注釈を付けることができます。 その行がローカル変更とリモートブランチの両方によって変更されている場合、その行には赤の注釈が付けられます。 これはマージの競合ではありません。 これはマージの競合の&lt;em&gt;可能性&lt;/em&gt;があります。 これは、リモートブランチから &lt;code&gt;git pull&lt;/code&gt; を実行する前に、将来のマージの競合を解決するために使用できるヘッドアップです。</target>
        </trans-unit>
        <trans-unit id="751516aaf56e4a009d9a95473521f2b5e4a91c6b" translate="yes" xml:space="preserve">
          <source>Some major advantages for having a fetched mirror of the remote are:</source>
          <target state="translated">リモートのミラーをフェッチしてもらうことの大きなメリットはいくつかあります。</target>
        </trans-unit>
        <trans-unit id="f116feeed3453af125cc94651d00b568b3382b73" translate="yes" xml:space="preserve">
          <source>Sometimes a visual representation helps.</source>
          <target state="translated">視覚的な表現が役立つこともあります。</target>
        </trans-unit>
        <trans-unit id="13de40234719d2a5e55c0bc0833165ebde52b54e" translate="yes" xml:space="preserve">
          <source>Subversion was designed and built with a client/server model. There is a single repository that is the server, and several clients can fetch code from the server, work on it, then commit it back to the server. The assumption is that the client can always contact the server when it needs to perform an operation.</source>
          <target state="translated">Subversion はクライアントサーバーモデルで設計され、構築されています。サーバーとなる単一のリポジトリがあり、複数のクライアントがサーバーからコードを取得して作業し、それをサーバーにコミットすることができます。前提として、クライアントは操作を実行する必要があるときにはいつでもサーバーに連絡を取ることができます。</target>
        </trans-unit>
        <trans-unit id="cbe53d654abeea87d780df2cbb35f48b293f4ab8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fetch&lt;/code&gt; command downloads commits, files, and refs from a
  remote repository into your local repository.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; コマンドは、コミット、ファイル、および参照をリモートリポジトリからローカルリポジトリにダウンロードします。</target>
        </trans-unit>
        <trans-unit id="306f6d2083f24839bb90d29d30ccdf4811f10c03" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;git pull&lt;/strong&gt; command is actually a &lt;code&gt;shortcut&lt;/code&gt; for &lt;strong&gt;git fetch&lt;/strong&gt; followed by the &lt;strong&gt;git merge&lt;/strong&gt; or the &lt;strong&gt;git rebase&lt;/strong&gt; command depending on your configuration. You can configure your Git repository so that &lt;strong&gt;git pull&lt;/strong&gt; is a fetch followed by a rebase.</source>
          <target state="translated">&lt;strong&gt;git pull&lt;/strong&gt;コマンドは実際には、構成に応じて&lt;strong&gt;git fetchの&lt;/strong&gt;後に&lt;strong&gt;git merge&lt;/strong&gt;または&lt;strong&gt;git rebase&lt;/strong&gt;コマンド&lt;strong&gt;が&lt;/strong&gt;続く &lt;code&gt;shortcut&lt;/code&gt; です。 &lt;strong&gt;git pull&lt;/strong&gt;がフェッチとそれに続くリベースになるようにGitリポジトリを構成できます。</target>
        </trans-unit>
        <trans-unit id="35c94b59a53fa50c4f5c982a81436bdd806fd908" translate="yes" xml:space="preserve">
          <source>The Difference between &lt;strong&gt;GIT Fetch&lt;/strong&gt; and &lt;strong&gt;GIT Pull&lt;/strong&gt; can be explained with the following scenario:
&lt;em&gt;(Keeping in mind that pictures speak louder than words!, I have provided pictorial representation)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;GIT Fetch&lt;/strong&gt;と&lt;strong&gt;GIT Pull&lt;/strong&gt;の違いは、次のシナリオで説明できます：（ &lt;em&gt;写真は言葉よりも雄弁であることを念頭に置いて！）、図で表現しました）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53f91a7e62942e203876dd071752da5d13ec2baf" translate="yes" xml:space="preserve">
          <source>The difference between git pull, git fetch and git clone (and git rebase) - Mike Pearce</source>
          <target state="translated">git pull、git fetch、git clone (とgit rebase)の違い-Mike Pearce</target>
        </trans-unit>
        <trans-unit id="f9d05bd2faa3f1351a188371811118689f8a1ab7" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names
  they point at, are written to .git/FETCH_HEAD. This information may be
  used by scripts or other git commands, such as git-pull.</source>
          <target state="translated">取得した ref の名前と、それが指すオブジェクト名が .gitFETCH_HEAD に書き込まれます。この情報は、スクリプトや git-pull などの git コマンドで使用することができます。</target>
        </trans-unit>
        <trans-unit id="709e4c591c9ada67d70a258e7e4251499d7ac05f" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt; is that :</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; と &lt;code&gt;git fetch&lt;/code&gt; の唯一の違いは、</target>
        </trans-unit>
        <trans-unit id="76daff5996e8269d3dd02ea66d3869e8f9168b82" translate="yes" xml:space="preserve">
          <source>The short and easy answer is that &lt;code&gt;git pull&lt;/code&gt; is simply &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">短くて簡単な答えは、 &lt;code&gt;git pull&lt;/code&gt; は単に &lt;code&gt;git fetch&lt;/code&gt; に続いて &lt;code&gt;git merge&lt;/code&gt; を実行することです。</target>
        </trans-unit>
        <trans-unit id="51513cadff1ee5095c8df532e4e37c7e6e2a0fb0" translate="yes" xml:space="preserve">
          <source>The take away is to keep in mind that there are often at least &lt;strong&gt;three copies&lt;/strong&gt; of a project on your workstation. One copy is your own repository with your own commit history. The second copy is your working copy where you are editing and building. The third copy is your local &quot;cached&quot; copy of a remote repository.</source>
          <target state="translated">重要なのは、ワークステーションにはプロジェクトの&lt;strong&gt;コピー&lt;/strong&gt;が少なくとも&lt;strong&gt;3つ&lt;/strong&gt;あることが多いことを覚えておいてください。 1つのコピーは、独自のコミット履歴を持つ独自のリポジトリです。 2番目のコピーは、編集および構築する作業コピーです。 3番目のコピーは、リモートリポジトリのローカルの「キャッシュされた」コピーです。</target>
        </trans-unit>
        <trans-unit id="e6efaade8678bbf79f86466455ab8588f51ff88e" translate="yes" xml:space="preserve">
          <source>The three repos with a fetch:</source>
          <target state="translated">フェッチで3レポ。</target>
        </trans-unit>
        <trans-unit id="96306d9d7afb366db3fd8034aacc498461c28b62" translate="yes" xml:space="preserve">
          <source>The three repos with a pull</source>
          <target state="translated">プルのある3つのレポ</target>
        </trans-unit>
        <trans-unit id="a2f54e0cd5a7689c3b9e61f6dd82d101a2ed1953" translate="yes" xml:space="preserve">
          <source>Then this would go into your remotes directory. It's still not available to your local directory. However, it simplifies your checkout to that remote branch by DWIM (Do what I mean):</source>
          <target state="translated">そうすると、これはあなたのリモートディレクトリに入ります。ローカルディレクトリにはまだ利用できません。しかし、DWIM (Do what I mean)によってリモートブランチへのチェックアウトが簡単になります。</target>
        </trans-unit>
        <trans-unit id="55a7d6a0db4ebe297f2d43c4272f3114636d3660" translate="yes" xml:space="preserve">
          <source>There are two ways of doing step 2. You can:</source>
          <target state="translated">ステップ2を行うには2つの方法があります。できます。</target>
        </trans-unit>
        <trans-unit id="22479224c315e3ac8965a8d67b70537247f8ee88" translate="yes" xml:space="preserve">
          <source>This above command is the most useful command in my git life which saved a lots of time.</source>
          <target state="translated">このコマンドは私のgitライフの中で最も便利なコマンドで、多くの時間を節約してくれました。</target>
        </trans-unit>
        <trans-unit id="d295d38717fafe8c79328dc8ddc3deb6761388e0" translate="yes" xml:space="preserve">
          <source>This blog post was useful:</source>
          <target state="translated">このブログ記事は参考になりました。</target>
        </trans-unit>
        <trans-unit id="0a829a2d422289272de5ab855cb5e9577ba60534" translate="yes" xml:space="preserve">
          <source>This helped me understand why a fetch is pretty important.</source>
          <target state="translated">なぜフェッチがかなり重要なのかを理解するのに役立ちました。</target>
        </trans-unit>
        <trans-unit id="5d5082feffe5ba17e1674f6f1a13809963795a02" translate="yes" xml:space="preserve">
          <source>This interactive graphical representation is very helpful in understanging git: &lt;a href=&quot;http://ndpsoftware.com/git-cheatsheet.html&quot;&gt;http://ndpsoftware.com/git-cheatsheet.html&lt;/a&gt;</source>
          <target state="translated">このインタラクティブなグラフィック表現は、gitの理解に非常に役立ちます&lt;a href=&quot;http://ndpsoftware.com/git-cheatsheet.html&quot;&gt;。http&lt;/a&gt; ： //ndpsoftware.com/git-cheatsheet.html</target>
        </trans-unit>
        <trans-unit id="c03e8aa568e39354d4fef8b90850b194009b133d" translate="yes" xml:space="preserve">
          <source>This is a potentially dangerous mode of operation. It rewrites
  history, which does not bode well when you published that history
  already. Do not use this option unless you have read git-rebase(1)
  carefully.</source>
          <target state="translated">これは潜在的に危険な操作方法です。履歴を書き換えてしまうので、その履歴をすでに公開していた場合には良い結果にはなりません。git-rebase(1)をよく読んでいない限り、このオプションは使わないでください。</target>
        </trans-unit>
        <trans-unit id="6d4d3f7cd0b544f4693755b4f708541dcaf1fb43" translate="yes" xml:space="preserve">
          <source>This is an example for a remote repository called &lt;code&gt;origin&lt;/code&gt; and a branch called &lt;code&gt;master&lt;/code&gt; tracking the remote branch &lt;code&gt;origin/master&lt;/code&gt;:</source>
          <target state="translated">これは、 &lt;code&gt;origin&lt;/code&gt; と呼ばれるリモートリポジトリと、リモートブランチ &lt;code&gt;origin/master&lt;/code&gt; を追跡する &lt;code&gt;master&lt;/code&gt; と呼ばれるブランチの例です。</target>
        </trans-unit>
        <trans-unit id="538591b00fc41f249782e67a77ba3727e103f194" translate="yes" xml:space="preserve">
          <source>This operation never changes any of your own local branches under &lt;code&gt;refs/heads&lt;/code&gt;, and is safe to do without changing your working copy. I have even heard of people running &lt;code&gt;git fetch&lt;/code&gt; periodically in a cron job in the background (although I wouldn't recommend doing this).</source>
          <target state="translated">この操作は、 &lt;code&gt;refs/heads&lt;/code&gt; の下の独自のローカルブランチを変更することはなく、作業コピーを変更せずに安全に実行できます。 バックグラウンドでcronジョブで定期的に &lt;code&gt;git fetch&lt;/code&gt; を実行している人のことさえ聞いたことがあります（ただし、これを行うことはお勧めしません）。</target>
        </trans-unit>
        <trans-unit id="be526cd7b29f7539ab21c31c8d6a75b818a2623e" translate="yes" xml:space="preserve">
          <source>To avoid such issues and to work parallel with the original progress of the project their are Two ways:</source>
          <target state="translated">このような問題を回避し、プロジェクトの本来の進行と並行して作業するためには、以下の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="9cdf14da3817f6628ec1361bea603aa959657fdc" translate="yes" xml:space="preserve">
          <source>To see the actual difference</source>
          <target state="translated">実際の違いを見るには</target>
        </trans-unit>
        <trans-unit id="e5f1d7a647255e501edc50ce9e6aa00b9187d82d" translate="yes" xml:space="preserve">
          <source>To understand this, you first need to understand that your local git maintains not only your local repository, but it also maintains a local copy of the remote repository.</source>
          <target state="translated">これを理解するには、まず、ローカルの git はローカルのリポジトリだけでなく、リモートのリポジトリのローカルコピーも管理していることを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="ffc16a6560848a6d7f779bb9aced6fdf7c588383" translate="yes" xml:space="preserve">
          <source>Trying to be clear and simple.</source>
          <target state="translated">わかりやすくシンプルなものにしようとしている。</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="332032088e32c31d232f02474810d74702bd1d78" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git fetch&lt;/code&gt; where it only affects your &lt;code&gt;.git/refs/remotes&lt;/code&gt;, git pull will affect both your &lt;code&gt;.git/refs/remotes&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;code&gt;.git/refs/heads/&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.git/refs/remotes&lt;/code&gt; にのみ影響する &lt;code&gt;git fetch&lt;/code&gt; とは異なり、git pullは &lt;code&gt;.git/refs/remotes&lt;/code&gt; &lt;strong&gt;と&lt;/strong&gt; &lt;code&gt;.git/refs/heads/&lt;/code&gt; 両方に影響します</target>
        </trans-unit>
        <trans-unit id="d13c88e54fc8efb180fc6b3b27421a7fb284a530" translate="yes" xml:space="preserve">
          <source>Update your local repo from the remote (but don't merge):</source>
          <target state="translated">リモートからローカルのレポを更新してください (ただしマージはしないでください)。</target>
        </trans-unit>
        <trans-unit id="8f6be89be11acde27b9603fe48a423a16c6df9dc" translate="yes" xml:space="preserve">
          <source>We simply say:</source>
          <target state="translated">私たちは単純に言います。</target>
        </trans-unit>
        <trans-unit id="ea59d40483dcdff606446c1278db4f30b88410e8" translate="yes" xml:space="preserve">
          <source>What are the differences between &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; と &lt;code&gt;git fetch&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="f4a4b649621d7f1f61aa3c746531b2f6672b090d" translate="yes" xml:space="preserve">
          <source>What is the difference between 'git pull' and 'git fetch'</source>
          <target state="translated">git pull' と 'git fetch' の違いは?</target>
        </trans-unit>
        <trans-unit id="bc03f833fd7c52d8a1b370a5afba995d1e6fe5f2" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; と &lt;code&gt;git fetch&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="b8cf24993f0288b5cc2c819833af209e300e949c" translate="yes" xml:space="preserve">
          <source>When downloading content from a remote repository, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt; commands are available to accomplish the task. You can consider
  &lt;code&gt;git fetch&lt;/code&gt; the 'safe' version of the two commands. It will download
  the remote content, but not update your local repository's working state,
  leaving your current work intact. &lt;code&gt;git pull&lt;/code&gt; is the more aggressive
  alternative, it will download the remote content for the active local
  branch and immediately execute &lt;code&gt;git merge&lt;/code&gt; to create a merge commit
  for the new remote content. If you have pending changes in progress
  this will cause conflicts and kickoff the merge conflict resolution
  flow.</source>
          <target state="translated">リモートリポジトリからコンテンツをダウンロードする場合、 &lt;code&gt;git pull&lt;/code&gt; および &lt;code&gt;git fetch&lt;/code&gt; コマンドを使用してタスクを実行できます。 2つのコマンドの「安全な」バージョンを &lt;code&gt;git fetch&lt;/code&gt; することを検討できます。 リモートコンテンツはダウンロードされますが、ローカルリポジトリの動作状態は更新されず、現在の作業はそのまま残ります。 &lt;code&gt;git pull&lt;/code&gt; はより強力な代替手段です。アクティブなローカルブランチのリモートコンテンツをダウンロードし、すぐに &lt;code&gt;git merge&lt;/code&gt; を実行して、新しいリモートコンテンツのマージコミットを作成します。 保留中の変更が進行中の場合、これにより競合が発生し、マージ競合解決フローが開始されます。</target>
        </trans-unit>
        <trans-unit id="90241fc66dccec755b7f7a1db64386e32d1975aa" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the origin remote will be
  used, unless there&amp;rsquo;s an upstream branch configured for the current
  branch.</source>
          <target state="translated">リモートが指定されていない場合、現在のブランチに設定されたアップストリームブランチがない限り、デフォルトで元のリモートが使用されます。</target>
        </trans-unit>
        <trans-unit id="f29d1d15a178302f133f949f8f12fc0d9c744655" translate="yes" xml:space="preserve">
          <source>When you &lt;code&gt;fetch&lt;/code&gt;, Git gathers any commits from the target branch that do not exist in your current branch and &lt;strong&gt;stores them in your local repository&lt;/strong&gt;. However, &lt;strong&gt;it does not merge them with your current branch&lt;/strong&gt;. This is particularly useful if you need to keep your repository up to date, but are working on something that might break if you update your files. 
To integrate the commits into your master branch, you use &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 、Gitは現在のブランチに存在しないターゲットブランチからのコミットを収集&lt;strong&gt;し、ローカルリポジトリに保存します&lt;/strong&gt; 。 ただし、 &lt;strong&gt;現在のブランチとはマージされません&lt;/strong&gt; 。 これは、リポジトリを最新の状態に保つ必要があるが、ファイルを更新すると壊れる可能性のある問題に取り組んでいる場合に特に便利です。 コミットをマスターブランチに統合するには、 &lt;code&gt;merge&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="2f6b2b23ee6b56459eb33e7764e459ba74679007" translate="yes" xml:space="preserve">
          <source>When you clone a repository you fetch the entire repository to you local host. This means that at that time you have an origin/master pointer to &lt;code&gt;HEAD&lt;/code&gt; and master pointing to the same &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">リポジトリを複製すると、リポジトリ全体がローカルホストにフェッチされます。 つまり、その時点で、 &lt;code&gt;HEAD&lt;/code&gt; へのオリジン/マスターポインターと、同じ &lt;code&gt;HEAD&lt;/code&gt; を指すマスターがあります。</target>
        </trans-unit>
        <trans-unit id="8ae99188f3ea7c125344fba8a5364f2b481c9542" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;pull&lt;/code&gt;, Git tries to automatically do your work for you. &lt;strong&gt;It is context sensitive&lt;/strong&gt;, so Git will merge any pulled commits into the branch you are currently working in.  &lt;code&gt;pull&lt;/code&gt;&lt;strong&gt;automatically merges the commits without letting you review them first&lt;/strong&gt;. If you don&amp;rsquo;t closely manage your branches, you may run into frequent conflicts.</source>
          <target state="translated">&lt;code&gt;pull&lt;/code&gt; を使用すると、Gitは自動的に作業を実行しようとします。 &lt;strong&gt;これは状況依存&lt;/strong&gt;であるため、Gitはプルされたコミットを現在作業中のブランチにマージします。 &lt;code&gt;pull&lt;/code&gt; &lt;strong&gt;最初に確認せずにコミットを自動的にマージします&lt;/strong&gt; 。 ブランチを厳密に管理しないと、頻繁に競合する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1b93bc9367ac04ff57c408636c95b140163378c0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git pull&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; で ：</target>
        </trans-unit>
        <trans-unit id="3d83192bff705155cb759eec49d16b9a3257e7a7" translate="yes" xml:space="preserve">
          <source>You can apply changes downloaded through fetch using the merge command. Merge will take the commits retrieved from fetch and try to add them to your local branch. The merge will keep the commit history of your local changes so that when you share your branch with push, Git will know how others can merge your changes.</source>
          <target state="translated">fetch でダウンロードした変更は merge コマンドを使用して適用することができます。merge は fetch で取得したコミットをローカルブランチに追加しようとします。マージはローカルでの変更のコミット履歴を保持するので、プッシュでブランチを共有したときに、他の人がどのようにして変更をマージできるかを Git が知ることができます。</target>
        </trans-unit>
        <trans-unit id="77cc8b703c81ec309bd760da433e26013a43df97" translate="yes" xml:space="preserve">
          <source>You can do a &lt;code&gt;git fetch&lt;/code&gt; at any time to update your remote-tracking branches under &lt;code&gt;refs/remotes/&amp;lt;remote&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">いつでも &lt;code&gt;git fetch&lt;/code&gt; を実行して、 &lt;code&gt;refs/remotes/&amp;lt;remote&amp;gt;/&lt;/code&gt; にあるリモート追跡ブランチを更新できます。</target>
        </trans-unit>
        <trans-unit id="60d4353b41982c20e79e6a617ebff5018b2b3fef" translate="yes" xml:space="preserve">
          <source>You can fetch from a remote repository, see the differences and then pull or merge.</source>
          <target state="translated">リモートリポジトリから取得し、差分を確認してからプルやマージすることができます。</target>
        </trans-unit>
        <trans-unit id="9648163d36e5997ca061fecd2f767a9206a1de2a" translate="yes" xml:space="preserve">
          <source>You don't get any isolation.</source>
          <target state="translated">孤立することはない。</target>
        </trans-unit>
        <trans-unit id="3af21692e399cffc1b0602029c4c529d3a93c542" translate="yes" xml:space="preserve">
          <source>You download changes to your local branch from origin through fetch. Fetch asks the remote repo for all commits that others have made but you don't have on your local repo. Fetch downloads these commits and adds them to the local repository.</source>
          <target state="translated">fetch を使ってローカルブランチに変更をダウンロードします。Fetch はリモートのリポジトリに、他の人が行ったがローカルのリポジトリにはないコミットをすべて問い合わせます。Fetch はこれらのコミットをダウンロードし、ローカルリポジトリに追加します。</target>
        </trans-unit>
        <trans-unit id="71deaa7d8f575ab7ed6cd6bbf3334a1461005600" translate="yes" xml:space="preserve">
          <source>You would pull if you want the histories merged, you'd fetch if you just 'want the codez' as some person has been tagging some articles around here.</source>
          <target state="translated">履歴をマージしたい場合はプルして、この辺りの記事にタグを付けている人がいるように「コードが欲しい」場合はフェッチします。</target>
        </trans-unit>
        <trans-unit id="d0a02932aa479b6aeba6af580331b25d6888fea8" translate="yes" xml:space="preserve">
          <source>and covers &lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git clone&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 、 &lt;code&gt;git fetch&lt;/code&gt; 、 &lt;code&gt;git clone&lt;/code&gt; 、 &lt;code&gt;git rebase&lt;/code&gt; についても取り上げています。</target>
        </trans-unit>
        <trans-unit id="076889ab0a1a5ea289dc99e4db7f5646876c95f3" translate="yes" xml:space="preserve">
          <source>but in ,</source>
          <target state="translated">然し乍ら</target>
        </trans-unit>
        <trans-unit id="338b9d34cef0cc10394bbeb555b6c8652b8ad965" translate="yes" xml:space="preserve">
          <source>eg: i am going to fetch from server master and rebase it in my local master.</source>
          <target state="translated">例:サーバーマスターから取得して、ローカルマスターにリベースしようとしています。</target>
        </trans-unit>
        <trans-unit id="7652ed4e9782162856d4648e8895b3387d9f68e6" translate="yes" xml:space="preserve">
          <source>git fetch</source>
          <target state="translated">git フェッチ</target>
        </trans-unit>
        <trans-unit id="a1e51d9e97a083cd4a749ceb74184d3a801ebb5d" translate="yes" xml:space="preserve">
          <source>git fetch can fetch from either a single named repository or URL, or
  from several repositories at once if  is given and there is a
  remotes. entry in the configuration file. (See git-config&lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1&lt;/a&gt;).</source>
          <target state="translated">git fetchは、指定されたリモートが存在する場合、単一の名前付きリポジトリまたはURLから、または一度に複数のリポジトリからフェッチできます。 構成ファイルのエントリ。 （git-config &lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a6378e53c49a3c9ce8158f63060def312e889cf2" translate="yes" xml:space="preserve">
          <source>git fetch does not changes to local branches.</source>
          <target state="translated">git fetch はローカルブランチを変更しません。</target>
        </trans-unit>
        <trans-unit id="5b19fd74d867e845324d1cc6667583a990caa8b8" translate="yes" xml:space="preserve">
          <source>git fetch: Git is going to get the latest version from remote to local,  but it do not automatically merge.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;code&gt;git fetch origin master&lt;/code&gt;&lt;code&gt;git log -p master..origin/master&lt;/code&gt;&lt;code&gt;git merge origin/master&lt;/code&gt;</source>
          <target state="translated">git fetch：Gitはリモートからローカルに最新バージョンを取得しますが、自動的にはマージされません。 &lt;code&gt;git fetch origin master&lt;/code&gt; &lt;code&gt;git log -p master..origin/master&lt;/code&gt; &lt;code&gt;git merge origin/master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d065adf8851333810ea91f5f69a1ea63158b8826" translate="yes" xml:space="preserve">
          <source>git pull</source>
          <target state="translated">ギットプル</target>
        </trans-unit>
        <trans-unit id="7211a49be2c5e530c61f049fc400dec211114d60" translate="yes" xml:space="preserve">
          <source>git pull == ( git fetch + git merge)</source>
          <target state="translated">git pull ==(git fetch+git merge)</target>
        </trans-unit>
        <trans-unit id="98d57b348afc86b663f71eb34f50f6b73b3d02af" translate="yes" xml:space="preserve">
          <source>git pull: Git is going to get the latest version from the remote and merge into the local.</source>
          <target state="translated">git pullします。Gitがリモートから最新版を取得してローカルにマージしてくれます。</target>
        </trans-unit>
        <trans-unit id="4c01625fa313444b2582a58311703d8668a6b3bb" translate="yes" xml:space="preserve">
          <source>here &lt;strong&gt;origin&lt;/strong&gt; is your remote repo &lt;strong&gt;master&lt;/strong&gt; is your branch</source>
          <target state="translated">ここで、 &lt;strong&gt;オリジン&lt;/strong&gt;はリモートレポ&lt;strong&gt;マスター&lt;/strong&gt;がブランチです</target>
        </trans-unit>
        <trans-unit id="f3293b87bc9bb8812771c354181c62eef7b1e271" translate="yes" xml:space="preserve">
          <source>here,</source>
          <target state="translated">here,</target>
        </trans-unit>
        <trans-unit id="3aa005c86b2e48f70aa9c07d41965bad325d9628" translate="yes" xml:space="preserve">
          <source>i.e. git pull = git fetch + git merge ...</source>
          <target state="translated">つまり、git pull=git fetch+git merge ...</target>
        </trans-unit>
        <trans-unit id="8abe66c44f7b8696d85a5e265ed9f37769e3e453" translate="yes" xml:space="preserve">
          <source>it will fetch server changes from origin. and it will be in your local until you rebase it on your own. we need to fix conflicts manually by checking codes.</source>
          <target state="translated">これはサーバーの変更をオリジンから取得し、自分でリベースするまではローカルに置かれます。</target>
        </trans-unit>
        <trans-unit id="77e703902168624324db616363fbd43a7158e819" translate="yes" xml:space="preserve">
          <source>should be the name of a remote repository as passed to
  git-fetch&lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1&lt;/a&gt;.  can name an arbitrary remote ref (for example,
  the name of a tag) or even a collection of refs with corresponding
  remote-tracking branches (e.g., refs/heads/&lt;em&gt;:refs/remotes/origin/&lt;/em&gt;),
  but usually it is the name of a branch in the remote repository.</source>
          <target state="translated">git-fetch &lt;a href=&quot;https://i.stack.imgur.com/nWYnQ.png&quot;&gt;1に&lt;/a&gt;渡されるリモートリポジトリの名前である必要があります。 任意のリモート参照（たとえば、タグの名前）または対応するリモート追跡ブランチを持つ参照のコレクション（たとえば、refs / heads / &lt;em&gt;：refs / remotes / origin /&lt;/em&gt; ）に名前を付けることができますが、通常は名前ですリモートリポジトリのブランチの。</target>
        </trans-unit>
        <trans-unit id="a6e839f3fb69bba683587d3332f5f0020879b4dc" translate="yes" xml:space="preserve">
          <source>this will rebase code into local. before that ensure you're in right branch.</source>
          <target state="translated">これはコードをローカルにリベースします。その前に正しいブランチにいることを確認してください。</target>
        </trans-unit>
        <trans-unit id="8fd2b1b8f0afc6bcf95d25c97c52d650bc531b47" translate="yes" xml:space="preserve">
          <source>when you start working and do commits you advance the master pointer to &lt;code&gt;HEAD&lt;/code&gt; + your commits. But the origin/master pointer is still pointing to what it was when you cloned.</source>
          <target state="translated">作業を開始してコミットすると、マスターポインターを &lt;code&gt;HEAD&lt;/code&gt; +コミットに進めます。 しかし、オリジン/マスターポインターは、クローンを作成したときの状態を指しています。</target>
        </trans-unit>
        <trans-unit id="c8611464dcef8825f2ef8aa62feb4357dc35ccde" translate="yes" xml:space="preserve">
          <source>will fetch code from repository and rebase with your local... in git pull there is possibility of new commits getting created.</source>
          <target state="translated">リポジトリからコードを取得し、ローカルでリベースします...git pullでは新しいコミットが作成される可能性があります。</target>
        </trans-unit>
        <trans-unit id="f6492f8b35e6d7766d4dd5492898cb07179aaa87" translate="yes" xml:space="preserve">
          <source>will fetch code from repository and we need to rebase it manually by using &lt;code&gt;git rebase&lt;/code&gt;</source>
          <target state="translated">リポジトリからコードをフェッチし、 &lt;code&gt;git rebase&lt;/code&gt; を使用して手動でリベースする必要があります</target>
        </trans-unit>
        <trans-unit id="922ad17f05bbaa394ace87920268f3431e1ccebb" translate="yes" xml:space="preserve">
          <source>you no longer need to do:</source>
          <target state="translated">あなたがする必要はありません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
