<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/291978">
    <body>
      <group id="291978">
        <trans-unit id="2e5ea5b373efb0a978388bcda9efa3c4e5c03c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; will never be found in &lt;code&gt;code2&lt;/code&gt; (even in cases where you might expect it would, see &lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;Antti's answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; は &lt;code&gt;code2&lt;/code&gt; で検出されることはありません（ 予期される場合でも、 &lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;Anttiの回答&lt;/a&gt;または&lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;こちらを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="844b4071ade54e31a272636444a86d27dbf60eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B&lt;/strong&gt;uilt-in (Python) &amp;mdash; Names preassigned in the built-in names module: &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;SyntaxError&lt;/code&gt;, etc</source>
          <target state="translated">&lt;strong&gt;B&lt;/strong&gt; uilt-in（Python）&amp;mdash;組み込みの名前モジュールで事前に割り当てられた名前： &lt;code&gt;open&lt;/code&gt; 、 &lt;code&gt;range&lt;/code&gt; 、 &lt;code&gt;SyntaxError&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="97299d3c668df1ab4082a55faa649fd2528112b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;nclosing-function &amp;mdash; Names assigned in the local scope of any and all statically enclosing functions (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), from inner to outer</source>
          <target state="translated">&lt;strong&gt;E&lt;/strong&gt; nclosing-function &amp;mdash;静的に囲むすべての関数（ &lt;code&gt;def&lt;/code&gt; または &lt;code&gt;lambda&lt;/code&gt; ）のローカルスコープで、内側から外側に割り当てられた名前</target>
        </trans-unit>
        <trans-unit id="cfb38a37b33062a0dac44099257bd4a65386ac18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;lobal (module) &amp;mdash; Names assigned at the top-level of a module file, or by executing a &lt;code&gt;global&lt;/code&gt; statement in a &lt;code&gt;def&lt;/code&gt; within the file</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; （モジュール）&amp;mdash;モジュールファイルのトップレベルで、またはファイル内の &lt;code&gt;def&lt;/code&gt; でグローバルステートメントを実行して割り当てられた名前</target>
        </trans-unit>
        <trans-unit id="778d2680a013b2b927bbd42cf4dbd8f8e603daa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;L&lt;/strong&gt;ocal &amp;mdash; Names assigned in any way within a function (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), and not declared global in that function</source>
          <target state="translated">&lt;strong&gt;L&lt;/strong&gt; ocal &amp;mdash;関数（ &lt;code&gt;def&lt;/code&gt; または &lt;code&gt;lambda&lt;/code&gt; ）内で何らかの方法で割り当てられ、その関数でグローバルに宣言されていない名前</target>
        </trans-unit>
        <trans-unit id="5277f4fac12d44eb629e5c22b7e1d8094c037eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LEGB Rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LEGBルール&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8fbc1e546684b1d340d4bb068e765dfcdfb7254c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restrictions:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Restrictions:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e9af317e5a414fef2826cb666d4e978c26801dd" translate="yes" xml:space="preserve">
          <source>A slightly more complete example of scope:</source>
          <target state="translated">少し完成度の高いスコープの例。</target>
        </trans-unit>
        <trans-unit id="3eacc2675a7bf748ffe69c0804238499bf0a642c" translate="yes" xml:space="preserve">
          <source>Actually, a concise rule for Python Scope resolution, from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;Learning Python, 3rd. Ed.&lt;/a&gt;. (These rules are specific to variable names, not attributes. If you reference it without a period, these rules apply.)</source>
          <target state="translated">実際には、Pythonスコープ解決のための簡潔なルール、 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;Learning Python、3番目。&lt;/a&gt; エド。 。 （これらのルールは、属性ではなく変数名に固有です。ピリオドなしで参照すると、これらのルールが適用されます。）</target>
        </trans-unit>
        <trans-unit id="b9b84618b4dc87a1c871237cbcae8ef234da18b5" translate="yes" xml:space="preserve">
          <source>Also there is the context during execution, when the function &lt;code&gt;spam&lt;/code&gt; is passed somewhere else. And maybe &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;lambda functions&lt;/a&gt; pass a bit differently?</source>
          <target state="translated">また、関数 &lt;code&gt;spam&lt;/code&gt; が別の場所に渡された場合、実行中にコンテキストがあります。 そして、おそらく&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;ラムダ関数&lt;/a&gt;は少し異なって渡しますか？</target>
        </trans-unit>
        <trans-unit id="2b234758bd81a7c9bf0560b3b0aec62418bf437f" translate="yes" xml:space="preserve">
          <source>An object (an instance of a class) has instance variables.  These names are in the object's namespace.  They must be qualified by the object.  (&lt;code&gt;variable.instance&lt;/code&gt;.)</source>
          <target state="translated">オブジェクト（クラスのインスタンス）にはインスタンス変数があります。 これらの名前はオブジェクトの名前空間にあります。 それらはオブジェクトによって修飾される必要があります。 （ &lt;code&gt;variable.instance&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="edd9da0852ea07205aefc7b6ee60189bd45f1905" translate="yes" xml:space="preserve">
          <source>Any variable that is not deemed to be local to the current scope, or any enclosing scope, is a global variable. A global name is looked up in the module global dictionary; if not found, the global is then looked up from the builtins module; the name of the module was changed from python 2 to python 3; in python 2 it was &lt;code&gt;__builtin__&lt;/code&gt; and in python 3 it is now called &lt;code&gt;builtins&lt;/code&gt;. If you assign to an attribute of builtins module, it will be visible thereafter to any module as a readable global variable, unless that module shadows them with its own global variable with the same name.</source>
          <target state="translated">現在のスコープに対してローカルであると見なされない変数、またはそれを囲むスコープは、グローバル変数です。 グローバル名はモジュールのグローバル辞書で検索されます。 見つからない場合は、組み込みモジュールからグローバルが検索されます。 モジュールの名前がpython 2からpython 3に変更されました。 Python 2では &lt;code&gt;__builtin__&lt;/code&gt; でしたが、Python 3では &lt;code&gt;builtins&lt;/code&gt; と呼ばれています 。 ビルトインモジュールの属性に割り当てる場合、そのモジュールが同じ名前の独自のグローバル変数でそれらをシャドウしない限り、その後、読み取り可能なグローバル変数として任意のモジュールに表示されます。</target>
        </trans-unit>
        <trans-unit id="5e4660e77d407e9b103ce4b6048d3ef22738c691" translate="yes" xml:space="preserve">
          <source>As provided in other answers, there are 4 basic scopes, the LEGB, for Local, Enclosing, Global and Builtin. In addition to those, there is a special scope, the &lt;strong&gt;class body&lt;/strong&gt;, which does not comprise an enclosing scope for methods defined within the class; any assignments within the class body make the variable from there on be bound in the class body.</source>
          <target state="translated">他の回答で提供されているように、LEGBには4つの基本スコープがあります。ローカル、囲み、グローバル、および組み込みです。 これらに加えて、特別なスコープである&lt;strong&gt;クラス本体&lt;/strong&gt;があります。これは、クラス内で定義されたメソッドの囲みスコープを構成しません。 クラス本体内の割り当てにより、そこからの変数はクラス本体にバインドされます。</target>
        </trans-unit>
        <trans-unit id="77587594047610e85f49724453d7e1697738b9e3" translate="yes" xml:space="preserve">
          <source>At any time during execution, there
  are at least three nested scopes whose
  namespaces are directly accessible:
  the innermost scope, which is searched
  first, contains the local names; the
  namespaces of any enclosing functions,
  which are searched starting with the
  nearest enclosing scope; the middle
  scope, searched next, contains the
  current module's global names; and the
  outermost scope (searched last) is the
  namespace containing built-in names.</source>
          <target state="translated">最初に検索される一番内側のスコープにはローカルの名前が含まれています。</target>
        </trans-unit>
        <trans-unit id="949db5aedd1359c2910fdcddc532ee3920954144" translate="yes" xml:space="preserve">
          <source>B: Any builtin &lt;code&gt;x&lt;/code&gt; in Python.</source>
          <target state="translated">B：Pythonの組み込み &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94f58ad3d39e723cd41ed035c3fc63eb570fe299" translate="yes" xml:space="preserve">
          <source>Before nested_scopes&amp;thinsp;&amp;mdash;&amp;thinsp;in Python pre-2.1, and in 2.1 unless you specifically ask for the feature using a from-future-import&amp;thinsp;&amp;mdash;&amp;thinsp;fun1 and fun2's scopes are not visible to fun3, so S.Lott's answer holds and you would get the global x:</source>
          <target state="translated">nested_scopesの前&amp;mdash; Python 2.1より前、およびfrom-future-importを使用して機能を特に要求しない限り2.1では、fun1およびfun2のスコープはfun3に表示されないため、S.Lottの答えは保持され、グローバルxを取得します：</target>
        </trans-unit>
        <trans-unit id="ccabba569adb4497369de2ec7d4f33e75f0e6878" translate="yes" xml:space="preserve">
          <source>Currently there is no way to do the same for variables in enclosing &lt;em&gt;function&lt;/em&gt; scopes, but Python 3 introduces a new keyword, &quot;&lt;code&gt;nonlocal&lt;/code&gt;&quot; which will act in a similar way to global, but for nested function scopes.</source>
          <target state="translated">現在、 &lt;em&gt;関数&lt;/em&gt;スコープを囲んでいる変数に対して同じことを行う方法はありませんが、Python 3では、グローバルと同様に&lt;em&gt;機能&lt;/em&gt;する新しいキーワード「 &lt;code&gt;nonlocal&lt;/code&gt; 」が導入されていますが、関数スコープがネストされています。</target>
        </trans-unit>
        <trans-unit id="685a7a88c4d863000bc56afa13ac95aae11160f0" translate="yes" xml:space="preserve">
          <source>E: Any enclosing functions (if the whole example were in another &lt;code&gt;def&lt;/code&gt;)</source>
          <target state="translated">E：任意の囲み関数（例全体が別の &lt;code&gt;def&lt;/code&gt; にある場合 ）</target>
        </trans-unit>
        <trans-unit id="3091bb32545b1f507703c4fcd6455ca21eb171a8" translate="yes" xml:space="preserve">
          <source>EDIT: Here's the &lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt; with more information on this.</source>
          <target state="translated">編集：これに関する詳細情報を記載した&lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt;を以下に示します。</target>
        </trans-unit>
        <trans-unit id="5067e65f592d1333460adda9fda56628aeffb64e" translate="yes" xml:space="preserve">
          <source>Especially, &lt;strong&gt;no&lt;/strong&gt; block statement, besides &lt;code&gt;def&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;, create a variable scope. In Python 2 a list comprehension does not create a variable scope, however in Python 3 the loop variable within list comprehensions is created in a new scope.</source>
          <target state="translated">特に、 &lt;code&gt;def&lt;/code&gt; と &lt;code&gt;class&lt;/code&gt; 以外&lt;strong&gt;の&lt;/strong&gt;ブロックステートメントは、変数スコープを作成し&lt;strong&gt;ません&lt;/strong&gt; 。 Python 2ではリスト内包表記は変数スコープを作成しませんが、Python 3ではリスト内包表記内のループ変数は新しいスコープ内に作成されます。</target>
        </trans-unit>
        <trans-unit id="4360b38ce6fca6533891aa6402e815f6de882ee8" translate="yes" xml:space="preserve">
          <source>Essentially, the only thing in Python that introduces a new scope is a function definition.  Classes are a bit of a special case in that anything defined directly in the body is placed in the class's namespace, but they are not directly accessible from within the methods (or nested classes) they contain.</source>
          <target state="translated">基本的に、Pythonで新しいスコープを導入するのは関数の定義だけです。クラスは少し特殊なケースで、ボディ内で直接定義されたものはクラスの名前空間に置かれますが、それらが含むメソッド(またはネストされたクラス)内から直接アクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="3454040cf44b56303faa3532297c412240cf336a" translate="yes" xml:space="preserve">
          <source>From within a class method, you have locals and globals.  You say &lt;code&gt;self.variable&lt;/code&gt; to pick the instance as the namespace.  You'll note that &lt;code&gt;self&lt;/code&gt; is an argument to every class member function, making it part of the local namespace.</source>
          <target state="translated">クラスメソッド内から、ローカルとグローバルがあります。 インスタンスを名前空間として選択するには、 &lt;code&gt;self.variable&lt;/code&gt; と言います。 &lt;code&gt;self&lt;/code&gt; はすべてのクラスメンバー関数の引数であり、ローカル名前空間の一部になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7664a9e609e66bc2d00fa363b667ab4f2f1fefff" translate="yes" xml:space="preserve">
          <source>G: Were there any &lt;code&gt;x&lt;/code&gt; declared globally in the module (in &lt;code&gt;code1&lt;/code&gt;)?</source>
          <target state="translated">G：モジュール（ &lt;code&gt;code1&lt;/code&gt; ）でグローバルに宣言された &lt;code&gt;x&lt;/code&gt; はありましたか？</target>
        </trans-unit>
        <trans-unit id="1d87f06cf14aca3bd4a191b57670565bfad952c1" translate="yes" xml:space="preserve">
          <source>Global is -- well -- global.</source>
          <target state="translated">グローバルは...その...グローバル。</target>
        </trans-unit>
        <trans-unit id="5e8b57f9b5edca1d505a9498465cdf117eedf409" translate="yes" xml:space="preserve">
          <source>However in python 3, the &lt;code&gt;nonlocal&lt;/code&gt; comes to rescue:</source>
          <target state="translated">しかしpython 3では、 &lt;code&gt;nonlocal&lt;/code&gt; が救いに来ます：</target>
        </trans-unit>
        <trans-unit id="489c4eee2e8a8e18d94f2c3c5b9d39e4ba2a71d9" translate="yes" xml:space="preserve">
          <source>If I have some code:</source>
          <target state="translated">コードがあれば</target>
        </trans-unit>
        <trans-unit id="3f0b2cb298d97b428d9e6a5814ab14829603d125" translate="yes" xml:space="preserve">
          <source>If a name is ever assigned to in the current scope (except in the class scope), it will be considered belonging to that scope, otherwise it will be considered to belonging to any enclosing scope that assigns to the variable (it might not be assigned yet, or not at all), or finally the global scope. If the variable is considered local, but it is not set yet, or has been deleted, reading the variable value will result in &lt;code&gt;UnboundLocalError&lt;/code&gt;, which is a subclass of &lt;code&gt;NameError&lt;/code&gt;.</source>
          <target state="translated">現在のスコープ（クラススコープを除く）で名前が割り当てられている場合、その名前はそのスコープに属していると見なされます。それ以外の場合、変数に割り当てられているスコープに属していると見なされます（割り当てられない場合があります）まだ、またはまったくない）、または最後にグローバルスコープ。 変数がローカルと見なされているが、まだ設定されていないか、削除されている場合、変数値を読み取ると、 &lt;code&gt;UnboundLocalError&lt;/code&gt; のサブクラスである &lt;code&gt;NameError&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="d536a4e1d312f0bb4a36c7db71be18f86a0595ec" translate="yes" xml:space="preserve">
          <source>If a variable can't be found in the current scope, please refer to the LEGB order.</source>
          <target state="translated">現在のスコープに変数が見つからない場合は、LEGBのオーダーを参照してください。</target>
        </trans-unit>
        <trans-unit id="594e2207a906c678397d7ca8b95cf26be8bec159" translate="yes" xml:space="preserve">
          <source>In Python,</source>
          <target state="translated">Pythonで。</target>
        </trans-unit>
        <trans-unit id="daa6bf94be3ef37adbff56bb43caa58be32ae290" translate="yes" xml:space="preserve">
          <source>In order to actually modify the bindings of global variables from within a function scope, you need to specify that the variable is global with the global keyword.  Eg:</source>
          <target state="translated">関数スコープ内からグローバル変数のバインディングを実際に変更するには、その変数がグローバルであることをグローバルキーワードで指定する必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0bc6e3d84d0a49e5ed2803b53b300500f65ae44e" translate="yes" xml:space="preserve">
          <source>In python 2 there is no easy way to modify the value in the enclosing scope; usually this is simulated by having a mutable value, such as a list with length of 1:</source>
          <target state="translated">python 2では、スコープ内の値を簡単に変更する方法はありません。通常は、長さが1のリストのような可変値を持つことでシミュレートします。</target>
        </trans-unit>
        <trans-unit id="286079d30426b3322fda99d492f07b15340885cb" translate="yes" xml:space="preserve">
          <source>In the class namespace</source>
          <target state="translated">クラスの名前空間では</target>
        </trans-unit>
        <trans-unit id="28d8f315b0ed9313fc78b3f5380fd9a3257f9305" translate="yes" xml:space="preserve">
          <source>In the enclosing source file</source>
          <target state="translated">同封のソースファイルでは</target>
        </trans-unit>
        <trans-unit id="ca0a0838b052bc29ab825218ced55d4acd83b7c4" translate="yes" xml:space="preserve">
          <source>In the for loop index variable</source>
          <target state="translated">forループのインデックス変数</target>
        </trans-unit>
        <trans-unit id="61e7200f1f6a388923daba14399fca3fa229c76d" translate="yes" xml:space="preserve">
          <source>In the function definition</source>
          <target state="translated">関数定義では</target>
        </trans-unit>
        <trans-unit id="a677829300682f1c31d8905cb2e5282167c47489" translate="yes" xml:space="preserve">
          <source>In this case, the call to a function named &lt;code&gt;x&lt;/code&gt; has to be resolved in the local name space or the global namespace.</source>
          <target state="translated">この場合、 &lt;code&gt;x&lt;/code&gt; という名前の関数の呼び出しは、ローカル名前空間またはグローバル名前空間で解決する必要があります。</target>
        </trans-unit>
        <trans-unit id="df991876b5a88f673697607e52e60c6b1c9b6fe4" translate="yes" xml:space="preserve">
          <source>In your example there are only 3 scopes where x will be searched in:</source>
          <target state="translated">あなたの例では、xが検索されるスコープは3つしかありません。</target>
        </trans-unit>
        <trans-unit id="b22ee2fbcc9bb471eb4de6b0b6be177886173cac" translate="yes" xml:space="preserve">
          <source>Inside a class definition, the names are part of the class namespace.  &lt;code&gt;code2&lt;/code&gt;, for instance, must be qualified by the class name.  Generally &lt;code&gt;Foo.code2&lt;/code&gt;.  However, &lt;code&gt;self.code2&lt;/code&gt; will also work because Python objects look at the containing class as a fall-back.</source>
          <target state="translated">クラス定義内では、名前はクラス名前空間の一部です。 たとえば、 &lt;code&gt;code2&lt;/code&gt; はクラス名で修飾する必要があります。 通常は &lt;code&gt;Foo.code2&lt;/code&gt; です。 ただし、Pythonオブジェクトは包含クラスをフォールバックと &lt;code&gt;self.code2&lt;/code&gt; ため、 self.code2も機能します。</target>
        </trans-unit>
        <trans-unit id="09981edc13a0ed704530d39e42b44aa50109ee99" translate="yes" xml:space="preserve">
          <source>Inside the for loop</source>
          <target state="translated">フォーループの内側</target>
        </trans-unit>
        <trans-unit id="e0e03b34b38a81e2a7f53f8a81459fc2d617f237" translate="yes" xml:space="preserve">
          <source>L: Local in &lt;code&gt;def spam&lt;/code&gt; (in &lt;code&gt;code3&lt;/code&gt;, &lt;code&gt;code4&lt;/code&gt;, and &lt;code&gt;code5&lt;/code&gt;)</source>
          <target state="translated">L： &lt;code&gt;def spam&lt;/code&gt; ローカル（ &lt;code&gt;code3&lt;/code&gt; 、 &lt;code&gt;code5&lt;/code&gt; 、およびcode5 ）</target>
        </trans-unit>
        <trans-unit id="e92d705ad99ad05765b1551d9ea147eb1bdeda13" translate="yes" xml:space="preserve">
          <source>Local in this case, is the body of the method function &lt;code&gt;Foo.spam&lt;/code&gt;.</source>
          <target state="translated">この場合のローカルは、メソッド関数 &lt;code&gt;Foo.spam&lt;/code&gt; の本体です。</target>
        </trans-unit>
        <trans-unit id="9239d3c1c8dfe483cc92d0d056245b45330b191b" translate="yes" xml:space="preserve">
          <source>More scopes only appear when you introduce a nested function (or lambda) into the picture.
These will behave pretty much as you'd expect however.  The nested function can access everything in the local scope, as well as anything in the enclosing function's scope. eg.</source>
          <target state="translated">より多くのスコープが表示されるのは、入れ子になった関数(またはラムダ)を画像に導入したときだけです。しかし、これらのスコープの振る舞いは期待通りのものです。入れ子になった関数は、ローカルスコープ内のすべてのものだけでなく、 囲む関数のスコープ内のすべてのものにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="27da1baa1c8ced7550e55368c36e9a711d3e6fa3" translate="yes" xml:space="preserve">
          <source>Names listed in a nonlocal statement, unlike those listed in a global statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously).</source>
          <target state="translated">非ローカル文に記載されている名前は、グローバル文に記載されている名前とは異なり、囲いのスコープ内の既存のバインディングを参照しなければなりません(新しいバインディングを作成すべきスコープを明確に決定することはできません)。</target>
        </trans-unit>
        <trans-unit id="28b769433b63849ac3d6dd68d58b2953ccbd4282" translate="yes" xml:space="preserve">
          <source>Namespaces are created by packages, modules, classes, object construction and functions.  There aren't any other flavors of namespaces.</source>
          <target state="translated">名前空間は、パッケージ、モジュール、クラス、オブジェクト構築、関数によって作成されます。名前空間には他の種類はありません。</target>
        </trans-unit>
        <trans-unit id="beb5b3eceb0aafb4ddd706656bbfc7ee6baaddbe" translate="yes" xml:space="preserve">
          <source>One of the greater surprises to many newcomers to Python is that a &lt;code&gt;for&lt;/code&gt; loop does not create a variable scope. In Python 2 the list comprehensions do not create a scope either (while generators and dict comprehensions do!) Instead they leak the value in the function or the global scope:</source>
          <target state="translated">Pythonを初めて使用する多くの人にとって大きな驚きの1つは、 &lt;code&gt;for&lt;/code&gt; ループが変数スコープを作成しないことです。 Python 2では、リスト内包表記もスコープを作成しません（一方、ジェネレーターとdict内包表記は作成します！）代わりに、関数またはグローバルスコープの値をリークします。</target>
        </trans-unit>
        <trans-unit id="12ce7bda1dda1b2c962ca66689c2785500bf04ad" translate="yes" xml:space="preserve">
          <source>Python is statically scoped, so if you pass &amp;lsquo;spam&amp;rsquo; to another function spam will still have access to globals in the module it came from (defined in code1), and any other containing scopes (see below). code2 members would again be accessed through self.</source>
          <target state="translated">Pythonは静的にスコープが設定されているため、「spam」を別の関数に渡しても、spamはそれが由来するモジュール（code1で定義）のグローバル、および他の包含スコープ（以下を参照）に引き続きアクセスできます。 code2メンバーは再びselfを介してアクセスされます。</target>
        </trans-unit>
        <trans-unit id="ca50994c79187618aaa08a98a101ea8024bec937" translate="yes" xml:space="preserve">
          <source>Python resolves your variables with -- generally -- three namespaces available.</source>
          <target state="translated">Python は、通常 --通常 --3 つの名前空間を使用して変数を解決します。</target>
        </trans-unit>
        <trans-unit id="db64c8c2222f51f190901bd1ac7f77cfbca7a5eb" translate="yes" xml:space="preserve">
          <source>Reading the builtin module can also be useful; suppose that you want the python 3 style print function in some parts of file, but other parts of file still use the &lt;code&gt;print&lt;/code&gt; statement. In Python 2.6-2.7 you can get hold of the Python 3 &lt;code&gt;print&lt;/code&gt; function with:</source>
          <target state="translated">組み込みモジュールを読むことも役立ちます。 ファイルの一部でpython 3スタイルの印刷関数が必要だが、ファイルの他の部分では引き続き &lt;code&gt;print&lt;/code&gt; ステートメントを使用するとします 。 Python 2.6-2.7では、次のようにしてPython 3の &lt;code&gt;print&lt;/code&gt; 関数を取得できます。</target>
        </trans-unit>
        <trans-unit id="5b5d18222e29afa718228e26345659e72bb55bf1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Python Scope Rules&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Python Scope&lt;/a&gt;, &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;Variable Scope&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Pythonスコープルール&lt;/a&gt; 、 &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Pythonスコープ&lt;/a&gt; 、 &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;変数スコープを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c8c6e2463ee152af10c825b92902e29b53188a0e" translate="yes" xml:space="preserve">
          <source>Short description of the scoping rules</source>
          <target state="translated">スコーピングルールの簡単な説明</target>
        </trans-unit>
        <trans-unit id="4137ae49ea23b49b8aded44e40cc20f03153e5ea" translate="yes" xml:space="preserve">
          <source>So, in the case of</source>
          <target state="translated">ということで、今回のケースでは</target>
        </trans-unit>
        <trans-unit id="c1f5b7fd34b0297627287f84737d24abc3aef183" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt;&lt;code&gt;nonlocal&lt;/code&gt; documentation&lt;/a&gt; says that</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt; &lt;code&gt;nonlocal&lt;/code&gt; ドキュメントに&lt;/a&gt;は、</target>
        </trans-unit>
        <trans-unit id="f37cfe501f6b493322c7adbc4648321534c77ec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop does not have its own namespace. In LEGB order, the scopes would be</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループには独自の名前空間はありません。 LEGBの順序では、スコープは</target>
        </trans-unit>
        <trans-unit id="3f202f06df9b6796d66908f7d06c0fb4a5dba2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from __future__ import print_function&lt;/code&gt; actually does not import the &lt;code&gt;print&lt;/code&gt; function anywhere in Python 2 - instead it just disables the parsing rules for &lt;code&gt;print&lt;/code&gt; statement in the current module, handling &lt;code&gt;print&lt;/code&gt; like any other variable identifier, and thus allowing the &lt;code&gt;print&lt;/code&gt; the function be looked up in the builtins.</source>
          <target state="translated">&lt;code&gt;from __future__ import print_function&lt;/code&gt; 実際には &lt;code&gt;print&lt;/code&gt; 関数をPython 2のどこにもインポートしません。代わりに、現在のモジュールの &lt;code&gt;print&lt;/code&gt; ステートメントの解析ルールを無効にし、他の変数識別子と同様に &lt;code&gt;print&lt;/code&gt; 処理して、 &lt;code&gt;print&lt;/code&gt; 関数から検索できるようにします。ビルトイン。</target>
        </trans-unit>
        <trans-unit id="b852b61c52cf6abf12d94fe216923a1456609117" translate="yes" xml:space="preserve">
          <source>The builtins namespace.  A bit of a special case - this contains the various Python builtin functions and types such as len() and str(). Generally this shouldn't be modified by any user code, so expect it to contain the standard functions and nothing else.</source>
          <target state="translated">ビルドインの名前空間です。少し特殊なケースですが、これは様々な Python ビルドイン関数と len()や str()のような型を含んでいます。一般的に、これはユーザコードによって変更されるべきではないので、標準の関数を含み、それ以外は何も含まれていないことを期待してください。</target>
        </trans-unit>
        <trans-unit id="b666180107f3bb2a5459c2803fd6ec63d97c8a5f" translate="yes" xml:space="preserve">
          <source>The comprehensions can be used as a cunning (or awful if you will) way to make modifiable variables within lambda expressions in Python 2 - a lambda expression does create a variable scope, like the &lt;code&gt;def&lt;/code&gt; statement would, but within lambda no statements are allowed. Assignment being a statement in Python means that no variable assignments in lambda are allowed, but a list comprehension is an expression...</source>
          <target state="translated">内包表記は、Python 2のラムダ式内で変更可能な変数を作成するための狡猾な（または必要であればひどい）方法として使用できます。ラムダ式は &lt;code&gt;def&lt;/code&gt; ステートメントと同様に変数スコープを作成しますが、ラムダ内ではステートメントを使用できません。 Pythonでのステートメントである代入は、ラムダでの変数代入は許可されないことを意味しますが、リスト内包表記は式です...</target>
        </trans-unit>
        <trans-unit id="d83d3f2e8e91a527bd523f95cb8e0b56a2f91f94" translate="yes" xml:space="preserve">
          <source>The global really means the module scope; the main python module is the &lt;code&gt;__main__&lt;/code&gt;; all imported modules are accessible through the &lt;code&gt;sys.modules&lt;/code&gt; variable; to get access to &lt;code&gt;__main__&lt;/code&gt; one can use &lt;code&gt;sys.modules['__main__']&lt;/code&gt;, or &lt;code&gt;import __main__&lt;/code&gt;; it is perfectly acceptable to access and assign attributes there; they will show up as variables in the global scope of the main module.</source>
          <target state="translated">グローバルは本当にモジュールのスコープを意味します。 メインのPythonモジュールは &lt;code&gt;__main__&lt;/code&gt; です 。 インポートされたすべてのモジュールには、 &lt;code&gt;sys.modules&lt;/code&gt; 変数を介してアクセスできます。 &lt;code&gt;__main__&lt;/code&gt; にアクセスするには、 &lt;code&gt;sys.modules['__main__']&lt;/code&gt; 使用するか、 __main__を &lt;code&gt;import __main__&lt;/code&gt; ます。 そこで属性にアクセスして割り当てることは完全に許容されます。 それらは、メインモジュールのグローバルスコープの変数として表示されます。</target>
        </trans-unit>
        <trans-unit id="ea88c84d8c2d8c0a30fbe73d16592805fd95c700" translate="yes" xml:space="preserve">
          <source>The global scope - containing everything defined in code1, as well as Foo (and whatever changes after it)</source>
          <target state="translated">グローバルスコープ-code1 で定義されているすべてのものと Foo (およびそれ以降の変更点)を含む。</target>
        </trans-unit>
        <trans-unit id="5e3aea07bda301107941314511a14e18439bd4db" translate="yes" xml:space="preserve">
          <source>The rule is to search the nested local spaces created by method functions (and nested function definitions), then search global.  That's it.</source>
          <target state="translated">ルールとしては、メソッド関数(および入れ子になった関数の定義)で作成された入れ子になったローカル空間を検索してから、グローバルを検索する。これだけです。</target>
        </trans-unit>
        <trans-unit id="b2cef6f50c86efea01393fcf6254ce2bd0a1dedd" translate="yes" xml:space="preserve">
          <source>The scope can declare that it explicitly wants to modify the global (module scope) variable, with the global keyword:</source>
          <target state="translated">スコープは、グローバル (モジュールスコープ)変数を変更したいと明示的に宣言することができます。</target>
        </trans-unit>
        <trans-unit id="94b81dae7f5d26ac7081fc6ac0cbbd90734b62ef" translate="yes" xml:space="preserve">
          <source>The scoping rules for Python 2.x have been outlined already in other answers. The only thing I would add is that in Python 3.0, there is also the concept of a non-local scope (indicated by the 'nonlocal' keyword). This allows you to access outer scopes directly, and opens up the ability to do some neat tricks, including lexical closures (without ugly hacks involving mutable objects).</source>
          <target state="translated">Python 2.x のスコーピングルールは、他の回答ですでに概説されています。私が唯一付け加えたいのは、Python 3.0では非ローカルスコープの概念があるということです('nonlocal'キーワードで示されています)。これにより、外部スコープに直接アクセスすることができるようになり、語彙的なクロージャを含む、いくつかの巧妙なトリックを行う能力が開放されました(突然変異可能なオブジェクトを含む醜いハックなしで)。</target>
        </trans-unit>
        <trans-unit id="01feb0417fe8dd53fe7a7458888a7cf55f38e6c5" translate="yes" xml:space="preserve">
          <source>There are no other scopes.  The &lt;code&gt;for&lt;/code&gt; statement (and other compound statements like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt;) don't create new nested scopes.  Only definitions (packages, modules, functions, classes and object instances.)</source>
          <target state="translated">他のスコープはありません。 &lt;code&gt;for&lt;/code&gt; ステートメント（および &lt;code&gt;if&lt;/code&gt; や &lt;code&gt;try&lt;/code&gt; などの他の複合ステートメント）は、ネストされた新しいスコープを作成しません。 定義のみ（パッケージ、モジュール、関数、クラス、オブジェクトインスタンス）</target>
        </trans-unit>
        <trans-unit id="2c9bc52a6aab7f588fc16c4ea6fa447de217b0d0" translate="yes" xml:space="preserve">
          <source>There are two functions: &lt;code&gt;globals&lt;/code&gt; and &lt;code&gt;locals&lt;/code&gt; which show you the contents two of these namespaces.</source>
          <target state="translated">これらの名前空間の2つのコンテンツを表示する &lt;code&gt;globals&lt;/code&gt; と &lt;code&gt;locals&lt;/code&gt; 2つの関数があります。</target>
        </trans-unit>
        <trans-unit id="66f53662b40fee705c6cf869f8862a3f0af7508c" translate="yes" xml:space="preserve">
          <source>There must be a simple reference or algorithm somewhere.  It's a confusing world for intermediate Python programmers.</source>
          <target state="translated">どこかに簡単なリファレンスやアルゴリズムがあるはずです。Pythonの中級者向けのプログラマーにとっては混乱の世界です。</target>
        </trans-unit>
        <trans-unit id="dc197e05c0a632bbe533e1fc9cc6179dbe36858f" translate="yes" xml:space="preserve">
          <source>There was no thorough answer concerning Python3 time, so I made an answer here. Most of what is described here is detailed in the &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;4.2.2 Resolution of names&lt;/a&gt; of the Python 3 documentation.</source>
          <target state="translated">Python3の時間に関して完全な答えはなかったので、ここで答えを出しました。 ここで説明されていることのほとんどは、 &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;4.2.2&lt;/a&gt; Python 3ドキュメントの名前の解決で詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="a99a7f033c4ec910190127fe5239538d99412265" translate="yes" xml:space="preserve">
          <source>This also is possible even if it was shadowed in enclosing scope:</source>
          <target state="translated">これも、囲い込みスコープでシャドーイングされていた場合でも可能です。</target>
        </trans-unit>
        <trans-unit id="7d7b9be324dd796904b34f5106809953d41f6197" translate="yes" xml:space="preserve">
          <source>This behaviour has been fixed in Python 3 - no comprehension expressions or generators leak variables.</source>
          <target state="translated">この動作はPython 3で修正されました-内包表現やジェネレータが変数をリークしないようになりました。</target>
        </trans-unit>
        <trans-unit id="87022636f054df4ffc1ead1749bf1e9c7e728e13" translate="yes" xml:space="preserve">
          <source>Thus unlike in function body, you can reassign the variable to the same name in class body, to get a class variable with the same name; further lookups on this name resolve
to the class variable instead.</source>
          <target state="translated">このように、関数本体とは異なり、クラス本体では同じ名前のクラス変数を取得するために変数を同じ名前に再割り当てすることができます。</target>
        </trans-unit>
        <trans-unit id="c10493d5c8fd991112f0f5a007908a58dcf71274" translate="yes" xml:space="preserve">
          <source>To demonstrate the peculiarities of the class body</source>
          <target state="translated">クラス体の特殊性を発揮するために</target>
        </trans-unit>
        <trans-unit id="1ec4a888c88d98357bd2355b16e9d2ee0d98401c" translate="yes" xml:space="preserve">
          <source>Variables in scopes other than the local function's variables can be accessed, but can't be rebound to new parameters without further syntax.  Instead, assignment will create a new &lt;strong&gt;local&lt;/strong&gt; variable instead of affecting the variable in the parent scope.  For example:</source>
          <target state="translated">ローカル関数の変数以外のスコープ内の変数にはアクセスできますが、構文を追加しないと新しいパラメーターに再バインドできません。 代わりに、割り当ては、親スコープの変数に影響を与える代わりに、新しい&lt;strong&gt;ローカル&lt;/strong&gt;変数を作成します。 例えば：</target>
        </trans-unit>
        <trans-unit id="ee59b3c6c46ff5b1167d076e20e42bc9f718a1a0" translate="yes" xml:space="preserve">
          <source>What &lt;strong&gt;exactly&lt;/strong&gt; are the Python scoping rules?</source>
          <target state="translated">Pythonスコーピングルールとは&lt;strong&gt;正確に&lt;/strong&gt;は何ですか？</target>
        </trans-unit>
        <trans-unit id="e5d36aed6ed1fa3b08d655991945340186892707" translate="yes" xml:space="preserve">
          <source>Where is &lt;code&gt;x&lt;/code&gt; found?  Some possible choices include the list below:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; はどこにありますか？ 可能な選択肢には、以下のリストが含まれます。</target>
        </trans-unit>
        <trans-unit id="9ceaf19971bdc05e03243ab1bad8110fc5d0ed96" translate="yes" xml:space="preserve">
          <source>Where is x found?</source>
          <target state="translated">Xはどこで見つかったのか?</target>
        </trans-unit>
        <trans-unit id="3aeb7e91ed96df6d7f81bbb0e1551a8531c67024" translate="yes" xml:space="preserve">
          <source>any variable that is assigned a value is local to the block in which
  the assignment appears.</source>
          <target state="translated">値が代入された変数は、代入されたブロックにローカルになります。</target>
        </trans-unit>
        <trans-unit id="63066c351b344d3122b8c8f4b46ea52b390be1db" translate="yes" xml:space="preserve">
          <source>code2 (class members) aren't visible to code inside methods of the same class&amp;thinsp;&amp;mdash;&amp;thinsp;you would usually access them using self. code4/code5 (loops) live in the same scope as code3, so if you wrote to x in there you would be changing the x instance defined in code3, not making a new x.</source>
          <target state="translated">code2（クラスメンバー）は、同じクラスのメソッド内のコードからは見えません。通常は、selfを使用してアクセスします。 code4 / code5（ループ）はcode3と同じスコープに存在するため、そこでxに書き込んだ場合、新しいxを作成するのではなく、code3で定義されたxインスタンスを変更します。</target>
        </trans-unit>
        <trans-unit id="cc6ec69a6efab094133defe38aae1e3d60c488d6" translate="yes" xml:space="preserve">
          <source>fun3 sees the instance x from the nearest containing scope, which is the function scope associated with fun2. But the other x instances, defined in fun1 and globally, are not affected.</source>
          <target state="translated">fun3 は、fun2 に関連付けられた関数スコープである、最も近い包含スコープからインスタンス x を見ます。しかし、fun1で定義された他のxインスタンスとグローバルに定義されたインスタンスは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="58ea49680b324ab3ca71332dbc3414bb1ebdb589" translate="yes" xml:space="preserve">
          <source>i.e. &lt;code&gt;nonlocal&lt;/code&gt; always refers to the innermost outer non-global scope where the name has been bound (i.e. assigned to, including used as the &lt;code&gt;for&lt;/code&gt; target variable, in the &lt;code&gt;with&lt;/code&gt; clause, or as a function parameter).</source>
          <target state="translated">つまり、 &lt;code&gt;nonlocal&lt;/code&gt; 常に、名前がバインドされている最も内側の外側の非グローバルスコープを指します（つまり、 &lt;code&gt;for&lt;/code&gt; 変数で、 &lt;code&gt;with&lt;/code&gt; 句で、または関数パラメーターとして使用されるなど、割り当てられています）。</target>
        </trans-unit>
        <trans-unit id="da2bcfabde892b5bb52d9d550d0458eca4faf08a" translate="yes" xml:space="preserve">
          <source>lambda is no different to def. If you have a lambda used inside a function, it's the same as defining a nested function. In Python 2.2 onwards, nested scopes are available. In this case you can bind x at any level of function nesting and Python will pick up the innermost instance:</source>
          <target state="translated">lambdaはdefと何ら変わりません。 関数の中でlambdaを使用している場合は、入れ子になった関数を定義しているのと同じです。Python 2.2以降では、入れ子になったスコープが利用できるようになりました。この場合、関数のネストのどのレベルでも x をバインドすることができ、Python は一番内側のインスタンスを拾ってきます。</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="d501ea9d1210349ed22ada10ec53a89a01499008" translate="yes" xml:space="preserve">
          <source>spam's scope - containing everything defined in code3 and code5 (as well as code4, your loop variable)</source>
          <target state="translated">spam のスコープ-code3 と code5 で定義されているすべてのものを含む (ループ変数の code4 も含む)</target>
        </trans-unit>
        <trans-unit id="b3b90f9cae4e8e26b4024f88a8f592ef96cb8712" translate="yes" xml:space="preserve">
          <source>x is not found as you haven't defined it. :-) It could be found in code1 (global) or code3 (local) if you put it there.</source>
          <target state="translated">x は定義していないので見つかりません。)code1 (グローバル)や code3 (ローカル)に記述すれば見つかるかもしれません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
