<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/291978">
    <body>
      <group id="291978">
        <trans-unit id="2e5ea5b373efb0a978388bcda9efa3c4e5c03c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; will never be found in &lt;code&gt;code2&lt;/code&gt; (even in cases where you might expect it would, see &lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;Antti's answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; nunca se encontrar&amp;aacute; en el &lt;code&gt;code2&lt;/code&gt; (incluso en los casos en que podr&amp;iacute;a esperarse, consulte &lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;la respuesta de Antti&lt;/a&gt; o &lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;aqu&amp;iacute;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="844b4071ade54e31a272636444a86d27dbf60eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B&lt;/strong&gt;uilt-in (Python) &amp;mdash; Names preassigned in the built-in names module: &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;SyntaxError&lt;/code&gt;, etc</source>
          <target state="translated">&lt;strong&gt;B&lt;/strong&gt; uilt-in (Python): nombres preasignados en el m&amp;oacute;dulo de nombres incorporado: &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;SyntaxError&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="97299d3c668df1ab4082a55faa649fd2528112b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;nclosing-function &amp;mdash; Names assigned in the local scope of any and all statically enclosing functions (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), from inner to outer</source>
          <target state="translated">Funci&amp;oacute;n de cierre: nombres asignados en el &amp;aacute;mbito local de todas y cada una de las funciones de cierre est&amp;aacute;tico ( &lt;code&gt;def&lt;/code&gt; o &lt;code&gt;lambda&lt;/code&gt; ), de interna a externa</target>
        </trans-unit>
        <trans-unit id="cfb38a37b33062a0dac44099257bd4a65386ac18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;lobal (module) &amp;mdash; Names assigned at the top-level of a module file, or by executing a &lt;code&gt;global&lt;/code&gt; statement in a &lt;code&gt;def&lt;/code&gt; within the file</source>
          <target state="translated">&lt;strong&gt;G&lt;/strong&gt; lobal (m&amp;oacute;dulo): nombres asignados en el nivel superior de un archivo de m&amp;oacute;dulo o al ejecutar una declaraci&amp;oacute;n &lt;code&gt;global&lt;/code&gt; en una &lt;code&gt;def&lt;/code&gt; inici&amp;oacute;n dentro del archivo</target>
        </trans-unit>
        <trans-unit id="778d2680a013b2b927bbd42cf4dbd8f8e603daa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;L&lt;/strong&gt;ocal &amp;mdash; Names assigned in any way within a function (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), and not declared global in that function</source>
          <target state="translated">&lt;strong&gt;L&lt;/strong&gt; ocal: nombres asignados de cualquier manera dentro de una funci&amp;oacute;n ( &lt;code&gt;def&lt;/code&gt; o &lt;code&gt;lambda&lt;/code&gt; ), y no declarados globales en esa funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="5277f4fac12d44eb629e5c22b7e1d8094c037eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LEGB Rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Regla LEGB&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8fbc1e546684b1d340d4bb068e765dfcdfb7254c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restrictions:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Restrictions:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e9af317e5a414fef2826cb666d4e978c26801dd" translate="yes" xml:space="preserve">
          <source>A slightly more complete example of scope:</source>
          <target state="translated">Un ejemplo un poco m√°s completo de alcance:</target>
        </trans-unit>
        <trans-unit id="3eacc2675a7bf748ffe69c0804238499bf0a642c" translate="yes" xml:space="preserve">
          <source>Actually, a concise rule for Python Scope resolution, from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;Learning Python, 3rd. Ed.&lt;/a&gt;. (These rules are specific to variable names, not attributes. If you reference it without a period, these rules apply.)</source>
          <target state="translated">En realidad, una regla concisa para la resoluci&amp;oacute;n de Python Scope, de &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;Learning Python, 3rd.&lt;/a&gt; Ed. . (Estas reglas son espec&amp;iacute;ficas de nombres de variables, no de atributos. Si hace referencia a ellas sin un punto, se aplican estas reglas).</target>
        </trans-unit>
        <trans-unit id="b9b84618b4dc87a1c871237cbcae8ef234da18b5" translate="yes" xml:space="preserve">
          <source>Also there is the context during execution, when the function &lt;code&gt;spam&lt;/code&gt; is passed somewhere else. And maybe &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;lambda functions&lt;/a&gt; pass a bit differently?</source>
          <target state="translated">Tambi&amp;eacute;n existe el contexto durante la ejecuci&amp;oacute;n, cuando la funci&amp;oacute;n &lt;code&gt;spam&lt;/code&gt; se pasa a otro lugar. &amp;iquest;Y tal vez las &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;funciones lambda&lt;/a&gt; pasan un poco diferente?</target>
        </trans-unit>
        <trans-unit id="2b234758bd81a7c9bf0560b3b0aec62418bf437f" translate="yes" xml:space="preserve">
          <source>An object (an instance of a class) has instance variables.  These names are in the object's namespace.  They must be qualified by the object.  (&lt;code&gt;variable.instance&lt;/code&gt;.)</source>
          <target state="translated">Un objeto (una instancia de una clase) tiene variables de instancia. Estos nombres est&amp;aacute;n en el espacio de nombres del objeto. Deben ser calificados por el objeto. ( &lt;code&gt;variable.instance&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="edd9da0852ea07205aefc7b6ee60189bd45f1905" translate="yes" xml:space="preserve">
          <source>Any variable that is not deemed to be local to the current scope, or any enclosing scope, is a global variable. A global name is looked up in the module global dictionary; if not found, the global is then looked up from the builtins module; the name of the module was changed from python 2 to python 3; in python 2 it was &lt;code&gt;__builtin__&lt;/code&gt; and in python 3 it is now called &lt;code&gt;builtins&lt;/code&gt;. If you assign to an attribute of builtins module, it will be visible thereafter to any module as a readable global variable, unless that module shadows them with its own global variable with the same name.</source>
          <target state="translated">Cualquier variable que no se considere local para el alcance actual, o cualquier alcance que la incluya, es una variable global. Se busca un nombre global en el diccionario global del m&amp;oacute;dulo; si no se encuentra, el global se busca desde el m&amp;oacute;dulo integrado; el nombre del m&amp;oacute;dulo fue cambiado de python 2 a python 3; en python 2 era &lt;code&gt;__builtin__&lt;/code&gt; y en python 3 ahora se llama &lt;code&gt;builtins&lt;/code&gt; . Si asigna un atributo del m&amp;oacute;dulo integrado, ser&amp;aacute; visible a partir de entonces para cualquier m&amp;oacute;dulo como una variable global legible, a menos que ese m&amp;oacute;dulo los sombree con su propia variable global con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="5e4660e77d407e9b103ce4b6048d3ef22738c691" translate="yes" xml:space="preserve">
          <source>As provided in other answers, there are 4 basic scopes, the LEGB, for Local, Enclosing, Global and Builtin. In addition to those, there is a special scope, the &lt;strong&gt;class body&lt;/strong&gt;, which does not comprise an enclosing scope for methods defined within the class; any assignments within the class body make the variable from there on be bound in the class body.</source>
          <target state="translated">Como se proporciona en otras respuestas, hay 4 &amp;aacute;mbitos b&amp;aacute;sicos, el LEGB, para Local, Enclosing, Global y Builtin. Adem&amp;aacute;s de esos, hay un alcance especial, el &lt;strong&gt;cuerpo de&lt;/strong&gt; la &lt;strong&gt;clase&lt;/strong&gt; , que no comprende un alcance cerrado para los m&amp;eacute;todos definidos dentro de la clase; cualquier tarea dentro del cuerpo de la clase hace que la variable a partir de ah&amp;iacute; est&amp;eacute; vinculada en el cuerpo de la clase.</target>
        </trans-unit>
        <trans-unit id="77587594047610e85f49724453d7e1697738b9e3" translate="yes" xml:space="preserve">
          <source>At any time during execution, there
  are at least three nested scopes whose
  namespaces are directly accessible:
  the innermost scope, which is searched
  first, contains the local names; the
  namespaces of any enclosing functions,
  which are searched starting with the
  nearest enclosing scope; the middle
  scope, searched next, contains the
  current module's global names; and the
  outermost scope (searched last) is the
  namespace containing built-in names.</source>
          <target state="translated">En cualquier momento de la ejecuci√≥n,hay por lo menos tres √°mbitos anidados cuyos espacios de nombres son directamente accesibles:el √°mbito m√°s interno,que se busca primero,contiene los nombres locales;los espacios de nombres de cualquier funci√≥n de encierro,que se buscan empezando por el √°mbito de encierro m√°s cercano;el √°mbito intermedio,que se busca despu√©s,contiene los nombres globales del m√≥dulo actual;y el √°mbito m√°s externo (que se busca al final)es el espacio de nombres que contiene los nombres incorporados.</target>
        </trans-unit>
        <trans-unit id="949db5aedd1359c2910fdcddc532ee3920954144" translate="yes" xml:space="preserve">
          <source>B: Any builtin &lt;code&gt;x&lt;/code&gt; in Python.</source>
          <target state="translated">B: Cualquier &lt;code&gt;x&lt;/code&gt; incorporado en Python.</target>
        </trans-unit>
        <trans-unit id="94f58ad3d39e723cd41ed035c3fc63eb570fe299" translate="yes" xml:space="preserve">
          <source>Before nested_scopes&amp;thinsp;&amp;mdash;&amp;thinsp;in Python pre-2.1, and in 2.1 unless you specifically ask for the feature using a from-future-import&amp;thinsp;&amp;mdash;&amp;thinsp;fun1 and fun2's scopes are not visible to fun3, so S.Lott's answer holds and you would get the global x:</source>
          <target state="translated">Antes de nested_scopes, en Python pre-2.1 y en 2.1, a menos que solicite espec&amp;iacute;ficamente la funci&amp;oacute;n mediante una importaci&amp;oacute;n desde el futuro, los alcances de fun1 y fun2 no son visibles para fun3, por lo que la respuesta de S.Lott se mantiene y obtendr&amp;aacute; la x global :</target>
        </trans-unit>
        <trans-unit id="ccabba569adb4497369de2ec7d4f33e75f0e6878" translate="yes" xml:space="preserve">
          <source>Currently there is no way to do the same for variables in enclosing &lt;em&gt;function&lt;/em&gt; scopes, but Python 3 introduces a new keyword, &quot;&lt;code&gt;nonlocal&lt;/code&gt;&quot; which will act in a similar way to global, but for nested function scopes.</source>
          <target state="translated">Actualmente no hay forma de hacer lo mismo para las variables al incluir &amp;aacute;mbitos de &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; , pero Python 3 introduce una nueva palabra clave, &quot; &lt;code&gt;nonlocal&lt;/code&gt; &quot;, que actuar&amp;aacute; de manera similar a global, pero para &amp;aacute;mbitos de funci&amp;oacute;n anidados.</target>
        </trans-unit>
        <trans-unit id="685a7a88c4d863000bc56afa13ac95aae11160f0" translate="yes" xml:space="preserve">
          <source>E: Any enclosing functions (if the whole example were in another &lt;code&gt;def&lt;/code&gt;)</source>
          <target state="translated">E: cualquier funci&amp;oacute;n de cierre (si todo el ejemplo estuviera en otra &lt;code&gt;def&lt;/code&gt; inici&amp;oacute;n )</target>
        </trans-unit>
        <trans-unit id="3091bb32545b1f507703c4fcd6455ca21eb171a8" translate="yes" xml:space="preserve">
          <source>EDIT: Here's the &lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt; with more information on this.</source>
          <target state="translated">EDITAR: Aqu&amp;iacute; est&amp;aacute; el &lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt; con m&amp;aacute;s informaci&amp;oacute;n sobre esto.</target>
        </trans-unit>
        <trans-unit id="5067e65f592d1333460adda9fda56628aeffb64e" translate="yes" xml:space="preserve">
          <source>Especially, &lt;strong&gt;no&lt;/strong&gt; block statement, besides &lt;code&gt;def&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;, create a variable scope. In Python 2 a list comprehension does not create a variable scope, however in Python 3 the loop variable within list comprehensions is created in a new scope.</source>
          <target state="translated">Especialmente, &lt;strong&gt;ninguna&lt;/strong&gt; declaraci&amp;oacute;n de bloque, adem&amp;aacute;s de &lt;code&gt;def&lt;/code&gt; y &lt;code&gt;class&lt;/code&gt; , crea un alcance variable. En Python 2, la comprensi&amp;oacute;n de la lista no crea un alcance variable, sin embargo, en Python 3 la variable de bucle dentro de las comprensiones de la lista se crea en un nuevo alcance.</target>
        </trans-unit>
        <trans-unit id="4360b38ce6fca6533891aa6402e815f6de882ee8" translate="yes" xml:space="preserve">
          <source>Essentially, the only thing in Python that introduces a new scope is a function definition.  Classes are a bit of a special case in that anything defined directly in the body is placed in the class's namespace, but they are not directly accessible from within the methods (or nested classes) they contain.</source>
          <target state="translated">Esencialmente,lo √∫nico en Python que introduce un nuevo alcance es la definici√≥n de la funci√≥n.Las clases son un caso un poco especial en el que cualquier cosa definida directamente en el cuerpo se coloca en el espacio de nombres de la clase,pero no son directamente accesibles desde dentro de los m√©todos (o clases anidadas)que contienen.</target>
        </trans-unit>
        <trans-unit id="3454040cf44b56303faa3532297c412240cf336a" translate="yes" xml:space="preserve">
          <source>From within a class method, you have locals and globals.  You say &lt;code&gt;self.variable&lt;/code&gt; to pick the instance as the namespace.  You'll note that &lt;code&gt;self&lt;/code&gt; is an argument to every class member function, making it part of the local namespace.</source>
          <target state="translated">Desde dentro de un m&amp;eacute;todo de clase, tienes locales y globales. Dices &lt;code&gt;self.variable&lt;/code&gt; para elegir la instancia como el espacio de nombres. Notar&amp;aacute;s que &lt;code&gt;self&lt;/code&gt; es un argumento para cada funci&amp;oacute;n de miembro de la clase, por lo que es parte del espacio de nombres local.</target>
        </trans-unit>
        <trans-unit id="7664a9e609e66bc2d00fa363b667ab4f2f1fefff" translate="yes" xml:space="preserve">
          <source>G: Were there any &lt;code&gt;x&lt;/code&gt; declared globally in the module (in &lt;code&gt;code1&lt;/code&gt;)?</source>
          <target state="translated">G: &amp;iquest;Hubo alguna &lt;code&gt;x&lt;/code&gt; declarada globalmente en el m&amp;oacute;dulo (en &lt;code&gt;code1&lt;/code&gt; )?</target>
        </trans-unit>
        <trans-unit id="1d87f06cf14aca3bd4a191b57670565bfad952c1" translate="yes" xml:space="preserve">
          <source>Global is -- well -- global.</source>
          <target state="translated">Global es...bueno...global.</target>
        </trans-unit>
        <trans-unit id="5e8b57f9b5edca1d505a9498465cdf117eedf409" translate="yes" xml:space="preserve">
          <source>However in python 3, the &lt;code&gt;nonlocal&lt;/code&gt; comes to rescue:</source>
          <target state="translated">Sin embargo, en Python 3, lo &lt;code&gt;nonlocal&lt;/code&gt; viene a rescatar:</target>
        </trans-unit>
        <trans-unit id="489c4eee2e8a8e18d94f2c3c5b9d39e4ba2a71d9" translate="yes" xml:space="preserve">
          <source>If I have some code:</source>
          <target state="translated">Si tengo alg√∫n c√≥digo:</target>
        </trans-unit>
        <trans-unit id="3f0b2cb298d97b428d9e6a5814ab14829603d125" translate="yes" xml:space="preserve">
          <source>If a name is ever assigned to in the current scope (except in the class scope), it will be considered belonging to that scope, otherwise it will be considered to belonging to any enclosing scope that assigns to the variable (it might not be assigned yet, or not at all), or finally the global scope. If the variable is considered local, but it is not set yet, or has been deleted, reading the variable value will result in &lt;code&gt;UnboundLocalError&lt;/code&gt;, which is a subclass of &lt;code&gt;NameError&lt;/code&gt;.</source>
          <target state="translated">Si alguna vez se asigna un nombre en el alcance actual (excepto en el alcance de la clase), se considerar&amp;aacute; que pertenece a ese alcance, de lo contrario se considerar&amp;aacute; que pertenece a cualquier alcance adjunto que se asigne a la variable (puede que no se asigne todav&amp;iacute;a, o no), o finalmente el alcance global. Si la variable se considera local, pero a&amp;uacute;n no se ha establecido o se ha eliminado, leer el valor de la variable dar&amp;aacute; como resultado &lt;code&gt;UnboundLocalError&lt;/code&gt; , que es una subclase de &lt;code&gt;NameError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d536a4e1d312f0bb4a36c7db71be18f86a0595ec" translate="yes" xml:space="preserve">
          <source>If a variable can't be found in the current scope, please refer to the LEGB order.</source>
          <target state="translated">Si no se puede encontrar una variable en el √°mbito actual,por favor,consulte la orden de LEGB.</target>
        </trans-unit>
        <trans-unit id="594e2207a906c678397d7ca8b95cf26be8bec159" translate="yes" xml:space="preserve">
          <source>In Python,</source>
          <target state="translated">En Python,</target>
        </trans-unit>
        <trans-unit id="daa6bf94be3ef37adbff56bb43caa58be32ae290" translate="yes" xml:space="preserve">
          <source>In order to actually modify the bindings of global variables from within a function scope, you need to specify that the variable is global with the global keyword.  Eg:</source>
          <target state="translated">Para modificar realmente las uniones de las variables globales dentro del √°mbito de una funci√≥n,es necesario especificar que la variable es global con la palabra clave global.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="0bc6e3d84d0a49e5ed2803b53b300500f65ae44e" translate="yes" xml:space="preserve">
          <source>In python 2 there is no easy way to modify the value in the enclosing scope; usually this is simulated by having a mutable value, such as a list with length of 1:</source>
          <target state="translated">En la pit√≥n 2 no hay una forma f√°cil de modificar el valor en el √°mbito adjunto;normalmente esto se simula teniendo un valor mutable,como una lista con una longitud de 1:</target>
        </trans-unit>
        <trans-unit id="286079d30426b3322fda99d492f07b15340885cb" translate="yes" xml:space="preserve">
          <source>In the class namespace</source>
          <target state="translated">En el espacio de nombres de la clase</target>
        </trans-unit>
        <trans-unit id="28d8f315b0ed9313fc78b3f5380fd9a3257f9305" translate="yes" xml:space="preserve">
          <source>In the enclosing source file</source>
          <target state="translated">En el archivo fuente adjunto</target>
        </trans-unit>
        <trans-unit id="ca0a0838b052bc29ab825218ced55d4acd83b7c4" translate="yes" xml:space="preserve">
          <source>In the for loop index variable</source>
          <target state="translated">En la variable de √≠ndice de bucle for</target>
        </trans-unit>
        <trans-unit id="61e7200f1f6a388923daba14399fca3fa229c76d" translate="yes" xml:space="preserve">
          <source>In the function definition</source>
          <target state="translated">En la definici√≥n de la funci√≥n</target>
        </trans-unit>
        <trans-unit id="a677829300682f1c31d8905cb2e5282167c47489" translate="yes" xml:space="preserve">
          <source>In this case, the call to a function named &lt;code&gt;x&lt;/code&gt; has to be resolved in the local name space or the global namespace.</source>
          <target state="translated">En este caso, la llamada a una funci&amp;oacute;n llamada &lt;code&gt;x&lt;/code&gt; debe resolverse en el espacio de nombres local o en el espacio de nombres global.</target>
        </trans-unit>
        <trans-unit id="df991876b5a88f673697607e52e60c6b1c9b6fe4" translate="yes" xml:space="preserve">
          <source>In your example there are only 3 scopes where x will be searched in:</source>
          <target state="translated">En su ejemplo s√≥lo hay 3 alcances en los que se buscar√° en x:</target>
        </trans-unit>
        <trans-unit id="b22ee2fbcc9bb471eb4de6b0b6be177886173cac" translate="yes" xml:space="preserve">
          <source>Inside a class definition, the names are part of the class namespace.  &lt;code&gt;code2&lt;/code&gt;, for instance, must be qualified by the class name.  Generally &lt;code&gt;Foo.code2&lt;/code&gt;.  However, &lt;code&gt;self.code2&lt;/code&gt; will also work because Python objects look at the containing class as a fall-back.</source>
          <target state="translated">Dentro de una definici&amp;oacute;n de clase, los nombres son parte del espacio de nombres de clase. &lt;code&gt;code2&lt;/code&gt; , por ejemplo, debe estar calificado por el nombre de la clase. Generalmente &lt;code&gt;Foo.code2&lt;/code&gt; . Sin embargo, &lt;code&gt;self.code2&lt;/code&gt; tambi&amp;eacute;n funcionar&amp;aacute; porque los objetos Python miran la clase que lo contiene como una alternativa .</target>
        </trans-unit>
        <trans-unit id="09981edc13a0ed704530d39e42b44aa50109ee99" translate="yes" xml:space="preserve">
          <source>Inside the for loop</source>
          <target state="translated">Dentro del bucle de for</target>
        </trans-unit>
        <trans-unit id="e0e03b34b38a81e2a7f53f8a81459fc2d617f237" translate="yes" xml:space="preserve">
          <source>L: Local in &lt;code&gt;def spam&lt;/code&gt; (in &lt;code&gt;code3&lt;/code&gt;, &lt;code&gt;code4&lt;/code&gt;, and &lt;code&gt;code5&lt;/code&gt;)</source>
          <target state="translated">L: Local en &lt;code&gt;def spam&lt;/code&gt; (en &lt;code&gt;code3&lt;/code&gt; , &lt;code&gt;code4&lt;/code&gt; y &lt;code&gt;code5&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e92d705ad99ad05765b1551d9ea147eb1bdeda13" translate="yes" xml:space="preserve">
          <source>Local in this case, is the body of the method function &lt;code&gt;Foo.spam&lt;/code&gt;.</source>
          <target state="translated">Local en este caso, es el cuerpo de la funci&amp;oacute;n del m&amp;eacute;todo &lt;code&gt;Foo.spam&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9239d3c1c8dfe483cc92d0d056245b45330b191b" translate="yes" xml:space="preserve">
          <source>More scopes only appear when you introduce a nested function (or lambda) into the picture.
These will behave pretty much as you'd expect however.  The nested function can access everything in the local scope, as well as anything in the enclosing function's scope. eg.</source>
          <target state="translated">S√≥lo aparecen m√°s alcances cuando se introduce una funci√≥n anidada (o lambda)en la imagen.Sin embargo,estos se comportar√°n m√°s o menos como se espera.La funci√≥n anidada puede acceder a todo en el √°mbito local,as√≠ como a cualquier cosa en el √°mbito de la funci√≥n adjunta,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="27da1baa1c8ced7550e55368c36e9a711d3e6fa3" translate="yes" xml:space="preserve">
          <source>Names listed in a nonlocal statement, unlike those listed in a global statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously).</source>
          <target state="translated">Los nombres enumerados en una declaraci√≥n no local,a diferencia de los que figuran en una declaraci√≥n global,deben referirse a las vinculaciones preexistentes en un √°mbito adjunto (el √°mbito en el que debe crearse una nueva vinculaci√≥n no puede determinarse sin ambig√ºedad).</target>
        </trans-unit>
        <trans-unit id="28b769433b63849ac3d6dd68d58b2953ccbd4282" translate="yes" xml:space="preserve">
          <source>Namespaces are created by packages, modules, classes, object construction and functions.  There aren't any other flavors of namespaces.</source>
          <target state="translated">Los espacios de nombres son creados por paquetes,m√≥dulos,clases,construcci√≥n de objetos y funciones.No hay otros sabores de los espacios de nombres.</target>
        </trans-unit>
        <trans-unit id="beb5b3eceb0aafb4ddd706656bbfc7ee6baaddbe" translate="yes" xml:space="preserve">
          <source>One of the greater surprises to many newcomers to Python is that a &lt;code&gt;for&lt;/code&gt; loop does not create a variable scope. In Python 2 the list comprehensions do not create a scope either (while generators and dict comprehensions do!) Instead they leak the value in the function or the global scope:</source>
          <target state="translated">Una de las mayores sorpresas para muchos reci&amp;eacute;n llegados a Python es que un bucle &lt;code&gt;for&lt;/code&gt; no crea un alcance variable. En Python 2, las comprensiones de la lista tampoco crean un alcance (&amp;iexcl;mientras que los generadores y las comprensiones dict s&amp;iacute; lo hacen!) En cambio, pierden el valor en la funci&amp;oacute;n o el alcance global:</target>
        </trans-unit>
        <trans-unit id="12ce7bda1dda1b2c962ca66689c2785500bf04ad" translate="yes" xml:space="preserve">
          <source>Python is statically scoped, so if you pass &amp;lsquo;spam&amp;rsquo; to another function spam will still have access to globals in the module it came from (defined in code1), and any other containing scopes (see below). code2 members would again be accessed through self.</source>
          <target state="translated">Python tiene un alcance est&amp;aacute;tico, por lo que si pasa 'spam' a otra funci&amp;oacute;n, el spam todav&amp;iacute;a tendr&amp;aacute; acceso a los globales en el m&amp;oacute;dulo del que proviene (definido en el c&amp;oacute;digo 1), y a cualquier otro &amp;aacute;mbito que contenga (ver m&amp;aacute;s abajo). Se acceder&amp;iacute;a nuevamente a los miembros de code2 a trav&amp;eacute;s de self.</target>
        </trans-unit>
        <trans-unit id="ca50994c79187618aaa08a98a101ea8024bec937" translate="yes" xml:space="preserve">
          <source>Python resolves your variables with -- generally -- three namespaces available.</source>
          <target state="translated">Python resuelve sus variables con...generalmente...tres espacios de nombres disponibles.</target>
        </trans-unit>
        <trans-unit id="db64c8c2222f51f190901bd1ac7f77cfbca7a5eb" translate="yes" xml:space="preserve">
          <source>Reading the builtin module can also be useful; suppose that you want the python 3 style print function in some parts of file, but other parts of file still use the &lt;code&gt;print&lt;/code&gt; statement. In Python 2.6-2.7 you can get hold of the Python 3 &lt;code&gt;print&lt;/code&gt; function with:</source>
          <target state="translated">Leer el m&amp;oacute;dulo integrado tambi&amp;eacute;n puede ser &amp;uacute;til; suponga que desea la funci&amp;oacute;n de impresi&amp;oacute;n de estilo python 3 en algunas partes del archivo, pero otras partes del archivo a&amp;uacute;n usan la declaraci&amp;oacute;n de &lt;code&gt;print&lt;/code&gt; . En Python 2.6-2.7 puede obtener la funci&amp;oacute;n de &lt;code&gt;print&lt;/code&gt; Python 3 con:</target>
        </trans-unit>
        <trans-unit id="5b5d18222e29afa718228e26345659e72bb55bf1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Python Scope Rules&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Python Scope&lt;/a&gt;, &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;Variable Scope&lt;/a&gt;.</source>
          <target state="translated">Consulte las &lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Reglas de Python Scope&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Python Scope&lt;/a&gt; , &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;Variable Scope&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8c6e2463ee152af10c825b92902e29b53188a0e" translate="yes" xml:space="preserve">
          <source>Short description of the scoping rules</source>
          <target state="translated">Breve descripci√≥n de las reglas de alcance</target>
        </trans-unit>
        <trans-unit id="4137ae49ea23b49b8aded44e40cc20f03153e5ea" translate="yes" xml:space="preserve">
          <source>So, in the case of</source>
          <target state="translated">As√≠ que,en el caso de</target>
        </trans-unit>
        <trans-unit id="c1f5b7fd34b0297627287f84737d24abc3aef183" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt;&lt;code&gt;nonlocal&lt;/code&gt; documentation&lt;/a&gt; says that</source>
          <target state="translated">La &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt;documentaci&amp;oacute;n &lt;code&gt;nonlocal&lt;/code&gt; &lt;/a&gt; dice que</target>
        </trans-unit>
        <trans-unit id="f37cfe501f6b493322c7adbc4648321534c77ec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop does not have its own namespace. In LEGB order, the scopes would be</source>
          <target state="translated">El bucle &lt;code&gt;for&lt;/code&gt; no tiene su propio espacio de nombres. En orden LEGB, los &amp;aacute;mbitos ser&amp;iacute;an</target>
        </trans-unit>
        <trans-unit id="3f202f06df9b6796d66908f7d06c0fb4a5dba2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from __future__ import print_function&lt;/code&gt; actually does not import the &lt;code&gt;print&lt;/code&gt; function anywhere in Python 2 - instead it just disables the parsing rules for &lt;code&gt;print&lt;/code&gt; statement in the current module, handling &lt;code&gt;print&lt;/code&gt; like any other variable identifier, and thus allowing the &lt;code&gt;print&lt;/code&gt; the function be looked up in the builtins.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;from __future__ import print_function&lt;/code&gt; realidad no importa la funci&amp;oacute;n de &lt;code&gt;print&lt;/code&gt; en ning&amp;uacute;n lugar de Python 2; en cambio, solo deshabilita las reglas de an&amp;aacute;lisis para &lt;code&gt;print&lt;/code&gt; declaraci&amp;oacute;n de impresi&amp;oacute;n en el m&amp;oacute;dulo actual, manejando la &lt;code&gt;print&lt;/code&gt; como cualquier otro identificador de variable, y permitiendo as&amp;iacute; que la funci&amp;oacute;n de &lt;code&gt;print&lt;/code&gt; se busque en las builtins.</target>
        </trans-unit>
        <trans-unit id="b852b61c52cf6abf12d94fe216923a1456609117" translate="yes" xml:space="preserve">
          <source>The builtins namespace.  A bit of a special case - this contains the various Python builtin functions and types such as len() and str(). Generally this shouldn't be modified by any user code, so expect it to contain the standard functions and nothing else.</source>
          <target state="translated">El espacio de nombres construido.Un caso un poco especial-contiene las diversas funciones y tipos de builtin de Python como len()y str().Generalmente esto no deber√≠a ser modificado por ning√∫n c√≥digo de usuario,as√≠ que espera que contenga las funciones est√°ndar y nada m√°s.</target>
        </trans-unit>
        <trans-unit id="b666180107f3bb2a5459c2803fd6ec63d97c8a5f" translate="yes" xml:space="preserve">
          <source>The comprehensions can be used as a cunning (or awful if you will) way to make modifiable variables within lambda expressions in Python 2 - a lambda expression does create a variable scope, like the &lt;code&gt;def&lt;/code&gt; statement would, but within lambda no statements are allowed. Assignment being a statement in Python means that no variable assignments in lambda are allowed, but a list comprehension is an expression...</source>
          <target state="translated">Las comprensiones se pueden usar como una manera astuta (o horrible, si se quiere) de hacer variables modificables dentro de las expresiones lambda en Python 2: una expresi&amp;oacute;n lambda crea un alcance variable, como lo har&amp;iacute;a la declaraci&amp;oacute;n &lt;code&gt;def&lt;/code&gt; , pero dentro de lambda no se permiten declaraciones. La asignaci&amp;oacute;n como una declaraci&amp;oacute;n en Python significa que no se permiten asignaciones variables en lambda, pero una comprensi&amp;oacute;n de la lista es una expresi&amp;oacute;n ...</target>
        </trans-unit>
        <trans-unit id="d83d3f2e8e91a527bd523f95cb8e0b56a2f91f94" translate="yes" xml:space="preserve">
          <source>The global really means the module scope; the main python module is the &lt;code&gt;__main__&lt;/code&gt;; all imported modules are accessible through the &lt;code&gt;sys.modules&lt;/code&gt; variable; to get access to &lt;code&gt;__main__&lt;/code&gt; one can use &lt;code&gt;sys.modules['__main__']&lt;/code&gt;, or &lt;code&gt;import __main__&lt;/code&gt;; it is perfectly acceptable to access and assign attributes there; they will show up as variables in the global scope of the main module.</source>
          <target state="translated">Lo global realmente significa el alcance del m&amp;oacute;dulo; El m&amp;oacute;dulo principal de Python es &lt;code&gt;__main__&lt;/code&gt; ; todos los m&amp;oacute;dulos importados son accesibles a trav&amp;eacute;s de la variable &lt;code&gt;sys.modules&lt;/code&gt; ; para obtener acceso a &lt;code&gt;__main__&lt;/code&gt; se puede usar &lt;code&gt;sys.modules['__main__']&lt;/code&gt; o &lt;code&gt;import __main__&lt;/code&gt; ; es perfectamente aceptable acceder y asignar atributos all&amp;iacute;; se mostrar&amp;aacute;n como variables en el alcance global del m&amp;oacute;dulo principal.</target>
        </trans-unit>
        <trans-unit id="ea88c84d8c2d8c0a30fbe73d16592805fd95c700" translate="yes" xml:space="preserve">
          <source>The global scope - containing everything defined in code1, as well as Foo (and whatever changes after it)</source>
          <target state="translated">El alcance global-que contiene todo lo definido en el c√≥digo1,as√≠ como Foo (y cualquier cosa que cambie despu√©s de √©l)</target>
        </trans-unit>
        <trans-unit id="5e3aea07bda301107941314511a14e18439bd4db" translate="yes" xml:space="preserve">
          <source>The rule is to search the nested local spaces created by method functions (and nested function definitions), then search global.  That's it.</source>
          <target state="translated">La regla es buscar los espacios locales anidados creados por las funciones del m√©todo (y las definiciones de las funciones anidadas),y luego buscar globalmente.Eso es todo.</target>
        </trans-unit>
        <trans-unit id="b2cef6f50c86efea01393fcf6254ce2bd0a1dedd" translate="yes" xml:space="preserve">
          <source>The scope can declare that it explicitly wants to modify the global (module scope) variable, with the global keyword:</source>
          <target state="translated">El alcance puede declarar que quiere modificar expl√≠citamente la variable global (alcance del m√≥dulo),con la palabra clave global:</target>
        </trans-unit>
        <trans-unit id="94b81dae7f5d26ac7081fc6ac0cbbd90734b62ef" translate="yes" xml:space="preserve">
          <source>The scoping rules for Python 2.x have been outlined already in other answers. The only thing I would add is that in Python 3.0, there is also the concept of a non-local scope (indicated by the 'nonlocal' keyword). This allows you to access outer scopes directly, and opens up the ability to do some neat tricks, including lexical closures (without ugly hacks involving mutable objects).</source>
          <target state="translated">Las reglas de alcance para Python 2.x ya han sido esbozadas en otras respuestas.Lo √∫nico que a√±adir√≠a es que en Python 3.0 tambi√©n existe el concepto de un √°mbito no local (indicado por la palabra clave &quot;no local&quot;).Esto permite acceder directamente a los alcances exteriores,y abre la posibilidad de hacer algunos trucos prolijos,incluyendo cierres l√©xicos (sin feos hacks que involucren objetos mutables).</target>
        </trans-unit>
        <trans-unit id="01feb0417fe8dd53fe7a7458888a7cf55f38e6c5" translate="yes" xml:space="preserve">
          <source>There are no other scopes.  The &lt;code&gt;for&lt;/code&gt; statement (and other compound statements like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt;) don't create new nested scopes.  Only definitions (packages, modules, functions, classes and object instances.)</source>
          <target state="translated">No hay otros &amp;aacute;mbitos. La declaraci&amp;oacute;n &lt;code&gt;for&lt;/code&gt; (y otras declaraciones compuestas como &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;try&lt;/code&gt; ) no crean nuevos &amp;aacute;mbitos anidados. Solo definiciones (paquetes, m&amp;oacute;dulos, funciones, clases e instancias de objeto).</target>
        </trans-unit>
        <trans-unit id="2c9bc52a6aab7f588fc16c4ea6fa447de217b0d0" translate="yes" xml:space="preserve">
          <source>There are two functions: &lt;code&gt;globals&lt;/code&gt; and &lt;code&gt;locals&lt;/code&gt; which show you the contents two of these namespaces.</source>
          <target state="translated">Hay dos funciones: &lt;code&gt;globals&lt;/code&gt; y &lt;code&gt;locals&lt;/code&gt; que le muestran el contenido de dos de estos espacios de nombres.</target>
        </trans-unit>
        <trans-unit id="66f53662b40fee705c6cf869f8862a3f0af7508c" translate="yes" xml:space="preserve">
          <source>There must be a simple reference or algorithm somewhere.  It's a confusing world for intermediate Python programmers.</source>
          <target state="translated">Debe haber una simple referencia o algoritmo en alg√∫n lugar.Es un mundo confuso para los programadores Python intermedios.</target>
        </trans-unit>
        <trans-unit id="dc197e05c0a632bbe533e1fc9cc6179dbe36858f" translate="yes" xml:space="preserve">
          <source>There was no thorough answer concerning Python3 time, so I made an answer here. Most of what is described here is detailed in the &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;4.2.2 Resolution of names&lt;/a&gt; of the Python 3 documentation.</source>
          <target state="translated">No hubo una respuesta completa sobre el tiempo de Python3, as&amp;iacute; que hice una respuesta aqu&amp;iacute;. La mayor parte de lo que se describe aqu&amp;iacute; se detalla en la &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;Resoluci&amp;oacute;n 4.2.2 de los nombres&lt;/a&gt; de la documentaci&amp;oacute;n de Python 3.</target>
        </trans-unit>
        <trans-unit id="a99a7f033c4ec910190127fe5239538d99412265" translate="yes" xml:space="preserve">
          <source>This also is possible even if it was shadowed in enclosing scope:</source>
          <target state="translated">Esto tambi√©n es posible,incluso si se ha sombreado en un campo de visi√≥n cerrado:</target>
        </trans-unit>
        <trans-unit id="7d7b9be324dd796904b34f5106809953d41f6197" translate="yes" xml:space="preserve">
          <source>This behaviour has been fixed in Python 3 - no comprehension expressions or generators leak variables.</source>
          <target state="translated">Este comportamiento ha sido fijado en Python 3-no hay expresiones de comprensi√≥n o variables de fuga de generadores.</target>
        </trans-unit>
        <trans-unit id="87022636f054df4ffc1ead1749bf1e9c7e728e13" translate="yes" xml:space="preserve">
          <source>Thus unlike in function body, you can reassign the variable to the same name in class body, to get a class variable with the same name; further lookups on this name resolve
to the class variable instead.</source>
          <target state="translated">As√≠,a diferencia de lo que ocurre en el cuerpo de la funci√≥n,en el cuerpo de la clase se puede reasignar la variable al mismo nombre,para obtener una variable de clase con el mismo nombre;las b√∫squedas posteriores sobre este nombre se resuelven en la variable de clase en su lugar.</target>
        </trans-unit>
        <trans-unit id="c10493d5c8fd991112f0f5a007908a58dcf71274" translate="yes" xml:space="preserve">
          <source>To demonstrate the peculiarities of the class body</source>
          <target state="translated">Para demostrar las peculiaridades del cuerpo de la clase</target>
        </trans-unit>
        <trans-unit id="1ec4a888c88d98357bd2355b16e9d2ee0d98401c" translate="yes" xml:space="preserve">
          <source>Variables in scopes other than the local function's variables can be accessed, but can't be rebound to new parameters without further syntax.  Instead, assignment will create a new &lt;strong&gt;local&lt;/strong&gt; variable instead of affecting the variable in the parent scope.  For example:</source>
          <target state="translated">Se puede acceder a las variables en &amp;aacute;mbitos que no sean las variables de la funci&amp;oacute;n local, pero no se pueden rebotar a nuevos par&amp;aacute;metros sin m&amp;aacute;s sintaxis. En cambio, la asignaci&amp;oacute;n crear&amp;aacute; una nueva variable &lt;strong&gt;local en&lt;/strong&gt; lugar de afectar la variable en el &amp;aacute;mbito primario. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ee59b3c6c46ff5b1167d076e20e42bc9f718a1a0" translate="yes" xml:space="preserve">
          <source>What &lt;strong&gt;exactly&lt;/strong&gt; are the Python scoping rules?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;les son &lt;strong&gt;exactamente&lt;/strong&gt; las reglas de alcance de Python?</target>
        </trans-unit>
        <trans-unit id="e5d36aed6ed1fa3b08d655991945340186892707" translate="yes" xml:space="preserve">
          <source>Where is &lt;code&gt;x&lt;/code&gt; found?  Some possible choices include the list below:</source>
          <target state="translated">&amp;iquest;D&amp;oacute;nde se encuentra &lt;code&gt;x&lt;/code&gt; ? Algunas opciones posibles incluyen la siguiente lista:</target>
        </trans-unit>
        <trans-unit id="9ceaf19971bdc05e03243ab1bad8110fc5d0ed96" translate="yes" xml:space="preserve">
          <source>Where is x found?</source>
          <target state="translated">¬øD√≥nde se encuentra x?</target>
        </trans-unit>
        <trans-unit id="3aeb7e91ed96df6d7f81bbb0e1551a8531c67024" translate="yes" xml:space="preserve">
          <source>any variable that is assigned a value is local to the block in which
  the assignment appears.</source>
          <target state="translated">cualquier variable a la que se le asigne un valor es local al bloque en el que aparece la asignaci√≥n.</target>
        </trans-unit>
        <trans-unit id="63066c351b344d3122b8c8f4b46ea52b390be1db" translate="yes" xml:space="preserve">
          <source>code2 (class members) aren't visible to code inside methods of the same class&amp;thinsp;&amp;mdash;&amp;thinsp;you would usually access them using self. code4/code5 (loops) live in the same scope as code3, so if you wrote to x in there you would be changing the x instance defined in code3, not making a new x.</source>
          <target state="translated">code2 (miembros de la clase) no son visibles para el c&amp;oacute;digo dentro de los m&amp;eacute;todos de la misma clase; por lo general, se accede a ellos usando self. code4 / code5 (bucles) viven en el mismo &amp;aacute;mbito que code3, por lo que si escribiera en x all&amp;iacute; estar&amp;iacute;a cambiando la instancia de x definida en code3, no haciendo una nueva x.</target>
        </trans-unit>
        <trans-unit id="cc6ec69a6efab094133defe38aae1e3d60c488d6" translate="yes" xml:space="preserve">
          <source>fun3 sees the instance x from the nearest containing scope, which is the function scope associated with fun2. But the other x instances, defined in fun1 and globally, are not affected.</source>
          <target state="translated">fun3 ve la instancia x desde el √°mbito de contenci√≥n m√°s cercano,que es el √°mbito de funci√≥n asociado a fun2.Pero las otras instancias x,definidas en fun1 y globalmente,no se ven afectadas.</target>
        </trans-unit>
        <trans-unit id="58ea49680b324ab3ca71332dbc3414bb1ebdb589" translate="yes" xml:space="preserve">
          <source>i.e. &lt;code&gt;nonlocal&lt;/code&gt; always refers to the innermost outer non-global scope where the name has been bound (i.e. assigned to, including used as the &lt;code&gt;for&lt;/code&gt; target variable, in the &lt;code&gt;with&lt;/code&gt; clause, or as a function parameter).</source>
          <target state="translated">es decir, &lt;code&gt;nonlocal&lt;/code&gt; siempre se refiere al &amp;aacute;mbito externo no global m&amp;aacute;s interno donde se ha vinculado el nombre (es decir, asignado a, incluido el utilizado &lt;code&gt;for&lt;/code&gt; la variable de destino, en la cl&amp;aacute;usula &lt;code&gt;with&lt;/code&gt; o como un par&amp;aacute;metro de funci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="da2bcfabde892b5bb52d9d550d0458eca4faf08a" translate="yes" xml:space="preserve">
          <source>lambda is no different to def. If you have a lambda used inside a function, it's the same as defining a nested function. In Python 2.2 onwards, nested scopes are available. In this case you can bind x at any level of function nesting and Python will pick up the innermost instance:</source>
          <target state="translated">lambda no es diferente a def.Si tienes un lambda usado dentro de una funci√≥n,es lo mismo que definir una funci√≥n anidada.A partir de Python 2.2,hay disponibles alcances anidados.En este caso puedes enlazar x en cualquier nivel de anidaci√≥n de funciones y Python recoger√° la instancia m√°s interna:</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="d501ea9d1210349ed22ada10ec53a89a01499008" translate="yes" xml:space="preserve">
          <source>spam's scope - containing everything defined in code3 and code5 (as well as code4, your loop variable)</source>
          <target state="translated">El alcance del spam-que contiene todo lo definido en code3 y code5 (as√≠ como code4,su variable de bucle)</target>
        </trans-unit>
        <trans-unit id="b3b90f9cae4e8e26b4024f88a8f592ef96cb8712" translate="yes" xml:space="preserve">
          <source>x is not found as you haven't defined it. :-) It could be found in code1 (global) or code3 (local) if you put it there.</source>
          <target state="translated">x no se encuentra como no lo has definido.:-)Podr√≠a encontrarse en c√≥digo1 (global)o c√≥digo3 (local)si lo pones ah√≠.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
