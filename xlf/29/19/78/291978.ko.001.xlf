<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/291978">
    <body>
      <group id="291978">
        <trans-unit id="2e5ea5b373efb0a978388bcda9efa3c4e5c03c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; will never be found in &lt;code&gt;code2&lt;/code&gt; (even in cases where you might expect it would, see &lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;Antti's answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;code2&lt;/code&gt; 에서는 &lt;code&gt;x&lt;/code&gt; 를 찾을 수 없습니다 (예를 들어 &lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;Antti의 대답&lt;/a&gt; 또는 &lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;here 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="844b4071ade54e31a272636444a86d27dbf60eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B&lt;/strong&gt;uilt-in (Python) &amp;mdash; Names preassigned in the built-in names module: &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;SyntaxError&lt;/code&gt;, etc</source>
          <target state="translated">&lt;strong&gt;B&lt;/strong&gt; uilt-in (Python) &amp;mdash; 내장 이름 모듈에 사전 할당 된 이름 : &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;SyntaxError&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="97299d3c668df1ab4082a55faa649fd2528112b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;nclosing-function &amp;mdash; Names assigned in the local scope of any and all statically enclosing functions (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), from inner to outer</source>
          <target state="translated">&lt;strong&gt;E&lt;/strong&gt; -closing-function &amp;mdash; 내부에서 외부로 모든 정적으로 둘러싸는 함수 ( &lt;code&gt;def&lt;/code&gt; 또는 &lt;code&gt;lambda&lt;/code&gt; )의 로컬 범위에 지정된 이름</target>
        </trans-unit>
        <trans-unit id="cfb38a37b33062a0dac44099257bd4a65386ac18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;lobal (module) &amp;mdash; Names assigned at the top-level of a module file, or by executing a &lt;code&gt;global&lt;/code&gt; statement in a &lt;code&gt;def&lt;/code&gt; within the file</source>
          <target state="translated">&lt;strong&gt;G&lt;/strong&gt; lobal (모듈) &amp;mdash; 모듈 파일의 최상위 레벨에 할당되거나 파일 내의 &lt;code&gt;def&lt;/code&gt; 에서 &lt;code&gt;global&lt;/code&gt; 명령문을 실행하여 지정된 이름</target>
        </trans-unit>
        <trans-unit id="778d2680a013b2b927bbd42cf4dbd8f8e603daa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;L&lt;/strong&gt;ocal &amp;mdash; Names assigned in any way within a function (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), and not declared global in that function</source>
          <target state="translated">&lt;strong&gt;L&lt;/strong&gt; ocal &amp;mdash; 함수 내에서 어떤 식 으로든 할당되고 ( &lt;code&gt;def&lt;/code&gt; 또는 &lt;code&gt;lambda&lt;/code&gt; ) 해당 함수에서 전역으로 선언되지 않은 이름</target>
        </trans-unit>
        <trans-unit id="5277f4fac12d44eb629e5c22b7e1d8094c037eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LEGB Rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LEGB 규칙&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8fbc1e546684b1d340d4bb068e765dfcdfb7254c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restrictions:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Restrictions:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e9af317e5a414fef2826cb666d4e978c26801dd" translate="yes" xml:space="preserve">
          <source>A slightly more complete example of scope:</source>
          <target state="translated">범위의 약간 더 완전한 예 :</target>
        </trans-unit>
        <trans-unit id="3eacc2675a7bf748ffe69c0804238499bf0a642c" translate="yes" xml:space="preserve">
          <source>Actually, a concise rule for Python Scope resolution, from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;Learning Python, 3rd. Ed.&lt;/a&gt;. (These rules are specific to variable names, not attributes. If you reference it without a period, these rules apply.)</source>
          <target state="translated">실제로, &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;Python python 3의&lt;/a&gt; Python Scope 해상도에 대한 간결한 규칙 . 에드 . (이 규칙은 속성이 아닌 변수 이름에만 적용됩니다. 마침표없이 참조하면이 규칙이 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="b9b84618b4dc87a1c871237cbcae8ef234da18b5" translate="yes" xml:space="preserve">
          <source>Also there is the context during execution, when the function &lt;code&gt;spam&lt;/code&gt; is passed somewhere else. And maybe &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;lambda functions&lt;/a&gt; pass a bit differently?</source>
          <target state="translated">또한 &lt;code&gt;spam&lt;/code&gt; 기능이 다른 곳으로 전달 될 때 실행 중에 컨텍스트가 있습니다. &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;람다 함수&lt;/a&gt; 가 약간 다르게 전달 될 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2b234758bd81a7c9bf0560b3b0aec62418bf437f" translate="yes" xml:space="preserve">
          <source>An object (an instance of a class) has instance variables.  These names are in the object's namespace.  They must be qualified by the object.  (&lt;code&gt;variable.instance&lt;/code&gt;.)</source>
          <target state="translated">객체 (클래스의 인스턴스)에는 인스턴스 변수가 있습니다. 이러한 이름은 객체의 네임 스페이스에 있습니다. 그것들은 객체에 의해 자격을 갖추어야합니다. ( &lt;code&gt;variable.instance&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="edd9da0852ea07205aefc7b6ee60189bd45f1905" translate="yes" xml:space="preserve">
          <source>Any variable that is not deemed to be local to the current scope, or any enclosing scope, is a global variable. A global name is looked up in the module global dictionary; if not found, the global is then looked up from the builtins module; the name of the module was changed from python 2 to python 3; in python 2 it was &lt;code&gt;__builtin__&lt;/code&gt; and in python 3 it is now called &lt;code&gt;builtins&lt;/code&gt;. If you assign to an attribute of builtins module, it will be visible thereafter to any module as a readable global variable, unless that module shadows them with its own global variable with the same name.</source>
          <target state="translated">현재 범위 또는 로컬 범위에 로컬로 간주되지 않는 변수는 전역 변수입니다. 전역 이름은 모듈 전역 사전에서 조회됩니다. 찾을 수없는 경우 내장 모듈에서 전역을 찾습니다. 모듈 이름이 python 2에서 python 3으로 변경되었습니다. 파이썬 2에서는 &lt;code&gt;__builtin__&lt;/code&gt; 이며 파이썬 3에서는 이제 &lt;code&gt;builtins&lt;/code&gt; 라고합니다. 내장 모듈의 속성에 할당하는 경우, 모듈이 동일한 이름의 자체 글로벌 변수로 음영 처리되지 않는 한 그 모듈은 읽을 수있는 글로벌 변수로 모든 모듈에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5e4660e77d407e9b103ce4b6048d3ef22738c691" translate="yes" xml:space="preserve">
          <source>As provided in other answers, there are 4 basic scopes, the LEGB, for Local, Enclosing, Global and Builtin. In addition to those, there is a special scope, the &lt;strong&gt;class body&lt;/strong&gt;, which does not comprise an enclosing scope for methods defined within the class; any assignments within the class body make the variable from there on be bound in the class body.</source>
          <target state="translated">다른 답변에서 제공하는 것처럼 로컬, 인클로저, 글로벌 및 내장에 대한 4 가지 기본 범위 인 LEGB가 있습니다. 그 외에도 &lt;strong&gt;클래스 본문&lt;/strong&gt; 내에 특별한 범위가 있으며, &lt;strong&gt;클래스 본문&lt;/strong&gt; 은 클래스 내에 정의 된 메소드에 대한 범위를 포함하지 않습니다. 클래스 본문 내에서 할당하면 변수가 클래스 본문에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="77587594047610e85f49724453d7e1697738b9e3" translate="yes" xml:space="preserve">
          <source>At any time during execution, there
  are at least three nested scopes whose
  namespaces are directly accessible:
  the innermost scope, which is searched
  first, contains the local names; the
  namespaces of any enclosing functions,
  which are searched starting with the
  nearest enclosing scope; the middle
  scope, searched next, contains the
  current module's global names; and the
  outermost scope (searched last) is the
  namespace containing built-in names.</source>
          <target state="translated">실행 중 언제든지 네임 스페이스에 직접 액세스 할 수있는 중첩 된 범위가 3 개 이상 있습니다. 가장 먼저 검색되는 가장 안쪽 범위에는 로컬 이름이 포함됩니다. 가장 가까운 엔 클로징 범위에서 시작하여 검색되는 모든 엔 클로징 함수의 네임 스페이스 다음에 검색되는 중간 범위에는 현재 모듈의 전체 이름이 포함됩니다. 가장 바깥 쪽 범위 (마지막으로 검색)는 내장 이름이 포함 된 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="949db5aedd1359c2910fdcddc532ee3920954144" translate="yes" xml:space="preserve">
          <source>B: Any builtin &lt;code&gt;x&lt;/code&gt; in Python.</source>
          <target state="translated">B : 파이썬에 내장 된 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94f58ad3d39e723cd41ed035c3fc63eb570fe299" translate="yes" xml:space="preserve">
          <source>Before nested_scopes&amp;thinsp;&amp;mdash;&amp;thinsp;in Python pre-2.1, and in 2.1 unless you specifically ask for the feature using a from-future-import&amp;thinsp;&amp;mdash;&amp;thinsp;fun1 and fun2's scopes are not visible to fun3, so S.Lott's answer holds and you would get the global x:</source>
          <target state="translated">파이썬에서 2.1 이전 버전과 2.1 이후 버전에서 가져 오기 기능을 사용하여 기능을 특별히 요청하지 않는 한 nested_scopes 이전에는 fun1 및 fun2의 범위가 fun3에 표시되지 않으므로 S.Lott의 답변이 유지되고 전역 x를 얻을 수 있습니다. :</target>
        </trans-unit>
        <trans-unit id="ccabba569adb4497369de2ec7d4f33e75f0e6878" translate="yes" xml:space="preserve">
          <source>Currently there is no way to do the same for variables in enclosing &lt;em&gt;function&lt;/em&gt; scopes, but Python 3 introduces a new keyword, &quot;&lt;code&gt;nonlocal&lt;/code&gt;&quot; which will act in a similar way to global, but for nested function scopes.</source>
          <target state="translated">현재 &lt;em&gt;함수&lt;/em&gt; 범위를 묶는 변수에 대해 동일한 작업을 수행 할 수있는 방법은 없지만 Python 3에서는 전역 키워드와 유사한 방식으로 작동하지만 중첩 된 함수 범위에 대해 &quot; &lt;code&gt;nonlocal&lt;/code&gt; &quot;이라는 새로운 키워드를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="685a7a88c4d863000bc56afa13ac95aae11160f0" translate="yes" xml:space="preserve">
          <source>E: Any enclosing functions (if the whole example were in another &lt;code&gt;def&lt;/code&gt;)</source>
          <target state="translated">E : 모든 포함 함수 (전체 예제가 다른 정의에있는 경우)</target>
        </trans-unit>
        <trans-unit id="3091bb32545b1f507703c4fcd6455ca21eb171a8" translate="yes" xml:space="preserve">
          <source>EDIT: Here's the &lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt; with more information on this.</source>
          <target state="translated">편집 : 여기에 대한 자세한 정보가있는 &lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5067e65f592d1333460adda9fda56628aeffb64e" translate="yes" xml:space="preserve">
          <source>Especially, &lt;strong&gt;no&lt;/strong&gt; block statement, besides &lt;code&gt;def&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;, create a variable scope. In Python 2 a list comprehension does not create a variable scope, however in Python 3 the loop variable within list comprehensions is created in a new scope.</source>
          <target state="translated">특히 &lt;code&gt;def&lt;/code&gt; 및 &lt;code&gt;class&lt;/code&gt; 외에는 블록 범위가 변수 범위를 작성 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 파이썬 2에서는리스트 이해가 변수 범위를 생성하지 않지만, 파이썬 3에서는리스트 이해 내의 루프 변수가 새로운 범위로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4360b38ce6fca6533891aa6402e815f6de882ee8" translate="yes" xml:space="preserve">
          <source>Essentially, the only thing in Python that introduces a new scope is a function definition.  Classes are a bit of a special case in that anything defined directly in the body is placed in the class's namespace, but they are not directly accessible from within the methods (or nested classes) they contain.</source>
          <target state="translated">본질적으로 파이썬에서 새로운 범위를 소개하는 유일한 것은 함수 정의입니다. 클래스는 본문에 직접 정의 된 모든 것이 클래스의 네임 스페이스에 배치되지만 포함 된 메소드 (또는 중첩 클래스)에서 직접 액세스 할 수 없다는 점에서 약간 특별한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="3454040cf44b56303faa3532297c412240cf336a" translate="yes" xml:space="preserve">
          <source>From within a class method, you have locals and globals.  You say &lt;code&gt;self.variable&lt;/code&gt; to pick the instance as the namespace.  You'll note that &lt;code&gt;self&lt;/code&gt; is an argument to every class member function, making it part of the local namespace.</source>
          <target state="translated">수업 방법 내에서 지역과 세계가 있습니다. &lt;code&gt;self.variable&lt;/code&gt; 을 사용하여 인스턴스를 네임 스페이스로 선택하십시오. &lt;code&gt;self&lt;/code&gt; 는 모든 클래스 멤버 함수에 대한 인수이므로 로컬 네임 스페이스의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="7664a9e609e66bc2d00fa363b667ab4f2f1fefff" translate="yes" xml:space="preserve">
          <source>G: Were there any &lt;code&gt;x&lt;/code&gt; declared globally in the module (in &lt;code&gt;code1&lt;/code&gt;)?</source>
          <target state="translated">G : 모듈에서 &lt;code&gt;x&lt;/code&gt; 가 전역 적으로 선언 되었습니까 ( &lt;code&gt;code1&lt;/code&gt; )?</target>
        </trans-unit>
        <trans-unit id="1d87f06cf14aca3bd4a191b57670565bfad952c1" translate="yes" xml:space="preserve">
          <source>Global is -- well -- global.</source>
          <target state="translated">글로벌은 글로벌입니다.</target>
        </trans-unit>
        <trans-unit id="5e8b57f9b5edca1d505a9498465cdf117eedf409" translate="yes" xml:space="preserve">
          <source>However in python 3, the &lt;code&gt;nonlocal&lt;/code&gt; comes to rescue:</source>
          <target state="translated">그러나 파이썬 3에서는 &lt;code&gt;nonlocal&lt;/code&gt; 이 구출됩니다.</target>
        </trans-unit>
        <trans-unit id="489c4eee2e8a8e18d94f2c3c5b9d39e4ba2a71d9" translate="yes" xml:space="preserve">
          <source>If I have some code:</source>
          <target state="translated">코드가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="3f0b2cb298d97b428d9e6a5814ab14829603d125" translate="yes" xml:space="preserve">
          <source>If a name is ever assigned to in the current scope (except in the class scope), it will be considered belonging to that scope, otherwise it will be considered to belonging to any enclosing scope that assigns to the variable (it might not be assigned yet, or not at all), or finally the global scope. If the variable is considered local, but it is not set yet, or has been deleted, reading the variable value will result in &lt;code&gt;UnboundLocalError&lt;/code&gt;, which is a subclass of &lt;code&gt;NameError&lt;/code&gt;.</source>
          <target state="translated">이름이 현재 범위 (클래스 범위 제외)에 할당 된 경우 해당 범위에 속하는 것으로 간주되고, 그렇지 않으면 변수에 할당되는 모든 범위에 속하는 것으로 간주됩니다 (할당되지 않을 수 있음) 아직 또는 전혀) 또는 마지막으로 글로벌 범위. 변수가 로컬로 간주되지만 아직 설정되지 않았거나 삭제 된 경우 변수 값을 &lt;code&gt;UnboundLocalError&lt;/code&gt; 가 발생하며 이는 &lt;code&gt;NameError&lt;/code&gt; 의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d536a4e1d312f0bb4a36c7db71be18f86a0595ec" translate="yes" xml:space="preserve">
          <source>If a variable can't be found in the current scope, please refer to the LEGB order.</source>
          <target state="translated">현재 범위에서 변수를 찾을 수 없으면 LEGB 순서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="594e2207a906c678397d7ca8b95cf26be8bec159" translate="yes" xml:space="preserve">
          <source>In Python,</source>
          <target state="translated">파이썬에서</target>
        </trans-unit>
        <trans-unit id="daa6bf94be3ef37adbff56bb43caa58be32ae290" translate="yes" xml:space="preserve">
          <source>In order to actually modify the bindings of global variables from within a function scope, you need to specify that the variable is global with the global keyword.  Eg:</source>
          <target state="translated">함수 범위 내에서 전역 변수의 바인딩을 실제로 수정하려면 global 키워드를 사용하여 변수가 전역임을 지정해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="0bc6e3d84d0a49e5ed2803b53b300500f65ae44e" translate="yes" xml:space="preserve">
          <source>In python 2 there is no easy way to modify the value in the enclosing scope; usually this is simulated by having a mutable value, such as a list with length of 1:</source>
          <target state="translated">파이썬 2에서는 둘러싸는 범위에서 값을 수정하는 쉬운 방법이 없습니다. 일반적으로 이것은 길이가 1 인 목록과 같이 변경 가능한 값을 가짐으로써 시뮬레이션됩니다.</target>
        </trans-unit>
        <trans-unit id="286079d30426b3322fda99d492f07b15340885cb" translate="yes" xml:space="preserve">
          <source>In the class namespace</source>
          <target state="translated">클래스 네임 스페이스에서</target>
        </trans-unit>
        <trans-unit id="28d8f315b0ed9313fc78b3f5380fd9a3257f9305" translate="yes" xml:space="preserve">
          <source>In the enclosing source file</source>
          <target state="translated">둘러싸는 소스 파일에서</target>
        </trans-unit>
        <trans-unit id="ca0a0838b052bc29ab825218ced55d4acd83b7c4" translate="yes" xml:space="preserve">
          <source>In the for loop index variable</source>
          <target state="translated">for 루프 인덱스 변수에서</target>
        </trans-unit>
        <trans-unit id="61e7200f1f6a388923daba14399fca3fa229c76d" translate="yes" xml:space="preserve">
          <source>In the function definition</source>
          <target state="translated">함수 정의에서</target>
        </trans-unit>
        <trans-unit id="a677829300682f1c31d8905cb2e5282167c47489" translate="yes" xml:space="preserve">
          <source>In this case, the call to a function named &lt;code&gt;x&lt;/code&gt; has to be resolved in the local name space or the global namespace.</source>
          <target state="translated">이 경우 &lt;code&gt;x&lt;/code&gt; 라는 함수에 대한 호출은 로컬 네임 스페이스 또는 글로벌 네임 스페이스에서 해결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="df991876b5a88f673697607e52e60c6b1c9b6fe4" translate="yes" xml:space="preserve">
          <source>In your example there are only 3 scopes where x will be searched in:</source>
          <target state="translated">귀하의 예에는 x가 검색되는 범위가 3 개뿐입니다.</target>
        </trans-unit>
        <trans-unit id="b22ee2fbcc9bb471eb4de6b0b6be177886173cac" translate="yes" xml:space="preserve">
          <source>Inside a class definition, the names are part of the class namespace.  &lt;code&gt;code2&lt;/code&gt;, for instance, must be qualified by the class name.  Generally &lt;code&gt;Foo.code2&lt;/code&gt;.  However, &lt;code&gt;self.code2&lt;/code&gt; will also work because Python objects look at the containing class as a fall-back.</source>
          <target state="translated">클래스 정의 내에서 이름은 클래스 네임 스페이스의 일부입니다. 예를 들어 &lt;code&gt;code2&lt;/code&gt; 는 클래스 이름으로 규정되어야합니다. 일반적으로 &lt;code&gt;Foo.code2&lt;/code&gt; . 그러나 파이썬 객체는 포함하는 클래스를 폴백으로 간주하기 때문에 &lt;code&gt;self.code2&lt;/code&gt; 도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="09981edc13a0ed704530d39e42b44aa50109ee99" translate="yes" xml:space="preserve">
          <source>Inside the for loop</source>
          <target state="translated">for 루프 내부</target>
        </trans-unit>
        <trans-unit id="e0e03b34b38a81e2a7f53f8a81459fc2d617f237" translate="yes" xml:space="preserve">
          <source>L: Local in &lt;code&gt;def spam&lt;/code&gt; (in &lt;code&gt;code3&lt;/code&gt;, &lt;code&gt;code4&lt;/code&gt;, and &lt;code&gt;code5&lt;/code&gt;)</source>
          <target state="translated">L : &lt;code&gt;def spam&lt;/code&gt; 로컬 ( &lt;code&gt;code3&lt;/code&gt; , &lt;code&gt;code4&lt;/code&gt; 및 &lt;code&gt;code5&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e92d705ad99ad05765b1551d9ea147eb1bdeda13" translate="yes" xml:space="preserve">
          <source>Local in this case, is the body of the method function &lt;code&gt;Foo.spam&lt;/code&gt;.</source>
          <target state="translated">이 경우 로컬은 메소드 함수 &lt;code&gt;Foo.spam&lt;/code&gt; 의 본문입니다.</target>
        </trans-unit>
        <trans-unit id="9239d3c1c8dfe483cc92d0d056245b45330b191b" translate="yes" xml:space="preserve">
          <source>More scopes only appear when you introduce a nested function (or lambda) into the picture.
These will behave pretty much as you'd expect however.  The nested function can access everything in the local scope, as well as anything in the enclosing function's scope. eg.</source>
          <target state="translated">더 많은 범위는 그림에 중첩 함수 (또는 람다)를 도입 할 때만 나타납니다. 그러나 이것은 예상대로 거의 작동합니다. 중첩 된 함수는 로컬 범위의 모든 항목과 둘러싸는 함수의 범위에있는 모든 항목에 액세스 할 수 있습니다. 예.</target>
        </trans-unit>
        <trans-unit id="27da1baa1c8ced7550e55368c36e9a711d3e6fa3" translate="yes" xml:space="preserve">
          <source>Names listed in a nonlocal statement, unlike those listed in a global statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously).</source>
          <target state="translated">글로벌 명령문에 나열된 것과 달리 로컬이 아닌 명령문에 나열된 이름은 둘러싸는 범위의 기존 바인딩을 참조해야합니다 (새 바인딩을 작성해야하는 범위를 명확하게 판별 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="28b769433b63849ac3d6dd68d58b2953ccbd4282" translate="yes" xml:space="preserve">
          <source>Namespaces are created by packages, modules, classes, object construction and functions.  There aren't any other flavors of namespaces.</source>
          <target state="translated">네임 스페이스는 패키지, 모듈, 클래스, 객체 구성 및 기능으로 생성됩니다. 다른 이름 공간은 없습니다.</target>
        </trans-unit>
        <trans-unit id="beb5b3eceb0aafb4ddd706656bbfc7ee6baaddbe" translate="yes" xml:space="preserve">
          <source>One of the greater surprises to many newcomers to Python is that a &lt;code&gt;for&lt;/code&gt; loop does not create a variable scope. In Python 2 the list comprehensions do not create a scope either (while generators and dict comprehensions do!) Instead they leak the value in the function or the global scope:</source>
          <target state="translated">파이썬을 처음 접하는 많은 사람들에게 큰 놀라움 중 하나는 &lt;code&gt;for&lt;/code&gt; 루프가 변수 범위를 만들지 않는다는 것입니다. Python 2에서 목록 이해는 범위를 만들지 않습니다 (제너레이터와 dict 이해력이있는 동안!) 대신 함수 또는 전역 범위에서 값을 유출합니다.</target>
        </trans-unit>
        <trans-unit id="12ce7bda1dda1b2c962ca66689c2785500bf04ad" translate="yes" xml:space="preserve">
          <source>Python is statically scoped, so if you pass &amp;lsquo;spam&amp;rsquo; to another function spam will still have access to globals in the module it came from (defined in code1), and any other containing scopes (see below). code2 members would again be accessed through self.</source>
          <target state="translated">파이썬은 정적으로 범위가 정해져 있으므로 '스팸'을 다른 함수에 전달하면 스팸은 모듈의 코드 (코드 1에 정의 됨) 및 다른 포함 범위 (아래 참조)에 계속 액세스 할 수 있습니다. code2 멤버는 다시 self를 통해 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="ca50994c79187618aaa08a98a101ea8024bec937" translate="yes" xml:space="preserve">
          <source>Python resolves your variables with -- generally -- three namespaces available.</source>
          <target state="translated">파이썬은 일반적으로 세 가지 네임 스페이스로 변수를 분석합니다.</target>
        </trans-unit>
        <trans-unit id="db64c8c2222f51f190901bd1ac7f77cfbca7a5eb" translate="yes" xml:space="preserve">
          <source>Reading the builtin module can also be useful; suppose that you want the python 3 style print function in some parts of file, but other parts of file still use the &lt;code&gt;print&lt;/code&gt; statement. In Python 2.6-2.7 you can get hold of the Python 3 &lt;code&gt;print&lt;/code&gt; function with:</source>
          <target state="translated">내장 모듈을 읽는 것도 유용 할 수 있습니다. 파일의 일부 부분에서 python 3 스타일 인쇄 기능을 원하지만 파일의 다른 부분에서는 여전히 &lt;code&gt;print&lt;/code&gt; 문을 사용한다고 가정하십시오. Python 2.6-2.7에서는 다음을 사용하여 Python 3 &lt;code&gt;print&lt;/code&gt; 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b5d18222e29afa718228e26345659e72bb55bf1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Python Scope Rules&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Python Scope&lt;/a&gt;, &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;Variable Scope&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Python 범위 규칙&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Python 범위&lt;/a&gt; , &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;변수 범위를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8c6e2463ee152af10c825b92902e29b53188a0e" translate="yes" xml:space="preserve">
          <source>Short description of the scoping rules</source>
          <target state="translated">범위 지정 규칙에 대한 간단한 설명</target>
        </trans-unit>
        <trans-unit id="4137ae49ea23b49b8aded44e40cc20f03153e5ea" translate="yes" xml:space="preserve">
          <source>So, in the case of</source>
          <target state="translated">따라서</target>
        </trans-unit>
        <trans-unit id="c1f5b7fd34b0297627287f84737d24abc3aef183" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt;&lt;code&gt;nonlocal&lt;/code&gt; documentation&lt;/a&gt; says that</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt; &lt;code&gt;nonlocal&lt;/code&gt; &lt;/a&gt; 이 아닌 문서에 따르면</target>
        </trans-unit>
        <trans-unit id="f37cfe501f6b493322c7adbc4648321534c77ec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop does not have its own namespace. In LEGB order, the scopes would be</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프에는 자체 네임 스페이스가 없습니다. LEGB 순서에서 범위는</target>
        </trans-unit>
        <trans-unit id="3f202f06df9b6796d66908f7d06c0fb4a5dba2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from __future__ import print_function&lt;/code&gt; actually does not import the &lt;code&gt;print&lt;/code&gt; function anywhere in Python 2 - instead it just disables the parsing rules for &lt;code&gt;print&lt;/code&gt; statement in the current module, handling &lt;code&gt;print&lt;/code&gt; like any other variable identifier, and thus allowing the &lt;code&gt;print&lt;/code&gt; the function be looked up in the builtins.</source>
          <target state="translated">&lt;code&gt;from __future__ import print_function&lt;/code&gt; 실제로 Python 2의 어느 곳에서나 &lt;code&gt;print&lt;/code&gt; 함수를 가져 오지 않습니다. 대신 현재 모듈의 &lt;code&gt;print&lt;/code&gt; 문에 대한 구문 분석 규칙을 비활성화하고 다른 변수 식별자와 같이 &lt;code&gt;print&lt;/code&gt; 처리하여 &lt;code&gt;print&lt;/code&gt; 기능을 조회 할 수 있습니다 내장에서.</target>
        </trans-unit>
        <trans-unit id="b852b61c52cf6abf12d94fe216923a1456609117" translate="yes" xml:space="preserve">
          <source>The builtins namespace.  A bit of a special case - this contains the various Python builtin functions and types such as len() and str(). Generally this shouldn't be modified by any user code, so expect it to contain the standard functions and nothing else.</source>
          <target state="translated">내장 네임 스페이스 약간의 특별한 경우-len () 및 str ()과 같은 다양한 Python 내장 함수 및 유형이 포함되어 있습니다. 일반적으로 이것은 사용자 코드로 수정해서는 안되므로 표준 기능 만 포함하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b666180107f3bb2a5459c2803fd6ec63d97c8a5f" translate="yes" xml:space="preserve">
          <source>The comprehensions can be used as a cunning (or awful if you will) way to make modifiable variables within lambda expressions in Python 2 - a lambda expression does create a variable scope, like the &lt;code&gt;def&lt;/code&gt; statement would, but within lambda no statements are allowed. Assignment being a statement in Python means that no variable assignments in lambda are allowed, but a list comprehension is an expression...</source>
          <target state="translated">이해는 파이썬 2의 람다 식 내에서 수정 가능한 변수를 만드는 교활한 (또는 끔찍한 경우) 방법으로 사용될 수 있습니다. 람다 식은 &lt;code&gt;def&lt;/code&gt; 문과 같이 변수 범위를 만들지 만 람다 내에서는 문이 허용되지 않습니다. 파이썬에서 명령문으로 할당한다는 것은 람다에서 변수 할당이 허용되지 않지만 목록 이해는 표현식이라는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d83d3f2e8e91a527bd523f95cb8e0b56a2f91f94" translate="yes" xml:space="preserve">
          <source>The global really means the module scope; the main python module is the &lt;code&gt;__main__&lt;/code&gt;; all imported modules are accessible through the &lt;code&gt;sys.modules&lt;/code&gt; variable; to get access to &lt;code&gt;__main__&lt;/code&gt; one can use &lt;code&gt;sys.modules['__main__']&lt;/code&gt;, or &lt;code&gt;import __main__&lt;/code&gt;; it is perfectly acceptable to access and assign attributes there; they will show up as variables in the global scope of the main module.</source>
          <target state="translated">전역은 실제로 모듈 범위를 의미합니다. 주요 파이썬 모듈은 &lt;code&gt;__main__&lt;/code&gt; 입니다 . 가져온 모든 모듈은 &lt;code&gt;sys.modules&lt;/code&gt; 변수를 통해 액세스 할 수 있습니다. &lt;code&gt;__main__&lt;/code&gt; 에 액세스하려면 &lt;code&gt;sys.modules['__main__']&lt;/code&gt; 을 사용하거나 &lt;code&gt;import __main__&lt;/code&gt; . 속성을 액세스하고 할당하는 것은 완벽하게 허용됩니다. 메인 모듈의 전역 범위에 변수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ea88c84d8c2d8c0a30fbe73d16592805fd95c700" translate="yes" xml:space="preserve">
          <source>The global scope - containing everything defined in code1, as well as Foo (and whatever changes after it)</source>
          <target state="translated">전역 범위-code1에 정의 된 모든 내용과 Foo (및 그 이후의 변경 사항)</target>
        </trans-unit>
        <trans-unit id="5e3aea07bda301107941314511a14e18439bd4db" translate="yes" xml:space="preserve">
          <source>The rule is to search the nested local spaces created by method functions (and nested function definitions), then search global.  That's it.</source>
          <target state="translated">규칙은 메소드 함수 (및 내포 된 함수 정의)로 작성된 내포 된 로컬 공간을 검색 한 후 글로벌을 검색하는 것입니다. 그게 다야.</target>
        </trans-unit>
        <trans-unit id="b2cef6f50c86efea01393fcf6254ce2bd0a1dedd" translate="yes" xml:space="preserve">
          <source>The scope can declare that it explicitly wants to modify the global (module scope) variable, with the global keyword:</source>
          <target state="translated">범위는 global 키워드를 사용하여 전역 (모듈 범위) 변수를 명시 적으로 수정한다고 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94b81dae7f5d26ac7081fc6ac0cbbd90734b62ef" translate="yes" xml:space="preserve">
          <source>The scoping rules for Python 2.x have been outlined already in other answers. The only thing I would add is that in Python 3.0, there is also the concept of a non-local scope (indicated by the 'nonlocal' keyword). This allows you to access outer scopes directly, and opens up the ability to do some neat tricks, including lexical closures (without ugly hacks involving mutable objects).</source>
          <target state="translated">Python 2.x의 범위 지정 규칙은 이미 다른 답변에 설명되어 있습니다. 내가 추가 할 유일한 것은 Python 3.0에는 로컬이 아닌 범위 ( 'nonlocal'키워드로 표시)의 개념이 있다는 것입니다. 이를 통해 외부 스코프에 직접 액세스 할 수 있으며 어휘 클로저 (가변 객체를 포함하는 추악한 해킹없이)를 포함한 깔끔한 트릭을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01feb0417fe8dd53fe7a7458888a7cf55f38e6c5" translate="yes" xml:space="preserve">
          <source>There are no other scopes.  The &lt;code&gt;for&lt;/code&gt; statement (and other compound statements like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt;) don't create new nested scopes.  Only definitions (packages, modules, functions, classes and object instances.)</source>
          <target state="translated">다른 범위는 없습니다. &lt;code&gt;for&lt;/code&gt; 문 (및 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;try&lt;/code&gt; 와 같은 다른 복합 문)은 새 중첩 범위를 만들지 않습니다. 정의 (패키지, 모듈, 함수, 클래스 및 객체 인스턴스)</target>
        </trans-unit>
        <trans-unit id="2c9bc52a6aab7f588fc16c4ea6fa447de217b0d0" translate="yes" xml:space="preserve">
          <source>There are two functions: &lt;code&gt;globals&lt;/code&gt; and &lt;code&gt;locals&lt;/code&gt; which show you the contents two of these namespaces.</source>
          <target state="translated">&lt;code&gt;globals&lt;/code&gt; 와 &lt;code&gt;locals&lt;/code&gt; 의 두 가지 기능이 있는데,이 네임 스페이스 중 두 가지를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="66f53662b40fee705c6cf869f8862a3f0af7508c" translate="yes" xml:space="preserve">
          <source>There must be a simple reference or algorithm somewhere.  It's a confusing world for intermediate Python programmers.</source>
          <target state="translated">어딘가에 간단한 참조 또는 알고리즘이 있어야합니다. 중간 파이썬 프로그래머에게는 혼란스러운 세상입니다.</target>
        </trans-unit>
        <trans-unit id="dc197e05c0a632bbe533e1fc9cc6179dbe36858f" translate="yes" xml:space="preserve">
          <source>There was no thorough answer concerning Python3 time, so I made an answer here. Most of what is described here is detailed in the &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;4.2.2 Resolution of names&lt;/a&gt; of the Python 3 documentation.</source>
          <target state="translated">Python3 시간에 대한 완전한 대답은 없었으므로 여기서 대답했습니다. 여기에 설명 된 대부분의 내용은 &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;4.2.2&lt;/a&gt; Python 3 문서 이름 확인에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a99a7f033c4ec910190127fe5239538d99412265" translate="yes" xml:space="preserve">
          <source>This also is possible even if it was shadowed in enclosing scope:</source>
          <target state="translated">둘러싸는 범위에서 음영 처리 된 경우에도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7d7b9be324dd796904b34f5106809953d41f6197" translate="yes" xml:space="preserve">
          <source>This behaviour has been fixed in Python 3 - no comprehension expressions or generators leak variables.</source>
          <target state="translated">이 동작은 Python 3에서 수정되었습니다. 이해 표현식이나 생성기 누출 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="87022636f054df4ffc1ead1749bf1e9c7e728e13" translate="yes" xml:space="preserve">
          <source>Thus unlike in function body, you can reassign the variable to the same name in class body, to get a class variable with the same name; further lookups on this name resolve
to the class variable instead.</source>
          <target state="translated">따라서 함수 본문과 달리 변수를 클래스 본문에서 동일한 이름으로 다시 할당하여 동일한 이름의 클래스 변수를 얻을 수 있습니다. 이 이름에 대한 추가 조회는 대신 클래스 변수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="c10493d5c8fd991112f0f5a007908a58dcf71274" translate="yes" xml:space="preserve">
          <source>To demonstrate the peculiarities of the class body</source>
          <target state="translated">학급의 특성을 보여주기 위해</target>
        </trans-unit>
        <trans-unit id="1ec4a888c88d98357bd2355b16e9d2ee0d98401c" translate="yes" xml:space="preserve">
          <source>Variables in scopes other than the local function's variables can be accessed, but can't be rebound to new parameters without further syntax.  Instead, assignment will create a new &lt;strong&gt;local&lt;/strong&gt; variable instead of affecting the variable in the parent scope.  For example:</source>
          <target state="translated">로컬 함수 변수 이외의 범위에있는 변수는 액세스 할 수 있지만 추가 구문 없이는 새 매개 변수로 리바운드 할 수 없습니다. 대신 할당은 상위 범위의 변수에 영향을주는 대신 새 &lt;strong&gt;로컬&lt;/strong&gt; 변수를 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee59b3c6c46ff5b1167d076e20e42bc9f718a1a0" translate="yes" xml:space="preserve">
          <source>What &lt;strong&gt;exactly&lt;/strong&gt; are the Python scoping rules?</source>
          <target state="translated">파이썬 범위 규칙은 &lt;strong&gt;정확히&lt;/strong&gt; 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e5d36aed6ed1fa3b08d655991945340186892707" translate="yes" xml:space="preserve">
          <source>Where is &lt;code&gt;x&lt;/code&gt; found?  Some possible choices include the list below:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 어디에 있습니까? 가능한 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ceaf19971bdc05e03243ab1bad8110fc5d0ed96" translate="yes" xml:space="preserve">
          <source>Where is x found?</source>
          <target state="translated">x는 어디에 있습니까?</target>
        </trans-unit>
        <trans-unit id="3aeb7e91ed96df6d7f81bbb0e1551a8531c67024" translate="yes" xml:space="preserve">
          <source>any variable that is assigned a value is local to the block in which
  the assignment appears.</source>
          <target state="translated">값이 할당 된 변수는 할당이 나타나는 블록에 대해 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="63066c351b344d3122b8c8f4b46ea52b390be1db" translate="yes" xml:space="preserve">
          <source>code2 (class members) aren't visible to code inside methods of the same class&amp;thinsp;&amp;mdash;&amp;thinsp;you would usually access them using self. code4/code5 (loops) live in the same scope as code3, so if you wrote to x in there you would be changing the x instance defined in code3, not making a new x.</source>
          <target state="translated">code2 (클래스 멤버)는 같은 클래스의 메서드 내부에서 코딩 할 수 없습니다. 일반적으로 self를 사용하여 액세스합니다. code4 / code5 (루프)는 code3과 동일한 범위에 있으므로 x를 쓰면 새 x를 만들지 않고 code3에 정의 된 x 인스턴스를 변경하게됩니다.</target>
        </trans-unit>
        <trans-unit id="cc6ec69a6efab094133defe38aae1e3d60c488d6" translate="yes" xml:space="preserve">
          <source>fun3 sees the instance x from the nearest containing scope, which is the function scope associated with fun2. But the other x instances, defined in fun1 and globally, are not affected.</source>
          <target state="translated">fun3은 fun2와 연관된 함수 범위 인 가장 가까운 포함 범위에서 인스턴스 x를 봅니다. 그러나 fun1 및 전체적으로 정의 된 다른 x 인스턴스는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58ea49680b324ab3ca71332dbc3414bb1ebdb589" translate="yes" xml:space="preserve">
          <source>i.e. &lt;code&gt;nonlocal&lt;/code&gt; always refers to the innermost outer non-global scope where the name has been bound (i.e. assigned to, including used as the &lt;code&gt;for&lt;/code&gt; target variable, in the &lt;code&gt;with&lt;/code&gt; clause, or as a function parameter).</source>
          <target state="translated">즉, &lt;code&gt;nonlocal&lt;/code&gt; 항상 이름이 바인딩 된 가장 안쪽에있는 비 글로벌 범위를 나타냅니다 (예 : &lt;code&gt;with&lt;/code&gt; 대상 변수, with 절 또는 함수 매개 변수로 사용됨을 포함하여).</target>
        </trans-unit>
        <trans-unit id="da2bcfabde892b5bb52d9d550d0458eca4faf08a" translate="yes" xml:space="preserve">
          <source>lambda is no different to def. If you have a lambda used inside a function, it's the same as defining a nested function. In Python 2.2 onwards, nested scopes are available. In this case you can bind x at any level of function nesting and Python will pick up the innermost instance:</source>
          <target state="translated">람다는 데프와 다르지 않습니다. 함수 안에 람다가 사용 된 경우 중첩 함수를 정의하는 것과 같습니다. Python 2.2부터는 중첩 범위를 사용할 수 있습니다. 이 경우 모든 수준의 함수 중첩에서 x를 바인딩 할 수 있으며 Python은 가장 안쪽 인스턴스를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="d501ea9d1210349ed22ada10ec53a89a01499008" translate="yes" xml:space="preserve">
          <source>spam's scope - containing everything defined in code3 and code5 (as well as code4, your loop variable)</source>
          <target state="translated">스팸 범위-code3 및 code5에 정의 된 모든 항목 (루프 변수 code4는 물론)</target>
        </trans-unit>
        <trans-unit id="b3b90f9cae4e8e26b4024f88a8f592ef96cb8712" translate="yes" xml:space="preserve">
          <source>x is not found as you haven't defined it. :-) It could be found in code1 (global) or code3 (local) if you put it there.</source>
          <target state="translated">정의하지 않은 x를 찾을 수 없습니다. :-) code1 (글로벌) 또는 code3 (로컬)에서 찾을 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
