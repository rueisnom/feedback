<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/291978">
    <body>
      <group id="291978">
        <trans-unit id="2e5ea5b373efb0a978388bcda9efa3c4e5c03c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; will never be found in &lt;code&gt;code2&lt;/code&gt; (even in cases where you might expect it would, see &lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;Antti's answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; никогда не будет найден в &lt;code&gt;code2&lt;/code&gt; (даже в тех случаях, когда вы ожидаете, см &lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;. ответ Антти&lt;/a&gt; или &lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;здесь&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="844b4071ade54e31a272636444a86d27dbf60eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B&lt;/strong&gt;uilt-in (Python) &amp;mdash; Names preassigned in the built-in names module: &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;SyntaxError&lt;/code&gt;, etc</source>
          <target state="translated">Встроенный (Python) - имена, предварительно назначенные в модуле встроенных имен: &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;SyntaxError&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="97299d3c668df1ab4082a55faa649fd2528112b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;nclosing-function &amp;mdash; Names assigned in the local scope of any and all statically enclosing functions (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), from inner to outer</source>
          <target state="translated">&lt;strong&gt;E&lt;/strong&gt; nclosing-function - Имена, назначенные в локальной области действия любых статически включающих функций ( &lt;code&gt;def&lt;/code&gt; или &lt;code&gt;lambda&lt;/code&gt; ), от внутренней к внешней.</target>
        </trans-unit>
        <trans-unit id="cfb38a37b33062a0dac44099257bd4a65386ac18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;lobal (module) &amp;mdash; Names assigned at the top-level of a module file, or by executing a &lt;code&gt;global&lt;/code&gt; statement in a &lt;code&gt;def&lt;/code&gt; within the file</source>
          <target state="translated">&lt;strong&gt;G&lt;/strong&gt; lobal (module) - Имена, назначенные на верхнем уровне файла модуля, или путем выполнения &lt;code&gt;global&lt;/code&gt; инструкции в &lt;code&gt;def&lt;/code&gt; внутри файла</target>
        </trans-unit>
        <trans-unit id="778d2680a013b2b927bbd42cf4dbd8f8e603daa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;L&lt;/strong&gt;ocal &amp;mdash; Names assigned in any way within a function (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), and not declared global in that function</source>
          <target state="translated">&lt;strong&gt;L&lt;/strong&gt; ocal - Имена, назначенные любым способом внутри функции ( &lt;code&gt;def&lt;/code&gt; или &lt;code&gt;lambda&lt;/code&gt; ) и не объявленные глобальными в этой функции</target>
        </trans-unit>
        <trans-unit id="5277f4fac12d44eb629e5c22b7e1d8094c037eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LEGB Rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Правило LEGB&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8fbc1e546684b1d340d4bb068e765dfcdfb7254c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restrictions:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Restrictions:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e9af317e5a414fef2826cb666d4e978c26801dd" translate="yes" xml:space="preserve">
          <source>A slightly more complete example of scope:</source>
          <target state="translated">Немного более полный пример сферы применения:</target>
        </trans-unit>
        <trans-unit id="3eacc2675a7bf748ffe69c0804238499bf0a642c" translate="yes" xml:space="preserve">
          <source>Actually, a concise rule for Python Scope resolution, from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;Learning Python, 3rd. Ed.&lt;/a&gt;. (These rules are specific to variable names, not attributes. If you reference it without a period, these rules apply.)</source>
          <target state="translated">Собственно, краткое правило для разрешения Python Scope, из &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;Learning Python, 3-е.&lt;/a&gt; Издание , (Эти правила относятся к именам переменных, а не атрибутам. Если вы ссылаетесь на них без точки, эти правила применяются.)</target>
        </trans-unit>
        <trans-unit id="b9b84618b4dc87a1c871237cbcae8ef234da18b5" translate="yes" xml:space="preserve">
          <source>Also there is the context during execution, when the function &lt;code&gt;spam&lt;/code&gt; is passed somewhere else. And maybe &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;lambda functions&lt;/a&gt; pass a bit differently?</source>
          <target state="translated">Также есть контекст во время выполнения, когда функция &lt;code&gt;spam&lt;/code&gt; передается куда-то еще. А может &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;лямбда-функции&lt;/a&gt; проходят немного иначе?</target>
        </trans-unit>
        <trans-unit id="2b234758bd81a7c9bf0560b3b0aec62418bf437f" translate="yes" xml:space="preserve">
          <source>An object (an instance of a class) has instance variables.  These names are in the object's namespace.  They must be qualified by the object.  (&lt;code&gt;variable.instance&lt;/code&gt;.)</source>
          <target state="translated">Объект (экземпляр класса) имеет переменные экземпляра. Эти имена находятся в пространстве имен объекта. Они должны быть квалифицированы по объекту. ( &lt;code&gt;variable.instance&lt;/code&gt; . экземпляр )</target>
        </trans-unit>
        <trans-unit id="edd9da0852ea07205aefc7b6ee60189bd45f1905" translate="yes" xml:space="preserve">
          <source>Any variable that is not deemed to be local to the current scope, or any enclosing scope, is a global variable. A global name is looked up in the module global dictionary; if not found, the global is then looked up from the builtins module; the name of the module was changed from python 2 to python 3; in python 2 it was &lt;code&gt;__builtin__&lt;/code&gt; and in python 3 it is now called &lt;code&gt;builtins&lt;/code&gt;. If you assign to an attribute of builtins module, it will be visible thereafter to any module as a readable global variable, unless that module shadows them with its own global variable with the same name.</source>
          <target state="translated">Любая переменная, которая не считается локальной для текущей области или любой включающей области, является глобальной переменной. Глобальное имя ищется в глобальном словаре модуля; если он не найден, глобальный объект ищется из встроенного модуля; название модуля было изменено с python 2 на python 3; в python 2 это был &lt;code&gt;__builtin__&lt;/code&gt; , а в python 3 теперь он называется &lt;code&gt;builtins&lt;/code&gt; . Если вы назначите атрибут встроенного модуля, он будет виден после этого любому модулю как читаемая глобальная переменная, если только этот модуль не затеняет их своей глобальной переменной с тем же именем.</target>
        </trans-unit>
        <trans-unit id="5e4660e77d407e9b103ce4b6048d3ef22738c691" translate="yes" xml:space="preserve">
          <source>As provided in other answers, there are 4 basic scopes, the LEGB, for Local, Enclosing, Global and Builtin. In addition to those, there is a special scope, the &lt;strong&gt;class body&lt;/strong&gt;, which does not comprise an enclosing scope for methods defined within the class; any assignments within the class body make the variable from there on be bound in the class body.</source>
          <target state="translated">Как указано в других ответах, есть 4 основных области, LEGB, для Local, Enclosing, Global и Builtin. В дополнение к ним, существует специальная область видимости, &lt;strong&gt;тело класса&lt;/strong&gt; , которая не содержит вмещающей области видимости для методов, определенных в классе; любые присваивания в теле класса делают переменную оттуда связанной в теле класса.</target>
        </trans-unit>
        <trans-unit id="77587594047610e85f49724453d7e1697738b9e3" translate="yes" xml:space="preserve">
          <source>At any time during execution, there
  are at least three nested scopes whose
  namespaces are directly accessible:
  the innermost scope, which is searched
  first, contains the local names; the
  namespaces of any enclosing functions,
  which are searched starting with the
  nearest enclosing scope; the middle
  scope, searched next, contains the
  current module's global names; and the
  outermost scope (searched last) is the
  namespace containing built-in names.</source>
          <target state="translated">В любой момент во время выполнения,существует как минимум три вложенных диапазона,пространства имен которых доступны напрямую:самый внутренний диапазон,в котором выполняется поиск первым,содержит локальные имена;пространства имен любых ограждающих функций,в которых выполняется поиск,начиная с ближайшего ограждающего диапазона;средний диапазон,в котором выполняется поиск следующим,содержит глобальные имена текущего модуля;а самый внешний диапазон (в котором выполняется поиск последним)-это пространство имен,содержащее встроенные имена.</target>
        </trans-unit>
        <trans-unit id="949db5aedd1359c2910fdcddc532ee3920954144" translate="yes" xml:space="preserve">
          <source>B: Any builtin &lt;code&gt;x&lt;/code&gt; in Python.</source>
          <target state="translated">B: Любой встроенный &lt;code&gt;x&lt;/code&gt; в Python.</target>
        </trans-unit>
        <trans-unit id="94f58ad3d39e723cd41ed035c3fc63eb570fe299" translate="yes" xml:space="preserve">
          <source>Before nested_scopes&amp;thinsp;&amp;mdash;&amp;thinsp;in Python pre-2.1, and in 2.1 unless you specifically ask for the feature using a from-future-import&amp;thinsp;&amp;mdash;&amp;thinsp;fun1 and fun2's scopes are not visible to fun3, so S.Lott's answer holds and you would get the global x:</source>
          <target state="translated">До nested_scopes - в Python pre-2.1 и в 2.1, если только вы специально не запрашиваете функцию, использующую импорт из будущего - области действия fun1 и fun2 не видны для fun3, поэтому ответ S.Lott верен, и вы получите глобальный x :</target>
        </trans-unit>
        <trans-unit id="ccabba569adb4497369de2ec7d4f33e75f0e6878" translate="yes" xml:space="preserve">
          <source>Currently there is no way to do the same for variables in enclosing &lt;em&gt;function&lt;/em&gt; scopes, but Python 3 introduces a new keyword, &quot;&lt;code&gt;nonlocal&lt;/code&gt;&quot; which will act in a similar way to global, but for nested function scopes.</source>
          <target state="translated">В настоящее время нет способа сделать то же самое для переменных во вложенных областях &lt;em&gt;функций&lt;/em&gt; , но Python 3 вводит новое ключевое слово &amp;laquo; &lt;code&gt;nonlocal&lt;/code&gt; &amp;raquo;, которое будет действовать аналогично глобальному, но для областей вложенных функций.</target>
        </trans-unit>
        <trans-unit id="685a7a88c4d863000bc56afa13ac95aae11160f0" translate="yes" xml:space="preserve">
          <source>E: Any enclosing functions (if the whole example were in another &lt;code&gt;def&lt;/code&gt;)</source>
          <target state="translated">E: Любые включающие функции (если весь пример был в другом &lt;code&gt;def&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3091bb32545b1f507703c4fcd6455ca21eb171a8" translate="yes" xml:space="preserve">
          <source>EDIT: Here's the &lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt; with more information on this.</source>
          <target state="translated">РЕДАКТИРОВАТЬ: Вот &lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt; с дополнительной информацией об этом.</target>
        </trans-unit>
        <trans-unit id="5067e65f592d1333460adda9fda56628aeffb64e" translate="yes" xml:space="preserve">
          <source>Especially, &lt;strong&gt;no&lt;/strong&gt; block statement, besides &lt;code&gt;def&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;, create a variable scope. In Python 2 a list comprehension does not create a variable scope, however in Python 3 the loop variable within list comprehensions is created in a new scope.</source>
          <target state="translated">В частности, &lt;strong&gt;никакие&lt;/strong&gt; операторы блока, кроме &lt;code&gt;def&lt;/code&gt; и &lt;code&gt;class&lt;/code&gt; , не создают переменную область видимости. В Python 2 понимание списка не создает область видимости переменной, однако в Python 3 переменная цикла в пределах понимания списка создается в новой области видимости.</target>
        </trans-unit>
        <trans-unit id="4360b38ce6fca6533891aa6402e815f6de882ee8" translate="yes" xml:space="preserve">
          <source>Essentially, the only thing in Python that introduces a new scope is a function definition.  Classes are a bit of a special case in that anything defined directly in the body is placed in the class's namespace, but they are not directly accessible from within the methods (or nested classes) they contain.</source>
          <target state="translated">По сути,единственная вещь на Python,которая вводит новый диапазон,это определение функции.Классы немного специфичны в том смысле,что все,что определяется непосредственно в теле,помещается в пространство имён класса,но они не доступны напрямую из содержащихся в них методов (или вложенных классов).</target>
        </trans-unit>
        <trans-unit id="3454040cf44b56303faa3532297c412240cf336a" translate="yes" xml:space="preserve">
          <source>From within a class method, you have locals and globals.  You say &lt;code&gt;self.variable&lt;/code&gt; to pick the instance as the namespace.  You'll note that &lt;code&gt;self&lt;/code&gt; is an argument to every class member function, making it part of the local namespace.</source>
          <target state="translated">Из метода класса у вас есть локальные и глобальные переменные. Вы говорите &lt;code&gt;self.variable&lt;/code&gt; , чтобы выбрать экземпляр в качестве пространства имен. Вы заметите, что &lt;code&gt;self&lt;/code&gt; является аргументом для каждой функции-члена класса, что делает его частью локального пространства имен.</target>
        </trans-unit>
        <trans-unit id="7664a9e609e66bc2d00fa363b667ab4f2f1fefff" translate="yes" xml:space="preserve">
          <source>G: Were there any &lt;code&gt;x&lt;/code&gt; declared globally in the module (in &lt;code&gt;code1&lt;/code&gt;)?</source>
          <target state="translated">G: Был ли &lt;code&gt;x&lt;/code&gt; объявлен глобально в модуле (в &lt;code&gt;code1&lt;/code&gt; )?</target>
        </trans-unit>
        <trans-unit id="1d87f06cf14aca3bd4a191b57670565bfad952c1" translate="yes" xml:space="preserve">
          <source>Global is -- well -- global.</source>
          <target state="translated">Глобал-это...ну...глобал.</target>
        </trans-unit>
        <trans-unit id="5e8b57f9b5edca1d505a9498465cdf117eedf409" translate="yes" xml:space="preserve">
          <source>However in python 3, the &lt;code&gt;nonlocal&lt;/code&gt; comes to rescue:</source>
          <target state="translated">Однако в Python 3 &lt;code&gt;nonlocal&lt;/code&gt; приходит на помощь:</target>
        </trans-unit>
        <trans-unit id="489c4eee2e8a8e18d94f2c3c5b9d39e4ba2a71d9" translate="yes" xml:space="preserve">
          <source>If I have some code:</source>
          <target state="translated">Если у меня есть какой-нибудь код:</target>
        </trans-unit>
        <trans-unit id="3f0b2cb298d97b428d9e6a5814ab14829603d125" translate="yes" xml:space="preserve">
          <source>If a name is ever assigned to in the current scope (except in the class scope), it will be considered belonging to that scope, otherwise it will be considered to belonging to any enclosing scope that assigns to the variable (it might not be assigned yet, or not at all), or finally the global scope. If the variable is considered local, but it is not set yet, or has been deleted, reading the variable value will result in &lt;code&gt;UnboundLocalError&lt;/code&gt;, which is a subclass of &lt;code&gt;NameError&lt;/code&gt;.</source>
          <target state="translated">Если имя когда-либо назначено в текущей области (за исключением области класса), оно будет считаться принадлежащим этой области, в противном случае оно будет считаться принадлежащим какой-либо вмещающей области, которая присваивается переменной (оно может не назначаться). пока или нет) или, наконец, глобальный охват. Если переменная считается локальной, но она еще не установлена ​​или была удалена, чтение значения переменной приведет к &lt;code&gt;UnboundLocalError&lt;/code&gt; , который является подклассом &lt;code&gt;NameError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d536a4e1d312f0bb4a36c7db71be18f86a0595ec" translate="yes" xml:space="preserve">
          <source>If a variable can't be found in the current scope, please refer to the LEGB order.</source>
          <target state="translated">Если переменная не может быть найдена в текущем диапазоне,пожалуйста,обратитесь к заказу LEGB.</target>
        </trans-unit>
        <trans-unit id="594e2207a906c678397d7ca8b95cf26be8bec159" translate="yes" xml:space="preserve">
          <source>In Python,</source>
          <target state="translated">В Питоне,</target>
        </trans-unit>
        <trans-unit id="daa6bf94be3ef37adbff56bb43caa58be32ae290" translate="yes" xml:space="preserve">
          <source>In order to actually modify the bindings of global variables from within a function scope, you need to specify that the variable is global with the global keyword.  Eg:</source>
          <target state="translated">Чтобы реально изменить привязки глобальных переменных из области видимости функции,необходимо указать,что переменная является глобальной с глобальным ключевым словом.Eg:</target>
        </trans-unit>
        <trans-unit id="0bc6e3d84d0a49e5ed2803b53b300500f65ae44e" translate="yes" xml:space="preserve">
          <source>In python 2 there is no easy way to modify the value in the enclosing scope; usually this is simulated by having a mutable value, such as a list with length of 1:</source>
          <target state="translated">На питоне 2 нет простого способа модифицировать значение в прилагаемом диапазоне;обычно это имитируется наличием мутирующего значения,например,списка длиной 1:</target>
        </trans-unit>
        <trans-unit id="286079d30426b3322fda99d492f07b15340885cb" translate="yes" xml:space="preserve">
          <source>In the class namespace</source>
          <target state="translated">В пространстве имён класса</target>
        </trans-unit>
        <trans-unit id="28d8f315b0ed9313fc78b3f5380fd9a3257f9305" translate="yes" xml:space="preserve">
          <source>In the enclosing source file</source>
          <target state="translated">В прилагаемом исходном файле</target>
        </trans-unit>
        <trans-unit id="ca0a0838b052bc29ab825218ced55d4acd83b7c4" translate="yes" xml:space="preserve">
          <source>In the for loop index variable</source>
          <target state="translated">В цикле for переменная индекса</target>
        </trans-unit>
        <trans-unit id="61e7200f1f6a388923daba14399fca3fa229c76d" translate="yes" xml:space="preserve">
          <source>In the function definition</source>
          <target state="translated">В определении функции</target>
        </trans-unit>
        <trans-unit id="a677829300682f1c31d8905cb2e5282167c47489" translate="yes" xml:space="preserve">
          <source>In this case, the call to a function named &lt;code&gt;x&lt;/code&gt; has to be resolved in the local name space or the global namespace.</source>
          <target state="translated">В этом случае вызов функции с именем &lt;code&gt;x&lt;/code&gt; должен быть разрешен в локальном пространстве имен или глобальном пространстве имен.</target>
        </trans-unit>
        <trans-unit id="df991876b5a88f673697607e52e60c6b1c9b6fe4" translate="yes" xml:space="preserve">
          <source>In your example there are only 3 scopes where x will be searched in:</source>
          <target state="translated">В вашем примере есть только 3 диапазона,в которых будет осуществляться поиск по x:</target>
        </trans-unit>
        <trans-unit id="b22ee2fbcc9bb471eb4de6b0b6be177886173cac" translate="yes" xml:space="preserve">
          <source>Inside a class definition, the names are part of the class namespace.  &lt;code&gt;code2&lt;/code&gt;, for instance, must be qualified by the class name.  Generally &lt;code&gt;Foo.code2&lt;/code&gt;.  However, &lt;code&gt;self.code2&lt;/code&gt; will also work because Python objects look at the containing class as a fall-back.</source>
          <target state="translated">Внутри определения класса имена являются частью пространства имен класса. &lt;code&gt;code2&lt;/code&gt; , code2 должен указывать имя класса. Вообще-то &lt;code&gt;Foo.code2&lt;/code&gt; . Однако &lt;code&gt;self.code2&lt;/code&gt; также будет работать, поскольку объекты Python рассматривают содержащий класс как запасной вариант .</target>
        </trans-unit>
        <trans-unit id="09981edc13a0ed704530d39e42b44aa50109ee99" translate="yes" xml:space="preserve">
          <source>Inside the for loop</source>
          <target state="translated">Внутри петли for</target>
        </trans-unit>
        <trans-unit id="e0e03b34b38a81e2a7f53f8a81459fc2d617f237" translate="yes" xml:space="preserve">
          <source>L: Local in &lt;code&gt;def spam&lt;/code&gt; (in &lt;code&gt;code3&lt;/code&gt;, &lt;code&gt;code4&lt;/code&gt;, and &lt;code&gt;code5&lt;/code&gt;)</source>
          <target state="translated">L: локально в &lt;code&gt;def spam&lt;/code&gt; (в &lt;code&gt;code3&lt;/code&gt; , &lt;code&gt;code5&lt;/code&gt; и code5 )</target>
        </trans-unit>
        <trans-unit id="e92d705ad99ad05765b1551d9ea147eb1bdeda13" translate="yes" xml:space="preserve">
          <source>Local in this case, is the body of the method function &lt;code&gt;Foo.spam&lt;/code&gt;.</source>
          <target state="translated">Локальным в данном случае является тело метода-функции &lt;code&gt;Foo.spam&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9239d3c1c8dfe483cc92d0d056245b45330b191b" translate="yes" xml:space="preserve">
          <source>More scopes only appear when you introduce a nested function (or lambda) into the picture.
These will behave pretty much as you'd expect however.  The nested function can access everything in the local scope, as well as anything in the enclosing function's scope. eg.</source>
          <target state="translated">Больше диапазонов появляется только тогда,когда вы вводите вложенную функцию (или лямбда)на картинке.Однако,они будут вести себя так,как вы ожидали.Вложенная функция может получить доступ ко всему,что находится в локальной области видимости,а также ко всему,что находится в области видимости вложенной функции,например.</target>
        </trans-unit>
        <trans-unit id="27da1baa1c8ced7550e55368c36e9a711d3e6fa3" translate="yes" xml:space="preserve">
          <source>Names listed in a nonlocal statement, unlike those listed in a global statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously).</source>
          <target state="translated">Наименования,перечисленные в неместном заявлении,в отличие от имен,перечисленных в глобальном заявлении,должны относиться к ранее существовавшим привязкам в прилагаемом объеме (объем,в котором должна быть создана новая привязка,не может быть определен однозначно).</target>
        </trans-unit>
        <trans-unit id="28b769433b63849ac3d6dd68d58b2953ccbd4282" translate="yes" xml:space="preserve">
          <source>Namespaces are created by packages, modules, classes, object construction and functions.  There aren't any other flavors of namespaces.</source>
          <target state="translated">Пространства имен создаются пакетами,модулями,классами,построением объектов и функциями.Других ароматов пространств имён нет.</target>
        </trans-unit>
        <trans-unit id="beb5b3eceb0aafb4ddd706656bbfc7ee6baaddbe" translate="yes" xml:space="preserve">
          <source>One of the greater surprises to many newcomers to Python is that a &lt;code&gt;for&lt;/code&gt; loop does not create a variable scope. In Python 2 the list comprehensions do not create a scope either (while generators and dict comprehensions do!) Instead they leak the value in the function or the global scope:</source>
          <target state="translated">Многие новички в Python удивляют тем, что цикл &lt;code&gt;for&lt;/code&gt; не создает переменную область видимости. В Python 2 понимание списка также не создает область действия (в то время как генераторы и вычисления dict делают это!) Вместо этого они пропускают значение в функции или глобальной области видимости:</target>
        </trans-unit>
        <trans-unit id="12ce7bda1dda1b2c962ca66689c2785500bf04ad" translate="yes" xml:space="preserve">
          <source>Python is statically scoped, so if you pass &amp;lsquo;spam&amp;rsquo; to another function spam will still have access to globals in the module it came from (defined in code1), and any other containing scopes (see below). code2 members would again be accessed through self.</source>
          <target state="translated">Python статически ограничен, поэтому, если вы передадите &amp;laquo;spam&amp;raquo; другой функции, spam по-прежнему будет иметь доступ к глобальным переменным в модуле, из которого он был получен (определен в code1), и любым другим содержащим области (см. Ниже). Члены code2 снова будут доступны через себя.</target>
        </trans-unit>
        <trans-unit id="ca50994c79187618aaa08a98a101ea8024bec937" translate="yes" xml:space="preserve">
          <source>Python resolves your variables with -- generally -- three namespaces available.</source>
          <target state="translated">Python разрешает ваши переменные с --обычно --тремя доступными пространствами имен.</target>
        </trans-unit>
        <trans-unit id="db64c8c2222f51f190901bd1ac7f77cfbca7a5eb" translate="yes" xml:space="preserve">
          <source>Reading the builtin module can also be useful; suppose that you want the python 3 style print function in some parts of file, but other parts of file still use the &lt;code&gt;print&lt;/code&gt; statement. In Python 2.6-2.7 you can get hold of the Python 3 &lt;code&gt;print&lt;/code&gt; function with:</source>
          <target state="translated">Чтение встроенного модуля также может быть полезным; Предположим, что вам нужна функция печати в стиле Python 3 в некоторых частях файла, но в других частях файла все еще используется оператор &lt;code&gt;print&lt;/code&gt; . В Python 2.6-2.7 вы можете получить функцию &lt;code&gt;print&lt;/code&gt; Python 3 с помощью:</target>
        </trans-unit>
        <trans-unit id="5b5d18222e29afa718228e26345659e72bb55bf1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Python Scope Rules&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Python Scope&lt;/a&gt;, &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;Variable Scope&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Правила области&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Python, Область Python, Область&lt;/a&gt; &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;переменных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8c6e2463ee152af10c825b92902e29b53188a0e" translate="yes" xml:space="preserve">
          <source>Short description of the scoping rules</source>
          <target state="translated">Краткое описание правил поиска</target>
        </trans-unit>
        <trans-unit id="4137ae49ea23b49b8aded44e40cc20f03153e5ea" translate="yes" xml:space="preserve">
          <source>So, in the case of</source>
          <target state="translated">Итак,в случае</target>
        </trans-unit>
        <trans-unit id="c1f5b7fd34b0297627287f84737d24abc3aef183" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt;&lt;code&gt;nonlocal&lt;/code&gt; documentation&lt;/a&gt; says that</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt; &lt;code&gt;nonlocal&lt;/code&gt; документация&lt;/a&gt; гласит, что</target>
        </trans-unit>
        <trans-unit id="f37cfe501f6b493322c7adbc4648321534c77ec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop does not have its own namespace. In LEGB order, the scopes would be</source>
          <target state="translated">Цикл &lt;code&gt;for&lt;/code&gt; не имеет собственного пространства имен. В порядке LEGB, области будут</target>
        </trans-unit>
        <trans-unit id="3f202f06df9b6796d66908f7d06c0fb4a5dba2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from __future__ import print_function&lt;/code&gt; actually does not import the &lt;code&gt;print&lt;/code&gt; function anywhere in Python 2 - instead it just disables the parsing rules for &lt;code&gt;print&lt;/code&gt; statement in the current module, handling &lt;code&gt;print&lt;/code&gt; like any other variable identifier, and thus allowing the &lt;code&gt;print&lt;/code&gt; the function be looked up in the builtins.</source>
          <target state="translated">Функция &lt;code&gt;from __future__ import print_function&lt;/code&gt; фактически не импортирует функцию &lt;code&gt;print&lt;/code&gt; нигде в Python 2 - вместо этого она просто отключает правила синтаксического анализа для оператора &lt;code&gt;print&lt;/code&gt; в текущем модуле, обрабатывая &lt;code&gt;print&lt;/code&gt; как любой другой идентификатор переменной и, таким образом, позволяя функции &lt;code&gt;print&lt;/code&gt; просматривать поиск во встроенных.</target>
        </trans-unit>
        <trans-unit id="b852b61c52cf6abf12d94fe216923a1456609117" translate="yes" xml:space="preserve">
          <source>The builtins namespace.  A bit of a special case - this contains the various Python builtin functions and types such as len() and str(). Generally this shouldn't be modified by any user code, so expect it to contain the standard functions and nothing else.</source>
          <target state="translated">Строится пространство имён.Немного особый случай-в нем присутствуют различные Python-функции builtin и типы,такие как len()и str().Обычно это не должно быть изменено никаким пользовательским кодом,поэтому ожидайте,что в нем будут содержаться стандартные функции и больше ничего.</target>
        </trans-unit>
        <trans-unit id="b666180107f3bb2a5459c2803fd6ec63d97c8a5f" translate="yes" xml:space="preserve">
          <source>The comprehensions can be used as a cunning (or awful if you will) way to make modifiable variables within lambda expressions in Python 2 - a lambda expression does create a variable scope, like the &lt;code&gt;def&lt;/code&gt; statement would, but within lambda no statements are allowed. Assignment being a statement in Python means that no variable assignments in lambda are allowed, but a list comprehension is an expression...</source>
          <target state="translated">Понимания могут быть использованы как хитрый (или ужасный, если хотите) способ создания изменяемых переменных в лямбда-выражениях в Python 2 - лямбда-выражение создает переменную область видимости, как это делает оператор &lt;code&gt;def&lt;/code&gt; , но в лямбда-выражениях никакие операторы не допускаются. Назначение, являющееся оператором в Python, означает, что никакие переменные назначения в лямбде не допускаются, но понимание списка является выражением ...</target>
        </trans-unit>
        <trans-unit id="d83d3f2e8e91a527bd523f95cb8e0b56a2f91f94" translate="yes" xml:space="preserve">
          <source>The global really means the module scope; the main python module is the &lt;code&gt;__main__&lt;/code&gt;; all imported modules are accessible through the &lt;code&gt;sys.modules&lt;/code&gt; variable; to get access to &lt;code&gt;__main__&lt;/code&gt; one can use &lt;code&gt;sys.modules['__main__']&lt;/code&gt;, or &lt;code&gt;import __main__&lt;/code&gt;; it is perfectly acceptable to access and assign attributes there; they will show up as variables in the global scope of the main module.</source>
          <target state="translated">Глобальный действительно означает область видимости модуля; основным модулем Python является &lt;code&gt;__main__&lt;/code&gt; ; все импортированные модули доступны через переменную &lt;code&gt;sys.modules&lt;/code&gt; ; чтобы получить доступ к &lt;code&gt;__main__&lt;/code&gt; , можно использовать &lt;code&gt;sys.modules['__main__']&lt;/code&gt; или &lt;code&gt;import __main__&lt;/code&gt; ; это вполне приемлемо для доступа и назначения атрибутов там; они будут отображаться как переменные в глобальной области видимости основного модуля.</target>
        </trans-unit>
        <trans-unit id="ea88c84d8c2d8c0a30fbe73d16592805fd95c700" translate="yes" xml:space="preserve">
          <source>The global scope - containing everything defined in code1, as well as Foo (and whatever changes after it)</source>
          <target state="translated">Глобальная область видимости-содержащая все,что определено в коде1,а также Foo (и все изменения после него).</target>
        </trans-unit>
        <trans-unit id="5e3aea07bda301107941314511a14e18439bd4db" translate="yes" xml:space="preserve">
          <source>The rule is to search the nested local spaces created by method functions (and nested function definitions), then search global.  That's it.</source>
          <target state="translated">Правило заключается в поиске вложенных локальных пространств,созданных функциями метода (и определениями вложенных функций),а затем в глобальном поиске.Вот и все.</target>
        </trans-unit>
        <trans-unit id="b2cef6f50c86efea01393fcf6254ce2bd0a1dedd" translate="yes" xml:space="preserve">
          <source>The scope can declare that it explicitly wants to modify the global (module scope) variable, with the global keyword:</source>
          <target state="translated">С помощью глобального ключевого слова scope может объявить,что она явно хочет изменить глобальную (модульную)переменную:</target>
        </trans-unit>
        <trans-unit id="94b81dae7f5d26ac7081fc6ac0cbbd90734b62ef" translate="yes" xml:space="preserve">
          <source>The scoping rules for Python 2.x have been outlined already in other answers. The only thing I would add is that in Python 3.0, there is also the concept of a non-local scope (indicated by the 'nonlocal' keyword). This allows you to access outer scopes directly, and opens up the ability to do some neat tricks, including lexical closures (without ugly hacks involving mutable objects).</source>
          <target state="translated">Правила поиска для Python 2.x уже были изложены в других ответах.Единственное,что я хотел бы добавить,это то,что на Python 3.0 также присутствует понятие нелокального диапазона (обозначаемого ключевым словом 'nonlocal').Это позволяет получить прямой доступ к внешним областям видимости и открывает возможность делать некоторые аккуратные трюки,включая лексическое замыкание (без уродливых взломов с участием мутирующих объектов).</target>
        </trans-unit>
        <trans-unit id="01feb0417fe8dd53fe7a7458888a7cf55f38e6c5" translate="yes" xml:space="preserve">
          <source>There are no other scopes.  The &lt;code&gt;for&lt;/code&gt; statement (and other compound statements like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt;) don't create new nested scopes.  Only definitions (packages, modules, functions, classes and object instances.)</source>
          <target state="translated">Других возможностей нет. Оператор &lt;code&gt;for&lt;/code&gt; (и другие составные операторы, такие как &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;try&lt;/code&gt; ) не создают новых вложенных областей. Только определения (пакеты, модули, функции, классы и экземпляры объектов.)</target>
        </trans-unit>
        <trans-unit id="2c9bc52a6aab7f588fc16c4ea6fa447de217b0d0" translate="yes" xml:space="preserve">
          <source>There are two functions: &lt;code&gt;globals&lt;/code&gt; and &lt;code&gt;locals&lt;/code&gt; which show you the contents two of these namespaces.</source>
          <target state="translated">Есть две функции: &lt;code&gt;globals&lt;/code&gt; и &lt;code&gt;locals&lt;/code&gt; которые показывают содержимое двух этих пространств имен.</target>
        </trans-unit>
        <trans-unit id="66f53662b40fee705c6cf869f8862a3f0af7508c" translate="yes" xml:space="preserve">
          <source>There must be a simple reference or algorithm somewhere.  It's a confusing world for intermediate Python programmers.</source>
          <target state="translated">Где-то должна быть простая ссылка или алгоритм.Это запутанный мир для программистов-промежуточных Python.</target>
        </trans-unit>
        <trans-unit id="dc197e05c0a632bbe533e1fc9cc6179dbe36858f" translate="yes" xml:space="preserve">
          <source>There was no thorough answer concerning Python3 time, so I made an answer here. Most of what is described here is detailed in the &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;4.2.2 Resolution of names&lt;/a&gt; of the Python 3 documentation.</source>
          <target state="translated">Там не было никакого подробного ответа относительно времени Python3, поэтому я сделал ответ здесь. Большая часть того, что описано здесь, подробно описана в разделе &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;4.2.2 Разрешение имен&lt;/a&gt; документации Python 3.</target>
        </trans-unit>
        <trans-unit id="a99a7f033c4ec910190127fe5239538d99412265" translate="yes" xml:space="preserve">
          <source>This also is possible even if it was shadowed in enclosing scope:</source>
          <target state="translated">Это также возможно,даже если оно было затенено в ограждающем прицеле:</target>
        </trans-unit>
        <trans-unit id="7d7b9be324dd796904b34f5106809953d41f6197" translate="yes" xml:space="preserve">
          <source>This behaviour has been fixed in Python 3 - no comprehension expressions or generators leak variables.</source>
          <target state="translated">Это поведение было исправлено на Python 3-никаких выражений понимания или переменных утечки генераторов.</target>
        </trans-unit>
        <trans-unit id="87022636f054df4ffc1ead1749bf1e9c7e728e13" translate="yes" xml:space="preserve">
          <source>Thus unlike in function body, you can reassign the variable to the same name in class body, to get a class variable with the same name; further lookups on this name resolve
to the class variable instead.</source>
          <target state="translated">Таким образом,в теле функции,в отличие от тела функции,можно переназначить переменную с тем же именем в теле класса,чтобы получить переменную класса с тем же именем;в дальнейшем поиск по этому имени разрешается в переменную класса вместо этого.</target>
        </trans-unit>
        <trans-unit id="c10493d5c8fd991112f0f5a007908a58dcf71274" translate="yes" xml:space="preserve">
          <source>To demonstrate the peculiarities of the class body</source>
          <target state="translated">Для демонстрации особенностей тела класса</target>
        </trans-unit>
        <trans-unit id="1ec4a888c88d98357bd2355b16e9d2ee0d98401c" translate="yes" xml:space="preserve">
          <source>Variables in scopes other than the local function's variables can be accessed, but can't be rebound to new parameters without further syntax.  Instead, assignment will create a new &lt;strong&gt;local&lt;/strong&gt; variable instead of affecting the variable in the parent scope.  For example:</source>
          <target state="translated">Переменные в областях, кроме переменных локальной функции, могут быть доступны, но не могут быть связаны с новыми параметрами без дополнительного синтаксиса. Вместо этого присваивание создаст новую &lt;strong&gt;локальную&lt;/strong&gt; переменную вместо того, чтобы воздействовать на переменную в родительской области. Например:</target>
        </trans-unit>
        <trans-unit id="ee59b3c6c46ff5b1167d076e20e42bc9f718a1a0" translate="yes" xml:space="preserve">
          <source>What &lt;strong&gt;exactly&lt;/strong&gt; are the Python scoping rules?</source>
          <target state="translated">Каковы точные правила Python?</target>
        </trans-unit>
        <trans-unit id="e5d36aed6ed1fa3b08d655991945340186892707" translate="yes" xml:space="preserve">
          <source>Where is &lt;code&gt;x&lt;/code&gt; found?  Some possible choices include the list below:</source>
          <target state="translated">Где &lt;code&gt;x&lt;/code&gt; найден? Некоторые возможные варианты включают список ниже:</target>
        </trans-unit>
        <trans-unit id="9ceaf19971bdc05e03243ab1bad8110fc5d0ed96" translate="yes" xml:space="preserve">
          <source>Where is x found?</source>
          <target state="translated">Где Икс найден?</target>
        </trans-unit>
        <trans-unit id="3aeb7e91ed96df6d7f81bbb0e1551a8531c67024" translate="yes" xml:space="preserve">
          <source>any variable that is assigned a value is local to the block in which
  the assignment appears.</source>
          <target state="translated">любая переменная,которой присваивается значение,является локальной для блока,в котором появляется присваивание.</target>
        </trans-unit>
        <trans-unit id="63066c351b344d3122b8c8f4b46ea52b390be1db" translate="yes" xml:space="preserve">
          <source>code2 (class members) aren't visible to code inside methods of the same class&amp;thinsp;&amp;mdash;&amp;thinsp;you would usually access them using self. code4/code5 (loops) live in the same scope as code3, so if you wrote to x in there you would be changing the x instance defined in code3, not making a new x.</source>
          <target state="translated">code2 (члены класса) не видны для кода внутри методов одного и того же класса - вы обычно получаете к ним доступ, используя self. code4 / code5 (циклы) находятся в той же области видимости, что и code3, поэтому, если вы записали туда x, вы бы изменили экземпляр x, определенный в code3, а не создавали новый x.</target>
        </trans-unit>
        <trans-unit id="cc6ec69a6efab094133defe38aae1e3d60c488d6" translate="yes" xml:space="preserve">
          <source>fun3 sees the instance x from the nearest containing scope, which is the function scope associated with fun2. But the other x instances, defined in fun1 and globally, are not affected.</source>
          <target state="translated">fun3 видит экземпляр x из ближайшей содержащей области видимости,которая является областью видимости функции,связанной с fun2.Но другие экземпляры x,определенные в fun1 и глобально,не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="58ea49680b324ab3ca71332dbc3414bb1ebdb589" translate="yes" xml:space="preserve">
          <source>i.e. &lt;code&gt;nonlocal&lt;/code&gt; always refers to the innermost outer non-global scope where the name has been bound (i.e. assigned to, including used as the &lt;code&gt;for&lt;/code&gt; target variable, in the &lt;code&gt;with&lt;/code&gt; clause, or as a function parameter).</source>
          <target state="translated">то есть &lt;code&gt;nonlocal&lt;/code&gt; всегда относится к самой внутренней внешней неглобальной области, где имя было связано (то есть назначено, в том числе используется в качестве целевой переменной, в предложении &lt;code&gt;with&lt;/code&gt; или в качестве параметра функции).</target>
        </trans-unit>
        <trans-unit id="da2bcfabde892b5bb52d9d550d0458eca4faf08a" translate="yes" xml:space="preserve">
          <source>lambda is no different to def. If you have a lambda used inside a function, it's the same as defining a nested function. In Python 2.2 onwards, nested scopes are available. In this case you can bind x at any level of function nesting and Python will pick up the innermost instance:</source>
          <target state="translated">лямбда ничем не отличается от Def.Если лямбда используется внутри функции,это то же самое,что и определение вложенной функции.На Python 2.2 и далее доступны вложенные диапазоны.В этом случае вы можете связать x на любом уровне функции гнездования,и Python подберет самый внутренний экземпляр:</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="d501ea9d1210349ed22ada10ec53a89a01499008" translate="yes" xml:space="preserve">
          <source>spam's scope - containing everything defined in code3 and code5 (as well as code4, your loop variable)</source>
          <target state="translated">Область действия спама-содержит все,что определено в коде3 и коде5 (а также в коде4,переменной цикла).</target>
        </trans-unit>
        <trans-unit id="b3b90f9cae4e8e26b4024f88a8f592ef96cb8712" translate="yes" xml:space="preserve">
          <source>x is not found as you haven't defined it. :-) It could be found in code1 (global) or code3 (local) if you put it there.</source>
          <target state="translated">x не найден,так как вы его не определили.:-)Он может быть найден в коде1 (global)или коде3 (local),если его туда поместить.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
