<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/291978">
    <body>
      <group id="291978">
        <trans-unit id="2e5ea5b373efb0a978388bcda9efa3c4e5c03c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; will never be found in &lt;code&gt;code2&lt;/code&gt; (even in cases where you might expect it would, see &lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;Antti's answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 永远不会在 &lt;code&gt;code2&lt;/code&gt; 中找到（即使在您可能期望的情况下，请参阅&lt;a href=&quot;https://stackoverflow.com/a/23471004/2810305&quot;&gt;Antti的答案&lt;/a&gt;或&lt;a href=&quot;https://stackoverflow.com/q/13905741/2810305&quot;&gt;此处&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="844b4071ade54e31a272636444a86d27dbf60eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B&lt;/strong&gt;uilt-in (Python) &amp;mdash; Names preassigned in the built-in names module: &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;SyntaxError&lt;/code&gt;, etc</source>
          <target state="translated">内置（Python）-在内置名称模块中预先分配的名称： &lt;code&gt;open&lt;/code&gt; ， &lt;code&gt;range&lt;/code&gt; ， &lt;code&gt;SyntaxError&lt;/code&gt; 等</target>
        </trans-unit>
        <trans-unit id="97299d3c668df1ab4082a55faa649fd2528112b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;nclosing-function &amp;mdash; Names assigned in the local scope of any and all statically enclosing functions (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), from inner to outer</source>
          <target state="translated">&lt;strong&gt;E&lt;/strong&gt; nclosing-function &amp;mdash;在任何和所有静态封闭函数（ &lt;code&gt;def&lt;/code&gt; 或 &lt;code&gt;lambda&lt;/code&gt; ）的本地范围内从内部到外部分配的名称</target>
        </trans-unit>
        <trans-unit id="cfb38a37b33062a0dac44099257bd4a65386ac18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;lobal (module) &amp;mdash; Names assigned at the top-level of a module file, or by executing a &lt;code&gt;global&lt;/code&gt; statement in a &lt;code&gt;def&lt;/code&gt; within the file</source>
          <target state="translated">全球（模块）&amp;mdash;在模块文件的顶级分配的名称，或通过在文件内的 &lt;code&gt;def&lt;/code&gt; 中执行 &lt;code&gt;global&lt;/code&gt; 语句来分配的名称</target>
        </trans-unit>
        <trans-unit id="778d2680a013b2b927bbd42cf4dbd8f8e603daa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;L&lt;/strong&gt;ocal &amp;mdash; Names assigned in any way within a function (&lt;code&gt;def&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;), and not declared global in that function</source>
          <target state="translated">&lt;strong&gt;L&lt;/strong&gt; ocal &amp;mdash;在函数内以任何方式分配的名称（ &lt;code&gt;def&lt;/code&gt; 或 &lt;code&gt;lambda&lt;/code&gt; ），但未在该函数中声明为全局</target>
        </trans-unit>
        <trans-unit id="5277f4fac12d44eb629e5c22b7e1d8094c037eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LEGB Rule&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;LEGB规则&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8fbc1e546684b1d340d4bb068e765dfcdfb7254c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restrictions:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Restrictions:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e9af317e5a414fef2826cb666d4e978c26801dd" translate="yes" xml:space="preserve">
          <source>A slightly more complete example of scope:</source>
          <target state="translated">稍微完整的范围体例。</target>
        </trans-unit>
        <trans-unit id="3eacc2675a7bf748ffe69c0804238499bf0a642c" translate="yes" xml:space="preserve">
          <source>Actually, a concise rule for Python Scope resolution, from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;Learning Python, 3rd. Ed.&lt;/a&gt;. (These rules are specific to variable names, not attributes. If you reference it without a period, these rules apply.)</source>
          <target state="translated">实际上，这是&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596513984&quot;&gt;学习Python的第3条&lt;/a&gt;关于Python范围解析的简明规则。 埃德 。 （这些规则特定于变量名，而不是属性。如果不加句点引用，则适用这些规则。）</target>
        </trans-unit>
        <trans-unit id="b9b84618b4dc87a1c871237cbcae8ef234da18b5" translate="yes" xml:space="preserve">
          <source>Also there is the context during execution, when the function &lt;code&gt;spam&lt;/code&gt; is passed somewhere else. And maybe &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;lambda functions&lt;/a&gt; pass a bit differently?</source>
          <target state="translated">当功能 &lt;code&gt;spam&lt;/code&gt; 传递到其他地方时，执行期间还会有上下文。 也许&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions&quot;&gt;lambda函数&lt;/a&gt;传递的方式有所不同？</target>
        </trans-unit>
        <trans-unit id="2b234758bd81a7c9bf0560b3b0aec62418bf437f" translate="yes" xml:space="preserve">
          <source>An object (an instance of a class) has instance variables.  These names are in the object's namespace.  They must be qualified by the object.  (&lt;code&gt;variable.instance&lt;/code&gt;.)</source>
          <target state="translated">对象（类的实例）具有实例变量。 这些名称位于对象的名称空间中。 它们必须由对象限定。 （ &lt;code&gt;variable.instance&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="edd9da0852ea07205aefc7b6ee60189bd45f1905" translate="yes" xml:space="preserve">
          <source>Any variable that is not deemed to be local to the current scope, or any enclosing scope, is a global variable. A global name is looked up in the module global dictionary; if not found, the global is then looked up from the builtins module; the name of the module was changed from python 2 to python 3; in python 2 it was &lt;code&gt;__builtin__&lt;/code&gt; and in python 3 it is now called &lt;code&gt;builtins&lt;/code&gt;. If you assign to an attribute of builtins module, it will be visible thereafter to any module as a readable global variable, unless that module shadows them with its own global variable with the same name.</source>
          <target state="translated">任何不被视为当前作用域或任何封闭作用域局部变量的变量都是全局变量。 在模块全局词典中查找全局名称； 如果找不到，则从内建模块中查找全局变量； 模块的名称从python 2更改为python 3; 在python 2中，它是 &lt;code&gt;__builtin__&lt;/code&gt; ,而在python 3中，它现在称为 &lt;code&gt;builtins&lt;/code&gt; 。 如果分配给buildins模块的属性，此后它将以可读的全局变量的形式对任何模块可见，除非该模块用自己的同名全局变量遮盖它们。</target>
        </trans-unit>
        <trans-unit id="5e4660e77d407e9b103ce4b6048d3ef22738c691" translate="yes" xml:space="preserve">
          <source>As provided in other answers, there are 4 basic scopes, the LEGB, for Local, Enclosing, Global and Builtin. In addition to those, there is a special scope, the &lt;strong&gt;class body&lt;/strong&gt;, which does not comprise an enclosing scope for methods defined within the class; any assignments within the class body make the variable from there on be bound in the class body.</source>
          <target state="translated">如其他答案中所提供的，本地，封闭，全局和内置有4个基本范围，即LEGB。 除此以外，还有一个特殊的范围，即&lt;strong&gt;类主体&lt;/strong&gt; ，它不包括该类中定义的方法的封闭范围。 类主体中的任何赋值都会使变量从此绑定到类主体中。</target>
        </trans-unit>
        <trans-unit id="77587594047610e85f49724453d7e1697738b9e3" translate="yes" xml:space="preserve">
          <source>At any time during execution, there
  are at least three nested scopes whose
  namespaces are directly accessible:
  the innermost scope, which is searched
  first, contains the local names; the
  namespaces of any enclosing functions,
  which are searched starting with the
  nearest enclosing scope; the middle
  scope, searched next, contains the
  current module's global names; and the
  outermost scope (searched last) is the
  namespace containing built-in names.</source>
          <target state="translated">在执行过程中的任何时候,至少有三个嵌套的作用域,其命名空间是可以直接访问的:最内侧的作用域,首先被搜索的是本地名;任何包围函数的命名空间,从最近的包围作用域开始搜索;中间的作用域,下一个被搜索的是当前模块的全局名;最外侧的作用域(最后一个被搜索的)是包含内置名的命名空间。</target>
        </trans-unit>
        <trans-unit id="949db5aedd1359c2910fdcddc532ee3920954144" translate="yes" xml:space="preserve">
          <source>B: Any builtin &lt;code&gt;x&lt;/code&gt; in Python.</source>
          <target state="translated">B：Python中的任何内置 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94f58ad3d39e723cd41ed035c3fc63eb570fe299" translate="yes" xml:space="preserve">
          <source>Before nested_scopes&amp;thinsp;&amp;mdash;&amp;thinsp;in Python pre-2.1, and in 2.1 unless you specifically ask for the feature using a from-future-import&amp;thinsp;&amp;mdash;&amp;thinsp;fun1 and fun2's scopes are not visible to fun3, so S.Lott's answer holds and you would get the global x:</source>
          <target state="translated">在nested_scopes之前（在Python 2.1之前的版本中以及在2.1中，除非您特别使用from-future-import要求功能），fun1和fun2的作用域对fun3不可见，因此S.Lott的答案成立，您将获得全局x ：</target>
        </trans-unit>
        <trans-unit id="ccabba569adb4497369de2ec7d4f33e75f0e6878" translate="yes" xml:space="preserve">
          <source>Currently there is no way to do the same for variables in enclosing &lt;em&gt;function&lt;/em&gt; scopes, but Python 3 introduces a new keyword, &quot;&lt;code&gt;nonlocal&lt;/code&gt;&quot; which will act in a similar way to global, but for nested function scopes.</source>
          <target state="translated">当前，对于封闭&lt;em&gt;函数&lt;/em&gt;范围内的变量，尚无办法做到这一点，但是Python 3引入了一个新关键字&amp;ldquo; &lt;code&gt;nonlocal&lt;/code&gt; &amp;rdquo;，其作用类似于全局变量，但适用于嵌套函数范围。</target>
        </trans-unit>
        <trans-unit id="685a7a88c4d863000bc56afa13ac95aae11160f0" translate="yes" xml:space="preserve">
          <source>E: Any enclosing functions (if the whole example were in another &lt;code&gt;def&lt;/code&gt;)</source>
          <target state="translated">E：任何封闭函数（如果整个示例在另一个 &lt;code&gt;def&lt;/code&gt; 中 ）</target>
        </trans-unit>
        <trans-unit id="3091bb32545b1f507703c4fcd6455ca21eb171a8" translate="yes" xml:space="preserve">
          <source>EDIT: Here's the &lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt; with more information on this.</source>
          <target state="translated">编辑：这是&lt;a href=&quot;http://www.python.org/dev/peps/pep-3104/&quot;&gt;PEP&lt;/a&gt; ，对此有更多信息。</target>
        </trans-unit>
        <trans-unit id="5067e65f592d1333460adda9fda56628aeffb64e" translate="yes" xml:space="preserve">
          <source>Especially, &lt;strong&gt;no&lt;/strong&gt; block statement, besides &lt;code&gt;def&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;, create a variable scope. In Python 2 a list comprehension does not create a variable scope, however in Python 3 the loop variable within list comprehensions is created in a new scope.</source>
          <target state="translated">特别是，除了 &lt;code&gt;def&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; 之外， &lt;strong&gt;没有任何&lt;/strong&gt;块语句创建变量作用域。 在Python 2中，列表推导不会创建变量作用域，但是在Python 3中，列表推导内的循环变量是在新作用域中创建的。</target>
        </trans-unit>
        <trans-unit id="4360b38ce6fca6533891aa6402e815f6de882ee8" translate="yes" xml:space="preserve">
          <source>Essentially, the only thing in Python that introduces a new scope is a function definition.  Classes are a bit of a special case in that anything defined directly in the body is placed in the class's namespace, but they are not directly accessible from within the methods (or nested classes) they contain.</source>
          <target state="translated">本质上,Python中唯一引入新作用域的东西就是函数定义。类是一个有点特殊的情况,因为直接在类的主体中定义的任何东西都被放置在类的命名空间中,但它们不能从它们所包含的方法 (或嵌套类)中直接访问。</target>
        </trans-unit>
        <trans-unit id="3454040cf44b56303faa3532297c412240cf336a" translate="yes" xml:space="preserve">
          <source>From within a class method, you have locals and globals.  You say &lt;code&gt;self.variable&lt;/code&gt; to pick the instance as the namespace.  You'll note that &lt;code&gt;self&lt;/code&gt; is an argument to every class member function, making it part of the local namespace.</source>
          <target state="translated">在类方法中，您具有局部变量和全局变量。 您说使用 &lt;code&gt;self.variable&lt;/code&gt; 将实例选择为名称空间。 您会注意到 &lt;code&gt;self&lt;/code&gt; 是每个类成员函数的参数，使其成为本地名称空间的一部分。</target>
        </trans-unit>
        <trans-unit id="7664a9e609e66bc2d00fa363b667ab4f2f1fefff" translate="yes" xml:space="preserve">
          <source>G: Were there any &lt;code&gt;x&lt;/code&gt; declared globally in the module (in &lt;code&gt;code1&lt;/code&gt;)?</source>
          <target state="translated">G：模块（在 &lt;code&gt;code1&lt;/code&gt; 中 ）是否全局声明了 &lt;code&gt;x&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="1d87f06cf14aca3bd4a191b57670565bfad952c1" translate="yes" xml:space="preserve">
          <source>Global is -- well -- global.</source>
          <target state="translated">全球是 ----嗯 ----全球。</target>
        </trans-unit>
        <trans-unit id="5e8b57f9b5edca1d505a9498465cdf117eedf409" translate="yes" xml:space="preserve">
          <source>However in python 3, the &lt;code&gt;nonlocal&lt;/code&gt; comes to rescue:</source>
          <target state="translated">但是在python 3中， &lt;code&gt;nonlocal&lt;/code&gt; 可以挽救：</target>
        </trans-unit>
        <trans-unit id="489c4eee2e8a8e18d94f2c3c5b9d39e4ba2a71d9" translate="yes" xml:space="preserve">
          <source>If I have some code:</source>
          <target state="translated">如果我有一些代码。</target>
        </trans-unit>
        <trans-unit id="3f0b2cb298d97b428d9e6a5814ab14829603d125" translate="yes" xml:space="preserve">
          <source>If a name is ever assigned to in the current scope (except in the class scope), it will be considered belonging to that scope, otherwise it will be considered to belonging to any enclosing scope that assigns to the variable (it might not be assigned yet, or not at all), or finally the global scope. If the variable is considered local, but it is not set yet, or has been deleted, reading the variable value will result in &lt;code&gt;UnboundLocalError&lt;/code&gt;, which is a subclass of &lt;code&gt;NameError&lt;/code&gt;.</source>
          <target state="translated">如果在当前作用域中分配了名称（在类作用域中除外），则该名称将被视为属于该作用域，否则将被视为属于任何分配给该变量的封闭作用域（可能未分配）然而，或者根本没有），或者最后是全球范围。 如果将变量视为本地变量，但尚未设置或已删除，则读取变量值将导致 &lt;code&gt;UnboundLocalError&lt;/code&gt; ，它是 &lt;code&gt;NameError&lt;/code&gt; 的子类。</target>
        </trans-unit>
        <trans-unit id="d536a4e1d312f0bb4a36c7db71be18f86a0595ec" translate="yes" xml:space="preserve">
          <source>If a variable can't be found in the current scope, please refer to the LEGB order.</source>
          <target state="translated">如果在当前范围内找不到变量,请参考LEGB订单。</target>
        </trans-unit>
        <trans-unit id="594e2207a906c678397d7ca8b95cf26be8bec159" translate="yes" xml:space="preserve">
          <source>In Python,</source>
          <target state="translated">在Python中。</target>
        </trans-unit>
        <trans-unit id="daa6bf94be3ef37adbff56bb43caa58be32ae290" translate="yes" xml:space="preserve">
          <source>In order to actually modify the bindings of global variables from within a function scope, you need to specify that the variable is global with the global keyword.  Eg:</source>
          <target state="translated">为了在函数范围内实际修改全局变量的绑定,需要用全局关键字指定该变量为全局变量。例如</target>
        </trans-unit>
        <trans-unit id="0bc6e3d84d0a49e5ed2803b53b300500f65ae44e" translate="yes" xml:space="preserve">
          <source>In python 2 there is no easy way to modify the value in the enclosing scope; usually this is simulated by having a mutable value, such as a list with length of 1:</source>
          <target state="translated">在python 2中,没有简单的方法来修改包围范围中的值;通常是通过一个可变值来模拟,比如一个长度为1的列表。</target>
        </trans-unit>
        <trans-unit id="286079d30426b3322fda99d492f07b15340885cb" translate="yes" xml:space="preserve">
          <source>In the class namespace</source>
          <target state="translated">在类命名空间中</target>
        </trans-unit>
        <trans-unit id="28d8f315b0ed9313fc78b3f5380fd9a3257f9305" translate="yes" xml:space="preserve">
          <source>In the enclosing source file</source>
          <target state="translated">在附带的源文件中</target>
        </trans-unit>
        <trans-unit id="ca0a0838b052bc29ab825218ced55d4acd83b7c4" translate="yes" xml:space="preserve">
          <source>In the for loop index variable</source>
          <target state="translated">在for循环索引变量中</target>
        </trans-unit>
        <trans-unit id="61e7200f1f6a388923daba14399fca3fa229c76d" translate="yes" xml:space="preserve">
          <source>In the function definition</source>
          <target state="translated">在函数定义中</target>
        </trans-unit>
        <trans-unit id="a677829300682f1c31d8905cb2e5282167c47489" translate="yes" xml:space="preserve">
          <source>In this case, the call to a function named &lt;code&gt;x&lt;/code&gt; has to be resolved in the local name space or the global namespace.</source>
          <target state="translated">在这种情况下，必须在本地名称空间或全局名称空间中解析对名为 &lt;code&gt;x&lt;/code&gt; 的函数的调用。</target>
        </trans-unit>
        <trans-unit id="df991876b5a88f673697607e52e60c6b1c9b6fe4" translate="yes" xml:space="preserve">
          <source>In your example there are only 3 scopes where x will be searched in:</source>
          <target state="translated">在你的例子中,只有3个范围,其中x将被搜索到。</target>
        </trans-unit>
        <trans-unit id="b22ee2fbcc9bb471eb4de6b0b6be177886173cac" translate="yes" xml:space="preserve">
          <source>Inside a class definition, the names are part of the class namespace.  &lt;code&gt;code2&lt;/code&gt;, for instance, must be qualified by the class name.  Generally &lt;code&gt;Foo.code2&lt;/code&gt;.  However, &lt;code&gt;self.code2&lt;/code&gt; will also work because Python objects look at the containing class as a fall-back.</source>
          <target state="translated">在类定义中，名称是类名称空间的一部分。 例如， &lt;code&gt;code2&lt;/code&gt; 必须由类名限定。 通常是 &lt;code&gt;Foo.code2&lt;/code&gt; 。 但是， &lt;code&gt;self.code2&lt;/code&gt; 也将起作用，因为Python对象将包含类视为后备。</target>
        </trans-unit>
        <trans-unit id="09981edc13a0ed704530d39e42b44aa50109ee99" translate="yes" xml:space="preserve">
          <source>Inside the for loop</source>
          <target state="translated">在for循环内</target>
        </trans-unit>
        <trans-unit id="e0e03b34b38a81e2a7f53f8a81459fc2d617f237" translate="yes" xml:space="preserve">
          <source>L: Local in &lt;code&gt;def spam&lt;/code&gt; (in &lt;code&gt;code3&lt;/code&gt;, &lt;code&gt;code4&lt;/code&gt;, and &lt;code&gt;code5&lt;/code&gt;)</source>
          <target state="translated">L：本地 &lt;code&gt;def spam&lt;/code&gt; （在 &lt;code&gt;code3&lt;/code&gt; ， &lt;code&gt;code4&lt;/code&gt; 和 &lt;code&gt;code5&lt;/code&gt; 中 ）</target>
        </trans-unit>
        <trans-unit id="e92d705ad99ad05765b1551d9ea147eb1bdeda13" translate="yes" xml:space="preserve">
          <source>Local in this case, is the body of the method function &lt;code&gt;Foo.spam&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，本地方法方法函数 &lt;code&gt;Foo.spam&lt;/code&gt; 的主体 。</target>
        </trans-unit>
        <trans-unit id="9239d3c1c8dfe483cc92d0d056245b45330b191b" translate="yes" xml:space="preserve">
          <source>More scopes only appear when you introduce a nested function (or lambda) into the picture.
These will behave pretty much as you'd expect however.  The nested function can access everything in the local scope, as well as anything in the enclosing function's scope. eg.</source>
          <target state="translated">只有当你将嵌套函数(或 lambda)引入到图片中时,才会出现更多的作用域。但是,这些作用域的表现和你所期望的差不多。嵌套函数可以访问本地作用域中的一切,也可以访问包围函数作用域中的任何东西。</target>
        </trans-unit>
        <trans-unit id="27da1baa1c8ced7550e55368c36e9a711d3e6fa3" translate="yes" xml:space="preserve">
          <source>Names listed in a nonlocal statement, unlike those listed in a global statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously).</source>
          <target state="translated">在非本地语句中列出的名称,与在全局语句中列出的名称不同,必须指的是在一个包围的范围内已经存在的绑定(不能明确地确定应该在哪个范围内创建一个新的绑定)。</target>
        </trans-unit>
        <trans-unit id="28b769433b63849ac3d6dd68d58b2953ccbd4282" translate="yes" xml:space="preserve">
          <source>Namespaces are created by packages, modules, classes, object construction and functions.  There aren't any other flavors of namespaces.</source>
          <target state="translated">命名空间是由包、模块、类、对象构造和函数创建的。命名空间没有任何其他口味的名称空间。</target>
        </trans-unit>
        <trans-unit id="beb5b3eceb0aafb4ddd706656bbfc7ee6baaddbe" translate="yes" xml:space="preserve">
          <source>One of the greater surprises to many newcomers to Python is that a &lt;code&gt;for&lt;/code&gt; loop does not create a variable scope. In Python 2 the list comprehensions do not create a scope either (while generators and dict comprehensions do!) Instead they leak the value in the function or the global scope:</source>
          <target state="translated">对于许多使用Python的新手来说，最大的惊喜之一是 &lt;code&gt;for&lt;/code&gt; 循环不会创建变量范围。 在Python 2中，列表推导也不创建作用域（而generator和dict推定会创建作用域）。相反，它们会泄漏函数或全局范围中的值：</target>
        </trans-unit>
        <trans-unit id="12ce7bda1dda1b2c962ca66689c2785500bf04ad" translate="yes" xml:space="preserve">
          <source>Python is statically scoped, so if you pass &amp;lsquo;spam&amp;rsquo; to another function spam will still have access to globals in the module it came from (defined in code1), and any other containing scopes (see below). code2 members would again be accessed through self.</source>
          <target state="translated">Python是静态作用域的，因此，如果您将&amp;ldquo;垃圾邮件&amp;rdquo;传递给另一个函数，则垃圾邮件仍可以访问它来自的模块（在code1中定义）以及任何其他包含范围的全局变量（请参见下文）。 code2成员将再次通过self访问。</target>
        </trans-unit>
        <trans-unit id="ca50994c79187618aaa08a98a101ea8024bec937" translate="yes" xml:space="preserve">
          <source>Python resolves your variables with -- generally -- three namespaces available.</source>
          <target state="translated">Python 用 ----一般来说 ----三个可用的命名空间来解析你的变量。</target>
        </trans-unit>
        <trans-unit id="db64c8c2222f51f190901bd1ac7f77cfbca7a5eb" translate="yes" xml:space="preserve">
          <source>Reading the builtin module can also be useful; suppose that you want the python 3 style print function in some parts of file, but other parts of file still use the &lt;code&gt;print&lt;/code&gt; statement. In Python 2.6-2.7 you can get hold of the Python 3 &lt;code&gt;print&lt;/code&gt; function with:</source>
          <target state="translated">读取内置模块也很有用； 假设您希望在文件的某些部分使用python 3样式的打印功能，但文件的其他部分仍使用 &lt;code&gt;print&lt;/code&gt; 语句。 在Python 2.6-2.7中，您可以使用以下命令来掌握Python 3的 &lt;code&gt;print&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="5b5d18222e29afa718228e26345659e72bb55bf1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Python Scope Rules&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Python Scope&lt;/a&gt;, &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;Variable Scope&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html&quot;&gt;Python作用域规则&lt;/a&gt; ， &lt;a href=&quot;https://stackoverflow.com/questions/146359/python-scope&quot;&gt;Python作用域&lt;/a&gt; ， &lt;a href=&quot;http://showmedo.com/videos/video?name=2800020&amp;amp;fromSeriesID=280&quot;&gt;变量作用域&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8c6e2463ee152af10c825b92902e29b53188a0e" translate="yes" xml:space="preserve">
          <source>Short description of the scoping rules</source>
          <target state="translated">关于范围界定规则的简要说明</target>
        </trans-unit>
        <trans-unit id="4137ae49ea23b49b8aded44e40cc20f03153e5ea" translate="yes" xml:space="preserve">
          <source>So, in the case of</source>
          <target state="translated">因此,在</target>
        </trans-unit>
        <trans-unit id="c1f5b7fd34b0297627287f84737d24abc3aef183" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt;&lt;code&gt;nonlocal&lt;/code&gt; documentation&lt;/a&gt; says that</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement&quot;&gt; &lt;code&gt;nonlocal&lt;/code&gt; 文档&lt;/a&gt;说</target>
        </trans-unit>
        <trans-unit id="f37cfe501f6b493322c7adbc4648321534c77ec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop does not have its own namespace. In LEGB order, the scopes would be</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 循环没有自己的名称空间。 按照LEGB顺序，范围为</target>
        </trans-unit>
        <trans-unit id="3f202f06df9b6796d66908f7d06c0fb4a5dba2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from __future__ import print_function&lt;/code&gt; actually does not import the &lt;code&gt;print&lt;/code&gt; function anywhere in Python 2 - instead it just disables the parsing rules for &lt;code&gt;print&lt;/code&gt; statement in the current module, handling &lt;code&gt;print&lt;/code&gt; like any other variable identifier, and thus allowing the &lt;code&gt;print&lt;/code&gt; the function be looked up in the builtins.</source>
          <target state="translated">实际上， &lt;code&gt;from __future__ import print_function&lt;/code&gt; 不会在Python 2中的任何地方导入 &lt;code&gt;print&lt;/code&gt; 函数-而是仅禁用当前模块中 &lt;code&gt;print&lt;/code&gt; 语句的解析规则，像处理其他任何变量标识符一样处理 &lt;code&gt;print&lt;/code&gt; ，从而允许查找 &lt;code&gt;print&lt;/code&gt; 函数在内置函数中。</target>
        </trans-unit>
        <trans-unit id="b852b61c52cf6abf12d94fe216923a1456609117" translate="yes" xml:space="preserve">
          <source>The builtins namespace.  A bit of a special case - this contains the various Python builtin functions and types such as len() and str(). Generally this shouldn't be modified by any user code, so expect it to contain the standard functions and nothing else.</source>
          <target state="translated">buildins 命名空间。有点特殊,它包含了各种 Python 内建的函数和类型,如 len()和 str()。一般来说,这个空间不应该被任何用户代码修改,所以希望它包含标准的函数,而不是其他。</target>
        </trans-unit>
        <trans-unit id="b666180107f3bb2a5459c2803fd6ec63d97c8a5f" translate="yes" xml:space="preserve">
          <source>The comprehensions can be used as a cunning (or awful if you will) way to make modifiable variables within lambda expressions in Python 2 - a lambda expression does create a variable scope, like the &lt;code&gt;def&lt;/code&gt; statement would, but within lambda no statements are allowed. Assignment being a statement in Python means that no variable assignments in lambda are allowed, but a list comprehension is an expression...</source>
          <target state="translated">理解可以用作在Python 2中的lambda表达式内创建可修改变量的一种狡猾（或者如果您愿意的话）的方法-lambda表达式确实会创建变量范围，就像 &lt;code&gt;def&lt;/code&gt; 语句一样，但是在lambda内不允许使用任何语句。 赋值是Python中的语句，表示不允许在lambda中进行变量赋值，但列表推导是一个表达式...</target>
        </trans-unit>
        <trans-unit id="d83d3f2e8e91a527bd523f95cb8e0b56a2f91f94" translate="yes" xml:space="preserve">
          <source>The global really means the module scope; the main python module is the &lt;code&gt;__main__&lt;/code&gt;; all imported modules are accessible through the &lt;code&gt;sys.modules&lt;/code&gt; variable; to get access to &lt;code&gt;__main__&lt;/code&gt; one can use &lt;code&gt;sys.modules['__main__']&lt;/code&gt;, or &lt;code&gt;import __main__&lt;/code&gt;; it is perfectly acceptable to access and assign attributes there; they will show up as variables in the global scope of the main module.</source>
          <target state="translated">全局实际上意味着模块范围； 主要的python模块是 &lt;code&gt;__main__&lt;/code&gt; ; 所有导入的模块都可以通过 &lt;code&gt;sys.modules&lt;/code&gt; 变量进行访问； 要访问 &lt;code&gt;__main__&lt;/code&gt; ,可以使用 &lt;code&gt;sys.modules['__main__']&lt;/code&gt; 或 &lt;code&gt;import __main__&lt;/code&gt; ； 完全可以在那里访问和分配属性； 它们将作为变量显示在主模块的全局范围内。</target>
        </trans-unit>
        <trans-unit id="ea88c84d8c2d8c0a30fbe73d16592805fd95c700" translate="yes" xml:space="preserve">
          <source>The global scope - containing everything defined in code1, as well as Foo (and whatever changes after it)</source>
          <target state="translated">全局范围-包含代码1中定义的所有内容,以及Foo(以及之后的任何变化)。</target>
        </trans-unit>
        <trans-unit id="5e3aea07bda301107941314511a14e18439bd4db" translate="yes" xml:space="preserve">
          <source>The rule is to search the nested local spaces created by method functions (and nested function definitions), then search global.  That's it.</source>
          <target state="translated">规则是先搜索方法函数创建的嵌套局部空间(以及嵌套函数定义),然后搜索全局。就这样。</target>
        </trans-unit>
        <trans-unit id="b2cef6f50c86efea01393fcf6254ce2bd0a1dedd" translate="yes" xml:space="preserve">
          <source>The scope can declare that it explicitly wants to modify the global (module scope) variable, with the global keyword:</source>
          <target state="translated">作用域可以用全局关键字声明它明确地要修改全局(模块作用域)变量。</target>
        </trans-unit>
        <trans-unit id="94b81dae7f5d26ac7081fc6ac0cbbd90734b62ef" translate="yes" xml:space="preserve">
          <source>The scoping rules for Python 2.x have been outlined already in other answers. The only thing I would add is that in Python 3.0, there is also the concept of a non-local scope (indicated by the 'nonlocal' keyword). This allows you to access outer scopes directly, and opens up the ability to do some neat tricks, including lexical closures (without ugly hacks involving mutable objects).</source>
          <target state="translated">Python 2.x 的作用域规则已经在其他答案中概述过了。我唯一想补充的是,在 Python 3.0 中,还有一个非本地作用域的概念 (用 'non-local' 关键字表示)。这让你可以直接访问外部作用域,并开放了一些整洁的技巧,包括词法闭包 (没有涉及到可变对象的丑陋的黑客)。</target>
        </trans-unit>
        <trans-unit id="01feb0417fe8dd53fe7a7458888a7cf55f38e6c5" translate="yes" xml:space="preserve">
          <source>There are no other scopes.  The &lt;code&gt;for&lt;/code&gt; statement (and other compound statements like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt;) don't create new nested scopes.  Only definitions (packages, modules, functions, classes and object instances.)</source>
          <target state="translated">没有其他范围。 &lt;code&gt;for&lt;/code&gt; 语句（以及其他复合语句，例如 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;try&lt;/code&gt; ）不会创建新的嵌套作用域。 仅定义（包，模块，函数，类和对象实例。）</target>
        </trans-unit>
        <trans-unit id="2c9bc52a6aab7f588fc16c4ea6fa447de217b0d0" translate="yes" xml:space="preserve">
          <source>There are two functions: &lt;code&gt;globals&lt;/code&gt; and &lt;code&gt;locals&lt;/code&gt; which show you the contents two of these namespaces.</source>
          <target state="translated">有两个函数： &lt;code&gt;globals&lt;/code&gt; 函数和 &lt;code&gt;locals&lt;/code&gt; 函数，向您显示这些命名空间中的两个内容。</target>
        </trans-unit>
        <trans-unit id="66f53662b40fee705c6cf869f8862a3f0af7508c" translate="yes" xml:space="preserve">
          <source>There must be a simple reference or algorithm somewhere.  It's a confusing world for intermediate Python programmers.</source>
          <target state="translated">一定有一个简单的引用或算法的地方。对于中级Python程序员来说,这是一个混乱的世界。</target>
        </trans-unit>
        <trans-unit id="dc197e05c0a632bbe533e1fc9cc6179dbe36858f" translate="yes" xml:space="preserve">
          <source>There was no thorough answer concerning Python3 time, so I made an answer here. Most of what is described here is detailed in the &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;4.2.2 Resolution of names&lt;/a&gt; of the Python 3 documentation.</source>
          <target state="translated">关于Python3时间，还没有详尽的答案，因此我在这里做了一个答案。 &lt;a href=&quot;https://docs.python.org/3/reference/executionmodel.html#resolution-of-names&quot;&gt;4.2.2&lt;/a&gt; Python 3文档名称的解析详细介绍了此处描述的大部分内容。</target>
        </trans-unit>
        <trans-unit id="a99a7f033c4ec910190127fe5239538d99412265" translate="yes" xml:space="preserve">
          <source>This also is possible even if it was shadowed in enclosing scope:</source>
          <target state="translated">这也是有可能的,即使是在包围式范围内的阴影,也是有可能的。</target>
        </trans-unit>
        <trans-unit id="7d7b9be324dd796904b34f5106809953d41f6197" translate="yes" xml:space="preserve">
          <source>This behaviour has been fixed in Python 3 - no comprehension expressions or generators leak variables.</source>
          <target state="translated">这种行为在Python 3中已被修复----没有理解表达式或生成器泄漏变量。</target>
        </trans-unit>
        <trans-unit id="87022636f054df4ffc1ead1749bf1e9c7e728e13" translate="yes" xml:space="preserve">
          <source>Thus unlike in function body, you can reassign the variable to the same name in class body, to get a class variable with the same name; further lookups on this name resolve
to the class variable instead.</source>
          <target state="translated">因此,与函数体中不同的是,在类体中,你可以将变量重新分配到相同的名称,以得到一个同名的类变量;在这个名称上的进一步查找,就会解析到这个类变量。</target>
        </trans-unit>
        <trans-unit id="c10493d5c8fd991112f0f5a007908a58dcf71274" translate="yes" xml:space="preserve">
          <source>To demonstrate the peculiarities of the class body</source>
          <target state="translated">展示班级主体的特殊性。</target>
        </trans-unit>
        <trans-unit id="1ec4a888c88d98357bd2355b16e9d2ee0d98401c" translate="yes" xml:space="preserve">
          <source>Variables in scopes other than the local function's variables can be accessed, but can't be rebound to new parameters without further syntax.  Instead, assignment will create a new &lt;strong&gt;local&lt;/strong&gt; variable instead of affecting the variable in the parent scope.  For example:</source>
          <target state="translated">可以访问除局部函数的变量之外的范围中的变量，但是如果没有进一步的语法，就不能将其反弹到新参数。 相反，赋值将创建一个新的&lt;strong&gt;局部&lt;/strong&gt;变量，而不是影响父作用域中的变量。 例如：</target>
        </trans-unit>
        <trans-unit id="ee59b3c6c46ff5b1167d076e20e42bc9f718a1a0" translate="yes" xml:space="preserve">
          <source>What &lt;strong&gt;exactly&lt;/strong&gt; are the Python scoping rules?</source>
          <target state="translated">Python范围规则&lt;strong&gt;到底&lt;/strong&gt;是什么？</target>
        </trans-unit>
        <trans-unit id="e5d36aed6ed1fa3b08d655991945340186892707" translate="yes" xml:space="preserve">
          <source>Where is &lt;code&gt;x&lt;/code&gt; found?  Some possible choices include the list below:</source>
          <target state="translated">在哪里找到 &lt;code&gt;x&lt;/code&gt; ？ 一些可能的选择包括以下列表：</target>
        </trans-unit>
        <trans-unit id="9ceaf19971bdc05e03243ab1bad8110fc5d0ed96" translate="yes" xml:space="preserve">
          <source>Where is x found?</source>
          <target state="translated">X在哪里找到的?</target>
        </trans-unit>
        <trans-unit id="3aeb7e91ed96df6d7f81bbb0e1551a8531c67024" translate="yes" xml:space="preserve">
          <source>any variable that is assigned a value is local to the block in which
  the assignment appears.</source>
          <target state="translated">任何被赋值的变量都是在赋值块中出现的本地变量。</target>
        </trans-unit>
        <trans-unit id="63066c351b344d3122b8c8f4b46ea52b390be1db" translate="yes" xml:space="preserve">
          <source>code2 (class members) aren't visible to code inside methods of the same class&amp;thinsp;&amp;mdash;&amp;thinsp;you would usually access them using self. code4/code5 (loops) live in the same scope as code3, so if you wrote to x in there you would be changing the x instance defined in code3, not making a new x.</source>
          <target state="translated">code2（类成员）对于相同类的方法内部的代码不可见-您通常可以使用self来访问它们。 code4 / code5（循环）的作用域与code3相同，因此，如果在其中写入x，则将更改code3中定义的x实例，而不创建新的x。</target>
        </trans-unit>
        <trans-unit id="cc6ec69a6efab094133defe38aae1e3d60c488d6" translate="yes" xml:space="preserve">
          <source>fun3 sees the instance x from the nearest containing scope, which is the function scope associated with fun2. But the other x instances, defined in fun1 and globally, are not affected.</source>
          <target state="translated">fun3从最近的包含作用域中看到实例x,也就是与fun2关联的函数作用域。但是其他的x实例,在fun1中定义的和全局的x实例并没有受到影响。</target>
        </trans-unit>
        <trans-unit id="58ea49680b324ab3ca71332dbc3414bb1ebdb589" translate="yes" xml:space="preserve">
          <source>i.e. &lt;code&gt;nonlocal&lt;/code&gt; always refers to the innermost outer non-global scope where the name has been bound (i.e. assigned to, including used as the &lt;code&gt;for&lt;/code&gt; target variable, in the &lt;code&gt;with&lt;/code&gt; clause, or as a function parameter).</source>
          <target state="translated">即， &lt;code&gt;nonlocal&lt;/code&gt; 始终是指已绑定名称的最里面的外部非全局范围（即，分配给它，包括用作 &lt;code&gt;for&lt;/code&gt; 目标变量， &lt;code&gt;with&lt;/code&gt; 子句中或用作函数参数）。</target>
        </trans-unit>
        <trans-unit id="da2bcfabde892b5bb52d9d550d0458eca4faf08a" translate="yes" xml:space="preserve">
          <source>lambda is no different to def. If you have a lambda used inside a function, it's the same as defining a nested function. In Python 2.2 onwards, nested scopes are available. In this case you can bind x at any level of function nesting and Python will pick up the innermost instance:</source>
          <target state="translated">lambda 和 def 没有什么不同,如果在函数内部使用 lambda,就等于定义了一个嵌套函数。在 Python 2.2 以后,嵌套作用域是可用的。在这种情况下,你可以在任意级别的函数嵌套中绑定x,Python会拿起最内层的实例。</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="d501ea9d1210349ed22ada10ec53a89a01499008" translate="yes" xml:space="preserve">
          <source>spam's scope - containing everything defined in code3 and code5 (as well as code4, your loop variable)</source>
          <target state="translated">spam的范围--包含代码3和代码5中定义的所有内容(以及代码4,你的循环变量)。</target>
        </trans-unit>
        <trans-unit id="b3b90f9cae4e8e26b4024f88a8f592ef96cb8712" translate="yes" xml:space="preserve">
          <source>x is not found as you haven't defined it. :-) It could be found in code1 (global) or code3 (local) if you put it there.</source>
          <target state="translated">没有找到x,因为你没有定义它。)如果你把代码1(全局)或代码3(本地)放在那里,就可以找到它。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
