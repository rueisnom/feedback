<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4176328">
    <body>
      <group id="4176328">
        <trans-unit id="8870c0b78d2f8c5d51c2bb94aca02172e8d812a0" translate="yes" xml:space="preserve">
          <source>(&amp;sect;1.9/15)
  The value computations of the operands of an
  operator are sequenced before the value computation of the result of the operator.</source>
          <target state="translated">（第1.9 / 15节）在对运算符的结果进行值计算之前，对运算符的操作数的值计算进行排序。</target>
        </trans-unit>
        <trans-unit id="f6789a34db8f60925945bcb624e1bf27596aee94" translate="yes" xml:space="preserve">
          <source>(&amp;sect;1.9/15) If a side effect on a scalar object is unsequenced relative to either</source>
          <target state="translated">（第1.9 / 15节）如果相对于任何一个标量对象的副作用未排序</target>
        </trans-unit>
        <trans-unit id="d03eca4ee881d6c9d172a41f36cf1e2dc14c6921" translate="yes" xml:space="preserve">
          <source>(a) &lt;strong&gt;another side effect on the same scalar object&lt;/strong&gt;</source>
          <target state="translated">（a） &lt;strong&gt;对同一标量对象的另一种副作用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7de31a37bbc3d2d1c7535de9aaa9a2d2c89665c2" translate="yes" xml:space="preserve">
          <source>(b) &lt;strong&gt;a value computation using the value of the same scalar object.&lt;/strong&gt;</source>
          <target state="translated">（b） &lt;strong&gt;使用相同标量对象的值进行值计算。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a37ce5427ff6266638bda82ba5addfaf1eddd932" translate="yes" xml:space="preserve">
          <source>1) &lt;strong&gt;Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression.&lt;/strong&gt;</source>
          <target state="translated">1） &lt;strong&gt;在上一个和下一个序列点之间，一个标量对象最多应通过表达式的计算修改其存储值。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c06988d3595ab2a28cd41d481cfaebc25ee10f2" translate="yes" xml:space="preserve">
          <source>2) &lt;strong&gt;Furthermore, the prior value shall be accessed only to determine the value to be stored.&lt;/strong&gt;</source>
          <target state="translated">2） &lt;strong&gt;此外，应仅访问先验值以确定要存储的值。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fda10bc0210ae7516d38ae8f60df65cb2be2b24a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a , b (&amp;sect;5.18)&lt;/code&gt; (here a , b is a comma operator; in &lt;code&gt;func(a,a++)&lt;/code&gt;&lt;code&gt;,&lt;/code&gt; is not a comma operator, it's merely a separator between the arguments &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a++&lt;/code&gt;. Thus the behaviour is undefined in that case (if &lt;code&gt;a&lt;/code&gt; is considered to be a primitive type))</source>
          <target state="translated">&lt;code&gt;a , b (&amp;sect;5.18)&lt;/code&gt; （这里a，b是逗号运算符；在 &lt;code&gt;func(a,a++)&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; 它不是逗号运算符，它只是参数 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;a++&lt;/code&gt; 之间的分隔符。因此在这种情况下，行为是不确定的（如果 &lt;code&gt;a&lt;/code&gt; 被认为是原始类型）</target>
        </trans-unit>
        <trans-unit id="5cbb99cfd67aa0ed7c9abf9fe32b9cb527dbb10e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int x;&lt;/code&gt;&lt;code&gt;x = 10;&lt;/code&gt;&lt;code&gt;++x;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int x;&lt;/code&gt; &lt;code&gt;x = 10;&lt;/code&gt; &lt;code&gt;++x;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a949dc1c9f550107654d74da78d5d42424053380" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;8.18 Assignment and compound assignment operators&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;8.18赋值和复合赋值运算符&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="9d069fa79ddd4f9f4141383dd0eca1d2590f65b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Asymmetric&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Asymmetric&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f52f520e63951b740474e846fac98e153b9acf9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++17&lt;/strong&gt; (&lt;code&gt;N4659&lt;/code&gt;) includes a proposal &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf&quot;&gt;Refining Expression Evaluation Order for Idiomatic C++&lt;/a&gt;
which defines a stricter order of expression evaluation.</source>
          <target state="translated">&lt;strong&gt;C ++ 17&lt;/strong&gt; （ &lt;code&gt;N4659&lt;/code&gt; ）包含一项提议， &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf&quot;&gt;用于&lt;/a&gt; 完善惯用 &lt;strong&gt;C ++的&lt;/strong&gt; 表达式评估顺序，该提案定义了更严格的表达式评估顺序。</target>
        </trans-unit>
        <trans-unit id="886ab1261d735f993b15c51c1bc58f5542846d90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt; : Okay. This answer is a bit long. So have patience while reading it. If you already know these things, reading them again won't make you crazy.</source>
          <target state="translated">&lt;strong&gt;免责声明&lt;/strong&gt; ：好的。 这个答案有点长。 因此阅读时要有耐心。 如果您已经知道这些事情，那么再次阅读它们不会使您发疯。</target>
        </trans-unit>
        <trans-unit id="2abc7e47d5ebbbf19c4348696e3073af038cb44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final Note&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;最后说明&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="e934205b4f3054922c2a5b8b6244db59ae5a2559" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Follow up answer for C++11 &lt;a href=&quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4183735#4183735&quot;&gt;here&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4183735#4183735&quot;&gt;在此处&lt;/a&gt;跟踪C ++ 11的答案。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="280bacf147f4332348859249dc18aef73052508a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pre-requisites&lt;/strong&gt; : An elementary knowledge of &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/&quot;&gt;C++ Standard&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;先决条件&lt;/strong&gt; ： &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/&quot;&gt;C ++标准&lt;/a&gt;的基础知识</target>
        </trans-unit>
        <trans-unit id="6a9f93a852c700a1f842b06c832daeaedac1a0df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pre-requisites&lt;/strong&gt; : An elementary knowledge of Relations (Mathematics).</source>
          <target state="translated">&lt;strong&gt;先决条件&lt;/strong&gt; ：关系（数学）基础知识。</target>
        </trans-unit>
        <trans-unit id="bb16d5b7f750e589aa8591dc2b0311cf94f000d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequence Points&lt;/strong&gt; have been replaced by &lt;strong&gt;Sequenced Before&lt;/strong&gt; and &lt;strong&gt;Sequenced After&lt;/strong&gt; (and &lt;strong&gt;Unsequenced&lt;/strong&gt; and &lt;strong&gt;Indeterminately Sequenced&lt;/strong&gt;) &lt;a href=&quot;http://en.wikipedia.org/wiki/Relation_(mathematics)&quot;&gt;relations&lt;/a&gt; in C++11.</source>
          <target state="translated">在C ++ 11中， &lt;strong&gt;序列点&lt;/strong&gt;已被&lt;strong&gt;序列化之前&lt;/strong&gt;和&lt;strong&gt;序列化之后的关系&lt;/strong&gt; （以及&lt;strong&gt;无&lt;/strong&gt; &lt;strong&gt;序列&lt;/strong&gt;和&lt;strong&gt;不确定序列的&lt;/strong&gt; ）取代。</target>
        </trans-unit>
        <trans-unit id="8d34bf4d70820266daeb2ec70d0a4d26cfd065ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequenced Before&lt;/strong&gt;&lt;sup&gt;(&amp;sect;1.9/13)&lt;/sup&gt; is a relation which is:</source>
          <target state="translated">&lt;strong&gt;排序之前&lt;/strong&gt; &lt;sup&gt;（第1.9 / 13节）&lt;/sup&gt;是一个关系：</target>
        </trans-unit>
        <trans-unit id="204dc21a36933167085eb6437592dd1d62d82250" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is a follow up to my &lt;a href=&quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4176333#4176333&quot;&gt;previous answer&lt;/a&gt; and contains C++11 related material.&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;这是我&lt;a href=&quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4176333#4176333&quot;&gt;之前的回答&lt;/a&gt;的后续文章，其中包含与C ++ 11相关的材料。&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d52f13cea96c3b5a3d0d430c90cf5210a996c3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Transitive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Transitive&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c671d5cd81ed0921c79d3cd1899a9bca816d7f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes!&lt;/strong&gt; Right.</source>
          <target state="translated">&lt;strong&gt;是!&lt;/strong&gt; 对。</target>
        </trans-unit>
        <trans-unit id="022e9567b2b3b169242f2a720ec0a6d446c419ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes!&lt;/strong&gt; This is very true.</source>
          <target state="translated">&lt;strong&gt;是!&lt;/strong&gt; 这是真的。</target>
        </trans-unit>
        <trans-unit id="929829f559fa26e55cfe9537499e25f431156fbc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value computations&lt;/strong&gt; (including determining the identity of an object for &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;glvalue evaluation&lt;/a&gt; and fetching a value previously assigned to an object for &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;prvalue evaluation&lt;/a&gt;) and</source>
          <target state="translated">&lt;strong&gt;值计算&lt;/strong&gt; （包括确定对象的身份以进行&lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;glvalue评估&lt;/a&gt;和获取先前分配给对象的值以进行&lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;prvalue评估&lt;/a&gt; ）和</target>
        </trans-unit>
        <trans-unit id="620ae72342c6c376f4c4a1a08f78905e1878296d" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;(Note: This is meant to be an entry to &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow's C++ FAQ&lt;/a&gt;. If you want to critique the idea of providing an FAQ in this form, then &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;the posting on meta that started all this&lt;/a&gt; would be the place to do that. Answers to that question are monitored in the &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C++ chatroom&lt;/a&gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;（注意：这本来是&lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow的C ++ FAQ&lt;/a&gt;的条目。如果您想批评以这种形式提供FAQ的想法，那么&lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;在所有这些&lt;/a&gt;都开始的meta上的张贴将是这样做的地方。该问题在&lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C ++聊天室&lt;/a&gt;中进行监控，该问题最初是从FAQ想法开始的，所以提出这个想法的人很可能会读懂您的答案。）&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a426f588a643ba6573aa0dc06dff29890b117809" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt; 3 : permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or with-
out the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;3：允许的不确定行为，范围从完全忽略具有不可预测结果的情况，到在翻译或程序执行期间以环境特征的书面方式记录的行为（有无诊断消息），到终止翻译或执行（发出诊断消息）。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="95ae89f99caff438000886790fcdd7dc75b710de" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt; 4: In an expression that is evaluated more than once during the execution
of a program, &lt;strong&gt;unsequenced&lt;/strong&gt; and &lt;strong&gt;indeterminately sequenced&lt;/strong&gt; evaluations of its subexpressions need not be performed consistently in different evaluations. &lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;4：在程序执行过程中多次评估的表达式中，不需要在不同的评估中一致地执行其子表达式的无序且不&lt;strong&gt;确定顺序的&lt;/strong&gt;评估。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9312fa9a457767f8b93b9c4711607a7389eaf60e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;1 : Note : the evaluation of a full-expression can include the evaluation of subexpressions that are not lexically
part of the full-expression.  For example, subexpressions involved in evaluating default argument expressions (8.3.6) are considered to be created in the expression that calls the function, not the expression that defines the default argument&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;1：注意：对完整表达式的评估可以包括对不属于完整表达式的词汇的子表达式的评估。&lt;/sub&gt; &lt;sub&gt;例如，与评估默认参数表达式（8.3.6）有关的子表达式被认为是在调用函数的表达式中创建的，而不是在定义默认参数的表达式中创建的&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="60038c8883c25d5e00c8087ef90a1ff8f121ef42" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;2 : The operators indicated are the built-in operators, as described in clause 5.  When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation and the operands form an argument list, without an implied sequence point between them.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;2：指示的运算符是内置运算符，如第5节中所述。如果在有效上下文中将其中一个运算符重载（第13节），从而指定了用户定义的运算符函数，则该表达式指定函数调用，并且操作数形成一个参数列表，它们之间没有隐含的序列点。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="dd3c08ea9f72c1327d8c8c9d45bc917ac9981426" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;[NOTES]&lt;/sub&gt;&lt;sub&gt;&lt;br/&gt;
  1 :  A strict partial order is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_relation&quot;&gt;&lt;strong&gt;binary relation&lt;/strong&gt;&lt;/a&gt; &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; over a set &lt;code&gt;P&lt;/code&gt; which is &lt;a href=&quot;http://en.wikipedia.org/wiki/Asymmetric_relation&quot;&gt;&lt;code&gt;asymmetric&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;http://en.wikipedia.org/wiki/Transitive_relation&quot;&gt;&lt;code&gt;transitive&lt;/code&gt;&lt;/a&gt;, i.e., for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;P&lt;/code&gt;, we have that:&lt;br/&gt; &lt;/sub&gt;&lt;sub&gt;  ........(i). if a &amp;lt; b then &amp;not; (b &amp;lt; a) (&lt;code&gt;asymmetry&lt;/code&gt;);&lt;br/&gt;
  ........(ii). if a &amp;lt; b and b &amp;lt; c then a &amp;lt; c (&lt;code&gt;transitivity&lt;/code&gt;).&lt;br/&gt;
  2 : The execution of &lt;strong&gt;unsequenced evaluations&lt;/strong&gt; can &lt;em&gt;overlap&lt;/em&gt;.&lt;br/&gt;
  3 : &lt;strong&gt;Indeterminately sequenced evaluations&lt;/strong&gt; cannot &lt;em&gt;overlap&lt;/em&gt;, but either could be executed first.
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;[笔记]&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;1：严格的偏序是在&lt;a href=&quot;http://en.wikipedia.org/wiki/Asymmetric_relation&quot;&gt; &lt;code&gt;asymmetric&lt;/code&gt; &lt;/a&gt;且可&lt;a href=&quot;http://en.wikipedia.org/wiki/Transitive_relation&quot;&gt; &lt;code&gt;transitive&lt;/code&gt; &lt;/a&gt;的集合 &lt;code&gt;P&lt;/code&gt; 上的&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_relation&quot;&gt;&lt;strong&gt;二进制关系&lt;/strong&gt;&lt;/a&gt; &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; ，即对于 &lt;code&gt;P&lt;/code&gt; 中的所有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ，我们都有：&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;........（一世）。&lt;/sub&gt; &lt;sub&gt;如果a &amp;lt;b然后&amp;not;（b &amp;lt;a）（ &lt;code&gt;asymmetry&lt;/code&gt; ）;&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;........（ii）。&lt;/sub&gt; &lt;sub&gt;如果a &amp;lt;b和b &amp;lt;c，则a &amp;lt;c（ &lt;code&gt;transitivity&lt;/code&gt; ）。&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;2： &lt;strong&gt;无序评估&lt;/strong&gt;的执行可能会&lt;em&gt;重叠&lt;/em&gt; 。&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;3： &lt;strong&gt;不确定顺序的求&lt;/strong&gt;值不能&lt;em&gt;重叠&lt;/em&gt; ，但可以先执行。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="c7f05a513b706b4a1f9cb106d583e49db558645f" translate="yes" xml:space="preserve">
          <source>An expression &lt;em&gt;X&lt;/em&gt; is said to be sequenced before an expression &lt;em&gt;Y&lt;/em&gt; if every
  value computation and every side effect associated with the expression &lt;em&gt;X&lt;/em&gt; is sequenced before every value
  computation and every side effect associated with the expression &lt;em&gt;Y&lt;/em&gt;.</source>
          <target state="translated">如果与表达式&lt;em&gt;X&lt;/em&gt;关联的每个值计算和每个副作用在与表达式&lt;em&gt;Y&lt;/em&gt;关联的每个值计算和每个副作用之前都被排序，则可以说表达式&lt;em&gt;X&lt;/em&gt;在表达式&lt;em&gt;Y&lt;/em&gt;之前被排序。</target>
        </trans-unit>
        <trans-unit id="153d5bd3ffb42c2afbf3901847ae23308ee5a040" translate="yes" xml:space="preserve">
          <source>Another example &lt;a href=&quot;https://stackoverflow.com/questions/3457967/what-belongs-in-an-educational-tool-to-demonstrate-the-unwarranted-assumptions-pe/3458842#3458842&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/3457967/what-belongs-in-an-educational-tool-to-demonstrate-the-unwarranted-assumptions-pe/3458842#3458842&quot;&gt;这里的&lt;/a&gt;另一个例子。</target>
        </trans-unit>
        <trans-unit id="8ec01806be24062fea2d9f86213ec8a1e47cbe35" translate="yes" xml:space="preserve">
          <source>At  certain specified points in the execution sequence called &lt;strong&gt;sequence points&lt;/strong&gt;, all &lt;em&gt;side effects&lt;/em&gt; of previous evaluations 
  shall be complete and no &lt;em&gt;side effects&lt;/em&gt; of subsequent evaluations shall have taken place. (&amp;sect;1.9/7)</source>
          <target state="translated">在执行序列中某些特定的点（称为&lt;strong&gt;顺序点）上&lt;/strong&gt; ，以前评估的所有&lt;em&gt;副作用&lt;/em&gt;都应完整，并且以后评估的任何&lt;em&gt;副作用&lt;/em&gt;都不应发生。 （第1.9 / 7节）</target>
        </trans-unit>
        <trans-unit id="daf318858a3809a2aa50a9396bad28cdbbc5b979" translate="yes" xml:space="preserve">
          <source>Before I get into that you must know the difference(s) between &lt;a href=&quot;https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior&quot;&gt;Undefined Behaviour, Unspecified Behaviour and Implementation Defined Behaviour&lt;/a&gt;.</source>
          <target state="translated">在开始讨论之前，您必须了解&amp;ldquo; &lt;a href=&quot;https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior&quot;&gt;未定义行为&amp;rdquo;，&amp;ldquo;未指定行为&amp;rdquo;和&amp;ldquo;实现已定义行为&amp;rdquo;&lt;/a&gt;之间的区别。</target>
        </trans-unit>
        <trans-unit id="91dd0af55b97c31dc0bccf19143f7b7880f341a1" translate="yes" xml:space="preserve">
          <source>But in &lt;code&gt;N4659&lt;/code&gt;</source>
          <target state="translated">但是在 &lt;code&gt;N4659&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="d51d489d3ac886e7ea3ca9a2b07bed917b53895d" translate="yes" xml:space="preserve">
          <source>But the following expressions are fine:</source>
          <target state="translated">但是下面的表达方式就可以了。</target>
        </trans-unit>
        <trans-unit id="99eaf8f6cc151e73b21d6790c8bc8a2b84b7ba36" translate="yes" xml:space="preserve">
          <source>C++98 and C++03</source>
          <target state="translated">C++98和C++03</target>
        </trans-unit>
        <trans-unit id="9e67e09870ca0989e71cb269267edc0455043285" translate="yes" xml:space="preserve">
          <source>Evaluation  of  an  expression produces something and if in addition there is a change in the state of the execution environment it is said that the expression (its evaluation) has some side effect(s).</source>
          <target state="translated">对一个表达式的评价会产生一些东西,如果再加上执行环境的状态发生了变化,则表示该表达式(它的评价)有一些副作用。</target>
        </trans-unit>
        <trans-unit id="ba67e3bf4a955da66b33b710af3baabeaf6f5983" translate="yes" xml:space="preserve">
          <source>Evaluation of operands of &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operators are unsequenced relative to each other.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 运算符的操作数的求值相对于彼此是无序列的。</target>
        </trans-unit>
        <trans-unit id="64e262c018b20f74702f4f2184ebedf6e4ec767b" translate="yes" xml:space="preserve">
          <source>Evaluation of operands of &lt;code&gt;+&lt;/code&gt; operator are unsequenced relative to each other.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 运算符的操作数的求值相对于彼此没有顺序。</target>
        </trans-unit>
        <trans-unit id="4207deb1ca4c1aeaec83c1e9887c129a6054ca46" translate="yes" xml:space="preserve">
          <source>Evaluations &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are &lt;strong&gt;indeterminately sequenced&lt;/strong&gt; when either &lt;code&gt;A&lt;/code&gt; is sequenced before &lt;code&gt;B&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; is sequenced before &lt;code&gt;A&lt;/code&gt;, but it is unspecified which&lt;sup&gt;3&lt;/sup&gt;.</source>
          <target state="translated">当在 &lt;code&gt;B&lt;/code&gt; 之前先对 &lt;code&gt;A&lt;/code&gt; 进行排序，或者 &lt;code&gt;B&lt;/code&gt; 在 &lt;code&gt;A&lt;/code&gt; 之前对B进行 &lt;strong&gt;排序&lt;/strong&gt;时，评估 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的&lt;strong&gt;顺序不确定&lt;/strong&gt; ，但是不确定哪&lt;sup&gt;3&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c07fa7c9e378ccd40615376ea6880ef0d1c7126" translate="yes" xml:space="preserve">
          <source>Every value computation and side effect associated with a full-expression is &lt;strong&gt;sequenced before&lt;/strong&gt; every value computation and side effect associated with the &lt;strong&gt;next full-expression to be evaluated&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;在&lt;/strong&gt;与&lt;strong&gt;要评估&lt;/strong&gt;的&lt;strong&gt;下一个完整表达式&lt;/strong&gt;关联的每个值计算和副作用&lt;strong&gt;之前，&lt;/strong&gt;对与一个完整表达式关联的每个值计算和副作用进行&lt;strong&gt;排序&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ef2e1210c47909b18d1b60b9c30a0116c39a246" translate="yes" xml:space="preserve">
          <source>Example 1:</source>
          <target state="translated">例1:</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">例2:</target>
        </trans-unit>
        <trans-unit id="19b6677ab36387289cbb2372a028e31d1e438889" translate="yes" xml:space="preserve">
          <source>Example 3 :</source>
          <target state="translated">例3:</target>
        </trans-unit>
        <trans-unit id="0483beb1135269908e7a45fb455b6f6963675242" translate="yes" xml:space="preserve">
          <source>Example :</source>
          <target state="translated">例子 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="406e4bca4b11d6e472a01508642fc217ed5ef469" translate="yes" xml:space="preserve">
          <source>Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are &lt;strong&gt;unsequenced&lt;/strong&gt;&lt;sup&gt;4&lt;/sup&gt;.</source>
          <target state="translated">除非另有说明，否则对单个运算符的操作数和单个表达式的子表达式的求值是无&lt;strong&gt;序列的&lt;/strong&gt; &lt;sup&gt;4&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="a860b41292f726793b4b3135e3a7635bcdbf99ef" translate="yes" xml:space="preserve">
          <source>Expressions &lt;code&gt;(5)&lt;/code&gt;, &lt;code&gt;(7)&lt;/code&gt; and &lt;code&gt;(8)&lt;/code&gt; do not invoke undefined behaviour. Check out the following answers for a more detailed explanation.</source>
          <target state="translated">表达式 &lt;code&gt;(5)&lt;/code&gt; ， &lt;code&gt;(7)&lt;/code&gt; 和 &lt;code&gt;(8)&lt;/code&gt; 不会调用未定义的行为。 请查看以下答案以获得更详细的说明。</target>
        </trans-unit>
        <trans-unit id="88fa3152aa1a080052016562134c18cdbc4e0603" translate="yes" xml:space="preserve">
          <source>For example :</source>
          <target state="translated">比如说:</target>
        </trans-unit>
        <trans-unit id="f42745ac0f5de04dd9f5e31b65fbbb63e4c15167" translate="yes" xml:space="preserve">
          <source>For example in &lt;code&gt;i = i + 1&lt;/code&gt; all the access of &lt;code&gt;i&lt;/code&gt; (in L.H.S and in R.H.S) are &lt;strong&gt;directly involved in computation&lt;/strong&gt; of the value to be written. So it is fine.</source>
          <target state="translated">例如，在 &lt;code&gt;i = i + 1&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; 的所有访问（在LHS和RHS中） &lt;strong&gt;直接涉及&lt;/strong&gt;要写入的值的&lt;strong&gt;计算&lt;/strong&gt; 。 很好。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="9aa68292d7569023871135b4089b691e89a56f5a" translate="yes" xml:space="preserve">
          <source>Formally it means given any two evaluations&lt;sup&gt;(See below)&lt;/sup&gt;&lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, if &lt;code&gt;A&lt;/code&gt; is &lt;strong&gt;sequenced before&lt;/strong&gt;&lt;code&gt;B&lt;/code&gt;, then the execution of &lt;code&gt;A&lt;/code&gt;&lt;em&gt;shall precede&lt;/em&gt; the execution of &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;A&lt;/code&gt; is not sequenced before &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; is not sequenced before &lt;code&gt;A&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are &lt;strong&gt;unsequenced&lt;/strong&gt;&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">从形式上讲，这意味着给定 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的任何两个评估&lt;sup&gt;（请参见下文）&lt;/sup&gt; ，如果 &lt;code&gt;A&lt;/code&gt; &lt;strong&gt;在&lt;/strong&gt; &lt;code&gt;B&lt;/code&gt; &lt;strong&gt;之前排序&lt;/strong&gt; ，则A的执行&lt;em&gt;应在&lt;/em&gt; &lt;code&gt;B&lt;/code&gt; 的执行&lt;em&gt;之前&lt;/em&gt; 。 如果 &lt;code&gt;A&lt;/code&gt; 在 &lt;code&gt;B&lt;/code&gt; 之前未排序，而 &lt;code&gt;B&lt;/code&gt; 在 &lt;code&gt;A&lt;/code&gt; 之前未排序，则 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 是未排序&lt;sup&gt;2&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="eac423cee75b32090f5d0d9792a419ddd0af5e6f" translate="yes" xml:space="preserve">
          <source>From the above sentence the following expressions invoke Undefined Behaviour:</source>
          <target state="translated">从上面的句子中,下列表述中援引未定义行为的是()。</target>
        </trans-unit>
        <trans-unit id="ba6c960249f3aafc39737f39e23d6cefa0037a31" translate="yes" xml:space="preserve">
          <source>However several other similar cases still lead to undefined behavior.</source>
          <target state="translated">然而,其他几种类似的情况仍然导致了未定义的行为。</target>
        </trans-unit>
        <trans-unit id="64f407e5e5f324cd785789444eed0a59f0937e5e" translate="yes" xml:space="preserve">
          <source>I am guessing there is a fundamental reason for the change, it isn't merely cosmetic to make the old interpretation clearer: that reason is concurrency. Unspecified order of elaboration is merely selection of one of several possible serial orderings, this is quite different to before and after orderings, because if there is no specified ordering, concurrent evaluation is possible: not so with the old rules. For example in:</source>
          <target state="translated">我猜测这个变化是有一个根本原因的,它不仅仅是为了让旧的解释更清晰一些而做的表面文章:这个原因就是并发。未指定的阐述顺序只是在几个可能的序列顺序中选择一个,这和前后顺序有很大的区别,因为如果没有指定的顺序,就可以进行并发评价:而旧规则则不然。例如在。</target>
        </trans-unit>
        <trans-unit id="dc15d88006a8199cfa78e1c45d14c286fb27f703" translate="yes" xml:space="preserve">
          <source>I often use funny and convoluted expressions like &lt;code&gt;a[++i] = i;&lt;/code&gt;, to make myself feel better. Why should I stop using them?</source>
          <target state="translated">我经常使用有趣和复杂的表达式，例如 &lt;code&gt;a[++i] = i;&lt;/code&gt; ，让自己感觉更好。 为什么我应该停止使用它们？</target>
        </trans-unit>
        <trans-unit id="7bf88b9125f90667375d801ebb86d1d08c42099d" translate="yes" xml:space="preserve">
          <source>If you find any flaw in the post please leave a comment. Power-users (With rep &amp;gt;20000) please do not hesitate to edit the post for correcting typos and other mistakes.</source>
          <target state="translated">如果您发现帖子中有任何缺陷，请发表评论。 超级用户（代表&amp;gt; 20000）请随时编辑帖子以更正错别字和其他错误。</target>
        </trans-unit>
        <trans-unit id="bc47a04d1a4bab80348b412aad415fc3dd9f9ce5" translate="yes" xml:space="preserve">
          <source>If you've read this, be sure to visit the follow-up question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4638364&quot;&gt;Undefined behavior and sequence points reloaded&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">如果您已阅读本文，请确保访问后续问题&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4638364&quot;&gt;未定义行为和重载序列点&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="652e555c4df01fc076aec8ee7a1d86b707fe7184" translate="yes" xml:space="preserve">
          <source>In (&amp;sect;1.9/15) it has been mentioned that</source>
          <target state="translated">在（&amp;sect;1.9/ 15）中提到</target>
        </trans-unit>
        <trans-unit id="4c52f5367ab947bba6d1b1cf5bca260a9edc87de" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C99(ISO/IEC 9899:TC3)&lt;/code&gt; which seems absent from this discussion thus far the following steteents are made regarding order of evaluaiton.</source>
          <target state="translated">到目前为止，在本次讨论中似乎缺少的 &lt;code&gt;C99(ISO/IEC 9899:TC3)&lt;/code&gt; 中 ，针对评估顺序进行了以下修改。</target>
        </trans-unit>
        <trans-unit id="bd5b7a4772b25de672849363c08a46e9876609fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;N4140&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;N4140&lt;/code&gt; 中 ：</target>
        </trans-unit>
        <trans-unit id="c7e36d1d9a63e34fb0930c72cc616f8c4fbbd0c1" translate="yes" xml:space="preserve">
          <source>In C++11, evaluation of an expression (or a sub-expression) in general includes:</source>
          <target state="translated">在C++11中,对一个表达式(或子表达式)的评价一般包括。</target>
        </trans-unit>
        <trans-unit id="940e8112672c49e76504070e5cdf7d536f7df4e1" translate="yes" xml:space="preserve">
          <source>In addition to the initialization operation the value of &lt;code&gt;y&lt;/code&gt; gets changed due to the side effect of &lt;code&gt;++&lt;/code&gt; operator.</source>
          <target state="translated">除了初始化操作之外，由于 &lt;code&gt;++&lt;/code&gt; 运算符的副作用， &lt;code&gt;y&lt;/code&gt; 的值也会更改。</target>
        </trans-unit>
        <trans-unit id="e3894686d84dca096a2337f3716d28b44fedb4db" translate="yes" xml:space="preserve">
          <source>In all cases, the assignment is sequenced after the value
  computation of the right and left operands, and before the value computation of the assignment expression.
  &lt;strong&gt;&lt;em&gt;The right operand is sequenced before the left operand.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">在所有情况下，赋值都在左右操作数的值计算之后以及赋值表达式的值计算之前进行排序。 &lt;strong&gt;&lt;em&gt;右操作数在左操作数之前排序。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f3783804d60a76a00fd374673d91cebbb0e44e25" translate="yes" xml:space="preserve">
          <source>In particular, the &lt;strong&gt;&lt;em&gt;following sentence&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">特别是&lt;strong&gt;&lt;em&gt;下面的句子&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="617effb1d8e8263589de961e2e7b9f950ccfd3d0" translate="yes" xml:space="preserve">
          <source>In short, undefined behaviour means &lt;strong&gt;anything&lt;/strong&gt; can happen from daemons flying out of your nose to  your girlfriend getting pregnant.</source>
          <target state="translated">简而言之，未定义的行为意味着从守护程序从鼻子飞出到女友怀孕&lt;strong&gt;都&lt;/strong&gt;可能发生&lt;strong&gt;任何&lt;/strong&gt;事情。</target>
        </trans-unit>
        <trans-unit id="30e4fdc9922ca401ebec5c5d2ca75e8eddd91c38" translate="yes" xml:space="preserve">
          <source>Informally it means that between two sequence points a variable must not be modified more than once.
In an expression statement, the &lt;code&gt;next sequence point&lt;/code&gt; is usually at the terminating semicolon, and the &lt;code&gt;previous sequence point&lt;/code&gt; is at the end of the previous statement. An expression may also contain intermediate &lt;code&gt;sequence points&lt;/code&gt;.</source>
          <target state="translated">非正式地，它意味着两个序列点之间的变量不得被多次修改。 在表达式语句中， &lt;code&gt;next sequence point&lt;/code&gt; 通常在终止分号处，而上 &lt;code&gt;previous sequence point&lt;/code&gt; 一条语句的末尾。 一个表达式也可以包含中间 &lt;code&gt;sequence points&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72d6c19372257ac1933afb0a881d59d363366e13" translate="yes" xml:space="preserve">
          <source>Is it true that there are no Sequence Points in C++11?</source>
          <target state="translated">C++11中真的没有序列点吗?</target>
        </trans-unit>
        <trans-unit id="8bdbba62423aafb33233c14c04af680f2c1edba6" translate="yes" xml:space="preserve">
          <source>More importantly</source>
          <target state="translated">更重要的是</target>
        </trans-unit>
        <trans-unit id="990cdd13220ac29d0b6ede208ef83a4fa9dbd84e" translate="yes" xml:space="preserve">
          <source>Multiple preincrement operations on a variable in C++0x</source>
          <target state="translated">在C++0x中对一个变量进行多次预增操作</target>
        </trans-unit>
        <trans-unit id="d1ed313837b92d00cf87c6dae332f5af91bfca80" translate="yes" xml:space="preserve">
          <source>Now  (&amp;sect;1.9/14) says:</source>
          <target state="translated">现在（第1.9 / 14节）说：</target>
        </trans-unit>
        <trans-unit id="8a484c465793ca714b6bcdc23b747ba39bd901d6" translate="yes" xml:space="preserve">
          <source>Now the Standard in &lt;code&gt;&amp;sect;5/4&lt;/code&gt; says</source>
          <target state="translated">现在，第 &lt;code&gt;&amp;sect;5/4&lt;/code&gt; 的标准说</target>
        </trans-unit>
        <trans-unit id="8bd7723fe01aeb7a98d73d693451c80beee344d7" translate="yes" xml:space="preserve">
          <source>Of course, using a C++17 compliant compiler does not necessarily mean that one should start writing such expressions.</source>
          <target state="translated">当然,使用兼容C++17的编译器并不意味着一定要开始编写这样的表达式。</target>
        </trans-unit>
        <trans-unit id="458d1997bcf26b81560b08ea6ea5be3aa11f4376" translate="yes" xml:space="preserve">
          <source>Sequence point is a point in time at which the dust has settled and all side effects which have been seen so far are guaranteed to be complete.</source>
          <target state="translated">顺序点是指尘埃落定的时间点,到目前为止所见过的所有副作用都能保证完成。</target>
        </trans-unit>
        <trans-unit id="9b53077da07196f084c3c12e2d14dc1059eec0c2" translate="yes" xml:space="preserve">
          <source>Side effects? What are side effects?</source>
          <target state="translated">副作用?副作用是什么?</target>
        </trans-unit>
        <trans-unit id="e25244b7a39a375416acf31f2d6810f2b050173a" translate="yes" xml:space="preserve">
          <source>So far so good. Moving on to sequence points. An alternation definition of seq-points given by the comp.lang.c author &lt;code&gt;Steve Summit&lt;/code&gt;:</source>
          <target state="translated">到现在为止还挺好。 继续到序列点。 comp.lang.c作者 &lt;code&gt;Steve Summit&lt;/code&gt; 给出的seq-point的交替定义：</target>
        </trans-unit>
        <trans-unit id="3276033ca3f269623eda3a83e62e8252eee54d70" translate="yes" xml:space="preserve">
          <source>So there must be some relation between Undefined Behaviour and the above-mentioned things, right?</source>
          <target state="translated">所以说,未定义行为与上述事物之间一定有一定的关系吧?</target>
        </trans-unit>
        <trans-unit id="eabf5b327e550da30860ed745c1e2eae65082eff" translate="yes" xml:space="preserve">
          <source>That means in &lt;code&gt;x + y&lt;/code&gt; the value computation of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are sequenced before the value computation of &lt;code&gt;(x + y)&lt;/code&gt;.</source>
          <target state="translated">这意味着在 &lt;code&gt;x + y&lt;/code&gt; ，对 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的值计算在 &lt;code&gt;(x + y)&lt;/code&gt; 的值计算之前进行排序。</target>
        </trans-unit>
        <trans-unit id="04fa30dedddd3187dfef29f539bfd6d837ce07f7" translate="yes" xml:space="preserve">
          <source>The Standard defines Undefined Behaviour in Section &lt;code&gt;&amp;sect;1.3.12&lt;/code&gt; as</source>
          <target state="translated">该标准在第 &lt;code&gt;&amp;sect;1.3.12&lt;/code&gt; 节中将未定义行为定义为</target>
        </trans-unit>
        <trans-unit id="cc3825fe31d3f227de05d63696f01adfd25413f6" translate="yes" xml:space="preserve">
          <source>The Standard says</source>
          <target state="translated">标准》说</target>
        </trans-unit>
        <trans-unit id="ecfe246ba857988aa603cf220b0140b9f496a485" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands is unspecified. If an attempt
  is made to modify the result of an assignment operator or to access it
  after the next sequence point, the behavior[sic] is undefined.(Section
  6.5.16 pp 91)</source>
          <target state="translated">运算子的评价顺序是未指定的。如果试图修改一个赋值运算符的结果或在下一个序列点之后访问它,行为[sic]是未定义的。</target>
        </trans-unit>
        <trans-unit id="98d34d7717c305fec376084020473ffd968566be" translate="yes" xml:space="preserve">
          <source>This answer is for the older versions of the C++ standard.  The C++11 and C++14 versions of the standard do not formally contain 'sequence points'; operations are 'sequenced before' or 'unsequenced' or 'indeterminately sequenced' instead.  The net effect is essentially the same, but the terminology is different.</source>
          <target state="translated">这个答案是针对C++标准的旧版本。C++11和C++14版本的标准没有正式包含 &quot;顺序点&quot;,操作是 &quot;顺序化前 &quot;或 &quot;无顺序化 &quot;或 &quot;不定顺序化&quot;。净效果基本上是一样的,但术语不同。</target>
        </trans-unit>
        <trans-unit id="391877d79b1fd6dd824fd29ab9c7d8d671230e24" translate="yes" xml:space="preserve">
          <source>This rule effectively constrains legal expressions to those in which the accesses demonstrably precede the modification.</source>
          <target state="translated">这条规则有效地将法律表达方式限制在法律表达方式中,即在修改前有明显的访问量。</target>
        </trans-unit>
        <trans-unit id="f7263d87574b12081e5695094ca83a2c5298a6b0" translate="yes" xml:space="preserve">
          <source>Those are:</source>
          <target state="translated">这些是:</target>
        </trans-unit>
        <trans-unit id="86ffe4e34823f77699906a8f2cc28e0a36b44be6" translate="yes" xml:space="preserve">
          <source>Trivial example:</source>
          <target state="translated">琐碎的例子。</target>
        </trans-unit>
        <trans-unit id="a15a56e2346e0d81d8d95c79e39e94430fe5d1e8" translate="yes" xml:space="preserve">
          <source>Undefined  behavior  may  also  be  expected  when  this
  International Standard omits the description of any explicit definition of behavior.</source>
          <target state="translated">当本国际标准省略了对行为的任何明确定义时,也可以预期未定义的行为。</target>
        </trans-unit>
        <trans-unit id="5109b2e7ff59ff1bf194187e9b404f9b063d4e37" translate="yes" xml:space="preserve">
          <source>Undefined behavior and sequence points</source>
          <target state="translated">未定义的行为和顺序点</target>
        </trans-unit>
        <trans-unit id="fbb99fc8283814cb9af4d737b1328eb2f80f2298" translate="yes" xml:space="preserve">
          <source>Unsequenced Value Computations</source>
          <target state="translated">无序值计算</target>
        </trans-unit>
        <trans-unit id="0b9ee0bad57b9aa23197de1969ca62cd45c0e10e" translate="yes" xml:space="preserve">
          <source>Value computation and side effect associated with &lt;code&gt;++x&lt;/code&gt; is sequenced after the value computation and side effect of &lt;code&gt;x = 10;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;x = 10;&lt;/code&gt; 的值计算和副作用之后，对与 &lt;code&gt;++x&lt;/code&gt; 相关的值计算和副作用进行排序。</target>
        </trans-unit>
        <trans-unit id="c1553ee23f64335d9f5575846335c215c4f556fe" translate="yes" xml:space="preserve">
          <source>What are &quot;sequence points&quot;?</source>
          <target state="translated">什么是 &quot;顺序点&quot;?</target>
        </trans-unit>
        <trans-unit id="5580eab4cffca63ecfa895dce1c35429a7721d75" translate="yes" xml:space="preserve">
          <source>What are Sequence Points?</source>
          <target state="translated">什么是顺序点?</target>
        </trans-unit>
        <trans-unit id="6e9c789346e18ce5be4e6deda5cc8b7767a977e7" translate="yes" xml:space="preserve">
          <source>What are the common sequence points listed in the C++ Standard ?</source>
          <target state="translated">C++标准中列出的常用顺序点有哪些?</target>
        </trans-unit>
        <trans-unit id="a5ed464308c94903d6f60610da2f96028a67653c" translate="yes" xml:space="preserve">
          <source>What does it mean?</source>
          <target state="translated">这是什么意思?</target>
        </trans-unit>
        <trans-unit id="ddf1970fbf15053c0de78fbdb8bb9c5a5319d4a6" translate="yes" xml:space="preserve">
          <source>What does it mean? It means if an object is written to within a full expression, any and all accesses to it within the same expression &lt;strong&gt;must be directly involved in the computation of the value to be written&lt;/strong&gt;.</source>
          <target state="translated">这是什么意思？ 这意味着，如果将对象写入完整表达式内，则在同一表达式内对其的所有访问都&lt;strong&gt;必须直接参与要写入的值的计算&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9b9cc427f946732e721b7ccbf4b3c3166aeea40" translate="yes" xml:space="preserve">
          <source>What exactly is this 'Sequenced before' thing?</source>
          <target state="translated">'之前的排序'到底是什么东西?</target>
        </trans-unit>
        <trans-unit id="44c906335f64785d553c0284006d490c13bf0900" translate="yes" xml:space="preserve">
          <source>What is Undefined Behaviour?</source>
          <target state="translated">什么是未定义行为?</target>
        </trans-unit>
        <trans-unit id="f9c7bb688ad67e35f31fb2b89ccb85808deb976e" translate="yes" xml:space="preserve">
          <source>What is the meaning of the word 'evaluation' in context of C++11?</source>
          <target state="translated">在C++11的上下文中,&quot;评价 &quot;一词的含义是什么?</target>
        </trans-unit>
        <trans-unit id="093a89bf3df40d809fb2ed82e44f0855443490b8" translate="yes" xml:space="preserve">
          <source>What is the relation between Undefined Behaviour and Sequence Points?</source>
          <target state="translated">未定义行为和顺序点之间有什么关系?</target>
        </trans-unit>
        <trans-unit id="caf82056aa35f376cce3be24a9b9a2227c913f8e" translate="yes" xml:space="preserve">
          <source>What is the relation between undefined behaviour and sequence points?</source>
          <target state="translated">未定义行为和顺序点之间有什么关系?</target>
        </trans-unit>
        <trans-unit id="6fb1c9cfb5692133ce65e0caed51fa572a4b8df5" translate="yes" xml:space="preserve">
          <source>When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. [&lt;em&gt;Note:&lt;/em&gt;&lt;strong&gt;Value computations and side effects associated with different argument expressions are unsequenced&lt;/strong&gt;.  &amp;mdash; &lt;em&gt;end note&lt;/em&gt;]</source>
          <target state="translated">在调用函数时（无论函数是否为内联），与任何参数表达式或后缀表达式指定被调用函数相关联的每个值计算和副作用都将在执行函数主体中的每个表达式或语句之前进行排序。称为函数。 [ &lt;em&gt;注意：&lt;/em&gt; &lt;strong&gt;与不同参数表达式关联的值计算和副作用是无序列的&lt;/strong&gt; 。 &amp;mdash; &lt;em&gt;尾注&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="51b6b5895ef96bb02783c8a47c62b0dd464c3aba" translate="yes" xml:space="preserve">
          <source>You must also know that &lt;code&gt;the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified&lt;/code&gt;.</source>
          <target state="translated">您还必须知道， &lt;code&gt;the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="466a6585cbd4be9a5e956ed88dd68a492784a9f9" translate="yes" xml:space="preserve">
          <source>[...]the order of evaluation of subexpressions and the order in which
  side effects take place are both unspecified. (Section 6.5 pp 67)</source>
          <target state="translated">[....]评价亚表达的顺序和副作用发生的顺序都没有说明。(第6.5节,第67页)</target>
        </trans-unit>
        <trans-unit id="9bb817c4fd78f76ae7b6675b66a0af1204c51885" translate="yes" xml:space="preserve">
          <source>at a function call (whether or not the function is inline), after the evaluation of all function arguments (if any) which 
takes place before execution of any expressions or statements in the function body (&lt;code&gt;&amp;sect;1.9/17&lt;/code&gt;).</source>
          <target state="translated">在对所有函数参数（如果有）进行求值之后（在函数主体中执行任何表达式或语句之前）在函数调用（函数是否为内联）时（第 &lt;code&gt;&amp;sect;1.9/17&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f12161911d4fad86511b4eb366e2ee36effc8211" translate="yes" xml:space="preserve">
          <source>at the end of the evaluation of full expression (&lt;code&gt;&amp;sect;1.9/16&lt;/code&gt;) (A full-expression is an expression that is not a subexpression of another expression.)&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">在对完整表达式的评估结束时（第 &lt;code&gt;&amp;sect;1.9/16&lt;/code&gt; ）（完整表达式是不是另一个表达式的子表达式的表达式。） &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b3394eecdcb8cb1117c318cedb871d0572708579" translate="yes" xml:space="preserve">
          <source>behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes &lt;strong&gt;no  requirements &lt;sup&gt;3&lt;/sup&gt;&lt;/strong&gt;.</source>
          <target state="translated">行为，例如在使用错误的程序构造或错误的数据时可能发生的行为，对此本国际标准不施加&lt;strong&gt;任何要求&lt;sup&gt;3&lt;/sup&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="cca93eac493b7391171ec42a66933b5d0d433e1e" translate="yes" xml:space="preserve">
          <source>between evaluations executed by a single &lt;a href=&quot;http://en.wikipedia.org/wiki/Thread_(computer_science)&quot;&gt;thread&lt;/a&gt; and induces a &lt;strong&gt;strict partial order&lt;/strong&gt;&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">单个&lt;a href=&quot;http://en.wikipedia.org/wiki/Thread_(computer_science)&quot;&gt;线程&lt;/a&gt;执行的评估之间，并得出&lt;strong&gt;严格的偏序&lt;/strong&gt; &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="3c7b1f87e9915365f75a64d6e2a47b9e86d8035e" translate="yes" xml:space="preserve">
          <source>in the evaluation of each of the following expressions after the evaluation of the first expression (&lt;code&gt;&amp;sect;1.9/18&lt;/code&gt;) &lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">在对第一个表达式求值之后对以下每个表达式求值（第 &lt;code&gt;&amp;sect;1.9/18&lt;/code&gt; ） &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6f83c8b6514790a9407377c3f4ef98b941b04595" translate="yes" xml:space="preserve">
          <source>initiation of &lt;strong&gt;side effects&lt;/strong&gt;.</source>
          <target state="translated">引发&lt;strong&gt;副作用&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c0c70ca023797ca6b5b8e5572c7ec724cb314ce" translate="yes" xml:space="preserve">
          <source>is disallowed because one of the accesses of &lt;code&gt;i&lt;/code&gt; (the one in &lt;code&gt;a[i]&lt;/code&gt;) has nothing to do with the value which ends up being stored in i (which happens over in &lt;code&gt;i++&lt;/code&gt;), and so there's no good way to define--either for our understanding or the compiler's--whether the access should take place before or after the incremented value is stored. So the behaviour is undefined.</source>
          <target state="translated">之所以被禁止，是因为 &lt;code&gt;i&lt;/code&gt; 的访问之一（ &lt;code&gt;a[i]&lt;/code&gt; 中的访问）与最终存储在i中的值（在 &lt;code&gt;i++&lt;/code&gt; 发生）无关，因此，没有很好的方法来定义-无论是对我们还是对编译器来说，访问是在存储递增的值之前还是之后进行。 因此，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="6df2d1e296ea26ed60c7b7b29576ce6872dfc6a2" translate="yes" xml:space="preserve">
          <source>make several cases of previously undefined behavior valid, including the one in question:</source>
          <target state="translated">使以前未定义的行为的几种情况有效,包括本案中的情况。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="f98714b22930c003dcee8dfb1a4a94df52338e76" translate="yes" xml:space="preserve">
          <source>previously either a then b, or, b then a. Now, a and b can be evaluated with instructions interleaved or even on different cores.</source>
          <target state="translated">现在,a和b可以用交错的指令来评估,甚至可以在不同的核上进行评估。</target>
        </trans-unit>
        <trans-unit id="016cfaace633cc6567b132c93461aba49d804cd4" translate="yes" xml:space="preserve">
          <source>the behaviour is &lt;strong&gt;undefined&lt;/strong&gt;.</source>
          <target state="translated">行为是&lt;strong&gt;不确定的&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="11688589f9f4e92309082daaedd72c31492e5f21" translate="yes" xml:space="preserve">
          <source>together with the following clarification</source>
          <target state="translated">并作出以下澄清</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
