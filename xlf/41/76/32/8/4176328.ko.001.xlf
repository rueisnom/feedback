<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4176328">
    <body>
      <group id="4176328">
        <trans-unit id="8870c0b78d2f8c5d51c2bb94aca02172e8d812a0" translate="yes" xml:space="preserve">
          <source>(&amp;sect;1.9/15)
  The value computations of the operands of an
  operator are sequenced before the value computation of the result of the operator.</source>
          <target state="translated">(&amp;sect;1.9 / 15) 연산자 피연산자의 값 계산은 연산자 결과의 값 계산 전에 순서화됩니다.</target>
        </trans-unit>
        <trans-unit id="f6789a34db8f60925945bcb624e1bf27596aee94" translate="yes" xml:space="preserve">
          <source>(&amp;sect;1.9/15) If a side effect on a scalar object is unsequenced relative to either</source>
          <target state="translated">(&amp;sect;1.9 / 15) 스칼라 객체에 대한 부작용이 다음 중 하나와 관련이없는 경우</target>
        </trans-unit>
        <trans-unit id="d03eca4ee881d6c9d172a41f36cf1e2dc14c6921" translate="yes" xml:space="preserve">
          <source>(a) &lt;strong&gt;another side effect on the same scalar object&lt;/strong&gt;</source>
          <target state="translated">(a) &lt;strong&gt;동일한 스칼라 객체에 대한 다른 부작용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7de31a37bbc3d2d1c7535de9aaa9a2d2c89665c2" translate="yes" xml:space="preserve">
          <source>(b) &lt;strong&gt;a value computation using the value of the same scalar object.&lt;/strong&gt;</source>
          <target state="translated">(b) &lt;strong&gt;동일한 스칼라 객체의 값을 사용한 값 계산.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a37ce5427ff6266638bda82ba5addfaf1eddd932" translate="yes" xml:space="preserve">
          <source>1) &lt;strong&gt;Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression.&lt;/strong&gt;</source>
          <target state="translated">1) &lt;strong&gt;이전 시퀀스 포인트와 다음 시퀀스 포인트 사이에서 스칼라 객체는 표현식의 평가에 의해 저장된 값을 최대 한 번 수정해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c06988d3595ab2a28cd41d481cfaebc25ee10f2" translate="yes" xml:space="preserve">
          <source>2) &lt;strong&gt;Furthermore, the prior value shall be accessed only to determine the value to be stored.&lt;/strong&gt;</source>
          <target state="translated">2) &lt;strong&gt;또한, 이전 값은 저장 될 값을 결정하기 위해서만 액세스되어야한다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fda10bc0210ae7516d38ae8f60df65cb2be2b24a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a , b (&amp;sect;5.18)&lt;/code&gt; (here a , b is a comma operator; in &lt;code&gt;func(a,a++)&lt;/code&gt;&lt;code&gt;,&lt;/code&gt; is not a comma operator, it's merely a separator between the arguments &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a++&lt;/code&gt;. Thus the behaviour is undefined in that case (if &lt;code&gt;a&lt;/code&gt; is considered to be a primitive type))</source>
          <target state="translated">&lt;code&gt;a , b (&amp;sect;5.18)&lt;/code&gt; (여기서 a, b는 쉼표 연산자입니다. &lt;code&gt;func(a,a++)&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; 쉼표 연산자가 아니며 인수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;a++&lt;/code&gt; 사이의 구분자 일 뿐이 므로이 경우 동작은 정의되지 않습니다. ( &lt;code&gt;a&lt;/code&gt; 가 기본 유형으로 간주되는 경우)</target>
        </trans-unit>
        <trans-unit id="5cbb99cfd67aa0ed7c9abf9fe32b9cb527dbb10e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int x;&lt;/code&gt;&lt;code&gt;x = 10;&lt;/code&gt;&lt;code&gt;++x;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int x;&lt;/code&gt; &lt;code&gt;x = 10;&lt;/code&gt; &lt;code&gt;++x;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a949dc1c9f550107654d74da78d5d42424053380" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;8.18 Assignment and compound assignment operators&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;8.18 대입 및 복합 대입 연산자&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="9d069fa79ddd4f9f4141383dd0eca1d2590f65b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Asymmetric&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Asymmetric&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f52f520e63951b740474e846fac98e153b9acf9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++17&lt;/strong&gt; (&lt;code&gt;N4659&lt;/code&gt;) includes a proposal &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf&quot;&gt;Refining Expression Evaluation Order for Idiomatic C++&lt;/a&gt;
which defines a stricter order of expression evaluation.</source>
          <target state="translated">&lt;strong&gt;C ++ 17&lt;/strong&gt; ( &lt;code&gt;N4659&lt;/code&gt; )에는 엄격한 식 평가 순서를 정의하는 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf&quot;&gt;관용적 C ++에 대한 Refining Expression Evaluation Order&lt;/a&gt; 제안이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="886ab1261d735f993b15c51c1bc58f5542846d90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt; : Okay. This answer is a bit long. So have patience while reading it. If you already know these things, reading them again won't make you crazy.</source>
          <target state="translated">&lt;strong&gt;면책 조항&lt;/strong&gt; : 알겠습니다. 이 답변은 약간 깁니다. 읽는 동안 인내심을 가지십시오. 이미 알고 있다면 다시 읽어도 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2abc7e47d5ebbbf19c4348696e3073af038cb44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final Note&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;최종 메모&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e934205b4f3054922c2a5b8b6244db59ae5a2559" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Follow up answer for C++11 &lt;a href=&quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4183735#4183735&quot;&gt;here&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4183735#4183735&quot;&gt;여기&lt;/a&gt; 에서 C ++ 11에 대한 답변을 따르십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="280bacf147f4332348859249dc18aef73052508a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pre-requisites&lt;/strong&gt; : An elementary knowledge of &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/&quot;&gt;C++ Standard&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;전제 조건&lt;/strong&gt; : &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/&quot;&gt;C ++ 표준에&lt;/a&gt; 대한 기초 지식</target>
        </trans-unit>
        <trans-unit id="6a9f93a852c700a1f842b06c832daeaedac1a0df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pre-requisites&lt;/strong&gt; : An elementary knowledge of Relations (Mathematics).</source>
          <target state="translated">&lt;strong&gt;선수 과목&lt;/strong&gt; : 관계 (수학)에 대한 기초 지식.</target>
        </trans-unit>
        <trans-unit id="bb16d5b7f750e589aa8591dc2b0311cf94f000d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequence Points&lt;/strong&gt; have been replaced by &lt;strong&gt;Sequenced Before&lt;/strong&gt; and &lt;strong&gt;Sequenced After&lt;/strong&gt; (and &lt;strong&gt;Unsequenced&lt;/strong&gt; and &lt;strong&gt;Indeterminately Sequenced&lt;/strong&gt;) &lt;a href=&quot;http://en.wikipedia.org/wiki/Relation_(mathematics)&quot;&gt;relations&lt;/a&gt; in C++11.</source>
          <target state="translated">C ++ 11에서 &lt;strong&gt;Sequence Points&lt;/strong&gt; 는 &lt;strong&gt;Sequenced Before&lt;/strong&gt; 및 &lt;strong&gt;Sequenced After&lt;/strong&gt; (및 &lt;strong&gt;Unsequenced&lt;/strong&gt; and &lt;strong&gt;Indeterminately Sequenced&lt;/strong&gt; ) &lt;a href=&quot;http://en.wikipedia.org/wiki/Relation_(mathematics)&quot;&gt;관계&lt;/a&gt; 로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d34bf4d70820266daeb2ec70d0a4d26cfd065ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sequenced Before&lt;/strong&gt;&lt;sup&gt;(&amp;sect;1.9/13)&lt;/sup&gt; is a relation which is:</source>
          <target state="translated">&lt;strong&gt;Sequenced Before&lt;/strong&gt; &lt;sup&gt;(&amp;sect;1.9 / 13)&lt;/sup&gt; 는 다음과 같은 관계입니다.</target>
        </trans-unit>
        <trans-unit id="204dc21a36933167085eb6437592dd1d62d82250" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is a follow up to my &lt;a href=&quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4176333#4176333&quot;&gt;previous answer&lt;/a&gt; and contains C++11 related material.&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;이것은 &lt;a href=&quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4176333#4176333&quot;&gt;이전 답변에 대한&lt;/a&gt; 후속 조치이며 C ++ 11 관련 자료를 포함합니다.&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2d52f13cea96c3b5a3d0d430c90cf5210a996c3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Transitive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Transitive&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c671d5cd81ed0921c79d3cd1899a9bca816d7f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes!&lt;/strong&gt; Right.</source>
          <target state="translated">&lt;strong&gt;예!&lt;/strong&gt; 권리.</target>
        </trans-unit>
        <trans-unit id="022e9567b2b3b169242f2a720ec0a6d446c419ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes!&lt;/strong&gt; This is very true.</source>
          <target state="translated">&lt;strong&gt;예!&lt;/strong&gt; 이것은 매우 사실입니다.</target>
        </trans-unit>
        <trans-unit id="929829f559fa26e55cfe9537499e25f431156fbc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value computations&lt;/strong&gt; (including determining the identity of an object for &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;glvalue evaluation&lt;/a&gt; and fetching a value previously assigned to an object for &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;prvalue evaluation&lt;/a&gt;) and</source>
          <target state="translated">&lt;strong&gt;가치 계산&lt;/strong&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;glvalue 평가&lt;/a&gt; 를위한 객체의 아이덴티티 결정 및 prvalue 평가 를 위해 객체에 이전에 할당 된 값 가져 오기 포함)</target>
        </trans-unit>
        <trans-unit id="620ae72342c6c376f4c4a1a08f78905e1878296d" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;(Note: This is meant to be an entry to &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow's C++ FAQ&lt;/a&gt;. If you want to critique the idea of providing an FAQ in this form, then &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;the posting on meta that started all this&lt;/a&gt; would be the place to do that. Answers to that question are monitored in the &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C++ chatroom&lt;/a&gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;(참고 : 이것은 &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow의 C ++ FAQ에&lt;/a&gt; 대한 항목입니다.이 양식으로 FAQ를 제공한다는 아이디어를 비판하려면이 &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;모든 것을 시작한 메타에 게시&lt;/a&gt; 하면됩니다. 이 질문은 &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C ++ 대화방&lt;/a&gt; 에서 모니터링되며 여기서 FAQ 아이디어는 처음부터 시작되었으므로 아이디어를 얻은 사람들이 귀하의 답변을 읽을 가능성이 큽니다.)&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a426f588a643ba6573aa0dc06dff29890b117809" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt; 3 : permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or with-
out the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;3 : 허용되지 않는 정의 된 동작은 예측할 수없는 결과로 상황을 완전히 무시하는 것부터, 환경의 문서화 된 방식으로 진단 또는 프로그램 실행 중 (진단 메시지 발행 여부에 관계없이), 번역 또는 실행 종료에 이르기까지 다양합니다. (진단 메시지 발행).&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="95ae89f99caff438000886790fcdd7dc75b710de" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt; 4: In an expression that is evaluated more than once during the execution
of a program, &lt;strong&gt;unsequenced&lt;/strong&gt; and &lt;strong&gt;indeterminately sequenced&lt;/strong&gt; evaluations of its subexpressions need not be performed consistently in different evaluations. &lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;4 : 프로그램 실행 중에 두 번 이상 평가되는 표현식에서 하위 표현식에 대해 &lt;strong&gt;순서가 지정&lt;/strong&gt; &lt;strong&gt;되지&lt;/strong&gt; 않고 &lt;strong&gt;불확실하게 시퀀싱 된&lt;/strong&gt; 평가를 다른 평가에서 일관되게 수행 할 필요는 없습니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9312fa9a457767f8b93b9c4711607a7389eaf60e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;1 : Note : the evaluation of a full-expression can include the evaluation of subexpressions that are not lexically
part of the full-expression.  For example, subexpressions involved in evaluating default argument expressions (8.3.6) are considered to be created in the expression that calls the function, not the expression that defines the default argument&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;1 : 참고 : 전체 표현 평가에는 전체 표현의 어휘 부분이 아닌 하위 표현 평가가 포함될 수 있습니다.&lt;/sub&gt; &lt;sub&gt;예를 들어, 기본 인수 표현식 (8.3.6)을 평가하는 데 포함 된 하위 표현식은 기본 인수를 정의하는 표현식이 아니라 함수를 호출하는 표현식에서 작성된 것으로 간주됩니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="60038c8883c25d5e00c8087ef90a1ff8f121ef42" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;2 : The operators indicated are the built-in operators, as described in clause 5.  When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation and the operands form an argument list, without an implied sequence point between them.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;2 : 표시된 연산자는 5 절에 설명 된 내장 연산자입니다. 이러한 연산자 중 하나가 유효한 컨텍스트에서 오버로드되어 (13 절) 사용자 정의 연산자 함수를 지정하면 표현식은 함수 호출을 지정합니다. 피연산자는 그들 사이에 내재 된 순서 지점없이 인수 목록을 형성합니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="dd3c08ea9f72c1327d8c8c9d45bc917ac9981426" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;[NOTES]&lt;/sub&gt;&lt;sub&gt;&lt;br/&gt;
  1 :  A strict partial order is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_relation&quot;&gt;&lt;strong&gt;binary relation&lt;/strong&gt;&lt;/a&gt; &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; over a set &lt;code&gt;P&lt;/code&gt; which is &lt;a href=&quot;http://en.wikipedia.org/wiki/Asymmetric_relation&quot;&gt;&lt;code&gt;asymmetric&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;http://en.wikipedia.org/wiki/Transitive_relation&quot;&gt;&lt;code&gt;transitive&lt;/code&gt;&lt;/a&gt;, i.e., for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;P&lt;/code&gt;, we have that:&lt;br/&gt; &lt;/sub&gt;&lt;sub&gt;  ........(i). if a &amp;lt; b then &amp;not; (b &amp;lt; a) (&lt;code&gt;asymmetry&lt;/code&gt;);&lt;br/&gt;
  ........(ii). if a &amp;lt; b and b &amp;lt; c then a &amp;lt; c (&lt;code&gt;transitivity&lt;/code&gt;).&lt;br/&gt;
  2 : The execution of &lt;strong&gt;unsequenced evaluations&lt;/strong&gt; can &lt;em&gt;overlap&lt;/em&gt;.&lt;br/&gt;
  3 : &lt;strong&gt;Indeterminately sequenced evaluations&lt;/strong&gt; cannot &lt;em&gt;overlap&lt;/em&gt;, but either could be executed first.
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;[노트]&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;1 : 엄격한 부분 순서는 세트 &lt;code&gt;P&lt;/code&gt; 에 대한 &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_relation&quot;&gt;&lt;strong&gt;이진 관계&lt;/strong&gt;&lt;/a&gt; &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Asymmetric_relation&quot;&gt; &lt;code&gt;asymmetric&lt;/code&gt; &lt;/a&gt; 적이고 &lt;a href=&quot;http://en.wikipedia.org/wiki/Transitive_relation&quot;&gt; &lt;code&gt;transitive&lt;/code&gt; &lt;/a&gt; . 즉 &lt;code&gt;P&lt;/code&gt; 의 모든 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 에 대해 다음과 같이됩니다.&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;........(나는).&lt;/sub&gt; &lt;sub&gt;a &amp;lt;b이면 &amp;not; (b &amp;lt;a) ( &lt;code&gt;asymmetry&lt;/code&gt; );&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;........ (ii).&lt;/sub&gt; &lt;sub&gt;a &amp;lt;b 및 b &amp;lt;c이면 a &amp;lt;c ( &lt;code&gt;transitivity&lt;/code&gt; )&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;2 : 순서없는 &lt;strong&gt;평가&lt;/strong&gt; 실행이 &lt;em&gt;겹칠&lt;/em&gt; 수 있습니다.&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;3 : &lt;strong&gt;불확실한 시퀀스 평가&lt;/strong&gt; 는 &lt;em&gt;중복&lt;/em&gt; 될 수 없지만 둘 중 하나를 먼저 실행할 수 있습니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="c7f05a513b706b4a1f9cb106d583e49db558645f" translate="yes" xml:space="preserve">
          <source>An expression &lt;em&gt;X&lt;/em&gt; is said to be sequenced before an expression &lt;em&gt;Y&lt;/em&gt; if every
  value computation and every side effect associated with the expression &lt;em&gt;X&lt;/em&gt; is sequenced before every value
  computation and every side effect associated with the expression &lt;em&gt;Y&lt;/em&gt;.</source>
          <target state="translated">식 &lt;em&gt;X&lt;/em&gt; 와 관련된 모든 값 계산 및 모든 부작용이 식 &lt;em&gt;Y&lt;/em&gt; 와 관련된 모든 값 계산 및 모든 부작용 전에 시퀀싱된다면, 식 &lt;em&gt;X&lt;/em&gt; 는 식 &lt;em&gt;Y&lt;/em&gt; 전에 시퀀싱된다고한다.</target>
        </trans-unit>
        <trans-unit id="153d5bd3ffb42c2afbf3901847ae23308ee5a040" translate="yes" xml:space="preserve">
          <source>Another example &lt;a href=&quot;https://stackoverflow.com/questions/3457967/what-belongs-in-an-educational-tool-to-demonstrate-the-unwarranted-assumptions-pe/3458842#3458842&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/3457967/what-belongs-in-an-educational-tool-to-demonstrate-the-unwarranted-assumptions-pe/3458842#3458842&quot;&gt;여기&lt;/a&gt; 또 다른 예가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ec01806be24062fea2d9f86213ec8a1e47cbe35" translate="yes" xml:space="preserve">
          <source>At  certain specified points in the execution sequence called &lt;strong&gt;sequence points&lt;/strong&gt;, all &lt;em&gt;side effects&lt;/em&gt; of previous evaluations 
  shall be complete and no &lt;em&gt;side effects&lt;/em&gt; of subsequent evaluations shall have taken place. (&amp;sect;1.9/7)</source>
          <target state="translated">실행 순서에서 &lt;strong&gt;시퀀스 포인트&lt;/strong&gt; 라고하는 특정 지점에서 이전 평가의 모든 &lt;em&gt;부작용&lt;/em&gt; 이 완료되고 후속 평가의 &lt;em&gt;부작용&lt;/em&gt; 이 발생하지 않아야합니다. (&amp;sect;1.9 / 7)</target>
        </trans-unit>
        <trans-unit id="daf318858a3809a2aa50a9396bad28cdbbc5b979" translate="yes" xml:space="preserve">
          <source>Before I get into that you must know the difference(s) between &lt;a href=&quot;https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior&quot;&gt;Undefined Behaviour, Unspecified Behaviour and Implementation Defined Behaviour&lt;/a&gt;.</source>
          <target state="translated">들어가기 전에 &lt;a href=&quot;https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior&quot;&gt;Undefined Behaviour, Unspecified Behavior 및 Implementation Defined Behavior&lt;/a&gt; 의 차이점을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="91dd0af55b97c31dc0bccf19143f7b7880f341a1" translate="yes" xml:space="preserve">
          <source>But in &lt;code&gt;N4659&lt;/code&gt;</source>
          <target state="translated">그러나 &lt;code&gt;N4659&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="d51d489d3ac886e7ea3ca9a2b07bed917b53895d" translate="yes" xml:space="preserve">
          <source>But the following expressions are fine:</source>
          <target state="translated">그러나 다음 표현은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="99eaf8f6cc151e73b21d6790c8bc8a2b84b7ba36" translate="yes" xml:space="preserve">
          <source>C++98 and C++03</source>
          <target state="translated">C ++ 98 및 C ++ 03</target>
        </trans-unit>
        <trans-unit id="9e67e09870ca0989e71cb269267edc0455043285" translate="yes" xml:space="preserve">
          <source>Evaluation  of  an  expression produces something and if in addition there is a change in the state of the execution environment it is said that the expression (its evaluation) has some side effect(s).</source>
          <target state="translated">표현식의 평가는 무언가를 생성하고, 실행 환경의 상태에 변화가 있다면, 그 표현식 (평가)은 부작용이 있다고합니다.</target>
        </trans-unit>
        <trans-unit id="ba67e3bf4a955da66b33b710af3baabeaf6f5983" translate="yes" xml:space="preserve">
          <source>Evaluation of operands of &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operators are unsequenced relative to each other.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 연산자의 피연산자 평가는 서로에 대해 순서가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64e262c018b20f74702f4f2184ebedf6e4ec767b" translate="yes" xml:space="preserve">
          <source>Evaluation of operands of &lt;code&gt;+&lt;/code&gt; operator are unsequenced relative to each other.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 연산자의 피연산자 평가는 서로에 대해 순서가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4207deb1ca4c1aeaec83c1e9887c129a6054ca46" translate="yes" xml:space="preserve">
          <source>Evaluations &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are &lt;strong&gt;indeterminately sequenced&lt;/strong&gt; when either &lt;code&gt;A&lt;/code&gt; is sequenced before &lt;code&gt;B&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; is sequenced before &lt;code&gt;A&lt;/code&gt;, but it is unspecified which&lt;sup&gt;3&lt;/sup&gt;.</source>
          <target state="translated">평가 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 보다 먼저 &lt;strong&gt;시퀀싱&lt;/strong&gt; 될 때 또는 &lt;code&gt;B&lt;/code&gt; 가 &lt;code&gt;A&lt;/code&gt; 보다 먼저 &lt;strong&gt;시퀀싱&lt;/strong&gt; 될 때 &lt;strong&gt;불확실하게 시퀀싱&lt;/strong&gt; 되지만 어느 것이 &lt;sup&gt;3&lt;/sup&gt; 인지는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c07fa7c9e378ccd40615376ea6880ef0d1c7126" translate="yes" xml:space="preserve">
          <source>Every value computation and side effect associated with a full-expression is &lt;strong&gt;sequenced before&lt;/strong&gt; every value computation and side effect associated with the &lt;strong&gt;next full-expression to be evaluated&lt;/strong&gt;.</source>
          <target state="translated">전체 표현식과 관련된 모든 값 계산 및 부작용 &lt;strong&gt;은 평가할 다음 전체 표현식&lt;/strong&gt; 과 관련된 모든 값 계산 및 부작용 &lt;strong&gt;보다 먼저 시퀀싱&lt;/strong&gt; &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8ef2e1210c47909b18d1b60b9c30a0116c39a246" translate="yes" xml:space="preserve">
          <source>Example 1:</source>
          <target state="translated">예 1 :</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">예 2 :</target>
        </trans-unit>
        <trans-unit id="19b6677ab36387289cbb2372a028e31d1e438889" translate="yes" xml:space="preserve">
          <source>Example 3 :</source>
          <target state="translated">예 3 :</target>
        </trans-unit>
        <trans-unit id="0483beb1135269908e7a45fb455b6f6963675242" translate="yes" xml:space="preserve">
          <source>Example :</source>
          <target state="translated">예 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="406e4bca4b11d6e472a01508642fc217ed5ef469" translate="yes" xml:space="preserve">
          <source>Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are &lt;strong&gt;unsequenced&lt;/strong&gt;&lt;sup&gt;4&lt;/sup&gt;.</source>
          <target state="translated">언급 된 경우를 제외하고, 개별 연산자의 피연산자 및 개별 표현식의 하위 표현식 평가는 순서가 없습니다 &lt;sup&gt;4&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="a860b41292f726793b4b3135e3a7635bcdbf99ef" translate="yes" xml:space="preserve">
          <source>Expressions &lt;code&gt;(5)&lt;/code&gt;, &lt;code&gt;(7)&lt;/code&gt; and &lt;code&gt;(8)&lt;/code&gt; do not invoke undefined behaviour. Check out the following answers for a more detailed explanation.</source>
          <target state="translated">식 &lt;code&gt;(5)&lt;/code&gt; , &lt;code&gt;(7)&lt;/code&gt; 및 &lt;code&gt;(8)&lt;/code&gt; 은 정의되지 않은 동작을 호출하지 않습니다. 자세한 설명은 다음 답변을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="88fa3152aa1a080052016562134c18cdbc4e0603" translate="yes" xml:space="preserve">
          <source>For example :</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f42745ac0f5de04dd9f5e31b65fbbb63e4c15167" translate="yes" xml:space="preserve">
          <source>For example in &lt;code&gt;i = i + 1&lt;/code&gt; all the access of &lt;code&gt;i&lt;/code&gt; (in L.H.S and in R.H.S) are &lt;strong&gt;directly involved in computation&lt;/strong&gt; of the value to be written. So it is fine.</source>
          <target state="translated">예를 들어, &lt;code&gt;i = i + 1&lt;/code&gt; 에서 i의 모든 접근 (LHS 및 RHS)은 기록 될 값의 &lt;strong&gt;계산&lt;/strong&gt; 에 &lt;strong&gt;직접 관여&lt;/strong&gt; 합니다. 그래서 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9aa68292d7569023871135b4089b691e89a56f5a" translate="yes" xml:space="preserve">
          <source>Formally it means given any two evaluations&lt;sup&gt;(See below)&lt;/sup&gt;&lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, if &lt;code&gt;A&lt;/code&gt; is &lt;strong&gt;sequenced before&lt;/strong&gt;&lt;code&gt;B&lt;/code&gt;, then the execution of &lt;code&gt;A&lt;/code&gt;&lt;em&gt;shall precede&lt;/em&gt; the execution of &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;A&lt;/code&gt; is not sequenced before &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; is not sequenced before &lt;code&gt;A&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are &lt;strong&gt;unsequenced&lt;/strong&gt;&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">공식적으로 그것은 두 가지 평가 &lt;sup&gt;(아래 참조)가&lt;/sup&gt; 주어 졌음을 의미합니다 &lt;sup&gt;(&lt;/sup&gt; &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; &lt;sup&gt;)&lt;/sup&gt; . &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; &lt;em&gt;보다 먼저&lt;/em&gt; &lt;strong&gt;순서화&lt;/strong&gt; 되면 A 의 실행이 &lt;code&gt;B&lt;/code&gt; 의 실행 &lt;em&gt;보다 우선&lt;/em&gt; 합니다. &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 보다 먼저 시퀀싱되지 않고 &lt;code&gt;B&lt;/code&gt; 가 &lt;code&gt;A&lt;/code&gt; 보다 먼저 시퀀싱 &lt;strong&gt;되지 않은&lt;/strong&gt; 경우 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 는 시퀀싱되지 않습니다 &lt;sup&gt;2&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="eac423cee75b32090f5d0d9792a419ddd0af5e6f" translate="yes" xml:space="preserve">
          <source>From the above sentence the following expressions invoke Undefined Behaviour:</source>
          <target state="translated">위 문장에서 다음 표현식은 정의되지 않은 동작을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ba6c960249f3aafc39737f39e23d6cefa0037a31" translate="yes" xml:space="preserve">
          <source>However several other similar cases still lead to undefined behavior.</source>
          <target state="translated">그러나 몇 가지 다른 유사한 사례는 여전히 정의되지 않은 동작으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="64f407e5e5f324cd785789444eed0a59f0937e5e" translate="yes" xml:space="preserve">
          <source>I am guessing there is a fundamental reason for the change, it isn't merely cosmetic to make the old interpretation clearer: that reason is concurrency. Unspecified order of elaboration is merely selection of one of several possible serial orderings, this is quite different to before and after orderings, because if there is no specified ordering, concurrent evaluation is possible: not so with the old rules. For example in:</source>
          <target state="translated">나는 변화의 근본적인 이유가 있다고 추측하고 있습니다. 오래된 해석을 더 명확하게 만드는 것은 단지 화장품이 아닙니다. 그 이유는 동시성입니다. 지정되지 않은 정교화 순서는 가능한 여러 일련의 순서 중 하나를 선택하는 것입니다. 이는 지정된 순서가 없으면 동시 평가가 가능하기 때문에 순서 전후와는 상당히 다릅니다. 이전 규칙은 그렇지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc15d88006a8199cfa78e1c45d14c286fb27f703" translate="yes" xml:space="preserve">
          <source>I often use funny and convoluted expressions like &lt;code&gt;a[++i] = i;&lt;/code&gt;, to make myself feel better. Why should I stop using them?</source>
          <target state="translated">나는 종종 &lt;code&gt;a[++i] = i;&lt;/code&gt; 기분이 나아지도록 왜 사용을 중단해야합니까?</target>
        </trans-unit>
        <trans-unit id="7bf88b9125f90667375d801ebb86d1d08c42099d" translate="yes" xml:space="preserve">
          <source>If you find any flaw in the post please leave a comment. Power-users (With rep &amp;gt;20000) please do not hesitate to edit the post for correcting typos and other mistakes.</source>
          <target state="translated">게시물에 결함이 있으면 의견을 남겨주세요. 고급 사용자 (rep&amp;gt; 20000)는 오타 및 기타 실수를 수정하기 위해 게시물을 편집하는 것을 망설이지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bc47a04d1a4bab80348b412aad415fc3dd9f9ce5" translate="yes" xml:space="preserve">
          <source>If you've read this, be sure to visit the follow-up question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4638364&quot;&gt;Undefined behavior and sequence points reloaded&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">이 내용을 읽은 경우 후속 질문 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4638364&quot;&gt;Undefined behavior and sequence points reloaded&lt;/a&gt;&lt;/em&gt; 를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="652e555c4df01fc076aec8ee7a1d86b707fe7184" translate="yes" xml:space="preserve">
          <source>In (&amp;sect;1.9/15) it has been mentioned that</source>
          <target state="translated">(&amp;sect;1.9 / 15)에서 다음과 같이 언급되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c52f5367ab947bba6d1b1cf5bca260a9edc87de" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C99(ISO/IEC 9899:TC3)&lt;/code&gt; which seems absent from this discussion thus far the following steteents are made regarding order of evaluaiton.</source>
          <target state="translated">이 논의에서 결여 된 것으로 보이는 &lt;code&gt;C99(ISO/IEC 9899:TC3)&lt;/code&gt; 에서는 지금까지 평가 순서에 따라 다음과 같은 악취가 나게된다.</target>
        </trans-unit>
        <trans-unit id="bd5b7a4772b25de672849363c08a46e9876609fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;N4140&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;N4140&lt;/code&gt; 에서 :</target>
        </trans-unit>
        <trans-unit id="c7e36d1d9a63e34fb0930c72cc616f8c4fbbd0c1" translate="yes" xml:space="preserve">
          <source>In C++11, evaluation of an expression (or a sub-expression) in general includes:</source>
          <target state="translated">C ++ 11에서 일반적으로 표현식 (또는 하위 표현식)의 평가에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="940e8112672c49e76504070e5cdf7d536f7df4e1" translate="yes" xml:space="preserve">
          <source>In addition to the initialization operation the value of &lt;code&gt;y&lt;/code&gt; gets changed due to the side effect of &lt;code&gt;++&lt;/code&gt; operator.</source>
          <target state="translated">초기화 작업 외에도 &lt;code&gt;++&lt;/code&gt; 연산자의 부작용으로 인해 &lt;code&gt;y&lt;/code&gt; 값이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e3894686d84dca096a2337f3716d28b44fedb4db" translate="yes" xml:space="preserve">
          <source>In all cases, the assignment is sequenced after the value
  computation of the right and left operands, and before the value computation of the assignment expression.
  &lt;strong&gt;&lt;em&gt;The right operand is sequenced before the left operand.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">모든 경우에, 할당은 오른쪽과 왼쪽 피연산자의 값 계산 후와 할당 표현식의 값 계산 전에 순서화됩니다. &lt;strong&gt;&lt;em&gt;오른쪽 피연산자는 왼쪽 피연산자보다 먼저 시퀀싱됩니다.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f3783804d60a76a00fd374673d91cebbb0e44e25" translate="yes" xml:space="preserve">
          <source>In particular, the &lt;strong&gt;&lt;em&gt;following sentence&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">특히 &lt;strong&gt;&lt;em&gt;다음 문장&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="617effb1d8e8263589de961e2e7b9f950ccfd3d0" translate="yes" xml:space="preserve">
          <source>In short, undefined behaviour means &lt;strong&gt;anything&lt;/strong&gt; can happen from daemons flying out of your nose to  your girlfriend getting pregnant.</source>
          <target state="translated">즉, 정의되지 않은 동작은 코에서 날아 오는 데몬에서 여자 친구가 임신하는 것에 이르기까지 &lt;strong&gt;모든&lt;/strong&gt; 일이 발생할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="30e4fdc9922ca401ebec5c5d2ca75e8eddd91c38" translate="yes" xml:space="preserve">
          <source>Informally it means that between two sequence points a variable must not be modified more than once.
In an expression statement, the &lt;code&gt;next sequence point&lt;/code&gt; is usually at the terminating semicolon, and the &lt;code&gt;previous sequence point&lt;/code&gt; is at the end of the previous statement. An expression may also contain intermediate &lt;code&gt;sequence points&lt;/code&gt;.</source>
          <target state="translated">공식적으로 두 시퀀스 포인트 사이에서 변수를 두 번 이상 수정해서는 안됩니다. 표현식 명령문에서 &lt;code&gt;next sequence point&lt;/code&gt; 는 일반적으로 종료 세미콜론에 있으며 &lt;code&gt;previous sequence point&lt;/code&gt; 는 이전 명령문의 끝에 있습니다. 표현식은 중간 &lt;code&gt;sequence points&lt;/code&gt; 포함 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="72d6c19372257ac1933afb0a881d59d363366e13" translate="yes" xml:space="preserve">
          <source>Is it true that there are no Sequence Points in C++11?</source>
          <target state="translated">C ++ 11에 시퀀스 포인트가 없다는 것이 사실입니까?</target>
        </trans-unit>
        <trans-unit id="8bdbba62423aafb33233c14c04af680f2c1edba6" translate="yes" xml:space="preserve">
          <source>More importantly</source>
          <target state="translated">더 중요한 것은</target>
        </trans-unit>
        <trans-unit id="990cdd13220ac29d0b6ede208ef83a4fa9dbd84e" translate="yes" xml:space="preserve">
          <source>Multiple preincrement operations on a variable in C++0x</source>
          <target state="translated">C ++ 0x에서 변수에 대한 다중 사전 증분 연산</target>
        </trans-unit>
        <trans-unit id="d1ed313837b92d00cf87c6dae332f5af91bfca80" translate="yes" xml:space="preserve">
          <source>Now  (&amp;sect;1.9/14) says:</source>
          <target state="translated">이제 (&amp;sect;1.9 / 14)는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="8a484c465793ca714b6bcdc23b747ba39bd901d6" translate="yes" xml:space="preserve">
          <source>Now the Standard in &lt;code&gt;&amp;sect;5/4&lt;/code&gt; says</source>
          <target state="translated">이제 &lt;code&gt;&amp;sect;5/4&lt;/code&gt; 의 표준에 따르면</target>
        </trans-unit>
        <trans-unit id="8bd7723fe01aeb7a98d73d693451c80beee344d7" translate="yes" xml:space="preserve">
          <source>Of course, using a C++17 compliant compiler does not necessarily mean that one should start writing such expressions.</source>
          <target state="translated">물론 C ++ 17 호환 컴파일러를 사용한다고해서 반드시 그러한 표현식을 작성해야한다는 의미는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="458d1997bcf26b81560b08ea6ea5be3aa11f4376" translate="yes" xml:space="preserve">
          <source>Sequence point is a point in time at which the dust has settled and all side effects which have been seen so far are guaranteed to be complete.</source>
          <target state="translated">시퀀스 포인트는 먼지가 침전 된 시점이며 지금까지 본 모든 부작용이 완벽하게 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="9b53077da07196f084c3c12e2d14dc1059eec0c2" translate="yes" xml:space="preserve">
          <source>Side effects? What are side effects?</source>
          <target state="translated">부작용? 부작용은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e25244b7a39a375416acf31f2d6810f2b050173a" translate="yes" xml:space="preserve">
          <source>So far so good. Moving on to sequence points. An alternation definition of seq-points given by the comp.lang.c author &lt;code&gt;Steve Summit&lt;/code&gt;:</source>
          <target state="translated">여태까지는 그런대로 잘됐다. 시퀀스 포인트로 넘어갑니다. comp.lang.c 저자 &lt;code&gt;Steve Summit&lt;/code&gt; 이 제공 한 seq-points의 대체 정의 :</target>
        </trans-unit>
        <trans-unit id="3276033ca3f269623eda3a83e62e8252eee54d70" translate="yes" xml:space="preserve">
          <source>So there must be some relation between Undefined Behaviour and the above-mentioned things, right?</source>
          <target state="translated">정의되지 않은 행동과 위에 언급 된 것들 사이에는 어떤 관계가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="eabf5b327e550da30860ed745c1e2eae65082eff" translate="yes" xml:space="preserve">
          <source>That means in &lt;code&gt;x + y&lt;/code&gt; the value computation of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are sequenced before the value computation of &lt;code&gt;(x + y)&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;x + y&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 값 계산이 &lt;code&gt;(x + y)&lt;/code&gt; 의 값 계산 전에 순서화됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="04fa30dedddd3187dfef29f539bfd6d837ce07f7" translate="yes" xml:space="preserve">
          <source>The Standard defines Undefined Behaviour in Section &lt;code&gt;&amp;sect;1.3.12&lt;/code&gt; as</source>
          <target state="translated">표준은 &lt;code&gt;&amp;sect;1.3.12&lt;/code&gt; 에서 정의되지 않은 행동을 다음 과 같이 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cc3825fe31d3f227de05d63696f01adfd25413f6" translate="yes" xml:space="preserve">
          <source>The Standard says</source>
          <target state="translated">표준은 말한다</target>
        </trans-unit>
        <trans-unit id="ecfe246ba857988aa603cf220b0140b9f496a485" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands is unspecified. If an attempt
  is made to modify the result of an assignment operator or to access it
  after the next sequence point, the behavior[sic] is undefined.(Section
  6.5.16 pp 91)</source>
          <target state="translated">피연산자의 평가 순서는 지정되어 있지 않습니다. 할당 연산자의 결과를 수정하거나 다음 시퀀스 포인트 이후에 액세스하려고하면 동작 [sic]이 정의되지 않습니다 (6.5.16 pp 91 절).</target>
        </trans-unit>
        <trans-unit id="98d34d7717c305fec376084020473ffd968566be" translate="yes" xml:space="preserve">
          <source>This answer is for the older versions of the C++ standard.  The C++11 and C++14 versions of the standard do not formally contain 'sequence points'; operations are 'sequenced before' or 'unsequenced' or 'indeterminately sequenced' instead.  The net effect is essentially the same, but the terminology is different.</source>
          <target state="translated">이 답변은 이전 버전의 C ++ 표준에 대한 것입니다. 표준의 C ++ 11 및 C ++ 14 버전은 공식적으로 '시퀀스 포인트'를 포함하지 않습니다. 대신에 '시퀀스 이전'또는 '시퀀스되지 않은'또는 '불확정 한 시퀀스'연산이 수행됩니다. 순 효과는 본질적으로 동일하지만 용어는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="391877d79b1fd6dd824fd29ab9c7d8d671230e24" translate="yes" xml:space="preserve">
          <source>This rule effectively constrains legal expressions to those in which the accesses demonstrably precede the modification.</source>
          <target state="translated">이 규칙은 법적 표현이 접근이 수정 전에 명백하게 적용되는 표현으로 효과적으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="f7263d87574b12081e5695094ca83a2c5298a6b0" translate="yes" xml:space="preserve">
          <source>Those are:</source>
          <target state="translated">사람들은:</target>
        </trans-unit>
        <trans-unit id="86ffe4e34823f77699906a8f2cc28e0a36b44be6" translate="yes" xml:space="preserve">
          <source>Trivial example:</source>
          <target state="translated">사소한 예 :</target>
        </trans-unit>
        <trans-unit id="a15a56e2346e0d81d8d95c79e39e94430fe5d1e8" translate="yes" xml:space="preserve">
          <source>Undefined  behavior  may  also  be  expected  when  this
  International Standard omits the description of any explicit definition of behavior.</source>
          <target state="translated">이 국제 표준이 행동의 명시 적 정의에 대한 설명을 생략 할 때 정의되지 않은 행동이 예상 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5109b2e7ff59ff1bf194187e9b404f9b063d4e37" translate="yes" xml:space="preserve">
          <source>Undefined behavior and sequence points</source>
          <target state="translated">정의되지 않은 동작 및 시퀀스 포인트</target>
        </trans-unit>
        <trans-unit id="fbb99fc8283814cb9af4d737b1328eb2f80f2298" translate="yes" xml:space="preserve">
          <source>Unsequenced Value Computations</source>
          <target state="translated">순차 가치 계산</target>
        </trans-unit>
        <trans-unit id="0b9ee0bad57b9aa23197de1969ca62cd45c0e10e" translate="yes" xml:space="preserve">
          <source>Value computation and side effect associated with &lt;code&gt;++x&lt;/code&gt; is sequenced after the value computation and side effect of &lt;code&gt;x = 10;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;++x&lt;/code&gt; 와 연관된 값 계산 및 부작용은 &lt;code&gt;x = 10;&lt;/code&gt; 의 값 계산 및 부작용 후에 시퀀싱된다 ;</target>
        </trans-unit>
        <trans-unit id="c1553ee23f64335d9f5575846335c215c4f556fe" translate="yes" xml:space="preserve">
          <source>What are &quot;sequence points&quot;?</source>
          <target state="translated">&quot;시퀀스 포인트&quot;란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5580eab4cffca63ecfa895dce1c35429a7721d75" translate="yes" xml:space="preserve">
          <source>What are Sequence Points?</source>
          <target state="translated">시퀀스 포인트는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6e9c789346e18ce5be4e6deda5cc8b7767a977e7" translate="yes" xml:space="preserve">
          <source>What are the common sequence points listed in the C++ Standard ?</source>
          <target state="translated">C ++ 표준에 나열된 공통 시퀀스 포인트는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a5ed464308c94903d6f60610da2f96028a67653c" translate="yes" xml:space="preserve">
          <source>What does it mean?</source>
          <target state="translated">무슨 뜻인가요?</target>
        </trans-unit>
        <trans-unit id="ddf1970fbf15053c0de78fbdb8bb9c5a5319d4a6" translate="yes" xml:space="preserve">
          <source>What does it mean? It means if an object is written to within a full expression, any and all accesses to it within the same expression &lt;strong&gt;must be directly involved in the computation of the value to be written&lt;/strong&gt;.</source>
          <target state="translated">무슨 뜻인가요? 이는 전체 표현식 내에서 오브젝트를 작성하는 경우 동일한 표현식 내에서 오브젝트에 대한 모든 액세스 &lt;strong&gt;가 작성 될 값의 계산에 직접 포함되어야 함을 의미합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e9b9cc427f946732e721b7ccbf4b3c3166aeea40" translate="yes" xml:space="preserve">
          <source>What exactly is this 'Sequenced before' thing?</source>
          <target state="translated">이 '시퀀스 이전'은 정확히 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="44c906335f64785d553c0284006d490c13bf0900" translate="yes" xml:space="preserve">
          <source>What is Undefined Behaviour?</source>
          <target state="translated">정의되지 않은 행동이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f9c7bb688ad67e35f31fb2b89ccb85808deb976e" translate="yes" xml:space="preserve">
          <source>What is the meaning of the word 'evaluation' in context of C++11?</source>
          <target state="translated">C ++ 11과 관련하여 '평가'라는 단어의 의미는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="093a89bf3df40d809fb2ed82e44f0855443490b8" translate="yes" xml:space="preserve">
          <source>What is the relation between Undefined Behaviour and Sequence Points?</source>
          <target state="translated">정의되지 않은 동작과 시퀀스 포인트의 관계는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="caf82056aa35f376cce3be24a9b9a2227c913f8e" translate="yes" xml:space="preserve">
          <source>What is the relation between undefined behaviour and sequence points?</source>
          <target state="translated">정의되지 않은 동작과 시퀀스 포인트 사이의 관계는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6fb1c9cfb5692133ce65e0caed51fa572a4b8df5" translate="yes" xml:space="preserve">
          <source>When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. [&lt;em&gt;Note:&lt;/em&gt;&lt;strong&gt;Value computations and side effects associated with different argument expressions are unsequenced&lt;/strong&gt;.  &amp;mdash; &lt;em&gt;end note&lt;/em&gt;]</source>
          <target state="translated">함수가 인라인인지 여부에 관계없이 함수를 호출하면 인수 표현식 또는 호출 된 함수를 지정하는 접미사 표현식과 연관된 모든 값 계산 및 부작용이 본문의 모든 표현식 또는 명령문을 실행하기 전에 순서화됩니다. 함수를 호출했습니다. [ &lt;em&gt;참고 :&lt;/em&gt; &lt;strong&gt;다른 인수 표현식과 관련된 값 계산 및 부작용은 순서가 없습니다&lt;/strong&gt; . &amp;mdash; &lt;em&gt;끝 참고&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="51b6b5895ef96bb02783c8a47c62b0dd464c3aba" translate="yes" xml:space="preserve">
          <source>You must also know that &lt;code&gt;the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="466a6585cbd4be9a5e956ed88dd68a492784a9f9" translate="yes" xml:space="preserve">
          <source>[...]the order of evaluation of subexpressions and the order in which
  side effects take place are both unspecified. (Section 6.5 pp 67)</source>
          <target state="translated">[...] 부 표현식 평가 순서와 부작용 발생 순서는 모두 지정되어 있지 않습니다. (섹션 6.5 pp 67)</target>
        </trans-unit>
        <trans-unit id="9bb817c4fd78f76ae7b6675b66a0af1204c51885" translate="yes" xml:space="preserve">
          <source>at a function call (whether or not the function is inline), after the evaluation of all function arguments (if any) which 
takes place before execution of any expressions or statements in the function body (&lt;code&gt;&amp;sect;1.9/17&lt;/code&gt;).</source>
          <target state="translated">함수 호출에서 함수가 인라인인지 여부에 관계없이 함수 본문에서 표현식 또는 명령문을 실행하기 전에 발생하는 모든 함수 인수 (있는 경우)를 평가 한 후 ( &lt;code&gt;&amp;sect;1.9/17&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f12161911d4fad86511b4eb366e2ee36effc8211" translate="yes" xml:space="preserve">
          <source>at the end of the evaluation of full expression (&lt;code&gt;&amp;sect;1.9/16&lt;/code&gt;) (A full-expression is an expression that is not a subexpression of another expression.)&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">전체 표현 평가 종료시 ( &lt;code&gt;&amp;sect;1.9/16&lt;/code&gt; ) (전체 표현은 다른 표현의 하위 표현이 아닌 표현입니다.) &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b3394eecdcb8cb1117c318cedb871d0572708579" translate="yes" xml:space="preserve">
          <source>behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes &lt;strong&gt;no  requirements &lt;sup&gt;3&lt;/sup&gt;&lt;/strong&gt;.</source>
          <target state="translated">잘못된 프로그램 구조 또는 잘못된 데이터를 사용할 때 발생할 수있는 행동 (이 국제 표준에 &lt;strong&gt;요구 사항 없음) &lt;sup&gt;3&lt;/sup&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cca93eac493b7391171ec42a66933b5d0d433e1e" translate="yes" xml:space="preserve">
          <source>between evaluations executed by a single &lt;a href=&quot;http://en.wikipedia.org/wiki/Thread_(computer_science)&quot;&gt;thread&lt;/a&gt; and induces a &lt;strong&gt;strict partial order&lt;/strong&gt;&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">단일 &lt;a href=&quot;http://en.wikipedia.org/wiki/Thread_(computer_science)&quot;&gt;스레드에&lt;/a&gt; 의해 실행되는 평가 사이에 &lt;strong&gt;엄격한 부분 순서를&lt;/strong&gt; 유도합니다 &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="3c7b1f87e9915365f75a64d6e2a47b9e86d8035e" translate="yes" xml:space="preserve">
          <source>in the evaluation of each of the following expressions after the evaluation of the first expression (&lt;code&gt;&amp;sect;1.9/18&lt;/code&gt;) &lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">첫 번째 표현의 평가 후 다음 각 표현의 평가에서 ( &lt;code&gt;&amp;sect;1.9/18&lt;/code&gt; ) &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6f83c8b6514790a9407377c3f4ef98b941b04595" translate="yes" xml:space="preserve">
          <source>initiation of &lt;strong&gt;side effects&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;부작용의&lt;/strong&gt; 시작.</target>
        </trans-unit>
        <trans-unit id="6c0c70ca023797ca6b5b8e5572c7ec724cb314ce" translate="yes" xml:space="preserve">
          <source>is disallowed because one of the accesses of &lt;code&gt;i&lt;/code&gt; (the one in &lt;code&gt;a[i]&lt;/code&gt;) has nothing to do with the value which ends up being stored in i (which happens over in &lt;code&gt;i++&lt;/code&gt;), and so there's no good way to define--either for our understanding or the compiler's--whether the access should take place before or after the incremented value is stored. So the behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 의 액세스 중 하나 ( &lt;code&gt;a[i]&lt;/code&gt; 의 액세스 중 하나)는 i에 저장된 값 ( &lt;code&gt;i++&lt;/code&gt; 에서 발생 함)과 아무 관련이 없으므로 정의 할 수있는 좋은 방법이 없기 때문에 허용되지 않습니다. 증가 된 값을 저장하기 전이나 후에 액세스를 수행해야하는지 여부를 이해하거나 컴파일러에 알릴 수 있습니다. 따라서 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6df2d1e296ea26ed60c7b7b29576ce6872dfc6a2" translate="yes" xml:space="preserve">
          <source>make several cases of previously undefined behavior valid, including the one in question:</source>
          <target state="translated">해당 사건을 포함하여 이전에 정의되지 않은 행동의 여러 사례를 유효하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="f98714b22930c003dcee8dfb1a4a94df52338e76" translate="yes" xml:space="preserve">
          <source>previously either a then b, or, b then a. Now, a and b can be evaluated with instructions interleaved or even on different cores.</source>
          <target state="translated">이전에는 a 다음 b 또는 b 다음에 a. 이제 a와 b는 인터리브 된 명령어 또는 다른 코어에서 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="016cfaace633cc6567b132c93461aba49d804cd4" translate="yes" xml:space="preserve">
          <source>the behaviour is &lt;strong&gt;undefined&lt;/strong&gt;.</source>
          <target state="translated">동작은 &lt;strong&gt;정의되어 있지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="11688589f9f4e92309082daaedd72c31492e5f21" translate="yes" xml:space="preserve">
          <source>together with the following clarification</source>
          <target state="translated">다음 설명과 함께</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
