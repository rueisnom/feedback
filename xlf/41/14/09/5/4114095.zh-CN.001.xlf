<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4114095">
    <body>
      <group id="4114095">
        <trans-unit id="e04a70a050e0184c775c34cc5b81f69d06b5dbc4" translate="yes" xml:space="preserve">
          <source>&quot;Move&quot; your head back to the desired commit.</source>
          <target state="translated">&quot;移动 &quot;你的头,回到你想要的承诺。</target>
        </trans-unit>
        <trans-unit id="4148ca3446d8d4e6a32759ec85d980d2895c84c8" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;--no-commit&lt;/code&gt; flag lets git revert all the commits at once- otherwise you'll be prompted for a message for each commit in the range, littering your history with unnecessary new commits.)</source>
          <target state="translated">（ &lt;code&gt;--no-commit&lt;/code&gt; 标志可让git一次还原所有提交-否则，系统会提示您输入该范围内每个提交的消息，从而在历史记录中出现不必要的新提交。）</target>
        </trans-unit>
        <trans-unit id="e15d04330bbe740f6a74404ee089d55347802fef" translate="yes" xml:space="preserve">
          <source>(to check COMMIT_ID use &lt;code&gt;git log&lt;/code&gt;)</source>
          <target state="translated">（要检查COMMIT_ID，请使用 &lt;code&gt;git log&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0564dd57a84c02e672779732094c56edac717756" translate="yes" xml:space="preserve">
          <source>** Note:** As mentioned in comments don't do this if you're sharing your branch with other people who have copies of the old commits</source>
          <target state="translated">注意:**注:**正如评论中提到的那样,如果你要和其他人分享你的分支,而他们有旧提交的副本,就不要这样做。</target>
        </trans-unit>
        <trans-unit id="f0c56341861d3a785e407509c045330522d22834" translate="yes" xml:space="preserve">
          <source>--hard</source>
          <target state="translated">--hard</target>
        </trans-unit>
        <trans-unit id="39cd6d54ca024c3d25abf1100015175fb07ed816" translate="yes" xml:space="preserve">
          <source>--soft</source>
          <target state="translated">--soft</target>
        </trans-unit>
        <trans-unit id="3170ffa737d53dfa1e49c230fc0deda33fe5f900" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/4114122/456814&quot;&gt;Jefromi's solutions&lt;/a&gt; are definitely the best ones, and you should definitely use them. However, for the sake of completeness, I also wanted to show these other alternative solutions that can also be used to revert a commit (in the sense that you &lt;strong&gt;create a new commit that undoes changes in previous commit&lt;/strong&gt;, just like what &lt;code&gt;git revert&lt;/code&gt; does).</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/4114122/456814&quot;&gt;Jefromi的解决方案&lt;/a&gt;绝对是最好的解决方案 ，您绝对应该使用它们。 但是，为了完整起见，我还想展示这些其他可替代的解决方案，这些解决方案也可用于还原提交（从某种意义上说，您&lt;strong&gt;创建了一个新的提交，可以撤消先前提交中的更改&lt;/strong&gt; ，就像 &lt;code&gt;git revert&lt;/code&gt; 所做的那样） 。</target>
        </trans-unit>
        <trans-unit id="7e7010d06d8ef75028c81045c4e8e665e47400c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--soft&lt;/code&gt; indicates that the uncommitted files should be retained as working files opposed to &lt;code&gt;--hard&lt;/code&gt; which would discard them.</source>
          <target state="translated">&lt;code&gt;--soft&lt;/code&gt; 表示未提交的文件应保留为工作文件，而 &lt;code&gt;--hard&lt;/code&gt; 则将其丢弃。</target>
        </trans-unit>
        <trans-unit id="af9a83c35282ccf6b38d1f91d218020d39a4319e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HEAD&lt;/code&gt; is simply a reference to the current commit (latest) on the current branch. There can only be a single &lt;code&gt;HEAD&lt;/code&gt; at any given time (excluding &lt;code&gt;git worktree&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 只是对当前分支上当前提交（最新）的引用。 在任何给定时间（ &lt;code&gt;git worktree&lt;/code&gt; 除外 ）只能有一个 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9377808b29b1b2885d71fd864cfb1eaf22a08f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HEAD~1&lt;/code&gt; is the last commit.  If you want to rollback 3 commits you could use &lt;code&gt;HEAD~3&lt;/code&gt;.  If you want to rollback to a specific revision number, you could also do that using its SHA hash.</source>
          <target state="translated">&lt;code&gt;HEAD~1&lt;/code&gt; 是最后的提交。 如果要回滚3次提交，则可以使用 &lt;code&gt;HEAD~3&lt;/code&gt; 。 如果要回滚到特定的修订版号，也可以使用其SHA哈希值来完成。</target>
        </trans-unit>
        <trans-unit id="8362fb05761b16c13e670545438dd3cbe76732ed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Sample:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Sample:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43d0a6c03da527ec12858c306ab6555e6caf9088" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-reset&quot;&gt;&lt;code&gt;git reset HEAD --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-reset&quot;&gt; &lt;code&gt;git reset HEAD --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5941d87399c11b4c01ccb41bbd0ab033fe969fd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;code&gt;First of all what is HEAD?&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;First of all what is HEAD?&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1253bf83df98a1b2c7a29a783edb0908bb3dd47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;code&gt;detached HEAD&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;detached HEAD&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19f54112a4fcd0d690e93b53da0c501fa0fff714" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution!&lt;/strong&gt; This command can cause losing commit history, if user put the wrong commit mistakenly. Always have en extra backup of your git some
  where else just in case if you do mistakes, than you are a bit safer.
  :)</source>
          <target state="translated">&lt;strong&gt;警告！&lt;/strong&gt; 如果用户错误地输入了错误的提交，该命令可能会导致丢失提交历史。 始终在其他地方进行git的额外备份，以防万一您犯错，那会比安全一些。 :)</target>
        </trans-unit>
        <trans-unit id="785ae5f8e57e7bb1825787323ff5e8191b3b952c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every time the HEAD is modified there will be a new entry in the &lt;code&gt;reflog&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;每次修改HEAD时， &lt;code&gt;reflog&lt;/code&gt; 中都会有一个新条目&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6859536c2cfa6c9f9a2889b1c0dd1aa5ed99eb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt; using &lt;code&gt;git reset&lt;/code&gt;, you can reset to a specific state. It's common using it with a commit hash as you see above.</source>
          <target state="translated">&lt;strong&gt;说明：&lt;/strong&gt;使用 &lt;code&gt;git reset&lt;/code&gt; ，您可以重置为特定状态。 如上所示，将其与提交哈希一起使用是很常见的。</target>
        </trans-unit>
        <trans-unit id="eb182cc53494f3ad8a6ff778131dffe11ebe85c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; going back to a previous commit in Git is quite easy...</source>
          <target state="translated">&lt;strong&gt;好的，&lt;/strong&gt;回到上一个在Git中的提交非常容易...</target>
        </trans-unit>
        <trans-unit id="7e772e2042df02f4ac5a238212782b6d4443ff7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;QUICK AND DIRTY&lt;/strong&gt;: depending on the circumstances, quick and dirty may in fact be very GOOD. What my solution here does is &lt;strong&gt;NOT&lt;/strong&gt; replace irreversibly the files you have in your working directory with files hauled up/extracted from the depths of the git repository lurking beneath your .git/ directory using fiendishly clever and diabolically powerful git commands, of which there are many. &lt;strong&gt;YOU DO NOT HAVE TO DO SUCH DEEP-SEA DIVING TO RECOVER what may appear to be a disastrous situation, and attempting to do so without sufficient expertise may prove fatal&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;快速&lt;/strong&gt;而肮脏：根据情况，快速而肮脏实际上可能非常好。 我在这里的解决方案&lt;strong&gt;不是&lt;/strong&gt;使用不可思议的，功能强大的git命令将工作目录中的文件不可逆地替换为从.git /目录下潜伏的git仓库深处拖拉/提取的文件，许多。 &lt;strong&gt;您无需进行此类深海潜水来恢复似乎是灾难性的情况，并且在没有足够专业知识的情况下尝试这样做可能会致命&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7878cb7ef8c06d6486adcc9797b87c6465365093" translate="yes" xml:space="preserve">
          <source>A few options on how to recover from a detached HEAD:</source>
          <target state="translated">关于脱发后如何恢复的几个方案。</target>
        </trans-unit>
        <trans-unit id="4dfe83e406d11d3436d23ab86d77fdd7d265e9d1" translate="yes" xml:space="preserve">
          <source>After all the changes, when you push all these commands, you might have to use:</source>
          <target state="translated">改了这么多,当你推送这些命令的时候,你可能要用。</target>
        </trans-unit>
        <trans-unit id="827bbaa3663448c6ac82349b74e8b6dbac2840f5" translate="yes" xml:space="preserve">
          <source>Also from the comments, if you wanted a less 'ballzy' method you could use</source>
          <target state="translated">从评论中也可以看出,如果你想用一种不那么 &quot;笨拙 &quot;的方法,你可以用</target>
        </trans-unit>
        <trans-unit id="3902dbcd464f156f54bd98d40c88fd9ece998663" translate="yes" xml:space="preserve">
          <source>Alternative 1: Hard and Soft Resets</source>
          <target state="translated">替代品1:硬复位和软复位</target>
        </trans-unit>
        <trans-unit id="f7440ea2bf2d9cd756dc173beb3fbb2c0b96d8c4" translate="yes" xml:space="preserve">
          <source>Alternative 2: Delete the Current Tree and Replace with the New One</source>
          <target state="translated">备选方案2:删除当前的树,并以新的树取代。</target>
        </trans-unit>
        <trans-unit id="340d66c4fa37dbe035c6408a713ee2d51dda30c1" translate="yes" xml:space="preserve">
          <source>And not only &lt;code&gt;git push&lt;/code&gt;.</source>
          <target state="translated">而且不仅是 &lt;code&gt;git push&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11661e7c79c2472a2ccca3cd18e34e3b89b601de" translate="yes" xml:space="preserve">
          <source>As your commits are pushed remotely, you need to remove them. Let me assume your branch is &lt;em&gt;develop&lt;/em&gt; and it is pushed over &lt;em&gt;origin&lt;/em&gt;.</source>
          <target state="translated">当您的提交被远程推送时，您需要将其删除。 让我假设您的分支正在&lt;em&gt;发展&lt;/em&gt; ，并且已经超过&lt;em&gt;原点&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1cbde60a0009c9d0edd5c3e0172fa943911e90e" translate="yes" xml:space="preserve">
          <source>Assuming you're talking about master and on that respective branch (that said, this could be any working branch you're concerned with):</source>
          <target state="translated">假设你说的是主人,并在那个各自的分支上(话说回来,这可能是你所关心的任何工作分支)。</target>
        </trans-unit>
        <trans-unit id="deb1eef83454f8b7a428db302e61bd2120a598c0" translate="yes" xml:space="preserve">
          <source>At this point you can create a branch and start to work from this point on:</source>
          <target state="translated">这时,你可以创建一个分支,从这一点上开始工作。</target>
        </trans-unit>
        <trans-unit id="92e0a8b083d31eeec3fb7a54b8954e484fe4bac4" translate="yes" xml:space="preserve">
          <source>Be careful with this flag. It resets the working tree and all changes to tracked files and all will be gone!</source>
          <target state="translated">要小心这个标志。它将重置工作树和跟踪文件的所有更改都会消失!</target>
        </trans-unit>
        <trans-unit id="7b8436733b5d2fc8b339e76308ff8f0bce1ffb29" translate="yes" xml:space="preserve">
          <source>Before answering let's add some background, explaining what this &lt;code&gt;HEAD&lt;/code&gt; is.</source>
          <target state="translated">在回答之前，让我们添加一些背景，解释什么是 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34948cca5fa253149fae12b8b2bf9e121701e283" translate="yes" xml:space="preserve">
          <source>Better to use revert (see other answers) than reset. 
If you're a one man team then it probably doesn't matter.</source>
          <target state="translated">使用revert(见其他答案)比重置更好。如果你是一个人的团队,那么这可能并不重要。</target>
        </trans-unit>
        <trans-unit id="1fb7af211b3dbdd61026144dfc055b0281908607" translate="yes" xml:space="preserve">
          <source>But as you see the difference is using the two flags &lt;code&gt;--soft&lt;/code&gt; and &lt;code&gt;--hard&lt;/code&gt;, by default &lt;code&gt;git reset&lt;/code&gt; using &lt;code&gt;--soft&lt;/code&gt; flag, but it's a good practice always using the flag, I explain each flag:</source>
          <target state="translated">但是，您看到的区别是使用了两个标志 &lt;code&gt;--soft&lt;/code&gt; 和 &lt;code&gt;--hard&lt;/code&gt; ，默认情况下 &lt;code&gt;git reset&lt;/code&gt; 使用 &lt;code&gt;--soft&lt;/code&gt; 标志，但是始终使用该标志是一个好习惯，我将解释每个标志：</target>
        </trans-unit>
        <trans-unit id="3a40a3783dc2f06f1af89b954e94f1911bb876ad" translate="yes" xml:space="preserve">
          <source>Check &lt;code&gt;git log&lt;/code&gt; to verify your changes.</source>
          <target state="translated">检查 &lt;code&gt;git log&lt;/code&gt; 以验证您的更改。</target>
        </trans-unit>
        <trans-unit id="08f74d88ac0c5925d8abd0552fd45357483210d4" translate="yes" xml:space="preserve">
          <source>Copy the whole directory and call it something else, like &quot;my project - copy&quot;. Assuming your git repository (&quot;repo&quot;) files are under the &quot;my project&quot; directory (the default place for them, under a directory called &quot;.git&quot;), you will now have copied both your work files and your repo files.</source>
          <target state="translated">复制整个目录,然后把它改名为 &quot;my project-copy&quot;。假设你的 git 仓库(&quot;repo&quot;)文件在 &quot;我的项目 &quot;目录下(默认的位置,在一个叫&quot;.git &quot;的目录下),那么你现在已经复制了你的工作文件和repo文件。</target>
        </trans-unit>
        <trans-unit id="b8dccbee136be960880188a55bdb68eb079a6375" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; shell script to revert each of them:</source>
          <target state="translated">创建一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; shell脚本以还原它们每个：</target>
        </trans-unit>
        <trans-unit id="02bd119e81cc5355f078fe13af30b2da39d568b8" translate="yes" xml:space="preserve">
          <source>Credits go to a similar Stack Overflow question, &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1895059/git-revert-to-a-commit-by-sha-hash&quot;&gt;Revert to a commit by a SHA hash in Git?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">积分会转到类似的堆栈溢出问题， &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1895059/git-revert-to-a-commit-by-sha-hash&quot;&gt;还原为Git中的SHA哈希提交？&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d141bd57bfd683cbbec69826d5890d110b047df" translate="yes" xml:space="preserve">
          <source>Do this in the directory &quot;my project&quot;:</source>
          <target state="translated">在目录 &quot;我的项目 &quot;中做这个。</target>
        </trans-unit>
        <trans-unit id="378126339503a68fbaa8c750f1f8573ba4cef3c8" translate="yes" xml:space="preserve">
          <source>Especially if, for example, this is a desperate situation and you're a newbie with Git!</source>
          <target state="translated">尤其是当你是Git新手的时候,比如说,这是个无奈之举,而你又是Git的新手!</target>
        </trans-unit>
        <trans-unit id="659226488a54232bdf101d9941ce68c9bf52d0fc" translate="yes" xml:space="preserve">
          <source>Extra Alternatives to Jefromi's Solutions</source>
          <target state="translated">Jefromi解决方案的额外替代品</target>
        </trans-unit>
        <trans-unit id="e2691319c7272d9172f6c142db095dd9d2ef86e8" translate="yes" xml:space="preserve">
          <source>For rollback (or to revert):</source>
          <target state="translated">用于回滚(或恢复)。</target>
        </trans-unit>
        <trans-unit id="b678c79ecbee0d37c6f6be648ab4d24e89b21a6f" translate="yes" xml:space="preserve">
          <source>Git is a brilliant creation but absolutely no-one is able to just &quot;pick it up on the fly&quot;: also people who try to explain it &lt;strong&gt;far too often&lt;/strong&gt; assume prior knowledge of other VCS [Version Control Systems] and delve far too deep far too soon, and commit other crimes, like using interchangeable terms for &quot;checking out&quot; - in ways which sometimes appear almost calculated to confuse a beginner.</source>
          <target state="translated">Git是一个绝妙的创造，但绝对没有人能够&amp;ldquo;即时获取&amp;rdquo;：尝试解释它的人&lt;strong&gt;也经常&lt;/strong&gt;假设其他VCS [Version Control Systems]的先验知识，并且研究得太深了太早了，并犯下了其他罪行，例如使用可互换的术语&amp;ldquo;结帐&amp;rdquo;（有时以某种似乎几乎可以使初学者迷惑的方式）。</target>
        </trans-unit>
        <trans-unit id="bfb8913d15cf59c5da03d05deec15a29efbd97e3" translate="yes" xml:space="preserve">
          <source>Hard delete unpublished commits</source>
          <target state="translated">硬删除未发布的提交</target>
        </trans-unit>
        <trans-unit id="d37dc1a343e485e372ab88fd5766ed464acce0a7" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;much simpler&lt;/strong&gt; way to go back to a previous commit (and have it in an uncommited state, to do with it whatever you like):</source>
          <target state="translated">这是返回上一次提交的一种&lt;strong&gt;更简单的&lt;/strong&gt;方法（让它处于未提交状态，可以根据需要进行处理）：</target>
        </trans-unit>
        <trans-unit id="215d7a8e885045e594e831263c3e9ba11f717afe" translate="yes" xml:space="preserve">
          <source>How do I revert a Git repository to a previous commit</source>
          <target state="translated">如何将 Git 仓库恢复到之前的提交?</target>
        </trans-unit>
        <trans-unit id="f4b9e60697411c2b40df2355799c33b516b6278b" translate="yes" xml:space="preserve">
          <source>How do I revert from my current state to a snapshot made on a certain commit?</source>
          <target state="translated">如何从当前状态恢复到某个提交上的快照?</target>
        </trans-unit>
        <trans-unit id="9819e65d810cdde62bd17e39442b700ad932d75c" translate="yes" xml:space="preserve">
          <source>How do I revert to the commit from November 3, i.e. commit &lt;code&gt;0d1d7fc&lt;/code&gt;?</source>
          <target state="translated">我如何从11月3日恢复到提交，即commit &lt;code&gt;0d1d7fc&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="a0bc944d8d865d8ba6bc35d44c2edb19d282e0b7" translate="yes" xml:space="preserve">
          <source>How to move HEAD back to a previous location? (Detached head)</source>
          <target state="translated">如何将head移回之前的位置?(分离头)</target>
        </trans-unit>
        <trans-unit id="b87ef2ff181d7d386886af94b08f992cfc8c5136" translate="yes" xml:space="preserve">
          <source>I also created the image below that may happen in a real life working with Git:</source>
          <target state="translated">我还创造了下面这张图片,在现实生活中使用Git工作的时候可能会出现这样的情况。</target>
        </trans-unit>
        <trans-unit id="8c33029b35f3d01145d86868163313daf5c84274" translate="yes" xml:space="preserve">
          <source>I believe some people may come to this question wanting to know how to rollback committed changes they've made in their master - ie throw everything away and go back to origin/master, in which case, do this:</source>
          <target state="translated">我相信有些人可能会问到这个问题,想知道如何回滚他们在主程序中所做的修改--即把所有的东西都扔掉,然后回到原点主程序,在这种情况下,这样做。</target>
        </trans-unit>
        <trans-unit id="e72247558e4b5ad84fc16e003254af4f90587b17" translate="yes" xml:space="preserve">
          <source>I found a much more convenient and simple way to achieve the results above:</source>
          <target state="translated">我找到了一个更方便、更简单的方法来实现上面的结果。</target>
        </trans-unit>
        <trans-unit id="0262f3bdfcb749038ef55e8d537b8a1a7c721298" translate="yes" xml:space="preserve">
          <source>I found the answer from in a blog post (now no longer exists)</source>
          <target state="translated">我从一篇博文中找到了答案(现在已经不存在了)。</target>
        </trans-unit>
        <trans-unit id="26c73afeef62688ff9fde1fd66868ad120f3a9c0" translate="yes" xml:space="preserve">
          <source>I have had a similar issue and wanted to revert back to an earlier commit. In my case I was not interested to keep the newer commit, hence I used &lt;code&gt;Hard&lt;/code&gt;.</source>
          <target state="translated">我遇到过类似的问题，想恢复到以前的提交。 就我而言，我对保留新提交不感兴趣，因此我使用 &lt;code&gt;Hard&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6910536d152b4d8cb3df0022070f30f0dc88999" translate="yes" xml:space="preserve">
          <source>I have tried a lot of ways to revert local changes in Git, and it seems that this works the best if you just want to revert to the latest commit state.</source>
          <target state="translated">我尝试了很多在Git中恢复本地修改的方法,如果你只是想恢复到最新的提交状态,这个方法似乎效果最好。</target>
        </trans-unit>
        <trans-unit id="20144fbb67d31dfaa0aab28764e5a24600f64929" translate="yes" xml:space="preserve">
          <source>If I do &lt;code&gt;git log&lt;/code&gt;, then I get the following output:</source>
          <target state="translated">如果执行 &lt;code&gt;git log&lt;/code&gt; ，则得到以下输出：</target>
        </trans-unit>
        <trans-unit id="a9dc1195c97f99966a626fc0a6b57adb56e167fa" translate="yes" xml:space="preserve">
          <source>If changes are not required from the previous commit to HEAD and just discard all changes, do:</source>
          <target state="translated">如果从之前的提交到head不需要修改,只需丢弃所有的修改就可以了。</target>
        </trans-unit>
        <trans-unit id="c7c4de579733c15d4364d2a57e8371976d3f8015" translate="yes" xml:space="preserve">
          <source>If the situation is an &lt;strong&gt;urgent one&lt;/strong&gt;, and you just want to do what the questioner asked in a &lt;strong&gt;quick and dirty&lt;/strong&gt; way, assuming your project is under a directory called, for example, &quot;my project&quot;:</source>
          <target state="translated">如果情况很&lt;strong&gt;紧急&lt;/strong&gt; ，并且您只是想以一种&lt;strong&gt;快速而肮脏的&lt;/strong&gt;方式来执行发问者所要求的操作，那么您的项目就位于一个名为&amp;ldquo;我的项目&amp;rdquo;的目录下：</target>
        </trans-unit>
        <trans-unit id="b06ed00b1db93823cdbc02006aad46f5fb3ad39f" translate="yes" xml:space="preserve">
          <source>If you are not on the latest commit - meaning that &lt;code&gt;HEAD&lt;/code&gt; is pointing to a prior commit in history it's called &lt;strong&gt;&lt;em&gt;&lt;code&gt;detached HEAD&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">如果您不在最新提交上，这意味着 &lt;code&gt;HEAD&lt;/code&gt; 指向历史记录中的先前提交，则称为&lt;strong&gt;&lt;em&gt; &lt;code&gt;detached HEAD&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8531e0a48ed45802099d9ae7e009dfd16c1eba9c" translate="yes" xml:space="preserve">
          <source>If you decide you didn't want to revert after all, you can revert the revert (as described here) or reset back to before the revert (see the previous section).</source>
          <target state="translated">如果你终究决定不想还原,可以还原还原(如这里描述的那样),或者重置回还原前的状态(见上一节)。</target>
        </trans-unit>
        <trans-unit id="8d7fa0de483735064b1cb81199ea5be983c9fc2b" translate="yes" xml:space="preserve">
          <source>If you find something wrong, do:</source>
          <target state="translated">如果你发现有什么问题,就做。</target>
        </trans-unit>
        <trans-unit id="0c568174f2a4a4531694150c506de49219506b53" translate="yes" xml:space="preserve">
          <source>If you have &lt;strong&gt;one and only&lt;/strong&gt; commit in your repo, try</source>
          <target state="translated">如果您只有&lt;strong&gt;一个并且仅&lt;/strong&gt;在您的仓库中提交，请尝试</target>
        </trans-unit>
        <trans-unit id="f8561a2aa2ca03b7277119e0d3ed51f7d90d7f06" translate="yes" xml:space="preserve">
          <source>If you mess up, you've already thrown away your local changes, but you can at least get back to where you were before by resetting again.</source>
          <target state="translated">如果你搞砸了,你已经扔掉了你的本地更改,但你至少可以通过重新设置来恢复到你之前的位置。</target>
        </trans-unit>
        <trans-unit id="427ff9573e5ddce662f5ac0851f87ec0e4f79bd7" translate="yes" xml:space="preserve">
          <source>If you want the Git repository to a previous commit:</source>
          <target state="translated">如果你想让Git仓库到之前的提交。</target>
        </trans-unit>
        <trans-unit id="a4276522808022598711b636fe0f6fb240bcec8f" translate="yes" xml:space="preserve">
          <source>If you want to &quot;uncommit&quot;, erase the last commit message, and put the modified files back in staging, you would use the command:</source>
          <target state="translated">如果你想 &quot;取消提交&quot;,删除上次提交的消息,然后将修改后的文件放回暂存,你会使用该命令。</target>
        </trans-unit>
        <trans-unit id="de04053c3af13c4e631f9c32fc311eee129f128d" translate="yes" xml:space="preserve">
          <source>If you want to correct some error in the last commit a good alternative would be using &lt;strong&gt;git commit --amend&lt;/strong&gt; command. If the last commit is not pointed by any reference, this will do the trick, as it create a commit with the same parent as the last commit. If there is no reference to the last commit, it will simply be discarded and this commit will be the last commit. This is a good way of correcting commits without reverting commits. However it has its own limitations.</source>
          <target state="translated">如果您想在最后一次提交中更正某些错误，可以使用&lt;strong&gt;git commit --amend&lt;/strong&gt;命令来替代。 如果没有任何引用指向最后一次提交，则将成功，因为它将创建一个与最后一次提交具有相同父级的提交。 如果没有对最后一次提交的引用，它将被简单地丢弃，并且该提交将成为最后一次提交。 这是纠正提交而不恢复提交的好方法。 但是，它有其自身的局限性。</target>
        </trans-unit>
        <trans-unit id="8f961938dac4103278585a68d34a01db4237b0fc" translate="yes" xml:space="preserve">
          <source>If you want to keep your changes, you can also use:</source>
          <target state="translated">如果你想保留你的改动,也可以使用。</target>
        </trans-unit>
        <trans-unit id="d856fff44e0b372b7b4c3612a30af8112dd941ab" translate="yes" xml:space="preserve">
          <source>If you want to temporarily go back to it, fool around, then come back to where you are, all you have to do is check out the desired commit:</source>
          <target state="translated">如果你想暂时回到它,糊弄一下,然后再回到你所在的地方,你所要做的就是检查出你想要的提交。</target>
        </trans-unit>
        <trans-unit id="25ef3e3b661a2247aab4fb208c0d2510055a9739" translate="yes" xml:space="preserve">
          <source>If, on the other hand, you want to really get rid of everything you've done since then, there are two possibilities. One, if you haven't published any of these commits, simply reset:</source>
          <target state="translated">反之,如果你想真的把此后所做的一切都清除掉,有两种可能。其一,如果你没有发布过这些提交,只需重置即可。</target>
        </trans-unit>
        <trans-unit id="ebd49d9e9e79e3647b4491da259cf962d75113e8" translate="yes" xml:space="preserve">
          <source>It WILL override all your local changes and DELETE all added files since the last commit in the branch.</source>
          <target state="translated">它将覆盖你所有的本地修改,并删除上次提交后添加的所有文件。</target>
        </trans-unit>
        <trans-unit id="3c149ded6611aef9d7462af1e5621ecaaf07abf6" translate="yes" xml:space="preserve">
          <source>It directly clears all the changes that you have been making since the last commit.</source>
          <target state="translated">它直接清除了你上次提交后的所有改动。</target>
        </trans-unit>
        <trans-unit id="58bbb523b3d2e34c2af2248245176f969ea2f258" translate="yes" xml:space="preserve">
          <source>It is capable of taking range from the HEAD like below. Here 1 says &quot;revert last commit.&quot;</source>
          <target state="translated">它能够像下面这样从HEAD中取范围。这里1说的是 &quot;恢复上次提交&quot;。</target>
        </trans-unit>
        <trans-unit id="eb09fdc79570755955c80aa0d4bc081876b97bac" translate="yes" xml:space="preserve">
          <source>It is the same code code as boulder_ruby suggested, but I have added &lt;code&gt;git add .&lt;/code&gt; before  &lt;code&gt;git reset --hard HEAD&lt;/code&gt; to erase all new files created since the last commit since this is what most people expect I believe when reverting to the latest commit.</source>
          <target state="translated">它与boulder_ruby建议的代码相同，但是我添加了 &lt;code&gt;git add .&lt;/code&gt; 在 &lt;code&gt;git reset --hard HEAD&lt;/code&gt; 之前，擦除自上次提交以来创建的所有新文件，因为这是大多数人在还原为最新提交时所希望的。</target>
        </trans-unit>
        <trans-unit id="4c30d8d0b88769f23fbadcbdeb36ad079e70ea8a" translate="yes" xml:space="preserve">
          <source>It will NOT create any commits as &lt;code&gt;git revert&lt;/code&gt; does.</source>
          <target state="translated">它不会像 &lt;code&gt;git revert&lt;/code&gt; 那样创建任何提交。</target>
        </trans-unit>
        <trans-unit id="8005ef78b00c05ee0f92589ff930d6b321f3c1fe" translate="yes" xml:space="preserve">
          <source>It will NOT detach your HEAD like &lt;code&gt;git checkout &amp;lt;commithashcode&amp;gt;&lt;/code&gt; does.</source>
          <target state="translated">它不会像 &lt;code&gt;git checkout &amp;lt;commithashcode&amp;gt;&lt;/code&gt; 那样分离您的HEAD。</target>
        </trans-unit>
        <trans-unit id="6eb5bea727a80b27c2fa5b69b3487e69026c556a" translate="yes" xml:space="preserve">
          <source>It will remove your previous Git commit.</source>
          <target state="translated">它将删除你之前的Git提交。</target>
        </trans-unit>
        <trans-unit id="7249d3ccfdff131742220b6429cf95e4e286e0d6" translate="yes" xml:space="preserve">
          <source>It works only with branches names, so you can revert only to latest commit in the branch this way.</source>
          <target state="translated">它只对分支名称起作用,所以你可以通过这种方式只恢复到分支中的最新提交。</target>
        </trans-unit>
        <trans-unit id="bd597ad6f3e74b984d2eff89845813ceef14c52b" translate="yes" xml:space="preserve">
          <source>Just &lt;code&gt;git reset --hard HEAD&lt;/code&gt; will get rid of modifications, but it won't get rid of &quot;new&quot; files. In their case they'd accidentally dragged an important folder somewhere random, and all those files were being treated as new by Git, so a &lt;code&gt;reset --hard&lt;/code&gt; didn't fix it. By running the &lt;code&gt;git add -A .&lt;/code&gt; beforehand, it explicitly tracked them all with git, to be wiped out by the reset.</source>
          <target state="translated">只是 &lt;code&gt;git reset --hard HEAD&lt;/code&gt; 将摆脱修改，但不会摆脱&amp;ldquo;新&amp;rdquo;文件。 在他们的情况下，他们无意中将一个重要的文件夹随机地拖到了某个地方，而所有这些文件都被Git视为新文件，因此 &lt;code&gt;reset --hard&lt;/code&gt; 并未解决。 通过运行 &lt;code&gt;git add -A .&lt;/code&gt; 事先，它使用git明确跟踪了它们，然后将其清除。</target>
        </trans-unit>
        <trans-unit id="c8a473be30d0bd103f06c5bf43af10cddca46531" translate="yes" xml:space="preserve">
          <source>Lastly, push &lt;em&gt;develop&lt;/em&gt; again:</source>
          <target state="translated">最后，再次推动&lt;em&gt;开发&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="8031e401d2da65a74406a30adeb72243cd3390a7" translate="yes" xml:space="preserve">
          <source>Lots of complicated and dangerous answers here, but it's actually easy:</source>
          <target state="translated">这里有很多复杂而危险的答案,但其实很简单。</target>
        </trans-unit>
        <trans-unit id="6a3ea14413dd6ac5b8e74268e0d3256e4a55da1b" translate="yes" xml:space="preserve">
          <source>Note that this is Resetting and Forcing the change to the remote, so that if others on your team have already git pulled, you will cause problems for them. You are destroying the change history, which is an important reason why people use git in the first place.</source>
          <target state="translated">注意,这是重置并强制更改到远程,这样如果你的团队中的其他人已经被git拉了,你会给他们带来麻烦。你是在破坏更改历史记录,这也是人们首先使用git的一个重要原因。</target>
        </trans-unit>
        <trans-unit id="4be35ba1efbe333f75c355856eb657e4448b68fa" translate="yes" xml:space="preserve">
          <source>Note: (&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/RelNotes/2.7.0.txt&quot;&gt;Since Git 2.7&lt;/a&gt;) you can also use the &lt;code&gt;git rebase --no-autostash&lt;/code&gt; as well.</source>
          <target state="translated">注意：（ &lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/RelNotes/2.7.0.txt&quot;&gt;从Git 2.7开始&lt;/a&gt; ），您还可以使用 &lt;code&gt;git rebase --no-autostash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08e293c8b2eb9661fb2b9e59253581e609baa6c8" translate="yes" xml:space="preserve">
          <source>Nothing here worked for me apart from this exact combination:</source>
          <target state="translated">除了这个组合之外,这里没有任何东西对我有用。</target>
        </trans-unit>
        <trans-unit id="419ddbdcdc17f46e12b7bf15b16aa8731606d7b0" translate="yes" xml:space="preserve">
          <source>Now you can &lt;code&gt;checkout&lt;/code&gt; all un-added files by</source>
          <target state="translated">现在，您可以通过以下方式 &lt;code&gt;checkout&lt;/code&gt; 所有未添加的文件</target>
        </trans-unit>
        <trans-unit id="e54b6879a199c4996950e6c441beef9bc4f56ce4" translate="yes" xml:space="preserve">
          <source>On the command line it will look like this - SHA-1 instead of the branch name since the &lt;code&gt;HEAD&lt;/code&gt; is not pointing to the the tip of the current branch:</source>
          <target state="translated">在命令行上，它将看起来像这样-SHA-1而不是分支名称，因为 &lt;code&gt;HEAD&lt;/code&gt; 并未指向当前分支的尖端：</target>
        </trans-unit>
        <trans-unit id="32ab2cb78ae1de14f78e6d0c088c542ad358e245" translate="yes" xml:space="preserve">
          <source>On the other hand, if you've published the work, you probably don't want to reset the branch, since that's effectively rewriting history. In that case, you could indeed revert the commits. With Git, revert has a very specific meaning: create a commit with the reverse patch to cancel it out. This way you don't rewrite any history.</source>
          <target state="translated">另一方面,如果你已经发布了作品,你可能不想重置分支,因为这实际上是在重写历史。在这种情况下,你确实可以恢复提交。在 Git 中,revert 有一个非常特殊的含义:用反向补丁创建一个提交来取消它。这样你就不会重写任何历史记录了。</target>
        </trans-unit>
        <trans-unit id="56a3c461f0299749f2a082f928f4ebddece45866" translate="yes" xml:space="preserve">
          <source>On this subject of &quot;backing up to the Cloud&quot;, the next step is to open an account (free of course) with GitHub or (better in my view) &lt;a href=&quot;https://gitlab.com&quot;&gt;GitLab&lt;/a&gt;. You can then regularly do a &lt;code&gt;git push&lt;/code&gt; command to make your Cloud repo up-to-date &quot;properly&quot;. But again, talking about this may be too much too soon.</source>
          <target state="translated">关于&amp;ldquo;备份到云&amp;rdquo;这一主题，下一步是（当然是免费）在GitHub或（在我看来更好） &lt;a href=&quot;https://gitlab.com&quot;&gt;GitLab&lt;/a&gt;开设一个帐户。 然后，您可以定期执行 &lt;code&gt;git push&lt;/code&gt; 命令，以&amp;ldquo;适当地&amp;rdquo;使您的云存储库为最新。 但是，再次谈论这个问题可能为时过早。</target>
        </trans-unit>
        <trans-unit id="62f200b3dfaa6dff2d5ae300412e4adc775e9540" translate="yes" xml:space="preserve">
          <source>Or if you want to make commits while you're there, go ahead and make a new branch while you're at it:</source>
          <target state="translated">或者,如果你想趁着你在那里的时候提交,就去做一个新的分支吧。</target>
        </trans-unit>
        <trans-unit id="60b244e32b96925828e25d2b3c24cfdc70e7d1f5" translate="yes" xml:space="preserve">
          <source>PS: It has a little problem; it also deletes all you recently stored stash changes. Which I guess in most cases should not matter.</source>
          <target state="translated">PS:它有一个小问题;它还会删除所有你最近存储的存贮器的更改。我想在大多数情况下,这应该不重要。</target>
        </trans-unit>
        <trans-unit id="5b5050c847d01d43c2c27ca22983b3c3aa0c9f7b" translate="yes" xml:space="preserve">
          <source>PS: One other thought: It is (now) actually quite simple to keep the Git repo in a directory other than the one with the working files. This would mean you would not have to copy the entire Git repository using the above quick &amp;amp; dirty solution. See the answer by Fryer using &lt;code&gt;--separate-git-dir&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/questions/505467/can-i-store-the-git-folder-outside-the-files-i-want-tracked&quot;&gt;here&lt;/a&gt;. &lt;strong&gt;Be warned&lt;/strong&gt;, though: If you have a &quot;separate-directory&quot; repository which you don't copy, and you do a hard reset, all versions subsequent to the reset commit will be lost forever, unless you have, as you absolutely should, regularly backed up your repository, preferably to the Cloud (e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_Drive&quot;&gt;Google Drive&lt;/a&gt;) among other places.</source>
          <target state="translated">PS：另一个想法：（现在）将Git存储库保存在除具有工作文件的目录之外的其他目录中实际上非常简单。 这意味着您不必使用上述快速又肮脏的解决方案来复制整个Git存储库。 请在&lt;a href=&quot;https://stackoverflow.com/questions/505467/can-i-store-the-git-folder-outside-the-files-i-want-tracked&quot;&gt;此处&lt;/a&gt;使用 &lt;code&gt;--separate-git-dir&lt;/code&gt; 查看 Fryer的答案。 &lt;strong&gt;但是请注意&lt;/strong&gt; ：如果您有一个不复制的&amp;ldquo;单独目录&amp;rdquo;存储库，并且进行了硬重置，那么重置提交之后的所有版本将永远丢失，除非您如绝对必要那样拥有，定期备份您的存储库，最好备份到其他地方的云（例如&lt;a href=&quot;https://en.wikipedia.org/wiki/Google_Drive&quot;&gt;Google Drive&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fd0ba66aa9ddaa029e7c11b077be6e222c3aa32a" translate="yes" xml:space="preserve">
          <source>Per the &lt;a href=&quot;https://en.wikipedia.org/wiki/Man_page&quot;&gt;man page&lt;/a&gt;, it can also be used as such:</source>
          <target state="translated">对于&lt;a href=&quot;https://en.wikipedia.org/wiki/Man_page&quot;&gt;手册页&lt;/a&gt; ，它也可以这样使用：</target>
        </trans-unit>
        <trans-unit id="1070632c158ecb6d00478018b42aa2927bcfff94" translate="yes" xml:space="preserve">
          <source>Pull the latest version of your repository from Bitbucket using the &lt;code&gt;git pull --all&lt;/code&gt; command.</source>
          <target state="translated">使用 &lt;code&gt;git pull --all&lt;/code&gt; 命令从Bitbucket提取存储库的最新版本。</target>
        </trans-unit>
        <trans-unit id="9fe38f7b3252db2987b29485e48b59951ef72185" translate="yes" xml:space="preserve">
          <source>Push the change to Git repository using &lt;code&gt;git push --force&lt;/code&gt; to force push the change.</source>
          <target state="translated">使用 &lt;code&gt;git push --force&lt;/code&gt; 将更改推送到Git存储库，以强制推送更改。</target>
        </trans-unit>
        <trans-unit id="2dd8de4c78a70b4822060391dc7092a8a0da9c11" translate="yes" xml:space="preserve">
          <source>Reset the head of your repository's history using the &lt;code&gt;git reset --hard HEAD~N&lt;/code&gt; where N is the number of commits you want to take the head back. In the following example the head would be set back one commit, to the last commit in the repository history:</source>
          <target state="translated">使用 &lt;code&gt;git reset --hard HEAD~N&lt;/code&gt; 存储库历史记录的开头，其中N是您要收回的提交次数。 在下面的示例中，将头部设置为一次提交，直到存储库历史记录中的最后一次提交：</target>
        </trans-unit>
        <trans-unit id="d0be8e3d2b5caaa96f38eb189df8ec95362918aa" translate="yes" xml:space="preserve">
          <source>Revert back &lt;strong&gt;with keeping&lt;/strong&gt; the changes:</source>
          <target state="translated">恢复&lt;strong&gt;并保留&lt;/strong&gt;更改：</target>
        </trans-unit>
        <trans-unit id="9c0d62b8fc38ca4721e6e1706ee9f51dce3b15f2" translate="yes" xml:space="preserve">
          <source>Revert back &lt;strong&gt;without keeping&lt;/strong&gt; the changes:</source>
          <target state="translated">还原&lt;strong&gt;但不保留&lt;/strong&gt;更改：</target>
        </trans-unit>
        <trans-unit id="ee00d25f4d3f7808f421b0d05a47469fb758bd2e" translate="yes" xml:space="preserve">
          <source>Revert is the command to rollback the commits.</source>
          <target state="translated">Revert是回滚提交的命令。</target>
        </trans-unit>
        <trans-unit id="c6b4bece923a7536b8b1b2f52de3a298484975dc" translate="yes" xml:space="preserve">
          <source>Revert to &lt;em&gt;most recent&lt;/em&gt; commit and ignoring all local changes:</source>
          <target state="translated">恢复为&lt;em&gt;最新&lt;/em&gt;提交，并忽略所有本地更改：</target>
        </trans-unit>
        <trans-unit id="e6348ed8b19da88a2dc2a2d4d06140b03041b1fd" translate="yes" xml:space="preserve">
          <source>Reverting The Working Copy to an Older Commit</source>
          <target state="translated">将工作副本还原为旧的承诺书</target>
        </trans-unit>
        <trans-unit id="c31dc90f055c63b6461a162487e4f54af0389983" translate="yes" xml:space="preserve">
          <source>Reverting Working Copy to Most Recent Commit</source>
          <target state="translated">将工作副本恢复到最近的承诺</target>
        </trans-unit>
        <trans-unit id="068a74558d4325c7d1e5fc758527efac26587586" translate="yes" xml:space="preserve">
          <source>Rogue Coder?</source>
          <target state="translated">盗版程序员?</target>
        </trans-unit>
        <trans-unit id="4a01fa35392523364900604a0d0713b788eebb53" translate="yes" xml:space="preserve">
          <source>Run the Git log command with &lt;code&gt;-n 4&lt;/code&gt; from your terminal. The number after the &lt;code&gt;-n&lt;/code&gt; determines the number of commits in the log starting from the most recent commit in your local history.</source>
          <target state="translated">从终端使用 &lt;code&gt;-n 4&lt;/code&gt; 运行Git log命令。 &lt;code&gt;-n&lt;/code&gt; 后面的数字确定日志中从本地历史记录中的最新提交开始的提交数量。</target>
        </trans-unit>
        <trans-unit id="5e60c86f8418a7c1455bb5883bd1d7711db7d549" translate="yes" xml:space="preserve">
          <source>Say you have the following commits in a text file named &lt;code&gt;~/commits-to-revert.txt&lt;/code&gt; (I used &lt;code&gt;git log --pretty=oneline&lt;/code&gt; to get them)</source>
          <target state="translated">假设您在名为 &lt;code&gt;~/commits-to-revert.txt&lt;/code&gt; 的文本文件中具有以下提交（我使用 &lt;code&gt;git log --pretty=oneline&lt;/code&gt; 来获取它们）</target>
        </trans-unit>
        <trans-unit id="81732aeea4059405eab03949322e5aa6b57b1dfa" translate="yes" xml:space="preserve">
          <source>Select your required commit, and check it by</source>
          <target state="translated">选择你需要的提交,并通过</target>
        </trans-unit>
        <trans-unit id="67cfec235644a14ea2c7c197d4b69761db936191" translate="yes" xml:space="preserve">
          <source>Short description:</source>
          <target state="translated">简要说明:</target>
        </trans-unit>
        <trans-unit id="fe04fdc25bd7034b2cf3e1bb748034b199565949" translate="yes" xml:space="preserve">
          <source>Similarly to alternative #1, this reproduces the state of &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; in the current working copy. It is necessary to do &lt;code&gt;git rm&lt;/code&gt; first because &lt;code&gt;git checkout&lt;/code&gt; won't remove files that have been added since &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">与替代方法＃1相似，这将在当前工作副本中重现 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 的状态。 首先需要执行 &lt;code&gt;git rm&lt;/code&gt; ,因为 &lt;code&gt;git checkout&lt;/code&gt; 不会删除自 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 以来添加的文件。</target>
        </trans-unit>
        <trans-unit id="5deb2504bde4f4691c3fbcb5913a32747fdace3a" translate="yes" xml:space="preserve">
          <source>So, no need for commit ids and so on :)</source>
          <target state="translated">所以,不需要提交ID之类的东西:)</target>
        </trans-unit>
        <trans-unit id="6954634df3ee2911f1393b2cdf9d64b6a21f4038" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;http://nakkaya.com/2009/09/24/git-delete-last-commit/&quot;&gt;http://nakkaya.com/2009/09/24/git-delete-last-commit/&lt;/a&gt;</source>
          <target state="translated">资料来源： &lt;a href=&quot;http://nakkaya.com/2009/09/24/git-delete-last-commit/&quot;&gt;http&lt;/a&gt; ： //nakkaya.com/2009/09/24/git-delete-last-commit/</target>
        </trans-unit>
        <trans-unit id="d5800959f85dcc1c548571a3f3a0105891f5b415" translate="yes" xml:space="preserve">
          <source>Temporarily switch to a different commit</source>
          <target state="translated">暂时切换到另一个提交</target>
        </trans-unit>
        <trans-unit id="0f2773d8bddf901d05f958a871f495f7e27fdba5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://schacon.github.com/git/git-revert.html&quot;&gt;&lt;code&gt;git-revert&lt;/code&gt; manpage&lt;/a&gt; actually covers a lot of this in its description. Another useful link is &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging#_undoing_merges&quot;&gt;this git-scm.com section discussing git-revert&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://schacon.github.com/git/git-revert.html&quot;&gt; &lt;code&gt;git-revert&lt;/code&gt; 手册页&lt;/a&gt;实际上在其描述中涵盖了很多内容。 另一个有用的链接是&lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging#_undoing_merges&quot;&gt;git-scm.com讨论git-revert的部分&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b78da6e377c9c98a192707a215236eede0cd2bb" translate="yes" xml:space="preserve">
          <source>The best option for me and probably others is the Git reset option:</source>
          <target state="translated">对我和其他人来说,最好的选择是Git重置选项。</target>
        </trans-unit>
        <trans-unit id="54a5ff1a1b6340200a291fdbc4a740dc59a7559a" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;HEAD&lt;/code&gt; is stored inside &lt;code&gt;.git/HEAD&lt;/code&gt;, and it contains the 40 bytes SHA-1 of the current commit.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 的内容存储在 &lt;code&gt;.git/HEAD&lt;/code&gt; 内 ，它包含当前提交的40个字节的SHA-1。</target>
        </trans-unit>
        <trans-unit id="26523735edbc0fadce77f13b3d4489dc7b54899c" translate="yes" xml:space="preserve">
          <source>The default flag as explained, not need to provide it, does not change the working tree, but it adds all changed files ready to commit, so you go back to the commit status which changes to files get unstaged.</source>
          <target state="translated">默认的标志如解释,不需要提供它,不改变工作树,但它添加了所有改变后的文件准备提交,所以你回到提交状态,改变后的文件得到未定型的文件。</target>
        </trans-unit>
        <trans-unit id="c8937a58fd58248066d458a8e3e1faa865c7e84a" translate="yes" xml:space="preserve">
          <source>The key here is forcing the push, no extra commits/commit messages, etc.</source>
          <target state="translated">这里的关键是强行推送,没有多余的commit消息等。</target>
        </trans-unit>
        <trans-unit id="f9b0929e5129e850ed1b5be9e16b85c31b2892f2" translate="yes" xml:space="preserve">
          <source>The obvious thing if you want to carry on with the state of the project without actually discarding the work since this retrieved commit is to rename your directory again: Delete the project containing the retrieved commit (or give it a temporary name) and rename your &quot;my project - copy&quot; directory back to &quot;my project&quot;. Then maybe try to understand some of the other answers here, and probably do another commit fairly soon.</source>
          <target state="translated">如果你想继续保持项目的状态而不实际丢弃工作,很明显的事情就是重新命名你的目录。删除包含检索到的提交的项目(或者给它起一个临时的名字),然后把你的 &quot;我的项目--复制 &quot;目录重命名为 &quot;我的项目&quot;。然后也许试着理解这里的其他一些答案,可能很快就会再做一次提交。</target>
        </trans-unit>
        <trans-unit id="4b50aaa5d7059e59a4807acb3932d2d3b6d7295e" translate="yes" xml:space="preserve">
          <source>Then it will save your changes.</source>
          <target state="translated">然后它将保存你的修改。</target>
        </trans-unit>
        <trans-unit id="58b39406130fc132b234d68312b4211c64120db0" translate="yes" xml:space="preserve">
          <source>Then you need to get develop to the status you want, let me assume the commit hash is EFGHIJK:</source>
          <target state="translated">那么你需要把开发到你想要的状态,让我假设提交的哈希是EFGHIJK。</target>
        </trans-unit>
        <trans-unit id="ea3d908ec7db49d81934603e4f0e6b285b817827" translate="yes" xml:space="preserve">
          <source>There is a command (not a part of core Git, but it is in the &lt;a href=&quot;https://github.com/visionmedia/git-extras&quot;&gt;git-extras&lt;/a&gt; package) specifically for reverting and staging old commits:</source>
          <target state="translated">有一个命令（不是核心Git的一部分，但是在&lt;a href=&quot;https://github.com/visionmedia/git-extras&quot;&gt;git-extras&lt;/a&gt;包中）专门用于还原和暂存旧提交：</target>
        </trans-unit>
        <trans-unit id="815f16f30f9ba6b824003a15340434622e387031" translate="yes" xml:space="preserve">
          <source>This basically works by using the fact that soft resets will leave the state of the previous commit staged in the index/staging-area, which you can then commit.</source>
          <target state="translated">这基本上是利用了软复位会把之前的提交状态留在indexstaging-area中,然后就可以提交。</target>
        </trans-unit>
        <trans-unit id="85fd59a0e320797d0e3cfbedfe47292634df1558" translate="yes" xml:space="preserve">
          <source>This depends a lot on what you mean by &quot;revert&quot;.</source>
          <target state="translated">这在很大程度上取决于你所说的 &quot;还原 &quot;是什么意思。</target>
        </trans-unit>
        <trans-unit id="ae7ed64993835cbe67a58f9f2cd839e739812861" translate="yes" xml:space="preserve">
          <source>This has been the best option for me! It is simple, fast and effective!</source>
          <target state="translated">这对我来说一直是最好的选择! 它简单、快速、有效!</target>
        </trans-unit>
        <trans-unit id="0f8803f90afffda4da3bd38d62f19dc63d2a481d" translate="yes" xml:space="preserve">
          <source>This is a &lt;strong&gt;safe and easy way to rollback to a previous state&lt;/strong&gt;. No history is destroyed, so it can be used for commits that have already been made public.</source>
          <target state="translated">这是&lt;strong&gt;回滚到先前状态&lt;/strong&gt;的&lt;strong&gt;安全，简便的方法&lt;/strong&gt; 。 历史记录不会被销毁，因此可以用于已公开的提交。</target>
        </trans-unit>
        <trans-unit id="3dcd570acd02deab0e0528c3bef08d7781c4101e" translate="yes" xml:space="preserve">
          <source>This is a very slightly modified version of Charles Bailey's solution to &lt;a href=&quot;https://stackoverflow.com/questions/1895059/revert-to-a-commit-by-sha-hash-in-git/1895095#1895095&quot;&gt;Revert to a commit by a SHA hash in Git?&lt;/a&gt;:</source>
          <target state="translated">这是Charles Bailey解决方案的略微修改版本，用于&lt;a href=&quot;https://stackoverflow.com/questions/1895059/revert-to-a-commit-by-sha-hash-in-git/1895095#1895095&quot;&gt;还原到Git中SHA哈希的提交？&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="0c675ec8ac6c294e8061252ff39c89b38b305a0c" translate="yes" xml:space="preserve">
          <source>This is an extremely useful command in situations where you committed the wrong thing and you want to undo that last commit.</source>
          <target state="translated">这是一个非常有用的命令,当你做错了事情,而你想撤销最后一次提交的时候,这个命令非常有用。</target>
        </trans-unit>
        <trans-unit id="33268d90d137e16d0ff7bdf13883c995cd339665" translate="yes" xml:space="preserve">
          <source>This is how I did it:</source>
          <target state="translated">我就是这样做的。</target>
        </trans-unit>
        <trans-unit id="89f1f2cd90d517dbecb5870742250306be88f1ee" translate="yes" xml:space="preserve">
          <source>This is one more way to directly reset to a recent commit</source>
          <target state="translated">这是另一种直接重置到最近提交的方法。</target>
        </trans-unit>
        <trans-unit id="a638c35d7c8a1baea04fbfbe74917c3a635754fa" translate="yes" xml:space="preserve">
          <source>This reverts everything back to the previous state, including file and directory creations, and deletions, commit it to your branch and you retain the history, but you have it reverted back to the same file structure. Why Git doesn't have a &lt;code&gt;git revert --to &amp;lt;hash&amp;gt;&lt;/code&gt; is beyond me.</source>
          <target state="translated">这会将所有内容还原到以前的状态，包括文件和目录的创建以及删除，将其提交到分支并保留历史记录，但是您将其还原到相同的文件结构。 为什么Git没有 &lt;code&gt;git revert --to &amp;lt;hash&amp;gt;&lt;/code&gt; 超出了我的范围。</target>
        </trans-unit>
        <trans-unit id="b2c32a1b98727e64ca2da1eaa9ddc6a817e68906" translate="yes" xml:space="preserve">
          <source>This schema illustrates which command does what. As you can see there &lt;code&gt;reset &amp;amp;&amp;amp; checkout&lt;/code&gt; modify the &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">该模式说明了哪个命令可以执行什么操作。 如您所见， &lt;code&gt;reset &amp;amp;&amp;amp; checkout&lt;/code&gt; 修改了 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a3f409131a6896a9bc560e6025e02d2b5433f7b" translate="yes" xml:space="preserve">
          <source>This solution comes from svick's solution to &lt;a href=&quot;https://stackoverflow.com/questions/3380805/checkout-old-commit-and-make-it-a-new-commit/3382249#3382249&quot;&gt;Checkout old commit and make it a new commit&lt;/a&gt;:</source>
          <target state="translated">该解决方案来自svick的&lt;a href=&quot;https://stackoverflow.com/questions/3380805/checkout-old-commit-and-make-it-a-new-commit/3382249#3382249&quot;&gt;Checkout旧提交并使之成为新提交&lt;/a&gt;的解决方案：</target>
        </trans-unit>
        <trans-unit id="23e15c6d963b17e7997420be2c7d3b3f99d8ef72" translate="yes" xml:space="preserve">
          <source>This will checkout new branch pointing to the desired commit. This command will checkout to a given commit.</source>
          <target state="translated">这条命令将退出指向所需提交的新分支。这个命令将结账到指定的提交。</target>
        </trans-unit>
        <trans-unit id="deecf3786f5adeab0a8d032a5b74b01cb144271d" translate="yes" xml:space="preserve">
          <source>This will get you back to your desired commit</source>
          <target state="translated">这将会让你回到你想要的承诺</target>
        </trans-unit>
        <trans-unit id="40dbc891e4d9a6e9d189f3487caaedd144c42f8a" translate="yes" xml:space="preserve">
          <source>This will reset all changed files to un-added state.</source>
          <target state="translated">这将重置所有已更改的文件为未添加状态。</target>
        </trans-unit>
        <trans-unit id="a896003d14a51adf413918e0193aff717b25832a" translate="yes" xml:space="preserve">
          <source>This will return the state of the repo under &quot;my project&quot; to what it was when you made that commit (a &quot;commit&quot; means a snapshot of your working files). All commits since then will be lost forever under &quot;my project&quot;, BUT... &lt;strong&gt;they will still be present&lt;/strong&gt; in the repo under &quot;my project - copy&quot; since you copied &lt;em&gt;all&lt;/em&gt; those files - including the ones under .../.git/.</source>
          <target state="translated">这会将&amp;ldquo;我的项目&amp;rdquo;下的存储库状态返回到您进行提交时的状态（&amp;ldquo;提交&amp;rdquo;表示您的工作文件的快照）。 此后的所有提交将永久丢失在&amp;ldquo;我的项目&amp;rdquo;下，但是...由于您复制了&lt;em&gt;所有&lt;/em&gt;这些文件-包括... /。git下的文件， &lt;strong&gt;它们仍将存在&lt;/strong&gt;于&amp;ldquo;我的项目-复制&amp;rdquo;下的回购中。 /。</target>
        </trans-unit>
        <trans-unit id="d4bd97818967ec523bd6f7b1579640e38609e22e" translate="yes" xml:space="preserve">
          <source>This will revert everything from the HEAD back to the commit hash, meaning it will recreate that commit state in the working tree &lt;em&gt;as if&lt;/em&gt; every commit since had been walked back. You can then commit the current tree, and it will create a brand new commit essentially equivalent to the commit you &quot;reverted&quot; to.</source>
          <target state="translated">这会将所有内容从HEAD还原回提交哈希，这意味着它将在工作树中重新创建该提交状态， &lt;em&gt;就好像&lt;/em&gt;回溯了所有提交以来。 然后，您可以提交当前树，它将创建一个全新的提交，该提交基本上等同于您&amp;ldquo;还原&amp;rdquo;到的提交。</target>
        </trans-unit>
        <trans-unit id="c67e05bcff0f4c1a62d4ecdacccace9fec0a9a55" translate="yes" xml:space="preserve">
          <source>This will revert on the local repository, and here after using &lt;code&gt;git push -f&lt;/code&gt; will update the remote repository.</source>
          <target state="translated">这将在本地存储库上还原，并且在使用 &lt;code&gt;git push -f&lt;/code&gt; 之后将在此处更新远程存储库。</target>
        </trans-unit>
        <trans-unit id="5d91c733edd0666eeb1a577ec8aa795bdf80e0be" translate="yes" xml:space="preserve">
          <source>To be clear, these alternatives &lt;strong&gt;&lt;em&gt;are not the best way to revert commits&lt;/em&gt;&lt;/strong&gt;, &lt;a href=&quot;https://stackoverflow.com/a/4114122/456814&quot;&gt;Jefromi's solutions are&lt;/a&gt;, but I just want to point out that you can also use these other methods to achieve the same thing as &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">需要明确的是，这些替代&lt;strong&gt;&lt;em&gt;方法不是还原提交的最佳方法&lt;/em&gt;&lt;/strong&gt; ， &lt;a href=&quot;https://stackoverflow.com/a/4114122/456814&quot;&gt;Jefromi的解决方案是&lt;/a&gt; ，但是我只想指出，您还可以使用这些其他方法来实现与 &lt;code&gt;git revert&lt;/code&gt; 相同的目的。</target>
        </trans-unit>
        <trans-unit id="36f8bb30864057728606d69b5633ce52d6920b0e" translate="yes" xml:space="preserve">
          <source>To completely clean a coder's directory up from some accidental changes, we used:</source>
          <target state="translated">为了彻底清理掉一些不小心的改动,我们用了。</target>
        </trans-unit>
        <trans-unit id="a1f640222eec0351f9613d995f9798a710e3b622" translate="yes" xml:space="preserve">
          <source>To go back to where you were, just check out the branch you were on again. (If you've made changes, as always when switching branches, you'll have to deal with them as appropriate. You could reset to throw them away; you could stash, checkout, stash pop to take them with you; you could commit them to a branch there if you want a branch there.)</source>
          <target state="translated">要想回到原来的地方,只需再次检查出你原来所在的分支就可以了。(如果你做了更改,在切换分支的时候,你要像往常一样,酌情处理它们)。你可以重置丢掉它们;你可以把它们藏起来,结账、结账、藏起来,把它们带在身上;如果你想在那里有一个分支,你可以把它们提交到那里的分支上)。</target>
        </trans-unit>
        <trans-unit id="129cac7b2f2308cb06623ae91e17d42a34cd6450" translate="yes" xml:space="preserve">
          <source>To keep the changes from the previous commit to HEAD and move to the previous commit, do:</source>
          <target state="translated">要保留前一个提交到HEAD的更改,并移动到前一个提交,请做。</target>
        </trans-unit>
        <trans-unit id="2cdc5dc8a6118cdbdf6653eb58002f8b4b9643eb" translate="yes" xml:space="preserve">
          <source>To revert to a commit that's older than the most recent commit:</source>
          <target state="translated">要恢复到比最近一次提交更早的提交。</target>
        </trans-unit>
        <trans-unit id="af05159b40594ed3dd36e91ea67e0ecc5c9b9824" translate="yes" xml:space="preserve">
          <source>To revert to a previous commit, ignoring any changes:</source>
          <target state="translated">要恢复到之前的提交,忽略任何更改。</target>
        </trans-unit>
        <trans-unit id="18f27a31c44cf903ff5441d21940a6fca4a36ad5" translate="yes" xml:space="preserve">
          <source>To save yourself much stress, learn from my scars. You have to pretty much have to read a book on Git - I'd recommend &lt;a href=&quot;http://shop.oreilly.com/product/0636920022862.do&quot;&gt;&quot;Version Control with Git&quot;&lt;/a&gt;. Do it sooner rather than later. If you do, bear in mind that much of the complexity of Git comes from branching and then remerging: you can skip those parts in any book. From your question there's &lt;strong&gt;no reason why people should be blinding you with science&lt;/strong&gt;.</source>
          <target state="translated">为了减轻压力，请从我的伤疤中吸取教训。 您几乎必须阅读有关Git的书-我建议您使用&lt;a href=&quot;http://shop.oreilly.com/product/0636920022862.do&quot;&gt;&amp;ldquo;使用Git进行版本控制&amp;rdquo;&lt;/a&gt; 。 尽早而不是迟些。 如果这样做，请记住，Git的大部分复杂性来自分支然后进行合并：您可以跳过任何本书中的那些部分。 从您的问题出发， &lt;strong&gt;没有理由人们不应该对科学视而不见&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="60371cbf5e87d6f2002f2a206a806a7e5f91fa95" translate="yes" xml:space="preserve">
          <source>Try resetting to the desired commit -</source>
          <target state="translated">试着重置为所需的提交 ----</target>
        </trans-unit>
        <trans-unit id="4ab73cc42152aafd9cdeb94678eddca0f26c65b2" translate="yes" xml:space="preserve">
          <source>Try the above two steps, and if you find this is what you want then &lt;code&gt;git push&lt;/code&gt;.</source>
          <target state="translated">尝试以上两个步骤，如果找到所需的内容，则使用 &lt;code&gt;git push&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce0fc03dd48af3f60e24d84c9f03e10d33ab29f2" translate="yes" xml:space="preserve">
          <source>Undo published commits with new commits</source>
          <target state="translated">用新的提交撤销已发布的提交</target>
        </trans-unit>
        <trans-unit id="e357f037417b79c1f53b14e55b45586d58a3a8fc" translate="yes" xml:space="preserve">
          <source>Working on your own and just want it to work? Follow these instructions below, they&amp;rsquo;ve worked reliably for me and many others for years.</source>
          <target state="translated">独自工作，只是想让它工作？ 请按照以下这些说明进行操作，它们已经为我和其他许多人可靠地工作了很多年。</target>
        </trans-unit>
        <trans-unit id="bfbc1492c175741aec1b19e36c158372c2acb248" translate="yes" xml:space="preserve">
          <source>Working with others? Git is complicated. Read the comments below this answer before you do something rash.</source>
          <target state="translated">和别人合作?Git很复杂。在你草率行事之前,请先阅读这个答案下面的评论。</target>
        </trans-unit>
        <trans-unit id="6fc5b5d4f9f58f2ada5512e1323131052ffa47d8" translate="yes" xml:space="preserve">
          <source>You can always use the &lt;code&gt;reflog&lt;/code&gt; as well. &lt;code&gt;git reflog&lt;/code&gt; will display any change which updated the &lt;code&gt;HEAD&lt;/code&gt; and checking out the desired reflog entry will set the &lt;code&gt;HEAD&lt;/code&gt; back to this commit.</source>
          <target state="translated">您也可以始终使用 &lt;code&gt;reflog&lt;/code&gt; 。 &lt;code&gt;git reflog&lt;/code&gt; 将显示任何更新了 &lt;code&gt;HEAD&lt;/code&gt; 的更改，并且签出所需的reflog条目会将 &lt;code&gt;HEAD&lt;/code&gt; 设置为此提交。</target>
        </trans-unit>
        <trans-unit id="b8c8bcea16c9481768b294a2ff0bb5893fbd2b22" translate="yes" xml:space="preserve">
          <source>You can complete all these initial steps yourself and push back to the Git repository.</source>
          <target state="translated">你可以自己完成所有这些初始步骤,然后推送回 Git 仓库。</target>
        </trans-unit>
        <trans-unit id="46d4a73bb0c7e90909ecbe27018a35659e540a96" translate="yes" xml:space="preserve">
          <source>You can do this by the following two commands:</source>
          <target state="translated">你可以通过以下两个命令来实现。</target>
        </trans-unit>
        <trans-unit id="87a7f8aebc0121bb14d36842cc030ba7f7a06899" translate="yes" xml:space="preserve">
          <source>You first need to remove &lt;em&gt;develop&lt;/em&gt; from &lt;em&gt;origin&lt;/em&gt;:</source>
          <target state="translated">您首先需要从&lt;em&gt;源中&lt;/em&gt;删除&lt;em&gt;开发&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="585c85b4dfbefb384c267da9a02b846ad39914b9" translate="yes" xml:space="preserve">
          <source>You may also find this answer helpful in this case:</source>
          <target state="translated">在这种情况下,你可能也会发现这个答案对你有帮助。</target>
        </trans-unit>
        <trans-unit id="d87b94b215284e1aa841827bb6562b76a92a53bb" translate="yes" xml:space="preserve">
          <source>You then have two versions on your system... you can examine or copy or modify files of interest, or whatever, from the previous commit. You can completely discard the files under &quot;my project - copy&quot;, if you have decided the new work since the restored commit was going nowhere...</source>
          <target state="translated">然后你的系统上就有了两个版本...........你可以检查或复制或修改之前提交的感兴趣的文件,或者其他什么的。你可以完全丢弃 &quot;我的项目-复制 &quot;下的文件,如果你已经决定了新的工作,因为恢复后的提交没有任何进展......</target>
        </trans-unit>
        <trans-unit id="0f2e318b1935d70cae2d23c7890a20999cf17577" translate="yes" xml:space="preserve">
          <source>and then do &lt;code&gt;git push&lt;/code&gt;</source>
          <target state="translated">然后做 &lt;code&gt;git push&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ce7c8c60b9f299878c97f98c24b38f49d1d7943" translate="yes" xml:space="preserve">
          <source>or &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt; or whatever.</source>
          <target state="translated">或 &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt; 或其他。</target>
        </trans-unit>
        <trans-unit id="b8f6644189516425ecbec15a26511b2a1d063607" translate="yes" xml:space="preserve">
          <source>till you get the required commit. To make the HEAD point to that, do</source>
          <target state="translated">直到你得到所需的提交。为了使HEAD点到这一点,做</target>
        </trans-unit>
        <trans-unit id="47c1a7bde6fea0f98c36d82121612c5d695d52d3" translate="yes" xml:space="preserve">
          <source>where HEAD is the last commit in your current branch</source>
          <target state="translated">其中HEAD是当前分支中的最后一个提交。</target>
        </trans-unit>
        <trans-unit id="31057de6b748ee9376193a5a0bb4847fa68394d5" translate="yes" xml:space="preserve">
          <source>where HEAD points to the latest commit at you current branch.</source>
          <target state="translated">其中head指向您当前分支的最新提交。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
