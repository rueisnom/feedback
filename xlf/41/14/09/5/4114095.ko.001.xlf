<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4114095">
    <body>
      <group id="4114095">
        <trans-unit id="e04a70a050e0184c775c34cc5b81f69d06b5dbc4" translate="yes" xml:space="preserve">
          <source>&quot;Move&quot; your head back to the desired commit.</source>
          <target state="translated">머리를 원하는 커밋으로 &quot;이동&quot;하십시오.</target>
        </trans-unit>
        <trans-unit id="4148ca3446d8d4e6a32759ec85d980d2895c84c8" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;--no-commit&lt;/code&gt; flag lets git revert all the commits at once- otherwise you'll be prompted for a message for each commit in the range, littering your history with unnecessary new commits.)</source>
          <target state="translated">( &lt;code&gt;--no-commit&lt;/code&gt; 플래그를 사용하면 git은 모든 커밋을 한 번에 되돌릴 수 있습니다. 그렇지 않으면 범위 내의 각 커밋에 대한 메시지가 표시되어 불필요한 새로운 커밋으로 히스토리가 흩어집니다.)</target>
        </trans-unit>
        <trans-unit id="e15d04330bbe740f6a74404ee089d55347802fef" translate="yes" xml:space="preserve">
          <source>(to check COMMIT_ID use &lt;code&gt;git log&lt;/code&gt;)</source>
          <target state="translated">(COMMIT_ID를 확인하려면 &lt;code&gt;git log&lt;/code&gt; 사용)</target>
        </trans-unit>
        <trans-unit id="0564dd57a84c02e672779732094c56edac717756" translate="yes" xml:space="preserve">
          <source>** Note:** As mentioned in comments don't do this if you're sharing your branch with other people who have copies of the old commits</source>
          <target state="translated">** 참고 : ** 의견에서 언급했듯이 이전 커밋의 사본을 가진 다른 사람들과 지점을 공유하는 경우이 작업을 수행하지 마십시오</target>
        </trans-unit>
        <trans-unit id="f0c56341861d3a785e407509c045330522d22834" translate="yes" xml:space="preserve">
          <source>--hard</source>
          <target state="translated">--hard</target>
        </trans-unit>
        <trans-unit id="39cd6d54ca024c3d25abf1100015175fb07ed816" translate="yes" xml:space="preserve">
          <source>--soft</source>
          <target state="translated">--soft</target>
        </trans-unit>
        <trans-unit id="3170ffa737d53dfa1e49c230fc0deda33fe5f900" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/4114122/456814&quot;&gt;Jefromi's solutions&lt;/a&gt; are definitely the best ones, and you should definitely use them. However, for the sake of completeness, I also wanted to show these other alternative solutions that can also be used to revert a commit (in the sense that you &lt;strong&gt;create a new commit that undoes changes in previous commit&lt;/strong&gt;, just like what &lt;code&gt;git revert&lt;/code&gt; does).</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/4114122/456814&quot;&gt;Jefromi의 솔루션&lt;/a&gt; 은 확실히 최고의 솔루션 이므로 반드시 사용해야합니다. 그러나 완전성을 기하기 위해 커밋을 되돌릴 때 사용할 수있는 다른 대안 솔루션을 보여주고 싶었습니다 ( &lt;code&gt;git revert&lt;/code&gt; 와 마찬가지로 &lt;strong&gt;이전 커밋의 변경 사항을 취소하는 새로운 커밋을 생성&lt;/strong&gt; 한다는 의미 &lt;strong&gt;에서&lt;/strong&gt; ) .</target>
        </trans-unit>
        <trans-unit id="7e7010d06d8ef75028c81045c4e8e665e47400c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--soft&lt;/code&gt; indicates that the uncommitted files should be retained as working files opposed to &lt;code&gt;--hard&lt;/code&gt; which would discard them.</source>
          <target state="translated">&lt;code&gt;--soft&lt;/code&gt; 는 커밋되지 않은 파일을 &lt;code&gt;--hard&lt;/code&gt; 와 반대되는 작업 파일로 유지하여 파일을 버리는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="af9a83c35282ccf6b38d1f91d218020d39a4319e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HEAD&lt;/code&gt; is simply a reference to the current commit (latest) on the current branch. There can only be a single &lt;code&gt;HEAD&lt;/code&gt; at any given time (excluding &lt;code&gt;git worktree&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 는 단순히 현재 분기의 현재 커밋 (최신)에 대한 참조입니다. 주어진 시간에 단일 &lt;code&gt;HEAD&lt;/code&gt; 만있을 수 있습니다 ( &lt;code&gt;git worktree&lt;/code&gt; 제외).</target>
        </trans-unit>
        <trans-unit id="c9377808b29b1b2885d71fd864cfb1eaf22a08f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HEAD~1&lt;/code&gt; is the last commit.  If you want to rollback 3 commits you could use &lt;code&gt;HEAD~3&lt;/code&gt;.  If you want to rollback to a specific revision number, you could also do that using its SHA hash.</source>
          <target state="translated">&lt;code&gt;HEAD~1&lt;/code&gt; 이 마지막 커밋입니다. 3 커밋을 롤백하려면 &lt;code&gt;HEAD~3&lt;/code&gt; 사용할 수 있습니다. 특정 개정 번호로 롤백하려는 경우 SHA 해시를 사용하여이를 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8362fb05761b16c13e670545438dd3cbe76732ed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Sample:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Sample:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43d0a6c03da527ec12858c306ab6555e6caf9088" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-reset&quot;&gt;&lt;code&gt;git reset HEAD --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-reset&quot;&gt; &lt;code&gt;git reset HEAD --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5941d87399c11b4c01ccb41bbd0ab033fe969fd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;code&gt;First of all what is HEAD?&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;First of all what is HEAD?&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1253bf83df98a1b2c7a29a783edb0908bb3dd47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;code&gt;detached HEAD&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;detached HEAD&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19f54112a4fcd0d690e93b53da0c501fa0fff714" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution!&lt;/strong&gt; This command can cause losing commit history, if user put the wrong commit mistakenly. Always have en extra backup of your git some
  where else just in case if you do mistakes, than you are a bit safer.
  :)</source>
          <target state="translated">&lt;strong&gt;주의!&lt;/strong&gt; 사용자가 잘못된 커밋을 실수로 입력 한 경우이 명령으로 커밋 기록이 손실 될 수 있습니다. 실수를 할 경우를 대비하여 조금 더 안전하기 때문에 항상 git을 추가 백업하십시오. :)</target>
        </trans-unit>
        <trans-unit id="785ae5f8e57e7bb1825787323ff5e8191b3b952c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every time the HEAD is modified there will be a new entry in the &lt;code&gt;reflog&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HEAD가 수정 될 때마다 &lt;code&gt;reflog&lt;/code&gt; 에 새로운 항목이 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6859536c2cfa6c9f9a2889b1c0dd1aa5ed99eb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt; using &lt;code&gt;git reset&lt;/code&gt;, you can reset to a specific state. It's common using it with a commit hash as you see above.</source>
          <target state="translated">&lt;strong&gt;설명 :&lt;/strong&gt; &lt;code&gt;git reset&lt;/code&gt; 을 사용하면 특정 상태로 재설정 할 수 있습니다. 위에서 본 것처럼 커밋 해시와 함께 사용하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="eb182cc53494f3ad8a6ff778131dffe11ebe85c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; going back to a previous commit in Git is quite easy...</source>
          <target state="translated">&lt;strong&gt;좋아,&lt;/strong&gt; Git의 이전 커밋으로 돌아가는 것은 매우 쉽습니다 ...</target>
        </trans-unit>
        <trans-unit id="7e772e2042df02f4ac5a238212782b6d4443ff7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;QUICK AND DIRTY&lt;/strong&gt;: depending on the circumstances, quick and dirty may in fact be very GOOD. What my solution here does is &lt;strong&gt;NOT&lt;/strong&gt; replace irreversibly the files you have in your working directory with files hauled up/extracted from the depths of the git repository lurking beneath your .git/ directory using fiendishly clever and diabolically powerful git commands, of which there are many. &lt;strong&gt;YOU DO NOT HAVE TO DO SUCH DEEP-SEA DIVING TO RECOVER what may appear to be a disastrous situation, and attempting to do so without sufficient expertise may prove fatal&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;QUICK AND DIRTY&lt;/strong&gt; : 상황에 따라 빠르고 더러워진 것이 실제로 매우 좋습니다. 내 솔루션이하는 일은 작업 디렉토리에있는 파일을 돌이킬 수없고 영리하고 강력한 git 명령을 사용하여 .git / 디렉토리 아래에있는 git 저장소 깊이에서 추출 / 추출 된 파일로 되돌릴 수없는 것입니다. 많은. &lt;strong&gt;당신은 비참한 상황 인 것처럼 보이는 것을 회복하기 위해 심해 다이빙을해서는 안되며, 충분한 전문 지식 없이는 그렇게하지 않으면 치명적일 수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7878cb7ef8c06d6486adcc9797b87c6465365093" translate="yes" xml:space="preserve">
          <source>A few options on how to recover from a detached HEAD:</source>
          <target state="translated">분리 된 HEAD에서 복구하는 방법에 대한 몇 가지 옵션 :</target>
        </trans-unit>
        <trans-unit id="4dfe83e406d11d3436d23ab86d77fdd7d265e9d1" translate="yes" xml:space="preserve">
          <source>After all the changes, when you push all these commands, you might have to use:</source>
          <target state="translated">모든 변경 후,이 명령을 모두 누르면 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="827bbaa3663448c6ac82349b74e8b6dbac2840f5" translate="yes" xml:space="preserve">
          <source>Also from the comments, if you wanted a less 'ballzy' method you could use</source>
          <target state="translated">또한 의견에서, 덜 'ballzy'방법을 원한다면 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3902dbcd464f156f54bd98d40c88fd9ece998663" translate="yes" xml:space="preserve">
          <source>Alternative 1: Hard and Soft Resets</source>
          <target state="translated">대안 1 : 하드 및 소프트 리셋</target>
        </trans-unit>
        <trans-unit id="f7440ea2bf2d9cd756dc173beb3fbb2c0b96d8c4" translate="yes" xml:space="preserve">
          <source>Alternative 2: Delete the Current Tree and Replace with the New One</source>
          <target state="translated">대안 2 : 현재 트리를 삭제하고 새 트리로 교체</target>
        </trans-unit>
        <trans-unit id="340d66c4fa37dbe035c6408a713ee2d51dda30c1" translate="yes" xml:space="preserve">
          <source>And not only &lt;code&gt;git push&lt;/code&gt;.</source>
          <target state="translated">그리고 &lt;code&gt;git push&lt;/code&gt; 뿐만 아니라.</target>
        </trans-unit>
        <trans-unit id="11661e7c79c2472a2ccca3cd18e34e3b89b601de" translate="yes" xml:space="preserve">
          <source>As your commits are pushed remotely, you need to remove them. Let me assume your branch is &lt;em&gt;develop&lt;/em&gt; and it is pushed over &lt;em&gt;origin&lt;/em&gt;.</source>
          <target state="translated">커밋이 원격으로 푸시되면 커밋을 제거해야합니다. 당신의 브랜치가 &lt;em&gt;개발&lt;/em&gt; 되었다고 가정하고 그것이 &lt;em&gt;원점&lt;/em&gt; 으로 밀려 들어 오게하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f1cbde60a0009c9d0edd5c3e0172fa943911e90e" translate="yes" xml:space="preserve">
          <source>Assuming you're talking about master and on that respective branch (that said, this could be any working branch you're concerned with):</source>
          <target state="translated">마스터와 해당 지점에 대해 이야기하고 있다고 가정하면 (이는 관심있는 작업 지점이 될 수 있음) :</target>
        </trans-unit>
        <trans-unit id="deb1eef83454f8b7a428db302e61bd2120a598c0" translate="yes" xml:space="preserve">
          <source>At this point you can create a branch and start to work from this point on:</source>
          <target state="translated">이 시점에서 분기를 작성하고이 시점부터 작업을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92e0a8b083d31eeec3fb7a54b8954e484fe4bac4" translate="yes" xml:space="preserve">
          <source>Be careful with this flag. It resets the working tree and all changes to tracked files and all will be gone!</source>
          <target state="translated">이 플래그에주의하십시오. 작업 트리와 추적 된 파일의 모든 변경 사항을 재설정하면 모든 것이 사라집니다!</target>
        </trans-unit>
        <trans-unit id="7b8436733b5d2fc8b339e76308ff8f0bce1ffb29" translate="yes" xml:space="preserve">
          <source>Before answering let's add some background, explaining what this &lt;code&gt;HEAD&lt;/code&gt; is.</source>
          <target state="translated">대답하기 전에이 &lt;code&gt;HEAD&lt;/code&gt; 가 무엇인지 설명하는 배경을 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="34948cca5fa253149fae12b8b2bf9e121701e283" translate="yes" xml:space="preserve">
          <source>Better to use revert (see other answers) than reset. 
If you're a one man team then it probably doesn't matter.</source>
          <target state="translated">재설정보다 되돌리기 (다른 답변 참조)를 사용하는 것이 좋습니다. 당신이 한 남자 팀이라면 그것은 중요하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="1fb7af211b3dbdd61026144dfc055b0281908607" translate="yes" xml:space="preserve">
          <source>But as you see the difference is using the two flags &lt;code&gt;--soft&lt;/code&gt; and &lt;code&gt;--hard&lt;/code&gt;, by default &lt;code&gt;git reset&lt;/code&gt; using &lt;code&gt;--soft&lt;/code&gt; flag, but it's a good practice always using the flag, I explain each flag:</source>
          <target state="translated">그러나 차이점은 기본적으로 &lt;code&gt;--soft&lt;/code&gt; 플래그를 사용하는 &lt;code&gt;git reset&lt;/code&gt; 이라는 두 플래그 &lt;code&gt;--soft&lt;/code&gt; 및 &lt;code&gt;--hard&lt;/code&gt; 를 사용하는 것입니다. 그러나 항상 플래그를 사용하는 것이 좋습니다. 각 플래그를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3a40a3783dc2f06f1af89b954e94f1911bb876ad" translate="yes" xml:space="preserve">
          <source>Check &lt;code&gt;git log&lt;/code&gt; to verify your changes.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 를 확인하여 변경 사항을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="08f74d88ac0c5925d8abd0552fd45357483210d4" translate="yes" xml:space="preserve">
          <source>Copy the whole directory and call it something else, like &quot;my project - copy&quot;. Assuming your git repository (&quot;repo&quot;) files are under the &quot;my project&quot; directory (the default place for them, under a directory called &quot;.git&quot;), you will now have copied both your work files and your repo files.</source>
          <target state="translated">전체 디렉토리를 복사하고 &quot;my project-copy&quot;와 같은 다른 디렉토리로 호출하십시오. git 저장소 ( &quot;repo&quot;) 파일이 &quot;my project&quot;디렉토리 ( &quot;.git&quot;디렉토리 아래의 기본 위치)에 있다고 가정하면 작업 파일과 repo 파일이 모두 복사 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="b8dccbee136be960880188a55bdb68eb079a6375" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; shell script to revert each of them:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; 쉘 스크립트를 작성하여 각각을 되 돌리십시오.</target>
        </trans-unit>
        <trans-unit id="02bd119e81cc5355f078fe13af30b2da39d568b8" translate="yes" xml:space="preserve">
          <source>Credits go to a similar Stack Overflow question, &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1895059/git-revert-to-a-commit-by-sha-hash&quot;&gt;Revert to a commit by a SHA hash in Git?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">크레딧은 비슷한 스택 오버플로 질문으로 이동합니다. &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1895059/git-revert-to-a-commit-by-sha-hash&quot;&gt;Git에서 SHA 해시로 커밋으로 되 돌리시겠습니까?&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5d141bd57bfd683cbbec69826d5890d110b047df" translate="yes" xml:space="preserve">
          <source>Do this in the directory &quot;my project&quot;:</source>
          <target state="translated">&quot;내 프로젝트&quot;디렉토리에서이를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="378126339503a68fbaa8c750f1f8573ba4cef3c8" translate="yes" xml:space="preserve">
          <source>Especially if, for example, this is a desperate situation and you're a newbie with Git!</source>
          <target state="translated">특히, 예를 들어, 이것이 절박한 상황이고 Git의 초보자라면!</target>
        </trans-unit>
        <trans-unit id="659226488a54232bdf101d9941ce68c9bf52d0fc" translate="yes" xml:space="preserve">
          <source>Extra Alternatives to Jefromi's Solutions</source>
          <target state="translated">Jefromi의 솔루션에 대한 추가 대안</target>
        </trans-unit>
        <trans-unit id="e2691319c7272d9172f6c142db095dd9d2ef86e8" translate="yes" xml:space="preserve">
          <source>For rollback (or to revert):</source>
          <target state="translated">롤백 (또는 되돌리기)의 경우 :</target>
        </trans-unit>
        <trans-unit id="b678c79ecbee0d37c6f6be648ab4d24e89b21a6f" translate="yes" xml:space="preserve">
          <source>Git is a brilliant creation but absolutely no-one is able to just &quot;pick it up on the fly&quot;: also people who try to explain it &lt;strong&gt;far too often&lt;/strong&gt; assume prior knowledge of other VCS [Version Control Systems] and delve far too deep far too soon, and commit other crimes, like using interchangeable terms for &quot;checking out&quot; - in ways which sometimes appear almost calculated to confuse a beginner.</source>
          <target state="translated">Git은 훌륭한 창조물이지만 아무도 &quot;즉시 집어들&quot;수는 없다. &lt;strong&gt;너무 멀리&lt;/strong&gt; 설명하려고 시도하는 사람들은 다른 VCS [Version Control Systems]에 대한 사전 지식을 &lt;strong&gt;너무 자주&lt;/strong&gt; 생각하고 너무 깊이 파고 들었다. &quot;체크 아웃&quot;이라는 용어를 바꾸는 것과 같은 다른 범죄를 저지르는 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb8913d15cf59c5da03d05deec15a29efbd97e3" translate="yes" xml:space="preserve">
          <source>Hard delete unpublished commits</source>
          <target state="translated">게시되지 않은 커밋 강제 삭제</target>
        </trans-unit>
        <trans-unit id="d37dc1a343e485e372ab88fd5766ed464acce0a7" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;much simpler&lt;/strong&gt; way to go back to a previous commit (and have it in an uncommited state, to do with it whatever you like):</source>
          <target state="translated">다음은 이전 커밋으로 돌아가서 커밋되지 않은 상태로 만들고 원하는 방식으로 수행하는 &lt;strong&gt;훨씬 간단한&lt;/strong&gt; 방법입니다.</target>
        </trans-unit>
        <trans-unit id="215d7a8e885045e594e831263c3e9ba11f717afe" translate="yes" xml:space="preserve">
          <source>How do I revert a Git repository to a previous commit</source>
          <target state="translated">Git 리포지토리를 이전 커밋으로 되 돌리는 방법</target>
        </trans-unit>
        <trans-unit id="f4b9e60697411c2b40df2355799c33b516b6278b" translate="yes" xml:space="preserve">
          <source>How do I revert from my current state to a snapshot made on a certain commit?</source>
          <target state="translated">현재 상태에서 특정 커밋에 대한 스냅 샷으로 되돌리려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="9819e65d810cdde62bd17e39442b700ad932d75c" translate="yes" xml:space="preserve">
          <source>How do I revert to the commit from November 3, i.e. commit &lt;code&gt;0d1d7fc&lt;/code&gt;?</source>
          <target state="translated">11 월 3 일부터 커밋으로 되 돌리는 방법, 즉 commit &lt;code&gt;0d1d7fc&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="a0bc944d8d865d8ba6bc35d44c2edb19d282e0b7" translate="yes" xml:space="preserve">
          <source>How to move HEAD back to a previous location? (Detached head)</source>
          <target state="translated">HEAD를 이전 위치로 다시 옮기는 방법? (분리 된 머리)</target>
        </trans-unit>
        <trans-unit id="b87ef2ff181d7d386886af94b08f992cfc8c5136" translate="yes" xml:space="preserve">
          <source>I also created the image below that may happen in a real life working with Git:</source>
          <target state="translated">또한 Git을 사용하여 실제 작업에서 발생할 수있는 아래 이미지를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="8c33029b35f3d01145d86868163313daf5c84274" translate="yes" xml:space="preserve">
          <source>I believe some people may come to this question wanting to know how to rollback committed changes they've made in their master - ie throw everything away and go back to origin/master, in which case, do this:</source>
          <target state="translated">나는 어떤 사람들이 자신의 주인이 저지른 변경 사항을 롤백하는 방법을 알고 싶어서이 질문에 올 수 있다고 생각합니다. 즉, 모든 것을 버리고 원산지 / 마스터로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e72247558e4b5ad84fc16e003254af4f90587b17" translate="yes" xml:space="preserve">
          <source>I found a much more convenient and simple way to achieve the results above:</source>
          <target state="translated">위의 결과를 달성하는 훨씬 더 편리하고 간단한 방법을 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="0262f3bdfcb749038ef55e8d537b8a1a7c721298" translate="yes" xml:space="preserve">
          <source>I found the answer from in a blog post (now no longer exists)</source>
          <target state="translated">블로그 게시물에서 답변을 찾았습니다 (더 이상 존재하지 않음).</target>
        </trans-unit>
        <trans-unit id="26c73afeef62688ff9fde1fd66868ad120f3a9c0" translate="yes" xml:space="preserve">
          <source>I have had a similar issue and wanted to revert back to an earlier commit. In my case I was not interested to keep the newer commit, hence I used &lt;code&gt;Hard&lt;/code&gt;.</source>
          <target state="translated">비슷한 문제가 있었고 이전 커밋으로 되돌리려 고했습니다. 필자의 경우 새로운 커밋을 유지하는 데 관심이 없었으므로 &lt;code&gt;Hard&lt;/code&gt; 를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="d6910536d152b4d8cb3df0022070f30f0dc88999" translate="yes" xml:space="preserve">
          <source>I have tried a lot of ways to revert local changes in Git, and it seems that this works the best if you just want to revert to the latest commit state.</source>
          <target state="translated">Git에서 로컬 변경 사항을 되 돌리는 많은 방법을 시도했지만 최신 커밋 상태로 되돌리려는 경우 이것이 가장 효과가있는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="20144fbb67d31dfaa0aab28764e5a24600f64929" translate="yes" xml:space="preserve">
          <source>If I do &lt;code&gt;git log&lt;/code&gt;, then I get the following output:</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 을 수행하면 다음과 같은 출력이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a9dc1195c97f99966a626fc0a6b57adb56e167fa" translate="yes" xml:space="preserve">
          <source>If changes are not required from the previous commit to HEAD and just discard all changes, do:</source>
          <target state="translated">이전 커밋에서 HEAD 로의 변경이 필요하지 않고 모든 변경 사항을 버릴 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c7c4de579733c15d4364d2a57e8371976d3f8015" translate="yes" xml:space="preserve">
          <source>If the situation is an &lt;strong&gt;urgent one&lt;/strong&gt;, and you just want to do what the questioner asked in a &lt;strong&gt;quick and dirty&lt;/strong&gt; way, assuming your project is under a directory called, for example, &quot;my project&quot;:</source>
          <target state="translated">상황이 &lt;strong&gt;긴급한&lt;/strong&gt; 상황이고 프로젝트가 &quot;my project&quot;와 같은 디렉토리에 있다고 가정하면 질문자가 &lt;strong&gt;빠르고 더러운&lt;/strong&gt; 방식으로 요청한 것을 수행하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b06ed00b1db93823cdbc02006aad46f5fb3ad39f" translate="yes" xml:space="preserve">
          <source>If you are not on the latest commit - meaning that &lt;code&gt;HEAD&lt;/code&gt; is pointing to a prior commit in history it's called &lt;strong&gt;&lt;em&gt;&lt;code&gt;detached HEAD&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 가 히스토리에서 이전 커밋을 가리키고 있다는 최신 커밋이 아닌 경우이를 &lt;strong&gt;&lt;em&gt; &lt;code&gt;detached HEAD&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="8531e0a48ed45802099d9ae7e009dfd16c1eba9c" translate="yes" xml:space="preserve">
          <source>If you decide you didn't want to revert after all, you can revert the revert (as described here) or reset back to before the revert (see the previous section).</source>
          <target state="translated">결국 되 돌리지 않기로 결정한 경우 여기에 설명 된대로 되돌리기를 되돌 리거나 되돌리기 전에 다시 설정할 수 있습니다 (이전 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="8d7fa0de483735064b1cb81199ea5be983c9fc2b" translate="yes" xml:space="preserve">
          <source>If you find something wrong, do:</source>
          <target state="translated">잘못된 것을 발견하면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0c568174f2a4a4531694150c506de49219506b53" translate="yes" xml:space="preserve">
          <source>If you have &lt;strong&gt;one and only&lt;/strong&gt; commit in your repo, try</source>
          <target state="translated">당신이 &lt;strong&gt;하나만&lt;/strong&gt; 가지고 당신의 레포에 헌신한다면, 시도하십시오</target>
        </trans-unit>
        <trans-unit id="f8561a2aa2ca03b7277119e0d3ed51f7d90d7f06" translate="yes" xml:space="preserve">
          <source>If you mess up, you've already thrown away your local changes, but you can at least get back to where you were before by resetting again.</source>
          <target state="translated">혼란 스러우면 이미 로컬 변경 사항을 버렸지 만 최소한 다시 재설정하여 이전 위치로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="427ff9573e5ddce662f5ac0851f87ec0e4f79bd7" translate="yes" xml:space="preserve">
          <source>If you want the Git repository to a previous commit:</source>
          <target state="translated">Git 리포지토리를 이전 커밋에 적용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="a4276522808022598711b636fe0f6fb240bcec8f" translate="yes" xml:space="preserve">
          <source>If you want to &quot;uncommit&quot;, erase the last commit message, and put the modified files back in staging, you would use the command:</source>
          <target state="translated">&quot;커밋 해제&quot;, 마지막 커밋 메시지를 지우고 수정 된 파일을 다시 스테이징에 넣으려면 다음 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="de04053c3af13c4e631f9c32fc311eee129f128d" translate="yes" xml:space="preserve">
          <source>If you want to correct some error in the last commit a good alternative would be using &lt;strong&gt;git commit --amend&lt;/strong&gt; command. If the last commit is not pointed by any reference, this will do the trick, as it create a commit with the same parent as the last commit. If there is no reference to the last commit, it will simply be discarded and this commit will be the last commit. This is a good way of correcting commits without reverting commits. However it has its own limitations.</source>
          <target state="translated">마지막 커밋에서 일부 오류를 수정하려면 &lt;strong&gt;git commit --amend&lt;/strong&gt; 명령을 사용하는 것이 좋습니다. 마지막 커밋이 참조에 의해 지시되지 않으면 마지막 커밋과 동일한 부모로 커밋을 생성하므로 트릭을 수행합니다. 마지막 커밋에 대한 참조가 없으면 단순히 삭제되고이 커밋이 마지막 커밋이됩니다. 이것은 커밋을 되 돌리지 않고 커밋을 수정하는 좋은 방법입니다. 그러나 자체 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f961938dac4103278585a68d34a01db4237b0fc" translate="yes" xml:space="preserve">
          <source>If you want to keep your changes, you can also use:</source>
          <target state="translated">변경 사항을 유지하려면 다음을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d856fff44e0b372b7b4c3612a30af8112dd941ab" translate="yes" xml:space="preserve">
          <source>If you want to temporarily go back to it, fool around, then come back to where you are, all you have to do is check out the desired commit:</source>
          <target state="translated">일시적으로 돌아가서 어리석은 다음 현재 위치로 돌아 오려면 원하는 커밋을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="25ef3e3b661a2247aab4fb208c0d2510055a9739" translate="yes" xml:space="preserve">
          <source>If, on the other hand, you want to really get rid of everything you've done since then, there are two possibilities. One, if you haven't published any of these commits, simply reset:</source>
          <target state="translated">반면에 그 이후로 한 모든 일을 정말로 없애고 싶다면 두 가지 가능성이 있습니다. 하나,이 커밋을 게시하지 않은 경우 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ebd49d9e9e79e3647b4491da259cf962d75113e8" translate="yes" xml:space="preserve">
          <source>It WILL override all your local changes and DELETE all added files since the last commit in the branch.</source>
          <target state="translated">분기의 마지막 커밋 이후 모든 로컬 변경 사항을 무시하고 추가 된 모든 파일을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="3c149ded6611aef9d7462af1e5621ecaaf07abf6" translate="yes" xml:space="preserve">
          <source>It directly clears all the changes that you have been making since the last commit.</source>
          <target state="translated">마지막 커밋 이후에 수행 한 모든 변경 사항을 직접 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="58bbb523b3d2e34c2af2248245176f969ea2f258" translate="yes" xml:space="preserve">
          <source>It is capable of taking range from the HEAD like below. Here 1 says &quot;revert last commit.&quot;</source>
          <target state="translated">아래와 같이 HEAD로부터 범위를 취할 수 있습니다. 여기 1은 &quot;마지막 커밋 되돌리기&quot;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="eb09fdc79570755955c80aa0d4bc081876b97bac" translate="yes" xml:space="preserve">
          <source>It is the same code code as boulder_ruby suggested, but I have added &lt;code&gt;git add .&lt;/code&gt; before  &lt;code&gt;git reset --hard HEAD&lt;/code&gt; to erase all new files created since the last commit since this is what most people expect I believe when reverting to the latest commit.</source>
          <target state="translated">boulder_ruby가 제안한 코드 코드와 동일하지만 &lt;code&gt;git add .&lt;/code&gt; &lt;code&gt;git reset --hard HEAD&lt;/code&gt; before -hard HEAD 는 마지막 커밋 이후에 생성 된 모든 새 파일을 지우는 것입니다. 이것은 대부분의 사람들이 최신 커밋으로 되돌릴 때 내가 기대하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c30d8d0b88769f23fbadcbdeb36ad079e70ea8a" translate="yes" xml:space="preserve">
          <source>It will NOT create any commits as &lt;code&gt;git revert&lt;/code&gt; does.</source>
          <target state="translated">&lt;code&gt;git revert&lt;/code&gt; 처럼 커밋을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8005ef78b00c05ee0f92589ff930d6b321f3c1fe" translate="yes" xml:space="preserve">
          <source>It will NOT detach your HEAD like &lt;code&gt;git checkout &amp;lt;commithashcode&amp;gt;&lt;/code&gt; does.</source>
          <target state="translated">&lt;code&gt;git checkout &amp;lt;commithashcode&amp;gt;&lt;/code&gt; 와 같이 HEAD를 분리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6eb5bea727a80b27c2fa5b69b3487e69026c556a" translate="yes" xml:space="preserve">
          <source>It will remove your previous Git commit.</source>
          <target state="translated">이전 Git 커밋을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="7249d3ccfdff131742220b6429cf95e4e286e0d6" translate="yes" xml:space="preserve">
          <source>It works only with branches names, so you can revert only to latest commit in the branch this way.</source>
          <target state="translated">분기 이름에서만 작동하므로 이런 방식으로 분기의 최신 커밋으로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd597ad6f3e74b984d2eff89845813ceef14c52b" translate="yes" xml:space="preserve">
          <source>Just &lt;code&gt;git reset --hard HEAD&lt;/code&gt; will get rid of modifications, but it won't get rid of &quot;new&quot; files. In their case they'd accidentally dragged an important folder somewhere random, and all those files were being treated as new by Git, so a &lt;code&gt;reset --hard&lt;/code&gt; didn't fix it. By running the &lt;code&gt;git add -A .&lt;/code&gt; beforehand, it explicitly tracked them all with git, to be wiped out by the reset.</source>
          <target state="translated">&lt;code&gt;git reset --hard HEAD&lt;/code&gt; 는 수정을 제거하지만 &quot;새&quot;파일은 제거하지 않습니다. 그들의 경우 그들은 실수로 중요한 폴더를 무작위로 드래그했으며 모든 파일이 Git에 의해 새로운 것으로 취급 되었기 때문에 &lt;code&gt;reset --hard&lt;/code&gt; 이 해결되지 않았습니다. &lt;code&gt;git add -A .&lt;/code&gt; 를 실행하면 사전에 git으로 명시 적으로 추적하여 재설정으로 지워집니다.</target>
        </trans-unit>
        <trans-unit id="c8a473be30d0bd103f06c5bf43af10cddca46531" translate="yes" xml:space="preserve">
          <source>Lastly, push &lt;em&gt;develop&lt;/em&gt; again:</source>
          <target state="translated">마지막으로 다시 &lt;em&gt;개발을&lt;/em&gt; 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="8031e401d2da65a74406a30adeb72243cd3390a7" translate="yes" xml:space="preserve">
          <source>Lots of complicated and dangerous answers here, but it's actually easy:</source>
          <target state="translated">여기에 복잡하고 위험한 답변이 많이 있지만 실제로는 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="6a3ea14413dd6ac5b8e74268e0d3256e4a55da1b" translate="yes" xml:space="preserve">
          <source>Note that this is Resetting and Forcing the change to the remote, so that if others on your team have already git pulled, you will cause problems for them. You are destroying the change history, which is an important reason why people use git in the first place.</source>
          <target state="translated">이것은 팀의 다른 사람들이 이미 깃을 뽑아서 문제를 일으킬 수 있도록 재설정 및 원격 변경을 강제합니다. 변경 내역을 파괴하고 있는데, 이것이 사람들이 처음에 git을 사용하는 중요한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="4be35ba1efbe333f75c355856eb657e4448b68fa" translate="yes" xml:space="preserve">
          <source>Note: (&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/RelNotes/2.7.0.txt&quot;&gt;Since Git 2.7&lt;/a&gt;) you can also use the &lt;code&gt;git rebase --no-autostash&lt;/code&gt; as well.</source>
          <target state="translated">참고 : ( &lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/RelNotes/2.7.0.txt&quot;&gt;Git 2.7 이후&lt;/a&gt; ) &lt;code&gt;git rebase --no-autostash&lt;/code&gt; 도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e293c8b2eb9661fb2b9e59253581e609baa6c8" translate="yes" xml:space="preserve">
          <source>Nothing here worked for me apart from this exact combination:</source>
          <target state="translated">이 정확한 조합을 제외하고는 여기에서 아무것도 효과가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="419ddbdcdc17f46e12b7bf15b16aa8731606d7b0" translate="yes" xml:space="preserve">
          <source>Now you can &lt;code&gt;checkout&lt;/code&gt; all un-added files by</source>
          <target state="translated">이제 추가되지 않은 모든 파일을 &lt;code&gt;checkout&lt;/code&gt; 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e54b6879a199c4996950e6c441beef9bc4f56ce4" translate="yes" xml:space="preserve">
          <source>On the command line it will look like this - SHA-1 instead of the branch name since the &lt;code&gt;HEAD&lt;/code&gt; is not pointing to the the tip of the current branch:</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 가 현재 분기의 끝을 가리 키지 않기 때문에 명령 줄에서 분기 이름 대신 SHA-1이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="32ab2cb78ae1de14f78e6d0c088c542ad358e245" translate="yes" xml:space="preserve">
          <source>On the other hand, if you've published the work, you probably don't want to reset the branch, since that's effectively rewriting history. In that case, you could indeed revert the commits. With Git, revert has a very specific meaning: create a commit with the reverse patch to cancel it out. This way you don't rewrite any history.</source>
          <target state="translated">다른 한편으로, 당신이 작품을 출판했다면, 아마도 역사를 효과적으로 다시 작성하기 때문에 브랜치를 재설정하고 싶지 않을 것입니다. 이 경우 실제로 커밋을 되돌릴 수 있습니다. Git에서 revert는 매우 구체적인 의미를 갖습니다. 리버스 패치로 커밋을 생성하여 취소합니다. 이렇게하면 기록을 다시 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56a3c461f0299749f2a082f928f4ebddece45866" translate="yes" xml:space="preserve">
          <source>On this subject of &quot;backing up to the Cloud&quot;, the next step is to open an account (free of course) with GitHub or (better in my view) &lt;a href=&quot;https://gitlab.com&quot;&gt;GitLab&lt;/a&gt;. You can then regularly do a &lt;code&gt;git push&lt;/code&gt; command to make your Cloud repo up-to-date &quot;properly&quot;. But again, talking about this may be too much too soon.</source>
          <target state="translated">&quot;클라우드에 백업&quot;이라는이 주제에 대해 다음 단계는 GitHub 또는 (더 나은 관점에서) &lt;a href=&quot;https://gitlab.com&quot;&gt;GitLab&lt;/a&gt; 계정을 개설하는 것입니다 (물론). 그런 다음 정기적으로 &lt;code&gt;git push&lt;/code&gt; 명령을 수행하여 Cloud 저장소를 &quot;적절하게&quot;최신 상태로 만들 수 있습니다. 그러나 다시 말하지만, 이것에 대해 너무 빨리 이야기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62f200b3dfaa6dff2d5ae300412e4adc775e9540" translate="yes" xml:space="preserve">
          <source>Or if you want to make commits while you're there, go ahead and make a new branch while you're at it:</source>
          <target state="translated">또는 당신이 거기있는 동안 커밋을하고 싶다면 계속해서 새로운 지점을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="60b244e32b96925828e25d2b3c24cfdc70e7d1f5" translate="yes" xml:space="preserve">
          <source>PS: It has a little problem; it also deletes all you recently stored stash changes. Which I guess in most cases should not matter.</source>
          <target state="translated">추신 : 약간의 문제가 있습니다. 또한 최근에 저장된 숨김 변경 사항을 모두 삭제합니다. 나는 대부분의 경우 중요하지 않다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="5b5050c847d01d43c2c27ca22983b3c3aa0c9f7b" translate="yes" xml:space="preserve">
          <source>PS: One other thought: It is (now) actually quite simple to keep the Git repo in a directory other than the one with the working files. This would mean you would not have to copy the entire Git repository using the above quick &amp;amp; dirty solution. See the answer by Fryer using &lt;code&gt;--separate-git-dir&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/questions/505467/can-i-store-the-git-folder-outside-the-files-i-want-tracked&quot;&gt;here&lt;/a&gt;. &lt;strong&gt;Be warned&lt;/strong&gt;, though: If you have a &quot;separate-directory&quot; repository which you don't copy, and you do a hard reset, all versions subsequent to the reset commit will be lost forever, unless you have, as you absolutely should, regularly backed up your repository, preferably to the Cloud (e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_Drive&quot;&gt;Google Drive&lt;/a&gt;) among other places.</source>
          <target state="translated">추신 : 한 가지 다른 생각 : 실제로 파일을 가지고있는 디렉토리가 아닌 다른 디렉토리에 Git 저장소를 유지하는 것은 실제로 간단합니다. 이것은 위의 빠르고 더러운 솔루션을 사용하여 전체 Git 저장소를 복사하지 않아도됨을 의미합니다. &lt;code&gt;--separate-git-dir&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/questions/505467/can-i-store-the-git-folder-outside-the-files-i-want-tracked&quot;&gt;here&lt;/a&gt; 사용하여 Fryer의 답변을 참조 하십시오 . 그러나 &lt;strong&gt;경고&lt;/strong&gt; : 복사하지 않는 &quot;별도의 디렉토리&quot;저장소가 있고 하드 재설정을 수행하는 경우, 재설정 커밋 이후의 모든 버전은 반드시 필요한 경우를 제외하고는 영원히 손실됩니다. 저장소를 정기적으로 백업하는 것이 좋습니다 (예 : 클라우드 (예 : &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_Drive&quot;&gt;Google 드라이브&lt;/a&gt; )).</target>
        </trans-unit>
        <trans-unit id="fd0ba66aa9ddaa029e7c11b077be6e222c3aa32a" translate="yes" xml:space="preserve">
          <source>Per the &lt;a href=&quot;https://en.wikipedia.org/wiki/Man_page&quot;&gt;man page&lt;/a&gt;, it can also be used as such:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Man_page&quot;&gt;매뉴얼 페이지&lt;/a&gt; 에 따라 다음과 같이 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1070632c158ecb6d00478018b42aa2927bcfff94" translate="yes" xml:space="preserve">
          <source>Pull the latest version of your repository from Bitbucket using the &lt;code&gt;git pull --all&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;git pull --all&lt;/code&gt; 명령을 사용하여 Bitbucket에서 최신 버전의 저장소를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9fe38f7b3252db2987b29485e48b59951ef72185" translate="yes" xml:space="preserve">
          <source>Push the change to Git repository using &lt;code&gt;git push --force&lt;/code&gt; to force push the change.</source>
          <target state="translated">&lt;code&gt;git push --force&lt;/code&gt; 를 사용하여 변경 사항을 Git 리포지토리로 푸시하여 변경 사항을 강제로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="2dd8de4c78a70b4822060391dc7092a8a0da9c11" translate="yes" xml:space="preserve">
          <source>Reset the head of your repository's history using the &lt;code&gt;git reset --hard HEAD~N&lt;/code&gt; where N is the number of commits you want to take the head back. In the following example the head would be set back one commit, to the last commit in the repository history:</source>
          <target state="translated">&lt;code&gt;git reset --hard HEAD~N&lt;/code&gt; 사용하여 저장소 히스토리 헤드를 재설정하십시오. 여기서 N은 헤드를 되 찾을 커밋 수입니다. 다음 예제에서 헤드는 하나의 커밋을 저장소 히스토리의 마지막 커밋으로 다시 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d0be8e3d2b5caaa96f38eb189df8ec95362918aa" translate="yes" xml:space="preserve">
          <source>Revert back &lt;strong&gt;with keeping&lt;/strong&gt; the changes:</source>
          <target state="translated">변경 사항 &lt;strong&gt;을 유지&lt;/strong&gt; 한 &lt;strong&gt;상태로&lt;/strong&gt; 되 돌리십시오.</target>
        </trans-unit>
        <trans-unit id="9c0d62b8fc38ca4721e6e1706ee9f51dce3b15f2" translate="yes" xml:space="preserve">
          <source>Revert back &lt;strong&gt;without keeping&lt;/strong&gt; the changes:</source>
          <target state="translated">변경 사항 &lt;strong&gt;을 유지하지 않고&lt;/strong&gt; 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="ee00d25f4d3f7808f421b0d05a47469fb758bd2e" translate="yes" xml:space="preserve">
          <source>Revert is the command to rollback the commits.</source>
          <target state="translated">되돌리기는 커밋을 롤백하는 명령입니다.</target>
        </trans-unit>
        <trans-unit id="c6b4bece923a7536b8b1b2f52de3a298484975dc" translate="yes" xml:space="preserve">
          <source>Revert to &lt;em&gt;most recent&lt;/em&gt; commit and ignoring all local changes:</source>
          <target state="translated">&lt;em&gt;가장 최근의&lt;/em&gt; 커밋으로 되돌리고 모든 로컬 변경 사항을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="e6348ed8b19da88a2dc2a2d4d06140b03041b1fd" translate="yes" xml:space="preserve">
          <source>Reverting The Working Copy to an Older Commit</source>
          <target state="translated">작업 사본을 이전 커밋으로 되돌리기</target>
        </trans-unit>
        <trans-unit id="c31dc90f055c63b6461a162487e4f54af0389983" translate="yes" xml:space="preserve">
          <source>Reverting Working Copy to Most Recent Commit</source>
          <target state="translated">가장 최근의 커밋으로 작업 복사본 되돌리기</target>
        </trans-unit>
        <trans-unit id="068a74558d4325c7d1e5fc758527efac26587586" translate="yes" xml:space="preserve">
          <source>Rogue Coder?</source>
          <target state="translated">도적 코더?</target>
        </trans-unit>
        <trans-unit id="4a01fa35392523364900604a0d0713b788eebb53" translate="yes" xml:space="preserve">
          <source>Run the Git log command with &lt;code&gt;-n 4&lt;/code&gt; from your terminal. The number after the &lt;code&gt;-n&lt;/code&gt; determines the number of commits in the log starting from the most recent commit in your local history.</source>
          <target state="translated">터미널에서 &lt;code&gt;-n 4&lt;/code&gt; 와 함께 Git log 명령을 실행하십시오. &lt;code&gt;-n&lt;/code&gt; 뒤의 숫자는 로컬 히스토리에서 가장 최근의 커밋부터 시작하여 로그의 커밋 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5e60c86f8418a7c1455bb5883bd1d7711db7d549" translate="yes" xml:space="preserve">
          <source>Say you have the following commits in a text file named &lt;code&gt;~/commits-to-revert.txt&lt;/code&gt; (I used &lt;code&gt;git log --pretty=oneline&lt;/code&gt; to get them)</source>
          <target state="translated">&lt;code&gt;~/commits-to-revert.txt&lt;/code&gt; 라는 텍스트 파일에 다음 커밋이 있다고 가정 해보십시오 ( &lt;code&gt;git log --pretty=oneline&lt;/code&gt; 을 사용하여 가져 왔습니다 )</target>
        </trans-unit>
        <trans-unit id="81732aeea4059405eab03949322e5aa6b57b1dfa" translate="yes" xml:space="preserve">
          <source>Select your required commit, and check it by</source>
          <target state="translated">필요한 커밋을 선택하고 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="67cfec235644a14ea2c7c197d4b69761db936191" translate="yes" xml:space="preserve">
          <source>Short description:</source>
          <target state="translated">간단한 설명:</target>
        </trans-unit>
        <trans-unit id="fe04fdc25bd7034b2cf3e1bb748034b199565949" translate="yes" xml:space="preserve">
          <source>Similarly to alternative #1, this reproduces the state of &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; in the current working copy. It is necessary to do &lt;code&gt;git rm&lt;/code&gt; first because &lt;code&gt;git checkout&lt;/code&gt; won't remove files that have been added since &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">대안 # 1과 유사하게 현재 작업 사본의 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 상태를 재현합니다. &lt;code&gt;git checkout&lt;/code&gt; 은 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 이후에 추가 된 파일을 제거하지 않기 때문에 &lt;code&gt;git rm&lt;/code&gt; 을 먼저 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5deb2504bde4f4691c3fbcb5913a32747fdace3a" translate="yes" xml:space="preserve">
          <source>So, no need for commit ids and so on :)</source>
          <target state="translated">따라서 커밋 ID 등이 필요하지 않습니다. :)</target>
        </trans-unit>
        <trans-unit id="6954634df3ee2911f1393b2cdf9d64b6a21f4038" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;http://nakkaya.com/2009/09/24/git-delete-last-commit/&quot;&gt;http://nakkaya.com/2009/09/24/git-delete-last-commit/&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;http://nakkaya.com/2009/09/24/git-delete-last-commit/&quot;&gt;http://nakkaya.com/2009/09/24/git-delete-last-commit/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5800959f85dcc1c548571a3f3a0105891f5b415" translate="yes" xml:space="preserve">
          <source>Temporarily switch to a different commit</source>
          <target state="translated">일시적으로 다른 커밋으로 전환</target>
        </trans-unit>
        <trans-unit id="0f2773d8bddf901d05f958a871f495f7e27fdba5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://schacon.github.com/git/git-revert.html&quot;&gt;&lt;code&gt;git-revert&lt;/code&gt; manpage&lt;/a&gt; actually covers a lot of this in its description. Another useful link is &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging#_undoing_merges&quot;&gt;this git-scm.com section discussing git-revert&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://schacon.github.com/git/git-revert.html&quot;&gt; &lt;code&gt;git-revert&lt;/code&gt; 맨 페이지는&lt;/a&gt; 실제로 설명에서 많은 부분을 다루고 있습니다. 또 다른 유용한 링크는 &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging#_undoing_merges&quot;&gt;이 git-scm.com 섹션으로 git-revert에 대해 설명&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0b78da6e377c9c98a192707a215236eede0cd2bb" translate="yes" xml:space="preserve">
          <source>The best option for me and probably others is the Git reset option:</source>
          <target state="translated">나와 다른 사람들에게 가장 좋은 옵션은 Git 재설정 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="54a5ff1a1b6340200a291fdbc4a740dc59a7559a" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;HEAD&lt;/code&gt; is stored inside &lt;code&gt;.git/HEAD&lt;/code&gt;, and it contains the 40 bytes SHA-1 of the current commit.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 내용은 &lt;code&gt;.git/HEAD&lt;/code&gt; 안에 저장되며 현재 커밋의 40 바이트 SHA-1을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="26523735edbc0fadce77f13b3d4489dc7b54899c" translate="yes" xml:space="preserve">
          <source>The default flag as explained, not need to provide it, does not change the working tree, but it adds all changed files ready to commit, so you go back to the commit status which changes to files get unstaged.</source>
          <target state="translated">설명 된 기본 플래그는 제공 할 필요가 없으며 작업 트리를 변경하지 않지만 커밋 할 준비가 된 모든 변경된 파일을 추가하므로 커밋 상태로 돌아가 파일의 변경 사항이 스테이지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8937a58fd58248066d458a8e3e1faa865c7e84a" translate="yes" xml:space="preserve">
          <source>The key here is forcing the push, no extra commits/commit messages, etc.</source>
          <target state="translated">여기서 핵심은 푸시, 추가 커밋 / 커밋 메시지 등을 강제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9b0929e5129e850ed1b5be9e16b85c31b2892f2" translate="yes" xml:space="preserve">
          <source>The obvious thing if you want to carry on with the state of the project without actually discarding the work since this retrieved commit is to rename your directory again: Delete the project containing the retrieved commit (or give it a temporary name) and rename your &quot;my project - copy&quot; directory back to &quot;my project&quot;. Then maybe try to understand some of the other answers here, and probably do another commit fairly soon.</source>
          <target state="translated">검색된 커밋이 있기 때문에 실제로 작업을 버리지 않고 프로젝트의 상태를 계속 유지하려면 분명한 것은 디렉토리의 이름을 다시 바꾸는 것입니다. 검색된 커밋이 포함 된 프로젝트를 삭제하거나 임시 이름을 지정하십시오. 내 프로젝트- &quot;디렉토리를&quot;내 프로젝트 &quot;로 다시 복사하십시오. 그런 다음 여기에 다른 답변 중 일부를 이해하려고 시도하고 아마도 곧 다른 커밋을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4b50aaa5d7059e59a4807acb3932d2d3b6d7295e" translate="yes" xml:space="preserve">
          <source>Then it will save your changes.</source>
          <target state="translated">그런 다음 변경 사항을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="58b39406130fc132b234d68312b4211c64120db0" translate="yes" xml:space="preserve">
          <source>Then you need to get develop to the status you want, let me assume the commit hash is EFGHIJK:</source>
          <target state="translated">그런 다음 커밋 해시가 EFGHIJK라고 가정하고 원하는 상태로 개발해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea3d908ec7db49d81934603e4f0e6b285b817827" translate="yes" xml:space="preserve">
          <source>There is a command (not a part of core Git, but it is in the &lt;a href=&quot;https://github.com/visionmedia/git-extras&quot;&gt;git-extras&lt;/a&gt; package) specifically for reverting and staging old commits:</source>
          <target state="translated">이전 커밋을 되돌리고 스테이징하기위한 명령 (핵심 Git의 일부는 아니지만 &lt;a href=&quot;https://github.com/visionmedia/git-extras&quot;&gt;git-extras&lt;/a&gt; 패키지에 있음)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="815f16f30f9ba6b824003a15340434622e387031" translate="yes" xml:space="preserve">
          <source>This basically works by using the fact that soft resets will leave the state of the previous commit staged in the index/staging-area, which you can then commit.</source>
          <target state="translated">이것은 기본적으로 소프트 리셋이 이전 커밋 상태를 인덱스 / 스테이징 영역에서 단계적으로 남겨두고 커밋 할 수 있다는 사실을 사용하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="85fd59a0e320797d0e3cfbedfe47292634df1558" translate="yes" xml:space="preserve">
          <source>This depends a lot on what you mean by &quot;revert&quot;.</source>
          <target state="translated">이것은 &quot;되돌아 가다&quot;의 의미에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ae7ed64993835cbe67a58f9f2cd839e739812861" translate="yes" xml:space="preserve">
          <source>This has been the best option for me! It is simple, fast and effective!</source>
          <target state="translated">이것은 나에게 가장 좋은 옵션이었습니다! 간단하고 빠르며 효과적입니다!</target>
        </trans-unit>
        <trans-unit id="0f8803f90afffda4da3bd38d62f19dc63d2a481d" translate="yes" xml:space="preserve">
          <source>This is a &lt;strong&gt;safe and easy way to rollback to a previous state&lt;/strong&gt;. No history is destroyed, so it can be used for commits that have already been made public.</source>
          <target state="translated">이것은 &lt;strong&gt;이전 상태로 롤백&lt;/strong&gt; 하는 &lt;strong&gt;안전하고 쉬운 방법&lt;/strong&gt; 입니다. 기록이 삭제되지 않으므로 이미 공개 된 커밋에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dcd570acd02deab0e0528c3bef08d7781c4101e" translate="yes" xml:space="preserve">
          <source>This is a very slightly modified version of Charles Bailey's solution to &lt;a href=&quot;https://stackoverflow.com/questions/1895059/revert-to-a-commit-by-sha-hash-in-git/1895095#1895095&quot;&gt;Revert to a commit by a SHA hash in Git?&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://stackoverflow.com/questions/1895059/revert-to-a-commit-by-sha-hash-in-git/1895095#1895095&quot;&gt;Git의 SHA 해시로 커밋으로 되 돌리는&lt;/a&gt; Charles Bailey 솔루션의 약간 수정 된 버전 입니까? :</target>
        </trans-unit>
        <trans-unit id="0c675ec8ac6c294e8061252ff39c89b38b305a0c" translate="yes" xml:space="preserve">
          <source>This is an extremely useful command in situations where you committed the wrong thing and you want to undo that last commit.</source>
          <target state="translated">이것은 잘못된 것을 커밋하고 마지막 커밋을 취소하려는 경우에 매우 유용한 명령입니다.</target>
        </trans-unit>
        <trans-unit id="33268d90d137e16d0ff7bdf13883c995cd339665" translate="yes" xml:space="preserve">
          <source>This is how I did it:</source>
          <target state="translated">이것이 내가 한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="89f1f2cd90d517dbecb5870742250306be88f1ee" translate="yes" xml:space="preserve">
          <source>This is one more way to directly reset to a recent commit</source>
          <target state="translated">이것은 최근 커밋으로 직접 재설정하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a638c35d7c8a1baea04fbfbe74917c3a635754fa" translate="yes" xml:space="preserve">
          <source>This reverts everything back to the previous state, including file and directory creations, and deletions, commit it to your branch and you retain the history, but you have it reverted back to the same file structure. Why Git doesn't have a &lt;code&gt;git revert --to &amp;lt;hash&amp;gt;&lt;/code&gt; is beyond me.</source>
          <target state="translated">파일 및 디렉토리 작성 및 삭제를 포함하여 모든 항목을 이전 상태로 되돌리고 분기로 커밋하고 기록을 유지하지만 동일한 파일 구조로 되돌립니다. Git에 &lt;code&gt;git revert --to &amp;lt;hash&amp;gt;&lt;/code&gt; 가없는 이유는 &amp;lt;hash&amp;gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2c32a1b98727e64ca2da1eaa9ddc6a817e68906" translate="yes" xml:space="preserve">
          <source>This schema illustrates which command does what. As you can see there &lt;code&gt;reset &amp;amp;&amp;amp; checkout&lt;/code&gt; modify the &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">이 스키마는 어떤 명령이 무엇을 수행하는지 보여줍니다. 보시다시피 &lt;code&gt;reset &amp;amp;&amp;amp; checkout&lt;/code&gt; &lt;code&gt;HEAD&lt;/code&gt; 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="8a3f409131a6896a9bc560e6025e02d2b5433f7b" translate="yes" xml:space="preserve">
          <source>This solution comes from svick's solution to &lt;a href=&quot;https://stackoverflow.com/questions/3380805/checkout-old-commit-and-make-it-a-new-commit/3382249#3382249&quot;&gt;Checkout old commit and make it a new commit&lt;/a&gt;:</source>
          <target state="translated">이 솔루션은 svick의 솔루션에서 &lt;a href=&quot;https://stackoverflow.com/questions/3380805/checkout-old-commit-and-make-it-a-new-commit/3382249#3382249&quot;&gt;기존 커밋&lt;/a&gt; 을 Checkout하고 새로운 커밋으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="23e15c6d963b17e7997420be2c7d3b3f99d8ef72" translate="yes" xml:space="preserve">
          <source>This will checkout new branch pointing to the desired commit. This command will checkout to a given commit.</source>
          <target state="translated">원하는 커밋을 가리키는 새 분기를 체크 아웃합니다. 이 명령은 주어진 커밋을 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="deecf3786f5adeab0a8d032a5b74b01cb144271d" translate="yes" xml:space="preserve">
          <source>This will get you back to your desired commit</source>
          <target state="translated">원하는 커밋으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="40dbc891e4d9a6e9d189f3487caaedd144c42f8a" translate="yes" xml:space="preserve">
          <source>This will reset all changed files to un-added state.</source>
          <target state="translated">변경된 모든 파일이 추가되지 않은 상태로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a896003d14a51adf413918e0193aff717b25832a" translate="yes" xml:space="preserve">
          <source>This will return the state of the repo under &quot;my project&quot; to what it was when you made that commit (a &quot;commit&quot; means a snapshot of your working files). All commits since then will be lost forever under &quot;my project&quot;, BUT... &lt;strong&gt;they will still be present&lt;/strong&gt; in the repo under &quot;my project - copy&quot; since you copied &lt;em&gt;all&lt;/em&gt; those files - including the ones under .../.git/.</source>
          <target state="translated">이것은 &quot;내 프로젝트&quot;아래의 레포 상태를 커밋 할 때의 상태로 되돌릴 것입니다 ( &quot;커밋&quot;은 작업 파일의 스냅 샷을 의미합니다). 그 이후의 모든 커밋은 &quot;내 프로젝트&quot;에서 영원히 잃어 버릴 것입니다 ...하지만 ... /. git 아래의 파일을 포함하여 &lt;em&gt;모든&lt;/em&gt; 파일을 복사 했으므로 &lt;strong&gt;여전히&lt;/strong&gt; 레포지토리에 &quot;내 프로젝트-복사&quot;아래에 있습니다 /.</target>
        </trans-unit>
        <trans-unit id="d4bd97818967ec523bd6f7b1579640e38609e22e" translate="yes" xml:space="preserve">
          <source>This will revert everything from the HEAD back to the commit hash, meaning it will recreate that commit state in the working tree &lt;em&gt;as if&lt;/em&gt; every commit since had been walked back. You can then commit the current tree, and it will create a brand new commit essentially equivalent to the commit you &quot;reverted&quot; to.</source>
          <target state="translated">이것은 HEAD에서 커밋 해시로 모든 것을 되돌릴 것입니다. 즉, 모든 커밋이 되돌아 간 &lt;em&gt;것처럼&lt;/em&gt; 작업 트리에서 커밋 상태를 다시 만듭니다. 그런 다음 현재 트리를 커밋 할 수 있으며 &quot;revert&quot;한 커밋과 본질적으로 동일한 새로운 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c67e05bcff0f4c1a62d4ecdacccace9fec0a9a55" translate="yes" xml:space="preserve">
          <source>This will revert on the local repository, and here after using &lt;code&gt;git push -f&lt;/code&gt; will update the remote repository.</source>
          <target state="translated">이것은 로컬 리포지토리를 되돌리고 여기서 &lt;code&gt;git push -f&lt;/code&gt; 를 사용한 후 원격 리포지토리를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="5d91c733edd0666eeb1a577ec8aa795bdf80e0be" translate="yes" xml:space="preserve">
          <source>To be clear, these alternatives &lt;strong&gt;&lt;em&gt;are not the best way to revert commits&lt;/em&gt;&lt;/strong&gt;, &lt;a href=&quot;https://stackoverflow.com/a/4114122/456814&quot;&gt;Jefromi's solutions are&lt;/a&gt;, but I just want to point out that you can also use these other methods to achieve the same thing as &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">분명히, 이러한 대안 &lt;strong&gt;&lt;em&gt;은 커밋을 되돌릴 수있는 가장 좋은 방법은 아니지만&lt;/em&gt;&lt;/strong&gt; &lt;a href=&quot;https://stackoverflow.com/a/4114122/456814&quot;&gt;Jefromi의 솔루션은&lt;/a&gt; 있지만 &lt;code&gt;git revert&lt;/code&gt; 와 동일한 것을 달성하기 위해 다른 방법을 사용할 수도 있음을 지적하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="36f8bb30864057728606d69b5633ce52d6920b0e" translate="yes" xml:space="preserve">
          <source>To completely clean a coder's directory up from some accidental changes, we used:</source>
          <target state="translated">우발적 인 변경으로 코더의 디렉토리를 완전히 정리하기 위해 다음을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="a1f640222eec0351f9613d995f9798a710e3b622" translate="yes" xml:space="preserve">
          <source>To go back to where you were, just check out the branch you were on again. (If you've made changes, as always when switching branches, you'll have to deal with them as appropriate. You could reset to throw them away; you could stash, checkout, stash pop to take them with you; you could commit them to a branch there if you want a branch there.)</source>
          <target state="translated">현재 위치로 돌아가려면 다시 있던 지점을 확인하십시오. (분기를 전환 할 때 항상 변경 한 경우 분기를 적절하게 처리해야합니다. 버릴 수 있도록 재설정 할 수 있습니다. 당신이 거기에 지점을 원한다면 거기에 지점에.)</target>
        </trans-unit>
        <trans-unit id="129cac7b2f2308cb06623ae91e17d42a34cd6450" translate="yes" xml:space="preserve">
          <source>To keep the changes from the previous commit to HEAD and move to the previous commit, do:</source>
          <target state="translated">이전 커밋에서 HEAD로 변경 사항을 유지하고 이전 커밋으로 이동하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2cdc5dc8a6118cdbdf6653eb58002f8b4b9643eb" translate="yes" xml:space="preserve">
          <source>To revert to a commit that's older than the most recent commit:</source>
          <target state="translated">가장 최근의 커밋보다 오래된 커밋으로 되돌리려면 :</target>
        </trans-unit>
        <trans-unit id="af05159b40594ed3dd36e91ea67e0ecc5c9b9824" translate="yes" xml:space="preserve">
          <source>To revert to a previous commit, ignoring any changes:</source>
          <target state="translated">변경 사항을 무시하고 이전 커밋으로 되돌리려면</target>
        </trans-unit>
        <trans-unit id="18f27a31c44cf903ff5441d21940a6fca4a36ad5" translate="yes" xml:space="preserve">
          <source>To save yourself much stress, learn from my scars. You have to pretty much have to read a book on Git - I'd recommend &lt;a href=&quot;http://shop.oreilly.com/product/0636920022862.do&quot;&gt;&quot;Version Control with Git&quot;&lt;/a&gt;. Do it sooner rather than later. If you do, bear in mind that much of the complexity of Git comes from branching and then remerging: you can skip those parts in any book. From your question there's &lt;strong&gt;no reason why people should be blinding you with science&lt;/strong&gt;.</source>
          <target state="translated">스트레스를 많이 줄이려면 내 흉터에서 배우십시오. Git에 관한 책을 읽어야 만한다. &lt;a href=&quot;http://shop.oreilly.com/product/0636920022862.do&quot;&gt;&quot;Git을 이용한 버전 관리&quot;를&lt;/a&gt; 추천한다. 나중에보다 빨리하십시오. 그렇게한다면 Git의 복잡한 부분이 분기 된 다음 다시 나온다는 점을 명심해야한다. 어떤 책에서도 그 부분을 건너 뛸 수있다. 당신의 질문에서 &lt;strong&gt;사람들이 과학에 대해 당신을 눈을 멀게하는 이유&lt;/strong&gt; 는 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="60371cbf5e87d6f2002f2a206a806a7e5f91fa95" translate="yes" xml:space="preserve">
          <source>Try resetting to the desired commit -</source>
          <target state="translated">원하는 커밋으로 재설정하십시오-</target>
        </trans-unit>
        <trans-unit id="4ab73cc42152aafd9cdeb94678eddca0f26c65b2" translate="yes" xml:space="preserve">
          <source>Try the above two steps, and if you find this is what you want then &lt;code&gt;git push&lt;/code&gt;.</source>
          <target state="translated">위의 두 단계를 시도하고 이것이 원하는 것이라면 &lt;code&gt;git push&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0fc03dd48af3f60e24d84c9f03e10d33ab29f2" translate="yes" xml:space="preserve">
          <source>Undo published commits with new commits</source>
          <target state="translated">새로운 커밋으로 게시 된 커밋 실행 취소</target>
        </trans-unit>
        <trans-unit id="e357f037417b79c1f53b14e55b45586d58a3a8fc" translate="yes" xml:space="preserve">
          <source>Working on your own and just want it to work? Follow these instructions below, they&amp;rsquo;ve worked reliably for me and many others for years.</source>
          <target state="translated">혼자서 일하고 싶지만 작동하고 싶습니까? 아래의 지침을 따르십시오. 수년간 저와 다른 많은 사람들을 위해 안정적으로 일해 왔습니다.</target>
        </trans-unit>
        <trans-unit id="bfbc1492c175741aec1b19e36c158372c2acb248" translate="yes" xml:space="preserve">
          <source>Working with others? Git is complicated. Read the comments below this answer before you do something rash.</source>
          <target state="translated">다른 사람들과 함께 일하십니까? 힘내는 복잡하다. 발진이 생기기 전에이 답변 아래의 의견을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="6fc5b5d4f9f58f2ada5512e1323131052ffa47d8" translate="yes" xml:space="preserve">
          <source>You can always use the &lt;code&gt;reflog&lt;/code&gt; as well. &lt;code&gt;git reflog&lt;/code&gt; will display any change which updated the &lt;code&gt;HEAD&lt;/code&gt; and checking out the desired reflog entry will set the &lt;code&gt;HEAD&lt;/code&gt; back to this commit.</source>
          <target state="translated">언제든지 &lt;code&gt;reflog&lt;/code&gt; 를 사용할 수 있습니다. &lt;code&gt;git reflog&lt;/code&gt; 는 &lt;code&gt;HEAD&lt;/code&gt; 를 업데이트 한 모든 변경 사항을 표시하며 원하는 reflog 항목을 체크 아웃하면 &lt;code&gt;HEAD&lt;/code&gt; 가이 커밋으로 다시 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c8bcea16c9481768b294a2ff0bb5893fbd2b22" translate="yes" xml:space="preserve">
          <source>You can complete all these initial steps yourself and push back to the Git repository.</source>
          <target state="translated">이러한 모든 초기 단계를 직접 완료하고 Git 리포지토리로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46d4a73bb0c7e90909ecbe27018a35659e540a96" translate="yes" xml:space="preserve">
          <source>You can do this by the following two commands:</source>
          <target state="translated">다음 두 명령으로이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87a7f8aebc0121bb14d36842cc030ba7f7a06899" translate="yes" xml:space="preserve">
          <source>You first need to remove &lt;em&gt;develop&lt;/em&gt; from &lt;em&gt;origin&lt;/em&gt;:</source>
          <target state="translated">먼저 &lt;em&gt;origin&lt;/em&gt; 에서 &lt;em&gt;develop&lt;/em&gt; 을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="585c85b4dfbefb384c267da9a02b846ad39914b9" translate="yes" xml:space="preserve">
          <source>You may also find this answer helpful in this case:</source>
          <target state="translated">이 경우에도이 답변이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d87b94b215284e1aa841827bb6562b76a92a53bb" translate="yes" xml:space="preserve">
          <source>You then have two versions on your system... you can examine or copy or modify files of interest, or whatever, from the previous commit. You can completely discard the files under &quot;my project - copy&quot;, if you have decided the new work since the restored commit was going nowhere...</source>
          <target state="translated">그런 다음 시스템에 두 가지 버전이 있습니다. 이전 커밋에서 관심있는 파일 등을 검사하거나 복사 또는 수정할 수 있습니다. 복원 된 커밋이 아무데도 진행되지 않은 이후에 새 작업을 결정한 경우 &quot;내 프로젝트-복사&quot;에서 파일을 완전히 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f2e318b1935d70cae2d23c7890a20999cf17577" translate="yes" xml:space="preserve">
          <source>and then do &lt;code&gt;git push&lt;/code&gt;</source>
          <target state="translated">그리고 &lt;code&gt;git push&lt;/code&gt; 를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9ce7c8c60b9f299878c97f98c24b38f49d1d7943" translate="yes" xml:space="preserve">
          <source>or &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt; or whatever.</source>
          <target state="translated">또는 &lt;code&gt;git reset --hard HEAD~2&lt;/code&gt; 또는 무엇이든.</target>
        </trans-unit>
        <trans-unit id="b8f6644189516425ecbec15a26511b2a1d063607" translate="yes" xml:space="preserve">
          <source>till you get the required commit. To make the HEAD point to that, do</source>
          <target state="translated">필요한 커밋을 얻을 때까지. HEAD가이를 가리 키도록하려면</target>
        </trans-unit>
        <trans-unit id="47c1a7bde6fea0f98c36d82121612c5d695d52d3" translate="yes" xml:space="preserve">
          <source>where HEAD is the last commit in your current branch</source>
          <target state="translated">HEAD는 현재 지점의 마지막 커밋입니다.</target>
        </trans-unit>
        <trans-unit id="31057de6b748ee9376193a5a0bb4847fa68394d5" translate="yes" xml:space="preserve">
          <source>where HEAD points to the latest commit at you current branch.</source>
          <target state="translated">HEAD는 현재 지점의 최신 커밋을 가리 킵니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
