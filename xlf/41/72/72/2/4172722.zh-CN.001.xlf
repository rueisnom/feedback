<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4172722">
    <body>
      <group id="4172722">
        <trans-unit id="79e24a0626d41444ee958448d5c317e6ee96b2d7" translate="yes" xml:space="preserve">
          <source>(If you are puzzled by the &lt;code&gt;name(name), age(age)&lt;/code&gt; part,
this is called a &lt;a href=&quot;https://stackoverflow.com/questions/1272680/&quot;&gt;member initializer list&lt;/a&gt;.)</source>
          <target state="translated">（如果您对 &lt;code&gt;name(name), age(age)&lt;/code&gt; 部分感到困惑，这称为&lt;a href=&quot;https://stackoverflow.com/questions/1272680/&quot;&gt;成员初始化器列表&lt;/a&gt; 。）</target>
        </trans-unit>
        <trans-unit id="9ee45baa134bd16dcc20742aeef7a5dcc5e7df5f" translate="yes" xml:space="preserve">
          <source>(Note that the forthcoming new version of the C++ standard (which is C++11) adds move semantics to C++, which will likely change the Rule of Three. However, I know too little about this to write a C++11 section about the Rule of Three.)</source>
          <target state="translated">(注意,即将发布的C++标准新版本(也就是C++11)在C++中增加了移动语义,这很可能会改变三条规则。不过,我对这方面的了解太少,所以不可能写一篇C++11中关于 &quot;三原则 &quot;的章节)。)</target>
        </trans-unit>
        <trans-unit id="ac32f8d69a83f86f12590e0408e25faea5115d85" translate="yes" xml:space="preserve">
          <source>(Unfortunately, this &quot;rule&quot; is not enforced by the C++ standard or any compiler I am aware of.)</source>
          <target state="translated">不幸的是,这个 &quot;规则 &quot;并没有被C++标准或我所知道的任何编译器执行)。</target>
        </trans-unit>
        <trans-unit id="399a7f59e9617cfda8eb3917ac2ec614447795d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A consequence of the Rule of Three&lt;/strong&gt; is that the presence of a user-declared destructor indicates that simple member wise copy is unlikely to be appropriate for the copying operations in the class. That, in turn, suggests that if a class declares a destructor, the copy operations probably shouldn&amp;rsquo;t be automatically generated, because they wouldn&amp;rsquo;t do the right thing. At the time C++98 was adopted, the significance of this line of reasoning was not fully appreciated, so in C++98, the existence of a user declared destructor had no impact on compilers&amp;rsquo; willingness to generate copy operations. That continues to be the case in C++11, but only because restricting the conditions under which the copy operations are generated would break too much legacy code.</source>
          <target state="translated">&lt;strong&gt;三规则的结果&lt;/strong&gt;是，用户声明的析构函数的存在表明简单的成员明智的复制不太可能适用于该类中的复制操作。 反过来，这表明如果类声明了析构函数，则复制操作可能不应该自动生成，因为它们不会做正确的事情。 在采用C ++ 98时，这种思路的重要性并未得到充分认识，因此在C ++ 98中，用户声明的析构函数的存在对编译器生成复制操作的意愿没有影响。 在C ++ 11中，情况仍然如此，但这仅是因为限制复制操作的生成条件会破坏太多的旧代码。</target>
        </trans-unit>
        <trans-unit id="0164fa64f12437b3f7154666932df4843f15d77b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Assignment operator and copy constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;赋值运算符和副本构造函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc9c35ab6dcfa7c2dcc49cf50d7fef4989cdbc50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non default destructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;非默认析构函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa9b5621e88a931c947e8c3afe8b1aa2a1130d8e" translate="yes" xml:space="preserve">
          <source>A deep copy is if we declare an object and then create a completely separate copy of the object...we end up with 2 objects in 2 completely sets of memory.</source>
          <target state="translated">深度复制就是如果我们声明一个对象,然后创建一个完全独立的对象的副本...........我们最终会在2个完全独立的内存中拥有2个对象。</target>
        </trans-unit>
        <trans-unit id="8295b736050208f7764a760aab4c1497c80f65b8" translate="yes" xml:space="preserve">
          <source>Advice</source>
          <target state="translated">Advice</target>
        </trans-unit>
        <trans-unit id="31fc773c31823ee138ba7ae357bfa817320368ae" translate="yes" xml:space="preserve">
          <source>After executing the body of the destructor and destroying any automatic objects allocated within the body,
  a destructor for class X calls the destructors for X's direct [...] members
  [n3126.pdf 12.4 &amp;sect;6]</source>
          <target state="translated">在执行析构函数的主体并销毁主体中分配的所有自动对象之后，类X的析构函数调用X的直接成员的析构函数[n3126.pdf 12.4&amp;sect;6]</target>
        </trans-unit>
        <trans-unit id="d381eea5c923562f51eaaeba8f680d94b10e9ebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can inherit from &lt;code&gt;boost::noncopyable&lt;/code&gt; or declare them as deleted (in C++11 and above):</source>
          <target state="translated">另外，您可以继承 &lt;code&gt;boost::noncopyable&lt;/code&gt; 或声明它们已删除（在C ++ 11及更高版本中）：</target>
        </trans-unit>
        <trans-unit id="deb0d50380e6ef75ff89f373543f1a6d844bbf0c" translate="yes" xml:space="preserve">
          <source>An easy example, in plain English, of the kind of problem it solves:</source>
          <target state="translated">一个简单的例子,用通俗易懂的英语来说明它所解决的问题。</target>
        </trans-unit>
        <trans-unit id="c263cc2c82f31396f753d881e9e77d3326c39577" translate="yes" xml:space="preserve">
          <source>An example with the signatures:</source>
          <target state="translated">签名的一个例子。</target>
        </trans-unit>
        <trans-unit id="1ee9a96a64d973ab9e4f1c4205c68f56050f9c6d" translate="yes" xml:space="preserve">
          <source>Basically if you have a destructor (not the default destructor) it means that the class that you defined has some memory allocation. Suppose that the class is used outside by some client code or by you.</source>
          <target state="translated">基本上,如果你有一个destructor(不是默认的destructor),这意味着你定义的类有一些内存分配。假设这个类被一些客户端的代码或你自己在外面使用。</target>
        </trans-unit>
        <trans-unit id="040aea26272cfb1d12bf7b28729c9a1bc9a8c003" translate="yes" xml:space="preserve">
          <source>By default, copying an object means copying its members:</source>
          <target state="translated">默认情况下,复制一个对象意味着复制其成员。</target>
        </trans-unit>
        <trans-unit id="261439050af4def416458064b12196626103581a" translate="yes" xml:space="preserve">
          <source>C++ treats variables of user-defined types with &lt;em&gt;value semantics&lt;/em&gt;.
This means that objects are implicitly copied in various contexts,
and we should understand what &quot;copying an object&quot; actually means.</source>
          <target state="translated">C ++使用&lt;em&gt;值语义&lt;/em&gt;处理用户定义类型的变量。 这意味着在各种上下文中隐式复制对象，我们应该了解&amp;ldquo;复制对象&amp;rdquo;的实际含义。</target>
        </trans-unit>
        <trans-unit id="968d5d2027df3519a8f0d765e5be5ddda1fb83f5" translate="yes" xml:space="preserve">
          <source>Changes via &lt;code&gt;a&lt;/code&gt; can be observed via &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">通过 &lt;code&gt;b&lt;/code&gt; 可以观察到a的变化 。</target>
        </trans-unit>
        <trans-unit id="9403b9333150f696ac7a722596c3db118a3e4748" translate="yes" xml:space="preserve">
          <source>Copy assignment operator is a special assignment operator that is usually used to specify an existing object to others of the same type of object.</source>
          <target state="translated">复制赋值运算符是一种特殊的赋值运算符,通常用来指定一个已有的对象给其他同类型的对象。</target>
        </trans-unit>
        <trans-unit id="e18cc1bf79ff7f3976543961cb3b485844532b76" translate="yes" xml:space="preserve">
          <source>Copy constructor  in C++ is a special constructor. It is used to build a new object, which is the new object equivalent to a copy of an existing object.</source>
          <target state="translated">C++中的Copy构造函数是一个特殊的构造函数。它用于构建一个新对象,也就是新对象相当于现有对象的复制。</target>
        </trans-unit>
        <trans-unit id="facd05cb3a58650993fff6a1db85255e3b0a94e4" translate="yes" xml:space="preserve">
          <source>Declare copy constructor &amp;amp; copy assignment operator as private access specifier.</source>
          <target state="translated">声明复制构造函数和复制赋值运算符作为私有访问说明符。</target>
        </trans-unit>
        <trans-unit id="c812d5bab43eaee8b4dccb2342f4c954b3622299" translate="yes" xml:space="preserve">
          <source>Even today, people still write classes in this style and get into trouble:
&quot;&lt;em&gt;I pushed a person into a vector and now I get crazy memory errors!&lt;/em&gt;&quot;
Remember that by default, copying an object means copying its members,
but copying the &lt;code&gt;name&lt;/code&gt; member merely copies a pointer, &lt;em&gt;not&lt;/em&gt; the character array it points to!
This has several unpleasant effects:</source>
          <target state="translated">即使在今天，人们仍然以这种风格编写类并遇到麻烦：&amp;ldquo; &lt;em&gt;我将一个人推到向量中，现在我出现了疯狂的内存错误！&lt;/em&gt; &amp;rdquo;请记住，默认情况下，复制对象意味着复制其成员，但复制 &lt;code&gt;name&lt;/code&gt; 成员仅复制一个指针， &lt;em&gt;而不&lt;/em&gt;复制它指向的字符数组！ 这有几个令人不愉快的影响：</target>
        </trans-unit>
        <trans-unit id="80d5280e70d86ad891f2b40c8ed78d7da520c6d7" translate="yes" xml:space="preserve">
          <source>Exception safety</source>
          <target state="translated">例外安全</target>
        </trans-unit>
        <trans-unit id="fd290e2e68fb87d2b14ea759aa77e5a733ae350e" translate="yes" xml:space="preserve">
          <source>Explicit definitions</source>
          <target state="translated">明确的定义</target>
        </trans-unit>
        <trans-unit id="4a0cfddf1fb85246d456bc7d093602f37388897b" translate="yes" xml:space="preserve">
          <source>From C++11 on, an object has 2 extra special member functions: the move constructor and move assignment. The rule of five states to implement these functions as well.</source>
          <target state="translated">从C++11开始,一个对象有两个额外的特殊成员函数:移动构造函数和移动赋值。五种状态的规则来实现这些函数。</target>
        </trans-unit>
        <trans-unit id="833fe2498329a54d020e1de8e8b856d36c3fff90" translate="yes" xml:space="preserve">
          <source>How can I prevent my objects from being copied?</source>
          <target state="translated">如何防止我的对象被复制?</target>
        </trans-unit>
        <trans-unit id="e2990e958e6115da8fdfe33d77595387d730ae6a" translate="yes" xml:space="preserve">
          <source>How can I prevent my objects from being copied?
Override all of the ways you're allowed to allocate memory for your object with a private function is a reasonable start.  If you really don't want people copying them, you could make it public and alert the programmer by throwing an exception and also not copying the object.</source>
          <target state="translated">如何防止我的对象被复制?用一个私有函数覆盖所有允许你为对象分配内存的方式是一个合理的开始。如果你真的不希望别人复制,你可以把它公开化,通过抛出一个例外来提醒程序员,同时也可以不复制对象。</target>
        </trans-unit>
        <trans-unit id="2fffc80b2aed30ab6e2c6f37124564640bebd4f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is destroyed, deleting the dangling pointer yields &lt;a href=&quot;https://stackoverflow.com/questions/2397984/&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 被销毁，则删除悬空指针会产生&lt;a href=&quot;https://stackoverflow.com/questions/2397984/&quot;&gt;未定义的行为&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccc869f09575dbb7deb05212e2e5cf80ad65c178" translate="yes" xml:space="preserve">
          <source>If MyClass has only some primitive typed members a default assignment operator would work but if it has some pointer members and objects that do not have assignment operators the result would be unpredictable. Therefore we can say that if there is something to delete in destructor of a class, we might need a deep copy operator which means we should provide a copy constructor and assignment operator.</source>
          <target state="translated">如果MyClass只有一些基元类型的成员,那么默认的赋值操作符就可以工作,但是如果它有一些指针成员和没有赋值操作符的对象,那么结果就很难预料了。因此,我们可以说,如果在类的destructor里有东西要删除,我们可能需要一个深度复制操作符,这意味着我们应该提供一个复制构造函数和赋值操作符。</target>
        </trans-unit>
        <trans-unit id="a63bf0c27bf9d5b347645c1eb049794e6c9e0a96" translate="yes" xml:space="preserve">
          <source>If there is no good semantic for copying the resource your class manages, then consider to forbid copying by declaring (not &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632&quot;&gt;defining&lt;/a&gt;&lt;/em&gt;) the copy constructor and assignment operator as &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">如果没有很好的语义来复制类管理的资源，请考虑通过将复制构造函数和赋值运算符声明为 &lt;code&gt;private&lt;/code&gt; 来禁止复制。</target>
        </trans-unit>
        <trans-unit id="51f6e5ade40c3c9a4a68b72fe61c5e91886c7550" translate="yes" xml:space="preserve">
          <source>If you need to explicitly declare either the destructor,
  copy constructor or copy assignment operator yourself,
  you probably need to explicitly declare all three of them.</source>
          <target state="translated">如果你需要自己明文声明destructor、copy构造函数或copy assignment操作符,那么你可能需要明文声明这三者中的任何一个。</target>
        </trans-unit>
        <trans-unit id="09a94708e1b97a605d19d58a5c49654584da2872" translate="yes" xml:space="preserve">
          <source>If your class needs any of</source>
          <target state="translated">如果你的班级需要以下任何一项</target>
        </trans-unit>
        <trans-unit id="75ff4574c03c6ae385a5c3f20e0b16c05d00ac94" translate="yes" xml:space="preserve">
          <source>Implicit definitions</source>
          <target state="translated">隐含的定义</target>
        </trans-unit>
        <trans-unit id="b155dc653289592b1f4a60114ae84c23564cbcf9" translate="yes" xml:space="preserve">
          <source>In C++11 onwards you can also declare copy constructor &amp;amp; assignment operator deleted</source>
          <target state="translated">从C ++ 11开始，您还可以声明复制构造函数和赋值运算符已删除</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="378aea80c897817c0d000fbb012307be514db260" translate="yes" xml:space="preserve">
          <source>Let us consider a simple example:</source>
          <target state="translated">让我们考虑一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="a417ad7382c5d845e673d6f81d037730bd016e3d" translate="yes" xml:space="preserve">
          <source>Let us go back in time to pre-standard C++.
There was no such thing as &lt;code&gt;std::string&lt;/code&gt;, and programmers were in love with pointers.
The &lt;code&gt;person&lt;/code&gt; class might have looked like this:</source>
          <target state="translated">让我们回到过去的标准C ++。 没有 &lt;code&gt;std::string&lt;/code&gt; 这样的东西，并且程序员爱上了指针。 &lt;code&gt;person&lt;/code&gt; 类可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="bce1a863e79c7b9dc13ce487b7372b22bac1853c" translate="yes" xml:space="preserve">
          <source>Managing resources</source>
          <target state="translated">资源管理</target>
        </trans-unit>
        <trans-unit id="e76b391e984b0c691e529b288ad536b252afc7b3" translate="yes" xml:space="preserve">
          <source>Many of the existing answers already touch the copy constructor, assignment operator and destructor.
However, in post C++11, the introduction of move semantic may expand this beyond 3.</source>
          <target state="translated">现有的很多答案已经触及到了copy构造函数、赋值操作符和destructor。但是,在C++11之后,移动语义的引入,可能会把这个扩展到3之外。</target>
        </trans-unit>
        <trans-unit id="0819198a9da4fb2e67a093cb535fb845ff8654d0" translate="yes" xml:space="preserve">
          <source>Memberwise copying is exactly what we want in this case:
&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; are copied, so we get a self-contained, independent &lt;code&gt;person&lt;/code&gt; object.
The implicitly-defined destructor is always empty.
This is also fine in this case since we did not acquire any resources in the constructor.
The members' destructors are implicitly called after the &lt;code&gt;person&lt;/code&gt; destructor is finished:</source>
          <target state="translated">在这种情况下，按成员复制正是我们想要的：复制 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;age&lt;/code&gt; ，因此我们得到了一个独立的，独立的 &lt;code&gt;person&lt;/code&gt; 对象。 隐式定义的析构函数始终为空。 在这种情况下也可以，因为我们没有在构造函数中获取任何资源。 在 &lt;code&gt;person&lt;/code&gt; 析构函数完成之后，将隐式调用成员的析构函数：</target>
        </trans-unit>
        <trans-unit id="0dd92645d263aa57f332c39c57b04a0c6ff5a10e" translate="yes" xml:space="preserve">
          <source>Most of the time, you do not need to manage a resource yourself,
because an existing class such as &lt;code&gt;std::string&lt;/code&gt; already does it for you.
Just compare the simple code using a &lt;code&gt;std::string&lt;/code&gt; member
to the convoluted and error-prone alternative using a &lt;code&gt;char*&lt;/code&gt; and you should be convinced.
As long as you stay away from raw pointer members, the rule of three is unlikely to concern your own code.</source>
          <target state="translated">大多数时候，您不需要自己管理资源，因为诸如 &lt;code&gt;std::string&lt;/code&gt; 类的现有类已经为您完成了。 只需将使用 &lt;code&gt;std::string&lt;/code&gt; 成员的简单代码与使用 &lt;code&gt;char*&lt;/code&gt; 进行卷积且容易出错的替代方法进行比较，您应该被说服。 只要您远离原始指针成员，三个规则就不太可能涉及您自己的代码。</target>
        </trans-unit>
        <trans-unit id="dd0558423f6422a29a6d0332c36f63c59c7f95f8" translate="yes" xml:space="preserve">
          <source>Noncopyable resources</source>
          <target state="translated">不可复制的资源</target>
        </trans-unit>
        <trans-unit id="4be5e1e184cee713a06eb304202691ba706e11be" translate="yes" xml:space="preserve">
          <source>Note the difference between initialization and assignment:
we must tear down the old state before assigning to &lt;code&gt;name&lt;/code&gt; to prevent memory leaks.
Also, we have to protect against self-assignment of the form &lt;code&gt;x = x&lt;/code&gt;.
Without that check, &lt;code&gt;delete[] name&lt;/code&gt; would delete the array containing the &lt;em&gt;source&lt;/em&gt; string,
because when you write &lt;code&gt;x = x&lt;/code&gt;, both &lt;code&gt;this-&amp;gt;name&lt;/code&gt; and &lt;code&gt;that.name&lt;/code&gt; contain the same pointer.</source>
          <target state="translated">注意初始化和赋值之间的区别：我们必须在分配给 &lt;code&gt;name&lt;/code&gt; 之前拆除旧状态，以防止内存泄漏。 同样，我们必须防止 &lt;code&gt;x = x&lt;/code&gt; 形式的自赋值。 如果没有该检查， &lt;code&gt;delete[] name&lt;/code&gt; 将删除包含&lt;em&gt;源&lt;/em&gt;字符串的数组，因为当您编写 &lt;code&gt;x = x&lt;/code&gt; ， &lt;code&gt;this-&amp;gt;name&lt;/code&gt; 和 &lt;code&gt;that.name&lt;/code&gt; 都包含相同的指针。</target>
        </trans-unit>
        <trans-unit id="73057aa0d94caeff72d3f954441205d18a0c5e92" translate="yes" xml:space="preserve">
          <source>Now let's do something strange.  Let's say car2 is either programmed wrong or purposely meant to share the actual memory that car1 is made of.  (It's usually a mistake to do this and in classes is usually the blanket it's discussed under.)  Pretend that anytime you ask about car2, you're really resolving a pointer to car1's memory space...that's more or less what a shallow copy is.</source>
          <target state="translated">现在我们来做一个奇怪的事情。假设car2不是编程错了,就是故意把car1的实际内存与car1共享。(这样做通常是错误的,在课堂上通常都是在这种情况下讨论的空穴来风)。假设每次问到car2的时候,你真的是在解析一个指向car1的内存空间的指针...........这差不多就是浅层次的复制。</target>
        </trans-unit>
        <trans-unit id="fc62f4b9642ccc8d14eccf688ad938a553acfa03" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;b&lt;/code&gt; is destroyed, &lt;code&gt;a.name&lt;/code&gt; is a dangling pointer.</source>
          <target state="translated">一旦 &lt;code&gt;b&lt;/code&gt; 被销毁， &lt;code&gt;a.name&lt;/code&gt; 是一个悬空指针。</target>
        </trans-unit>
        <trans-unit id="943852bcdc471f99d2175602717c3e90a8e2be92" translate="yes" xml:space="preserve">
          <source>Once, one of these deletes the memory in its destructor, the other will have a pointer to invalid memory (this is called a dangling pointer) when it tries to use it things are going to get hairy.</source>
          <target state="translated">一旦,其中一个删除了它的解构器中的内存,另一个就会有一个指向无效内存的指针(这叫做悬空指针),当它试图使用它的时候,事情就会变得很麻烦。</target>
        </trans-unit>
        <trans-unit id="8d49c0a90a74b9bd99cd612e86d765b341ed4fa3" translate="yes" xml:space="preserve">
          <source>Recently Michael Claisse gave a talk that touches this topic:
&lt;a href=&quot;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&quot;&gt;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&lt;/a&gt;</source>
          <target state="translated">最近，迈克尔&amp;middot;克莱斯（Michael Claisse）发表了涉及该主题的演讲： &lt;a href=&quot;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&quot;&gt;http&lt;/a&gt; ://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class</target>
        </trans-unit>
        <trans-unit id="4e23ca9e46e33f48cc5cf353d5d00a2dd2ffdf4d" translate="yes" xml:space="preserve">
          <source>Rule of three in C++ is a fundamental principle of the design and the development of three requirements that if there is clear definition in one of the following member function, then the programmer should define the other two members functions together. Namely the following three member functions are indispensable: destructor, copy constructor, copy assignment operator.</source>
          <target state="translated">在C++中,三条规则是设计和开发中的一个基本原则,即如果在下面的成员函数中,有一个成员函数有明确的定义,那么程序员就应该把另外两个成员函数一起定义。即以下三个成员函数缺一不可:destructor、copy构造函数、copy赋值操作符。</target>
        </trans-unit>
        <trans-unit id="211147411bb0b9fe8452e926d2a21b6c29d0375b" translate="yes" xml:space="preserve">
          <source>Since memberwise copying does not have the desired effect, we must define the copy constructor and the copy assignment operator explicitly to make deep copies of the character array:</source>
          <target state="translated">由于成员式复制并没有达到预期的效果,所以我们必须明确定义复制构造函数和复制赋值操作符来对字符数组进行深度复制。</target>
        </trans-unit>
        <trans-unit id="360428a6299c49410f566d35610ff9a59032ced5" translate="yes" xml:space="preserve">
          <source>Since the assignment does not take into account what &lt;code&gt;name&lt;/code&gt; pointed to before the assignment,
sooner or later you will get memory leaks all over the place.</source>
          <target state="translated">由于分配没有考虑分配前所指的 &lt;code&gt;name&lt;/code&gt; ，因此迟早您会在各处发现内存泄漏。</target>
        </trans-unit>
        <trans-unit id="7e6450c00de2897fd30725717505cfce2ddcba24" translate="yes" xml:space="preserve">
          <source>Since we declared neither the copy constructor nor the assignment operator (nor the destructor) ourselves,
these are implicitly defined for us. Quote from the standard:</source>
          <target state="translated">由于我们自己声明了copy构造函数和赋值操作符(也没有destructor),所以这些都是隐含地为我们定义的。引用标准中的说法。</target>
        </trans-unit>
        <trans-unit id="b553fbe0594d46cb1cf45f1cf21cb873033e693b" translate="yes" xml:space="preserve">
          <source>Since we're in an object-oriented language (or at least are assuming so), let's say you have a piece of memory allocated.  Since it's an OO-language, we can easily refer to chunks of memory we allocate because they are usually primitive variables (ints, chars, bytes) or classes we defined that are made of our own types and primitives.  So let's say we have a class of Car as follows:</source>
          <target state="translated">既然我们是在面向对象语言中(或者至少是假设是这样),假设你有一块内存被分配了。因为是面向对象语言,所以我们可以很容易地引用我们分配的内存大块,因为它们通常都是我们定义的基元变量(ints、chars、bytes)或者是我们定义的类,这些类是由我们自己的类型和基元组成的。所以,我们假设我们有一个类Car,如下图所示。</target>
        </trans-unit>
        <trans-unit id="432d13bb72859614ef983d24eb754ab62db05256" translate="yes" xml:space="preserve">
          <source>So regardless of what language you're writing in, be very careful about what you mean when it comes to copying objects because most of the time you want a deep copy.</source>
          <target state="translated">所以不管你用什么语言写作,在临摹对象的时候一定要非常小心,因为大多数时候你要的是深度临摹。</target>
        </trans-unit>
        <trans-unit id="e333bc494c02ee48487436daa4334ea20e29487b" translate="yes" xml:space="preserve">
          <source>So when should we declare those special member functions explicitly?
When our class &lt;em&gt;manages a resource&lt;/em&gt;, that is,
when an object of the class is &lt;em&gt;responsible&lt;/em&gt; for that resource.
That usually means the resource is &lt;em&gt;acquired&lt;/em&gt; in the constructor
(or passed into the constructor) and &lt;em&gt;released&lt;/em&gt; in the destructor.</source>
          <target state="translated">那么什么时候应该明确声明那些特殊的成员函数呢？ 当我们的班级&lt;em&gt;管理资源时&lt;/em&gt; ，也就是说，当班级的对象&lt;em&gt;负责&lt;/em&gt;该资源时。 这通常意味着资源是在构造函数中&lt;em&gt;获取&lt;/em&gt;的（或传递到构造函数中）并在析构函数中&lt;em&gt;释放&lt;/em&gt;的。</target>
        </trans-unit>
        <trans-unit id="7c453391545cb5f2f1a89762b41a0bf392d97e58" translate="yes" xml:space="preserve">
          <source>Some resources cannot or should not be copied, such as file handles or mutexes.
In that case, simply declare the copy constructor and copy assignment operator as &lt;code&gt;private&lt;/code&gt; without giving a definition:</source>
          <target state="translated">某些资源不能或不应被复制，例如文件句柄或互斥体。 在这种情况下，只需将复制构造函数和复制赋值运算符声明为 &lt;code&gt;private&lt;/code&gt; 而不给出定义：</target>
        </trans-unit>
        <trans-unit id="20e5e60c500a267d3e35b24f8a5cc1ea1cc105ce" translate="yes" xml:space="preserve">
          <source>Sometimes you need to implement a class that manages a resource.
(Never manage multiple resources in a single class,
this will only lead to pain.)
In that case, remember the &lt;strong&gt;rule of three&lt;/strong&gt;:</source>
          <target state="translated">有时您需要实现一个管理资源的类。 （永远不要在一个类中管理多个资源，这只会导致痛苦。）在这种情况下，请记住以下&lt;strong&gt;三个规则&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">特别成员的职能</target>
        </trans-unit>
        <trans-unit id="aec0b15e6e51aa2d57ebbad90284afce08e7d2a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29&quot;&gt;Rule of Three&lt;/a&gt; is a rule of thumb for C++, basically saying</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29&quot;&gt;三个&lt;/a&gt;规则是C ++的经验法则，基本上说</target>
        </trans-unit>
        <trans-unit id="6f11c9f21f514f7ee41c87b1f2bafc24e2635390" translate="yes" xml:space="preserve">
          <source>The Rule of Three states that if you declare any of a</source>
          <target state="translated">&quot;三原则 &quot;规定,如果你申报的任何一项是</target>
        </trans-unit>
        <trans-unit id="1dc26c6289bab93223f65317189061f65e87b723" translate="yes" xml:space="preserve">
          <source>The [...] copy constructor and copy assignment operator, [...] and destructor are special member functions.
  [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;The implementation will implicitly declare these member functions
  for some class types when the program does not explicitly declare them.&lt;/strong&gt;
  The implementation will implicitly define them if they are used. [...] &lt;em&gt;end note&lt;/em&gt; ]
  [n3126.pdf section 12 &amp;sect;1]</source>
          <target state="translated">复制构造函数和复制赋值运算符，析构函数是特殊的成员函数。 [ &lt;em&gt;注意&lt;/em&gt; ： &lt;strong&gt;当程序未明确声明它们时，实现将为某些类类型隐式声明这些成员函数。&lt;/strong&gt; 如果使用它们，实现将隐式定义它们。 [... &lt;em&gt;尾注&lt;/em&gt; ] [n3126.pdf第12节&amp;sect;1]</target>
        </trans-unit>
        <trans-unit id="b5768ebb789ad0414cec44ca827a0cff6a0eddbc" translate="yes" xml:space="preserve">
          <source>The implicitly-defined copy assignment operator for a non-union class X performs memberwise copy assignment
  of its subobjects.
  [n3126.pdf section 12.8 &amp;sect;30]</source>
          <target state="translated">非联合类X的隐式定义的副本分配运算符执行其子对象的成员式副本分配。 [n3126.pdf第12.8&amp;sect;30节]</target>
        </trans-unit>
        <trans-unit id="156ecf78fca8d8fec636ef6004c3ff179d90628f" translate="yes" xml:space="preserve">
          <source>The implicitly-defined copy constructor for a non-union class X performs a memberwise copy of its subobjects.
  [n3126.pdf section 12.8 &amp;sect;16]</source>
          <target state="translated">非联合类X的隐式定义的副本构造函数执行其子对象的成员式副本。 [n3126.pdf第12.8&amp;sect;16节]</target>
        </trans-unit>
        <trans-unit id="8a6fcda93390d8731cd9984e256fc2aebb8eff80" translate="yes" xml:space="preserve">
          <source>The implicitly-defined special member functions for &lt;code&gt;person&lt;/code&gt; look like this:</source>
          <target state="translated">为 &lt;code&gt;person&lt;/code&gt; 隐式定义的特殊成员函数如下所示：</target>
        </trans-unit>
        <trans-unit id="a650b709af18f4d7fbd3e2ed31b0e773370b2363" translate="yes" xml:space="preserve">
          <source>The law of the big three is as specified above.</source>
          <target state="translated">三大法则如上规定。</target>
        </trans-unit>
        <trans-unit id="d185dd0e04b218850ba08102a2a62761a1f136a6" translate="yes" xml:space="preserve">
          <source>The problem will be, if a copy is made of your object, then the copy will point to the same memory as the original object.</source>
          <target state="translated">问题是,如果对你的对象进行了复制,那么副本将指向与原对象相同的内存。</target>
        </trans-unit>
        <trans-unit id="eb497d383301a549cbb9c1d89b7ae37163e627ab" translate="yes" xml:space="preserve">
          <source>The reasons for this is that all three of them are usually used to manage a resource, and if your class manages a resource, it usually needs to manage copying as well as freeing.</source>
          <target state="translated">原因是这三者通常都是用来管理一个资源的,如果你的类管理一个资源,通常需要管理复制的同时,也需要管理释放的资源。</target>
        </trans-unit>
        <trans-unit id="1e6aaca63062ac28b69db5d58ca82abc5b67162c" translate="yes" xml:space="preserve">
          <source>The rule of 3/5 is also referred to as the rule of 0/3/5. The zero part of the rule states that you are allowed to not write any of the special member functions when creating your class.</source>
          <target state="translated">35规则也被称为035规则。该规则的0部分规定,在创建类时,允许你不写任何特殊成员函数。</target>
        </trans-unit>
        <trans-unit id="5fc3cdb89901e2470465908ef90cc89de3c36d0c" translate="yes" xml:space="preserve">
          <source>The rule of five</source>
          <target state="translated">五常法则</target>
        </trans-unit>
        <trans-unit id="a855a1fba9a32d8f71b9622855bf798047f92314" translate="yes" xml:space="preserve">
          <source>The rule of three</source>
          <target state="translated">三分法则</target>
        </trans-unit>
        <trans-unit id="36c8d8c036bb8fe797cb958ace9878b1d9f0a216" translate="yes" xml:space="preserve">
          <source>The rule of zero</source>
          <target state="translated">零点法则</target>
        </trans-unit>
        <trans-unit id="a903fdf03fcab0513e11024031b16c3545e6f802" translate="yes" xml:space="preserve">
          <source>There are quick examples:</source>
          <target state="translated">有快速的例子。</target>
        </trans-unit>
        <trans-unit id="3cd542f7977cffdfdc31953ce90697e0b2617148" translate="yes" xml:space="preserve">
          <source>Therefore, you write a copy constructor so that it allocates new objects their own pieces of memory to destroy.</source>
          <target state="translated">因此,你写一个复制构造函数,让它分配给新对象自己的内存块来销毁。</target>
        </trans-unit>
        <trans-unit id="f8798170a9a6651fb0a4c954205b28e6e3af390f" translate="yes" xml:space="preserve">
          <source>This also takes care of self-assignment without an explicit check.
An even more robust solution to this problem is the &lt;a href=&quot;https://stackoverflow.com/questions/3279543/&quot;&gt;copy-and-swap idiom&lt;/a&gt;,
but I will not go into the details of exception safety here.
I only mentioned exceptions to make the following point: &lt;strong&gt;Writing classes that manage resources is hard.&lt;/strong&gt;</source>
          <target state="translated">这也可以在没有明确检查的情况下进行自我分配。 解决此问题的一个更强大的解决方案是&amp;ldquo; &lt;a href=&quot;https://stackoverflow.com/questions/3279543/&quot;&gt;复制和交换&amp;rdquo;习惯用法&lt;/a&gt; ，但是在此我将不讨论异常安全性的详细信息。 我只提到了例外，以说明以下几点： &lt;strong&gt;编写用于管理资源的类很困难。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27b40563b27907a9f057f675f3f37fd6000ad1ac" translate="yes" xml:space="preserve">
          <source>This means that the new object and the old object will be pointing at the same piece of memory so when you change it in one object it will be changed for the other objerct too.  If one object deletes this memory the other will carry on trying to use it - eek.</source>
          <target state="translated">这意味着新对象和旧对象将指向同一块内存,所以当你改变一个对象时,另一个对象也会被改变。如果一个对象删除了这个内存,那么另一个对象就会继续尝试使用它-eek.</target>
        </trans-unit>
        <trans-unit id="802dfeceb89576282efc5b61a8af1d0cdbcc4a26" translate="yes" xml:space="preserve">
          <source>To resolve this you write your own version of the copy constructor and assignment operator.  Your versions allocate separate memory to the new objects and copy across the values that the first pointer is pointing to rather than its address.</source>
          <target state="translated">为了解决这个问题,你可以编写自己版本的复制构造函数和赋值操作符。你的版本会给新对象分配单独的内存,并复制第一个指针指向的值而不是它的地址。</target>
        </trans-unit>
        <trans-unit id="6c910658e0d85611554b78b95cba5500416e1e24" translate="yes" xml:space="preserve">
          <source>Unfortunately, this solution will fail if &lt;code&gt;new char[...]&lt;/code&gt; throws an exception due to memory exhaustion.
One possible solution is to introduce a local variable and reorder the statements:</source>
          <target state="translated">不幸的是，如果 &lt;code&gt;new char[...]&lt;/code&gt; 由于内存耗尽而引发异常，则该解决方案将失败。 一种可能的解决方案是引入局部变量并对语句重新排序：</target>
        </trans-unit>
        <trans-unit id="dce3694d3e97fbbf21e3bbef551abea96907eb47" translate="yes" xml:space="preserve">
          <source>What are the &lt;em&gt;copy constructor&lt;/em&gt; and the &lt;em&gt;copy assignment operator&lt;/em&gt;?</source>
          <target state="translated">&lt;em&gt;复制构造函数&lt;/em&gt;和&lt;em&gt;复制赋值运算符是&lt;/em&gt;什么？</target>
        </trans-unit>
        <trans-unit id="d284fc80dc776543cde9d354bdfabe8024285a6b" translate="yes" xml:space="preserve">
          <source>What are the copy constructor and the copy assignment operator?
I have already used them above.  The copy constructor is called when you type code such as &lt;code&gt;Car car2 = car1;&lt;/code&gt;  Essentially if you declare a variable and assign it in one line, that's when the copy constructor is called.  The assignment operator is what happens when you use an equal sign--&lt;code&gt;car2 = car1;&lt;/code&gt;.  Notice &lt;code&gt;car2&lt;/code&gt; isn't declared in the same statement.  The two chunks of code you write for these operations are likely very similar.  In fact the typical design pattern has another function you call to set everything once you're satisfied the initial copy/assignment is legitimate--if you look at the longhand code I wrote, the functions are nearly identical.</source>
          <target state="translated">复制构造函数和复制分配运算符是什么？ 我已经在上面使用了它们。 输入诸如 &lt;code&gt;Car car2 = car1;&lt;/code&gt; 类的代码时，将调用复制构造函数。 本质上，如果您声明一个变量并在一行中分配它，那么这就是复制构造函数被调用的时候。 赋值运算符是当您使用等号时发生的事情 &lt;code&gt;car2 = car1;&lt;/code&gt; 。 注意， &lt;code&gt;car2&lt;/code&gt; 没有在同一语句中声明。 您为这些操作编写的两段代码可能非常相似。 实际上，典型的设计模式还提供了另一个函数，只要您对初始的复制/赋值感到满意，就可以调用它来设置所有内容-如果您查看我编写的长手代码，则这些函数几乎是相同的。</target>
        </trans-unit>
        <trans-unit id="2e18f7284f77f3d90b9ec0f927d31ea3e9dd4931" translate="yes" xml:space="preserve">
          <source>What does &lt;em&gt;copying an object&lt;/em&gt; mean?</source>
          <target state="translated">&lt;em&gt;复制对象&lt;/em&gt;是什么意思？</target>
        </trans-unit>
        <trans-unit id="e314a085c799aa51bc02f6c5e796a58203d1aa5f" translate="yes" xml:space="preserve">
          <source>What does copying an object mean? 
There are a few ways you can copy objects--let's talk about the 2 kinds you're most likely referring to--deep copy and shallow copy.</source>
          <target state="translated">复制对象是什么意思?有几种方法可以复制对象----让我们来谈谈你最可能提到的两种类型--深层复制和浅层复制。</target>
        </trans-unit>
        <trans-unit id="18288f95e467e5d08ac50a74ac3a5f64d0b646f6" translate="yes" xml:space="preserve">
          <source>What does it mean to copy a &lt;code&gt;person&lt;/code&gt; object?
The &lt;code&gt;main&lt;/code&gt; function shows two distinct copying scenarios.
The initialization &lt;code&gt;person b(a);&lt;/code&gt; is performed by the &lt;em&gt;copy constructor&lt;/em&gt;.
Its job is to construct a fresh object based on the state of an existing object.
The assignment &lt;code&gt;b = a&lt;/code&gt; is performed by the &lt;em&gt;copy assignment operator&lt;/em&gt;.
Its job is generally a little more complicated,
because the target object is already in some valid state that needs to be dealt with.</source>
          <target state="translated">复制 &lt;code&gt;person&lt;/code&gt; 对象是什么意思？ &lt;code&gt;main&lt;/code&gt; 功能显示了两种不同的复制方案。 初始化 &lt;code&gt;person b(a);&lt;/code&gt; 由&lt;em&gt;复制构造函数&lt;/em&gt;执行。 它的工作是根据现有对象的状态构造一个新对象。 分配 &lt;code&gt;b = a&lt;/code&gt; 由&lt;em&gt;副本分配运算符执行&lt;/em&gt; 。 它的工作通常要复杂一点，因为目标对象已经处于某种需要处理的有效状态。</target>
        </trans-unit>
        <trans-unit id="525369d9ad8d90cf2e824a3d03f0e647b6245a31" translate="yes" xml:space="preserve">
          <source>What is The Rule of Three</source>
          <target state="translated">什么是 &quot;三原则&quot;?</target>
        </trans-unit>
        <trans-unit id="9326d3d974cf129180db9fb54ae9fe50c11558bc" translate="yes" xml:space="preserve">
          <source>When do I need to declare them myself?</source>
          <target state="translated">我什么时候需要自己申报?</target>
        </trans-unit>
        <trans-unit id="2b4d3c03212efec5704293148396f064cc3fa772" translate="yes" xml:space="preserve">
          <source>When do I need to declare them myself? 
If you are not writing code that is to be shared or for production in some manner, you really only need to declare them when you need them.  You do need to be aware of what your program language does if you choose to use it 'by accident' and didn't make one--i.e. you get the compiler default.  I rarely use copy constructors for instance, but assignment operator overrides are very common.  Did you know you can override what addition, subtraction, etc. mean as well?</source>
          <target state="translated">我什么时候需要自己声明它们?如果你所写的代码不是以某种方式共享或用于生产,那么你只需要在需要的时候声明它们。你确实需要知道你的程序语言是怎么做的,如果你选择使用它是 &quot;偶然 &quot;而没有做一个--也就是说,你会得到编译器的默认值。比如说我很少使用复制构造函数,但是赋值运算符重写是很常见的。你知道你也可以覆盖加法、减法等的含义吗?</target>
        </trans-unit>
        <trans-unit id="b0748a17383e0d0183f82f7af89a83b5c48c0592" translate="yes" xml:space="preserve">
          <source>You allocated memory in your constructor and so you need to write a destructor to delete it.  Otherwise you will cause a memory leak.</source>
          <target state="translated">你在构造函数中分配了内存,所以你需要写一个destructor来删除它。否则你会造成内存泄漏。</target>
        </trans-unit>
        <trans-unit id="f35591d3af737f6da366aa57fe0c8a3cec3ebd05" translate="yes" xml:space="preserve">
          <source>You allocated memory in your constructor to a member pointer of your class.  When you copy an object of this class the default assignment operator and copy constructor will copy the value of this member pointer to the new object.</source>
          <target state="translated">你在构造函数中为类的成员指针分配了内存。当你复制这个类的一个对象时,默认的赋值操作符和copy构造函数将把这个成员指针的值复制到新对象上。</target>
        </trans-unit>
        <trans-unit id="d665236b12b323d034f1a59d0be9b78aa4a45839" translate="yes" xml:space="preserve">
          <source>You might think that this is job done.</source>
          <target state="translated">你可能会认为这就是工作了。</target>
        </trans-unit>
        <trans-unit id="4245c721abbc6eb77fa44f3f4a16ff9787771472" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;copy constructor&lt;/strong&gt;,</source>
          <target state="translated">&lt;strong&gt;复制构造函数&lt;/strong&gt; ，</target>
        </trans-unit>
        <trans-unit id="a251f0e395aad7bbb837ca31dc8c54f763926c32" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;assignment operator&lt;/strong&gt;,</source>
          <target state="translated">&lt;strong&gt;赋值运算符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1af3319531cdc9d080e124c289ad057aefd0cc4c" translate="yes" xml:space="preserve">
          <source>copy assignment operator</source>
          <target state="translated">复制分配器</target>
        </trans-unit>
        <trans-unit id="183ecfccbbd2d4096ad1d48b49c8f24046ebf9c1" translate="yes" xml:space="preserve">
          <source>copy constructor</source>
          <target state="translated">复制构造函数</target>
        </trans-unit>
        <trans-unit id="8bc5b477b47fc9df65f37bbb8cb4a49ff6fe6dec" translate="yes" xml:space="preserve">
          <source>defined explictly, then it is likely to need &lt;strong&gt;all three of them&lt;/strong&gt;.</source>
          <target state="translated">明确定义，则可能需要&lt;strong&gt;全部三个&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="867e8ce6dcd7e9c598e666c812691b0cff661d7c" translate="yes" xml:space="preserve">
          <source>destructor</source>
          <target state="translated">destructor</target>
        </trans-unit>
        <trans-unit id="6813b0bf4b910cdeab71fd38315eaad01f7becab" translate="yes" xml:space="preserve">
          <source>or a &lt;strong&gt;destructor&lt;/strong&gt;,</source>
          <target state="translated">或&lt;strong&gt;破坏者&lt;/strong&gt; ，</target>
        </trans-unit>
        <trans-unit id="63ac133f749caa7f0c542633b2a3bf7831b595d0" translate="yes" xml:space="preserve">
          <source>the class destructor would also be participating in management of the resource (usually releasing it). The classic resource to be managed was memory, and this is why all Standard Library classes that
manage memory (e.g., the STL containers that perform dynamic memory management) all declare &amp;ldquo;the big three&amp;rdquo;: both copy operations and a destructor.</source>
          <target state="translated">类析构函数也将参与资源的管理（通常是释放资源）。 要管理的经典资源是内存，这就是为什么所有管理内存的标准库类（例如，执行动态内存管理的STL容器）都声明&amp;ldquo;三者&amp;rdquo;：复制操作和析构函数。</target>
        </trans-unit>
        <trans-unit id="b6b9dbf4312ced3cbd7237155947344baf0a01a7" translate="yes" xml:space="preserve">
          <source>then you should declare all three. It grew out of the observation that the need to take over the meaning of a copy operation almost always stemmed from the class performing some kind of resource management, and that almost always implied that</source>
          <target state="translated">那么你应该声明这三个都要声明。它是出于这样的观察而产生的,即需要接管复制操作的意义几乎总是来自于类执行某种资源管理,而这几乎总是意味着</target>
        </trans-unit>
        <trans-unit id="7ceae16642af9c2edc08b7ed1a5862ae8d9cf4a9" translate="yes" xml:space="preserve">
          <source>whatever resource management was being done in one copy operation probably needed to be done in the other copy operation and</source>
          <target state="translated">无论在一个副本操作中进行的资源管理,很可能需要在另一个副本操作中进行,并且</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
