<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4172722">
    <body>
      <group id="4172722">
        <trans-unit id="79e24a0626d41444ee958448d5c317e6ee96b2d7" translate="yes" xml:space="preserve">
          <source>(If you are puzzled by the &lt;code&gt;name(name), age(age)&lt;/code&gt; part,
this is called a &lt;a href=&quot;https://stackoverflow.com/questions/1272680/&quot;&gt;member initializer list&lt;/a&gt;.)</source>
          <target state="translated">( &lt;code&gt;name(name), age(age)&lt;/code&gt; 부분에 의아해하는 경우이를 &lt;a href=&quot;https://stackoverflow.com/questions/1272680/&quot;&gt;멤버 이니셜 라이저 목록&lt;/a&gt; 이라고 합니다 .)</target>
        </trans-unit>
        <trans-unit id="9ee45baa134bd16dcc20742aeef7a5dcc5e7df5f" translate="yes" xml:space="preserve">
          <source>(Note that the forthcoming new version of the C++ standard (which is C++11) adds move semantics to C++, which will likely change the Rule of Three. However, I know too little about this to write a C++11 section about the Rule of Three.)</source>
          <target state="translated">(다가오는 C ++ 표준의 새로운 버전 (C ++ 11)은 C ++에 이동 의미를 추가하여 3의 규칙을 변경 할 수 있습니다. 그러나 C ++ 11 섹션을 작성하기에는 이것에 대해 거의 알지 못합니다. 3의 법칙에 대해.)</target>
        </trans-unit>
        <trans-unit id="ac32f8d69a83f86f12590e0408e25faea5115d85" translate="yes" xml:space="preserve">
          <source>(Unfortunately, this &quot;rule&quot; is not enforced by the C++ standard or any compiler I am aware of.)</source>
          <target state="translated">(안타깝게도이 &quot;규칙&quot;은 C ++ 표준 또는 내가 알고있는 컴파일러에 의해 시행되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="399a7f59e9617cfda8eb3917ac2ec614447795d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A consequence of the Rule of Three&lt;/strong&gt; is that the presence of a user-declared destructor indicates that simple member wise copy is unlikely to be appropriate for the copying operations in the class. That, in turn, suggests that if a class declares a destructor, the copy operations probably shouldn&amp;rsquo;t be automatically generated, because they wouldn&amp;rsquo;t do the right thing. At the time C++98 was adopted, the significance of this line of reasoning was not fully appreciated, so in C++98, the existence of a user declared destructor had no impact on compilers&amp;rsquo; willingness to generate copy operations. That continues to be the case in C++11, but only because restricting the conditions under which the copy operations are generated would break too much legacy code.</source>
          <target state="translated">&lt;strong&gt;3의 규칙의 결과는&lt;/strong&gt; 사용자가 선언 한 소멸자가 있다는 것은 간단한 멤버 현명한 사본이 클래스의 복사 작업에 적합하지 않을 것임을 나타냅니다. 즉, 클래스가 소멸자를 선언하면 올바른 작업을 수행하지 않기 때문에 복사 작업이 자동으로 생성되지 않아야합니다. C ++ 98이 채택되었을 때,이 추론의 중요성은 충분히 인식되지 않았으므로 C ++ 98에서는 사용자 선언 소멸자가 존재한다는 것은 복사 작업을 생성하려는 컴파일러의 의지에 영향을 미치지 않았습니다. C ++ 11에서는 계속 그렇습니다. 그러나 복사 작업이 생성되는 조건을 제한하면 너무 많은 레거시 코드가 손상되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0164fa64f12437b3f7154666932df4843f15d77b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Assignment operator and copy constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;할당 연산자 및 복사 생성자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc9c35ab6dcfa7c2dcc49cf50d7fef4989cdbc50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non default destructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본이 아닌 소멸자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa9b5621e88a931c947e8c3afe8b1aa2a1130d8e" translate="yes" xml:space="preserve">
          <source>A deep copy is if we declare an object and then create a completely separate copy of the object...we end up with 2 objects in 2 completely sets of memory.</source>
          <target state="translated">딥 카피는 객체를 선언 한 다음 객체의 완전히 별개의 사본을 생성하는 것입니다. 우리는 2 개의 메모리 세트에 2 개의 객체가 생깁니다.</target>
        </trans-unit>
        <trans-unit id="8295b736050208f7764a760aab4c1497c80f65b8" translate="yes" xml:space="preserve">
          <source>Advice</source>
          <target state="translated">Advice</target>
        </trans-unit>
        <trans-unit id="31fc773c31823ee138ba7ae357bfa817320368ae" translate="yes" xml:space="preserve">
          <source>After executing the body of the destructor and destroying any automatic objects allocated within the body,
  a destructor for class X calls the destructors for X's direct [...] members
  [n3126.pdf 12.4 &amp;sect;6]</source>
          <target state="translated">소멸자의 본문을 실행하고 본문 내에 할당 된 자동 객체를 삭제 한 후, 클래스 X의 소멸자는 X의 직접 [...] 멤버의 소멸자를 호출합니다. [n3126.pdf 12.4 &amp;sect;6]</target>
        </trans-unit>
        <trans-unit id="d381eea5c923562f51eaaeba8f680d94b10e9ebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can inherit from &lt;code&gt;boost::noncopyable&lt;/code&gt; or declare them as deleted (in C++11 and above):</source>
          <target state="translated">또는 &lt;code&gt;boost::noncopyable&lt;/code&gt; 에서 상속하거나 삭제 된 것으로 선언 할 수 있습니다 (C ++ 11 이상에서).</target>
        </trans-unit>
        <trans-unit id="deb0d50380e6ef75ff89f373543f1a6d844bbf0c" translate="yes" xml:space="preserve">
          <source>An easy example, in plain English, of the kind of problem it solves:</source>
          <target state="translated">일반 영어로 해결되는 문제의 쉬운 예 :</target>
        </trans-unit>
        <trans-unit id="c263cc2c82f31396f753d881e9e77d3326c39577" translate="yes" xml:space="preserve">
          <source>An example with the signatures:</source>
          <target state="translated">서명이있는 예 :</target>
        </trans-unit>
        <trans-unit id="1ee9a96a64d973ab9e4f1c4205c68f56050f9c6d" translate="yes" xml:space="preserve">
          <source>Basically if you have a destructor (not the default destructor) it means that the class that you defined has some memory allocation. Suppose that the class is used outside by some client code or by you.</source>
          <target state="translated">기본적으로 소멸자 (기본 소멸자가 아님)가있는 경우 정의한 클래스에 메모리 할당이 있음을 의미합니다. 클래스가 일부 클라이언트 코드 또는 사용자가 외부에서 사용한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="040aea26272cfb1d12bf7b28729c9a1bc9a8c003" translate="yes" xml:space="preserve">
          <source>By default, copying an object means copying its members:</source>
          <target state="translated">기본적으로 객체를 복사한다는 것은 해당 멤버를 복사하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="261439050af4def416458064b12196626103581a" translate="yes" xml:space="preserve">
          <source>C++ treats variables of user-defined types with &lt;em&gt;value semantics&lt;/em&gt;.
This means that objects are implicitly copied in various contexts,
and we should understand what &quot;copying an object&quot; actually means.</source>
          <target state="translated">C ++는 사용자 정의 유형의 변수를 &lt;em&gt;값 의미론으로 처리&lt;/em&gt; 합니다. 이는 객체가 다양한 컨텍스트에서 암시 적으로 복사됨을 의미하며, &quot;객체 복사&quot;가 실제로 무엇을 의미하는지 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="968d5d2027df3519a8f0d765e5be5ddda1fb83f5" translate="yes" xml:space="preserve">
          <source>Changes via &lt;code&gt;a&lt;/code&gt; can be observed via &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 를 통한 변경은 &lt;code&gt;b&lt;/code&gt; 를 통해 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9403b9333150f696ac7a722596c3db118a3e4748" translate="yes" xml:space="preserve">
          <source>Copy assignment operator is a special assignment operator that is usually used to specify an existing object to others of the same type of object.</source>
          <target state="translated">복사 할당 연산자는 일반적으로 기존 객체를 동일한 유형의 객체로 다른 객체에 지정하는 데 사용되는 특수 할당 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="e18cc1bf79ff7f3976543961cb3b485844532b76" translate="yes" xml:space="preserve">
          <source>Copy constructor  in C++ is a special constructor. It is used to build a new object, which is the new object equivalent to a copy of an existing object.</source>
          <target state="translated">C ++의 복사 생성자는 특수 생성자입니다. 기존 객체의 복사본과 동일한 새로운 객체 인 새 객체를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="facd05cb3a58650993fff6a1db85255e3b0a94e4" translate="yes" xml:space="preserve">
          <source>Declare copy constructor &amp;amp; copy assignment operator as private access specifier.</source>
          <target state="translated">복사 생성자 및 복사 할당 연산자를 개인용 액세스 지정자로 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="c812d5bab43eaee8b4dccb2342f4c954b3622299" translate="yes" xml:space="preserve">
          <source>Even today, people still write classes in this style and get into trouble:
&quot;&lt;em&gt;I pushed a person into a vector and now I get crazy memory errors!&lt;/em&gt;&quot;
Remember that by default, copying an object means copying its members,
but copying the &lt;code&gt;name&lt;/code&gt; member merely copies a pointer, &lt;em&gt;not&lt;/em&gt; the character array it points to!
This has several unpleasant effects:</source>
          <target state="translated">오늘날에도 사람들은 여전히이 스타일로 수업을 작성하고 어려움을 겪습니다. &quot; &lt;em&gt;나는 사람을 벡터로 밀어 넣고 이제는 메모리 오류가 발생합니다!&lt;/em&gt; &quot;기본적으로 객체를 복사한다는 것은 멤버를 복사하지만 &lt;code&gt;name&lt;/code&gt; 복사하는 것을 의미합니다. 가리키는 문자 배열이 &lt;em&gt;아닌&lt;/em&gt; 포인터 만 복사합니다! 이것은 몇 가지 불쾌한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d5280e70d86ad891f2b40c8ed78d7da520c6d7" translate="yes" xml:space="preserve">
          <source>Exception safety</source>
          <target state="translated">예외 안전</target>
        </trans-unit>
        <trans-unit id="fd290e2e68fb87d2b14ea759aa77e5a733ae350e" translate="yes" xml:space="preserve">
          <source>Explicit definitions</source>
          <target state="translated">명시 적 정의</target>
        </trans-unit>
        <trans-unit id="4a0cfddf1fb85246d456bc7d093602f37388897b" translate="yes" xml:space="preserve">
          <source>From C++11 on, an object has 2 extra special member functions: the move constructor and move assignment. The rule of five states to implement these functions as well.</source>
          <target state="translated">C ++ 11부터 객체에는 2 개의 추가 특수 멤버 함수 인 이동 생성자와 이동 지정이 있습니다. 이러한 기능을 구현하기위한 5 가지 상태 규칙.</target>
        </trans-unit>
        <trans-unit id="833fe2498329a54d020e1de8e8b856d36c3fff90" translate="yes" xml:space="preserve">
          <source>How can I prevent my objects from being copied?</source>
          <target state="translated">객체가 복사되지 않도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="e2990e958e6115da8fdfe33d77595387d730ae6a" translate="yes" xml:space="preserve">
          <source>How can I prevent my objects from being copied?
Override all of the ways you're allowed to allocate memory for your object with a private function is a reasonable start.  If you really don't want people copying them, you could make it public and alert the programmer by throwing an exception and also not copying the object.</source>
          <target state="translated">객체가 복사되지 않도록하려면 어떻게해야합니까? 개인 기능으로 객체에 메모리를 할당하도록 허용 된 모든 방법을 무시하는 것이 합리적 시작입니다. 사람들이 실제로 복사하는 것을 원하지 않으면 공개를 만들고 예외를 발생시키고 객체를 복사하지 않음으로써 프로그래머에게 경고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fffc80b2aed30ab6e2c6f37124564640bebd4f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is destroyed, deleting the dangling pointer yields &lt;a href=&quot;https://stackoverflow.com/questions/2397984/&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 파괴되면 매달려있는 포인터를 삭제하면 &lt;a href=&quot;https://stackoverflow.com/questions/2397984/&quot;&gt;정의되지 않은 동작이&lt;/a&gt; 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ccc869f09575dbb7deb05212e2e5cf80ad65c178" translate="yes" xml:space="preserve">
          <source>If MyClass has only some primitive typed members a default assignment operator would work but if it has some pointer members and objects that do not have assignment operators the result would be unpredictable. Therefore we can say that if there is something to delete in destructor of a class, we might need a deep copy operator which means we should provide a copy constructor and assignment operator.</source>
          <target state="translated">MyClass에 기본 형식의 멤버가 일부만 있으면 기본 할당 연산자가 작동하지만 할당 연산자가없는 포인터 멤버 및 개체가 있으면 결과를 예측할 수 없습니다. 따라서 클래스의 소멸자에서 삭제할 항목이 있으면 깊은 복사 연산자가 필요할 수 있습니다. 즉 복사 생성자와 할당 연산자를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="a63bf0c27bf9d5b347645c1eb049794e6c9e0a96" translate="yes" xml:space="preserve">
          <source>If there is no good semantic for copying the resource your class manages, then consider to forbid copying by declaring (not &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632&quot;&gt;defining&lt;/a&gt;&lt;/em&gt;) the copy constructor and assignment operator as &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">클래스가 관리하는 리소스를 복사하는 데 의미가 없으면 복사 생성자와 할당 연산자를 &lt;code&gt;private&lt;/code&gt; 로 선언 ( &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632&quot;&gt;정의&lt;/a&gt;&lt;/em&gt; 하지 않음)하여 복사를 금지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="51f6e5ade40c3c9a4a68b72fe61c5e91886c7550" translate="yes" xml:space="preserve">
          <source>If you need to explicitly declare either the destructor,
  copy constructor or copy assignment operator yourself,
  you probably need to explicitly declare all three of them.</source>
          <target state="translated">소멸자, 복사 생성자 또는 복사 할당 연산자를 명시 적으로 선언해야하는 경우 세 가지 모두 명시 적으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="09a94708e1b97a605d19d58a5c49654584da2872" translate="yes" xml:space="preserve">
          <source>If your class needs any of</source>
          <target state="translated">수업이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="75ff4574c03c6ae385a5c3f20e0b16c05d00ac94" translate="yes" xml:space="preserve">
          <source>Implicit definitions</source>
          <target state="translated">암시 적 정의</target>
        </trans-unit>
        <trans-unit id="b155dc653289592b1f4a60114ae84c23564cbcf9" translate="yes" xml:space="preserve">
          <source>In C++11 onwards you can also declare copy constructor &amp;amp; assignment operator deleted</source>
          <target state="translated">C ++ 11 이후에는 복사 생성자 및 할당 연산자가 삭제됨을 선언 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="378aea80c897817c0d000fbb012307be514db260" translate="yes" xml:space="preserve">
          <source>Let us consider a simple example:</source>
          <target state="translated">간단한 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a417ad7382c5d845e673d6f81d037730bd016e3d" translate="yes" xml:space="preserve">
          <source>Let us go back in time to pre-standard C++.
There was no such thing as &lt;code&gt;std::string&lt;/code&gt;, and programmers were in love with pointers.
The &lt;code&gt;person&lt;/code&gt; class might have looked like this:</source>
          <target state="translated">사전 표준 C ++로 시간을 거슬러 갑시다. &lt;code&gt;std::string&lt;/code&gt; 과 같은 것은 없었으며 프로그래머는 포인터를 좋아했습니다. &lt;code&gt;person&lt;/code&gt; 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bce1a863e79c7b9dc13ce487b7372b22bac1853c" translate="yes" xml:space="preserve">
          <source>Managing resources</source>
          <target state="translated">자원 관리</target>
        </trans-unit>
        <trans-unit id="e76b391e984b0c691e529b288ad536b252afc7b3" translate="yes" xml:space="preserve">
          <source>Many of the existing answers already touch the copy constructor, assignment operator and destructor.
However, in post C++11, the introduction of move semantic may expand this beyond 3.</source>
          <target state="translated">기존의 많은 답변이 이미 복사 생성자, 할당 연산자 및 소멸자에 닿았습니다. 그러나 포스트 C ++ 11에서 이동 의미론의 도입은 이것을 3 이상으로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0819198a9da4fb2e67a093cb535fb845ff8654d0" translate="yes" xml:space="preserve">
          <source>Memberwise copying is exactly what we want in this case:
&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; are copied, so we get a self-contained, independent &lt;code&gt;person&lt;/code&gt; object.
The implicitly-defined destructor is always empty.
This is also fine in this case since we did not acquire any resources in the constructor.
The members' destructors are implicitly called after the &lt;code&gt;person&lt;/code&gt; destructor is finished:</source>
          <target state="translated">회원 별 복사는이 경우에 원하는 것입니다. &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; 가 복사되므로 독립적이고 독립적 인 &lt;code&gt;person&lt;/code&gt; 개체를 얻게됩니다. 암시 적으로 정의 된 소멸자는 항상 비어 있습니다. 이 경우에도 생성자에서 리소스를 얻지 못했기 때문에 좋습니다. 구성원 소멸자는 &lt;code&gt;person&lt;/code&gt; 소멸자가 완료된 후에 암시 적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0dd92645d263aa57f332c39c57b04a0c6ff5a10e" translate="yes" xml:space="preserve">
          <source>Most of the time, you do not need to manage a resource yourself,
because an existing class such as &lt;code&gt;std::string&lt;/code&gt; already does it for you.
Just compare the simple code using a &lt;code&gt;std::string&lt;/code&gt; member
to the convoluted and error-prone alternative using a &lt;code&gt;char*&lt;/code&gt; and you should be convinced.
As long as you stay away from raw pointer members, the rule of three is unlikely to concern your own code.</source>
          <target state="translated">&lt;code&gt;std::string&lt;/code&gt; 과 같은 기존 클래스가 이미이를 수행하므로 대부분의 경우 리소스를 직접 관리 할 필요가 없습니다. &lt;code&gt;std::string&lt;/code&gt; 멤버를 사용하는 간단한 코드를 &lt;code&gt;char*&lt;/code&gt; 사용하여 복잡하고 오류가 발생하기 쉬운 대안과 비교하면 확실합니다. 원시 포인터 멤버에서 멀리 떨어져있는 한 세 규칙은 자신의 코드와 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd0558423f6422a29a6d0332c36f63c59c7f95f8" translate="yes" xml:space="preserve">
          <source>Noncopyable resources</source>
          <target state="translated">복사 할 수없는 리소스</target>
        </trans-unit>
        <trans-unit id="4be5e1e184cee713a06eb304202691ba706e11be" translate="yes" xml:space="preserve">
          <source>Note the difference between initialization and assignment:
we must tear down the old state before assigning to &lt;code&gt;name&lt;/code&gt; to prevent memory leaks.
Also, we have to protect against self-assignment of the form &lt;code&gt;x = x&lt;/code&gt;.
Without that check, &lt;code&gt;delete[] name&lt;/code&gt; would delete the array containing the &lt;em&gt;source&lt;/em&gt; string,
because when you write &lt;code&gt;x = x&lt;/code&gt;, both &lt;code&gt;this-&amp;gt;name&lt;/code&gt; and &lt;code&gt;that.name&lt;/code&gt; contain the same pointer.</source>
          <target state="translated">초기화와 할당의 차이점에 유의하십시오. 메모리 누수를 방지하기 위해 &lt;code&gt;name&lt;/code&gt; 에 할당하기 전에 이전 상태를 해제해야합니다. 또한 &lt;code&gt;x = x&lt;/code&gt; 형식의 자체 할당으로부터 보호해야합니다. 이 검사가 없으면 &lt;code&gt;delete[] name&lt;/code&gt; 은 &lt;em&gt;소스&lt;/em&gt; 문자열을 포함하는 배열을 삭제합니다. &lt;code&gt;x = x&lt;/code&gt; 를 쓸 때 &lt;code&gt;this-&amp;gt;name&lt;/code&gt; 과 &lt;code&gt;that.name&lt;/code&gt; 모두 동일한 포인터를 포함하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="73057aa0d94caeff72d3f954441205d18a0c5e92" translate="yes" xml:space="preserve">
          <source>Now let's do something strange.  Let's say car2 is either programmed wrong or purposely meant to share the actual memory that car1 is made of.  (It's usually a mistake to do this and in classes is usually the blanket it's discussed under.)  Pretend that anytime you ask about car2, you're really resolving a pointer to car1's memory space...that's more or less what a shallow copy is.</source>
          <target state="translated">이제 이상한 것을하자. car2가 잘못 프로그래밍되었거나 의도적으로 car1의 실제 메모리를 공유하도록되어 있다고 가정 해 봅시다. (이 작업을 수행하는 것은 일반적으로 실수이며 수업 시간에는 일반적으로 아래에서 논의되는 담요입니다.) car2에 대해 질문 할 때마다 car1의 메모리 공간에 대한 포인터를 실제로 해결하고 있다고 가정하십시오. 입니다.</target>
        </trans-unit>
        <trans-unit id="fc62f4b9642ccc8d14eccf688ad938a553acfa03" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;b&lt;/code&gt; is destroyed, &lt;code&gt;a.name&lt;/code&gt; is a dangling pointer.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 가 파괴되면 &lt;code&gt;a.name&lt;/code&gt; 은 매달려있는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="943852bcdc471f99d2175602717c3e90a8e2be92" translate="yes" xml:space="preserve">
          <source>Once, one of these deletes the memory in its destructor, the other will have a pointer to invalid memory (this is called a dangling pointer) when it tries to use it things are going to get hairy.</source>
          <target state="translated">이 중 하나가 소멸자에서 메모리를 삭제하면 다른 하나는 메모리를 사용하려고 할 때 유효하지 않은 메모리 (이것은 매달려 포인터라고 함)에 대한 포인터를 갖게됩니다.</target>
        </trans-unit>
        <trans-unit id="8d49c0a90a74b9bd99cd612e86d765b341ed4fa3" translate="yes" xml:space="preserve">
          <source>Recently Michael Claisse gave a talk that touches this topic:
&lt;a href=&quot;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&quot;&gt;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&lt;/a&gt;</source>
          <target state="translated">최근 마이클 클라이 스 (Michael Claisse)는이 주제에 관한 강연을했다 : &lt;a href=&quot;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&quot;&gt;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e23ca9e46e33f48cc5cf353d5d00a2dd2ffdf4d" translate="yes" xml:space="preserve">
          <source>Rule of three in C++ is a fundamental principle of the design and the development of three requirements that if there is clear definition in one of the following member function, then the programmer should define the other two members functions together. Namely the following three member functions are indispensable: destructor, copy constructor, copy assignment operator.</source>
          <target state="translated">C ++에서 3의 규칙은 다음 멤버 함수 중 하나에 명확한 정의가있는 경우 프로그래머가 다른 두 멤버 함수를 함께 정의해야하는 세 가지 요구 사항의 설계 및 개발의 기본 원칙입니다. 즉, 소멸자, 복사 생성자, 복사 할당 연산자의 세 가지 멤버 함수는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="211147411bb0b9fe8452e926d2a21b6c29d0375b" translate="yes" xml:space="preserve">
          <source>Since memberwise copying does not have the desired effect, we must define the copy constructor and the copy assignment operator explicitly to make deep copies of the character array:</source>
          <target state="translated">멤버 별 복사는 원하는 효과가 없으므로 문자 배열의 깊은 복사본을 만들려면 복사 생성자와 복사 할당 연산자를 명시 적으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="360428a6299c49410f566d35610ff9a59032ced5" translate="yes" xml:space="preserve">
          <source>Since the assignment does not take into account what &lt;code&gt;name&lt;/code&gt; pointed to before the assignment,
sooner or later you will get memory leaks all over the place.</source>
          <target state="translated">배정은 배정 이전에 어떤 &lt;code&gt;name&lt;/code&gt; 가리키는 지 고려하지 않기 때문에 조만간 메모리 누수가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e6450c00de2897fd30725717505cfce2ddcba24" translate="yes" xml:space="preserve">
          <source>Since we declared neither the copy constructor nor the assignment operator (nor the destructor) ourselves,
these are implicitly defined for us. Quote from the standard:</source>
          <target state="translated">우리는 복사 생성 자나 할당 연산자 (또는 소멸자)를 선언하지 않았기 때문에 암시 적으로 정의되어 있습니다. 표준에서 인용 :</target>
        </trans-unit>
        <trans-unit id="b553fbe0594d46cb1cf45f1cf21cb873033e693b" translate="yes" xml:space="preserve">
          <source>Since we're in an object-oriented language (or at least are assuming so), let's say you have a piece of memory allocated.  Since it's an OO-language, we can easily refer to chunks of memory we allocate because they are usually primitive variables (ints, chars, bytes) or classes we defined that are made of our own types and primitives.  So let's say we have a class of Car as follows:</source>
          <target state="translated">우리는 객체 지향 언어 (또는 최소한 그렇게 가정하고 있음)이므로 메모리 조각이 할당되었다고 가정 해 봅시다. OO 언어이므로 할당 된 메모리 청크를 쉽게 참조 할 수 있습니다. 메모리 청크는 대개 기본 변수 (int, char, bytes) 또는 자체 유형과 프리미티브로 정의 된 클래스이기 때문에 할당합니다. 다음과 같이 Car 클래스가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="432d13bb72859614ef983d24eb754ab62db05256" translate="yes" xml:space="preserve">
          <source>So regardless of what language you're writing in, be very careful about what you mean when it comes to copying objects because most of the time you want a deep copy.</source>
          <target state="translated">따라서 어떤 언어로 작성하든 관계없이 대부분의 경우 딥 카피를 원하기 때문에 객체를 복사 할 때의 의미에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="e333bc494c02ee48487436daa4334ea20e29487b" translate="yes" xml:space="preserve">
          <source>So when should we declare those special member functions explicitly?
When our class &lt;em&gt;manages a resource&lt;/em&gt;, that is,
when an object of the class is &lt;em&gt;responsible&lt;/em&gt; for that resource.
That usually means the resource is &lt;em&gt;acquired&lt;/em&gt; in the constructor
(or passed into the constructor) and &lt;em&gt;released&lt;/em&gt; in the destructor.</source>
          <target state="translated">그렇다면 언제 특수 멤버 함수를 명시 적으로 선언해야합니까? 클래스 &lt;em&gt;가 리소스를 관리&lt;/em&gt; 할 때, 즉 클래스의 객체가 해당 리소스를 &lt;em&gt;담당&lt;/em&gt; 할 때. 이는 일반적으로 생성자에서 리소스를 &lt;em&gt;얻&lt;/em&gt; 거나 생성자로 전달하여 소멸자에서 &lt;em&gt;해제&lt;/em&gt; 한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7c453391545cb5f2f1a89762b41a0bf392d97e58" translate="yes" xml:space="preserve">
          <source>Some resources cannot or should not be copied, such as file handles or mutexes.
In that case, simply declare the copy constructor and copy assignment operator as &lt;code&gt;private&lt;/code&gt; without giving a definition:</source>
          <target state="translated">파일 핸들 또는 뮤텍스와 같은 일부 리소스는 복사 할 수 없거나 복사해서는 안됩니다. 이 경우 정의를 제공하지 않고 복사 생성자와 복사 할당 연산자를 &lt;code&gt;private&lt;/code&gt; 으로 선언하면됩니다.</target>
        </trans-unit>
        <trans-unit id="20e5e60c500a267d3e35b24f8a5cc1ea1cc105ce" translate="yes" xml:space="preserve">
          <source>Sometimes you need to implement a class that manages a resource.
(Never manage multiple resources in a single class,
this will only lead to pain.)
In that case, remember the &lt;strong&gt;rule of three&lt;/strong&gt;:</source>
          <target state="translated">때때로 자원을 관리하는 클래스를 구현해야합니다. (단일 클래스에서 여러 리소스를 관리하지 않으면 고통을 초래할뿐입니다.)이 경우 &lt;strong&gt;세 가지 규칙을&lt;/strong&gt; 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">특별 회원 기능</target>
        </trans-unit>
        <trans-unit id="aec0b15e6e51aa2d57ebbad90284afce08e7d2a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29&quot;&gt;Rule of Three&lt;/a&gt; is a rule of thumb for C++, basically saying</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29&quot;&gt;3&lt;/a&gt; 의 규칙은 기본적으로 C ++의 경험 법칙입니다.</target>
        </trans-unit>
        <trans-unit id="6f11c9f21f514f7ee41c87b1f2bafc24e2635390" translate="yes" xml:space="preserve">
          <source>The Rule of Three states that if you declare any of a</source>
          <target state="translated">세 가지 규칙에 따르면</target>
        </trans-unit>
        <trans-unit id="1dc26c6289bab93223f65317189061f65e87b723" translate="yes" xml:space="preserve">
          <source>The [...] copy constructor and copy assignment operator, [...] and destructor are special member functions.
  [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;The implementation will implicitly declare these member functions
  for some class types when the program does not explicitly declare them.&lt;/strong&gt;
  The implementation will implicitly define them if they are used. [...] &lt;em&gt;end note&lt;/em&gt; ]
  [n3126.pdf section 12 &amp;sect;1]</source>
          <target state="translated">[...] 복사 생성자 및 복사 할당 연산자, [...] 및 소멸자는 특수 멤버 함수입니다. [ &lt;em&gt;참고&lt;/em&gt; : &lt;strong&gt;구현시 프로그램에서 명시 적으로 선언하지 않은 경우 일부 클래스 유형에 대해 이러한 멤버 함수를 암시 적으로 선언합니다.&lt;/strong&gt; 구현은 사용되는 경우 암시 적으로 정의합니다. [...] &lt;em&gt;끝 참고&lt;/em&gt; ] [n3126.pdf section 12 &amp;sect;1]</target>
        </trans-unit>
        <trans-unit id="b5768ebb789ad0414cec44ca827a0cff6a0eddbc" translate="yes" xml:space="preserve">
          <source>The implicitly-defined copy assignment operator for a non-union class X performs memberwise copy assignment
  of its subobjects.
  [n3126.pdf section 12.8 &amp;sect;30]</source>
          <target state="translated">비 유니언 클래스 X에 대해 암시 적으로 정의 된 복사 할당 연산자는 해당 서브 오브젝트의 멤버 별 복사 할당을 수행합니다. [n3126.pdf 섹션 12.8 &amp;sect;30]</target>
        </trans-unit>
        <trans-unit id="156ecf78fca8d8fec636ef6004c3ff179d90628f" translate="yes" xml:space="preserve">
          <source>The implicitly-defined copy constructor for a non-union class X performs a memberwise copy of its subobjects.
  [n3126.pdf section 12.8 &amp;sect;16]</source>
          <target state="translated">비 유니언 클래스 X에 대한 암시 적으로 정의 된 복사 생성자는 해당 서브 오브젝트의 멤버 별 사본을 수행합니다. [n3126.pdf 섹션 12.8 &amp;sect;16]</target>
        </trans-unit>
        <trans-unit id="8a6fcda93390d8731cd9984e256fc2aebb8eff80" translate="yes" xml:space="preserve">
          <source>The implicitly-defined special member functions for &lt;code&gt;person&lt;/code&gt; look like this:</source>
          <target state="translated">사람에 대한 암시 적으로 정의 된 특수 멤버 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a650b709af18f4d7fbd3e2ed31b0e773370b2363" translate="yes" xml:space="preserve">
          <source>The law of the big three is as specified above.</source>
          <target state="translated">빅 3의 법칙은 위에서 지정한대로입니다.</target>
        </trans-unit>
        <trans-unit id="d185dd0e04b218850ba08102a2a62761a1f136a6" translate="yes" xml:space="preserve">
          <source>The problem will be, if a copy is made of your object, then the copy will point to the same memory as the original object.</source>
          <target state="translated">문제는 사본이 객체로 만들어진 경우 사본이 원래 객체와 동일한 메모리를 가리킬 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb497d383301a549cbb9c1d89b7ae37163e627ab" translate="yes" xml:space="preserve">
          <source>The reasons for this is that all three of them are usually used to manage a resource, and if your class manages a resource, it usually needs to manage copying as well as freeing.</source>
          <target state="translated">그 이유는이 세 가지가 모두 리소스를 관리하는 데 주로 사용되기 때문에 클래스에서 리소스를 관리하는 경우 일반적으로 복사 및 해제를 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e6aaca63062ac28b69db5d58ca82abc5b67162c" translate="yes" xml:space="preserve">
          <source>The rule of 3/5 is also referred to as the rule of 0/3/5. The zero part of the rule states that you are allowed to not write any of the special member functions when creating your class.</source>
          <target state="translated">3/5의 규칙은 0/3/5의 규칙이라고도합니다. 규칙의 0 부분은 클래스를 만들 때 특수 멤버 함수를 작성할 수 없다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5fc3cdb89901e2470465908ef90cc89de3c36d0c" translate="yes" xml:space="preserve">
          <source>The rule of five</source>
          <target state="translated">5의 규칙</target>
        </trans-unit>
        <trans-unit id="a855a1fba9a32d8f71b9622855bf798047f92314" translate="yes" xml:space="preserve">
          <source>The rule of three</source>
          <target state="translated">세의 규칙</target>
        </trans-unit>
        <trans-unit id="36c8d8c036bb8fe797cb958ace9878b1d9f0a216" translate="yes" xml:space="preserve">
          <source>The rule of zero</source>
          <target state="translated">제로의 규칙</target>
        </trans-unit>
        <trans-unit id="a903fdf03fcab0513e11024031b16c3545e6f802" translate="yes" xml:space="preserve">
          <source>There are quick examples:</source>
          <target state="translated">빠른 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cd542f7977cffdfdc31953ce90697e0b2617148" translate="yes" xml:space="preserve">
          <source>Therefore, you write a copy constructor so that it allocates new objects their own pieces of memory to destroy.</source>
          <target state="translated">따라서 복사 할 생성자를 작성하여 새 객체에 자체 메모리 조각을 할당하여 파기합니다.</target>
        </trans-unit>
        <trans-unit id="f8798170a9a6651fb0a4c954205b28e6e3af390f" translate="yes" xml:space="preserve">
          <source>This also takes care of self-assignment without an explicit check.
An even more robust solution to this problem is the &lt;a href=&quot;https://stackoverflow.com/questions/3279543/&quot;&gt;copy-and-swap idiom&lt;/a&gt;,
but I will not go into the details of exception safety here.
I only mentioned exceptions to make the following point: &lt;strong&gt;Writing classes that manage resources is hard.&lt;/strong&gt;</source>
          <target state="translated">또한 명시적인 확인없이 자체 할당을 처리합니다. 이 문제에 대한 더욱 강력한 해결책은 &lt;a href=&quot;https://stackoverflow.com/questions/3279543/&quot;&gt;copy-and-swap idiom&lt;/a&gt; 이지만 예외 안전에 대한 자세한 내용은 다루지 않겠습니다. 나는 다음과 같은 점을 지적하기 위해 예외를 언급 &lt;strong&gt;했다. 자원을 관리하는 클래스를 작성하는 것은 어렵다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27b40563b27907a9f057f675f3f37fd6000ad1ac" translate="yes" xml:space="preserve">
          <source>This means that the new object and the old object will be pointing at the same piece of memory so when you change it in one object it will be changed for the other objerct too.  If one object deletes this memory the other will carry on trying to use it - eek.</source>
          <target state="translated">즉, 새 개체와 이전 개체는 동일한 메모리 조각을 가리 키므로 한 개체에서 변경하면 다른 개체도 변경됩니다. 한 개체가이 메모리를 삭제하면 다른 개체는이 메모리를 계속 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="802dfeceb89576282efc5b61a8af1d0cdbcc4a26" translate="yes" xml:space="preserve">
          <source>To resolve this you write your own version of the copy constructor and assignment operator.  Your versions allocate separate memory to the new objects and copy across the values that the first pointer is pointing to rather than its address.</source>
          <target state="translated">이 문제를 해결하려면 고유 한 버전의 복사 생성자와 할당 연산자를 작성하십시오. 버전은 새 객체에 별도의 메모리를 할당하고 첫 번째 포인터가 주소가 아닌 가리키는 값을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="6c910658e0d85611554b78b95cba5500416e1e24" translate="yes" xml:space="preserve">
          <source>Unfortunately, this solution will fail if &lt;code&gt;new char[...]&lt;/code&gt; throws an exception due to memory exhaustion.
One possible solution is to introduce a local variable and reorder the statements:</source>
          <target state="translated">불행히도 메모리 소진으로 인해 &lt;code&gt;new char[...]&lt;/code&gt; 에서 예외가 발생하면이 솔루션이 실패합니다. 가능한 한 가지 해결책은 지역 변수를 도입하고 명령문을 재정렬하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dce3694d3e97fbbf21e3bbef551abea96907eb47" translate="yes" xml:space="preserve">
          <source>What are the &lt;em&gt;copy constructor&lt;/em&gt; and the &lt;em&gt;copy assignment operator&lt;/em&gt;?</source>
          <target state="translated">&lt;em&gt;복사 생성자&lt;/em&gt; 와 &lt;em&gt;복사 할당 연산자는&lt;/em&gt; 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d284fc80dc776543cde9d354bdfabe8024285a6b" translate="yes" xml:space="preserve">
          <source>What are the copy constructor and the copy assignment operator?
I have already used them above.  The copy constructor is called when you type code such as &lt;code&gt;Car car2 = car1;&lt;/code&gt;  Essentially if you declare a variable and assign it in one line, that's when the copy constructor is called.  The assignment operator is what happens when you use an equal sign--&lt;code&gt;car2 = car1;&lt;/code&gt;.  Notice &lt;code&gt;car2&lt;/code&gt; isn't declared in the same statement.  The two chunks of code you write for these operations are likely very similar.  In fact the typical design pattern has another function you call to set everything once you're satisfied the initial copy/assignment is legitimate--if you look at the longhand code I wrote, the functions are nearly identical.</source>
          <target state="translated">복사 생성자와 복사 할당 연산자는 무엇입니까? 나는 이미 그것들을 사용했다. 복사 생성자는 &lt;code&gt;Car car2 = car1;&lt;/code&gt; 본질적으로 변수를 선언하고 한 줄로 지정하면 복사 생성자가 호출됩니다. 대입 연산자는 등호를 사용할 때 발생합니다 &lt;code&gt;car2 = car1;&lt;/code&gt; . &lt;code&gt;car2&lt;/code&gt; 는 동일한 진술에서 선언되지 않습니다. 이러한 작업을 위해 작성하는 두 코드 조각은 매우 유사합니다. 실제로 일반적인 디자인 패턴에는 초기 복사 / 할당이 만족스러운 경우 모든 것을 설정하기 위해 호출하는 또 다른 함수가 있습니다. 필자가 작성한 긴 코드를 보면 함수는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2e18f7284f77f3d90b9ec0f927d31ea3e9dd4931" translate="yes" xml:space="preserve">
          <source>What does &lt;em&gt;copying an object&lt;/em&gt; mean?</source>
          <target state="translated">&lt;em&gt;객체 복사&lt;/em&gt; 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e314a085c799aa51bc02f6c5e796a58203d1aa5f" translate="yes" xml:space="preserve">
          <source>What does copying an object mean? 
There are a few ways you can copy objects--let's talk about the 2 kinds you're most likely referring to--deep copy and shallow copy.</source>
          <target state="translated">객체 복사 란 무엇입니까? 딥 카피와 얕은 카피는 객체를 복사 할 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="18288f95e467e5d08ac50a74ac3a5f64d0b646f6" translate="yes" xml:space="preserve">
          <source>What does it mean to copy a &lt;code&gt;person&lt;/code&gt; object?
The &lt;code&gt;main&lt;/code&gt; function shows two distinct copying scenarios.
The initialization &lt;code&gt;person b(a);&lt;/code&gt; is performed by the &lt;em&gt;copy constructor&lt;/em&gt;.
Its job is to construct a fresh object based on the state of an existing object.
The assignment &lt;code&gt;b = a&lt;/code&gt; is performed by the &lt;em&gt;copy assignment operator&lt;/em&gt;.
Its job is generally a little more complicated,
because the target object is already in some valid state that needs to be dealt with.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 개체를 복사한다는 것은 무엇을 의미합니까? &lt;code&gt;main&lt;/code&gt; 기능은 두 가지 별개의 복사 시나리오를 보여줍니다. 초기화 &lt;code&gt;person b(a);&lt;/code&gt; &lt;em&gt;복사 생성자에&lt;/em&gt; 의해 수행됩니다. 기존 객체의 상태에 따라 새로운 객체를 만드는 것이 그 임무입니다. 할당 &lt;code&gt;b = a&lt;/code&gt; 는 &lt;em&gt;복사 할당 연산자에&lt;/em&gt; 의해 수행됩니다. 대상 객체가 이미 처리해야 할 유효한 상태에 있기 때문에 작업이 일반적으로 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="525369d9ad8d90cf2e824a3d03f0e647b6245a31" translate="yes" xml:space="preserve">
          <source>What is The Rule of Three</source>
          <target state="translated">세 가지 규칙은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="9326d3d974cf129180db9fb54ae9fe50c11558bc" translate="yes" xml:space="preserve">
          <source>When do I need to declare them myself?</source>
          <target state="translated">언제 스스로 신고해야합니까?</target>
        </trans-unit>
        <trans-unit id="2b4d3c03212efec5704293148396f064cc3fa772" translate="yes" xml:space="preserve">
          <source>When do I need to declare them myself? 
If you are not writing code that is to be shared or for production in some manner, you really only need to declare them when you need them.  You do need to be aware of what your program language does if you choose to use it 'by accident' and didn't make one--i.e. you get the compiler default.  I rarely use copy constructors for instance, but assignment operator overrides are very common.  Did you know you can override what addition, subtraction, etc. mean as well?</source>
          <target state="translated">언제 스스로 신고해야합니까? 공유하거나 프로덕션 용 코드를 작성하지 않는 경우 필요할 때만 선언하면됩니다. 프로그램 언어를 '우연히'사용하기로 선택하고 언어를 만들지 않은 경우 (예 : 컴파일러 기본값을 사용하는 경우) 프로그램 언어의 기능을 알아야합니다. 예를 들어 복사 생성자를 거의 사용하지 않지만 할당 연산자 재정의는 매우 일반적입니다. 더하기, 빼기 등의 의미를 무시할 수 있다는 것을 알고 있습니까?</target>
        </trans-unit>
        <trans-unit id="b0748a17383e0d0183f82f7af89a83b5c48c0592" translate="yes" xml:space="preserve">
          <source>You allocated memory in your constructor and so you need to write a destructor to delete it.  Otherwise you will cause a memory leak.</source>
          <target state="translated">생성자에 메모리를 할당 했으므로 소멸자를 작성하여 삭제해야합니다. 그렇지 않으면 메모리 누수가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f35591d3af737f6da366aa57fe0c8a3cec3ebd05" translate="yes" xml:space="preserve">
          <source>You allocated memory in your constructor to a member pointer of your class.  When you copy an object of this class the default assignment operator and copy constructor will copy the value of this member pointer to the new object.</source>
          <target state="translated">생성자의 메모리를 클래스의 멤버 포인터에 할당했습니다. 이 클래스의 객체를 복사하면 기본 할당 연산자와 복사 생성자가이 멤버 포인터의 값을 새 객체에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="d665236b12b323d034f1a59d0be9b78aa4a45839" translate="yes" xml:space="preserve">
          <source>You might think that this is job done.</source>
          <target state="translated">이 작업이 완료된 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4245c721abbc6eb77fa44f3f4a16ff9787771472" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;copy constructor&lt;/strong&gt;,</source>
          <target state="translated">&lt;strong&gt;복사 생성자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a251f0e395aad7bbb837ca31dc8c54f763926c32" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;assignment operator&lt;/strong&gt;,</source>
          <target state="translated">&lt;strong&gt;할당 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1af3319531cdc9d080e124c289ad057aefd0cc4c" translate="yes" xml:space="preserve">
          <source>copy assignment operator</source>
          <target state="translated">복사 할당 연산자</target>
        </trans-unit>
        <trans-unit id="183ecfccbbd2d4096ad1d48b49c8f24046ebf9c1" translate="yes" xml:space="preserve">
          <source>copy constructor</source>
          <target state="translated">복사 생성자</target>
        </trans-unit>
        <trans-unit id="8bc5b477b47fc9df65f37bbb8cb4a49ff6fe6dec" translate="yes" xml:space="preserve">
          <source>defined explictly, then it is likely to need &lt;strong&gt;all three of them&lt;/strong&gt;.</source>
          <target state="translated">명확하게 정의 &lt;strong&gt;하면 세 가지&lt;/strong&gt; 가 &lt;strong&gt;모두&lt;/strong&gt; 필요할 &lt;strong&gt;것&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="867e8ce6dcd7e9c598e666c812691b0cff661d7c" translate="yes" xml:space="preserve">
          <source>destructor</source>
          <target state="translated">destructor</target>
        </trans-unit>
        <trans-unit id="6813b0bf4b910cdeab71fd38315eaad01f7becab" translate="yes" xml:space="preserve">
          <source>or a &lt;strong&gt;destructor&lt;/strong&gt;,</source>
          <target state="translated">또는 &lt;strong&gt;소멸자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="63ac133f749caa7f0c542633b2a3bf7831b595d0" translate="yes" xml:space="preserve">
          <source>the class destructor would also be participating in management of the resource (usually releasing it). The classic resource to be managed was memory, and this is why all Standard Library classes that
manage memory (e.g., the STL containers that perform dynamic memory management) all declare &amp;ldquo;the big three&amp;rdquo;: both copy operations and a destructor.</source>
          <target state="translated">클래스 소멸자는 리소스 관리에 참여할 것입니다 (보통 리소스를 공개). 관리해야 할 기본 리소스는 메모리 였기 때문에 메모리를 관리하는 모든 표준 라이브러리 클래스 (예 : 동적 메모리 관리를 수행하는 STL 컨테이너)가 모두 복사 작업과 소멸자 모두 &quot;큰 세 가지&quot;를 선언하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6b9dbf4312ced3cbd7237155947344baf0a01a7" translate="yes" xml:space="preserve">
          <source>then you should declare all three. It grew out of the observation that the need to take over the meaning of a copy operation almost always stemmed from the class performing some kind of resource management, and that almost always implied that</source>
          <target state="translated">그런 다음 세 가지를 모두 선언해야합니다. 복사 작업의 의미를 인계해야 할 필요성은 거의 항상 일종의 자원 관리를 수행하는 클래스에서 비롯되었으며 거의 ​​항상 그 의미를 암시했습니다.</target>
        </trans-unit>
        <trans-unit id="7ceae16642af9c2edc08b7ed1a5862ae8d9cf4a9" translate="yes" xml:space="preserve">
          <source>whatever resource management was being done in one copy operation probably needed to be done in the other copy operation and</source>
          <target state="translated">한 번의 복사 작업에서 수행 된 모든 자원 관리는 다른 복사 작업에서 수행되어야 할 것입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
