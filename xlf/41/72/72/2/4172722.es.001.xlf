<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/4172722">
    <body>
      <group id="4172722">
        <trans-unit id="79e24a0626d41444ee958448d5c317e6ee96b2d7" translate="yes" xml:space="preserve">
          <source>(If you are puzzled by the &lt;code&gt;name(name), age(age)&lt;/code&gt; part,
this is called a &lt;a href=&quot;https://stackoverflow.com/questions/1272680/&quot;&gt;member initializer list&lt;/a&gt;.)</source>
          <target state="translated">(Si le desconcierta la parte del &lt;code&gt;name(name), age(age)&lt;/code&gt; , esto se llama &lt;a href=&quot;https://stackoverflow.com/questions/1272680/&quot;&gt;lista de inicializador de miembros&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ee45baa134bd16dcc20742aeef7a5dcc5e7df5f" translate="yes" xml:space="preserve">
          <source>(Note that the forthcoming new version of the C++ standard (which is C++11) adds move semantics to C++, which will likely change the Rule of Three. However, I know too little about this to write a C++11 section about the Rule of Three.)</source>
          <target state="translated">(Obsérvese que la nueva versión del estándar C++(que es C++11)añade la semántica del movimiento a C++,lo que probablemente cambiará la Regla de Tres.Sin embargo,sé muy poco sobre esto como para escribir una sección de C++11 sobre la Regla de Tres).</target>
        </trans-unit>
        <trans-unit id="ac32f8d69a83f86f12590e0408e25faea5115d85" translate="yes" xml:space="preserve">
          <source>(Unfortunately, this &quot;rule&quot; is not enforced by the C++ standard or any compiler I am aware of.)</source>
          <target state="translated">(Desafortunadamente,esta &quot;regla&quot; no es aplicada por el estándar C++o cualquier otro compilador que yo conozca.)</target>
        </trans-unit>
        <trans-unit id="399a7f59e9617cfda8eb3917ac2ec614447795d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A consequence of the Rule of Three&lt;/strong&gt; is that the presence of a user-declared destructor indicates that simple member wise copy is unlikely to be appropriate for the copying operations in the class. That, in turn, suggests that if a class declares a destructor, the copy operations probably shouldn&amp;rsquo;t be automatically generated, because they wouldn&amp;rsquo;t do the right thing. At the time C++98 was adopted, the significance of this line of reasoning was not fully appreciated, so in C++98, the existence of a user declared destructor had no impact on compilers&amp;rsquo; willingness to generate copy operations. That continues to be the case in C++11, but only because restricting the conditions under which the copy operations are generated would break too much legacy code.</source>
          <target state="translated">&lt;strong&gt;Una consecuencia de la Regla de tres&lt;/strong&gt; es que la presencia de un destructor declarado por el usuario indica que es improbable que la copia simple por parte del miembro sea apropiada para las operaciones de copia en la clase. Eso, a su vez, sugiere que si una clase declara un destructor, las operaciones de copia probablemente no deber&amp;iacute;an generarse autom&amp;aacute;ticamente, porque no har&amp;iacute;an lo correcto. En el momento en que se adopt&amp;oacute; C ++ 98, la importancia de esta l&amp;iacute;nea de razonamiento no se apreciaba completamente, por lo que en C ++ 98, la existencia de un destructor declarado por el usuario no tuvo ning&amp;uacute;n impacto en la disposici&amp;oacute;n de los compiladores para generar operaciones de copia. Ese sigue siendo el caso en C ++ 11, pero solo porque restringir las condiciones bajo las cuales se generan las operaciones de copia romper&amp;iacute;a demasiado c&amp;oacute;digo heredado.</target>
        </trans-unit>
        <trans-unit id="0164fa64f12437b3f7154666932df4843f15d77b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Assignment operator and copy constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Operador de asignaci&amp;oacute;n y constructor de copia&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc9c35ab6dcfa7c2dcc49cf50d7fef4989cdbc50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non default destructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Destructor no predeterminado&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa9b5621e88a931c947e8c3afe8b1aa2a1130d8e" translate="yes" xml:space="preserve">
          <source>A deep copy is if we declare an object and then create a completely separate copy of the object...we end up with 2 objects in 2 completely sets of memory.</source>
          <target state="translated">Una copia profunda es que si declaramos un objeto y luego creamos una copia completamente separada del objeto...terminamos con 2 objetos en 2 conjuntos completos de memoria.</target>
        </trans-unit>
        <trans-unit id="8295b736050208f7764a760aab4c1497c80f65b8" translate="yes" xml:space="preserve">
          <source>Advice</source>
          <target state="translated">Advice</target>
        </trans-unit>
        <trans-unit id="31fc773c31823ee138ba7ae357bfa817320368ae" translate="yes" xml:space="preserve">
          <source>After executing the body of the destructor and destroying any automatic objects allocated within the body,
  a destructor for class X calls the destructors for X's direct [...] members
  [n3126.pdf 12.4 &amp;sect;6]</source>
          <target state="translated">Despu&amp;eacute;s de ejecutar el cuerpo del destructor y destruir cualquier objeto autom&amp;aacute;tico asignado dentro del cuerpo, un destructor para la clase X llama a los destructores para los miembros directos [...] de X [n3126.pdf 12.4 &amp;sect;6]</target>
        </trans-unit>
        <trans-unit id="d381eea5c923562f51eaaeba8f680d94b10e9ebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can inherit from &lt;code&gt;boost::noncopyable&lt;/code&gt; or declare them as deleted (in C++11 and above):</source>
          <target state="translated">Alternativamente, puede heredar de &lt;code&gt;boost::noncopyable&lt;/code&gt; o declararlos como eliminados (en C ++ 11 y superior):</target>
        </trans-unit>
        <trans-unit id="deb0d50380e6ef75ff89f373543f1a6d844bbf0c" translate="yes" xml:space="preserve">
          <source>An easy example, in plain English, of the kind of problem it solves:</source>
          <target state="translated">Un ejemplo fácil,en inglés,del tipo de problema que resuelve:</target>
        </trans-unit>
        <trans-unit id="c263cc2c82f31396f753d881e9e77d3326c39577" translate="yes" xml:space="preserve">
          <source>An example with the signatures:</source>
          <target state="translated">Un ejemplo con las firmas:</target>
        </trans-unit>
        <trans-unit id="1ee9a96a64d973ab9e4f1c4205c68f56050f9c6d" translate="yes" xml:space="preserve">
          <source>Basically if you have a destructor (not the default destructor) it means that the class that you defined has some memory allocation. Suppose that the class is used outside by some client code or by you.</source>
          <target state="translated">Básicamente,si tienes un destructor (no el destructor por defecto)significa que la clase que has definido tiene alguna asignación de memoria.Supongamos que la clase es usada fuera por algún código de cliente o por ti.</target>
        </trans-unit>
        <trans-unit id="040aea26272cfb1d12bf7b28729c9a1bc9a8c003" translate="yes" xml:space="preserve">
          <source>By default, copying an object means copying its members:</source>
          <target state="translated">Por defecto,copiar un objeto significa copiar sus miembros:</target>
        </trans-unit>
        <trans-unit id="261439050af4def416458064b12196626103581a" translate="yes" xml:space="preserve">
          <source>C++ treats variables of user-defined types with &lt;em&gt;value semantics&lt;/em&gt;.
This means that objects are implicitly copied in various contexts,
and we should understand what &quot;copying an object&quot; actually means.</source>
          <target state="translated">C ++ trata las variables de tipos definidos por el usuario con &lt;em&gt;sem&amp;aacute;ntica de valores&lt;/em&gt; . Esto significa que los objetos se copian impl&amp;iacute;citamente en varios contextos, y debemos entender lo que realmente significa &quot;copiar un objeto&quot;.</target>
        </trans-unit>
        <trans-unit id="968d5d2027df3519a8f0d765e5be5ddda1fb83f5" translate="yes" xml:space="preserve">
          <source>Changes via &lt;code&gt;a&lt;/code&gt; can be observed via &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Los cambios a trav&amp;eacute;s de &lt;code&gt;a&lt;/code&gt; pueden observarse a trav&amp;eacute;s de &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9403b9333150f696ac7a722596c3db118a3e4748" translate="yes" xml:space="preserve">
          <source>Copy assignment operator is a special assignment operator that is usually used to specify an existing object to others of the same type of object.</source>
          <target state="translated">El operador de asignación de copias es un operador de asignación especial que suele utilizarse para especificar un objeto existente a otros del mismo tipo de objeto.</target>
        </trans-unit>
        <trans-unit id="e18cc1bf79ff7f3976543961cb3b485844532b76" translate="yes" xml:space="preserve">
          <source>Copy constructor  in C++ is a special constructor. It is used to build a new object, which is the new object equivalent to a copy of an existing object.</source>
          <target state="translated">El constructor de copias en C++es un constructor especial.Se utiliza para construir un nuevo objeto,que es el nuevo objeto equivalente a una copia de un objeto existente.</target>
        </trans-unit>
        <trans-unit id="facd05cb3a58650993fff6a1db85255e3b0a94e4" translate="yes" xml:space="preserve">
          <source>Declare copy constructor &amp;amp; copy assignment operator as private access specifier.</source>
          <target state="translated">Declare el constructor de copia y el operador de asignaci&amp;oacute;n de copia como especificador de acceso privado.</target>
        </trans-unit>
        <trans-unit id="c812d5bab43eaee8b4dccb2342f4c954b3622299" translate="yes" xml:space="preserve">
          <source>Even today, people still write classes in this style and get into trouble:
&quot;&lt;em&gt;I pushed a person into a vector and now I get crazy memory errors!&lt;/em&gt;&quot;
Remember that by default, copying an object means copying its members,
but copying the &lt;code&gt;name&lt;/code&gt; member merely copies a pointer, &lt;em&gt;not&lt;/em&gt; the character array it points to!
This has several unpleasant effects:</source>
          <target state="translated">Incluso hoy en d&amp;iacute;a, la gente todav&amp;iacute;a escribe clases en este estilo y se mete en problemas: &quot; &lt;em&gt;&amp;iexcl;Empuj&amp;eacute; a una persona a un vector y ahora tengo errores de memoria locos!&lt;/em&gt; &quot; Recuerde que, de forma predeterminada, copiar un objeto significa copiar sus miembros, pero copiar el &lt;code&gt;name&lt;/code&gt; miembro simplemente copia un puntero, &lt;em&gt;no&lt;/em&gt; el conjunto de caracteres al que apunta. Esto tiene varios efectos desagradables:</target>
        </trans-unit>
        <trans-unit id="80d5280e70d86ad891f2b40c8ed78d7da520c6d7" translate="yes" xml:space="preserve">
          <source>Exception safety</source>
          <target state="translated">Seguridad de excepción</target>
        </trans-unit>
        <trans-unit id="fd290e2e68fb87d2b14ea759aa77e5a733ae350e" translate="yes" xml:space="preserve">
          <source>Explicit definitions</source>
          <target state="translated">Definiciones explícitas</target>
        </trans-unit>
        <trans-unit id="4a0cfddf1fb85246d456bc7d093602f37388897b" translate="yes" xml:space="preserve">
          <source>From C++11 on, an object has 2 extra special member functions: the move constructor and move assignment. The rule of five states to implement these functions as well.</source>
          <target state="translated">A partir de C++11,un objeto tiene 2 funciones especiales extra:el constructor de movimientos y la asignación de movimientos.La regla de cinco estados para implementar estas funciones también.</target>
        </trans-unit>
        <trans-unit id="833fe2498329a54d020e1de8e8b856d36c3fff90" translate="yes" xml:space="preserve">
          <source>How can I prevent my objects from being copied?</source>
          <target state="translated">¿Cómo puedo evitar que mis objetos sean copiados?</target>
        </trans-unit>
        <trans-unit id="e2990e958e6115da8fdfe33d77595387d730ae6a" translate="yes" xml:space="preserve">
          <source>How can I prevent my objects from being copied?
Override all of the ways you're allowed to allocate memory for your object with a private function is a reasonable start.  If you really don't want people copying them, you could make it public and alert the programmer by throwing an exception and also not copying the object.</source>
          <target state="translated">¿Cómo puedo evitar que mis objetos sean copiados? Anular todas las formas en que se le permite asignar memoria para su objeto con una función privada es un comienzo razonable.Si realmente no quieres que la gente los copie,puedes hacerlo público y alertar al programador lanzando una excepción y tampoco copiando el objeto.</target>
        </trans-unit>
        <trans-unit id="2fffc80b2aed30ab6e2c6f37124564640bebd4f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is destroyed, deleting the dangling pointer yields &lt;a href=&quot;https://stackoverflow.com/questions/2397984/&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">Si se destruye a, eliminar el puntero colgante produce &lt;a href=&quot;https://stackoverflow.com/questions/2397984/&quot;&gt;un comportamiento indefinido&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc869f09575dbb7deb05212e2e5cf80ad65c178" translate="yes" xml:space="preserve">
          <source>If MyClass has only some primitive typed members a default assignment operator would work but if it has some pointer members and objects that do not have assignment operators the result would be unpredictable. Therefore we can say that if there is something to delete in destructor of a class, we might need a deep copy operator which means we should provide a copy constructor and assignment operator.</source>
          <target state="translated">Si MiClase tiene sólo algunos miembros de tipo primitivo un operador de asignación por defecto funcionaría pero si tiene algunos miembros de tipo puntero y objetos que no tienen operadores de asignación el resultado sería impredecible.Por lo tanto podemos decir que si hay algo que eliminar en el destructor de una clase,podríamos necesitar un operador de copia profundo,lo que significa que deberíamos proporcionar un constructor de copia y un operador de asignación.</target>
        </trans-unit>
        <trans-unit id="a63bf0c27bf9d5b347645c1eb049794e6c9e0a96" translate="yes" xml:space="preserve">
          <source>If there is no good semantic for copying the resource your class manages, then consider to forbid copying by declaring (not &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632&quot;&gt;defining&lt;/a&gt;&lt;/em&gt;) the copy constructor and assignment operator as &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">Si no hay una buena sem&amp;aacute;ntica para copiar el recurso que administra su clase, considere prohibir la copia declarando (no &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632&quot;&gt;definiendo&lt;/a&gt;&lt;/em&gt; ) el constructor de copia y el operador de asignaci&amp;oacute;n como &lt;code&gt;private&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51f6e5ade40c3c9a4a68b72fe61c5e91886c7550" translate="yes" xml:space="preserve">
          <source>If you need to explicitly declare either the destructor,
  copy constructor or copy assignment operator yourself,
  you probably need to explicitly declare all three of them.</source>
          <target state="translated">Si necesita declarar explícitamente el destructor,el constructor de la copia o el operador de la asignación de la copia usted mismo,probablemente necesite declarar explícitamente los tres.</target>
        </trans-unit>
        <trans-unit id="09a94708e1b97a605d19d58a5c49654584da2872" translate="yes" xml:space="preserve">
          <source>If your class needs any of</source>
          <target state="translated">Si su clase necesita algo de</target>
        </trans-unit>
        <trans-unit id="75ff4574c03c6ae385a5c3f20e0b16c05d00ac94" translate="yes" xml:space="preserve">
          <source>Implicit definitions</source>
          <target state="translated">Definiciones implícitas</target>
        </trans-unit>
        <trans-unit id="b155dc653289592b1f4a60114ae84c23564cbcf9" translate="yes" xml:space="preserve">
          <source>In C++11 onwards you can also declare copy constructor &amp;amp; assignment operator deleted</source>
          <target state="translated">En C ++ 11 en adelante tambi&amp;eacute;n puede declarar que el constructor de copia y el operador de asignaci&amp;oacute;n han sido eliminados</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="378aea80c897817c0d000fbb012307be514db260" translate="yes" xml:space="preserve">
          <source>Let us consider a simple example:</source>
          <target state="translated">Consideremos un simple ejemplo:</target>
        </trans-unit>
        <trans-unit id="a417ad7382c5d845e673d6f81d037730bd016e3d" translate="yes" xml:space="preserve">
          <source>Let us go back in time to pre-standard C++.
There was no such thing as &lt;code&gt;std::string&lt;/code&gt;, and programmers were in love with pointers.
The &lt;code&gt;person&lt;/code&gt; class might have looked like this:</source>
          <target state="translated">Volvamos en el tiempo a C ++ preest&amp;aacute;ndar. No exist&amp;iacute;a &lt;code&gt;std::string&lt;/code&gt; , y los programadores estaban enamorados de los punteros. La clase de &lt;code&gt;person&lt;/code&gt; a podr&amp;iacute;a haberse visto as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="bce1a863e79c7b9dc13ce487b7372b22bac1853c" translate="yes" xml:space="preserve">
          <source>Managing resources</source>
          <target state="translated">Gestionar los recursos...</target>
        </trans-unit>
        <trans-unit id="e76b391e984b0c691e529b288ad536b252afc7b3" translate="yes" xml:space="preserve">
          <source>Many of the existing answers already touch the copy constructor, assignment operator and destructor.
However, in post C++11, the introduction of move semantic may expand this beyond 3.</source>
          <target state="translated">Muchas de las respuestas existentes ya tocan al constructor de copias,al operador de asignaciones y al destructor.Sin embargo,en el post C++11,la introducción de la semántica de movimiento puede expandir esto más allá de 3.</target>
        </trans-unit>
        <trans-unit id="0819198a9da4fb2e67a093cb535fb845ff8654d0" translate="yes" xml:space="preserve">
          <source>Memberwise copying is exactly what we want in this case:
&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; are copied, so we get a self-contained, independent &lt;code&gt;person&lt;/code&gt; object.
The implicitly-defined destructor is always empty.
This is also fine in this case since we did not acquire any resources in the constructor.
The members' destructors are implicitly called after the &lt;code&gt;person&lt;/code&gt; destructor is finished:</source>
          <target state="translated">Copiar a los miembros es exactamente lo que queremos en este caso: se copian el &lt;code&gt;name&lt;/code&gt; y la &lt;code&gt;age&lt;/code&gt; , por lo que obtenemos un objeto de &lt;code&gt;person&lt;/code&gt; a aut&amp;oacute;nomo e independiente. El destructor definido impl&amp;iacute;citamente siempre est&amp;aacute; vac&amp;iacute;o. Esto tambi&amp;eacute;n est&amp;aacute; bien en este caso ya que no adquirimos ning&amp;uacute;n recurso en el constructor. Los destructores de los miembros se invocan impl&amp;iacute;citamente despu&amp;eacute;s de que el destructor de &lt;code&gt;person&lt;/code&gt; as finaliza:</target>
        </trans-unit>
        <trans-unit id="0dd92645d263aa57f332c39c57b04a0c6ff5a10e" translate="yes" xml:space="preserve">
          <source>Most of the time, you do not need to manage a resource yourself,
because an existing class such as &lt;code&gt;std::string&lt;/code&gt; already does it for you.
Just compare the simple code using a &lt;code&gt;std::string&lt;/code&gt; member
to the convoluted and error-prone alternative using a &lt;code&gt;char*&lt;/code&gt; and you should be convinced.
As long as you stay away from raw pointer members, the rule of three is unlikely to concern your own code.</source>
          <target state="translated">La mayor&amp;iacute;a de las veces, no necesita administrar un recurso usted mismo, porque una clase existente como &lt;code&gt;std::string&lt;/code&gt; ya lo hace por usted. Simplemente compare el c&amp;oacute;digo simple usando un miembro &lt;code&gt;std::string&lt;/code&gt; con la alternativa enrevesada y propensa a errores usando un &lt;code&gt;char*&lt;/code&gt; y deber&amp;iacute;a estar convencido. Siempre y cuando se mantenga alejado de los miembros de puntero sin procesar, es poco probable que la regla de tres se refiera a su propio c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="dd0558423f6422a29a6d0332c36f63c59c7f95f8" translate="yes" xml:space="preserve">
          <source>Noncopyable resources</source>
          <target state="translated">Recursos no copiables</target>
        </trans-unit>
        <trans-unit id="4be5e1e184cee713a06eb304202691ba706e11be" translate="yes" xml:space="preserve">
          <source>Note the difference between initialization and assignment:
we must tear down the old state before assigning to &lt;code&gt;name&lt;/code&gt; to prevent memory leaks.
Also, we have to protect against self-assignment of the form &lt;code&gt;x = x&lt;/code&gt;.
Without that check, &lt;code&gt;delete[] name&lt;/code&gt; would delete the array containing the &lt;em&gt;source&lt;/em&gt; string,
because when you write &lt;code&gt;x = x&lt;/code&gt;, both &lt;code&gt;this-&amp;gt;name&lt;/code&gt; and &lt;code&gt;that.name&lt;/code&gt; contain the same pointer.</source>
          <target state="translated">Tenga en cuenta la diferencia entre inicializaci&amp;oacute;n y asignaci&amp;oacute;n: debemos derribar el estado anterior antes de asignar un &lt;code&gt;name&lt;/code&gt; para evitar p&amp;eacute;rdidas de memoria. Adem&amp;aacute;s, debemos protegernos contra la autoasignaci&amp;oacute;n de la forma &lt;code&gt;x = x&lt;/code&gt; . Sin esa verificaci&amp;oacute;n, &lt;code&gt;delete[] name&lt;/code&gt; eliminar&amp;iacute;a la matriz que contiene la cadena de &lt;em&gt;origen&lt;/em&gt; , porque cuando escribe &lt;code&gt;x = x&lt;/code&gt; , tanto &lt;code&gt;this-&amp;gt;name&lt;/code&gt; como &lt;code&gt;that.name&lt;/code&gt; contienen el mismo puntero.</target>
        </trans-unit>
        <trans-unit id="73057aa0d94caeff72d3f954441205d18a0c5e92" translate="yes" xml:space="preserve">
          <source>Now let's do something strange.  Let's say car2 is either programmed wrong or purposely meant to share the actual memory that car1 is made of.  (It's usually a mistake to do this and in classes is usually the blanket it's discussed under.)  Pretend that anytime you ask about car2, you're really resolving a pointer to car1's memory space...that's more or less what a shallow copy is.</source>
          <target state="translated">Ahora hagamos algo extraño.Digamos que el coche 2 está mal programado o que está destinado a compartir la memoria real de la que está hecho el coche 1.(Suele ser un error hacer esto y en las clases suele ser la manta de la que se habla.)Imagina que cada vez que preguntas por el coche 2,estás resolviendo un puntero al espacio de memoria del coche 1...eso es más o menos lo que es una copia superficial.</target>
        </trans-unit>
        <trans-unit id="fc62f4b9642ccc8d14eccf688ad938a553acfa03" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;b&lt;/code&gt; is destroyed, &lt;code&gt;a.name&lt;/code&gt; is a dangling pointer.</source>
          <target state="translated">Una vez que se destruye &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a.name&lt;/code&gt; es un puntero colgante.</target>
        </trans-unit>
        <trans-unit id="943852bcdc471f99d2175602717c3e90a8e2be92" translate="yes" xml:space="preserve">
          <source>Once, one of these deletes the memory in its destructor, the other will have a pointer to invalid memory (this is called a dangling pointer) when it tries to use it things are going to get hairy.</source>
          <target state="translated">Una vez,uno de estos borra la memoria en su destructor,el otro tendrá un puntero a la memoria inválida (esto se llama un puntero colgante)cuando trate de usarlo las cosas se van a poner peliagudas.</target>
        </trans-unit>
        <trans-unit id="8d49c0a90a74b9bd99cd612e86d765b341ed4fa3" translate="yes" xml:space="preserve">
          <source>Recently Michael Claisse gave a talk that touches this topic:
&lt;a href=&quot;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&quot;&gt;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&lt;/a&gt;</source>
          <target state="translated">Recientemente, Michael Claisse dio una charla que toca este tema: &lt;a href=&quot;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&quot;&gt;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e23ca9e46e33f48cc5cf353d5d00a2dd2ffdf4d" translate="yes" xml:space="preserve">
          <source>Rule of three in C++ is a fundamental principle of the design and the development of three requirements that if there is clear definition in one of the following member function, then the programmer should define the other two members functions together. Namely the following three member functions are indispensable: destructor, copy constructor, copy assignment operator.</source>
          <target state="translated">La regla de tres en C++es un principio fundamental del diseño y el desarrollo de tres requisitos que si hay una definición clara en una de las siguientes funciones de los miembros,entonces el programador debe definir las otras dos funciones de los miembros juntas.A saber,las siguientes tres funciones miembros son indispensables:destructor,constructor de copias,operador de asignación de copias.</target>
        </trans-unit>
        <trans-unit id="211147411bb0b9fe8452e926d2a21b6c29d0375b" translate="yes" xml:space="preserve">
          <source>Since memberwise copying does not have the desired effect, we must define the copy constructor and the copy assignment operator explicitly to make deep copies of the character array:</source>
          <target state="translated">Como la copia de miembros no tiene el efecto deseado,debemos definir el constructor de la copia y el operador de asignación de la copia explícitamente para hacer copias profundas de la matriz de caracteres:</target>
        </trans-unit>
        <trans-unit id="360428a6299c49410f566d35610ff9a59032ced5" translate="yes" xml:space="preserve">
          <source>Since the assignment does not take into account what &lt;code&gt;name&lt;/code&gt; pointed to before the assignment,
sooner or later you will get memory leaks all over the place.</source>
          <target state="translated">Dado que la asignaci&amp;oacute;n no tiene en cuenta el &lt;code&gt;name&lt;/code&gt; se&amp;ntilde;alado antes de la asignaci&amp;oacute;n, tarde o temprano obtendr&amp;aacute; p&amp;eacute;rdidas de memoria por todas partes.</target>
        </trans-unit>
        <trans-unit id="7e6450c00de2897fd30725717505cfce2ddcba24" translate="yes" xml:space="preserve">
          <source>Since we declared neither the copy constructor nor the assignment operator (nor the destructor) ourselves,
these are implicitly defined for us. Quote from the standard:</source>
          <target state="translated">Como no declaramos ni el constructor de la copia ni el operador de la asignación (ni el destructor)nosotros mismos,estos están implícitamente definidos para nosotros.Cita de la norma:</target>
        </trans-unit>
        <trans-unit id="b553fbe0594d46cb1cf45f1cf21cb873033e693b" translate="yes" xml:space="preserve">
          <source>Since we're in an object-oriented language (or at least are assuming so), let's say you have a piece of memory allocated.  Since it's an OO-language, we can easily refer to chunks of memory we allocate because they are usually primitive variables (ints, chars, bytes) or classes we defined that are made of our own types and primitives.  So let's say we have a class of Car as follows:</source>
          <target state="translated">Ya que estamos en un lenguaje orientado a los objetos (o al menos lo estamos asumiendo),digamos que tienes un trozo de memoria asignado.Como es un lenguaje OO,podemos referirnos fácilmente a los trozos de memoria que asignamos porque son normalmente variables primitivas (ints,chars,bytes)o clases que definimos que están hechas de nuestros propios tipos y primitivos.Así que digamos que tenemos una clase de Car como la siguiente:</target>
        </trans-unit>
        <trans-unit id="432d13bb72859614ef983d24eb754ab62db05256" translate="yes" xml:space="preserve">
          <source>So regardless of what language you're writing in, be very careful about what you mean when it comes to copying objects because most of the time you want a deep copy.</source>
          <target state="translated">Así que,independientemente del idioma en el que escribas,ten mucho cuidado con lo que quieres decir cuando se trata de copiar objetos porque la mayoría de las veces quieres una copia profunda.</target>
        </trans-unit>
        <trans-unit id="e333bc494c02ee48487436daa4334ea20e29487b" translate="yes" xml:space="preserve">
          <source>So when should we declare those special member functions explicitly?
When our class &lt;em&gt;manages a resource&lt;/em&gt;, that is,
when an object of the class is &lt;em&gt;responsible&lt;/em&gt; for that resource.
That usually means the resource is &lt;em&gt;acquired&lt;/em&gt; in the constructor
(or passed into the constructor) and &lt;em&gt;released&lt;/em&gt; in the destructor.</source>
          <target state="translated">Entonces, &amp;iquest;cu&amp;aacute;ndo debemos declarar expl&amp;iacute;citamente esas funciones miembro especiales? Cuando nuestra clase &lt;em&gt;administra un recurso&lt;/em&gt; , es decir, cuando un objeto de la clase es &lt;em&gt;responsable&lt;/em&gt; de ese recurso. Eso generalmente significa que el recurso se &lt;em&gt;adquiere&lt;/em&gt; en el constructor (o se pasa al constructor) y se &lt;em&gt;libera&lt;/em&gt; en el destructor.</target>
        </trans-unit>
        <trans-unit id="7c453391545cb5f2f1a89762b41a0bf392d97e58" translate="yes" xml:space="preserve">
          <source>Some resources cannot or should not be copied, such as file handles or mutexes.
In that case, simply declare the copy constructor and copy assignment operator as &lt;code&gt;private&lt;/code&gt; without giving a definition:</source>
          <target state="translated">Algunos recursos no pueden o no deben copiarse, como identificadores de archivos o mutexes. En ese caso, simplemente declare el constructor de copia y el operador de asignaci&amp;oacute;n de copia como &lt;code&gt;private&lt;/code&gt; sin dar una definici&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="20e5e60c500a267d3e35b24f8a5cc1ea1cc105ce" translate="yes" xml:space="preserve">
          <source>Sometimes you need to implement a class that manages a resource.
(Never manage multiple resources in a single class,
this will only lead to pain.)
In that case, remember the &lt;strong&gt;rule of three&lt;/strong&gt;:</source>
          <target state="translated">A veces necesita implementar una clase que gestione un recurso. (Nunca administre m&amp;uacute;ltiples recursos en una sola clase, esto solo provocar&amp;aacute; dolor). En ese caso, recuerde la &lt;strong&gt;regla de tres&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">Funciones especiales de los miembros</target>
        </trans-unit>
        <trans-unit id="aec0b15e6e51aa2d57ebbad90284afce08e7d2a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29&quot;&gt;Rule of Three&lt;/a&gt; is a rule of thumb for C++, basically saying</source>
          <target state="translated">La &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29&quot;&gt;regla de tres&lt;/a&gt; es una regla general para C ++, b&amp;aacute;sicamente diciendo</target>
        </trans-unit>
        <trans-unit id="6f11c9f21f514f7ee41c87b1f2bafc24e2635390" translate="yes" xml:space="preserve">
          <source>The Rule of Three states that if you declare any of a</source>
          <target state="translated">La Regla de Tres establece que si declaras algo de un</target>
        </trans-unit>
        <trans-unit id="1dc26c6289bab93223f65317189061f65e87b723" translate="yes" xml:space="preserve">
          <source>The [...] copy constructor and copy assignment operator, [...] and destructor are special member functions.
  [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;The implementation will implicitly declare these member functions
  for some class types when the program does not explicitly declare them.&lt;/strong&gt;
  The implementation will implicitly define them if they are used. [...] &lt;em&gt;end note&lt;/em&gt; ]
  [n3126.pdf section 12 &amp;sect;1]</source>
          <target state="translated">El constructor de [...] copia y el operador de asignaci&amp;oacute;n de copia, [...] y el destructor son funciones miembro especiales. [ &lt;em&gt;Nota&lt;/em&gt; : &lt;strong&gt;La implementaci&amp;oacute;n declarar&amp;aacute; impl&amp;iacute;citamente estas funciones miembro para algunos tipos de clase cuando el programa no las declare expl&amp;iacute;citamente.&lt;/strong&gt; La implementaci&amp;oacute;n los definir&amp;aacute; impl&amp;iacute;citamente si se usan. [...] &lt;em&gt;nota final&lt;/em&gt; ] [n3126.pdf secci&amp;oacute;n 12 &amp;sect;1]</target>
        </trans-unit>
        <trans-unit id="b5768ebb789ad0414cec44ca827a0cff6a0eddbc" translate="yes" xml:space="preserve">
          <source>The implicitly-defined copy assignment operator for a non-union class X performs memberwise copy assignment
  of its subobjects.
  [n3126.pdf section 12.8 &amp;sect;30]</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de copia definido impl&amp;iacute;citamente para una clase X no sindical realiza la asignaci&amp;oacute;n de copia de sus subobjetos a nivel de miembro. [n3126.pdf secci&amp;oacute;n 12.8 &amp;sect;30]</target>
        </trans-unit>
        <trans-unit id="156ecf78fca8d8fec636ef6004c3ff179d90628f" translate="yes" xml:space="preserve">
          <source>The implicitly-defined copy constructor for a non-union class X performs a memberwise copy of its subobjects.
  [n3126.pdf section 12.8 &amp;sect;16]</source>
          <target state="translated">El constructor de copia impl&amp;iacute;citamente definido para una clase X sin uni&amp;oacute;n realiza una copia miembro de sus subobjetos. [n3126.pdf secci&amp;oacute;n 12.8 &amp;sect;16]</target>
        </trans-unit>
        <trans-unit id="8a6fcda93390d8731cd9984e256fc2aebb8eff80" translate="yes" xml:space="preserve">
          <source>The implicitly-defined special member functions for &lt;code&gt;person&lt;/code&gt; look like this:</source>
          <target state="translated">Las funciones de miembro especiales definidas impl&amp;iacute;citamente para &lt;code&gt;person&lt;/code&gt; a se ven as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="a650b709af18f4d7fbd3e2ed31b0e773370b2363" translate="yes" xml:space="preserve">
          <source>The law of the big three is as specified above.</source>
          <target state="translated">La ley de los tres grandes es la especificada anteriormente.</target>
        </trans-unit>
        <trans-unit id="d185dd0e04b218850ba08102a2a62761a1f136a6" translate="yes" xml:space="preserve">
          <source>The problem will be, if a copy is made of your object, then the copy will point to the same memory as the original object.</source>
          <target state="translated">El problema será que si se hace una copia de su objeto,entonces la copia apuntará a la misma memoria que el objeto original.</target>
        </trans-unit>
        <trans-unit id="eb497d383301a549cbb9c1d89b7ae37163e627ab" translate="yes" xml:space="preserve">
          <source>The reasons for this is that all three of them are usually used to manage a resource, and if your class manages a resource, it usually needs to manage copying as well as freeing.</source>
          <target state="translated">Las razones de esto es que las tres se utilizan normalmente para gestionar un recurso,y si su clase gestiona un recurso,normalmente necesita gestionar la copia así como la liberación.</target>
        </trans-unit>
        <trans-unit id="1e6aaca63062ac28b69db5d58ca82abc5b67162c" translate="yes" xml:space="preserve">
          <source>The rule of 3/5 is also referred to as the rule of 0/3/5. The zero part of the rule states that you are allowed to not write any of the special member functions when creating your class.</source>
          <target state="translated">La regla de 35 también se conoce como la regla de 035.La parte cero de la regla establece que se le permite no escribir ninguna de las funciones especiales del miembro al crear su clase.</target>
        </trans-unit>
        <trans-unit id="5fc3cdb89901e2470465908ef90cc89de3c36d0c" translate="yes" xml:space="preserve">
          <source>The rule of five</source>
          <target state="translated">La regla de los cinco</target>
        </trans-unit>
        <trans-unit id="a855a1fba9a32d8f71b9622855bf798047f92314" translate="yes" xml:space="preserve">
          <source>The rule of three</source>
          <target state="translated">La regla de tres</target>
        </trans-unit>
        <trans-unit id="36c8d8c036bb8fe797cb958ace9878b1d9f0a216" translate="yes" xml:space="preserve">
          <source>The rule of zero</source>
          <target state="translated">La regla del cero</target>
        </trans-unit>
        <trans-unit id="a903fdf03fcab0513e11024031b16c3545e6f802" translate="yes" xml:space="preserve">
          <source>There are quick examples:</source>
          <target state="translated">Hay ejemplos rápidos:</target>
        </trans-unit>
        <trans-unit id="3cd542f7977cffdfdc31953ce90697e0b2617148" translate="yes" xml:space="preserve">
          <source>Therefore, you write a copy constructor so that it allocates new objects their own pieces of memory to destroy.</source>
          <target state="translated">Por lo tanto,se escribe un constructor de copias para que asigne a los nuevos objetos sus propios trozos de memoria para destruir.</target>
        </trans-unit>
        <trans-unit id="f8798170a9a6651fb0a4c954205b28e6e3af390f" translate="yes" xml:space="preserve">
          <source>This also takes care of self-assignment without an explicit check.
An even more robust solution to this problem is the &lt;a href=&quot;https://stackoverflow.com/questions/3279543/&quot;&gt;copy-and-swap idiom&lt;/a&gt;,
but I will not go into the details of exception safety here.
I only mentioned exceptions to make the following point: &lt;strong&gt;Writing classes that manage resources is hard.&lt;/strong&gt;</source>
          <target state="translated">Esto tambi&amp;eacute;n se encarga de la autoasignaci&amp;oacute;n sin una verificaci&amp;oacute;n expl&amp;iacute;cita. Una soluci&amp;oacute;n a&amp;uacute;n m&amp;aacute;s robusta para este problema es el &lt;a href=&quot;https://stackoverflow.com/questions/3279543/&quot;&gt;modismo de copiar e intercambiar&lt;/a&gt; , pero no entrar&amp;eacute; aqu&amp;iacute; en los detalles de seguridad de excepci&amp;oacute;n. Solo mencion&amp;eacute; excepciones para hacer el siguiente punto: &lt;strong&gt;Escribir clases que administren recursos es dif&amp;iacute;cil.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27b40563b27907a9f057f675f3f37fd6000ad1ac" translate="yes" xml:space="preserve">
          <source>This means that the new object and the old object will be pointing at the same piece of memory so when you change it in one object it will be changed for the other objerct too.  If one object deletes this memory the other will carry on trying to use it - eek.</source>
          <target state="translated">Esto significa que el nuevo y el antiguo objeto apuntarán al mismo trozo de memoria,de modo que cuando lo cambie en un objeto,también lo cambiará en el otro.Si un objeto borra esta memoria,el otro seguirá intentando usarla,eek.</target>
        </trans-unit>
        <trans-unit id="802dfeceb89576282efc5b61a8af1d0cdbcc4a26" translate="yes" xml:space="preserve">
          <source>To resolve this you write your own version of the copy constructor and assignment operator.  Your versions allocate separate memory to the new objects and copy across the values that the first pointer is pointing to rather than its address.</source>
          <target state="translated">Para resolver esto,escribes tu propia versión del constructor de copias y del operador de asignaciones.Sus versiones asignan una memoria separada a los nuevos objetos y copian a través de los valores a los que apunta el primer puntero en lugar de su dirección.</target>
        </trans-unit>
        <trans-unit id="6c910658e0d85611554b78b95cba5500416e1e24" translate="yes" xml:space="preserve">
          <source>Unfortunately, this solution will fail if &lt;code&gt;new char[...]&lt;/code&gt; throws an exception due to memory exhaustion.
One possible solution is to introduce a local variable and reorder the statements:</source>
          <target state="translated">Desafortunadamente, esta soluci&amp;oacute;n fallar&amp;aacute; si los &lt;code&gt;new char[...]&lt;/code&gt; arrojan una excepci&amp;oacute;n debido al agotamiento de la memoria. Una posible soluci&amp;oacute;n es introducir una variable local y reordenar las declaraciones:</target>
        </trans-unit>
        <trans-unit id="dce3694d3e97fbbf21e3bbef551abea96907eb47" translate="yes" xml:space="preserve">
          <source>What are the &lt;em&gt;copy constructor&lt;/em&gt; and the &lt;em&gt;copy assignment operator&lt;/em&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;les son el &lt;em&gt;constructor de copia&lt;/em&gt; y el &lt;em&gt;operador de asignaci&amp;oacute;n de copia&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="d284fc80dc776543cde9d354bdfabe8024285a6b" translate="yes" xml:space="preserve">
          <source>What are the copy constructor and the copy assignment operator?
I have already used them above.  The copy constructor is called when you type code such as &lt;code&gt;Car car2 = car1;&lt;/code&gt;  Essentially if you declare a variable and assign it in one line, that's when the copy constructor is called.  The assignment operator is what happens when you use an equal sign--&lt;code&gt;car2 = car1;&lt;/code&gt;.  Notice &lt;code&gt;car2&lt;/code&gt; isn't declared in the same statement.  The two chunks of code you write for these operations are likely very similar.  In fact the typical design pattern has another function you call to set everything once you're satisfied the initial copy/assignment is legitimate--if you look at the longhand code I wrote, the functions are nearly identical.</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;les son el constructor de copia y el operador de asignaci&amp;oacute;n de copia? Ya los he usado arriba. Se llama al constructor de copia cuando escribe c&amp;oacute;digo como &lt;code&gt;Car car2 = car1;&lt;/code&gt; Esencialmente, si declara una variable y la asigna en una l&amp;iacute;nea, es cuando se llama al constructor de la copia. El operador de asignaci&amp;oacute;n es lo que sucede cuando usa un signo igual: &lt;code&gt;car2 = car1;&lt;/code&gt; . Observe que &lt;code&gt;car2&lt;/code&gt; no se declara en la misma declaraci&amp;oacute;n. Es probable que los dos fragmentos de c&amp;oacute;digo que escriba para estas operaciones sean muy similares. De hecho, el patr&amp;oacute;n de dise&amp;ntilde;o t&amp;iacute;pico tiene otra funci&amp;oacute;n a la que llama para configurar todo una vez que est&amp;aacute; satisfecho, la copia / asignaci&amp;oacute;n inicial es leg&amp;iacute;tima: si observa el c&amp;oacute;digo escrito a mano, las funciones son casi id&amp;eacute;nticas.</target>
        </trans-unit>
        <trans-unit id="2e18f7284f77f3d90b9ec0f927d31ea3e9dd4931" translate="yes" xml:space="preserve">
          <source>What does &lt;em&gt;copying an object&lt;/em&gt; mean?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; significa &lt;em&gt;copiar un objeto&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="e314a085c799aa51bc02f6c5e796a58203d1aa5f" translate="yes" xml:space="preserve">
          <source>What does copying an object mean? 
There are a few ways you can copy objects--let's talk about the 2 kinds you're most likely referring to--deep copy and shallow copy.</source>
          <target state="translated">¿Qué significa copiar un objeto? Hay algunas maneras de copiar objetos...hablemos de los dos tipos a los que más probablemente te refieras...copia profunda y copia superficial.</target>
        </trans-unit>
        <trans-unit id="18288f95e467e5d08ac50a74ac3a5f64d0b646f6" translate="yes" xml:space="preserve">
          <source>What does it mean to copy a &lt;code&gt;person&lt;/code&gt; object?
The &lt;code&gt;main&lt;/code&gt; function shows two distinct copying scenarios.
The initialization &lt;code&gt;person b(a);&lt;/code&gt; is performed by the &lt;em&gt;copy constructor&lt;/em&gt;.
Its job is to construct a fresh object based on the state of an existing object.
The assignment &lt;code&gt;b = a&lt;/code&gt; is performed by the &lt;em&gt;copy assignment operator&lt;/em&gt;.
Its job is generally a little more complicated,
because the target object is already in some valid state that needs to be dealt with.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; significa copiar un objeto &lt;code&gt;person&lt;/code&gt; a ? La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; muestra dos escenarios de copia distintos. La &lt;code&gt;person b(a);&lt;/code&gt; inicializaci&amp;oacute;n b (a); es realizado por el &lt;em&gt;constructor de&lt;/em&gt; la &lt;em&gt;copia&lt;/em&gt; . Su trabajo es construir un objeto nuevo basado en el estado de un objeto existente. La asignaci&amp;oacute;n &lt;code&gt;b = a&lt;/code&gt; es realizada por el &lt;em&gt;operador de asignaci&amp;oacute;n de copia&lt;/em&gt; . Su trabajo es generalmente un poco m&amp;aacute;s complicado, porque el objeto de destino ya est&amp;aacute; en alg&amp;uacute;n estado v&amp;aacute;lido que necesita ser tratado.</target>
        </trans-unit>
        <trans-unit id="525369d9ad8d90cf2e824a3d03f0e647b6245a31" translate="yes" xml:space="preserve">
          <source>What is The Rule of Three</source>
          <target state="translated">¿Cuál es la regla de tres</target>
        </trans-unit>
        <trans-unit id="9326d3d974cf129180db9fb54ae9fe50c11558bc" translate="yes" xml:space="preserve">
          <source>When do I need to declare them myself?</source>
          <target state="translated">¿Cuándo tengo que declararlos yo mismo?</target>
        </trans-unit>
        <trans-unit id="2b4d3c03212efec5704293148396f064cc3fa772" translate="yes" xml:space="preserve">
          <source>When do I need to declare them myself? 
If you are not writing code that is to be shared or for production in some manner, you really only need to declare them when you need them.  You do need to be aware of what your program language does if you choose to use it 'by accident' and didn't make one--i.e. you get the compiler default.  I rarely use copy constructors for instance, but assignment operator overrides are very common.  Did you know you can override what addition, subtraction, etc. mean as well?</source>
          <target state="translated">¿Cuándo tengo que declararlos yo mismo? Si no estás escribiendo un código para ser compartido o para ser producido de alguna manera,sólo necesitas declararlos cuando los necesites.Necesitas ser consciente de lo que hace tu lenguaje de programa si eliges usarlo &quot;por accidente&quot; y no lo hiciste,es decir,obtienes el compilador por defecto.Raramente uso constructores de copias,por ejemplo,pero las anulaciones de operadores de asignaciones son muy comunes.¿Sabías que también puedes anular lo que significan la suma,la resta,etc.?</target>
        </trans-unit>
        <trans-unit id="b0748a17383e0d0183f82f7af89a83b5c48c0592" translate="yes" xml:space="preserve">
          <source>You allocated memory in your constructor and so you need to write a destructor to delete it.  Otherwise you will cause a memory leak.</source>
          <target state="translated">Asignaste memoria en tu constructor y por eso necesitas escribir un destructor para borrarla.De lo contrario,causará una fuga de memoria.</target>
        </trans-unit>
        <trans-unit id="f35591d3af737f6da366aa57fe0c8a3cec3ebd05" translate="yes" xml:space="preserve">
          <source>You allocated memory in your constructor to a member pointer of your class.  When you copy an object of this class the default assignment operator and copy constructor will copy the value of this member pointer to the new object.</source>
          <target state="translated">Asignó la memoria de su constructor a un miembro de su clase.Al copiar un objeto de esta clase,el operador de asignación por defecto y el constructor de copia copiarán el valor de este puntero miembro al nuevo objeto.</target>
        </trans-unit>
        <trans-unit id="d665236b12b323d034f1a59d0be9b78aa4a45839" translate="yes" xml:space="preserve">
          <source>You might think that this is job done.</source>
          <target state="translated">Podrías pensar que esto es un trabajo hecho.</target>
        </trans-unit>
        <trans-unit id="4245c721abbc6eb77fa44f3f4a16ff9787771472" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;copy constructor&lt;/strong&gt;,</source>
          <target state="translated">un &lt;strong&gt;constructor de copias&lt;/strong&gt; ,</target>
        </trans-unit>
        <trans-unit id="a251f0e395aad7bbb837ca31dc8c54f763926c32" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;assignment operator&lt;/strong&gt;,</source>
          <target state="translated">un &lt;strong&gt;operador de asignaci&amp;oacute;n&lt;/strong&gt; ,</target>
        </trans-unit>
        <trans-unit id="1af3319531cdc9d080e124c289ad057aefd0cc4c" translate="yes" xml:space="preserve">
          <source>copy assignment operator</source>
          <target state="translated">operador de asignación de copias</target>
        </trans-unit>
        <trans-unit id="183ecfccbbd2d4096ad1d48b49c8f24046ebf9c1" translate="yes" xml:space="preserve">
          <source>copy constructor</source>
          <target state="translated">constructor de copias</target>
        </trans-unit>
        <trans-unit id="8bc5b477b47fc9df65f37bbb8cb4a49ff6fe6dec" translate="yes" xml:space="preserve">
          <source>defined explictly, then it is likely to need &lt;strong&gt;all three of them&lt;/strong&gt;.</source>
          <target state="translated">definido expl&amp;iacute;citamente, entonces es probable que los necesite a &lt;strong&gt;los tres&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="867e8ce6dcd7e9c598e666c812691b0cff661d7c" translate="yes" xml:space="preserve">
          <source>destructor</source>
          <target state="translated">destructor</target>
        </trans-unit>
        <trans-unit id="6813b0bf4b910cdeab71fd38315eaad01f7becab" translate="yes" xml:space="preserve">
          <source>or a &lt;strong&gt;destructor&lt;/strong&gt;,</source>
          <target state="translated">o un &lt;strong&gt;destructor&lt;/strong&gt; ,</target>
        </trans-unit>
        <trans-unit id="63ac133f749caa7f0c542633b2a3bf7831b595d0" translate="yes" xml:space="preserve">
          <source>the class destructor would also be participating in management of the resource (usually releasing it). The classic resource to be managed was memory, and this is why all Standard Library classes that
manage memory (e.g., the STL containers that perform dynamic memory management) all declare &amp;ldquo;the big three&amp;rdquo;: both copy operations and a destructor.</source>
          <target state="translated">el destructor de clase tambi&amp;eacute;n estar&amp;iacute;a participando en la gesti&amp;oacute;n del recurso (generalmente solt&amp;aacute;ndolo). El recurso cl&amp;aacute;sico que se administr&amp;oacute; fue la memoria, y esta es la raz&amp;oacute;n por la cual todas las clases de la Biblioteca est&amp;aacute;ndar que administran la memoria (por ejemplo, los contenedores STL que realizan la administraci&amp;oacute;n din&amp;aacute;mica de la memoria) declaran &quot;los tres grandes&quot;: operaciones de copia y un destructor.</target>
        </trans-unit>
        <trans-unit id="b6b9dbf4312ced3cbd7237155947344baf0a01a7" translate="yes" xml:space="preserve">
          <source>then you should declare all three. It grew out of the observation that the need to take over the meaning of a copy operation almost always stemmed from the class performing some kind of resource management, and that almost always implied that</source>
          <target state="translated">entonces deberías declarar los tres.Surgió de la observación de que la necesidad de asumir el significado de una operación de copia casi siempre provenía de la clase que realizaba algún tipo de gestión de recursos,y que casi siempre implicaba que</target>
        </trans-unit>
        <trans-unit id="7ceae16642af9c2edc08b7ed1a5862ae8d9cf4a9" translate="yes" xml:space="preserve">
          <source>whatever resource management was being done in one copy operation probably needed to be done in the other copy operation and</source>
          <target state="translated">cualquier gestión de recursos que se hiciera en una operación de copia probablemente debía hacerse en la otra operación de copia y</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
