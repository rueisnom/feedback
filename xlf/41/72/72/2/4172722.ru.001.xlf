<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/4172722">
    <body>
      <group id="4172722">
        <trans-unit id="79e24a0626d41444ee958448d5c317e6ee96b2d7" translate="yes" xml:space="preserve">
          <source>(If you are puzzled by the &lt;code&gt;name(name), age(age)&lt;/code&gt; part,
this is called a &lt;a href=&quot;https://stackoverflow.com/questions/1272680/&quot;&gt;member initializer list&lt;/a&gt;.)</source>
          <target state="translated">(Если вы озадачены &lt;code&gt;name(name), age(age)&lt;/code&gt; части, это называется &lt;a href=&quot;https://stackoverflow.com/questions/1272680/&quot;&gt;списком инициализатора участника&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="9ee45baa134bd16dcc20742aeef7a5dcc5e7df5f" translate="yes" xml:space="preserve">
          <source>(Note that the forthcoming new version of the C++ standard (which is C++11) adds move semantics to C++, which will likely change the Rule of Three. However, I know too little about this to write a C++11 section about the Rule of Three.)</source>
          <target state="translated">(Обратите внимание,что в грядущей новой версии стандарта C++(то есть C++11)к C++добавлена семантика перемещений,что,скорее всего,изменит Правило трех.Однако,я знаю об этом слишком мало,чтобы написать раздел на C++11 о правиле трех).</target>
        </trans-unit>
        <trans-unit id="ac32f8d69a83f86f12590e0408e25faea5115d85" translate="yes" xml:space="preserve">
          <source>(Unfortunately, this &quot;rule&quot; is not enforced by the C++ standard or any compiler I am aware of.)</source>
          <target state="translated">(К сожалению,это &quot;правило&quot; не выполняется ни стандартом языка Си++,ни каким-либо известным мне компилятором).</target>
        </trans-unit>
        <trans-unit id="399a7f59e9617cfda8eb3917ac2ec614447795d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A consequence of the Rule of Three&lt;/strong&gt; is that the presence of a user-declared destructor indicates that simple member wise copy is unlikely to be appropriate for the copying operations in the class. That, in turn, suggests that if a class declares a destructor, the copy operations probably shouldn&amp;rsquo;t be automatically generated, because they wouldn&amp;rsquo;t do the right thing. At the time C++98 was adopted, the significance of this line of reasoning was not fully appreciated, so in C++98, the existence of a user declared destructor had no impact on compilers&amp;rsquo; willingness to generate copy operations. That continues to be the case in C++11, but only because restricting the conditions under which the copy operations are generated would break too much legacy code.</source>
          <target state="translated">&lt;strong&gt;Следствием правила три&lt;/strong&gt; является то, что наличие деструктора, объявленного пользователем, указывает на то, что простое копирование в виде члена вряд ли подходит для операций копирования в классе. Это, в свою очередь, говорит о том, что если класс объявляет деструктор, операции копирования, вероятно, не должны генерироваться автоматически, потому что они не будут делать правильные вещи. В то время, когда был принят C ++ 98, значение этой линии рассуждений не было полностью оценено, поэтому в C ++ 98 существование объявленного пользователем деструктора не оказало влияния на готовность компиляторов генерировать операции копирования. Это продолжает иметь место в C ++ 11, но только потому, что ограничение условий, при которых генерируются операции копирования, нарушило бы слишком много устаревшего кода.</target>
        </trans-unit>
        <trans-unit id="0164fa64f12437b3f7154666932df4843f15d77b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Assignment operator and copy constructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Оператор присваивания и конструктор копирования&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc9c35ab6dcfa7c2dcc49cf50d7fef4989cdbc50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non default destructor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Деструктор не по умолчанию&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa9b5621e88a931c947e8c3afe8b1aa2a1130d8e" translate="yes" xml:space="preserve">
          <source>A deep copy is if we declare an object and then create a completely separate copy of the object...we end up with 2 objects in 2 completely sets of memory.</source>
          <target state="translated">Глубокая копия-это если мы объявим объект,а затем создадим полностью отдельную копию объекта...в конечном итоге мы получим 2 объекта в 2-х полных комплектах памяти.</target>
        </trans-unit>
        <trans-unit id="8295b736050208f7764a760aab4c1497c80f65b8" translate="yes" xml:space="preserve">
          <source>Advice</source>
          <target state="translated">Advice</target>
        </trans-unit>
        <trans-unit id="31fc773c31823ee138ba7ae357bfa817320368ae" translate="yes" xml:space="preserve">
          <source>After executing the body of the destructor and destroying any automatic objects allocated within the body,
  a destructor for class X calls the destructors for X's direct [...] members
  [n3126.pdf 12.4 &amp;sect;6]</source>
          <target state="translated">После выполнения тела деструктора и уничтожения любых автоматических объектов, размещенных в теле, деструктор для класса X вызывает деструкторы для прямых [...] членов X [n3126.pdf 12.4 &amp;sect;6]</target>
        </trans-unit>
        <trans-unit id="d381eea5c923562f51eaaeba8f680d94b10e9ebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can inherit from &lt;code&gt;boost::noncopyable&lt;/code&gt; or declare them as deleted (in C++11 and above):</source>
          <target state="translated">Кроме того, вы можете наследовать от &lt;code&gt;boost::noncopyable&lt;/code&gt; или объявить их как удаленные (в C ++ 11 и выше):</target>
        </trans-unit>
        <trans-unit id="deb0d50380e6ef75ff89f373543f1a6d844bbf0c" translate="yes" xml:space="preserve">
          <source>An easy example, in plain English, of the kind of problem it solves:</source>
          <target state="translated">Легкий пример,на простом английском языке,той проблемы,которую он решает:</target>
        </trans-unit>
        <trans-unit id="c263cc2c82f31396f753d881e9e77d3326c39577" translate="yes" xml:space="preserve">
          <source>An example with the signatures:</source>
          <target state="translated">Пример с подписями:</target>
        </trans-unit>
        <trans-unit id="1ee9a96a64d973ab9e4f1c4205c68f56050f9c6d" translate="yes" xml:space="preserve">
          <source>Basically if you have a destructor (not the default destructor) it means that the class that you defined has some memory allocation. Suppose that the class is used outside by some client code or by you.</source>
          <target state="translated">В принципе,если у вас есть деструктор (не деструктор по умолчанию),это означает,что класс,который вы определили,имеет некоторое выделение памяти.Предположим,что класс используется снаружи каким-то клиентским кодом или вами.</target>
        </trans-unit>
        <trans-unit id="040aea26272cfb1d12bf7b28729c9a1bc9a8c003" translate="yes" xml:space="preserve">
          <source>By default, copying an object means copying its members:</source>
          <target state="translated">По умолчанию копирование объекта означает копирование его членов:</target>
        </trans-unit>
        <trans-unit id="261439050af4def416458064b12196626103581a" translate="yes" xml:space="preserve">
          <source>C++ treats variables of user-defined types with &lt;em&gt;value semantics&lt;/em&gt;.
This means that objects are implicitly copied in various contexts,
and we should understand what &quot;copying an object&quot; actually means.</source>
          <target state="translated">C ++ обрабатывает переменные пользовательских типов с помощью &lt;em&gt;семантики значений&lt;/em&gt; . Это означает, что объекты неявно копируются в различных контекстах, и мы должны понимать, что на самом деле означает &amp;laquo;копирование объекта&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="968d5d2027df3519a8f0d765e5be5ddda1fb83f5" translate="yes" xml:space="preserve">
          <source>Changes via &lt;code&gt;a&lt;/code&gt; can be observed via &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Изменения через &lt;code&gt;a&lt;/code&gt; можно наблюдать через &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9403b9333150f696ac7a722596c3db118a3e4748" translate="yes" xml:space="preserve">
          <source>Copy assignment operator is a special assignment operator that is usually used to specify an existing object to others of the same type of object.</source>
          <target state="translated">Оператор копирования присваивания-это специальный оператор присваивания,который обычно используется для указания существующего объекта другим объектам того же типа.</target>
        </trans-unit>
        <trans-unit id="e18cc1bf79ff7f3976543961cb3b485844532b76" translate="yes" xml:space="preserve">
          <source>Copy constructor  in C++ is a special constructor. It is used to build a new object, which is the new object equivalent to a copy of an existing object.</source>
          <target state="translated">Конструктор копирования на C++-это специальный конструктор.Он используется для создания нового объекта,который является новым объектом,эквивалентным копии существующего объекта.</target>
        </trans-unit>
        <trans-unit id="facd05cb3a58650993fff6a1db85255e3b0a94e4" translate="yes" xml:space="preserve">
          <source>Declare copy constructor &amp;amp; copy assignment operator as private access specifier.</source>
          <target state="translated">Объявите конструктор копирования и оператор назначения копирования как частный указатель доступа.</target>
        </trans-unit>
        <trans-unit id="c812d5bab43eaee8b4dccb2342f4c954b3622299" translate="yes" xml:space="preserve">
          <source>Even today, people still write classes in this style and get into trouble:
&quot;&lt;em&gt;I pushed a person into a vector and now I get crazy memory errors!&lt;/em&gt;&quot;
Remember that by default, copying an object means copying its members,
but copying the &lt;code&gt;name&lt;/code&gt; member merely copies a pointer, &lt;em&gt;not&lt;/em&gt; the character array it points to!
This has several unpleasant effects:</source>
          <target state="translated">Даже сегодня люди все еще пишут классы в этом стиле и попадают в неприятности: &amp;laquo; &lt;em&gt;Я толкнул человека в вектор, и теперь у меня возникают сумасшедшие ошибки памяти!&lt;/em&gt; &amp;raquo; Помните, что по умолчанию копирование объекта означает копирование его членов, но копирование &lt;code&gt;name&lt;/code&gt; члена просто копирует указатель, а &lt;em&gt;не&lt;/em&gt; массив символов, на который он указывает! Это имеет несколько неприятных эффектов:</target>
        </trans-unit>
        <trans-unit id="80d5280e70d86ad891f2b40c8ed78d7da520c6d7" translate="yes" xml:space="preserve">
          <source>Exception safety</source>
          <target state="translated">Исключительная безопасность</target>
        </trans-unit>
        <trans-unit id="fd290e2e68fb87d2b14ea759aa77e5a733ae350e" translate="yes" xml:space="preserve">
          <source>Explicit definitions</source>
          <target state="translated">Четкие определения</target>
        </trans-unit>
        <trans-unit id="4a0cfddf1fb85246d456bc7d093602f37388897b" translate="yes" xml:space="preserve">
          <source>From C++11 on, an object has 2 extra special member functions: the move constructor and move assignment. The rule of five states to implement these functions as well.</source>
          <target state="translated">Начиная с C++11,объект имеет 2 дополнительные специальные функции-членов:конструктор перемещения и назначение перемещения.Правило пяти состояний для реализации этих функций также.</target>
        </trans-unit>
        <trans-unit id="833fe2498329a54d020e1de8e8b856d36c3fff90" translate="yes" xml:space="preserve">
          <source>How can I prevent my objects from being copied?</source>
          <target state="translated">Как я могу предотвратить копирование моих предметов?</target>
        </trans-unit>
        <trans-unit id="e2990e958e6115da8fdfe33d77595387d730ae6a" translate="yes" xml:space="preserve">
          <source>How can I prevent my objects from being copied?
Override all of the ways you're allowed to allocate memory for your object with a private function is a reasonable start.  If you really don't want people copying them, you could make it public and alert the programmer by throwing an exception and also not copying the object.</source>
          <target state="translated">Как я могу предотвратить копирование моих предметов? Отменить все способы,которыми вам разрешено выделять память для вашего объекта с помощью приватной функции-это разумное начало.Если вы действительно не хотите,чтобы люди их копировали,вы можете сделать это публичным и предупредить программиста,бросив исключение,а также не копировать объект.</target>
        </trans-unit>
        <trans-unit id="2fffc80b2aed30ab6e2c6f37124564640bebd4f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is destroyed, deleting the dangling pointer yields &lt;a href=&quot;https://stackoverflow.com/questions/2397984/&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; уничтожено, удаление висящего указателя приводит к &lt;a href=&quot;https://stackoverflow.com/questions/2397984/&quot;&gt;неопределенному поведению&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc869f09575dbb7deb05212e2e5cf80ad65c178" translate="yes" xml:space="preserve">
          <source>If MyClass has only some primitive typed members a default assignment operator would work but if it has some pointer members and objects that do not have assignment operators the result would be unpredictable. Therefore we can say that if there is something to delete in destructor of a class, we might need a deep copy operator which means we should provide a copy constructor and assignment operator.</source>
          <target state="translated">Если в MyClass есть только несколько членов с примитивным типом,то оператор присваивания будет работать по умолчанию,но если в нем есть несколько членов с указателями и объекты,которые не имеют операторов присваивания,то результат будет непредсказуемым.Поэтому можно сказать,что если в деструкторе класса есть что удалять,то может понадобиться оператор глубокого копирования,а значит,следует предоставить конструктор копирования и оператор присваивания.</target>
        </trans-unit>
        <trans-unit id="a63bf0c27bf9d5b347645c1eb049794e6c9e0a96" translate="yes" xml:space="preserve">
          <source>If there is no good semantic for copying the resource your class manages, then consider to forbid copying by declaring (not &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632&quot;&gt;defining&lt;/a&gt;&lt;/em&gt;) the copy constructor and assignment operator as &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">Если нет хорошей семантики для копирования ресурса, которым управляет ваш класс, тогда попробуйте запретить копирование, объявив (не &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632&quot;&gt;определяя&lt;/a&gt;&lt;/em&gt; ) конструктор копирования и оператор присваивания как &lt;code&gt;private&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51f6e5ade40c3c9a4a68b72fe61c5e91886c7550" translate="yes" xml:space="preserve">
          <source>If you need to explicitly declare either the destructor,
  copy constructor or copy assignment operator yourself,
  you probably need to explicitly declare all three of them.</source>
          <target state="translated">Если вам необходимо явно объявить либо деструктор,либо конструктор копирования,либо оператор присваивания,то,вероятно,вам необходимо явно объявить все три из них.</target>
        </trans-unit>
        <trans-unit id="09a94708e1b97a605d19d58a5c49654584da2872" translate="yes" xml:space="preserve">
          <source>If your class needs any of</source>
          <target state="translated">Если вашему классу нужно</target>
        </trans-unit>
        <trans-unit id="75ff4574c03c6ae385a5c3f20e0b16c05d00ac94" translate="yes" xml:space="preserve">
          <source>Implicit definitions</source>
          <target state="translated">Неявные определения</target>
        </trans-unit>
        <trans-unit id="b155dc653289592b1f4a60114ae84c23564cbcf9" translate="yes" xml:space="preserve">
          <source>In C++11 onwards you can also declare copy constructor &amp;amp; assignment operator deleted</source>
          <target state="translated">В C ++ 11 и далее вы также можете объявить, что конструктор копирования и оператор присваивания удалены</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="378aea80c897817c0d000fbb012307be514db260" translate="yes" xml:space="preserve">
          <source>Let us consider a simple example:</source>
          <target state="translated">Рассмотрим простой пример:</target>
        </trans-unit>
        <trans-unit id="a417ad7382c5d845e673d6f81d037730bd016e3d" translate="yes" xml:space="preserve">
          <source>Let us go back in time to pre-standard C++.
There was no such thing as &lt;code&gt;std::string&lt;/code&gt;, and programmers were in love with pointers.
The &lt;code&gt;person&lt;/code&gt; class might have looked like this:</source>
          <target state="translated">Давайте вернемся назад к предстандартному C ++. Не было такого понятия, как &lt;code&gt;std::string&lt;/code&gt; , и программисты были влюблены в указатели. Класс &lt;code&gt;person&lt;/code&gt; мог бы выглядеть так:</target>
        </trans-unit>
        <trans-unit id="bce1a863e79c7b9dc13ce487b7372b22bac1853c" translate="yes" xml:space="preserve">
          <source>Managing resources</source>
          <target state="translated">Управление ресурсами</target>
        </trans-unit>
        <trans-unit id="e76b391e984b0c691e529b288ad536b252afc7b3" translate="yes" xml:space="preserve">
          <source>Many of the existing answers already touch the copy constructor, assignment operator and destructor.
However, in post C++11, the introduction of move semantic may expand this beyond 3.</source>
          <target state="translated">Многие из существующих ответов уже касаются конструктора копирования,оператора присваивания и деструктора.Однако,в пост-С++11 введение семантики перемещения может расширить это за пределы 3.</target>
        </trans-unit>
        <trans-unit id="0819198a9da4fb2e67a093cb535fb845ff8654d0" translate="yes" xml:space="preserve">
          <source>Memberwise copying is exactly what we want in this case:
&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; are copied, so we get a self-contained, independent &lt;code&gt;person&lt;/code&gt; object.
The implicitly-defined destructor is always empty.
This is also fine in this case since we did not acquire any resources in the constructor.
The members' destructors are implicitly called after the &lt;code&gt;person&lt;/code&gt; destructor is finished:</source>
          <target state="translated">Копирование по элементам - это именно то, что мы хотим в этом случае: &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;age&lt;/code&gt; копируются, поэтому мы получаем самостоятельный, независимый объект &lt;code&gt;person&lt;/code&gt; . Неявно определенный деструктор всегда пуст. Это также хорошо в этом случае, так как мы не получили никаких ресурсов в конструкторе. Деструкторы членов неявно вызываются после завершения деструктора &lt;code&gt;person&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0dd92645d263aa57f332c39c57b04a0c6ff5a10e" translate="yes" xml:space="preserve">
          <source>Most of the time, you do not need to manage a resource yourself,
because an existing class such as &lt;code&gt;std::string&lt;/code&gt; already does it for you.
Just compare the simple code using a &lt;code&gt;std::string&lt;/code&gt; member
to the convoluted and error-prone alternative using a &lt;code&gt;char*&lt;/code&gt; and you should be convinced.
As long as you stay away from raw pointer members, the rule of three is unlikely to concern your own code.</source>
          <target state="translated">В большинстве случаев вам не нужно самостоятельно управлять ресурсом, потому что существующий класс, такой как &lt;code&gt;std::string&lt;/code&gt; уже делает это за вас. Просто сравните простой код, использующий элемент &lt;code&gt;std::string&lt;/code&gt; с извилистой и подверженной ошибкам альтернативой, использующей &lt;code&gt;char*&lt;/code&gt; и вы должны убедиться в этом. Пока вы держитесь подальше от необработанных членов-указателей, правило трех вряд ли будет касаться вашего собственного кода.</target>
        </trans-unit>
        <trans-unit id="dd0558423f6422a29a6d0332c36f63c59c7f95f8" translate="yes" xml:space="preserve">
          <source>Noncopyable resources</source>
          <target state="translated">Некопируемые ресурсы</target>
        </trans-unit>
        <trans-unit id="4be5e1e184cee713a06eb304202691ba706e11be" translate="yes" xml:space="preserve">
          <source>Note the difference between initialization and assignment:
we must tear down the old state before assigning to &lt;code&gt;name&lt;/code&gt; to prevent memory leaks.
Also, we have to protect against self-assignment of the form &lt;code&gt;x = x&lt;/code&gt;.
Without that check, &lt;code&gt;delete[] name&lt;/code&gt; would delete the array containing the &lt;em&gt;source&lt;/em&gt; string,
because when you write &lt;code&gt;x = x&lt;/code&gt;, both &lt;code&gt;this-&amp;gt;name&lt;/code&gt; and &lt;code&gt;that.name&lt;/code&gt; contain the same pointer.</source>
          <target state="translated">Обратите внимание на разницу между инициализацией и назначением: мы должны разрушить старое состояние перед назначением &lt;code&gt;name&lt;/code&gt; чтобы предотвратить утечки памяти. Также мы должны защитить себя от самостоятельного присвоения вида &lt;code&gt;x = x&lt;/code&gt; . Без этой проверки &lt;code&gt;delete[] name&lt;/code&gt; удалит массив, содержащий &lt;em&gt;исходную&lt;/em&gt; строку, потому что когда вы пишете &lt;code&gt;x = x&lt;/code&gt; , и &lt;code&gt;this-&amp;gt;name&lt;/code&gt; , и &lt;code&gt;that.name&lt;/code&gt; содержат один и тот же указатель.</target>
        </trans-unit>
        <trans-unit id="73057aa0d94caeff72d3f954441205d18a0c5e92" translate="yes" xml:space="preserve">
          <source>Now let's do something strange.  Let's say car2 is either programmed wrong or purposely meant to share the actual memory that car1 is made of.  (It's usually a mistake to do this and in classes is usually the blanket it's discussed under.)  Pretend that anytime you ask about car2, you're really resolving a pointer to car1's memory space...that's more or less what a shallow copy is.</source>
          <target state="translated">А теперь давайте сделаем что-нибудь странное.Допустим,car2 либо неправильно запрограммирован,либо специально предназначен для совместного использования реальной памяти,из которой сделан car1.(Обычно это ошибка,а в классах это,как правило,одеяло,о котором идет речь).Притворитесь,что каждый раз,когда вы спрашиваете о car2,вы действительно разрешаете указатель на пространство памяти car1...это более или менее мелкая копия.</target>
        </trans-unit>
        <trans-unit id="fc62f4b9642ccc8d14eccf688ad938a553acfa03" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;b&lt;/code&gt; is destroyed, &lt;code&gt;a.name&lt;/code&gt; is a dangling pointer.</source>
          <target state="translated">Как только &lt;code&gt;b&lt;/code&gt; уничтожен, &lt;code&gt;a.name&lt;/code&gt; является висящим указателем.</target>
        </trans-unit>
        <trans-unit id="943852bcdc471f99d2175602717c3e90a8e2be92" translate="yes" xml:space="preserve">
          <source>Once, one of these deletes the memory in its destructor, the other will have a pointer to invalid memory (this is called a dangling pointer) when it tries to use it things are going to get hairy.</source>
          <target state="translated">Как только один из них удалит память в своем деструкторе,другой будет иметь указатель на некорректную память (это называется висячий указатель),когда он попытается ее использовать,вещи станут волосатыми.</target>
        </trans-unit>
        <trans-unit id="8d49c0a90a74b9bd99cd612e86d765b341ed4fa3" translate="yes" xml:space="preserve">
          <source>Recently Michael Claisse gave a talk that touches this topic:
&lt;a href=&quot;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&quot;&gt;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&lt;/a&gt;</source>
          <target state="translated">Недавно Майкл Клэсс выступил с докладом на эту тему: &lt;a href=&quot;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&quot;&gt;http://channel9.msdn.com/events/CPP/C-PP-Con-2014/The-Canonical-Class&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e23ca9e46e33f48cc5cf353d5d00a2dd2ffdf4d" translate="yes" xml:space="preserve">
          <source>Rule of three in C++ is a fundamental principle of the design and the development of three requirements that if there is clear definition in one of the following member function, then the programmer should define the other two members functions together. Namely the following three member functions are indispensable: destructor, copy constructor, copy assignment operator.</source>
          <target state="translated">Правило трех в языке Си++-это основополагающий принцип проектирования и разработки трех требований,согласно которому если в одной из следующих членских функций дано четкое определение,то программист должен определить вместе две другие членские функции.А именно:деструктор,конструктор копирования,оператор присваивания копий.</target>
        </trans-unit>
        <trans-unit id="211147411bb0b9fe8452e926d2a21b6c29d0375b" translate="yes" xml:space="preserve">
          <source>Since memberwise copying does not have the desired effect, we must define the copy constructor and the copy assignment operator explicitly to make deep copies of the character array:</source>
          <target state="translated">Так как членское копирование не имеет желаемого эффекта,мы должны явно определить конструктор копирования и оператор присваивания копий,чтобы сделать глубокие копии символьного массива:</target>
        </trans-unit>
        <trans-unit id="360428a6299c49410f566d35610ff9a59032ced5" translate="yes" xml:space="preserve">
          <source>Since the assignment does not take into account what &lt;code&gt;name&lt;/code&gt; pointed to before the assignment,
sooner or later you will get memory leaks all over the place.</source>
          <target state="translated">Поскольку в назначении не учитывается &lt;code&gt;name&lt;/code&gt; указывало до назначения, рано или поздно вы обнаружите утечки памяти повсюду.</target>
        </trans-unit>
        <trans-unit id="7e6450c00de2897fd30725717505cfce2ddcba24" translate="yes" xml:space="preserve">
          <source>Since we declared neither the copy constructor nor the assignment operator (nor the destructor) ourselves,
these are implicitly defined for us. Quote from the standard:</source>
          <target state="translated">Поскольку мы сами не объявили ни конструктора копирования,ни оператора присваивания (ни деструктора),то для нас они неявно определены.Цитата из стандарта:</target>
        </trans-unit>
        <trans-unit id="b553fbe0594d46cb1cf45f1cf21cb873033e693b" translate="yes" xml:space="preserve">
          <source>Since we're in an object-oriented language (or at least are assuming so), let's say you have a piece of memory allocated.  Since it's an OO-language, we can easily refer to chunks of memory we allocate because they are usually primitive variables (ints, chars, bytes) or classes we defined that are made of our own types and primitives.  So let's say we have a class of Car as follows:</source>
          <target state="translated">Поскольку мы находимся на объектно-ориентированном языке (или,по крайней мере,предполагаем,что это так),допустим,у вас выделена часть памяти.Так как это объектно-ориентированный язык,мы можем легко обратиться к выделенным кускам памяти,потому что это обычно примитивные переменные (ints,chars,bytes)или классы,которые мы определили и которые сделаны из наших собственных типов и примитивов.Так что,допустим,у нас есть класс Car следующим образом:</target>
        </trans-unit>
        <trans-unit id="432d13bb72859614ef983d24eb754ab62db05256" translate="yes" xml:space="preserve">
          <source>So regardless of what language you're writing in, be very careful about what you mean when it comes to copying objects because most of the time you want a deep copy.</source>
          <target state="translated">Поэтому,независимо от того,на каком языке вы пишете,будьте очень осторожны,когда речь заходит о копировании объектов,потому что в большинстве случаев вам нужна глубокая копия.</target>
        </trans-unit>
        <trans-unit id="e333bc494c02ee48487436daa4334ea20e29487b" translate="yes" xml:space="preserve">
          <source>So when should we declare those special member functions explicitly?
When our class &lt;em&gt;manages a resource&lt;/em&gt;, that is,
when an object of the class is &lt;em&gt;responsible&lt;/em&gt; for that resource.
That usually means the resource is &lt;em&gt;acquired&lt;/em&gt; in the constructor
(or passed into the constructor) and &lt;em&gt;released&lt;/em&gt; in the destructor.</source>
          <target state="translated">Итак, когда мы должны объявить эти специальные функции-члены явно? Когда наш класс &lt;em&gt;управляет ресурсом&lt;/em&gt; , то есть когда объект класса &lt;em&gt;отвечает&lt;/em&gt; за этот ресурс. Обычно это означает, что ресурс получается в конструкторе (или передается в конструктор) и &lt;em&gt;освобождается&lt;/em&gt; в деструкторе.</target>
        </trans-unit>
        <trans-unit id="7c453391545cb5f2f1a89762b41a0bf392d97e58" translate="yes" xml:space="preserve">
          <source>Some resources cannot or should not be copied, such as file handles or mutexes.
In that case, simply declare the copy constructor and copy assignment operator as &lt;code&gt;private&lt;/code&gt; without giving a definition:</source>
          <target state="translated">Некоторые ресурсы не могут или не должны копироваться, такие как дескрипторы файлов или мьютексы. В этом случае просто объявите конструктор копирования и оператор присваивания копирования как &lt;code&gt;private&lt;/code&gt; без определения:</target>
        </trans-unit>
        <trans-unit id="20e5e60c500a267d3e35b24f8a5cc1ea1cc105ce" translate="yes" xml:space="preserve">
          <source>Sometimes you need to implement a class that manages a resource.
(Never manage multiple resources in a single class,
this will only lead to pain.)
In that case, remember the &lt;strong&gt;rule of three&lt;/strong&gt;:</source>
          <target state="translated">Иногда вам нужно реализовать класс, который управляет ресурсом. (Никогда не управляйте несколькими ресурсами в одном классе, это только приведет к боли.) В этом случае помните &lt;strong&gt;правило трех&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="translated">Специальные функции члена</target>
        </trans-unit>
        <trans-unit id="aec0b15e6e51aa2d57ebbad90284afce08e7d2a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29&quot;&gt;Rule of Three&lt;/a&gt; is a rule of thumb for C++, basically saying</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29&quot;&gt;Правило трех&lt;/a&gt; является практическим правилом для C ++, в основном говоря,</target>
        </trans-unit>
        <trans-unit id="6f11c9f21f514f7ee41c87b1f2bafc24e2635390" translate="yes" xml:space="preserve">
          <source>The Rule of Three states that if you declare any of a</source>
          <target state="translated">Правило трех гласит,что если вы объявите что-либо из</target>
        </trans-unit>
        <trans-unit id="1dc26c6289bab93223f65317189061f65e87b723" translate="yes" xml:space="preserve">
          <source>The [...] copy constructor and copy assignment operator, [...] and destructor are special member functions.
  [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;The implementation will implicitly declare these member functions
  for some class types when the program does not explicitly declare them.&lt;/strong&gt;
  The implementation will implicitly define them if they are used. [...] &lt;em&gt;end note&lt;/em&gt; ]
  [n3126.pdf section 12 &amp;sect;1]</source>
          <target state="translated">[...] конструктор копирования и оператор присваивания копии, [...] и деструктор являются специальными функциями-членами. [ &lt;em&gt;Примечание&lt;/em&gt; : &lt;strong&gt;Реализация будет неявно объявлять эти функции-члены для некоторых типов классов, когда программа явно не объявляет их.&lt;/strong&gt; Реализация будет неявно определять их, если они используются. [...] &lt;em&gt;конец примечания&lt;/em&gt; ] [n3126.pdf раздел 12 &amp;sect;1]</target>
        </trans-unit>
        <trans-unit id="b5768ebb789ad0414cec44ca827a0cff6a0eddbc" translate="yes" xml:space="preserve">
          <source>The implicitly-defined copy assignment operator for a non-union class X performs memberwise copy assignment
  of its subobjects.
  [n3126.pdf section 12.8 &amp;sect;30]</source>
          <target state="translated">Неявно определенный оператор присваивания копии для класса X, не являющегося объединением, выполняет присваивание для каждого элемента подобъекта. [n3126.pdf раздел 12.8 &amp;sect;30]</target>
        </trans-unit>
        <trans-unit id="156ecf78fca8d8fec636ef6004c3ff179d90628f" translate="yes" xml:space="preserve">
          <source>The implicitly-defined copy constructor for a non-union class X performs a memberwise copy of its subobjects.
  [n3126.pdf section 12.8 &amp;sect;16]</source>
          <target state="translated">Неявно определенный конструктор копирования для класса X, не являющегося объединением, выполняет пошаговую копию своих подобъектов. [n3126.pdf раздел 12.8 &amp;sect;16]</target>
        </trans-unit>
        <trans-unit id="8a6fcda93390d8731cd9984e256fc2aebb8eff80" translate="yes" xml:space="preserve">
          <source>The implicitly-defined special member functions for &lt;code&gt;person&lt;/code&gt; look like this:</source>
          <target state="translated">Неявно определенные специальные функции-члены для &lt;code&gt;person&lt;/code&gt; выглядят так:</target>
        </trans-unit>
        <trans-unit id="a650b709af18f4d7fbd3e2ed31b0e773370b2363" translate="yes" xml:space="preserve">
          <source>The law of the big three is as specified above.</source>
          <target state="translated">Закон большой тройки,как указано выше.</target>
        </trans-unit>
        <trans-unit id="d185dd0e04b218850ba08102a2a62761a1f136a6" translate="yes" xml:space="preserve">
          <source>The problem will be, if a copy is made of your object, then the copy will point to the same memory as the original object.</source>
          <target state="translated">Проблема будет заключаться в том,что если копия сделана с вашего объекта,то копия будет указывать на ту же самую память,что и оригинал.</target>
        </trans-unit>
        <trans-unit id="eb497d383301a549cbb9c1d89b7ae37163e627ab" translate="yes" xml:space="preserve">
          <source>The reasons for this is that all three of them are usually used to manage a resource, and if your class manages a resource, it usually needs to manage copying as well as freeing.</source>
          <target state="translated">Причины этого в том,что все три из них обычно используются для управления ресурсом,и если ваш класс управляет ресурсом,то ему обычно нужно управлять копированием,а также освобождением.</target>
        </trans-unit>
        <trans-unit id="1e6aaca63062ac28b69db5d58ca82abc5b67162c" translate="yes" xml:space="preserve">
          <source>The rule of 3/5 is also referred to as the rule of 0/3/5. The zero part of the rule states that you are allowed to not write any of the special member functions when creating your class.</source>
          <target state="translated">Правило 35 также называется правилом 035.Нулевая часть правила гласит,что при создании класса разрешается не писать ни одной из специальных функций-членов.</target>
        </trans-unit>
        <trans-unit id="5fc3cdb89901e2470465908ef90cc89de3c36d0c" translate="yes" xml:space="preserve">
          <source>The rule of five</source>
          <target state="translated">Правило пяти</target>
        </trans-unit>
        <trans-unit id="a855a1fba9a32d8f71b9622855bf798047f92314" translate="yes" xml:space="preserve">
          <source>The rule of three</source>
          <target state="translated">Правило трех</target>
        </trans-unit>
        <trans-unit id="36c8d8c036bb8fe797cb958ace9878b1d9f0a216" translate="yes" xml:space="preserve">
          <source>The rule of zero</source>
          <target state="translated">Правило обнуления</target>
        </trans-unit>
        <trans-unit id="a903fdf03fcab0513e11024031b16c3545e6f802" translate="yes" xml:space="preserve">
          <source>There are quick examples:</source>
          <target state="translated">Есть быстрые примеры:</target>
        </trans-unit>
        <trans-unit id="3cd542f7977cffdfdc31953ce90697e0b2617148" translate="yes" xml:space="preserve">
          <source>Therefore, you write a copy constructor so that it allocates new objects their own pieces of memory to destroy.</source>
          <target state="translated">Поэтому вы пишете конструктор копирования так,чтобы он выделял новым объектам собственные куски памяти для уничтожения.</target>
        </trans-unit>
        <trans-unit id="f8798170a9a6651fb0a4c954205b28e6e3af390f" translate="yes" xml:space="preserve">
          <source>This also takes care of self-assignment without an explicit check.
An even more robust solution to this problem is the &lt;a href=&quot;https://stackoverflow.com/questions/3279543/&quot;&gt;copy-and-swap idiom&lt;/a&gt;,
but I will not go into the details of exception safety here.
I only mentioned exceptions to make the following point: &lt;strong&gt;Writing classes that manage resources is hard.&lt;/strong&gt;</source>
          <target state="translated">Это также заботится о самостоятельном назначении без явной проверки. Еще более надежное решение этой проблемы - &lt;a href=&quot;https://stackoverflow.com/questions/3279543/&quot;&gt;идиома копирования и обмена&lt;/a&gt; , но я не буду вдаваться в детали безопасности исключений здесь. Я упомянул только исключения, чтобы подчеркнуть следующее: &lt;strong&gt;писать классы, которые управляют ресурсами, сложно.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27b40563b27907a9f057f675f3f37fd6000ad1ac" translate="yes" xml:space="preserve">
          <source>This means that the new object and the old object will be pointing at the same piece of memory so when you change it in one object it will be changed for the other objerct too.  If one object deletes this memory the other will carry on trying to use it - eek.</source>
          <target state="translated">Это означает,что новый объект и старый объект будут указывать на один и тот же участок памяти,поэтому при изменении в одном объекте он будет изменен и на другой объект.Если один объект удалит эту память,то другой продолжит пытаться ее использовать-eek.</target>
        </trans-unit>
        <trans-unit id="802dfeceb89576282efc5b61a8af1d0cdbcc4a26" translate="yes" xml:space="preserve">
          <source>To resolve this you write your own version of the copy constructor and assignment operator.  Your versions allocate separate memory to the new objects and copy across the values that the first pointer is pointing to rather than its address.</source>
          <target state="translated">Для решения этой проблемы вы пишете свою собственную версию конструктора копирования и оператора присваивания.Ваши версии выделяют отдельную память новым объектам и копируют через значения,на которые указывает первый указатель,а не его адрес.</target>
        </trans-unit>
        <trans-unit id="6c910658e0d85611554b78b95cba5500416e1e24" translate="yes" xml:space="preserve">
          <source>Unfortunately, this solution will fail if &lt;code&gt;new char[...]&lt;/code&gt; throws an exception due to memory exhaustion.
One possible solution is to introduce a local variable and reorder the statements:</source>
          <target state="translated">К сожалению, это решение не сработает, если &lt;code&gt;new char[...]&lt;/code&gt; вызовет исключение из-за исчерпания памяти. Одно из возможных решений - ввести локальную переменную и изменить порядок операторов:</target>
        </trans-unit>
        <trans-unit id="dce3694d3e97fbbf21e3bbef551abea96907eb47" translate="yes" xml:space="preserve">
          <source>What are the &lt;em&gt;copy constructor&lt;/em&gt; and the &lt;em&gt;copy assignment operator&lt;/em&gt;?</source>
          <target state="translated">Что такое &lt;em&gt;конструктор&lt;/em&gt; &lt;em&gt;копирования и оператор присваивания копии&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="d284fc80dc776543cde9d354bdfabe8024285a6b" translate="yes" xml:space="preserve">
          <source>What are the copy constructor and the copy assignment operator?
I have already used them above.  The copy constructor is called when you type code such as &lt;code&gt;Car car2 = car1;&lt;/code&gt;  Essentially if you declare a variable and assign it in one line, that's when the copy constructor is called.  The assignment operator is what happens when you use an equal sign--&lt;code&gt;car2 = car1;&lt;/code&gt;.  Notice &lt;code&gt;car2&lt;/code&gt; isn't declared in the same statement.  The two chunks of code you write for these operations are likely very similar.  In fact the typical design pattern has another function you call to set everything once you're satisfied the initial copy/assignment is legitimate--if you look at the longhand code I wrote, the functions are nearly identical.</source>
          <target state="translated">Что такое конструктор копирования и оператор присваивания копии? Я уже использовал их выше. Конструктор копирования вызывается при вводе кода, такого как &lt;code&gt;Car car2 = car1;&lt;/code&gt; По сути, если вы объявляете переменную и присваиваете ей одну строку, тогда вызывается конструктор копирования. Оператор присваивания - это то, что происходит, когда вы используете знак равенства - car2 &lt;code&gt;car2 = car1;&lt;/code&gt; , Обратите внимание, что &lt;code&gt;car2&lt;/code&gt; не объявлено в том же заявлении. Две части кода, которые вы пишете для этих операций, вероятно, очень похожи. На самом деле типичный шаблон проектирования имеет другую функцию, которую вы вызываете, чтобы установить все, как только вы убедитесь, что первоначальное копирование / присвоение является законным - если вы посмотрите на написанный мной от руки код, функции почти идентичны.</target>
        </trans-unit>
        <trans-unit id="2e18f7284f77f3d90b9ec0f927d31ea3e9dd4931" translate="yes" xml:space="preserve">
          <source>What does &lt;em&gt;copying an object&lt;/em&gt; mean?</source>
          <target state="translated">Что означает &lt;em&gt;копирование объекта&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="e314a085c799aa51bc02f6c5e796a58203d1aa5f" translate="yes" xml:space="preserve">
          <source>What does copying an object mean? 
There are a few ways you can copy objects--let's talk about the 2 kinds you're most likely referring to--deep copy and shallow copy.</source>
          <target state="translated">Что означает копирование объекта? Есть несколько способов копирования объектов-давайте поговорим о двух видах,которые вы,скорее всего,имеете в виду-глубокое копирование и поверхностное копирование.</target>
        </trans-unit>
        <trans-unit id="18288f95e467e5d08ac50a74ac3a5f64d0b646f6" translate="yes" xml:space="preserve">
          <source>What does it mean to copy a &lt;code&gt;person&lt;/code&gt; object?
The &lt;code&gt;main&lt;/code&gt; function shows two distinct copying scenarios.
The initialization &lt;code&gt;person b(a);&lt;/code&gt; is performed by the &lt;em&gt;copy constructor&lt;/em&gt;.
Its job is to construct a fresh object based on the state of an existing object.
The assignment &lt;code&gt;b = a&lt;/code&gt; is performed by the &lt;em&gt;copy assignment operator&lt;/em&gt;.
Its job is generally a little more complicated,
because the target object is already in some valid state that needs to be dealt with.</source>
          <target state="translated">Что значит скопировать объект &lt;code&gt;person&lt;/code&gt; ? &lt;code&gt;main&lt;/code&gt; функция показывает два разных сценария копирования. Инициализация &lt;code&gt;person b(a);&lt;/code&gt; выполняется &lt;em&gt;конструктором копирования&lt;/em&gt; . Его работа заключается в создании нового объекта на основе состояния существующего объекта. Назначение &lt;code&gt;b = a&lt;/code&gt; выполняется оператором &lt;em&gt;копирования&lt;/em&gt; . Его работа обычно немного сложнее, потому что целевой объект уже находится в каком-то допустимом состоянии, с которым нужно иметь дело.</target>
        </trans-unit>
        <trans-unit id="525369d9ad8d90cf2e824a3d03f0e647b6245a31" translate="yes" xml:space="preserve">
          <source>What is The Rule of Three</source>
          <target state="translated">Что такое правило трех</target>
        </trans-unit>
        <trans-unit id="9326d3d974cf129180db9fb54ae9fe50c11558bc" translate="yes" xml:space="preserve">
          <source>When do I need to declare them myself?</source>
          <target state="translated">Когда я должен сам их объявить?</target>
        </trans-unit>
        <trans-unit id="2b4d3c03212efec5704293148396f064cc3fa772" translate="yes" xml:space="preserve">
          <source>When do I need to declare them myself? 
If you are not writing code that is to be shared or for production in some manner, you really only need to declare them when you need them.  You do need to be aware of what your program language does if you choose to use it 'by accident' and didn't make one--i.e. you get the compiler default.  I rarely use copy constructors for instance, but assignment operator overrides are very common.  Did you know you can override what addition, subtraction, etc. mean as well?</source>
          <target state="translated">Когда я должен сам их объявить? Если вы не пишете код,который должен быть распространен или для производства каким-то образом,вам действительно нужно объявлять их только тогда,когда они вам нужны.Вам действительно нужно знать,что делает ваш язык программы,если вы решили использовать его 'случайно' и не сделали его 'случайно'-т.е.вы получаете компилятор по умолчанию.Я редко использую,например,конструкторы копирования,но переопределения операторов присваивания встречаются очень часто.Знаете ли Вы,что можно переопределить и то,что означают сложение,вычитание и т.д.?</target>
        </trans-unit>
        <trans-unit id="b0748a17383e0d0183f82f7af89a83b5c48c0592" translate="yes" xml:space="preserve">
          <source>You allocated memory in your constructor and so you need to write a destructor to delete it.  Otherwise you will cause a memory leak.</source>
          <target state="translated">Вы выделили память в конструкторе,поэтому для ее удаления необходимо записать деструктор.Иначе произойдет утечка памяти.</target>
        </trans-unit>
        <trans-unit id="f35591d3af737f6da366aa57fe0c8a3cec3ebd05" translate="yes" xml:space="preserve">
          <source>You allocated memory in your constructor to a member pointer of your class.  When you copy an object of this class the default assignment operator and copy constructor will copy the value of this member pointer to the new object.</source>
          <target state="translated">Вы выделили память в конструкторе указателю на член вашего класса.При копировании объекта этого класса оператор присваивания по умолчанию и конструктор копирования скопируют значение указателя этого члена в новый объект.</target>
        </trans-unit>
        <trans-unit id="d665236b12b323d034f1a59d0be9b78aa4a45839" translate="yes" xml:space="preserve">
          <source>You might think that this is job done.</source>
          <target state="translated">Ты можешь подумать,что это работа.</target>
        </trans-unit>
        <trans-unit id="4245c721abbc6eb77fa44f3f4a16ff9787771472" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;copy constructor&lt;/strong&gt;,</source>
          <target state="translated">&lt;strong&gt;конструктор копирования&lt;/strong&gt; ,</target>
        </trans-unit>
        <trans-unit id="a251f0e395aad7bbb837ca31dc8c54f763926c32" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;assignment operator&lt;/strong&gt;,</source>
          <target state="translated">&lt;strong&gt;оператор присваивания&lt;/strong&gt; ,</target>
        </trans-unit>
        <trans-unit id="1af3319531cdc9d080e124c289ad057aefd0cc4c" translate="yes" xml:space="preserve">
          <source>copy assignment operator</source>
          <target state="translated">оператор копирования</target>
        </trans-unit>
        <trans-unit id="183ecfccbbd2d4096ad1d48b49c8f24046ebf9c1" translate="yes" xml:space="preserve">
          <source>copy constructor</source>
          <target state="translated">копировальный конструктор</target>
        </trans-unit>
        <trans-unit id="8bc5b477b47fc9df65f37bbb8cb4a49ff6fe6dec" translate="yes" xml:space="preserve">
          <source>defined explictly, then it is likely to need &lt;strong&gt;all three of them&lt;/strong&gt;.</source>
          <target state="translated">определяется точно, тогда, вероятно, понадобятся &lt;strong&gt;все три из них&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="867e8ce6dcd7e9c598e666c812691b0cff661d7c" translate="yes" xml:space="preserve">
          <source>destructor</source>
          <target state="translated">destructor</target>
        </trans-unit>
        <trans-unit id="6813b0bf4b910cdeab71fd38315eaad01f7becab" translate="yes" xml:space="preserve">
          <source>or a &lt;strong&gt;destructor&lt;/strong&gt;,</source>
          <target state="translated">или &lt;strong&gt;деструктор&lt;/strong&gt; ,</target>
        </trans-unit>
        <trans-unit id="63ac133f749caa7f0c542633b2a3bf7831b595d0" translate="yes" xml:space="preserve">
          <source>the class destructor would also be participating in management of the resource (usually releasing it). The classic resource to be managed was memory, and this is why all Standard Library classes that
manage memory (e.g., the STL containers that perform dynamic memory management) all declare &amp;ldquo;the big three&amp;rdquo;: both copy operations and a destructor.</source>
          <target state="translated">деструктор класса также будет участвовать в управлении ресурсом (обычно освобождая его). Классическим ресурсом, которым нужно управлять, была память, и именно поэтому все классы стандартной библиотеки, которые управляют памятью (например, контейнеры STL, которые выполняют динамическое управление памятью), объявляют &amp;laquo;большую тройку&amp;raquo;: и операции копирования, и деструктор.</target>
        </trans-unit>
        <trans-unit id="b6b9dbf4312ced3cbd7237155947344baf0a01a7" translate="yes" xml:space="preserve">
          <source>then you should declare all three. It grew out of the observation that the need to take over the meaning of a copy operation almost always stemmed from the class performing some kind of resource management, and that almost always implied that</source>
          <target state="translated">тогда тебе следует объявить все три.Это выросло из наблюдения,что необходимость взять на себя значение операции копирования почти всегда вытекала из класса,выполняющего какое-то управление ресурсами,и это почти всегда подразумевало,что</target>
        </trans-unit>
        <trans-unit id="7ceae16642af9c2edc08b7ed1a5862ae8d9cf4a9" translate="yes" xml:space="preserve">
          <source>whatever resource management was being done in one copy operation probably needed to be done in the other copy operation and</source>
          <target state="translated">какое бы управление ресурсами ни осуществлялось в одной операции копирования,вероятно,нужно было сделать в другой операции копирования и</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
