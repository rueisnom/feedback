<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4181703">
    <body>
      <group id="4181703">
        <trans-unit id="4bd1d3cc3136e5c3d71fc0745b3d07eb11921ec2" translate="yes" xml:space="preserve">
          <source>(Because I am frugal, I will only use two variables &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; and then re-use the same in the whole answer. ;-)</source>
          <target state="translated">(나는 검소하기 때문에 두 개의 변수 &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 만 사용하고 전체 대답에서 동일하게 재사용합니다. ;-)</target>
        </trans-unit>
        <trans-unit id="3ed780fbe42c35c04706582604649e133dadc0e5" translate="yes" xml:space="preserve">
          <source>(NOTE: &lt;code&gt;date&lt;/code&gt; on macOS does not offer nanoseconds, so this must be done on Linux.)</source>
          <target state="translated">(참고 : macOS의 &lt;code&gt;date&lt;/code&gt; 는 나노초를 제공하지 않으므로 Linux에서 수행해야합니다.)</target>
        </trans-unit>
        <trans-unit id="adcf7ac4dae866aa597be61d4bc723836b15d956" translate="yes" xml:space="preserve">
          <source>...and yet yet another one.</source>
          <target state="translated">... 그리고 아직 또 하나.</target>
        </trans-unit>
        <trans-unit id="b41db4deb31715bf7bf36e52424cf9ce6795750e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+=&lt;/code&gt; is better from a performance standpoint if a big string is being constructed in small increments, especially in a loop</source>
          <target state="translated">큰 문자열이 작은 증가로, 특히 루프에서 구성되는 경우 성능 관점에서 &lt;code&gt;+=&lt;/code&gt; 가 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5af36a2e7e39d199453ed1d4361dacec96231975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+=&lt;/code&gt;: Append to variable</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; : 변수에 추가</target>
        </trans-unit>
        <trans-unit id="05d6df9d483a7b6d16a3f29398d269a5e619edc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf&lt;/code&gt;: Re-construct variable using the &lt;em&gt;builtin&lt;/em&gt; command</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; : &lt;em&gt;내장&lt;/em&gt; 명령을 사용하여 변수 재구성</target>
        </trans-unit>
        <trans-unit id="92340b09e3176c06e36dd2e613d7b3008da8067c" translate="yes" xml:space="preserve">
          <source>A few notes:</source>
          <target state="translated">몇 가지 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="a84621f46f0fee168321d457ef3de65caadd50d9" translate="yes" xml:space="preserve">
          <source>Any script using this operator on older Bash versions will fail with a &quot;command not found&quot; error if you are lucky, or a &quot;syntax error near unexpected token&quot;.</source>
          <target state="translated">이전 Bash 버전에서이 연산자를 사용하는 스크립트는 운이 좋으면 &quot;명령을 찾을 수 없음&quot;오류 또는 &quot;예기치 않은 토큰 근처의 구문 오류&quot;와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f9ffbe9bae5466efe9eff1924bec37046780c4b9" translate="yes" xml:space="preserve">
          <source>Append to an array &lt;code&gt;var+=(...)&lt;/code&gt;</source>
          <target state="translated">배열에 추가 &lt;code&gt;var+=(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c917d872ad7580c1d2a82bb2b09f9cb7afd46a1f" translate="yes" xml:space="preserve">
          <source>Append to an integer &lt;code&gt;((var+=...))&lt;/code&gt;</source>
          <target state="translated">정수에 추가 &lt;code&gt;((var+=...))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87545afb385457472346e8c34f5e307d0ea09c7" translate="yes" xml:space="preserve">
          <source>Append to string &lt;code&gt;var+=...&lt;/code&gt;</source>
          <target state="translated">문자열에 추가 &lt;code&gt;var+=...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9019e62d634cc49064c4af923be91dc426a71d8e" translate="yes" xml:space="preserve">
          <source>As this question stand specifically for &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt;, my first part of the answer would present different ways of doing this properly:</source>
          <target state="translated">이 질문은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash 전용&lt;/a&gt; 이므로 답변의 첫 부분은 올바르게 수행하는 다른 방법을 제시합니다.</target>
        </trans-unit>
        <trans-unit id="45142948cb319477715fce1d34dcb1007fd42b92" translate="yes" xml:space="preserve">
          <source>Bash also supports a &lt;code&gt;+=&lt;/code&gt; operator as shown in this code:</source>
          <target state="translated">Bash는이 코드에 표시된대로 &lt;code&gt;+=&lt;/code&gt; 연산자도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6272217110d63d3314649dc98f68993b3f4fc25b" translate="yes" xml:space="preserve">
          <source>Bash first</source>
          <target state="translated">배쉬 먼저</target>
        </trans-unit>
        <trans-unit id="2b9b5a17640aba2390f955e194ba0c5459a7f8f8" translate="yes" xml:space="preserve">
          <source>BashFAQ/013 - How can I concatenate two variables?</source>
          <target state="translated">BashFAQ / 013-두 변수를 어떻게 연결합니까?</target>
        </trans-unit>
        <trans-unit id="99583553fb98177526bd20eae2a56b4038ac4e39" translate="yes" xml:space="preserve">
          <source>Basically</source>
          <target state="translated">Basically</target>
        </trans-unit>
        <trans-unit id="f047bd2fcec20f719e0562e02bb415076a2d577e" translate="yes" xml:space="preserve">
          <source>But this is not easy for &lt;em&gt;nesting&lt;/em&gt;:</source>
          <target state="translated">그러나 이것은 &lt;em&gt;중첩&lt;/em&gt; 하기 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87bd9427b02292d06a7de4d66383145cca8e6fbc" translate="yes" xml:space="preserve">
          <source>But you could simply do:</source>
          <target state="translated">그러나 당신은 단순히 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5f290d2b8034d7265ac5e9c5f19bfe9423cc6d4d" translate="yes" xml:space="preserve">
          <source>Curly brackets will fit to Continuous string usage:</source>
          <target state="translated">중괄호는 연속 문자열 사용에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d82948156c93a167a453437c93a3dfd57e09e8a9" translate="yes" xml:space="preserve">
          <source>Despite of the special operator, &lt;code&gt;+=&lt;/code&gt;, for concatenation, there is a simpler way to go:</source>
          <target state="translated">연결을위한 특수 연산자 &lt;code&gt;+=&lt;/code&gt; 에도 불구하고 더 간단한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="061fabe1a3aee116bd4d5460d512e6927c9604aa" translate="yes" xml:space="preserve">
          <source>Double quotes take an extra calculation time for interpretation of variables inside. Avoid it if possible.</source>
          <target state="translated">큰 따옴표는 내부 변수를 해석하는 데 추가 계산 시간이 걸립니다. 가능하면 피하십시오.</target>
        </trans-unit>
        <trans-unit id="33fcbe45dd33298fc2b3a8b03f45c79724aa9165" translate="yes" xml:space="preserve">
          <source>Even if the += operator is now permitted, it has been introduced in &lt;strong&gt;Bash 3.1&lt;/strong&gt; in 2004.</source>
          <target state="translated">+ = 연산자가 이제 허용 되더라도 2004 년 &lt;strong&gt;Bash 3.1&lt;/strong&gt; 에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="f6f431c6d1b83fdc76c20f5dbc1efe535d0f1ae4" translate="yes" xml:space="preserve">
          <source>For those who cares about backward compatibility, stick with the older standard Bash concatenation methods, like those mentioned in the chosen answer:</source>
          <target state="translated">이전 버전과의 호환성에 관심이있는 사용자는 선택한 답변에 언급 된 것과 같이 이전 표준 Bash 연결 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4b7550837fb71ce5dc516a85fe3ebea51669a90c" translate="yes" xml:space="preserve">
          <source>Formatted, using &lt;em&gt;forked&lt;/em&gt;&lt;code&gt;printf&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;포크 인쇄를&lt;/em&gt; 사용하여 형식화</target>
        </trans-unit>
        <trans-unit id="96c9a559e8db14c487dda610affda849531e73f2" translate="yes" xml:space="preserve">
          <source>Here is a concise summary of what most answers are talking about.</source>
          <target state="translated">다음은 대부분의 답변에 대한 간결한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="2248bd500c18170425820e91a0ef3024f446b852" translate="yes" xml:space="preserve">
          <source>Here is the one through &lt;a href=&quot;http://en.wikipedia.org/wiki/AWK&quot;&gt;AWK&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;http://en.wikipedia.org/wiki/AWK&quot;&gt;AWK를&lt;/a&gt; 통한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bfd7e226ecef699774482324a6b142aaa2c37d1b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;$foo&lt;/code&gt; becomes &quot;Hello World&quot;.</source>
          <target state="translated">여기서 &lt;code&gt;$foo&lt;/code&gt; 는 &quot;Hello World&quot;가됩니다.</target>
        </trans-unit>
        <trans-unit id="bc577f90688a74d1fc87891d866a16700187afd1" translate="yes" xml:space="preserve">
          <source>Historically, you could use &lt;em&gt;backticks&lt;/em&gt; for retrieving result of a &lt;em&gt;fork&lt;/em&gt;:</source>
          <target state="translated">역사적으로 &lt;em&gt;포크&lt;/em&gt; 결과를 검색하기 위해 &lt;em&gt;백틱&lt;/em&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e0e0a3dfcf33ed4acc9ce3503792e75ac7cf96b" translate="yes" xml:space="preserve">
          <source>Hmm.. &lt;a href=&quot;https://serverfault.com/a/208266/142978&quot;&gt;this is not a bug, but a feature&lt;/a&gt;... To prevent bash to try to develop &lt;code&gt;!&quot;&lt;/code&gt;, you could:</source>
          <target state="translated">흠 .. &lt;a href=&quot;https://serverfault.com/a/208266/142978&quot;&gt;이것은 버그가 아니라 기능입니다&lt;/a&gt; ... bash가 개발을 시도하지 못하게하려면 &lt;code&gt;!&quot;&lt;/code&gt; , 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="98589eda0b0c3350efeb7df609481a8612eef1f0" translate="yes" xml:space="preserve">
          <source>How is this accomplished in Bash?</source>
          <target state="translated">이것은 Bash에서 어떻게 성취됩니까?</target>
        </trans-unit>
        <trans-unit id="6a2e6f81fd6ac37d46c523c21beba38638180d0d" translate="yes" xml:space="preserve">
          <source>How to concatenate string variables in Bash</source>
          <target state="translated">Bash에서 문자열 변수를 연결하는 방법</target>
        </trans-unit>
        <trans-unit id="470f68da03b911ef6709722d3140d5a7814b314e" translate="yes" xml:space="preserve">
          <source>I do it this way when convenient: Use an inline command!</source>
          <target state="translated">편리 할 때 이렇게합니다 : 인라인 명령을 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="467721da41492e4bb81590c0bb56387ca9eeb51f" translate="yes" xml:space="preserve">
          <source>I don't know about PHP yet, but this works in Linux Bash. If you don't want to affect it to a variable, you could try this:</source>
          <target state="translated">아직 PHP에 대해 잘 모르지만 Linux Bash에서 작동합니다. 변수에 영향을 미치지 않으려면 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="2d5c981dbbad201f3bbc11b6fdacef1a2a28d7f9" translate="yes" xml:space="preserve">
          <source>I have created &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;append_test.sh on GitHub&lt;/a&gt; with the contents:</source>
          <target state="translated">내용 &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;으로 GitHub에 append_test.sh를&lt;/a&gt; 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="df60ad75b0491805267dfff61134960304cc8674" translate="yes" xml:space="preserve">
          <source>I kind of like making a quick function.</source>
          <target state="translated">나는 빠른 기능을 만드는 것을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="35816762d51684f0de91167ddbc3f78b49194000" translate="yes" xml:space="preserve">
          <source>I prefer to use curly brackets &lt;code&gt;${}&lt;/code&gt; for expanding variable in string:</source>
          <target state="translated">문자열에서 변수를 확장하기 위해 중괄호 &lt;code&gt;${}&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6515924b2fdbe8380a92f0af7780f9e61495663f" translate="yes" xml:space="preserve">
          <source>I wanted to build a string from a list. Couldn't find an answer for that so I post it here. Here is what I did:</source>
          <target state="translated">목록에서 문자열을 만들고 싶었습니다. 이에 대한 답변을 찾을 수 없으므로 여기에 게시하십시오. 여기 내가 한 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bff2a79b85772297cfcbaa68bb7b6557aa73dd0" translate="yes" xml:space="preserve">
          <source>If it is as your example of adding &lt;code&gt;&quot; World&quot;&lt;/code&gt; to the original string, then it can be:</source>
          <target state="translated">원래 문자열에 &lt;code&gt;&quot; World&quot;&lt;/code&gt; 를 추가 한 예라면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a150e41a394fe65e305a228a887924fcaf285ef" translate="yes" xml:space="preserve">
          <source>If what you are trying to do is to &lt;em&gt;split&lt;/em&gt; a string into several lines, you can use a backslash:</source>
          <target state="translated">문자열을 여러 줄로 나누려는 경우 백 슬래시를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d1bd98eba26b54d374352283f5c8effae6e1f03" translate="yes" xml:space="preserve">
          <source>If you try to concatenate a string with another string, for example,</source>
          <target state="translated">예를 들어, 문자열을 다른 문자열과 연결하려고하면</target>
        </trans-unit>
        <trans-unit id="2361bd2fbeb116748c047b41ff0d3f439612678a" translate="yes" xml:space="preserve">
          <source>If you want to append something like an underscore, use escape (\)</source>
          <target state="translated">밑줄과 같은 것을 추가하려면 이스케이프 (\)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1035e2881f6270ad0c3c2063687ee85e31e26ee" translate="yes" xml:space="preserve">
          <source>If you want to use more sophisticated constructions you have to use a &lt;em&gt;fork&lt;/em&gt; (new child process that make the job and return the result via &lt;code&gt;stdout&lt;/code&gt;):</source>
          <target state="translated">보다 정교한 구성을 사용하려면 &lt;em&gt;포크&lt;/em&gt; (작업을 만들고 &lt;code&gt;stdout&lt;/code&gt; 을 통해 결과를 리턴하는 새로운 하위 프로세스)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="11fe5aa37000e7af29a90564aa80284fb3a6ddf0" translate="yes" xml:space="preserve">
          <source>In PHP, strings are concatenated together as follows:</source>
          <target state="translated">PHP에서 문자열은 다음과 같이 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="6f39848fc3cad9f2f63ac3212b2dac4f68c4fd33" translate="yes" xml:space="preserve">
          <source>In general to concatenate two variables you can just write them one after another:</source>
          <target state="translated">일반적으로 두 변수를 연결하기 위해 하나씩 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9218f385063dd34e45700fe7ab2d28aa12027888" translate="yes" xml:space="preserve">
          <source>In my opinion, the simplest way to concatenate two strings is to write a function that does it for you, then use that function.</source>
          <target state="translated">제 생각에는 두 개의 문자열을 연결하는 가장 간단한 방법은 그것을 수행하는 함수를 작성한 다음 해당 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31a6c4cacbadbe7e6a8bd544cc7e65719fce7ab9" translate="yes" xml:space="preserve">
          <source>Let's say we have two variables and $1 is set to 'one':</source>
          <target state="translated">두 개의 변수가 있고 $ 1이 'one'으로 설정되어 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="7f532384aa967b5bdc460f66dd85df621b543f6b" translate="yes" xml:space="preserve">
          <source>Nota: The use of &lt;em&gt;double-quotes&lt;/em&gt; may be useful for manipulating strings that contain &lt;code&gt;spaces&lt;/code&gt;, &lt;code&gt;tabulations&lt;/code&gt; and/or &lt;code&gt;newlines&lt;/code&gt;</source>
          <target state="translated">참고 : &lt;em&gt;큰 따옴표를&lt;/em&gt; 사용하면 &lt;code&gt;spaces&lt;/code&gt; , &lt;code&gt;tabulations&lt;/code&gt; 및 / 또는 줄 &lt;code&gt;newlines&lt;/code&gt; 이 포함 된 문자열을 조작하는 데 유용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="16d9f74c5071b2a7b73caf5323062bbf69de994d" translate="yes" xml:space="preserve">
          <source>Note that between parentheses, there is a &lt;em&gt;space separated array&lt;/em&gt;. If you want to store a string containing spaces in your array, you have to enclose them:</source>
          <target state="translated">괄호 사이에는 &lt;em&gt;공백으로 구분 된 배열이&lt;/em&gt; 있습니다. 배열에 공백이 포함 된 문자열을 저장하려면 공백을 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="d75948a16a0e3e8f5f2e46c92ff7994f3218bd45" translate="yes" xml:space="preserve">
          <source>Note that our &lt;code&gt;a&lt;/code&gt; is still an array! Only first element is changed!</source>
          <target state="translated">우리의 배열은 여전히 ​​배열입니다! 첫 번째 요소 만 변경되었습니다!</target>
        </trans-unit>
        <trans-unit id="43fddc7b23f4c7838d65564a074aee691c438546" translate="yes" xml:space="preserve">
          <source>Note that this won't work</source>
          <target state="translated">이 작동하지 않습니다</target>
        </trans-unit>
        <trans-unit id="8a4844dda52f0c26f5af432efbb40409bda7cde9" translate="yes" xml:space="preserve">
          <source>One argument format string with many argument passed to:</source>
          <target state="translated">많은 인수가 전달 된 하나의 인수 형식 문자열 :</target>
        </trans-unit>
        <trans-unit id="36660cb47e775732843ecb2655cd60434aa3f239" translate="yes" xml:space="preserve">
          <source>Or we could use &lt;em&gt;one argument format string&lt;/em&gt; which will be repeated as many argument submitted...</source>
          <target state="translated">또는 우리는 &lt;em&gt;하나의 인수 형식 문자열&lt;/em&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="279f60bf9a525240c46a2d3699489765843259f7" translate="yes" xml:space="preserve">
          <source>Otherwise using &lt;code&gt;foo = &quot;$fooWorld&quot;&lt;/code&gt; will not work.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;foo = &quot;$fooWorld&quot;&lt;/code&gt; 이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9f0b837f6b79e52ab2a34a74f68668672128a4a" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;a&lt;/code&gt; is also an array of only one element.</source>
          <target state="translated">우리는 또한 하나의 요소의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="1771e4c9acf6dde706b3b7fa5860621248195877" translate="yes" xml:space="preserve">
          <source>PREFIX_HELLO_WORLD</source>
          <target state="translated">PREFIX_HELLO_WORLD</target>
        </trans-unit>
        <trans-unit id="87eb592b096fe1bc9286f71d12faf9a6552a868a" translate="yes" xml:space="preserve">
          <source>PREFIX_WORLD</source>
          <target state="translated">PREFIX_WORLD</target>
        </trans-unit>
        <trans-unit id="dee69127295d004ceef94bf9e5bdab008cf2d5ec" translate="yes" xml:space="preserve">
          <source>Plus take a look at other answer about &lt;strong&gt;+=&lt;/strong&gt;</source>
          <target state="translated">또한 &lt;strong&gt;+ =&lt;/strong&gt; 에 대한 다른 답변을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="719ac2e5ed17645b278921f59e179e7c8f800769" translate="yes" xml:space="preserve">
          <source>Safer way:</source>
          <target state="translated">더 안전한 방법 :</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="8667cec4c6c0a55f3f90079fdd67283ecb218068" translate="yes" xml:space="preserve">
          <source>Shell now</source>
          <target state="translated">지금 쉘</target>
        </trans-unit>
        <trans-unit id="53517aeaf2261fd62cf086622d3b029b513c0d37" translate="yes" xml:space="preserve">
          <source>So to retrieve our seven field array, we only need to re-set 1st element:</source>
          <target state="translated">따라서 7 개의 필드 배열을 검색하려면 첫 번째 요소 만 재설정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="27289f5e2e72d52b42f56975a352ef1503ab370e" translate="yes" xml:space="preserve">
          <source>Strings containing spaces can become part of command, use &quot;$XXX&quot; and &quot;${XXX}&quot; to avoid these errors.</source>
          <target state="translated">공백이 포함 된 문자열은 명령의 일부가 될 수 있습니다. 이러한 오류를 피하려면 &quot;$ XXX&quot;및 &quot;$ {XXX}&quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc55bd621afd18d3f9e08f2edf48af5bb50f5e1a" translate="yes" xml:space="preserve">
          <source>Test 1:</source>
          <target state="translated">시험 1 :</target>
        </trans-unit>
        <trans-unit id="159b00a4fd6d920b86d8b7523b32be7f6b1a3f8c" translate="yes" xml:space="preserve">
          <source>Test 2:</source>
          <target state="translated">시험 2 :</target>
        </trans-unit>
        <trans-unit id="32b1cd28de4997ecac10988388a3c6f27f1f4e0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;printf&lt;/code&gt;&lt;em&gt;builtin&lt;/em&gt; command gives a powerful way of drawing string format. As this is a Bash &lt;em&gt;builtin&lt;/em&gt;, there is a option for sending formatted string to a variable instead of printing on &lt;code&gt;stdout&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; &lt;em&gt;내장&lt;/em&gt; 명령은 문자열 형식을 그리는 강력한 방법을 제공합니다. 이것은 Bash &lt;em&gt;내장&lt;/em&gt; 이므로 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄하는 대신 형식이 지정된 문자열을 변수로 보내는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83e416ba1eaa9a4279e3d3c10315ea18cd865fb5" translate="yes" xml:space="preserve">
          <source>The errors indicate that my Bash got up to &lt;strong&gt;335.54432 MB&lt;/strong&gt; before it crashed. You could change &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;the code&lt;/a&gt; from doubling the data to appending a constant to get a more granular graph and failure point. But I think this should give you enough information to decide whether you care. Personally, below 100&amp;nbsp;MB I don't. Your mileage may vary.</source>
          <target state="translated">오류는 내 Bash가 충돌하기 전에 최대 &lt;strong&gt;335.54432MB&lt;/strong&gt; 를 &lt;strong&gt;얻었음을&lt;/strong&gt; 나타냅니다. 더 세분화 된 그래프와 실패 지점을 얻기 위해 &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;코드&lt;/a&gt; 를 데이터 배가에서 상수 추가로 변경할 수 있습니다. 그러나 이것이 귀하의 관심 여부를 결정하기에 충분한 정보를 제공해야한다고 생각합니다. 개인적으로 100MB 미만은 아닙니다. 귀하의 마일리지가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">출력 :</target>
        </trans-unit>
        <trans-unit id="69bb31328df0691de52625b07666156e1b902430" translate="yes" xml:space="preserve">
          <source>The simplest way with quotation marks:</source>
          <target state="translated">따옴표가있는 가장 간단한 방법 :</target>
        </trans-unit>
        <trans-unit id="2ad5c63cc2c6ab78b38fc26f2339035fd0e19592" translate="yes" xml:space="preserve">
          <source>The syntax &lt;strong&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/strong&gt; may be used in different ways:</source>
          <target state="translated">구문 &lt;strong&gt; &lt;code&gt;+=&lt;/code&gt; &lt;/strong&gt; 는 다른 방식으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd691a88ea59ef340905ac53356df5effe747fd" translate="yes" xml:space="preserve">
          <source>The table below explains the different contexts where we can combine the values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to create a new variable, &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">아래 표는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 값을 결합하여 새 변수 &lt;code&gt;c&lt;/code&gt; 를 생성 할 수있는 다양한 컨텍스트를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2c3e52ae28a38ff578be8e3e7dbfc958d04c64ce" translate="yes" xml:space="preserve">
          <source>The way I'd solve the problem is just</source>
          <target state="translated">문제를 해결하는 방법은</target>
        </trans-unit>
        <trans-unit id="94dea865f36eb2a17a49ec7744c9cd0003e14d92" translate="yes" xml:space="preserve">
          <source>There are seven &lt;em&gt;strings&lt;/em&gt; in this array. So we could build a formatted string containing exactly seven positional arguments:</source>
          <target state="translated">이 배열에는 7 개의 &lt;em&gt;문자열&lt;/em&gt; 이 있습니다. 따라서 정확히 7 개의 위치 인수를 포함하는 형식화 된 문자열을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb165be54b165d1c959a0c982060f22f1aa1c925" translate="yes" xml:space="preserve">
          <source>There are voiced concerns about performance, but no data is offered. Let me suggest a simple test.</source>
          <target state="translated">성능에 대한 우려가 있지만 데이터가 제공되지 않습니다. 간단한 테스트를 제안하겠습니다.</target>
        </trans-unit>
        <trans-unit id="369a75e97f318d6ec145a9493109e6364a6829ed" translate="yes" xml:space="preserve">
          <source>There's one particular case where you should take care:</source>
          <target state="translated">주의해야 할 특별한 경우가 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c3c35a74ab1ce4bc2031b207d811e22c1c07906" translate="yes" xml:space="preserve">
          <source>This does &lt;em&gt;not&lt;/em&gt; work:</source>
          <target state="translated">작동하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cb780e8eb924fadf79808d44840abbcd92d1563a" translate="yes" xml:space="preserve">
          <source>This is an example of a Bash script:</source>
          <target state="translated">이것은 Bash 스크립트의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e188f83fdefc6603d01c6584f28c5195768dd202" translate="yes" xml:space="preserve">
          <source>This is how you concatenate two strings.</source>
          <target state="translated">이것이 두 문자열을 연결하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="db44249067683e4ab33834a42f5d074a526ab936" translate="yes" xml:space="preserve">
          <source>This is useful when 
    &lt;code&gt;$blaohai&lt;/code&gt;
leads to a variable not found error. Or if you have spaces or other special characters in your strings. &lt;code&gt;&quot;${foo}&quot;&lt;/code&gt; properly escapes anything you put into it.</source>
          <target state="translated">이것은 &lt;code&gt;$blaohai&lt;/code&gt; 가 변수를 찾을 수 없음 오류로 이어질 때 유용합니다. 또는 문자열에 공백이나 다른 특수 문자가있는 경우. &lt;code&gt;&quot;${foo}&quot;&lt;/code&gt; 올바르게 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="bbfed531f3c8084ebfdf51e489df479d5e845d35" translate="yes" xml:space="preserve">
          <source>This last statement would print &quot;OpenSystems&quot; (without quotes).</source>
          <target state="translated">이 마지막 문장은 &quot;OpenSystems&quot;를 따옴표없이 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6c47bc5f898e5e62e29dd7dfd964d007a17d9276" translate="yes" xml:space="preserve">
          <source>This one also adds only one space in between:</source>
          <target state="translated">이것은 또한 사이에 하나의 공백 만 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e4bf4a51ac667b923a2a205a96f6bee4239bd03f" translate="yes" xml:space="preserve">
          <source>This works fine:</source>
          <target state="translated">이것은 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d32a8bbfc3e779ddecfadcd682d49cd50e5db2c0" translate="yes" xml:space="preserve">
          <source>Under &lt;em&gt;POSIX&lt;/em&gt; shell, you could not use &lt;em&gt;bashisms&lt;/em&gt;, so there is no &lt;em&gt;builtin&lt;/em&gt;&lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;POSIX&lt;/em&gt; 쉘에서 &lt;em&gt;bashisms를&lt;/em&gt; 사용할 수 없으므로 &lt;em&gt;내장&lt;/em&gt; &lt;code&gt;printf&lt;/code&gt; 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a3d7e2f61e8f32a1ae973fc94bb4197e186095d4" translate="yes" xml:space="preserve">
          <source>Under bash, when you access a variable name without specifying index, you always address first element only!</source>
          <target state="translated">bash에서 index를 지정하지 않고 변수 이름에 액세스하면 항상 첫 번째 요소 만 처리합니다!</target>
        </trans-unit>
        <trans-unit id="ea6508f50790e35b9b9d80ac7edc335be5414591" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;Stack&amp;nbsp;Overflow question&lt;/em&gt; syntax,</source>
          <target state="translated">&lt;em&gt;스택 오버플로 질문&lt;/em&gt; 구문을 사용하여</target>
        </trans-unit>
        <trans-unit id="9a2da18a7bf535275c4e7f972fa322a4ed255d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;Stack&amp;nbsp;Overflow question&lt;/em&gt; syntax:</source>
          <target state="translated">&lt;em&gt;스택 오버플로 질문&lt;/em&gt; 구문 사용 :</target>
        </trans-unit>
        <trans-unit id="6d868372db567c7c4882189257fe82c1fd3bf18c" translate="yes" xml:space="preserve">
          <source>When do we need curly braces around shell variables?</source>
          <target state="translated">쉘 변수 주위에 중괄호가 필요할 때</target>
        </trans-unit>
        <trans-unit id="e012bd2854254580514f478d3bb60e50df1d66cc" translate="yes" xml:space="preserve">
          <source>Will output</source>
          <target state="translated">출력</target>
        </trans-unit>
        <trans-unit id="ab40238dc123ed0ec7be782ed27a673ceb626a15" translate="yes" xml:space="preserve">
          <source>Will output &lt;code&gt;&quot;daniel&quot;san&lt;/code&gt;, and not &lt;code&gt;danielsan&lt;/code&gt;, as you might have wanted.
In this case you should do instead:</source>
          <target state="translated">원하는대로 &lt;code&gt;danielsan&lt;/code&gt; 이 아닌 &lt;code&gt;&quot;daniel&quot;san&lt;/code&gt; 을 출력합니다. 이 경우 대신 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fd90e44035bd17dbb78c97fbba80096c6263b8f" translate="yes" xml:space="preserve">
          <source>With one space in between:</source>
          <target state="translated">사이에 공백이 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="871e01daf406c1892151bd181c141d675e07320c" translate="yes" xml:space="preserve">
          <source>Yet another approach...</source>
          <target state="translated">또 다른 접근법은 ...</target>
        </trans-unit>
        <trans-unit id="91a638bb31ee9ad130888c9815b0119d9a453d13" translate="yes" xml:space="preserve">
          <source>Yet another way to skin a cat. This time with functions :D</source>
          <target state="translated">고양이를 피부에 바르는 또 다른 방법. 이번에는 기능 : D</target>
        </trans-unit>
        <trans-unit id="a531591bd4aed429a40efdf39f39312ef690fdb1" translate="yes" xml:space="preserve">
          <source>You can concatenate without the quotes. Here is an example:</source>
          <target state="translated">따옴표없이 연결할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5eaa802aaf4ac75bd51f813943445b77cbe195d2" translate="yes" xml:space="preserve">
          <source>You can do this too:</source>
          <target state="translated">당신도 이것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f70be73d85ba20f8535d6dc5a4206127dab6911b" translate="yes" xml:space="preserve">
          <source>You could place another variable instead of 'Hello' or '!'. You could concatenate more strings as well.</source>
          <target state="translated">'Hello'또는 '!'대신 다른 변수를 배치 할 수 있습니다. 더 많은 문자열을 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="03feafa4ae5e8e1034dce509446863cdba708ae9" translate="yes" xml:space="preserve">
          <source>and leave you with the correct output:</source>
          <target state="translated">올바른 출력으로 남겨 두십시오.</target>
        </trans-unit>
        <trans-unit id="6f3d898257f79b02115e3a52c1801572d3ccc37b" translate="yes" xml:space="preserve">
          <source>and then I get the following output:</source>
          <target state="translated">그런 다음 다음 출력을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="593869f5e8a639ef50d6fe708ad32edfd44b98b6" translate="yes" xml:space="preserve">
          <source>as it seems to drop $foo and leaves you with:</source>
          <target state="translated">$ foo를 삭제하고 다음과 같이 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="18bcac79b4f2aea5ef8ea43f5cd9dd51430ac264" translate="yes" xml:space="preserve">
          <source>but this will work:</source>
          <target state="translated">그러나 이것은 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="10bc1ec735f3b6de29cdc0b026e11da078fbc1e9" translate="yes" xml:space="preserve">
          <source>doesn't work, as you may imagine, but</source>
          <target state="translated">당신이 상상할 수 있듯이 작동하지 않지만</target>
        </trans-unit>
        <trans-unit id="fe180a4775ec9b1876f8b66bc4797517bdc706b5" translate="yes" xml:space="preserve">
          <source>enclosing the RHS of an assignment in double quotes is generally a good practice, though it is quite optional in many cases</source>
          <target state="translated">과제의 RHS를 큰 따옴표로 묶는 것은 일반적으로 좋은 방법이지만 많은 경우에 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="24c5fb14936b7b8d27e72e207aca33e4a45b11f8" translate="yes" xml:space="preserve">
          <source>produces</source>
          <target state="translated">produces</target>
        </trans-unit>
        <trans-unit id="5add484b1702a015606da5a23c555e6fdee149ba" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;echo &quot;$c&quot;&lt;/code&gt; will produce</source>
          <target state="translated">그런 다음 &lt;code&gt;echo &quot;$c&quot;&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="005d2e406282bfd4d7072659be8cf45340dc43df" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;{}&lt;/code&gt; around variable names to disambiguate their expansion (as in row 2 in the table above). As seen on rows 3 and 4, there is no need for &lt;code&gt;{}&lt;/code&gt; unless a variable is being concatenated with a string that starts with a character that is a valid first character in shell variable name, that is alphabet or underscore.</source>
          <target state="translated">변수 이름 주위에 &lt;code&gt;{}&lt;/code&gt; 를 사용하여 확장을 명확하게하십시오 (위 표의 2 행에서와 같이). 3 행과 4 행에서 볼 수 있듯이, 변수가 쉘 변수 이름의 유효한 첫 문자 (알파벳 또는 밑줄)로 시작하는 문자열과 연결되지 않는 한 &lt;code&gt;{}&lt;/code&gt; 이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="909e4fadfd532cc1d7b59d2485174ef44672a5ec" translate="yes" xml:space="preserve">
          <source>variable &lt;code&gt;a&lt;/code&gt; is a string, but also an integer</source>
          <target state="translated">변수 &lt;code&gt;a&lt;/code&gt; 는 문자열이지만 정수</target>
        </trans-unit>
        <trans-unit id="92e8237524405cfe4179e596467c9268495494d5" translate="yes" xml:space="preserve">
          <source>which produces</source>
          <target state="translated">어떤 생산</target>
        </trans-unit>
        <trans-unit id="325bac1115922b539b20a947c68348d86ae1e4e3" translate="yes" xml:space="preserve">
          <source>with an extra space.</source>
          <target state="translated">여분의 공간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fde63634acbe4ff5f906859e13d40c19d4eeb787" translate="yes" xml:space="preserve">
          <source>with backticks, you have to escape inner forks with &lt;em&gt;backslashes&lt;/em&gt;:</source>
          <target state="translated">백틱으로 &lt;em&gt;백 슬래시로&lt;/em&gt; 내부 포크를 탈출 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="12fb46f3c161e46bb95ce405273979b44a2caf5e" translate="yes" xml:space="preserve">
          <source>works fine!</source>
          <target state="translated">잘 작동합니다!</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
