<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4181703">
    <body>
      <group id="4181703">
        <trans-unit id="4bd1d3cc3136e5c3d71fc0745b3d07eb11921ec2" translate="yes" xml:space="preserve">
          <source>(Because I am frugal, I will only use two variables &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; and then re-use the same in the whole answer. ;-)</source>
          <target state="translated">（因为我很节俭，所以我将只使用两个变量 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; ，然后在整个答案中重新使用相同的变量。</target>
        </trans-unit>
        <trans-unit id="3ed780fbe42c35c04706582604649e133dadc0e5" translate="yes" xml:space="preserve">
          <source>(NOTE: &lt;code&gt;date&lt;/code&gt; on macOS does not offer nanoseconds, so this must be done on Linux.)</source>
          <target state="translated">（注意：macOS上的 &lt;code&gt;date&lt;/code&gt; 不提供纳秒，因此必须在Linux上完成。）</target>
        </trans-unit>
        <trans-unit id="adcf7ac4dae866aa597be61d4bc723836b15d956" translate="yes" xml:space="preserve">
          <source>...and yet yet another one.</source>
          <target state="translated">...又有一个</target>
        </trans-unit>
        <trans-unit id="b41db4deb31715bf7bf36e52424cf9ce6795750e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+=&lt;/code&gt; is better from a performance standpoint if a big string is being constructed in small increments, especially in a loop</source>
          <target state="translated">如果以小增量（尤其是在循环中）构造大字符串，则从性能角度来看， &lt;code&gt;+=&lt;/code&gt; 更好</target>
        </trans-unit>
        <trans-unit id="5af36a2e7e39d199453ed1d4361dacec96231975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+=&lt;/code&gt;: Append to variable</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; ：附加到变量</target>
        </trans-unit>
        <trans-unit id="05d6df9d483a7b6d16a3f29398d269a5e619edc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf&lt;/code&gt;: Re-construct variable using the &lt;em&gt;builtin&lt;/em&gt; command</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; ：使用&lt;em&gt;内置&lt;/em&gt;命令重建变量</target>
        </trans-unit>
        <trans-unit id="92340b09e3176c06e36dd2e613d7b3008da8067c" translate="yes" xml:space="preserve">
          <source>A few notes:</source>
          <target state="translated">有几个注意事项。</target>
        </trans-unit>
        <trans-unit id="a84621f46f0fee168321d457ef3de65caadd50d9" translate="yes" xml:space="preserve">
          <source>Any script using this operator on older Bash versions will fail with a &quot;command not found&quot; error if you are lucky, or a &quot;syntax error near unexpected token&quot;.</source>
          <target state="translated">任何在旧版本的Bash上使用这个操作符的脚本,如果你很幸运的话,都会出现 &quot;command not found &quot;的错误,或者是 &quot;语法错误,靠近意想不到的token&quot;。</target>
        </trans-unit>
        <trans-unit id="f9ffbe9bae5466efe9eff1924bec37046780c4b9" translate="yes" xml:space="preserve">
          <source>Append to an array &lt;code&gt;var+=(...)&lt;/code&gt;</source>
          <target state="translated">附加到数组 &lt;code&gt;var+=(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c917d872ad7580c1d2a82bb2b09f9cb7afd46a1f" translate="yes" xml:space="preserve">
          <source>Append to an integer &lt;code&gt;((var+=...))&lt;/code&gt;</source>
          <target state="translated">附加一个整数 &lt;code&gt;((var+=...))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87545afb385457472346e8c34f5e307d0ea09c7" translate="yes" xml:space="preserve">
          <source>Append to string &lt;code&gt;var+=...&lt;/code&gt;</source>
          <target state="translated">附加到字符串 &lt;code&gt;var+=...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9019e62d634cc49064c4af923be91dc426a71d8e" translate="yes" xml:space="preserve">
          <source>As this question stand specifically for &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt;, my first part of the answer would present different ways of doing this properly:</source>
          <target state="translated">正如这个问题专门代表&lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash一样&lt;/a&gt; ，我的答案的第一部分将提出正确执行此操作的不同方法：</target>
        </trans-unit>
        <trans-unit id="45142948cb319477715fce1d34dcb1007fd42b92" translate="yes" xml:space="preserve">
          <source>Bash also supports a &lt;code&gt;+=&lt;/code&gt; operator as shown in this code:</source>
          <target state="translated">Bash还支持 &lt;code&gt;+=&lt;/code&gt; 运算符，如以下代码所示：</target>
        </trans-unit>
        <trans-unit id="6272217110d63d3314649dc98f68993b3f4fc25b" translate="yes" xml:space="preserve">
          <source>Bash first</source>
          <target state="translated">Bash第一</target>
        </trans-unit>
        <trans-unit id="2b9b5a17640aba2390f955e194ba0c5459a7f8f8" translate="yes" xml:space="preserve">
          <source>BashFAQ/013 - How can I concatenate two variables?</source>
          <target state="translated">BashFAQ013-如何将两个变量串联起来?</target>
        </trans-unit>
        <trans-unit id="99583553fb98177526bd20eae2a56b4038ac4e39" translate="yes" xml:space="preserve">
          <source>Basically</source>
          <target state="translated">Basically</target>
        </trans-unit>
        <trans-unit id="f047bd2fcec20f719e0562e02bb415076a2d577e" translate="yes" xml:space="preserve">
          <source>But this is not easy for &lt;em&gt;nesting&lt;/em&gt;:</source>
          <target state="translated">但这对于&lt;em&gt;嵌套&lt;/em&gt;来说并不容易：</target>
        </trans-unit>
        <trans-unit id="87bd9427b02292d06a7de4d66383145cca8e6fbc" translate="yes" xml:space="preserve">
          <source>But you could simply do:</source>
          <target state="translated">但是,你可以简单地做。</target>
        </trans-unit>
        <trans-unit id="5f290d2b8034d7265ac5e9c5f19bfe9423cc6d4d" translate="yes" xml:space="preserve">
          <source>Curly brackets will fit to Continuous string usage:</source>
          <target state="translated">卷曲的括号将适合于连续的字符串使用。</target>
        </trans-unit>
        <trans-unit id="d82948156c93a167a453437c93a3dfd57e09e8a9" translate="yes" xml:space="preserve">
          <source>Despite of the special operator, &lt;code&gt;+=&lt;/code&gt;, for concatenation, there is a simpler way to go:</source>
          <target state="translated">尽管有特殊的运算符 &lt;code&gt;+=&lt;/code&gt; 进行连接，但还有一种更简单的方法：</target>
        </trans-unit>
        <trans-unit id="061fabe1a3aee116bd4d5460d512e6927c9604aa" translate="yes" xml:space="preserve">
          <source>Double quotes take an extra calculation time for interpretation of variables inside. Avoid it if possible.</source>
          <target state="translated">双引号需要额外的计算时间来解释里面的变量。尽量避免。</target>
        </trans-unit>
        <trans-unit id="33fcbe45dd33298fc2b3a8b03f45c79724aa9165" translate="yes" xml:space="preserve">
          <source>Even if the += operator is now permitted, it has been introduced in &lt;strong&gt;Bash 3.1&lt;/strong&gt; in 2004.</source>
          <target state="translated">即使现在允许+ =运算符，它也在2004年的&lt;strong&gt;Bash 3.1&lt;/strong&gt;中引入。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="f6f431c6d1b83fdc76c20f5dbc1efe535d0f1ae4" translate="yes" xml:space="preserve">
          <source>For those who cares about backward compatibility, stick with the older standard Bash concatenation methods, like those mentioned in the chosen answer:</source>
          <target state="translated">对于那些关心向后兼容性的人来说,坚持使用老的标准Bash串联方法,就像选择答案中提到的那些方法。</target>
        </trans-unit>
        <trans-unit id="4b7550837fb71ce5dc516a85fe3ebea51669a90c" translate="yes" xml:space="preserve">
          <source>Formatted, using &lt;em&gt;forked&lt;/em&gt;&lt;code&gt;printf&lt;/code&gt;</source>
          <target state="translated">格式化，使用&lt;em&gt;分叉的&lt;/em&gt; &lt;code&gt;printf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c9a559e8db14c487dda610affda849531e73f2" translate="yes" xml:space="preserve">
          <source>Here is a concise summary of what most answers are talking about.</source>
          <target state="translated">下面简明扼要地总结一下大多数人的回答是什么。</target>
        </trans-unit>
        <trans-unit id="2248bd500c18170425820e91a0ef3024f446b852" translate="yes" xml:space="preserve">
          <source>Here is the one through &lt;a href=&quot;http://en.wikipedia.org/wiki/AWK&quot;&gt;AWK&lt;/a&gt;:</source>
          <target state="translated">这是通过&lt;a href=&quot;http://en.wikipedia.org/wiki/AWK&quot;&gt;AWK进行的操作&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="bfd7e226ecef699774482324a6b142aaa2c37d1b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;$foo&lt;/code&gt; becomes &quot;Hello World&quot;.</source>
          <target state="translated">在这里， &lt;code&gt;$foo&lt;/code&gt; 变成&amp;ldquo; Hello World&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="bc577f90688a74d1fc87891d866a16700187afd1" translate="yes" xml:space="preserve">
          <source>Historically, you could use &lt;em&gt;backticks&lt;/em&gt; for retrieving result of a &lt;em&gt;fork&lt;/em&gt;:</source>
          <target state="translated">从历史上看，您可以使用&lt;em&gt;反引号&lt;/em&gt;来检索&lt;em&gt;fork的&lt;/em&gt;结果：</target>
        </trans-unit>
        <trans-unit id="5e0e0a3dfcf33ed4acc9ce3503792e75ac7cf96b" translate="yes" xml:space="preserve">
          <source>Hmm.. &lt;a href=&quot;https://serverfault.com/a/208266/142978&quot;&gt;this is not a bug, but a feature&lt;/a&gt;... To prevent bash to try to develop &lt;code&gt;!&quot;&lt;/code&gt;, you could:</source>
          <target state="translated">嗯.. &lt;a href=&quot;https://serverfault.com/a/208266/142978&quot;&gt;这不是一个bug，而是一个功能&lt;/a&gt; ...为了防止bash尝试开发 &lt;code&gt;!&quot;&lt;/code&gt; ，您可以：</target>
        </trans-unit>
        <trans-unit id="98589eda0b0c3350efeb7df609481a8612eef1f0" translate="yes" xml:space="preserve">
          <source>How is this accomplished in Bash?</source>
          <target state="translated">这在Bash中是如何实现的?</target>
        </trans-unit>
        <trans-unit id="6a2e6f81fd6ac37d46c523c21beba38638180d0d" translate="yes" xml:space="preserve">
          <source>How to concatenate string variables in Bash</source>
          <target state="translated">如何在Bash中聚合字符串变量</target>
        </trans-unit>
        <trans-unit id="470f68da03b911ef6709722d3140d5a7814b314e" translate="yes" xml:space="preserve">
          <source>I do it this way when convenient: Use an inline command!</source>
          <target state="translated">我是在方便的时候这样做的。用内联命令!</target>
        </trans-unit>
        <trans-unit id="467721da41492e4bb81590c0bb56387ca9eeb51f" translate="yes" xml:space="preserve">
          <source>I don't know about PHP yet, but this works in Linux Bash. If you don't want to affect it to a variable, you could try this:</source>
          <target state="translated">我还不了解PHP,但这在Linux Bash中是可以的。如果你不想影响到一个变量,可以试试这个。</target>
        </trans-unit>
        <trans-unit id="2d5c981dbbad201f3bbc11b6fdacef1a2a28d7f9" translate="yes" xml:space="preserve">
          <source>I have created &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;append_test.sh on GitHub&lt;/a&gt; with the contents:</source>
          <target state="translated">我&lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;在GitHub上&lt;/a&gt;创建了append_test.sh，内容如下：</target>
        </trans-unit>
        <trans-unit id="df60ad75b0491805267dfff61134960304cc8674" translate="yes" xml:space="preserve">
          <source>I kind of like making a quick function.</source>
          <target state="translated">我有点喜欢做一个快速功能。</target>
        </trans-unit>
        <trans-unit id="35816762d51684f0de91167ddbc3f78b49194000" translate="yes" xml:space="preserve">
          <source>I prefer to use curly brackets &lt;code&gt;${}&lt;/code&gt; for expanding variable in string:</source>
          <target state="translated">我更喜欢使用大括号 &lt;code&gt;${}&lt;/code&gt; 来扩展字符串中的变量：</target>
        </trans-unit>
        <trans-unit id="6515924b2fdbe8380a92f0af7780f9e61495663f" translate="yes" xml:space="preserve">
          <source>I wanted to build a string from a list. Couldn't find an answer for that so I post it here. Here is what I did:</source>
          <target state="translated">我想从一个列表中建立一个字符串。找不到答案,所以我把它贴到这里。我是这样做的。</target>
        </trans-unit>
        <trans-unit id="9bff2a79b85772297cfcbaa68bb7b6557aa73dd0" translate="yes" xml:space="preserve">
          <source>If it is as your example of adding &lt;code&gt;&quot; World&quot;&lt;/code&gt; to the original string, then it can be:</source>
          <target state="translated">如果这是将 &lt;code&gt;&quot; World&quot;&lt;/code&gt; 添加到原始字符串的示例，则可以是：</target>
        </trans-unit>
        <trans-unit id="8a150e41a394fe65e305a228a887924fcaf285ef" translate="yes" xml:space="preserve">
          <source>If what you are trying to do is to &lt;em&gt;split&lt;/em&gt; a string into several lines, you can use a backslash:</source>
          <target state="translated">如果您要执行的操作是将字符串分成几行，则可以使用反斜杠：</target>
        </trans-unit>
        <trans-unit id="3d1bd98eba26b54d374352283f5c8effae6e1f03" translate="yes" xml:space="preserve">
          <source>If you try to concatenate a string with another string, for example,</source>
          <target state="translated">如果你试图将一个字符串与另一个字符串连接起来,例如。</target>
        </trans-unit>
        <trans-unit id="2361bd2fbeb116748c047b41ff0d3f439612678a" translate="yes" xml:space="preserve">
          <source>If you want to append something like an underscore, use escape (\)</source>
          <target state="translated">如果你想附加一些类似下划线的东西,请使用转义符(\\)</target>
        </trans-unit>
        <trans-unit id="b1035e2881f6270ad0c3c2063687ee85e31e26ee" translate="yes" xml:space="preserve">
          <source>If you want to use more sophisticated constructions you have to use a &lt;em&gt;fork&lt;/em&gt; (new child process that make the job and return the result via &lt;code&gt;stdout&lt;/code&gt;):</source>
          <target state="translated">如果您想使用更复杂的构造，则必须使用&lt;em&gt;fork&lt;/em&gt; （新的子进程进行工作并通过 &lt;code&gt;stdout&lt;/code&gt; 返回结果）：</target>
        </trans-unit>
        <trans-unit id="11fe5aa37000e7af29a90564aa80284fb3a6ddf0" translate="yes" xml:space="preserve">
          <source>In PHP, strings are concatenated together as follows:</source>
          <target state="translated">在PHP中,字符串被串联在一起,如下所示。</target>
        </trans-unit>
        <trans-unit id="6f39848fc3cad9f2f63ac3212b2dac4f68c4fd33" translate="yes" xml:space="preserve">
          <source>In general to concatenate two variables you can just write them one after another:</source>
          <target state="translated">一般来说,要把两个变量串联起来,你可以一个接一个地写就可以了。</target>
        </trans-unit>
        <trans-unit id="9218f385063dd34e45700fe7ab2d28aa12027888" translate="yes" xml:space="preserve">
          <source>In my opinion, the simplest way to concatenate two strings is to write a function that does it for you, then use that function.</source>
          <target state="translated">在我看来,把两个字符串串串联起来的最简单的方法就是写一个函数来帮你做,然后用这个函数。</target>
        </trans-unit>
        <trans-unit id="31a6c4cacbadbe7e6a8bd544cc7e65719fce7ab9" translate="yes" xml:space="preserve">
          <source>Let's say we have two variables and $1 is set to 'one':</source>
          <target state="translated">假设我们有两个变量,将1元设置为 &quot;1&quot;。</target>
        </trans-unit>
        <trans-unit id="7f532384aa967b5bdc460f66dd85df621b543f6b" translate="yes" xml:space="preserve">
          <source>Nota: The use of &lt;em&gt;double-quotes&lt;/em&gt; may be useful for manipulating strings that contain &lt;code&gt;spaces&lt;/code&gt;, &lt;code&gt;tabulations&lt;/code&gt; and/or &lt;code&gt;newlines&lt;/code&gt;</source>
          <target state="translated">注意：使用&lt;em&gt;双引号&lt;/em&gt;可能对处理包含 &lt;code&gt;spaces&lt;/code&gt; ， &lt;code&gt;tabulations&lt;/code&gt; 和/或 &lt;code&gt;newlines&lt;/code&gt; 字符串很有用</target>
        </trans-unit>
        <trans-unit id="16d9f74c5071b2a7b73caf5323062bbf69de994d" translate="yes" xml:space="preserve">
          <source>Note that between parentheses, there is a &lt;em&gt;space separated array&lt;/em&gt;. If you want to store a string containing spaces in your array, you have to enclose them:</source>
          <target state="translated">请注意，括号之间有一个以&lt;em&gt;空格分隔的array&lt;/em&gt; 。 如果要在数组中存储包含空格的字符串，则必须将它们括起来：</target>
        </trans-unit>
        <trans-unit id="d75948a16a0e3e8f5f2e46c92ff7994f3218bd45" translate="yes" xml:space="preserve">
          <source>Note that our &lt;code&gt;a&lt;/code&gt; is still an array! Only first element is changed!</source>
          <target state="translated">注意，我们的 &lt;code&gt;a&lt;/code&gt; 仍然是数组！ 仅第一个元素被更改！</target>
        </trans-unit>
        <trans-unit id="43fddc7b23f4c7838d65564a074aee691c438546" translate="yes" xml:space="preserve">
          <source>Note that this won't work</source>
          <target state="translated">注意,这是不可行的</target>
        </trans-unit>
        <trans-unit id="8a4844dda52f0c26f5af432efbb40409bda7cde9" translate="yes" xml:space="preserve">
          <source>One argument format string with many argument passed to:</source>
          <target state="translated">一个参数的格式字符串,传递给多个参数的参数。</target>
        </trans-unit>
        <trans-unit id="36660cb47e775732843ecb2655cd60434aa3f239" translate="yes" xml:space="preserve">
          <source>Or we could use &lt;em&gt;one argument format string&lt;/em&gt; which will be repeated as many argument submitted...</source>
          <target state="translated">或者我们可以使用&lt;em&gt;一个参数格式字符串&lt;/em&gt; ，该&lt;em&gt;字符串&lt;/em&gt;将与提交的许多参数重复...</target>
        </trans-unit>
        <trans-unit id="279f60bf9a525240c46a2d3699489765843259f7" translate="yes" xml:space="preserve">
          <source>Otherwise using &lt;code&gt;foo = &quot;$fooWorld&quot;&lt;/code&gt; will not work.</source>
          <target state="translated">否则，使用 &lt;code&gt;foo = &quot;$fooWorld&quot;&lt;/code&gt; 将不起作用。</target>
        </trans-unit>
        <trans-unit id="d9f0b837f6b79e52ab2a34a74f68668672128a4a" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;a&lt;/code&gt; is also an array of only one element.</source>
          <target state="translated">我们的 &lt;code&gt;a&lt;/code&gt; 也是只有一个元素的数组。</target>
        </trans-unit>
        <trans-unit id="1771e4c9acf6dde706b3b7fa5860621248195877" translate="yes" xml:space="preserve">
          <source>PREFIX_HELLO_WORLD</source>
          <target state="translated">PREFIX_HELLO_WORLD</target>
        </trans-unit>
        <trans-unit id="87eb592b096fe1bc9286f71d12faf9a6552a868a" translate="yes" xml:space="preserve">
          <source>PREFIX_WORLD</source>
          <target state="translated">PREFIX_WORLD</target>
        </trans-unit>
        <trans-unit id="dee69127295d004ceef94bf9e5bdab008cf2d5ec" translate="yes" xml:space="preserve">
          <source>Plus take a look at other answer about &lt;strong&gt;+=&lt;/strong&gt;</source>
          <target state="translated">再看一下关于&lt;strong&gt;+ =的&lt;/strong&gt;其他答案</target>
        </trans-unit>
        <trans-unit id="719ac2e5ed17645b278921f59e179e7c8f800769" translate="yes" xml:space="preserve">
          <source>Safer way:</source>
          <target state="translated">更安全的方式。</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">也见。</target>
        </trans-unit>
        <trans-unit id="8667cec4c6c0a55f3f90079fdd67283ecb218068" translate="yes" xml:space="preserve">
          <source>Shell now</source>
          <target state="translated">壳牌现在</target>
        </trans-unit>
        <trans-unit id="53517aeaf2261fd62cf086622d3b029b513c0d37" translate="yes" xml:space="preserve">
          <source>So to retrieve our seven field array, we only need to re-set 1st element:</source>
          <target state="translated">所以要检索我们的七字段数组,我们只需要重新设置1号元素即可。</target>
        </trans-unit>
        <trans-unit id="27289f5e2e72d52b42f56975a352ef1503ab370e" translate="yes" xml:space="preserve">
          <source>Strings containing spaces can become part of command, use &quot;$XXX&quot; and &quot;${XXX}&quot; to avoid these errors.</source>
          <target state="translated">包含空格的字符串可能成为命令的一部分,使用&quot;$XXX &quot;和&quot;${XXX}&quot;来避免这些错误。</target>
        </trans-unit>
        <trans-unit id="fc55bd621afd18d3f9e08f2edf48af5bb50f5e1a" translate="yes" xml:space="preserve">
          <source>Test 1:</source>
          <target state="translated">测试1:</target>
        </trans-unit>
        <trans-unit id="159b00a4fd6d920b86d8b7523b32be7f6b1a3f8c" translate="yes" xml:space="preserve">
          <source>Test 2:</source>
          <target state="translated">测试2:</target>
        </trans-unit>
        <trans-unit id="32b1cd28de4997ecac10988388a3c6f27f1f4e0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;printf&lt;/code&gt;&lt;em&gt;builtin&lt;/em&gt; command gives a powerful way of drawing string format. As this is a Bash &lt;em&gt;builtin&lt;/em&gt;, there is a option for sending formatted string to a variable instead of printing on &lt;code&gt;stdout&lt;/code&gt;:</source>
          <target state="translated">&lt;em&gt;内置&lt;/em&gt;的 &lt;code&gt;printf&lt;/code&gt; 命令提供了一种强大的绘制字符串格式的方式。 由于这是Bash &lt;em&gt;内置的&lt;/em&gt; ，因此可以选择将格式化的字符串发送到变量，而不是在 &lt;code&gt;stdout&lt;/code&gt; 上打印：</target>
        </trans-unit>
        <trans-unit id="83e416ba1eaa9a4279e3d3c10315ea18cd865fb5" translate="yes" xml:space="preserve">
          <source>The errors indicate that my Bash got up to &lt;strong&gt;335.54432 MB&lt;/strong&gt; before it crashed. You could change &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;the code&lt;/a&gt; from doubling the data to appending a constant to get a more granular graph and failure point. But I think this should give you enough information to decide whether you care. Personally, below 100&amp;nbsp;MB I don't. Your mileage may vary.</source>
          <target state="translated">该错误表明我的Bash在崩溃前已达到&lt;strong&gt;335.54432 MB&lt;/strong&gt; 。 您可以&lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;将代码&lt;/a&gt;从加倍数据更改为附加常量，以获取更精细的图形和故障点。 但是我认为这应该给您足够的信息来决定您是否在乎。 就个人而言，我不会低于100 MB。 你的旅费可能会改变。</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">的输出。</target>
        </trans-unit>
        <trans-unit id="69bb31328df0691de52625b07666156e1b902430" translate="yes" xml:space="preserve">
          <source>The simplest way with quotation marks:</source>
          <target state="translated">用引号的最简单的方法。</target>
        </trans-unit>
        <trans-unit id="2ad5c63cc2c6ab78b38fc26f2339035fd0e19592" translate="yes" xml:space="preserve">
          <source>The syntax &lt;strong&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/strong&gt; may be used in different ways:</source>
          <target state="translated">语法&lt;strong&gt; &lt;code&gt;+=&lt;/code&gt; &lt;/strong&gt;可以以不同的方式使用：</target>
        </trans-unit>
        <trans-unit id="6cd691a88ea59ef340905ac53356df5effe747fd" translate="yes" xml:space="preserve">
          <source>The table below explains the different contexts where we can combine the values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to create a new variable, &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">下表说明了可以结合 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的值以创建新变量 &lt;code&gt;c&lt;/code&gt; 的不同上下文。</target>
        </trans-unit>
        <trans-unit id="2c3e52ae28a38ff578be8e3e7dbfc958d04c64ce" translate="yes" xml:space="preserve">
          <source>The way I'd solve the problem is just</source>
          <target state="translated">我解决这个问题的方法就是</target>
        </trans-unit>
        <trans-unit id="94dea865f36eb2a17a49ec7744c9cd0003e14d92" translate="yes" xml:space="preserve">
          <source>There are seven &lt;em&gt;strings&lt;/em&gt; in this array. So we could build a formatted string containing exactly seven positional arguments:</source>
          <target state="translated">此数组中有七个&lt;em&gt;字符串&lt;/em&gt; 。 因此，我们可以构建一个格式化的字符串，其中包含恰好七个位置参数：</target>
        </trans-unit>
        <trans-unit id="fb165be54b165d1c959a0c982060f22f1aa1c925" translate="yes" xml:space="preserve">
          <source>There are voiced concerns about performance, but no data is offered. Let me suggest a simple test.</source>
          <target state="translated">有人表示担心性能问题,但没有提供数据。让我提出一个简单的测试建议。</target>
        </trans-unit>
        <trans-unit id="369a75e97f318d6ec145a9493109e6364a6829ed" translate="yes" xml:space="preserve">
          <source>There's one particular case where you should take care:</source>
          <target state="translated">有一种特殊情况,你应该注意。</target>
        </trans-unit>
        <trans-unit id="2c3c35a74ab1ce4bc2031b207d811e22c1c07906" translate="yes" xml:space="preserve">
          <source>This does &lt;em&gt;not&lt;/em&gt; work:</source>
          <target state="translated">这不起作用：</target>
        </trans-unit>
        <trans-unit id="cb780e8eb924fadf79808d44840abbcd92d1563a" translate="yes" xml:space="preserve">
          <source>This is an example of a Bash script:</source>
          <target state="translated">这是一个Bash脚本的例子。</target>
        </trans-unit>
        <trans-unit id="e188f83fdefc6603d01c6584f28c5195768dd202" translate="yes" xml:space="preserve">
          <source>This is how you concatenate two strings.</source>
          <target state="translated">这就是把两个字符串串串联起来的方法。</target>
        </trans-unit>
        <trans-unit id="db44249067683e4ab33834a42f5d074a526ab936" translate="yes" xml:space="preserve">
          <source>This is useful when 
    &lt;code&gt;$blaohai&lt;/code&gt;
leads to a variable not found error. Or if you have spaces or other special characters in your strings. &lt;code&gt;&quot;${foo}&quot;&lt;/code&gt; properly escapes anything you put into it.</source>
          <target state="translated">当 &lt;code&gt;$blaohai&lt;/code&gt; 导致变量未找到错误时，这很有用。 或者，如果字符串中包含空格或其他特殊字符。 &lt;code&gt;&quot;${foo}&quot;&lt;/code&gt; 正确地转义了您放入其中的所有内容。</target>
        </trans-unit>
        <trans-unit id="bbfed531f3c8084ebfdf51e489df479d5e845d35" translate="yes" xml:space="preserve">
          <source>This last statement would print &quot;OpenSystems&quot; (without quotes).</source>
          <target state="translated">最后这句话将打印 &quot;OpenSystems&quot;(不含引号)。</target>
        </trans-unit>
        <trans-unit id="6c47bc5f898e5e62e29dd7dfd964d007a17d9276" translate="yes" xml:space="preserve">
          <source>This one also adds only one space in between:</source>
          <target state="translated">这个也只在中间增加了一个空间。</target>
        </trans-unit>
        <trans-unit id="e4bf4a51ac667b923a2a205a96f6bee4239bd03f" translate="yes" xml:space="preserve">
          <source>This works fine:</source>
          <target state="translated">这个很好用。</target>
        </trans-unit>
        <trans-unit id="d32a8bbfc3e779ddecfadcd682d49cd50e5db2c0" translate="yes" xml:space="preserve">
          <source>Under &lt;em&gt;POSIX&lt;/em&gt; shell, you could not use &lt;em&gt;bashisms&lt;/em&gt;, so there is no &lt;em&gt;builtin&lt;/em&gt;&lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">在&lt;em&gt;POSIX&lt;/em&gt; shell下，您不能使用&lt;em&gt;bashisms&lt;/em&gt; ，因此没有&lt;em&gt;内置的&lt;/em&gt; &lt;code&gt;printf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3d7e2f61e8f32a1ae973fc94bb4197e186095d4" translate="yes" xml:space="preserve">
          <source>Under bash, when you access a variable name without specifying index, you always address first element only!</source>
          <target state="translated">在bash下,当你访问一个变量名而不指定索引的时候,你总是只处理第一个元素!</target>
        </trans-unit>
        <trans-unit id="ea6508f50790e35b9b9d80ac7edc335be5414591" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;Stack&amp;nbsp;Overflow question&lt;/em&gt; syntax,</source>
          <target state="translated">使用&lt;em&gt;堆栈溢出问题&lt;/em&gt;语法，</target>
        </trans-unit>
        <trans-unit id="9a2da18a7bf535275c4e7f972fa322a4ed255d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;Stack&amp;nbsp;Overflow question&lt;/em&gt; syntax:</source>
          <target state="translated">使用&lt;em&gt;堆栈溢出问题&lt;/em&gt;语法：</target>
        </trans-unit>
        <trans-unit id="6d868372db567c7c4882189257fe82c1fd3bf18c" translate="yes" xml:space="preserve">
          <source>When do we need curly braces around shell variables?</source>
          <target state="translated">我们什么时候需要在shell变量周围的大括号?</target>
        </trans-unit>
        <trans-unit id="e012bd2854254580514f478d3bb60e50df1d66cc" translate="yes" xml:space="preserve">
          <source>Will output</source>
          <target state="translated">将输出</target>
        </trans-unit>
        <trans-unit id="ab40238dc123ed0ec7be782ed27a673ceb626a15" translate="yes" xml:space="preserve">
          <source>Will output &lt;code&gt;&quot;daniel&quot;san&lt;/code&gt;, and not &lt;code&gt;danielsan&lt;/code&gt;, as you might have wanted.
In this case you should do instead:</source>
          <target state="translated">将输出 &lt;code&gt;&quot;daniel&quot;san&lt;/code&gt; ，而不是您可能想要的 &lt;code&gt;danielsan&lt;/code&gt; 。 在这种情况下，您应该改为：</target>
        </trans-unit>
        <trans-unit id="8fd90e44035bd17dbb78c97fbba80096c6263b8f" translate="yes" xml:space="preserve">
          <source>With one space in between:</source>
          <target state="translated">中间有一个空间。</target>
        </trans-unit>
        <trans-unit id="871e01daf406c1892151bd181c141d675e07320c" translate="yes" xml:space="preserve">
          <source>Yet another approach...</source>
          <target state="translated">但另一种方法.....</target>
        </trans-unit>
        <trans-unit id="91a638bb31ee9ad130888c9815b0119d9a453d13" translate="yes" xml:space="preserve">
          <source>Yet another way to skin a cat. This time with functions :D</source>
          <target state="translated">然而,又是另一种剥猫皮的方法。这一次是带功能的 :D</target>
        </trans-unit>
        <trans-unit id="a531591bd4aed429a40efdf39f39312ef690fdb1" translate="yes" xml:space="preserve">
          <source>You can concatenate without the quotes. Here is an example:</source>
          <target state="translated">可以不加引号,也可以不加引号。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="5eaa802aaf4ac75bd51f813943445b77cbe195d2" translate="yes" xml:space="preserve">
          <source>You can do this too:</source>
          <target state="translated">你也可以这样做。</target>
        </trans-unit>
        <trans-unit id="f70be73d85ba20f8535d6dc5a4206127dab6911b" translate="yes" xml:space="preserve">
          <source>You could place another variable instead of 'Hello' or '!'. You could concatenate more strings as well.</source>
          <target state="translated">你可以把另一个变量代替'Hello'或'!!'。你也可以串联更多的字符串。</target>
        </trans-unit>
        <trans-unit id="03feafa4ae5e8e1034dce509446863cdba708ae9" translate="yes" xml:space="preserve">
          <source>and leave you with the correct output:</source>
          <target state="translated">并给你留下正确的输出。</target>
        </trans-unit>
        <trans-unit id="6f3d898257f79b02115e3a52c1801572d3ccc37b" translate="yes" xml:space="preserve">
          <source>and then I get the following output:</source>
          <target state="translated">然后我得到以下输出。</target>
        </trans-unit>
        <trans-unit id="593869f5e8a639ef50d6fe708ad32edfd44b98b6" translate="yes" xml:space="preserve">
          <source>as it seems to drop $foo and leaves you with:</source>
          <target state="translated">因为它似乎要掉落$foo,并给你留下了。</target>
        </trans-unit>
        <trans-unit id="18bcac79b4f2aea5ef8ea43f5cd9dd51430ac264" translate="yes" xml:space="preserve">
          <source>but this will work:</source>
          <target state="translated">但这样就可以了。</target>
        </trans-unit>
        <trans-unit id="10bc1ec735f3b6de29cdc0b026e11da078fbc1e9" translate="yes" xml:space="preserve">
          <source>doesn't work, as you may imagine, but</source>
          <target state="translated">如你所想象的那样,并不奏效,但</target>
        </trans-unit>
        <trans-unit id="fe180a4775ec9b1876f8b66bc4797517bdc706b5" translate="yes" xml:space="preserve">
          <source>enclosing the RHS of an assignment in double quotes is generally a good practice, though it is quite optional in many cases</source>
          <target state="translated">用双引号括住作业的页脚,通常是一个好的做法,尽管在许多情况下是可有可无的。</target>
        </trans-unit>
        <trans-unit id="24c5fb14936b7b8d27e72e207aca33e4a45b11f8" translate="yes" xml:space="preserve">
          <source>produces</source>
          <target state="translated">produces</target>
        </trans-unit>
        <trans-unit id="5add484b1702a015606da5a23c555e6fdee149ba" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;echo &quot;$c&quot;&lt;/code&gt; will produce</source>
          <target state="translated">然后 &lt;code&gt;echo &quot;$c&quot;&lt;/code&gt; 将产生</target>
        </trans-unit>
        <trans-unit id="005d2e406282bfd4d7072659be8cf45340dc43df" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;{}&lt;/code&gt; around variable names to disambiguate their expansion (as in row 2 in the table above). As seen on rows 3 and 4, there is no need for &lt;code&gt;{}&lt;/code&gt; unless a variable is being concatenated with a string that starts with a character that is a valid first character in shell variable name, that is alphabet or underscore.</source>
          <target state="translated">在变量名前后使用 &lt;code&gt;{}&lt;/code&gt; 消除歧义（如上表第2行所示）。 如第3行和第4行所示，除非将变量与以一个字符开头的字符串连接在一起，该字符是shell变量名称中有效的第一个字符（即字母或下划线），否则不需要 &lt;code&gt;{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="909e4fadfd532cc1d7b59d2485174ef44672a5ec" translate="yes" xml:space="preserve">
          <source>variable &lt;code&gt;a&lt;/code&gt; is a string, but also an integer</source>
          <target state="translated">变量 &lt;code&gt;a&lt;/code&gt; 是字符串，也是整数</target>
        </trans-unit>
        <trans-unit id="92e8237524405cfe4179e596467c9268495494d5" translate="yes" xml:space="preserve">
          <source>which produces</source>
          <target state="translated">其生产</target>
        </trans-unit>
        <trans-unit id="325bac1115922b539b20a947c68348d86ae1e4e3" translate="yes" xml:space="preserve">
          <source>with an extra space.</source>
          <target state="translated">有了额外的空间。</target>
        </trans-unit>
        <trans-unit id="fde63634acbe4ff5f906859e13d40c19d4eeb787" translate="yes" xml:space="preserve">
          <source>with backticks, you have to escape inner forks with &lt;em&gt;backslashes&lt;/em&gt;:</source>
          <target state="translated">如果使用反引号，则必须使用&lt;em&gt;反斜线&lt;/em&gt;转义内叉：</target>
        </trans-unit>
        <trans-unit id="12fb46f3c161e46bb95ce405273979b44a2caf5e" translate="yes" xml:space="preserve">
          <source>works fine!</source>
          <target state="translated">好用</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
