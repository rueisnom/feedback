<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/4181703">
    <body>
      <group id="4181703">
        <trans-unit id="4bd1d3cc3136e5c3d71fc0745b3d07eb11921ec2" translate="yes" xml:space="preserve">
          <source>(Because I am frugal, I will only use two variables &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; and then re-use the same in the whole answer. ;-)</source>
          <target state="translated">(Поскольку я скромен, я буду использовать только две переменные &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; , а затем повторно использовать их во всем ответе. ;-)</target>
        </trans-unit>
        <trans-unit id="3ed780fbe42c35c04706582604649e133dadc0e5" translate="yes" xml:space="preserve">
          <source>(NOTE: &lt;code&gt;date&lt;/code&gt; on macOS does not offer nanoseconds, so this must be done on Linux.)</source>
          <target state="translated">(ПРИМЕЧАНИЕ: &lt;code&gt;date&lt;/code&gt; в macOS не предлагает наносекунд, поэтому это должно быть сделано в Linux.)</target>
        </trans-unit>
        <trans-unit id="adcf7ac4dae866aa597be61d4bc723836b15d956" translate="yes" xml:space="preserve">
          <source>...and yet yet another one.</source>
          <target state="translated">...и еще один.</target>
        </trans-unit>
        <trans-unit id="b41db4deb31715bf7bf36e52424cf9ce6795750e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+=&lt;/code&gt; is better from a performance standpoint if a big string is being constructed in small increments, especially in a loop</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; лучше с точки зрения производительности, если большая строка строится с небольшими приращениями, особенно в цикле</target>
        </trans-unit>
        <trans-unit id="5af36a2e7e39d199453ed1d4361dacec96231975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+=&lt;/code&gt;: Append to variable</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; : Добавить к переменной</target>
        </trans-unit>
        <trans-unit id="05d6df9d483a7b6d16a3f29398d269a5e619edc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf&lt;/code&gt;: Re-construct variable using the &lt;em&gt;builtin&lt;/em&gt; command</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; : перестроить переменную с помощью &lt;em&gt;встроенной&lt;/em&gt; команды</target>
        </trans-unit>
        <trans-unit id="92340b09e3176c06e36dd2e613d7b3008da8067c" translate="yes" xml:space="preserve">
          <source>A few notes:</source>
          <target state="translated">Несколько заметок:</target>
        </trans-unit>
        <trans-unit id="a84621f46f0fee168321d457ef3de65caadd50d9" translate="yes" xml:space="preserve">
          <source>Any script using this operator on older Bash versions will fail with a &quot;command not found&quot; error if you are lucky, or a &quot;syntax error near unexpected token&quot;.</source>
          <target state="translated">Любой скрипт,использующий этот оператор на старых версиях Bash,в случае удачи выдаст ошибку &quot;команда не найдена&quot; или &quot;синтаксическая ошибка рядом с неожиданным токеном&quot;.</target>
        </trans-unit>
        <trans-unit id="f9ffbe9bae5466efe9eff1924bec37046780c4b9" translate="yes" xml:space="preserve">
          <source>Append to an array &lt;code&gt;var+=(...)&lt;/code&gt;</source>
          <target state="translated">Добавить в массив &lt;code&gt;var+=(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c917d872ad7580c1d2a82bb2b09f9cb7afd46a1f" translate="yes" xml:space="preserve">
          <source>Append to an integer &lt;code&gt;((var+=...))&lt;/code&gt;</source>
          <target state="translated">Добавить к целому числу &lt;code&gt;((var+=...))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87545afb385457472346e8c34f5e307d0ea09c7" translate="yes" xml:space="preserve">
          <source>Append to string &lt;code&gt;var+=...&lt;/code&gt;</source>
          <target state="translated">Добавить в строку &lt;code&gt;var+=...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9019e62d634cc49064c4af923be91dc426a71d8e" translate="yes" xml:space="preserve">
          <source>As this question stand specifically for &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt;, my first part of the answer would present different ways of doing this properly:</source>
          <target state="translated">Поскольку этот вопрос предназначен специально для &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; , моя первая часть ответа представит различные способы сделать это правильно:</target>
        </trans-unit>
        <trans-unit id="45142948cb319477715fce1d34dcb1007fd42b92" translate="yes" xml:space="preserve">
          <source>Bash also supports a &lt;code&gt;+=&lt;/code&gt; operator as shown in this code:</source>
          <target state="translated">Bash также поддерживает оператор &lt;code&gt;+=&lt;/code&gt; , как показано в этом коде:</target>
        </trans-unit>
        <trans-unit id="6272217110d63d3314649dc98f68993b3f4fc25b" translate="yes" xml:space="preserve">
          <source>Bash first</source>
          <target state="translated">Бэш первый</target>
        </trans-unit>
        <trans-unit id="2b9b5a17640aba2390f955e194ba0c5459a7f8f8" translate="yes" xml:space="preserve">
          <source>BashFAQ/013 - How can I concatenate two variables?</source>
          <target state="translated">BashFAQ013-Как соединить две переменные?</target>
        </trans-unit>
        <trans-unit id="99583553fb98177526bd20eae2a56b4038ac4e39" translate="yes" xml:space="preserve">
          <source>Basically</source>
          <target state="translated">Basically</target>
        </trans-unit>
        <trans-unit id="f047bd2fcec20f719e0562e02bb415076a2d577e" translate="yes" xml:space="preserve">
          <source>But this is not easy for &lt;em&gt;nesting&lt;/em&gt;:</source>
          <target state="translated">Но это не легко для &lt;em&gt;вложения&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="87bd9427b02292d06a7de4d66383145cca8e6fbc" translate="yes" xml:space="preserve">
          <source>But you could simply do:</source>
          <target state="translated">Но ты можешь просто сделать:</target>
        </trans-unit>
        <trans-unit id="5f290d2b8034d7265ac5e9c5f19bfe9423cc6d4d" translate="yes" xml:space="preserve">
          <source>Curly brackets will fit to Continuous string usage:</source>
          <target state="translated">Кудрявые скобки подойдут для использования непрерывной строки:</target>
        </trans-unit>
        <trans-unit id="d82948156c93a167a453437c93a3dfd57e09e8a9" translate="yes" xml:space="preserve">
          <source>Despite of the special operator, &lt;code&gt;+=&lt;/code&gt;, for concatenation, there is a simpler way to go:</source>
          <target state="translated">Несмотря на специальный оператор &lt;code&gt;+=&lt;/code&gt; , для конкатенации есть более простой способ:</target>
        </trans-unit>
        <trans-unit id="061fabe1a3aee116bd4d5460d512e6927c9604aa" translate="yes" xml:space="preserve">
          <source>Double quotes take an extra calculation time for interpretation of variables inside. Avoid it if possible.</source>
          <target state="translated">Двойные котировки требуют дополнительного времени на вычисление для интерпретации переменных внутри.По возможности избегайте этого.</target>
        </trans-unit>
        <trans-unit id="33fcbe45dd33298fc2b3a8b03f45c79724aa9165" translate="yes" xml:space="preserve">
          <source>Even if the += operator is now permitted, it has been introduced in &lt;strong&gt;Bash 3.1&lt;/strong&gt; in 2004.</source>
          <target state="translated">Даже если теперь разрешен оператор + =, он был введен в &lt;strong&gt;Bash 3.1&lt;/strong&gt; в 2004 году.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="f6f431c6d1b83fdc76c20f5dbc1efe535d0f1ae4" translate="yes" xml:space="preserve">
          <source>For those who cares about backward compatibility, stick with the older standard Bash concatenation methods, like those mentioned in the chosen answer:</source>
          <target state="translated">Для тех,кто заботится об обратной совместимости,придерживайтесь старых стандартных методов конкатенации Bash,как те,которые упомянуты в выбранном ответе:</target>
        </trans-unit>
        <trans-unit id="4b7550837fb71ce5dc516a85fe3ebea51669a90c" translate="yes" xml:space="preserve">
          <source>Formatted, using &lt;em&gt;forked&lt;/em&gt;&lt;code&gt;printf&lt;/code&gt;</source>
          <target state="translated">Отформатирован с использованием &lt;em&gt;разветвленного&lt;/em&gt; &lt;code&gt;printf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c9a559e8db14c487dda610affda849531e73f2" translate="yes" xml:space="preserve">
          <source>Here is a concise summary of what most answers are talking about.</source>
          <target state="translated">Вот краткое изложение того,о чем говорится в большинстве ответов.</target>
        </trans-unit>
        <trans-unit id="2248bd500c18170425820e91a0ef3024f446b852" translate="yes" xml:space="preserve">
          <source>Here is the one through &lt;a href=&quot;http://en.wikipedia.org/wiki/AWK&quot;&gt;AWK&lt;/a&gt;:</source>
          <target state="translated">Вот один через &lt;a href=&quot;http://en.wikipedia.org/wiki/AWK&quot;&gt;AWK&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bfd7e226ecef699774482324a6b142aaa2c37d1b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;$foo&lt;/code&gt; becomes &quot;Hello World&quot;.</source>
          <target state="translated">Здесь &lt;code&gt;$foo&lt;/code&gt; становится &amp;laquo;Hello World&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="bc577f90688a74d1fc87891d866a16700187afd1" translate="yes" xml:space="preserve">
          <source>Historically, you could use &lt;em&gt;backticks&lt;/em&gt; for retrieving result of a &lt;em&gt;fork&lt;/em&gt;:</source>
          <target state="translated">Исторически, вы могли использовать &lt;em&gt;обратные пометки&lt;/em&gt; для получения результата &lt;em&gt;форка&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="5e0e0a3dfcf33ed4acc9ce3503792e75ac7cf96b" translate="yes" xml:space="preserve">
          <source>Hmm.. &lt;a href=&quot;https://serverfault.com/a/208266/142978&quot;&gt;this is not a bug, but a feature&lt;/a&gt;... To prevent bash to try to develop &lt;code&gt;!&quot;&lt;/code&gt;, you could:</source>
          <target state="translated">Хм .. &lt;a href=&quot;https://serverfault.com/a/208266/142978&quot;&gt;это не ошибка, а особенность&lt;/a&gt; ... Чтобы предотвратить попытки разработки bash &lt;code&gt;!&quot;&lt;/code&gt; , Вы можете:</target>
        </trans-unit>
        <trans-unit id="98589eda0b0c3350efeb7df609481a8612eef1f0" translate="yes" xml:space="preserve">
          <source>How is this accomplished in Bash?</source>
          <target state="translated">Как это достигается в Бэше?</target>
        </trans-unit>
        <trans-unit id="6a2e6f81fd6ac37d46c523c21beba38638180d0d" translate="yes" xml:space="preserve">
          <source>How to concatenate string variables in Bash</source>
          <target state="translated">Как скомкатентовать строковые переменные в Бэше</target>
        </trans-unit>
        <trans-unit id="470f68da03b911ef6709722d3140d5a7814b314e" translate="yes" xml:space="preserve">
          <source>I do it this way when convenient: Use an inline command!</source>
          <target state="translated">Я делаю это так,когда это удобно:Используйте встроенную команду!</target>
        </trans-unit>
        <trans-unit id="467721da41492e4bb81590c0bb56387ca9eeb51f" translate="yes" xml:space="preserve">
          <source>I don't know about PHP yet, but this works in Linux Bash. If you don't want to affect it to a variable, you could try this:</source>
          <target state="translated">Я пока не знаю о PHP,но это работает в Linux Bash.Если вы не хотите влиять на переменную,вы можете попробовать это:</target>
        </trans-unit>
        <trans-unit id="2d5c981dbbad201f3bbc11b6fdacef1a2a28d7f9" translate="yes" xml:space="preserve">
          <source>I have created &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;append_test.sh on GitHub&lt;/a&gt; with the contents:</source>
          <target state="translated">Я создал &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;append_test.sh на GitHub&lt;/a&gt; с содержанием:</target>
        </trans-unit>
        <trans-unit id="df60ad75b0491805267dfff61134960304cc8674" translate="yes" xml:space="preserve">
          <source>I kind of like making a quick function.</source>
          <target state="translated">Мне вроде как нравится делать быстрые функции.</target>
        </trans-unit>
        <trans-unit id="35816762d51684f0de91167ddbc3f78b49194000" translate="yes" xml:space="preserve">
          <source>I prefer to use curly brackets &lt;code&gt;${}&lt;/code&gt; for expanding variable in string:</source>
          <target state="translated">Я предпочитаю использовать фигурные скобки &lt;code&gt;${}&lt;/code&gt; для расширения переменной в строке:</target>
        </trans-unit>
        <trans-unit id="6515924b2fdbe8380a92f0af7780f9e61495663f" translate="yes" xml:space="preserve">
          <source>I wanted to build a string from a list. Couldn't find an answer for that so I post it here. Here is what I did:</source>
          <target state="translated">Я хотел построить строку из списка.Не смог найти ответ на этот вопрос,поэтому разместил его здесь.Вот что я сделал:</target>
        </trans-unit>
        <trans-unit id="9bff2a79b85772297cfcbaa68bb7b6557aa73dd0" translate="yes" xml:space="preserve">
          <source>If it is as your example of adding &lt;code&gt;&quot; World&quot;&lt;/code&gt; to the original string, then it can be:</source>
          <target state="translated">Если это как ваш пример добавления &lt;code&gt;&quot; World&quot;&lt;/code&gt; к исходной строке, то это может быть:</target>
        </trans-unit>
        <trans-unit id="8a150e41a394fe65e305a228a887924fcaf285ef" translate="yes" xml:space="preserve">
          <source>If what you are trying to do is to &lt;em&gt;split&lt;/em&gt; a string into several lines, you can use a backslash:</source>
          <target state="translated">Если вы пытаетесь &lt;em&gt;разбить&lt;/em&gt; строку на несколько строк, вы можете использовать обратную косую черту:</target>
        </trans-unit>
        <trans-unit id="3d1bd98eba26b54d374352283f5c8effae6e1f03" translate="yes" xml:space="preserve">
          <source>If you try to concatenate a string with another string, for example,</source>
          <target state="translated">Например,если вы пытаетесь соединить строку с другой строкой,</target>
        </trans-unit>
        <trans-unit id="2361bd2fbeb116748c047b41ff0d3f439612678a" translate="yes" xml:space="preserve">
          <source>If you want to append something like an underscore, use escape (\)</source>
          <target state="translated">Если вы хотите добавить что-то вроде подчеркивания,используйте escape (\).</target>
        </trans-unit>
        <trans-unit id="b1035e2881f6270ad0c3c2063687ee85e31e26ee" translate="yes" xml:space="preserve">
          <source>If you want to use more sophisticated constructions you have to use a &lt;em&gt;fork&lt;/em&gt; (new child process that make the job and return the result via &lt;code&gt;stdout&lt;/code&gt;):</source>
          <target state="translated">Если вы хотите использовать более сложные конструкции, вы должны использовать &lt;em&gt;форк&lt;/em&gt; (новый дочерний процесс, который выполняет задание и возвращает результат через &lt;code&gt;stdout&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="11fe5aa37000e7af29a90564aa80284fb3a6ddf0" translate="yes" xml:space="preserve">
          <source>In PHP, strings are concatenated together as follows:</source>
          <target state="translated">В PHP,строки скомпонованы вместе следующим образом:</target>
        </trans-unit>
        <trans-unit id="6f39848fc3cad9f2f63ac3212b2dac4f68c4fd33" translate="yes" xml:space="preserve">
          <source>In general to concatenate two variables you can just write them one after another:</source>
          <target state="translated">В общем,чтобы свести воедино две переменные,можно просто записывать их одну за другой:</target>
        </trans-unit>
        <trans-unit id="9218f385063dd34e45700fe7ab2d28aa12027888" translate="yes" xml:space="preserve">
          <source>In my opinion, the simplest way to concatenate two strings is to write a function that does it for you, then use that function.</source>
          <target state="translated">На мой взгляд,самый простой способ соединить две строки-это написать функцию,которая делает это за вас,а затем использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="31a6c4cacbadbe7e6a8bd544cc7e65719fce7ab9" translate="yes" xml:space="preserve">
          <source>Let's say we have two variables and $1 is set to 'one':</source>
          <target state="translated">Допустим,у нас есть две переменные,и $1 установлен в 'одну':</target>
        </trans-unit>
        <trans-unit id="7f532384aa967b5bdc460f66dd85df621b543f6b" translate="yes" xml:space="preserve">
          <source>Nota: The use of &lt;em&gt;double-quotes&lt;/em&gt; may be useful for manipulating strings that contain &lt;code&gt;spaces&lt;/code&gt;, &lt;code&gt;tabulations&lt;/code&gt; and/or &lt;code&gt;newlines&lt;/code&gt;</source>
          <target state="translated">Примечание: использование &lt;em&gt;двойных кавычек&lt;/em&gt; может быть полезно для манипулирования строками, которые содержат &lt;code&gt;spaces&lt;/code&gt; , &lt;code&gt;tabulations&lt;/code&gt; и / или &lt;code&gt;newlines&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16d9f74c5071b2a7b73caf5323062bbf69de994d" translate="yes" xml:space="preserve">
          <source>Note that between parentheses, there is a &lt;em&gt;space separated array&lt;/em&gt;. If you want to store a string containing spaces in your array, you have to enclose them:</source>
          <target state="translated">Обратите внимание, что между скобками находится &lt;em&gt;разделенный пробелами массив&lt;/em&gt; . Если вы хотите сохранить строку, содержащую пробелы в вашем массиве, вы должны заключить их:</target>
        </trans-unit>
        <trans-unit id="d75948a16a0e3e8f5f2e46c92ff7994f3218bd45" translate="yes" xml:space="preserve">
          <source>Note that our &lt;code&gt;a&lt;/code&gt; is still an array! Only first element is changed!</source>
          <target state="translated">Обратите внимание, что наш &lt;code&gt;a&lt;/code&gt; все еще является массивом! Только первый элемент изменен!</target>
        </trans-unit>
        <trans-unit id="43fddc7b23f4c7838d65564a074aee691c438546" translate="yes" xml:space="preserve">
          <source>Note that this won't work</source>
          <target state="translated">Обратите внимание,что это не сработает</target>
        </trans-unit>
        <trans-unit id="8a4844dda52f0c26f5af432efbb40409bda7cde9" translate="yes" xml:space="preserve">
          <source>One argument format string with many argument passed to:</source>
          <target state="translated">Строка форматирования одного аргумента с множеством переданных аргументов:</target>
        </trans-unit>
        <trans-unit id="36660cb47e775732843ecb2655cd60434aa3f239" translate="yes" xml:space="preserve">
          <source>Or we could use &lt;em&gt;one argument format string&lt;/em&gt; which will be repeated as many argument submitted...</source>
          <target state="translated">Или мы могли бы использовать &lt;em&gt;одну строку формата аргумента,&lt;/em&gt; которая будет повторяться столько же аргументов, сколько представлено ...</target>
        </trans-unit>
        <trans-unit id="279f60bf9a525240c46a2d3699489765843259f7" translate="yes" xml:space="preserve">
          <source>Otherwise using &lt;code&gt;foo = &quot;$fooWorld&quot;&lt;/code&gt; will not work.</source>
          <target state="translated">В противном случае использование &lt;code&gt;foo = &quot;$fooWorld&quot;&lt;/code&gt; не будет работать.</target>
        </trans-unit>
        <trans-unit id="d9f0b837f6b79e52ab2a34a74f68668672128a4a" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;a&lt;/code&gt; is also an array of only one element.</source>
          <target state="translated">Наше &lt;code&gt;a&lt;/code&gt; также массив только из одного элемента.</target>
        </trans-unit>
        <trans-unit id="1771e4c9acf6dde706b3b7fa5860621248195877" translate="yes" xml:space="preserve">
          <source>PREFIX_HELLO_WORLD</source>
          <target state="translated">PREFIX_HELLO_WORLD</target>
        </trans-unit>
        <trans-unit id="87eb592b096fe1bc9286f71d12faf9a6552a868a" translate="yes" xml:space="preserve">
          <source>PREFIX_WORLD</source>
          <target state="translated">PREFIX_WORLD</target>
        </trans-unit>
        <trans-unit id="dee69127295d004ceef94bf9e5bdab008cf2d5ec" translate="yes" xml:space="preserve">
          <source>Plus take a look at other answer about &lt;strong&gt;+=&lt;/strong&gt;</source>
          <target state="translated">Плюс взгляните на другой ответ о &lt;strong&gt;+ =&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="719ac2e5ed17645b278921f59e179e7c8f800769" translate="yes" xml:space="preserve">
          <source>Safer way:</source>
          <target state="translated">Более безопасный путь:</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">См.также:</target>
        </trans-unit>
        <trans-unit id="8667cec4c6c0a55f3f90079fdd67283ecb218068" translate="yes" xml:space="preserve">
          <source>Shell now</source>
          <target state="translated">Шелл теперь</target>
        </trans-unit>
        <trans-unit id="53517aeaf2261fd62cf086622d3b029b513c0d37" translate="yes" xml:space="preserve">
          <source>So to retrieve our seven field array, we only need to re-set 1st element:</source>
          <target state="translated">Поэтому,чтобы получить наш массив из семи полей,нам нужно только переустановить 1-й элемент:</target>
        </trans-unit>
        <trans-unit id="27289f5e2e72d52b42f56975a352ef1503ab370e" translate="yes" xml:space="preserve">
          <source>Strings containing spaces can become part of command, use &quot;$XXX&quot; and &quot;${XXX}&quot; to avoid these errors.</source>
          <target state="translated">Строки,содержащие пробелы,могут стать частью команды,используйте &quot;$XXX&quot; и &quot;${XXX}&quot;,чтобы избежать этих ошибок.</target>
        </trans-unit>
        <trans-unit id="fc55bd621afd18d3f9e08f2edf48af5bb50f5e1a" translate="yes" xml:space="preserve">
          <source>Test 1:</source>
          <target state="translated">Тест 1:</target>
        </trans-unit>
        <trans-unit id="159b00a4fd6d920b86d8b7523b32be7f6b1a3f8c" translate="yes" xml:space="preserve">
          <source>Test 2:</source>
          <target state="translated">Тест 2:</target>
        </trans-unit>
        <trans-unit id="32b1cd28de4997ecac10988388a3c6f27f1f4e0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;printf&lt;/code&gt;&lt;em&gt;builtin&lt;/em&gt; command gives a powerful way of drawing string format. As this is a Bash &lt;em&gt;builtin&lt;/em&gt;, there is a option for sending formatted string to a variable instead of printing on &lt;code&gt;stdout&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; &lt;em&gt;команда&lt;/em&gt; printf предоставляет мощный способ рисования формата строки. Поскольку это &lt;em&gt;встроенная функция&lt;/em&gt; Bash, существует возможность отправки отформатированной строки в переменную вместо печати на стандартный &lt;code&gt;stdout&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="83e416ba1eaa9a4279e3d3c10315ea18cd865fb5" translate="yes" xml:space="preserve">
          <source>The errors indicate that my Bash got up to &lt;strong&gt;335.54432 MB&lt;/strong&gt; before it crashed. You could change &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;the code&lt;/a&gt; from doubling the data to appending a constant to get a more granular graph and failure point. But I think this should give you enough information to decide whether you care. Personally, below 100&amp;nbsp;MB I don't. Your mileage may vary.</source>
          <target state="translated">Ошибки указывают, что мой Bash получил до &lt;strong&gt;335.54432 МБ,&lt;/strong&gt; прежде чем он упал. Вы можете изменить &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;код&lt;/a&gt; с удвоения данных на добавление константы, чтобы получить более детальный график и точку сбоя. Но я думаю, что это должно дать вам достаточно информации, чтобы решить, волнует ли вас это. Лично я ниже 100 МБ. Ваш пробег может варьироваться.</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">Выход:</target>
        </trans-unit>
        <trans-unit id="69bb31328df0691de52625b07666156e1b902430" translate="yes" xml:space="preserve">
          <source>The simplest way with quotation marks:</source>
          <target state="translated">Самый простой способ с кавычками:</target>
        </trans-unit>
        <trans-unit id="2ad5c63cc2c6ab78b38fc26f2339035fd0e19592" translate="yes" xml:space="preserve">
          <source>The syntax &lt;strong&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/strong&gt; may be used in different ways:</source>
          <target state="translated">Синтаксис &lt;strong&gt; &lt;code&gt;+=&lt;/code&gt; &lt;/strong&gt; может использоваться по-разному:</target>
        </trans-unit>
        <trans-unit id="6cd691a88ea59ef340905ac53356df5effe747fd" translate="yes" xml:space="preserve">
          <source>The table below explains the different contexts where we can combine the values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to create a new variable, &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Таблица ниже объясняет различные контексты, в которых мы можем объединить значения &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; для создания новой переменной &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c3e52ae28a38ff578be8e3e7dbfc958d04c64ce" translate="yes" xml:space="preserve">
          <source>The way I'd solve the problem is just</source>
          <target state="translated">Я бы решил проблему так.</target>
        </trans-unit>
        <trans-unit id="94dea865f36eb2a17a49ec7744c9cd0003e14d92" translate="yes" xml:space="preserve">
          <source>There are seven &lt;em&gt;strings&lt;/em&gt; in this array. So we could build a formatted string containing exactly seven positional arguments:</source>
          <target state="translated">В этом массиве семь &lt;em&gt;строк&lt;/em&gt; . Таким образом, мы можем построить отформатированную строку, содержащую ровно семь позиционных аргументов:</target>
        </trans-unit>
        <trans-unit id="fb165be54b165d1c959a0c982060f22f1aa1c925" translate="yes" xml:space="preserve">
          <source>There are voiced concerns about performance, but no data is offered. Let me suggest a simple test.</source>
          <target state="translated">Высказываются опасения по поводу производительности,но данные не предлагаются.Позвольте предложить простой тест.</target>
        </trans-unit>
        <trans-unit id="369a75e97f318d6ec145a9493109e6364a6829ed" translate="yes" xml:space="preserve">
          <source>There's one particular case where you should take care:</source>
          <target state="translated">Есть один конкретный случай,о котором тебе следует позаботиться:</target>
        </trans-unit>
        <trans-unit id="2c3c35a74ab1ce4bc2031b207d811e22c1c07906" translate="yes" xml:space="preserve">
          <source>This does &lt;em&gt;not&lt;/em&gt; work:</source>
          <target state="translated">Это &lt;em&gt;не&lt;/em&gt; работает:</target>
        </trans-unit>
        <trans-unit id="cb780e8eb924fadf79808d44840abbcd92d1563a" translate="yes" xml:space="preserve">
          <source>This is an example of a Bash script:</source>
          <target state="translated">Это пример Бэш-скрипта:</target>
        </trans-unit>
        <trans-unit id="e188f83fdefc6603d01c6584f28c5195768dd202" translate="yes" xml:space="preserve">
          <source>This is how you concatenate two strings.</source>
          <target state="translated">Вот как вы соединяете две струны.</target>
        </trans-unit>
        <trans-unit id="db44249067683e4ab33834a42f5d074a526ab936" translate="yes" xml:space="preserve">
          <source>This is useful when 
    &lt;code&gt;$blaohai&lt;/code&gt;
leads to a variable not found error. Or if you have spaces or other special characters in your strings. &lt;code&gt;&quot;${foo}&quot;&lt;/code&gt; properly escapes anything you put into it.</source>
          <target state="translated">Это полезно, когда &lt;code&gt;$blaohai&lt;/code&gt; приводит к ошибке переменной not found. Или если у вас есть пробелы или другие специальные символы в ваших строках. &lt;code&gt;&quot;${foo}&quot;&lt;/code&gt; правильно экранирует все, что вы в него помещаете.</target>
        </trans-unit>
        <trans-unit id="bbfed531f3c8084ebfdf51e489df479d5e845d35" translate="yes" xml:space="preserve">
          <source>This last statement would print &quot;OpenSystems&quot; (without quotes).</source>
          <target state="translated">Это последнее утверждение выведет &quot;OpenSystems&quot; (без кавычек).</target>
        </trans-unit>
        <trans-unit id="6c47bc5f898e5e62e29dd7dfd964d007a17d9276" translate="yes" xml:space="preserve">
          <source>This one also adds only one space in between:</source>
          <target state="translated">Этот также добавляет только одно место между ними:</target>
        </trans-unit>
        <trans-unit id="e4bf4a51ac667b923a2a205a96f6bee4239bd03f" translate="yes" xml:space="preserve">
          <source>This works fine:</source>
          <target state="translated">Прекрасно работает:</target>
        </trans-unit>
        <trans-unit id="d32a8bbfc3e779ddecfadcd682d49cd50e5db2c0" translate="yes" xml:space="preserve">
          <source>Under &lt;em&gt;POSIX&lt;/em&gt; shell, you could not use &lt;em&gt;bashisms&lt;/em&gt;, so there is no &lt;em&gt;builtin&lt;/em&gt;&lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">В оболочке &lt;em&gt;POSIX&lt;/em&gt; вы не можете использовать &lt;em&gt;bashisms&lt;/em&gt; , поэтому нет &lt;em&gt;встроенного&lt;/em&gt; &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3d7e2f61e8f32a1ae973fc94bb4197e186095d4" translate="yes" xml:space="preserve">
          <source>Under bash, when you access a variable name without specifying index, you always address first element only!</source>
          <target state="translated">Под bash,когда вы получаете доступ к имени переменной без указания индекса,вы всегда обращаетесь только к первому элементу!</target>
        </trans-unit>
        <trans-unit id="ea6508f50790e35b9b9d80ac7edc335be5414591" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;Stack&amp;nbsp;Overflow question&lt;/em&gt; syntax,</source>
          <target state="translated">Используя синтаксис &lt;em&gt;вопроса Stack Overflow&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="9a2da18a7bf535275c4e7f972fa322a4ed255d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;Stack&amp;nbsp;Overflow question&lt;/em&gt; syntax:</source>
          <target state="translated">Использование синтаксиса &lt;em&gt;вопроса переполнения стека&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="6d868372db567c7c4882189257fe82c1fd3bf18c" translate="yes" xml:space="preserve">
          <source>When do we need curly braces around shell variables?</source>
          <target state="translated">Когда нам нужны фигурные скобки вокруг переменных оболочки?</target>
        </trans-unit>
        <trans-unit id="e012bd2854254580514f478d3bb60e50df1d66cc" translate="yes" xml:space="preserve">
          <source>Will output</source>
          <target state="translated">Волевой вывод</target>
        </trans-unit>
        <trans-unit id="ab40238dc123ed0ec7be782ed27a673ceb626a15" translate="yes" xml:space="preserve">
          <source>Will output &lt;code&gt;&quot;daniel&quot;san&lt;/code&gt;, and not &lt;code&gt;danielsan&lt;/code&gt;, as you might have wanted.
In this case you should do instead:</source>
          <target state="translated">&lt;code&gt;danielsan&lt;/code&gt; &lt;code&gt;&quot;daniel&quot;san&lt;/code&gt; , а не danielsan , как вы, возможно, хотели. В этом случае вы должны сделать вместо этого:</target>
        </trans-unit>
        <trans-unit id="8fd90e44035bd17dbb78c97fbba80096c6263b8f" translate="yes" xml:space="preserve">
          <source>With one space in between:</source>
          <target state="translated">С одним пробелом между ними:</target>
        </trans-unit>
        <trans-unit id="871e01daf406c1892151bd181c141d675e07320c" translate="yes" xml:space="preserve">
          <source>Yet another approach...</source>
          <target state="translated">Еще один подход...</target>
        </trans-unit>
        <trans-unit id="91a638bb31ee9ad130888c9815b0119d9a453d13" translate="yes" xml:space="preserve">
          <source>Yet another way to skin a cat. This time with functions :D</source>
          <target state="translated">Еще один способ снять шкуру с кошки.На этот раз с функциями :D</target>
        </trans-unit>
        <trans-unit id="a531591bd4aed429a40efdf39f39312ef690fdb1" translate="yes" xml:space="preserve">
          <source>You can concatenate without the quotes. Here is an example:</source>
          <target state="translated">Ты можешь конкатенировать без кавычек.Вот пример:</target>
        </trans-unit>
        <trans-unit id="5eaa802aaf4ac75bd51f813943445b77cbe195d2" translate="yes" xml:space="preserve">
          <source>You can do this too:</source>
          <target state="translated">Ты тоже можешь это сделать:</target>
        </trans-unit>
        <trans-unit id="f70be73d85ba20f8535d6dc5a4206127dab6911b" translate="yes" xml:space="preserve">
          <source>You could place another variable instead of 'Hello' or '!'. You could concatenate more strings as well.</source>
          <target state="translated">Вы можете поместить другую переменную вместо 'Hello' или '!'.Можно было бы также сконцентрировать больше строк.</target>
        </trans-unit>
        <trans-unit id="03feafa4ae5e8e1034dce509446863cdba708ae9" translate="yes" xml:space="preserve">
          <source>and leave you with the correct output:</source>
          <target state="translated">и оставить тебя с правильным выходом:</target>
        </trans-unit>
        <trans-unit id="6f3d898257f79b02115e3a52c1801572d3ccc37b" translate="yes" xml:space="preserve">
          <source>and then I get the following output:</source>
          <target state="translated">и тогда я получаю следующий результат:</target>
        </trans-unit>
        <trans-unit id="593869f5e8a639ef50d6fe708ad32edfd44b98b6" translate="yes" xml:space="preserve">
          <source>as it seems to drop $foo and leaves you with:</source>
          <target state="translated">как будто он сбросил $фут и оставил тебя с собой:</target>
        </trans-unit>
        <trans-unit id="18bcac79b4f2aea5ef8ea43f5cd9dd51430ac264" translate="yes" xml:space="preserve">
          <source>but this will work:</source>
          <target state="translated">но это сработает:</target>
        </trans-unit>
        <trans-unit id="10bc1ec735f3b6de29cdc0b026e11da078fbc1e9" translate="yes" xml:space="preserve">
          <source>doesn't work, as you may imagine, but</source>
          <target state="translated">не работает,как ты можешь себе представить,но</target>
        </trans-unit>
        <trans-unit id="fe180a4775ec9b1876f8b66bc4797517bdc706b5" translate="yes" xml:space="preserve">
          <source>enclosing the RHS of an assignment in double quotes is generally a good practice, though it is quite optional in many cases</source>
          <target state="translated">Заключение RHS задания в двойные кавычки,как правило,является хорошей практикой,хотя во многих случаях оно является довольно необязательным.</target>
        </trans-unit>
        <trans-unit id="24c5fb14936b7b8d27e72e207aca33e4a45b11f8" translate="yes" xml:space="preserve">
          <source>produces</source>
          <target state="translated">produces</target>
        </trans-unit>
        <trans-unit id="5add484b1702a015606da5a23c555e6fdee149ba" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;echo &quot;$c&quot;&lt;/code&gt; will produce</source>
          <target state="translated">тогда &lt;code&gt;echo &quot;$c&quot;&lt;/code&gt; выдаст</target>
        </trans-unit>
        <trans-unit id="005d2e406282bfd4d7072659be8cf45340dc43df" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;{}&lt;/code&gt; around variable names to disambiguate their expansion (as in row 2 in the table above). As seen on rows 3 and 4, there is no need for &lt;code&gt;{}&lt;/code&gt; unless a variable is being concatenated with a string that starts with a character that is a valid first character in shell variable name, that is alphabet or underscore.</source>
          <target state="translated">используйте &lt;code&gt;{}&lt;/code&gt; вокруг имен переменных, чтобы устранить неоднозначность их расширения (как в строке 2 в таблице выше). Как видно из строк 3 и 4, нет необходимости в &lt;code&gt;{}&lt;/code&gt; , если переменная не конкатенируется со строкой, которая начинается с символа, который является допустимым первым символом в имени переменной оболочки, то есть является алфавитом или подчеркиванием.</target>
        </trans-unit>
        <trans-unit id="909e4fadfd532cc1d7b59d2485174ef44672a5ec" translate="yes" xml:space="preserve">
          <source>variable &lt;code&gt;a&lt;/code&gt; is a string, but also an integer</source>
          <target state="translated">переменная &lt;code&gt;a&lt;/code&gt; является строкой, но также и целым числом</target>
        </trans-unit>
        <trans-unit id="92e8237524405cfe4179e596467c9268495494d5" translate="yes" xml:space="preserve">
          <source>which produces</source>
          <target state="translated">который производит</target>
        </trans-unit>
        <trans-unit id="325bac1115922b539b20a947c68348d86ae1e4e3" translate="yes" xml:space="preserve">
          <source>with an extra space.</source>
          <target state="translated">с дополнительным пространством.</target>
        </trans-unit>
        <trans-unit id="fde63634acbe4ff5f906859e13d40c19d4eeb787" translate="yes" xml:space="preserve">
          <source>with backticks, you have to escape inner forks with &lt;em&gt;backslashes&lt;/em&gt;:</source>
          <target state="translated">с обратными чертами вы должны избегать внутренних вилок с &lt;em&gt;обратными слешами&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="12fb46f3c161e46bb95ce405273979b44a2caf5e" translate="yes" xml:space="preserve">
          <source>works fine!</source>
          <target state="translated">работает отлично!</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
