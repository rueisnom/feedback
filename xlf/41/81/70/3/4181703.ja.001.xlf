<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/4181703">
    <body>
      <group id="4181703">
        <trans-unit id="4bd1d3cc3136e5c3d71fc0745b3d07eb11921ec2" translate="yes" xml:space="preserve">
          <source>(Because I am frugal, I will only use two variables &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; and then re-use the same in the whole answer. ;-)</source>
          <target state="translated">（私は質素なので、私は2つの変数 &lt;code&gt;foo&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; のみを使用し 、それを答え全体で再利用します。;-)</target>
        </trans-unit>
        <trans-unit id="3ed780fbe42c35c04706582604649e133dadc0e5" translate="yes" xml:space="preserve">
          <source>(NOTE: &lt;code&gt;date&lt;/code&gt; on macOS does not offer nanoseconds, so this must be done on Linux.)</source>
          <target state="translated">（注：macOSの &lt;code&gt;date&lt;/code&gt; はナノ秒を提供しないため、これはLinuxで実行する必要があります。）</target>
        </trans-unit>
        <trans-unit id="adcf7ac4dae866aa597be61d4bc723836b15d956" translate="yes" xml:space="preserve">
          <source>...and yet yet another one.</source>
          <target state="translated">...と、またしても</target>
        </trans-unit>
        <trans-unit id="b41db4deb31715bf7bf36e52424cf9ce6795750e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+=&lt;/code&gt; is better from a performance standpoint if a big string is being constructed in small increments, especially in a loop</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; は、特にループ内で大きな文字列を小さな増分で構築する場合、パフォーマンスの観点から優れています。</target>
        </trans-unit>
        <trans-unit id="5af36a2e7e39d199453ed1d4361dacec96231975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+=&lt;/code&gt;: Append to variable</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; ：変数に追加</target>
        </trans-unit>
        <trans-unit id="05d6df9d483a7b6d16a3f29398d269a5e619edc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf&lt;/code&gt;: Re-construct variable using the &lt;em&gt;builtin&lt;/em&gt; command</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; ： &lt;em&gt;組み込み&lt;/em&gt;コマンドを使用して変数を再構築します</target>
        </trans-unit>
        <trans-unit id="92340b09e3176c06e36dd2e613d7b3008da8067c" translate="yes" xml:space="preserve">
          <source>A few notes:</source>
          <target state="translated">ちょっとした注意点。</target>
        </trans-unit>
        <trans-unit id="a84621f46f0fee168321d457ef3de65caadd50d9" translate="yes" xml:space="preserve">
          <source>Any script using this operator on older Bash versions will fail with a &quot;command not found&quot; error if you are lucky, or a &quot;syntax error near unexpected token&quot;.</source>
          <target state="translated">古いバージョンの Bash でこの演算子を使ったスクリプトは、運が良ければ &quot;command not found&quot; エラーで失敗するか、&quot;予期しないトークンの近くで構文エラー&quot; が発生します。</target>
        </trans-unit>
        <trans-unit id="f9ffbe9bae5466efe9eff1924bec37046780c4b9" translate="yes" xml:space="preserve">
          <source>Append to an array &lt;code&gt;var+=(...)&lt;/code&gt;</source>
          <target state="translated">配列に &lt;code&gt;var+=(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c917d872ad7580c1d2a82bb2b09f9cb7afd46a1f" translate="yes" xml:space="preserve">
          <source>Append to an integer &lt;code&gt;((var+=...))&lt;/code&gt;</source>
          <target state="translated">整数に追加する &lt;code&gt;((var+=...))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87545afb385457472346e8c34f5e307d0ea09c7" translate="yes" xml:space="preserve">
          <source>Append to string &lt;code&gt;var+=...&lt;/code&gt;</source>
          <target state="translated">文字列 &lt;code&gt;var+=...&lt;/code&gt; に追加</target>
        </trans-unit>
        <trans-unit id="9019e62d634cc49064c4af923be91dc426a71d8e" translate="yes" xml:space="preserve">
          <source>As this question stand specifically for &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt;, my first part of the answer would present different ways of doing this properly:</source>
          <target state="translated">この質問は特に&lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bashを&lt;/a&gt;表しているので、私の答えの最初の部分では、これを適切に行うためのさまざまな方法を示します。</target>
        </trans-unit>
        <trans-unit id="45142948cb319477715fce1d34dcb1007fd42b92" translate="yes" xml:space="preserve">
          <source>Bash also supports a &lt;code&gt;+=&lt;/code&gt; operator as shown in this code:</source>
          <target state="translated">次のコードに示すように、bashは &lt;code&gt;+=&lt;/code&gt; 演算子もサポートしています。</target>
        </trans-unit>
        <trans-unit id="6272217110d63d3314649dc98f68993b3f4fc25b" translate="yes" xml:space="preserve">
          <source>Bash first</source>
          <target state="translated">バッシュファースト</target>
        </trans-unit>
        <trans-unit id="2b9b5a17640aba2390f955e194ba0c5459a7f8f8" translate="yes" xml:space="preserve">
          <source>BashFAQ/013 - How can I concatenate two variables?</source>
          <target state="translated">BashFAQ013-2つの変数を連結するにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="99583553fb98177526bd20eae2a56b4038ac4e39" translate="yes" xml:space="preserve">
          <source>Basically</source>
          <target state="translated">Basically</target>
        </trans-unit>
        <trans-unit id="f047bd2fcec20f719e0562e02bb415076a2d577e" translate="yes" xml:space="preserve">
          <source>But this is not easy for &lt;em&gt;nesting&lt;/em&gt;:</source>
          <target state="translated">しかし、これは&lt;em&gt;ネストするの&lt;/em&gt;は簡単ではありません：</target>
        </trans-unit>
        <trans-unit id="87bd9427b02292d06a7de4d66383145cca8e6fbc" translate="yes" xml:space="preserve">
          <source>But you could simply do:</source>
          <target state="translated">しかし、あなたは単純にそうすることができました。</target>
        </trans-unit>
        <trans-unit id="5f290d2b8034d7265ac5e9c5f19bfe9423cc6d4d" translate="yes" xml:space="preserve">
          <source>Curly brackets will fit to Continuous string usage:</source>
          <target state="translated">巻き括弧は、連続した文字列の使用法に適合します。</target>
        </trans-unit>
        <trans-unit id="d82948156c93a167a453437c93a3dfd57e09e8a9" translate="yes" xml:space="preserve">
          <source>Despite of the special operator, &lt;code&gt;+=&lt;/code&gt;, for concatenation, there is a simpler way to go:</source>
          <target state="translated">連結のための特別な演算子 &lt;code&gt;+=&lt;/code&gt; にもかかわらず、より簡単な方法があります：</target>
        </trans-unit>
        <trans-unit id="061fabe1a3aee116bd4d5460d512e6927c9604aa" translate="yes" xml:space="preserve">
          <source>Double quotes take an extra calculation time for interpretation of variables inside. Avoid it if possible.</source>
          <target state="translated">二重引用符は、内部の変数の解釈に余計な計算時間がかかります。可能であれば避けてください。</target>
        </trans-unit>
        <trans-unit id="33fcbe45dd33298fc2b3a8b03f45c79724aa9165" translate="yes" xml:space="preserve">
          <source>Even if the += operator is now permitted, it has been introduced in &lt;strong&gt;Bash 3.1&lt;/strong&gt; in 2004.</source>
          <target state="translated">+ =演算子が許可された場合でも、2004年に&lt;strong&gt;Bash 3.1&lt;/strong&gt;で導入されました。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="f6f431c6d1b83fdc76c20f5dbc1efe535d0f1ae4" translate="yes" xml:space="preserve">
          <source>For those who cares about backward compatibility, stick with the older standard Bash concatenation methods, like those mentioned in the chosen answer:</source>
          <target state="translated">下位互換性を気にする人は、選択された答えで述べられているような古い標準的な Bash の連結方法に固執してください。</target>
        </trans-unit>
        <trans-unit id="4b7550837fb71ce5dc516a85fe3ebea51669a90c" translate="yes" xml:space="preserve">
          <source>Formatted, using &lt;em&gt;forked&lt;/em&gt;&lt;code&gt;printf&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;フォークされた&lt;/em&gt; &lt;code&gt;printf&lt;/code&gt; を使用してフォーマット</target>
        </trans-unit>
        <trans-unit id="96c9a559e8db14c487dda610affda849531e73f2" translate="yes" xml:space="preserve">
          <source>Here is a concise summary of what most answers are talking about.</source>
          <target state="translated">ほとんどの回答者が話していることを簡潔にまとめてみました。</target>
        </trans-unit>
        <trans-unit id="2248bd500c18170425820e91a0ef3024f446b852" translate="yes" xml:space="preserve">
          <source>Here is the one through &lt;a href=&quot;http://en.wikipedia.org/wiki/AWK&quot;&gt;AWK&lt;/a&gt;:</source>
          <target state="translated">これが&lt;a href=&quot;http://en.wikipedia.org/wiki/AWK&quot;&gt;AWK&lt;/a&gt;を介したものです。</target>
        </trans-unit>
        <trans-unit id="bfd7e226ecef699774482324a6b142aaa2c37d1b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;$foo&lt;/code&gt; becomes &quot;Hello World&quot;.</source>
          <target state="translated">ここで、 &lt;code&gt;$foo&lt;/code&gt; は「Hello World」になります。</target>
        </trans-unit>
        <trans-unit id="bc577f90688a74d1fc87891d866a16700187afd1" translate="yes" xml:space="preserve">
          <source>Historically, you could use &lt;em&gt;backticks&lt;/em&gt; for retrieving result of a &lt;em&gt;fork&lt;/em&gt;:</source>
          <target state="translated">歴史的には、 &lt;em&gt;フォークの&lt;/em&gt;結果を取得するために&lt;em&gt;バックティック&lt;/em&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="5e0e0a3dfcf33ed4acc9ce3503792e75ac7cf96b" translate="yes" xml:space="preserve">
          <source>Hmm.. &lt;a href=&quot;https://serverfault.com/a/208266/142978&quot;&gt;this is not a bug, but a feature&lt;/a&gt;... To prevent bash to try to develop &lt;code&gt;!&quot;&lt;/code&gt;, you could:</source>
          <target state="translated">うーん、 &lt;a href=&quot;https://serverfault.com/a/208266/142978&quot;&gt;これはバグではなく機能&lt;/a&gt;です... bashが開発を試みないようにするために &lt;code&gt;!&quot;&lt;/code&gt; 、次のことができます。</target>
        </trans-unit>
        <trans-unit id="98589eda0b0c3350efeb7df609481a8612eef1f0" translate="yes" xml:space="preserve">
          <source>How is this accomplished in Bash?</source>
          <target state="translated">これはBashではどのようにして実現されているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="6a2e6f81fd6ac37d46c523c21beba38638180d0d" translate="yes" xml:space="preserve">
          <source>How to concatenate string variables in Bash</source>
          <target state="translated">Bashで文字列変数を連結する方法</target>
        </trans-unit>
        <trans-unit id="470f68da03b911ef6709722d3140d5a7814b314e" translate="yes" xml:space="preserve">
          <source>I do it this way when convenient: Use an inline command!</source>
          <target state="translated">私は便利な時はこの方法でやっています。インラインコマンドを使う</target>
        </trans-unit>
        <trans-unit id="467721da41492e4bb81590c0bb56387ca9eeb51f" translate="yes" xml:space="preserve">
          <source>I don't know about PHP yet, but this works in Linux Bash. If you don't want to affect it to a variable, you could try this:</source>
          <target state="translated">PHPについてはまだわかりませんが、これはLinuxのBashで動作します。変数に影響を与えたくない場合は、以下のようにしてみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="2d5c981dbbad201f3bbc11b6fdacef1a2a28d7f9" translate="yes" xml:space="preserve">
          <source>I have created &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;append_test.sh on GitHub&lt;/a&gt; with the contents:</source>
          <target state="translated">&lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;GitHubにappend_test.sh&lt;/a&gt;を作成し、次の内容を含めました 。</target>
        </trans-unit>
        <trans-unit id="df60ad75b0491805267dfff61134960304cc8674" translate="yes" xml:space="preserve">
          <source>I kind of like making a quick function.</source>
          <target state="translated">クイック機能を作るのが好きなんだ</target>
        </trans-unit>
        <trans-unit id="35816762d51684f0de91167ddbc3f78b49194000" translate="yes" xml:space="preserve">
          <source>I prefer to use curly brackets &lt;code&gt;${}&lt;/code&gt; for expanding variable in string:</source>
          <target state="translated">文字列の変数を展開するために中括弧 &lt;code&gt;${}&lt;/code&gt; を使用することを好みます。</target>
        </trans-unit>
        <trans-unit id="6515924b2fdbe8380a92f0af7780f9e61495663f" translate="yes" xml:space="preserve">
          <source>I wanted to build a string from a list. Couldn't find an answer for that so I post it here. Here is what I did:</source>
          <target state="translated">リストから文字列を作りたいと思いました。そのための答えが見つからなかったので、ここに投稿します。私がやったことは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9bff2a79b85772297cfcbaa68bb7b6557aa73dd0" translate="yes" xml:space="preserve">
          <source>If it is as your example of adding &lt;code&gt;&quot; World&quot;&lt;/code&gt; to the original string, then it can be:</source>
          <target state="translated">元の文字列に &lt;code&gt;&quot; World&quot;&lt;/code&gt; を追加する例の場合は、 次のようになります。</target>
        </trans-unit>
        <trans-unit id="8a150e41a394fe65e305a228a887924fcaf285ef" translate="yes" xml:space="preserve">
          <source>If what you are trying to do is to &lt;em&gt;split&lt;/em&gt; a string into several lines, you can use a backslash:</source>
          <target state="translated">文字列を複数の行に&lt;em&gt;分割&lt;/em&gt;する場合は、バックスラッシュを使用できます。</target>
        </trans-unit>
        <trans-unit id="3d1bd98eba26b54d374352283f5c8effae6e1f03" translate="yes" xml:space="preserve">
          <source>If you try to concatenate a string with another string, for example,</source>
          <target state="translated">例えば、文字列を別の文字列と連結しようとした場合。</target>
        </trans-unit>
        <trans-unit id="2361bd2fbeb116748c047b41ff0d3f439612678a" translate="yes" xml:space="preserve">
          <source>If you want to append something like an underscore, use escape (\)</source>
          <target state="translated">アンダースコアのようなものを追加したい場合は、エスケープ(esscape)を使用します。</target>
        </trans-unit>
        <trans-unit id="b1035e2881f6270ad0c3c2063687ee85e31e26ee" translate="yes" xml:space="preserve">
          <source>If you want to use more sophisticated constructions you have to use a &lt;em&gt;fork&lt;/em&gt; (new child process that make the job and return the result via &lt;code&gt;stdout&lt;/code&gt;):</source>
          <target state="translated">より洗練された構造を使用したい場合は、 &lt;em&gt;フォーク&lt;/em&gt; （ジョブを作成して &lt;code&gt;stdout&lt;/code&gt; を介して結果を返す新しい子プロセス）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="11fe5aa37000e7af29a90564aa80284fb3a6ddf0" translate="yes" xml:space="preserve">
          <source>In PHP, strings are concatenated together as follows:</source>
          <target state="translated">PHPでは、以下のように文字列を連結します。</target>
        </trans-unit>
        <trans-unit id="6f39848fc3cad9f2f63ac3212b2dac4f68c4fd33" translate="yes" xml:space="preserve">
          <source>In general to concatenate two variables you can just write them one after another:</source>
          <target state="translated">一般的には、2つの変数を連結するには、次から次へと書いていけばいいのです。</target>
        </trans-unit>
        <trans-unit id="9218f385063dd34e45700fe7ab2d28aa12027888" translate="yes" xml:space="preserve">
          <source>In my opinion, the simplest way to concatenate two strings is to write a function that does it for you, then use that function.</source>
          <target state="translated">私の考えでは、2つの文字列を連結する最も簡単な方法は、それをしてくれる関数を書いて、その関数を使うことだと思います。</target>
        </trans-unit>
        <trans-unit id="31a6c4cacbadbe7e6a8bd544cc7e65719fce7ab9" translate="yes" xml:space="preserve">
          <source>Let's say we have two variables and $1 is set to 'one':</source>
          <target state="translated">2つの変数があり、$1が'1'に設定されているとします。</target>
        </trans-unit>
        <trans-unit id="7f532384aa967b5bdc460f66dd85df621b543f6b" translate="yes" xml:space="preserve">
          <source>Nota: The use of &lt;em&gt;double-quotes&lt;/em&gt; may be useful for manipulating strings that contain &lt;code&gt;spaces&lt;/code&gt;, &lt;code&gt;tabulations&lt;/code&gt; and/or &lt;code&gt;newlines&lt;/code&gt;</source>
          <target state="translated">注意： &lt;em&gt;二重引用符&lt;/em&gt;の使用は、 &lt;code&gt;spaces&lt;/code&gt; 、 &lt;code&gt;tabulations&lt;/code&gt; 、および/または &lt;code&gt;newlines&lt;/code&gt; を含む文字列を操作するのに役立ちます 。</target>
        </trans-unit>
        <trans-unit id="16d9f74c5071b2a7b73caf5323062bbf69de994d" translate="yes" xml:space="preserve">
          <source>Note that between parentheses, there is a &lt;em&gt;space separated array&lt;/em&gt;. If you want to store a string containing spaces in your array, you have to enclose them:</source>
          <target state="translated">括弧の間に&lt;em&gt;スペースで区切られた配列&lt;/em&gt;があることに注意してください。 配列にスペースを含む文字列を格納する場合は、それらを囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="d75948a16a0e3e8f5f2e46c92ff7994f3218bd45" translate="yes" xml:space="preserve">
          <source>Note that our &lt;code&gt;a&lt;/code&gt; is still an array! Only first element is changed!</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; はまだ配列であることに注意してください！ 最初の要素のみが変更されます！</target>
        </trans-unit>
        <trans-unit id="43fddc7b23f4c7838d65564a074aee691c438546" translate="yes" xml:space="preserve">
          <source>Note that this won't work</source>
          <target state="translated">これは動作しませんのでご注意ください。</target>
        </trans-unit>
        <trans-unit id="8a4844dda52f0c26f5af432efbb40409bda7cde9" translate="yes" xml:space="preserve">
          <source>One argument format string with many argument passed to:</source>
          <target state="translated">1つの引数形式の文字列で、多くの引数が渡されます。</target>
        </trans-unit>
        <trans-unit id="36660cb47e775732843ecb2655cd60434aa3f239" translate="yes" xml:space="preserve">
          <source>Or we could use &lt;em&gt;one argument format string&lt;/em&gt; which will be repeated as many argument submitted...</source>
          <target state="translated">または、送信された引数の数だけ繰り返される&lt;em&gt;1つの引数フォーマット文字列&lt;/em&gt;を使用することもできます...</target>
        </trans-unit>
        <trans-unit id="279f60bf9a525240c46a2d3699489765843259f7" translate="yes" xml:space="preserve">
          <source>Otherwise using &lt;code&gt;foo = &quot;$fooWorld&quot;&lt;/code&gt; will not work.</source>
          <target state="translated">そうしないと、 &lt;code&gt;foo = &quot;$fooWorld&quot;&lt;/code&gt; を使用しても機能しません。</target>
        </trans-unit>
        <trans-unit id="d9f0b837f6b79e52ab2a34a74f68668672128a4a" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;a&lt;/code&gt; is also an array of only one element.</source>
          <target state="translated">私たちの &lt;code&gt;a&lt;/code&gt; も1つの要素のみの配列です。</target>
        </trans-unit>
        <trans-unit id="1771e4c9acf6dde706b3b7fa5860621248195877" translate="yes" xml:space="preserve">
          <source>PREFIX_HELLO_WORLD</source>
          <target state="translated">PREFIX_HELLO_WORLD</target>
        </trans-unit>
        <trans-unit id="87eb592b096fe1bc9286f71d12faf9a6552a868a" translate="yes" xml:space="preserve">
          <source>PREFIX_WORLD</source>
          <target state="translated">PREFIX_WORLD</target>
        </trans-unit>
        <trans-unit id="dee69127295d004ceef94bf9e5bdab008cf2d5ec" translate="yes" xml:space="preserve">
          <source>Plus take a look at other answer about &lt;strong&gt;+=&lt;/strong&gt;</source>
          <target state="translated">プラス&lt;strong&gt;+ =&lt;/strong&gt;について他の回答を見てください</target>
        </trans-unit>
        <trans-unit id="719ac2e5ed17645b278921f59e179e7c8f800769" translate="yes" xml:space="preserve">
          <source>Safer way:</source>
          <target state="translated">より安全な方法。</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="8667cec4c6c0a55f3f90079fdd67283ecb218068" translate="yes" xml:space="preserve">
          <source>Shell now</source>
          <target state="translated">現在のシェル</target>
        </trans-unit>
        <trans-unit id="53517aeaf2261fd62cf086622d3b029b513c0d37" translate="yes" xml:space="preserve">
          <source>So to retrieve our seven field array, we only need to re-set 1st element:</source>
          <target state="translated">ですから、7つのフィールドの配列を取得するためには、1番目の要素を再設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="27289f5e2e72d52b42f56975a352ef1503ab370e" translate="yes" xml:space="preserve">
          <source>Strings containing spaces can become part of command, use &quot;$XXX&quot; and &quot;${XXX}&quot; to avoid these errors.</source>
          <target state="translated">スペースを含む文字列はコマンドの一部になることがあるので、これらのエラーを避けるために &quot;$XXX&quot; と &quot;${XXX}&quot; を使用してください。</target>
        </trans-unit>
        <trans-unit id="fc55bd621afd18d3f9e08f2edf48af5bb50f5e1a" translate="yes" xml:space="preserve">
          <source>Test 1:</source>
          <target state="translated">テスト1.</target>
        </trans-unit>
        <trans-unit id="159b00a4fd6d920b86d8b7523b32be7f6b1a3f8c" translate="yes" xml:space="preserve">
          <source>Test 2:</source>
          <target state="translated">テスト2.</target>
        </trans-unit>
        <trans-unit id="32b1cd28de4997ecac10988388a3c6f27f1f4e0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;printf&lt;/code&gt;&lt;em&gt;builtin&lt;/em&gt; command gives a powerful way of drawing string format. As this is a Bash &lt;em&gt;builtin&lt;/em&gt;, there is a option for sending formatted string to a variable instead of printing on &lt;code&gt;stdout&lt;/code&gt;:</source>
          <target state="translated">&lt;em&gt;組み込み&lt;/em&gt;の &lt;code&gt;printf&lt;/code&gt; コマンドは、文字列形式を描画する強力な方法を提供します。 これはBash &lt;em&gt;組み込み&lt;/em&gt;であるため、 &lt;code&gt;stdout&lt;/code&gt; 代わりに、フォーマットされた文字列を変数に送信するオプションがあります。</target>
        </trans-unit>
        <trans-unit id="83e416ba1eaa9a4279e3d3c10315ea18cd865fb5" translate="yes" xml:space="preserve">
          <source>The errors indicate that my Bash got up to &lt;strong&gt;335.54432 MB&lt;/strong&gt; before it crashed. You could change &lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;the code&lt;/a&gt; from doubling the data to appending a constant to get a more granular graph and failure point. But I think this should give you enough information to decide whether you care. Personally, below 100&amp;nbsp;MB I don't. Your mileage may vary.</source>
          <target state="translated">エラーは、Bashがクラッシュする前に&lt;strong&gt;335.54432 MB&lt;/strong&gt;に&lt;strong&gt;達した&lt;/strong&gt;ことを示しています。 データを2倍に&lt;a href=&quot;https://gist.github.com/RichardBronosky/dd4deaa3b9b0e2a59198f28e6334ef36&quot;&gt;するコード&lt;/a&gt;から定数を追加するコードに変更して 、より詳細なグラフと障害点を取得できます。 しかし、これはあなたが気にするかどうかを決定するのに十分な情報をあなたに与えるべきだと思います。 個人的には、100 MB未満ではありません。 あなたのマイレージは異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">アウトプットです。</target>
        </trans-unit>
        <trans-unit id="69bb31328df0691de52625b07666156e1b902430" translate="yes" xml:space="preserve">
          <source>The simplest way with quotation marks:</source>
          <target state="translated">引用符を使った一番シンプルな方法。</target>
        </trans-unit>
        <trans-unit id="2ad5c63cc2c6ab78b38fc26f2339035fd0e19592" translate="yes" xml:space="preserve">
          <source>The syntax &lt;strong&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/strong&gt; may be used in different ways:</source>
          <target state="translated">構文&lt;strong&gt; &lt;code&gt;+=&lt;/code&gt; &lt;/strong&gt;はさまざまな方法で使用できます。</target>
        </trans-unit>
        <trans-unit id="6cd691a88ea59ef340905ac53356df5effe747fd" translate="yes" xml:space="preserve">
          <source>The table below explains the different contexts where we can combine the values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to create a new variable, &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">以下の表は &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の値を組み合わせて新しい変数 &lt;code&gt;c&lt;/code&gt; を作成できるさまざまなコンテキストを示しています。</target>
        </trans-unit>
        <trans-unit id="2c3e52ae28a38ff578be8e3e7dbfc958d04c64ce" translate="yes" xml:space="preserve">
          <source>The way I'd solve the problem is just</source>
          <target state="translated">私が解決する方法は</target>
        </trans-unit>
        <trans-unit id="94dea865f36eb2a17a49ec7744c9cd0003e14d92" translate="yes" xml:space="preserve">
          <source>There are seven &lt;em&gt;strings&lt;/em&gt; in this array. So we could build a formatted string containing exactly seven positional arguments:</source>
          <target state="translated">この配列には7つの&lt;em&gt;文字列&lt;/em&gt;があります。 したがって、正確に7つの位置引数を含むフォーマットされた文字列を作成できます。</target>
        </trans-unit>
        <trans-unit id="fb165be54b165d1c959a0c982060f22f1aa1c925" translate="yes" xml:space="preserve">
          <source>There are voiced concerns about performance, but no data is offered. Let me suggest a simple test.</source>
          <target state="translated">性能を心配する声があるが、データが出てこない。簡単なテストを提案します。</target>
        </trans-unit>
        <trans-unit id="369a75e97f318d6ec145a9493109e6364a6829ed" translate="yes" xml:space="preserve">
          <source>There's one particular case where you should take care:</source>
          <target state="translated">特に気をつけなければならないことがあります。</target>
        </trans-unit>
        <trans-unit id="2c3c35a74ab1ce4bc2031b207d811e22c1c07906" translate="yes" xml:space="preserve">
          <source>This does &lt;em&gt;not&lt;/em&gt; work:</source>
          <target state="translated">これは機能しませ&lt;em&gt;ん&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="cb780e8eb924fadf79808d44840abbcd92d1563a" translate="yes" xml:space="preserve">
          <source>This is an example of a Bash script:</source>
          <target state="translated">これはBashスクリプトの例です。</target>
        </trans-unit>
        <trans-unit id="e188f83fdefc6603d01c6584f28c5195768dd202" translate="yes" xml:space="preserve">
          <source>This is how you concatenate two strings.</source>
          <target state="translated">これが2つの文字列を連結する方法です。</target>
        </trans-unit>
        <trans-unit id="db44249067683e4ab33834a42f5d074a526ab936" translate="yes" xml:space="preserve">
          <source>This is useful when 
    &lt;code&gt;$blaohai&lt;/code&gt;
leads to a variable not found error. Or if you have spaces or other special characters in your strings. &lt;code&gt;&quot;${foo}&quot;&lt;/code&gt; properly escapes anything you put into it.</source>
          <target state="translated">これは、 &lt;code&gt;$blaohai&lt;/code&gt; が変数が見つからないというエラーにつながる場合に役立ちます。 または、文字列にスペースやその他の特殊文字が含まれている場合。 &lt;code&gt;&quot;${foo}&quot;&lt;/code&gt; は、入力したものを適切にエスケープします。</target>
        </trans-unit>
        <trans-unit id="bbfed531f3c8084ebfdf51e489df479d5e845d35" translate="yes" xml:space="preserve">
          <source>This last statement would print &quot;OpenSystems&quot; (without quotes).</source>
          <target state="translated">この最後の文は、&quot;OpenSystems&quot;(引用符なし)と表示されます。</target>
        </trans-unit>
        <trans-unit id="6c47bc5f898e5e62e29dd7dfd964d007a17d9276" translate="yes" xml:space="preserve">
          <source>This one also adds only one space in between:</source>
          <target state="translated">こちらも間に1つだけスペースが追加されています。</target>
        </trans-unit>
        <trans-unit id="e4bf4a51ac667b923a2a205a96f6bee4239bd03f" translate="yes" xml:space="preserve">
          <source>This works fine:</source>
          <target state="translated">これで大丈夫です。</target>
        </trans-unit>
        <trans-unit id="d32a8bbfc3e779ddecfadcd682d49cd50e5db2c0" translate="yes" xml:space="preserve">
          <source>Under &lt;em&gt;POSIX&lt;/em&gt; shell, you could not use &lt;em&gt;bashisms&lt;/em&gt;, so there is no &lt;em&gt;builtin&lt;/em&gt;&lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;POSIX&lt;/em&gt;シェルでは、 &lt;em&gt;bashismsを&lt;/em&gt;使用できないため、 &lt;em&gt;組み込みの&lt;/em&gt; &lt;code&gt;printf&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="a3d7e2f61e8f32a1ae973fc94bb4197e186095d4" translate="yes" xml:space="preserve">
          <source>Under bash, when you access a variable name without specifying index, you always address first element only!</source>
          <target state="translated">bashでは、インデックスを指定せずに変数名にアクセスした場合、常に最初の要素のみを指定します。</target>
        </trans-unit>
        <trans-unit id="ea6508f50790e35b9b9d80ac7edc335be5414591" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;Stack&amp;nbsp;Overflow question&lt;/em&gt; syntax,</source>
          <target state="translated">&lt;em&gt;スタックオーバーフローの質問&lt;/em&gt;構文を使用して、</target>
        </trans-unit>
        <trans-unit id="9a2da18a7bf535275c4e7f972fa322a4ed255d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;em&gt;Stack&amp;nbsp;Overflow question&lt;/em&gt; syntax:</source>
          <target state="translated">&lt;em&gt;スタックオーバーフローの質問&lt;/em&gt;構文の使用：</target>
        </trans-unit>
        <trans-unit id="6d868372db567c7c4882189257fe82c1fd3bf18c" translate="yes" xml:space="preserve">
          <source>When do we need curly braces around shell variables?</source>
          <target state="translated">シェル変数の周りに中括弧が必要なのはいつですか?</target>
        </trans-unit>
        <trans-unit id="e012bd2854254580514f478d3bb60e50df1d66cc" translate="yes" xml:space="preserve">
          <source>Will output</source>
          <target state="translated">出力されます。</target>
        </trans-unit>
        <trans-unit id="ab40238dc123ed0ec7be782ed27a673ceb626a15" translate="yes" xml:space="preserve">
          <source>Will output &lt;code&gt;&quot;daniel&quot;san&lt;/code&gt;, and not &lt;code&gt;danielsan&lt;/code&gt;, as you might have wanted.
In this case you should do instead:</source>
          <target state="translated">&lt;code&gt;danielsan&lt;/code&gt; ではなく、 &lt;code&gt;&quot;daniel&quot;san&lt;/code&gt; 出力します。 この場合、代わりに行う必要があります。</target>
        </trans-unit>
        <trans-unit id="8fd90e44035bd17dbb78c97fbba80096c6263b8f" translate="yes" xml:space="preserve">
          <source>With one space in between:</source>
          <target state="translated">間に1つのスペースを挟んで</target>
        </trans-unit>
        <trans-unit id="871e01daf406c1892151bd181c141d675e07320c" translate="yes" xml:space="preserve">
          <source>Yet another approach...</source>
          <target state="translated">まだ別のアプローチ...</target>
        </trans-unit>
        <trans-unit id="91a638bb31ee9ad130888c9815b0119d9a453d13" translate="yes" xml:space="preserve">
          <source>Yet another way to skin a cat. This time with functions :D</source>
          <target state="translated">猫の皮を剥ぐもう一つの方法。今回は機能付きです。</target>
        </trans-unit>
        <trans-unit id="a531591bd4aed429a40efdf39f39312ef690fdb1" translate="yes" xml:space="preserve">
          <source>You can concatenate without the quotes. Here is an example:</source>
          <target state="translated">引用符を使わずに連結することができます。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="5eaa802aaf4ac75bd51f813943445b77cbe195d2" translate="yes" xml:space="preserve">
          <source>You can do this too:</source>
          <target state="translated">こんなこともできるんですね。</target>
        </trans-unit>
        <trans-unit id="f70be73d85ba20f8535d6dc5a4206127dab6911b" translate="yes" xml:space="preserve">
          <source>You could place another variable instead of 'Hello' or '!'. You could concatenate more strings as well.</source>
          <target state="translated">Hello' や '!' の代わりに別の変数を配置することもできます。文字列を連結することもできます。</target>
        </trans-unit>
        <trans-unit id="03feafa4ae5e8e1034dce509446863cdba708ae9" translate="yes" xml:space="preserve">
          <source>and leave you with the correct output:</source>
          <target state="translated">と正しい出力を残します。</target>
        </trans-unit>
        <trans-unit id="6f3d898257f79b02115e3a52c1801572d3ccc37b" translate="yes" xml:space="preserve">
          <source>and then I get the following output:</source>
          <target state="translated">で、以下のような出力が出てきました。</target>
        </trans-unit>
        <trans-unit id="593869f5e8a639ef50d6fe708ad32edfd44b98b6" translate="yes" xml:space="preserve">
          <source>as it seems to drop $foo and leaves you with:</source>
          <target state="translated">これは $foo を削除して、あなたを残しているように見えます。</target>
        </trans-unit>
        <trans-unit id="18bcac79b4f2aea5ef8ea43f5cd9dd51430ac264" translate="yes" xml:space="preserve">
          <source>but this will work:</source>
          <target state="translated">しかし、これはうまくいくでしょう。</target>
        </trans-unit>
        <trans-unit id="10bc1ec735f3b6de29cdc0b026e11da078fbc1e9" translate="yes" xml:space="preserve">
          <source>doesn't work, as you may imagine, but</source>
          <target state="translated">思うようにはいかないが</target>
        </trans-unit>
        <trans-unit id="fe180a4775ec9b1876f8b66bc4797517bdc706b5" translate="yes" xml:space="preserve">
          <source>enclosing the RHS of an assignment in double quotes is generally a good practice, though it is quite optional in many cases</source>
          <target state="translated">二重引用符で課題のRHSを囲むことは一般的に良い習慣ですが、多くの場合はかなり任意です。</target>
        </trans-unit>
        <trans-unit id="24c5fb14936b7b8d27e72e207aca33e4a45b11f8" translate="yes" xml:space="preserve">
          <source>produces</source>
          <target state="translated">produces</target>
        </trans-unit>
        <trans-unit id="5add484b1702a015606da5a23c555e6fdee149ba" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;echo &quot;$c&quot;&lt;/code&gt; will produce</source>
          <target state="translated">&lt;code&gt;echo &quot;$c&quot;&lt;/code&gt; が生成されます</target>
        </trans-unit>
        <trans-unit id="005d2e406282bfd4d7072659be8cf45340dc43df" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;{}&lt;/code&gt; around variable names to disambiguate their expansion (as in row 2 in the table above). As seen on rows 3 and 4, there is no need for &lt;code&gt;{}&lt;/code&gt; unless a variable is being concatenated with a string that starts with a character that is a valid first character in shell variable name, that is alphabet or underscore.</source>
          <target state="translated">変数名の前後に &lt;code&gt;{}&lt;/code&gt; を使用して、それらの展開を明確にします（上記の表の2行目と同様）。 3行目と4行目に見られるように、シェル変数名の有効な最初の文字である文字で始まる文字列（つまり、アルファベットまたはアンダースコア）で変数を連結しない限り、 &lt;code&gt;{}&lt;/code&gt; は必要ありません。</target>
        </trans-unit>
        <trans-unit id="909e4fadfd532cc1d7b59d2485174ef44672a5ec" translate="yes" xml:space="preserve">
          <source>variable &lt;code&gt;a&lt;/code&gt; is a string, but also an integer</source>
          <target state="translated">変数 &lt;code&gt;a&lt;/code&gt; は文字列ですが、整数でもあります</target>
        </trans-unit>
        <trans-unit id="92e8237524405cfe4179e596467c9268495494d5" translate="yes" xml:space="preserve">
          <source>which produces</source>
          <target state="translated">生み出す</target>
        </trans-unit>
        <trans-unit id="325bac1115922b539b20a947c68348d86ae1e4e3" translate="yes" xml:space="preserve">
          <source>with an extra space.</source>
          <target state="translated">余裕を持って。</target>
        </trans-unit>
        <trans-unit id="fde63634acbe4ff5f906859e13d40c19d4eeb787" translate="yes" xml:space="preserve">
          <source>with backticks, you have to escape inner forks with &lt;em&gt;backslashes&lt;/em&gt;:</source>
          <target state="translated">バックティックを使用する場合は、 &lt;em&gt;バックスラッシュで&lt;/em&gt;内側のフォークを&lt;em&gt;エスケープ&lt;/em&gt;する必要があり&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="12fb46f3c161e46bb95ce405273979b44a2caf5e" translate="yes" xml:space="preserve">
          <source>works fine!</source>
          <target state="translated">順調</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
