<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/419163">
    <body>
      <group id="419163">
        <trans-unit id="be437cc206c4a893439095f2b33790a548b29bdd" translate="yes" xml:space="preserve">
          <source>(&lt;strong&gt;instead&lt;/strong&gt;) If your module is not the main program but was imported by another one, then &lt;code&gt;__name__&lt;/code&gt; will be &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, not &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;, and it'll skip the body of the &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">( &lt;strong&gt;대신&lt;/strong&gt; ) 모듈이 메인 프로그램은 아니지만 다른 프로그램으로 가져온 경우 &lt;code&gt;__name__&lt;/code&gt; 은 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 이 아니라 &quot; &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 이며 &lt;code&gt;if&lt;/code&gt; 문의 본문을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="87357c2f1577f162cab1176800cb98e9ae9f1df0" translate="yes" xml:space="preserve">
          <source>(As an aside, &lt;a href=&quot;https://stackoverflow.com/questions/23000075/purpose-of-if-name-main&quot;&gt;this question&lt;/a&gt; contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of &lt;a href=&quot;https://stackoverflow.com/questions/419163/what-does-if-name-main-do&quot;&gt;this one&lt;/a&gt;, which I think is a mistake.)</source>
          <target state="translated">(여기서, &lt;a href=&quot;https://stackoverflow.com/questions/23000075/purpose-of-if-name-main&quot;&gt;이 질문&lt;/a&gt; 에는 @kindall의 답변이 마침내 이해하는 데 도움이되었습니다. 이유는 방법이 아닌 이유입니다. 불행히도 이것은 실수라고 생각되는 &lt;a href=&quot;https://stackoverflow.com/questions/419163/what-does-if-name-main-do&quot;&gt;이&lt;/a&gt; 복제본으로 표시되었습니다.)</target>
        </trans-unit>
        <trans-unit id="99ee0547f367b7fbe108d02a06130f410fdeed36" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;This idiom can also be found in the Python documentation in an explanation of the &lt;code&gt;__main__&lt;/code&gt; module.&lt;/a&gt; That text states:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;이 관용구는 또한 파이썬 설명서에서 &lt;code&gt;__main__&lt;/code&gt; 모듈에 대한 설명에서 찾을 수 있습니다.&lt;/a&gt; 그 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d07b4aba29e620e47507cb0c3f0488674297686a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'__main__'&lt;/code&gt; is the name of the scope in which top-level code executes. A module&amp;rsquo;s &lt;code&gt;__name__&lt;/code&gt; is set equal to &lt;code&gt;'__main__'&lt;/code&gt; when read from standard input, a script, or from an interactive prompt.</source>
          <target state="translated">&lt;code&gt;'__main__'&lt;/code&gt; 은 최상위 코드가 실행되는 범위의 이름입니다. 표준 입력, 스크립트 또는 대화식 프롬프트에서 읽을 때 모듈의 &lt;code&gt;__name__&lt;/code&gt; 은 &lt;code&gt;'__main__'&lt;/code&gt; 과 동일하게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fafdac69f04bc2657902a7797c051653adc55033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__main__&lt;/code&gt;: Like other programming languages, Python too has an execution entry point, i.e., main. &lt;code&gt;'__main__'&lt;/code&gt;&lt;em&gt;is the name of the scope in which top-level code executes&lt;/em&gt;. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its &lt;code&gt;__name__&lt;/code&gt; is set to &lt;code&gt;__main__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__main__&lt;/code&gt; : 다른 프로그래밍 언어와 마찬가지로 Python에도 실행 진입 점이 있습니다 (예 : main). &lt;code&gt;'__main__'&lt;/code&gt; &lt;em&gt;은 최상위 코드가 실행되는 범위의 이름입니다&lt;/em&gt; . 기본적으로 Python 모듈을 사용하는 두 가지 방법이 있습니다. 직접 스크립트로 실행하거나 가져옵니다. 모듈이 스크립트로 실행될 때 &lt;code&gt;__name__&lt;/code&gt; 은 &lt;code&gt;__main__&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="39eb9da36f02c4419a8bdef9e03ec68236ed2afc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; can also be used in modules to define the name of a module</source>
          <target state="translated">모듈에서 &lt;code&gt;__name__&lt;/code&gt; 을 사용하여 모듈 이름을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be6ddf60538888ac5a053e568c5a35b99e293a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is a &lt;a href=&quot;https://wiki.python.org/moin/DunderAlias&quot;&gt;DunderAlias&lt;/a&gt; - can be thought of as a global variable (accessible from modules) and works in a similar way to &lt;a href=&quot;https://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 은 &lt;a href=&quot;https://wiki.python.org/moin/DunderAlias&quot;&gt;DunderAlias입니다&lt;/a&gt; -전역 변수 (모듈에서 액세스 가능)로 생각할 수 있으며 global과 비슷한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8f7940fd7af049d3ce98c54968886dbc4470c59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is a global variable (in Python, global actually means on the &lt;a href=&quot;https://docs.python.org/tutorial/modules.html#modules&quot;&gt;module level&lt;/a&gt;) that exists in all namespaces. It is typically the module's name (as a &lt;code&gt;str&lt;/code&gt; type).</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 은 모든 네임 스페이스에 존재하는 전역 변수 (Python에서 전역은 실제로 &lt;a href=&quot;https://docs.python.org/tutorial/modules.html#modules&quot;&gt;모듈 수준을&lt;/a&gt; 의미 함)입니다. 일반적으로 모듈의 이름입니다 ( &lt;code&gt;str&lt;/code&gt; 유형).</target>
        </trans-unit>
        <trans-unit id="2cf51e459a190c18f6d42769d3718fcae45ce2cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is always equal to &lt;code&gt;__main__&lt;/code&gt; whenever that file is &lt;strong&gt;run directly&lt;/strong&gt; showing that this is the main file.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 은 파일이 기본 파일임을 &lt;strong&gt;직접&lt;/strong&gt; 표시 할 때마다 항상 &lt;code&gt;__main__&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bd80d28fa314832c308431bb2b4654a9578e9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is an implicit variable in all .py modules; when a.py is imported, the value of &lt;code&gt;__name__&lt;/code&gt; of a.py module is set to its file name &quot;a&quot;; when a.py is run directly using &quot;python a.py&quot;, which means a.py is the entry point, then the value of &lt;code&gt;__name__&lt;/code&gt; of a.py module is set to a string &lt;code&gt;__main__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 은 모든 .py 모듈에서 암시 적 변수입니다. a.py를 가져올 때 a.py 모듈의 &lt;code&gt;__name__&lt;/code&gt; 값은 파일 이름 &quot;a&quot;로 설정됩니다. &quot;python a.py&quot;를 사용하여 a.py를 직접 실행하는 경우 a.py가 진입 점임을 의미하며 a.py 모듈의 &lt;code&gt;__name__&lt;/code&gt; 값은 문자열 &lt;code&gt;__main__&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ee91c879b2d309081471328a6d2e05241079dfda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt;: Every module in Python has a special attribute called &lt;code&gt;__name__&lt;/code&gt;.
It is a built-in variable that returns the name of the module.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; : Python의 모든 모듈에는 &lt;code&gt;__name__&lt;/code&gt; 이라는 특수 속성이 있습니다. 모듈 이름을 리턴하는 내장 변수입니다.</target>
        </trans-unit>
        <trans-unit id="78840eb1470db249624c988b713afc3e97a69c78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; is basically the top-level script environment, and it specifies the interpreter that ('I have the highest priority to be executed first').</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 기본적으로 최상위 스크립트 환경이며, ( '먼저 실행되는 우선 순위가 가장 높습니다') 인터프리터를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2340c4517f7704fbff95ab3e637235230b8ccc11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; is the part that runs when the script is run from (say) the command line using a command like &lt;code&gt;python myscript.py&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; 이 &lt;code&gt;python myscript.py&lt;/code&gt; 와 같은 명령을 사용하여 명령 줄에서 스크립트를 실행할 때 실행되는 부분입니다.</target>
        </trans-unit>
        <trans-unit id="018c83f2b5e1ed2102eb4e0da64ee296a8027e39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import a&lt;/code&gt; action actually runs all that can be ran in &quot;a&quot;</source>
          <target state="translated">액션 &lt;code&gt;import a&lt;/code&gt; 실제로 &quot;a&quot;에서 실행될 수있는 모든 것을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="df08731afb7c7ed2393aaa3f368ad0bb925ea7df" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Before explaining anything about &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; it is important to understand what &lt;code&gt;__name__&lt;/code&gt; is and what it does.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 에 대해 설명하기 전에 &lt;code&gt;__name__&lt;/code&gt; 이 무엇이며 무엇을 수행하는지 이해하는 것이 중요합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79da7cc29ac2426a88a714fbfaad47448858fdb1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Now we know the behaviour of &lt;code&gt;__name__&lt;/code&gt; things become clearer:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이제 &lt;code&gt;__name__&lt;/code&gt; 의 동작이 더 명확 해졌습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6728d8cd0ad927190e1963daa4daa6ea31c0c2f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;example:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="986b24c1aac5848a15ecb03780859084b31b46f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;somefile.py:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;somefile.py:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf1a9df34745e53acb5ed83d94dcb4372a21cee0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;test_file.py:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;test_file.py:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf539f837085192b477057fecbecb42c7bb86636" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;test_file.py&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;test_file.py&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="9b690b9867f89d5298a09814a6babe01c9bf70c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1st possibility: Import &lt;code&gt;my_test_module.py&lt;/code&gt; in another module&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;첫 번째 가능성 : 다른 모듈에서 &lt;code&gt;my_test_module.py&lt;/code&gt; 가져 오기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ac4feb6fd281aa9afa7bdda0ab2e439dc46fad0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2nd possibility: Invoke &lt;code&gt;my_test_module.py&lt;/code&gt; as a script&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;두 번째 가능성 : &lt;code&gt;my_test_module.py&lt;/code&gt; 를 스크립트로 호출&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc1f82081899627449ae26dee60c95d25b23c96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Summary&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Summary&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49a14964903307d811b50a88b1ff45287fbcbe6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Always&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Always&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0f57c51335086529afb8880f52e400970642376" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Executing only if the file is a module or package:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;파일이 모듈 또는 패키지 인 경우에만 실행 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58b371b66c6af23b26eadee978e7565caf07d812" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In short&lt;/strong&gt;, use this '&lt;code&gt;if __name__ == &quot;main&quot;&lt;/code&gt; ' block to prevent (certain) code from being run when the module is imported.</source>
          <target state="translated">&lt;strong&gt;즉&lt;/strong&gt; , 모듈을 가져올 때 (확실한) 코드가 실행되지 않도록하려면이 &lt;code&gt;if __name__ == &quot;main&quot;&lt;/code&gt; ' if __name__ == &quot;main&quot; '블록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="25c82edc0cf6b044fa8902f9ff4abb5f517318e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interpreter:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Interpreter:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9ed28c097ebb85433364ac1f4e044499a4d8c6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Module or package:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;모듈 또는 패키지 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1693186367529d23d67840c6cb92fd7b90836c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modules:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Modules:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bca1585410631753dd411aa2077f9de811966cd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now to answer &lt;code&gt;if __name__ == '__main__'&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이제 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 대답 하십시오 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="230a303facf1a2101a405f86dcdb8fcb53a82aea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only When Your Module Is Imported by Another&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 사람이 모듈을 가져 오는 경우에만&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98cb0f812771c34b1e9af7b910b6edb79e3ec992" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only When Your Module Is the Main Program&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;모듈이 메인 프로그램 인 경우에만&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecabc97610f091b28f299c3556ae2c2c8ba7ed78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Practice:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Practice:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25c5146cc441b2968a8c82ef2238dbdcc07728f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Running one condition if the file is the main one and another if it is not:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;파일이 기본 파일 인 경우 하나의 조건을 실행하고 그렇지 않은 경우 다른 조건을 실행하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15379d1a1ff9a18caec0d1609f2db4600cd6fe75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Script:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Script:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00e3df3306b151747da81b3135f8996102b6398c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variants:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Variants:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a427fb5acc312c062284737d9919ea80c80c0203" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is &lt;code&gt;__name__&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;__name__&lt;/code&gt; 은 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f2823989afe8101f68c8c884942631f433adaa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Your Module Is Imported By Another&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 사람이 모듈을 가져 오는 경우&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f40fc5f6f2fe7685a294e653a18be70c2bdc7f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Your Module Is the Main Program&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;모듈이 메인 프로그램 인 경우&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8da700b6247cf29cd4fd28b742f87b159469d2d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Where:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Where:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e57f67deaea1f928eb43934d908849cb2ac5b721" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;a&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;a&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="433798c30d6b2ba5b1b05b05cff30873a8571d47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;b&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;b&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02f26958ff8bbfffbe238764a41e6feacde136f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fibo.py (a module named &lt;code&gt;fibo&lt;/code&gt;)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;fibo.py ( &lt;code&gt;fibo&lt;/code&gt; 라는 모듈)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf22c4f6ccae5c5a45f16a6c1118de9c5f963fef" translate="yes" xml:space="preserve">
          <source>A Better Way</source>
          <target state="translated">더 나은 방법</target>
        </trans-unit>
        <trans-unit id="cf8a62e672a3b4293103f254c2a62d76c46512dd" translate="yes" xml:space="preserve">
          <source>A side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using &lt;code&gt;main()&lt;/code&gt; as the entry point, &lt;em&gt;but you don't have to&lt;/em&gt;. While &lt;code&gt;setup.py&lt;/code&gt; expects &lt;code&gt;main()&lt;/code&gt;, other tools use alternate entry points. For example, to run your file as a &lt;code&gt;gunicorn&lt;/code&gt; process, you define an &lt;code&gt;app()&lt;/code&gt; function instead of a &lt;code&gt;main()&lt;/code&gt;. Just as with &lt;code&gt;setup.py&lt;/code&gt;, &lt;code&gt;gunicorn&lt;/code&gt; imports your code so you don't want it do do anything while it's being imported (because of the import lock issue).</source>
          <target state="translated">부작용은 여러 진입 점을 지원하는 방법론에 자동으로 로그온한다는 것입니다. &lt;code&gt;main()&lt;/code&gt; 을 시작점으로 사용하여 프로그램을 실행할 수 &lt;em&gt;있지만 반드시 할 필요는 없습니다&lt;/em&gt; . &lt;code&gt;setup.py&lt;/code&gt; 에서는 &lt;code&gt;main()&lt;/code&gt; 하지만 다른 도구는 대체 진입 점을 사용합니다. 예를 들어 파일을 &lt;code&gt;gunicorn&lt;/code&gt; 프로세스로 실행하려면 &lt;code&gt;main()&lt;/code&gt; 대신 &lt;code&gt;app()&lt;/code&gt; 함수를 정의하십시오. &lt;code&gt;setup.py&lt;/code&gt; 와 마찬가지로 &lt;code&gt;gunicorn&lt;/code&gt; 은 코드를 가져 오기 때문에 코드를 가져 오는 동안 (가져 오기 잠금 문제 때문에) 아무 것도하지 않기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="1279ac465ae03ccecc8242e951637177d836eac0" translate="yes" xml:space="preserve">
          <source>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.</source>
          <target state="translated">특수 변수가 설정된 후 인터프리터는 모듈의 모든 코드를 한 번에 한 명령문 씩 실행합니다. 코드 샘플과 함께 측면에서 다른 창을 열어서이 설명을 따라갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="383d69461af4204128d7a2e22e0747b27e8c41c3" translate="yes" xml:space="preserve">
          <source>Again, there will be exceptions, but common practice is that &lt;code&gt;main()&lt;/code&gt; doesn't usually get called externally. So you may be wondering one more thing: if we're not calling &lt;code&gt;main()&lt;/code&gt;, why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this:</source>
          <target state="translated">다시 한 번 예외가 있지만 일반적으로 &lt;code&gt;main()&lt;/code&gt; 은 일반적으로 외부에서 호출되지 않습니다. 따라서 한 가지 더 궁금 할 수도 있습니다. &lt;code&gt;main()&lt;/code&gt; 호출하지 않으면 왜 스크립트를 호출합니까? 많은 사람들이 파일의 나머지 코드와 독립적으로 실행되는 독립형 함수로 스크립트를 구성하기 때문입니다. 그런 다음 나중에 스크립트 본문의 다른 곳에서 호출됩니다. 어느 것이 나를 이끌어 줍니까?</target>
        </trans-unit>
        <trans-unit id="a358e3aa692468b145f1d8ad7d489a6ccc1f8b13" translate="yes" xml:space="preserve">
          <source>All the answers have pretty much explained the functionality. But I will provide one example of its usage which might help clearing out the concept further.</source>
          <target state="translated">모든 답변은 기능을 거의 설명했습니다. 그러나 개념을 더 명확하게 정리하는 데 도움이 될 사용법의 한 가지 예를 제공하겠습니다.</target>
        </trans-unit>
        <trans-unit id="728913bf30e6213619a10923f8ca08b92f0ccf99" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#if-statements&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; is a flow control statement that contains the block of code will execute if the value given is true. We have seen that &lt;code&gt;__name__&lt;/code&gt; can take either 
&lt;code&gt;__main__&lt;/code&gt; or the file name it has been imported from.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#if-statements&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 는 주어진 값이 참이면 코드 블록을 포함하는 흐름 제어 명령문입니다. &lt;code&gt;__name__&lt;/code&gt; 은 &lt;code&gt;__main__&lt;/code&gt; 또는 가져온 파일 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="291a6a1c87e677da65912996bc98ea09be8c889c" translate="yes" xml:space="preserve">
          <source>An Even Better Way</source>
          <target state="translated">더 나은 방법</target>
        </trans-unit>
        <trans-unit id="e25027686192c6d115ffa987e895d2c366f4813e" translate="yes" xml:space="preserve">
          <source>And a second file &quot;xy.py&quot;:</source>
          <target state="translated">그리고 두 번째 파일 &quot;xy.py&quot;:</target>
        </trans-unit>
        <trans-unit id="56bea24f0fbd1f255ecadf46a21ba6a136330f7a" translate="yes" xml:space="preserve">
          <source>And the output from executing script2 is:</source>
          <target state="translated">그리고 script2 실행 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32c90a0b6a16423e14ed51492f9d35d3262ee3dc" translate="yes" xml:space="preserve">
          <source>And then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome.</source>
          <target state="translated">그런 다음 테스트 함수 호출을 주석 처리했는지 여부를 기억해야합니다. 또한 이러한 추가 복잡성으로 인해 개발 과정이 더욱 까다로워지고 잊어 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27665df0153065e46daf1f28871bd9475bf8e1d5" translate="yes" xml:space="preserve">
          <source>Another benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:</source>
          <target state="translated">이 구문을 사용하면 얻을 수있는 또 다른 이점 : 코드를 다른 스크립트에서 모듈로 가져 와서 프로그램이 결정할 때 주 함수를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e24f293208b0bd554685671142f6ee40f5264006" translate="yes" xml:space="preserve">
          <source>Another one.</source>
          <target state="translated">다른 것.</target>
        </trans-unit>
        <trans-unit id="490e331532fa57020b75e3d7497ad0ed1e28417b" translate="yes" xml:space="preserve">
          <source>Any other script that's called from this &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; script is assigned its filename as its &lt;code&gt;__name__&lt;/code&gt; (e.g., &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt;). Hence, the line &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally.</source>
          <target state="translated">이 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 스크립트에서 호출 된 다른 스크립트에는 파일 이름이 &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt; (예 : __name__ == &quot;ab.py&quot; )로 지정됩니다. 따라서 &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 행은 처음 실행 된 '홈'스크립트를 해석 / 파싱하는지 또는 다른 (외부) 스크립트로 일시적으로 엿보기 여부를 판별하기위한 인터프리터의 테스트입니다. 이를 통해 프로그래머가 스크립트를 직접 실행하거나 외부에서 호출하는 경우 다르게 동작하도록 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4f021478ef2f8fb352704d122ccd48a0f448bb10" translate="yes" xml:space="preserve">
          <source>As an example, consider the following module &lt;code&gt;my_test_module.py&lt;/code&gt;:</source>
          <target state="translated">예를 들어 다음 모듈 &lt;code&gt;my_test_module.py&lt;/code&gt; 를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c8214b3e3fc0c1096a5057a6fbcda3ca94b4ab14" translate="yes" xml:space="preserve">
          <source>As by default (when module running as main, not imported) the &lt;code&gt;__name__&lt;/code&gt; variable is set to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;, and when it'll be imported the &lt;code&gt;__name__&lt;/code&gt; variable will get a different value, most probably the name of the module (&lt;code&gt;'M'&lt;/code&gt;).
This is helpful in running different variants of a modules together, and separating their specific input &amp;amp; output statements and also if there are any test-cases.</source>
          <target state="translated">기본적으로 (모듈을 main으로 실행하고 가져 오지 않은 경우) &lt;code&gt;__name__&lt;/code&gt; 변수는 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 로 설정되며 가져올 때 &lt;code&gt;__name__&lt;/code&gt; 변수는 다른 값을 얻습니다. 대부분의 경우 모듈 이름 ( &lt;code&gt;'M'&lt;/code&gt; ). 이는 모듈의 여러 변형을 함께 실행하고 특정 입력 및 출력 문을 분리하고 테스트 사례가있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0fb36a6c33279c346eb468f0e09c25e124f94cda" translate="yes" xml:space="preserve">
          <source>As the only special case, however, in whatever Python process you run, as in mycode.py:</source>
          <target state="translated">그러나 유일한 특별한 경우로, mycode.py에서와 같이 실행하는 모든 Python 프로세스에서 :</target>
        </trans-unit>
        <trans-unit id="77a8033bf10bed893a83d034163981dde9b5ee97" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;__name__&lt;/code&gt; tells us which code is the 'main' module.
This is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a 'main' function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.</source>
          <target state="translated">보다시피, &lt;code&gt;__name__&lt;/code&gt; 은 어떤 코드가 'main'모듈인지 알려줍니다. 코드를 작성하고 C / C ++에서와 같은 구조적 문제에 대해 걱정할 필요가 없기 때문에, 파일이 '주요'기능을 구현하지 않으면 실행 파일로 컴파일 할 수 없으며, 그런 다음 라이브러리로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c45bdc9c773c22c178338f1dc79c2aa63246ed33" translate="yes" xml:space="preserve">
          <source>As you can see, when a file is executed, Python sets &lt;code&gt;globals()['__name__']&lt;/code&gt; in this file to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;. This time, the &lt;code&gt;if&lt;/code&gt; statement evaluates to &lt;code&gt;True&lt;/code&gt; and is being run.</source>
          <target state="translated">보다시피, 파일이 실행될 때, 파이썬은이 파일에서 &lt;code&gt;globals()['__name__']&lt;/code&gt; 을 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 로 설정 합니다. 이번에는 &lt;code&gt;if&lt;/code&gt; 문이 &lt;code&gt;True&lt;/code&gt; 로 평가되어 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="fa35fc2b3ffb5707c6ed36201d14709b2795177a" translate="yes" xml:space="preserve">
          <source>As you can see, when a module is imported, Python sets &lt;code&gt;globals()['__name__']&lt;/code&gt; in this module to the module's name. Also, upon import all the code in the module is being run. As the &lt;code&gt;if&lt;/code&gt; statement evaluates to &lt;code&gt;False&lt;/code&gt; this part is not executed.</source>
          <target state="translated">보다시피, 모듈을 가져 오면 파이썬은이 모듈의 &lt;code&gt;globals()['__name__']&lt;/code&gt; 을 모듈 이름으로 설정합니다. 또한 가져 오면 모듈의 모든 코드가 실행됩니다. &lt;code&gt;if&lt;/code&gt; 문이 &lt;code&gt;False&lt;/code&gt; 로 평가 되므로이 부분은 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4174aeb05b05eec8583dcae607865c6ef32ba122" translate="yes" xml:space="preserve">
          <source>Assume that you have two Python files, a.py and b.py. Now, a.py imports b.py. We run the a.py file, where the &quot;import b.py&quot; code is executed first. Before the rest of the a.py code runs, the code in the file b.py must run completely.</source>
          <target state="translated">a.py 및 b.py라는 두 개의 Python 파일이 있다고 가정하십시오. 이제 a.py는 b.py를 가져옵니다. &quot;import b.py&quot;코드가 먼저 실행되는 a.py 파일을 실행합니다. 나머지 a.py 코드가 실행되기 전에 b.py 파일의 코드가 완전히 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="53de5b46d0fbb20fff33ad741960e992c53e5836" translate="yes" xml:space="preserve">
          <source>Based on the mechanism how python sets the variable &lt;code&gt;__name__&lt;/code&gt; for each module, do you know how to achieve point 3? The answer is fairly easy, right? Put a if condition: &lt;code&gt;if __name__ == &quot;__main__&quot;: ...&lt;/code&gt;; you can even put if &lt;code&gt;__name__ == &quot;a&quot;&lt;/code&gt; depending on your functional need</source>
          <target state="translated">파이썬이 각 모듈에 대해 &lt;code&gt;__name__&lt;/code&gt; 변수를 설정하는 메커니즘에 따라 포인트 3을 달성하는 방법을 알고 있습니까? 대답은 매우 쉽습니다. if 조건을 입력하십시오. &lt;code&gt;if __name__ == &quot;__main__&quot;: ...&lt;/code&gt; ; 기능적 필요에 따라 &lt;code&gt;__name__ == &quot;a&quot;&lt;/code&gt; 경우에도 넣을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b5daba4bc12144be47ac4ef97123506a5d670ee9" translate="yes" xml:space="preserve">
          <source>Because of point 1, you may not want everything to be run in &quot;a&quot; when importing it</source>
          <target state="translated">지점 1 때문에 가져올 때 모든 항목이 &quot;a&quot;로 실행되는 것을 원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5555032fd1fd8c47f02216cf05cff7797235c4eb" translate="yes" xml:space="preserve">
          <source>Before the interpreter executes the source code file though, it defines a few special variables for that file; &lt;strong&gt;__name__&lt;/strong&gt; is one of those special variables that Python automatically defines for each source code file.</source>
          <target state="translated">인터프리터는 소스 코드 파일을 실행하기 전에 해당 파일에 대한 몇 가지 특수 변수를 정의합니다. &lt;strong&gt;__name__&lt;/strong&gt; 은 파이썬이 각 소스 코드 파일에 대해 자동으로 정의하는 특수 변수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="be4403cc17466eedfa891d4a51f7740fa3d7f3f3" translate="yes" xml:space="preserve">
          <source>Being a variable means that it's value &lt;em&gt;can&lt;/em&gt; be overwritten (&quot;can&quot; does not mean &quot;should&quot;), overwriting the value of &lt;code&gt;__name__&lt;/code&gt; will result in a lack of readability.  So do not do it, for any reason.  If you need a variable define a new variable.</source>
          <target state="translated">변수는 값 &lt;em&gt;을&lt;/em&gt; 덮어 쓸 &lt;em&gt;수&lt;/em&gt; 있음을 의미하고 ( &quot;can&quot;은 &quot;should&quot;를 의미하지 않음), &lt;code&gt;__name__&lt;/code&gt; 값을 덮어 쓰면 가독성이 떨어집니다. 어떤 이유로 든 그렇게하지 마십시오. 변수가 필요한 경우 새 변수를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="cdba82558e6d2b296c8fda06454da814e1ab4ab2" translate="yes" xml:space="preserve">
          <source>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. &quot;Running&quot; the script is a side effect of importing the script's module.</source>
          <target state="translated">이 예제 외에도 Python에서 스크립트를 실행하면 몇 가지 마법 변수를 설정하고 스크립트를 가져 오는 것이 우아합니다. 스크립트를 &quot;실행 중&quot;은 스크립트 모듈을 가져 오는 데 따른 부작용입니다.</target>
        </trans-unit>
        <trans-unit id="7fdb9a68214237799e539012c1ae04b1ee6fcbff" translate="yes" xml:space="preserve">
          <source>Blocks A and B are run when we are running &quot;x.py&quot;.</source>
          <target state="translated">&quot;x.py&quot;를 실행할 때 블록 A와 B가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="51aacee3ee9f4b0785c1a298e8721c7f3d008776" translate="yes" xml:space="preserve">
          <source>But inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.</source>
          <target state="translated">그러나 기본 모듈 (또는 인터랙티브 한 파이썬 세션, 즉 인터프리터의 Read, Eval, Print Loop 또는 REPL)에서는 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 에서 모든 것을 실행하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d45165ec85f4c41aac136977806fa7b3e1b0399" translate="yes" xml:space="preserve">
          <source>But just block A (and not B) is run when we are running another module, &quot;y.py&quot; for example, in which x.y is imported and the code is run from there (like when a function in &quot;x.py&quot; is called from y.py).</source>
          <target state="translated">그러나 xy를 가져오고 코드를 실행하는 &quot;y.py&quot;와 같은 다른 모듈을 실행할 때 블록 A (B는 아님)가 실행됩니다 (예 : &quot;x.py&quot;의 함수가 y.py에서 호출).</target>
        </trans-unit>
        <trans-unit id="187017f79b4f4176019be635feccedac47d394a8" translate="yes" xml:space="preserve">
          <source>But that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.</source>
          <target state="translated">그러나 그것은 아마도 외부에서 호출되는 함수를 가질 수없는 스크립트 일 것입니다. 그렇다면 변수 계산 및 할당이 즉시 시작되기 때문입니다. 함수를 재사용하려고 할 때 새 스크립트가 이전 스크립트와 밀접하게 관련되어 변수가 충돌 할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0cc7be78b4f7426e808a9f14bb2ee02b52a60bf" translate="yes" xml:space="preserve">
          <source>But the code works without it</source>
          <target state="translated">그러나 코드는 그것없이 작동합니다</target>
        </trans-unit>
        <trans-unit id="b868b03c6a857fb43254a438d5d2b52f62b19ea2" translate="yes" xml:space="preserve">
          <source>Call the class from other files. You just have to import it in the calling program.</source>
          <target state="translated">다른 파일에서 클래스를 호출하십시오. 호출 프로그램에서 가져 오기만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d1249e34e446972c34012a866f67bc184db7bc52" translate="yes" xml:space="preserve">
          <source>Code Sample</source>
          <target state="translated">코드 샘플</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="9274899889be8b8adc4e3be4ea8d4a133c134b2d" translate="yes" xml:space="preserve">
          <source>Create a file, &lt;strong&gt;a.py&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;a.py&lt;/strong&gt; 파일을 &lt;strong&gt;만듭니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="56a0a9523b0c4b5eb5e2bbdb33ad60b126caa07f" translate="yes" xml:space="preserve">
          <source>Create another file, &lt;strong&gt;b.py&lt;/strong&gt;, in the same directory:</source>
          <target state="translated">동일한 디렉토리에 다른 파일 &lt;strong&gt;b.py를&lt;/strong&gt; 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="cd3b4d3abc33414ae3e100a1d6cbfe6b75ea5eb4" translate="yes" xml:space="preserve">
          <source>Create the following files.</source>
          <target state="translated">다음 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="28d96b6441a5da8450600f4898f133fbdd6961e4" translate="yes" xml:space="preserve">
          <source>Developing and Testing Your Code</source>
          <target state="translated">코드 개발 및 테스트</target>
        </trans-unit>
        <trans-unit id="6bc05812a294f6f7a5f9e19db22d8cd3b2afc410" translate="yes" xml:space="preserve">
          <source>End of file; back to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;!</source>
          <target state="translated">파일의 끝; &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 돌아 가기</target>
        </trans-unit>
        <trans-unit id="ccf898dbe57906e5594bcd719f8b93726090fd0d" translate="yes" xml:space="preserve">
          <source>Every module in python has a attribute called &lt;code&gt;__name__&lt;/code&gt;. The value of &lt;code&gt;__name__&lt;/code&gt;  attribute is  &lt;code&gt;__main__&lt;/code&gt;  when the module is run directly, like &lt;code&gt;python my_module.py&lt;/code&gt;. Otherwise (like when you say &lt;code&gt;import my_module&lt;/code&gt;) the value of &lt;code&gt;__name__&lt;/code&gt;  is the name of the module.</source>
          <target state="translated">파이썬의 모든 모듈에는 &lt;code&gt;__name__&lt;/code&gt; 이라는 속성이 있습니다. &lt;code&gt;python my_module.py&lt;/code&gt; 와 같이 모듈이 직접 실행될 때 &lt;code&gt;__name__&lt;/code&gt; 속성의 값은 &lt;code&gt;__main__&lt;/code&gt; 입니다. 그렇지 않으면 ( &lt;code&gt;import my_module&lt;/code&gt; 과 같이) &lt;code&gt;__name__&lt;/code&gt; 의 값은 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8ea353689f62515305875bd4c1491c1b1eda4969" translate="yes" xml:space="preserve">
          <source>Executing the Module's Code</source>
          <target state="translated">모듈 코드 실행</target>
        </trans-unit>
        <trans-unit id="decbc65feed3492d925a3828afa0685ee965a44f" translate="yes" xml:space="preserve">
          <source>Food for Thought</source>
          <target state="translated">생각할 거리</target>
        </trans-unit>
        <trans-unit id="c01b0b737be74a6ef3efec2d9c67ec6b0e73c2dd" translate="yes" xml:space="preserve">
          <source>For the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label &lt;code&gt;'__main__'&lt;/code&gt;.</source>
          <target state="translated">후자의 경우 클래스에는 public static void main () 메서드가 포함되어야합니다. 파이썬에서이 목적은 전역 적으로 정의 된 레이블 &lt;code&gt;'__main__'&lt;/code&gt; 이 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="06c6abe53de8158ff545ff3025465ac568502266" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;x()&lt;/code&gt;; ok, printing '&lt;em&gt;peripheral task: might be useful in other projects&lt;/em&gt;'.</source>
          <target state="translated">함수 &lt;code&gt;x()&lt;/code&gt; ; 좋아, 인쇄 ' &lt;em&gt;주변 작업 : 다른 프로젝트에서 유용 할 수 있습니다&lt;/em&gt; '.</target>
        </trans-unit>
        <trans-unit id="270272d52b278ed4834707720d02142b04dac683" translate="yes" xml:space="preserve">
          <source>Given the following code, what does the &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; do?</source>
          <target state="translated">다음 코드가 주어지면 &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c532f4344993da004ef0d886409dd1dc176dd817" translate="yes" xml:space="preserve">
          <source>Hope this helps out.</source>
          <target state="translated">이것이 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="7cf7df778e073d4ee9549c9276978c839886daaf" translate="yes" xml:space="preserve">
          <source>However, if you want to import the module to another script:</source>
          <target state="translated">그러나 모듈을 다른 스크립트로 가져 오려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3f7f6f7cdf15bc15aa54e3347e678918567e405d" translate="yes" xml:space="preserve">
          <source>However, if your Python script is used by a module, any code outside of the &lt;code&gt;if&lt;/code&gt; statement will be executed, so &lt;code&gt;if \__name__ == &quot;\__main__&quot;&lt;/code&gt; is used just to check if the program is used as a module or not, and therefore decides whether to run the code.</source>
          <target state="translated">그러나 파이썬 스크립트가 모듈에서 사용 &lt;code&gt;if&lt;/code&gt; 문 외부의 모든 코드가 실행되므로 &lt;code&gt;if \__name__ == &quot;\__main__&quot;&lt;/code&gt; 이 프로그램이 모듈로 사용되는지 여부를 확인하는 데 사용되는 경우 따라서 코드 실행 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="27aee883b9125fa742bdc6ce62419f671fc09b30" translate="yes" xml:space="preserve">
          <source>I am not saying you should use this in production code, but it serves to illustrate that there is nothing &quot;magical&quot; about &lt;code&gt;if __name__ == '__main__'&lt;/code&gt;. It is a good convention for invoking a main function in Python files.</source>
          <target state="translated">나는 이것을 프로덕션 코드에서 사용해야한다고 말하지는 않지만 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 대해 &quot;매직&quot;이 없음을 보여줍니다. 파이썬 파일에서 주요 함수를 호출하는 좋은 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="7aaee90df97cdf574f54c44ac544ddfd2ecf3202" translate="yes" xml:space="preserve">
          <source>I think it's best to break the answer in depth and in simple words:</source>
          <target state="translated">깊이 있고 간단한 단어로 답을 나누는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2d610a68610206f4422d124c53fd2b4ef28bb011" translate="yes" xml:space="preserve">
          <source>I've been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused.</source>
          <target state="translated">이 페이지의 답변 전체에서 많은 것을 읽었습니다. 나는 당신이 그 사실을 알고 있다면 그 대답을 확실히 이해할 것입니다. 그렇지 않으면 여전히 혼란 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="7dc8666b8e0d5305ca6686fcdd3a64aa30613f45" translate="yes" xml:space="preserve">
          <source>If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special &lt;strong&gt;__name__&lt;/strong&gt; variable for this file to have a value &lt;strong&gt;&quot;__main__&quot;&lt;/strong&gt;.</source>
          <target state="translated">Python이이 소스 코드 파일을 기본 프로그램 (즉, 실행하는 파일)으로로드하는 경우이 파일의 특수 &lt;strong&gt;__name__&lt;/strong&gt; 변수가 &lt;strong&gt;&quot;__main__&quot;&lt;/strong&gt; 값을 갖도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a009492026900b4a9397225067c6a9f84f8e1216" translate="yes" xml:space="preserve">
          <source>If indeed &lt;code&gt;__name__&lt;/code&gt; does take the value of &lt;code&gt;__main__&lt;/code&gt; then whatever is in that block of code will execute.</source>
          <target state="translated">실제로 &lt;code&gt;__name__&lt;/code&gt; 이 &lt;code&gt;__main__&lt;/code&gt; 의 값을 취하면 해당 코드 블록에있는 모든 것이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0a6d69f64768205bc73fd5ba1367e74b8059c5c0" translate="yes" xml:space="preserve">
          <source>If the python interpreter is running&amp;nbsp;a particular module then &lt;code&gt;__name__&lt;/code&gt; global  variable will have value &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;</source>
          <target state="translated">파이썬 인터프리터가 특정 모듈을 실행 중이면 &lt;code&gt;__name__&lt;/code&gt; 전역 변수의 값은 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b1094aa47aa3aeccd6ed85b8ebb5ed271222d0e3" translate="yes" xml:space="preserve">
          <source>If this .py are run by &lt;code&gt;python this_py.py&lt;/code&gt; under shell, or double clicked in Windows. the code under &quot;the if statement&quot; will be executed.</source>
          <target state="translated">이 .py가 &lt;code&gt;python this_py.py&lt;/code&gt; 의해 실행되면 this_py.py 쉘에서 또는 Windows에서 두 번 클릭하십시오. &quot;if 문&quot;아래의 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f0f1e75c2a123bfd0fe539932a26c8d0e246a7f1" translate="yes" xml:space="preserve">
          <source>If this .py file are imported by other .py files, the code under &quot;the if statement&quot; will not be executed.</source>
          <target state="translated">이 .py 파일을 다른 .py 파일로 가져 오면 &quot;if 문&quot;아래의 코드가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfc7c4aaf15b28c6320a80c22273eb5bfeb2a46e" translate="yes" xml:space="preserve">
          <source>If this is being imported from another module, &lt;strong&gt;__name__&lt;/strong&gt; will be set to that module's name.</source>
          <target state="translated">다른 모듈에서 가져 오면 &lt;strong&gt;__name__&lt;/strong&gt; 이 해당 모듈의 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6523f8ca1b9a6c1da707b351f493c4cbbace2647" translate="yes" xml:space="preserve">
          <source>If we put the code we want to exercise as we develop and test in a function like this and then do our check for &lt;code&gt;'__main__'&lt;/code&gt; immediately after:</source>
          <target state="translated">코드를 입력하면 다음과 같은 함수를 개발하고 테스트 할 때 연습하고 싶은 즉시 &lt;code&gt;'__main__'&lt;/code&gt; 을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bc80bf0204f13ba7089b5451f461bfc665cec29b" translate="yes" xml:space="preserve">
          <source>If we run the code directly via &lt;code&gt;python test.py&lt;/code&gt;, the module name is &lt;code&gt;__main__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;python test.py&lt;/code&gt; 를 통해 직접 코드를 실행하면 모듈 이름은 &lt;code&gt;__main__&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a6516beb3b9f8bebd5a8fe5d91c615ccfb9500a4" translate="yes" xml:space="preserve">
          <source>If you are running your module (the source file) as the main program, e.g.</source>
          <target state="translated">기본 프로그램으로 모듈 (소스 파일)을 실행중인 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="5a002ca7d32e704fd426536fc54e7e1e47ad2e8b" translate="yes" xml:space="preserve">
          <source>If you import this file say A to file B  and execute the file B then &lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; in file A becomes false, so it prints  &lt;strong&gt;You can't see me&lt;/strong&gt;</source>
          <target state="translated">이 파일을 A 파일 B로 가져 와서 파일 B를 실행하면 파일 A의 &lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; 이 false가되어 인쇄됩니다 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bae9f62ff08151418abbbc49ef9673f76cd6210a" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;two.py&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;two.py&lt;/code&gt; 를 대신 실행 하면 :</target>
        </trans-unit>
        <trans-unit id="3d5150bf1d7adcfd96cab36821f53eb6a118618d" translate="yes" xml:space="preserve">
          <source>If your module is the main program, then it will see that &lt;code&gt;__name__&lt;/code&gt; was indeed set to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; and it calls the two functions, printing the strings &lt;code&gt;&quot;Function A&quot;&lt;/code&gt; and &lt;code&gt;&quot;Function B 10.0&quot;&lt;/code&gt;.</source>
          <target state="translated">모듈이 기본 프로그램 인 경우 &lt;code&gt;__name__&lt;/code&gt; 이 실제로 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 으로 설정되었으며 문자열 &lt;code&gt;&quot;Function A&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Function B 10.0&quot;&lt;/code&gt; 을 인쇄하는 두 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="dec279dce56fe81437675634947d0898c2cd9a40" translate="yes" xml:space="preserve">
          <source>If your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the &lt;code&gt;if&lt;/code&gt; clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:</source>
          <target state="translated">스크립트를 다른 모듈로 가져 오는 경우 다양한 함수 및 클래스 정의를 가져 와서 최상위 코드가 실행되지만 위의 &lt;code&gt;if&lt;/code&gt; 절의 then-body 코드는 조건으로 실행되지 않습니다 충족되지 않습니다. 기본 예로 다음 두 스크립트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="47cbbcfd6a2d88e3b7665ea5155dcef87bbe0234" translate="yes" xml:space="preserve">
          <source>Import and open file with the &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt; 파일을 가져오고 엽니 다.</target>
        </trans-unit>
        <trans-unit id="4339fb8da56f030c085b801561fcd6353668defe" translate="yes" xml:space="preserve">
          <source>In other words, the code within the &lt;code&gt;if&lt;/code&gt; block will be executed only when the code runs directly. Here &lt;code&gt;directly&lt;/code&gt; means &lt;code&gt;not imported&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;if&lt;/code&gt; 블록 내의 코드는 코드가 직접 실행될 때만 실행됩니다. 여기에서 &lt;code&gt;directly&lt;/code&gt; &lt;code&gt;not imported&lt;/code&gt; 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7ef3470680942e6fd3926f3ffbec1e8810ecf8fb" translate="yes" xml:space="preserve">
          <source>In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, &quot;example.py&quot; might import &quot;xy.py&quot; and call &lt;code&gt;x()&lt;/code&gt;, making use of the 'x' function from &quot;xy.py&quot;. (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)</source>
          <target state="translated">독립적 인 기능을 분리하면 이전 작업을 다른 스크립트로 호출하여 이전 작업을 재사용 할 수 있습니다. 예를 들어, &quot;example.py&quot;는 &quot;xy.py&quot;를 가져오고 &quot;xy.py&quot;에서 'x'함수를 사용하여 &lt;code&gt;x()&lt;/code&gt; 호출 할 수 있습니다. (어쩌면 주어진 텍스트 문자열의 세 번째 단어를 대문자로 사용하거나 숫자 목록에서 NumPy 배열을 만들고 제곱하거나 3D 표면을 비추는 경향이 있습니다. 가능성은 무한합니다.)</target>
        </trans-unit>
        <trans-unit id="d853790bb43ec92bf806d95fb5eb4681a4a8a3c8" translate="yes" xml:space="preserve">
          <source>In summary, here's what'd be printed in the two cases:</source>
          <target state="translated">요약하면 다음 두 경우에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1f0a6937d20af80d3078dedc2606cc5a59b0e220" translate="yes" xml:space="preserve">
          <source>In the b.py code there is some code that is exclusive to that file b.py and we don't want any other file (other than b.py file), that has imported the b.py file, to run it.</source>
          <target state="translated">b.py 코드에는 해당 파일 b.py 전용 코드가 있으며 b.py 파일을 가져온 다른 파일 (b.py 파일 이외)은 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="260ca32c942591fccd6abb92b2ac85ea296638c3" translate="yes" xml:space="preserve">
          <source>In this case, the top-level code is an &lt;code&gt;if&lt;/code&gt; block.  &lt;code&gt;__name__&lt;/code&gt; is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in &lt;code&gt;myscript.py&lt;/code&gt; above), then &lt;code&gt;__name__&lt;/code&gt; instead is set to the string &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.  Thus, you can test whether your script is being run directly or being imported by something else by testing</source>
          <target state="translated">이 경우 최상위 코드는 &lt;code&gt;if&lt;/code&gt; 블록입니다. &lt;code&gt;__name__&lt;/code&gt; 은 현재 모듈의 이름으로 평가되는 내장 변수입니다. 그러나 모듈이 위의 &lt;code&gt;myscript.py&lt;/code&gt; 에서와 같이 직접 실행되는 경우 &lt;code&gt;__name__&lt;/code&gt; 이 대신 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 문자열로 설정됩니다. 따라서 테스트를 통해 스크립트가 직접 실행되는지 또는 다른 것으로 가져 오는지 테스트 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fc7351db8caa3bc174e3dab9c38941592f350c9e" translate="yes" xml:space="preserve">
          <source>Inside an imported module, it's the name of that module.</source>
          <target state="translated">가져온 모듈 내에서 해당 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="600ec79b4436fd522224aeb5e817487e39bf7c75" translate="yes" xml:space="preserve">
          <source>It allows the code in the module to be importable by other modules, without executing the code block beneath on import.</source>
          <target state="translated">가져 오기시 코드 블록을 실행하지 않고도 모듈의 코드를 다른 모듈에서 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="675efdeb054d458c04693317ce35a181157e918e" translate="yes" xml:space="preserve">
          <source>It also allows modules to be run from the command line as main scripts, which can be also very useful.</source>
          <target state="translated">또한 명령 줄에서 모듈을 기본 스크립트로 실행할 수 있으므로 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54b2453f92e0d3e4d73f97207fe07c2dc556e48a" translate="yes" xml:space="preserve">
          <source>It can not only be used in scripts but can also be found in both the interpreter and modules/packages.</source>
          <target state="translated">스크립트에서만 사용할 수있을뿐만 아니라 인터프리터 및 모듈 / 패키지에서도 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3528aa55d868a317f591f6ee9b7618c515d6e0af" translate="yes" xml:space="preserve">
          <source>It checks if a module is being imported or not.</source>
          <target state="translated">모듈을 가져오고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4714816743d3504312c6ed1b30410b9d76cd8f74" translate="yes" xml:space="preserve">
          <source>It checks if the &lt;code&gt;__name__&lt;/code&gt; attribute of the Python script is &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;. In other words, if the program itself is executed, the attribute will be &lt;code&gt;__main__&lt;/code&gt;, so the program will be executed (in this case the &lt;code&gt;main()&lt;/code&gt; function).</source>
          <target state="translated">Python 스크립트의 &lt;code&gt;__name__&lt;/code&gt; 속성이 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 인지 확인 합니다. 즉, 프로그램 자체가 실행되면 속성이 &lt;code&gt;__main__&lt;/code&gt; 이되고 프로그램이 실행됩니다 (이 경우 &lt;code&gt;main()&lt;/code&gt; 함수).</target>
        </trans-unit>
        <trans-unit id="d45839ba20c9bcb826d469c0e65576dc489d5de3" translate="yes" xml:space="preserve">
          <source>It could be written in several ways. Another is:</source>
          <target state="translated">여러 가지 방법으로 쓸 수 있습니다. 다른 것은 :</target>
        </trans-unit>
        <trans-unit id="72796cbd4b51d3cdeb2d0d02bdcb18094d7dd7ca" translate="yes" xml:space="preserve">
          <source>It executes the &lt;code&gt;def&lt;/code&gt; block, creating a function object, then assigning that function object to a variable called &lt;code&gt;functionA&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;def&lt;/code&gt; 블록을 실행하여 함수 객체를 만든 다음 해당 함수 객체를 &lt;code&gt;functionA&lt;/code&gt; 라는 변수에 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="4a1336d55772c318b9c2339583e8b328d7e55ca8" translate="yes" xml:space="preserve">
          <source>It executes the second &lt;code&gt;def&lt;/code&gt; block, creating another function object, then assigning it to a variable called &lt;code&gt;functionB&lt;/code&gt;.</source>
          <target state="translated">두 번째 &lt;code&gt;def&lt;/code&gt; 블록을 실행하여 다른 함수 객체를 만든 다음 &lt;code&gt;functionB&lt;/code&gt; 라는 변수에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="d422f7632b03e10b878e1d03615ebf1e878466d9" translate="yes" xml:space="preserve">
          <source>It is a special for when a Python file is called from the command line. This is typically used to call a &quot;main()&quot; function or execute other appropriate startup code, like commandline arguments handling for instance.</source>
          <target state="translated">명령 행에서 Python 파일을 호출 할 때 특히 유용합니다. 일반적으로 &quot;main ()&quot;함수를 호출하거나 명령 줄 인수 처리와 같은 다른 적절한 시작 코드를 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c5e6e85034260b34583d4b3d062afde5577df61" translate="yes" xml:space="preserve">
          <source>It is a string (global as mentioned above) as indicated by &lt;code&gt;type(__name__)&lt;/code&gt; (yielding &lt;code&gt;&amp;lt;class 'str'&amp;gt;&lt;/code&gt;), and is an inbuilt standard for both &lt;a href=&quot;https://docs.python.org/3/library/__main__.html&quot;&gt;Python 3&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;Python 2&lt;/a&gt; versions.</source>
          <target state="translated">&lt;code&gt;type(__name__)&lt;/code&gt; ( &lt;code&gt;&amp;lt;class 'str'&amp;gt;&lt;/code&gt; )으로 표시되는 문자열 (위에서 언급 한 것처럼 전역 문자열)이며 &lt;a href=&quot;https://docs.python.org/3/library/__main__.html&quot;&gt;Python 3&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;Python 2&lt;/a&gt; 버전 모두에 대한 기본 제공 표준입니다.</target>
        </trans-unit>
        <trans-unit id="3b32f06639244cd4fe1f298cf6a239029bf115ac" translate="yes" xml:space="preserve">
          <source>It is also possible to do other, less common but useful things with &lt;code&gt;__name__&lt;/code&gt;, some I will show here:</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 사용 하여 덜 일반적이지만 유용한 다른 작업을 수행하는 것도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fa5911f298adfd582f1742f2457c41f8e0363fdb" translate="yes" xml:space="preserve">
          <source>It is always assumed that the value of &lt;code&gt;__name__&lt;/code&gt; to be &lt;code&gt;__main__&lt;/code&gt; or the name of the file.  Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 의 값이 &lt;code&gt;__main__&lt;/code&gt; 또는 파일 이름 인 것으로 항상 가정합니다. 이 기본값을 다시 변경하면 더 많은 혼동이 발생하여 더 나은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="433366427f82e9a941e28039c28d109ea0304b44" translate="yes" xml:space="preserve">
          <source>It is considered good practice in general to include the &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; in scripts.</source>
          <target state="translated">스크립트에 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 을 포함시키는 것이 일반적으로 좋은 방법으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ae6fdd181016a398f76b7382908ae7290de561a7" translate="yes" xml:space="preserve">
          <source>It is usually written for testing.</source>
          <target state="translated">일반적으로 테스트 용으로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="c3402e91991c1a14ff2a75a0ab38e464eb5133ba" translate="yes" xml:space="preserve">
          <source>It loads the &lt;code&gt;math&lt;/code&gt; module and assigns it to a variable called &lt;code&gt;math&lt;/code&gt;. This is equivalent to replacing &lt;code&gt;import math&lt;/code&gt; with the following (note that &lt;code&gt;__import__&lt;/code&gt; is a low-level function in Python that takes a string and triggers the actual import):</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 모듈을로드하고 math 라는 변수에 할당합니다. 이는 &lt;code&gt;import math&lt;/code&gt; 를 다음으로 바꾸는 것과 같습니다 ( &lt;code&gt;__import__&lt;/code&gt; 는 문자열을 가져와 실제 가져 오기를 트리거하는 Python의 저수준 함수입니다).</target>
        </trans-unit>
        <trans-unit id="56f71295dc0080691356ca0c01cec7d37f4e28e9" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before __name__ guard&quot;&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;before __name__ guard&quot;&lt;/code&gt; 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2577e5a4b9e5bed19b4432e05d2660faee329607" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before functionA&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;before functionA&quot;&lt;/code&gt; 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="990ff0164122db4967979e56b95623fac83be16d" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before functionB&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;before functionB&quot;&lt;/code&gt; 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="67a82144baac90e3bfe77c37b1e7cfd66966d43e" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before import&quot;&lt;/code&gt; (without quotes).</source>
          <target state="translated">&lt;code&gt;&quot;before import&quot;&lt;/code&gt; (따옴표없이) 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="487802f670fb40e8bf81d7517f78375a228bb226" translate="yes" xml:space="preserve">
          <source>It will allow the module and its functions and classes to be imported into other scripts without running the &lt;code&gt;main&lt;/code&gt; function, and will also allow the module (and its functions and classes) to be called when running from a different &lt;code&gt;'__main__'&lt;/code&gt; module, i.e.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 함수를 실행하지 않고 모듈과 함수 및 클래스를 다른 스크립트로 가져올 수 있으며, 다른 &lt;code&gt;'__main__'&lt;/code&gt; 모듈에서 실행할 때 모듈 (및 해당 함수와 클래스)을 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="db31e7b989046834490a12f44ad8c713989903b9" translate="yes" xml:space="preserve">
          <source>It will print the string &lt;code&gt;&quot;after __name__ guard&quot;&lt;/code&gt; in both situations.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;&quot;after __name__ guard&quot;&lt;/code&gt; 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="0640f504c6f1cabceaecd1e002b971be93067ac4" translate="yes" xml:space="preserve">
          <source>Let's look at the answer in a more abstract way:</source>
          <target state="translated">보다 추상적 인 방법으로 답을 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="59c0758ddc6f775006dd70cbf5286216ff0f8137" translate="yes" xml:space="preserve">
          <source>Let's see how this works and how it relates to your question about the &lt;code&gt;__name__&lt;/code&gt; checks we always see in Python scripts.</source>
          <target state="translated">이것이 어떻게 작동하고 파이썬 스크립트에서 항상 볼 수있는 &lt;code&gt;__name__&lt;/code&gt; 검사에 대한 질문과 어떻게 관련이 있는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="36e704322c41ccc6a321769ec4f01db18ff86add" translate="yes" xml:space="preserve">
          <source>Let's see what it does using a simple code that prints the name of the module:</source>
          <target state="translated">모듈 이름을 인쇄하는 간단한 코드를 사용하여 수행하는 작업을 살펴 ​​보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5f645eb565c673e545d1679f2c86c2b42014562e" translate="yes" xml:space="preserve">
          <source>Let's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or &lt;code&gt;def&lt;/code&gt; - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself:</source>
          <target state="translated">들여 쓰기되지 않은 줄과 스크립트에 나타나는 순서에 중점을두고 위의 코드를 단계별로 살펴 보겠습니다. 함수 또는 &lt;code&gt;def&lt;/code&gt; 블록은 호출 될 때까지 자체적으로 아무것도하지 않습니다. 통역사가 스스로에게 말을 걸었을 때의 말 :</target>
        </trans-unit>
        <trans-unit id="1254a1f938039680c725134df68b131b5aa46dc5" translate="yes" xml:space="preserve">
          <source>Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called &lt;code&gt;foo.py&lt;/code&gt;.</source>
          <target state="translated">약간 다른 코드 샘플을 사용하여 가져 오기 및 스크립트 작동 방식을 살펴 보겠습니다. 다음이 &lt;code&gt;foo.py&lt;/code&gt; 파일에 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="842b192efb9c67214acf7a300d55ce4db505bdcc" translate="yes" xml:space="preserve">
          <source>Note that only the top-level &lt;code&gt;print()&lt;/code&gt; statement in &lt;code&gt;my_test_module&lt;/code&gt; is executed.</source>
          <target state="translated">&lt;code&gt;my_test_module&lt;/code&gt; 의 최상위 &lt;code&gt;print()&lt;/code&gt; 문만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="81c6d0a8223e137d4fd96a2fea5acdc58cde2cd7" translate="yes" xml:space="preserve">
          <source>Notice that when used in a package or module, &lt;code&gt;__name__&lt;/code&gt; takes the name of the file.  The path of the actual module or package path is not given, but has its own DunderAlias &lt;code&gt;__file__&lt;/code&gt;, that allows for this.</source>
          <target state="translated">패키지 또는 모듈에서 사용될 때 &lt;code&gt;__name__&lt;/code&gt; 은 파일 이름을 사용합니다. 실제 모듈 또는 패키지 경로의 경로는 제공되지 않지만이를 허용하는 자체 DunderAlias &lt;code&gt;__file__&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf84fdf12bf682b1e82dc617a50185e488527e76" translate="yes" xml:space="preserve">
          <source>Now if you invoke &lt;code&gt;main.py&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;main.py&lt;/code&gt; 를 호출하면 :</target>
        </trans-unit>
        <trans-unit id="7cdbc821008ebfe4fc4cd41f81d12ccd5cec7db9" translate="yes" xml:space="preserve">
          <source>Now if you run &lt;code&gt;my_test_module.py&lt;/code&gt; as a Python script, both &lt;code&gt;print()&lt;/code&gt; statements will be exectued:</source>
          <target state="translated">이제 &lt;code&gt;my_test_module.py&lt;/code&gt; 를 Python 스크립트로 실행하면 두 &lt;code&gt;print()&lt;/code&gt; 문이 모두 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3875b0e9c99d33dd9d9117fb278540c718c1625f" translate="yes" xml:space="preserve">
          <source>Now suppose we call above script from other script</source>
          <target state="translated">이제 다른 스크립트에서 위의 스크립트를 호출한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="32d820770706edc1d47e13dfe4072ab74a677b21" translate="yes" xml:space="preserve">
          <source>Now, figure out what will happen if you remove the &lt;code&gt;__name__&lt;/code&gt; check in &lt;code&gt;foo3.py&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;foo3.py&lt;/code&gt; 에서 &lt;code&gt;__name__&lt;/code&gt; 검사를 제거하면 어떻게 될지 알아 보십시오 .</target>
        </trans-unit>
        <trans-unit id="f61cdcc0e64bc154546828675c159f927f257516" translate="yes" xml:space="preserve">
          <source>Now, if you invoke the interpreter as</source>
          <target state="translated">이제 인터프리터를 다음과 같이 호출하면</target>
        </trans-unit>
        <trans-unit id="8ca2803175deedc185a32811ae0d215b53994bac" translate="yes" xml:space="preserve">
          <source>Oh, a function. I'll remember that.</source>
          <target state="translated">아, 기능. 기억 할게</target>
        </trans-unit>
        <trans-unit id="6077d0ebf452529d19420c847ef52de2a426a2ee" translate="yes" xml:space="preserve">
          <source>Ok, function &lt;code&gt;a()&lt;/code&gt;; I just learned that. Printing '&lt;em&gt;A function in ab file&lt;/em&gt;'.</source>
          <target state="translated">좋아, 함수 &lt;code&gt;a()&lt;/code&gt; ; 방금 배웠습니다. ' &lt;em&gt;ab 파일의 기능&lt;/em&gt; '인쇄 중.</target>
        </trans-unit>
        <trans-unit id="f8c73f6bb1c6fc650c6e40cfdcfea137d51b31bb" translate="yes" xml:space="preserve">
          <source>On import, the &lt;code&gt;do_important&lt;/code&gt; function would be called, so you'd probably comment out your function call, &lt;code&gt;do_important()&lt;/code&gt;, at the bottom.</source>
          <target state="translated">가져올 때 &lt;code&gt;do_important&lt;/code&gt; 함수가 호출되므로 맨 아래에 함수 호출 &lt;code&gt;do_important()&lt;/code&gt; 주석 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="2d793a6eac08930c66fb11b06b414c6c74e2e724" translate="yes" xml:space="preserve">
          <source>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:</source>
          <target state="translated">반면에 다른 모듈이 기본 프로그램이고 모듈을 가져 오는 것으로 가정합니다. 이것은 메인 프로그램이나 메인 모듈이 가져 오는 다른 모듈에서 이와 같은 문장이 있다는 것을 의미합니다 :</target>
        </trans-unit>
        <trans-unit id="4b8160972d3ededbe405e2919fa2974b8a5330ed" translate="yes" xml:space="preserve">
          <source>Open xy.py as the 'home' file; call it &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; in the &lt;code&gt;__name__&lt;/code&gt; variable.</source>
          <target state="translated">xy.py를 'home'파일로여십시오. &lt;code&gt;__name__&lt;/code&gt; 변수에서 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 이라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="a703490bf01742db237973ccf277b94b1592d61d" translate="yes" xml:space="preserve">
          <source>Put simply, &lt;code&gt;__name__&lt;/code&gt; is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.</source>
          <target state="translated">간단히 말해 &lt;code&gt;__name__&lt;/code&gt; 은 스크립트가 기본 모듈로 실행되는지 아니면 가져온 모듈로 실행되는지를 정의하는 각 스크립트에 대해 정의 된 변수입니다.</target>
        </trans-unit>
        <trans-unit id="e37067e387ec00a654d6a8a4421c869e9ce7f02b" translate="yes" xml:space="preserve">
          <source>Question: Can I have multiple &lt;code&gt;__name__&lt;/code&gt; checking blocks?  Answer: it's strange to do so, but the language won't stop you.</source>
          <target state="translated">질문 : &lt;code&gt;__name__&lt;/code&gt; 점검 블록을 여러 개 가질 수 있습니까? 답 : 그렇게하는 것이 이상하지만 언어는 당신을 막을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f6213cf7dc0a0a2692503179dc1a74e244db9a2" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://docs.python.org/3.5/tutorial/modules.html&quot;&gt;https://docs.python.org/3.5/tutorial/modules.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;https://docs.python.org/3.5/tutorial/modules.html&quot;&gt;https://docs.python.org/3.5/tutorial/modules.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="664467ee79494c88e6f1e2c2697dbbe4ff48a5d2" translate="yes" xml:space="preserve">
          <source>Remember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the &lt;code&gt;main()&lt;/code&gt; function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script.</source>
          <target state="translated">수입 명세서에 대해 앞서 말한 것을 기억하십니까? 모듈을 가져올 때 모듈을 '인식'하고 추가 지시를 기다리는 것이 아니라 실제로 스크립트 내에 포함 된 모든 실행 가능한 작업을 실행합니다. 따라서 스크립트의 고기를 &lt;code&gt;main()&lt;/code&gt; 함수에 넣으면 효과적으로 격리하여 다른 스크립트로 가져올 때 즉시 실행되지 않도록 격리시킵니다.</target>
        </trans-unit>
        <trans-unit id="f98434905bc42aec74771816b1350633e53ce854" translate="yes" xml:space="preserve">
          <source>Resulting in &lt;code&gt;__main__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__main__&lt;/code&gt; 의 결과</target>
        </trans-unit>
        <trans-unit id="e63592c750f974c67228385bd47700a1dc930828" translate="yes" xml:space="preserve">
          <source>Resulting in &lt;code&gt;somefile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;somefile&lt;/code&gt; 결과</target>
        </trans-unit>
        <trans-unit id="dca1109ee592b30f70306745ecaf4e3be65dabb6" translate="yes" xml:space="preserve">
          <source>Run it. It will print &lt;strong&gt;a&lt;/strong&gt;, i.e., the name of the file which &lt;strong&gt;is imported&lt;/strong&gt;.</source>
          <target state="translated">그것을 실행하십시오. &lt;strong&gt;가져온&lt;/strong&gt; 파일의 이름을 인쇄 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3f5bef58a00ebcb694aa52babce37958f2b198f1" translate="yes" xml:space="preserve">
          <source>Run the class stand alone, for testing purposes.</source>
          <target state="translated">테스트 목적으로 수업을 단독으로 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="20e86911fbff3e384f7f5f09191137367a0df800" translate="yes" xml:space="preserve">
          <source>Running them will get you this output:</source>
          <target state="translated">그것들을 실행하면 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ec89290100bc024be13c487e6ae209eaa691b9" translate="yes" xml:space="preserve">
          <source>Say you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the  &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;</source>
          <target state="translated">훌륭한 기능을 수행하는 Python 스크립트를 작성하고 다른 목적에 유용한 함수의 보트로드를 구현한다고 가정 해보십시오. 그것들을 사용하려면 스크립트를 가져 와서 프로그램을 실행하지 않고 스크립트를 사용할 수 있습니다 (코드가 &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 컨텍스트 내에서만 실행되는 경우 ). C / C ++에서는 이러한 부분을 파일을 포함하는 별도의 모듈로 나누어야합니다. 아래 상황을 묘사하십시오.</target>
        </trans-unit>
        <trans-unit id="8d613d269c466eb978baefb1a911abf766ab0238" translate="yes" xml:space="preserve">
          <source>Say you're writing a Python script designed to be used as a module:</source>
          <target state="translated">모듈로 사용하도록 설계된 Python 스크립트를 작성한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="fb6ab9485c691b027c37729a425f370d612207ed" translate="yes" xml:space="preserve">
          <source>Simply, it is the entry point to run the file, like the &lt;code&gt;main&lt;/code&gt; function in the &lt;em&gt;C&lt;/em&gt; programming language.</source>
          <target state="translated">간단히 말하면 &lt;em&gt;C&lt;/em&gt; 프로그래밍 언어의 &lt;code&gt;main&lt;/code&gt; 기능과 같이 파일을 실행하는 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="2f0eb42cc94ae6f1d6b27a11e936825cd6e9be63" translate="yes" xml:space="preserve">
          <source>Small example to explain in short.</source>
          <target state="translated">간단히 설명하는 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="abff45f4f7494a045c401c2b502e510dbd014b28" translate="yes" xml:space="preserve">
          <source>So if we have two scripts;</source>
          <target state="translated">우리가 두 개의 스크립트를 가지고 있다면;</target>
        </trans-unit>
        <trans-unit id="84ce746d38e49c0592c794aa0e1ec5b2af9e35c4" translate="yes" xml:space="preserve">
          <source>So if you check before executing:</source>
          <target state="translated">따라서 실행하기 전에 확인하면 :</target>
        </trans-unit>
        <trans-unit id="640d3626fbf5c4384513193cd5a05b99491f804b" translate="yes" xml:space="preserve">
          <source>So that is what this line of code checks. If it is the main file (i.e., b.py) running the code, which in this case it is not (a.py is the main file running), then only the code gets executed.</source>
          <target state="translated">이것이 바로이 코드 라인이 확인하는 것입니다. 코드를 실행하는 기본 파일 (즉, b.py) 인 경우 (이 경우에는 실행되지 않는 (a.py는 기본 파일 임)) 코드 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="263e6ff9fdb235045559021aa4f3aaf6a28dd1e6" translate="yes" xml:space="preserve">
          <source>So, above is self explanatory that when you call test from other script, if loop &lt;code&gt;__name__&lt;/code&gt; in &lt;code&gt;test.py&lt;/code&gt; will not execute.</source>
          <target state="translated">따라서 위의 설명은 다른 스크립트에서 test를 호출 할 때 &lt;code&gt;test.py&lt;/code&gt; 의 &lt;code&gt;__name__&lt;/code&gt; 루프가 실행되지 않는 경우에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="68f77a6ccbf56724f5b40205ddb5e475652f0586" translate="yes" xml:space="preserve">
          <source>So, code under the &lt;code&gt;if&lt;/code&gt; block will only run if the module is the entry point to your program.</source>
          <target state="translated">따라서 &lt;code&gt;if&lt;/code&gt; 블록 아래의 코드는 모듈이 프로그램의 진입 점 인 경우에만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f39f20521dcc328835dd2bae85539d96c3ed5764" translate="yes" xml:space="preserve">
          <source>So, in your example in part:</source>
          <target state="translated">따라서 일부 예에서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b0e64ff7926b8af4a777a49504ee4171aa1f955" translate="yes" xml:space="preserve">
          <source>So, to show &lt;strong&gt;two different behavior of the same file&lt;/strong&gt;, this is a commonly used trick:</source>
          <target state="translated">따라서 &lt;strong&gt;동일한 파일의 두 가지 동작&lt;/strong&gt; 을 보여주기 위해 일반적으로 사용되는 트릭입니다.</target>
        </trans-unit>
        <trans-unit id="1fd11fffb92fae55b373db1f1b2a14481892db42" translate="yes" xml:space="preserve">
          <source>Special Variables</source>
          <target state="translated">특수 변수</target>
        </trans-unit>
        <trans-unit id="b0b9fd78351c8645d3bb611c5714fc4fb48a880a" translate="yes" xml:space="preserve">
          <source>Suppose the following is in &lt;code&gt;foo2.py&lt;/code&gt;.  What happens if you say &lt;code&gt;python foo2.py&lt;/code&gt; on the command-line? Why?</source>
          <target state="translated">다음이 &lt;code&gt;foo2.py&lt;/code&gt; 에 있다고 가정하십시오. 명령 행에서 &lt;code&gt;python foo2.py&lt;/code&gt; 를 말하면 어떻게됩니까? 왜?</target>
        </trans-unit>
        <trans-unit id="19e0db61176529f3b08091162b28a1b8097dbc39" translate="yes" xml:space="preserve">
          <source>Suppose we have this code in x.py:</source>
          <target state="translated">이 코드가 x.py에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b522da1d722893c1c3514d7e1c720966c233662f" translate="yes" xml:space="preserve">
          <source>Take file &quot;ab.py&quot;:</source>
          <target state="translated">&quot;ab.py&quot;파일을 가져 오십시오 :</target>
        </trans-unit>
        <trans-unit id="63dd3922ae392ebb0802b3e1fb913af39e39d6ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__name__&lt;/code&gt; variable points to the namespace wherever the Python interpreter happens to be at the moment.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 변수는 파이썬 인터프리터가 현재 어디에 있든지 네임 스페이스를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="d9eef56265e1ad5d7b64df6c1fea6c1c26857bc3" translate="yes" xml:space="preserve">
          <source>The above statement is true and prints &lt;em&gt;&quot;direct method&quot;&lt;/em&gt;. Suppose if they imported this class in another class it doesn't print &lt;em&gt;&quot;direct method&quot;&lt;/em&gt; because, while importing, it will set &lt;code&gt;__name__ equal to &quot;first model name&quot;&lt;/code&gt;.</source>
          <target state="translated">위의 내용은 true이고 &lt;em&gt;&quot;direct method&quot;를&lt;/em&gt; 인쇄합니다. 가져 오는 동안 &lt;code&gt;__name__ equal to &quot;first model name&quot;&lt;/code&gt; 하게 설정하기 때문에이 클래스를 다른 클래스로 가져온 경우 &lt;em&gt;&quot;직접 메소드&quot;를&lt;/em&gt; 인쇄하지 않는다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2b0b314d4585244ae8ac5cd70de557719041b367" translate="yes" xml:space="preserve">
          <source>The arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:</source>
          <target state="translated">화살표는 가져 오기 링크입니다. 각각 이전 모듈 코드를 포함시키려는 세 개의 모듈에는 6 개의 파일 (9 개, 구현 파일 수)과 5 개의 링크가 있습니다. 라이브러리로 특별히 컴파일되지 않으면 다른 코드를 C 프로젝트에 포함시키기가 어렵습니다. 이제 파이썬으로 그림을 그려보십시오.</target>
        </trans-unit>
        <trans-unit id="b96b1c26d7d07398a4108598c24c3f6449d82fe1" translate="yes" xml:space="preserve">
          <source>The bottom two lines mean: &quot;If this is the &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; or 'home' script, execute the function called &lt;code&gt;main()&lt;/code&gt;&quot;. That's why you'll see a &lt;code&gt;def main():&lt;/code&gt; block up top, which contains the main flow of the script's functionality.</source>
          <target state="translated">맨 아래 두 줄은 &quot;이것이 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 또는&quot;home &quot;스크립트 인 경우 &lt;code&gt;main()&lt;/code&gt; 이라는 함수를 실행하십시오. &lt;code&gt;def main():&lt;/code&gt; block up top이 스크립트 기능의 주요 흐름을 포함하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="ee36bd7aa18be8f75cff321a8cbe45b79fa20c99" translate="yes" xml:space="preserve">
          <source>The code inside &lt;code&gt;if __name__ == '__main__':&lt;/code&gt;&lt;strong&gt;will only be executed if the module is invoked as a script&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 내부의 코드 &lt;strong&gt;는 모듈이 스크립트로 호출 된 경우에만 실행됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c7cb418b6654cc08bd7fdbc541322601045fee60" translate="yes" xml:space="preserve">
          <source>The global variable, &lt;code&gt;__name__&lt;/code&gt;, in the module that is the entry point to your program, is &lt;code&gt;'__main__'&lt;/code&gt;. Otherwise, it's the name you import the module by.</source>
          <target state="translated">프로그램의 진입 점 인 모듈의 전역 변수 &lt;code&gt;__name__&lt;/code&gt; 은 &lt;code&gt;'__main__'&lt;/code&gt; 입니다. 그렇지 않으면 모듈을 가져 오는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="abc8795a207d7fd1e55acd3339216f07ad278e91" translate="yes" xml:space="preserve">
          <source>The important thing that python is special at is point 4! The rest is just basic logic.</source>
          <target state="translated">파이썬이 특별한 점은 포인트 4입니다! 나머지는 기본 논리입니다.</target>
        </trans-unit>
        <trans-unit id="070234b07de191f078cf7dded19198b7b44d467d" translate="yes" xml:space="preserve">
          <source>The interpreter keeps track of which scripts are running with &lt;code&gt;__name__&lt;/code&gt;. When you run a script - no matter what you've named it - the interpreter calls it &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;, making it the master or 'home' script that gets returned to after running an external script.</source>
          <target state="translated">인터프리터는 &lt;code&gt;__name__&lt;/code&gt; 과 함께 실행중인 스크립트를 추적합니다. 스크립트의 이름에 관계없이 스크립트를 실행하면 인터프리터는이를 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 이라고 부르며 외부 스크립트를 실행 한 후 반환되는 마스터 또는 '홈'스크립트가됩니다.</target>
        </trans-unit>
        <trans-unit id="e490bbfebdeff408a85402b8066f8e0d765afb42" translate="yes" xml:space="preserve">
          <source>The interpreter will search for your &lt;code&gt;foo.py&lt;/code&gt; file (along with searching for a few other variants), and prior to executing that module, it will assign the name &lt;code&gt;&quot;foo&quot;&lt;/code&gt; from the import statement to the &lt;code&gt;__name__&lt;/code&gt; variable, i.e.</source>
          <target state="translated">인터프리터는 &lt;code&gt;foo.py&lt;/code&gt; 파일을 검색하고 (몇 가지 다른 변형 검색과 함께) 해당 모듈을 실행하기 전에 import 문에서 &lt;code&gt;__name__&lt;/code&gt; 변수에 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 라는 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="beb5c6ca096be5c499ae9d622ede781690b12de1" translate="yes" xml:space="preserve">
          <source>The output for the above is &lt;code&gt;__main__&lt;/code&gt;.</source>
          <target state="translated">위의 출력은 &lt;code&gt;__main__&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b315daf004ca0729cd2f96be56c31138214abce" translate="yes" xml:space="preserve">
          <source>The output from executing script1 is</source>
          <target state="translated">script1을 실행 한 결과는</target>
        </trans-unit>
        <trans-unit id="a61791ccd424eca040a7f63b8afadbed687c913a" translate="yes" xml:space="preserve">
          <source>The output will be</source>
          <target state="translated">출력은</target>
        </trans-unit>
        <trans-unit id="f7783b7273a972da2fb19a09cf27c06a5a76b303" translate="yes" xml:space="preserve">
          <source>The reason for</source>
          <target state="translated">대한 이유</target>
        </trans-unit>
        <trans-unit id="461ad2d3ca9debfc02d07f3beea45fedd8fe7c48" translate="yes" xml:space="preserve">
          <source>The simplest explanation for the &lt;code&gt;__name__&lt;/code&gt; variable (imho) is the following:</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 변수 (imho)에 대한 가장 간단한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7bb35afec92b2288483eddfee92b6b137ba1ffee" translate="yes" xml:space="preserve">
          <source>There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the &lt;strong&gt;__name__&lt;/strong&gt; variable/attribute:</source>
          <target state="translated">시스템 (Python 인터프리터)이 소스 파일 (모듈)에 제공하는 여러 변수가 있습니다. 언제든지 원하는 값을 얻을 수 있으므로 &lt;strong&gt;__name__&lt;/strong&gt; 변수 / 속성에 중점을 두십시오.</target>
        </trans-unit>
        <trans-unit id="d334018c829a8afc4b891e4ccfd37fcb00325b95" translate="yes" xml:space="preserve">
          <source>There are lots of different takes here on the mechanics of the code in question, the &quot;How&quot;, but for me none of it made sense until I understood the &quot;Why&quot;. This should be especially helpful for new programmers.</source>
          <target state="translated">문제의 코드 메커니즘 인 &quot;어떻게&quot;에 대한 다양한 설명이 여기에 있지만 &quot;왜&quot;를 이해하기 전까지는 아무런 의미가 없었습니다. 이것은 새로운 프로그래머에게 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e63743be839c5f96b5ee726f165c404beeea8567" translate="yes" xml:space="preserve">
          <source>There's a Pythonic way to improve on this, though.</source>
          <target state="translated">그래도 이것을 개선하는 Pythonic 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da449e38cd83db4680bb69d26f25544a12a00c0" translate="yes" xml:space="preserve">
          <source>This answer is for Java programmers learning Python.
Every Java file typically contains one public class. You can use that class in two ways:</source>
          <target state="translated">이 답변은 Python을 배우는 Java 프로그래머를위한 것입니다. 모든 Java 파일에는 일반적으로 하나의 공용 클래스가 포함됩니다. 해당 클래스를 두 가지 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a93248e8c28b2baad3105d4909c76fa1d06bca1b" translate="yes" xml:space="preserve">
          <source>This means that if &lt;code&gt;__name__&lt;/code&gt; is equal to &lt;code&gt;__main__&lt;/code&gt; then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.</source>
          <target state="translated">이는 &lt;code&gt;__name__&lt;/code&gt; 이 &lt;code&gt;__main__&lt;/code&gt; 과 같으면 파일이 기본 파일이어야하며 스크립트로 가져온 모듈이나 패키지가 아니라 실제로 실행 중이거나 인터프리터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="26768ab59b39b3300f945b6b412204438fd854c1" translate="yes" xml:space="preserve">
          <source>This module represents the (otherwise anonymous) scope in which the
  interpreter&amp;rsquo;s main program executes &amp;mdash; commands read either from
  standard input, from a script file, or from an interactive prompt. It
  is this environment in which the idiomatic &amp;ldquo;conditional script&amp;rdquo; stanza
  causes a script to run:</source>
          <target state="translated">이 모듈은 인터프리터의 기본 프로그램이 실행하는 (그렇지 않은 익명의) 범위를 나타냅니다. 명령은 표준 입력, 스크립트 파일 또는 대화식 프롬프트에서 읽습니다. 관용적 인 &quot;조건부 스크립트&quot;스탠자가 스크립트를 실행하는 환경은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="570c99fbd84e48be7a4bc039c23bb770f7a93f2d" translate="yes" xml:space="preserve">
          <source>This tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute.  If it is a package then it should not, and the value will not be &lt;code&gt;__main__&lt;/code&gt;.</source>
          <target state="translated">이것은 실행중인 파일이 기본 파일 (또는 인터프리터에서 직접 실행중인 경우)이면 해당 조건을 실행해야 함을 알려줍니다. 패키지 인 경우 패키지가 아니어야하며 값은 &lt;code&gt;__main__&lt;/code&gt; 이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="400df23e6535cffd76bdbec3d29bf175104d993d" translate="yes" xml:space="preserve">
          <source>Thus, including &lt;a href=&quot;https://docs.python.org/library/__main__.html&quot;&gt;the final lines&lt;/a&gt;</source>
          <target state="translated">따라서 &lt;a href=&quot;https://docs.python.org/library/__main__.html&quot;&gt;마지막 줄을&lt;/a&gt; 포함 하여</target>
        </trans-unit>
        <trans-unit id="41ff41b822d3a441a23084a1b748580b08728f3a" translate="yes" xml:space="preserve">
          <source>Thus, the value of the &lt;code&gt;__name__&lt;/code&gt; attribute is set to &lt;code&gt;__main__&lt;/code&gt; when the module is run as the main program. Otherwise the value of &lt;code&gt;__name__&lt;/code&gt;  is set to contain the name of the module.</source>
          <target state="translated">따라서 모듈이 기본 프로그램으로 실행될 때 &lt;code&gt;__name__&lt;/code&gt; 속성의 값은 &lt;code&gt;__main__&lt;/code&gt; 로 설정됩니다. 그렇지 않으면 &lt;code&gt;__name__&lt;/code&gt; 값이 모듈 이름을 포함하도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e5bb2a5a3f702f74d72560d048b4376dfc0840a3" translate="yes" xml:space="preserve">
          <source>Thus, when module &lt;code&gt;one&lt;/code&gt; gets loaded, its &lt;code&gt;__name__&lt;/code&gt; equals &lt;code&gt;&quot;one&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.</source>
          <target state="translated">따라서 모듈 &lt;code&gt;one&lt;/code&gt; &lt;code&gt;__name__&lt;/code&gt; 드 될 때 __name__ 은 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;one&quot;&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="523dcaae791ba2376f9d0e38205b6e104584b94b" translate="yes" xml:space="preserve">
          <source>To be short, you need to know several points:</source>
          <target state="translated">간단히 말해 몇 가지 사항을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="ab6345109ea5809edd76f43e5ad346f6c84b96e7" translate="yes" xml:space="preserve">
          <source>To outline the basics:</source>
          <target state="translated">기본 사항을 설명하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="12ab10369b1f47def1cf885774f934b4e0985f34" translate="yes" xml:space="preserve">
          <source>To solve the problem in point 2, python allows you to put a condition check</source>
          <target state="translated">포인트 2의 문제를 해결하기 위해 파이썬은 조건 검사를 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4711ba0e3e6d6e4a6ad75a1fa7aa2587e14a3867" translate="yes" xml:space="preserve">
          <source>We can execute this directly as</source>
          <target state="translated">우리는 이것을 다음과 같이 직접 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="babfa4c489d804dc449fbd841bce76fc1745bd5c" translate="yes" xml:space="preserve">
          <source>We now have a final function for the end of our module that will run if we run the module as the primary module.</source>
          <target state="translated">이제 모듈을 기본 모듈로 실행하면 실행될 모듈의 마지막 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c12bf3938c1cb1ecd0ac996a47bdeae5af33c7c" translate="yes" xml:space="preserve">
          <source>We see if &lt;code&gt;__name__ == '__main__':&lt;/code&gt; quite often.</source>
          <target state="translated">우리는 &lt;code&gt;__name__ == '__main__':&lt;/code&gt; 매우 자주 봅니다.</target>
        </trans-unit>
        <trans-unit id="8c1bfdb1fcdcd5574d83109e0bae5ad3a5cf62db" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; do?</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="882f556d9b969816afbc080f2c0c2833e74571bd" translate="yes" xml:space="preserve">
          <source>What does if __name__ == “__main__”: do</source>
          <target state="translated">__name__ ==&amp;ldquo;__main__&amp;rdquo;인 경우 수행 할 작업 :</target>
        </trans-unit>
        <trans-unit id="0519ae47b8614fd1d5f5805a3c6ace1513a3c429" translate="yes" xml:space="preserve">
          <source>What does the &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; do?</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 은 무엇을합니까?</target>
        </trans-unit>
        <trans-unit id="e8ade84c1dddd0abd1d4a5cbe46e38dc11bedceb" translate="yes" xml:space="preserve">
          <source>What if we want to run this business process from outside the module?</source>
          <target state="translated">모듈 외부에서이 비즈니스 프로세스를 실행하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="849ed2229cbffb820dde4aac079e940cbf66d22f" translate="yes" xml:space="preserve">
          <source>What is this code actually doing?</source>
          <target state="translated">이 코드는 실제로 무엇을하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="ac4dd5fb5ee621db0e7fc13bfab42a28cf4cb6c7" translate="yes" xml:space="preserve">
          <source>What will this do when used as a script?  When imported as a module?</source>
          <target state="translated">스크립트로 사용하면 어떻게됩니까? 모듈로 가져올 때?</target>
        </trans-unit>
        <trans-unit id="34026079e5767a32ede0b2469d594a04aa502cd0" translate="yes" xml:space="preserve">
          <source>What's this? An &lt;code&gt;if&lt;/code&gt; statement. Well, the condition has been met (the variable &lt;code&gt;__name__&lt;/code&gt; has been set to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;), so I'll enter the &lt;code&gt;main()&lt;/code&gt; function and print '&lt;em&gt;main function: this is where the action is&lt;/em&gt;'.</source>
          <target state="translated">이게 뭐야? &lt;code&gt;if&lt;/code&gt; 문. 조건이 충족되었으므로 (변수 &lt;code&gt;__name__&lt;/code&gt; 이 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 으로 설정 됨) &lt;code&gt;main()&lt;/code&gt; 함수를 입력하고 ' &lt;em&gt;main function :&lt;/em&gt; print &lt;em&gt;the main function :이 곳이 액션입니다&lt;/em&gt; '입니다.</target>
        </trans-unit>
        <trans-unit id="a7a878649d8009684428450f8af9b808c3a3075d" translate="yes" xml:space="preserve">
          <source>When Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.)</source>
          <target state="translated">파이썬은 소스 코드 파일을로드 할 때, 그 안에있는 모든 코드를 실행합니다. (파일에 정의 된 모든 메소드와 함수를 호출하지는 않지만 정의합니다.)</target>
        </trans-unit>
        <trans-unit id="2a4ffb529b1700ce20d37ede654fc1142a11d491" translate="yes" xml:space="preserve">
          <source>When the Python interpeter reads a source file, it first defines a few special variables. In this case, we care about the &lt;code&gt;__name__&lt;/code&gt; variable.</source>
          <target state="translated">Python interpeter가 소스 파일을 읽을 때 먼저 몇 가지 특수 변수를 정의합니다. 이 경우 &lt;code&gt;__name__&lt;/code&gt; 변수에 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="447dd3597ff37641a5da70095abbfb1e338af1d5" translate="yes" xml:space="preserve">
          <source>When there are certain statements in our module (&lt;code&gt;M.py&lt;/code&gt;) we want to be executed when it'll be running as main (not imported), we can place those statements (test-cases, print statements) under this &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">모듈 ( &lt;code&gt;M.py&lt;/code&gt; )에 특정 명령문이있는 경우 메인 (가져 오기되지 않은 )으로 실행될 때 실행되기를 원합니다.이 &lt;code&gt;if&lt;/code&gt; 블록 아래에 해당 명령문 (테스트 케이스, 인쇄 명령문)을 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9877906a93c95cdaf2921362477e675f7b677ec6" translate="yes" xml:space="preserve">
          <source>When you execute &lt;code&gt;xy.py&lt;/code&gt;, you &lt;code&gt;import ab&lt;/code&gt;. The import statement runs the module immediately on import, so &lt;code&gt;ab&lt;/code&gt;'s operations get executed before the remainder of &lt;code&gt;xy&lt;/code&gt;'s. Once finished with &lt;code&gt;ab&lt;/code&gt;, it continues with &lt;code&gt;xy&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xy.py&lt;/code&gt; 를 실행하면 &lt;code&gt;import ab&lt;/code&gt; 를 가져옵니다 . import 문은 모듈을 가져올 때 즉시 모듈을 실행하므로 &lt;code&gt;ab&lt;/code&gt; 의 작업은 나머지 &lt;code&gt;xy&lt;/code&gt; 보다 먼저 실행됩니다. &lt;code&gt;ab&lt;/code&gt; 로 끝나면 &lt;code&gt;xy&lt;/code&gt; 로 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="b8b36e56cdbe31fc5262405f5324cf63c8c6e4bf" translate="yes" xml:space="preserve">
          <source>When you execute this</source>
          <target state="translated">이것을 실행할 때</target>
        </trans-unit>
        <trans-unit id="6fd61966708d4f62ded02175bf761bbf0e8fb9c3" translate="yes" xml:space="preserve">
          <source>When you run Python interactively the local &lt;code&gt;__name__&lt;/code&gt; variable is assigned a value of &lt;code&gt;__main__&lt;/code&gt;. Likewise, when you execute a Python module from the command line, rather than importing it into another module, its &lt;code&gt;__name__&lt;/code&gt; attribute is assigned a value of &lt;code&gt;__main__&lt;/code&gt;, rather than the actual name of the module. In this way, modules can look at their own &lt;code&gt;__name__&lt;/code&gt; value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:</source>
          <target state="translated">파이썬을 대화식으로 실행하면 로컬 &lt;code&gt;__name__&lt;/code&gt; 변수에 &lt;code&gt;__main__&lt;/code&gt; 값이 할당됩니다. 마찬가지로, 다른 모듈로 가져 오는 대신 명령 줄에서 Python 모듈을 실행할 때 해당 &lt;code&gt;__name__&lt;/code&gt; 속성에 실제 모듈 이름이 아닌 &lt;code&gt;__main__&lt;/code&gt; 값이 할당됩니다. 이런 식으로 모듈은 다른 프로그램을 지원하거나 명령 줄에서 실행되는 기본 응용 프로그램인지 여부에 관계없이 자체 &lt;code&gt;__name__&lt;/code&gt; 값을 사용하여 사용 방법을 결정할 수 있습니다. 따라서 다음 관용구는 파이썬 모듈에서 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="4382aa34afa3d659f0bb4edaf5dcf55f253232cd" translate="yes" xml:space="preserve">
          <source>When you run this script prints &lt;strong&gt;you can see me&lt;/strong&gt;</source>
          <target state="translated">이 스크립트 인쇄를 실행하면 &lt;strong&gt;나를 볼 수 있습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff92db554b1095b0d40299da20c445f80406d870" translate="yes" xml:space="preserve">
          <source>When your script is run by passing it as a command to the Python interpreter,</source>
          <target state="translated">스크립트를 Python 인터프리터에 명령으로 전달하여 스크립트를 실행하면</target>
        </trans-unit>
        <trans-unit id="ab593498ef9ec53331cbff2af3b2dd2b51bdf819" translate="yes" xml:space="preserve">
          <source>Whenever the Python interpreter reads a source file, it does two things:</source>
          <target state="translated">파이썬 인터프리터는 소스 파일을 읽을 때마다 다음 두 가지를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6a1d2d8182ddb99759342b07d21796d4a90b92eb" translate="yes" xml:space="preserve">
          <source>Why Does It Work This Way?</source>
          <target state="translated">왜 이런 식으로 작동합니까?</target>
        </trans-unit>
        <trans-unit id="fc47432e4bb8b9783f8dbd23b35f57d699c4a18e" translate="yes" xml:space="preserve">
          <source>Why do we need this?</source>
          <target state="translated">왜이게 필요한가요?</target>
        </trans-unit>
        <trans-unit id="acd0bc142a66a740172c6969fcbd8897e5de82ac" translate="yes" xml:space="preserve">
          <source>Why implement this?</source>
          <target state="translated">왜 이것을 구현해야합니까?</target>
        </trans-unit>
        <trans-unit id="b6e9143e9e32c607148934a535cfda140fe418d6" translate="yes" xml:space="preserve">
          <source>With the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script).</source>
          <target state="translated">위의 코드를 사용하면 코드를 기본 모듈로 실행하거나 의도적으로 다른 스크립트에서 호출 할 때만 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="913a9ffbcabac7b4746945a64e723d43537938ef" translate="yes" xml:space="preserve">
          <source>Yes, that's right. These separate functions &lt;strong&gt;can&lt;/strong&gt; be called from an in-line script that's not contained inside a &lt;code&gt;main()&lt;/code&gt; function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read.</source>
          <target state="translated">네 맞습니다. 이러한 별도의 함수 &lt;strong&gt;는&lt;/strong&gt; &lt;code&gt;main()&lt;/code&gt; 함수에 포함되지 않은 인라인 스크립트에서 호출 &lt;strong&gt;할 수&lt;/strong&gt; 있습니다. 당신이 (필자의 초기 학습 단계에서) 당신이 필요로하는 것을 정확하게 수행하는 인라인 스크립트를 만드는 데 익숙하다면, 당신은 그 작업이 다시 필요할 때 다시 알아 내려고 노력할 것입니다. 글쎄, 당신은 코드에 대한 이러한 종류의 내부 구조에 익숙하지 않습니다. 왜냐하면 빌드하기가 더 복잡하고 읽기가 직관적이지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bbf85bd3bd1a2f405d72d298d6d2e8dc0e6a4075" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; test the module by adding this call of the function to the bottom:</source>
          <target state="translated">이 함수 호출을 맨 아래에 추가하여 모듈을 테스트 &lt;em&gt;할 수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="786d584d19c5e53ad4e4097843269cf6c5e6292a" translate="yes" xml:space="preserve">
          <source>You can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.</source>
          <target state="translated">또한 라이브러리를 정교하게 사용하지 않고도 패키지 및 모듈에서 실행 가능한 도움말 기능 / 유틸리티를 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1022be4eed5ff0cd45b00fa73b4ca1a925550db8" translate="yes" xml:space="preserve">
          <source>You can make the file usable as a &lt;strong&gt;script&lt;/strong&gt; as well as an &lt;strong&gt;importable module&lt;/strong&gt;.</source>
          <target state="translated">가져 &lt;strong&gt;오기 가능한 모듈&lt;/strong&gt; 뿐만 아니라 &lt;strong&gt;스크립트&lt;/strong&gt; 로 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53eb1352da0ffb51c0ec047f0ef125c909ddaefa" translate="yes" xml:space="preserve">
          <source>You get</source>
          <target state="translated">당신은 얻을</target>
        </trans-unit>
        <trans-unit id="dadc4d8e7d9fa9779b4e08f566981499d80cb4e7" translate="yes" xml:space="preserve">
          <source>You might naturally wonder why anybody would want this.  Well, sometimes you want to write a &lt;code&gt;.py&lt;/code&gt; file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:</source>
          <target state="translated">왜 아무도 이것을 원하는지 궁금 할 것입니다. 글쎄, 때로는 다른 프로그램 및 / 또는 모듈에서 모듈로 사용할 수있는 &lt;code&gt;.py&lt;/code&gt; 파일을 작성하고 주 프로그램 자체로 실행할 수도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8047f868d8a396e2d98f574de9648be818c0aee6" translate="yes" xml:space="preserve">
          <source>You should see that, where &lt;code&gt;__name__&lt;/code&gt;, where it is the main file (or program) will &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;__main__&lt;/code&gt;, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.</source>
          <target state="translated">여기서 &lt;code&gt;__name__&lt;/code&gt; 은 기본 파일 (또는 프로그램) 인 곳에서 &lt;em&gt;항상&lt;/em&gt; &lt;code&gt;__main__&lt;/code&gt; 을 반환하며 모듈 / 패키지 또는 다른 Python 스크립트에서 실행중인 모든 파일은 파일 이름을 반환합니다 그것이 시작된 곳.</target>
        </trans-unit>
        <trans-unit id="737d0a68671613e4f63d5688dcabf38a268873ac" translate="yes" xml:space="preserve">
          <source>You write a module, and if someone wants to use your code they just import it and the &lt;code&gt;__name__&lt;/code&gt; variable can help to separate the executable portion of the program from the library part.</source>
          <target state="translated">모듈을 작성하고 누군가가 코드를 사용하려면 모듈을 가져 오면 &lt;code&gt;__name__&lt;/code&gt; 변수가 프로그램의 실행 가능 부분을 라이브러리 부분과 분리하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e48102eb585faacfdf2ded85e1a6e43222bcef6c" translate="yes" xml:space="preserve">
          <source>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.</source>
          <target state="translated">모듈은 라이브러리이지만 일부 단위 테스트 또는 데모를 실행하는 스크립트 모드를 원합니다.</target>
        </trans-unit>
        <trans-unit id="9775ebd3a1d07733317e1e64b5d35d40fca683d8" translate="yes" xml:space="preserve">
          <source>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.</source>
          <target state="translated">모듈은 주로 기본 프로그램으로 사용되지만 고급 사용자를위한 프로그래머 친화적 인 API도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="327fb7d82f537223ad218bd0c2bd1f339f312554" translate="yes" xml:space="preserve">
          <source>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing &lt;code&gt;.py&lt;/code&gt; files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.</source>
          <target state="translated">모듈은 기본 프로그램으로 만 사용되지만 몇 가지 단위 테스트가 있으며 테스트 프레임 워크는 스크립트와 같은 &lt;code&gt;.py&lt;/code&gt; 파일을 가져오고 특수 테스트 기능을 실행하여 작동합니다. 모듈을 가져 오기 때문에 스크립트를 실행하지 않으려 고합니다.</target>
        </trans-unit>
        <trans-unit id="7921914ab3f7b51666817a9add8daeeb610bdeaf" translate="yes" xml:space="preserve">
          <source>all of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there's no &lt;code&gt;main()&lt;/code&gt; function that gets run automatically - the &lt;code&gt;main()&lt;/code&gt; function is implicitly all the code at the top level.</source>
          <target state="translated">들여 쓰기 수준 0에있는 모든 코드가 실행됩니다. 정의 된 함수와 클래스는 잘 정의되어 있지만 해당 코드는 실행되지 않습니다. 다른 언어와 달리 자동으로 실행되는 &lt;code&gt;main()&lt;/code&gt; 함수는 없습니다. main () 함수는 암시 적으로 최상위 레벨의 모든 코드입니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="57216f4f62e4c7cff528a1042119b6bd292590a1" translate="yes" xml:space="preserve">
          <source>and running it (on a command prompt) with something like:</source>
          <target state="translated">다음과 같이 명령 프롬프트에서 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3ef1ebbdd755420799ee3cf5f1bbe79340df1c25" translate="yes" xml:space="preserve">
          <source>at the end of your mycode.py script,</source>
          <target state="translated">mycode.py 스크립트 끝에서</target>
        </trans-unit>
        <trans-unit id="d2fb4096be84a03b40677e8860e321cd4dab7598" translate="yes" xml:space="preserve">
          <source>if &lt;strong&gt;name&lt;/strong&gt; == '&lt;strong&gt;main&lt;/strong&gt;':</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; == ' &lt;strong&gt;main&lt;/strong&gt; '인 경우 :</target>
        </trans-unit>
        <trans-unit id="e874b6c8f390f7d7eef2f26e6eba081818ffd576" translate="yes" xml:space="preserve">
          <source>is primarily to avoid the &lt;a href=&quot;https://docs.python.org/2/library/threading.html#importing-in-threaded-code&quot;&gt;import lock&lt;/a&gt; problems that would arise from &lt;a href=&quot;https://stackoverflow.com/questions/46326059/&quot;&gt;having code directly imported&lt;/a&gt;. You want &lt;code&gt;main()&lt;/code&gt; to run if your file was directly invoked (that's the &lt;code&gt;__name__ == &quot;__main__&quot;&lt;/code&gt; case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/46326059/&quot;&gt;코드를 직접 가져 와서&lt;/a&gt; 발생할 수있는 &lt;a href=&quot;https://docs.python.org/2/library/threading.html#importing-in-threaded-code&quot;&gt;가져 오기 잠금&lt;/a&gt; 문제를 피하기위한 것입니다. 파일이 직접 호출 된 경우 &lt;code&gt;main()&lt;/code&gt; 을 실행하려고하지만 (즉, &lt;code&gt;__name__ == &quot;__main__&quot;&lt;/code&gt; 경우), 코드를 가져온 경우 가져 오기 프로그램은 가져 오기 잠금 문제를 피하기 위해 실제 기본 모듈에서 코드를 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac8e610ec891561e761ac3b81b1844f41418fb4b" translate="yes" xml:space="preserve">
          <source>it executes all of the code found in the file.</source>
          <target state="translated">파일에서 찾은 모든 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0ebc8d74e14ef81dd980f3fabdbf3885802c2366" translate="yes" xml:space="preserve">
          <source>it sets a few special variables like &lt;code&gt;__name__&lt;/code&gt;, and then</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 과 같은 몇 가지 특수 변수를 설정 한 다음</target>
        </trans-unit>
        <trans-unit id="75cd93d2e463e2434b2a0c03ccd41ae796240e8e" translate="yes" xml:space="preserve">
          <source>means that the code block:</source>
          <target state="translated">코드 블록은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6d7de544326381643ee98f9ae79c1d3e6d9eceef" translate="yes" xml:space="preserve">
          <source>the interpreter will assign the hard-coded string &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; to the &lt;code&gt;__name__&lt;/code&gt; variable, i.e.</source>
          <target state="translated">인터프리터는 하드 코딩 된 문자열 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 을 &lt;code&gt;__name__&lt;/code&gt; 변수에 할당합니다. 즉</target>
        </trans-unit>
        <trans-unit id="0a6a0101819f9a81026cd9527ab3084564a94697" translate="yes" xml:space="preserve">
          <source>the otherwise anonymous global namespace is assigned the value of &lt;code&gt;'__main__'&lt;/code&gt; to its &lt;code&gt;__name__&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 익명의 글로벌 네임 스페이스에 &lt;code&gt;'__main__'&lt;/code&gt; 값이 &lt;code&gt;__name__&lt;/code&gt; 에 지정 됩니다.</target>
        </trans-unit>
        <trans-unit id="b7dc9621082d73413870731d07212c168ee0c948" translate="yes" xml:space="preserve">
          <source>when it is the primary, entry-point module that is run by a Python process,</source>
          <target state="translated">파이썬 프로세스에 의해 실행되는 기본 엔트리 포인트 모듈 인 경우</target>
        </trans-unit>
        <trans-unit id="2616062d77ab8e88551d4e00b757e66c49032c1f" translate="yes" xml:space="preserve">
          <source>will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of &lt;strong&gt;__name__&lt;/strong&gt; will not equal to &quot;&lt;strong&gt;main&lt;/strong&gt;&quot; in that particular instance.</source>
          <target state="translated">모듈을 직접 실행할 때만 실행됩니다. &lt;strong&gt;__name__&lt;/strong&gt; 의 값이 해당 특정 인스턴스의 &quot; &lt;strong&gt;main&lt;/strong&gt; &quot;과 같지 않기 때문에 다른 모듈이 호출 / 가져 오는 경우 코드 블록이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae6fd70eacf54f86ab690f1936c2bc5c6419b15c" translate="yes" xml:space="preserve">
          <source>will cause your script's uniquely defined &lt;code&gt;main&lt;/code&gt; function to run.</source>
          <target state="translated">스크립트의 고유하게 정의 된 &lt;code&gt;main&lt;/code&gt; 기능이 실행됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
