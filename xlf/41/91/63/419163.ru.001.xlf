<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/419163">
    <body>
      <group id="419163">
        <trans-unit id="be437cc206c4a893439095f2b33790a548b29bdd" translate="yes" xml:space="preserve">
          <source>(&lt;strong&gt;instead&lt;/strong&gt;) If your module is not the main program but was imported by another one, then &lt;code&gt;__name__&lt;/code&gt; will be &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, not &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;, and it'll skip the body of the &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">( &lt;strong&gt;вместо этого&lt;/strong&gt; ) Если ваш модуль не является основной программой, но был импортирован другой, тогда &lt;code&gt;__name__&lt;/code&gt; будет &lt;code&gt;&quot;foo&quot;&lt;/code&gt; , а не &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; , и пропустит тело оператора &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87357c2f1577f162cab1176800cb98e9ae9f1df0" translate="yes" xml:space="preserve">
          <source>(As an aside, &lt;a href=&quot;https://stackoverflow.com/questions/23000075/purpose-of-if-name-main&quot;&gt;this question&lt;/a&gt; contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of &lt;a href=&quot;https://stackoverflow.com/questions/419163/what-does-if-name-main-do&quot;&gt;this one&lt;/a&gt;, which I think is a mistake.)</source>
          <target state="translated">(Помимо &lt;a href=&quot;https://stackoverflow.com/questions/23000075/purpose-of-if-name-main&quot;&gt;этого&lt;/a&gt; , этот вопрос содержит ответ @kindall, который наконец помог мне понять - почему, а не как. К сожалению, он был помечен как дубликат &lt;a href=&quot;https://stackoverflow.com/questions/419163/what-does-if-name-main-do&quot;&gt;этого&lt;/a&gt; , что я считаю ошибкой.)</target>
        </trans-unit>
        <trans-unit id="99ee0547f367b7fbe108d02a06130f410fdeed36" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;This idiom can also be found in the Python documentation in an explanation of the &lt;code&gt;__main__&lt;/code&gt; module.&lt;/a&gt; That text states:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;Эту идиому также можно найти в документации по Python в объяснении модуля &lt;code&gt;__main__&lt;/code&gt; .&lt;/a&gt; Этот текст гласит:</target>
        </trans-unit>
        <trans-unit id="d07b4aba29e620e47507cb0c3f0488674297686a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'__main__'&lt;/code&gt; is the name of the scope in which top-level code executes. A module&amp;rsquo;s &lt;code&gt;__name__&lt;/code&gt; is set equal to &lt;code&gt;'__main__'&lt;/code&gt; when read from standard input, a script, or from an interactive prompt.</source>
          <target state="translated">&lt;code&gt;'__main__'&lt;/code&gt; - это имя области, в которой выполняется код верхнего уровня. &lt;code&gt;__name__&lt;/code&gt; модуля устанавливается равным &lt;code&gt;'__main__'&lt;/code&gt; при чтении из стандартного ввода, скрипта или из интерактивного приглашения.</target>
        </trans-unit>
        <trans-unit id="fafdac69f04bc2657902a7797c051653adc55033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__main__&lt;/code&gt;: Like other programming languages, Python too has an execution entry point, i.e., main. &lt;code&gt;'__main__'&lt;/code&gt;&lt;em&gt;is the name of the scope in which top-level code executes&lt;/em&gt;. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its &lt;code&gt;__name__&lt;/code&gt; is set to &lt;code&gt;__main__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__main__&lt;/code&gt; : Как и другие языки программирования, Python также имеет точку входа в выполнение, т.е. main. &lt;code&gt;'__main__'&lt;/code&gt; &lt;em&gt;- это имя области, в которой выполняется код верхнего уровня&lt;/em&gt; . По сути, у вас есть два способа использования модуля Python: запустить его непосредственно как скрипт или импортировать его. Когда модуль запускается как скрипт, его &lt;code&gt;__name__&lt;/code&gt; устанавливается на &lt;code&gt;__main__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39eb9da36f02c4419a8bdef9e03ec68236ed2afc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; can also be used in modules to define the name of a module</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; также может использоваться в модулях для определения имени модуля</target>
        </trans-unit>
        <trans-unit id="0be6ddf60538888ac5a053e568c5a35b99e293a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is a &lt;a href=&quot;https://wiki.python.org/moin/DunderAlias&quot;&gt;DunderAlias&lt;/a&gt; - can be thought of as a global variable (accessible from modules) and works in a similar way to &lt;a href=&quot;https://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; является &lt;a href=&quot;https://wiki.python.org/moin/DunderAlias&quot;&gt;DunderAlias&lt;/a&gt; - его можно рассматривать как глобальную переменную (доступную из модулей), и она работает аналогично &lt;a href=&quot;https://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f7940fd7af049d3ce98c54968886dbc4470c59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is a global variable (in Python, global actually means on the &lt;a href=&quot;https://docs.python.org/tutorial/modules.html#modules&quot;&gt;module level&lt;/a&gt;) that exists in all namespaces. It is typically the module's name (as a &lt;code&gt;str&lt;/code&gt; type).</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; - это глобальная переменная (в Python глобальная на самом деле означает на &lt;a href=&quot;https://docs.python.org/tutorial/modules.html#modules&quot;&gt;уровне модуля&lt;/a&gt; ), которая существует во всех пространствах имен. Обычно это имя модуля (типа &lt;code&gt;str&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2cf51e459a190c18f6d42769d3718fcae45ce2cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is always equal to &lt;code&gt;__main__&lt;/code&gt; whenever that file is &lt;strong&gt;run directly&lt;/strong&gt; showing that this is the main file.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; всегда равен &lt;code&gt;__main__&lt;/code&gt; всякий раз, когда этот файл &lt;strong&gt;запускается напрямую,&lt;/strong&gt; показывая, что это основной файл.</target>
        </trans-unit>
        <trans-unit id="9bd80d28fa314832c308431bb2b4654a9578e9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is an implicit variable in all .py modules; when a.py is imported, the value of &lt;code&gt;__name__&lt;/code&gt; of a.py module is set to its file name &quot;a&quot;; when a.py is run directly using &quot;python a.py&quot;, which means a.py is the entry point, then the value of &lt;code&gt;__name__&lt;/code&gt; of a.py module is set to a string &lt;code&gt;__main__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; - неявная переменная во всех модулях .py; когда импортируется a.py, значение &lt;code&gt;__name__&lt;/code&gt; модуля a.py устанавливается равным его имени файла &amp;laquo;a&amp;raquo;; когда a.py запускается напрямую с использованием &amp;laquo;python a.py&amp;raquo;, что означает, что a.py является точкой входа, тогда значение &lt;code&gt;__name__&lt;/code&gt; модуля a.py устанавливается в строку &lt;code&gt;__main__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee91c879b2d309081471328a6d2e05241079dfda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt;: Every module in Python has a special attribute called &lt;code&gt;__name__&lt;/code&gt;.
It is a built-in variable that returns the name of the module.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; : у каждого модуля в Python есть специальный атрибут, называемый &lt;code&gt;__name__&lt;/code&gt; . Это встроенная переменная, которая возвращает имя модуля.</target>
        </trans-unit>
        <trans-unit id="78840eb1470db249624c988b713afc3e97a69c78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; is basically the top-level script environment, and it specifies the interpreter that ('I have the highest priority to be executed first').</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; в основном это среда сценариев верхнего уровня, и она указывает интерпретатору, что (&amp;laquo;у меня самый высокий приоритет, который будет выполняться первым&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="2340c4517f7704fbff95ab3e637235230b8ccc11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; is the part that runs when the script is run from (say) the command line using a command like &lt;code&gt;python myscript.py&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; - это часть, которая запускается, когда скрипт запускается из (скажем) командной строки с помощью такой команды, как &lt;code&gt;python myscript.py&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="018c83f2b5e1ed2102eb4e0da64ee296a8027e39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import a&lt;/code&gt; action actually runs all that can be ran in &quot;a&quot;</source>
          <target state="translated">&lt;code&gt;import a&lt;/code&gt; действия фактически запускает все, что может быть запущено в &amp;laquo;а&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="df08731afb7c7ed2393aaa3f368ad0bb925ea7df" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Before explaining anything about &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; it is important to understand what &lt;code&gt;__name__&lt;/code&gt; is and what it does.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Прежде чем что-либо объяснять, &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; важно понять, что такое &lt;code&gt;__name__&lt;/code&gt; и что он делает.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79da7cc29ac2426a88a714fbfaad47448858fdb1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Now we know the behaviour of &lt;code&gt;__name__&lt;/code&gt; things become clearer:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Теперь мы знаем, как &lt;code&gt;__name__&lt;/code&gt; становится понятнее:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6728d8cd0ad927190e1963daa4daa6ea31c0c2f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;example:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="986b24c1aac5848a15ecb03780859084b31b46f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;somefile.py:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;somefile.py:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf1a9df34745e53acb5ed83d94dcb4372a21cee0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;test_file.py:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;test_file.py:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf539f837085192b477057fecbecb42c7bb86636" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;test_file.py&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;test_file.py&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="9b690b9867f89d5298a09814a6babe01c9bf70c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1st possibility: Import &lt;code&gt;my_test_module.py&lt;/code&gt; in another module&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1-я возможность: &lt;code&gt;my_test_module.py&lt;/code&gt; в другой модуль&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ac4feb6fd281aa9afa7bdda0ab2e439dc46fad0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2nd possibility: Invoke &lt;code&gt;my_test_module.py&lt;/code&gt; as a script&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2-я возможность: &lt;code&gt;my_test_module.py&lt;/code&gt; как скрипт&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc1f82081899627449ae26dee60c95d25b23c96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Summary&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Summary&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49a14964903307d811b50a88b1ff45287fbcbe6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Always&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Always&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0f57c51335086529afb8880f52e400970642376" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Executing only if the file is a module or package:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Выполняется, только если файл является модулем или пакетом:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58b371b66c6af23b26eadee978e7565caf07d812" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In short&lt;/strong&gt;, use this '&lt;code&gt;if __name__ == &quot;main&quot;&lt;/code&gt; ' block to prevent (certain) code from being run when the module is imported.</source>
          <target state="translated">&lt;strong&gt;Вкратце&lt;/strong&gt; , используйте этот блок &lt;code&gt;if __name__ == &quot;main&quot;&lt;/code&gt; &quot;, чтобы предотвратить запуск (определенного) кода при импорте модуля.</target>
        </trans-unit>
        <trans-unit id="25c82edc0cf6b044fa8902f9ff4abb5f517318e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interpreter:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Interpreter:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9ed28c097ebb85433364ac1f4e044499a4d8c6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Module or package:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Модуль или пакет:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1693186367529d23d67840c6cb92fd7b90836c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modules:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Modules:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bca1585410631753dd411aa2077f9de811966cd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now to answer &lt;code&gt;if __name__ == '__main__'&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Теперь ответим, &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="230a303facf1a2101a405f86dcdb8fcb53a82aea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only When Your Module Is Imported by Another&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Только когда ваш модуль импортируется другим&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98cb0f812771c34b1e9af7b910b6edb79e3ec992" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only When Your Module Is the Main Program&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Только когда ваш модуль является основной программой&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecabc97610f091b28f299c3556ae2c2c8ba7ed78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Practice:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Practice:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25c5146cc441b2968a8c82ef2238dbdcc07728f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Running one condition if the file is the main one and another if it is not:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Выполнение одного условия, если файл является основным, и другого, если это не так:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15379d1a1ff9a18caec0d1609f2db4600cd6fe75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Script:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Script:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00e3df3306b151747da81b3135f8996102b6398c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variants:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Variants:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a427fb5acc312c062284737d9919ea80c80c0203" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is &lt;code&gt;__name__&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что такое &lt;code&gt;__name__&lt;/code&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f2823989afe8101f68c8c884942631f433adaa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Your Module Is Imported By Another&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Когда ваш модуль импортируется другим&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f40fc5f6f2fe7685a294e653a18be70c2bdc7f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Your Module Is the Main Program&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Когда ваш модуль является основной программой&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8da700b6247cf29cd4fd28b742f87b159469d2d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Where:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Where:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e57f67deaea1f928eb43934d908849cb2ac5b721" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;a&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433798c30d6b2ba5b1b05b05cff30873a8571d47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;b&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;b&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02f26958ff8bbfffbe238764a41e6feacde136f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fibo.py (a module named &lt;code&gt;fibo&lt;/code&gt;)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;fibo.py (модуль с именем &lt;code&gt;fibo&lt;/code&gt; )&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf22c4f6ccae5c5a45f16a6c1118de9c5f963fef" translate="yes" xml:space="preserve">
          <source>A Better Way</source>
          <target state="translated">Лучший путь</target>
        </trans-unit>
        <trans-unit id="cf8a62e672a3b4293103f254c2a62d76c46512dd" translate="yes" xml:space="preserve">
          <source>A side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using &lt;code&gt;main()&lt;/code&gt; as the entry point, &lt;em&gt;but you don't have to&lt;/em&gt;. While &lt;code&gt;setup.py&lt;/code&gt; expects &lt;code&gt;main()&lt;/code&gt;, other tools use alternate entry points. For example, to run your file as a &lt;code&gt;gunicorn&lt;/code&gt; process, you define an &lt;code&gt;app()&lt;/code&gt; function instead of a &lt;code&gt;main()&lt;/code&gt;. Just as with &lt;code&gt;setup.py&lt;/code&gt;, &lt;code&gt;gunicorn&lt;/code&gt; imports your code so you don't want it do do anything while it's being imported (because of the import lock issue).</source>
          <target state="translated">Побочным эффектом является то, что вы автоматически входите в методологию, которая поддерживает несколько точек входа. Вы можете запустить свою программу, используя &lt;code&gt;main()&lt;/code&gt; в качестве точки входа, &lt;em&gt;но это не обязательно&lt;/em&gt; . Хотя &lt;code&gt;setup.py&lt;/code&gt; ожидает &lt;code&gt;main()&lt;/code&gt; , другие инструменты используют альтернативные точки входа. Например, чтобы запустить ваш файл как процесс &lt;code&gt;gunicorn&lt;/code&gt; , вы определяете функцию &lt;code&gt;app()&lt;/code&gt; вместо &lt;code&gt;main()&lt;/code&gt; . Как и в случае с &lt;code&gt;setup.py&lt;/code&gt; , &lt;code&gt;gunicorn&lt;/code&gt; импортирует ваш код, поэтому вы не хотите, чтобы он что-либо делал во время импорта (из-за проблемы с блокировкой импорта).</target>
        </trans-unit>
        <trans-unit id="1279ac465ae03ccecc8242e951637177d836eac0" translate="yes" xml:space="preserve">
          <source>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.</source>
          <target state="translated">После установки специальных переменных интерпретатор выполняет весь код в модуле,по одному оператору за раз.Возможно,вам захочется открыть еще одно окно сбоку с примером кода,чтобы вы могли следовать этому объяснению.</target>
        </trans-unit>
        <trans-unit id="383d69461af4204128d7a2e22e0747b27e8c41c3" translate="yes" xml:space="preserve">
          <source>Again, there will be exceptions, but common practice is that &lt;code&gt;main()&lt;/code&gt; doesn't usually get called externally. So you may be wondering one more thing: if we're not calling &lt;code&gt;main()&lt;/code&gt;, why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this:</source>
          <target state="translated">Опять же, будут исключения, но обычная практика заключается в том, что &lt;code&gt;main()&lt;/code&gt; обычно не вызывается извне. Поэтому вам может быть интересно еще одно: если мы не вызываем &lt;code&gt;main()&lt;/code&gt; , почему мы вообще вызываем скрипт? Это связано с тем, что многие люди структурируют свои скрипты с помощью автономных функций, которые создаются для запуска независимо от остальной части кода в файле. Позже их потом называют где-то в теле сценария. Что подводит меня к этому:</target>
        </trans-unit>
        <trans-unit id="a358e3aa692468b145f1d8ad7d489a6ccc1f8b13" translate="yes" xml:space="preserve">
          <source>All the answers have pretty much explained the functionality. But I will provide one example of its usage which might help clearing out the concept further.</source>
          <target state="translated">Все ответы почти полностью объяснили функциональность.Но я приведу один пример ее использования,который может помочь прояснить концепцию в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="728913bf30e6213619a10923f8ca08b92f0ccf99" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#if-statements&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; is a flow control statement that contains the block of code will execute if the value given is true. We have seen that &lt;code&gt;__name__&lt;/code&gt; can take either 
&lt;code&gt;__main__&lt;/code&gt; or the file name it has been imported from.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#if-statements&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; - это оператор управления потоком, содержащий блок кода, который будет выполнен, если задано значение true. Мы видели, что &lt;code&gt;__name__&lt;/code&gt; может принимать либо &lt;code&gt;__main__&lt;/code&gt; , либо имя файла, из которого он был импортирован.</target>
        </trans-unit>
        <trans-unit id="291a6a1c87e677da65912996bc98ea09be8c889c" translate="yes" xml:space="preserve">
          <source>An Even Better Way</source>
          <target state="translated">Еще лучший путь</target>
        </trans-unit>
        <trans-unit id="e25027686192c6d115ffa987e895d2c366f4813e" translate="yes" xml:space="preserve">
          <source>And a second file &quot;xy.py&quot;:</source>
          <target state="translated">И второй файл &quot;xy.py&quot;:</target>
        </trans-unit>
        <trans-unit id="56bea24f0fbd1f255ecadf46a21ba6a136330f7a" translate="yes" xml:space="preserve">
          <source>And the output from executing script2 is:</source>
          <target state="translated">И результат выполнения скрипта2:</target>
        </trans-unit>
        <trans-unit id="32c90a0b6a16423e14ed51492f9d35d3262ee3dc" translate="yes" xml:space="preserve">
          <source>And then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome.</source>
          <target state="translated">И тогда вы должны будете вспомнить,прокомментировали ли вы вызов вашей тестовой функции или нет.И эта дополнительная сложность будет означать,что вы,скорее всего,забудете,делая процесс разработки более сложным.</target>
        </trans-unit>
        <trans-unit id="27665df0153065e46daf1f28871bd9475bf8e1d5" translate="yes" xml:space="preserve">
          <source>Another benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:</source>
          <target state="translated">Еще одно преимущество использования этой конструкции:вы можете также импортировать свой код как модуль в другой скрипт,а затем запустить основную функцию,если и когда ваша программа примет решение:</target>
        </trans-unit>
        <trans-unit id="e24f293208b0bd554685671142f6ee40f5264006" translate="yes" xml:space="preserve">
          <source>Another one.</source>
          <target state="translated">Еще один.</target>
        </trans-unit>
        <trans-unit id="490e331532fa57020b75e3d7497ad0ed1e28417b" translate="yes" xml:space="preserve">
          <source>Any other script that's called from this &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; script is assigned its filename as its &lt;code&gt;__name__&lt;/code&gt; (e.g., &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt;). Hence, the line &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally.</source>
          <target state="translated">Любому другому сценарию, который вызывается из этого сценария &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; , присваивается имя файла в качестве его &lt;code&gt;__name__&lt;/code&gt; (например, &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt; ). Следовательно, строка &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; это тест интерпретатора, чтобы определить, интерпретирует ли он / анализирует &amp;laquo;домашний&amp;raquo; скрипт, который был первоначально выполнен, или он временно просматривает другой (внешний) скрипт. Это дает программисту гибкость, позволяющую сценарию вести себя по-разному, если он выполняется напрямую или вызывается извне.</target>
        </trans-unit>
        <trans-unit id="4f021478ef2f8fb352704d122ccd48a0f448bb10" translate="yes" xml:space="preserve">
          <source>As an example, consider the following module &lt;code&gt;my_test_module.py&lt;/code&gt;:</source>
          <target state="translated">В качестве примера рассмотрим следующий модуль &lt;code&gt;my_test_module.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c8214b3e3fc0c1096a5057a6fbcda3ca94b4ab14" translate="yes" xml:space="preserve">
          <source>As by default (when module running as main, not imported) the &lt;code&gt;__name__&lt;/code&gt; variable is set to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;, and when it'll be imported the &lt;code&gt;__name__&lt;/code&gt; variable will get a different value, most probably the name of the module (&lt;code&gt;'M'&lt;/code&gt;).
This is helpful in running different variants of a modules together, and separating their specific input &amp;amp; output statements and also if there are any test-cases.</source>
          <target state="translated">Как и по умолчанию (когда модуль работает как основной, а не импортированный), переменная &lt;code&gt;__name__&lt;/code&gt; установлена ​​на &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; , а когда она будет импортирована, переменная &lt;code&gt;__name__&lt;/code&gt; получит другое значение, скорее всего, имя модуля ( &lt;code&gt;'M'&lt;/code&gt; ). Это полезно для одновременного запуска различных вариантов модулей и разделения их конкретных операторов ввода и вывода, а также при наличии тестов.</target>
        </trans-unit>
        <trans-unit id="0fb36a6c33279c346eb468f0e09c25e124f94cda" translate="yes" xml:space="preserve">
          <source>As the only special case, however, in whatever Python process you run, as in mycode.py:</source>
          <target state="translated">Единственный особый случай,однако,в любом процессе на Python,который вы запускаете,как в mycode.py:</target>
        </trans-unit>
        <trans-unit id="77a8033bf10bed893a83d034163981dde9b5ee97" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;__name__&lt;/code&gt; tells us which code is the 'main' module.
This is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a 'main' function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.</source>
          <target state="translated">Как видите, &lt;code&gt;__name__&lt;/code&gt; сообщает нам, какой код является &amp;laquo;основным&amp;raquo; модулем. Это здорово, потому что вы можете просто написать код и не беспокоиться о структурных проблемах, как в C / C ++, где, если файл не реализует функцию main, он не может быть скомпилирован как исполняемый файл, и если он это делает, затем его нельзя использовать в качестве библиотеки.</target>
        </trans-unit>
        <trans-unit id="c45bdc9c773c22c178338f1dc79c2aa63246ed33" translate="yes" xml:space="preserve">
          <source>As you can see, when a file is executed, Python sets &lt;code&gt;globals()['__name__']&lt;/code&gt; in this file to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;. This time, the &lt;code&gt;if&lt;/code&gt; statement evaluates to &lt;code&gt;True&lt;/code&gt; and is being run.</source>
          <target state="translated">Как вы можете видеть, когда файл выполняется, Python устанавливает &lt;code&gt;globals()['__name__']&lt;/code&gt; в этом файле на &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; . На этот раз оператор &lt;code&gt;if&lt;/code&gt; оценивается как &lt;code&gt;True&lt;/code&gt; и выполняется.</target>
        </trans-unit>
        <trans-unit id="fa35fc2b3ffb5707c6ed36201d14709b2795177a" translate="yes" xml:space="preserve">
          <source>As you can see, when a module is imported, Python sets &lt;code&gt;globals()['__name__']&lt;/code&gt; in this module to the module's name. Also, upon import all the code in the module is being run. As the &lt;code&gt;if&lt;/code&gt; statement evaluates to &lt;code&gt;False&lt;/code&gt; this part is not executed.</source>
          <target state="translated">Как вы можете видеть, когда модуль импортируется, Python устанавливает &lt;code&gt;globals()['__name__']&lt;/code&gt; в этом модуле на имя модуля. Также при импорте запускается весь код в модуле. Поскольку оператор &lt;code&gt;if&lt;/code&gt; оценивается как &lt;code&gt;False&lt;/code&gt; , эта часть не выполняется.</target>
        </trans-unit>
        <trans-unit id="4174aeb05b05eec8583dcae607865c6ef32ba122" translate="yes" xml:space="preserve">
          <source>Assume that you have two Python files, a.py and b.py. Now, a.py imports b.py. We run the a.py file, where the &quot;import b.py&quot; code is executed first. Before the rest of the a.py code runs, the code in the file b.py must run completely.</source>
          <target state="translated">Предположим,что у вас есть два файла с Python,a.py и b.py.Теперь,a.py импортирует b.py.Запускаем файл a.py,где сначала выполняется код &quot;import b.py&quot;.Перед тем,как запустить остальной код a.py,код в файле b.py должен быть запущен полностью.</target>
        </trans-unit>
        <trans-unit id="53de5b46d0fbb20fff33ad741960e992c53e5836" translate="yes" xml:space="preserve">
          <source>Based on the mechanism how python sets the variable &lt;code&gt;__name__&lt;/code&gt; for each module, do you know how to achieve point 3? The answer is fairly easy, right? Put a if condition: &lt;code&gt;if __name__ == &quot;__main__&quot;: ...&lt;/code&gt;; you can even put if &lt;code&gt;__name__ == &quot;a&quot;&lt;/code&gt; depending on your functional need</source>
          <target state="translated">Основываясь на механизме, как python устанавливает переменную &lt;code&gt;__name__&lt;/code&gt; для каждого модуля, знаете ли вы, как достичь пункта 3? Ответ довольно прост, верно? Поставить условие if: &lt;code&gt;if __name__ == &quot;__main__&quot;: ...&lt;/code&gt; ; Вы даже можете поставить, если &lt;code&gt;__name__ == &quot;a&quot;&lt;/code&gt; зависимости от ваших функциональных потребностей</target>
        </trans-unit>
        <trans-unit id="b5daba4bc12144be47ac4ef97123506a5d670ee9" translate="yes" xml:space="preserve">
          <source>Because of point 1, you may not want everything to be run in &quot;a&quot; when importing it</source>
          <target state="translated">Из-за пункта 1,вы можете не хотеть,чтобы все было запущено в &quot;а&quot; при импорте.</target>
        </trans-unit>
        <trans-unit id="5555032fd1fd8c47f02216cf05cff7797235c4eb" translate="yes" xml:space="preserve">
          <source>Before the interpreter executes the source code file though, it defines a few special variables for that file; &lt;strong&gt;__name__&lt;/strong&gt; is one of those special variables that Python automatically defines for each source code file.</source>
          <target state="translated">Прежде чем интерпретатор выполнит файл исходного кода, он определит несколько специальных переменных для этого файла; &lt;strong&gt;__name__&lt;/strong&gt; - это одна из тех специальных переменных, которые Python автоматически определяет для каждого файла исходного кода.</target>
        </trans-unit>
        <trans-unit id="be4403cc17466eedfa891d4a51f7740fa3d7f3f3" translate="yes" xml:space="preserve">
          <source>Being a variable means that it's value &lt;em&gt;can&lt;/em&gt; be overwritten (&quot;can&quot; does not mean &quot;should&quot;), overwriting the value of &lt;code&gt;__name__&lt;/code&gt; will result in a lack of readability.  So do not do it, for any reason.  If you need a variable define a new variable.</source>
          <target state="translated">Наличие переменной означает, что ее значение &lt;em&gt;может&lt;/em&gt; быть перезаписано (&amp;laquo;может&amp;raquo; не означает &amp;laquo;следует&amp;raquo;), перезапись значения &lt;code&gt;__name__&lt;/code&gt; приведет к недостаточной читабельности. Так что не делай этого ни по какой причине. Если вам нужна переменная, определите новую переменную.</target>
        </trans-unit>
        <trans-unit id="cdba82558e6d2b296c8fda06454da814e1ab4ab2" translate="yes" xml:space="preserve">
          <source>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. &quot;Running&quot; the script is a side effect of importing the script's module.</source>
          <target state="translated">Помимо этих примеров,элегантно то,что запуск скрипта на Python-это просто настройка нескольких волшебных переменных и импорт скрипта.&quot;Запуск&quot; скрипта является побочным эффектом импорта модуля скрипта.</target>
        </trans-unit>
        <trans-unit id="7fdb9a68214237799e539012c1ae04b1ee6fcbff" translate="yes" xml:space="preserve">
          <source>Blocks A and B are run when we are running &quot;x.py&quot;.</source>
          <target state="translated">Блоки A и B запускаются,когда мы запускаем &quot;x.py&quot;.</target>
        </trans-unit>
        <trans-unit id="51aacee3ee9f4b0785c1a298e8721c7f3d008776" translate="yes" xml:space="preserve">
          <source>But inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.</source>
          <target state="translated">Но внутри основного модуля (или интерактивного сеанса Python, то есть Read, Eval, Print Loop или REPL интерпретатора) вы запускаете все из его &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d45165ec85f4c41aac136977806fa7b3e1b0399" translate="yes" xml:space="preserve">
          <source>But just block A (and not B) is run when we are running another module, &quot;y.py&quot; for example, in which x.y is imported and the code is run from there (like when a function in &quot;x.py&quot; is called from y.py).</source>
          <target state="translated">Но просто блок A (а не B)запускается при запуске другого модуля,например,&quot;y.py&quot;,в который импортируется x.y и оттуда запускается код (как,например,при вызове функции в &quot;x.py&quot; из y.py).</target>
        </trans-unit>
        <trans-unit id="187017f79b4f4176019be635feccedac47d394a8" translate="yes" xml:space="preserve">
          <source>But that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.</source>
          <target state="translated">Но это скрипт,который,вероятно,не может иметь своих функций,называемых внешними,потому что если бы он сделал это,то сразу же начал бы вычислять и присваивать переменные.И есть шанс,что если вы пытаетесь повторно использовать функцию,то ваш новый сценарий достаточно тесно связан со старым,в котором будут конфликтующие переменные.</target>
        </trans-unit>
        <trans-unit id="e0cc7be78b4f7426e808a9f14bb2ee02b52a60bf" translate="yes" xml:space="preserve">
          <source>But the code works without it</source>
          <target state="translated">Но код работает без него.</target>
        </trans-unit>
        <trans-unit id="b868b03c6a857fb43254a438d5d2b52f62b19ea2" translate="yes" xml:space="preserve">
          <source>Call the class from other files. You just have to import it in the calling program.</source>
          <target state="translated">Вызовите класс из других файлов.Нужно лишь импортировать его в вызывающую программу.</target>
        </trans-unit>
        <trans-unit id="d1249e34e446972c34012a866f67bc184db7bc52" translate="yes" xml:space="preserve">
          <source>Code Sample</source>
          <target state="translated">Образец кода</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="9274899889be8b8adc4e3be4ea8d4a133c134b2d" translate="yes" xml:space="preserve">
          <source>Create a file, &lt;strong&gt;a.py&lt;/strong&gt;:</source>
          <target state="translated">Создайте файл, &lt;strong&gt;a.py&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="56a0a9523b0c4b5eb5e2bbdb33ad60b126caa07f" translate="yes" xml:space="preserve">
          <source>Create another file, &lt;strong&gt;b.py&lt;/strong&gt;, in the same directory:</source>
          <target state="translated">Создайте другой файл, &lt;strong&gt;b.py&lt;/strong&gt; , в том же каталоге:</target>
        </trans-unit>
        <trans-unit id="cd3b4d3abc33414ae3e100a1d6cbfe6b75ea5eb4" translate="yes" xml:space="preserve">
          <source>Create the following files.</source>
          <target state="translated">Создайте следующие файлы.</target>
        </trans-unit>
        <trans-unit id="28d96b6441a5da8450600f4898f133fbdd6961e4" translate="yes" xml:space="preserve">
          <source>Developing and Testing Your Code</source>
          <target state="translated">Разработка и тестирование вашего кода</target>
        </trans-unit>
        <trans-unit id="6bc05812a294f6f7a5f9e19db22d8cd3b2afc410" translate="yes" xml:space="preserve">
          <source>End of file; back to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;!</source>
          <target state="translated">Конец файла; вернуться к &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="ccf898dbe57906e5594bcd719f8b93726090fd0d" translate="yes" xml:space="preserve">
          <source>Every module in python has a attribute called &lt;code&gt;__name__&lt;/code&gt;. The value of &lt;code&gt;__name__&lt;/code&gt;  attribute is  &lt;code&gt;__main__&lt;/code&gt;  when the module is run directly, like &lt;code&gt;python my_module.py&lt;/code&gt;. Otherwise (like when you say &lt;code&gt;import my_module&lt;/code&gt;) the value of &lt;code&gt;__name__&lt;/code&gt;  is the name of the module.</source>
          <target state="translated">Каждый модуль в Python имеет атрибут с именем &lt;code&gt;__name__&lt;/code&gt; . Атрибут &lt;code&gt;__name__&lt;/code&gt; имеет значение &lt;code&gt;__main__&lt;/code&gt; , когда модуль запускается напрямую, например, &lt;code&gt;python my_module.py&lt;/code&gt; . В противном случае (например, когда вы говорите &lt;code&gt;import my_module&lt;/code&gt; ) значение &lt;code&gt;__name__&lt;/code&gt; является именем модуля.</target>
        </trans-unit>
        <trans-unit id="8ea353689f62515305875bd4c1491c1b1eda4969" translate="yes" xml:space="preserve">
          <source>Executing the Module's Code</source>
          <target state="translated">Выполнение кода модуля</target>
        </trans-unit>
        <trans-unit id="decbc65feed3492d925a3828afa0685ee965a44f" translate="yes" xml:space="preserve">
          <source>Food for Thought</source>
          <target state="translated">Пища для Мысли</target>
        </trans-unit>
        <trans-unit id="c01b0b737be74a6ef3efec2d9c67ec6b0e73c2dd" translate="yes" xml:space="preserve">
          <source>For the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label &lt;code&gt;'__main__'&lt;/code&gt;.</source>
          <target state="translated">В последнем случае класс должен содержать открытый статический метод void main (). В Python этой цели служит глобально определенный ярлык &lt;code&gt;'__main__'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06c6abe53de8158ff545ff3025465ac568502266" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;x()&lt;/code&gt;; ok, printing '&lt;em&gt;peripheral task: might be useful in other projects&lt;/em&gt;'.</source>
          <target state="translated">Функция &lt;code&gt;x()&lt;/code&gt; ; хорошо, печатать &amp;laquo; &lt;em&gt;периферийное задание: может быть полезно в других проектах&lt;/em&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="270272d52b278ed4834707720d02142b04dac683" translate="yes" xml:space="preserve">
          <source>Given the following code, what does the &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; do?</source>
          <target state="translated">Учитывая следующий код, что делает &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c532f4344993da004ef0d886409dd1dc176dd817" translate="yes" xml:space="preserve">
          <source>Hope this helps out.</source>
          <target state="translated">Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="7cf7df778e073d4ee9549c9276978c839886daaf" translate="yes" xml:space="preserve">
          <source>However, if you want to import the module to another script:</source>
          <target state="translated">Однако,если вы хотите импортировать модуль в другой скрипт:</target>
        </trans-unit>
        <trans-unit id="3f7f6f7cdf15bc15aa54e3347e678918567e405d" translate="yes" xml:space="preserve">
          <source>However, if your Python script is used by a module, any code outside of the &lt;code&gt;if&lt;/code&gt; statement will be executed, so &lt;code&gt;if \__name__ == &quot;\__main__&quot;&lt;/code&gt; is used just to check if the program is used as a module or not, and therefore decides whether to run the code.</source>
          <target state="translated">Однако, если ваш скрипт Python используется модулем, будет выполнен любой код вне оператора &lt;code&gt;if&lt;/code&gt; , поэтому, &lt;code&gt;if \__name__ == &quot;\__main__&quot;&lt;/code&gt; используется только для проверки, используется ли программа в качестве модуля или нет, и поэтому решает, стоит ли запускать код.</target>
        </trans-unit>
        <trans-unit id="27aee883b9125fa742bdc6ce62419f671fc09b30" translate="yes" xml:space="preserve">
          <source>I am not saying you should use this in production code, but it serves to illustrate that there is nothing &quot;magical&quot; about &lt;code&gt;if __name__ == '__main__'&lt;/code&gt;. It is a good convention for invoking a main function in Python files.</source>
          <target state="translated">Я не говорю, что вы должны использовать это в рабочем коде, но это служит иллюстрацией того, что нет ничего &amp;laquo;волшебного&amp;raquo; в том, что &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; . Это хорошее соглашение для вызова основной функции в файлах Python.</target>
        </trans-unit>
        <trans-unit id="7aaee90df97cdf574f54c44ac544ddfd2ecf3202" translate="yes" xml:space="preserve">
          <source>I think it's best to break the answer in depth and in simple words:</source>
          <target state="translated">Я думаю,что лучше всего разбить ответ глубоко и простыми словами:</target>
        </trans-unit>
        <trans-unit id="2d610a68610206f4422d124c53fd2b4ef28bb011" translate="yes" xml:space="preserve">
          <source>I've been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused.</source>
          <target state="translated">Я так много читал ответов на этой странице.Я бы сказал,что если вы знаете эту вещь,вы наверняка поймете эти ответы,в противном случае,вы все еще в замешательстве.</target>
        </trans-unit>
        <trans-unit id="7dc8666b8e0d5305ca6686fcdd3a64aa30613f45" translate="yes" xml:space="preserve">
          <source>If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special &lt;strong&gt;__name__&lt;/strong&gt; variable for this file to have a value &lt;strong&gt;&quot;__main__&quot;&lt;/strong&gt;.</source>
          <target state="translated">Если Python загружает этот файл исходного кода в качестве основной программы (то есть файла, который вы запускаете), то он устанавливает специальную переменную &lt;strong&gt;__name__&lt;/strong&gt; для этого файла, чтобы иметь значение &lt;strong&gt;&amp;laquo;__main__&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a009492026900b4a9397225067c6a9f84f8e1216" translate="yes" xml:space="preserve">
          <source>If indeed &lt;code&gt;__name__&lt;/code&gt; does take the value of &lt;code&gt;__main__&lt;/code&gt; then whatever is in that block of code will execute.</source>
          <target state="translated">Если действительно &lt;code&gt;__name__&lt;/code&gt; принимает значение &lt;code&gt;__main__&lt;/code&gt; , то все, что находится в этом блоке кода, будет выполнено.</target>
        </trans-unit>
        <trans-unit id="0a6d69f64768205bc73fd5ba1367e74b8059c5c0" translate="yes" xml:space="preserve">
          <source>If the python interpreter is running&amp;nbsp;a particular module then &lt;code&gt;__name__&lt;/code&gt; global  variable will have value &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;</source>
          <target state="translated">Если интерпретатор Python работает с определенным модулем, глобальная переменная &lt;code&gt;__name__&lt;/code&gt; будет иметь значение &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1094aa47aa3aeccd6ed85b8ebb5ed271222d0e3" translate="yes" xml:space="preserve">
          <source>If this .py are run by &lt;code&gt;python this_py.py&lt;/code&gt; under shell, or double clicked in Windows. the code under &quot;the if statement&quot; will be executed.</source>
          <target state="translated">Если этот .py запускается &lt;code&gt;python this_py.py&lt;/code&gt; из- под оболочки или дважды щелкает в Windows. код под &amp;laquo;оператором if&amp;raquo; будет выполнен.</target>
        </trans-unit>
        <trans-unit id="f0f1e75c2a123bfd0fe539932a26c8d0e246a7f1" translate="yes" xml:space="preserve">
          <source>If this .py file are imported by other .py files, the code under &quot;the if statement&quot; will not be executed.</source>
          <target state="translated">Если этот .py-файл импортируется другими .py-файлами,код под &quot;оператором if&quot; не будет выполнен.</target>
        </trans-unit>
        <trans-unit id="cfc7c4aaf15b28c6320a80c22273eb5bfeb2a46e" translate="yes" xml:space="preserve">
          <source>If this is being imported from another module, &lt;strong&gt;__name__&lt;/strong&gt; will be set to that module's name.</source>
          <target state="translated">Если это импортируется из другого модуля, &lt;strong&gt;__name__&lt;/strong&gt; будет установлен на имя этого модуля.</target>
        </trans-unit>
        <trans-unit id="6523f8ca1b9a6c1da707b351f493c4cbbace2647" translate="yes" xml:space="preserve">
          <source>If we put the code we want to exercise as we develop and test in a function like this and then do our check for &lt;code&gt;'__main__'&lt;/code&gt; immediately after:</source>
          <target state="translated">Если мы поместим код, который хотим использовать, при разработке и тестировании в подобной функции, а затем сделаем проверку на &lt;code&gt;'__main__'&lt;/code&gt; сразу после:</target>
        </trans-unit>
        <trans-unit id="bc80bf0204f13ba7089b5451f461bfc665cec29b" translate="yes" xml:space="preserve">
          <source>If we run the code directly via &lt;code&gt;python test.py&lt;/code&gt;, the module name is &lt;code&gt;__main__&lt;/code&gt;:</source>
          <target state="translated">Если мы запустим код напрямую через &lt;code&gt;python test.py&lt;/code&gt; , имя модуля будет &lt;code&gt;__main__&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6516beb3b9f8bebd5a8fe5d91c615ccfb9500a4" translate="yes" xml:space="preserve">
          <source>If you are running your module (the source file) as the main program, e.g.</source>
          <target state="translated">Если вы запускаете модуль (исходный файл)в качестве основной программы,например</target>
        </trans-unit>
        <trans-unit id="5a002ca7d32e704fd426536fc54e7e1e47ad2e8b" translate="yes" xml:space="preserve">
          <source>If you import this file say A to file B  and execute the file B then &lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; in file A becomes false, so it prints  &lt;strong&gt;You can't see me&lt;/strong&gt;</source>
          <target state="translated">Если вы импортируете этот файл, скажите A в файл B и выполните файл B, тогда, &lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; в файле A становится ложным, значит, он печатает. &lt;strong&gt;Вы меня не видите&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bae9f62ff08151418abbbc49ef9673f76cd6210a" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;two.py&lt;/code&gt; instead:</source>
          <target state="translated">Если вместо этого вы запустите &lt;code&gt;two.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3d5150bf1d7adcfd96cab36821f53eb6a118618d" translate="yes" xml:space="preserve">
          <source>If your module is the main program, then it will see that &lt;code&gt;__name__&lt;/code&gt; was indeed set to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; and it calls the two functions, printing the strings &lt;code&gt;&quot;Function A&quot;&lt;/code&gt; and &lt;code&gt;&quot;Function B 10.0&quot;&lt;/code&gt;.</source>
          <target state="translated">Если ваш модуль является основной программой, то он увидит, что &lt;code&gt;__name__&lt;/code&gt; действительно был установлен на &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; и он вызывает две функции, печатая строки &lt;code&gt;&quot;Function A&quot;&lt;/code&gt; и &lt;code&gt;&quot;Function B 10.0&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dec279dce56fe81437675634947d0898c2cd9a40" translate="yes" xml:space="preserve">
          <source>If your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the &lt;code&gt;if&lt;/code&gt; clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:</source>
          <target state="translated">Если ваш скрипт импортируется в другой модуль, его различные определения функций и классов будут импортированы, и будет выполнен его код верхнего уровня, но код в теле then условия &lt;code&gt;if&lt;/code&gt; выше не будет выполняться как условие не встретил В качестве основного примера рассмотрим следующие два сценария:</target>
        </trans-unit>
        <trans-unit id="47cbbcfd6a2d88e3b7665ea5155dcef87bbe0234" translate="yes" xml:space="preserve">
          <source>Import and open file with the &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt;.</source>
          <target state="translated">Импортируйте и откройте файл с помощью &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4339fb8da56f030c085b801561fcd6353668defe" translate="yes" xml:space="preserve">
          <source>In other words, the code within the &lt;code&gt;if&lt;/code&gt; block will be executed only when the code runs directly. Here &lt;code&gt;directly&lt;/code&gt; means &lt;code&gt;not imported&lt;/code&gt;.</source>
          <target state="translated">Другими словами, код внутри блока &lt;code&gt;if&lt;/code&gt; будет выполняться только тогда, когда код выполняется напрямую. Здесь &lt;code&gt;directly&lt;/code&gt; означает &lt;code&gt;not imported&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef3470680942e6fd3926f3ffbec1e8810ecf8fb" translate="yes" xml:space="preserve">
          <source>In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, &quot;example.py&quot; might import &quot;xy.py&quot; and call &lt;code&gt;x()&lt;/code&gt;, making use of the 'x' function from &quot;xy.py&quot;. (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)</source>
          <target state="translated">Разбивая независимые функции, вы получаете возможность повторно использовать вашу предыдущую работу, вызывая их в другой скрипт. Например, &amp;laquo;example.py&amp;raquo; может импортировать &amp;laquo;xy.py&amp;raquo; и вызывать &lt;code&gt;x()&lt;/code&gt; , используя функцию &amp;laquo;x&amp;raquo; из &amp;laquo;xy.py&amp;raquo;. (Возможно, это заглавная буква третьего слова данной текстовой строки; создание массива NumPy из списка чисел и возведение их в квадрат; или растяжение трехмерной поверхности. Возможности безграничны.)</target>
        </trans-unit>
        <trans-unit id="d853790bb43ec92bf806d95fb5eb4681a4a8a3c8" translate="yes" xml:space="preserve">
          <source>In summary, here's what'd be printed in the two cases:</source>
          <target state="translated">Подводя итог,вот что будет напечатано в этих двух случаях:</target>
        </trans-unit>
        <trans-unit id="1f0a6937d20af80d3078dedc2606cc5a59b0e220" translate="yes" xml:space="preserve">
          <source>In the b.py code there is some code that is exclusive to that file b.py and we don't want any other file (other than b.py file), that has imported the b.py file, to run it.</source>
          <target state="translated">В коде b.py есть некоторый код,который является эксклюзивным для этого файла b.py,и нам не нужен никакой другой файл (кроме файла b.py),который импортировал файл b.py,чтобы запустить его.</target>
        </trans-unit>
        <trans-unit id="260ca32c942591fccd6abb92b2ac85ea296638c3" translate="yes" xml:space="preserve">
          <source>In this case, the top-level code is an &lt;code&gt;if&lt;/code&gt; block.  &lt;code&gt;__name__&lt;/code&gt; is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in &lt;code&gt;myscript.py&lt;/code&gt; above), then &lt;code&gt;__name__&lt;/code&gt; instead is set to the string &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.  Thus, you can test whether your script is being run directly or being imported by something else by testing</source>
          <target state="translated">В этом случае код верхнего уровня является блоком &lt;code&gt;if&lt;/code&gt; . &lt;code&gt;__name__&lt;/code&gt; - это встроенная переменная, которая оценивает имя текущего модуля. Однако, если модуль запускается напрямую (как в &lt;code&gt;myscript.py&lt;/code&gt; выше), тогда вместо &lt;code&gt;__name__&lt;/code&gt; устанавливается строка &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; . Таким образом, вы можете проверить, выполняется ли ваш скрипт напрямую или импортируется чем-то другим, проверяя</target>
        </trans-unit>
        <trans-unit id="fc7351db8caa3bc174e3dab9c38941592f350c9e" translate="yes" xml:space="preserve">
          <source>Inside an imported module, it's the name of that module.</source>
          <target state="translated">Внутри импортируемого модуля-его название.</target>
        </trans-unit>
        <trans-unit id="600ec79b4436fd522224aeb5e817487e39bf7c75" translate="yes" xml:space="preserve">
          <source>It allows the code in the module to be importable by other modules, without executing the code block beneath on import.</source>
          <target state="translated">Это позволяет импортировать код в модуль другими модулями,не выполняя блок кода под импортом.</target>
        </trans-unit>
        <trans-unit id="675efdeb054d458c04693317ce35a181157e918e" translate="yes" xml:space="preserve">
          <source>It also allows modules to be run from the command line as main scripts, which can be also very useful.</source>
          <target state="translated">Она также позволяет запускать модули из командной строки в качестве основных скриптов,что также может быть очень полезно.</target>
        </trans-unit>
        <trans-unit id="54b2453f92e0d3e4d73f97207fe07c2dc556e48a" translate="yes" xml:space="preserve">
          <source>It can not only be used in scripts but can also be found in both the interpreter and modules/packages.</source>
          <target state="translated">Его можно не только использовать в скриптах,но и найти как в интерпретаторе,так и в модульных пакетах.</target>
        </trans-unit>
        <trans-unit id="3528aa55d868a317f591f6ee9b7618c515d6e0af" translate="yes" xml:space="preserve">
          <source>It checks if a module is being imported or not.</source>
          <target state="translated">Проверяет,импортируется ли модуль или нет.</target>
        </trans-unit>
        <trans-unit id="4714816743d3504312c6ed1b30410b9d76cd8f74" translate="yes" xml:space="preserve">
          <source>It checks if the &lt;code&gt;__name__&lt;/code&gt; attribute of the Python script is &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;. In other words, if the program itself is executed, the attribute will be &lt;code&gt;__main__&lt;/code&gt;, so the program will be executed (in this case the &lt;code&gt;main()&lt;/code&gt; function).</source>
          <target state="translated">Он проверяет, является ли атрибут &lt;code&gt;__name__&lt;/code&gt; скрипта Python &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; . Другими словами, если сама программа выполняется, атрибут будет &lt;code&gt;__main__&lt;/code&gt; , поэтому программа будет выполнена (в этом случае функция &lt;code&gt;main()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d45839ba20c9bcb826d469c0e65576dc489d5de3" translate="yes" xml:space="preserve">
          <source>It could be written in several ways. Another is:</source>
          <target state="translated">Это может быть написано несколькими способами.Другой -</target>
        </trans-unit>
        <trans-unit id="72796cbd4b51d3cdeb2d0d02bdcb18094d7dd7ca" translate="yes" xml:space="preserve">
          <source>It executes the &lt;code&gt;def&lt;/code&gt; block, creating a function object, then assigning that function object to a variable called &lt;code&gt;functionA&lt;/code&gt;.</source>
          <target state="translated">Он выполняет блок &lt;code&gt;def&lt;/code&gt; , создавая функциональный объект, затем назначая этот функциональный объект переменной с именем &lt;code&gt;functionA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a1336d55772c318b9c2339583e8b328d7e55ca8" translate="yes" xml:space="preserve">
          <source>It executes the second &lt;code&gt;def&lt;/code&gt; block, creating another function object, then assigning it to a variable called &lt;code&gt;functionB&lt;/code&gt;.</source>
          <target state="translated">Он выполняет второй блок &lt;code&gt;def&lt;/code&gt; , создавая другой функциональный объект, а затем присваивая его переменной с именем &lt;code&gt;functionB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d422f7632b03e10b878e1d03615ebf1e878466d9" translate="yes" xml:space="preserve">
          <source>It is a special for when a Python file is called from the command line. This is typically used to call a &quot;main()&quot; function or execute other appropriate startup code, like commandline arguments handling for instance.</source>
          <target state="translated">Это специальный случай,когда файл Python вызывается из командной строки.Обычно это используется для вызова функции &quot;main()&quot; или выполнения другого соответствующего кода запуска,например,обработки аргументов командной строки.</target>
        </trans-unit>
        <trans-unit id="7c5e6e85034260b34583d4b3d062afde5577df61" translate="yes" xml:space="preserve">
          <source>It is a string (global as mentioned above) as indicated by &lt;code&gt;type(__name__)&lt;/code&gt; (yielding &lt;code&gt;&amp;lt;class 'str'&amp;gt;&lt;/code&gt;), and is an inbuilt standard for both &lt;a href=&quot;https://docs.python.org/3/library/__main__.html&quot;&gt;Python 3&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;Python 2&lt;/a&gt; versions.</source>
          <target state="translated">Это строка (глобальная, как упомянуто выше), обозначенная &lt;code&gt;type(__name__)&lt;/code&gt; (с выходом &lt;code&gt;&amp;lt;class 'str'&amp;gt;&lt;/code&gt; ), и является встроенным стандартом для версий &lt;a href=&quot;https://docs.python.org/3/library/__main__.html&quot;&gt;Python 3&lt;/a&gt; и &lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;Python 2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b32f06639244cd4fe1f298cf6a239029bf115ac" translate="yes" xml:space="preserve">
          <source>It is also possible to do other, less common but useful things with &lt;code&gt;__name__&lt;/code&gt;, some I will show here:</source>
          <target state="translated">С &lt;code&gt;__name__&lt;/code&gt; можно также делать другие, менее распространенные, но полезные вещи, некоторые из которых я покажу здесь:</target>
        </trans-unit>
        <trans-unit id="fa5911f298adfd582f1742f2457c41f8e0363fdb" translate="yes" xml:space="preserve">
          <source>It is always assumed that the value of &lt;code&gt;__name__&lt;/code&gt; to be &lt;code&gt;__main__&lt;/code&gt; or the name of the file.  Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.</source>
          <target state="translated">Всегда предполагается, что значением &lt;code&gt;__name__&lt;/code&gt; будет &lt;code&gt;__main__&lt;/code&gt; или имя файла. Повторное изменение этого значения по умолчанию вызовет еще большую путаницу в том, что оно пойдет на пользу, и вызовет проблемы в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="433366427f82e9a941e28039c28d109ea0304b44" translate="yes" xml:space="preserve">
          <source>It is considered good practice in general to include the &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; in scripts.</source>
          <target state="translated">В целом считается хорошей практикой включать в сценарии &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae6fdd181016a398f76b7382908ae7290de561a7" translate="yes" xml:space="preserve">
          <source>It is usually written for testing.</source>
          <target state="translated">Обычно она пишется для тестирования.</target>
        </trans-unit>
        <trans-unit id="c3402e91991c1a14ff2a75a0ab38e464eb5133ba" translate="yes" xml:space="preserve">
          <source>It loads the &lt;code&gt;math&lt;/code&gt; module and assigns it to a variable called &lt;code&gt;math&lt;/code&gt;. This is equivalent to replacing &lt;code&gt;import math&lt;/code&gt; with the following (note that &lt;code&gt;__import__&lt;/code&gt; is a low-level function in Python that takes a string and triggers the actual import):</source>
          <target state="translated">Он загружает &lt;code&gt;math&lt;/code&gt; модуль и присваивает его переменной с именем &lt;code&gt;math&lt;/code&gt; . Это эквивалентно замене &lt;code&gt;import math&lt;/code&gt; на следующее (обратите внимание, что &lt;code&gt;__import__&lt;/code&gt; - это низкоуровневая функция в Python, которая принимает строку и запускает фактический импорт):</target>
        </trans-unit>
        <trans-unit id="56f71295dc0080691356ca0c01cec7d37f4e28e9" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before __name__ guard&quot;&lt;/code&gt;.</source>
          <target state="translated">Он печатает строку &lt;code&gt;&quot;before __name__ guard&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2577e5a4b9e5bed19b4432e05d2660faee329607" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before functionA&quot;&lt;/code&gt;.</source>
          <target state="translated">Он печатает строку &lt;code&gt;&quot;before functionA&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990ff0164122db4967979e56b95623fac83be16d" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before functionB&quot;&lt;/code&gt;.</source>
          <target state="translated">Он печатает строку &lt;code&gt;&quot;before functionB&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67a82144baac90e3bfe77c37b1e7cfd66966d43e" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before import&quot;&lt;/code&gt; (without quotes).</source>
          <target state="translated">Он печатает строку &lt;code&gt;&quot;before import&quot;&lt;/code&gt; (без кавычек).</target>
        </trans-unit>
        <trans-unit id="487802f670fb40e8bf81d7517f78375a228bb226" translate="yes" xml:space="preserve">
          <source>It will allow the module and its functions and classes to be imported into other scripts without running the &lt;code&gt;main&lt;/code&gt; function, and will also allow the module (and its functions and classes) to be called when running from a different &lt;code&gt;'__main__'&lt;/code&gt; module, i.e.</source>
          <target state="translated">Это позволит импортировать модуль и его функции и классы в другие сценарии без запуска &lt;code&gt;main&lt;/code&gt; функции, а также позволит вызывать модуль (и его функции и классы) при запуске из другого модуля &lt;code&gt;'__main__'&lt;/code&gt; , т.е.</target>
        </trans-unit>
        <trans-unit id="db31e7b989046834490a12f44ad8c713989903b9" translate="yes" xml:space="preserve">
          <source>It will print the string &lt;code&gt;&quot;after __name__ guard&quot;&lt;/code&gt; in both situations.</source>
          <target state="translated">В обеих ситуациях будет напечатана строка &lt;code&gt;&quot;after __name__ guard&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0640f504c6f1cabceaecd1e002b971be93067ac4" translate="yes" xml:space="preserve">
          <source>Let's look at the answer in a more abstract way:</source>
          <target state="translated">Давайте посмотрим на ответ более абстрактно:</target>
        </trans-unit>
        <trans-unit id="59c0758ddc6f775006dd70cbf5286216ff0f8137" translate="yes" xml:space="preserve">
          <source>Let's see how this works and how it relates to your question about the &lt;code&gt;__name__&lt;/code&gt; checks we always see in Python scripts.</source>
          <target state="translated">Давайте посмотрим, как это работает и как это связано с вашим вопросом о проверках &lt;code&gt;__name__&lt;/code&gt; ,которые мы всегда видим в скриптах Python.</target>
        </trans-unit>
        <trans-unit id="36e704322c41ccc6a321769ec4f01db18ff86add" translate="yes" xml:space="preserve">
          <source>Let's see what it does using a simple code that prints the name of the module:</source>
          <target state="translated">Посмотрим,что он делает,используя простой код,который печатает название модуля:</target>
        </trans-unit>
        <trans-unit id="5f645eb565c673e545d1679f2c86c2b42014562e" translate="yes" xml:space="preserve">
          <source>Let's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or &lt;code&gt;def&lt;/code&gt; - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself:</source>
          <target state="translated">Давайте пройдемся по приведенному выше коду, чтобы понять, что происходит, сосредоточив внимание в первую очередь на неиспользуемых строках и порядке их появления в скриптах. Помните, что блоки функций - или &lt;code&gt;def&lt;/code&gt; - сами ничего не делают, пока их не вызовут. Что может сказать переводчик, если бормочет себе:</target>
        </trans-unit>
        <trans-unit id="1254a1f938039680c725134df68b131b5aa46dc5" translate="yes" xml:space="preserve">
          <source>Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called &lt;code&gt;foo.py&lt;/code&gt;.</source>
          <target state="translated">Давайте использовать немного другой пример кода, чтобы изучить, как работают импорт и скрипты. Предположим, что следующее находится в файле с именем &lt;code&gt;foo.py&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="842b192efb9c67214acf7a300d55ce4db505bdcc" translate="yes" xml:space="preserve">
          <source>Note that only the top-level &lt;code&gt;print()&lt;/code&gt; statement in &lt;code&gt;my_test_module&lt;/code&gt; is executed.</source>
          <target state="translated">Обратите внимание, что выполняется только оператор &lt;code&gt;print()&lt;/code&gt; верхнего уровня в &lt;code&gt;my_test_module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81c6d0a8223e137d4fd96a2fea5acdc58cde2cd7" translate="yes" xml:space="preserve">
          <source>Notice that when used in a package or module, &lt;code&gt;__name__&lt;/code&gt; takes the name of the file.  The path of the actual module or package path is not given, but has its own DunderAlias &lt;code&gt;__file__&lt;/code&gt;, that allows for this.</source>
          <target state="translated">Обратите внимание, что при использовании в пакете или модуле &lt;code&gt;__name__&lt;/code&gt; принимает имя файла. Путь к фактическому модулю или пути пакета не указан, но имеет свой собственный DunderAlias &lt;code&gt;__file__&lt;/code&gt; , который учитывает это.</target>
        </trans-unit>
        <trans-unit id="cf84fdf12bf682b1e82dc617a50185e488527e76" translate="yes" xml:space="preserve">
          <source>Now if you invoke &lt;code&gt;main.py&lt;/code&gt;:</source>
          <target state="translated">Теперь, если вы вызываете &lt;code&gt;main.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7cdbc821008ebfe4fc4cd41f81d12ccd5cec7db9" translate="yes" xml:space="preserve">
          <source>Now if you run &lt;code&gt;my_test_module.py&lt;/code&gt; as a Python script, both &lt;code&gt;print()&lt;/code&gt; statements will be exectued:</source>
          <target state="translated">Теперь, если вы запустите &lt;code&gt;my_test_module.py&lt;/code&gt; как скрипт Python, оба оператора &lt;code&gt;print()&lt;/code&gt; будут выполнены:</target>
        </trans-unit>
        <trans-unit id="3875b0e9c99d33dd9d9117fb278540c718c1625f" translate="yes" xml:space="preserve">
          <source>Now suppose we call above script from other script</source>
          <target state="translated">Теперь предположим,что мы вызовем вышеприведенный сценарий из другого сценария.</target>
        </trans-unit>
        <trans-unit id="32d820770706edc1d47e13dfe4072ab74a677b21" translate="yes" xml:space="preserve">
          <source>Now, figure out what will happen if you remove the &lt;code&gt;__name__&lt;/code&gt; check in &lt;code&gt;foo3.py&lt;/code&gt;:</source>
          <target state="translated">Теперь &lt;code&gt;foo3.py&lt;/code&gt; , что произойдет, если вы удалите проверку &lt;code&gt;__name__&lt;/code&gt; в foo3.py :</target>
        </trans-unit>
        <trans-unit id="f61cdcc0e64bc154546828675c159f927f257516" translate="yes" xml:space="preserve">
          <source>Now, if you invoke the interpreter as</source>
          <target state="translated">Теперь,если вы вызовете переводчика,как</target>
        </trans-unit>
        <trans-unit id="8ca2803175deedc185a32811ae0d215b53994bac" translate="yes" xml:space="preserve">
          <source>Oh, a function. I'll remember that.</source>
          <target state="translated">О,функция.Я запомню это.</target>
        </trans-unit>
        <trans-unit id="6077d0ebf452529d19420c847ef52de2a426a2ee" translate="yes" xml:space="preserve">
          <source>Ok, function &lt;code&gt;a()&lt;/code&gt;; I just learned that. Printing '&lt;em&gt;A function in ab file&lt;/em&gt;'.</source>
          <target state="translated">Хорошо, функция &lt;code&gt;a()&lt;/code&gt; ; Я только что узнал это. Печать &amp;laquo; &lt;em&gt;Функция в файле ab&lt;/em&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f8c73f6bb1c6fc650c6e40cfdcfea137d51b31bb" translate="yes" xml:space="preserve">
          <source>On import, the &lt;code&gt;do_important&lt;/code&gt; function would be called, so you'd probably comment out your function call, &lt;code&gt;do_important()&lt;/code&gt;, at the bottom.</source>
          <target state="translated">При импорте &lt;code&gt;do_important&lt;/code&gt; функция do_important , поэтому вы, вероятно, закомментируете вызов функции &lt;code&gt;do_important()&lt;/code&gt; внизу.</target>
        </trans-unit>
        <trans-unit id="2d793a6eac08930c66fb11b06b414c6c74e2e724" translate="yes" xml:space="preserve">
          <source>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:</source>
          <target state="translated">С другой стороны,предположим,что какой-то другой модуль является основной программой и он импортирует ваш модуль.Это означает,что такое утверждение есть в основной программе или в каком-то другом модуле,который импортирует основная программа:</target>
        </trans-unit>
        <trans-unit id="4b8160972d3ededbe405e2919fa2974b8a5330ed" translate="yes" xml:space="preserve">
          <source>Open xy.py as the 'home' file; call it &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; in the &lt;code&gt;__name__&lt;/code&gt; variable.</source>
          <target state="translated">Откройте xy.py как &amp;laquo;домашний&amp;raquo; файл; Назовите его &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; в переменной &lt;code&gt;__name__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="a703490bf01742db237973ccf277b94b1592d61d" translate="yes" xml:space="preserve">
          <source>Put simply, &lt;code&gt;__name__&lt;/code&gt; is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.</source>
          <target state="translated">Проще говоря, &lt;code&gt;__name__&lt;/code&gt; - это переменная, определенная для каждого сценария, которая определяет, выполняется ли сценарий как основной модуль или как импортированный модуль.</target>
        </trans-unit>
        <trans-unit id="e37067e387ec00a654d6a8a4421c869e9ce7f02b" translate="yes" xml:space="preserve">
          <source>Question: Can I have multiple &lt;code&gt;__name__&lt;/code&gt; checking blocks?  Answer: it's strange to do so, but the language won't stop you.</source>
          <target state="translated">Вопрос: Могу ли я иметь несколько блоков проверки &lt;code&gt;__name__&lt;/code&gt; ? Ответ: это странно, но язык не остановит вас.</target>
        </trans-unit>
        <trans-unit id="1f6213cf7dc0a0a2692503179dc1a74e244db9a2" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://docs.python.org/3.5/tutorial/modules.html&quot;&gt;https://docs.python.org/3.5/tutorial/modules.html&lt;/a&gt;</source>
          <target state="translated">Ссылка: &lt;a href=&quot;https://docs.python.org/3.5/tutorial/modules.html&quot;&gt;https://docs.python.org/3.5/tutorial/modules.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="664467ee79494c88e6f1e2c2697dbbe4ff48a5d2" translate="yes" xml:space="preserve">
          <source>Remember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the &lt;code&gt;main()&lt;/code&gt; function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script.</source>
          <target state="translated">Помните, что я говорил ранее об операциях импорта? Когда вы импортируете модуль, он не просто &amp;laquo;распознает&amp;raquo; его и ждет дальнейших инструкций - он фактически выполняет все исполняемые операции, содержащиеся в скрипте. Таким образом, помещение мяса вашего скрипта в функцию &lt;code&gt;main()&lt;/code&gt; эффективно помещает его в карантин, изолируя его, чтобы он не запустился сразу после импорта другим скриптом.</target>
        </trans-unit>
        <trans-unit id="f98434905bc42aec74771816b1350633e53ce854" translate="yes" xml:space="preserve">
          <source>Resulting in &lt;code&gt;__main__&lt;/code&gt;</source>
          <target state="translated">В результате &lt;code&gt;__main__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e63592c750f974c67228385bd47700a1dc930828" translate="yes" xml:space="preserve">
          <source>Resulting in &lt;code&gt;somefile&lt;/code&gt;</source>
          <target state="translated">В результате &lt;code&gt;somefile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dca1109ee592b30f70306745ecaf4e3be65dabb6" translate="yes" xml:space="preserve">
          <source>Run it. It will print &lt;strong&gt;a&lt;/strong&gt;, i.e., the name of the file which &lt;strong&gt;is imported&lt;/strong&gt;.</source>
          <target state="translated">Запустить его. Это напечатает, то есть имя файла, который &lt;strong&gt;импортирован&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3f5bef58a00ebcb694aa52babce37958f2b198f1" translate="yes" xml:space="preserve">
          <source>Run the class stand alone, for testing purposes.</source>
          <target state="translated">Запустите класс в одиночку,в целях тестирования.</target>
        </trans-unit>
        <trans-unit id="20e86911fbff3e384f7f5f09191137367a0df800" translate="yes" xml:space="preserve">
          <source>Running them will get you this output:</source>
          <target state="translated">Запустив их,вы получите этот результат:</target>
        </trans-unit>
        <trans-unit id="10ec89290100bc024be13c487e6ae209eaa691b9" translate="yes" xml:space="preserve">
          <source>Say you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the  &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;</source>
          <target state="translated">Скажем, вы пишете скрипт на Python, который делает что-то великолепное, и вы реализуете множество функций, которые полезны для других целей. Если я хочу использовать их, я могу просто импортировать ваш скрипт и использовать его без выполнения вашей программы (учитывая, что ваш код выполняется только в контексте &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; . В то время как в C / C ++ вам придется разделить эти части на отдельный модуль, который затем включает файл. Изобразите ситуацию ниже;</target>
        </trans-unit>
        <trans-unit id="8d613d269c466eb978baefb1a911abf766ab0238" translate="yes" xml:space="preserve">
          <source>Say you're writing a Python script designed to be used as a module:</source>
          <target state="translated">Скажем,вы пишете сценарий на Python,предназначенный для использования в качестве модуля:</target>
        </trans-unit>
        <trans-unit id="fb6ab9485c691b027c37729a425f370d612207ed" translate="yes" xml:space="preserve">
          <source>Simply, it is the entry point to run the file, like the &lt;code&gt;main&lt;/code&gt; function in the &lt;em&gt;C&lt;/em&gt; programming language.</source>
          <target state="translated">Проще говоря, это точка входа для запуска файла, как и &lt;code&gt;main&lt;/code&gt; функция в языке программирования &lt;em&gt;C.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f0eb42cc94ae6f1d6b27a11e936825cd6e9be63" translate="yes" xml:space="preserve">
          <source>Small example to explain in short.</source>
          <target state="translated">Небольшой пример для объяснения вкратце.</target>
        </trans-unit>
        <trans-unit id="abff45f4f7494a045c401c2b502e510dbd014b28" translate="yes" xml:space="preserve">
          <source>So if we have two scripts;</source>
          <target state="translated">Так что,если у нас есть два сценария;</target>
        </trans-unit>
        <trans-unit id="84ce746d38e49c0592c794aa0e1ec5b2af9e35c4" translate="yes" xml:space="preserve">
          <source>So if you check before executing:</source>
          <target state="translated">Так что,если вы проверите перед выполнением:</target>
        </trans-unit>
        <trans-unit id="640d3626fbf5c4384513193cd5a05b99491f804b" translate="yes" xml:space="preserve">
          <source>So that is what this line of code checks. If it is the main file (i.e., b.py) running the code, which in this case it is not (a.py is the main file running), then only the code gets executed.</source>
          <target state="translated">Так вот что проверяет эта строка кода.Если это главный файл (т.е.b.py),в котором запущен код,которого в данном случае нет (a.py-это главный запущенный файл),то выполняется только код.</target>
        </trans-unit>
        <trans-unit id="263e6ff9fdb235045559021aa4f3aaf6a28dd1e6" translate="yes" xml:space="preserve">
          <source>So, above is self explanatory that when you call test from other script, if loop &lt;code&gt;__name__&lt;/code&gt; in &lt;code&gt;test.py&lt;/code&gt; will not execute.</source>
          <target state="translated">Итак, вышесказанное говорит само за себя, что при вызове test из другого скрипта цикл &lt;code&gt;__name__&lt;/code&gt; в &lt;code&gt;test.py&lt;/code&gt; не будет выполнен.</target>
        </trans-unit>
        <trans-unit id="68f77a6ccbf56724f5b40205ddb5e475652f0586" translate="yes" xml:space="preserve">
          <source>So, code under the &lt;code&gt;if&lt;/code&gt; block will only run if the module is the entry point to your program.</source>
          <target state="translated">Таким образом, код под блоком &lt;code&gt;if&lt;/code&gt; будет выполняться, только если модуль является точкой входа в вашу программу.</target>
        </trans-unit>
        <trans-unit id="f39f20521dcc328835dd2bae85539d96c3ed5764" translate="yes" xml:space="preserve">
          <source>So, in your example in part:</source>
          <target state="translated">Итак,в вашем примере частично:</target>
        </trans-unit>
        <trans-unit id="9b0e64ff7926b8af4a777a49504ee4171aa1f955" translate="yes" xml:space="preserve">
          <source>So, to show &lt;strong&gt;two different behavior of the same file&lt;/strong&gt;, this is a commonly used trick:</source>
          <target state="translated">Итак, чтобы показать &lt;strong&gt;два разных поведения одного и того же файла&lt;/strong&gt; , это часто используемый прием:</target>
        </trans-unit>
        <trans-unit id="1fd11fffb92fae55b373db1f1b2a14481892db42" translate="yes" xml:space="preserve">
          <source>Special Variables</source>
          <target state="translated">Специальные переменные</target>
        </trans-unit>
        <trans-unit id="b0b9fd78351c8645d3bb611c5714fc4fb48a880a" translate="yes" xml:space="preserve">
          <source>Suppose the following is in &lt;code&gt;foo2.py&lt;/code&gt;.  What happens if you say &lt;code&gt;python foo2.py&lt;/code&gt; on the command-line? Why?</source>
          <target state="translated">Предположим, что следующее в &lt;code&gt;foo2.py&lt;/code&gt; . Что произойдет, если вы скажете &lt;code&gt;python foo2.py&lt;/code&gt; в командной строке? Почему?</target>
        </trans-unit>
        <trans-unit id="19e0db61176529f3b08091162b28a1b8097dbc39" translate="yes" xml:space="preserve">
          <source>Suppose we have this code in x.py:</source>
          <target state="translated">Предположим,у нас есть этот код в x.py:</target>
        </trans-unit>
        <trans-unit id="b522da1d722893c1c3514d7e1c720966c233662f" translate="yes" xml:space="preserve">
          <source>Take file &quot;ab.py&quot;:</source>
          <target state="translated">Возьми файл &quot;ab.py&quot;:</target>
        </trans-unit>
        <trans-unit id="63dd3922ae392ebb0802b3e1fb913af39e39d6ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__name__&lt;/code&gt; variable points to the namespace wherever the Python interpreter happens to be at the moment.</source>
          <target state="translated">Переменная &lt;code&gt;__name__&lt;/code&gt; указывает на пространство имен, где бы ни находился интерпретатор Python в данный момент.</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">Проблема</target>
        </trans-unit>
        <trans-unit id="d9eef56265e1ad5d7b64df6c1fea6c1c26857bc3" translate="yes" xml:space="preserve">
          <source>The above statement is true and prints &lt;em&gt;&quot;direct method&quot;&lt;/em&gt;. Suppose if they imported this class in another class it doesn't print &lt;em&gt;&quot;direct method&quot;&lt;/em&gt; because, while importing, it will set &lt;code&gt;__name__ equal to &quot;first model name&quot;&lt;/code&gt;.</source>
          <target state="translated">Вышеприведенное утверждение верно и печатает &lt;em&gt;&amp;laquo;прямой метод&amp;raquo;&lt;/em&gt; . Предположим, что если они импортировали этот класс в другой класс, он не печатает &lt;em&gt;&amp;laquo;прямой метод&amp;raquo;,&lt;/em&gt; потому что при импорте он установит &lt;code&gt;__name__ equal to &quot;first model name&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b0b314d4585244ae8ac5cd70de557719041b367" translate="yes" xml:space="preserve">
          <source>The arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:</source>
          <target state="translated">Стрелки являются ссылками на импорт.Для трех модулей,каждый из которых пытается включить код предыдущих модулей,имеется шесть файлов (девять,считая файлы реализации)и пять ссылок.Это затрудняет включение другого кода в проект на C,если только он не скомпилирован специально как библиотека.Теперь представьте это для Python:</target>
        </trans-unit>
        <trans-unit id="b96b1c26d7d07398a4108598c24c3f6449d82fe1" translate="yes" xml:space="preserve">
          <source>The bottom two lines mean: &quot;If this is the &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; or 'home' script, execute the function called &lt;code&gt;main()&lt;/code&gt;&quot;. That's why you'll see a &lt;code&gt;def main():&lt;/code&gt; block up top, which contains the main flow of the script's functionality.</source>
          <target state="translated">Две нижние строки означают: &amp;laquo;Если это сценарий &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; или&amp;laquo; home &amp;raquo;, выполните функцию &lt;code&gt;main()&lt;/code&gt; &amp;raquo;. Вот почему вы увидите &lt;code&gt;def main():&lt;/code&gt; block up top, который содержит основной поток функций скрипта.</target>
        </trans-unit>
        <trans-unit id="ee36bd7aa18be8f75cff321a8cbe45b79fa20c99" translate="yes" xml:space="preserve">
          <source>The code inside &lt;code&gt;if __name__ == '__main__':&lt;/code&gt;&lt;strong&gt;will only be executed if the module is invoked as a script&lt;/strong&gt;.</source>
          <target state="translated">Код внутри &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; &lt;strong&gt;будет выполняться только в том случае, если модуль вызывается как скрипт&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c7cb418b6654cc08bd7fdbc541322601045fee60" translate="yes" xml:space="preserve">
          <source>The global variable, &lt;code&gt;__name__&lt;/code&gt;, in the module that is the entry point to your program, is &lt;code&gt;'__main__'&lt;/code&gt;. Otherwise, it's the name you import the module by.</source>
          <target state="translated">Глобальной переменной &lt;code&gt;__name__&lt;/code&gt; в модуле, являющемся точкой входа в вашу программу, является &lt;code&gt;'__main__'&lt;/code&gt; . В противном случае это имя, по которому вы импортируете модуль.</target>
        </trans-unit>
        <trans-unit id="abc8795a207d7fd1e55acd3339216f07ad278e91" translate="yes" xml:space="preserve">
          <source>The important thing that python is special at is point 4! The rest is just basic logic.</source>
          <target state="translated">Главное,что питон особенный в точке 4! Остальное-всего лишь базовая логика.</target>
        </trans-unit>
        <trans-unit id="070234b07de191f078cf7dded19198b7b44d467d" translate="yes" xml:space="preserve">
          <source>The interpreter keeps track of which scripts are running with &lt;code&gt;__name__&lt;/code&gt;. When you run a script - no matter what you've named it - the interpreter calls it &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;, making it the master or 'home' script that gets returned to after running an external script.</source>
          <target state="translated">Интерпретатор отслеживает, какие сценарии выполняются с &lt;code&gt;__name__&lt;/code&gt; . Когда вы запускаете сценарий - независимо от того, как вы его назвали - интерпретатор называет его &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; , делая его основным или &amp;laquo;домашним&amp;raquo; сценарием, к которому возвращается после запуска внешнего сценария.</target>
        </trans-unit>
        <trans-unit id="e490bbfebdeff408a85402b8066f8e0d765afb42" translate="yes" xml:space="preserve">
          <source>The interpreter will search for your &lt;code&gt;foo.py&lt;/code&gt; file (along with searching for a few other variants), and prior to executing that module, it will assign the name &lt;code&gt;&quot;foo&quot;&lt;/code&gt; from the import statement to the &lt;code&gt;__name__&lt;/code&gt; variable, i.e.</source>
          <target state="translated">Интерпретатор будет искать ваш файл &lt;code&gt;foo.py&lt;/code&gt; (наряду с поиском нескольких других вариантов), и перед выполнением этого модуля он назначит имя &lt;code&gt;&quot;foo&quot;&lt;/code&gt; из оператора import переменной &lt;code&gt;__name__&lt;/code&gt; , т.е.</target>
        </trans-unit>
        <trans-unit id="beb5c6ca096be5c499ae9d622ede781690b12de1" translate="yes" xml:space="preserve">
          <source>The output for the above is &lt;code&gt;__main__&lt;/code&gt;.</source>
          <target state="translated">Выход для вышеупомянутого - &lt;code&gt;__main__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b315daf004ca0729cd2f96be56c31138214abce" translate="yes" xml:space="preserve">
          <source>The output from executing script1 is</source>
          <target state="translated">Вывод из исполняемого скрипта1</target>
        </trans-unit>
        <trans-unit id="a61791ccd424eca040a7f63b8afadbed687c913a" translate="yes" xml:space="preserve">
          <source>The output will be</source>
          <target state="translated">Выход будет</target>
        </trans-unit>
        <trans-unit id="f7783b7273a972da2fb19a09cf27c06a5a76b303" translate="yes" xml:space="preserve">
          <source>The reason for</source>
          <target state="translated">Причина для</target>
        </trans-unit>
        <trans-unit id="461ad2d3ca9debfc02d07f3beea45fedd8fe7c48" translate="yes" xml:space="preserve">
          <source>The simplest explanation for the &lt;code&gt;__name__&lt;/code&gt; variable (imho) is the following:</source>
          <target state="translated">Простейшее объяснение переменной &lt;code&gt;__name__&lt;/code&gt; (imho) следующее:</target>
        </trans-unit>
        <trans-unit id="7bb35afec92b2288483eddfee92b6b137ba1ffee" translate="yes" xml:space="preserve">
          <source>There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the &lt;strong&gt;__name__&lt;/strong&gt; variable/attribute:</source>
          <target state="translated">Существует ряд переменных, которые система (интерпретатор Python) предоставляет для исходных файлов (модулей). Вы можете получить их значения в любое время, поэтому давайте сосредоточимся на переменной / атрибуте &lt;strong&gt;__name__&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d334018c829a8afc4b891e4ccfd37fcb00325b95" translate="yes" xml:space="preserve">
          <source>There are lots of different takes here on the mechanics of the code in question, the &quot;How&quot;, but for me none of it made sense until I understood the &quot;Why&quot;. This should be especially helpful for new programmers.</source>
          <target state="translated">Здесь много разных дублей по механике рассматриваемого кода,&quot;Как&quot;,но для меня ничего из этого не имело смысла,пока я не понял &quot;Почему&quot;.Это должно быть особенно полезно для новых программистов.</target>
        </trans-unit>
        <trans-unit id="e63743be839c5f96b5ee726f165c404beeea8567" translate="yes" xml:space="preserve">
          <source>There's a Pythonic way to improve on this, though.</source>
          <target state="translated">Но есть питонический способ улучшить это.</target>
        </trans-unit>
        <trans-unit id="7da449e38cd83db4680bb69d26f25544a12a00c0" translate="yes" xml:space="preserve">
          <source>This answer is for Java programmers learning Python.
Every Java file typically contains one public class. You can use that class in two ways:</source>
          <target state="translated">Этот ответ предназначен для Java-программистов,изучающих Python.Каждый Java-файл обычно содержит один общедоступный класс.Вы можете использовать этот класс двумя способами:</target>
        </trans-unit>
        <trans-unit id="a93248e8c28b2baad3105d4909c76fa1d06bca1b" translate="yes" xml:space="preserve">
          <source>This means that if &lt;code&gt;__name__&lt;/code&gt; is equal to &lt;code&gt;__main__&lt;/code&gt; then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.</source>
          <target state="translated">Это означает, что если &lt;code&gt;__name__&lt;/code&gt; равен &lt;code&gt;__main__&lt;/code&gt; , то этот файл должен быть основным файлом и фактически должен быть запущен (или интерпретатором), а не модулем или пакетом, импортированным в сценарий.</target>
        </trans-unit>
        <trans-unit id="26768ab59b39b3300f945b6b412204438fd854c1" translate="yes" xml:space="preserve">
          <source>This module represents the (otherwise anonymous) scope in which the
  interpreter&amp;rsquo;s main program executes &amp;mdash; commands read either from
  standard input, from a script file, or from an interactive prompt. It
  is this environment in which the idiomatic &amp;ldquo;conditional script&amp;rdquo; stanza
  causes a script to run:</source>
          <target state="translated">Этот модуль представляет (иначе анонимную) область, в которой выполняется основная программа интерпретатора - команды, читаемые либо из стандартного ввода, из файла сценария, либо из интерактивного приглашения. Именно в этой среде идиоматический раздел &amp;laquo;условный скрипт&amp;raquo; запускает скрипт:</target>
        </trans-unit>
        <trans-unit id="570c99fbd84e48be7a4bc039c23bb770f7a93f2d" translate="yes" xml:space="preserve">
          <source>This tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute.  If it is a package then it should not, and the value will not be &lt;code&gt;__main__&lt;/code&gt;.</source>
          <target state="translated">Это говорит нам о том, что если выполняемый файл является основным файлом (или вы запускаете непосредственно из интерпретатора), то это условие должно выполняться. Если это пакет, то не должен, и значение не будет &lt;code&gt;__main__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="400df23e6535cffd76bdbec3d29bf175104d993d" translate="yes" xml:space="preserve">
          <source>Thus, including &lt;a href=&quot;https://docs.python.org/library/__main__.html&quot;&gt;the final lines&lt;/a&gt;</source>
          <target state="translated">Таким образом, включая &lt;a href=&quot;https://docs.python.org/library/__main__.html&quot;&gt;последние строки&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41ff41b822d3a441a23084a1b748580b08728f3a" translate="yes" xml:space="preserve">
          <source>Thus, the value of the &lt;code&gt;__name__&lt;/code&gt; attribute is set to &lt;code&gt;__main__&lt;/code&gt; when the module is run as the main program. Otherwise the value of &lt;code&gt;__name__&lt;/code&gt;  is set to contain the name of the module.</source>
          <target state="translated">Таким образом, значение атрибута &lt;code&gt;__name__&lt;/code&gt; устанавливается &lt;code&gt;__main__&lt;/code&gt; когда модуль запускается в качестве основной программы. В противном случае значение &lt;code&gt;__name__&lt;/code&gt; должно содержать имя модуля.</target>
        </trans-unit>
        <trans-unit id="e5bb2a5a3f702f74d72560d048b4376dfc0840a3" translate="yes" xml:space="preserve">
          <source>Thus, when module &lt;code&gt;one&lt;/code&gt; gets loaded, its &lt;code&gt;__name__&lt;/code&gt; equals &lt;code&gt;&quot;one&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.</source>
          <target state="translated">Таким образом, когда модуль &lt;code&gt;one&lt;/code&gt; загружается, его &lt;code&gt;__name__&lt;/code&gt; равно &lt;code&gt;&quot;one&quot;&lt;/code&gt; вместо &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="523dcaae791ba2376f9d0e38205b6e104584b94b" translate="yes" xml:space="preserve">
          <source>To be short, you need to know several points:</source>
          <target state="translated">Чтобы быть коротким,нужно знать несколько пунктов:</target>
        </trans-unit>
        <trans-unit id="ab6345109ea5809edd76f43e5ad346f6c84b96e7" translate="yes" xml:space="preserve">
          <source>To outline the basics:</source>
          <target state="translated">Чтобы изложить основы:</target>
        </trans-unit>
        <trans-unit id="12ab10369b1f47def1cf885774f934b4e0985f34" translate="yes" xml:space="preserve">
          <source>To solve the problem in point 2, python allows you to put a condition check</source>
          <target state="translated">Для решения задачи в пункте 2,питон позволяет поставить проверку состояния</target>
        </trans-unit>
        <trans-unit id="4711ba0e3e6d6e4a6ad75a1fa7aa2587e14a3867" translate="yes" xml:space="preserve">
          <source>We can execute this directly as</source>
          <target state="translated">Мы можем выполнить это непосредственно как</target>
        </trans-unit>
        <trans-unit id="babfa4c489d804dc449fbd841bce76fc1745bd5c" translate="yes" xml:space="preserve">
          <source>We now have a final function for the end of our module that will run if we run the module as the primary module.</source>
          <target state="translated">Теперь у нас есть последняя функция для конца нашего модуля,которая будет выполняться,если мы запустим модуль в качестве основного.</target>
        </trans-unit>
        <trans-unit id="1c12bf3938c1cb1ecd0ac996a47bdeae5af33c7c" translate="yes" xml:space="preserve">
          <source>We see if &lt;code&gt;__name__ == '__main__':&lt;/code&gt; quite often.</source>
          <target state="translated">Мы видим, если &lt;code&gt;__name__ == '__main__':&lt;/code&gt; довольно часто.</target>
        </trans-unit>
        <trans-unit id="8c1bfdb1fcdcd5574d83109e0bae5ad3a5cf62db" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; do?</source>
          <target state="translated">Что делать, &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; делать?</target>
        </trans-unit>
        <trans-unit id="882f556d9b969816afbc080f2c0c2833e74571bd" translate="yes" xml:space="preserve">
          <source>What does if __name__ == “__main__”: do</source>
          <target state="translated">Что будет,если __name_==&quot;__main_&quot;:do</target>
        </trans-unit>
        <trans-unit id="0519ae47b8614fd1d5f5805a3c6ace1513a3c429" translate="yes" xml:space="preserve">
          <source>What does the &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; do?</source>
          <target state="translated">Что делает &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8ade84c1dddd0abd1d4a5cbe46e38dc11bedceb" translate="yes" xml:space="preserve">
          <source>What if we want to run this business process from outside the module?</source>
          <target state="translated">Что,если мы хотим запустить этот бизнес-процесс снаружи модуля?</target>
        </trans-unit>
        <trans-unit id="849ed2229cbffb820dde4aac079e940cbf66d22f" translate="yes" xml:space="preserve">
          <source>What is this code actually doing?</source>
          <target state="translated">Что на самом деле делает этот код?</target>
        </trans-unit>
        <trans-unit id="ac4dd5fb5ee621db0e7fc13bfab42a28cf4cb6c7" translate="yes" xml:space="preserve">
          <source>What will this do when used as a script?  When imported as a module?</source>
          <target state="translated">Что это будет делать при использовании в качестве сценария? При импорте в качестве модуля?</target>
        </trans-unit>
        <trans-unit id="34026079e5767a32ede0b2469d594a04aa502cd0" translate="yes" xml:space="preserve">
          <source>What's this? An &lt;code&gt;if&lt;/code&gt; statement. Well, the condition has been met (the variable &lt;code&gt;__name__&lt;/code&gt; has been set to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;), so I'll enter the &lt;code&gt;main()&lt;/code&gt; function and print '&lt;em&gt;main function: this is where the action is&lt;/em&gt;'.</source>
          <target state="translated">Что это? &lt;code&gt;if&lt;/code&gt; заявление. Итак, условие выполнено (переменная &lt;code&gt;__name__&lt;/code&gt; установлена ​​в &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; ), поэтому я войду в функцию &lt;code&gt;main()&lt;/code&gt; и выведу &amp;laquo; &lt;em&gt;main function: это где действие&lt;/em&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a7a878649d8009684428450f8af9b808c3a3075d" translate="yes" xml:space="preserve">
          <source>When Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.)</source>
          <target state="translated">Когда Python загружает файл с исходным кодом,он выполняет весь найденный в нем код.(Обратите внимание,что он вызывает не все методы и функции,определённые в файле,а определённые им).</target>
        </trans-unit>
        <trans-unit id="2a4ffb529b1700ce20d37ede654fc1142a11d491" translate="yes" xml:space="preserve">
          <source>When the Python interpeter reads a source file, it first defines a few special variables. In this case, we care about the &lt;code&gt;__name__&lt;/code&gt; variable.</source>
          <target state="translated">Когда интерпретатор Python читает исходный файл, он сначала определяет несколько специальных переменных. В этом случае мы заботимся о переменной &lt;code&gt;__name__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="447dd3597ff37641a5da70095abbfb1e338af1d5" translate="yes" xml:space="preserve">
          <source>When there are certain statements in our module (&lt;code&gt;M.py&lt;/code&gt;) we want to be executed when it'll be running as main (not imported), we can place those statements (test-cases, print statements) under this &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">Когда в нашем модуле ( &lt;code&gt;M.py&lt;/code&gt; ) есть определенные операторы, которые мы хотим выполнить, когда он будет работать как основной (не импортированный), мы можем поместить эти операторы (тестовые случаи, операторы печати) в блок &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9877906a93c95cdaf2921362477e675f7b677ec6" translate="yes" xml:space="preserve">
          <source>When you execute &lt;code&gt;xy.py&lt;/code&gt;, you &lt;code&gt;import ab&lt;/code&gt;. The import statement runs the module immediately on import, so &lt;code&gt;ab&lt;/code&gt;'s operations get executed before the remainder of &lt;code&gt;xy&lt;/code&gt;'s. Once finished with &lt;code&gt;ab&lt;/code&gt;, it continues with &lt;code&gt;xy&lt;/code&gt;.</source>
          <target state="translated">Когда вы выполняете &lt;code&gt;xy.py&lt;/code&gt; , вы &lt;code&gt;import ab&lt;/code&gt; . Оператор import сразу же запускает модуль при импорте, поэтому операции &lt;code&gt;ab&lt;/code&gt; выполняются раньше, чем до &lt;code&gt;xy&lt;/code&gt; . Закончив с &lt;code&gt;ab&lt;/code&gt; , он продолжает с &lt;code&gt;xy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b36e56cdbe31fc5262405f5324cf63c8c6e4bf" translate="yes" xml:space="preserve">
          <source>When you execute this</source>
          <target state="translated">Когда вы выполняете это</target>
        </trans-unit>
        <trans-unit id="6fd61966708d4f62ded02175bf761bbf0e8fb9c3" translate="yes" xml:space="preserve">
          <source>When you run Python interactively the local &lt;code&gt;__name__&lt;/code&gt; variable is assigned a value of &lt;code&gt;__main__&lt;/code&gt;. Likewise, when you execute a Python module from the command line, rather than importing it into another module, its &lt;code&gt;__name__&lt;/code&gt; attribute is assigned a value of &lt;code&gt;__main__&lt;/code&gt;, rather than the actual name of the module. In this way, modules can look at their own &lt;code&gt;__name__&lt;/code&gt; value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:</source>
          <target state="translated">Когда вы запускаете Python в интерактивном режиме, локальной переменной &lt;code&gt;__name__&lt;/code&gt; присваивается значение &lt;code&gt;__main__&lt;/code&gt; . Аналогично, когда вы запускаете модуль Python из командной строки, а не импортируете его в другой модуль, его атрибуту &lt;code&gt;__name__&lt;/code&gt; присваивается значение &lt;code&gt;__main__&lt;/code&gt; , а не фактическое имя модуля. Таким образом, модули могут смотреть на свое собственное значение &lt;code&gt;__name__&lt;/code&gt; , чтобы определить для себя, как они используются, в качестве поддержки другой программы или в качестве основного приложения, выполняемого из командной строки. Таким образом, следующая идиома довольно распространена в модулях Python:</target>
        </trans-unit>
        <trans-unit id="4382aa34afa3d659f0bb4edaf5dcf55f253232cd" translate="yes" xml:space="preserve">
          <source>When you run this script prints &lt;strong&gt;you can see me&lt;/strong&gt;</source>
          <target state="translated">Когда вы запустите этот скрипт, &lt;strong&gt;вы увидите меня&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff92db554b1095b0d40299da20c445f80406d870" translate="yes" xml:space="preserve">
          <source>When your script is run by passing it as a command to the Python interpreter,</source>
          <target state="translated">Когда ваш скрипт выполняется путем передачи его в качестве команды интерпретатору Python,</target>
        </trans-unit>
        <trans-unit id="ab593498ef9ec53331cbff2af3b2dd2b51bdf819" translate="yes" xml:space="preserve">
          <source>Whenever the Python interpreter reads a source file, it does two things:</source>
          <target state="translated">Всякий раз,когда интерпретатор Python читает исходный файл,он делает две вещи:</target>
        </trans-unit>
        <trans-unit id="6a1d2d8182ddb99759342b07d21796d4a90b92eb" translate="yes" xml:space="preserve">
          <source>Why Does It Work This Way?</source>
          <target state="translated">Почему это так работает?</target>
        </trans-unit>
        <trans-unit id="fc47432e4bb8b9783f8dbd23b35f57d699c4a18e" translate="yes" xml:space="preserve">
          <source>Why do we need this?</source>
          <target state="translated">Зачем нам это?</target>
        </trans-unit>
        <trans-unit id="acd0bc142a66a740172c6969fcbd8897e5de82ac" translate="yes" xml:space="preserve">
          <source>Why implement this?</source>
          <target state="translated">Зачем это делать?</target>
        </trans-unit>
        <trans-unit id="b6e9143e9e32c607148934a535cfda140fe418d6" translate="yes" xml:space="preserve">
          <source>With the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script).</source>
          <target state="translated">При указанном выше,ваш код будет выполняться только в том случае,если вы запускаете его в качестве основного модуля (или намеренно вызываете его из другого скрипта).</target>
        </trans-unit>
        <trans-unit id="913a9ffbcabac7b4746945a64e723d43537938ef" translate="yes" xml:space="preserve">
          <source>Yes, that's right. These separate functions &lt;strong&gt;can&lt;/strong&gt; be called from an in-line script that's not contained inside a &lt;code&gt;main()&lt;/code&gt; function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read.</source>
          <target state="translated">Да это правильно. Эти отдельные функции &lt;strong&gt;можно&lt;/strong&gt; вызывать из встроенного скрипта, который не содержится внутри функции &lt;code&gt;main()&lt;/code&gt; . Если вы привыкли (как и я, на ранних этапах обучения программированию) к созданию встроенных сценариев, которые выполняют именно то, что вам нужно, и вы попытаетесь снова это выяснить, если вам когда-нибудь понадобится эта операция снова ... Ну, вы не привыкли к такого рода внутренней структуре вашего кода, потому что его сложнее построить и он не настолько интуитивно понятен для чтения.</target>
        </trans-unit>
        <trans-unit id="bbf85bd3bd1a2f405d72d298d6d2e8dc0e6a4075" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; test the module by adding this call of the function to the bottom:</source>
          <target state="translated">Вы &lt;em&gt;можете&lt;/em&gt; протестировать модуль, добавив этот вызов функции внизу:</target>
        </trans-unit>
        <trans-unit id="786d584d19c5e53ad4e4097843269cf6c5e6292a" translate="yes" xml:space="preserve">
          <source>You can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.</source>
          <target state="translated">Вы также можете использовать его для предоставления запускаемых справочных функциональных утилит для пакетов и модулей без сложного использования библиотек.</target>
        </trans-unit>
        <trans-unit id="1022be4eed5ff0cd45b00fa73b4ca1a925550db8" translate="yes" xml:space="preserve">
          <source>You can make the file usable as a &lt;strong&gt;script&lt;/strong&gt; as well as an &lt;strong&gt;importable module&lt;/strong&gt;.</source>
          <target state="translated">Вы можете сделать файл пригодным для использования в качестве &lt;strong&gt;скрипта,&lt;/strong&gt; а также в качестве &lt;strong&gt;импортируемого модуля&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="53eb1352da0ffb51c0ec047f0ef125c909ddaefa" translate="yes" xml:space="preserve">
          <source>You get</source>
          <target state="translated">Ты получаешь</target>
        </trans-unit>
        <trans-unit id="dadc4d8e7d9fa9779b4e08f566981499d80cb4e7" translate="yes" xml:space="preserve">
          <source>You might naturally wonder why anybody would want this.  Well, sometimes you want to write a &lt;code&gt;.py&lt;/code&gt; file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:</source>
          <target state="translated">Естественно, вы можете удивиться, почему кто-то хотел этого. Ну, иногда вы хотите написать &lt;code&gt;.py&lt;/code&gt; файл, который может быть использован другими программами и / или модулями как модуль, а также может быть запущен как основная программа. Примеры:</target>
        </trans-unit>
        <trans-unit id="8047f868d8a396e2d98f574de9648be818c0aee6" translate="yes" xml:space="preserve">
          <source>You should see that, where &lt;code&gt;__name__&lt;/code&gt;, where it is the main file (or program) will &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;__main__&lt;/code&gt;, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.</source>
          <target state="translated">Вы должны увидеть, что, где &lt;code&gt;__name__&lt;/code&gt; , где это основной файл (или программа), &lt;em&gt;всегда&lt;/em&gt; будет возвращать &lt;code&gt;__main__&lt;/code&gt; , а если это модуль / пакет или что-то, что выполняется на каком-либо другом скрипте Python, вернет имя файла откуда он возник.</target>
        </trans-unit>
        <trans-unit id="737d0a68671613e4f63d5688dcabf38a268873ac" translate="yes" xml:space="preserve">
          <source>You write a module, and if someone wants to use your code they just import it and the &lt;code&gt;__name__&lt;/code&gt; variable can help to separate the executable portion of the program from the library part.</source>
          <target state="translated">Вы пишете модуль, и если кто-то хочет использовать ваш код, он просто импортирует его, а переменная &lt;code&gt;__name__&lt;/code&gt; может помочь отделить исполняемую часть программы от части библиотеки.</target>
        </trans-unit>
        <trans-unit id="e48102eb585faacfdf2ded85e1a6e43222bcef6c" translate="yes" xml:space="preserve">
          <source>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.</source>
          <target state="translated">Ваш модуль является библиотекой,но вы хотите иметь скриптовый режим,в котором он запускает какие-то юнит-тесты или демо-версию.</target>
        </trans-unit>
        <trans-unit id="9775ebd3a1d07733317e1e64b5d35d40fca683d8" translate="yes" xml:space="preserve">
          <source>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.</source>
          <target state="translated">Ваш модуль в основном используется как основная программа,но он также предоставляет удобный для программиста API для продвинутых пользователей.</target>
        </trans-unit>
        <trans-unit id="327fb7d82f537223ad218bd0c2bd1f339f312554" translate="yes" xml:space="preserve">
          <source>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing &lt;code&gt;.py&lt;/code&gt; files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.</source>
          <target state="translated">Ваш модуль используется только в качестве основной программы, но у него есть несколько модульных тестов, и среда тестирования работает путем импорта файлов &lt;code&gt;.py&lt;/code&gt; , таких как ваш скрипт, и запуска специальных функций тестирования. Вы не хотите, чтобы он пытался запустить скрипт только потому, что он импортирует модуль.</target>
        </trans-unit>
        <trans-unit id="7921914ab3f7b51666817a9add8daeeb610bdeaf" translate="yes" xml:space="preserve">
          <source>all of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there's no &lt;code&gt;main()&lt;/code&gt; function that gets run automatically - the &lt;code&gt;main()&lt;/code&gt; function is implicitly all the code at the top level.</source>
          <target state="translated">весь код на уровне отступа 0 выполняется. Определенные функции и классы, ну, в общем, определены, но ни один из их кода не запускается. В отличие от других языков, нет функции &lt;code&gt;main()&lt;/code&gt; которая запускается автоматически - функция &lt;code&gt;main()&lt;/code&gt; неявно представляет собой весь код верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="57216f4f62e4c7cff528a1042119b6bd292590a1" translate="yes" xml:space="preserve">
          <source>and running it (on a command prompt) with something like:</source>
          <target state="translated">и запустить его (в командной строке)с чем-то вроде:</target>
        </trans-unit>
        <trans-unit id="3ef1ebbdd755420799ee3cf5f1bbe79340df1c25" translate="yes" xml:space="preserve">
          <source>at the end of your mycode.py script,</source>
          <target state="translated">в конце твоего сценария mycode.py,</target>
        </trans-unit>
        <trans-unit id="d2fb4096be84a03b40677e8860e321cd4dab7598" translate="yes" xml:space="preserve">
          <source>if &lt;strong&gt;name&lt;/strong&gt; == '&lt;strong&gt;main&lt;/strong&gt;':</source>
          <target state="translated">если &lt;strong&gt;name&lt;/strong&gt; == ' &lt;strong&gt;main&lt;/strong&gt; ':</target>
        </trans-unit>
        <trans-unit id="e874b6c8f390f7d7eef2f26e6eba081818ffd576" translate="yes" xml:space="preserve">
          <source>is primarily to avoid the &lt;a href=&quot;https://docs.python.org/2/library/threading.html#importing-in-threaded-code&quot;&gt;import lock&lt;/a&gt; problems that would arise from &lt;a href=&quot;https://stackoverflow.com/questions/46326059/&quot;&gt;having code directly imported&lt;/a&gt;. You want &lt;code&gt;main()&lt;/code&gt; to run if your file was directly invoked (that's the &lt;code&gt;__name__ == &quot;__main__&quot;&lt;/code&gt; case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems.</source>
          <target state="translated">прежде всего, чтобы избежать проблем с &lt;a href=&quot;https://docs.python.org/2/library/threading.html#importing-in-threaded-code&quot;&gt;блокировкой импорта,&lt;/a&gt; которые могут возникнуть из- &lt;a href=&quot;https://stackoverflow.com/questions/46326059/&quot;&gt;за прямого импорта кода&lt;/a&gt; . Вы хотите, чтобы &lt;code&gt;main()&lt;/code&gt; запускалась, если ваш файл был вызван напрямую (это случай &lt;code&gt;__name__ == &quot;__main__&quot;&lt;/code&gt; ), но если ваш код был импортирован, то импортер должен ввести ваш код из истинного основного модуля, чтобы избежать проблем блокировки импорта.</target>
        </trans-unit>
        <trans-unit id="ac8e610ec891561e761ac3b81b1844f41418fb4b" translate="yes" xml:space="preserve">
          <source>it executes all of the code found in the file.</source>
          <target state="translated">он выполняет весь код,найденный в файле.</target>
        </trans-unit>
        <trans-unit id="0ebc8d74e14ef81dd980f3fabdbf3885802c2366" translate="yes" xml:space="preserve">
          <source>it sets a few special variables like &lt;code&gt;__name__&lt;/code&gt;, and then</source>
          <target state="translated">он устанавливает несколько специальных переменных, таких как &lt;code&gt;__name__&lt;/code&gt; , а затем</target>
        </trans-unit>
        <trans-unit id="75cd93d2e463e2434b2a0c03ccd41ae796240e8e" translate="yes" xml:space="preserve">
          <source>means that the code block:</source>
          <target state="translated">означает,что блок кода:</target>
        </trans-unit>
        <trans-unit id="6d7de544326381643ee98f9ae79c1d3e6d9eceef" translate="yes" xml:space="preserve">
          <source>the interpreter will assign the hard-coded string &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; to the &lt;code&gt;__name__&lt;/code&gt; variable, i.e.</source>
          <target state="translated">интерпретатор назначит жестко запрограммированную строку &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; переменной &lt;code&gt;__name__&lt;/code&gt; , т.е.</target>
        </trans-unit>
        <trans-unit id="0a6a0101819f9a81026cd9527ab3084564a94697" translate="yes" xml:space="preserve">
          <source>the otherwise anonymous global namespace is assigned the value of &lt;code&gt;'__main__'&lt;/code&gt; to its &lt;code&gt;__name__&lt;/code&gt;.</source>
          <target state="translated">в противном случае анонимному глобальному пространству имен присваивается значение &lt;code&gt;'__main__'&lt;/code&gt; его &lt;code&gt;__name__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7dc9621082d73413870731d07212c168ee0c948" translate="yes" xml:space="preserve">
          <source>when it is the primary, entry-point module that is run by a Python process,</source>
          <target state="translated">когда это первичный,начальный модуль,который запускается процессом Python,</target>
        </trans-unit>
        <trans-unit id="2616062d77ab8e88551d4e00b757e66c49032c1f" translate="yes" xml:space="preserve">
          <source>will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of &lt;strong&gt;__name__&lt;/strong&gt; will not equal to &quot;&lt;strong&gt;main&lt;/strong&gt;&quot; in that particular instance.</source>
          <target state="translated">будет выполняться только при непосредственном запуске модуля; блок кода не будет выполняться, если другой модуль вызывает / импортирует его, потому что значение &lt;strong&gt;__name__&lt;/strong&gt; не будет равно &amp;laquo; &lt;strong&gt;main&lt;/strong&gt; &amp;raquo; в данном конкретном случае.</target>
        </trans-unit>
        <trans-unit id="ae6fd70eacf54f86ab690f1936c2bc5c6419b15c" translate="yes" xml:space="preserve">
          <source>will cause your script's uniquely defined &lt;code&gt;main&lt;/code&gt; function to run.</source>
          <target state="translated">приведет к запуску уникальной &lt;code&gt;main&lt;/code&gt; функции вашего скрипта.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
