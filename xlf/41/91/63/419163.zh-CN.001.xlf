<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/419163">
    <body>
      <group id="419163">
        <trans-unit id="be437cc206c4a893439095f2b33790a548b29bdd" translate="yes" xml:space="preserve">
          <source>(&lt;strong&gt;instead&lt;/strong&gt;) If your module is not the main program but was imported by another one, then &lt;code&gt;__name__&lt;/code&gt; will be &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, not &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;, and it'll skip the body of the &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">（ &lt;strong&gt;相反&lt;/strong&gt; ）如果您的模块不是主程序而是由另一个程序导入的，则 &lt;code&gt;__name__&lt;/code&gt; 将是 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ，而不是 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; ，它将跳过 &lt;code&gt;if&lt;/code&gt; 语句的主体。</target>
        </trans-unit>
        <trans-unit id="87357c2f1577f162cab1176800cb98e9ae9f1df0" translate="yes" xml:space="preserve">
          <source>(As an aside, &lt;a href=&quot;https://stackoverflow.com/questions/23000075/purpose-of-if-name-main&quot;&gt;this question&lt;/a&gt; contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of &lt;a href=&quot;https://stackoverflow.com/questions/419163/what-does-if-name-main-do&quot;&gt;this one&lt;/a&gt;, which I think is a mistake.)</source>
          <target state="translated">（顺便说一句， &lt;a href=&quot;https://stackoverflow.com/questions/23000075/purpose-of-if-name-main&quot;&gt;这个问题&lt;/a&gt;包含@kindall的答案，它最终帮助我理解了-原因，而不是方法。不幸的是，它被标记为与&lt;a href=&quot;https://stackoverflow.com/questions/419163/what-does-if-name-main-do&quot;&gt;此&lt;/a&gt;副本的副本，我认为这是错误的。）</target>
        </trans-unit>
        <trans-unit id="99ee0547f367b7fbe108d02a06130f410fdeed36" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;This idiom can also be found in the Python documentation in an explanation of the &lt;code&gt;__main__&lt;/code&gt; module.&lt;/a&gt; That text states:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;也可以在Python文档中的 &lt;code&gt;__main__&lt;/code&gt; 模块说明中找到该惯用法。&lt;/a&gt; 该文本指出：</target>
        </trans-unit>
        <trans-unit id="d07b4aba29e620e47507cb0c3f0488674297686a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'__main__'&lt;/code&gt; is the name of the scope in which top-level code executes. A module&amp;rsquo;s &lt;code&gt;__name__&lt;/code&gt; is set equal to &lt;code&gt;'__main__'&lt;/code&gt; when read from standard input, a script, or from an interactive prompt.</source>
          <target state="translated">&lt;code&gt;'__main__'&lt;/code&gt; 是顶级代码在其中执行的作用域的名称。 从标准输入，脚本或交互式提示中读取时，模块的 &lt;code&gt;__name__&lt;/code&gt; 设置等于 &lt;code&gt;'__main__'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fafdac69f04bc2657902a7797c051653adc55033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__main__&lt;/code&gt;: Like other programming languages, Python too has an execution entry point, i.e., main. &lt;code&gt;'__main__'&lt;/code&gt;&lt;em&gt;is the name of the scope in which top-level code executes&lt;/em&gt;. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its &lt;code&gt;__name__&lt;/code&gt; is set to &lt;code&gt;__main__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__main__&lt;/code&gt; ：和其他编程语言一样，Python也有一个执行入口点，即main。 &lt;code&gt;'__main__'&lt;/code&gt; &lt;em&gt;是执行顶级代码的作用域的名称&lt;/em&gt; 。 基本上，您有两种使用Python模块的方式：直接将其作为脚本运行，或将其导入。 当模块作为脚本运行时，其 &lt;code&gt;__name__&lt;/code&gt; 设置为 &lt;code&gt;__main__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39eb9da36f02c4419a8bdef9e03ec68236ed2afc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; can also be used in modules to define the name of a module</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 也可以在模块中使用以定义模块的名称</target>
        </trans-unit>
        <trans-unit id="0be6ddf60538888ac5a053e568c5a35b99e293a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is a &lt;a href=&quot;https://wiki.python.org/moin/DunderAlias&quot;&gt;DunderAlias&lt;/a&gt; - can be thought of as a global variable (accessible from modules) and works in a similar way to &lt;a href=&quot;https://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 是&lt;a href=&quot;https://wiki.python.org/moin/DunderAlias&quot;&gt;DunderAlias-&lt;/a&gt;可以被认为是全局变量（可从模块访问），并以与&lt;a href=&quot;https://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt;相似的方式工作。</target>
        </trans-unit>
        <trans-unit id="8f7940fd7af049d3ce98c54968886dbc4470c59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is a global variable (in Python, global actually means on the &lt;a href=&quot;https://docs.python.org/tutorial/modules.html#modules&quot;&gt;module level&lt;/a&gt;) that exists in all namespaces. It is typically the module's name (as a &lt;code&gt;str&lt;/code&gt; type).</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 是一个存在于所有命名空间中的全局变量（在Python中，global实际上是在&lt;a href=&quot;https://docs.python.org/tutorial/modules.html#modules&quot;&gt;模块级别上表示&lt;/a&gt; ）。 它通常是模块的名称（作为 &lt;code&gt;str&lt;/code&gt; 类型）。</target>
        </trans-unit>
        <trans-unit id="2cf51e459a190c18f6d42769d3718fcae45ce2cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is always equal to &lt;code&gt;__main__&lt;/code&gt; whenever that file is &lt;strong&gt;run directly&lt;/strong&gt; showing that this is the main file.</source>
          <target state="translated">每当&lt;strong&gt;运行&lt;/strong&gt;该文件时， &lt;code&gt;__name__&lt;/code&gt; 始终等于 &lt;code&gt;__main__&lt;/code&gt; ， &lt;strong&gt;直接&lt;/strong&gt;表明它是主文件。</target>
        </trans-unit>
        <trans-unit id="9bd80d28fa314832c308431bb2b4654a9578e9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt; is an implicit variable in all .py modules; when a.py is imported, the value of &lt;code&gt;__name__&lt;/code&gt; of a.py module is set to its file name &quot;a&quot;; when a.py is run directly using &quot;python a.py&quot;, which means a.py is the entry point, then the value of &lt;code&gt;__name__&lt;/code&gt; of a.py module is set to a string &lt;code&gt;__main__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 是所有.py模块中的隐式变量； 导入 &lt;code&gt;__name__&lt;/code&gt; ，将a.py模块的__name__的值设置为其文件名&amp;ldquo; a&amp;rdquo;； 当使用&amp;ldquo; python a.py&amp;rdquo;直接运行a.py时，这意味着a.py是入口点，则a.py模块的 &lt;code&gt;__name__&lt;/code&gt; 的值设置为字符串 &lt;code&gt;__main__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee91c879b2d309081471328a6d2e05241079dfda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt;: Every module in Python has a special attribute called &lt;code&gt;__name__&lt;/code&gt;.
It is a built-in variable that returns the name of the module.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; ：Python中的每个模块都有一个名为 &lt;code&gt;__name__&lt;/code&gt; 的特殊属性。 它是一个内置变量，返回模块的名称。</target>
        </trans-unit>
        <trans-unit id="78840eb1470db249624c988b713afc3e97a69c78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; is basically the top-level script environment, and it specifies the interpreter that ('I have the highest priority to be executed first').</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 基本上是顶级脚本环境，并且它指定解释器（&amp;ldquo;我具有首先执行的最高优先级&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="2340c4517f7704fbff95ab3e637235230b8ccc11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; is the part that runs when the script is run from (say) the command line using a command like &lt;code&gt;python myscript.py&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; 是使用（例如） &lt;code&gt;python myscript.py&lt;/code&gt; 之类的命令从（例如）命令行运行脚本时运行的部分。</target>
        </trans-unit>
        <trans-unit id="018c83f2b5e1ed2102eb4e0da64ee296a8027e39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import a&lt;/code&gt; action actually runs all that can be ran in &quot;a&quot;</source>
          <target state="translated">&lt;code&gt;import a&lt;/code&gt; 操作实际上会运行所有可以在&amp;ldquo; a&amp;rdquo;中运行的操作</target>
        </trans-unit>
        <trans-unit id="df08731afb7c7ed2393aaa3f368ad0bb925ea7df" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Before explaining anything about &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; it is important to understand what &lt;code&gt;__name__&lt;/code&gt; is and what it does.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;在解释有关 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 任何内容之前，重要的是要了解 &lt;code&gt;__name__&lt;/code&gt; 是什么以及它的作用。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79da7cc29ac2426a88a714fbfaad47448858fdb1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Now we know the behaviour of &lt;code&gt;__name__&lt;/code&gt; things become clearer:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;现在我们知道 &lt;code&gt;__name__&lt;/code&gt; 的行为变得更清楚了：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6728d8cd0ad927190e1963daa4daa6ea31c0c2f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;example:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="986b24c1aac5848a15ecb03780859084b31b46f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;somefile.py:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;somefile.py:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf1a9df34745e53acb5ed83d94dcb4372a21cee0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;test_file.py:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;test_file.py:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf539f837085192b477057fecbecb42c7bb86636" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;test_file.py&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;test_file.py&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="9b690b9867f89d5298a09814a6babe01c9bf70c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1st possibility: Import &lt;code&gt;my_test_module.py&lt;/code&gt; in another module&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;第一种可能性：在另一个模块中导入 &lt;code&gt;my_test_module.py&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ac4feb6fd281aa9afa7bdda0ab2e439dc46fad0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2nd possibility: Invoke &lt;code&gt;my_test_module.py&lt;/code&gt; as a script&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;my_test_module.py&lt;/code&gt; 可能性：调用my_test_module.py作为脚本&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc1f82081899627449ae26dee60c95d25b23c96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Summary&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Summary&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49a14964903307d811b50a88b1ff45287fbcbe6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Always&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Always&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0f57c51335086529afb8880f52e400970642376" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Executing only if the file is a module or package:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;仅当文件是模块或软件包时才执行：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58b371b66c6af23b26eadee978e7565caf07d812" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In short&lt;/strong&gt;, use this '&lt;code&gt;if __name__ == &quot;main&quot;&lt;/code&gt; ' block to prevent (certain) code from being run when the module is imported.</source>
          <target state="translated">&lt;strong&gt;简而言之&lt;/strong&gt; ，使用此' &lt;code&gt;if __name__ == &quot;main&quot;&lt;/code&gt; '块可防止在导入模块时运行（某些）代码。</target>
        </trans-unit>
        <trans-unit id="25c82edc0cf6b044fa8902f9ff4abb5f517318e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interpreter:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Interpreter:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9ed28c097ebb85433364ac1f4e044499a4d8c6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Module or package:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;模块或包装：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1693186367529d23d67840c6cb92fd7b90836c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modules:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Modules:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bca1585410631753dd411aa2077f9de811966cd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now to answer &lt;code&gt;if __name__ == '__main__'&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;现在回答 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="230a303facf1a2101a405f86dcdb8fcb53a82aea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only When Your Module Is Imported by Another&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;仅当您的模块由另一个导入时&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98cb0f812771c34b1e9af7b910b6edb79e3ec992" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only When Your Module Is the Main Program&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;仅当您的模块是主程序时&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecabc97610f091b28f299c3556ae2c2c8ba7ed78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Practice:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Practice:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25c5146cc441b2968a8c82ef2238dbdcc07728f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Running one condition if the file is the main one and another if it is not:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果文件是主文件，则运行一个条件，如果文件不是主文件，则运行另一个条件：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15379d1a1ff9a18caec0d1609f2db4600cd6fe75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Script:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Script:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00e3df3306b151747da81b3135f8996102b6398c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variants:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Variants:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a427fb5acc312c062284737d9919ea80c80c0203" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is &lt;code&gt;__name__&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;__name__&lt;/code&gt; 是什么 ？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f2823989afe8101f68c8c884942631f433adaa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Your Module Is Imported By Another&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;当您的模块由另一个导入时&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f40fc5f6f2fe7685a294e653a18be70c2bdc7f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Your Module Is the Main Program&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;当您的模块是主程序时&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8da700b6247cf29cd4fd28b742f87b159469d2d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Where:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Where:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e57f67deaea1f928eb43934d908849cb2ac5b721" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;a&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;a&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="433798c30d6b2ba5b1b05b05cff30873a8571d47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;b&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;b&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02f26958ff8bbfffbe238764a41e6feacde136f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fibo.py (a module named &lt;code&gt;fibo&lt;/code&gt;)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;fibo.py（名为fibo的模块）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf22c4f6ccae5c5a45f16a6c1118de9c5f963fef" translate="yes" xml:space="preserve">
          <source>A Better Way</source>
          <target state="translated">更好的方法</target>
        </trans-unit>
        <trans-unit id="cf8a62e672a3b4293103f254c2a62d76c46512dd" translate="yes" xml:space="preserve">
          <source>A side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using &lt;code&gt;main()&lt;/code&gt; as the entry point, &lt;em&gt;but you don't have to&lt;/em&gt;. While &lt;code&gt;setup.py&lt;/code&gt; expects &lt;code&gt;main()&lt;/code&gt;, other tools use alternate entry points. For example, to run your file as a &lt;code&gt;gunicorn&lt;/code&gt; process, you define an &lt;code&gt;app()&lt;/code&gt; function instead of a &lt;code&gt;main()&lt;/code&gt;. Just as with &lt;code&gt;setup.py&lt;/code&gt;, &lt;code&gt;gunicorn&lt;/code&gt; imports your code so you don't want it do do anything while it's being imported (because of the import lock issue).</source>
          <target state="translated">副作用是您自动登录支持多个入口点的方法。 您可以使用 &lt;code&gt;main()&lt;/code&gt; 作为入口点运行程序， &lt;em&gt;但不必这样做&lt;/em&gt; 。 &lt;code&gt;setup.py&lt;/code&gt; 需要 &lt;code&gt;main()&lt;/code&gt; 时 ，其他工具使用备用入口点。 例如，要将文件作为 &lt;code&gt;gunicorn&lt;/code&gt; 进程运行，请定义 &lt;code&gt;app()&lt;/code&gt; 函数而不是 &lt;code&gt;main()&lt;/code&gt; 。 就像 &lt;code&gt;setup.py&lt;/code&gt; 一样 ， &lt;code&gt;gunicorn&lt;/code&gt; 会导入您的代码，因此您不希望它在导入时执行任何操作（由于导入锁定问题）。</target>
        </trans-unit>
        <trans-unit id="1279ac465ae03ccecc8242e951637177d836eac0" translate="yes" xml:space="preserve">
          <source>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.</source>
          <target state="translated">在设置好特殊变量后,解释器会执行模块中的所有代码,一条一条语句的执行。你可能想在边上打开另一个窗口与代码示例,这样你就可以跟上这个解释。</target>
        </trans-unit>
        <trans-unit id="383d69461af4204128d7a2e22e0747b27e8c41c3" translate="yes" xml:space="preserve">
          <source>Again, there will be exceptions, but common practice is that &lt;code&gt;main()&lt;/code&gt; doesn't usually get called externally. So you may be wondering one more thing: if we're not calling &lt;code&gt;main()&lt;/code&gt;, why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this:</source>
          <target state="translated">同样，会有例外，但是通常的做法是 &lt;code&gt;main()&lt;/code&gt; 通常不会在外部调用。 因此，您可能想知道又一件事：如果我们不调用 &lt;code&gt;main()&lt;/code&gt; ，为什么还要调用脚本呢？ 这是因为许多人使用独立的函数来构造脚本，这些独立的函数旨在独立于文件中的其余代码运行。 然后，在脚本主体的其他位置调用它们。 这使我想到了这一点：</target>
        </trans-unit>
        <trans-unit id="a358e3aa692468b145f1d8ad7d489a6ccc1f8b13" translate="yes" xml:space="preserve">
          <source>All the answers have pretty much explained the functionality. But I will provide one example of its usage which might help clearing out the concept further.</source>
          <target state="translated">所有的答案已经基本解释了功能。但我将举一个例子来说明它的用法,这可能有助于进一步理清概念。</target>
        </trans-unit>
        <trans-unit id="728913bf30e6213619a10923f8ca08b92f0ccf99" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#if-statements&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; is a flow control statement that contains the block of code will execute if the value given is true. We have seen that &lt;code&gt;__name__&lt;/code&gt; can take either 
&lt;code&gt;__main__&lt;/code&gt; or the file name it has been imported from.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#if-statements&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;给定的值为true，则将执行if是包含代码块的流控制语句。 我们已经看到 &lt;code&gt;__name__&lt;/code&gt; 可以采用 &lt;code&gt;__main__&lt;/code&gt; 或从中导入的文件名。</target>
        </trans-unit>
        <trans-unit id="291a6a1c87e677da65912996bc98ea09be8c889c" translate="yes" xml:space="preserve">
          <source>An Even Better Way</source>
          <target state="translated">一个更好的方法</target>
        </trans-unit>
        <trans-unit id="e25027686192c6d115ffa987e895d2c366f4813e" translate="yes" xml:space="preserve">
          <source>And a second file &quot;xy.py&quot;:</source>
          <target state="translated">还有第二个文件 &quot;xy.py&quot;。</target>
        </trans-unit>
        <trans-unit id="56bea24f0fbd1f255ecadf46a21ba6a136330f7a" translate="yes" xml:space="preserve">
          <source>And the output from executing script2 is:</source>
          <target state="translated">而执行脚本2的输出是。</target>
        </trans-unit>
        <trans-unit id="32c90a0b6a16423e14ed51492f9d35d3262ee3dc" translate="yes" xml:space="preserve">
          <source>And then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome.</source>
          <target state="translated">然后你还得记住你的测试函数调用是否注释过了。而这种额外的复杂性会意味着你很可能会忘记,让你的开发过程更加麻烦。</target>
        </trans-unit>
        <trans-unit id="27665df0153065e46daf1f28871bd9475bf8e1d5" translate="yes" xml:space="preserve">
          <source>Another benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:</source>
          <target state="translated">使用这个构造的另一个好处是:你还可以在另一个脚本中以模块的形式导入代码,然后在程序决定的时候,如果你的程序决定了,就可以运行主函数。</target>
        </trans-unit>
        <trans-unit id="e24f293208b0bd554685671142f6ee40f5264006" translate="yes" xml:space="preserve">
          <source>Another one.</source>
          <target state="translated">又是一个。</target>
        </trans-unit>
        <trans-unit id="490e331532fa57020b75e3d7497ad0ed1e28417b" translate="yes" xml:space="preserve">
          <source>Any other script that's called from this &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; script is assigned its filename as its &lt;code&gt;__name__&lt;/code&gt; (e.g., &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt;). Hence, the line &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally.</source>
          <target state="translated">从该 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 脚本调用的任何其他脚本 &lt;code&gt;__name__&lt;/code&gt; 分配其文件名作为其__name__ （例如 &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt; ）。 因此， &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 是解释程序的测试，以确定它是否正在解释/解析最初执行的&amp;ldquo; home&amp;rdquo;脚本，或者它是否正在临时窥视另一个（外部）脚本。 如果脚本是直接执行还是外部调用，这使程序员可以灵活地使脚本的行为有所不同。</target>
        </trans-unit>
        <trans-unit id="4f021478ef2f8fb352704d122ccd48a0f448bb10" translate="yes" xml:space="preserve">
          <source>As an example, consider the following module &lt;code&gt;my_test_module.py&lt;/code&gt;:</source>
          <target state="translated">例如，考虑以下模块 &lt;code&gt;my_test_module.py&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c8214b3e3fc0c1096a5057a6fbcda3ca94b4ab14" translate="yes" xml:space="preserve">
          <source>As by default (when module running as main, not imported) the &lt;code&gt;__name__&lt;/code&gt; variable is set to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;, and when it'll be imported the &lt;code&gt;__name__&lt;/code&gt; variable will get a different value, most probably the name of the module (&lt;code&gt;'M'&lt;/code&gt;).
This is helpful in running different variants of a modules together, and separating their specific input &amp;amp; output statements and also if there are any test-cases.</source>
          <target state="translated">默认情况下（当模块作为主模块运行而不是导入时）， &lt;code&gt;__name__&lt;/code&gt; 变量设置为 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; ，并且在导入时， &lt;code&gt;__name__&lt;/code&gt; 变量将获得不同的值，很可能是模块的名称（ &lt;code&gt;'M'&lt;/code&gt; ）。 这有助于一起运行模块的不同变体，分离其特定的输入和输出语句，以及是否存在任何测试用例。</target>
        </trans-unit>
        <trans-unit id="0fb36a6c33279c346eb468f0e09c25e124f94cda" translate="yes" xml:space="preserve">
          <source>As the only special case, however, in whatever Python process you run, as in mycode.py:</source>
          <target state="translated">然而,作为唯一的特殊情况,无论你运行的Python进程中,如mycode.py。</target>
        </trans-unit>
        <trans-unit id="77a8033bf10bed893a83d034163981dde9b5ee97" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;__name__&lt;/code&gt; tells us which code is the 'main' module.
This is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a 'main' function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.</source>
          <target state="translated">如您所见， &lt;code&gt;__name__&lt;/code&gt; 告诉我们哪个代码是&amp;ldquo;主&amp;rdquo;模块。 这很棒，因为您只需编写代码，而不必担心C / C ++中的结构性问题，在这种情况下，如果文件未实现&amp;ldquo; main&amp;rdquo;功能，则无法将其编译为可执行文件，如果可以，然后它不能用作库。</target>
        </trans-unit>
        <trans-unit id="c45bdc9c773c22c178338f1dc79c2aa63246ed33" translate="yes" xml:space="preserve">
          <source>As you can see, when a file is executed, Python sets &lt;code&gt;globals()['__name__']&lt;/code&gt; in this file to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;. This time, the &lt;code&gt;if&lt;/code&gt; statement evaluates to &lt;code&gt;True&lt;/code&gt; and is being run.</source>
          <target state="translated">如您所见，执行文件时，Python将此文件中的 &lt;code&gt;globals()['__name__']&lt;/code&gt; 设置为 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 。 这次， &lt;code&gt;if&lt;/code&gt; 语句的计算结果为 &lt;code&gt;True&lt;/code&gt; ，并且正在运行。</target>
        </trans-unit>
        <trans-unit id="fa35fc2b3ffb5707c6ed36201d14709b2795177a" translate="yes" xml:space="preserve">
          <source>As you can see, when a module is imported, Python sets &lt;code&gt;globals()['__name__']&lt;/code&gt; in this module to the module's name. Also, upon import all the code in the module is being run. As the &lt;code&gt;if&lt;/code&gt; statement evaluates to &lt;code&gt;False&lt;/code&gt; this part is not executed.</source>
          <target state="translated">如您所见，导入模块时，Python将此模块中的 &lt;code&gt;globals()['__name__']&lt;/code&gt; 设置为模块名称。 同样，在导入时，模块中的所有代码都在运行。 由于 &lt;code&gt;if&lt;/code&gt; 语句的计算结果为 &lt;code&gt;False&lt;/code&gt; ,因此不会执行此部分。</target>
        </trans-unit>
        <trans-unit id="4174aeb05b05eec8583dcae607865c6ef32ba122" translate="yes" xml:space="preserve">
          <source>Assume that you have two Python files, a.py and b.py. Now, a.py imports b.py. We run the a.py file, where the &quot;import b.py&quot; code is executed first. Before the rest of the a.py code runs, the code in the file b.py must run completely.</source>
          <target state="translated">假设你有两个Python文件,a.py和b.py。现在,a.py 导入 b.py。我们运行a.py文件,其中 &quot;导入b.py &quot;代码首先执行。在a.py的其他代码运行之前,必须先运行b.py文件中的代码。</target>
        </trans-unit>
        <trans-unit id="53de5b46d0fbb20fff33ad741960e992c53e5836" translate="yes" xml:space="preserve">
          <source>Based on the mechanism how python sets the variable &lt;code&gt;__name__&lt;/code&gt; for each module, do you know how to achieve point 3? The answer is fairly easy, right? Put a if condition: &lt;code&gt;if __name__ == &quot;__main__&quot;: ...&lt;/code&gt;; you can even put if &lt;code&gt;__name__ == &quot;a&quot;&lt;/code&gt; depending on your functional need</source>
          <target state="translated">根据python如何为每个模块设置变量 &lt;code&gt;__name__&lt;/code&gt; 的机制，您知道如何实现第3点吗？ 答案很简单，对吧？ 放置一个if条件： &lt;code&gt;if __name__ == &quot;__main__&quot;: ...&lt;/code&gt; ; 您甚至可以根据自己的功能需要输入 &lt;code&gt;__name__ == &quot;a&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5daba4bc12144be47ac4ef97123506a5d670ee9" translate="yes" xml:space="preserve">
          <source>Because of point 1, you may not want everything to be run in &quot;a&quot; when importing it</source>
          <target state="translated">因为第1点,你可能不希望所有的东西在导入时都在 &quot;a &quot;中运行</target>
        </trans-unit>
        <trans-unit id="5555032fd1fd8c47f02216cf05cff7797235c4eb" translate="yes" xml:space="preserve">
          <source>Before the interpreter executes the source code file though, it defines a few special variables for that file; &lt;strong&gt;__name__&lt;/strong&gt; is one of those special variables that Python automatically defines for each source code file.</source>
          <target state="translated">但是，在解释器执行源代码文件之前，它会为该文件定义一些特殊的变量。 &lt;strong&gt;__name__&lt;/strong&gt;是Python为每个源代码文件自动定义的那些特殊变量之一。</target>
        </trans-unit>
        <trans-unit id="be4403cc17466eedfa891d4a51f7740fa3d7f3f3" translate="yes" xml:space="preserve">
          <source>Being a variable means that it's value &lt;em&gt;can&lt;/em&gt; be overwritten (&quot;can&quot; does not mean &quot;should&quot;), overwriting the value of &lt;code&gt;__name__&lt;/code&gt; will result in a lack of readability.  So do not do it, for any reason.  If you need a variable define a new variable.</source>
          <target state="translated">作为变量意味着它的值&lt;em&gt;可以&lt;/em&gt;被覆盖（&amp;ldquo;可以&amp;rdquo;并不意味着&amp;ldquo;应该&amp;rdquo;），覆盖 &lt;code&gt;__name__&lt;/code&gt; 的值将导致缺乏可读性。 因此，无论出于任何原因都不要这样做。 如果需要变量，请定义一个新变量。</target>
        </trans-unit>
        <trans-unit id="cdba82558e6d2b296c8fda06454da814e1ab4ab2" translate="yes" xml:space="preserve">
          <source>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. &quot;Running&quot; the script is a side effect of importing the script's module.</source>
          <target state="translated">除了这些例子之外,在Python中运行一个脚本只是设置几个神奇的变量,然后导入脚本,这很优雅。&quot;运行 &quot;脚本是导入脚本的模块的一个副作用。</target>
        </trans-unit>
        <trans-unit id="7fdb9a68214237799e539012c1ae04b1ee6fcbff" translate="yes" xml:space="preserve">
          <source>Blocks A and B are run when we are running &quot;x.py&quot;.</source>
          <target state="translated">当我们运行 &quot;x.py &quot;时,A和B区块被运行。</target>
        </trans-unit>
        <trans-unit id="51aacee3ee9f4b0785c1a298e8721c7f3d008776" translate="yes" xml:space="preserve">
          <source>But inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.</source>
          <target state="translated">但是在主模块（或交互式Python会话，即解释器的Read，Eval，Print Loop或REPL）中，您正在运行其 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d45165ec85f4c41aac136977806fa7b3e1b0399" translate="yes" xml:space="preserve">
          <source>But just block A (and not B) is run when we are running another module, &quot;y.py&quot; for example, in which x.y is imported and the code is run from there (like when a function in &quot;x.py&quot; is called from y.py).</source>
          <target state="translated">但只是块A(而不是B)是在我们运行另一个模块 &quot;y.py &quot;的时候运行的,比如说 &quot;y.py &quot;中的x.y被导入,代码从那里运行(比如说 &quot;x.py &quot;中的一个函数从y.py中调用)。</target>
        </trans-unit>
        <trans-unit id="187017f79b4f4176019be635feccedac47d394a8" translate="yes" xml:space="preserve">
          <source>But that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.</source>
          <target state="translated">但这是一个脚本,可能不能让它的函数被外部调用,因为如果它这样做,它就会立即开始计算和分配变量。而且如果你想重新使用一个函数,你的新脚本和旧脚本的关系足够密切,很可能会出现冲突的变量。</target>
        </trans-unit>
        <trans-unit id="e0cc7be78b4f7426e808a9f14bb2ee02b52a60bf" translate="yes" xml:space="preserve">
          <source>But the code works without it</source>
          <target state="translated">但没有它,代码也能用</target>
        </trans-unit>
        <trans-unit id="b868b03c6a857fb43254a438d5d2b52f62b19ea2" translate="yes" xml:space="preserve">
          <source>Call the class from other files. You just have to import it in the calling program.</source>
          <target state="translated">从其他文件中调用类。你只需要在调用程序中导入就可以了。</target>
        </trans-unit>
        <trans-unit id="d1249e34e446972c34012a866f67bc184db7bc52" translate="yes" xml:space="preserve">
          <source>Code Sample</source>
          <target state="translated">代码样本</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="9274899889be8b8adc4e3be4ea8d4a133c134b2d" translate="yes" xml:space="preserve">
          <source>Create a file, &lt;strong&gt;a.py&lt;/strong&gt;:</source>
          <target state="translated">创建一个文件&lt;strong&gt;a.py&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="56a0a9523b0c4b5eb5e2bbdb33ad60b126caa07f" translate="yes" xml:space="preserve">
          <source>Create another file, &lt;strong&gt;b.py&lt;/strong&gt;, in the same directory:</source>
          <target state="translated">在同一目录中创建另一个文件&lt;strong&gt;b.py&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="cd3b4d3abc33414ae3e100a1d6cbfe6b75ea5eb4" translate="yes" xml:space="preserve">
          <source>Create the following files.</source>
          <target state="translated">创建以下文件:</target>
        </trans-unit>
        <trans-unit id="28d96b6441a5da8450600f4898f133fbdd6961e4" translate="yes" xml:space="preserve">
          <source>Developing and Testing Your Code</source>
          <target state="translated">开发和测试你的代码</target>
        </trans-unit>
        <trans-unit id="6bc05812a294f6f7a5f9e19db22d8cd3b2afc410" translate="yes" xml:space="preserve">
          <source>End of file; back to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;!</source>
          <target state="translated">文件结尾； 回到 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="ccf898dbe57906e5594bcd719f8b93726090fd0d" translate="yes" xml:space="preserve">
          <source>Every module in python has a attribute called &lt;code&gt;__name__&lt;/code&gt;. The value of &lt;code&gt;__name__&lt;/code&gt;  attribute is  &lt;code&gt;__main__&lt;/code&gt;  when the module is run directly, like &lt;code&gt;python my_module.py&lt;/code&gt;. Otherwise (like when you say &lt;code&gt;import my_module&lt;/code&gt;) the value of &lt;code&gt;__name__&lt;/code&gt;  is the name of the module.</source>
          <target state="translated">python中的每个模块都有一个名为 &lt;code&gt;__name__&lt;/code&gt; 的属性。 当模块直接运行时，例如 &lt;code&gt;python my_module.py&lt;/code&gt; ， &lt;code&gt;__name__&lt;/code&gt; 属性的值为 &lt;code&gt;__main__&lt;/code&gt; 。 否则（如您说 &lt;code&gt;import my_module&lt;/code&gt; ）， &lt;code&gt;__name__&lt;/code&gt; 的值就是模块的名称。</target>
        </trans-unit>
        <trans-unit id="8ea353689f62515305875bd4c1491c1b1eda4969" translate="yes" xml:space="preserve">
          <source>Executing the Module's Code</source>
          <target state="translated">执行模块的代码</target>
        </trans-unit>
        <trans-unit id="decbc65feed3492d925a3828afa0685ee965a44f" translate="yes" xml:space="preserve">
          <source>Food for Thought</source>
          <target state="translated">思考的食物</target>
        </trans-unit>
        <trans-unit id="c01b0b737be74a6ef3efec2d9c67ec6b0e73c2dd" translate="yes" xml:space="preserve">
          <source>For the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label &lt;code&gt;'__main__'&lt;/code&gt;.</source>
          <target state="translated">对于后一种情况，该类应包含一个公共的静态void main（）方法。 在Python中，此目的由全局定义的标签 &lt;code&gt;'__main__'&lt;/code&gt; 实现 。</target>
        </trans-unit>
        <trans-unit id="06c6abe53de8158ff545ff3025465ac568502266" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;x()&lt;/code&gt;; ok, printing '&lt;em&gt;peripheral task: might be useful in other projects&lt;/em&gt;'.</source>
          <target state="translated">函数 &lt;code&gt;x()&lt;/code&gt; ; 好的，打印&amp;ldquo; &lt;em&gt;外围任务：在其他项目中可能有用&lt;/em&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="270272d52b278ed4834707720d02142b04dac683" translate="yes" xml:space="preserve">
          <source>Given the following code, what does the &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; do?</source>
          <target state="translated">给定以下代码， &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 怎么办？</target>
        </trans-unit>
        <trans-unit id="c532f4344993da004ef0d886409dd1dc176dd817" translate="yes" xml:space="preserve">
          <source>Hope this helps out.</source>
          <target state="translated">希望这对你有帮助。</target>
        </trans-unit>
        <trans-unit id="7cf7df778e073d4ee9549c9276978c839886daaf" translate="yes" xml:space="preserve">
          <source>However, if you want to import the module to another script:</source>
          <target state="translated">但是,如果你想把模块导入到另一个脚本中。</target>
        </trans-unit>
        <trans-unit id="3f7f6f7cdf15bc15aa54e3347e678918567e405d" translate="yes" xml:space="preserve">
          <source>However, if your Python script is used by a module, any code outside of the &lt;code&gt;if&lt;/code&gt; statement will be executed, so &lt;code&gt;if \__name__ == &quot;\__main__&quot;&lt;/code&gt; is used just to check if the program is used as a module or not, and therefore decides whether to run the code.</source>
          <target state="translated">但是，如果模块使用了您的Python脚本，则将执行 &lt;code&gt;if&lt;/code&gt; 语句之外的任何代码，因此 &lt;code&gt;if \__name__ == &quot;\__main__&quot;&lt;/code&gt; 仅用于检查程序是否用作模块，并且因此决定是否运行代码。</target>
        </trans-unit>
        <trans-unit id="27aee883b9125fa742bdc6ce62419f671fc09b30" translate="yes" xml:space="preserve">
          <source>I am not saying you should use this in production code, but it serves to illustrate that there is nothing &quot;magical&quot; about &lt;code&gt;if __name__ == '__main__'&lt;/code&gt;. It is a good convention for invoking a main function in Python files.</source>
          <target state="translated">我并不是说您应该在生产代码中使用它，但这只是说明 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 并没有什么&amp;ldquo;魔术&amp;rdquo;。 在Python文件中调用主函数是一个很好的约定。</target>
        </trans-unit>
        <trans-unit id="7aaee90df97cdf574f54c44ac544ddfd2ecf3202" translate="yes" xml:space="preserve">
          <source>I think it's best to break the answer in depth and in simple words:</source>
          <target state="translated">我认为最好是用简单的文字深入浅出地把答案打破。</target>
        </trans-unit>
        <trans-unit id="2d610a68610206f4422d124c53fd2b4ef28bb011" translate="yes" xml:space="preserve">
          <source>I've been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused.</source>
          <target state="translated">我在这一页的答案里,看了这么多。我想说的是,如果你知道这个事情,肯定会明白这些答案,否则,你还是糊涂了。</target>
        </trans-unit>
        <trans-unit id="7dc8666b8e0d5305ca6686fcdd3a64aa30613f45" translate="yes" xml:space="preserve">
          <source>If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special &lt;strong&gt;__name__&lt;/strong&gt; variable for this file to have a value &lt;strong&gt;&quot;__main__&quot;&lt;/strong&gt;.</source>
          <target state="translated">如果Python将这个源代码文件作为主程序加载（即，您运行的文件），那么它将为此文件设置特殊的&lt;strong&gt;__name__&lt;/strong&gt;变量，使其具有值&lt;strong&gt;&amp;ldquo; __main__&amp;rdquo;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a009492026900b4a9397225067c6a9f84f8e1216" translate="yes" xml:space="preserve">
          <source>If indeed &lt;code&gt;__name__&lt;/code&gt; does take the value of &lt;code&gt;__main__&lt;/code&gt; then whatever is in that block of code will execute.</source>
          <target state="translated">如果确实 &lt;code&gt;__name__&lt;/code&gt; 确实采用 &lt;code&gt;__main__&lt;/code&gt; 的值，那么该代码块中的所有内容都将执行。</target>
        </trans-unit>
        <trans-unit id="0a6d69f64768205bc73fd5ba1367e74b8059c5c0" translate="yes" xml:space="preserve">
          <source>If the python interpreter is running&amp;nbsp;a particular module then &lt;code&gt;__name__&lt;/code&gt; global  variable will have value &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;</source>
          <target state="translated">如果python解释器正在运行特定模块，则 &lt;code&gt;__name__&lt;/code&gt; 全局变量将具有值 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1094aa47aa3aeccd6ed85b8ebb5ed271222d0e3" translate="yes" xml:space="preserve">
          <source>If this .py are run by &lt;code&gt;python this_py.py&lt;/code&gt; under shell, or double clicked in Windows. the code under &quot;the if statement&quot; will be executed.</source>
          <target state="translated">如果此.py是由 &lt;code&gt;python this_py.py&lt;/code&gt; 在外壳下的this_py.py运行，或在Windows中双击。 &amp;ldquo; if语句&amp;rdquo;下的代码将被执行。</target>
        </trans-unit>
        <trans-unit id="f0f1e75c2a123bfd0fe539932a26c8d0e246a7f1" translate="yes" xml:space="preserve">
          <source>If this .py file are imported by other .py files, the code under &quot;the if statement&quot; will not be executed.</source>
          <target state="translated">如果这个.py文件被其他的.py文件导入,那么 &quot;if语句 &quot;下的代码将不会被执行。</target>
        </trans-unit>
        <trans-unit id="cfc7c4aaf15b28c6320a80c22273eb5bfeb2a46e" translate="yes" xml:space="preserve">
          <source>If this is being imported from another module, &lt;strong&gt;__name__&lt;/strong&gt; will be set to that module's name.</source>
          <target state="translated">如果是从另一个模块导入的， &lt;strong&gt;则将__name__&lt;/strong&gt;设置为该模块的名称。</target>
        </trans-unit>
        <trans-unit id="6523f8ca1b9a6c1da707b351f493c4cbbace2647" translate="yes" xml:space="preserve">
          <source>If we put the code we want to exercise as we develop and test in a function like this and then do our check for &lt;code&gt;'__main__'&lt;/code&gt; immediately after:</source>
          <target state="translated">如果我们放上我们想在开发和测试这样的函数时使用的代码，然后在执行以下操作时立即检查 &lt;code&gt;'__main__'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc80bf0204f13ba7089b5451f461bfc665cec29b" translate="yes" xml:space="preserve">
          <source>If we run the code directly via &lt;code&gt;python test.py&lt;/code&gt;, the module name is &lt;code&gt;__main__&lt;/code&gt;:</source>
          <target state="translated">如果我们直接通过 &lt;code&gt;python test.py&lt;/code&gt; 运行代码，则模块名称为 &lt;code&gt;__main__&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a6516beb3b9f8bebd5a8fe5d91c615ccfb9500a4" translate="yes" xml:space="preserve">
          <source>If you are running your module (the source file) as the main program, e.g.</source>
          <target state="translated">如果你把你的模块(源文件)作为主程序来运行,比如说</target>
        </trans-unit>
        <trans-unit id="5a002ca7d32e704fd426536fc54e7e1e47ad2e8b" translate="yes" xml:space="preserve">
          <source>If you import this file say A to file B  and execute the file B then &lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; in file A becomes false, so it prints  &lt;strong&gt;You can't see me&lt;/strong&gt;</source>
          <target state="translated">如果您导入此文件，请说A到文件B并执行文件B，则 &lt;code&gt;if __name__ == &quot;__main__&quot;&lt;/code&gt; 文件A中的__name__ ==&amp;ldquo; __main__&amp;rdquo;变为false，则它会打印&lt;strong&gt;您看不到我&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bae9f62ff08151418abbbc49ef9673f76cd6210a" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;two.py&lt;/code&gt; instead:</source>
          <target state="translated">如果您改为运行 &lt;code&gt;two.py&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3d5150bf1d7adcfd96cab36821f53eb6a118618d" translate="yes" xml:space="preserve">
          <source>If your module is the main program, then it will see that &lt;code&gt;__name__&lt;/code&gt; was indeed set to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; and it calls the two functions, printing the strings &lt;code&gt;&quot;Function A&quot;&lt;/code&gt; and &lt;code&gt;&quot;Function B 10.0&quot;&lt;/code&gt;.</source>
          <target state="translated">如果您的模块是主程序，那么它将看到 &lt;code&gt;__name__&lt;/code&gt; 确实设置为 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 并且它将调用两个函数，分别打印字符串 &lt;code&gt;&quot;Function A&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;Function B 10.0&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dec279dce56fe81437675634947d0898c2cd9a40" translate="yes" xml:space="preserve">
          <source>If your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the &lt;code&gt;if&lt;/code&gt; clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:</source>
          <target state="translated">如果将脚本导入另一个模块，则将导入其各种功能和类定义，并执行其顶层代码，但上述 &lt;code&gt;if&lt;/code&gt; 子句的then-body中的代码将不会作为条件运行不符合。 作为一个基本示例，请考虑以下两个脚本：</target>
        </trans-unit>
        <trans-unit id="47cbbcfd6a2d88e3b7665ea5155dcef87bbe0234" translate="yes" xml:space="preserve">
          <source>Import and open file with the &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt;.</source>
          <target state="translated">导入并使用 &lt;code&gt;__name__ == &quot;ab.py&quot;&lt;/code&gt; 打开文件。</target>
        </trans-unit>
        <trans-unit id="4339fb8da56f030c085b801561fcd6353668defe" translate="yes" xml:space="preserve">
          <source>In other words, the code within the &lt;code&gt;if&lt;/code&gt; block will be executed only when the code runs directly. Here &lt;code&gt;directly&lt;/code&gt; means &lt;code&gt;not imported&lt;/code&gt;.</source>
          <target state="translated">换句话说，仅当直接运行代码时，才会执行 &lt;code&gt;if&lt;/code&gt; 块中的代码。 这里 &lt;code&gt;directly&lt;/code&gt; 表示 &lt;code&gt;not imported&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ef3470680942e6fd3926f3ffbec1e8810ecf8fb" translate="yes" xml:space="preserve">
          <source>In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, &quot;example.py&quot; might import &quot;xy.py&quot; and call &lt;code&gt;x()&lt;/code&gt;, making use of the 'x' function from &quot;xy.py&quot;. (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)</source>
          <target state="translated">在拆分独立功能时，您可以通过将其调用到另一个脚本中来重用以前的工作。 例如，&amp;ldquo; example.py&amp;rdquo;可能会导入&amp;ldquo; xy.py&amp;rdquo;并调用 &lt;code&gt;x()&lt;/code&gt; ，从而利用&amp;ldquo; xy.py&amp;rdquo;中的&amp;ldquo; x&amp;rdquo;功能。 （也许是将给定文本字符串的第三个单词大写；从一个数字列表中创建一个NumPy数组并对其进行平方；或者对3D表面进行趋势处理。这种可能性是无限的。）</target>
        </trans-unit>
        <trans-unit id="d853790bb43ec92bf806d95fb5eb4681a4a8a3c8" translate="yes" xml:space="preserve">
          <source>In summary, here's what'd be printed in the two cases:</source>
          <target state="translated">综上所述,以下是两个案例中会印的内容。</target>
        </trans-unit>
        <trans-unit id="1f0a6937d20af80d3078dedc2606cc5a59b0e220" translate="yes" xml:space="preserve">
          <source>In the b.py code there is some code that is exclusive to that file b.py and we don't want any other file (other than b.py file), that has imported the b.py file, to run it.</source>
          <target state="translated">在b.py代码中,有一些代码是该文件b.py独有的,我们不希望其他任何导入了b.py文件的文件(除b.py文件外)运行它。</target>
        </trans-unit>
        <trans-unit id="260ca32c942591fccd6abb92b2ac85ea296638c3" translate="yes" xml:space="preserve">
          <source>In this case, the top-level code is an &lt;code&gt;if&lt;/code&gt; block.  &lt;code&gt;__name__&lt;/code&gt; is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in &lt;code&gt;myscript.py&lt;/code&gt; above), then &lt;code&gt;__name__&lt;/code&gt; instead is set to the string &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.  Thus, you can test whether your script is being run directly or being imported by something else by testing</source>
          <target state="translated">在这种情况下，顶级代码是 &lt;code&gt;if&lt;/code&gt; 块。 &lt;code&gt;__name__&lt;/code&gt; 是一个内置变量，其结果为当前模块的名称。 但是，如果直接运行模块（如上述 &lt;code&gt;myscript.py&lt;/code&gt; 中所述），则将 &lt;code&gt;__name__&lt;/code&gt; 设置为字符串 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 。 因此，您可以通过测试来测试您的脚本是直接运行还是通过其他方式导入</target>
        </trans-unit>
        <trans-unit id="fc7351db8caa3bc174e3dab9c38941592f350c9e" translate="yes" xml:space="preserve">
          <source>Inside an imported module, it's the name of that module.</source>
          <target state="translated">在一个导入的模块里面,就是这个模块的名字。</target>
        </trans-unit>
        <trans-unit id="600ec79b4436fd522224aeb5e817487e39bf7c75" translate="yes" xml:space="preserve">
          <source>It allows the code in the module to be importable by other modules, without executing the code block beneath on import.</source>
          <target state="translated">它允许模块中的代码可以被其他模块导入,而无需在导入时执行下面的代码块。</target>
        </trans-unit>
        <trans-unit id="675efdeb054d458c04693317ce35a181157e918e" translate="yes" xml:space="preserve">
          <source>It also allows modules to be run from the command line as main scripts, which can be also very useful.</source>
          <target state="translated">它还允许将模块作为主脚本从命令行中运行,这也是非常有用的。</target>
        </trans-unit>
        <trans-unit id="54b2453f92e0d3e4d73f97207fe07c2dc556e48a" translate="yes" xml:space="preserve">
          <source>It can not only be used in scripts but can also be found in both the interpreter and modules/packages.</source>
          <target state="translated">它不仅可以在脚本中使用,也可以在解释器和模块包中找到。</target>
        </trans-unit>
        <trans-unit id="3528aa55d868a317f591f6ee9b7618c515d6e0af" translate="yes" xml:space="preserve">
          <source>It checks if a module is being imported or not.</source>
          <target state="translated">它可以检查一个模块是否被导入。</target>
        </trans-unit>
        <trans-unit id="4714816743d3504312c6ed1b30410b9d76cd8f74" translate="yes" xml:space="preserve">
          <source>It checks if the &lt;code&gt;__name__&lt;/code&gt; attribute of the Python script is &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;. In other words, if the program itself is executed, the attribute will be &lt;code&gt;__main__&lt;/code&gt;, so the program will be executed (in this case the &lt;code&gt;main()&lt;/code&gt; function).</source>
          <target state="translated">它检查Python脚本的 &lt;code&gt;__name__&lt;/code&gt; 属性是否为 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 。 换句话说，如果程序本身被执行，则属性将为 &lt;code&gt;__main__&lt;/code&gt; ，因此程序将被执行（在本例中为 &lt;code&gt;main()&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="d45839ba20c9bcb826d469c0e65576dc489d5de3" translate="yes" xml:space="preserve">
          <source>It could be written in several ways. Another is:</source>
          <target state="translated">可以用几种方式来写。另一种是:</target>
        </trans-unit>
        <trans-unit id="72796cbd4b51d3cdeb2d0d02bdcb18094d7dd7ca" translate="yes" xml:space="preserve">
          <source>It executes the &lt;code&gt;def&lt;/code&gt; block, creating a function object, then assigning that function object to a variable called &lt;code&gt;functionA&lt;/code&gt;.</source>
          <target state="translated">它执行 &lt;code&gt;def&lt;/code&gt; 块，创建一个功能对象，然后将该功能对象分配给一个名为 &lt;code&gt;functionA&lt;/code&gt; 的变量。</target>
        </trans-unit>
        <trans-unit id="4a1336d55772c318b9c2339583e8b328d7e55ca8" translate="yes" xml:space="preserve">
          <source>It executes the second &lt;code&gt;def&lt;/code&gt; block, creating another function object, then assigning it to a variable called &lt;code&gt;functionB&lt;/code&gt;.</source>
          <target state="translated">它执行第二个 &lt;code&gt;def&lt;/code&gt; 块，创建另一个函数对象，然后将其分配给名为 &lt;code&gt;functionB&lt;/code&gt; 的变量。</target>
        </trans-unit>
        <trans-unit id="d422f7632b03e10b878e1d03615ebf1e878466d9" translate="yes" xml:space="preserve">
          <source>It is a special for when a Python file is called from the command line. This is typically used to call a &quot;main()&quot; function or execute other appropriate startup code, like commandline arguments handling for instance.</source>
          <target state="translated">它是在命令行中调用Python文件时的特殊功能。它通常用于调用 &quot;main()&quot; 函数或执行其他适当的启动代码,例如命令行参数处理等。</target>
        </trans-unit>
        <trans-unit id="7c5e6e85034260b34583d4b3d062afde5577df61" translate="yes" xml:space="preserve">
          <source>It is a string (global as mentioned above) as indicated by &lt;code&gt;type(__name__)&lt;/code&gt; (yielding &lt;code&gt;&amp;lt;class 'str'&amp;gt;&lt;/code&gt;), and is an inbuilt standard for both &lt;a href=&quot;https://docs.python.org/3/library/__main__.html&quot;&gt;Python 3&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;Python 2&lt;/a&gt; versions.</source>
          <target state="translated">它是一个由 &lt;code&gt;type(__name__)&lt;/code&gt; 表示的字符串（如上所述，是全局的） （产生 &lt;code&gt;&amp;lt;class 'str'&amp;gt;&lt;/code&gt; class'str '&amp;gt; ），并且是&lt;a href=&quot;https://docs.python.org/3/library/__main__.html&quot;&gt;Python 3&lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/2/library/__main__.html&quot;&gt;Python 2&lt;/a&gt;版本的内置标准。</target>
        </trans-unit>
        <trans-unit id="3b32f06639244cd4fe1f298cf6a239029bf115ac" translate="yes" xml:space="preserve">
          <source>It is also possible to do other, less common but useful things with &lt;code&gt;__name__&lt;/code&gt;, some I will show here:</source>
          <target state="translated">也可以使用 &lt;code&gt;__name__&lt;/code&gt; 做其他一些不太常见但有用的事情，我将在这里展示一些：</target>
        </trans-unit>
        <trans-unit id="fa5911f298adfd582f1742f2457c41f8e0363fdb" translate="yes" xml:space="preserve">
          <source>It is always assumed that the value of &lt;code&gt;__name__&lt;/code&gt; to be &lt;code&gt;__main__&lt;/code&gt; or the name of the file.  Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.</source>
          <target state="translated">始终假定 &lt;code&gt;__name__&lt;/code&gt; 的值为 &lt;code&gt;__main__&lt;/code&gt; 或文件名。 再次更改此默认值将引起更多混乱，以至于无法解决问题。</target>
        </trans-unit>
        <trans-unit id="433366427f82e9a941e28039c28d109ea0304b44" translate="yes" xml:space="preserve">
          <source>It is considered good practice in general to include the &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; in scripts.</source>
          <target state="translated">通常，在脚本中包含 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 被认为是一种好习惯。</target>
        </trans-unit>
        <trans-unit id="ae6fdd181016a398f76b7382908ae7290de561a7" translate="yes" xml:space="preserve">
          <source>It is usually written for testing.</source>
          <target state="translated">通常是为测试而写的。</target>
        </trans-unit>
        <trans-unit id="c3402e91991c1a14ff2a75a0ab38e464eb5133ba" translate="yes" xml:space="preserve">
          <source>It loads the &lt;code&gt;math&lt;/code&gt; module and assigns it to a variable called &lt;code&gt;math&lt;/code&gt;. This is equivalent to replacing &lt;code&gt;import math&lt;/code&gt; with the following (note that &lt;code&gt;__import__&lt;/code&gt; is a low-level function in Python that takes a string and triggers the actual import):</source>
          <target state="translated">它加载 &lt;code&gt;math&lt;/code&gt; 模块并将其分配给名为 &lt;code&gt;math&lt;/code&gt; 的变量。 这等效于用以下内容替换 &lt;code&gt;import math&lt;/code&gt; （请注意， &lt;code&gt;__import__&lt;/code&gt; 是Python中的低级函数，它接受字符串并触发实际的导入）：</target>
        </trans-unit>
        <trans-unit id="56f71295dc0080691356ca0c01cec7d37f4e28e9" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before __name__ guard&quot;&lt;/code&gt;.</source>
          <target state="translated">它输出字符串 &lt;code&gt;&quot;before __name__ guard&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2577e5a4b9e5bed19b4432e05d2660faee329607" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before functionA&quot;&lt;/code&gt;.</source>
          <target state="translated">它打印字符串 &lt;code&gt;&quot;before functionA&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="990ff0164122db4967979e56b95623fac83be16d" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before functionB&quot;&lt;/code&gt;.</source>
          <target state="translated">它打印字符串 &lt;code&gt;&quot;before functionB&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67a82144baac90e3bfe77c37b1e7cfd66966d43e" translate="yes" xml:space="preserve">
          <source>It prints the string &lt;code&gt;&quot;before import&quot;&lt;/code&gt; (without quotes).</source>
          <target state="translated">它输出字符串 &lt;code&gt;&quot;before import&quot;&lt;/code&gt; （不带引号）。</target>
        </trans-unit>
        <trans-unit id="487802f670fb40e8bf81d7517f78375a228bb226" translate="yes" xml:space="preserve">
          <source>It will allow the module and its functions and classes to be imported into other scripts without running the &lt;code&gt;main&lt;/code&gt; function, and will also allow the module (and its functions and classes) to be called when running from a different &lt;code&gt;'__main__'&lt;/code&gt; module, i.e.</source>
          <target state="translated">它将允许在不运行 &lt;code&gt;main&lt;/code&gt; 函数的情况下将模块及其功能和类导入其他脚本，并且还允许在从其他 &lt;code&gt;'__main__'&lt;/code&gt; 模块运行时调用模块（及其功能和类），即</target>
        </trans-unit>
        <trans-unit id="db31e7b989046834490a12f44ad8c713989903b9" translate="yes" xml:space="preserve">
          <source>It will print the string &lt;code&gt;&quot;after __name__ guard&quot;&lt;/code&gt; in both situations.</source>
          <target state="translated">在两种情况下，它将在 &lt;code&gt;&quot;after __name__ guard&quot;&lt;/code&gt; 打印字符串。</target>
        </trans-unit>
        <trans-unit id="0640f504c6f1cabceaecd1e002b971be93067ac4" translate="yes" xml:space="preserve">
          <source>Let's look at the answer in a more abstract way:</source>
          <target state="translated">让我们从更抽象的角度来看一下答案。</target>
        </trans-unit>
        <trans-unit id="59c0758ddc6f775006dd70cbf5286216ff0f8137" translate="yes" xml:space="preserve">
          <source>Let's see how this works and how it relates to your question about the &lt;code&gt;__name__&lt;/code&gt; checks we always see in Python scripts.</source>
          <target state="translated">让我们看看它是如何工作的，以及它与您在Python脚本中经常看到的有关 &lt;code&gt;__name__&lt;/code&gt; 检查的问题如何相关。</target>
        </trans-unit>
        <trans-unit id="36e704322c41ccc6a321769ec4f01db18ff86add" translate="yes" xml:space="preserve">
          <source>Let's see what it does using a simple code that prints the name of the module:</source>
          <target state="translated">让我们用一个简单的代码来看看它是怎么做的,它可以打印出模块的名称。</target>
        </trans-unit>
        <trans-unit id="5f645eb565c673e545d1679f2c86c2b42014562e" translate="yes" xml:space="preserve">
          <source>Let's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or &lt;code&gt;def&lt;/code&gt; - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself:</source>
          <target state="translated">让我们逐步看一下上面的代码以了解发生了什么，首先关注未缩进的行及其在脚本中出现的顺序。 请记住，函数或 &lt;code&gt;def&lt;/code&gt; 块在被调用之前不会自行执行任何操作。 如果自言自语，口译员可能会说：</target>
        </trans-unit>
        <trans-unit id="1254a1f938039680c725134df68b131b5aa46dc5" translate="yes" xml:space="preserve">
          <source>Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called &lt;code&gt;foo.py&lt;/code&gt;.</source>
          <target state="translated">让我们使用稍微不同的代码示例来探索导入和脚本的工作方式。 假设以下内容位于名为 &lt;code&gt;foo.py&lt;/code&gt; 的文件中。</target>
        </trans-unit>
        <trans-unit id="842b192efb9c67214acf7a300d55ce4db505bdcc" translate="yes" xml:space="preserve">
          <source>Note that only the top-level &lt;code&gt;print()&lt;/code&gt; statement in &lt;code&gt;my_test_module&lt;/code&gt; is executed.</source>
          <target state="translated">请注意，仅执行 &lt;code&gt;my_test_module&lt;/code&gt; 中的顶级 &lt;code&gt;print()&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="81c6d0a8223e137d4fd96a2fea5acdc58cde2cd7" translate="yes" xml:space="preserve">
          <source>Notice that when used in a package or module, &lt;code&gt;__name__&lt;/code&gt; takes the name of the file.  The path of the actual module or package path is not given, but has its own DunderAlias &lt;code&gt;__file__&lt;/code&gt;, that allows for this.</source>
          <target state="translated">请注意，在包或模块中使用 &lt;code&gt;__name__&lt;/code&gt; 时，使用文件名。 没有给出实际模块或包路径的路径，但是具有其自己的DunderAlias &lt;code&gt;__file__&lt;/code&gt; ，因此可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="cf84fdf12bf682b1e82dc617a50185e488527e76" translate="yes" xml:space="preserve">
          <source>Now if you invoke &lt;code&gt;main.py&lt;/code&gt;:</source>
          <target state="translated">现在，如果您调用 &lt;code&gt;main.py&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7cdbc821008ebfe4fc4cd41f81d12ccd5cec7db9" translate="yes" xml:space="preserve">
          <source>Now if you run &lt;code&gt;my_test_module.py&lt;/code&gt; as a Python script, both &lt;code&gt;print()&lt;/code&gt; statements will be exectued:</source>
          <target state="translated">现在，如果将 &lt;code&gt;my_test_module.py&lt;/code&gt; 作为Python脚本运行，则两个 &lt;code&gt;print()&lt;/code&gt; 语句都将被执行：</target>
        </trans-unit>
        <trans-unit id="3875b0e9c99d33dd9d9117fb278540c718c1625f" translate="yes" xml:space="preserve">
          <source>Now suppose we call above script from other script</source>
          <target state="translated">现在,假设我们从其他脚本中调用上述脚本</target>
        </trans-unit>
        <trans-unit id="32d820770706edc1d47e13dfe4072ab74a677b21" translate="yes" xml:space="preserve">
          <source>Now, figure out what will happen if you remove the &lt;code&gt;__name__&lt;/code&gt; check in &lt;code&gt;foo3.py&lt;/code&gt;:</source>
          <target state="translated">现在，弄清楚如果删除 &lt;code&gt;__name__&lt;/code&gt; 中的__name__检查会发生什么：</target>
        </trans-unit>
        <trans-unit id="f61cdcc0e64bc154546828675c159f927f257516" translate="yes" xml:space="preserve">
          <source>Now, if you invoke the interpreter as</source>
          <target state="translated">现在,如果你调用解释器为</target>
        </trans-unit>
        <trans-unit id="8ca2803175deedc185a32811ae0d215b53994bac" translate="yes" xml:space="preserve">
          <source>Oh, a function. I'll remember that.</source>
          <target state="translated">哦,一个功能。我会记住的。</target>
        </trans-unit>
        <trans-unit id="6077d0ebf452529d19420c847ef52de2a426a2ee" translate="yes" xml:space="preserve">
          <source>Ok, function &lt;code&gt;a()&lt;/code&gt;; I just learned that. Printing '&lt;em&gt;A function in ab file&lt;/em&gt;'.</source>
          <target state="translated">好的，函数 &lt;code&gt;a()&lt;/code&gt; ; 我才知道 打印' &lt;em&gt;ab文件中&lt;/em&gt;的&lt;em&gt;函数&lt;/em&gt; '。</target>
        </trans-unit>
        <trans-unit id="f8c73f6bb1c6fc650c6e40cfdcfea137d51b31bb" translate="yes" xml:space="preserve">
          <source>On import, the &lt;code&gt;do_important&lt;/code&gt; function would be called, so you'd probably comment out your function call, &lt;code&gt;do_important()&lt;/code&gt;, at the bottom.</source>
          <target state="translated">导入时，将调用 &lt;code&gt;do_important&lt;/code&gt; 函数，因此您可能会在底部注释掉函数调用 &lt;code&gt;do_important()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d793a6eac08930c66fb11b06b414c6c74e2e724" translate="yes" xml:space="preserve">
          <source>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:</source>
          <target state="translated">另一方面,假设其他一些模块是主程序,它导入了你的模块。这意味着在主程序里有这样的语句,或者在其他一些主程序导入的模块里有这样的语句。</target>
        </trans-unit>
        <trans-unit id="4b8160972d3ededbe405e2919fa2974b8a5330ed" translate="yes" xml:space="preserve">
          <source>Open xy.py as the 'home' file; call it &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; in the &lt;code&gt;__name__&lt;/code&gt; variable.</source>
          <target state="translated">打开xy.py作为&amp;ldquo;主&amp;rdquo;文件； 在 &lt;code&gt;__name__&lt;/code&gt; 变量中将其称为 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="a703490bf01742db237973ccf277b94b1592d61d" translate="yes" xml:space="preserve">
          <source>Put simply, &lt;code&gt;__name__&lt;/code&gt; is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.</source>
          <target state="translated">简而言之， &lt;code&gt;__name__&lt;/code&gt; 是为每个脚本定义的变量，用于定义脚本是作为主模块运行还是作为导入模块运行。</target>
        </trans-unit>
        <trans-unit id="e37067e387ec00a654d6a8a4421c869e9ce7f02b" translate="yes" xml:space="preserve">
          <source>Question: Can I have multiple &lt;code&gt;__name__&lt;/code&gt; checking blocks?  Answer: it's strange to do so, but the language won't stop you.</source>
          <target state="translated">问题：我可以有多个 &lt;code&gt;__name__&lt;/code&gt; 检查块吗？ 答：这样做很奇怪，但是这种语言不会阻止您。</target>
        </trans-unit>
        <trans-unit id="1f6213cf7dc0a0a2692503179dc1a74e244db9a2" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://docs.python.org/3.5/tutorial/modules.html&quot;&gt;https://docs.python.org/3.5/tutorial/modules.html&lt;/a&gt;</source>
          <target state="translated">参考： &lt;a href=&quot;https://docs.python.org/3.5/tutorial/modules.html&quot;&gt;https&lt;/a&gt; : //docs.python.org/3.5/tutorial/modules.html</target>
        </trans-unit>
        <trans-unit id="664467ee79494c88e6f1e2c2697dbbe4ff48a5d2" translate="yes" xml:space="preserve">
          <source>Remember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the &lt;code&gt;main()&lt;/code&gt; function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script.</source>
          <target state="translated">还记得我之前说的有关导入语句的内容吗？ 导入模块时，它不仅会&amp;ldquo;识别&amp;rdquo;它并等待进一步的指令-它实际上会运行脚本中包含的所有可执行操作。 因此，将脚本的内容放入 &lt;code&gt;main()&lt;/code&gt; 函数可以有效地隔离它，将其隔离，以便在被另一个脚本导入时不会立即运行。</target>
        </trans-unit>
        <trans-unit id="f98434905bc42aec74771816b1350633e53ce854" translate="yes" xml:space="preserve">
          <source>Resulting in &lt;code&gt;__main__&lt;/code&gt;</source>
          <target state="translated">导致 &lt;code&gt;__main__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e63592c750f974c67228385bd47700a1dc930828" translate="yes" xml:space="preserve">
          <source>Resulting in &lt;code&gt;somefile&lt;/code&gt;</source>
          <target state="translated">产生 &lt;code&gt;somefile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dca1109ee592b30f70306745ecaf4e3be65dabb6" translate="yes" xml:space="preserve">
          <source>Run it. It will print &lt;strong&gt;a&lt;/strong&gt;, i.e., the name of the file which &lt;strong&gt;is imported&lt;/strong&gt;.</source>
          <target state="translated">运行。 它将打印&lt;strong&gt;一个&lt;/strong&gt; ，即被&lt;strong&gt;导入&lt;/strong&gt;文件的名称。</target>
        </trans-unit>
        <trans-unit id="3f5bef58a00ebcb694aa52babce37958f2b198f1" translate="yes" xml:space="preserve">
          <source>Run the class stand alone, for testing purposes.</source>
          <target state="translated">单独运行班级,用于测试。</target>
        </trans-unit>
        <trans-unit id="20e86911fbff3e384f7f5f09191137367a0df800" translate="yes" xml:space="preserve">
          <source>Running them will get you this output:</source>
          <target state="translated">运行它们,你会得到这样的输出。</target>
        </trans-unit>
        <trans-unit id="10ec89290100bc024be13c487e6ae209eaa691b9" translate="yes" xml:space="preserve">
          <source>Say you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the  &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;</source>
          <target state="translated">假设您编写的Python脚本功能出色，并实现了许多对其他目的有用的功能。 如果要使用它们，我可以导入脚本并使用它们而无需执行程序（假设您的代码仅在 &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 上下文中执行）。 而在C / C ++中，您将必须将这些部分分成一个单独的模块，然后再包含文件。 如下图所示；</target>
        </trans-unit>
        <trans-unit id="8d613d269c466eb978baefb1a911abf766ab0238" translate="yes" xml:space="preserve">
          <source>Say you're writing a Python script designed to be used as a module:</source>
          <target state="translated">假设你正在编写一个Python脚本作为模块使用。</target>
        </trans-unit>
        <trans-unit id="fb6ab9485c691b027c37729a425f370d612207ed" translate="yes" xml:space="preserve">
          <source>Simply, it is the entry point to run the file, like the &lt;code&gt;main&lt;/code&gt; function in the &lt;em&gt;C&lt;/em&gt; programming language.</source>
          <target state="translated">简单来说，它是运行文件的入口，就像&lt;em&gt;C&lt;/em&gt;编程语言中的 &lt;code&gt;main&lt;/code&gt; 功能一样。</target>
        </trans-unit>
        <trans-unit id="2f0eb42cc94ae6f1d6b27a11e936825cd6e9be63" translate="yes" xml:space="preserve">
          <source>Small example to explain in short.</source>
          <target state="translated">小编举个简单的例子来说明一下。</target>
        </trans-unit>
        <trans-unit id="abff45f4f7494a045c401c2b502e510dbd014b28" translate="yes" xml:space="preserve">
          <source>So if we have two scripts;</source>
          <target state="translated">所以,如果我们有两个脚本。</target>
        </trans-unit>
        <trans-unit id="84ce746d38e49c0592c794aa0e1ec5b2af9e35c4" translate="yes" xml:space="preserve">
          <source>So if you check before executing:</source>
          <target state="translated">所以,如果你在执行前检查。</target>
        </trans-unit>
        <trans-unit id="640d3626fbf5c4384513193cd5a05b99491f804b" translate="yes" xml:space="preserve">
          <source>So that is what this line of code checks. If it is the main file (i.e., b.py) running the code, which in this case it is not (a.py is the main file running), then only the code gets executed.</source>
          <target state="translated">所以这就是这行代码要检查的内容。如果是运行代码的主文件(即b.py),而本例中不是(a.py是运行的主文件),那么只有代码被执行。</target>
        </trans-unit>
        <trans-unit id="263e6ff9fdb235045559021aa4f3aaf6a28dd1e6" translate="yes" xml:space="preserve">
          <source>So, above is self explanatory that when you call test from other script, if loop &lt;code&gt;__name__&lt;/code&gt; in &lt;code&gt;test.py&lt;/code&gt; will not execute.</source>
          <target state="translated">因此，上面的解释是，当您从其他脚本调用test时，如果 &lt;code&gt;test.py&lt;/code&gt; 中的循环 &lt;code&gt;__name__&lt;/code&gt; 不会执行。</target>
        </trans-unit>
        <trans-unit id="68f77a6ccbf56724f5b40205ddb5e475652f0586" translate="yes" xml:space="preserve">
          <source>So, code under the &lt;code&gt;if&lt;/code&gt; block will only run if the module is the entry point to your program.</source>
          <target state="translated">因此，仅当模块是程序的入口点时， &lt;code&gt;if&lt;/code&gt; 块下的代码才会运行。</target>
        </trans-unit>
        <trans-unit id="f39f20521dcc328835dd2bae85539d96c3ed5764" translate="yes" xml:space="preserve">
          <source>So, in your example in part:</source>
          <target state="translated">所以,在你的例子中,有一部分。</target>
        </trans-unit>
        <trans-unit id="9b0e64ff7926b8af4a777a49504ee4171aa1f955" translate="yes" xml:space="preserve">
          <source>So, to show &lt;strong&gt;two different behavior of the same file&lt;/strong&gt;, this is a commonly used trick:</source>
          <target state="translated">因此，为了显示&lt;strong&gt;同一文件的两种不同行为&lt;/strong&gt; ，这是一个常用的技巧：</target>
        </trans-unit>
        <trans-unit id="1fd11fffb92fae55b373db1f1b2a14481892db42" translate="yes" xml:space="preserve">
          <source>Special Variables</source>
          <target state="translated">特殊变量</target>
        </trans-unit>
        <trans-unit id="b0b9fd78351c8645d3bb611c5714fc4fb48a880a" translate="yes" xml:space="preserve">
          <source>Suppose the following is in &lt;code&gt;foo2.py&lt;/code&gt;.  What happens if you say &lt;code&gt;python foo2.py&lt;/code&gt; on the command-line? Why?</source>
          <target state="translated">假设以下内容在 &lt;code&gt;foo2.py&lt;/code&gt; 中 。 如果在命令行上说 &lt;code&gt;python foo2.py&lt;/code&gt; 会发生什么？ 为什么？</target>
        </trans-unit>
        <trans-unit id="19e0db61176529f3b08091162b28a1b8097dbc39" translate="yes" xml:space="preserve">
          <source>Suppose we have this code in x.py:</source>
          <target state="translated">假设我们在x.py里有这样的代码。</target>
        </trans-unit>
        <trans-unit id="b522da1d722893c1c3514d7e1c720966c233662f" translate="yes" xml:space="preserve">
          <source>Take file &quot;ab.py&quot;:</source>
          <target state="translated">以文件 &quot;ab.py &quot;为例。</target>
        </trans-unit>
        <trans-unit id="63dd3922ae392ebb0802b3e1fb913af39e39d6ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__name__&lt;/code&gt; variable points to the namespace wherever the Python interpreter happens to be at the moment.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 变量指向Python解释器当前所在的名称空间。</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">问题所在</target>
        </trans-unit>
        <trans-unit id="d9eef56265e1ad5d7b64df6c1fea6c1c26857bc3" translate="yes" xml:space="preserve">
          <source>The above statement is true and prints &lt;em&gt;&quot;direct method&quot;&lt;/em&gt;. Suppose if they imported this class in another class it doesn't print &lt;em&gt;&quot;direct method&quot;&lt;/em&gt; because, while importing, it will set &lt;code&gt;__name__ equal to &quot;first model name&quot;&lt;/code&gt;.</source>
          <target state="translated">上面的陈述是正确的，并显示&lt;em&gt;&amp;ldquo; direct method&amp;rdquo;&lt;/em&gt; 。 假设他们在另一个类中导入了该类，则不会打印&lt;em&gt;&amp;ldquo;直接方法&amp;rdquo;，&lt;/em&gt;因为在导入时，它将设置 &lt;code&gt;__name__ equal to &quot;first model name&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b0b314d4585244ae8ac5cd70de557719041b367" translate="yes" xml:space="preserve">
          <source>The arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:</source>
          <target state="translated">箭头是导入链接。对于三个模块,每一个试图包含前一个模块的代码都有6个文件(9个,算上实现文件)和5个链接。这使得在C项目中很难包含其他代码,除非是专门编译成库,否则很难将其包含到C项目中。现在想象一下,对于Python来说。</target>
        </trans-unit>
        <trans-unit id="b96b1c26d7d07398a4108598c24c3f6449d82fe1" translate="yes" xml:space="preserve">
          <source>The bottom two lines mean: &quot;If this is the &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; or 'home' script, execute the function called &lt;code&gt;main()&lt;/code&gt;&quot;. That's why you'll see a &lt;code&gt;def main():&lt;/code&gt; block up top, which contains the main flow of the script's functionality.</source>
          <target state="translated">最下面两行表示：&amp;ldquo;如果这是 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 或'home'脚本，则执行名为 &lt;code&gt;main()&lt;/code&gt; 的函数。 这就是为什么您会看到 &lt;code&gt;def main():&lt;/code&gt; 顶部阻塞的原因，其中包含脚本功能的主要流程。</target>
        </trans-unit>
        <trans-unit id="ee36bd7aa18be8f75cff321a8cbe45b79fa20c99" translate="yes" xml:space="preserve">
          <source>The code inside &lt;code&gt;if __name__ == '__main__':&lt;/code&gt;&lt;strong&gt;will only be executed if the module is invoked as a script&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 内部的代码&lt;strong&gt;仅在模块作为脚本调用时才会执行&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7cb418b6654cc08bd7fdbc541322601045fee60" translate="yes" xml:space="preserve">
          <source>The global variable, &lt;code&gt;__name__&lt;/code&gt;, in the module that is the entry point to your program, is &lt;code&gt;'__main__'&lt;/code&gt;. Otherwise, it's the name you import the module by.</source>
          <target state="translated">作为程序入口点的模块中的全局变量 &lt;code&gt;__name__&lt;/code&gt; 是 &lt;code&gt;'__main__'&lt;/code&gt; 。 否则，这就是您导入模块的名称。</target>
        </trans-unit>
        <trans-unit id="abc8795a207d7fd1e55acd3339216f07ad278e91" translate="yes" xml:space="preserve">
          <source>The important thing that python is special at is point 4! The rest is just basic logic.</source>
          <target state="translated">python最重要的一点就是第4点的特别之处! 其他的只是基本的逻辑。</target>
        </trans-unit>
        <trans-unit id="070234b07de191f078cf7dded19198b7b44d467d" translate="yes" xml:space="preserve">
          <source>The interpreter keeps track of which scripts are running with &lt;code&gt;__name__&lt;/code&gt;. When you run a script - no matter what you've named it - the interpreter calls it &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;, making it the master or 'home' script that gets returned to after running an external script.</source>
          <target state="translated">解释器使用 &lt;code&gt;__name__&lt;/code&gt; 跟踪正在运行的脚本。 当您运行脚本时（无论您使用什么名称），解释器都将其称为 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; ，从而使其成为运行外部脚本后返回的主脚本或&amp;ldquo;主&amp;rdquo;脚本。</target>
        </trans-unit>
        <trans-unit id="e490bbfebdeff408a85402b8066f8e0d765afb42" translate="yes" xml:space="preserve">
          <source>The interpreter will search for your &lt;code&gt;foo.py&lt;/code&gt; file (along with searching for a few other variants), and prior to executing that module, it will assign the name &lt;code&gt;&quot;foo&quot;&lt;/code&gt; from the import statement to the &lt;code&gt;__name__&lt;/code&gt; variable, i.e.</source>
          <target state="translated">解释器将搜索您的 &lt;code&gt;foo.py&lt;/code&gt; 文件（以及搜索其他一些变体），并且在执行该模块之前，它将从import语句中将名称 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 分配给 &lt;code&gt;__name__&lt;/code&gt; 变量，即</target>
        </trans-unit>
        <trans-unit id="beb5c6ca096be5c499ae9d622ede781690b12de1" translate="yes" xml:space="preserve">
          <source>The output for the above is &lt;code&gt;__main__&lt;/code&gt;.</source>
          <target state="translated">上面的输出是 &lt;code&gt;__main__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b315daf004ca0729cd2f96be56c31138214abce" translate="yes" xml:space="preserve">
          <source>The output from executing script1 is</source>
          <target state="translated">执行脚本1的输出是</target>
        </trans-unit>
        <trans-unit id="a61791ccd424eca040a7f63b8afadbed687c913a" translate="yes" xml:space="preserve">
          <source>The output will be</source>
          <target state="translated">输出将是</target>
        </trans-unit>
        <trans-unit id="f7783b7273a972da2fb19a09cf27c06a5a76b303" translate="yes" xml:space="preserve">
          <source>The reason for</source>
          <target state="translated">原因是</target>
        </trans-unit>
        <trans-unit id="461ad2d3ca9debfc02d07f3beea45fedd8fe7c48" translate="yes" xml:space="preserve">
          <source>The simplest explanation for the &lt;code&gt;__name__&lt;/code&gt; variable (imho) is the following:</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; 变量（imho）的最简单解释如下：</target>
        </trans-unit>
        <trans-unit id="7bb35afec92b2288483eddfee92b6b137ba1ffee" translate="yes" xml:space="preserve">
          <source>There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the &lt;strong&gt;__name__&lt;/strong&gt; variable/attribute:</source>
          <target state="translated">系统（Python解释器）为源文件（模块）提供了许多变量。 您可以随时获取它们的值，因此，让我们关注&lt;strong&gt;__name__&lt;/strong&gt;变量/属性：</target>
        </trans-unit>
        <trans-unit id="d334018c829a8afc4b891e4ccfd37fcb00325b95" translate="yes" xml:space="preserve">
          <source>There are lots of different takes here on the mechanics of the code in question, the &quot;How&quot;, but for me none of it made sense until I understood the &quot;Why&quot;. This should be especially helpful for new programmers.</source>
          <target state="translated">在这里有很多关于代码的力学问题,也就是 &quot;如何 &quot;的问题,但对我来说,在我理解了 &quot;为什么 &quot;之前,没有一个是有意义的。这对新的程序员应该特别有帮助。</target>
        </trans-unit>
        <trans-unit id="e63743be839c5f96b5ee726f165c404beeea8567" translate="yes" xml:space="preserve">
          <source>There's a Pythonic way to improve on this, though.</source>
          <target state="translated">不过,有一个Pythonic的方法可以改进。</target>
        </trans-unit>
        <trans-unit id="7da449e38cd83db4680bb69d26f25544a12a00c0" translate="yes" xml:space="preserve">
          <source>This answer is for Java programmers learning Python.
Every Java file typically contains one public class. You can use that class in two ways:</source>
          <target state="translated">这个答案是为学习Python的Java程序员准备的。每个Java文件通常包含一个公有类。你可以通过两种方式来使用这个类。</target>
        </trans-unit>
        <trans-unit id="a93248e8c28b2baad3105d4909c76fa1d06bca1b" translate="yes" xml:space="preserve">
          <source>This means that if &lt;code&gt;__name__&lt;/code&gt; is equal to &lt;code&gt;__main__&lt;/code&gt; then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.</source>
          <target state="translated">这意味着，如果 &lt;code&gt;__name__&lt;/code&gt; 等于 &lt;code&gt;__main__&lt;/code&gt; ,则该文件必须是主文件并且必须实际上正在运行（或者它是解释器），而不是导入脚本的模块或包。</target>
        </trans-unit>
        <trans-unit id="26768ab59b39b3300f945b6b412204438fd854c1" translate="yes" xml:space="preserve">
          <source>This module represents the (otherwise anonymous) scope in which the
  interpreter&amp;rsquo;s main program executes &amp;mdash; commands read either from
  standard input, from a script file, or from an interactive prompt. It
  is this environment in which the idiomatic &amp;ldquo;conditional script&amp;rdquo; stanza
  causes a script to run:</source>
          <target state="translated">此模块表示解释程序的主程序在其中执行的（否则为匿名）范围-从标准输入，脚本文件或交互式提示中读取的命令。 在这种环境中，惯用的&amp;ldquo;条件脚本&amp;rdquo;节使脚本运行：</target>
        </trans-unit>
        <trans-unit id="570c99fbd84e48be7a4bc039c23bb770f7a93f2d" translate="yes" xml:space="preserve">
          <source>This tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute.  If it is a package then it should not, and the value will not be &lt;code&gt;__main__&lt;/code&gt;.</source>
          <target state="translated">这告诉我们，如果正在运行的文件是主文件（或者直接从解释器运行），则必须执行该条件。 如果它是一个包，则不应该，并且该值将不是 &lt;code&gt;__main__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="400df23e6535cffd76bdbec3d29bf175104d993d" translate="yes" xml:space="preserve">
          <source>Thus, including &lt;a href=&quot;https://docs.python.org/library/__main__.html&quot;&gt;the final lines&lt;/a&gt;</source>
          <target state="translated">因此，包括&lt;a href=&quot;https://docs.python.org/library/__main__.html&quot;&gt;最后几行&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41ff41b822d3a441a23084a1b748580b08728f3a" translate="yes" xml:space="preserve">
          <source>Thus, the value of the &lt;code&gt;__name__&lt;/code&gt; attribute is set to &lt;code&gt;__main__&lt;/code&gt; when the module is run as the main program. Otherwise the value of &lt;code&gt;__name__&lt;/code&gt;  is set to contain the name of the module.</source>
          <target state="translated">因此，当模块作为主程序运行时， &lt;code&gt;__name__&lt;/code&gt; 属性的值设置为 &lt;code&gt;__main__&lt;/code&gt; 。 否则， &lt;code&gt;__name__&lt;/code&gt; 的值将设置为包含模块的名称。</target>
        </trans-unit>
        <trans-unit id="e5bb2a5a3f702f74d72560d048b4376dfc0840a3" translate="yes" xml:space="preserve">
          <source>Thus, when module &lt;code&gt;one&lt;/code&gt; gets loaded, its &lt;code&gt;__name__&lt;/code&gt; equals &lt;code&gt;&quot;one&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.</source>
          <target state="translated">因此，在加载模块 &lt;code&gt;__name__&lt;/code&gt; ，其__name__等于 &lt;code&gt;&quot;one&quot;&lt;/code&gt; 而不是 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="523dcaae791ba2376f9d0e38205b6e104584b94b" translate="yes" xml:space="preserve">
          <source>To be short, you need to know several points:</source>
          <target state="translated">简而言之,你需要知道几个要点。</target>
        </trans-unit>
        <trans-unit id="ab6345109ea5809edd76f43e5ad346f6c84b96e7" translate="yes" xml:space="preserve">
          <source>To outline the basics:</source>
          <target state="translated">概述基本情况。</target>
        </trans-unit>
        <trans-unit id="12ab10369b1f47def1cf885774f934b4e0985f34" translate="yes" xml:space="preserve">
          <source>To solve the problem in point 2, python allows you to put a condition check</source>
          <target state="translated">为了解决第2点中的问题,python允许你把条件检查</target>
        </trans-unit>
        <trans-unit id="4711ba0e3e6d6e4a6ad75a1fa7aa2587e14a3867" translate="yes" xml:space="preserve">
          <source>We can execute this directly as</source>
          <target state="translated">我们可以直接执行为</target>
        </trans-unit>
        <trans-unit id="babfa4c489d804dc449fbd841bce76fc1745bd5c" translate="yes" xml:space="preserve">
          <source>We now have a final function for the end of our module that will run if we run the module as the primary module.</source>
          <target state="translated">我们现在有了一个最后的模块结尾函数,如果我们把这个模块作为主模块运行,那么这个模块就会运行。</target>
        </trans-unit>
        <trans-unit id="1c12bf3938c1cb1ecd0ac996a47bdeae5af33c7c" translate="yes" xml:space="preserve">
          <source>We see if &lt;code&gt;__name__ == '__main__':&lt;/code&gt; quite often.</source>
          <target state="translated">我们经常查看 &lt;code&gt;__name__ == '__main__':&lt;/code&gt; 情况。</target>
        </trans-unit>
        <trans-unit id="8c1bfdb1fcdcd5574d83109e0bae5ad3a5cf62db" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; do?</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 怎么办？</target>
        </trans-unit>
        <trans-unit id="882f556d9b969816afbc080f2c0c2833e74571bd" translate="yes" xml:space="preserve">
          <source>What does if __name__ == “__main__”: do</source>
          <target state="translated">如果__name__==&quot;__main__&quot;:如何处理?</target>
        </trans-unit>
        <trans-unit id="0519ae47b8614fd1d5f5805a3c6ace1513a3c429" translate="yes" xml:space="preserve">
          <source>What does the &lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; do?</source>
          <target state="translated">&lt;code&gt;if __name__ == &quot;__main__&quot;:&lt;/code&gt; 什么用？</target>
        </trans-unit>
        <trans-unit id="e8ade84c1dddd0abd1d4a5cbe46e38dc11bedceb" translate="yes" xml:space="preserve">
          <source>What if we want to run this business process from outside the module?</source>
          <target state="translated">如果我们想从模块外运行这个业务流程怎么办?</target>
        </trans-unit>
        <trans-unit id="849ed2229cbffb820dde4aac079e940cbf66d22f" translate="yes" xml:space="preserve">
          <source>What is this code actually doing?</source>
          <target state="translated">这段代码到底在做什么?</target>
        </trans-unit>
        <trans-unit id="ac4dd5fb5ee621db0e7fc13bfab42a28cf4cb6c7" translate="yes" xml:space="preserve">
          <source>What will this do when used as a script?  When imported as a module?</source>
          <target state="translated">当作为脚本使用时,会有什么作用?当作为模块导入时?</target>
        </trans-unit>
        <trans-unit id="34026079e5767a32ede0b2469d594a04aa502cd0" translate="yes" xml:space="preserve">
          <source>What's this? An &lt;code&gt;if&lt;/code&gt; statement. Well, the condition has been met (the variable &lt;code&gt;__name__&lt;/code&gt; has been set to &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;), so I'll enter the &lt;code&gt;main()&lt;/code&gt; function and print '&lt;em&gt;main function: this is where the action is&lt;/em&gt;'.</source>
          <target state="translated">这是什么？ 一个 &lt;code&gt;if&lt;/code&gt; 语句。 好了，条件已经满足（变量 &lt;code&gt;__name__&lt;/code&gt; 已设置为 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; ），所以我将输入 &lt;code&gt;main()&lt;/code&gt; 函数并输出' &lt;em&gt;main函数：这是操作所在&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7a878649d8009684428450f8af9b808c3a3075d" translate="yes" xml:space="preserve">
          <source>When Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.)</source>
          <target state="translated">当Python加载一个源代码文件时,它会执行其中的所有代码。(注意,它不会调用文件中定义的所有方法和函数,但它会定义它们)。</target>
        </trans-unit>
        <trans-unit id="2a4ffb529b1700ce20d37ede654fc1142a11d491" translate="yes" xml:space="preserve">
          <source>When the Python interpeter reads a source file, it first defines a few special variables. In this case, we care about the &lt;code&gt;__name__&lt;/code&gt; variable.</source>
          <target state="translated">当Python交互程序读取源文件时，它首先定义了一些特殊变量。 在这种情况下，我们关心的是 &lt;code&gt;__name__&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="447dd3597ff37641a5da70095abbfb1e338af1d5" translate="yes" xml:space="preserve">
          <source>When there are certain statements in our module (&lt;code&gt;M.py&lt;/code&gt;) we want to be executed when it'll be running as main (not imported), we can place those statements (test-cases, print statements) under this &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">当我们的模块（ &lt;code&gt;M.py&lt;/code&gt; ）中有某些语句要在作为主模块运行（不导入）时执行时，可以将这些语句（测试用例，打印语句）放在 &lt;code&gt;if&lt;/code&gt; 块下面。</target>
        </trans-unit>
        <trans-unit id="9877906a93c95cdaf2921362477e675f7b677ec6" translate="yes" xml:space="preserve">
          <source>When you execute &lt;code&gt;xy.py&lt;/code&gt;, you &lt;code&gt;import ab&lt;/code&gt;. The import statement runs the module immediately on import, so &lt;code&gt;ab&lt;/code&gt;'s operations get executed before the remainder of &lt;code&gt;xy&lt;/code&gt;'s. Once finished with &lt;code&gt;ab&lt;/code&gt;, it continues with &lt;code&gt;xy&lt;/code&gt;.</source>
          <target state="translated">执行 &lt;code&gt;xy.py&lt;/code&gt; 时 ， &lt;code&gt;import ab&lt;/code&gt; 。 import语句在导入时立即运行模块，因此 &lt;code&gt;ab&lt;/code&gt; 的操作在 &lt;code&gt;xy&lt;/code&gt; 的其余部分之前执行。 用 &lt;code&gt;ab&lt;/code&gt; 完成后，以 &lt;code&gt;xy&lt;/code&gt; 继续。</target>
        </trans-unit>
        <trans-unit id="b8b36e56cdbe31fc5262405f5324cf63c8c6e4bf" translate="yes" xml:space="preserve">
          <source>When you execute this</source>
          <target state="translated">当您执行此操作时</target>
        </trans-unit>
        <trans-unit id="6fd61966708d4f62ded02175bf761bbf0e8fb9c3" translate="yes" xml:space="preserve">
          <source>When you run Python interactively the local &lt;code&gt;__name__&lt;/code&gt; variable is assigned a value of &lt;code&gt;__main__&lt;/code&gt;. Likewise, when you execute a Python module from the command line, rather than importing it into another module, its &lt;code&gt;__name__&lt;/code&gt; attribute is assigned a value of &lt;code&gt;__main__&lt;/code&gt;, rather than the actual name of the module. In this way, modules can look at their own &lt;code&gt;__name__&lt;/code&gt; value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:</source>
          <target state="translated">当以交互方式运行Python时，将为本地 &lt;code&gt;__name__&lt;/code&gt; 变量分配 &lt;code&gt;__main__&lt;/code&gt; 的值。 同样，当您从命令行执行Python模块，而不是将其导入另一个模块时，其 &lt;code&gt;__name__&lt;/code&gt; 属性被分配为 &lt;code&gt;__main__&lt;/code&gt; 值，而不是模块的实际名称。 通过这种方式，模块可以查看自己的 &lt;code&gt;__name__&lt;/code&gt; 值来自行确定如何使用它们，作为对另一个程序的支持还是从命令行执行的主要应用程序。 因此，以下习语在Python模块中非常普遍：</target>
        </trans-unit>
        <trans-unit id="4382aa34afa3d659f0bb4edaf5dcf55f253232cd" translate="yes" xml:space="preserve">
          <source>When you run this script prints &lt;strong&gt;you can see me&lt;/strong&gt;</source>
          <target state="translated">运行此脚本打印件时， &lt;strong&gt;您可以看到我&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff92db554b1095b0d40299da20c445f80406d870" translate="yes" xml:space="preserve">
          <source>When your script is run by passing it as a command to the Python interpreter,</source>
          <target state="translated">当你的脚本运行时,将其作为命令传递给Python解释器。</target>
        </trans-unit>
        <trans-unit id="ab593498ef9ec53331cbff2af3b2dd2b51bdf819" translate="yes" xml:space="preserve">
          <source>Whenever the Python interpreter reads a source file, it does two things:</source>
          <target state="translated">每当Python解释器读取一个源文件时,它会做两件事。</target>
        </trans-unit>
        <trans-unit id="6a1d2d8182ddb99759342b07d21796d4a90b92eb" translate="yes" xml:space="preserve">
          <source>Why Does It Work This Way?</source>
          <target state="translated">为什么会有这样的效果?</target>
        </trans-unit>
        <trans-unit id="fc47432e4bb8b9783f8dbd23b35f57d699c4a18e" translate="yes" xml:space="preserve">
          <source>Why do we need this?</source>
          <target state="translated">我们为什么需要这个?</target>
        </trans-unit>
        <trans-unit id="acd0bc142a66a740172c6969fcbd8897e5de82ac" translate="yes" xml:space="preserve">
          <source>Why implement this?</source>
          <target state="translated">为什么要实施?</target>
        </trans-unit>
        <trans-unit id="b6e9143e9e32c607148934a535cfda140fe418d6" translate="yes" xml:space="preserve">
          <source>With the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script).</source>
          <target state="translated">有了上述内容,你的代码只有在你作为主模块运行时才会执行(或有意从其他脚本中调用)。</target>
        </trans-unit>
        <trans-unit id="913a9ffbcabac7b4746945a64e723d43537938ef" translate="yes" xml:space="preserve">
          <source>Yes, that's right. These separate functions &lt;strong&gt;can&lt;/strong&gt; be called from an in-line script that's not contained inside a &lt;code&gt;main()&lt;/code&gt; function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read.</source>
          <target state="translated">恩，那就对了。 这些单独的函数&lt;strong&gt;可以&lt;/strong&gt;从 &lt;code&gt;main()&lt;/code&gt; 函数中未包含的嵌入式脚本中调用。 如果您习惯了（就像我在编程的早期学习阶段一样）构建可以完全满足您需要的内联脚本，并且如果您再次需要该操作，那么您将尝试再次找出它。嗯，您不习惯这种代码的内部结构，因为它的构建更加复杂并且阅读起来也不那么直观。</target>
        </trans-unit>
        <trans-unit id="bbf85bd3bd1a2f405d72d298d6d2e8dc0e6a4075" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; test the module by adding this call of the function to the bottom:</source>
          <target state="translated">您&lt;em&gt;可以&lt;/em&gt;通过将此函数调用添加到底部&lt;em&gt;来&lt;/em&gt;测试模块：</target>
        </trans-unit>
        <trans-unit id="786d584d19c5e53ad4e4097843269cf6c5e6292a" translate="yes" xml:space="preserve">
          <source>You can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.</source>
          <target state="translated">你也可以用它来提供包和模块上的可运行的帮助功能实用程序,而不需要复杂地使用库。</target>
        </trans-unit>
        <trans-unit id="1022be4eed5ff0cd45b00fa73b4ca1a925550db8" translate="yes" xml:space="preserve">
          <source>You can make the file usable as a &lt;strong&gt;script&lt;/strong&gt; as well as an &lt;strong&gt;importable module&lt;/strong&gt;.</source>
          <target state="translated">您可以使该文件可用作&lt;strong&gt;脚本&lt;/strong&gt;以及&lt;strong&gt;可导入模块&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="53eb1352da0ffb51c0ec047f0ef125c909ddaefa" translate="yes" xml:space="preserve">
          <source>You get</source>
          <target state="translated">你懂的</target>
        </trans-unit>
        <trans-unit id="dadc4d8e7d9fa9779b4e08f566981499d80cb4e7" translate="yes" xml:space="preserve">
          <source>You might naturally wonder why anybody would want this.  Well, sometimes you want to write a &lt;code&gt;.py&lt;/code&gt; file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:</source>
          <target state="translated">您自然会想知道为什么有人会想要这个。 好吧，有时您想编写一个 &lt;code&gt;.py&lt;/code&gt; 文件，该文件既可以供其他程序和/或模块用作模块，也可以作为主程序本身运行。 例子：</target>
        </trans-unit>
        <trans-unit id="8047f868d8a396e2d98f574de9648be818c0aee6" translate="yes" xml:space="preserve">
          <source>You should see that, where &lt;code&gt;__name__&lt;/code&gt;, where it is the main file (or program) will &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;__main__&lt;/code&gt;, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.</source>
          <target state="translated">您应该看到，在 &lt;code&gt;__name__&lt;/code&gt; （它是主文件（或程序）的位置）将&lt;em&gt;始终&lt;/em&gt;返回 &lt;code&gt;__main__&lt;/code&gt; ，并且如果它是模块/软件包或正在运行其他Python脚本的任何内容，则将返回该文件的名称。它来自哪里。</target>
        </trans-unit>
        <trans-unit id="737d0a68671613e4f63d5688dcabf38a268873ac" translate="yes" xml:space="preserve">
          <source>You write a module, and if someone wants to use your code they just import it and the &lt;code&gt;__name__&lt;/code&gt; variable can help to separate the executable portion of the program from the library part.</source>
          <target state="translated">您编写了一个模块，如果有人想使用您的代码，他们只需导入它， &lt;code&gt;__name__&lt;/code&gt; 变量可以帮助将程序的可执行部分与库部分分开。</target>
        </trans-unit>
        <trans-unit id="e48102eb585faacfdf2ded85e1a6e43222bcef6c" translate="yes" xml:space="preserve">
          <source>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.</source>
          <target state="translated">你的模块是一个库,但你希望有一个脚本模式,在这个模式下,它可以运行一些单元测试或演示。</target>
        </trans-unit>
        <trans-unit id="9775ebd3a1d07733317e1e64b5d35d40fca683d8" translate="yes" xml:space="preserve">
          <source>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.</source>
          <target state="translated">你的模块大多作为主程序使用,但它也为高级用户提供了一个程序员友好的API。</target>
        </trans-unit>
        <trans-unit id="327fb7d82f537223ad218bd0c2bd1f339f312554" translate="yes" xml:space="preserve">
          <source>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing &lt;code&gt;.py&lt;/code&gt; files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.</source>
          <target state="translated">您的模块仅用作主程序，但具有一些单元测试，并且测试框架通过导入 &lt;code&gt;.py&lt;/code&gt; 文件（如脚本）并运行特殊的测试功能来工作。 您不希望它只是因为正在导入模块而尝试运行脚本。</target>
        </trans-unit>
        <trans-unit id="7921914ab3f7b51666817a9add8daeeb610bdeaf" translate="yes" xml:space="preserve">
          <source>all of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there's no &lt;code&gt;main()&lt;/code&gt; function that gets run automatically - the &lt;code&gt;main()&lt;/code&gt; function is implicitly all the code at the top level.</source>
          <target state="translated">缩进级别为0的所有代码都将执行。 可以很好地定义已定义的函数和类，但是不会运行任何代码。 与其他语言不同，没有 &lt;code&gt;main()&lt;/code&gt; 函数会自动运行-main &lt;code&gt;main()&lt;/code&gt; 函数隐式是顶层的所有代码。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="57216f4f62e4c7cff528a1042119b6bd292590a1" translate="yes" xml:space="preserve">
          <source>and running it (on a command prompt) with something like:</source>
          <target state="translated">并在命令提示符上运行它(在命令提示符上),用类似于:</target>
        </trans-unit>
        <trans-unit id="3ef1ebbdd755420799ee3cf5f1bbe79340df1c25" translate="yes" xml:space="preserve">
          <source>at the end of your mycode.py script,</source>
          <target state="translated">在你的mycode.py脚本的最后。</target>
        </trans-unit>
        <trans-unit id="d2fb4096be84a03b40677e8860e321cd4dab7598" translate="yes" xml:space="preserve">
          <source>if &lt;strong&gt;name&lt;/strong&gt; == '&lt;strong&gt;main&lt;/strong&gt;':</source>
          <target state="translated">如果&lt;strong&gt;name&lt;/strong&gt; ==' &lt;strong&gt;main&lt;/strong&gt; '：</target>
        </trans-unit>
        <trans-unit id="e874b6c8f390f7d7eef2f26e6eba081818ffd576" translate="yes" xml:space="preserve">
          <source>is primarily to avoid the &lt;a href=&quot;https://docs.python.org/2/library/threading.html#importing-in-threaded-code&quot;&gt;import lock&lt;/a&gt; problems that would arise from &lt;a href=&quot;https://stackoverflow.com/questions/46326059/&quot;&gt;having code directly imported&lt;/a&gt;. You want &lt;code&gt;main()&lt;/code&gt; to run if your file was directly invoked (that's the &lt;code&gt;__name__ == &quot;__main__&quot;&lt;/code&gt; case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems.</source>
          <target state="translated">主要是为了避免由于&lt;a href=&quot;https://stackoverflow.com/questions/46326059/&quot;&gt;直接导入代码&lt;/a&gt;而引起的&lt;a href=&quot;https://docs.python.org/2/library/threading.html#importing-in-threaded-code&quot;&gt;导入锁定&lt;/a&gt;问题。 如果要直接调用文件（这是 &lt;code&gt;__name__ == &quot;__main__&quot;&lt;/code&gt; 情况），则希望 &lt;code&gt;main()&lt;/code&gt; 运行，但是如果导入了代码，则导入程序必须从真正的主模块中输入代码，以避免导入锁定问题。</target>
        </trans-unit>
        <trans-unit id="ac8e610ec891561e761ac3b81b1844f41418fb4b" translate="yes" xml:space="preserve">
          <source>it executes all of the code found in the file.</source>
          <target state="translated">它执行文件中的所有代码。</target>
        </trans-unit>
        <trans-unit id="0ebc8d74e14ef81dd980f3fabdbf3885802c2366" translate="yes" xml:space="preserve">
          <source>it sets a few special variables like &lt;code&gt;__name__&lt;/code&gt;, and then</source>
          <target state="translated">它设置了一些特殊变量，例如 &lt;code&gt;__name__&lt;/code&gt; ，然后</target>
        </trans-unit>
        <trans-unit id="75cd93d2e463e2434b2a0c03ccd41ae796240e8e" translate="yes" xml:space="preserve">
          <source>means that the code block:</source>
          <target state="translated">指的是,代码块。</target>
        </trans-unit>
        <trans-unit id="6d7de544326381643ee98f9ae79c1d3e6d9eceef" translate="yes" xml:space="preserve">
          <source>the interpreter will assign the hard-coded string &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; to the &lt;code&gt;__name__&lt;/code&gt; variable, i.e.</source>
          <target state="translated">解释器会将硬编码字符串 &lt;code&gt;&quot;__main__&quot;&lt;/code&gt; 分配给 &lt;code&gt;__name__&lt;/code&gt; 变量，即</target>
        </trans-unit>
        <trans-unit id="0a6a0101819f9a81026cd9527ab3084564a94697" translate="yes" xml:space="preserve">
          <source>the otherwise anonymous global namespace is assigned the value of &lt;code&gt;'__main__'&lt;/code&gt; to its &lt;code&gt;__name__&lt;/code&gt;.</source>
          <target state="translated">否则将匿名全局命名空间的值 &lt;code&gt;'__main__'&lt;/code&gt; 分配给它的 &lt;code&gt;__name__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7dc9621082d73413870731d07212c168ee0c948" translate="yes" xml:space="preserve">
          <source>when it is the primary, entry-point module that is run by a Python process,</source>
          <target state="translated">时,它是由Python进程运行的主要的、入口模块。</target>
        </trans-unit>
        <trans-unit id="2616062d77ab8e88551d4e00b757e66c49032c1f" translate="yes" xml:space="preserve">
          <source>will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of &lt;strong&gt;__name__&lt;/strong&gt; will not equal to &quot;&lt;strong&gt;main&lt;/strong&gt;&quot; in that particular instance.</source>
          <target state="translated">仅当您直接运行模块时才会执行； 如果另一个模块正在调用/导入该代码块，则该代码块将不会执行，因为&lt;strong&gt;__name__&lt;/strong&gt;的值在该特定实例中将不等于&amp;ldquo; &lt;strong&gt;main&lt;/strong&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ae6fd70eacf54f86ab690f1936c2bc5c6419b15c" translate="yes" xml:space="preserve">
          <source>will cause your script's uniquely defined &lt;code&gt;main&lt;/code&gt; function to run.</source>
          <target state="translated">将导致脚本的唯一定义的 &lt;code&gt;main&lt;/code&gt; 函数运行。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
