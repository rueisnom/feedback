<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/20279484">
    <body>
      <group id="20279484">
        <trans-unit id="6a8bdb6458ccb5bee9b822332a5b4827ca338428" translate="yes" xml:space="preserve">
          <source>1. Use &lt;code&gt;bind()&lt;/code&gt; function</source>
          <target state="translated">1. &lt;code&gt;bind()&lt;/code&gt; 함수를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="17e4c8055d53b1988a8d696bb3defb11a904859e" translate="yes" xml:space="preserve">
          <source>2 Store reference to context/this inside another variable</source>
          <target state="translated">2 컨텍스트 / this에 대한 참조를 다른 변수에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="092b15ab8b05a52dd3f21d6ea8b19b812165c04c" translate="yes" xml:space="preserve">
          <source>3 Arrow function</source>
          <target state="translated">3 화살표 기능</target>
        </trans-unit>
        <trans-unit id="b83860e42609c8a7378127f94f739d0cfea363d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.oxforddictionaries.com/definition/english/context&quot;&gt;&quot;Context&quot;&lt;/a&gt; means the circumstances surrounding something that adds meaning, or some preceding and following information that gives extra meaning. The term &quot;context&quot; is used in ECMAScript to refer to &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;&lt;em&gt;execution context&lt;/em&gt;&lt;/a&gt;, which is all the parameters, scope and &lt;em&gt;this&lt;/em&gt; within the  scope of some executing code.</source>
          <target state="translated">&lt;a href=&quot;http://www.oxforddictionaries.com/definition/english/context&quot;&gt;&quot;컨텍스트&quot;&lt;/a&gt; 는 의미를 추가하는 것을 둘러싼 상황 또는 추가 의미를 부여하는 일부 선행 및 후속 정보를 의미합니다. &quot;컨텍스트&quot;라는 용어는 ECMAScript에서 &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;&lt;em&gt;실행 컨텍스트&lt;/em&gt;&lt;/a&gt; 를 나타내는 데 사용됩니다. &lt;em&gt;실행 컨텍스트&lt;/em&gt; 는 일부 실행 코드 범위 내에서 모든 매개 변수, 범위 및 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c5df195d0650fc0ca42b314ce0b5ccb5491d11fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sayNameVersion1&lt;/code&gt; and &lt;code&gt;sayNameVersion2&lt;/code&gt; use bind to manipulate &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; of the callback function.</source>
          <target state="translated">&lt;code&gt;sayNameVersion1&lt;/code&gt; 및 &lt;code&gt;sayNameVersion2&lt;/code&gt; 는 bind를 사용하여 콜백 함수를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="37b5b9961687599e81572e5c3967bd024409b075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sayNameVersion3&lt;/code&gt; uses  &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt; to manipulate the &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; to refer to the person object that we created, instead of the window object.</source>
          <target state="translated">&lt;code&gt;sayNameVersion3&lt;/code&gt; 은 &lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt; 을 사용하여 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 를 조작하여 window 객체 대신 만든 person 객체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="25633ebfee31e03761dfa090994b8a4d62111b9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sayNameVersion4&lt;/code&gt; uses &lt;strong&gt;&lt;code&gt;apply&lt;/code&gt;&lt;/strong&gt; to manipulate &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; to refer to person object</source>
          <target state="translated">&lt;code&gt;sayNameVersion4&lt;/code&gt; 는 &lt;strong&gt; &lt;code&gt;apply&lt;/code&gt; &lt;/strong&gt; 를 사용하여 person 객체를 참조하기 위해 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 조작합니다.</target>
        </trans-unit>
        <trans-unit id="b18e527b1d07b3c750775dd0acd1239988f2f430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; (aka &quot;the context&quot;) is a special keyword inside each function and its value only depends on &lt;em&gt;how&lt;/em&gt; the function was called, not how/when/where it was defined. It is not affected by lexical scopes like other variables (except for arrow functions, see below). Here are some examples:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; (일명 &quot;컨텍스트&quot;)은 각 함수 내부의 특수 키워드이며 그 값은 함수가 언제 / 어떻게 / 어디서 정의 &lt;em&gt;되었는지가&lt;/em&gt; 아니라 함수가 어떻게 호출 &lt;em&gt;되었는지에&lt;/em&gt; 달려 있습니다. 다른 변수와 같은 어휘 범위의 영향을받지 않습니다 (화살표 기능 제외, 아래 참조). 여기 예시들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7ccbb9142cbc877fcba507f098664bac50d55d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;this&lt;/code&gt; &amp;amp; &lt;code&gt;scope&lt;/code&gt; :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &amp;amp; &lt;code&gt;scope&lt;/code&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28d3e08a8329d2bf94877b367b5e9b6728015b6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As per my view you can implement &quot;this&quot; in three ways&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;(Self/Arrow function/Bind Method)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;내 관점에 따라 세 가지 방법으로 &quot;this&quot;를 구현할 수 있습니다&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;(Self / Arrow 함수 / Bind Method)&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5ea14bd8172aaf9a6ba506e6e7ada4b00f6c5bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Different ways to manipulate &lt;code&gt;this&lt;/code&gt; inside callback functions:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;콜백 함수 내부에서이를 조작하는 다른 방법 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9807c7820d8498af9fd8b0f569eda762bd110fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Google clearly recommends to use lambdas rather than bind or &lt;code&gt;const self = this&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Google은 바인딩 또는 &lt;code&gt;const self = this&lt;/code&gt; 대신 람다를 사용하는 것이 좋습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c9b836312f9b07af99edfd6d3c86fcf82d71366d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method1:&lt;/strong&gt; Self - Self is being used to maintain a reference to the original this even as the context is changing. It's a technique often used in event handlers (especially in closures).</source>
          <target state="translated">&lt;strong&gt;방법 1 :&lt;/strong&gt; 자체-컨텍스트가 변경되는 경우에도 자체를 사용하여 원본에 대한 참조를 유지합니다. 이벤트 처리기 (특히 클로저)에서 자주 사용되는 기술입니다.</target>
        </trans-unit>
        <trans-unit id="58ee73240b34336c1698b25bbcce84697a17df3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method2&lt;/strong&gt;: Arrow function - An arrow function expression is a syntactically compact alternative to a regular function expression,</source>
          <target state="translated">&lt;strong&gt;Method2&lt;/strong&gt; : 화살표 함수-화살표 함수 표현식은 정규 함수 표현식에 대한 구문 상 컴팩트 한 대안입니다.</target>
        </trans-unit>
        <trans-unit id="83807288d0c69591208b62be684605dc13b0d1ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method3&lt;/strong&gt;:Bind- The bind() method creates a new function that,</source>
          <target state="translated">&lt;strong&gt;Method3&lt;/strong&gt; : Bind- bind () 메소드는 새로운 함수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fbff03a5b9cb0d04b7b2cf5d21c576fe76193276" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When binding context for jQuery, use &lt;a href=&quot;http://api.jquery.com/jQuery.proxy/&quot;&gt;&lt;code&gt;jQuery.proxy&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; instead. The reason to do this is so that you don't need to store the reference to the function when unbinding an event callback. jQuery handles that internally.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; jQuery에 대한 컨텍스트를 바인딩 할 때는 &lt;a href=&quot;http://api.jquery.com/jQuery.proxy/&quot;&gt; &lt;code&gt;jQuery.proxy&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]를&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 대신 사용하십시오. 이를 수행하는 이유는 이벤트 콜백을 바인딩 해제 할 때 함수에 대한 참조를 저장할 필요가 없기 때문입니다. jQuery는 내부적으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7cddf8e8a39596a43c3943dc0b2a259074ff6e5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Whether or not you can pass a value for &lt;code&gt;this&lt;/code&gt; is usually mentioned in the documentation of that function/method. For example, &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery's &lt;code&gt;$.ajax&lt;/code&gt; method &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; describes an option called &lt;code&gt;context&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 값을 전달할 수 있는지 여부는 일반적으로 해당 기능 / 방법의 설명서에 나와 있습니다. 예를 들어, &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery의 &lt;code&gt;$.ajax&lt;/code&gt; 메소드 &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 는 &lt;code&gt;context&lt;/code&gt; 라는 옵션을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="207736ea8962167a3fa8bad382e8a76878d9f7be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference:&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Reference:&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75fdbb27ede9220d3d16fc78ac8586f0b59a2045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt; : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참조&lt;/strong&gt; : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc72ecd613eabb84943e85b3ada223948245ddd3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참조&lt;/strong&gt; : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad22017702d23a420c03692bfa75469cbd587279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The solution&lt;/strong&gt; is the same as mentioned above: If available, use &lt;code&gt;.bind&lt;/code&gt; to explicitly bind &lt;code&gt;this&lt;/code&gt; to a specific value</source>
          <target state="translated">&lt;strong&gt;해결책&lt;/strong&gt; 은 위에서 언급 한 것과 동일합니다. 사용 가능한 경우 &lt;code&gt;.bind&lt;/code&gt; 를 사용하여이를 특정 값에 명시 적으로 바인딩 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf2a3ebd0bb3eb43331c09c74be73028c7ea8561" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You Should know about &quot;this&quot; Keyword.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;this&quot;키워드에 대해 알아야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33851166d311aa4e76eff3f3efc9621355eca157" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;apply :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;적용 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77695723b8f02b1b09ad8e9f4c42690237d82c6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bind :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;바인딩 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e912e07305889ea58d8fde64c857c9a3fff38f53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;call :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전화 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29532e96f632af398dba50619e57e074313b2fdd" translate="yes" xml:space="preserve">
          <source>A function's this keyword behaves a little differently in JavaScript compared to other languages.</source>
          <target state="translated">함수의이 키워드는 JavaScript에서 다른 언어와 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="912cdfca5e5ce094d53ff3186f01991ddc662fc7" translate="yes" xml:space="preserve">
          <source>Alter code/function design/architecture - for this you should have command over  &lt;a href=&quot;https://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;design patterns&lt;/a&gt; in javascript.</source>
          <target state="translated">코드 / 함수 디자인 / 아키텍처 변경-이를 위해서는 자바 스크립트의 &lt;a href=&quot;https://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;디자인 패턴&lt;/a&gt; 에 대한 명령이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="52caaec3fba5f872647197877f4e4dd86e6a438a" translate="yes" xml:space="preserve">
          <source>An execution context provides the surrounding information that adds meaning to code that is being executed. It includes much more information than just the &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&lt;em&gt;thisBinding&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">실행 컨텍스트는 실행중인 코드에 의미를 추가하는 주변 정보를 제공합니다. &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&lt;em&gt;thisBinding&lt;/em&gt;&lt;/a&gt; 보다 훨씬 더 많은 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="44d98e8b0d43f360e36798f40afed6e98237427a" translate="yes" xml:space="preserve">
          <source>Another approach, which is &lt;strong&gt;the standard way since DOM2&lt;/strong&gt; to bind &lt;code&gt;this&lt;/code&gt; within the event listener, that &lt;strong&gt;let you always remove the listener&lt;/strong&gt; (among other benefits), is the &lt;code&gt;handleEvent(evt)&lt;/code&gt;method from the &lt;code&gt;EventListener&lt;/code&gt; interface:</source>
          <target state="translated">&lt;strong&gt;DOM2&lt;/strong&gt; 가 이벤트 리스너 내에서 &lt;code&gt;this&lt;/code&gt; 바인딩 &lt;strong&gt;하는 표준 방법 인&lt;/strong&gt; 다른 방법은 &lt;strong&gt;항상&lt;/strong&gt; 다른 &lt;strong&gt;리스너를 통해 리스너를 제거&lt;/strong&gt; 할 &lt;strong&gt;수있게&lt;/strong&gt; 하는 &lt;code&gt;EventListener&lt;/code&gt; 인터페이스의 &lt;code&gt;handleEvent(evt)&lt;/code&gt; 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="c7c7a67c1c463a52b508675c2a4fbcd7bd499c42" translate="yes" xml:space="preserve">
          <source>Another common manifestation of this problem is when an object method is used as callback/event handler. Functions are first-class citizens in JavaScript and the term &quot;method&quot; is just a colloquial term for a function that is a value of an object property. But that function doesn't have a specific link to its &quot;containing&quot; object.</source>
          <target state="translated">이 문제의 또 다른 일반적인 표현은 객체 메소드가 콜백 / 이벤트 핸들러로 사용될 때입니다. 함수는 JavaScript에서 일류 시민이며 &quot;메소드&quot;라는 용어는 객체 속성 값인 함수에 대한 구어체 용어 일뿐입니다. 그러나이 함수에는 &quot;포함&quot;개체에 대한 특정 링크가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5ca476aa209b8908ea0f9b7b407ec4efd27c9d0" translate="yes" xml:space="preserve">
          <source>Arrow Functions don&amp;rsquo;t bind &lt;code&gt;this&lt;/code&gt; &amp;mdash; instead, &lt;code&gt;this&lt;/code&gt; is bound lexically (i.e. based on the original context)</source>
          <target state="translated">화살표 함수는 이것을 바인딩하지 않습니다. 대신에 어휘 적으로 바인딩됩니다 (즉, 원래 컨텍스트를 기반으로 함)</target>
        </trans-unit>
        <trans-unit id="ab65dda1433ac3a4a44f2e5a043e4ea34a973af0" translate="yes" xml:space="preserve">
          <source>Arrow function expressions are ill suited as methods, and they cannot be used as constructors.</source>
          <target state="translated">화살표 함수 표현식은 메서드로 적합하지 않으며 생성자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="68bb09850cf0694061b593eb35c2d88f9e91ba2c" translate="yes" xml:space="preserve">
          <source>As already mentioned at the beginning, what &lt;code&gt;this&lt;/code&gt; refers to depends on how the function is &lt;strong&gt;called&lt;/strong&gt;, not how it is &lt;strong&gt;defined&lt;/strong&gt;.</source>
          <target state="translated">처음에 이미 언급했듯이, &lt;code&gt;this&lt;/code&gt; 참조하는 것은 함수가 어떻게 &lt;strong&gt;정의&lt;/strong&gt; 되는지가 아니라 함수가 어떻게 &lt;strong&gt;호출&lt;/strong&gt; 되는지에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2777b1eb41d0d72d449a11bc7ca8e6e5012319" translate="yes" xml:space="preserve">
          <source>As most of the answers suggest, we can use &lt;strong&gt;Arrow function or &lt;code&gt;bind()&lt;/code&gt; Method or Self&lt;/strong&gt; var. I would quote a point about lambdas (Arrow function) from &lt;a href=&quot;https://google.github.io/styleguide/jsguide.html#features-functions-arrow-functions&quot;&gt;Google JavaScript Style Guide&lt;/a&gt;</source>
          <target state="translated">대부분의 답변에서 알 수 있듯이 &lt;strong&gt;Arrow 함수 또는 &lt;code&gt;bind()&lt;/code&gt; 메서드 또는 Self&lt;/strong&gt; var를 사용할 수 있습니다. &lt;a href=&quot;https://google.github.io/styleguide/jsguide.html#features-functions-arrow-functions&quot;&gt;Google JavaScript 스타일 가이드&lt;/a&gt; 에서 람다 (화살표 기능)에 대한 요점을 인용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="e4a87be3685258b72d713f79d1bfa977f3e36674" translate="yes" xml:space="preserve">
          <source>Common problem: Using object methods as callbacks/event handlers</source>
          <target state="translated">일반적인 문제 : 콜백 / 이벤트 핸들러로 객체 메소드 사용</target>
        </trans-unit>
        <trans-unit id="d7f69e049d11cfea430a186ac01ffac1bca0cfc8" translate="yes" xml:space="preserve">
          <source>Consider the following example:</source>
          <target state="translated">다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="19baede9f95837656d71c40468e696396b8ec0b8" translate="yes" xml:space="preserve">
          <source>Currently there is another approach possible if classes are used in code.</source>
          <target state="translated">현재 클래스가 코드에 사용되는 경우 다른 접근 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbefe4b8aa228c45cb38892ce584258768af1d79" translate="yes" xml:space="preserve">
          <source>Detailed information about using &lt;code&gt;handleEvent&lt;/code&gt; can be found here: &lt;a href=&quot;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&quot;&gt;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;handleEvent&lt;/code&gt; 사용에 대한 자세한 정보는 다음에서 찾을 수 있습니다. &lt;a href=&quot;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&quot;&gt;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8141d62fd2995e418997f9206b5101ba5385986d" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">이것을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="4a2aba802819fc19a867deee3901f548f1feb051" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduces &lt;em&gt;arrow functions&lt;/em&gt;, which can be thought of as lambda functions. They don't have their own &lt;code&gt;this&lt;/code&gt; binding. Instead, &lt;code&gt;this&lt;/code&gt; is looked up in scope just like a normal variable. That means you don't have to call &lt;code&gt;.bind&lt;/code&gt;. That's not the only special behaviour they have, please refer to the MDN documentation for more information.</source>
          <target state="translated">ECMAScript 6에는 &lt;em&gt;화살표 함수가&lt;/em&gt; 도입되어 람다 함수로 생각할 수 있습니다. 그들은 &lt;code&gt;this&lt;/code&gt; 바인딩을 가지고 있지 않습니다. 대신 &lt;code&gt;this&lt;/code&gt; 일반 변수와 마찬가지로 범위 내에서 조회됩니다. 즉, &lt;code&gt;.bind&lt;/code&gt; 를 호출 할 필요가 없습니다. 이것이 유일한 특수한 행동은 아닙니다. 자세한 내용은 MDN 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6dbdc8171942a3d0dbd97de271857afd19174994" translate="yes" xml:space="preserve">
          <source>ECMAScript 6: Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt;</source>
          <target state="translated">ECMAScript 6 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 기능&lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="3ce4cc15e461303a1b469af49c17a030b2eaa449" translate="yes" xml:space="preserve">
          <source>ES5 introduced the bind() method to set the value of a function's this regardless of how it's called,</source>
          <target state="translated">ES5는 bind () 메소드를 도입하여 호출 방법에 관계없이 함수의 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3d92706e10419b5bc1277c566852681d2d948da0" translate="yes" xml:space="preserve">
          <source>Every function has the method &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;, which returns a new function with &lt;code&gt;this&lt;/code&gt; bound to a value. The function has exactly the same behaviour as the one you called &lt;code&gt;.bind&lt;/code&gt; on, only that &lt;code&gt;this&lt;/code&gt; was set by you. No matter how or when that function is called, &lt;code&gt;this&lt;/code&gt; will always refer to the passed value.</source>
          <target state="translated">모든 함수에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 메소드가 있으며이 함수는 값에 바인딩 된 새 함수를 반환합니다. 이 함수는 사용자가 &lt;code&gt;.bind&lt;/code&gt; 를 호출 한 것과 정확히 동일한 동작을 수행하며 사용자가 설정 한 것입니다. 해당 함수가 언제 어떻게 호출 되더라도 항상 전달 된 값을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="e9d6a485740427854045937df49a40853c402a69" translate="yes" xml:space="preserve">
          <source>Explicitly set &lt;code&gt;this&lt;/code&gt; of the callback - part 1</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 콜백을 명시 적으로 설정-1 부</target>
        </trans-unit>
        <trans-unit id="1126dd24f176d2a0b58861d9f7a6fa519f9c04cf" translate="yes" xml:space="preserve">
          <source>First, you need to have a clear understanding of &lt;strong&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/strong&gt; and behaviour of &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword in the context of &lt;strong&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">먼저 &lt;strong&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/strong&gt; 의 맥락 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 키워드의 &lt;strong&gt;범위&lt;/strong&gt; 와 동작을 명확하게 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="b98161925d8109b3e8a4d33cba64ddeafed7b359" translate="yes" xml:space="preserve">
          <source>For sure under the hood it's all old good arrow function that bind context but in this form it looks much more clear that explicit binding.</source>
          <target state="translated">후드 아래에는 컨텍스트를 바인딩하는 오래된 좋은 화살표 기능이 있지만이 형식에서는 명시 적 바인딩이 훨씬 더 명확합니다.</target>
        </trans-unit>
        <trans-unit id="e61e7a281fa5c383fee31613c5a0509a8533e6d5" translate="yes" xml:space="preserve">
          <source>Here I have a constructor function called Person. It has a property called &lt;strong&gt;&lt;code&gt;name&lt;/code&gt;&lt;/strong&gt; and four method called &lt;strong&gt;&lt;code&gt;sayNameVersion1&lt;/code&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;code&gt;sayNameVersion2&lt;/code&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;code&gt;sayNameVersion3&lt;/code&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;code&gt;sayNameVersion4&lt;/code&gt;&lt;/strong&gt;. All four of them has one specific task.Accept a callback and invoke it.The callback has a specific task which is to log the name property of an instance of Person constructor function.</source>
          <target state="translated">여기 Person이라는 생성자 함수가 있습니다. &lt;strong&gt; &lt;code&gt;name&lt;/code&gt; &lt;/strong&gt; 이라는 속성과 &lt;strong&gt; &lt;code&gt;sayNameVersion1&lt;/code&gt; &lt;/strong&gt; , &lt;strong&gt; &lt;code&gt;sayNameVersion2&lt;/code&gt; &lt;/strong&gt; , &lt;strong&gt; &lt;code&gt;sayNameVersion3&lt;/code&gt; &lt;/strong&gt; , &lt;strong&gt; &lt;code&gt;sayNameVersion4&lt;/code&gt; &lt;/strong&gt; 라는 네 가지 메서드가 있습니다. 콜백을 수락하고 호출합니다. 콜백에는 Person 생성자 함수 인스턴스의 name 속성을 기록하는 특정 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4acb81ac127a3601d53820d4d0f45171677e988c" translate="yes" xml:space="preserve">
          <source>Here are several ways to access parent context inside child context -</source>
          <target state="translated">자식 컨텍스트 내에서 부모 컨텍스트에 액세스하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e2143fbc09476ddf872285e4ee8305918dc1ef" translate="yes" xml:space="preserve">
          <source>How can I access the correct object?</source>
          <target state="translated">올바른 개체에 어떻게 액세스 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ae2ce4ed9d749ac553a5952af8ed485252570f3f" translate="yes" xml:space="preserve">
          <source>How to access the correct `this` inside a callback</source>
          <target state="translated">콜백 내에서 올바른 'this'에 액세스하는 방법</target>
        </trans-unit>
        <trans-unit id="6f908c89120425f927f214344354c0aca40f8b35" translate="yes" xml:space="preserve">
          <source>How to refer to the correct &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 올바르게 참조하는 방법</target>
        </trans-unit>
        <trans-unit id="5ed5328abf66e902733b964229b89a9e88ccb98f" translate="yes" xml:space="preserve">
          <source>However, I'm not able to access the &lt;code&gt;data&lt;/code&gt; property of the created object inside the callback. It looks like &lt;code&gt;this&lt;/code&gt; does not refer to the object that was created but to an other one.</source>
          <target state="translated">그러나 콜백 내에서 생성 된 객체의 &lt;code&gt;data&lt;/code&gt; 속성에 액세스 할 수 없습니다. 이것은 생성 된 객체가 아니라 다른 객체를 나타내는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="323833fe30e701dd0afbe644972c8297131ffd00" translate="yes" xml:space="preserve">
          <source>I also tried to use an object method instead of an anonymous function:</source>
          <target state="translated">또한 익명 함수 대신 객체 메소드를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="eaec236d744509e537cc8f03f2dea9ad53761954" translate="yes" xml:space="preserve">
          <source>I have a constructor function which registers an event handler:</source>
          <target state="translated">이벤트 핸들러를 등록하는 생성자 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b371a6ae052214f7818ec3deaed3e9b738646dd" translate="yes" xml:space="preserve">
          <source>If strict mode is enabled for any function then the value of &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; as in strict mode, global object refers to &lt;code&gt;undefined&lt;/code&gt; in place of the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">모든 기능에 대해 엄격 모드가 활성화 된 &lt;code&gt;this&lt;/code&gt; 값은 엄격 모드에서와 같이 &lt;code&gt;undefined&lt;/code&gt; 않으며 전역 객체는 &lt;code&gt;window&lt;/code&gt; 객체 대신 &lt;code&gt;undefined&lt;/code&gt; 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="97f3987d7dc7237e2cfee6a8dbacca0a0a502d88" translate="yes" xml:space="preserve">
          <source>If the code was like the following, it might be more obvious that the function doesn't have an implicit reference to the object:</source>
          <target state="translated">코드가 다음과 같으면 함수에 객체에 대한 암시 적 참조가없는 것이 더 분명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44286d5d725e24975302df95630b6a88edcc2bf7" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;underscore.js&lt;/code&gt; - &lt;a href=&quot;http://underscorejs.org/#bind&quot;&gt;http://underscorejs.org/#bind&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;underscore.js&lt;/code&gt; 를 사용중인 경우 -http : &lt;a href=&quot;http://underscorejs.org/#bind&quot;&gt;//underscorejs.org/#bind&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fde7334616f0dd164f29fddbf11acc809feee752" translate="yes" xml:space="preserve">
          <source>If you are using jQuery you should use the &lt;code&gt;$.proxy&lt;/code&gt; method instead, as &lt;code&gt;bind&lt;/code&gt; is not supported in all browsers:</source>
          <target state="translated">jQuery를 사용하는 경우 모든 브라우저에서 &lt;code&gt;bind&lt;/code&gt; 가 지원되지 않으므로 &lt;code&gt;$.proxy&lt;/code&gt; 메소드를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="13d3e294e950b7f4ab84cf9acca0ccd56c984cff" translate="yes" xml:space="preserve">
          <source>In most cases, the value of this is determined by how a function is called.</source>
          <target state="translated">대부분의 경우이 값은 함수 호출 방법에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa250ce283226ff53d868b2d334cd5e88dff4429" translate="yes" xml:space="preserve">
          <source>In the global scope, &lt;code&gt;this&lt;/code&gt; refers to the global object (the &lt;code&gt;window&lt;/code&gt; object).</source>
          <target state="translated">전역 범위에서 &lt;code&gt;this&lt;/code&gt; 전역 개체 ( &lt;code&gt;window&lt;/code&gt; 개체)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="84cfc4df2cedf0a396870ba012ed9bfc0f2b3c6c" translate="yes" xml:space="preserve">
          <source>In this case, we are binding the callback's &lt;code&gt;this&lt;/code&gt; to the value of &lt;code&gt;MyConstructor&lt;/code&gt;'s &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">이 경우 콜백의 &lt;code&gt;this&lt;/code&gt; 를 &lt;code&gt;MyConstructor&lt;/code&gt; 의 &lt;code&gt;this&lt;/code&gt; 값에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="30b4b861a818b8aa39958b98513130afef359643" translate="yes" xml:space="preserve">
          <source>It also has some differences between strict mode and non-strict mode.</source>
          <target state="translated">또한 엄격 모드와 엄격하지 않은 모드 사이에는 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5a4468c39b48f1e066f8525bae2767e24645b5a" translate="yes" xml:space="preserve">
          <source>It can't be set by assignment during execution, and it may be different each time the function is called.</source>
          <target state="translated">실행 중에 할당하여 설정할 수 없으며 함수가 호출 될 때마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c856cf98c012850bf9e871b799e02d2f89139d0f" translate="yes" xml:space="preserve">
          <source>It might look like you have no control over the value of &lt;code&gt;this&lt;/code&gt; because its value is set automatically, but that is actually not the case.</source>
          <target state="translated">값이 자동으로 설정되므로이 값을 제어 할 수없는 것처럼 보일 수 있지만 실제로는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a5c614e4a858c76be5f61117786c7f01782da3a" translate="yes" xml:space="preserve">
          <source>It's all in the &quot;magic&quot; syntax of calling a method:</source>
          <target state="translated">메소드 호출의 모든 &quot;마법&quot;구문에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d212c8aab88e3b2c631bdfa314a2c158284a9689" translate="yes" xml:space="preserve">
          <source>Now let's create an instance from person constructor and invoke different versions of &lt;strong&gt;&lt;code&gt;sayNameVersionX&lt;/code&gt;&lt;/strong&gt; ( X refers to 1,2,3,4 ) method with &lt;strong&gt;&lt;code&gt;niceCallback&lt;/code&gt;&lt;/strong&gt; to see how many ways we can manipulate the &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; inside callback to refer to the &lt;strong&gt;&lt;code&gt;person&lt;/code&gt;&lt;/strong&gt; instance.</source>
          <target state="translated">이제 person 생성자에서 인스턴스를 생성하고 &lt;strong&gt; &lt;code&gt;sayNameVersionX&lt;/code&gt; &lt;/strong&gt; 다른 버전의 &lt;strong&gt;sayNameVersionX&lt;/strong&gt; (X는 1,2,3,4 참조) 메소드를 호출하여 &lt;strong&gt; &lt;code&gt;person&lt;/code&gt; &lt;/strong&gt; 인스턴스를 참조하기 위해 콜백 내부에서 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 조작 할 수있는 방법을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bd382a556e0627a895f9d61c9e039efe9520f3a7" translate="yes" xml:space="preserve">
          <source>Prefer using arrow functions over f.bind(this), and especially over
  goog.bind(f, this). Avoid writing const self = this. Arrow functions
  are particularly useful for callbacks, which sometimes pass unexpected
  additional arguments.</source>
          <target state="translated">f.bind (this), 특히 goog.bind (f, this)보다 화살표 함수를 사용하는 것이 좋습니다. const self = this라고 쓰지 마십시오. 화살표 함수는 특히 예기치 않은 추가 인수를 전달하는 콜백에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="0659a76d505497879be6cfbe39c059f2d61df867" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;this&lt;/code&gt; of the callback - part 2</source>
          <target state="translated">콜백 설정-2 부</target>
        </trans-unit>
        <trans-unit id="56be075e48deed785dc54c97a107dbdfab73da93" translate="yes" xml:space="preserve">
          <source>Set the ThisBinding to the same value as the ThisBinding of the
  calling execution context</source>
          <target state="translated">ThisBinding을 호출 실행 컨텍스트의 ThisBinding과 동일한 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1e9e29d4637f7cebd0369d655eda5c71d09b9233" translate="yes" xml:space="preserve">
          <source>Similar to &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt;, first argument of &lt;strong&gt;&lt;code&gt;apply&lt;/code&gt;&lt;/strong&gt; refers to the object that will be indicated by &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt; 과 유사하게 &lt;strong&gt; &lt;code&gt;apply&lt;/code&gt; 의&lt;/strong&gt; 첫 번째 인수는 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 키워드로 표시 될 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="15dc5824306174e1163181b6492db3027e7184ba" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;self&lt;/code&gt; is a normal variable, it obeys lexical scope rules and is accessible inside the callback. This also has the advantage that you can access the &lt;code&gt;this&lt;/code&gt; value of the callback itself.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 는 일반적인 변수이므로 어휘 범위 규칙을 따르고 콜백 내에서 액세스 할 수 있습니다. 또한 콜백 자체 &lt;code&gt;this&lt;/code&gt; 값에 액세스 할 수 있다는 이점도 있습니다.</target>
        </trans-unit>
        <trans-unit id="841ea9b7a24ab9b0a4a11eb3d639efba860efaaa" translate="yes" xml:space="preserve">
          <source>Since it's Stage 3 Proposal you will need babel and appropriate &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-proposal-class-properties&quot;&gt;babel plugin&lt;/a&gt; to process it as for now(08/2018).</source>
          <target state="translated">3 단계 제안이기 때문에 지금과 같이 처리하려면 babel 및 적절한 &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-proposal-class-properties&quot;&gt;babel 플러그인&lt;/a&gt; 이 필요합니다 (08/2018).</target>
        </trans-unit>
        <trans-unit id="cdbe775fb45eb5ef2d2e6ce73eeeb4fd35368bf8" translate="yes" xml:space="preserve">
          <source>So the best solution would be to use lambdas as below,</source>
          <target state="translated">가장 좋은 해결책은 아래와 같이 람다를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="744d624b35c5c9839f7ef2f10dd23136a872cd13" translate="yes" xml:space="preserve">
          <source>So the value of &lt;em&gt;this&lt;/em&gt; isn't &quot;context&quot;, it's just one part of an execution context. It's essentially a local variable that can be set by the call to any object and in strict mode, to any value at all.</source>
          <target state="translated">따라서이 값은 &quot;컨텍스트&quot;가 아니라 실행 컨텍스트의 일부일뿐입니다. 본질적으로 모든 객체에 대한 호출과 엄격 모드에서 모든 값으로 설정할 수있는 로컬 변수입니다.</target>
        </trans-unit>
        <trans-unit id="08e7c0641502b25341ef35ff01a6e8bc40419c8b" translate="yes" xml:space="preserve">
          <source>Some functions/methods which accept callbacks also accept a value to which the callback's &lt;code&gt;this&lt;/code&gt; should refer to. This is basically the same as binding it yourself, but the function/method does it for you. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;Array#map&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; is such a method. Its signature is:</source>
          <target state="translated">콜백을 수락하는 일부 함수 / 메소드는 콜백 &lt;code&gt;this&lt;/code&gt; 참조해야하는 값도 허용합니다. 이것은 기본적으로 직접 바인딩하는 것과 동일하지만 함수 / 메소드가 대신합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;Array#map&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 는 그러한 방법입니다. 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d98f29032871395567d10fa9475d0524189b4f4b" translate="yes" xml:space="preserve">
          <source>Store reference to context/this inside another variable(see below example).</source>
          <target state="translated">컨텍스트 / this에 대한 참조를 다른 변수 안에 저장하십시오 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="46ccc3ce57128d895c43982bc51d536f065ddef4" translate="yes" xml:space="preserve">
          <source>That's where you would bind the context to the function:</source>
          <target state="translated">여기서 컨텍스트를 함수에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ea6ca42490b74de48fe8ae9a2bd9ccd3e0033f6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;first argument&lt;/code&gt;&lt;/strong&gt; of the &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt; method is used as &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; inside the function that is invoked with &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt; attached to it.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt; 메소드의 &lt;strong&gt; &lt;code&gt;first argument&lt;/code&gt; &lt;/strong&gt; 는 호출이 첨부 된 함수 내에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="55ff58898b5dfe7076511fbcd2d228ee39265388" translate="yes" xml:space="preserve">
          <source>The first argument is the callback and the second argument is the value &lt;code&gt;this&lt;/code&gt; should refer to. Here is a contrived example:</source>
          <target state="translated">첫 번째 인수는 콜백이고 두 번째 인수는 &lt;code&gt;this&lt;/code&gt; 참조해야하는 값입니다. 다음은 좋은 예입니다.</target>
        </trans-unit>
        <trans-unit id="67a37244ad69c52151f22e62ecb8e655636407eb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;this.method&lt;/code&gt; is assigned as click event handler, but if the &lt;code&gt;document.body&lt;/code&gt; is clicked, the value logged will be &lt;code&gt;undefined&lt;/code&gt;, because inside the event handler, &lt;code&gt;this&lt;/code&gt; refers to the &lt;code&gt;document.body&lt;/code&gt;, not the instance of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this.method&lt;/code&gt; 함수는 click 이벤트 핸들러로 지정되지만 &lt;code&gt;document.body&lt;/code&gt; 를 클릭하면 이벤트 핸들러 내부에서 &lt;code&gt;Foo&lt;/code&gt; 인스턴스가 아닌 &lt;code&gt;document.body&lt;/code&gt; 를 참조하므로 기록 된 값이 &lt;code&gt;undefined&lt;/code&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0f83deeb19c855f6e5e7fd4353ef35b56f82a60" translate="yes" xml:space="preserve">
          <source>The object that is standing before the dot is what the this keyword will be bound to.</source>
          <target state="translated">점 앞에 서있는 객체는이 키워드가 바인딩되는 대상입니다.</target>
        </trans-unit>
        <trans-unit id="fc3b4ab1171b67adb539b65128c31a6fe985a69d" translate="yes" xml:space="preserve">
          <source>The question revolves around how &lt;code&gt;this&lt;/code&gt; keyword behaves in javascript. &lt;code&gt;this&lt;/code&gt; behaves differently as below,</source>
          <target state="translated">질문은 &lt;code&gt;this&lt;/code&gt; 키워드가 자바 스크립트에서 어떻게 동작하는지에 관한 것입니다. &lt;code&gt;this&lt;/code&gt; 아래와 같이 다르게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="4f5bf601799b4826496754deacc27d88b45812b9" translate="yes" xml:space="preserve">
          <source>The term &quot;context&quot; is sometimes used to refer to the object referenced by &lt;em&gt;this&lt;/em&gt;. Its use is inappropriate because it doesn't fit either semantically or technically with &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;ECMAScript's &lt;em&gt;this&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&quot;컨텍스트&quot;라는 용어는 때때로 &lt;em&gt;이것에&lt;/em&gt; 의해 참조되는 객체를 지칭하기 위해 사용된다. 의미 적으로 또는 기술적으로 &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;ECMAScript의 &lt;em&gt;this&lt;/em&gt;&lt;/a&gt; 와 맞지 않기 때문에 부적절한 사용입니다.</target>
        </trans-unit>
        <trans-unit id="29e596611ce94c8c6c1da3cd4238c2debd6a73d7" translate="yes" xml:space="preserve">
          <source>The trouble with &quot;context&quot;</source>
          <target state="translated">&quot;문맥&quot;의 문제</target>
        </trans-unit>
        <trans-unit id="5f6b0d54cfa64916d991e3233dd9a414d112f53d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; is usually determined by a functions execution context.</source>
          <target state="translated">이것의 값은 일반적으로 함수 실행 컨텍스트에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="2c07ebf251b294d81ec44d6e5bd3eb7a7dcfbcd1" translate="yes" xml:space="preserve">
          <source>This is shown in &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;ECMA-262 section 10.4.2&lt;/a&gt;:</source>
          <target state="translated">이는 &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;ECMA-262 섹션 10.4.2에 나와 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15626ab66ea3225794d92a6db19166a07fbc59dc" translate="yes" xml:space="preserve">
          <source>This object will be made the context of all Ajax-related callbacks.</source>
          <target state="translated">이 객체는 모든 Ajax 관련 콜백의 컨텍스트가됩니다.</target>
        </trans-unit>
        <trans-unit id="e589b5b7cd7e785bbedfd119fb0e0f15604df60b" translate="yes" xml:space="preserve">
          <source>To learn more about &lt;code&gt;this&lt;/code&gt;, have a look at the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;MDN documentation&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;MDN 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a019c43e711ee20b2a34f1b9e376cf74602d468" translate="yes" xml:space="preserve">
          <source>Use ES6 &lt;a href=&quot;https://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/&quot;&gt;Arrow&lt;/a&gt; functions.</source>
          <target state="translated">ES6 &lt;a href=&quot;https://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/&quot;&gt;화살표&lt;/a&gt; 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20ff1eb2976d955300bd8cf852c3e8f0f9f77d7f" translate="yes" xml:space="preserve">
          <source>We can not bind this to &lt;code&gt;setTimeout()&lt;/code&gt;, as it always execute with &lt;strong&gt;global object (Window)&lt;/strong&gt;, if you want to access &lt;code&gt;this&lt;/code&gt; context in the callback function then by using &lt;code&gt;bind()&lt;/code&gt; to the callback function we can achieve as:</source>
          <target state="translated">콜백 함수 &lt;code&gt;this&lt;/code&gt; 컨텍스트에 액세스하려면 콜백 함수에 &lt;code&gt;bind()&lt;/code&gt; 를 사용하여 다음과 같이 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0b2e61844178ceed95f0cf3e0781840c230c85f" translate="yes" xml:space="preserve">
          <source>We can set the value of this explicitly with &lt;code&gt;call()&lt;/code&gt;, &lt;code&gt;bind()&lt;/code&gt;, and &lt;code&gt;apply()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; , &lt;code&gt;bind()&lt;/code&gt; 및 &lt;code&gt;apply()&lt;/code&gt; 를 사용하여이 값을 명시 적으로 설정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a300d1f4446b37c0b75e60ce04944773b10b001e" translate="yes" xml:space="preserve">
          <source>What bind do is to create a new function with the &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword set to the provided value.</source>
          <target state="translated">바인드하는 것은 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 키워드를 제공된 값으로 설정하여 새 함수를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4774184c662135228fe2eca5b4143a4243962322" translate="yes" xml:space="preserve">
          <source>What you should know about &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 에 대해 알아야 할 것</target>
        </trans-unit>
        <trans-unit id="97fd1730e7a467b4a6d822e1e3a3cb3729262c7c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;new&lt;/code&gt; keyword is used (a constructor), this is bound to the new object being created.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 키워드가 사용되면 (생성자) 생성되는 새 객체에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2ce6733786b30aaf931173ecc812b54c22cceb1f" translate="yes" xml:space="preserve">
          <source>When you get the property from the object and call it in one go, the object will be the context for the method. If you call the same method, but in separate steps, the context is the global scope (window) instead:</source>
          <target state="translated">객체에서 속성을 가져 와서 한 번에 호출하면 객체가 메서드의 컨텍스트가됩니다. 동일한 방법을 별도의 단계로 호출하면 컨텍스트는 전역 범위 (창)가됩니다.</target>
        </trans-unit>
        <trans-unit id="e25fd97d359cb9f70c917d4a8fc8aaa38d0af671" translate="yes" xml:space="preserve">
          <source>When you get the reference of a method, it's no longer attached to the object, it's just a reference to a plain function. The same happens when you get the reference to use as a callback:</source>
          <target state="translated">메소드의 참조를 얻으면 더 이상 객체에 연결되지 않으며 단지 일반 함수에 대한 참조 일뿐입니다. 콜백으로 사용할 참조를 얻을 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b2ab3b5c803ea2983f02f151826822393ffb5bb0" translate="yes" xml:space="preserve">
          <source>With support of &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;class fields&lt;/a&gt;  it's possible to make it next way:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;클래스 필드를&lt;/a&gt; 지원하면 다음과 같은 방법으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a8ca667cc08ea85fc32a97b825a84dd7f067f0" translate="yes" xml:space="preserve">
          <source>You actually don't want to access &lt;code&gt;this&lt;/code&gt; in particular, but &lt;em&gt;the object it refers to&lt;/em&gt;. That's why an easy solution is to simply create a new variable that also refers to that object. The variable can have any name, but common ones are &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;that&lt;/code&gt;.</source>
          <target state="translated">당신은 실제로 &lt;code&gt;this&lt;/code&gt; 에 특히 접근하고 싶지 않지만 &lt;em&gt;그것이 참조하는 객체&lt;/em&gt; 입니다. 그렇기 때문에 쉬운 해결책은 단순히 해당 객체를 참조하는 새 변수를 만드는 것입니다. 변수는 임의의 이름을 가질 수 있지만 일반적인 것은 &lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;that&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eebe4cba4c37d26de7bca202344e49cbf52db06f" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bind&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bind&lt;/a&gt;()&lt;/code&gt; 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82ed2eb7f8fe82e1cc5eaa133924e42112028ac" translate="yes" xml:space="preserve">
          <source>although without its own bindings to the this, arguments, super, or new.target keywords.</source>
          <target state="translated">this, arguments, super 또는 new.target 키워드에 대한 바인딩이없는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f4b8f7b7d10494d345f58339c67f09da7c068fce" translate="yes" xml:space="preserve">
          <source>and ES2015 introduced arrow functions which don't provide their own this binding (it retains the this value of the enclosing lexical context).</source>
          <target state="translated">그리고 ES2015는 자체적으로이 바인딩을 제공하지 않는 화살표 함수를 도입했습니다 (이것은 묶는 어휘 문맥의이 값을 유지합니다).</target>
        </trans-unit>
        <trans-unit id="e367339213aec025c0797185e727419061a64dcf" translate="yes" xml:space="preserve">
          <source>and it is called like the following :</source>
          <target state="translated">다음과 같이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="066df75b17918161da47216d637d594ae709c370" translate="yes" xml:space="preserve">
          <source>and it is called like the following.Simply the callback is passed,</source>
          <target state="translated">콜백이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a93f4cff86a4e5446eb5a9aa9d39d95ac9dc9bb1" translate="yes" xml:space="preserve">
          <source>arrow-functions-vs-bind</source>
          <target state="translated">arrow-functions-vs-bind</target>
        </trans-unit>
        <trans-unit id="4a5199c7966224c5b4cc141786e8e79f22d8eb27" translate="yes" xml:space="preserve">
          <source>but it exhibits the same problems.</source>
          <target state="translated">그러나 같은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="24f2046f2ac57b0086fb1167486679211880885d" translate="yes" xml:space="preserve">
          <source>first one bind &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; with callback inside the method itself.And for the second one callback is passed with the object bound to it.</source>
          <target state="translated">첫 번째는 메소드 자체 내에서 콜백으로 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 바인딩합니다. 두 번째 콜백은 바인딩 된 객체와 함께 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="722fdafbf37a84106f8a486d49b288bc874e5f69" translate="yes" xml:space="preserve">
          <source>in short, global scope refers to the window object.Variables declared in a global scope are accessible from anywhere.On the other hand function scope resides inside of a function.variable  declared inside a function cannot be accessed from outside world normally.&lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword in global scope refers to the window object.&lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; inside function also refers to the window object.So &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; will always refer to the window until we find a way to manipulate &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; to indicate a context of our own choosing.</source>
          <target state="translated">간단히 말하면 전역 범위는 창 개체를 가리 킵니다. 전역 범위에서 선언 된 변수는 어디서나 액세스 할 수 있습니다. 반면에 함수 범위는 함수 내부에 있습니다. 함수 내부에서 선언 된 변수는 일반적으로 외부 세계에서 액세스 할 수 없습니다. 전역 범위 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 키워드는 창 개체를 나타냅니다. &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 내부 함수는 window 객체를 참조하기도합니다. 따라서 우리가 선택한 컨텍스트를 나타 내기 위해 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; 조작하는 방법을 찾을 때까지 항상 window를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="274c09237e0f83abe388f09d3de9e024fb90b62c" translate="yes" xml:space="preserve">
          <source>or explicitly call the function as a &quot;method&quot; of the object, by using an anonymous function as callback / event handler and assign the object (&lt;code&gt;this&lt;/code&gt;) to another variable:</source>
          <target state="translated">또는 익명 함수를 콜백 / 이벤트 핸들러로 사용하여 객체의 &quot;메서드&quot;로 함수를 명시 적으로 호출하고 객체 ( &lt;code&gt;this&lt;/code&gt; )를 다른 변수에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="e42a701e964de93b244d1ecb51d0a90fadefe1a9" translate="yes" xml:space="preserve">
          <source>or use an arrow function:</source>
          <target state="translated">또는 화살표 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ded874b7c351a41a7abac69562389b93ebef4a29" translate="yes" xml:space="preserve">
          <source>when called, has its this keyword set to the provided value,</source>
          <target state="translated">호출되면이 키워드가 제공된 값으로 설정되어 있으며</target>
        </trans-unit>
        <trans-unit id="f6875ad9393de98b36793855e7a2d1181c8d5274" translate="yes" xml:space="preserve">
          <source>which clearly indicates that &lt;em&gt;this&lt;/em&gt; is part of an execution context.</source>
          <target state="translated">이것은 &lt;em&gt;이것이&lt;/em&gt; 실행 컨텍스트의 일부임을 분명히 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9dd2f6e1d0f1041fbeb21cc91e6a5ddf5ebb1c62" translate="yes" xml:space="preserve">
          <source>with a given sequence of arguments preceding any provided when the new function is called.</source>
          <target state="translated">새로운 함수가 호출 될 때 제공된 일련의 인수를 제공합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
