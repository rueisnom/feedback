<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/20279484">
    <body>
      <group id="20279484">
        <trans-unit id="6a8bdb6458ccb5bee9b822332a5b4827ca338428" translate="yes" xml:space="preserve">
          <source>1. Use &lt;code&gt;bind()&lt;/code&gt; function</source>
          <target state="translated">1.使用 &lt;code&gt;bind()&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="17e4c8055d53b1988a8d696bb3defb11a904859e" translate="yes" xml:space="preserve">
          <source>2 Store reference to context/this inside another variable</source>
          <target state="translated">2 在另一个变量中存储对上下文this的引用</target>
        </trans-unit>
        <trans-unit id="092b15ab8b05a52dd3f21d6ea8b19b812165c04c" translate="yes" xml:space="preserve">
          <source>3 Arrow function</source>
          <target state="translated">3 箭头功能</target>
        </trans-unit>
        <trans-unit id="b83860e42609c8a7378127f94f739d0cfea363d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.oxforddictionaries.com/definition/english/context&quot;&gt;&quot;Context&quot;&lt;/a&gt; means the circumstances surrounding something that adds meaning, or some preceding and following information that gives extra meaning. The term &quot;context&quot; is used in ECMAScript to refer to &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;&lt;em&gt;execution context&lt;/em&gt;&lt;/a&gt;, which is all the parameters, scope and &lt;em&gt;this&lt;/em&gt; within the  scope of some executing code.</source>
          <target state="translated">&lt;a href=&quot;http://www.oxforddictionaries.com/definition/english/context&quot;&gt;&amp;ldquo;上下文&amp;rdquo;&lt;/a&gt;是指围绕某些事物增加含义的环境，或一些提供额外含义的前后信息。 ECMAScript中使用术语&amp;ldquo;上下文&amp;rdquo;来指代&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;&lt;em&gt;执行上下文&lt;/em&gt;&lt;/a&gt; ，它是所有参数，范围以及某些执行代码范围内的内容。</target>
        </trans-unit>
        <trans-unit id="c5df195d0650fc0ca42b314ce0b5ccb5491d11fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sayNameVersion1&lt;/code&gt; and &lt;code&gt;sayNameVersion2&lt;/code&gt; use bind to manipulate &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; of the callback function.</source>
          <target state="translated">&lt;code&gt;sayNameVersion1&lt;/code&gt; 和 &lt;code&gt;sayNameVersion2&lt;/code&gt; 使用bind操作回调函数。</target>
        </trans-unit>
        <trans-unit id="37b5b9961687599e81572e5c3967bd024409b075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sayNameVersion3&lt;/code&gt; uses  &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt; to manipulate the &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; to refer to the person object that we created, instead of the window object.</source>
          <target state="translated">&lt;code&gt;sayNameVersion3&lt;/code&gt; 使用&lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt;来操纵&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;来引用我们创建的人员对象，而不是窗口对象。</target>
        </trans-unit>
        <trans-unit id="25633ebfee31e03761dfa090994b8a4d62111b9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sayNameVersion4&lt;/code&gt; uses &lt;strong&gt;&lt;code&gt;apply&lt;/code&gt;&lt;/strong&gt; to manipulate &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; to refer to person object</source>
          <target state="translated">&lt;code&gt;sayNameVersion4&lt;/code&gt; 用于操纵&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;对象来引用人对象</target>
        </trans-unit>
        <trans-unit id="b18e527b1d07b3c750775dd0acd1239988f2f430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; (aka &quot;the context&quot;) is a special keyword inside each function and its value only depends on &lt;em&gt;how&lt;/em&gt; the function was called, not how/when/where it was defined. It is not affected by lexical scopes like other variables (except for arrow functions, see below). Here are some examples:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; （又名&amp;ldquo;上下文&amp;rdquo;）是每个函数内部的特殊关键字，其值仅取决于函数的调用方式，而不取决于函数的定义方式/定义时间/位置。 它不受其他变量之类的词法作用域的影响（箭头函数除外，请参见下文）。 这里有些例子：</target>
        </trans-unit>
        <trans-unit id="7ccbb9142cbc877fcba507f098664bac50d55d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;this&lt;/code&gt; &amp;amp; &lt;code&gt;scope&lt;/code&gt; :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; 和 &lt;code&gt;scope&lt;/code&gt; ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28d3e08a8329d2bf94877b367b5e9b6728015b6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As per my view you can implement &quot;this&quot; in three ways&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;(Self/Arrow function/Bind Method)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;根据我的观点，您可以通过三种方式&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;（自/箭头功能/绑定方法）&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;实现&amp;ldquo; this&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5ea14bd8172aaf9a6ba506e6e7ada4b00f6c5bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Different ways to manipulate &lt;code&gt;this&lt;/code&gt; inside callback functions:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在回调函数内部处理 &lt;code&gt;this&lt;/code&gt; 不同方法：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9807c7820d8498af9fd8b0f569eda762bd110fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Google clearly recommends to use lambdas rather than bind or &lt;code&gt;const self = this&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Google明确建议使用Lambda而不是bind或 &lt;code&gt;const self = this&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c9b836312f9b07af99edfd6d3c86fcf82d71366d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method1:&lt;/strong&gt; Self - Self is being used to maintain a reference to the original this even as the context is changing. It's a technique often used in event handlers (especially in closures).</source>
          <target state="translated">&lt;strong&gt;方法1：&lt;/strong&gt;自我-自我用于保持对原始内容的引用，即使上下文在变化。 这是事件处理程序中经常使用的一种技术（尤其是在闭包中）。</target>
        </trans-unit>
        <trans-unit id="58ee73240b34336c1698b25bbcce84697a17df3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method2&lt;/strong&gt;: Arrow function - An arrow function expression is a syntactically compact alternative to a regular function expression,</source>
          <target state="translated">&lt;strong&gt;方法2&lt;/strong&gt; ：箭头函数-箭头函数表达式在语法上比常规函数表达式紧凑，</target>
        </trans-unit>
        <trans-unit id="83807288d0c69591208b62be684605dc13b0d1ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method3&lt;/strong&gt;:Bind- The bind() method creates a new function that,</source>
          <target state="translated">&lt;strong&gt;方法3&lt;/strong&gt; ：绑定-bind（）方法创建一个新函数，</target>
        </trans-unit>
        <trans-unit id="fbff03a5b9cb0d04b7b2cf5d21c576fe76193276" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When binding context for jQuery, use &lt;a href=&quot;http://api.jquery.com/jQuery.proxy/&quot;&gt;&lt;code&gt;jQuery.proxy&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; instead. The reason to do this is so that you don't need to store the reference to the function when unbinding an event callback. jQuery handles that internally.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;当为jQuery绑定上下文时，请改用&lt;a href=&quot;http://api.jquery.com/jQuery.proxy/&quot;&gt; &lt;code&gt;jQuery.proxy&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 。 这样做的原因是，使您在取消绑定事件回调时不需要存储对该函数的引用。 jQuery在内部进行处理。</target>
        </trans-unit>
        <trans-unit id="7cddf8e8a39596a43c3943dc0b2a259074ff6e5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Whether or not you can pass a value for &lt;code&gt;this&lt;/code&gt; is usually mentioned in the documentation of that function/method. For example, &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery's &lt;code&gt;$.ajax&lt;/code&gt; method &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; describes an option called &lt;code&gt;context&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;通常可以在该函数/方法的文档中提及是否可以 &lt;code&gt;this&lt;/code&gt; 传递值。 例如， &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery的 &lt;code&gt;$.ajax&lt;/code&gt; 方法&lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;描述了一个称为 &lt;code&gt;context&lt;/code&gt; 的选项：</target>
        </trans-unit>
        <trans-unit id="207736ea8962167a3fa8bad382e8a76878d9f7be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference:&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Reference:&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75fdbb27ede9220d3d16fc78ac8586f0b59a2045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt; : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;参考&lt;/strong&gt; ： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this</target>
        </trans-unit>
        <trans-unit id="fc72ecd613eabb84943e85b3ada223948245ddd3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;参考&lt;/strong&gt; ： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</target>
        </trans-unit>
        <trans-unit id="ad22017702d23a420c03692bfa75469cbd587279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The solution&lt;/strong&gt; is the same as mentioned above: If available, use &lt;code&gt;.bind&lt;/code&gt; to explicitly bind &lt;code&gt;this&lt;/code&gt; to a specific value</source>
          <target state="translated">&lt;strong&gt;解决方案&lt;/strong&gt;与上述相同：如果可用，请使用 &lt;code&gt;.bind&lt;/code&gt; 将其显式绑定到特定值</target>
        </trans-unit>
        <trans-unit id="cf2a3ebd0bb3eb43331c09c74be73028c7ea8561" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You Should know about &quot;this&quot; Keyword.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;您应该了解&amp;ldquo; this&amp;rdquo;关键字。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33851166d311aa4e76eff3f3efc9621355eca157" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;apply :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;适用：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77695723b8f02b1b09ad8e9f4c42690237d82c6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bind :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;绑定：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e912e07305889ea58d8fde64c857c9a3fff38f53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;call :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;致电：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29532e96f632af398dba50619e57e074313b2fdd" translate="yes" xml:space="preserve">
          <source>A function's this keyword behaves a little differently in JavaScript compared to other languages.</source>
          <target state="translated">一个函数的这个关键字在JavaScript中的表现与其他语言相比有一点不同。</target>
        </trans-unit>
        <trans-unit id="912cdfca5e5ce094d53ff3186f01991ddc662fc7" translate="yes" xml:space="preserve">
          <source>Alter code/function design/architecture - for this you should have command over  &lt;a href=&quot;https://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;design patterns&lt;/a&gt; in javascript.</source>
          <target state="translated">更改代码/功能设计/架构-为此，您应该对javascript中的&lt;a href=&quot;https://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;设计模式&lt;/a&gt;有命令。</target>
        </trans-unit>
        <trans-unit id="52caaec3fba5f872647197877f4e4dd86e6a438a" translate="yes" xml:space="preserve">
          <source>An execution context provides the surrounding information that adds meaning to code that is being executed. It includes much more information than just the &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&lt;em&gt;thisBinding&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">执行上下文提供了周围的信息，这些信息为正在执行的代码增加了含义。 它不仅包含&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&lt;em&gt;thisBinding&lt;/em&gt;&lt;/a&gt; ，还包含更多信息。</target>
        </trans-unit>
        <trans-unit id="44d98e8b0d43f360e36798f40afed6e98237427a" translate="yes" xml:space="preserve">
          <source>Another approach, which is &lt;strong&gt;the standard way since DOM2&lt;/strong&gt; to bind &lt;code&gt;this&lt;/code&gt; within the event listener, that &lt;strong&gt;let you always remove the listener&lt;/strong&gt; (among other benefits), is the &lt;code&gt;handleEvent(evt)&lt;/code&gt;method from the &lt;code&gt;EventListener&lt;/code&gt; interface:</source>
          <target state="translated">&lt;strong&gt;自DOM2以来&lt;/strong&gt; ，将其绑定到事件侦听器中的另一种方法是 &lt;code&gt;EventListener&lt;/code&gt; 接口中的 &lt;code&gt;handleEvent(evt)&lt;/code&gt; 方法，这是&lt;strong&gt;使您始终删除侦听器&lt;/strong&gt; （还有其他好处）的一种标准方法：</target>
        </trans-unit>
        <trans-unit id="c7c7a67c1c463a52b508675c2a4fbcd7bd499c42" translate="yes" xml:space="preserve">
          <source>Another common manifestation of this problem is when an object method is used as callback/event handler. Functions are first-class citizens in JavaScript and the term &quot;method&quot; is just a colloquial term for a function that is a value of an object property. But that function doesn't have a specific link to its &quot;containing&quot; object.</source>
          <target state="translated">这个问题的另一种常见表现形式是当一个对象方法被用作回调事件处理程序时。函数是JavaScript中的第一等公民,&quot;方法 &quot;只是一个俗称,指的是一个函数是对象属性的值。但这个函数并没有具体的链接到它的 &quot;包含 &quot;对象。</target>
        </trans-unit>
        <trans-unit id="e5ca476aa209b8908ea0f9b7b407ec4efd27c9d0" translate="yes" xml:space="preserve">
          <source>Arrow Functions don&amp;rsquo;t bind &lt;code&gt;this&lt;/code&gt; &amp;mdash; instead, &lt;code&gt;this&lt;/code&gt; is bound lexically (i.e. based on the original context)</source>
          <target state="translated">箭头函数不绑定 &lt;code&gt;this&lt;/code&gt; ，而是按词法绑定（即基于原始上下文）</target>
        </trans-unit>
        <trans-unit id="ab65dda1433ac3a4a44f2e5a043e4ea34a973af0" translate="yes" xml:space="preserve">
          <source>Arrow function expressions are ill suited as methods, and they cannot be used as constructors.</source>
          <target state="translated">箭头函数表达式不适合作为方法,不能作为构造函数使用。</target>
        </trans-unit>
        <trans-unit id="68bb09850cf0694061b593eb35c2d88f9e91ba2c" translate="yes" xml:space="preserve">
          <source>As already mentioned at the beginning, what &lt;code&gt;this&lt;/code&gt; refers to depends on how the function is &lt;strong&gt;called&lt;/strong&gt;, not how it is &lt;strong&gt;defined&lt;/strong&gt;.</source>
          <target state="translated">如开始时已经提到的， &lt;code&gt;this&lt;/code&gt; 指的是取决于函数的&lt;strong&gt;调用方式&lt;/strong&gt; ，而不是函数的&lt;strong&gt;定义方式&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d2777b1eb41d0d72d449a11bc7ca8e6e5012319" translate="yes" xml:space="preserve">
          <source>As most of the answers suggest, we can use &lt;strong&gt;Arrow function or &lt;code&gt;bind()&lt;/code&gt; Method or Self&lt;/strong&gt; var. I would quote a point about lambdas (Arrow function) from &lt;a href=&quot;https://google.github.io/styleguide/jsguide.html#features-functions-arrow-functions&quot;&gt;Google JavaScript Style Guide&lt;/a&gt;</source>
          <target state="translated">正如大多数答案所暗示的，我们可以使用&lt;strong&gt;Arrow函数或 &lt;code&gt;bind()&lt;/code&gt; 方法或Self&lt;/strong&gt; var。 我会从&lt;a href=&quot;https://google.github.io/styleguide/jsguide.html#features-functions-arrow-functions&quot;&gt;Google JavaScript样式指南中&lt;/a&gt;引用有关lambdas（箭头功能）的观点</target>
        </trans-unit>
        <trans-unit id="e4a87be3685258b72d713f79d1bfa977f3e36674" translate="yes" xml:space="preserve">
          <source>Common problem: Using object methods as callbacks/event handlers</source>
          <target state="translated">常见问题:使用对象方法作为回调事件处理程序</target>
        </trans-unit>
        <trans-unit id="d7f69e049d11cfea430a186ac01ffac1bca0cfc8" translate="yes" xml:space="preserve">
          <source>Consider the following example:</source>
          <target state="translated">请看下面的例子:</target>
        </trans-unit>
        <trans-unit id="19baede9f95837656d71c40468e696396b8ec0b8" translate="yes" xml:space="preserve">
          <source>Currently there is another approach possible if classes are used in code.</source>
          <target state="translated">目前,如果在代码中使用类,还有另一种可能的方法。</target>
        </trans-unit>
        <trans-unit id="cbefe4b8aa228c45cb38892ce584258768af1d79" translate="yes" xml:space="preserve">
          <source>Detailed information about using &lt;code&gt;handleEvent&lt;/code&gt; can be found here: &lt;a href=&quot;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&quot;&gt;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&lt;/a&gt;</source>
          <target state="translated">有关使用 &lt;code&gt;handleEvent&lt;/code&gt; 的详细信息，可以在这里找到： &lt;a href=&quot;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&quot;&gt;https&lt;/a&gt; : //medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38</target>
        </trans-unit>
        <trans-unit id="8141d62fd2995e418997f9206b5101ba5385986d" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">不要用 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a2aba802819fc19a867deee3901f548f1feb051" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduces &lt;em&gt;arrow functions&lt;/em&gt;, which can be thought of as lambda functions. They don't have their own &lt;code&gt;this&lt;/code&gt; binding. Instead, &lt;code&gt;this&lt;/code&gt; is looked up in scope just like a normal variable. That means you don't have to call &lt;code&gt;.bind&lt;/code&gt;. That's not the only special behaviour they have, please refer to the MDN documentation for more information.</source>
          <target state="translated">ECMAScript 6引入了&lt;em&gt;箭头功能&lt;/em&gt; ，可以将其视为lambda函数。 他们没有自己的绑定。 相反， &lt;code&gt;this&lt;/code&gt; 像普通变量一样在范围内查找。 这意味着您不必调用 &lt;code&gt;.bind&lt;/code&gt; 。 这不是它们唯一的特殊行为，请参考MDN文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="6dbdc8171942a3d0dbd97de271857afd19174994" translate="yes" xml:space="preserve">
          <source>ECMAScript 6: Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt;</source>
          <target state="translated">ECMAScript 6：使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;箭头功能&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ce4cc15e461303a1b469af49c17a030b2eaa449" translate="yes" xml:space="preserve">
          <source>ES5 introduced the bind() method to set the value of a function's this regardless of how it's called,</source>
          <target state="translated">ES5引入了bind()方法来设置一个函数的这个值,不管它是如何调用的。</target>
        </trans-unit>
        <trans-unit id="3d92706e10419b5bc1277c566852681d2d948da0" translate="yes" xml:space="preserve">
          <source>Every function has the method &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;, which returns a new function with &lt;code&gt;this&lt;/code&gt; bound to a value. The function has exactly the same behaviour as the one you called &lt;code&gt;.bind&lt;/code&gt; on, only that &lt;code&gt;this&lt;/code&gt; was set by you. No matter how or when that function is called, &lt;code&gt;this&lt;/code&gt; will always refer to the passed value.</source>
          <target state="translated">每个函数都有方法&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; ，该方法返回一个绑定了值的新函数。 该函数的行为与调用 &lt;code&gt;.bind&lt;/code&gt; 的行为完全相同，只是该行为由您设置。 无论如何或何时调用该函数， &lt;code&gt;this&lt;/code&gt; 始终将引用传递的值。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="e9d6a485740427854045937df49a40853c402a69" translate="yes" xml:space="preserve">
          <source>Explicitly set &lt;code&gt;this&lt;/code&gt; of the callback - part 1</source>
          <target state="translated">明确设置 &lt;code&gt;this&lt;/code&gt; 回调-第1部分</target>
        </trans-unit>
        <trans-unit id="1126dd24f176d2a0b58861d9f7a6fa519f9c04cf" translate="yes" xml:space="preserve">
          <source>First, you need to have a clear understanding of &lt;strong&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/strong&gt; and behaviour of &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword in the context of &lt;strong&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">首先，您需要对&lt;strong&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/strong&gt;和&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;关键字在&lt;strong&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/strong&gt;上下文中的行为有清楚的了解。</target>
        </trans-unit>
        <trans-unit id="b98161925d8109b3e8a4d33cba64ddeafed7b359" translate="yes" xml:space="preserve">
          <source>For sure under the hood it's all old good arrow function that bind context but in this form it looks much more clear that explicit binding.</source>
          <target state="translated">可以肯定的是,在引擎盖下,它都是绑定上下文的箭头函数,但在这种形式下,它看起来比显式绑定要清晰得多。</target>
        </trans-unit>
        <trans-unit id="e61e7a281fa5c383fee31613c5a0509a8533e6d5" translate="yes" xml:space="preserve">
          <source>Here I have a constructor function called Person. It has a property called &lt;strong&gt;&lt;code&gt;name&lt;/code&gt;&lt;/strong&gt; and four method called &lt;strong&gt;&lt;code&gt;sayNameVersion1&lt;/code&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;code&gt;sayNameVersion2&lt;/code&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;code&gt;sayNameVersion3&lt;/code&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;code&gt;sayNameVersion4&lt;/code&gt;&lt;/strong&gt;. All four of them has one specific task.Accept a callback and invoke it.The callback has a specific task which is to log the name property of an instance of Person constructor function.</source>
          <target state="translated">在这里，我有一个名为Person的构造函数。 它具有一个名为&lt;strong&gt; &lt;code&gt;name&lt;/code&gt; &lt;/strong&gt;的属性和四个名为&lt;strong&gt; &lt;code&gt;sayNameVersion1&lt;/code&gt; &lt;/strong&gt; ， &lt;strong&gt; &lt;code&gt;sayNameVersion2&lt;/code&gt; &lt;/strong&gt; ， &lt;strong&gt; &lt;code&gt;sayNameVersion3&lt;/code&gt; &lt;/strong&gt; ， &lt;strong&gt; &lt;code&gt;sayNameVersion4&lt;/code&gt; 的方法&lt;/strong&gt; 。 它们全部有一个特定的任务。接受一个回调并调用它。回调具有一个特定的任务，即记录Person构造函数实例的name属性。</target>
        </trans-unit>
        <trans-unit id="4acb81ac127a3601d53820d4d0f45171677e988c" translate="yes" xml:space="preserve">
          <source>Here are several ways to access parent context inside child context -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e2143fbc09476ddf872285e4ee8305918dc1ef" translate="yes" xml:space="preserve">
          <source>How can I access the correct object?</source>
          <target state="translated">如何才能访问正确的对象?</target>
        </trans-unit>
        <trans-unit id="ae2ce4ed9d749ac553a5952af8ed485252570f3f" translate="yes" xml:space="preserve">
          <source>How to access the correct `this` inside a callback</source>
          <target state="translated">如何在回调中访问正确的 &quot;this&quot;?</target>
        </trans-unit>
        <trans-unit id="6f908c89120425f927f214344354c0aca40f8b35" translate="yes" xml:space="preserve">
          <source>How to refer to the correct &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">如何正确地参考 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ed5328abf66e902733b964229b89a9e88ccb98f" translate="yes" xml:space="preserve">
          <source>However, I'm not able to access the &lt;code&gt;data&lt;/code&gt; property of the created object inside the callback. It looks like &lt;code&gt;this&lt;/code&gt; does not refer to the object that was created but to an other one.</source>
          <target state="translated">但是，我无法在回调内部访问已创建对象的 &lt;code&gt;data&lt;/code&gt; 属性。 看起来 &lt;code&gt;this&lt;/code&gt; 并不引用创建的对象，而是引用另一个对象。</target>
        </trans-unit>
        <trans-unit id="323833fe30e701dd0afbe644972c8297131ffd00" translate="yes" xml:space="preserve">
          <source>I also tried to use an object method instead of an anonymous function:</source>
          <target state="translated">我也尝试过用对象方法来代替匿名函数。</target>
        </trans-unit>
        <trans-unit id="eaec236d744509e537cc8f03f2dea9ad53761954" translate="yes" xml:space="preserve">
          <source>I have a constructor function which registers an event handler:</source>
          <target state="translated">我有一个构造函数,可以注册一个事件处理程序。</target>
        </trans-unit>
        <trans-unit id="5b371a6ae052214f7818ec3deaed3e9b738646dd" translate="yes" xml:space="preserve">
          <source>If strict mode is enabled for any function then the value of &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; as in strict mode, global object refers to &lt;code&gt;undefined&lt;/code&gt; in place of the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">如果为任何功能启用了严格模式，则该值将像在严格模式下一样 &lt;code&gt;undefined&lt;/code&gt; ，全局对象是 &lt;code&gt;undefined&lt;/code&gt; ，而不是 &lt;code&gt;window&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="97f3987d7dc7237e2cfee6a8dbacca0a0a502d88" translate="yes" xml:space="preserve">
          <source>If the code was like the following, it might be more obvious that the function doesn't have an implicit reference to the object:</source>
          <target state="translated">如果代码像下面这样,可能更明显的是函数没有隐含引用对象。</target>
        </trans-unit>
        <trans-unit id="44286d5d725e24975302df95630b6a88edcc2bf7" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;underscore.js&lt;/code&gt; - &lt;a href=&quot;http://underscorejs.org/#bind&quot;&gt;http://underscorejs.org/#bind&lt;/a&gt;</source>
          <target state="translated">如果您使用的是 &lt;code&gt;underscore.js&lt;/code&gt; - &lt;a href=&quot;http://underscorejs.org/#bind&quot;&gt;http://underscorejs.org/#bind&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fde7334616f0dd164f29fddbf11acc809feee752" translate="yes" xml:space="preserve">
          <source>If you are using jQuery you should use the &lt;code&gt;$.proxy&lt;/code&gt; method instead, as &lt;code&gt;bind&lt;/code&gt; is not supported in all browsers:</source>
          <target state="translated">如果您使用的是jQuery，则应改用 &lt;code&gt;$.proxy&lt;/code&gt; 方法，因为并非所有浏览器都支持 &lt;code&gt;bind&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="13d3e294e950b7f4ab84cf9acca0ccd56c984cff" translate="yes" xml:space="preserve">
          <source>In most cases, the value of this is determined by how a function is called.</source>
          <target state="translated">在大多数情况下,这个值是由函数的调用方式决定的。</target>
        </trans-unit>
        <trans-unit id="fa250ce283226ff53d868b2d334cd5e88dff4429" translate="yes" xml:space="preserve">
          <source>In the global scope, &lt;code&gt;this&lt;/code&gt; refers to the global object (the &lt;code&gt;window&lt;/code&gt; object).</source>
          <target state="translated">在全局范围内， &lt;code&gt;this&lt;/code&gt; 是指全局对象（ &lt;code&gt;window&lt;/code&gt; 对象）。</target>
        </trans-unit>
        <trans-unit id="84cfc4df2cedf0a396870ba012ed9bfc0f2b3c6c" translate="yes" xml:space="preserve">
          <source>In this case, we are binding the callback's &lt;code&gt;this&lt;/code&gt; to the value of &lt;code&gt;MyConstructor&lt;/code&gt;'s &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，我们将回调的 &lt;code&gt;this&lt;/code&gt; 绑定到 &lt;code&gt;MyConstructor&lt;/code&gt; 的this的值。</target>
        </trans-unit>
        <trans-unit id="30b4b861a818b8aa39958b98513130afef359643" translate="yes" xml:space="preserve">
          <source>It also has some differences between strict mode and non-strict mode.</source>
          <target state="translated">它也有严格模式和非严格模式的一些区别。</target>
        </trans-unit>
        <trans-unit id="b5a4468c39b48f1e066f8525bae2767e24645b5a" translate="yes" xml:space="preserve">
          <source>It can't be set by assignment during execution, and it may be different each time the function is called.</source>
          <target state="translated">在执行过程中不能通过赋值来设置,每次调用函数的时候,它可能会有不同的变化。</target>
        </trans-unit>
        <trans-unit id="c856cf98c012850bf9e871b799e02d2f89139d0f" translate="yes" xml:space="preserve">
          <source>It might look like you have no control over the value of &lt;code&gt;this&lt;/code&gt; because its value is set automatically, but that is actually not the case.</source>
          <target state="translated">您似乎无法控制此值，因为它的值是自动设置的，但实际上并非如此。</target>
        </trans-unit>
        <trans-unit id="3a5c614e4a858c76be5f61117786c7f01782da3a" translate="yes" xml:space="preserve">
          <source>It's all in the &quot;magic&quot; syntax of calling a method:</source>
          <target state="translated">这一切都在调用方法的 &quot;神奇 &quot;语法中。</target>
        </trans-unit>
        <trans-unit id="d212c8aab88e3b2c631bdfa314a2c158284a9689" translate="yes" xml:space="preserve">
          <source>Now let's create an instance from person constructor and invoke different versions of &lt;strong&gt;&lt;code&gt;sayNameVersionX&lt;/code&gt;&lt;/strong&gt; ( X refers to 1,2,3,4 ) method with &lt;strong&gt;&lt;code&gt;niceCallback&lt;/code&gt;&lt;/strong&gt; to see how many ways we can manipulate the &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; inside callback to refer to the &lt;strong&gt;&lt;code&gt;person&lt;/code&gt;&lt;/strong&gt; instance.</source>
          <target state="translated">现在，让我们从person构造函数创建一个实例，并使用&lt;strong&gt; &lt;code&gt;sayNameVersionX&lt;/code&gt; &lt;/strong&gt;调用不同版本的&lt;strong&gt;sayNameVersionX&lt;/strong&gt; （X表示1,2,3,4）方法，以查看我们有多少种方法可以操纵&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;内部回调来引用&lt;strong&gt; &lt;code&gt;person&lt;/code&gt; &lt;/strong&gt;实例。</target>
        </trans-unit>
        <trans-unit id="bd382a556e0627a895f9d61c9e039efe9520f3a7" translate="yes" xml:space="preserve">
          <source>Prefer using arrow functions over f.bind(this), and especially over
  goog.bind(f, this). Avoid writing const self = this. Arrow functions
  are particularly useful for callbacks, which sometimes pass unexpected
  additional arguments.</source>
          <target state="translated">优先使用箭头函数而不是f.bind(this),尤其是goog.bind(f,this)。避免写 const self=this。箭头函数对于回调特别有用,因为有时会传递一些意想不到的额外参数。</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="0659a76d505497879be6cfbe39c059f2d61df867" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;this&lt;/code&gt; of the callback - part 2</source>
          <target state="translated">设置 &lt;code&gt;this&lt;/code&gt; 回调-第2部分</target>
        </trans-unit>
        <trans-unit id="56be075e48deed785dc54c97a107dbdfab73da93" translate="yes" xml:space="preserve">
          <source>Set the ThisBinding to the same value as the ThisBinding of the
  calling execution context</source>
          <target state="translated">将 ThisBinding 设置为与调用执行上下文的 ThisBinding 相同的值</target>
        </trans-unit>
        <trans-unit id="1e9e29d4637f7cebd0369d655eda5c71d09b9233" translate="yes" xml:space="preserve">
          <source>Similar to &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt;, first argument of &lt;strong&gt;&lt;code&gt;apply&lt;/code&gt;&lt;/strong&gt; refers to the object that will be indicated by &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword.</source>
          <target state="translated">与&lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt;相似， &lt;strong&gt; &lt;code&gt;apply&lt;/code&gt; 的&lt;/strong&gt;第一个参数指的是将&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;关键字指示的对象。</target>
        </trans-unit>
        <trans-unit id="15dc5824306174e1163181b6492db3027e7184ba" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;self&lt;/code&gt; is a normal variable, it obeys lexical scope rules and is accessible inside the callback. This also has the advantage that you can access the &lt;code&gt;this&lt;/code&gt; value of the callback itself.</source>
          <target state="translated">由于 &lt;code&gt;self&lt;/code&gt; 是一个普通变量，因此它遵循词汇范围规则，并且可以在回调内部进行访问。 这还有一个优点，就是您可以访问回调本身的 &lt;code&gt;this&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="841ea9b7a24ab9b0a4a11eb3d639efba860efaaa" translate="yes" xml:space="preserve">
          <source>Since it's Stage 3 Proposal you will need babel and appropriate &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-proposal-class-properties&quot;&gt;babel plugin&lt;/a&gt; to process it as for now(08/2018).</source>
          <target state="translated">由于是Stage 3 Proposal，因此您现在需要Babel和适当的&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-proposal-class-properties&quot;&gt;babel插件&lt;/a&gt;来处理它（08/2018）。</target>
        </trans-unit>
        <trans-unit id="cdbe775fb45eb5ef2d2e6ce73eeeb4fd35368bf8" translate="yes" xml:space="preserve">
          <source>So the best solution would be to use lambdas as below,</source>
          <target state="translated">所以,最好的解决办法是使用下面的羊皮纸,如下图所示。</target>
        </trans-unit>
        <trans-unit id="744d624b35c5c9839f7ef2f10dd23136a872cd13" translate="yes" xml:space="preserve">
          <source>So the value of &lt;em&gt;this&lt;/em&gt; isn't &quot;context&quot;, it's just one part of an execution context. It's essentially a local variable that can be set by the call to any object and in strict mode, to any value at all.</source>
          <target state="translated">因此， &lt;em&gt;此&lt;/em&gt;值不是&amp;ldquo;上下文&amp;rdquo;，它只是执行上下文的一部分。 从本质上讲，它是一个局部变量，可以通过调用任何对象并在严格模式下将其设置为任何值。</target>
        </trans-unit>
        <trans-unit id="08e7c0641502b25341ef35ff01a6e8bc40419c8b" translate="yes" xml:space="preserve">
          <source>Some functions/methods which accept callbacks also accept a value to which the callback's &lt;code&gt;this&lt;/code&gt; should refer to. This is basically the same as binding it yourself, but the function/method does it for you. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;Array#map&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; is such a method. Its signature is:</source>
          <target state="translated">某些接受回调的函数/方法也接受该回调应引用的值。 这基本上与您自己绑定它相同，但是函数/方法可以为您完成它。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;Array#map&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;是这种方法。 它的签名是：</target>
        </trans-unit>
        <trans-unit id="d98f29032871395567d10fa9475d0524189b4f4b" translate="yes" xml:space="preserve">
          <source>Store reference to context/this inside another variable(see below example).</source>
          <target state="translated">将contextthis的引用存储在另一个变量中(见下面的例子)。</target>
        </trans-unit>
        <trans-unit id="46ccc3ce57128d895c43982bc51d536f065ddef4" translate="yes" xml:space="preserve">
          <source>That's where you would bind the context to the function:</source>
          <target state="translated">这就是你要把上下文与功能绑定的地方。</target>
        </trans-unit>
        <trans-unit id="8ea6ca42490b74de48fe8ae9a2bd9ccd3e0033f6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;first argument&lt;/code&gt;&lt;/strong&gt; of the &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt; method is used as &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; inside the function that is invoked with &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt; attached to it.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt;方法的&lt;strong&gt; &lt;code&gt;first argument&lt;/code&gt; &lt;/strong&gt;在附加了调用的函数内部使用。</target>
        </trans-unit>
        <trans-unit id="55ff58898b5dfe7076511fbcd2d228ee39265388" translate="yes" xml:space="preserve">
          <source>The first argument is the callback and the second argument is the value &lt;code&gt;this&lt;/code&gt; should refer to. Here is a contrived example:</source>
          <target state="translated">第一个参数是回调，第二个参数是应引用的值。 这是一个人为的示例：</target>
        </trans-unit>
        <trans-unit id="67a37244ad69c52151f22e62ecb8e655636407eb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;this.method&lt;/code&gt; is assigned as click event handler, but if the &lt;code&gt;document.body&lt;/code&gt; is clicked, the value logged will be &lt;code&gt;undefined&lt;/code&gt;, because inside the event handler, &lt;code&gt;this&lt;/code&gt; refers to the &lt;code&gt;document.body&lt;/code&gt;, not the instance of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;this.method&lt;/code&gt; 被分配为click事件处理程序，但是如果单击 &lt;code&gt;document.body&lt;/code&gt; ，则记录的值将是 &lt;code&gt;undefined&lt;/code&gt; ，因为在事件处理程序内部， &lt;code&gt;this&lt;/code&gt; 引用 &lt;code&gt;document.body&lt;/code&gt; ，而不是 &lt;code&gt;Foo&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="b0f83deeb19c855f6e5e7fd4353ef35b56f82a60" translate="yes" xml:space="preserve">
          <source>The object that is standing before the dot is what the this keyword will be bound to.</source>
          <target state="translated">站在点之前的对象就是这个关键词将被绑定的对象。</target>
        </trans-unit>
        <trans-unit id="fc3b4ab1171b67adb539b65128c31a6fe985a69d" translate="yes" xml:space="preserve">
          <source>The question revolves around how &lt;code&gt;this&lt;/code&gt; keyword behaves in javascript. &lt;code&gt;this&lt;/code&gt; behaves differently as below,</source>
          <target state="translated">问题围绕着 &lt;code&gt;this&lt;/code&gt; 关键字在javascript中的行为。 表现如下</target>
        </trans-unit>
        <trans-unit id="4f5bf601799b4826496754deacc27d88b45812b9" translate="yes" xml:space="preserve">
          <source>The term &quot;context&quot; is sometimes used to refer to the object referenced by &lt;em&gt;this&lt;/em&gt;. Its use is inappropriate because it doesn't fit either semantically or technically with &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;ECMAScript's &lt;em&gt;this&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">术语&amp;ldquo;上下文&amp;rdquo;有时用于表示&lt;em&gt;this&lt;/em&gt;引用的对象。 它的使用是不合适的，因为它在语义上或技术上都不适合&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;ECMAScript的&lt;em&gt;this&lt;/em&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="29e596611ce94c8c6c1da3cd4238c2debd6a73d7" translate="yes" xml:space="preserve">
          <source>The trouble with &quot;context&quot;</source>
          <target state="translated">&quot;语境 &quot;的问题</target>
        </trans-unit>
        <trans-unit id="5f6b0d54cfa64916d991e3233dd9a414d112f53d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; is usually determined by a functions execution context.</source>
          <target state="translated">此值通常由函数执行上下文确定。</target>
        </trans-unit>
        <trans-unit id="2c07ebf251b294d81ec44d6e5bd3eb7a7dcfbcd1" translate="yes" xml:space="preserve">
          <source>This is shown in &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;ECMA-262 section 10.4.2&lt;/a&gt;:</source>
          <target state="translated">这在&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;ECMA-262第10.4.2节中显示&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="15626ab66ea3225794d92a6db19166a07fbc59dc" translate="yes" xml:space="preserve">
          <source>This object will be made the context of all Ajax-related callbacks.</source>
          <target state="translated">这个对象将成为所有Ajax相关回调的上下文。</target>
        </trans-unit>
        <trans-unit id="e589b5b7cd7e785bbedfd119fb0e0f15604df60b" translate="yes" xml:space="preserve">
          <source>To learn more about &lt;code&gt;this&lt;/code&gt;, have a look at the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;MDN documentation&lt;/a&gt;.</source>
          <target state="translated">要了解更多信息，请查看&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;MDN文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a019c43e711ee20b2a34f1b9e376cf74602d468" translate="yes" xml:space="preserve">
          <source>Use ES6 &lt;a href=&quot;https://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/&quot;&gt;Arrow&lt;/a&gt; functions.</source>
          <target state="translated">使用ES6 &lt;a href=&quot;https://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/&quot;&gt;箭头&lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="20ff1eb2976d955300bd8cf852c3e8f0f9f77d7f" translate="yes" xml:space="preserve">
          <source>We can not bind this to &lt;code&gt;setTimeout()&lt;/code&gt;, as it always execute with &lt;strong&gt;global object (Window)&lt;/strong&gt;, if you want to access &lt;code&gt;this&lt;/code&gt; context in the callback function then by using &lt;code&gt;bind()&lt;/code&gt; to the callback function we can achieve as:</source>
          <target state="translated">我们不能将其绑定到 &lt;code&gt;setTimeout()&lt;/code&gt; ，因为它总是与&lt;strong&gt;全局对象（Window）&lt;/strong&gt;一起执行，如果您想在回调函数中访问 &lt;code&gt;this&lt;/code&gt; 上下文，则可以通过对回调函数使用 &lt;code&gt;bind()&lt;/code&gt; 来实现：</target>
        </trans-unit>
        <trans-unit id="f0b2e61844178ceed95f0cf3e0781840c230c85f" translate="yes" xml:space="preserve">
          <source>We can set the value of this explicitly with &lt;code&gt;call()&lt;/code&gt;, &lt;code&gt;bind()&lt;/code&gt;, and &lt;code&gt;apply()&lt;/code&gt;</source>
          <target state="translated">我们可以使用 &lt;code&gt;call()&lt;/code&gt; ， &lt;code&gt;bind()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 显式设置其值。</target>
        </trans-unit>
        <trans-unit id="a300d1f4446b37c0b75e60ce04944773b10b001e" translate="yes" xml:space="preserve">
          <source>What bind do is to create a new function with the &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword set to the provided value.</source>
          <target state="translated">绑定的作用是使用&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;关键字设置为提供的值来创建一个新函数。</target>
        </trans-unit>
        <trans-unit id="4774184c662135228fe2eca5b4143a4243962322" translate="yes" xml:space="preserve">
          <source>What you should know about &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">您应该知道些什么</target>
        </trans-unit>
        <trans-unit id="97fd1730e7a467b4a6d822e1e3a3cb3729262c7c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;new&lt;/code&gt; keyword is used (a constructor), this is bound to the new object being created.</source>
          <target state="translated">当使用 &lt;code&gt;new&lt;/code&gt; 关键字（构造函数）时，它将绑定到正在创建的新对象。</target>
        </trans-unit>
        <trans-unit id="2ce6733786b30aaf931173ecc812b54c22cceb1f" translate="yes" xml:space="preserve">
          <source>When you get the property from the object and call it in one go, the object will be the context for the method. If you call the same method, but in separate steps, the context is the global scope (window) instead:</source>
          <target state="translated">当你从对象中获取属性并一次性调用时,该对象将成为该方法的上下文。如果你调用同一个方法,但在不同的步骤中调用,那么上下文就是全局范围(窗口)。</target>
        </trans-unit>
        <trans-unit id="e25fd97d359cb9f70c917d4a8fc8aaa38d0af671" translate="yes" xml:space="preserve">
          <source>When you get the reference of a method, it's no longer attached to the object, it's just a reference to a plain function. The same happens when you get the reference to use as a callback:</source>
          <target state="translated">当你得到一个方法的引用时,它不再附着在对象上,它只是一个普通函数的引用。当你得到引用作为回调使用时也是一样的。</target>
        </trans-unit>
        <trans-unit id="b2ab3b5c803ea2983f02f151826822393ffb5bb0" translate="yes" xml:space="preserve">
          <source>With support of &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;class fields&lt;/a&gt;  it's possible to make it next way:</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;类字段&lt;/a&gt;的支持下，可以进行其他操作：</target>
        </trans-unit>
        <trans-unit id="f2a8ca667cc08ea85fc32a97b825a84dd7f067f0" translate="yes" xml:space="preserve">
          <source>You actually don't want to access &lt;code&gt;this&lt;/code&gt; in particular, but &lt;em&gt;the object it refers to&lt;/em&gt;. That's why an easy solution is to simply create a new variable that also refers to that object. The variable can have any name, but common ones are &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;that&lt;/code&gt;.</source>
          <target state="translated">实际上，您实际上不想访问 &lt;code&gt;this&lt;/code&gt; &lt;em&gt;对象&lt;/em&gt; ，但是要访问&lt;em&gt;它所指向的对象&lt;/em&gt; 。 这就是为什么一个简单的解决方案是简单地创建一个也引用该对象的新变量。 该变量可以具有任何名称，但是常见的名称是 &lt;code&gt;self&lt;/code&gt; 和 &lt;code&gt;that&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eebe4cba4c37d26de7bca202344e49cbf52db06f" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bind&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">您可以使用 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bind&lt;/a&gt;()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="c82ed2eb7f8fe82e1cc5eaa133924e42112028ac" translate="yes" xml:space="preserve">
          <source>although without its own bindings to the this, arguments, super, or new.target keywords.</source>
          <target state="translated">虽然没有自己绑定this、arguments、super或new.target关键字。</target>
        </trans-unit>
        <trans-unit id="f4b8f7b7d10494d345f58339c67f09da7c068fce" translate="yes" xml:space="preserve">
          <source>and ES2015 introduced arrow functions which don't provide their own this binding (it retains the this value of the enclosing lexical context).</source>
          <target state="translated">和ES2015引入了不提供自己的这个绑定的箭头函数(它保留了这个值的包围词义上下文)。</target>
        </trans-unit>
        <trans-unit id="e367339213aec025c0797185e727419061a64dcf" translate="yes" xml:space="preserve">
          <source>and it is called like the following :</source>
          <target state="translated">而它被称为如下所示。</target>
        </trans-unit>
        <trans-unit id="066df75b17918161da47216d637d594ae709c370" translate="yes" xml:space="preserve">
          <source>and it is called like the following.Simply the callback is passed,</source>
          <target state="translated">它的调用方式如下。</target>
        </trans-unit>
        <trans-unit id="a93f4cff86a4e5446eb5a9aa9d39d95ac9dc9bb1" translate="yes" xml:space="preserve">
          <source>arrow-functions-vs-bind</source>
          <target state="translated">arrow-functions-vs-bind</target>
        </trans-unit>
        <trans-unit id="4a5199c7966224c5b4cc141786e8e79f22d8eb27" translate="yes" xml:space="preserve">
          <source>but it exhibits the same problems.</source>
          <target state="translated">但它表现出同样的问题。</target>
        </trans-unit>
        <trans-unit id="24f2046f2ac57b0086fb1167486679211880885d" translate="yes" xml:space="preserve">
          <source>first one bind &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; with callback inside the method itself.And for the second one callback is passed with the object bound to it.</source>
          <target state="translated">第一个与方法本身内部的回调绑定在一起，第二个与绑定的对象一起传递回调。</target>
        </trans-unit>
        <trans-unit id="722fdafbf37a84106f8a486d49b288bc874e5f69" translate="yes" xml:space="preserve">
          <source>in short, global scope refers to the window object.Variables declared in a global scope are accessible from anywhere.On the other hand function scope resides inside of a function.variable  declared inside a function cannot be accessed from outside world normally.&lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword in global scope refers to the window object.&lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; inside function also refers to the window object.So &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; will always refer to the window until we find a way to manipulate &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; to indicate a context of our own choosing.</source>
          <target state="translated">简而言之，全局作用域是指window对象。在全局作用域中声明的变量可以从任何地方访问;另一方面，函数作用域位于函数内部。在函数内部声明的变量通常不能从外部访问。 全局范围内的&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;关键字引用窗口对象。 &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;内部函数也指的是窗口对象， &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;它将一直指代窗口，直到我们找到一种操纵&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;的方式来指示我们自己选择的上下文为止。</target>
        </trans-unit>
        <trans-unit id="274c09237e0f83abe388f09d3de9e024fb90b62c" translate="yes" xml:space="preserve">
          <source>or explicitly call the function as a &quot;method&quot; of the object, by using an anonymous function as callback / event handler and assign the object (&lt;code&gt;this&lt;/code&gt;) to another variable:</source>
          <target state="translated">或通过将匿名函数用作回调/事件处理程序并将该对象（ &lt;code&gt;this&lt;/code&gt; ）分配给另一个变量，来显式调用该函数作为对象的&amp;ldquo;方法&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="e42a701e964de93b244d1ecb51d0a90fadefe1a9" translate="yes" xml:space="preserve">
          <source>or use an arrow function:</source>
          <target state="translated">或使用箭头功能。</target>
        </trans-unit>
        <trans-unit id="ded874b7c351a41a7abac69562389b93ebef4a29" translate="yes" xml:space="preserve">
          <source>when called, has its this keyword set to the provided value,</source>
          <target state="translated">调用时,将其this关键字设置为所提供的值。</target>
        </trans-unit>
        <trans-unit id="f6875ad9393de98b36793855e7a2d1181c8d5274" translate="yes" xml:space="preserve">
          <source>which clearly indicates that &lt;em&gt;this&lt;/em&gt; is part of an execution context.</source>
          <target state="translated">这清楚地表明&lt;em&gt;这&lt;/em&gt;是执行上下文的一部分。</target>
        </trans-unit>
        <trans-unit id="9dd2f6e1d0f1041fbeb21cc91e6a5ddf5ebb1c62" translate="yes" xml:space="preserve">
          <source>with a given sequence of arguments preceding any provided when the new function is called.</source>
          <target state="translated">在新函数被调用时,在给定的参数序列之前的任何给定参数。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
