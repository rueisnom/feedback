<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/20279484">
    <body>
      <group id="20279484">
        <trans-unit id="6a8bdb6458ccb5bee9b822332a5b4827ca338428" translate="yes" xml:space="preserve">
          <source>1. Use &lt;code&gt;bind()&lt;/code&gt; function</source>
          <target state="translated">1. Используйте функцию &lt;code&gt;bind()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17e4c8055d53b1988a8d696bb3defb11a904859e" translate="yes" xml:space="preserve">
          <source>2 Store reference to context/this inside another variable</source>
          <target state="translated">2 Хранить ссылку на контекст-это внутри другой переменной.</target>
        </trans-unit>
        <trans-unit id="092b15ab8b05a52dd3f21d6ea8b19b812165c04c" translate="yes" xml:space="preserve">
          <source>3 Arrow function</source>
          <target state="translated">3 Стрелочная функция</target>
        </trans-unit>
        <trans-unit id="b83860e42609c8a7378127f94f739d0cfea363d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.oxforddictionaries.com/definition/english/context&quot;&gt;&quot;Context&quot;&lt;/a&gt; means the circumstances surrounding something that adds meaning, or some preceding and following information that gives extra meaning. The term &quot;context&quot; is used in ECMAScript to refer to &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;&lt;em&gt;execution context&lt;/em&gt;&lt;/a&gt;, which is all the parameters, scope and &lt;em&gt;this&lt;/em&gt; within the  scope of some executing code.</source>
          <target state="translated">&lt;a href=&quot;http://www.oxforddictionaries.com/definition/english/context&quot;&gt;&amp;laquo;Контекст&amp;raquo;&lt;/a&gt; означает обстоятельства, окружающие что-то, что добавляет значение, или некоторую предшествующую и следующую информацию, которая придает дополнительный смысл. Термин &amp;laquo;контекст&amp;raquo; используется в ECMAScript для обозначения &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;&lt;em&gt;контекста выполнения&lt;/em&gt;&lt;/a&gt; , который представляет собой все параметры, область действия и &lt;em&gt;это&lt;/em&gt; в рамках некоторого исполняемого кода.</target>
        </trans-unit>
        <trans-unit id="c5df195d0650fc0ca42b314ce0b5ccb5491d11fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sayNameVersion1&lt;/code&gt; and &lt;code&gt;sayNameVersion2&lt;/code&gt; use bind to manipulate &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; of the callback function.</source>
          <target state="translated">&lt;code&gt;sayNameVersion1&lt;/code&gt; и &lt;code&gt;sayNameVersion2&lt;/code&gt; используют bind для управления &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; функцией обратного вызова.</target>
        </trans-unit>
        <trans-unit id="37b5b9961687599e81572e5c3967bd024409b075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sayNameVersion3&lt;/code&gt; uses  &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt; to manipulate the &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; to refer to the person object that we created, instead of the window object.</source>
          <target state="translated">&lt;code&gt;sayNameVersion3&lt;/code&gt; использует &lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt; для манипулирования &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; ,&lt;/strong&gt; чтобы ссылаться на объект person, который мы создали, вместо объекта window.</target>
        </trans-unit>
        <trans-unit id="25633ebfee31e03761dfa090994b8a4d62111b9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sayNameVersion4&lt;/code&gt; uses &lt;strong&gt;&lt;code&gt;apply&lt;/code&gt;&lt;/strong&gt; to manipulate &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; to refer to person object</source>
          <target state="translated">&lt;code&gt;sayNameVersion4&lt;/code&gt; использует &lt;strong&gt; &lt;code&gt;apply&lt;/code&gt; ,&lt;/strong&gt; чтобы манипулировать &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; чтобы ссылаться на объект person</target>
        </trans-unit>
        <trans-unit id="b18e527b1d07b3c750775dd0acd1239988f2f430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; (aka &quot;the context&quot;) is a special keyword inside each function and its value only depends on &lt;em&gt;how&lt;/em&gt; the function was called, not how/when/where it was defined. It is not affected by lexical scopes like other variables (except for arrow functions, see below). Here are some examples:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; (он же &amp;laquo;контекст&amp;raquo;) является специальным ключевым словом внутри каждой функции, и его значение зависит только от &lt;em&gt;того, как&lt;/em&gt; была вызвана функция, а не от того, как / когда / где она была определена. На него не влияют лексические области, как и другие переменные (кроме функций со стрелками, см. Ниже). Вот некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="7ccbb9142cbc877fcba507f098664bac50d55d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;this&lt;/code&gt; &amp;amp; &lt;code&gt;scope&lt;/code&gt; :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &amp;amp; &lt;code&gt;scope&lt;/code&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28d3e08a8329d2bf94877b367b5e9b6728015b6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As per my view you can implement &quot;this&quot; in three ways&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;(Self/Arrow function/Bind Method)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;На мой взгляд, вы можете реализовать &amp;laquo;это&amp;raquo; тремя способами&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;(Self / Arrow function / Bind Method)&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5ea14bd8172aaf9a6ba506e6e7ada4b00f6c5bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Different ways to manipulate &lt;code&gt;this&lt;/code&gt; inside callback functions:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Различные способы манипулировать &lt;code&gt;this&lt;/code&gt; внутри функций обратного вызова:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9807c7820d8498af9fd8b0f569eda762bd110fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Google clearly recommends to use lambdas rather than bind or &lt;code&gt;const self = this&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Google явно рекомендует использовать лямбды, а не связывать или &lt;code&gt;const self = this&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c9b836312f9b07af99edfd6d3c86fcf82d71366d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method1:&lt;/strong&gt; Self - Self is being used to maintain a reference to the original this even as the context is changing. It's a technique often used in event handlers (especially in closures).</source>
          <target state="translated">&lt;strong&gt;Метод 1:&lt;/strong&gt; Self - Self используется для сохранения ссылки на оригинал, даже если контекст меняется. Эта техника часто используется в обработчиках событий (особенно в замыканиях).</target>
        </trans-unit>
        <trans-unit id="58ee73240b34336c1698b25bbcce84697a17df3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method2&lt;/strong&gt;: Arrow function - An arrow function expression is a syntactically compact alternative to a regular function expression,</source>
          <target state="translated">&lt;strong&gt;Метод 2&lt;/strong&gt; : функция стрелки - выражение функции стрелки является синтаксически компактной альтернативой регулярному выражению функции,</target>
        </trans-unit>
        <trans-unit id="83807288d0c69591208b62be684605dc13b0d1ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method3&lt;/strong&gt;:Bind- The bind() method creates a new function that,</source>
          <target state="translated">&lt;strong&gt;Метод 3&lt;/strong&gt; : Bind - метод bind () создает новую функцию, которая</target>
        </trans-unit>
        <trans-unit id="fbff03a5b9cb0d04b7b2cf5d21c576fe76193276" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When binding context for jQuery, use &lt;a href=&quot;http://api.jquery.com/jQuery.proxy/&quot;&gt;&lt;code&gt;jQuery.proxy&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; instead. The reason to do this is so that you don't need to store the reference to the function when unbinding an event callback. jQuery handles that internally.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; При связывании контекста для jQuery используйте &lt;a href=&quot;http://api.jquery.com/jQuery.proxy/&quot;&gt; &lt;code&gt;jQuery.proxy&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; . Причина этого заключается в том, что вам не нужно сохранять ссылку на функцию при отмене привязки обратного вызова события. JQuery обрабатывает это внутренне.</target>
        </trans-unit>
        <trans-unit id="7cddf8e8a39596a43c3943dc0b2a259074ff6e5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Whether or not you can pass a value for &lt;code&gt;this&lt;/code&gt; is usually mentioned in the documentation of that function/method. For example, &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery's &lt;code&gt;$.ajax&lt;/code&gt; method &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; describes an option called &lt;code&gt;context&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Можно ли передать значение для &lt;code&gt;this&lt;/code&gt; как правило, упоминается в документации к этой функции / методу. Например, &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;метод &lt;code&gt;$.ajax&lt;/code&gt; jQuery &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; описывает параметр под названием &lt;code&gt;context&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="207736ea8962167a3fa8bad382e8a76878d9f7be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference:&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Reference:&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75fdbb27ede9220d3d16fc78ac8586f0b59a2045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt; : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Ссылка&lt;/strong&gt; : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc72ecd613eabb84943e85b3ada223948245ddd3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Ссылка&lt;/strong&gt; : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad22017702d23a420c03692bfa75469cbd587279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The solution&lt;/strong&gt; is the same as mentioned above: If available, use &lt;code&gt;.bind&lt;/code&gt; to explicitly bind &lt;code&gt;this&lt;/code&gt; to a specific value</source>
          <target state="translated">&lt;strong&gt;Решение&lt;/strong&gt; такое же, как упомянуто выше: если доступно, используйте &lt;code&gt;.bind&lt;/code&gt; , чтобы явно привязать &lt;code&gt;this&lt;/code&gt; к определенному значению</target>
        </trans-unit>
        <trans-unit id="cf2a3ebd0bb3eb43331c09c74be73028c7ea8561" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You Should know about &quot;this&quot; Keyword.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вы должны знать об этом ключевом слове.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33851166d311aa4e76eff3f3efc9621355eca157" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;apply :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;применять :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77695723b8f02b1b09ad8e9f4c42690237d82c6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bind :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;связать:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e912e07305889ea58d8fde64c857c9a3fff38f53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;call :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;вызов :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29532e96f632af398dba50619e57e074313b2fdd" translate="yes" xml:space="preserve">
          <source>A function's this keyword behaves a little differently in JavaScript compared to other languages.</source>
          <target state="translated">Это ключевое слово функции в JavaScript ведет себя несколько иначе по сравнению с другими языками.</target>
        </trans-unit>
        <trans-unit id="912cdfca5e5ce094d53ff3186f01991ddc662fc7" translate="yes" xml:space="preserve">
          <source>Alter code/function design/architecture - for this you should have command over  &lt;a href=&quot;https://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;design patterns&lt;/a&gt; in javascript.</source>
          <target state="translated">Изменить код / ​​дизайн функции / архитектуру - для этого вы должны иметь команду над &lt;a href=&quot;https://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;шаблонами проектирования&lt;/a&gt; в javascript.</target>
        </trans-unit>
        <trans-unit id="52caaec3fba5f872647197877f4e4dd86e6a438a" translate="yes" xml:space="preserve">
          <source>An execution context provides the surrounding information that adds meaning to code that is being executed. It includes much more information than just the &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&lt;em&gt;thisBinding&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Контекст выполнения предоставляет окружающую информацию, которая добавляет смысл к исполняемому коду. Он включает в себя гораздо больше информации, чем просто &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-11.1.1&quot;&gt;&lt;em&gt;thisBinding&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44d98e8b0d43f360e36798f40afed6e98237427a" translate="yes" xml:space="preserve">
          <source>Another approach, which is &lt;strong&gt;the standard way since DOM2&lt;/strong&gt; to bind &lt;code&gt;this&lt;/code&gt; within the event listener, that &lt;strong&gt;let you always remove the listener&lt;/strong&gt; (among other benefits), is the &lt;code&gt;handleEvent(evt)&lt;/code&gt;method from the &lt;code&gt;EventListener&lt;/code&gt; interface:</source>
          <target state="translated">Другой подход, который является &lt;strong&gt;стандартным способом&lt;/strong&gt; связывания &lt;code&gt;this&lt;/code&gt; помощью прослушивателя событий в &lt;strong&gt;DOM2 и&lt;/strong&gt; который &lt;strong&gt;позволяет всегда удалять прослушиватель&lt;/strong&gt; (среди других преимуществ), - это метод &lt;code&gt;handleEvent(evt)&lt;/code&gt; из интерфейса &lt;code&gt;EventListener&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c7c7a67c1c463a52b508675c2a4fbcd7bd499c42" translate="yes" xml:space="preserve">
          <source>Another common manifestation of this problem is when an object method is used as callback/event handler. Functions are first-class citizens in JavaScript and the term &quot;method&quot; is just a colloquial term for a function that is a value of an object property. But that function doesn't have a specific link to its &quot;containing&quot; object.</source>
          <target state="translated">Другим распространенным проявлением этой проблемы является использование объектного метода в качестве обработчика callbackevent.Функции в JavaScript являются первоклассными гражданами,а термин &quot;метод&quot;-это просто разговорный термин для функции,которая является значением свойства объекта.Однако эта функция не имеет конкретной ссылки на свой &quot;содержащий&quot; объект.</target>
        </trans-unit>
        <trans-unit id="e5ca476aa209b8908ea0f9b7b407ec4efd27c9d0" translate="yes" xml:space="preserve">
          <source>Arrow Functions don&amp;rsquo;t bind &lt;code&gt;this&lt;/code&gt; &amp;mdash; instead, &lt;code&gt;this&lt;/code&gt; is bound lexically (i.e. based on the original context)</source>
          <target state="translated">Функции стрелки не связывают &lt;code&gt;this&lt;/code&gt; - вместо &lt;code&gt;this&lt;/code&gt; это связано лексически (то есть основано на оригинальном контексте)</target>
        </trans-unit>
        <trans-unit id="ab65dda1433ac3a4a44f2e5a043e4ea34a973af0" translate="yes" xml:space="preserve">
          <source>Arrow function expressions are ill suited as methods, and they cannot be used as constructors.</source>
          <target state="translated">Выражения функций стрелок плохо подходят в качестве методов,и их нельзя использовать в качестве конструкторов.</target>
        </trans-unit>
        <trans-unit id="68bb09850cf0694061b593eb35c2d88f9e91ba2c" translate="yes" xml:space="preserve">
          <source>As already mentioned at the beginning, what &lt;code&gt;this&lt;/code&gt; refers to depends on how the function is &lt;strong&gt;called&lt;/strong&gt;, not how it is &lt;strong&gt;defined&lt;/strong&gt;.</source>
          <target state="translated">Как уже упоминалось в начале, то, к чему &lt;code&gt;this&lt;/code&gt; относится, зависит от того, как вызывается функция, а не от того, как она &lt;strong&gt;определена&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8d2777b1eb41d0d72d449a11bc7ca8e6e5012319" translate="yes" xml:space="preserve">
          <source>As most of the answers suggest, we can use &lt;strong&gt;Arrow function or &lt;code&gt;bind()&lt;/code&gt; Method or Self&lt;/strong&gt; var. I would quote a point about lambdas (Arrow function) from &lt;a href=&quot;https://google.github.io/styleguide/jsguide.html#features-functions-arrow-functions&quot;&gt;Google JavaScript Style Guide&lt;/a&gt;</source>
          <target state="translated">Как подсказывает большинство ответов, мы можем использовать &lt;strong&gt;функцию Arrow или метод &lt;code&gt;bind()&lt;/code&gt; или Self&lt;/strong&gt; var. Я бы процитировал пункт о лямбдах (функция стрелки) из &lt;a href=&quot;https://google.github.io/styleguide/jsguide.html#features-functions-arrow-functions&quot;&gt;руководства по стилю Google JavaScript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4a87be3685258b72d713f79d1bfa977f3e36674" translate="yes" xml:space="preserve">
          <source>Common problem: Using object methods as callbacks/event handlers</source>
          <target state="translated">Общая проблема:Использование объектных методов в качестве обработчиков обратного вызова</target>
        </trans-unit>
        <trans-unit id="d7f69e049d11cfea430a186ac01ffac1bca0cfc8" translate="yes" xml:space="preserve">
          <source>Consider the following example:</source>
          <target state="translated">Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="19baede9f95837656d71c40468e696396b8ec0b8" translate="yes" xml:space="preserve">
          <source>Currently there is another approach possible if classes are used in code.</source>
          <target state="translated">В настоящее время возможен другой подход,если в коде используются классы.</target>
        </trans-unit>
        <trans-unit id="cbefe4b8aa228c45cb38892ce584258768af1d79" translate="yes" xml:space="preserve">
          <source>Detailed information about using &lt;code&gt;handleEvent&lt;/code&gt; can be found here: &lt;a href=&quot;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&quot;&gt;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&lt;/a&gt;</source>
          <target state="translated">Подробную информацию об использовании &lt;code&gt;handleEvent&lt;/code&gt; можно найти здесь: &lt;a href=&quot;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&quot;&gt;https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8141d62fd2995e418997f9206b5101ba5385986d" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">Не используйте &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a2aba802819fc19a867deee3901f548f1feb051" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduces &lt;em&gt;arrow functions&lt;/em&gt;, which can be thought of as lambda functions. They don't have their own &lt;code&gt;this&lt;/code&gt; binding. Instead, &lt;code&gt;this&lt;/code&gt; is looked up in scope just like a normal variable. That means you don't have to call &lt;code&gt;.bind&lt;/code&gt;. That's not the only special behaviour they have, please refer to the MDN documentation for more information.</source>
          <target state="translated">ECMAScript 6 представляет &lt;em&gt;функции стрелок&lt;/em&gt; , которые можно рассматривать как лямбда-функции. У них нет своей привязки. Вместо &lt;code&gt;this&lt;/code&gt; это выглядит как область видимости обычной переменной. Это означает, что вам не нужно звонить &lt;code&gt;.bind&lt;/code&gt; . Это не единственное специальное поведение, которое они имеют, пожалуйста, обратитесь к документации MDN для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6dbdc8171942a3d0dbd97de271857afd19174994" translate="yes" xml:space="preserve">
          <source>ECMAScript 6: Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt;</source>
          <target state="translated">ECMAScript 6: использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;функции стрелок&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ce4cc15e461303a1b469af49c17a030b2eaa449" translate="yes" xml:space="preserve">
          <source>ES5 introduced the bind() method to set the value of a function's this regardless of how it's called,</source>
          <target state="translated">В ES5 был введен метод bind()для установки значения функции this независимо от того,как она вызывается,</target>
        </trans-unit>
        <trans-unit id="3d92706e10419b5bc1277c566852681d2d948da0" translate="yes" xml:space="preserve">
          <source>Every function has the method &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;, which returns a new function with &lt;code&gt;this&lt;/code&gt; bound to a value. The function has exactly the same behaviour as the one you called &lt;code&gt;.bind&lt;/code&gt; on, only that &lt;code&gt;this&lt;/code&gt; was set by you. No matter how or when that function is called, &lt;code&gt;this&lt;/code&gt; will always refer to the passed value.</source>
          <target state="translated">Каждая функция имеет метод &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; , который возвращает новую функцию с &lt;code&gt;this&lt;/code&gt; привязкой к значению. Функция имеет точно такое же поведение, как и та, которую вы вызвали &lt;code&gt;.bind&lt;/code&gt; , только то, что &lt;code&gt;this&lt;/code&gt; было установлено вами. Независимо от того, как или когда вызывается &lt;code&gt;this&lt;/code&gt; функция, она всегда будет ссылаться на переданное значение.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="e9d6a485740427854045937df49a40853c402a69" translate="yes" xml:space="preserve">
          <source>Explicitly set &lt;code&gt;this&lt;/code&gt; of the callback - part 1</source>
          <target state="translated">Явно установить &lt;code&gt;this&lt;/code&gt; обратного вызова - часть 1</target>
        </trans-unit>
        <trans-unit id="1126dd24f176d2a0b58861d9f7a6fa519f9c04cf" translate="yes" xml:space="preserve">
          <source>First, you need to have a clear understanding of &lt;strong&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/strong&gt; and behaviour of &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword in the context of &lt;strong&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Во-первых, вам необходимо четко понимать &lt;strong&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/strong&gt; и поведение &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; ключевого слова в контексте области &lt;strong&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b98161925d8109b3e8a4d33cba64ddeafed7b359" translate="yes" xml:space="preserve">
          <source>For sure under the hood it's all old good arrow function that bind context but in this form it looks much more clear that explicit binding.</source>
          <target state="translated">Под капотом наверняка находится старая добрая функция стрелок,которая связывает контекст,но в этом виде она выглядит гораздо более понятной,чем явная привязка.</target>
        </trans-unit>
        <trans-unit id="e61e7a281fa5c383fee31613c5a0509a8533e6d5" translate="yes" xml:space="preserve">
          <source>Here I have a constructor function called Person. It has a property called &lt;strong&gt;&lt;code&gt;name&lt;/code&gt;&lt;/strong&gt; and four method called &lt;strong&gt;&lt;code&gt;sayNameVersion1&lt;/code&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;code&gt;sayNameVersion2&lt;/code&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;code&gt;sayNameVersion3&lt;/code&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;code&gt;sayNameVersion4&lt;/code&gt;&lt;/strong&gt;. All four of them has one specific task.Accept a callback and invoke it.The callback has a specific task which is to log the name property of an instance of Person constructor function.</source>
          <target state="translated">Здесь у меня есть функция конструктора под названием Person. У него есть свойство с именем &lt;strong&gt; &lt;code&gt;name&lt;/code&gt; &lt;/strong&gt; и четыре метода с именем &lt;strong&gt; &lt;code&gt;sayNameVersion1&lt;/code&gt; &lt;/strong&gt; , &lt;strong&gt; &lt;code&gt;sayNameVersion2&lt;/code&gt; &lt;/strong&gt; , &lt;strong&gt; &lt;code&gt;sayNameVersion3&lt;/code&gt; &lt;/strong&gt; , &lt;strong&gt; &lt;code&gt;sayNameVersion4&lt;/code&gt; &lt;/strong&gt; . У всех четырех из них есть одна конкретная задача. Принять обратный вызов и вызвать его. Обратный вызов имеет специальную задачу, которая заключается в регистрации свойства name экземпляра функции конструктора Person.</target>
        </trans-unit>
        <trans-unit id="4acb81ac127a3601d53820d4d0f45171677e988c" translate="yes" xml:space="preserve">
          <source>Here are several ways to access parent context inside child context -</source>
          <target state="translated">Вот несколько способов доступа к родительскому контексту внутри дочернего контекста -</target>
        </trans-unit>
        <trans-unit id="85e2143fbc09476ddf872285e4ee8305918dc1ef" translate="yes" xml:space="preserve">
          <source>How can I access the correct object?</source>
          <target state="translated">Как я могу получить доступ к нужному объекту?</target>
        </trans-unit>
        <trans-unit id="ae2ce4ed9d749ac553a5952af8ed485252570f3f" translate="yes" xml:space="preserve">
          <source>How to access the correct `this` inside a callback</source>
          <target state="translated">Как получить доступ к правильному `этому` внутри обратного вызова.</target>
        </trans-unit>
        <trans-unit id="6f908c89120425f927f214344354c0aca40f8b35" translate="yes" xml:space="preserve">
          <source>How to refer to the correct &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">Как правильно &lt;code&gt;this&lt;/code&gt; исправить</target>
        </trans-unit>
        <trans-unit id="5ed5328abf66e902733b964229b89a9e88ccb98f" translate="yes" xml:space="preserve">
          <source>However, I'm not able to access the &lt;code&gt;data&lt;/code&gt; property of the created object inside the callback. It looks like &lt;code&gt;this&lt;/code&gt; does not refer to the object that was created but to an other one.</source>
          <target state="translated">Однако я не могу получить доступ к свойству данных созданного объекта внутри обратного вызова. Похоже, что &lt;code&gt;this&lt;/code&gt; относится не к объекту, который был создан, а к другому.</target>
        </trans-unit>
        <trans-unit id="323833fe30e701dd0afbe644972c8297131ffd00" translate="yes" xml:space="preserve">
          <source>I also tried to use an object method instead of an anonymous function:</source>
          <target state="translated">Я также пытался использовать объектный метод вместо анонимной функции:</target>
        </trans-unit>
        <trans-unit id="eaec236d744509e537cc8f03f2dea9ad53761954" translate="yes" xml:space="preserve">
          <source>I have a constructor function which registers an event handler:</source>
          <target state="translated">У меня есть функция конструктора,которая регистрирует обработчик событий:</target>
        </trans-unit>
        <trans-unit id="5b371a6ae052214f7818ec3deaed3e9b738646dd" translate="yes" xml:space="preserve">
          <source>If strict mode is enabled for any function then the value of &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; as in strict mode, global object refers to &lt;code&gt;undefined&lt;/code&gt; in place of the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">Если строгий режим включен для любой функции, то значение &lt;code&gt;this&lt;/code&gt; будет &lt;code&gt;undefined&lt;/code&gt; как в строгом режиме, глобальный объект ссылается на &lt;code&gt;undefined&lt;/code&gt; вместо объекта &lt;code&gt;window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97f3987d7dc7237e2cfee6a8dbacca0a0a502d88" translate="yes" xml:space="preserve">
          <source>If the code was like the following, it might be more obvious that the function doesn't have an implicit reference to the object:</source>
          <target state="translated">Если бы код был похож на следующий,то было бы более очевидно,что функция не имеет неявной ссылки на объект:</target>
        </trans-unit>
        <trans-unit id="44286d5d725e24975302df95630b6a88edcc2bf7" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;underscore.js&lt;/code&gt; - &lt;a href=&quot;http://underscorejs.org/#bind&quot;&gt;http://underscorejs.org/#bind&lt;/a&gt;</source>
          <target state="translated">Если вы используете &lt;code&gt;underscore.js&lt;/code&gt; - &lt;a href=&quot;http://underscorejs.org/#bind&quot;&gt;http://underscorejs.org/#bind&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fde7334616f0dd164f29fddbf11acc809feee752" translate="yes" xml:space="preserve">
          <source>If you are using jQuery you should use the &lt;code&gt;$.proxy&lt;/code&gt; method instead, as &lt;code&gt;bind&lt;/code&gt; is not supported in all browsers:</source>
          <target state="translated">Если вы используете jQuery, вы должны использовать вместо этого метод &lt;code&gt;$.proxy&lt;/code&gt; , так как &lt;code&gt;bind&lt;/code&gt; поддерживается не во всех браузерах:</target>
        </trans-unit>
        <trans-unit id="13d3e294e950b7f4ab84cf9acca0ccd56c984cff" translate="yes" xml:space="preserve">
          <source>In most cases, the value of this is determined by how a function is called.</source>
          <target state="translated">В большинстве случаев значение этого определяется тем,как вызывается функция.</target>
        </trans-unit>
        <trans-unit id="fa250ce283226ff53d868b2d334cd5e88dff4429" translate="yes" xml:space="preserve">
          <source>In the global scope, &lt;code&gt;this&lt;/code&gt; refers to the global object (the &lt;code&gt;window&lt;/code&gt; object).</source>
          <target state="translated">В глобальной области &lt;code&gt;this&lt;/code&gt; относится к глобальному объекту (объекту &lt;code&gt;window&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="84cfc4df2cedf0a396870ba012ed9bfc0f2b3c6c" translate="yes" xml:space="preserve">
          <source>In this case, we are binding the callback's &lt;code&gt;this&lt;/code&gt; to the value of &lt;code&gt;MyConstructor&lt;/code&gt;'s &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">В этом случае мы связываем обратный вызов &lt;code&gt;this&lt;/code&gt; со значением &lt;code&gt;MyConstructor&lt;/code&gt; 's &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30b4b861a818b8aa39958b98513130afef359643" translate="yes" xml:space="preserve">
          <source>It also has some differences between strict mode and non-strict mode.</source>
          <target state="translated">Он также имеет некоторые различия между строгим режимом и нестрогим режимом.</target>
        </trans-unit>
        <trans-unit id="b5a4468c39b48f1e066f8525bae2767e24645b5a" translate="yes" xml:space="preserve">
          <source>It can't be set by assignment during execution, and it may be different each time the function is called.</source>
          <target state="translated">Она не может быть установлена присваиванием во время выполнения,и может быть разной при каждом вызове функции.</target>
        </trans-unit>
        <trans-unit id="c856cf98c012850bf9e871b799e02d2f89139d0f" translate="yes" xml:space="preserve">
          <source>It might look like you have no control over the value of &lt;code&gt;this&lt;/code&gt; because its value is set automatically, but that is actually not the case.</source>
          <target state="translated">Может показаться, что вы не можете контролировать это значение, потому что его значение устанавливается автоматически, но на самом деле это не так.</target>
        </trans-unit>
        <trans-unit id="3a5c614e4a858c76be5f61117786c7f01782da3a" translate="yes" xml:space="preserve">
          <source>It's all in the &quot;magic&quot; syntax of calling a method:</source>
          <target state="translated">Это все в &quot;волшебном&quot; синтаксисе вызова метода:</target>
        </trans-unit>
        <trans-unit id="d212c8aab88e3b2c631bdfa314a2c158284a9689" translate="yes" xml:space="preserve">
          <source>Now let's create an instance from person constructor and invoke different versions of &lt;strong&gt;&lt;code&gt;sayNameVersionX&lt;/code&gt;&lt;/strong&gt; ( X refers to 1,2,3,4 ) method with &lt;strong&gt;&lt;code&gt;niceCallback&lt;/code&gt;&lt;/strong&gt; to see how many ways we can manipulate the &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; inside callback to refer to the &lt;strong&gt;&lt;code&gt;person&lt;/code&gt;&lt;/strong&gt; instance.</source>
          <target state="translated">Теперь давайте создадим экземпляр из конструктора person и &lt;strong&gt; &lt;code&gt;sayNameVersionX&lt;/code&gt; &lt;/strong&gt; различные версии метода &lt;strong&gt;sayNameVersionX&lt;/strong&gt; (X относится к 1,2,3,4) с помощью &lt;strong&gt; &lt;code&gt;niceCallback&lt;/code&gt; ,&lt;/strong&gt; чтобы увидеть, сколько способов мы можем манипулировать обратным вызовом &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; inside для обращения к экземпляру &lt;strong&gt; &lt;code&gt;person&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bd382a556e0627a895f9d61c9e039efe9520f3a7" translate="yes" xml:space="preserve">
          <source>Prefer using arrow functions over f.bind(this), and especially over
  goog.bind(f, this). Avoid writing const self = this. Arrow functions
  are particularly useful for callbacks, which sometimes pass unexpected
  additional arguments.</source>
          <target state="translated">Предпочтительно использовать функции со стрелками,а не f.bind(this),и особенно goog.bind(f,this).Избегайте написания const self=this.Функции стрелок особенно полезны при обратных вызовах,которые иногда передают неожиданные дополнительные аргументы.</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="0659a76d505497879be6cfbe39c059f2d61df867" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;this&lt;/code&gt; of the callback - part 2</source>
          <target state="translated">Установите &lt;code&gt;this&lt;/code&gt; из обратного вызова - часть 2</target>
        </trans-unit>
        <trans-unit id="56be075e48deed785dc54c97a107dbdfab73da93" translate="yes" xml:space="preserve">
          <source>Set the ThisBinding to the same value as the ThisBinding of the
  calling execution context</source>
          <target state="translated">Установите значение ThisBinding таким же,как и значение ThisBinding контекста выполнения вызова.</target>
        </trans-unit>
        <trans-unit id="1e9e29d4637f7cebd0369d655eda5c71d09b9233" translate="yes" xml:space="preserve">
          <source>Similar to &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt;, first argument of &lt;strong&gt;&lt;code&gt;apply&lt;/code&gt;&lt;/strong&gt; refers to the object that will be indicated by &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword.</source>
          <target state="translated">Как и в случае &lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt; , первый аргумент &lt;strong&gt; &lt;code&gt;apply&lt;/code&gt; &lt;/strong&gt; относится к объекту, который будет указан &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; ключевым словом.</target>
        </trans-unit>
        <trans-unit id="15dc5824306174e1163181b6492db3027e7184ba" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;self&lt;/code&gt; is a normal variable, it obeys lexical scope rules and is accessible inside the callback. This also has the advantage that you can access the &lt;code&gt;this&lt;/code&gt; value of the callback itself.</source>
          <target state="translated">Поскольку &lt;code&gt;self&lt;/code&gt; является нормальной переменной, оно подчиняется лексическим правилам области видимости и доступно внутри обратного вызова. Это также имеет то преимущество, что вы можете получить доступ к значению &lt;code&gt;this&lt;/code&gt; самого обратного вызова.</target>
        </trans-unit>
        <trans-unit id="841ea9b7a24ab9b0a4a11eb3d639efba860efaaa" translate="yes" xml:space="preserve">
          <source>Since it's Stage 3 Proposal you will need babel and appropriate &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-proposal-class-properties&quot;&gt;babel plugin&lt;/a&gt; to process it as for now(08/2018).</source>
          <target state="translated">Поскольку это предложение уровня 3, вам понадобится babel и соответствующий &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-proposal-class-properties&quot;&gt;плагин babel,&lt;/a&gt; чтобы обработать его, как сейчас (08/2018).</target>
        </trans-unit>
        <trans-unit id="cdbe775fb45eb5ef2d2e6ce73eeeb4fd35368bf8" translate="yes" xml:space="preserve">
          <source>So the best solution would be to use lambdas as below,</source>
          <target state="translated">Поэтому лучшим решением будет использование баранины,как показано ниже,</target>
        </trans-unit>
        <trans-unit id="744d624b35c5c9839f7ef2f10dd23136a872cd13" translate="yes" xml:space="preserve">
          <source>So the value of &lt;em&gt;this&lt;/em&gt; isn't &quot;context&quot;, it's just one part of an execution context. It's essentially a local variable that can be set by the call to any object and in strict mode, to any value at all.</source>
          <target state="translated">Таким образом, значение &lt;em&gt;этого&lt;/em&gt; не &quot;контекст&quot;, это просто одна часть контекста исполнения. По сути, это локальная переменная, которая может быть установлена ​​при вызове любого объекта и в строгом режиме для любого значения вообще.</target>
        </trans-unit>
        <trans-unit id="08e7c0641502b25341ef35ff01a6e8bc40419c8b" translate="yes" xml:space="preserve">
          <source>Some functions/methods which accept callbacks also accept a value to which the callback's &lt;code&gt;this&lt;/code&gt; should refer to. This is basically the same as binding it yourself, but the function/method does it for you. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;Array#map&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; is such a method. Its signature is:</source>
          <target state="translated">Некоторые функции / методы, которые принимают обратные вызовы, также принимают значение, к которому относится обратный вызов. По сути, это то же самое, что связывать его самостоятельно, но функция / метод делает это за вас. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;Array#map&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[docs]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; - такой метод. Его подпись:</target>
        </trans-unit>
        <trans-unit id="d98f29032871395567d10fa9475d0524189b4f4b" translate="yes" xml:space="preserve">
          <source>Store reference to context/this inside another variable(see below example).</source>
          <target state="translated">Храните ссылку на контекст внутри другой переменной (см.пример ниже).</target>
        </trans-unit>
        <trans-unit id="46ccc3ce57128d895c43982bc51d536f065ddef4" translate="yes" xml:space="preserve">
          <source>That's where you would bind the context to the function:</source>
          <target state="translated">Там вы бы связали контекст с функцией:</target>
        </trans-unit>
        <trans-unit id="8ea6ca42490b74de48fe8ae9a2bd9ccd3e0033f6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;first argument&lt;/code&gt;&lt;/strong&gt; of the &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt; method is used as &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; inside the function that is invoked with &lt;strong&gt;&lt;code&gt;call&lt;/code&gt;&lt;/strong&gt; attached to it.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;first argument&lt;/code&gt; &lt;/strong&gt; метода &lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt; используется как таковой внутри функции, которая вызывается с прикрепленным к ней &lt;strong&gt; &lt;code&gt;call&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="55ff58898b5dfe7076511fbcd2d228ee39265388" translate="yes" xml:space="preserve">
          <source>The first argument is the callback and the second argument is the value &lt;code&gt;this&lt;/code&gt; should refer to. Here is a contrived example:</source>
          <target state="translated">Первый аргумент - это обратный вызов, а второй аргумент - это значение, к которому следует обращаться. Вот надуманный пример:</target>
        </trans-unit>
        <trans-unit id="67a37244ad69c52151f22e62ecb8e655636407eb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;this.method&lt;/code&gt; is assigned as click event handler, but if the &lt;code&gt;document.body&lt;/code&gt; is clicked, the value logged will be &lt;code&gt;undefined&lt;/code&gt;, because inside the event handler, &lt;code&gt;this&lt;/code&gt; refers to the &lt;code&gt;document.body&lt;/code&gt;, not the instance of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;this.method&lt;/code&gt; назначается в качестве обработчика события click, но если щелкнуть document.body, записанное значение будет &lt;code&gt;undefined&lt;/code&gt; , поскольку внутри обработчика события &lt;code&gt;this&lt;/code&gt; относится к &lt;code&gt;document.body&lt;/code&gt; , а не к экземпляру &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0f83deeb19c855f6e5e7fd4353ef35b56f82a60" translate="yes" xml:space="preserve">
          <source>The object that is standing before the dot is what the this keyword will be bound to.</source>
          <target state="translated">Объект,стоящий перед точкой-это то,к чему будет привязано это ключевое слово.</target>
        </trans-unit>
        <trans-unit id="fc3b4ab1171b67adb539b65128c31a6fe985a69d" translate="yes" xml:space="preserve">
          <source>The question revolves around how &lt;code&gt;this&lt;/code&gt; keyword behaves in javascript. &lt;code&gt;this&lt;/code&gt; behaves differently as below,</source>
          <target state="translated">Вопрос вращается вокруг того, как &lt;code&gt;this&lt;/code&gt; ключевое слово ведет себя в JavaScript. &lt;code&gt;this&lt;/code&gt; ведет себя иначе, как показано ниже,</target>
        </trans-unit>
        <trans-unit id="4f5bf601799b4826496754deacc27d88b45812b9" translate="yes" xml:space="preserve">
          <source>The term &quot;context&quot; is sometimes used to refer to the object referenced by &lt;em&gt;this&lt;/em&gt;. Its use is inappropriate because it doesn't fit either semantically or technically with &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;ECMAScript's &lt;em&gt;this&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Термин &amp;laquo;контекст&amp;raquo; иногда используется для обозначения объекта, на который ссылается &lt;em&gt;это&lt;/em&gt; . Его использование неуместно, потому что он не подходит ни семантически, ни технически к &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;ECMAScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29e596611ce94c8c6c1da3cd4238c2debd6a73d7" translate="yes" xml:space="preserve">
          <source>The trouble with &quot;context&quot;</source>
          <target state="translated">Проблема с &quot;контекстом&quot;</target>
        </trans-unit>
        <trans-unit id="5f6b0d54cfa64916d991e3233dd9a414d112f53d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; is usually determined by a functions execution context.</source>
          <target state="translated">Значение &lt;code&gt;this&lt;/code&gt; обычно определяется контекстом выполнения функций.</target>
        </trans-unit>
        <trans-unit id="2c07ebf251b294d81ec44d6e5bd3eb7a7dcfbcd1" translate="yes" xml:space="preserve">
          <source>This is shown in &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;ECMA-262 section 10.4.2&lt;/a&gt;:</source>
          <target state="translated">Это показано в &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;разделе 10.4.2 ECMA-262&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="15626ab66ea3225794d92a6db19166a07fbc59dc" translate="yes" xml:space="preserve">
          <source>This object will be made the context of all Ajax-related callbacks.</source>
          <target state="translated">Этот объект будет сделан контекстом всех связанных с Аяксом обратных вызовов.</target>
        </trans-unit>
        <trans-unit id="e589b5b7cd7e785bbedfd119fb0e0f15604df60b" translate="yes" xml:space="preserve">
          <source>To learn more about &lt;code&gt;this&lt;/code&gt;, have a look at the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;MDN documentation&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать больше об &lt;code&gt;this&lt;/code&gt; , посмотрите &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;документацию MDN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a019c43e711ee20b2a34f1b9e376cf74602d468" translate="yes" xml:space="preserve">
          <source>Use ES6 &lt;a href=&quot;https://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/&quot;&gt;Arrow&lt;/a&gt; functions.</source>
          <target state="translated">Используйте функции ES6 &lt;a href=&quot;https://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/&quot;&gt;Arrow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20ff1eb2976d955300bd8cf852c3e8f0f9f77d7f" translate="yes" xml:space="preserve">
          <source>We can not bind this to &lt;code&gt;setTimeout()&lt;/code&gt;, as it always execute with &lt;strong&gt;global object (Window)&lt;/strong&gt;, if you want to access &lt;code&gt;this&lt;/code&gt; context in the callback function then by using &lt;code&gt;bind()&lt;/code&gt; to the callback function we can achieve as:</source>
          <target state="translated">Мы не можем связать это с &lt;code&gt;setTimeout()&lt;/code&gt; , так как он всегда выполняется с &lt;strong&gt;глобальным объектом (Window)&lt;/strong&gt; , если вы хотите получить доступ к &lt;code&gt;this&lt;/code&gt; контексту в функции обратного вызова, то с помощью &lt;code&gt;bind()&lt;/code&gt; к функции обратного вызова мы можем добиться как:</target>
        </trans-unit>
        <trans-unit id="f0b2e61844178ceed95f0cf3e0781840c230c85f" translate="yes" xml:space="preserve">
          <source>We can set the value of this explicitly with &lt;code&gt;call()&lt;/code&gt;, &lt;code&gt;bind()&lt;/code&gt;, and &lt;code&gt;apply()&lt;/code&gt;</source>
          <target state="translated">Мы можем установить значение этого явно с помощью &lt;code&gt;call()&lt;/code&gt; , &lt;code&gt;bind()&lt;/code&gt; и &lt;code&gt;apply()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a300d1f4446b37c0b75e60ce04944773b10b001e" translate="yes" xml:space="preserve">
          <source>What bind do is to create a new function with the &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword set to the provided value.</source>
          <target state="translated">Привязка заключается в создании новой функции с установленным значением ключевого слова &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4774184c662135228fe2eca5b4143a4243962322" translate="yes" xml:space="preserve">
          <source>What you should know about &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">Что вы должны знать об &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97fd1730e7a467b4a6d822e1e3a3cb3729262c7c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;new&lt;/code&gt; keyword is used (a constructor), this is bound to the new object being created.</source>
          <target state="translated">Когда используется &lt;code&gt;new&lt;/code&gt; ключевое слово (конструктор), оно привязывается к создаваемому новому объекту.</target>
        </trans-unit>
        <trans-unit id="2ce6733786b30aaf931173ecc812b54c22cceb1f" translate="yes" xml:space="preserve">
          <source>When you get the property from the object and call it in one go, the object will be the context for the method. If you call the same method, but in separate steps, the context is the global scope (window) instead:</source>
          <target state="translated">Когда вы получаете свойство от объекта и вызываете его одним нажатием,объект будет контекстом для метода.Если вы вызываете тот же самый метод,но по отдельности,то контекстом является глобальная область видимости (окно):</target>
        </trans-unit>
        <trans-unit id="e25fd97d359cb9f70c917d4a8fc8aaa38d0af671" translate="yes" xml:space="preserve">
          <source>When you get the reference of a method, it's no longer attached to the object, it's just a reference to a plain function. The same happens when you get the reference to use as a callback:</source>
          <target state="translated">Когда вы получаете ссылку на метод,он больше не привязан к объекту,это просто ссылка на простую функцию.То же самое происходит,когда вы получаете ссылку для использования в качестве обратного вызова:</target>
        </trans-unit>
        <trans-unit id="b2ab3b5c803ea2983f02f151826822393ffb5bb0" translate="yes" xml:space="preserve">
          <source>With support of &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;class fields&lt;/a&gt;  it's possible to make it next way:</source>
          <target state="translated">С поддержкой &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;полей класса&lt;/a&gt; это можно сделать следующим образом:</target>
        </trans-unit>
        <trans-unit id="f2a8ca667cc08ea85fc32a97b825a84dd7f067f0" translate="yes" xml:space="preserve">
          <source>You actually don't want to access &lt;code&gt;this&lt;/code&gt; in particular, but &lt;em&gt;the object it refers to&lt;/em&gt;. That's why an easy solution is to simply create a new variable that also refers to that object. The variable can have any name, but common ones are &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;that&lt;/code&gt;.</source>
          <target state="translated">Вы на самом деле не хотите обращаться к &lt;code&gt;this&lt;/code&gt; в частности, &lt;em&gt;к объекту, на который он ссылается&lt;/em&gt; . Вот почему простое решение - просто создать новую переменную, которая также ссылается на этот объект. Переменная может иметь любое имя, но наиболее распространенными являются &lt;code&gt;self&lt;/code&gt; и &lt;code&gt;that&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eebe4cba4c37d26de7bca202344e49cbf52db06f" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bind&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">Вы можете использовать функцию &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bind&lt;/a&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c82ed2eb7f8fe82e1cc5eaa133924e42112028ac" translate="yes" xml:space="preserve">
          <source>although without its own bindings to the this, arguments, super, or new.target keywords.</source>
          <target state="translated">хотя и без собственных привязок к этому,аргументы,супер-или new.target ключевые слова.</target>
        </trans-unit>
        <trans-unit id="f4b8f7b7d10494d345f58339c67f09da7c068fce" translate="yes" xml:space="preserve">
          <source>and ES2015 introduced arrow functions which don't provide their own this binding (it retains the this value of the enclosing lexical context).</source>
          <target state="translated">а в ES2015 были введены функции стрелок,которые не обеспечивают свою собственную привязку (она сохраняет это значение в вложенного лексического контекста).</target>
        </trans-unit>
        <trans-unit id="e367339213aec025c0797185e727419061a64dcf" translate="yes" xml:space="preserve">
          <source>and it is called like the following :</source>
          <target state="translated">и называется так:</target>
        </trans-unit>
        <trans-unit id="066df75b17918161da47216d637d594ae709c370" translate="yes" xml:space="preserve">
          <source>and it is called like the following.Simply the callback is passed,</source>
          <target state="translated">и он называется так,как показано ниже.Просто передается обратный вызов,</target>
        </trans-unit>
        <trans-unit id="a93f4cff86a4e5446eb5a9aa9d39d95ac9dc9bb1" translate="yes" xml:space="preserve">
          <source>arrow-functions-vs-bind</source>
          <target state="translated">arrow-functions-vs-bind</target>
        </trans-unit>
        <trans-unit id="4a5199c7966224c5b4cc141786e8e79f22d8eb27" translate="yes" xml:space="preserve">
          <source>but it exhibits the same problems.</source>
          <target state="translated">но у него те же проблемы.</target>
        </trans-unit>
        <trans-unit id="24f2046f2ac57b0086fb1167486679211880885d" translate="yes" xml:space="preserve">
          <source>first one bind &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; with callback inside the method itself.And for the second one callback is passed with the object bound to it.</source>
          <target state="translated">первый связывает &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; с обратным вызовом внутри самого метода. А для второго передается обратный вызов с привязанным к нему объектом.</target>
        </trans-unit>
        <trans-unit id="722fdafbf37a84106f8a486d49b288bc874e5f69" translate="yes" xml:space="preserve">
          <source>in short, global scope refers to the window object.Variables declared in a global scope are accessible from anywhere.On the other hand function scope resides inside of a function.variable  declared inside a function cannot be accessed from outside world normally.&lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; keyword in global scope refers to the window object.&lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; inside function also refers to the window object.So &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; will always refer to the window until we find a way to manipulate &lt;strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt; to indicate a context of our own choosing.</source>
          <target state="translated">короче говоря, глобальная область действия относится к объекту окна. Переменные, объявленные в глобальной области видимости, доступны откуда угодно. С другой стороны, область действия функции находится внутри функции. Переменная, объявленная внутри функции, не может быть доступна из внешнего мира в обычном режиме. &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; ключевое слово в глобальной области видимости относится к объекту окна. &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; внутренняя функция также относится к объекту окна. Так что &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; всегда будет относиться к окну, пока мы не найдем способ манипулировать &lt;strong&gt; &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; чтобы указать контекст нашего собственного выбора.</target>
        </trans-unit>
        <trans-unit id="274c09237e0f83abe388f09d3de9e024fb90b62c" translate="yes" xml:space="preserve">
          <source>or explicitly call the function as a &quot;method&quot; of the object, by using an anonymous function as callback / event handler and assign the object (&lt;code&gt;this&lt;/code&gt;) to another variable:</source>
          <target state="translated">или явно вызвать функцию как &amp;laquo;метод&amp;raquo; объекта, используя анонимную функцию в качестве обработчика обратного вызова / события, и назначить объект ( &lt;code&gt;this&lt;/code&gt; ) другой переменной:</target>
        </trans-unit>
        <trans-unit id="e42a701e964de93b244d1ecb51d0a90fadefe1a9" translate="yes" xml:space="preserve">
          <source>or use an arrow function:</source>
          <target state="translated">или использовать функцию стрелки:</target>
        </trans-unit>
        <trans-unit id="ded874b7c351a41a7abac69562389b93ebef4a29" translate="yes" xml:space="preserve">
          <source>when called, has its this keyword set to the provided value,</source>
          <target state="translated">при вызове,имеет ключевое слово,установленное на предоставленное значение,</target>
        </trans-unit>
        <trans-unit id="f6875ad9393de98b36793855e7a2d1181c8d5274" translate="yes" xml:space="preserve">
          <source>which clearly indicates that &lt;em&gt;this&lt;/em&gt; is part of an execution context.</source>
          <target state="translated">что ясно указывает на то, что &lt;em&gt;это&lt;/em&gt; часть контекста исполнения.</target>
        </trans-unit>
        <trans-unit id="9dd2f6e1d0f1041fbeb21cc91e6a5ddf5ebb1c62" translate="yes" xml:space="preserve">
          <source>with a given sequence of arguments preceding any provided when the new function is called.</source>
          <target state="translated">с заданной последовательностью аргументов,предшествующей любому из них при вызове новой функции.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
