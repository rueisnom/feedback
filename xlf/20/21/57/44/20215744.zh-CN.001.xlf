<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/20215744">
    <body>
      <group id="20215744">
        <trans-unit id="b7e2cf995f060f84d394e037243fac4be0c2f42c" translate="yes" xml:space="preserve">
          <source>... with left join:</source>
          <target state="translated">..................:</target>
        </trans-unit>
        <trans-unit id="bc4669daf19948c0e06e0c410d61a130f41ce8d9" translate="yes" xml:space="preserve">
          <source>1) create a function that will check if a item is anywhere in the parent hierarchy of another one. Something like this (I will not write the function, make it with WHILE DO) :</source>
          <target state="translated">1)创建一个函数,检查一个项目是否在另一个项目的父级结构中的任何地方。类似这样的东西(我不会写这个函数,用WHILE DO来做)。</target>
        </trans-unit>
        <trans-unit id="091a9a50ae645943409a126262c2a8be84a6b1c7" translate="yes" xml:space="preserve">
          <source>2) use a sub-select , something like this:</source>
          <target state="translated">2)使用一个子选项,像这样的东西。</target>
        </trans-unit>
        <trans-unit id="b23ccfdfd86377f2973d1a0a1289df8e6a08fbd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Output::&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Output::&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c0f1eb761e0b0cd9b20b1c18d18c657d4734780" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: See the question &lt;a href=&quot;https://stackoverflow.com/questions/4048151/what-are-the-options-for-storing-hierarchical-data-in-a-relational-database&quot;&gt;What are the options for storing hierarchical data in a relational database?&lt;/a&gt; for more options. There are different optimal solutions for different situations.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编辑&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：请参阅问题&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4048151/what-are-the-options-for-storing-hierarchical-data-in-a-relational-database&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在关系数据库中存储层次结构数据的选项有哪些？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关更多选项。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;针对不同情况有不同的最佳解决方案。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="69643d56145ce04634714be2f7b84ba7974fbb5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optimise the path length and &lt;code&gt;ORDER BY path&lt;/code&gt; using base36 encoding instead real numeric path id&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用base36编码而不是真实数字路径ID &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优化路径长度和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ORDER BY path&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a4c9189a63c20797d6bbd8ceac0ab7a40e16058" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TODO&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TODO&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f74465adc66cec924b29ff9c635d9484c7f28ce6" translate="yes" xml:space="preserve">
          <source>All in all, one may find these assumptions too risky to rely on. The &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/user-variables.html&quot;&gt;documentation&lt;/a&gt; warns:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总而言之，人们可能会发现这些假设过于冒险，无法依靠。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/user-variables.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文档&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;警告：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5477dd17ce303b99fb49b1f9d98f3bc516de7abd" translate="yes" xml:space="preserve">
          <source>Also, I already have the solution using the for loop..... Let me know how to achieve the same using a single MySQL query if possible.</source>
          <target state="translated">另外,我已经有了使用for循环的解决方案.....。如果可能的话,让我知道如何使用一个单一的MySQL查询来实现同样的功能。</target>
        </trans-unit>
        <trans-unit id="6d76bf049c5159585ba6892ca92b85a1a2547b5a" translate="yes" xml:space="preserve">
          <source>Alternative 1: &lt;code&gt;with recursive&lt;/code&gt;, &lt;code&gt;connect by&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方案1：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;with recursive&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;connect by&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84f643890c9617f44cf83faef6e8b68f595275e5" translate="yes" xml:space="preserve">
          <source>Alternative 2: Path-style Identifiers</source>
          <target state="translated">替代方案2:路径式识别器</target>
        </trans-unit>
        <trans-unit id="4c799f0a9a6799a0ca45e9a9ed17d104e3215ea6" translate="yes" xml:space="preserve">
          <source>Alternative 3: Repeated Self-joins</source>
          <target state="translated">备选方案3:重复的自连接</target>
        </trans-unit>
        <trans-unit id="9b91579c1eb8f7403daa277fe963be94220a61fe" translate="yes" xml:space="preserve">
          <source>And then you just</source>
          <target state="translated">然后你就</target>
        </trans-unit>
        <trans-unit id="2d5f3cb3c67b77b6dc383da3890415186eb71978" translate="yes" xml:space="preserve">
          <source>As stated above, from MySQL 8.0 onward you should use the recursive &lt;code&gt;with&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如上所述，从MySQL 8.0开始，您应该使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;with&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的递归&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a6532f5123aa8c4e010415d21f455fafecb24246" translate="yes" xml:space="preserve">
          <source>Detailed optimization explanation here:
&lt;a href=&quot;https://bojanz.wordpress.com/2014/04/25/storing-hierarchical-data-materialized-path/&quot;&gt;https://bojanz.wordpress.com/2014/04/25/storing-hierarchical-data-materialized-path/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此处有详细的优化说明：&lt;/font&gt;&lt;a href=&quot;https://bojanz.wordpress.com/2014/04/25/storing-hierarchical-data-materialized-path/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//bojanz.wordpress.com/2014/04/25/storing-hierarchical-data-materialized-path/&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c4271430c0da02e9550544f7c14090490db247a8" translate="yes" xml:space="preserve">
          <source>Did the same thing for another quetion here</source>
          <target state="translated">在这里的另一个问题上也做了同样的事情</target>
        </trans-unit>
        <trans-unit id="12c4ffe1d987164a4bedf6ab2aac597a113e181c" translate="yes" xml:space="preserve">
          <source>Efficiency</source>
          <target state="translated">Efficiency</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="e791a8ba10bc9d624a3006f0b25f85b8e853dcd0" translate="yes" xml:space="preserve">
          <source>Experimental rows:</source>
          <target state="translated">实验行。</target>
        </trans-unit>
        <trans-unit id="6c11f943153b46cca92e6f29e7eb195d71c816d4" translate="yes" xml:space="preserve">
          <source>Filtering rows with certain path:</source>
          <target state="translated">筛选具有一定路径的行。</target>
        </trans-unit>
        <trans-unit id="5d9e82d860a6af0143337e46021b18acd4c3c99c" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;MySQL 5.x:&lt;/strong&gt; use inline variables, path IDs, or self-joins.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MySQL 5.x：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用内联变量，路径ID或自联接。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="611510b632472f7370b4ed8326b40e81c5ecaec9" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;MySQL 8+:&lt;/strong&gt; use the recursive &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/with.html&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MySQL 8+：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用递归&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/with.html&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6384aba0f85c45cc05ec0f2766a6aff248a4a5c8" translate="yes" xml:space="preserve">
          <source>For MySQL versions that do not support Common Table Expressions (up to version 5.7), you would achieve this with the following query:</source>
          <target state="translated">对于不支持通用表表达式的MySQL版本(5.7版本之前),可以通过以下查询实现。</target>
        </trans-unit>
        <trans-unit id="57083a262292cf5018db199c2d4c981d5c5c6cb3" translate="yes" xml:space="preserve">
          <source>For very large data sets this solution might get slow, as the &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_find-in-set&quot;&gt;&lt;code&gt;find_in_set&lt;/code&gt;&lt;/a&gt; operation is not the most ideal way to find a number in a list, certainly not in a list that reaches a size in the same order of magnitude as the number of records returned.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于非常大的数据集，此解决方案可能会变慢，因为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_find-in-set&quot;&gt; &lt;code&gt;find_in_set&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;操作不是在列表中查找数字的最理想方法，当然，在列表中找到的数字与返回的记录数大小在相同数量级时，肯定不是。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="303d1a56d21aa538e677a633db6beefa41d5e2db" translate="yes" xml:space="preserve">
          <source>From the blog &lt;strong&gt;&lt;a href=&quot;https://web.archive.org/web/20181221162916/http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/&quot;&gt;Managing Hierarchical Data in MySQL&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来自博客&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;https://web.archive.org/web/20181221162916/http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在MySQL中管理分层数据&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f13807ec4314af6740a5c8890da78c2440b0595" translate="yes" xml:space="preserve">
          <source>Function's body</source>
          <target state="translated">职能机构</target>
        </trans-unit>
        <trans-unit id="1c64007022d5a6b7fc56b70c6872d834daf7afeb" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;http://sqlfiddle.com/#!9/b4f997/3&quot;&gt;fiddle&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sqlfiddle.com/#!9/b4f997/3&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小提琴&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="daa66a8a369d04a26401fa838b5e654cb97763bd" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;http://sqlfiddle.com/#!9/d74210/1&quot;&gt;fiddle&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sqlfiddle.com/#!9/d74210/1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小提琴&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d3adf0ede9578f08877a8740425d4c6d29f5113e" translate="yes" xml:space="preserve">
          <source>Here is an example of using BlueM/tree:</source>
          <target state="translated">下面是一个使用BlueMtree的例子。</target>
        </trans-unit>
        <trans-unit id="9fa3c285d644a4ebf6a9ae4abbdae1b6a5e4cda5" translate="yes" xml:space="preserve">
          <source>Here, the value specified in &lt;code&gt;@pv := '19'&lt;/code&gt; should be set to the &lt;code&gt;id&lt;/code&gt; of the parent you want to select all the descendants of.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;@pv := '19'&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指定的值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应设置为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要选择其所有后代的父代&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="103ab8290f89ceeb39a65db4903ffbe55a437dad" translate="yes" xml:space="preserve">
          <source>Hope it helps somebody :)</source>
          <target state="translated">希望它能帮助到某人 :)</target>
        </trans-unit>
        <trans-unit id="b177c2ce1f6663820887513ddcce00c2844511ad" translate="yes" xml:space="preserve">
          <source>How to create a MySQL hierarchical recursive query</source>
          <target state="translated">如何创建一个MySQL分层递归查询</target>
        </trans-unit>
        <trans-unit id="7ef21ad37e7da788e87fe5304f1bf40dd151c848" translate="yes" xml:space="preserve">
          <source>I found it more easily to :</source>
          <target state="translated">我发现它更容易。</target>
        </trans-unit>
        <trans-unit id="d6ecd79fcd0029002938355b1e32a5c7c01db155" translate="yes" xml:space="preserve">
          <source>I have a MySQL table which is as follows:</source>
          <target state="translated">我有一个MySQL表,内容如下:</target>
        </trans-unit>
        <trans-unit id="39a33003c9ba672464407a38f7681a84143cfd10" translate="yes" xml:space="preserve">
          <source>I have made a query for you. This will give you Recursive Category with a Single Query:</source>
          <target state="translated">我为你做了一个查询。这将为您提供递归分类与单一查询。</target>
        </trans-unit>
        <trans-unit id="e61929951c25a4914351d05b2e5170acfec79520" translate="yes" xml:space="preserve">
          <source>If you know an upper limit for how deep your hierarchy tree can become, you can use a standard &lt;code&gt;sql&lt;/code&gt; query like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您知道层次结构树可以变为多深的上限，则可以使用如下所示的标准&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sql&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;查询：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6547c17bc8fba05db61716dc1c7368e05bc00a8f" translate="yes" xml:space="preserve">
          <source>If you need quick read speed, the best option is to use a closure table. A closure table contains a row for each ancestor/descendant pair. So in your example, the closure table would look like</source>
          <target state="translated">如果你需要快速读取速度,最好的选择是使用封存表。封闭表包含了每一个祖先后裔对的记录。因此,在你的例子中,封存表看起来是这样的</target>
        </trans-unit>
        <trans-unit id="251f62f0d5ace2a6d7c138ce194fe4f13f6ea999" translate="yes" xml:space="preserve">
          <source>In the end - got more-or-less simple, relatively fast, and SIMPLE solution.</source>
          <target state="translated">最后-得到了或多或少的简单,相对快速,和简单的解决方案。</target>
        </trans-unit>
        <trans-unit id="2545c26c702b94a515fc6db07a06ee528d06ef05" translate="yes" xml:space="preserve">
          <source>It's a &lt;strong&gt;category&lt;/strong&gt; table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类别&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35bc5df1bb85024e2a396f8bacd7c3ade5bc5a85" translate="yes" xml:space="preserve">
          <source>Its a little tricky one, check this whether it is working for you</source>
          <target state="translated">这是个有点棘手的问题,看看这个是否对你有用。</target>
        </trans-unit>
        <trans-unit id="9ef16fd9e098fe1b1f4b6df0d566974497a09113" translate="yes" xml:space="preserve">
          <source>Just use &lt;a href=&quot;https://github.com/BlueM/Tree&quot;&gt;BlueM/tree&lt;/a&gt; php class for make tree of a self-relation table in mysql.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只需&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在MySQL中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/BlueM/Tree&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BlueM / tree&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; php类为自关系表的make树。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5c4cb263b1243695f037e34d15166192d25d068" translate="yes" xml:space="preserve">
          <source>Lineage approach descr. can be found wherever, for example
&lt;a href=&quot;http://ferdychristant.com/blog/archive/DOMM-7QJPM7&quot;&gt;Here&lt;/a&gt; or &lt;a href=&quot;https://dba.stackexchange.com/questions/30021/mysql-tree-hierarchical-query&quot;&gt;here&lt;/a&gt;.
As of function - &lt;a href=&quot;https://stackoverflow.com/questions/12948009/finding-all-parents-in-mysql-table-with-single-query&quot;&gt;that&lt;/a&gt; is what enspired me.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;沿袭方法描述。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以在任何地方找到，例如 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ferdychristant.com/blog/archive/DOMM-7QJPM7&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Here&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://dba.stackexchange.com/questions/30021/mysql-tree-hierarchical-query&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;here&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从功能上来说- &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12948009/finding-all-parents-in-mysql-table-with-single-query&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就是我的灵感。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e90fbcce23a97315476207d7186f6d342adc2d3" translate="yes" xml:space="preserve">
          <source>More and more databases implement the &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL:1999#Common_table_expressions_and_recursive_queries&quot;&gt;SQL:1999 ISO standard &lt;code&gt;WITH [RECURSIVE]&lt;/code&gt; syntax&lt;/a&gt; for recursive queries (e.g. &lt;a href=&quot;http://www.postgresql.org/docs/8.4/static/queries-with.html&quot;&gt;Postgres 8.4+&lt;/a&gt;, &lt;a href=&quot;https://technet.microsoft.com/en-us/library/ms186243%28v=sql.105%29.aspx&quot;&gt;SQL Server 2005+&lt;/a&gt;, &lt;a href=&quot;https://www.ibm.com/developerworks/ibmi/library/i-db2connectby/&quot;&gt;DB2&lt;/a&gt;, &lt;a href=&quot;https://docs.oracle.com/cloud/latest/db112/SQLRF/statements_10002.htm#sthref6733&quot;&gt;Oracle 11gR2+&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/lang_with.html&quot;&gt;SQLite 3.8.4+&lt;/a&gt;, &lt;a href=&quot;https://firebirdsql.org/refdocs/langrefupd21-select.html#langrefupd21-select-cte&quot;&gt;Firebird 2.1+&lt;/a&gt;, &lt;a href=&quot;http://www.h2database.com/html/advanced.html#recursive_queries&quot;&gt;H2&lt;/a&gt;, &lt;a href=&quot;http://www.hsqldb.org/doc/guide/dataaccess-chapt.html#dac_with_clause&quot;&gt;HyperSQL 2.1.0+&lt;/a&gt;, &lt;a href=&quot;http://www.info.teradata.com/htmlpubs/DB_TTU_14_00/index.html#page/SQL_Reference/B035_1146_111A/ch01.032.066.html&quot;&gt;Teradata&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb/with/&quot;&gt;MariaDB 10.2.2+&lt;/a&gt;). And as of &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/with.html&quot;&gt;version 8.0, also MySQL supports it&lt;/a&gt;. See the top of this answer for the syntax to use.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;越来越多的数据库执行&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/SQL:1999#Common_table_expressions_and_recursive_queries&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL：1999 ISO标准&lt;/font&gt;&lt;/font&gt; &lt;code&gt;WITH [RECURSIVE]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;递归查询（例如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.postgresql.org/docs/8.4/static/queries-with.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Postgres的8.4+&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://technet.microsoft.com/en-us/library/ms186243%28v=sql.105%29.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server的2005+&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/ibmi/library/i-db2connectby/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DB2&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/cloud/latest/db112/SQLRF/statements_10002.htm#sthref6733&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;甲骨文11gR2的+&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.sqlite.org/lang_with.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQLite的3.8.4+&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://firebirdsql.org/refdocs/langrefupd21-select.html#langrefupd21-select-cte&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;火鸟2.1+&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.h2database.com/html/advanced.html#recursive_queries&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;H2&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.hsqldb.org/doc/guide/dataaccess-chapt.html#dac_with_clause&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的HyperSQL 2.1。 0+&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.info.teradata.com/htmlpubs/DB_TTU_14_00/index.html#page/SQL_Reference/B035_1146_111A/ch01.032.066.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Teradata&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://mariadb.com/kb/en/mariadb/with/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MariaDB 10.2.2+&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/with.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;8.0版开始，MySQL也支持它&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。有关使用的语法，请参见此答案的顶部。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b465fea6fefc20703fcd0184ebc321a00bd3a113" translate="yes" xml:space="preserve">
          <source>Most users at one time or another have dealt with hierarchical data in a SQL database and no doubt learned that the management of hierarchical data is not what a relational database is intended for. The tables of a relational database are not hierarchical (like XML), but are simply a flat list. Hierarchical data has a parent-child relationship that is not naturally represented in a relational database table.
&lt;a href=&quot;https://web.archive.org/web/20181221162916/http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大多数用户一次或一次都在处理SQL数据库中的分层数据，并且毫无疑问地了解到，分层数据的管理不是关系数据库的目的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关系数据库的表不是分层的（如XML），而仅仅是一个平面列表。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;层次结构数据具有父子关系，而该关系在数据库表中自然无法表示。 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://web.archive.org/web/20181221162916/http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;阅读更多&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09cd315d1d974b6e62f2e487a3710c1369ca5cd2" translate="yes" xml:space="preserve">
          <source>MySQL 5.x</source>
          <target state="translated">MySQL 5.x</target>
        </trans-unit>
        <trans-unit id="cd1b6a94e3bb3fbcc8076cb58c957eb3ca8285ef" translate="yes" xml:space="preserve">
          <source>MySQL 8+</source>
          <target state="translated">MySQL 8+</target>
        </trans-unit>
        <trans-unit id="8868b635a449c1e80fa6338977b9c17cfdf3837d" translate="yes" xml:space="preserve">
          <source>MySQL version 5.7 does not offer such a feature. When your database engine provides this syntax or you can migrate to one that does, then that is certainly the best option to go for. If not, then also consider the following alternatives.</source>
          <target state="translated">MySQL 5.7版本不提供这样的功能。当你的数据库引擎提供了这种语法,或者你可以迁移到提供这种语法的引擎,那么这无疑是最好的选择。如果没有,那么也可以考虑以下的选择。</target>
        </trans-unit>
        <trans-unit id="bbdba033b95c55501c21297ab7e064d71b51af4c" translate="yes" xml:space="preserve">
          <source>Mysql select recursive get all child with multiple level</source>
          <target state="translated">Mysql选择递归式获取所有带多级的孩子</target>
        </trans-unit>
        <trans-unit id="896218529adc761114a6949ee91c45d338e4bc57" translate="yes" xml:space="preserve">
          <source>Now, I want to have a single MySQL query to which I simply supply the id [for instance say 'id = 19'] then I should get all its child ids [i.e. result should have ids '20,21,22']....
Also, the hierarchy of the children is not known it can vary....</source>
          <target state="translated">现在,我想有一个单一的MySQL查询,我只需提供id [例如说'id=19'],然后我应该得到它的所有子id [即结果应该有id'20,21,22'].......另外,子项的层次结构不知道,可能会有变化.....。</target>
        </trans-unit>
        <trans-unit id="6fd1f2668320840a07a37e9fdddebabe466d1961" translate="yes" xml:space="preserve">
          <source>Of course, there is a big downside whenever you use denormalized data like this. You need to maintain the closure table alongside your categories table. The best way is probably to use triggers, but it is somewhat complex to correctly track inserts/updates/deletes for closure tables. As with anything, you need to look at your requirements and decide what approach is best for you.</source>
          <target state="translated">当然,每当你使用这样的非正态化数据时,有一个很大的缺点。你需要将封闭表与类别表一起维护。最好的方法可能是使用触发器,但要正确地跟踪闭合表的insertsupdatesdeletes是有些复杂的。与任何事情一样,你需要看一下你的需求,然后决定什么方法最适合你。</target>
        </trans-unit>
        <trans-unit id="fea0a9f83ce8dd5b7908d6f6102014da790bf083" translate="yes" xml:space="preserve">
          <source>Once you have this table, hierarchical queries become very easy and fast. To get all the descendants of category 20:</source>
          <target state="translated">一旦你有了这个表,分层查询就会变得非常容易和快速。要得到20类的所有子类。</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="3ea1f8834714c0d6fdaed95d92d27bd0bb5a161b" translate="yes" xml:space="preserve">
          <source>Previous releases of MySQL made it possible to assign a value to a user variable in statements other than &lt;code&gt;SET&lt;/code&gt;. This functionality is supported in MySQL 8.0 for backward compatibility but is subject to removal in a future release of MySQL.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MySQL的早期版本使得可以在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;SET&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以外的语句中为用户变量分配值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MySQL 8.0支持此功能以实现向后兼容，但是在将来的MySQL版本中可能会删除该功能。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c1822344bdf8633591dc55296427e00c5285fa8" translate="yes" xml:space="preserve">
          <source>Query:</source>
          <target state="translated">Query:</target>
        </trans-unit>
        <trans-unit id="2bc99338935ecf4308f7c616ced83eb8b692358e" translate="yes" xml:space="preserve">
          <source>Recursive Stored procedure:</source>
          <target state="translated">递归存储过程。</target>
        </trans-unit>
        <trans-unit id="6783b8280f73174e0613c23de9ae067d24cf527f" translate="yes" xml:space="preserve">
          <source>Refer the blog for more details.</source>
          <target state="translated">更多详情请参考博客。</target>
        </trans-unit>
        <trans-unit id="e751dbd9b50dcba4180a9ef66715a0e09620c46c" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://stackoverflow.com/questions/16513418/how-to-do-the-recursive-select-query-in-mysql&quot;&gt;How to do the Recursive SELECT query in Mysql?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参考：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/16513418/how-to-do-the-recursive-select-query-in-mysql&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何在Mysql中执行递归SELECT查询？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38ef9f5b93bbc3e1070283e723373d1275638357" translate="yes" xml:space="preserve">
          <source>Replace with your field and table name appropriately.</source>
          <target state="translated">适当替换为你的字段和表名。</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="ddc2d3f0b5808a9206edbb3146b90c4956b4e66c" translate="yes" xml:space="preserve">
          <source>SQL fiddle link &lt;a href=&quot;http://www.sqlfiddle.com/#!2/e3cdf/2&quot;&gt;http://www.sqlfiddle.com/#!2/e3cdf/2&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL小提琴链接&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.sqlfiddle.com/#!2/e3cdf/2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.sqlfiddle.com/#!2/e3cdf/2&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="479149be3ecb7aa4351d188d4d6ddbe0bc854a26" translate="yes" xml:space="preserve">
          <source>See this &lt;a href=&quot;http://sqlfiddle.com/#!9/5de2a/46&quot;&gt;fiddle&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;看到这个&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sqlfiddle.com/#!9/5de2a/46&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小提琴&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b191e0722a59e0bc08a6c015ba68517e511303a8" translate="yes" xml:space="preserve">
          <source>Select example:</source>
          <target state="translated">选择例子。</target>
        </trans-unit>
        <trans-unit id="0dbeacad6e10bb50e106867fb424804324f5257a" translate="yes" xml:space="preserve">
          <source>Simple query to list child's of first recursion:</source>
          <target state="translated">简单的查询,列出第一个递归的子项。</target>
        </trans-unit>
        <trans-unit id="3974149b0b60d0e3915d1f7ac4eacb82d88ed74f" translate="yes" xml:space="preserve">
          <source>So even though it works consistently with the above query, the evaluation order may still change, for instance when you add conditions or use this query as a view or sub-query in a larger query. It is a &quot;feature&quot; that &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/user-variables.html&quot;&gt;will be removed in a future MySQL release&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，即使它与上述查询一致地工作，评估顺序仍可能会更改，例如，当您添加条件或将此查询用作较大查询中的视图或子查询时。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个&amp;ldquo;功能&amp;rdquo;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/user-variables.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将在将来的MySQL版本中删除&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b1bc092a320c00fe0119e4963c25c91ab2648364" translate="yes" xml:space="preserve">
          <source>Some databases have an alternative, non-standard syntax for hierarchical look-ups, such as the &lt;code&gt;CONNECT BY&lt;/code&gt; clause available on &lt;a href=&quot;https://docs.oracle.com/cd/B19306_01/server.102/b14200/queries003.htm&quot;&gt;Oracle&lt;/a&gt;, &lt;a href=&quot;https://www.ibm.com/developerworks/ibmi/library/i-db2connectby/&quot;&gt;DB2&lt;/a&gt;, &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSGU8G_12.1.0/com.ibm.sqls.doc/ids_sqs_2035.htm&quot;&gt;Informix&lt;/a&gt;, &lt;a href=&quot;https://www.cubrid.org/manual/en/10.0/sql/query/hq.html&quot;&gt;CUBRID&lt;/a&gt; and other databases.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;某些数据库具有用于分层查找的替代非标准语法，例如&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/cd/B19306_01/server.102/b14200/queries003.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Oracle&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/ibmi/library/i-db2connectby/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DB2&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSGU8G_12.1.0/com.ibm.sqls.doc/ids_sqs_2035.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Informix&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;a href=&quot;https://www.cubrid.org/manual/en/10.0/sql/query/hq.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CUBRID&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和其他数据库&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上可用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;CONNECT BY&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子句&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26947e1fc07b1b3f990926e0a985cbb5e78aa8af" translate="yes" xml:space="preserve">
          <source>Something not mentioned here, although a bit similar to the second alternative of the accepted answer but different and low cost for big hierarchy query and easy (insert update delete) items, would be  adding a persistent path  column for each item.</source>
          <target state="translated">这里没有提到的东西,虽然有点类似于接受答案中的第二种选择,但不同的是,对于大的分层查询和简单的(插入更新删除)项来说,成本很低,这将是为每个项添加一个持久路径列。</target>
        </trans-unit>
        <trans-unit id="56f59e348bb1fa58e62f7df4bd2bfe907170b02f" translate="yes" xml:space="preserve">
          <source>Suppressing also the slash '/' separator by using fixed length and padding to the encoded id</source>
          <target state="translated">通过在编码后的id中使用固定的长度和padding来抑制斜线''''分隔符。</target>
        </trans-unit>
        <trans-unit id="aac1deb9db82b6cd6275b2705e677dce51d2057e" translate="yes" xml:space="preserve">
          <source>Table definition:</source>
          <target state="translated">表的定义:</target>
        </trans-unit>
        <trans-unit id="261e19cd4c00462ee4c72a1d1518d0962048f879" translate="yes" xml:space="preserve">
          <source>Table structure</source>
          <target state="translated">表格结构</target>
        </trans-unit>
        <trans-unit id="f4d63d7bc6b4ac2c5617fc5ec1bfe5252f32f899" translate="yes" xml:space="preserve">
          <source>Test it online with &lt;a href=&quot;http://sqlfiddle.com/#!9/a318e3/4/0&quot;&gt;Sql Fiddle&lt;/a&gt; and see all results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sqlfiddle.com/#!9/a318e3/4/0&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sql Fiddle&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在线测试它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并查看所有结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3522e21b699bf4af9b0d8d97c777880a17f0346e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; clause is evaluated first. So that is where &lt;code&gt;@pv&lt;/code&gt; gets initialised.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;from&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子句第一评价。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这就是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;@pv&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化的地方。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75127c8ae86210d69079f5e9485683fefc44c7ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; clause is evaluated for each record in the order of retrieval from the &lt;code&gt;from&lt;/code&gt; aliases. So this is where a condition is put to only include records for which the parent was already identified as being in the descendant tree (all descendants of the primary parent are progressively added to &lt;code&gt;@pv&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;按照&lt;/font&gt; &lt;code&gt;from&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;别名&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中检索的顺序为每个记录评估&lt;/font&gt;&lt;/font&gt; &lt;code&gt;where&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子句&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，在这里将条件放在仅包括已将其父级标识为后代树的记录中（主要父级的所有后代都逐渐添加到&lt;/font&gt; &lt;code&gt;@pv&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07c1bc852d4515012332a55ed60635472b661a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; condition specifies which parent you want to retrieve the descendants of. You can extend this query with more levels as needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;where&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要检索的后裔，其母公司条件指定。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以根据需要将查询扩展到更多级别。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94411603a318589131454c17f8d6834890d2b862" translate="yes" xml:space="preserve">
          <source>The best approach I've come up with is</source>
          <target state="translated">我想出的最好的办法是</target>
        </trans-unit>
        <trans-unit id="d3c24ebc8dacde720b6360e6449745f077296ccc" translate="yes" xml:space="preserve">
          <source>The conditions in this &lt;code&gt;where&lt;/code&gt; clause are evaluated in order, and the evaluation is interrupted once the total outcome is certain. Therefore the second condition must be in second place, as it adds the &lt;code&gt;id&lt;/code&gt; to the parent list, and this should only happen if the &lt;code&gt;id&lt;/code&gt; passes the first condition. The &lt;code&gt;length&lt;/code&gt; function is only called to make sure this condition is always true, even if the &lt;code&gt;pv&lt;/code&gt; string would for some reason yield a falsy value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;where&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子句中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的条件按&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;顺序求值，一旦确定总结果，就中断该求值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，第二个条件必须排在第二位，因为它会将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;添加&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到父级列表中，并且只有在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过第一个条件&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时才应发生&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt; &lt;code&gt;length&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数只调用，以确保这个条件总是真，即使&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pv&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;串会因为某些原因产生falsy值。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b2b8364d89bae3d7eb4a42ba260d163dd89e3ed2" translate="yes" xml:space="preserve">
          <source>The other way to do it is to store two extra bits of data, a left and right value. The left and right value are derived from a pre-order traversal of the tree structure you're representing.</source>
          <target state="translated">另一种方法是存储两个额外的数据位,一个左值和一个右值。左值和右值来自于你所代表的树形结构的预排序遍历。</target>
        </trans-unit>
        <trans-unit id="76db8ee2809916c0b2b2a7d652ec5c679894bf7b" translate="yes" xml:space="preserve">
          <source>The query will be :</source>
          <target state="translated">该查询将是.NET。</target>
        </trans-unit>
        <trans-unit id="5e9404295f927d7ad5d10873b9b9b6f46c629361" translate="yes" xml:space="preserve">
          <source>The solution of @tincot to list all child's:</source>
          <target state="translated">@tincot的解决方案,把所有的孩子都列出来。</target>
        </trans-unit>
        <trans-unit id="a16be5714781288692be72bb12e230b93057aa17" translate="yes" xml:space="preserve">
          <source>The value specified in &lt;code&gt;parent_id = 19&lt;/code&gt; should be set to the &lt;code&gt;id&lt;/code&gt; of the parent you want to select all the descendants of.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;parent_id = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指定的值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应设置为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要选择其所有后代的父代&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f07487f6d2811b0df667487d2cf479eea8051df1" translate="yes" xml:space="preserve">
          <source>Then your &lt;code&gt;select&lt;/code&gt; would look like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后您的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;select&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将如下所示：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7bc37dfa2ea170cae674199f02a088a9e10963e8" translate="yes" xml:space="preserve">
          <source>Things become a lot easier if you would assign &lt;code&gt;id&lt;/code&gt; values that contain the hierarchical information: a path. For example, in your case this could look like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您要分配&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包含分层信息（路径）的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;事情就会变得容易&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;得多。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，在您的情况下，可能如下所示：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="331534ddc60b194b84b9d29fb5c264bf01aa8406" translate="yes" xml:space="preserve">
          <source>This is know as Modified Preorder Tree Traversal and lets you run a simple query to get all parent values at once. It also goes by the name &quot;nested set&quot;.</source>
          <target state="translated">这就是所谓的 &quot;修改后的预订单树遍历&quot;,可以让你运行一个简单的查询来一次获得所有的父值。它还有一个名字叫 &quot;嵌套集&quot;。</target>
        </trans-unit>
        <trans-unit id="a2cf088ea5055f1dfc8928d426d7cd55cb4d196a" translate="yes" xml:space="preserve">
          <source>This query uses specific MySQL syntax: variables are assigned and modified during its execution. Some assumptions are made about the order of execution:</source>
          <target state="translated">这个查询使用了特定的MySQL语法:变量在执行过程中被分配和修改。对执行顺序做了一些假设。</target>
        </trans-unit>
        <trans-unit id="da5a6d4aaace077f35f99e3f5507790c624f58ca" translate="yes" xml:space="preserve">
          <source>This will work also if a parent has &lt;em&gt;multiple&lt;/em&gt; children. However, it is required that each record fulfills the condition &lt;code&gt;parent_id &amp;lt; id&lt;/code&gt;, otherwise the results will not be complete.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果父母有&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;孩子，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这也将起作用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，要求每个记录都满足条件&lt;/font&gt;&lt;/font&gt; &lt;code&gt;parent_id &amp;lt; id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，否则结果将不完整。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d209cf29ab46b58ebe40561303c74d429e73d07c" translate="yes" xml:space="preserve">
          <source>This works for me, hope this will work for you too. It will give you a Record set Root to Child for any Specific Menu. Change the Field name as per your requirements.</source>
          <target state="translated">这对我来说很管用,希望这对你也有用。它将给你一个记录设置为根到子菜单。根据你的要求更改字段名称。</target>
        </trans-unit>
        <trans-unit id="1da526bde925085c60848f103294a4a0db792a4c" translate="yes" xml:space="preserve">
          <source>Tree&amp;nbsp;and&amp;nbsp;Tree\Node&amp;nbsp;are PHP classes for handling data that is structured hierarchically using parent ID references. A typical example is a table in a relational database where each record&amp;rsquo;s &amp;ldquo;parent&amp;rdquo; field references the primary key of another record. Of course, Tree cannot only use data originating from a database, but anything: you supply the data, and Tree uses it, regardless of where the data came from and how it was processed. &lt;a href=&quot;https://github.com/BlueM/Tree/blob/master/README.markdown&quot;&gt;read more&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tree和Tree \ Node是PHP类，用于处理使用父ID引用进行层次结构化的数据。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个典型的示例是关系数据库中的表，其中每个记录的&amp;ldquo;父&amp;rdquo;字段引用另一个记录的主键。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，Tree不仅可以使用源自数据库的数据，还可以使用任何数据：您提供数据，而Tree使用它，而不管数据来自何处以及如何处理。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/BlueM/Tree/blob/master/README.markdown&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;阅读更多&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cf8dcbdc0bfd926ebca3a5335638f862ee1041d" translate="yes" xml:space="preserve">
          <source>Try these:</source>
          <target state="translated">试试这些。</target>
        </trans-unit>
        <trans-unit id="b7dabc3104b9a5b0d2f188ca63319dd09ba1f0bd" translate="yes" xml:space="preserve">
          <source>Use function that determines lineage for specific ID.</source>
          <target state="translated">使用决定特定ID的行系的函数。</target>
        </trans-unit>
        <trans-unit id="9a7938c42350c397d4f516ea3c096eb1b9702760" translate="yes" xml:space="preserve">
          <source>Use it as you wish (in selects, or on CUD operations, or even by jobs).</source>
          <target state="translated">随心所欲地使用它(在选择中,或在CUD操作中,甚至在作业中)。</target>
        </trans-unit>
        <trans-unit id="a1b7cb3b8b0dc66687f64c99313b7b486138688d" translate="yes" xml:space="preserve">
          <source>Use lineage to store\sort\trace trees. That's more than enough, and works thousands times faster for reading than any other approach.
It also allows to stay on that pattern even if DB will change(as ANY db will allow that pattern to be used)</source>
          <target state="translated">用线程来存储树。这已经足够了,而且比其他任何方法都要快上千倍。它还允许即使DB会改变,也可以保持在这个模式上(因为任何DB都允许使用这个模式)。</target>
        </trans-unit>
        <trans-unit id="6c78f56d43b0a4bb87035f70ceede81e43f8a9fb" translate="yes" xml:space="preserve">
          <source>Variable assignments inside a query</source>
          <target state="translated">查询中的变量分配</target>
        </trans-unit>
        <trans-unit id="7b16ce58957c8fd85c356f226d30d7e6d26b79c3" translate="yes" xml:space="preserve">
          <source>Wrapper function for the stored procedure:</source>
          <target state="translated">存储过程的Wrapper函数。</target>
        </trans-unit>
        <trans-unit id="087c01adb4e0d6a1b7278b2def4c041bb05b26fe" translate="yes" xml:space="preserve">
          <source>You can do it like this in other databases quite easily with a recursive query (YMMV on performance).</source>
          <target state="translated">你可以在其他数据库中通过递归查询很容易做到这一点(性能上的YMMV)。</target>
        </trans-unit>
        <trans-unit id="495f7224975e7dc2e442f7a009beeb4be776aa87" translate="yes" xml:space="preserve">
          <source>building a function or procedure to split path for retreive ancestors of one item</source>
          <target state="translated">构建一个函数或过程来分道扬镳的函数或过程</target>
        </trans-unit>
        <trans-unit id="72097978d88eb31ea63e5397e4a7bb18f52569a6" translate="yes" xml:space="preserve">
          <source>in your example</source>
          <target state="translated">在你的例子中</target>
        </trans-unit>
        <trans-unit id="a0afed75e77b22a52dbab394e67cc3e37bef1b6a" translate="yes" xml:space="preserve">
          <source>some like:</source>
          <target state="translated">有的人喜欢:</target>
        </trans-unit>
        <trans-unit id="b3e0d16124df14beec20207008de2845a0e3bf01" translate="yes" xml:space="preserve">
          <source>you might get the results you expect, but this is not guaranteed [...] the order of evaluation for expressions involving user variables is undefined.</source>
          <target state="translated">你可能会得到你期望的结果,但这并不能保证[...]涉及用户变量的表达式的评价顺序是未定义的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
