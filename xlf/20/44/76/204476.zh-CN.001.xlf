<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/204476">
    <body>
      <group id="204476">
        <trans-unit id="839e4a2006b278a93c4dc0f1936567078302c3f3" translate="yes" xml:space="preserve">
          <source>&amp;hellip;</source>
          <target state="translated">&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="f63367f1516d04e6d4576f54a6d715fa5519616b" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a function of () returning int and</source>
          <target state="translated">&amp;mdash;（）返回int和的函数</target>
        </trans-unit>
        <trans-unit id="e3f10b4fa0118c5d90b758f3a7a22ecd6eddcb20" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a function of (int, pointer to pointer to char) returning int</source>
          <target state="translated">&amp;mdash;（int，指向char的指针的指针）返回int的函数</target>
        </trans-unit>
        <trans-unit id="de2b84f7b4965ccad1f31acc3adcae74954902d4" translate="yes" xml:space="preserve">
          <source>&amp;para;1 A program shall contain a global function called main, which is the designated start of the program. [...]</source>
          <target state="translated">&amp;para;1程序应包含一个名为main的全局函数，这是程序的指定开始位置。 [...]</target>
        </trans-unit>
        <trans-unit id="fba079ec46d6590faa38ad6852c15693de356522" translate="yes" xml:space="preserve">
          <source>&amp;para;1 In a hosted environment, the main function receives a third argument, &lt;code&gt;char *envp[]&lt;/code&gt;,
  that points to a null-terminated array of pointers to &lt;code&gt;char&lt;/code&gt;, each of which points to a string
  that provides information about the environment for this execution of the program (5.1.2.2.1).</source>
          <target state="translated">&amp;para;1在托管环境中，主函数接收第三个参数 &lt;code&gt;char *envp[]&lt;/code&gt; ，它指向以 &lt;code&gt;char&lt;/code&gt; 结尾的以空字符结尾的指针数组，每个指针都指向一个字符串，该字符串为执行提供有关环境的信息程序（5.1.2.2.1）。</target>
        </trans-unit>
        <trans-unit id="268bf348aa4cc2e0b88457c3f6e444329c666667" translate="yes" xml:space="preserve">
          <source>&amp;para;2 An implementation shall not predefine the main function. This function shall not be overloaded. It shall
  have a return type of type int, but otherwise its type is implementation defined.
  All implementations
  shall allow both of the following definitions of main:</source>
          <target state="translated">&amp;para;2实现不得预定义主要功能。 此功能不得重载。 它的返回类型应该是int类型，否则它的类型是实现定义的。 所有实现都应允许以下两个main定义：</target>
        </trans-unit>
        <trans-unit id="f725c7d6a718deeff027d0b7dca43053111038cf" translate="yes" xml:space="preserve">
          <source>&amp;para;3 The function &lt;code&gt;main&lt;/code&gt; shall not be used within a program. The linkage (3.5) of &lt;code&gt;main&lt;/code&gt; is implementation-defined. [...]</source>
          <target state="translated">&amp;para;3函数 &lt;code&gt;main&lt;/code&gt; 不得在程序内使用。 &lt;code&gt;main&lt;/code&gt; 的链接（3.5）是实现定义的。 [...]</target>
        </trans-unit>
        <trans-unit id="6b25271533fe3e52213549f62d7343ca3360fd44" translate="yes" xml:space="preserve">
          <source>&amp;para;5 A &lt;em&gt;strictly conforming program&lt;/em&gt; shall use only those features of the language and library specified in this International Standard.&lt;sup&gt;3)&lt;/sup&gt; It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.</source>
          <target state="translated">&amp;para;5 &lt;em&gt;严格符合标准的程序&lt;/em&gt;应仅使用本国际标准中指定的语言和库的那些功能。 &lt;sup&gt;3）&lt;/sup&gt;不应根据任何未指定，未定义或实现定义的行为产生输出，并且不得超过任何最小实现限制。</target>
        </trans-unit>
        <trans-unit id="faf3a7ecabef70212bf778ca2245ba160daae386" translate="yes" xml:space="preserve">
          <source>&amp;para;5 A return statement in main has the effect of leaving the main function (destroying any objects with automatic
  storage duration) and calling &lt;code&gt;std::exit&lt;/code&gt; with the return value as the argument. If control reaches the end
  of main without encountering a return statement, the effect is that of executing</source>
          <target state="translated">&amp;para;5main中的return语句的作用是保留main函数（以自动存储持续时间销毁所有对象）并以返回值作为参数调用 &lt;code&gt;std::exit&lt;/code&gt; 。 如果控制在没有遇到return语句的情况下到达了main的末尾，则结果是执行</target>
        </trans-unit>
        <trans-unit id="cd52c684e5038903c8d7058be01e2ecabbdecb17" translate="yes" xml:space="preserve">
          <source>&amp;para;5 Finally, control is returned to the host environment. If the value of &lt;code&gt;status&lt;/code&gt; is zero or &lt;code&gt;EXIT_SUCCESS&lt;/code&gt;, an implementation-defined form of the status &lt;em&gt;successful termination&lt;/em&gt; is returned. If the value of &lt;code&gt;status&lt;/code&gt; is &lt;code&gt;EXIT_FAILURE&lt;/code&gt;, an implementation-defined form of the status &lt;em&gt;unsuccessful termination&lt;/em&gt; is returned. Otherwise the status returned is implementation-defined.</source>
          <target state="translated">&amp;para;5最后，控制权返回到主机环境。 如果 &lt;code&gt;status&lt;/code&gt; 的值为零或 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; ，则返回实现定义的状态&lt;em&gt;成功终止的&lt;/em&gt;形式。 如果 &lt;code&gt;status&lt;/code&gt; 的值为 &lt;code&gt;EXIT_FAILURE&lt;/code&gt; ，则返回实现定义的状态&lt;em&gt;失败终止的&lt;/em&gt;形式。 否则，返回的状态是实现定义的。</target>
        </trans-unit>
        <trans-unit id="75b067a9183eb49f341e4cb9b8899302c2bf5c32" translate="yes" xml:space="preserve">
          <source>&amp;para;6 The two forms of conforming implementation are &lt;em&gt;hosted&lt;/em&gt; and &lt;em&gt;freestanding&lt;/em&gt;. A &lt;em&gt;conforming hosted implementation&lt;/em&gt; shall accept any strictly conforming program. A &lt;em&gt;conforming freestanding implementation&lt;/em&gt; shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;,
  &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;, and
  &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;. A conforming implementation may have extensions (including
  additional library functions), provided they do not alter the behavior of any strictly conforming program.&lt;sup&gt;4)&lt;/sup&gt;</source>
          <target state="translated">&amp;para;6符合的实现的两种形式是&lt;em&gt;托管的&lt;/em&gt;和&lt;em&gt;独立的&lt;/em&gt; 。 &lt;em&gt;合格的托管实施&lt;/em&gt;应接受任何严格合格的程序。 &lt;em&gt;符合标准的独立实现&lt;/em&gt;应接受任何严格符合标准的程序，在该程序中，使用库子句（第7节）中指定的功能仅限于标准标头 &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt; 。 符合条件的实现可以具有扩展（包括其他库函数），前提是它们不会改变任何严格符合程序的行为。 &lt;sup&gt;4）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="80e12995965674219f63848c639631125cf40efd" translate="yes" xml:space="preserve">
          <source>&amp;para;7 A &lt;em&gt;conforming program&lt;/em&gt; is one that is acceptable to a conforming implementation.&lt;sup&gt;5)&lt;/sup&gt;</source>
          <target state="translated">&amp;para;7 &lt;em&gt;合格程序&lt;/em&gt;是合格实现可接受的&lt;em&gt;程序&lt;/em&gt; 。 &lt;sup&gt;5）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ca1e412dcdcb69f2e17aed105715050d1052b4ce" translate="yes" xml:space="preserve">
          <source>&amp;para;7 Two kinds of implementations are defined: a &lt;em&gt;hosted implementation&lt;/em&gt; and a &lt;em&gt;freestanding implementation&lt;/em&gt;. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding
  implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).</source>
          <target state="translated">&amp;para;7定义了两种实现： &lt;em&gt;托管实现&lt;/em&gt;和&lt;em&gt;独立实现&lt;/em&gt; 。 对于托管实施，此国际标准定义了可用库的集合。 独立的实现是可以在不借助操作系统的情况下进行执行的独立实现，并且具有一组实现定义的库，其中包括某些语言支持库（17.6.1.3）。</target>
        </trans-unit>
        <trans-unit id="d7dc9283f7b16f5ee420119dfbaa6363dac4ba08" translate="yes" xml:space="preserve">
          <source>&amp;para;8 A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that
  use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.</source>
          <target state="translated">&amp;para;8符合标准的实现可以具有扩展（包括附加的库函数），只要它们不改变任何格式良好的程序的行为即可。 需要实施以诊断使用根据本国际标准格式错误的扩展程序的程序。 但是，这样做后，他们可以编译和执行此类程序。</target>
        </trans-unit>
        <trans-unit id="aee57d8b42fa45a9c62d786d87e4e51641c9817b" translate="yes" xml:space="preserve">
          <source>&amp;para;8 EXAMPLE 3 In this example, the size of a variable length array is computed and returned from a function:</source>
          <target state="translated">&amp;para;8示例3在此示例中，将计算可变长度数组的大小并从函数返回：</target>
        </trans-unit>
        <trans-unit id="7375209cbdea44802996e1ba4bfbb7ebf8bcffc8" translate="yes" xml:space="preserve">
          <source>&amp;para;9 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support and defines all locale-specific characteristics.&lt;sup&gt;3&lt;/sup&gt;</source>
          <target state="translated">&amp;para;9每个实现都应包括文档，该文档标识它不支持的所有条件支持的构造，并定义所有特定于语言环境的特征。 &lt;sup&gt;3&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="f8c0fd5dd6b6ab8b703b27f9f230f0a90552ad70" translate="yes" xml:space="preserve">
          <source>0 for success, nonzero for failure.  Again, not something you need to (or get to) pick: it's defined by the interface you're supposed to be conforming to.</source>
          <target state="translated">0代表成功,非零代表失败。同样,不是你需要(或得到)选择的东西:它是由你应该遵守的接口定义的。</target>
        </trans-unit>
        <trans-unit id="bc9b8d3e781ce73dbb246a75ec5a09339f47b503" translate="yes" xml:space="preserve">
          <source>1 If the return type of the &lt;code&gt;main&lt;/code&gt; function is a type compatible with &lt;code&gt;int&lt;/code&gt;, a return from the
  initial call to the &lt;code&gt;main&lt;/code&gt; function is equivalent to calling the &lt;code&gt;exit&lt;/code&gt; function with the value
  returned by the &lt;code&gt;main&lt;/code&gt; function as its argument;&lt;sup&gt;11)&lt;/sup&gt; reaching the &lt;code&gt;}&lt;/code&gt; that terminates the
  &lt;code&gt;main&lt;/code&gt; function returns a value of 0. If the return type is not compatible with &lt;code&gt;int&lt;/code&gt;, the
  termination status returned to the host environment is unspecified.</source>
          <target state="translated">1如果 &lt;code&gt;main&lt;/code&gt; 函数的返回类型是与 &lt;code&gt;int&lt;/code&gt; 兼容的类型，则从初始调用到 &lt;code&gt;main&lt;/code&gt; 函数的返回等同于以 &lt;code&gt;main&lt;/code&gt; 函数返回的值作为参数来调用 &lt;code&gt;exit&lt;/code&gt; 函数； &lt;sup&gt;11）&lt;/sup&gt;到达终止 &lt;code&gt;main&lt;/code&gt; 函数的 &lt;code&gt;}&lt;/code&gt; 会返回值0。如果返回类型与 &lt;code&gt;int&lt;/code&gt; 不兼容，则未指定返回主机环境的终止状态。</target>
        </trans-unit>
        <trans-unit id="9f3fffa3327d3ba52b48bca6ea15dcebe78e227a" translate="yes" xml:space="preserve">
          <source>1.4 Implementation compliance [intro.compliance]</source>
          <target state="translated">1.4 执行遵约[介绍性遵约]</target>
        </trans-unit>
        <trans-unit id="c6764c018e0ee51831b7edf8ba43133716139970" translate="yes" xml:space="preserve">
          <source>17.6.1.3 Freestanding implementations [compliance]</source>
          <target state="translated">17.6.1.3 独立实施[遵守]</target>
        </trans-unit>
        <trans-unit id="c625fb551848e2eda9b2bcd7f1fbfbeae2205afb" translate="yes" xml:space="preserve">
          <source>3.6.1 Main function [basic.start.main]</source>
          <target state="translated">3.6.1 主函数[basic.start.main]</target>
        </trans-unit>
        <trans-unit id="74939d480b030b4d0aca4a62a78baefa0b305245" translate="yes" xml:space="preserve">
          <source>5.1.2 Execution environments</source>
          <target state="translated">5.1.2 执行环境</target>
        </trans-unit>
        <trans-unit id="a10709d6042407d378ae63fb597e3cb0c35f37a4" translate="yes" xml:space="preserve">
          <source>5.1.2.1 Freestanding environment</source>
          <target state="translated">5.1.2.1 独立式环境</target>
        </trans-unit>
        <trans-unit id="421d09a1018436b2d8a5dd11587decfcfcd9ac51" translate="yes" xml:space="preserve">
          <source>5.1.2.2.1 Program startup</source>
          <target state="translated">5.1.2.2.1 启动程序</target>
        </trans-unit>
        <trans-unit id="bf97d5d45eb7bf179cd39bc7a3476106465bd537" translate="yes" xml:space="preserve">
          <source>5.1.2.2.3 Program termination</source>
          <target state="translated">5.1.2.2.2.3 程序终止</target>
        </trans-unit>
        <trans-unit id="aaeb27114e23ee14710f683d375b03fdb9b9be98" translate="yes" xml:space="preserve">
          <source>6.11.6 Function declarators</source>
          <target state="translated">6.11.6 函数声明器</target>
        </trans-unit>
        <trans-unit id="fa42bbaed1d0a660afc0222443686a157a0e6ebd" translate="yes" xml:space="preserve">
          <source>6.5.3.4 The &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators</source>
          <target state="translated">6.5.3.4 &lt;code&gt;sizeof&lt;/code&gt; 和 &lt;code&gt;_Alignof&lt;/code&gt; 运算符</target>
        </trans-unit>
        <trans-unit id="af39c61a22e5f25a61be3c526a6c974cd1ea404d" translate="yes" xml:space="preserve">
          <source>7.22.4.4 The &lt;code&gt;exit&lt;/code&gt; function</source>
          <target state="translated">7.22.4.4 &lt;code&gt;exit&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="2259a4ab4a2439d3610778ec870b765036afd221" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main&quot;&gt;What is the proper declaration of &lt;code&gt;main()&lt;/code&gt;?&lt;/a&gt; &amp;mdash; For C++, with a very good answer indeed.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main&quot;&gt; &lt;code&gt;main()&lt;/code&gt; 的正确声明是什么？&lt;/a&gt; &amp;mdash;对于C ++，确实有很好的答案。</target>
        </trans-unit>
        <trans-unit id="e29bc9e2848992cf6548652af8a5be14a9249467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argv[argc]&lt;/code&gt; shall be a null pointer.</source>
          <target state="translated">&lt;code&gt;argv[argc]&lt;/code&gt; 应为空指针。</target>
        </trans-unit>
        <trans-unit id="4a37fed8f5445c4993b8c5da80701807ea9a23fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int main()&lt;/code&gt; vs &lt;code&gt;void main()&lt;/code&gt; in C</source>
          <target state="translated">&lt;code&gt;int main()&lt;/code&gt; 与 &lt;code&gt;void main()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8f60346f2e6dc9ec649d50698ae28dc37e9103d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt; in C89 and K&amp;amp;R C unspecified return types default to &amp;rsquo;int`.</source>
          <target state="translated">C89和K＆R C未指定返回类型的 &lt;code&gt;main()&lt;/code&gt; 默认为'int`。</target>
        </trans-unit>
        <trans-unit id="77a0a2cbf7bad637f5c880daeb2e835a409f5011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt; should be declared as either:</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 应该声明为：</target>
        </trans-unit>
        <trans-unit id="a99a4351928aa53be892994d830351307ef971d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt;'s signature in C++</source>
          <target state="translated">C ++中 &lt;code&gt;main()&lt;/code&gt; 的签名</target>
        </trans-unit>
        <trans-unit id="3389bce9434a3b56c3264af85cd3f1e622526831" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return 0&lt;/code&gt; or &lt;code&gt;return 1&lt;/code&gt; will be received by the parent process. In a shell it goes into a shell variable, and if you are running your program form a shell and not using that variable then you need not worry about the return value of &lt;code&gt;main()&lt;/code&gt;.</source>
          <target state="translated">父进程将收到 &lt;code&gt;return 0&lt;/code&gt; 或 &lt;code&gt;return 1&lt;/code&gt; 。 在外壳程序中，它进入一个外壳程序变量，如果您在外壳程序中运行程序而未使用该变量，则无需担心 &lt;code&gt;main()&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="9357defb5f570731b5b1bc998cafabdff46afe41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;There are numerous duplicates of this question, including:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;这个问题有很多重复，包括：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24c37500e1d6539a78a2997986f25d358e54ee71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++03 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 03独立式环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ca7c7ddff5ac442add7172c71909b660ede292c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++03 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 03托管环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82a7ebec217d66e8b8c2d24ab3e3f5b1cacef4f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 11独立环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2b3cabf96f4ea44d63a24449dabea2a53cf0512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 11托管环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09f98f8248303be464d553d71fb5cf58e90f51b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C11 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C11独立环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b60f1d79fd4fb894543c08e1c03275903168a46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C11 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C11托管环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f08ea5864b7e3a0f044a93ec2f7398ca698c40b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C90 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C90独立式环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d214f0511b5d0b5572547a7e70a1324e68f71d7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C90 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C90托管环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="100ce1f0e56996aa7562559f1b8a172eabbb3b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C99独立式环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aced90d316248fd18e7f601285666ee9656c0b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C99托管环境&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39941c674be35df5a1e78497af6e5aefcc124f65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when I make this suggestion, it's almost invariably followed by one of two kinds of comments:  &quot;I didn't know that.&quot; or &quot;That's bad advice!&quot;  My rationale is that it's safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;当我提出此建议时，几乎总是会出现以下两种评论之一：&amp;ldquo;我不知道。&amp;rdquo; 或&amp;ldquo;这是个坏建议！&amp;rdquo; 我的理由是，依靠该标准明确支持的编译器行为既安全又有用。 对于C，自C99起； 参见ISO / IEC 9899：1999第5.1.2.2.3节：</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ede2f6abb3f054287bbb931649c2f245bcaa1f0" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;10)&lt;/sup&gt; Thus, &lt;code&gt;int&lt;/code&gt; can be replaced by a typedef name defined as &lt;code&gt;int&lt;/code&gt;, or the type of &lt;code&gt;argv&lt;/code&gt; can be written as
  &lt;code&gt;char **argv&lt;/code&gt;, and so on.</source>
          <target state="translated">&lt;sup&gt;10）&lt;/sup&gt;因此，可以用定义为 &lt;code&gt;int&lt;/code&gt; 的typedef名称替换int ，也可以将 &lt;code&gt;argv&lt;/code&gt; 的类型写为 &lt;code&gt;char **argv&lt;/code&gt; ，依此类推。</target>
        </trans-unit>
        <trans-unit id="011ebdf423d0eeaeb00bbe1f5e9f73f7e03f1379" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;11)&lt;/sup&gt; In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in &lt;code&gt;main&lt;/code&gt;
  will have ended in the former case, even where they would not have in the latter.</source>
          <target state="translated">&lt;sup&gt;11）&lt;/sup&gt;根据6.2.4，在 &lt;code&gt;main&lt;/code&gt; 中声明的具有自动存储期限的对象的生存期将在前一种情况下终止，即使在后者没有的情况下也是如此。</target>
        </trans-unit>
        <trans-unit id="a58a7471bfb0770dd6b5ffe6f2124853a918a6d6" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3)&lt;/sup&gt; A strictly conforming program can use conditional features (see 6.10.8.3) provided the use is guarded by an appropriate conditional inclusion preprocessing directive using the related macro. For example:</source>
          <target state="translated">&lt;sup&gt;3）&lt;/sup&gt;严格符合条件的程序可以使用条件功能（请参阅6.10.8.3），前提是该使用受到使用相关宏的适当的条件包含预处理指令的保护。 例如：</target>
        </trans-unit>
        <trans-unit id="2a0e8c9db9d88c7fc9a217ed3b840fdfca0ad4c9" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3)&lt;/sup&gt; This documentation also defines implementation-defined behavior; see 1.9.</source>
          <target state="translated">&lt;sup&gt;3）&lt;/sup&gt;本文档还定义了实现定义的行为； 参见1.9。</target>
        </trans-unit>
        <trans-unit id="60f63bd67cf9699a2930ead7ef8840e496fb4919" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4)&lt;/sup&gt; This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.</source>
          <target state="translated">&lt;sup&gt;4）&lt;/sup&gt;这意味着除本国际标准中明确保留的标识符外，符合标准的实现不保留任何标识符。</target>
        </trans-unit>
        <trans-unit id="df6a402d9d62f5a27a627e0839825b19422b9ff0" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;5)&lt;/sup&gt; Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon non-portable features of a conforming implementation.</source>
          <target state="translated">&lt;sup&gt;5）&lt;/sup&gt;严格符合标准的程序旨在在符合标准的实现中最大程度地移植。 合格程序可能取决于合格实施的非便携式功能。</target>
        </trans-unit>
        <trans-unit id="181254e8f9b948c18cf54289fc472931f4bcaf8c" translate="yes" xml:space="preserve">
          <source>A freestanding implementation has an implementation-defined set of headers. This set shall include at least the headers shown in Table 16.</source>
          <target state="translated">一个独立的实施方式有一套由实施方式定义的标头。该集应至少包括表16所示的标题。</target>
        </trans-unit>
        <trans-unit id="80e91a530ec3d2ff8b86717bc9074b128cbda6a4" translate="yes" xml:space="preserve">
          <source>A strange, ambiguous sentence &quot;or in some other implementation-defined manner&quot; has been introduced. This can either be interpreted as &quot;the parameters to &lt;code&gt;int main()&lt;/code&gt; may vary&quot; or as &quot;main can have any implementation-defined form&quot;.</source>
          <target state="translated">引入了一个奇怪的，模棱两可的句子&amp;ldquo;或以其他实现定义的方式&amp;rdquo;。 这可以解释为&amp;ldquo; &lt;code&gt;int main()&lt;/code&gt; 的参数可能有所不同&amp;rdquo;或&amp;ldquo; main可以具有任何实现定义的形式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2ca23b0779eeca695d782b5b96f1577207241984" translate="yes" xml:space="preserve">
          <source>ANSI X3.159-1989 2.1.2.1 Freestanding environment:</source>
          <target state="translated">ANSI X3.159-1989 2.1.2.1.1 独立式环境。</target>
        </trans-unit>
        <trans-unit id="57a7155ea831c7e0d4282c280f1bb112dfa1e288" translate="yes" xml:space="preserve">
          <source>ANSI X3.159-1989 2.1.2.2 Hosted environment. &quot;Program startup&quot;</source>
          <target state="translated">ANSI X3.159-1989 2.1.2.2.2 托管环境。&quot;程序启动&quot;</target>
        </trans-unit>
        <trans-unit id="24cf3c85b055a0c58ef221fc468e8f9b43b2c027" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md&quot;&gt;C++ Core Guidelines&lt;/a&gt; contains multiple instances of omitting &lt;code&gt;return 0;&lt;/code&gt; at the end of &lt;code&gt;main&lt;/code&gt; and no instances in which an explicit return is written.  Although there is not yet a specific guideline on this particular topic in that document, that seems at least a tacit endorsement of the practice.</source>
          <target state="translated">此外，《 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md&quot;&gt;C ++核心准则》还&lt;/a&gt;包含多个省略 &lt;code&gt;return 0;&lt;/code&gt; 实例； 在 &lt;code&gt;main&lt;/code&gt; 的末尾，并且没有写入显式返回的实例。 尽管在该文档中还没有关于该特定主题的特定指南，但这似乎至少是对该实践的默认支持。</target>
        </trans-unit>
        <trans-unit id="23e493e83a229c8a646ea40b97b496511adb8337" translate="yes" xml:space="preserve">
          <source>After the second line nothing is printed to the terminal since &quot;foo&quot; made grep return 1 and we check if the return code of grep was equal to 0. The second conditional statement echoes its message in the last line since it is true due to CHECK == 1.</source>
          <target state="translated">在第二行之后,由于 &quot;foo &quot;使grep返回1,我们检查grep的返回码是否等于0,第二条条件语句在最后一行中回传了它的信息,因为CHECK ===1,所以它是真。</target>
        </trans-unit>
        <trans-unit id="09933d4decfafb0faf055a060f94f61bcf140364" translate="yes" xml:space="preserve">
          <source>All versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit &lt;code&gt;return;&lt;/code&gt; statements at the end of a &lt;code&gt;void&lt;/code&gt; function.  Reasons against omitting seem to boil down to &lt;a href=&quot;https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015&quot;&gt;&quot;it looks weird&quot;&lt;/a&gt;.  If, like me, you're curious about the rationale for the change to the C standard &lt;a href=&quot;https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional&quot;&gt;read this question&lt;/a&gt;.  Also note that in the early 1990s this was considered &quot;sloppy practice&quot; because it was undefined behavior (although widely supported) at the time.</source>
          <target state="translated">此后，这两个标准的所有版本（C99和C ++ 98）都保持了相同的想法。 我们依靠C ++中自动生成的成员函数，很少有人编写显式的 &lt;code&gt;return;&lt;/code&gt; &lt;code&gt;void&lt;/code&gt; 函数末尾的语句。 反对省略的原因似乎可以归结为&lt;a href=&quot;https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015&quot;&gt;&amp;ldquo;看起来很奇怪&amp;rdquo;&lt;/a&gt; 。 如果像我一样，您对更改C标准的理由感到好奇，请&lt;a href=&quot;https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional&quot;&gt;阅读此问题&lt;/a&gt; 。 还应注意，在1990年代初，这被视为&amp;ldquo;草率做法&amp;rdquo;，因为当时它是不确定的行为（尽管得到广泛支持）。</target>
        </trans-unit>
        <trans-unit id="83ff694899e1d845ab60582f3b73ef06850d2d34" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;11&lt;/sup&gt;:</source>
          <target state="translated">允许的表格&lt;sup&gt;11&lt;/sup&gt; ：</target>
        </trans-unit>
        <trans-unit id="1ffdd2e9d11e5e754b0a9cf96f132585a0112b4d" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;1&lt;/sup&gt;:</source>
          <target state="translated">允许的形式&lt;sup&gt;1&lt;/sup&gt; ：</target>
        </trans-unit>
        <trans-unit id="531b9bfacbabbde3a9ef0944158dd8da7569c421" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;3&lt;/sup&gt;:</source>
          <target state="translated">允许的表格&lt;sup&gt;3&lt;/sup&gt; ：</target>
        </trans-unit>
        <trans-unit id="75815e021134ec0eba7ed2c0d9c5a844701da1d0" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;7&lt;/sup&gt;:</source>
          <target state="translated">允许的表格&lt;sup&gt;7&lt;/sup&gt; ：</target>
        </trans-unit>
        <trans-unit id="4679a6ba8a0d1ca4986d60983e12b4e750ecdae5" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;9&lt;/sup&gt;:</source>
          <target state="translated">允许的表格&lt;sup&gt;9&lt;/sup&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ce86355d96de776927a38cfc34a124933831922" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;wmain&lt;/code&gt; functions can be declared as returning &lt;code&gt;void&lt;/code&gt; (no return value). If you declare &lt;code&gt;main&lt;/code&gt; or &lt;code&gt;wmain&lt;/code&gt; as returning void, you cannot return an exit code to the parent process or operating system by using a return statement. To return an exit code when &lt;code&gt;main&lt;/code&gt; or &lt;code&gt;wmain&lt;/code&gt; is declared as &lt;code&gt;void&lt;/code&gt;, you must use the &lt;code&gt;exit&lt;/code&gt; function.</source>
          <target state="translated">或者，可以将 &lt;code&gt;main&lt;/code&gt; 和 &lt;code&gt;wmain&lt;/code&gt; 函数声明为返回 &lt;code&gt;void&lt;/code&gt; （无返回值）。 如果将 &lt;code&gt;main&lt;/code&gt; 或 &lt;code&gt;wmain&lt;/code&gt; 声明为返回void，则不能使用return语句将退出代码返回到父进程或操作系统。 要在 &lt;code&gt;main&lt;/code&gt; 或 &lt;code&gt;wmain&lt;/code&gt; 声明为 &lt;code&gt;void&lt;/code&gt; 时返回退出代码，必须使用 &lt;code&gt;exit&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="108ea3b40bdac1fa932e2881ce8b590bb80462aa" translate="yes" xml:space="preserve">
          <source>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall
  allow both</source>
          <target state="translated">实施者不得预先定义主函数。该函数不应该被超载。它的返回类型应该是int类型,但否则其类型是由实现定义的。所有的实现都应允许</target>
        </trans-unit>
        <trans-unit id="cceddadf6ec36d3e334ec1453776d68f0a30b419" translate="yes" xml:space="preserve">
          <source>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both of the following definitions of main:</source>
          <target state="translated">实施者不得预先定义主函数。该函数不应该被超载。它的返回类型应该是int类型的,否则它的类型是由实现定义的。所有的实现都应允许对main进行以下两种定义。</target>
        </trans-unit>
        <trans-unit id="abe62c12cbd384f011ace9ca713b8616f65c4574" translate="yes" xml:space="preserve">
          <source>Any form or name of main is allowed &lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">main的任何形式或名称都是允许的&lt;sup&gt;2&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="f259d290cdcbc9bbec44ad4bd545c173c869cb9a" translate="yes" xml:space="preserve">
          <source>Any form or name of main is allowed &lt;sup&gt;6&lt;/sup&gt;.</source>
          <target state="translated">主体的任何形式或名称都是允许的&lt;sup&gt;6&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2314c2dd97eecb4a3e772641c44c357495c2a73" translate="yes" xml:space="preserve">
          <source>Any form or name of main is allowed &lt;sup&gt;8&lt;/sup&gt;.</source>
          <target state="translated">主体的任何形式或名称都是允许的&lt;sup&gt;8&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef855fa906d52778c2fb1c45f521ea626f5689c2" translate="yes" xml:space="preserve">
          <source>As noted early on, the requirements above apply to hosted environments. If you are working with a freestanding environment (which is the alternative to a hosted environment), then the standard has much less to say. For a freestanding environment, the function called at program startup need not be called &lt;code&gt;main&lt;/code&gt; and there are no constraints on its return type.  The standard says:</source>
          <target state="translated">如前所述，以上要求适用于托管环境。 如果您使用的是独立式环境（这是托管环境的替代方案），那么该标准就没什么好说的了。 对于独立的环境，在程序启动时调用的函数不必称为 &lt;code&gt;main&lt;/code&gt; ,并且对其返回类型没有限制。 该标准说：</target>
        </trans-unit>
        <trans-unit id="6a69258566146688a6c3902485cea9ec71efe8ed" translate="yes" xml:space="preserve">
          <source>As you can see if you are calling this and that process it is sometimes essential to see what it has returned (by the return value of main()).</source>
          <target state="translated">因为你可以看到,如果你在调用这个和那个进程时,有时必须看它返回了什么(由main()的返回值)。</target>
        </trans-unit>
        <trans-unit id="e46f165c0590a92b13364a7c8042f058136f6322" translate="yes" xml:space="preserve">
          <source>C++ &amp;mdash; &lt;code&gt;int main(int argc, char **argv)&lt;/code&gt;</source>
          <target state="translated">C ++ &amp;mdash; &lt;code&gt;int main(int argc, char **argv)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76311ff27f1cf5e0babcefff7edb17a402c58861" translate="yes" xml:space="preserve">
          <source>C++ &amp;mdash; &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;</source>
          <target state="translated">C ++ &amp;mdash; &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d70b6b60e0f24927bc4538fb0ceb71184d06bef0" translate="yes" xml:space="preserve">
          <source>C99 removed &quot;implicit int&quot; so &lt;code&gt;main()&lt;/code&gt; is no longer valid.</source>
          <target state="translated">C99删除了&amp;ldquo;隐式int&amp;rdquo;，因此 &lt;code&gt;main()&lt;/code&gt; 不再有效。</target>
        </trans-unit>
        <trans-unit id="6c8395748074b451b2f55b5c5e4c263a6bbe2bef" translate="yes" xml:space="preserve">
          <source>Classically, Unix systems support a third variant:</source>
          <target state="translated">传统上,Unix系统支持第三种变体。</target>
        </trans-unit>
        <trans-unit id="e4ed7f96515dbdbe5f5d0ecace105efe68e6c3ec" translate="yes" xml:space="preserve">
          <source>Comments:</source>
          <target state="translated">Comments:</target>
        </trans-unit>
        <trans-unit id="cf3f840e63764cb35ea2eae778010a42f50e1375" translate="yes" xml:space="preserve">
          <source>Difference between &lt;code&gt;void main()&lt;/code&gt; and &lt;code&gt;int main()&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;void main()&lt;/code&gt; 和 &lt;code&gt;int main()&lt;/code&gt; 之间的区别？</target>
        </trans-unit>
        <trans-unit id="8dd79bfba982dc335f30bf0edc8ada5d88da4914" translate="yes" xml:space="preserve">
          <source>Efficiency is not an issue with the &lt;code&gt;main&lt;/code&gt; function. It can only be entered and left once (marking the program's start and termination) according to the C++ standard. For C, re-entering &lt;code&gt;main()&lt;/code&gt; is allowed, but should be avoided.</source>
          <target state="translated">效率不是 &lt;code&gt;main&lt;/code&gt; 功能的问题。 根据C ++标准，它只能输入和保留一次（标记程序的开始和终止）。 对于C，允许重新输入 &lt;code&gt;main()&lt;/code&gt; ，但应避免输入。</target>
        </trans-unit>
        <trans-unit id="3fd215cf12ba7569beb5b6db1ee04c9f3d5989a2" translate="yes" xml:space="preserve">
          <source>Finally, there is nothing wrong from a standards point of view with calling &lt;code&gt;main()&lt;/code&gt; from a program.</source>
          <target state="translated">最后，从标准的角度来看，从程序中调用 &lt;code&gt;main()&lt;/code&gt; 并没有错。</target>
        </trans-unit>
        <trans-unit id="62b8c7d7dfd45c5f3d50a3d0e74887793a303162" translate="yes" xml:space="preserve">
          <source>For C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:</source>
          <target state="translated">对于C++,从1998年的第一个标准开始;见ISOIEC 14882:1998的3.6.1节。</target>
        </trans-unit>
        <trans-unit id="3500093e0edf7d6f4a566c3f4b7efdebecf64c37" translate="yes" xml:space="preserve">
          <source>For C99, everything is the same as above except:</source>
          <target state="translated">对于C99来说,一切同上,除了。</target>
        </trans-unit>
        <trans-unit id="fc184e779fe2b354b692cb83c96360ac6578836a" translate="yes" xml:space="preserve">
          <source>For a hosted environment (that's the normal one), the C11 standard (ISO/IEC 9899:2011) says:</source>
          <target state="translated">对于托管环境(这就是正常的环境),C11标准(ISOIEC 9899:2011)说。</target>
        </trans-unit>
        <trans-unit id="2c578db723c70cb97ef0753314ddb79e6ca46de7" translate="yes" xml:space="preserve">
          <source>Here is a small demonstration of the usage of return codes...</source>
          <target state="translated">下面是小编为大家演示一下返回码的使用方法.....</target>
        </trans-unit>
        <trans-unit id="d082866f80f3c7b776d5b28ecd6c0bcbdc809faf" translate="yes" xml:space="preserve">
          <source>However I usually return 0.</source>
          <target state="translated">然而,我通常返回0。</target>
        </trans-unit>
        <trans-unit id="bcc235a17e919b6165ee1c9df15ea0527e83ab84" translate="yes" xml:space="preserve">
          <source>However, to allow completely wild forms of &lt;code&gt;main()&lt;/code&gt; was probably(?) not the intention of this new sentence. The C99 rationale (not normative) implies that the sentence refers to additional parameters to &lt;code&gt;int main&lt;/code&gt;&lt;sup&gt;4&lt;/sup&gt;.</source>
          <target state="translated">但是，允许 &lt;code&gt;main()&lt;/code&gt; 的完全野生形式可能不是此新句子的意图。 C99基本原理（非规范性）意味着该句子引用了 &lt;code&gt;int main&lt;/code&gt; &lt;sup&gt;4的&lt;/sup&gt;附加参数。</target>
        </trans-unit>
        <trans-unit id="d1b1ad3f3ac01aeb1f1aa57b42231bc5e931e4f0" translate="yes" xml:space="preserve">
          <source>I believe that &lt;code&gt;main()&lt;/code&gt; should return either &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; or &lt;code&gt;EXIT_FAILURE&lt;/code&gt;. They are defined in &lt;code&gt;stdlib.h&lt;/code&gt;</source>
          <target state="translated">我相信 &lt;code&gt;main()&lt;/code&gt; 应该返回 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 或 &lt;code&gt;EXIT_FAILURE&lt;/code&gt; 。 它们在 &lt;code&gt;stdlib.h&lt;/code&gt; 中定义</target>
        </trans-unit>
        <trans-unit id="2c8ab38f22cccd2931145ee6336eedf191f6b30f" translate="yes" xml:space="preserve">
          <source>I was under the impression that standard specifies that main doesn't need a return value as a successful return was OS based (zero in one could be either a success or a failure in another), therefore the absence of return was a cue for the compiler to insert the successful return itself.</source>
          <target state="translated">在我的印象中,标准规定main不需要返回值,因为成功的返回是基于操作系统的(其中的0可能是成功的,也可能是失败的),所以没有返回值是提示编译器插入成功的返回本身。</target>
        </trans-unit>
        <trans-unit id="4fb16fcf1d38904d79af7bbdd1699672a66ac59e" translate="yes" xml:space="preserve">
          <source>ISO 14882:2003 3.6.1 Main function</source>
          <target state="translated">ISO 14882:2003 3.6.1 主要功能</target>
        </trans-unit>
        <trans-unit id="6fcc9ab167f456cff52beb58f8604705b44e2080" translate="yes" xml:space="preserve">
          <source>ISO 14882:2011 3.6.1 Main function</source>
          <target state="translated">ISO 14882:2011 3.6.1 主要功能</target>
        </trans-unit>
        <trans-unit id="072f40f89924efb24c9c0d91ec69c1b477accc60" translate="yes" xml:space="preserve">
          <source>ISO 9899:1999 5.1.2.1 Freestanding environment</source>
          <target state="translated">ISO 9899:1999 5.1.2.1 独立环境</target>
        </trans-unit>
        <trans-unit id="6cb748bf92ce81daeb76259fcdc696d6d4a84f98" translate="yes" xml:space="preserve">
          <source>ISO 9899:1999 5.1.2.2 Hosted environment -&amp;gt; 5.1.2.2.1 Program startup</source>
          <target state="translated">ISO 9899：1999 5.1.2.2托管环境-&amp;gt; 5.1.2.2.1程序启动</target>
        </trans-unit>
        <trans-unit id="c570e7967aeae8d218c9500d8af0ccbb2c0999ed" translate="yes" xml:space="preserve">
          <source>ISO 9899:1999 5.1.2.2 Hosted environment --&amp;gt; 5.1.2.2.3 Program termination</source>
          <target state="translated">ISO 9899：1999 5.1.2.2托管环境-&amp;gt; 5.1.2.2.3程序终止</target>
        </trans-unit>
        <trans-unit id="5adf9fbb580920fe4e8bdb0b93849057aa5eaef0" translate="yes" xml:space="preserve">
          <source>ISO 9899:2011 5.1.2.2 Hosted environment -&amp;gt; 5.1.2.2.1 Program startup</source>
          <target state="translated">ISO 9899：2011 5.1.2.2托管环境-&amp;gt; 5.1.2.2.1程序启动</target>
        </trans-unit>
        <trans-unit id="c026b51c24ee5003420193d6a1c30eba041e8812" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1989 (C90):</source>
          <target state="translated">ISOIEC 9899:1989(C90)。</target>
        </trans-unit>
        <trans-unit id="7738b221c80b5304b0ca9410b351937992dbdba2" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (C99):</source>
          <target state="translated">ISOIEC 9899:1999(C99)。</target>
        </trans-unit>
        <trans-unit id="0dff1e972d7a65190eb694ffe563008167981bd6" translate="yes" xml:space="preserve">
          <source>If an implementation permits it, &lt;code&gt;main()&lt;/code&gt; can be declared in other ways, but this makes the program implementation defined, and no longer strictly conforming.</source>
          <target state="translated">如果实现允许，则可以通过其他方式声明 &lt;code&gt;main()&lt;/code&gt; ，但这使程序实现已定义，并且不再严格遵循。</target>
        </trans-unit>
        <trans-unit id="36650763e12f75f89b51f84868ae093852daf601" translate="yes" xml:space="preserve">
          <source>If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;</source>
          <target state="translated">如果控件到达main的末尾,没有遇到返回语句,那么效果就是执行返回0。</target>
        </trans-unit>
        <trans-unit id="f306c8b2bb84020137c0b44d4df475b5a3dfaf8b" translate="yes" xml:space="preserve">
          <source>If int main() then return 1 or return 0?</source>
          <target state="translated">如果int main()则返回1或返回0?</target>
        </trans-unit>
        <trans-unit id="bbe13bc0ccc90c42b104135b14e3c3f18c8e40da" translate="yes" xml:space="preserve">
          <source>If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;11) reaching the &lt;code&gt;}&lt;/code&gt; that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified.</source>
          <target state="translated">如果主函数的返回类型是与int兼容的类型，则从初始调用到主函数的返回等同于以主函数返回的值作为其参数来调用退出函数； 11）到达 &lt;code&gt;}&lt;/code&gt; 终止时，主函数返回的值为0。如果返回类型与int不兼容，则未指定返回到主机环境的终止状态。</target>
        </trans-unit>
        <trans-unit id="80d38b087bcd0bf8f8ae646ae8cfc61a04ed675e" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the array members &lt;code&gt;argv[0]&lt;/code&gt; through
  &lt;code&gt;argv[argc-1]&lt;/code&gt; inclusive shall contain pointers to strings, which are given
  implementation-defined values by the host environment prior to program startup. The
  intent is to supply to the program information determined prior to program startup
  from elsewhere in the hosted environment. If the host environment is not capable of
  supplying strings with letters in both uppercase and lowercase, the implementation
  shall ensure that the strings are received in lowercase.</source>
          <target state="translated">如果 &lt;code&gt;argc&lt;/code&gt; 的值大于零，则数组成员 &lt;code&gt;argv[0]&lt;/code&gt; 至 &lt;code&gt;argv[argc-1]&lt;/code&gt; 包含在内）应包含指向字符串的指针，主机环境在程序启动之前将其指定为实现定义的值。 目的是从宿主环境中的其他位置向程序提供在程序启动之前确定的信息。 如果主机环境不能提供带有大写和小写字母的字符串，则实现应确保以小写形式接收字符串。</target>
        </trans-unit>
        <trans-unit id="5477192590999db427c7b99a724d15f14138992a" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the string pointed to by &lt;code&gt;argv[0]&lt;/code&gt;
  represents the program name; &lt;code&gt;argv[0][0]&lt;/code&gt; shall be the null character if the
  program name is not available from the host environment. If the value of &lt;code&gt;argc&lt;/code&gt; is
  greater than one, the strings pointed to by &lt;code&gt;argv[1]&lt;/code&gt; through &lt;code&gt;argv[argc-1]&lt;/code&gt;
  represent the program parameters.</source>
          <target state="translated">如果 &lt;code&gt;argc&lt;/code&gt; 的值大于零，则 &lt;code&gt;argv[0]&lt;/code&gt; 指向的字符串表示程序名称； 如果程序名称在主机环境中不可用，则 &lt;code&gt;argv[0][0]&lt;/code&gt; 为空字符。 如果 &lt;code&gt;argc&lt;/code&gt; 的值大于1，则 &lt;code&gt;argv[1]&lt;/code&gt; 到 &lt;code&gt;argv[argc-1]&lt;/code&gt; 指向的字符串代表程序参数。</target>
        </trans-unit>
        <trans-unit id="83b323b3be8c3ef77aecb667889dc3dd68d116df" translate="yes" xml:space="preserve">
          <source>If they are declared, the parameters to the main function shall obey the following
  constraints:</source>
          <target state="translated">如果声明了它们,主函数的参数应服从以下约束:</target>
        </trans-unit>
        <trans-unit id="d1a5b964a486551cab1f4315aeb05a3560a45f00" translate="yes" xml:space="preserve">
          <source>If you are doing this (call a process so many times), you should find a way to put your logic directly inside the caller, or in a DLL file, without allocate a specific process for each call; the multiple process allocations bring you the relevant efficiency problem in this case.</source>
          <target state="translated">如果你是这样做的(调用一个进程这么多次),你应该想办法把你的逻辑直接放在调用器里面,或者在DLL文件中,而不为每个调用分配一个特定的进程;多进程分配给你带来的是这种情况下的相关效率问题。</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">如果你做了</target>
        </trans-unit>
        <trans-unit id="483a23176183f6c1305e90f13f59c790a7cd8b33" translate="yes" xml:space="preserve">
          <source>If you do not write a return statement in &lt;code&gt;int main()&lt;/code&gt;, the closing &lt;code&gt;{&lt;/code&gt; will return 0 by default.</source>
          <target state="translated">如果您未在 &lt;code&gt;int main()&lt;/code&gt; 中编写return语句，则闭包 &lt;code&gt;{&lt;/code&gt; 将默认返回0。</target>
        </trans-unit>
        <trans-unit id="850185e652bcc3094867daff9db6c1960eaf3346" translate="yes" xml:space="preserve">
          <source>If you really have issues related to efficiency of returning an integer from a process, you should probably avoid to call that process so many times that this return value becomes an issue.</source>
          <target state="translated">如果你真的有关于从一个进程返回一个整数的效率问题,你可能应该避免多次调用那个进程,以至于这个返回值成为一个问题。</target>
        </trans-unit>
        <trans-unit id="52092fcdfb7b4fbe87c5392e56ec14ab62dfac60" translate="yes" xml:space="preserve">
          <source>In C89 (and hence in Microsoft C), there is no statement about what happens if the &lt;code&gt;main()&lt;/code&gt; function returns but does not specify a return value; it therefore leads to undefined behaviour.</source>
          <target state="translated">在C89中（因此在Microsoft C中），没有声明有关 &lt;code&gt;main()&lt;/code&gt; 函数返回但未指定返回值的情况； 因此，它导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="c87cc4b10f829842d58cbb57cfa34ee20cb520f0" translate="yes" xml:space="preserve">
          <source>In Unix and DOS scripting, &lt;code&gt;return 0&lt;/code&gt; on success and non-zero for error are usually returned. This is the standard used by Unix and DOS scripting to find out what happened with your program and controlling the whole flow.</source>
          <target state="translated">在Unix和DOS脚本中，成功 &lt;code&gt;return 0&lt;/code&gt; ，错误返回非零。 这是Unix和DOS脚本编写所使用的标准，用于查明程序发生了什么并控制整个流程。</target>
        </trans-unit>
        <trans-unit id="8eaed3f6bd24cf0c2bf1a5f18894bccff46da0ac" translate="yes" xml:space="preserve">
          <source>In a freestanding environment (in which C program execution may take
  place without any benefit of an operating system), the name and type
  of the function called at program startup are implementation-defined.</source>
          <target state="translated">在一个独立的环境中(在这个环境中,C语言程序的执行可以在没有操作系统的情况下进行),程序启动时调用的函数的名称和类型是由实现定义的。</target>
        </trans-unit>
        <trans-unit id="e8f9653053b16c99b1cfc10e334bf69a6adf9d71" translate="yes" xml:space="preserve">
          <source>In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined. Any library facilities available to a freestanding program, other than the minimal set required by clause 4, are implementation-defined.</source>
          <target state="translated">在一个独立的环境中(在这个环境中,C语言程序的执行可以在没有操作系统的情况下进行),程序启动时调用的函数的名称和类型是由实现定义的。除了第4条所要求的最小值以外,任何可供独立程序使用的库设施,都是由实现定义的。</target>
        </trans-unit>
        <trans-unit id="7e3919889d260828538ebba4f914ae5c8021bc7c" translate="yes" xml:space="preserve">
          <source>In detail, if you only want to know if returning 0 is more or less efficient than returning 1, it could depend from the compiler in some cases, but generically, assuming they are read from the same source (local, field, constant, embedded in the code, function result, etc.) it requires exactly the same number of clock cycles.</source>
          <target state="translated">详细来说,如果你只想知道返回0比返回1的效率更高或更低,在某些情况下可能取决于编译器,但一般来说,假设它们是从同一个源(局部、字段、常量、嵌入代码中的常量、函数结果等)读取的,所需要的时钟周期数完全相同。</target>
        </trans-unit>
        <trans-unit id="77bca36b5e136be0307abf4a901e487488fb4541" translate="yes" xml:space="preserve">
          <source>In the latter form &lt;code&gt;argc&lt;/code&gt; shall be the number of arguments passed to the program from the environment
  in which the program is run. If &lt;code&gt;argc&lt;/code&gt; is nonzero these arguments shall be supplied in &lt;code&gt;argv[0]&lt;/code&gt;
  through &lt;code&gt;argv[argc-1]&lt;/code&gt; as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and &lt;code&gt;argv[0]&lt;/code&gt; shall be the pointer to the initial character of a NTMBS that represents the
  name used to invoke the program or &lt;code&gt;&quot;&quot;&lt;/code&gt;. The value of &lt;code&gt;argc&lt;/code&gt; shall be non-negative. The value of &lt;code&gt;argv[argc]&lt;/code&gt;
  shall be 0. [ Note: It is recommended that any further (optional) parameters be added after &lt;code&gt;argv&lt;/code&gt;. &amp;mdash;end
  note ]</source>
          <target state="translated">在后一种形式中， &lt;code&gt;argc&lt;/code&gt; 是从运行程序的环境传递到程序的参数数量。 如果 &lt;code&gt;argc&lt;/code&gt; 为非零，则这些参数必须通过 &lt;code&gt;argv[argc-1]&lt;/code&gt; 在 &lt;code&gt;argv[0]&lt;/code&gt; 提供，以指针指向以空值结尾的多字节字符串（NTMBS）（17.5.2.1.4.2）的初始字符，而 &lt;code&gt;argv[0]&lt;/code&gt; 为指向NTMBS初始字符的指针，代表用于调用程序的名称或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。 &lt;code&gt;argc&lt;/code&gt; 的值应为非负数。 &lt;code&gt;argv[argc]&lt;/code&gt; 的值应为0。[注意：建议在 &lt;code&gt;argv&lt;/code&gt; 之后添加任何其他（可选）参数。 &amp;mdash;尾注]</target>
        </trans-unit>
        <trans-unit id="edd6065f0058ea6d8f4719347b7def37199e2a44" translate="yes" xml:space="preserve">
          <source>Interestingly, MS does not prescribe the two-argument version of &lt;code&gt;main()&lt;/code&gt; that the C and C++ standards require. It only prescribes a three argument form where the third argument is &lt;code&gt;char **envp&lt;/code&gt;, a pointer to a list of environment variables.</source>
          <target state="translated">有趣的是，MS没有规定C和C ++标准要求的 &lt;code&gt;main()&lt;/code&gt; 的两个参数版本。 它仅规定了三个参数形式，其中第三个参数是 &lt;code&gt;char **envp&lt;/code&gt; ，它是指向环境变量列表的指针。</target>
        </trans-unit>
        <trans-unit id="067bd54d24cbf0d635c159524fc85653cf8d1376" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;char *envp[]&lt;/code&gt; as a third argument to &lt;code&gt;main()&lt;/code&gt; portable?</source>
          <target state="translated">&lt;code&gt;char *envp[]&lt;/code&gt; 作为 &lt;code&gt;main()&lt;/code&gt; 的第三个参数是否可移植？</target>
        </trans-unit>
        <trans-unit id="01cfa03c02ebf6b8044d17ebc260a7a7e23f1bc7" translate="yes" xml:space="preserve">
          <source>It also can be checked when you call a process yourself, and see if the program exited and finished properly.</source>
          <target state="translated">也可以在自己调用程序的时候检查一下,看看程序是否正常退出并完成。</target>
        </trans-unit>
        <trans-unit id="743cc09a1d17dd8e6d9ef3423b452c2f4c20a21e" translate="yes" xml:space="preserve">
          <source>It is also worth noting that in C++, &lt;code&gt;int main()&lt;/code&gt; can be left without a return-statement, at which point it defaults to returning 0. This is also true with a C99 program. Whether &lt;code&gt;return 0;&lt;/code&gt; should be omitted or not is open to debate. The range of valid C program main signatures is much greater.</source>
          <target state="translated">还值得注意的是，在C ++中，可以将 &lt;code&gt;int main()&lt;/code&gt; 保留为不带返回语句，此时它默认返回值为0。C99程序也是如此。 是否 &lt;code&gt;return 0;&lt;/code&gt; 是否应省略还是值得商debate。 有效的C程序主签名的范围要大得多。</target>
        </trans-unit>
        <trans-unit id="eba4f3e259ceb0adf19ace0c32c1391d84cbfe54" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether a program in a freestanding environment is required to define a main function.</source>
          <target state="translated">它是由实现来定义的,是否需要在独立环境中的程序定义一个主函数。</target>
        </trans-unit>
        <trans-unit id="3d63d53707bc8469db68ce1f74c203b133e06b93" translate="yes" xml:space="preserve">
          <source>It is not clear to me what happens (what exit code is returned to the parent or OS) when a program with &lt;code&gt;void main()&lt;/code&gt; does exit &amp;mdash; and the MS web site is silent too.</source>
          <target state="translated">对我来说，尚不清楚当具有 &lt;code&gt;void main()&lt;/code&gt; 的程序确实退出时会发生什么（退出代码返回给父级或OS）&amp;mdash;并且MS网站也保持沉默。</target>
        </trans-unit>
        <trans-unit id="d1b1f744a8f0f327fd7f8ac8646e483671c5281c" translate="yes" xml:space="preserve">
          <source>It is noticeable that the only header required of a freestanding environment that actually defines any functions is &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; (and even those may be &amp;mdash; and often are &amp;mdash; just macros).</source>
          <target state="translated">值得注意的是，实际上定义任何功能的独立式环境所需的唯一标头是 &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; （甚至那些可能是-而且经常是-只是宏）。</target>
        </trans-unit>
        <trans-unit id="f0d85260bc0a36b034db5734d9715240a02623e7" translate="yes" xml:space="preserve">
          <source>It's &lt;strong&gt;NOT&lt;/strong&gt; just a programming convention.</source>
          <target state="translated">这不仅仅是编程约定。</target>
        </trans-unit>
        <trans-unit id="777237599abc671bc567b78dd552b08e24fe0ff7" translate="yes" xml:space="preserve">
          <source>It's not what &lt;em&gt;should&lt;/em&gt;&lt;code&gt;main()&lt;/code&gt; return, it's what &lt;em&gt;does&lt;/em&gt;&lt;code&gt;main()&lt;/code&gt; return.  &lt;code&gt;main()&lt;/code&gt; is, of course, a function that someone else calls.  You don't have any control over the code that calls &lt;code&gt;main()&lt;/code&gt;.  Therefore, you must declare &lt;code&gt;main()&lt;/code&gt; with a type-correct signature to match its caller.  You simply don't have any choice in the matter.  You don't have to ask yourself what's more or less efficient, or what's better or worse style, or anything like that, because the answer is already perfectly well defined, for you, by the C and C+ standards.  Just follow them.</source>
          <target state="translated">它不是 &lt;code&gt;main()&lt;/code&gt; 返回的内容， &lt;em&gt;而是&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; 返回的内容。 &lt;code&gt;main()&lt;/code&gt; 当然是其他人调用的函数。 您对调用 &lt;code&gt;main()&lt;/code&gt; 的代码没有任何控制。 因此，必须使用正确类型的签名声明 &lt;code&gt;main()&lt;/code&gt; 才能匹配其调用者。 您在这件事上别无选择。 您不必问自己什么是效率更高或更低，风格更好或更差的东西，诸如此类，因为答案已经完全按照C和C +标准为您定义了。 只要跟随他们。</target>
        </trans-unit>
        <trans-unit id="ceda7d6ce3400641cfc2d2b305e73a181d717c83" translate="yes" xml:space="preserve">
          <source>J.5.1 Environment arguments</source>
          <target state="translated">J.5.1 环境论证</target>
        </trans-unit>
        <trans-unit id="4646a05e59e1cdcc72d17eecf0ad0e9d72001305" translate="yes" xml:space="preserve">
          <source>Just as the C standard recognizes both hosted and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC 14882:2011.)</source>
          <target state="translated">正如C标准承认托管环境和独立环境一样,C++标准也是如此。(引自ISOIEC 14882:2011)。</target>
        </trans-unit>
        <trans-unit id="1cf33a289910a38b27ccf6fc406b6febbdf1f1a7" translate="yes" xml:space="preserve">
          <source>Keep in mind that,even though you're returning an int, some OSes (Windows) truncate the returned value to a single byte (0-255).</source>
          <target state="translated">请记住,即使你返回的是一个int,有些操作系统(Windows)会将返回的值截断为一个字节(0-255)。</target>
        </trans-unit>
        <trans-unit id="52e3d5ebdbc06938d8f3e9175e5789910e8284cc" translate="yes" xml:space="preserve">
          <source>Legal definitions of &lt;code&gt;main()&lt;/code&gt; in C++14?</source>
          <target state="translated">C ++ 14中 &lt;code&gt;main()&lt;/code&gt; 的法律定义？</target>
        </trans-unit>
        <trans-unit id="82be7a55804dc08de0168f6f592f149c8a430e44" translate="yes" xml:space="preserve">
          <source>Microsoft C</source>
          <target state="translated">微软C</target>
        </trans-unit>
        <trans-unit id="73d9e90f1eeed7db4c1746200a40ba2e4ac70074" translate="yes" xml:space="preserve">
          <source>Must the &lt;code&gt;int main()&lt;/code&gt; function return a value in all compilers?</source>
          <target state="translated">&lt;code&gt;int main()&lt;/code&gt; 函数是否必须在所有编译器中返回一个值？</target>
        </trans-unit>
        <trans-unit id="2e35d4f77f18bcad3aefd139f948af15aa758b72" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;0&lt;/code&gt; is mandated as 'success'. You can use &lt;code&gt;EXIT_FAILURE&lt;/code&gt; and &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; from &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; if you prefer, but 0 is well established, and so is 1. See also &lt;a href=&quot;https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/&quot;&gt;Exit codes greater than 255 &amp;mdash; possible?&lt;/a&gt;.</source>
          <target state="translated">请注意，将 &lt;code&gt;0&lt;/code&gt; 强制为&amp;ldquo;成功&amp;rdquo;。 如果愿意，可以使用 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;EXIT_FAILURE&lt;/code&gt; 和 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; ，但是0已很好建立，1也是如此。另请参见&lt;a href=&quot;https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/&quot;&gt;大于255的退出代码-可能吗？&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc19499ce0cd6befeb6d4ac0455d6a31e63efae2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;int main()&lt;/code&gt; was never listed as a valid form for any hosted implementation of C in any of the above versions. In C, unlike C++, &lt;code&gt;()&lt;/code&gt; and &lt;code&gt;(void)&lt;/code&gt; have different meanings. The former is an obsolescent feature which may be removed from the language. See C11 future language directions:</source>
          <target state="translated">请注意，对于以上任何版本的C的任何托管实现，都不 &lt;code&gt;int main()&lt;/code&gt; 列为有效形式。 在C中，与C ++不同， &lt;code&gt;()&lt;/code&gt; 和 &lt;code&gt;(void)&lt;/code&gt; 具有不同的含义。 前者是一种过时的功能，可以从语言中删除。 请参阅C11将来的语言说明：</target>
        </trans-unit>
        <trans-unit id="2a43cb795cc790685cb419ee571a160ade1ccb63" translate="yes" xml:space="preserve">
          <source>Note that the C and C++ standards define two kinds of implementations: freestanding and hosted.</source>
          <target state="translated">请注意,C和C++标准定义了两种实现:独立式和托管式。</target>
        </trans-unit>
        <trans-unit id="99eaa646b7b6e0082dbd4a6adae2c494f9eec0c8" translate="yes" xml:space="preserve">
          <source>Note the empty parenthesis in the first form. C++ and C are different in this case, because in C++ this means that the function takes no parameters. But in C it means that it may take any parameter.</source>
          <target state="translated">注意第一种形式中的空括号。在这种情况下,C++和C语言是不同的,因为在C++中,这意味着函数不接受任何参数。但在C语言中,这意味着它可以接受任何参数。</target>
        </trans-unit>
        <trans-unit id="546cad710ccd581eadc450a0c74833e5bcaa545e" translate="yes" xml:space="preserve">
          <source>Now the following bash script (simply type it in a Linux terminal) although very basic should give some idea of error handling:</source>
          <target state="translated">下面的bash脚本(只需在Linux终端中键入即可),虽然很基本,但应该能让人对错误处理有一定的了解。</target>
        </trans-unit>
        <trans-unit id="bb080a0718df6542d4433b03a9323560b055bb4d" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;return 0&lt;/code&gt;</source>
          <target state="translated">忽略 &lt;code&gt;return 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71453973d6cd4b7d6dce02765e1aeb2c794927d7" translate="yes" xml:space="preserve">
          <source>Or equivalent. For example, &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt; is equivalent to the second one. Further, the &lt;code&gt;int&lt;/code&gt; return type can be omitted as it is a default.</source>
          <target state="translated">或同等学历。 例如， &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt; 等效于第二个。 此外，可以将 &lt;code&gt;int&lt;/code&gt; 返回类型省略，因为它是默认值。</target>
        </trans-unit>
        <trans-unit id="1b4a599777a8efd1033fda40d60a3ac6da68728f" translate="yes" xml:space="preserve">
          <source>Program termination in C99 or C11</source>
          <target state="translated">C99或C11中的程序终止</target>
        </trans-unit>
        <trans-unit id="663f993e9b4f3d44ef4c0329debae8aeebbf12e3" translate="yes" xml:space="preserve">
          <source>Rationale for International Standard &amp;mdash; Programming Languages &amp;mdash; C, Revision 5.10. 5.1.2.2 Hosted environment --&amp;gt; 5.1.2.2.1 Program startup</source>
          <target state="translated">国际标准的理由-编程语言-C，修订版5.10。 5.1.2.2托管环境-&amp;gt; 5.1.2.2.1程序启动</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="06951cda41c4c25e07384cc2d791df8051ddc4f0" translate="yes" xml:space="preserve">
          <source>Return 0 on success and non-zero for error. This is the standard used by UNIX and DOS scripting to find out what happened with your program.</source>
          <target state="translated">成功时返回0,错误时返回非零。这是UNIX和DOS脚本的标准,用于查找你的程序发生了什么。</target>
        </trans-unit>
        <trans-unit id="c25bf9ecf87e37204aff4b7cbc681350ca825d5e" translate="yes" xml:space="preserve">
          <source>Return type of &lt;code&gt;main()&lt;/code&gt; method in C</source>
          <target state="translated">C语言中 &lt;code&gt;main()&lt;/code&gt; 方法的返回类型</target>
        </trans-unit>
        <trans-unit id="3675c5cbc8a91d96194988edd341f2880e76b8d4" translate="yes" xml:space="preserve">
          <source>Return value 0 usually means OK in most operating systems (the ones I can think of anyway).</source>
          <target state="translated">在大多数操作系统中,返回值为0通常意味着OK(反正我可以想到的)。</target>
        </trans-unit>
        <trans-unit id="7e87f801e2a286959cf6dbceaaf5200c563638ca" translate="yes" xml:space="preserve">
          <source>Returning 0 should tell the programmer that the program has successfully finished the job.</source>
          <target state="translated">返回0应该告诉程序员,程序已成功完成任务。</target>
        </trans-unit>
        <trans-unit id="d0d3720869171e755af6d0b0e9c8fa9c47bded55" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/q/8626109/775964&quot;&gt;How can I get what my main function has returned?&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://stackoverflow.com/q/8626109/775964&quot;&gt;如何获取主要函数返回的内容？&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="58c7663db54efd33586550979f6f35585936911c" translate="yes" xml:space="preserve">
          <source>Since grep failed to match the token &quot;foo&quot; with the content of our file the return code is 1 (this is the usual case when a failure occurs but as stated above you have plenty of values to choose from).</source>
          <target state="translated">由于grep未能将令牌 &quot;foo &quot;与文件的内容匹配,所以返回代码为1(这是失败时的通常情况,但如上所述,你有很多值可以选择)。</target>
        </trans-unit>
        <trans-unit id="58e729ae862197d2b4b8edf3be6c045cd942acef" translate="yes" xml:space="preserve">
          <source>So I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you'll know that it's explicitly supported by the standard and you'll know what it means.</source>
          <target state="translated">所以我主张省略它;其他人不同意(往往是坚决不同意!),无论如何,如果你遇到省略它的代码,你就会知道它是标准明确支持的,你就会知道它的含义。</target>
        </trans-unit>
        <trans-unit id="191c9d7581d1bc67cbc4954e3995712f84c74941" translate="yes" xml:space="preserve">
          <source>Some compilers have chosen to interpret the standard in the latter way. Arguably, one cannot easily state that they are not strictly conforming by citing the standard in itself, since it is is ambiguous.</source>
          <target state="translated">一些编译者选择了后一种方式来解释该标准。可以说,人们不能轻易地通过引用标准本身就说自己不严格遵守,因为它是模棱两可的。</target>
        </trans-unit>
        <trans-unit id="f98b7a7fbe66aa30604d46c9c186df5e7d476f7a" translate="yes" xml:space="preserve">
          <source>Standard C &amp;mdash; Common Extension</source>
          <target state="translated">标准C &amp;mdash;通用扩展</target>
        </trans-unit>
        <trans-unit id="559fce21984836e0b4c09f404ccadb796a238608" translate="yes" xml:space="preserve">
          <source>Standard C &amp;mdash; Freestanding Environment</source>
          <target state="translated">标准C-独立环境</target>
        </trans-unit>
        <trans-unit id="bf0058befe2fe0784752a61367cd774b2170e902" translate="yes" xml:space="preserve">
          <source>Standard C &amp;mdash; Hosted Environment</source>
          <target state="translated">标准C &amp;mdash;托管环境</target>
        </trans-unit>
        <trans-unit id="ead9983c448c82a4bc2e4fa329267dd58510e74c" translate="yes" xml:space="preserve">
          <source>Standard C++ &amp;mdash; Freestanding Environment</source>
          <target state="translated">标准C ++ &amp;mdash;独立环境</target>
        </trans-unit>
        <trans-unit id="17c880ba258c61c1f081e4f92072401258328c3f" translate="yes" xml:space="preserve">
          <source>Standard C++ &amp;mdash; Hosted Environment</source>
          <target state="translated">标准C ++ &amp;mdash;托管环境</target>
        </trans-unit>
        <trans-unit id="9e9bfc97678e1deb8fecca963cb28baa3742ac8f" translate="yes" xml:space="preserve">
          <source>Styles of &lt;code&gt;main()&lt;/code&gt; functions in C</source>
          <target state="translated">C语言中 &lt;code&gt;main()&lt;/code&gt; 函数的样式</target>
        </trans-unit>
        <trans-unit id="c32251a4dd807171928d97ccdcdf5412b6e1b584" translate="yes" xml:space="preserve">
          <source>Table 16 &amp;mdash; C++ headers for freestanding implementations</source>
          <target state="translated">表16 &amp;mdash;独立实现的C ++标头</target>
        </trans-unit>
        <trans-unit id="0b88a0ea077a1c835e53dcb3e5afe37a4a6880f1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx&quot;&gt;Microsoft VS 2010&lt;/a&gt; compiler is interesting. The web site says:</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx&quot;&gt;Microsoft VS 2010&lt;/a&gt;编译器很有趣。 该网站说：</target>
        </trans-unit>
        <trans-unit id="8364d6bdc8c6440426e1ae40049191ae42429996" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; return type may not be omitted.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 返回类型不能省略。</target>
        </trans-unit>
        <trans-unit id="1cf16e3e7d80a6df169adb6cfe5d5a70bd761eb9" translate="yes" xml:space="preserve">
          <source>The C++ standard explicitly says &quot;It [the main function] shall have a return type of type &lt;code&gt;int&lt;/code&gt;, but otherwise its type is implementation defined&quot;, and requires the same two signatures as the C standard to be supported as options. So a 'void main()' is directly not allowed by the C++ standard, though there's nothing it can do to stop a non-standard implementation allowing alternatives.  Note that C++ forbids the user from calling &lt;code&gt;main&lt;/code&gt; (but the C standard does not).</source>
          <target state="translated">C ++标准明确表示&amp;ldquo; [[主函数]应该具有 &lt;code&gt;int&lt;/code&gt; 类型的返回类型，但否则其类型是实现定义的&amp;rdquo;，并且需要与C标准相同的两个签名作为支持选项。 因此，C ++标准直接不允许使用&amp;ldquo; void main（）&amp;rdquo;，尽管它无法停止允许替代方法的非标准实现。 请注意，C ++禁止用户调用 &lt;code&gt;main&lt;/code&gt; （但C标准不这样做）。</target>
        </trans-unit>
        <trans-unit id="8ffaebd7ec7fa463926f599cf1254982eb713376" translate="yes" xml:space="preserve">
          <source>The C++11 standard (ISO/IEC 14882:2011) says:</source>
          <target state="translated">C++11标准(ISOIEC 14882:2011)说。</target>
        </trans-unit>
        <trans-unit id="4a496911a1450193efc097e191321a84e102d3d2" translate="yes" xml:space="preserve">
          <source>The Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2005&lt;/a&gt; version of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx&quot;&gt;this page&lt;/a&gt; does not list &lt;code&gt;void main()&lt;/code&gt; as an alternative.  The &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx&quot;&gt;versions&lt;/a&gt; from Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2008&lt;/a&gt; onwards do.</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx&quot;&gt;此页&lt;/a&gt;的Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005&quot;&gt;Visual Studio 2005&lt;/a&gt;版本没有列出 &lt;code&gt;void main()&lt;/code&gt; 作为替代方案。 从Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008&quot;&gt;Visual Studio 2008&lt;/a&gt;开始的&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx&quot;&gt;版本&lt;/a&gt;都可以。</target>
        </trans-unit>
        <trans-unit id="33cca83a9e2b339c3446cbab746394360baf8d65" translate="yes" xml:space="preserve">
          <source>The Microsoft page also lists some other alternatives &amp;mdash; &lt;code&gt;wmain()&lt;/code&gt; which takes wide character strings, and some more.</source>
          <target state="translated">Microsoft页面还列出了其他一些替代方法&amp;mdash; &lt;code&gt;wmain()&lt;/code&gt; 需要宽字符串，还有其他一些替代方法。</target>
        </trans-unit>
        <trans-unit id="7b0070d4ea6e95a967d24e8102c2d33f422b3fe2" translate="yes" xml:space="preserve">
          <source>The accepted answer appears to be targetted for C++, so I thought I'd add an answer that pertains to C, and this differs in a few ways.</source>
          <target state="translated">这个被接受的答案似乎是针对C++的,所以我想我再补充一个与C语言相关的答案,这个答案有几个不同的地方。</target>
        </trans-unit>
        <trans-unit id="546b26c20b5018e8e91b597a6abc305d7ad960ec" translate="yes" xml:space="preserve">
          <source>The behavior of the arguments to main, and of the interaction of exit, main and atexit
  (see &amp;sect;7.20.4.2) has been codified to curb some unwanted variety in the representation of argv
  strings, and in the meaning of values returned by main.</source>
          <target state="translated">main的参数行为以及exit，main和atexit的交互作用（请参见第7.20.4.2节）已被编纂，以抑制argv字符串表示以及main返回的值的含义中的某些不必要的变化。</target>
        </trans-unit>
        <trans-unit id="a1332b3e9a470eb6ea2ea721bb6e42f19fd7ef60" translate="yes" xml:space="preserve">
          <source>The cross-reference to clause 4 Conformance refers to this:</source>
          <target state="translated">对第4条 &quot;一致性 &quot;的比照提及。</target>
        </trans-unit>
        <trans-unit id="dc11d899a2bbef6b7ca7ebc05f3a76f63e6b3145" translate="yes" xml:space="preserve">
          <source>The declaration syntax for main is</source>
          <target state="translated">main的声明语法是</target>
        </trans-unit>
        <trans-unit id="54d077d6bc220b344cc0c2c98d6bff99a69286f5" translate="yes" xml:space="preserve">
          <source>The effect of program termination in a freestanding environment is implementation-defined.</source>
          <target state="translated">独立环境下的程序终止的效果是由实施定义的。</target>
        </trans-unit>
        <trans-unit id="d7cf7c56944bc0e60c66b4dd6a3630c1023a7db0" translate="yes" xml:space="preserve">
          <source>The former two are explicitly stated as the allowed forms, the others are implicitly allowed because C90 allowed &quot;implicit int&quot; for return type and function parameters. No other form is allowed.</source>
          <target state="translated">前两种形式被明文规定为允许的形式,其他的都是隐含的,因为C90允许返回类型和函数参数的 &quot;隐含int&quot;。其他形式都是不允许的。</target>
        </trans-unit>
        <trans-unit id="026f98c964de0d94f5fb9b6a1e303e50bcc1cdd6" translate="yes" xml:space="preserve">
          <source>The function called at program startup is named &lt;code&gt;main&lt;/code&gt;. The implementation declares no
  prototype for this function. It shall be defined with a return type of &lt;code&gt;int&lt;/code&gt; and with no
  parameters:</source>
          <target state="translated">程序启动时调用的函数名为 &lt;code&gt;main&lt;/code&gt; 。 该实现没有为此函数声明任何原型。 它应使用返回类型 &lt;code&gt;int&lt;/code&gt; 且不带参数来定义：</target>
        </trans-unit>
        <trans-unit id="ca5968af6b9e074a35418f4f286474743cccbd2c" translate="yes" xml:space="preserve">
          <source>The function called at program startup is named main. The
  implementation declares no prototype for this function. It shall be
  defined with a return type of int and with no parameters:</source>
          <target state="translated">程序启动时调用的函数被命名为main。实现中没有声明这个函数的原型。它将被定义为返回类型为int,没有参数。</target>
        </trans-unit>
        <trans-unit id="0ae03504835ac4c96ab05373731aeafea22c07c0" translate="yes" xml:space="preserve">
          <source>The name of the function called at startup is implementation-defined. If it is named &lt;code&gt;main()&lt;/code&gt; it must follow the stated forms &lt;sup&gt;10&lt;/sup&gt;:</source>
          <target state="translated">启动时调用的函数的名称是实现定义的。 如果将其命名为 &lt;code&gt;main()&lt;/code&gt; ,则必须遵循规定的格式&lt;sup&gt;10&lt;/sup&gt; ：</target>
        </trans-unit>
        <trans-unit id="42cedb16b5fd329909d8d618d881e9149d7c8ddf" translate="yes" xml:space="preserve">
          <source>The name of the function called at startup is implementation-defined. If it is named &lt;code&gt;main()&lt;/code&gt; it must follow the stated forms &lt;sup&gt;12&lt;/sup&gt;:</source>
          <target state="translated">启动时调用的函数的名称是实现定义的。 如果将其命名为 &lt;code&gt;main()&lt;/code&gt; ,则必须遵循规定的格式&lt;sup&gt;12&lt;/sup&gt; ：</target>
        </trans-unit>
        <trans-unit id="f411eabfea18f4d722bb32c090c81895998e01e5" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; and the strings pointed to by the &lt;code&gt;argv&lt;/code&gt; array shall
  be modifiable by the program, and retain their last-stored values between program
  startup and program termination.</source>
          <target state="translated">参数 &lt;code&gt;argc&lt;/code&gt; 和 &lt;code&gt;argv&lt;/code&gt; 以及 &lt;code&gt;argv&lt;/code&gt; 数组指向的字符串应可由程序修改，并在程序启动和程序终止之间保留其最后存储的值。</target>
        </trans-unit>
        <trans-unit id="71f2b4381bd48e53fc5bf7bb37600cda30ef7a72" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;main()&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 函数的返回类型</target>
        </trans-unit>
        <trans-unit id="30c22afa61a69f090f04a4b51d6f0da94397dc2d" translate="yes" xml:space="preserve">
          <source>The return value can be used by the operating system to check how the program was closed.</source>
          <target state="translated">返回值可以被操作系统用来检查程序是如何关闭的。</target>
        </trans-unit>
        <trans-unit id="ba1f12ca047f8d89e6d47cc78475d9dc71642ebe" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;main&lt;/code&gt; indicates how the program exited. Normal exit is represented by a 0 return value from &lt;code&gt;main&lt;/code&gt;. Abnormal exit is signaled by a non-zero return, but there is no standard for how non-zero codes are interpreted. As noted by others, &lt;code&gt;void main()&lt;/code&gt; is prohibited by the C++ standard and should not be used. The valid C++ &lt;code&gt;main&lt;/code&gt; signatures are:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 的返回值指示程序如何退出。 正常退出由 &lt;code&gt;main&lt;/code&gt; 的0返回值表示。 非零返回信号指示异常退出，但是对于如何解释非零代码没有标准。 正如其他人所指出的，C ++标准禁止 &lt;code&gt;void main()&lt;/code&gt; ，并且不应使用它。 有效的C ++ &lt;code&gt;main&lt;/code&gt; 签名是：</target>
        </trans-unit>
        <trans-unit id="22dbe4ab7277e0bacb463020855fe29f4a135940" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;main()&lt;/code&gt; shows how the program exited. If the return value is &lt;code&gt;zero&lt;/code&gt; it means that the execution was successful while any non-zero value will represent that something went bad in the execution.</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 的返回值显示程序如何退出。 如果返回值 &lt;code&gt;zero&lt;/code&gt; 则表示执行成功，而任何非零值都表示执行中出现问题。</target>
        </trans-unit>
        <trans-unit id="e22ad7a310bc1d275667315bd2dea731a9a4ebdc" translate="yes" xml:space="preserve">
          <source>The specification of argc and argv as arguments to main recognizes extensive prior practice.
  argv[argc] is required to be a null pointer to provide a redundant check for the end of the list, also on the basis of common practice.</source>
          <target state="translated">将argc和argv指定为main的参数,承认了之前的大量实践,要求argv[argc]为空指针,为列表的末尾提供一个多余的校验,这也是基于通常的做法。</target>
        </trans-unit>
        <trans-unit id="8e2e310f8d276bce8425174414a371db8d39f43f" translate="yes" xml:space="preserve">
          <source>The standard &amp;sect;5.1.2.2.1 of the C11 standard shows the preferred notation &amp;mdash;&amp;nbsp;&lt;code&gt;int main(void)&lt;/code&gt; &amp;mdash; but there are also two examples in the standard which show &lt;code&gt;int main()&lt;/code&gt;: &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8&quot;&gt;&amp;sect;6.5.3.4 &amp;para;8&lt;/a&gt; and &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20&quot;&gt;&amp;sect;6.7.6.3 &amp;para;20&lt;/a&gt;.  Now, it is important to note that examples are not 'normative'; they are only illustrative.  If there are bugs in the examples, they do not directly affect the main text of the standard.  That said, they are strongly indicative of expected behaviour, so if the standard includes &lt;code&gt;int main()&lt;/code&gt; in an example, it suggests that &lt;code&gt;int main()&lt;/code&gt; is not forbidden, even if it is not the preferred notation.</source>
          <target state="translated">C11标准的标准&amp;sect;5.1.2.2.1显示了首选的表示法-int &lt;code&gt;int main(void)&lt;/code&gt; -但该标准中还有两个示例显示 &lt;code&gt;int main()&lt;/code&gt; ： &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8&quot;&gt;&amp;sect;6.5.3.4&amp;para;8&lt;/a&gt;和&lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20&quot;&gt;&amp;sect;6.7.6.3 &amp;para;20&lt;/a&gt; 。 现在，重要的是要注意示例不是&amp;ldquo;规范性的&amp;rdquo;。 它们仅是说明性的。 如果示例中有错误，则它们不会直接影响标准的正文。 也就是说，它们强烈指示了预期的行为，因此，如果在示例中标准包含 &lt;code&gt;int main()&lt;/code&gt; ，则表明即使不是优选的表示法，也不禁止 &lt;code&gt;int main()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21097dd912cf311cfdb6f22df1d0503ba8d3b181" translate="yes" xml:space="preserve">
          <source>The standard defines 3 values for returning that are strictly conforming (that is, does not rely on implementation defined behaviour): &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; for a successful termination, and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; for an unsuccessful termination. Any other values are non-standard and implementation defined. &lt;code&gt;main()&lt;/code&gt; must have an explicit &lt;code&gt;return&lt;/code&gt; statement at the end to avoid undefined behaviour.</source>
          <target state="translated">该标准定义了三个严格符合要求的返回值（即，不依赖于实现定义的行为）： &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 表示成功终止， &lt;code&gt;EXIT_FAILURE&lt;/code&gt; 表示终止失败。 任何其他值都是非标准的，并且定义为实现。 &lt;code&gt;main()&lt;/code&gt; 在末尾必须具有显式的 &lt;code&gt;return&lt;/code&gt; 语句，以避免未定义的行为。</target>
        </trans-unit>
        <trans-unit id="04c357fe47330fd474b14115ca9a3a38ddbd2e54" translate="yes" xml:space="preserve">
          <source>The supplied version of the header &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; shall declare at least the functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;atexit&lt;/code&gt;, &lt;code&gt;at_quick_exit&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;quick_exit&lt;/code&gt; (18.5). The other headers listed in this table shall meet the same requirements as for a hosted implementation.</source>
          <target state="translated">标头 &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; 的提供的版本至少应声明函数 &lt;code&gt;abort&lt;/code&gt; ， &lt;code&gt;atexit&lt;/code&gt; ， &lt;code&gt;at_quick_exit&lt;/code&gt; ， &lt;code&gt;exit&lt;/code&gt; 和 &lt;code&gt;quick_exit&lt;/code&gt; （18.5）。 该表中列出的其他标头应满足与托管实现相同的要求。</target>
        </trans-unit>
        <trans-unit id="215b83b15446fc6e768d7de47de3d64d6250e81c" translate="yes" xml:space="preserve">
          <source>The text of the standard has been changed but it has the same meaning.</source>
          <target state="translated">标准的文字有了变化,但它的含义是一样的。</target>
        </trans-unit>
        <trans-unit id="3a96141f4a269d89eae9927fca95e222c0774ce2" translate="yes" xml:space="preserve">
          <source>The third argument is a null-terminated list of pointers to strings, each of which is an environment variable which has a name, an equals sign, and a value (possibly empty).  If you do not use this, you can still get at the environment via '&lt;code&gt;extern char **environ;&lt;/code&gt;'.  This global variable is unique among those in POSIX in that it does not have a header that declares it.</source>
          <target state="translated">第三个参数是一个以空字符结尾的字符串指针列表，每个字符串都是一个环境变量，该环境变量具有名称，等号和值（可​​能为空）。 如果不使用它，您仍然可以通过' &lt;code&gt;extern char **environ;&lt;/code&gt; 获取环境。 '。 该全局变量在POSIX中是唯一的，因为它没有声明它的标头。</target>
        </trans-unit>
        <trans-unit id="f1917f923748d24954167ac87cbedac4efe8c562" translate="yes" xml:space="preserve">
          <source>The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.</source>
          <target state="translated">使用带空括号的函数声明器(而不是原型格式参数类型声明器)是一个过时的特性。</target>
        </trans-unit>
        <trans-unit id="1e1d1d4c80a34abbd78d532e533e8e32a26baa46" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;argc&lt;/code&gt; shall be nonnegative.</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 的值应为非负数。</target>
        </trans-unit>
        <trans-unit id="3b6837137519a235145649ca26f22f77d0ac5ffc" translate="yes" xml:space="preserve">
          <source>The value returned from &lt;code&gt;main()&lt;/code&gt; is transmitted to the 'environment' in an implementation-defined way.</source>
          <target state="translated">从 &lt;code&gt;main()&lt;/code&gt; 返回的值以实现定义的方式传输到&amp;ldquo;环境&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ca8a9e03a294ed095d6a449285082fc38a13cce6" translate="yes" xml:space="preserve">
          <source>There's a paragraph of &amp;sect;18.5 &lt;strong&gt;Start and termination&lt;/strong&gt; in the C++11 standard that is identical to the paragraph from &amp;sect;7.22.4.4 &lt;strong&gt;The &lt;code&gt;exit&lt;/code&gt; function&lt;/strong&gt; in the C11 standard (quoted above), apart from a footnote (which simply documents that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; are defined in &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">C ++ 11标准中的第18.5节&amp;ldquo; &lt;strong&gt;开始和终止&amp;rdquo;&lt;/strong&gt;有一段与&amp;sect;7.22.4.4中的段落相同（上面引述），除了脚注（仅记录了 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 和 &lt;code&gt;EXIT_FAILURE&lt;/code&gt; 在 &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; 中定义）。</target>
        </trans-unit>
        <trans-unit id="8878897f94a88e2eb0a72b92a1a8eea14341dd7c" translate="yes" xml:space="preserve">
          <source>This is recognized by the C standard as a common extension, documented in Annex J:</source>
          <target state="translated">这是C标准所承认的通用扩展,载于附件J。</target>
        </trans-unit>
        <trans-unit id="90c926db372e34ff57f910bfc2a6bb307fd78475" translate="yes" xml:space="preserve">
          <source>This is some example in order to check how grep works.</source>
          <target state="translated">这是一些例子,以检查grep的工作原理。</target>
        </trans-unit>
        <trans-unit id="d9135e4649a5add9899348971cdf27790adec503" translate="yes" xml:space="preserve">
          <source>This section is identical to the C++03 one cited above.</source>
          <target state="translated">本节与上文所引的C++03相同。</target>
        </trans-unit>
        <trans-unit id="aff26f54c08ac6a220e320cf88a1cc85885f4a3d" translate="yes" xml:space="preserve">
          <source>This section is identical to the C99 one cited above.</source>
          <target state="translated">本节与上述C99所引的内容相同。</target>
        </trans-unit>
        <trans-unit id="492f852c402b8701a3d8ac1e786125fd366f3983" translate="yes" xml:space="preserve">
          <source>This way you can see that it is the variable &lt;code&gt;$?&lt;/code&gt; which receives the least significant byte of the return value of &lt;code&gt;main()&lt;/code&gt;.</source>
          <target state="translated">这样您可以看到它是变量 &lt;code&gt;$?&lt;/code&gt; 它接收 &lt;code&gt;main()&lt;/code&gt; 返回值的最低有效字节。</target>
        </trans-unit>
        <trans-unit id="083f523a48b50dec805c4b80d1381d0a4f4fa86b" translate="yes" xml:space="preserve">
          <source>Those words &quot;(most efficient)&quot; don't change the question.  Unless you're in a freestanding environment, there is one universally correct way to declare &lt;code&gt;main()&lt;/code&gt;, and that's as returning int.</source>
          <target state="translated">这些词（（最有效的）&amp;rdquo;不会改变问题。 除非您处于独立的环境中，否则存在一种通用的正确声明 &lt;code&gt;main()&lt;/code&gt; 的方法 ，那就是返回int。</target>
        </trans-unit>
        <trans-unit id="dd1d619c61e03e7c3983d9cf6e51c9a460b55ae1" translate="yes" xml:space="preserve">
          <source>Two execution environments are defined: freestanding and hosted. In both cases,
  program startup occurs when a designated C function is called by the execution
  environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.</source>
          <target state="translated">定义了两种执行环境:独立执行环境和托管执行环境。在这两种情况下,程序启动都是在执行环境调用指定的C函数时发生。在程序启动之前,所有具有静态存储持续时间的对象都应在程序启动前进行初始化(设置为初始值)。此种初始化的方式和时间,在其他方面没有规定。程序终止将控制权交还给执行环境。</target>
        </trans-unit>
        <trans-unit id="7e6d901cc3741eac5e0d54d5f5f6b0f0c7091f78" translate="yes" xml:space="preserve">
          <source>Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this International Standard describes the set of available headers.</source>
          <target state="translated">定义了两种实现方式:托管式和独立式(1.4)。对于托管式实施,本国际标准描述了可用的标题集。</target>
        </trans-unit>
        <trans-unit id="c8ffe25090b0726f102193ed465ce10faae40214" translate="yes" xml:space="preserve">
          <source>What about using &lt;code&gt;int main()&lt;/code&gt; in C?</source>
          <target state="translated">在C中使用 &lt;code&gt;int main()&lt;/code&gt; 怎么样？</target>
        </trans-unit>
        <trans-unit id="8db9388f551bf79763f6d366a53d00645a18b452" translate="yes" xml:space="preserve">
          <source>What are the valid signatures for C's &lt;code&gt;main()&lt;/code&gt; function?</source>
          <target state="translated">C的 &lt;code&gt;main()&lt;/code&gt; 函数的有效签名是什么？</target>
        </trans-unit>
        <trans-unit id="e375a0bb38b5733f5e33aea178300914bf1fc13b" translate="yes" xml:space="preserve">
          <source>What is the correct (most efficient) way to define the &lt;code&gt;main()&lt;/code&gt; function in C and C++ &amp;mdash; &lt;code&gt;int main()&lt;/code&gt; or &lt;code&gt;void main()&lt;/code&gt; &amp;mdash; and why? 
If &lt;code&gt;int main()&lt;/code&gt; then &lt;code&gt;return 1&lt;/code&gt; or &lt;code&gt;return 0&lt;/code&gt;?</source>
          <target state="translated">在C和C ++中定义 &lt;code&gt;main()&lt;/code&gt; 函数的正确（最有效）方法是什么&amp;mdash; &lt;code&gt;int main()&lt;/code&gt; 或 &lt;code&gt;void main()&lt;/code&gt; &amp;mdash;为什么？ 如果 &lt;code&gt;int main()&lt;/code&gt; &lt;code&gt;return 1&lt;/code&gt; 或 &lt;code&gt;return 0&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="ac7910d8738d0f6edbbbc837537320cc7243db50" translate="yes" xml:space="preserve">
          <source>What is the correct (most efficient) way to define the main() function in C and C++ &amp;mdash; int main() or void main() &amp;mdash; and why?</source>
          <target state="translated">在C和C ++中定义main（）函数的正确（最有效）方法是什么&amp;mdash; int main（）或void main（）&amp;mdash;为什么？</target>
        </trans-unit>
        <trans-unit id="b6fa6e7eb3c56c5443ca329d417a88f4f68960be" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;main()&lt;/code&gt; return in C and C++?</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 在C和C ++中应该返回什么？</target>
        </trans-unit>
        <trans-unit id="486019aa245ddcb5e5499f2b26db2df46e934c65" translate="yes" xml:space="preserve">
          <source>What should main() return in C and C++</source>
          <target state="translated">在C和C++中,main()应该返回什么?</target>
        </trans-unit>
        <trans-unit id="30ef05539959ff243c4e180d8cd581aaf97379b0" translate="yes" xml:space="preserve">
          <source>What to return depends on what you want to do with the executable. For example if you are using your program with a command line shell, then you need to return 0 for a success and a non zero for failure. Then you would be able to use the program in shells with conditional processing depending on the outcome of your code. Also you can assign any nonzero value as per your interpretation, for example for critical errors different program exit points could terminate a program with different exit values , and which is available to the calling shell which can decide what to do by inspecting the value returned.
If the code is not intended for use with shells and the returned value does not bother anybody then it might be omitted. I personally use the signature &lt;code&gt;int main (void) { .. return 0; .. }&lt;/code&gt;</source>
          <target state="translated">返回什么取决于您要对可执行文件执行的操作。 例如，如果您将程序与命令行外壳一起使用，则成功返回0，失败返回非零。 然后，您将能够在shell中使用程序进行条件处理，具体取决于代码的结果。 您还可以根据您的解释指定任何非零值，例如，对于严重错误，不同的程序出口点可能会终止具有不同出口值的程序，并且调用外壳程序可以使用该值，通过检查返回的值来决定要做什么。 如果该代码不适合与Shell一起使用，并且返回的值不会困扰任何人，则可以将其省略。 我个人使用签名 &lt;code&gt;int main (void) { .. return 0; .. }&lt;/code&gt; ..}</target>
        </trans-unit>
        <trans-unit id="23877bc0573cb6974d91820ac2c5704526b909c4" translate="yes" xml:space="preserve">
          <source>When a C or C++ program reaches the end of &lt;code&gt;main&lt;/code&gt; the compiler will automatically generate code to return 0, so there is no need to put &lt;code&gt;return 0;&lt;/code&gt; explicitly at the end of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">当C或C ++程序到达 &lt;code&gt;main&lt;/code&gt; 的末尾时，编译器将自动生成返回0的代码，因此无需将 &lt;code&gt;return 0;&lt;/code&gt; 放回原处。 在 &lt;code&gt;main&lt;/code&gt; 的末尾显式。</target>
        </trans-unit>
        <trans-unit id="c0ff9c6d19528fc5ecbf1d4fd6390af8df49063b" translate="yes" xml:space="preserve">
          <source>When using the various tools that the Linux terminal provides one can use the return code for example for error handling after the process has been completed. Imagine that the following text file myfile is present:</source>
          <target state="translated">在使用Linux终端提供的各种工具时,人们可以使用返回代码来进行错误处理,例如,在进程完成后,可以使用返回代码进行错误处理。想象一下,下面是一个文本文件myfile。</target>
        </trans-unit>
        <trans-unit id="1ed64c1ea746c88bec38d149c99f20765bec153b" translate="yes" xml:space="preserve">
          <source>When you execute the grep command a process is created. Once it is through (and didn't break) it returns some code between 0 and 255. For example:</source>
          <target state="translated">当你执行grep命令时,会创建一个进程。一旦它通过(并且没有中断),它就会返回一些0到255之间的代码。比如说</target>
        </trans-unit>
        <trans-unit id="96e3de3e6bf17276eac99869ea88fc0e71150b83" translate="yes" xml:space="preserve">
          <source>Why does &lt;code&gt;int main(){}&lt;/code&gt; compile?</source>
          <target state="translated">为什么 &lt;code&gt;int main(){}&lt;/code&gt; 会编译？</target>
        </trans-unit>
        <trans-unit id="51b0c9e4f517672dab551e3f0c8fb3a773467020" translate="yes" xml:space="preserve">
          <source>Why is the type of the &lt;code&gt;main()&lt;/code&gt; function in C and C++ left to the user to define?</source>
          <target state="translated">为什么C和C ++中的 &lt;code&gt;main()&lt;/code&gt; 函数的类型留给用户定义？</target>
        </trans-unit>
        <trans-unit id="2a862fb41af52a34873a9b301706a972cab7022b" translate="yes" xml:space="preserve">
          <source>Yet the section for hosted environment program termination then goes on arguing about the case where main does not return int &lt;sup&gt;5&lt;/sup&gt;. Although that section is not normative for how main should be declared, it definitely implies that main might be declared in a completely implementation-defined way even on hosted systems.</source>
          <target state="translated">但是，托管环境程序终止的部分然后继续讨论main不返回int &lt;sup&gt;5的情况&lt;/sup&gt; 。 尽管该部分并未就应如何声明main进行规范，但这绝对意味着即使在托管系统上，也可能以完全实现定义的方式声明main。</target>
        </trans-unit>
        <trans-unit id="922180965ea438bfff3906a2def9f2352b5adb9b" translate="yes" xml:space="preserve">
          <source>You may omit the return statement from &lt;code&gt;main()&lt;/code&gt;. If you do, and &lt;code&gt;main()&lt;/code&gt; finished, there is an implicit &lt;code&gt;return 0&lt;/code&gt;.</source>
          <target state="translated">您可以省略 &lt;code&gt;main()&lt;/code&gt; 的return语句。 如果这样做，并且 &lt;code&gt;main()&lt;/code&gt; 完成，则隐式 &lt;code&gt;return 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab226733ba35ae01df11c0190457de2d507d24e6" translate="yes" xml:space="preserve">
          <source>[...] a return from the initial call to the &lt;code&gt;main&lt;/code&gt; function is equivalent to calling the &lt;code&gt;exit&lt;/code&gt; function with the value returned by the &lt;code&gt;main&lt;/code&gt; function as its argument; reaching the &lt;code&gt;}&lt;/code&gt; that terminates the &lt;code&gt;main&lt;/code&gt; function returns a value of 0.</source>
          <target state="translated">[...]从初始调用返回到 &lt;code&gt;main&lt;/code&gt; 函数等同于以 &lt;code&gt;main&lt;/code&gt; 函数返回的值作为参数来调用 &lt;code&gt;exit&lt;/code&gt; 函数； 到达终止 &lt;code&gt;main&lt;/code&gt; 函数的 &lt;code&gt;}&lt;/code&gt; 会返回值0。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="121d20b5045a7b17be1953b2f4b5b7d1193aba4f" translate="yes" xml:space="preserve">
          <source>as the type of main (8.3.5).</source>
          <target state="translated">作为主要的类型(8.3.5)。</target>
        </trans-unit>
        <trans-unit id="8b4ea7908f3a8fca63af0e6ad2f61e8268c4885d" translate="yes" xml:space="preserve">
          <source>main is the only function that may portably be declared either with zero or two arguments. (The number of other functions&amp;rsquo; arguments must match exactly between invocation and definition.)
  This special case simply recognizes the widespread practice of leaving off the arguments to main when the program does not access the program argument strings. While many implementations support more than two arguments to main, such practice is neither blessed nor forbidden by the Standard; a program that defines main with three arguments is not strictly conforming (see &amp;sect;J.5.1.).</source>
          <target state="translated">main是唯一可以用零或两个参数声明的函数。 （其他函数的参数数目必须在调用和定义之间完全匹配。）这种特殊情况只是承认了广泛的做法，即当程序无法访问程序参数字符串时，将参数保留给main。 尽管许多实现支持对main的不止两个论点，但该实践并没有受到标准的祝福或禁止。 用三个参数定义main的程序不是严格符合要求的（请参见&amp;sect;J.5.1。）。</target>
        </trans-unit>
        <trans-unit id="622f82e8c075ada716a1cc9582aedc7d512d29d9" translate="yes" xml:space="preserve">
          <source>or equivalent;9) or in some other implementation-defined
  manner.</source>
          <target state="translated">或等价物;9)或以其他实施方式定义的方式。</target>
        </trans-unit>
        <trans-unit id="1afe888428199267b8fb21832c373dab7f683445" translate="yes" xml:space="preserve">
          <source>or equivalent;&lt;sup&gt;10)&lt;/sup&gt; or in some other implementation-defined manner.</source>
          <target state="translated">或同等学历; &lt;sup&gt;10）&lt;/sup&gt;或其他实现定义的方式。</target>
        </trans-unit>
        <trans-unit id="6270e8159f1807e121f60a87d982221f41402076" translate="yes" xml:space="preserve">
          <source>or with two parameters (referred to here as
  argc and argv, though any names may be used, as they are local to the
  function in which they are declared):</source>
          <target state="translated">或带两个参数(这里称为 argc 和 argv,尽管可以使用任何名称,因为它们是本地的,因为它们是被声明的函数的本地参数)。</target>
        </trans-unit>
        <trans-unit id="c5dae6252c11ab5b0df3caf711c397701d6124cd" translate="yes" xml:space="preserve">
          <source>or with two parameters (referred to here as &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;, though any names may be
  used, as they are local to the function in which they are declared):</source>
          <target state="translated">或带有两个参数（尽管可以使用任何名称，但在此处称为 &lt;code&gt;argc&lt;/code&gt; 和 &lt;code&gt;argv&lt;/code&gt; ，因为它们是声明它们的函数的局部名称）：</target>
        </trans-unit>
        <trans-unit id="f8a458ef7b858ad564adb1ed9a5adbf1c78ddb73" translate="yes" xml:space="preserve">
          <source>or, optionally,</source>
          <target state="translated">或者,可以选择:</target>
        </trans-unit>
        <trans-unit id="04c6ac4120301d7049af98011b0e572414db64b0" translate="yes" xml:space="preserve">
          <source>which is equivalent to</source>
          <target state="translated">相当于</target>
        </trans-unit>
        <trans-unit id="e7bb9db27381610dba7df259669ffd179effc729" translate="yes" xml:space="preserve">
          <source>you will get a 0. Why? Because &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; found a match and returned an exit code 0, which is the usual value for exiting with a success. Let's check it out again but with something that is not inside our text file and thus no match will be found:</source>
          <target state="translated">您将得到0。为什么？ 因为&lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt;找到一个匹配项并返回了退出代码0，这是成功退出的通常值。 让我们再次检查一下，但文本文件中未包含某些内容，因此找不到匹配项：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
