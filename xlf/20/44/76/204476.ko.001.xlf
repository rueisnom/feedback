<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/204476">
    <body>
      <group id="204476">
        <trans-unit id="839e4a2006b278a93c4dc0f1936567078302c3f3" translate="yes" xml:space="preserve">
          <source>&amp;hellip;</source>
          <target state="translated">&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="f63367f1516d04e6d4576f54a6d715fa5519616b" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a function of () returning int and</source>
          <target state="translated">&amp;mdash; int를 반환하는 () 함수</target>
        </trans-unit>
        <trans-unit id="e3f10b4fa0118c5d90b758f3a7a22ecd6eddcb20" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a function of (int, pointer to pointer to char) returning int</source>
          <target state="translated">&amp;mdash; int를 리턴하는 (int, char에 대한 포인터를 가리키는) 함수</target>
        </trans-unit>
        <trans-unit id="de2b84f7b4965ccad1f31acc3adcae74954902d4" translate="yes" xml:space="preserve">
          <source>&amp;para;1 A program shall contain a global function called main, which is the designated start of the program. [...]</source>
          <target state="translated">&amp;para;1 프로그램은 main이라는 전역 함수를 포함해야하며, 이는 프로그램의 지정된 시작입니다. [...]</target>
        </trans-unit>
        <trans-unit id="fba079ec46d6590faa38ad6852c15693de356522" translate="yes" xml:space="preserve">
          <source>&amp;para;1 In a hosted environment, the main function receives a third argument, &lt;code&gt;char *envp[]&lt;/code&gt;,
  that points to a null-terminated array of pointers to &lt;code&gt;char&lt;/code&gt;, each of which points to a string
  that provides information about the environment for this execution of the program (5.1.2.2.1).</source>
          <target state="translated">&amp;para;1 호스트 환경에서, 메인 함수는 &lt;code&gt;char *envp[]&lt;/code&gt; 의 세 번째 인수 인 char 에 대한 널로 끝나는 포인터 배열을 가리키며, 각 인수는이 실행을위한 환경에 대한 정보를 제공하는 문자열을 가리 킵니다. 프로그램 (5.1.2.2.1).</target>
        </trans-unit>
        <trans-unit id="268bf348aa4cc2e0b88457c3f6e444329c666667" translate="yes" xml:space="preserve">
          <source>&amp;para;2 An implementation shall not predefine the main function. This function shall not be overloaded. It shall
  have a return type of type int, but otherwise its type is implementation defined.
  All implementations
  shall allow both of the following definitions of main:</source>
          <target state="translated">&amp;para;2 구현은 주요 기능을 미리 정의하지 않아야한다. 이 기능은 과부하되지 않아야한다. int 타입의 리턴 타입을 가져야하지만 그렇지 않으면 타입이 구현 정의됩니다. 모든 구현은 다음 main 정의를 모두 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f725c7d6a718deeff027d0b7dca43053111038cf" translate="yes" xml:space="preserve">
          <source>&amp;para;3 The function &lt;code&gt;main&lt;/code&gt; shall not be used within a program. The linkage (3.5) of &lt;code&gt;main&lt;/code&gt; is implementation-defined. [...]</source>
          <target state="translated">&amp;para;3 기능 &lt;code&gt;main&lt;/code&gt; 은 프로그램 내에서 사용되지 않아야합니다. &lt;code&gt;main&lt;/code&gt; 의 연결 (3.5)은 구현에 따라 정의됩니다. [...]</target>
        </trans-unit>
        <trans-unit id="6b25271533fe3e52213549f62d7343ca3360fd44" translate="yes" xml:space="preserve">
          <source>&amp;para;5 A &lt;em&gt;strictly conforming program&lt;/em&gt; shall use only those features of the language and library specified in this International Standard.&lt;sup&gt;3)&lt;/sup&gt; It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.</source>
          <target state="translated">&amp;para;5 &lt;em&gt;엄격하게 준수하는 프로그램&lt;/em&gt; 은이 국제 표준에 명시된 언어 및 라이브러리의 기능 만 사용해야합니다. &lt;sup&gt;3)&lt;/sup&gt; 지정되지 않거나 정의되지 않은 또는 구현 정의 된 동작에 따라 출력을 생성하지 않아야하며 최소 구현 제한을 초과해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="faf3a7ecabef70212bf778ca2245ba160daae386" translate="yes" xml:space="preserve">
          <source>&amp;para;5 A return statement in main has the effect of leaving the main function (destroying any objects with automatic
  storage duration) and calling &lt;code&gt;std::exit&lt;/code&gt; with the return value as the argument. If control reaches the end
  of main without encountering a return statement, the effect is that of executing</source>
          <target state="translated">&amp;para;5 main의 return 문은 main 함수를 떠나고 (자동 저장 시간이있는 객체를 파괴 함) 반환 값을 인수로하여 &lt;code&gt;std::exit&lt;/code&gt; 를 호출하는 효과가 있습니다. 리턴 문이 발생하지 않고 제어가 메인의 끝에 도달하면 그 결과는 실행의 효과입니다</target>
        </trans-unit>
        <trans-unit id="cd52c684e5038903c8d7058be01e2ecabbdecb17" translate="yes" xml:space="preserve">
          <source>&amp;para;5 Finally, control is returned to the host environment. If the value of &lt;code&gt;status&lt;/code&gt; is zero or &lt;code&gt;EXIT_SUCCESS&lt;/code&gt;, an implementation-defined form of the status &lt;em&gt;successful termination&lt;/em&gt; is returned. If the value of &lt;code&gt;status&lt;/code&gt; is &lt;code&gt;EXIT_FAILURE&lt;/code&gt;, an implementation-defined form of the status &lt;em&gt;unsuccessful termination&lt;/em&gt; is returned. Otherwise the status returned is implementation-defined.</source>
          <target state="translated">&amp;para;5 마지막으로, 제어는 호스트 환경으로 돌아갑니다. &lt;code&gt;status&lt;/code&gt; 값이 0 또는 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 인 경우 구현 &lt;em&gt;성공&lt;/em&gt; 상태의 구현 정의 양식이 리턴됩니다. &lt;code&gt;status&lt;/code&gt; 값이 &lt;code&gt;EXIT_FAILURE&lt;/code&gt; 인 경우 구현이 정의한 상태의 &lt;em&gt;실패한 종료&lt;/em&gt; 양식이 리턴됩니다. 그렇지 않으면 반환 된 상태는 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="75b067a9183eb49f341e4cb9b8899302c2bf5c32" translate="yes" xml:space="preserve">
          <source>&amp;para;6 The two forms of conforming implementation are &lt;em&gt;hosted&lt;/em&gt; and &lt;em&gt;freestanding&lt;/em&gt;. A &lt;em&gt;conforming hosted implementation&lt;/em&gt; shall accept any strictly conforming program. A &lt;em&gt;conforming freestanding implementation&lt;/em&gt; shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;,
  &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;, and
  &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;. A conforming implementation may have extensions (including
  additional library functions), provided they do not alter the behavior of any strictly conforming program.&lt;sup&gt;4)&lt;/sup&gt;</source>
          <target state="translated">&amp;para;6 준수 구현의 두 가지 형태는 &lt;em&gt;호스팅&lt;/em&gt; 되고 &lt;em&gt;독립형&lt;/em&gt; 입니다. &lt;em&gt;준수 호스팅 구현&lt;/em&gt; 은 엄격하게 준수하는 모든 프로그램을 수락해야합니다. &lt;em&gt;준수하는 독립형 구현&lt;/em&gt; 은 라이브러리 절 (7 절)에 명시된 기능의 사용이 표준 헤더 &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; 의 내용으로 제한되는 엄격한 준수 프로그램을 수용해야한다 . h&amp;gt; , &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt; 입니다. 적합한 구현은 엄격하게 준수하는 프로그램의 동작을 변경하지 않는 한 확장 (추가 라이브러리 기능 포함)을 가질 수 있습니다. &lt;sup&gt;4)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="80e12995965674219f63848c639631125cf40efd" translate="yes" xml:space="preserve">
          <source>&amp;para;7 A &lt;em&gt;conforming program&lt;/em&gt; is one that is acceptable to a conforming implementation.&lt;sup&gt;5)&lt;/sup&gt;</source>
          <target state="translated">&amp;para;7 &lt;em&gt;준수 프로그램&lt;/em&gt; 은 준수 구현에 허용되는 &lt;em&gt;프로그램&lt;/em&gt; 입니다. &lt;sup&gt;5)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ca1e412dcdcb69f2e17aed105715050d1052b4ce" translate="yes" xml:space="preserve">
          <source>&amp;para;7 Two kinds of implementations are defined: a &lt;em&gt;hosted implementation&lt;/em&gt; and a &lt;em&gt;freestanding implementation&lt;/em&gt;. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding
  implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).</source>
          <target state="translated">&amp;para;7 두 가지 종류의 구현이 정의되어있다 : &lt;em&gt;호스팅 구현&lt;/em&gt; 과 &lt;em&gt;독립 구현&lt;/em&gt; . 호스팅 된 구현의 경우이 국제 표준은 사용 가능한 라이브러리 세트를 정의합니다. 독립 실행 형 구현은 운영 체제의 이점없이 실행할 수 있으며 특정 언어 지원 라이브러리 (17.6.1.3)를 포함하는 구현 정의 라이브러리 세트를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7dc9283f7b16f5ee420119dfbaa6363dac4ba08" translate="yes" xml:space="preserve">
          <source>&amp;para;8 A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that
  use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.</source>
          <target state="translated">&amp;para;8 적합한 구현은 올바른 형식의 프로그램 동작을 변경하지 않는 한 확장 기능 (추가 라이브러리 기능 포함)을 가질 수 있습니다. 이 국제 표준에 따라 잘못된 확장을 사용하는 프로그램을 진단하려면 구현이 필요합니다. 그러나 그렇게하면 그러한 프로그램을 컴파일하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aee57d8b42fa45a9c62d786d87e4e51641c9817b" translate="yes" xml:space="preserve">
          <source>&amp;para;8 EXAMPLE 3 In this example, the size of a variable length array is computed and returned from a function:</source>
          <target state="translated">&amp;para;8 예 3이 예에서는 가변 길이 배열의 크기가 계산되어 함수에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7375209cbdea44802996e1ba4bfbb7ebf8bcffc8" translate="yes" xml:space="preserve">
          <source>&amp;para;9 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support and defines all locale-specific characteristics.&lt;sup&gt;3&lt;/sup&gt;</source>
          <target state="translated">&amp;para;9 각 구현은 지원하지 않는 모든 조건부 지원 구성을 식별하고 모든 로케일 특정 특성을 정의하는 문서를 포함해야합니다. &lt;sup&gt;삼&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="f8c0fd5dd6b6ab8b703b27f9f230f0a90552ad70" translate="yes" xml:space="preserve">
          <source>0 for success, nonzero for failure.  Again, not something you need to (or get to) pick: it's defined by the interface you're supposed to be conforming to.</source>
          <target state="translated">성공하면 0, 실패하면 0이 아닙니다. 다시 말하지만, 선택해야 할 것은 아닙니다. 준수해야 할 인터페이스에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9b8d3e781ce73dbb246a75ec5a09339f47b503" translate="yes" xml:space="preserve">
          <source>1 If the return type of the &lt;code&gt;main&lt;/code&gt; function is a type compatible with &lt;code&gt;int&lt;/code&gt;, a return from the
  initial call to the &lt;code&gt;main&lt;/code&gt; function is equivalent to calling the &lt;code&gt;exit&lt;/code&gt; function with the value
  returned by the &lt;code&gt;main&lt;/code&gt; function as its argument;&lt;sup&gt;11)&lt;/sup&gt; reaching the &lt;code&gt;}&lt;/code&gt; that terminates the
  &lt;code&gt;main&lt;/code&gt; function returns a value of 0. If the return type is not compatible with &lt;code&gt;int&lt;/code&gt;, the
  termination status returned to the host environment is unspecified.</source>
          <target state="translated">1 &lt;code&gt;main&lt;/code&gt; 함수의 리턴 유형이 &lt;code&gt;int&lt;/code&gt; 와 호환되는 유형 인 경우, 초기 함수에서 &lt;code&gt;main&lt;/code&gt; 함수로의 리턴은 main 함수가 리턴 한 값을 인수로 사용하여 &lt;code&gt;exit&lt;/code&gt; 함수를 호출하는 것과 같습니다. &lt;sup&gt;11)&lt;/sup&gt; &lt;code&gt;main&lt;/code&gt; 함수를 종료하는 &lt;code&gt;}&lt;/code&gt; 에 도달하면 값 0이 리턴됩니다. 리턴 유형이 &lt;code&gt;int&lt;/code&gt; 와 호환되지 않으면 호스트 환경으로 리턴되는 종료 상태는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f3fffa3327d3ba52b48bca6ea15dcebe78e227a" translate="yes" xml:space="preserve">
          <source>1.4 Implementation compliance [intro.compliance]</source>
          <target state="translated">1.4 구현 준수 [intro.compliance]</target>
        </trans-unit>
        <trans-unit id="c6764c018e0ee51831b7edf8ba43133716139970" translate="yes" xml:space="preserve">
          <source>17.6.1.3 Freestanding implementations [compliance]</source>
          <target state="translated">17.6.1.3 독립 실행 형 구현 [규정 준수]</target>
        </trans-unit>
        <trans-unit id="c625fb551848e2eda9b2bcd7f1fbfbeae2205afb" translate="yes" xml:space="preserve">
          <source>3.6.1 Main function [basic.start.main]</source>
          <target state="translated">3.6.1 주요 기능 [basic.start.main]</target>
        </trans-unit>
        <trans-unit id="74939d480b030b4d0aca4a62a78baefa0b305245" translate="yes" xml:space="preserve">
          <source>5.1.2 Execution environments</source>
          <target state="translated">5.1.2 실행 환경</target>
        </trans-unit>
        <trans-unit id="a10709d6042407d378ae63fb597e3cb0c35f37a4" translate="yes" xml:space="preserve">
          <source>5.1.2.1 Freestanding environment</source>
          <target state="translated">5.1.2.1 독립 환경</target>
        </trans-unit>
        <trans-unit id="421d09a1018436b2d8a5dd11587decfcfcd9ac51" translate="yes" xml:space="preserve">
          <source>5.1.2.2.1 Program startup</source>
          <target state="translated">5.1.2.2.1 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="bf97d5d45eb7bf179cd39bc7a3476106465bd537" translate="yes" xml:space="preserve">
          <source>5.1.2.2.3 Program termination</source>
          <target state="translated">5.1.2.2.3 프로그램 종료</target>
        </trans-unit>
        <trans-unit id="aaeb27114e23ee14710f683d375b03fdb9b9be98" translate="yes" xml:space="preserve">
          <source>6.11.6 Function declarators</source>
          <target state="translated">6.11.6 함수 선언자</target>
        </trans-unit>
        <trans-unit id="fa42bbaed1d0a660afc0222443686a157a0e6ebd" translate="yes" xml:space="preserve">
          <source>6.5.3.4 The &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators</source>
          <target state="translated">6.5.3.4 &lt;code&gt;sizeof&lt;/code&gt; 와 &lt;code&gt;_Alignof&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="af39c61a22e5f25a61be3c526a6c974cd1ea404d" translate="yes" xml:space="preserve">
          <source>7.22.4.4 The &lt;code&gt;exit&lt;/code&gt; function</source>
          <target state="translated">7.22.4.4 &lt;code&gt;exit&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="2259a4ab4a2439d3610778ec870b765036afd221" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main&quot;&gt;What is the proper declaration of &lt;code&gt;main()&lt;/code&gt;?&lt;/a&gt; &amp;mdash; For C++, with a very good answer indeed.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main&quot;&gt; &lt;code&gt;main()&lt;/code&gt; 의 올바른 선언은 무엇입니까?&lt;/a&gt; &amp;mdash; C ++의 경우, 정말 좋은 대답이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e29bc9e2848992cf6548652af8a5be14a9249467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argv[argc]&lt;/code&gt; shall be a null pointer.</source>
          <target state="translated">&lt;code&gt;argv[argc]&lt;/code&gt; 는 널 포인터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4a37fed8f5445c4993b8c5da80701807ea9a23fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int main()&lt;/code&gt; vs &lt;code&gt;void main()&lt;/code&gt; in C</source>
          <target state="translated">C에서 &lt;code&gt;int main()&lt;/code&gt; vs &lt;code&gt;void main()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8f60346f2e6dc9ec649d50698ae28dc37e9103d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt; in C89 and K&amp;amp;R C unspecified return types default to &amp;rsquo;int`.</source>
          <target state="translated">C89의 &lt;code&gt;main()&lt;/code&gt; 및 K &amp;amp; R C 지정되지 않은 리턴 유형은 기본적으로 'int`입니다.</target>
        </trans-unit>
        <trans-unit id="77a0a2cbf7bad637f5c880daeb2e835a409f5011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt; should be declared as either:</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 은 다음 중 하나로 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a99a4351928aa53be892994d830351307ef971d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt;'s signature in C++</source>
          <target state="translated">C ++의 &lt;code&gt;main()&lt;/code&gt; 서명</target>
        </trans-unit>
        <trans-unit id="3389bce9434a3b56c3264af85cd3f1e622526831" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return 0&lt;/code&gt; or &lt;code&gt;return 1&lt;/code&gt; will be received by the parent process. In a shell it goes into a shell variable, and if you are running your program form a shell and not using that variable then you need not worry about the return value of &lt;code&gt;main()&lt;/code&gt;.</source>
          <target state="translated">부모 프로세스는 &lt;code&gt;return 0&lt;/code&gt; 또는 &lt;code&gt;return 1&lt;/code&gt; 을받습니다. 쉘에서는 쉘 변수로 들어가고 프로그램을 실행하고 쉘을 사용하지 않고 해당 변수를 사용하지 않으면 &lt;code&gt;main()&lt;/code&gt; 의 반환 값에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9357defb5f570731b5b1bc998cafabdff46afe41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;There are numerous duplicates of this question, including:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 질문에는 다음을 포함하여 수많은 사본이 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24c37500e1d6539a78a2997986f25d358e54ee71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++03 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 03 독립 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ca7c7ddff5ac442add7172c71909b660ede292c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++03 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 03 호스팅 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82a7ebec217d66e8b8c2d24ab3e3f5b1cacef4f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 11 독립 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2b3cabf96f4ea44d63a24449dabea2a53cf0512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 11 호스팅 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09f98f8248303be464d553d71fb5cf58e90f51b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C11 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C11 독립형 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b60f1d79fd4fb894543c08e1c03275903168a46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C11 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C11 호스팅 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f08ea5864b7e3a0f044a93ec2f7398ca698c40b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C90 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C90 독립형 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d214f0511b5d0b5572547a7e70a1324e68f71d7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C90 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C90 호스팅 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="100ce1f0e56996aa7562559f1b8a172eabbb3b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C99 독립형 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aced90d316248fd18e7f601285666ee9656c0b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C99 호스팅 환경&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39941c674be35df5a1e78497af6e5aefcc124f65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when I make this suggestion, it's almost invariably followed by one of two kinds of comments:  &quot;I didn't know that.&quot; or &quot;That's bad advice!&quot;  My rationale is that it's safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 제안을 할 때 거의 두 가지 유형의 주석 중 하나가 이어집니다. &quot;그것을 몰랐습니다.&quot; 또는 &quot;나쁜 조언이야!&quot; 내 근거는 표준에서 명시 적으로 지원하는 컴파일러 동작에 의존하는 것이 안전하고 유용하다는 것입니다. C의 경우 C99 이후; ISO / IEC 9899 : 1999 섹션 5.1.2.2.3 참조 :</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ede2f6abb3f054287bbb931649c2f245bcaa1f0" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;10)&lt;/sup&gt; Thus, &lt;code&gt;int&lt;/code&gt; can be replaced by a typedef name defined as &lt;code&gt;int&lt;/code&gt;, or the type of &lt;code&gt;argv&lt;/code&gt; can be written as
  &lt;code&gt;char **argv&lt;/code&gt;, and so on.</source>
          <target state="translated">&lt;sup&gt;10)&lt;/sup&gt; 따라서 &lt;code&gt;int&lt;/code&gt; 를 로 정의 된 typedef 이름으로 바꾸거나 &lt;code&gt;argv&lt;/code&gt; 유형을 &lt;code&gt;char **argv&lt;/code&gt; 등으로 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="011ebdf423d0eeaeb00bbe1f5e9f73f7e03f1379" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;11)&lt;/sup&gt; In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in &lt;code&gt;main&lt;/code&gt;
  will have ended in the former case, even where they would not have in the latter.</source>
          <target state="translated">&lt;sup&gt;11)&lt;/sup&gt; 6.2.4에 따르면 &lt;code&gt;main&lt;/code&gt; 에서 선언 된 자동 저장 기간을 가진 객체의 수명은 후자의 경우에는 없었지만 전자의 경우에는 끝났습니다.</target>
        </trans-unit>
        <trans-unit id="a58a7471bfb0770dd6b5ffe6f2124853a918a6d6" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3)&lt;/sup&gt; A strictly conforming program can use conditional features (see 6.10.8.3) provided the use is guarded by an appropriate conditional inclusion preprocessing directive using the related macro. For example:</source>
          <target state="translated">&lt;sup&gt;3)&lt;/sup&gt; 엄격하게 준수하는 프로그램은 관련 매크로를 사용하여 적절한 조건부 포함 전처리 지시문에 의해 보호되는 경우 조건부 기능 (6.10.8.3 참조)을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a0e8c9db9d88c7fc9a217ed3b840fdfca0ad4c9" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3)&lt;/sup&gt; This documentation also defines implementation-defined behavior; see 1.9.</source>
          <target state="translated">&lt;sup&gt;3)&lt;/sup&gt; 이 문서는 또한 구현 정의 동작을 정의합니다. 1.9 참조</target>
        </trans-unit>
        <trans-unit id="60f63bd67cf9699a2930ead7ef8840e496fb4919" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4)&lt;/sup&gt; This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.</source>
          <target state="translated">&lt;sup&gt;4)&lt;/sup&gt; 이는 적합한 구현이이 국제 표준에 명시 적으로 예약 된 식별자 이외의 식별자를 보유하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="df6a402d9d62f5a27a627e0839825b19422b9ff0" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;5)&lt;/sup&gt; Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon non-portable features of a conforming implementation.</source>
          <target state="translated">&lt;sup&gt;5)&lt;/sup&gt; 엄격하게 준수하는 프로그램은 준수하는 구현 중에서 최대한 이식성이 뛰어납니다. 적합한 프로그램은 적합한 구현의 이식 불가능한 기능에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="181254e8f9b948c18cf54289fc472931f4bcaf8c" translate="yes" xml:space="preserve">
          <source>A freestanding implementation has an implementation-defined set of headers. This set shall include at least the headers shown in Table 16.</source>
          <target state="translated">독립 구현에는 구현 정의 헤더 세트가 있습니다. 이 세트는 최소한 표 16에 표시된 헤더를 포함해야한다.</target>
        </trans-unit>
        <trans-unit id="80e91a530ec3d2ff8b86717bc9074b128cbda6a4" translate="yes" xml:space="preserve">
          <source>A strange, ambiguous sentence &quot;or in some other implementation-defined manner&quot; has been introduced. This can either be interpreted as &quot;the parameters to &lt;code&gt;int main()&lt;/code&gt; may vary&quot; or as &quot;main can have any implementation-defined form&quot;.</source>
          <target state="translated">&quot;또는 다른 구현 정의 방식으로&quot;이상한, 모호한 문장이 소개되었습니다. 이것은 &quot; &lt;code&gt;int main()&lt;/code&gt; 대한 매개 변수가 다를 수 있습니다&quot;또는 &quot;main이 구현 정의 형식을 가질 수 있습니다&quot;로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca23b0779eeca695d782b5b96f1577207241984" translate="yes" xml:space="preserve">
          <source>ANSI X3.159-1989 2.1.2.1 Freestanding environment:</source>
          <target state="translated">ANSI X3.159-1989 2.1.2.1 독립 환경 :</target>
        </trans-unit>
        <trans-unit id="57a7155ea831c7e0d4282c280f1bb112dfa1e288" translate="yes" xml:space="preserve">
          <source>ANSI X3.159-1989 2.1.2.2 Hosted environment. &quot;Program startup&quot;</source>
          <target state="translated">ANSI X3.159-1989 2.1.2.2 호스팅 환경. &quot;프로그램 시작&quot;</target>
        </trans-unit>
        <trans-unit id="24cf3c85b055a0c58ef221fc468e8f9b43b2c027" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md&quot;&gt;C++ Core Guidelines&lt;/a&gt; contains multiple instances of omitting &lt;code&gt;return 0;&lt;/code&gt; at the end of &lt;code&gt;main&lt;/code&gt; and no instances in which an explicit return is written.  Although there is not yet a specific guideline on this particular topic in that document, that seems at least a tacit endorsement of the practice.</source>
          <target state="translated">또한 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md&quot;&gt;C ++ 핵심 지침&lt;/a&gt; 에는 &lt;code&gt;return 0;&lt;/code&gt; 을 생략하는 여러 인스턴스가 포함되어 있습니다 . &lt;code&gt;main&lt;/code&gt; 의 끝에 명시 적 반환이 기록되는 인스턴스가 없습니다. 이 문서에서이 특정 주제에 대한 구체적인 지침은 아직 없지만, 적어도 관행에 대한 암묵적인 승인으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="23e493e83a229c8a646ea40b97b496511adb8337" translate="yes" xml:space="preserve">
          <source>After the second line nothing is printed to the terminal since &quot;foo&quot; made grep return 1 and we check if the return code of grep was equal to 0. The second conditional statement echoes its message in the last line since it is true due to CHECK == 1.</source>
          <target state="translated">&quot;foo&quot;가 grep을 1로 리턴 한 후 두 번째 줄 이후에는 아무것도 출력되지 않으며 grep의 리턴 코드가 0인지 확인합니다. 두 번째 조건문은 CHECK로 인해 true이므로 마지막 줄에 메시지를 표시합니다. == 1.</target>
        </trans-unit>
        <trans-unit id="09933d4decfafb0faf055a060f94f61bcf140364" translate="yes" xml:space="preserve">
          <source>All versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit &lt;code&gt;return;&lt;/code&gt; statements at the end of a &lt;code&gt;void&lt;/code&gt; function.  Reasons against omitting seem to boil down to &lt;a href=&quot;https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015&quot;&gt;&quot;it looks weird&quot;&lt;/a&gt;.  If, like me, you're curious about the rationale for the change to the C standard &lt;a href=&quot;https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional&quot;&gt;read this question&lt;/a&gt;.  Also note that in the early 1990s this was considered &quot;sloppy practice&quot; because it was undefined behavior (although widely supported) at the time.</source>
          <target state="translated">그 이후로 두 표준의 모든 버전 (C99 및 C ++ 98)은 동일한 아이디어를 유지했습니다. 우리는 C ++에서 자동으로 생성 된 멤버 함수에 의존하며, 명시적인 &lt;code&gt;return;&lt;/code&gt; 쓰는 사람은 거의 없습니다 . &lt;code&gt;void&lt;/code&gt; 함수의 끝에있는 문장. 생략에 대한 이유는 &lt;a href=&quot;https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015&quot;&gt;&quot;이상하게 보인다&quot;&lt;/a&gt; 로 요약되는 것처럼 보인다. 나처럼 C 표준으로의 변경에 대한 이론적 근거가 궁금하다면 &lt;a href=&quot;https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional&quot;&gt;이 질문을 읽으십시오&lt;/a&gt; . 또한 1990 년대 초에 이것은 당시에 정의되지 않은 행동 (광범위하게 지원 되기는했지만)이기 때문에 &quot;조잡한 관행&quot;으로 간주되었다.</target>
        </trans-unit>
        <trans-unit id="83ff694899e1d845ab60582f3b73ef06850d2d34" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;11&lt;/sup&gt;:</source>
          <target state="translated">허용 된 양식 &lt;sup&gt;11&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="1ffdd2e9d11e5e754b0a9cf96f132585a0112b4d" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;1&lt;/sup&gt;:</source>
          <target state="translated">허용되는 양식 &lt;sup&gt;1&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="531b9bfacbabbde3a9ef0944158dd8da7569c421" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;3&lt;/sup&gt;:</source>
          <target state="translated">허용되는 양식 &lt;sup&gt;3&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="75815e021134ec0eba7ed2c0d9c5a844701da1d0" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;7&lt;/sup&gt;:</source>
          <target state="translated">허용 된 양식 &lt;sup&gt;7&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="4679a6ba8a0d1ca4986d60983e12b4e750ecdae5" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;9&lt;/sup&gt;:</source>
          <target state="translated">허용 된 양식 &lt;sup&gt;9&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="8ce86355d96de776927a38cfc34a124933831922" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;wmain&lt;/code&gt; functions can be declared as returning &lt;code&gt;void&lt;/code&gt; (no return value). If you declare &lt;code&gt;main&lt;/code&gt; or &lt;code&gt;wmain&lt;/code&gt; as returning void, you cannot return an exit code to the parent process or operating system by using a return statement. To return an exit code when &lt;code&gt;main&lt;/code&gt; or &lt;code&gt;wmain&lt;/code&gt; is declared as &lt;code&gt;void&lt;/code&gt;, you must use the &lt;code&gt;exit&lt;/code&gt; function.</source>
          <target state="translated">또는 &lt;code&gt;main&lt;/code&gt; 및 &lt;code&gt;wmain&lt;/code&gt; 함수는 &lt;code&gt;void&lt;/code&gt; 를 반환하는 것으로 선언 될 수 있습니다 (반환 값 없음). &lt;code&gt;main&lt;/code&gt; 또는 &lt;code&gt;wmain&lt;/code&gt; 을 void를 리턴하는 것으로 선언하면 return 문을 사용하여 종료 코드를 상위 프로세스 또는 운영 체제에 리턴 할 수 없습니다. &lt;code&gt;main&lt;/code&gt; 또는 &lt;code&gt;wmain&lt;/code&gt; 이 &lt;code&gt;void&lt;/code&gt; 로 선언 될 때 종료 코드를 반환하려면 &lt;code&gt;exit&lt;/code&gt; 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="108ea3b40bdac1fa932e2881ce8b590bb80462aa" translate="yes" xml:space="preserve">
          <source>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall
  allow both</source>
          <target state="translated">구현이 주요 기능을 미리 정의해서는 안됩니다. 이 기능은 과부하되지 않아야한다. int 유형의 리턴 유형을 가져야하지만 그렇지 않으면 유형이 구현 정의됩니다. 모든 구현은 두 가지를 모두 허용해야한다</target>
        </trans-unit>
        <trans-unit id="cceddadf6ec36d3e334ec1453776d68f0a30b419" translate="yes" xml:space="preserve">
          <source>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both of the following definitions of main:</source>
          <target state="translated">구현이 주요 기능을 미리 정의해서는 안됩니다. 이 기능은 과부하되지 않아야한다. int 유형의 리턴 유형을 가져야하지만 그렇지 않으면 유형이 구현 정의됩니다. 모든 구현은 다음 main 정의를 모두 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="abe62c12cbd384f011ace9ca713b8616f65c4574" translate="yes" xml:space="preserve">
          <source>Any form or name of main is allowed &lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">main의 모든 형식 또는 이름이 허용됩니다 &lt;sup&gt;2&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="f259d290cdcbc9bbec44ad4bd545c173c869cb9a" translate="yes" xml:space="preserve">
          <source>Any form or name of main is allowed &lt;sup&gt;6&lt;/sup&gt;.</source>
          <target state="translated">main의 모든 형식 또는 이름이 허용됩니다 &lt;sup&gt;6&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="e2314c2dd97eecb4a3e772641c44c357495c2a73" translate="yes" xml:space="preserve">
          <source>Any form or name of main is allowed &lt;sup&gt;8&lt;/sup&gt;.</source>
          <target state="translated">main의 모든 형식 또는 이름이 허용됩니다 &lt;sup&gt;8&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="ef855fa906d52778c2fb1c45f521ea626f5689c2" translate="yes" xml:space="preserve">
          <source>As noted early on, the requirements above apply to hosted environments. If you are working with a freestanding environment (which is the alternative to a hosted environment), then the standard has much less to say. For a freestanding environment, the function called at program startup need not be called &lt;code&gt;main&lt;/code&gt; and there are no constraints on its return type.  The standard says:</source>
          <target state="translated">앞서 언급했듯이 위의 요구 사항은 호스팅 된 환경에 적용됩니다. 독립 환경 (호스트 환경의 대안)으로 작업하는 경우 표준에 대한 언급이 훨씬 적습니다. 독립형 환경의 경우 프로그램 시작시 호출 된 함수를 &lt;code&gt;main&lt;/code&gt; 이라고 할 필요가 없으며 리턴 유형에 제한이 없습니다. 표준은 말한다 :</target>
        </trans-unit>
        <trans-unit id="6a69258566146688a6c3902485cea9ec71efe8ed" translate="yes" xml:space="preserve">
          <source>As you can see if you are calling this and that process it is sometimes essential to see what it has returned (by the return value of main()).</source>
          <target state="translated">당신이 이것을 호출하고 있는지 그 프로세스를 볼 수 있듯이 때로는 main ()의 반환 값에 의해 반환 된 것을 보는 것이 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="e46f165c0590a92b13364a7c8042f058136f6322" translate="yes" xml:space="preserve">
          <source>C++ &amp;mdash; &lt;code&gt;int main(int argc, char **argv)&lt;/code&gt;</source>
          <target state="translated">C ++ &amp;mdash; &lt;code&gt;int main(int argc, char **argv)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76311ff27f1cf5e0babcefff7edb17a402c58861" translate="yes" xml:space="preserve">
          <source>C++ &amp;mdash; &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;</source>
          <target state="translated">C ++ &amp;mdash; &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d70b6b60e0f24927bc4538fb0ceb71184d06bef0" translate="yes" xml:space="preserve">
          <source>C99 removed &quot;implicit int&quot; so &lt;code&gt;main()&lt;/code&gt; is no longer valid.</source>
          <target state="translated">C99가 &quot;implicit int&quot;를 제거하여 &lt;code&gt;main()&lt;/code&gt; 이 더 이상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c8395748074b451b2f55b5c5e4c263a6bbe2bef" translate="yes" xml:space="preserve">
          <source>Classically, Unix systems support a third variant:</source>
          <target state="translated">일반적으로 Unix 시스템은 세 번째 변형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e4ed7f96515dbdbe5f5d0ecace105efe68e6c3ec" translate="yes" xml:space="preserve">
          <source>Comments:</source>
          <target state="translated">Comments:</target>
        </trans-unit>
        <trans-unit id="cf3f840e63764cb35ea2eae778010a42f50e1375" translate="yes" xml:space="preserve">
          <source>Difference between &lt;code&gt;void main()&lt;/code&gt; and &lt;code&gt;int main()&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;void main()&lt;/code&gt; 과 &lt;code&gt;int main()&lt;/code&gt; 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8dd79bfba982dc335f30bf0edc8ada5d88da4914" translate="yes" xml:space="preserve">
          <source>Efficiency is not an issue with the &lt;code&gt;main&lt;/code&gt; function. It can only be entered and left once (marking the program's start and termination) according to the C++ standard. For C, re-entering &lt;code&gt;main()&lt;/code&gt; is allowed, but should be avoided.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 기능의 효율성은 문제가되지 않습니다. C ++ 표준에 따라 한 번만 입력하고 남겨 둘 수 있습니다 (프로그램의 시작 및 종료 표시). C의 경우 &lt;code&gt;main()&lt;/code&gt; 다시 입력하는 것이 허용되지만 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="3fd215cf12ba7569beb5b6db1ee04c9f3d5989a2" translate="yes" xml:space="preserve">
          <source>Finally, there is nothing wrong from a standards point of view with calling &lt;code&gt;main()&lt;/code&gt; from a program.</source>
          <target state="translated">마지막으로 표준 관점에서 프로그램에서 &lt;code&gt;main()&lt;/code&gt; 을 호출하면 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="62b8c7d7dfd45c5f3d50a3d0e74887793a303162" translate="yes" xml:space="preserve">
          <source>For C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:</source>
          <target state="translated">C ++의 경우 1998 년 첫 번째 표준 이후 ISO / IEC 14882 : 1998 섹션 3.6.1 참조 :</target>
        </trans-unit>
        <trans-unit id="3500093e0edf7d6f4a566c3f4b7efdebecf64c37" translate="yes" xml:space="preserve">
          <source>For C99, everything is the same as above except:</source>
          <target state="translated">C99의 경우 다음을 제외하고 모든 것이 위와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fc184e779fe2b354b692cb83c96360ac6578836a" translate="yes" xml:space="preserve">
          <source>For a hosted environment (that's the normal one), the C11 standard (ISO/IEC 9899:2011) says:</source>
          <target state="translated">호스팅 환경 (일반적인 환경)의 경우 C11 표준 (ISO / IEC 9899 : 2011)은 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="2c578db723c70cb97ef0753314ddb79e6ca46de7" translate="yes" xml:space="preserve">
          <source>Here is a small demonstration of the usage of return codes...</source>
          <target state="translated">다음은 리턴 코드 사용법에 대한 간단한 데모입니다.</target>
        </trans-unit>
        <trans-unit id="d082866f80f3c7b776d5b28ecd6c0bcbdc809faf" translate="yes" xml:space="preserve">
          <source>However I usually return 0.</source>
          <target state="translated">그러나 나는 보통 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bcc235a17e919b6165ee1c9df15ea0527e83ab84" translate="yes" xml:space="preserve">
          <source>However, to allow completely wild forms of &lt;code&gt;main()&lt;/code&gt; was probably(?) not the intention of this new sentence. The C99 rationale (not normative) implies that the sentence refers to additional parameters to &lt;code&gt;int main&lt;/code&gt;&lt;sup&gt;4&lt;/sup&gt;.</source>
          <target state="translated">그러나 완전히 야생 인 &lt;code&gt;main()&lt;/code&gt; 형식을 허용하는 것은 아마도이 새로운 문장의 의도가 아니었을 것입니다. C99의 이론적 근거 (규범이 아님)는 문장이 &lt;code&gt;int main&lt;/code&gt; &lt;sup&gt;4에&lt;/sup&gt; 대한 추가 매개 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d1b1ad3f3ac01aeb1f1aa57b42231bc5e931e4f0" translate="yes" xml:space="preserve">
          <source>I believe that &lt;code&gt;main()&lt;/code&gt; should return either &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; or &lt;code&gt;EXIT_FAILURE&lt;/code&gt;. They are defined in &lt;code&gt;stdlib.h&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 은 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 또는 EXIT_FAILURE를 반환해야한다고 생각합니다. 그것들은 &lt;code&gt;stdlib.h&lt;/code&gt; 에 정의되어 있습니다</target>
        </trans-unit>
        <trans-unit id="2c8ab38f22cccd2931145ee6336eedf191f6b30f" translate="yes" xml:space="preserve">
          <source>I was under the impression that standard specifies that main doesn't need a return value as a successful return was OS based (zero in one could be either a success or a failure in another), therefore the absence of return was a cue for the compiler to insert the successful return itself.</source>
          <target state="translated">나는 표준이 성공적인 반환이 OS 기반이기 때문에 main이 반환 값을 필요로하지 않는다는 인상을 받았다. (하나는 0은 다른 하나는 성공 또는 실패 일 수 있음), 따라서 반환의 부재는 성공적인 반환 자체를 삽입하는 컴파일러.</target>
        </trans-unit>
        <trans-unit id="4fb16fcf1d38904d79af7bbdd1699672a66ac59e" translate="yes" xml:space="preserve">
          <source>ISO 14882:2003 3.6.1 Main function</source>
          <target state="translated">ISO 14882 : 2003 3.6.1 주요 기능</target>
        </trans-unit>
        <trans-unit id="6fcc9ab167f456cff52beb58f8604705b44e2080" translate="yes" xml:space="preserve">
          <source>ISO 14882:2011 3.6.1 Main function</source>
          <target state="translated">ISO 14882 : 2011 3.6.1 주요 기능</target>
        </trans-unit>
        <trans-unit id="072f40f89924efb24c9c0d91ec69c1b477accc60" translate="yes" xml:space="preserve">
          <source>ISO 9899:1999 5.1.2.1 Freestanding environment</source>
          <target state="translated">ISO 9899 : 1999 5.1.2.1 독립형 환경</target>
        </trans-unit>
        <trans-unit id="6cb748bf92ce81daeb76259fcdc696d6d4a84f98" translate="yes" xml:space="preserve">
          <source>ISO 9899:1999 5.1.2.2 Hosted environment -&amp;gt; 5.1.2.2.1 Program startup</source>
          <target state="translated">ISO 9899 : 1999 5.1.2.2 호스팅 환경-&amp;gt; 5.1.2.2.1 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="c570e7967aeae8d218c9500d8af0ccbb2c0999ed" translate="yes" xml:space="preserve">
          <source>ISO 9899:1999 5.1.2.2 Hosted environment --&amp;gt; 5.1.2.2.3 Program termination</source>
          <target state="translated">ISO 9899 : 1999 5.1.2.2 호스팅 환경-&amp;gt; 5.1.2.2.3 프로그램 종료</target>
        </trans-unit>
        <trans-unit id="5adf9fbb580920fe4e8bdb0b93849057aa5eaef0" translate="yes" xml:space="preserve">
          <source>ISO 9899:2011 5.1.2.2 Hosted environment -&amp;gt; 5.1.2.2.1 Program startup</source>
          <target state="translated">ISO 9899 : 2011 5.1.2.2 호스팅 환경-&amp;gt; 5.1.2.2.1 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="c026b51c24ee5003420193d6a1c30eba041e8812" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1989 (C90):</source>
          <target state="translated">ISO / IEC 9899 : 1989 (C90) :</target>
        </trans-unit>
        <trans-unit id="7738b221c80b5304b0ca9410b351937992dbdba2" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (C99):</source>
          <target state="translated">ISO / IEC 9899 : 1999 (C99) :</target>
        </trans-unit>
        <trans-unit id="0dff1e972d7a65190eb694ffe563008167981bd6" translate="yes" xml:space="preserve">
          <source>If an implementation permits it, &lt;code&gt;main()&lt;/code&gt; can be declared in other ways, but this makes the program implementation defined, and no longer strictly conforming.</source>
          <target state="translated">구현이 허용한다면, &lt;code&gt;main()&lt;/code&gt; 은 다른 방법으로 선언 될 수 있지만, 이것은 프로그램 구현을 정의하고 더 이상 엄격하게 준수하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36650763e12f75f89b51f84868ae093852daf601" translate="yes" xml:space="preserve">
          <source>If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;</source>
          <target state="translated">리턴 문이 발생하지 않고 제어가 메인의 끝에 도달하면 리턴 0을 실행하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f306c8b2bb84020137c0b44d4df475b5a3dfaf8b" translate="yes" xml:space="preserve">
          <source>If int main() then return 1 or return 0?</source>
          <target state="translated">int main ()이면 1을 반환하거나 0을 반환합니까?</target>
        </trans-unit>
        <trans-unit id="bbe13bc0ccc90c42b104135b14e3c3f18c8e40da" translate="yes" xml:space="preserve">
          <source>If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;11) reaching the &lt;code&gt;}&lt;/code&gt; that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified.</source>
          <target state="translated">주 함수의 반환 유형이 int와 호환되는 유형 인 경우, 초기 함수에서 기본 함수로의 반환은 기본 함수에서 반환 한 값을 인수로 사용하여 종료 함수를 호출하는 것과 같습니다. 기본 함수 종료는 0 값을 리턴합니다. 리턴 유형이 int와 호환되지 않으면 호스트 환경으로 리턴되는 종료 상태는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80d38b087bcd0bf8f8ae646ae8cfc61a04ed675e" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the array members &lt;code&gt;argv[0]&lt;/code&gt; through
  &lt;code&gt;argv[argc-1]&lt;/code&gt; inclusive shall contain pointers to strings, which are given
  implementation-defined values by the host environment prior to program startup. The
  intent is to supply to the program information determined prior to program startup
  from elsewhere in the hosted environment. If the host environment is not capable of
  supplying strings with letters in both uppercase and lowercase, the implementation
  shall ensure that the strings are received in lowercase.</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 의 값이 0보다 큰 경우, 배열 멤버 &lt;code&gt;argv[0]&lt;/code&gt; ~ &lt;code&gt;argv[argc-1]&lt;/code&gt; 은 문자열에 대한 포인터를 포함해야하며, 이는 프로그램 시작 전에 호스트 환경에 의해 구현 정의 된 값이 제공됩니다. 호스팅 환경의 다른 곳에서 프로그램을 시작하기 전에 결정된 프로그램 정보를 제공하기위한 것입니다. 호스트 환경에서 대문자와 소문자로 문자열을 제공 할 수없는 경우 구현시 문자열을 소문자로 수신해야합니다.</target>
        </trans-unit>
        <trans-unit id="5477192590999db427c7b99a724d15f14138992a" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the string pointed to by &lt;code&gt;argv[0]&lt;/code&gt;
  represents the program name; &lt;code&gt;argv[0][0]&lt;/code&gt; shall be the null character if the
  program name is not available from the host environment. If the value of &lt;code&gt;argc&lt;/code&gt; is
  greater than one, the strings pointed to by &lt;code&gt;argv[1]&lt;/code&gt; through &lt;code&gt;argv[argc-1]&lt;/code&gt;
  represent the program parameters.</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 의 값이 0보다 큰 경우 &lt;code&gt;argv[0]&lt;/code&gt; 가리키는 문자열은 프로그램 이름을 나타냅니다. 프로그램 이름을 호스트 환경에서 사용할 수없는 경우 &lt;code&gt;argv[0][0]&lt;/code&gt; 은 널 문자입니다. &lt;code&gt;argc&lt;/code&gt; 의 값이 1보다 큰 경우 &lt;code&gt;argv[1]&lt;/code&gt; 에서 &lt;code&gt;argv[argc-1]&lt;/code&gt; 가리키는 문자열은 프로그램 매개 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="83b323b3be8c3ef77aecb667889dc3dd68d116df" translate="yes" xml:space="preserve">
          <source>If they are declared, the parameters to the main function shall obey the following
  constraints:</source>
          <target state="translated">이들이 선언되면, main 함수에 대한 매개 변수는 다음 제약 조건을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="d1a5b964a486551cab1f4315aeb05a3560a45f00" translate="yes" xml:space="preserve">
          <source>If you are doing this (call a process so many times), you should find a way to put your logic directly inside the caller, or in a DLL file, without allocate a specific process for each call; the multiple process allocations bring you the relevant efficiency problem in this case.</source>
          <target state="translated">이 작업을 수행하는 경우 (프로세스를 너무 많이 호출) 각 호출에 특정 프로세스를 할당하지 않고 로직을 호출자 또는 DLL 파일에 직접 넣는 방법을 찾아야합니다. 다중 프로세스 할당은이 경우 관련 효율성 문제를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">당신이 할 경우</target>
        </trans-unit>
        <trans-unit id="483a23176183f6c1305e90f13f59c790a7cd8b33" translate="yes" xml:space="preserve">
          <source>If you do not write a return statement in &lt;code&gt;int main()&lt;/code&gt;, the closing &lt;code&gt;{&lt;/code&gt; will return 0 by default.</source>
          <target state="translated">&lt;code&gt;int main()&lt;/code&gt; 에 return 문을 쓰지 않으면 닫는 &lt;code&gt;{&lt;/code&gt; 은 기본적으로 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="850185e652bcc3094867daff9db6c1960eaf3346" translate="yes" xml:space="preserve">
          <source>If you really have issues related to efficiency of returning an integer from a process, you should probably avoid to call that process so many times that this return value becomes an issue.</source>
          <target state="translated">프로세스에서 정수를 반환하는 효율성과 관련하여 실제로 문제가있는 경우 해당 프로세스를 너무 많이 호출하여이 반환 값이 문제가되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="52092fcdfb7b4fbe87c5392e56ec14ab62dfac60" translate="yes" xml:space="preserve">
          <source>In C89 (and hence in Microsoft C), there is no statement about what happens if the &lt;code&gt;main()&lt;/code&gt; function returns but does not specify a return value; it therefore leads to undefined behaviour.</source>
          <target state="translated">C89 (및 Microsoft C)에서는 &lt;code&gt;main()&lt;/code&gt; 함수가 반환하지만 반환 값을 지정하지 않으면 어떻게되는지에 대한 설명이 없습니다. 그러므로 그것은 정의되지 않은 행동으로 이어진다.</target>
        </trans-unit>
        <trans-unit id="c87cc4b10f829842d58cbb57cfa34ee20cb520f0" translate="yes" xml:space="preserve">
          <source>In Unix and DOS scripting, &lt;code&gt;return 0&lt;/code&gt; on success and non-zero for error are usually returned. This is the standard used by Unix and DOS scripting to find out what happened with your program and controlling the whole flow.</source>
          <target state="translated">유닉스 및 DOS 스크립팅에서 성공시 0을 리턴하고 오류에 대해 0이 아닌 값이 리턴됩니다. 이것은 유닉스 및 DOS 스크립팅에서 프로그램에서 발생한 일을 파악하고 전체 흐름을 제어하는 ​​데 사용되는 표준입니다.</target>
        </trans-unit>
        <trans-unit id="8eaed3f6bd24cf0c2bf1a5f18894bccff46da0ac" translate="yes" xml:space="preserve">
          <source>In a freestanding environment (in which C program execution may take
  place without any benefit of an operating system), the name and type
  of the function called at program startup are implementation-defined.</source>
          <target state="translated">C 환경에서 운영 체제의 이점없이 C 프로그램이 실행될 수있는 독립 환경에서는 프로그램 시작시 호출되는 함수의 이름과 유형이 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e8f9653053b16c99b1cfc10e334bf69a6adf9d71" translate="yes" xml:space="preserve">
          <source>In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined. Any library facilities available to a freestanding program, other than the minimal set required by clause 4, are implementation-defined.</source>
          <target state="translated">C 환경에서 운영 체제의 이점없이 C 프로그램이 실행될 수있는 독립 환경에서는 프로그램 시작시 호출되는 함수의 이름과 유형이 구현 정의됩니다. 조항 4에 의해 요구되는 최소 세트 이외의 독립 프로그램에 이용 가능한 모든 도서관 시설은 구현에 따라 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7e3919889d260828538ebba4f914ae5c8021bc7c" translate="yes" xml:space="preserve">
          <source>In detail, if you only want to know if returning 0 is more or less efficient than returning 1, it could depend from the compiler in some cases, but generically, assuming they are read from the same source (local, field, constant, embedded in the code, function result, etc.) it requires exactly the same number of clock cycles.</source>
          <target state="translated">구체적으로, 0을 반환하는 것이 1을 반환하는 것보다 더 효율적인지 아닌지를 알고 싶다면 경우에 따라 컴파일러에서 의존 할 수 있지만 일반적으로 동일한 소스 (로컬, 필드, 상수, 임베디드)에서 읽은 것으로 가정합니다. 코드, 함수 결과 등)에는 정확히 동일한 수의 클럭 사이클이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="77bca36b5e136be0307abf4a901e487488fb4541" translate="yes" xml:space="preserve">
          <source>In the latter form &lt;code&gt;argc&lt;/code&gt; shall be the number of arguments passed to the program from the environment
  in which the program is run. If &lt;code&gt;argc&lt;/code&gt; is nonzero these arguments shall be supplied in &lt;code&gt;argv[0]&lt;/code&gt;
  through &lt;code&gt;argv[argc-1]&lt;/code&gt; as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and &lt;code&gt;argv[0]&lt;/code&gt; shall be the pointer to the initial character of a NTMBS that represents the
  name used to invoke the program or &lt;code&gt;&quot;&quot;&lt;/code&gt;. The value of &lt;code&gt;argc&lt;/code&gt; shall be non-negative. The value of &lt;code&gt;argv[argc]&lt;/code&gt;
  shall be 0. [ Note: It is recommended that any further (optional) parameters be added after &lt;code&gt;argv&lt;/code&gt;. &amp;mdash;end
  note ]</source>
          <target state="translated">후자의 형식에서 &lt;code&gt;argc&lt;/code&gt; 는 프로그램이 실행되는 환경에서 프로그램으로 전달 된 인수의 수입니다. &lt;code&gt;argc&lt;/code&gt; 가 0이 아닌 경우 이러한 인수는 &lt;code&gt;argv[0]&lt;/code&gt; 에서 &lt;code&gt;argv[argc-1]&lt;/code&gt; 로 널 종료 멀티 바이트 문자열 (NTMBS) (17.5.2.1.4.2)의 초기 문자에 대한 포인터로 제공되며 &lt;code&gt;argv[0]&lt;/code&gt; 은 프로그램을 호출하는 데 사용되는 이름을 나타내는 NTMBS의 초기 문자에 대한 포인터 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; &lt;code&gt;argc&lt;/code&gt; 의 값은 음이 아니어야합니다. &lt;code&gt;argv[argc]&lt;/code&gt; 의 값은 0이어야합니다. [참고 : &lt;code&gt;argv&lt;/code&gt; 뒤에 추가 (선택적) 매개 변수를 추가하는 것이 좋습니다. &amp;mdash; 끝 참고]</target>
        </trans-unit>
        <trans-unit id="edd6065f0058ea6d8f4719347b7def37199e2a44" translate="yes" xml:space="preserve">
          <source>Interestingly, MS does not prescribe the two-argument version of &lt;code&gt;main()&lt;/code&gt; that the C and C++ standards require. It only prescribes a three argument form where the third argument is &lt;code&gt;char **envp&lt;/code&gt;, a pointer to a list of environment variables.</source>
          <target state="translated">흥미롭게도 MS는 C 및 C ++ 표준에 필요한 &lt;code&gt;main()&lt;/code&gt; 의 2 인수 버전을 규정하지 않습니다. 세 번째 인수가 환경 변수 목록에 대한 포인터 인 &lt;code&gt;char **envp&lt;/code&gt; 인 세 가지 인수 형식 만 규정합니다.</target>
        </trans-unit>
        <trans-unit id="067bd54d24cbf0d635c159524fc85653cf8d1376" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;char *envp[]&lt;/code&gt; as a third argument to &lt;code&gt;main()&lt;/code&gt; portable?</source>
          <target state="translated">&lt;code&gt;char *envp[]&lt;/code&gt; 가 &lt;code&gt;main()&lt;/code&gt; 의 세 번째 인수입니까?</target>
        </trans-unit>
        <trans-unit id="01cfa03c02ebf6b8044d17ebc260a7a7e23f1bc7" translate="yes" xml:space="preserve">
          <source>It also can be checked when you call a process yourself, and see if the program exited and finished properly.</source>
          <target state="translated">프로세스를 직접 호출 할 때도 확인할 수 있으며 프로그램이 종료되고 올바르게 완료되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="743cc09a1d17dd8e6d9ef3423b452c2f4c20a21e" translate="yes" xml:space="preserve">
          <source>It is also worth noting that in C++, &lt;code&gt;int main()&lt;/code&gt; can be left without a return-statement, at which point it defaults to returning 0. This is also true with a C99 program. Whether &lt;code&gt;return 0;&lt;/code&gt; should be omitted or not is open to debate. The range of valid C program main signatures is much greater.</source>
          <target state="translated">C ++에서, &lt;code&gt;int main()&lt;/code&gt; 은 return-statement없이 남겨질 수 있으며, 이때 기본적으로 0을 리턴합니다. 이것은 C99 프로그램에서도 마찬가지입니다. &lt;code&gt;return 0;&lt;/code&gt; 인지 여부 ; 토론을 생략하거나 공개하지 않아야합니다. 유효한 C 프로그램 기본 서명의 범위는 훨씬 큽니다.</target>
        </trans-unit>
        <trans-unit id="eba4f3e259ceb0adf19ace0c32c1391d84cbfe54" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether a program in a freestanding environment is required to define a main function.</source>
          <target state="translated">주요 기능을 정의하기 위해 독립 환경의 프로그램이 필요한지 여부는 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="3d63d53707bc8469db68ce1f74c203b133e06b93" translate="yes" xml:space="preserve">
          <source>It is not clear to me what happens (what exit code is returned to the parent or OS) when a program with &lt;code&gt;void main()&lt;/code&gt; does exit &amp;mdash; and the MS web site is silent too.</source>
          <target state="translated">&lt;code&gt;void main()&lt;/code&gt; 이있는 프로그램이 종료되고 MS 웹 사이트가 침묵 할 때 어떤 결과가 발생하는지 (부모 또는 OS로 종료 코드가 반환되는지) 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1b1f744a8f0f327fd7f8ac8646e483671c5281c" translate="yes" xml:space="preserve">
          <source>It is noticeable that the only header required of a freestanding environment that actually defines any functions is &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; (and even those may be &amp;mdash; and often are &amp;mdash; just macros).</source>
          <target state="translated">실제로 함수를 정의하는 독립형 환경에 필요한 유일한 헤더는 &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; (및 심지어 매크로 일 수도 있음)입니다.</target>
        </trans-unit>
        <trans-unit id="f0d85260bc0a36b034db5734d9715240a02623e7" translate="yes" xml:space="preserve">
          <source>It's &lt;strong&gt;NOT&lt;/strong&gt; just a programming convention.</source>
          <target state="translated">그것은 단지 프로그래밍 규칙이 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="777237599abc671bc567b78dd552b08e24fe0ff7" translate="yes" xml:space="preserve">
          <source>It's not what &lt;em&gt;should&lt;/em&gt;&lt;code&gt;main()&lt;/code&gt; return, it's what &lt;em&gt;does&lt;/em&gt;&lt;code&gt;main()&lt;/code&gt; return.  &lt;code&gt;main()&lt;/code&gt; is, of course, a function that someone else calls.  You don't have any control over the code that calls &lt;code&gt;main()&lt;/code&gt;.  Therefore, you must declare &lt;code&gt;main()&lt;/code&gt; with a type-correct signature to match its caller.  You simply don't have any choice in the matter.  You don't have to ask yourself what's more or less efficient, or what's better or worse style, or anything like that, because the answer is already perfectly well defined, for you, by the C and C+ standards.  Just follow them.</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 리턴 &lt;em&gt;해야하는&lt;/em&gt; 것이 아니라 &lt;code&gt;main()&lt;/code&gt; 리턴하는 것입니다. 물론 &lt;code&gt;main()&lt;/code&gt; 은 다른 사람이 호출하는 함수입니다. &lt;code&gt;main()&lt;/code&gt; 을 호출하는 코드를 제어 할 수 없습니다. 따라서 호출자와 일치하도록 형식이 올바른 서명으로 &lt;code&gt;main()&lt;/code&gt; 을 선언해야합니다. 당신은 단순히 문제에 대한 선택의 여지가 없습니다. C와 C + 표준에 의해 답이 이미 완벽하게 정의되어 있기 때문에 더 효율적이거나 덜 효율적인 것, 더 나쁘거나 나쁜 스타일 등을 스스로에게 묻지 않아도됩니다. 그냥 따라와</target>
        </trans-unit>
        <trans-unit id="ceda7d6ce3400641cfc2d2b305e73a181d717c83" translate="yes" xml:space="preserve">
          <source>J.5.1 Environment arguments</source>
          <target state="translated">J.5.1 환경 인수</target>
        </trans-unit>
        <trans-unit id="4646a05e59e1cdcc72d17eecf0ad0e9d72001305" translate="yes" xml:space="preserve">
          <source>Just as the C standard recognizes both hosted and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC 14882:2011.)</source>
          <target state="translated">C 표준이 호스팅 환경과 독립 환경을 모두 인식하는 것처럼 C ++ 표준도 인식합니다. (ISO / IEC 14882 : 2011의 인용문)</target>
        </trans-unit>
        <trans-unit id="1cf33a289910a38b27ccf6fc406b6febbdf1f1a7" translate="yes" xml:space="preserve">
          <source>Keep in mind that,even though you're returning an int, some OSes (Windows) truncate the returned value to a single byte (0-255).</source>
          <target state="translated">int를 반환하더라도 일부 OS (Windows)는 반환 된 값을 단일 바이트 (0-255)로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="52e3d5ebdbc06938d8f3e9175e5789910e8284cc" translate="yes" xml:space="preserve">
          <source>Legal definitions of &lt;code&gt;main()&lt;/code&gt; in C++14?</source>
          <target state="translated">C ++ 14에서 &lt;code&gt;main()&lt;/code&gt; 의 법적 정의?</target>
        </trans-unit>
        <trans-unit id="82be7a55804dc08de0168f6f592f149c8a430e44" translate="yes" xml:space="preserve">
          <source>Microsoft C</source>
          <target state="translated">마이크로 소프트 C</target>
        </trans-unit>
        <trans-unit id="73d9e90f1eeed7db4c1746200a40ba2e4ac70074" translate="yes" xml:space="preserve">
          <source>Must the &lt;code&gt;int main()&lt;/code&gt; function return a value in all compilers?</source>
          <target state="translated">&lt;code&gt;int main()&lt;/code&gt; 함수가 모든 컴파일러에서 값을 반환해야합니까?</target>
        </trans-unit>
        <trans-unit id="2e35d4f77f18bcad3aefd139f948af15aa758b72" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;0&lt;/code&gt; is mandated as 'success'. You can use &lt;code&gt;EXIT_FAILURE&lt;/code&gt; and &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; from &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; if you prefer, but 0 is well established, and so is 1. See also &lt;a href=&quot;https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/&quot;&gt;Exit codes greater than 255 &amp;mdash; possible?&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 은 '성공'으로 의무화됩니다. 원하는 경우 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 및 EXIT_SUCCESS 를 사용할 수 있지만 0은 제대로 설정되어 있으며 1도 마찬가지입니다. 참조 &lt;a href=&quot;https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/&quot;&gt;255보다 큰 종료 코드 &amp;ndash; 가능합니까?&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc19499ce0cd6befeb6d4ac0455d6a31e63efae2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;int main()&lt;/code&gt; was never listed as a valid form for any hosted implementation of C in any of the above versions. In C, unlike C++, &lt;code&gt;()&lt;/code&gt; and &lt;code&gt;(void)&lt;/code&gt; have different meanings. The former is an obsolescent feature which may be removed from the language. See C11 future language directions:</source>
          <target state="translated">&lt;code&gt;int main()&lt;/code&gt; 은 위의 버전에서 호스팅 된 C 구현에 유효한 형식으로 나열되지 않았습니다. C에서 C ++와 달리 &lt;code&gt;()&lt;/code&gt; 와 &lt;code&gt;(void)&lt;/code&gt; 는 다른 의미를 갖습니다. 전자는 언어에서 제거 될 수있는 더 이상 사용되지 않는 기능입니다. C11 향후 언어 지시 사항 참조 :</target>
        </trans-unit>
        <trans-unit id="2a43cb795cc790685cb419ee571a160ade1ccb63" translate="yes" xml:space="preserve">
          <source>Note that the C and C++ standards define two kinds of implementations: freestanding and hosted.</source>
          <target state="translated">C 및 C ++ 표준은 독립형 및 호스팅의 두 가지 구현 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="99eaa646b7b6e0082dbd4a6adae2c494f9eec0c8" translate="yes" xml:space="preserve">
          <source>Note the empty parenthesis in the first form. C++ and C are different in this case, because in C++ this means that the function takes no parameters. But in C it means that it may take any parameter.</source>
          <target state="translated">첫 번째 양식의 빈 괄호에 유의하십시오. 이 경우 C ++과 C는 다릅니다. C ++에서는 함수가 매개 변수를 사용하지 않기 때문입니다. 그러나 C에서는 매개 변수를 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="546cad710ccd581eadc450a0c74833e5bcaa545e" translate="yes" xml:space="preserve">
          <source>Now the following bash script (simply type it in a Linux terminal) although very basic should give some idea of error handling:</source>
          <target state="translated">매우 기본적인 것이지만 오류 처리에 대한 아이디어를 제공해야하지만 이제 다음 bash 스크립트 (Linux 터미널에 간단히 입력하십시오) :</target>
        </trans-unit>
        <trans-unit id="bb080a0718df6542d4433b03a9323560b055bb4d" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;return 0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return 0&lt;/code&gt; 생략</target>
        </trans-unit>
        <trans-unit id="71453973d6cd4b7d6dce02765e1aeb2c794927d7" translate="yes" xml:space="preserve">
          <source>Or equivalent. For example, &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt; is equivalent to the second one. Further, the &lt;code&gt;int&lt;/code&gt; return type can be omitted as it is a default.</source>
          <target state="translated">또는 동등한 것. 예를 들어, &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt; 는 두 번째 것과 같습니다. 또한 &lt;code&gt;int&lt;/code&gt; return 유형은 기본값이므로 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b4a599777a8efd1033fda40d60a3ac6da68728f" translate="yes" xml:space="preserve">
          <source>Program termination in C99 or C11</source>
          <target state="translated">C99 또는 C11에서 프로그램 종료</target>
        </trans-unit>
        <trans-unit id="663f993e9b4f3d44ef4c0329debae8aeebbf12e3" translate="yes" xml:space="preserve">
          <source>Rationale for International Standard &amp;mdash; Programming Languages &amp;mdash; C, Revision 5.10. 5.1.2.2 Hosted environment --&amp;gt; 5.1.2.2.1 Program startup</source>
          <target state="translated">국제 표준의 이론적 근거 &amp;mdash; 프로그래밍 언어 &amp;mdash; C, 개정판 5.10. 5.1.2.2 호스팅 환경-&amp;gt; 5.1.2.2.1 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="06951cda41c4c25e07384cc2d791df8051ddc4f0" translate="yes" xml:space="preserve">
          <source>Return 0 on success and non-zero for error. This is the standard used by UNIX and DOS scripting to find out what happened with your program.</source>
          <target state="translated">성공하면 0을, 에러는 0이 아닌 값을 반환합니다. 이것은 UNIX 및 DOS 스크립팅에서 프로그램에서 발생한 문제를 찾기 위해 사용하는 표준입니다.</target>
        </trans-unit>
        <trans-unit id="c25bf9ecf87e37204aff4b7cbc681350ca825d5e" translate="yes" xml:space="preserve">
          <source>Return type of &lt;code&gt;main()&lt;/code&gt; method in C</source>
          <target state="translated">C에서 &lt;code&gt;main()&lt;/code&gt; 메소드의 리턴 유형</target>
        </trans-unit>
        <trans-unit id="3675c5cbc8a91d96194988edd341f2880e76b8d4" translate="yes" xml:space="preserve">
          <source>Return value 0 usually means OK in most operating systems (the ones I can think of anyway).</source>
          <target state="translated">반환 값 0은 대개 대부분의 운영 체제 (어쨌든 생각할 수있는 운영 체제)에서 OK를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7e87f801e2a286959cf6dbceaaf5200c563638ca" translate="yes" xml:space="preserve">
          <source>Returning 0 should tell the programmer that the program has successfully finished the job.</source>
          <target state="translated">0을 리턴하면 프로그램이 작업을 성공적으로 완료했음을 프로그래머에게 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="d0d3720869171e755af6d0b0e9c8fa9c47bded55" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/q/8626109/775964&quot;&gt;How can I get what my main function has returned?&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/8626109/775964&quot;&gt;주 함수가 반환 한 것을 어떻게 얻을 수 있습니까?를&lt;/a&gt; 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="58c7663db54efd33586550979f6f35585936911c" translate="yes" xml:space="preserve">
          <source>Since grep failed to match the token &quot;foo&quot; with the content of our file the return code is 1 (this is the usual case when a failure occurs but as stated above you have plenty of values to choose from).</source>
          <target state="translated">grep이 파일 &quot;foo&quot;와 토큰 &quot;foo&quot;를 일치시키는 데 실패했기 때문에 리턴 코드는 1입니다 (실패한 경우는 일반적이지만 위와 같이 선택할 수있는 값이 많습니다).</target>
        </trans-unit>
        <trans-unit id="58e729ae862197d2b4b8edf3be6c045cd942acef" translate="yes" xml:space="preserve">
          <source>So I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you'll know that it's explicitly supported by the standard and you'll know what it means.</source>
          <target state="translated">그래서 나는 그것을 생략하는 것을 옹호합니다. 어떤 경우에는 코드를 생략하는 코드가 발견되면 표준에서 명시 적으로 지원되고 코드의 의미를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="191c9d7581d1bc67cbc4954e3995712f84c74941" translate="yes" xml:space="preserve">
          <source>Some compilers have chosen to interpret the standard in the latter way. Arguably, one cannot easily state that they are not strictly conforming by citing the standard in itself, since it is is ambiguous.</source>
          <target state="translated">일부 컴파일러는 후자의 방식으로 표준을 해석하기로 선택했습니다. 의심 할 여지없이, 표준 자체가 모호하기 때문에 표준 자체를 인용하여 엄격하게 준수하지 않는다고 쉽게 말할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f98b7a7fbe66aa30604d46c9c186df5e7d476f7a" translate="yes" xml:space="preserve">
          <source>Standard C &amp;mdash; Common Extension</source>
          <target state="translated">표준 C &amp;mdash; 공통 확장</target>
        </trans-unit>
        <trans-unit id="559fce21984836e0b4c09f404ccadb796a238608" translate="yes" xml:space="preserve">
          <source>Standard C &amp;mdash; Freestanding Environment</source>
          <target state="translated">표준 C &amp;mdash; 독립형 환경</target>
        </trans-unit>
        <trans-unit id="bf0058befe2fe0784752a61367cd774b2170e902" translate="yes" xml:space="preserve">
          <source>Standard C &amp;mdash; Hosted Environment</source>
          <target state="translated">표준 C &amp;mdash; 호스팅 환경</target>
        </trans-unit>
        <trans-unit id="ead9983c448c82a4bc2e4fa329267dd58510e74c" translate="yes" xml:space="preserve">
          <source>Standard C++ &amp;mdash; Freestanding Environment</source>
          <target state="translated">표준 C ++ &amp;mdash; 독립형 환경</target>
        </trans-unit>
        <trans-unit id="17c880ba258c61c1f081e4f92072401258328c3f" translate="yes" xml:space="preserve">
          <source>Standard C++ &amp;mdash; Hosted Environment</source>
          <target state="translated">표준 C ++ &amp;mdash; 호스팅 환경</target>
        </trans-unit>
        <trans-unit id="9e9bfc97678e1deb8fecca963cb28baa3742ac8f" translate="yes" xml:space="preserve">
          <source>Styles of &lt;code&gt;main()&lt;/code&gt; functions in C</source>
          <target state="translated">C의 &lt;code&gt;main()&lt;/code&gt; 함수 스타일</target>
        </trans-unit>
        <trans-unit id="c32251a4dd807171928d97ccdcdf5412b6e1b584" translate="yes" xml:space="preserve">
          <source>Table 16 &amp;mdash; C++ headers for freestanding implementations</source>
          <target state="translated">표 16 &amp;mdash; 독립형 구현을위한 C ++ 헤더</target>
        </trans-unit>
        <trans-unit id="0b88a0ea077a1c835e53dcb3e5afe37a4a6880f1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx&quot;&gt;Microsoft VS 2010&lt;/a&gt; compiler is interesting. The web site says:</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx&quot;&gt;Microsoft VS 2010&lt;/a&gt; 컴파일러는 흥미 롭습니다. 웹 사이트는 말합니다 :</target>
        </trans-unit>
        <trans-unit id="8364d6bdc8c6440426e1ae40049191ae42429996" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; return type may not be omitted.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; return 유형은 생략 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1cf16e3e7d80a6df169adb6cfe5d5a70bd761eb9" translate="yes" xml:space="preserve">
          <source>The C++ standard explicitly says &quot;It [the main function] shall have a return type of type &lt;code&gt;int&lt;/code&gt;, but otherwise its type is implementation defined&quot;, and requires the same two signatures as the C standard to be supported as options. So a 'void main()' is directly not allowed by the C++ standard, though there's nothing it can do to stop a non-standard implementation allowing alternatives.  Note that C++ forbids the user from calling &lt;code&gt;main&lt;/code&gt; (but the C standard does not).</source>
          <target state="translated">C ++ 표준은 명시 적으로 &quot;[주 함수]는 &lt;code&gt;int&lt;/code&gt; 유형의 리턴 유형을 가져야하지만 그렇지 않은 경우 유형이 구현 정의됩니다&quot;라고 명시하고 C 표준과 동일한 두 서명을 옵션으로 지원해야합니다. 따라서 'void main ()'은 C ++ 표준에서 직접 허용되지 않지만 대안을 허용하는 비표준 구현을 중지하는 방법은 없습니다. C ++는 사용자가 &lt;code&gt;main&lt;/code&gt; 을 호출하는 것을 금지합니다 (그러나 C 표준은 그렇지 않습니다).</target>
        </trans-unit>
        <trans-unit id="8ffaebd7ec7fa463926f599cf1254982eb713376" translate="yes" xml:space="preserve">
          <source>The C++11 standard (ISO/IEC 14882:2011) says:</source>
          <target state="translated">C ++ 11 표준 (ISO / IEC 14882 : 2011)은 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="4a496911a1450193efc097e191321a84e102d3d2" translate="yes" xml:space="preserve">
          <source>The Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2005&lt;/a&gt; version of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx&quot;&gt;this page&lt;/a&gt; does not list &lt;code&gt;void main()&lt;/code&gt; as an alternative.  The &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx&quot;&gt;versions&lt;/a&gt; from Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2008&lt;/a&gt; onwards do.</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx&quot;&gt;이 페이지&lt;/a&gt; 의 Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005&quot;&gt;Visual Studio 2005&lt;/a&gt; 버전은 &lt;code&gt;void main()&lt;/code&gt; 을 대안으로 나열하지 않습니다. Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008&quot;&gt;Visual Studio 2008&lt;/a&gt; 이후 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx&quot;&gt;버전도&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="33cca83a9e2b339c3446cbab746394360baf8d65" translate="yes" xml:space="preserve">
          <source>The Microsoft page also lists some other alternatives &amp;mdash; &lt;code&gt;wmain()&lt;/code&gt; which takes wide character strings, and some more.</source>
          <target state="translated">또한 Microsoft 페이지에는 다른 대체 옵션 인 &lt;code&gt;wmain()&lt;/code&gt; 포함되어 있으며 넓은 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7b0070d4ea6e95a967d24e8102c2d33f422b3fe2" translate="yes" xml:space="preserve">
          <source>The accepted answer appears to be targetted for C++, so I thought I'd add an answer that pertains to C, and this differs in a few ways.</source>
          <target state="translated">허용 된 답변은 C ++을 대상으로하는 것으로 보이므로 C와 관련된 답변을 추가 할 것이라고 생각했는데 몇 가지면에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="546b26c20b5018e8e91b597a6abc305d7ad960ec" translate="yes" xml:space="preserve">
          <source>The behavior of the arguments to main, and of the interaction of exit, main and atexit
  (see &amp;sect;7.20.4.2) has been codified to curb some unwanted variety in the representation of argv
  strings, and in the meaning of values returned by main.</source>
          <target state="translated">main에 대한 인수의 동작과 exit, main 및 atexit의 상호 작용 (&amp;sect;7.20.4.2 참조)의 동작은 argv 문자열의 표현과 main이 반환 한 값의 의미에서 원하지 않는 다양성을 억제하기 위해 체계화되었습니다.</target>
        </trans-unit>
        <trans-unit id="a1332b3e9a470eb6ea2ea721bb6e42f19fd7ef60" translate="yes" xml:space="preserve">
          <source>The cross-reference to clause 4 Conformance refers to this:</source>
          <target state="translated">조항 4 적합성에 대한 상호 참조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc11d899a2bbef6b7ca7ebc05f3a76f63e6b3145" translate="yes" xml:space="preserve">
          <source>The declaration syntax for main is</source>
          <target state="translated">main의 선언 구문은</target>
        </trans-unit>
        <trans-unit id="54d077d6bc220b344cc0c2c98d6bff99a69286f5" translate="yes" xml:space="preserve">
          <source>The effect of program termination in a freestanding environment is implementation-defined.</source>
          <target state="translated">독립 환경에서 프로그램 종료의 효과는 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d7cf7c56944bc0e60c66b4dd6a3630c1023a7db0" translate="yes" xml:space="preserve">
          <source>The former two are explicitly stated as the allowed forms, the others are implicitly allowed because C90 allowed &quot;implicit int&quot; for return type and function parameters. No other form is allowed.</source>
          <target state="translated">앞의 두 개는 허용 된 형식으로 명시 적으로 언급되어 있으며, C90은 리턴 유형 및 함수 매개 변수에 &quot;implicit int&quot;를 허용하므로 다른 것은 내재적으로 허용됩니다. 다른 형식은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="026f98c964de0d94f5fb9b6a1e303e50bcc1cdd6" translate="yes" xml:space="preserve">
          <source>The function called at program startup is named &lt;code&gt;main&lt;/code&gt;. The implementation declares no
  prototype for this function. It shall be defined with a return type of &lt;code&gt;int&lt;/code&gt; and with no
  parameters:</source>
          <target state="translated">프로그램 시작시 호출되는 함수의 이름은 &lt;code&gt;main&lt;/code&gt; 입니다. 구현은이 함수에 대한 프로토 타입을 선언하지 않습니다. 반환 유형은 &lt;code&gt;int&lt;/code&gt; 이며 매개 변수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca5968af6b9e074a35418f4f286474743cccbd2c" translate="yes" xml:space="preserve">
          <source>The function called at program startup is named main. The
  implementation declares no prototype for this function. It shall be
  defined with a return type of int and with no parameters:</source>
          <target state="translated">프로그램 시작시 호출되는 기능의 이름은 main입니다. 구현은이 함수에 대한 프로토 타입을 선언하지 않습니다. 반환 유형은 int이며 매개 변수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ae03504835ac4c96ab05373731aeafea22c07c0" translate="yes" xml:space="preserve">
          <source>The name of the function called at startup is implementation-defined. If it is named &lt;code&gt;main()&lt;/code&gt; it must follow the stated forms &lt;sup&gt;10&lt;/sup&gt;:</source>
          <target state="translated">시작시 호출 된 함수의 이름은 구현 정의됩니다. 이름이 &lt;code&gt;main()&lt;/code&gt; 이면 명시된 양식 &lt;sup&gt;10을&lt;/sup&gt; 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="42cedb16b5fd329909d8d618d881e9149d7c8ddf" translate="yes" xml:space="preserve">
          <source>The name of the function called at startup is implementation-defined. If it is named &lt;code&gt;main()&lt;/code&gt; it must follow the stated forms &lt;sup&gt;12&lt;/sup&gt;:</source>
          <target state="translated">시작시 호출 된 함수의 이름은 구현 정의됩니다. 이름이 &lt;code&gt;main()&lt;/code&gt; 이면 명시된 양식 &lt;sup&gt;12를&lt;/sup&gt; 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="f411eabfea18f4d722bb32c090c81895998e01e5" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; and the strings pointed to by the &lt;code&gt;argv&lt;/code&gt; array shall
  be modifiable by the program, and retain their last-stored values between program
  startup and program termination.</source>
          <target state="translated">매개 변수 &lt;code&gt;argc&lt;/code&gt; 및 &lt;code&gt;argv&lt;/code&gt; 와 &lt;code&gt;argv&lt;/code&gt; 배열이 가리키는 문자열은 프로그램에 의해 수정 가능해야하며 프로그램 시작과 프로그램 종료 사이에 마지막으로 저장된 값을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="71f2b4381bd48e53fc5bf7bb37600cda30ef7a72" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;main()&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 함수의 반환 유형</target>
        </trans-unit>
        <trans-unit id="30c22afa61a69f090f04a4b51d6f0da94397dc2d" translate="yes" xml:space="preserve">
          <source>The return value can be used by the operating system to check how the program was closed.</source>
          <target state="translated">운영 체제에서 리턴 값을 사용하여 프로그램 종료 방법을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba1f12ca047f8d89e6d47cc78475d9dc71642ebe" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;main&lt;/code&gt; indicates how the program exited. Normal exit is represented by a 0 return value from &lt;code&gt;main&lt;/code&gt;. Abnormal exit is signaled by a non-zero return, but there is no standard for how non-zero codes are interpreted. As noted by others, &lt;code&gt;void main()&lt;/code&gt; is prohibited by the C++ standard and should not be used. The valid C++ &lt;code&gt;main&lt;/code&gt; signatures are:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 의 리턴 값은 프로그램 종료 방법을 나타냅니다. 일반 종료는 &lt;code&gt;main&lt;/code&gt; 의 0 반환 값으로 표시됩니다. 비정상 종료는 0이 아닌 리턴에 의해 표시되지만 0이 아닌 코드를 해석하는 방법에 대한 표준은 없습니다. 다른 사람들이 지적했듯이 &lt;code&gt;void main()&lt;/code&gt; 은 C ++ 표준에서 금지되어 있으므로 사용해서는 안됩니다. 유효한 C ++ &lt;code&gt;main&lt;/code&gt; 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22dbe4ab7277e0bacb463020855fe29f4a135940" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;main()&lt;/code&gt; shows how the program exited. If the return value is &lt;code&gt;zero&lt;/code&gt; it means that the execution was successful while any non-zero value will represent that something went bad in the execution.</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 의 반환 값은 프로그램이 어떻게 종료되었는지 보여줍니다. 반환 값이 &lt;code&gt;zero&lt;/code&gt; 이면 실행이 성공한 반면 0이 아닌 값은 실행에 문제가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e22ad7a310bc1d275667315bd2dea731a9a4ebdc" translate="yes" xml:space="preserve">
          <source>The specification of argc and argv as arguments to main recognizes extensive prior practice.
  argv[argc] is required to be a null pointer to provide a redundant check for the end of the list, also on the basis of common practice.</source>
          <target state="translated">main에 대한 인수로 argc 및 argv를 지정하면 광범위한 사전 실습이 인식됩니다. argv [argc]는 목록의 끝 부분에 대한 중복 검사를 제공하고 일반적인 관행에 따라 널 포인터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8e2e310f8d276bce8425174414a371db8d39f43f" translate="yes" xml:space="preserve">
          <source>The standard &amp;sect;5.1.2.2.1 of the C11 standard shows the preferred notation &amp;mdash;&amp;nbsp;&lt;code&gt;int main(void)&lt;/code&gt; &amp;mdash; but there are also two examples in the standard which show &lt;code&gt;int main()&lt;/code&gt;: &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8&quot;&gt;&amp;sect;6.5.3.4 &amp;para;8&lt;/a&gt; and &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20&quot;&gt;&amp;sect;6.7.6.3 &amp;para;20&lt;/a&gt;.  Now, it is important to note that examples are not 'normative'; they are only illustrative.  If there are bugs in the examples, they do not directly affect the main text of the standard.  That said, they are strongly indicative of expected behaviour, so if the standard includes &lt;code&gt;int main()&lt;/code&gt; in an example, it suggests that &lt;code&gt;int main()&lt;/code&gt; is not forbidden, even if it is not the preferred notation.</source>
          <target state="translated">C11 표준의 표준 &amp;sect;5.1.2.2.1은 선호 표기법 &lt;code&gt;int main(void)&lt;/code&gt; 하지만 표준에는 &lt;code&gt;int main()&lt;/code&gt; 을 표시하는 두 가지 예가 있습니다. &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8&quot;&gt;&amp;sect;6.5.3.4 &amp;para;8&lt;/a&gt; 및 &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20&quot;&gt;&amp;sect;6.7.6.3 &amp;para;20&lt;/a&gt; . 이제 예제는 '규범 적'이 아니라는 점에 유의해야합니다. 그들은 단지 예시 일 뿐이다. 예제에 버그가 있으면 표준 본문에 직접 영향을 미치지 않습니다. 즉, 예상되는 동작을 강력하게 나타내므로 표준에 예제에 &lt;code&gt;int main()&lt;/code&gt; 이 포함되어 있으면 선호되는 표기법이 아니더라도 int main () 이 금지되지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="21097dd912cf311cfdb6f22df1d0503ba8d3b181" translate="yes" xml:space="preserve">
          <source>The standard defines 3 values for returning that are strictly conforming (that is, does not rely on implementation defined behaviour): &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; for a successful termination, and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; for an unsuccessful termination. Any other values are non-standard and implementation defined. &lt;code&gt;main()&lt;/code&gt; must have an explicit &lt;code&gt;return&lt;/code&gt; statement at the end to avoid undefined behaviour.</source>
          <target state="translated">표준은 엄격하게 준수하는 (즉, 정의 된 구현 동작에 의존하지 않음) 리턴을위한 3 개의 값을 정의합니다. 성공적인 종료의 경우 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; , 종료 실패의 경우 EXIT_FAILURE 다른 값은 비표준이며 구현이 정의되어 있습니다. &lt;code&gt;main()&lt;/code&gt; 에는 정의되지 않은 동작을 피하기 위해 끝에 명시적인 &lt;code&gt;return&lt;/code&gt; 문이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="04c357fe47330fd474b14115ca9a3a38ddbd2e54" translate="yes" xml:space="preserve">
          <source>The supplied version of the header &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; shall declare at least the functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;atexit&lt;/code&gt;, &lt;code&gt;at_quick_exit&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;quick_exit&lt;/code&gt; (18.5). The other headers listed in this table shall meet the same requirements as for a hosted implementation.</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; 의 제공된 버전은 최소한 함수 &lt;code&gt;abort&lt;/code&gt; , &lt;code&gt;atexit&lt;/code&gt; , &lt;code&gt;at_quick_exit&lt;/code&gt; , &lt;code&gt;exit&lt;/code&gt; 및 &lt;code&gt;quick_exit&lt;/code&gt; (18.5)를 선언해야합니다. 이 표에 나열된 다른 헤더는 호스팅 된 구현과 동일한 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="215b83b15446fc6e768d7de47de3d64d6250e81c" translate="yes" xml:space="preserve">
          <source>The text of the standard has been changed but it has the same meaning.</source>
          <target state="translated">표준의 텍스트가 변경되었지만 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3a96141f4a269d89eae9927fca95e222c0774ce2" translate="yes" xml:space="preserve">
          <source>The third argument is a null-terminated list of pointers to strings, each of which is an environment variable which has a name, an equals sign, and a value (possibly empty).  If you do not use this, you can still get at the environment via '&lt;code&gt;extern char **environ;&lt;/code&gt;'.  This global variable is unique among those in POSIX in that it does not have a header that declares it.</source>
          <target state="translated">세 번째 인수는 null로 끝나는 문자열에 대한 포인터 목록으로, 각각 이름, 등호 및 값 (비어있을 수 있음)을 갖는 환경 변수입니다. 이것을 사용하지 않으면 여전히 &lt;code&gt;extern char **environ;&lt;/code&gt; '. 이 전역 변수는이를 선언하는 헤더가 없다는 점에서 POSIX의 변수 중에서 고유합니다.</target>
        </trans-unit>
        <trans-unit id="f1917f923748d24954167ac87cbedac4efe8c562" translate="yes" xml:space="preserve">
          <source>The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.</source>
          <target state="translated">빈 괄호 (프로토 타입 형식 매개 변수 유형 선언자가 아님)와 함께 함수 선언자를 사용하는 것은 더 이상 사용되지 않는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="1e1d1d4c80a34abbd78d532e533e8e32a26baa46" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;argc&lt;/code&gt; shall be nonnegative.</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 의 값은 음이 아니 어야합니다.</target>
        </trans-unit>
        <trans-unit id="3b6837137519a235145649ca26f22f77d0ac5ffc" translate="yes" xml:space="preserve">
          <source>The value returned from &lt;code&gt;main()&lt;/code&gt; is transmitted to the 'environment' in an implementation-defined way.</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 에서 반환 된 값은 구현 정의 방식으로 '환경'으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ca8a9e03a294ed095d6a449285082fc38a13cce6" translate="yes" xml:space="preserve">
          <source>There's a paragraph of &amp;sect;18.5 &lt;strong&gt;Start and termination&lt;/strong&gt; in the C++11 standard that is identical to the paragraph from &amp;sect;7.22.4.4 &lt;strong&gt;The &lt;code&gt;exit&lt;/code&gt; function&lt;/strong&gt; in the C11 standard (quoted above), apart from a footnote (which simply documents that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; are defined in &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">C ++ 11 표준에는 &amp;sect;7.22.4.4의 단락과 동일한 &amp;sect;18.5 &lt;strong&gt;시작 및 종료&lt;/strong&gt; 단락 &lt;strong&gt;이&lt;/strong&gt; 있습니다. 각주와 별도로 C11 표준 &lt;strong&gt;의 &lt;code&gt;exit&lt;/code&gt; 기능&lt;/strong&gt; (위에 인용)은 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 및 &lt;code&gt;EXIT_FAILURE&lt;/code&gt; 는 &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; 에 정의되어 있습니다).</target>
        </trans-unit>
        <trans-unit id="8878897f94a88e2eb0a72b92a1a8eea14341dd7c" translate="yes" xml:space="preserve">
          <source>This is recognized by the C standard as a common extension, documented in Annex J:</source>
          <target state="translated">이는 C 표준에 의해 부록 J에 문서화 된 공통 확장명으로 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="90c926db372e34ff57f910bfc2a6bb307fd78475" translate="yes" xml:space="preserve">
          <source>This is some example in order to check how grep works.</source>
          <target state="translated">grep의 작동 방식을 확인하기위한 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="d9135e4649a5add9899348971cdf27790adec503" translate="yes" xml:space="preserve">
          <source>This section is identical to the C++03 one cited above.</source>
          <target state="translated">이 섹션은 위에서 인용 한 C ++ 03과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="aff26f54c08ac6a220e320cf88a1cc85885f4a3d" translate="yes" xml:space="preserve">
          <source>This section is identical to the C99 one cited above.</source>
          <target state="translated">이 섹션은 위에서 언급 한 C99와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="492f852c402b8701a3d8ac1e786125fd366f3983" translate="yes" xml:space="preserve">
          <source>This way you can see that it is the variable &lt;code&gt;$?&lt;/code&gt; which receives the least significant byte of the return value of &lt;code&gt;main()&lt;/code&gt;.</source>
          <target state="translated">이런 식으로 변수 &lt;code&gt;$?&lt;/code&gt; 라는 것을 알 수 있습니다 . &lt;code&gt;main()&lt;/code&gt; 반환 값의 최하위 바이트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="083f523a48b50dec805c4b80d1381d0a4f4fa86b" translate="yes" xml:space="preserve">
          <source>Those words &quot;(most efficient)&quot; don't change the question.  Unless you're in a freestanding environment, there is one universally correct way to declare &lt;code&gt;main()&lt;/code&gt;, and that's as returning int.</source>
          <target state="translated">&quot;(가장 효율적)&quot;이라는 단어는 질문을 바꾸지 않습니다. 독립 환경에 있지 않는 한 &lt;code&gt;main()&lt;/code&gt; 을 선언하는 보편적으로 올바른 방법이 있으며 int를 반환하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd1d619c61e03e7c3983d9cf6e51c9a460b55ae1" translate="yes" xml:space="preserve">
          <source>Two execution environments are defined: freestanding and hosted. In both cases,
  program startup occurs when a designated C function is called by the execution
  environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.</source>
          <target state="translated">독립형 및 호스팅의 두 가지 실행 환경이 정의됩니다. 두 경우 모두, 지정된 C 함수가 실행 환경에 의해 호출 될 때 프로그램 시작이 발생합니다. 정적 저장 기간을 가진 모든 객체는 프로그램 시작 전에 초기화되어야합니다 (초기 값으로 설정). 그러한 초기화의 방식 및 타이밍은 달리 명시되지 않는다. 프로그램 종료는 제어를 실행 환경으로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="7e6d901cc3741eac5e0d54d5f5f6b0f0c7091f78" translate="yes" xml:space="preserve">
          <source>Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this International Standard describes the set of available headers.</source>
          <target state="translated">호스팅 및 독립 실행 형 (1.4)의 두 가지 구현이 정의됩니다. 호스팅 된 구현의 경우이 국제 표준은 사용 가능한 헤더 세트를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c8ffe25090b0726f102193ed465ce10faae40214" translate="yes" xml:space="preserve">
          <source>What about using &lt;code&gt;int main()&lt;/code&gt; in C?</source>
          <target state="translated">C에서 &lt;code&gt;int main()&lt;/code&gt; 을 사용하는 것은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="8db9388f551bf79763f6d366a53d00645a18b452" translate="yes" xml:space="preserve">
          <source>What are the valid signatures for C's &lt;code&gt;main()&lt;/code&gt; function?</source>
          <target state="translated">C의 &lt;code&gt;main()&lt;/code&gt; 함수에 유효한 서명은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e375a0bb38b5733f5e33aea178300914bf1fc13b" translate="yes" xml:space="preserve">
          <source>What is the correct (most efficient) way to define the &lt;code&gt;main()&lt;/code&gt; function in C and C++ &amp;mdash; &lt;code&gt;int main()&lt;/code&gt; or &lt;code&gt;void main()&lt;/code&gt; &amp;mdash; and why? 
If &lt;code&gt;int main()&lt;/code&gt; then &lt;code&gt;return 1&lt;/code&gt; or &lt;code&gt;return 0&lt;/code&gt;?</source>
          <target state="translated">C 및 C ++에서 &lt;code&gt;main()&lt;/code&gt; 함수를 정의하는 올바른 (가장 효율적인) 방법은 무엇입니까? &lt;code&gt;int main()&lt;/code&gt; 또는 &lt;code&gt;void main()&lt;/code&gt; &amp;mdash; 그 이유는 무엇입니까? &lt;code&gt;int main()&lt;/code&gt; 이면 &lt;code&gt;return 1&lt;/code&gt; 을 반환 하거나 &lt;code&gt;return 0&lt;/code&gt; 합니까?</target>
        </trans-unit>
        <trans-unit id="ac7910d8738d0f6edbbbc837537320cc7243db50" translate="yes" xml:space="preserve">
          <source>What is the correct (most efficient) way to define the main() function in C and C++ &amp;mdash; int main() or void main() &amp;mdash; and why?</source>
          <target state="translated">C 및 C ++에서 main () 함수를 정의하는 올바른 (가장 효율적인) 방법은 무엇입니까? int main () 또는 void main () &amp;mdash; 그 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b6fa6e7eb3c56c5443ca329d417a88f4f68960be" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;main()&lt;/code&gt; return in C and C++?</source>
          <target state="translated">C와 C ++에서 &lt;code&gt;main()&lt;/code&gt; 은 무엇을 반환해야합니까?</target>
        </trans-unit>
        <trans-unit id="486019aa245ddcb5e5499f2b26db2df46e934c65" translate="yes" xml:space="preserve">
          <source>What should main() return in C and C++</source>
          <target state="translated">C와 C ++에서 main ()이 반환해야 할 것</target>
        </trans-unit>
        <trans-unit id="30ef05539959ff243c4e180d8cd581aaf97379b0" translate="yes" xml:space="preserve">
          <source>What to return depends on what you want to do with the executable. For example if you are using your program with a command line shell, then you need to return 0 for a success and a non zero for failure. Then you would be able to use the program in shells with conditional processing depending on the outcome of your code. Also you can assign any nonzero value as per your interpretation, for example for critical errors different program exit points could terminate a program with different exit values , and which is available to the calling shell which can decide what to do by inspecting the value returned.
If the code is not intended for use with shells and the returned value does not bother anybody then it might be omitted. I personally use the signature &lt;code&gt;int main (void) { .. return 0; .. }&lt;/code&gt;</source>
          <target state="translated">반환 할 내용은 실행 파일로 수행하려는 작업에 따라 다릅니다. 예를 들어 명령 줄 셸과 함께 프로그램을 사용하는 경우 성공하면 0을, 실패하면 0이 아닌 값을 반환해야합니다. 그런 다음 코드 결과에 따라 조건부 처리를 사용하여 쉘에서 프로그램을 사용할 수 있습니다. 또한 해석에 따라 0이 아닌 값을 할당 할 수 있습니다 (예 : 중대한 오류의 경우 다른 프로그램 종료 지점이 다른 종료 값을 가진 프로그램을 종료 할 수 있으며 리턴 된 값을 검사하여 수행 할 조치를 결정할 수있는 호출 쉘에서 사용 가능). 코드가 쉘과 함께 사용되지 않고 리턴 된 값이 아무 것도 방해하지 않으면 생략 될 수 있습니다. 나는 개인적으로 서명 &lt;code&gt;int main (void) { .. return 0; .. }&lt;/code&gt; ..}</target>
        </trans-unit>
        <trans-unit id="23877bc0573cb6974d91820ac2c5704526b909c4" translate="yes" xml:space="preserve">
          <source>When a C or C++ program reaches the end of &lt;code&gt;main&lt;/code&gt; the compiler will automatically generate code to return 0, so there is no need to put &lt;code&gt;return 0;&lt;/code&gt; explicitly at the end of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">C 또는 C ++ 프로그램이 &lt;code&gt;main&lt;/code&gt; 의 끝에 도달하면 컴파일러는 0을 리턴하는 코드를 자동으로 생성하므로 &lt;code&gt;return 0;&lt;/code&gt; 을 넣을 필요가 없습니다 . &lt;code&gt;main&lt;/code&gt; 의 끝에 명시 적으로.</target>
        </trans-unit>
        <trans-unit id="c0ff9c6d19528fc5ecbf1d4fd6390af8df49063b" translate="yes" xml:space="preserve">
          <source>When using the various tools that the Linux terminal provides one can use the return code for example for error handling after the process has been completed. Imagine that the following text file myfile is present:</source>
          <target state="translated">Linux 터미널이 제공하는 다양한 도구를 사용하는 경우 프로세스가 완료된 후 오류 처리를 위해 리턴 코드를 사용할 수 있습니다. 다음 텍스트 파일 myfile이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed64c1ea746c88bec38d149c99f20765bec153b" translate="yes" xml:space="preserve">
          <source>When you execute the grep command a process is created. Once it is through (and didn't break) it returns some code between 0 and 255. For example:</source>
          <target state="translated">grep 명령을 실행하면 프로세스가 작성됩니다. 일단 통과되면 (및 중단되지 않음) 0에서 255 사이의 일부 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96e3de3e6bf17276eac99869ea88fc0e71150b83" translate="yes" xml:space="preserve">
          <source>Why does &lt;code&gt;int main(){}&lt;/code&gt; compile?</source>
          <target state="translated">왜 &lt;code&gt;int main(){}&lt;/code&gt; 컴파일됩니까?</target>
        </trans-unit>
        <trans-unit id="51b0c9e4f517672dab551e3f0c8fb3a773467020" translate="yes" xml:space="preserve">
          <source>Why is the type of the &lt;code&gt;main()&lt;/code&gt; function in C and C++ left to the user to define?</source>
          <target state="translated">C 및 C ++의 &lt;code&gt;main()&lt;/code&gt; 함수 유형이 사용자에게 정의 된 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2a862fb41af52a34873a9b301706a972cab7022b" translate="yes" xml:space="preserve">
          <source>Yet the section for hosted environment program termination then goes on arguing about the case where main does not return int &lt;sup&gt;5&lt;/sup&gt;. Although that section is not normative for how main should be declared, it definitely implies that main might be declared in a completely implementation-defined way even on hosted systems.</source>
          <target state="translated">그러나 호스트 된 환경 프로그램 종료 섹션은 main이 int &lt;sup&gt;5를&lt;/sup&gt; 반환하지 않는 경우에 대해 논쟁을 계속합니다. 이 섹션은 main 선언 방법에 대한 규범은 아니지만 호스트 시스템에서도 main이 완전히 구현 정의 된 방식으로 선언 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="922180965ea438bfff3906a2def9f2352b5adb9b" translate="yes" xml:space="preserve">
          <source>You may omit the return statement from &lt;code&gt;main()&lt;/code&gt;. If you do, and &lt;code&gt;main()&lt;/code&gt; finished, there is an implicit &lt;code&gt;return 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 에서 return 문을 생략 할 수 있습니다. 그렇게하고 &lt;code&gt;main()&lt;/code&gt; 끝나면 암시적인 &lt;code&gt;return 0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab226733ba35ae01df11c0190457de2d507d24e6" translate="yes" xml:space="preserve">
          <source>[...] a return from the initial call to the &lt;code&gt;main&lt;/code&gt; function is equivalent to calling the &lt;code&gt;exit&lt;/code&gt; function with the value returned by the &lt;code&gt;main&lt;/code&gt; function as its argument; reaching the &lt;code&gt;}&lt;/code&gt; that terminates the &lt;code&gt;main&lt;/code&gt; function returns a value of 0.</source>
          <target state="translated">[...] 초기 함수에서 &lt;code&gt;main&lt;/code&gt; 함수로의 리턴은 main 함수에서 리턴 된 값을 인수로 사용하여 &lt;code&gt;exit&lt;/code&gt; 함수를 호출하는 것과 같습니다. &lt;code&gt;main&lt;/code&gt; 함수를 종료하는 &lt;code&gt;}&lt;/code&gt; 에 도달하면 값 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="121d20b5045a7b17be1953b2f4b5b7d1193aba4f" translate="yes" xml:space="preserve">
          <source>as the type of main (8.3.5).</source>
          <target state="translated">주요 유형으로 (8.3.5).</target>
        </trans-unit>
        <trans-unit id="8b4ea7908f3a8fca63af0e6ad2f61e8268c4885d" translate="yes" xml:space="preserve">
          <source>main is the only function that may portably be declared either with zero or two arguments. (The number of other functions&amp;rsquo; arguments must match exactly between invocation and definition.)
  This special case simply recognizes the widespread practice of leaving off the arguments to main when the program does not access the program argument strings. While many implementations support more than two arguments to main, such practice is neither blessed nor forbidden by the Standard; a program that defines main with three arguments is not strictly conforming (see &amp;sect;J.5.1.).</source>
          <target state="translated">main은 0 또는 2 개의 인수로 선언 할 수있는 유일한 함수입니다. (다른 함수의 인수 수는 호출과 정의 사이에 정확히 일치해야합니다.)이 특별한 경우는 프로그램이 프로그램 인수 문자열에 액세스하지 않을 때 인수를 main으로 남겨 두는 광범위한 관행을 단순히 인식합니다. 많은 구현들이 주요한 주장에 대해 두 가지 이상의 주장을지지하지만, 그러한 관행은 표준에 의해 축복 받거나 금지되지 않습니다. 세 개의 인수로 main을 정의하는 프로그램은 엄격하게 준수하지 않습니다 (&amp;sect;J.5.1 참조).</target>
        </trans-unit>
        <trans-unit id="622f82e8c075ada716a1cc9582aedc7d512d29d9" translate="yes" xml:space="preserve">
          <source>or equivalent;9) or in some other implementation-defined
  manner.</source>
          <target state="translated">또는 등가; 9) 또는 다른 구현 정의 방식으로.</target>
        </trans-unit>
        <trans-unit id="1afe888428199267b8fb21832c373dab7f683445" translate="yes" xml:space="preserve">
          <source>or equivalent;&lt;sup&gt;10)&lt;/sup&gt; or in some other implementation-defined manner.</source>
          <target state="translated">또는 동등한 것; &lt;sup&gt;10)&lt;/sup&gt; 또는 다른 구현 정의 방식으로.</target>
        </trans-unit>
        <trans-unit id="6270e8159f1807e121f60a87d982221f41402076" translate="yes" xml:space="preserve">
          <source>or with two parameters (referred to here as
  argc and argv, though any names may be used, as they are local to the
  function in which they are declared):</source>
          <target state="translated">또는 두 개의 매개 변수가 있습니다 (여기서는 argc 및 argv라고 함). 선언 된 함수에 로컬이기 때문에 어떤 이름이든 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5dae6252c11ab5b0df3caf711c397701d6124cd" translate="yes" xml:space="preserve">
          <source>or with two parameters (referred to here as &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;, though any names may be
  used, as they are local to the function in which they are declared):</source>
          <target state="translated">또는 두 개의 매개 변수를 사용합니다 (여기서는 &lt;code&gt;argc&lt;/code&gt; 및 &lt;code&gt;argv&lt;/code&gt; 라고합니다. 이름은 선언 된 함수에 로컬이므로 모든 이름을 사용할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="f8a458ef7b858ad564adb1ed9a5adbf1c78ddb73" translate="yes" xml:space="preserve">
          <source>or, optionally,</source>
          <target state="translated">또는 선택적으로</target>
        </trans-unit>
        <trans-unit id="04c6ac4120301d7049af98011b0e572414db64b0" translate="yes" xml:space="preserve">
          <source>which is equivalent to</source>
          <target state="translated">어느 것이</target>
        </trans-unit>
        <trans-unit id="e7bb9db27381610dba7df259669ffd179effc729" translate="yes" xml:space="preserve">
          <source>you will get a 0. Why? Because &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; found a match and returned an exit code 0, which is the usual value for exiting with a success. Let's check it out again but with something that is not inside our text file and thus no match will be found:</source>
          <target state="translated">당신은 0을 얻을 것이다. 왜? &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; 이 일치하는 것을 발견하고 종료 코드 0을 리턴했습니다. 이는 성공으로 종료하기위한 일반적인 값입니다. 다시 확인하지만 텍스트 파일에없는 것과 일치하므로 일치하는 항목이 없습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
