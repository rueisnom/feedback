<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/204476">
    <body>
      <group id="204476">
        <trans-unit id="839e4a2006b278a93c4dc0f1936567078302c3f3" translate="yes" xml:space="preserve">
          <source>&amp;hellip;</source>
          <target state="translated">&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="f63367f1516d04e6d4576f54a6d715fa5519616b" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a function of () returning int and</source>
          <target state="translated">- функция (), возвращающая int и</target>
        </trans-unit>
        <trans-unit id="e3f10b4fa0118c5d90b758f3a7a22ecd6eddcb20" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a function of (int, pointer to pointer to char) returning int</source>
          <target state="translated">- функция (int, указатель на указатель на char), возвращающая int</target>
        </trans-unit>
        <trans-unit id="de2b84f7b4965ccad1f31acc3adcae74954902d4" translate="yes" xml:space="preserve">
          <source>&amp;para;1 A program shall contain a global function called main, which is the designated start of the program. [...]</source>
          <target state="translated">Program1 Программа должна содержать глобальную функцию, называемую main, которая является назначенным началом программы. [...]</target>
        </trans-unit>
        <trans-unit id="fba079ec46d6590faa38ad6852c15693de356522" translate="yes" xml:space="preserve">
          <source>&amp;para;1 In a hosted environment, the main function receives a third argument, &lt;code&gt;char *envp[]&lt;/code&gt;,
  that points to a null-terminated array of pointers to &lt;code&gt;char&lt;/code&gt;, each of which points to a string
  that provides information about the environment for this execution of the program (5.1.2.2.1).</source>
          <target state="translated">In1 В размещенной среде основная функция получает третий аргумент &lt;code&gt;char *envp[]&lt;/code&gt; , который указывает на массив указателей на &lt;code&gt;char&lt;/code&gt; с нулевым символом в конце , каждый из которых указывает на строку, предоставляющую информацию о среде для этого выполнения. программы (5.1.2.2.1).</target>
        </trans-unit>
        <trans-unit id="268bf348aa4cc2e0b88457c3f6e444329c666667" translate="yes" xml:space="preserve">
          <source>&amp;para;2 An implementation shall not predefine the main function. This function shall not be overloaded. It shall
  have a return type of type int, but otherwise its type is implementation defined.
  All implementations
  shall allow both of the following definitions of main:</source>
          <target state="translated">An2 Реализация не должна предопределять основную функцию. Эта функция не должна быть перегружена. Он должен иметь возвращаемый тип типа int, но в противном случае его тип определяется реализацией. Все реализации должны позволять оба следующих определения main:</target>
        </trans-unit>
        <trans-unit id="f725c7d6a718deeff027d0b7dca43053111038cf" translate="yes" xml:space="preserve">
          <source>&amp;para;3 The function &lt;code&gt;main&lt;/code&gt; shall not be used within a program. The linkage (3.5) of &lt;code&gt;main&lt;/code&gt; is implementation-defined. [...]</source>
          <target state="translated">Main3 Функция &lt;code&gt;main&lt;/code&gt; не должна использоваться в программе. Связь (3.5) с &lt;code&gt;main&lt;/code&gt; определяется реализацией. [...]</target>
        </trans-unit>
        <trans-unit id="6b25271533fe3e52213549f62d7343ca3360fd44" translate="yes" xml:space="preserve">
          <source>&amp;para;5 A &lt;em&gt;strictly conforming program&lt;/em&gt; shall use only those features of the language and library specified in this International Standard.&lt;sup&gt;3)&lt;/sup&gt; It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.</source>
          <target state="translated">A5 В &lt;em&gt;строго соответствующей программе&lt;/em&gt; должны использоваться только те функции языка и библиотеки, которые указаны в настоящем международном стандарте. &lt;sup&gt;3)&lt;/sup&gt; Он не должен производить выходные данные, зависящие от какого-либо неопределенного, неопределенного или определенного реализацией поведения, и не должен превышать какого-либо минимального предела реализации.</target>
        </trans-unit>
        <trans-unit id="faf3a7ecabef70212bf778ca2245ba160daae386" translate="yes" xml:space="preserve">
          <source>&amp;para;5 A return statement in main has the effect of leaving the main function (destroying any objects with automatic
  storage duration) and calling &lt;code&gt;std::exit&lt;/code&gt; with the return value as the argument. If control reaches the end
  of main without encountering a return statement, the effect is that of executing</source>
          <target state="translated">Statement5 Оператор return в main приводит к выходу из функции main (уничтожению любых объектов с автоматическим хранением) и вызову &lt;code&gt;std::exit&lt;/code&gt; с возвращаемым значением в качестве аргумента. Если управление достигает конца main, не встречая оператора return, эффект заключается в выполнении</target>
        </trans-unit>
        <trans-unit id="cd52c684e5038903c8d7058be01e2ecabbdecb17" translate="yes" xml:space="preserve">
          <source>&amp;para;5 Finally, control is returned to the host environment. If the value of &lt;code&gt;status&lt;/code&gt; is zero or &lt;code&gt;EXIT_SUCCESS&lt;/code&gt;, an implementation-defined form of the status &lt;em&gt;successful termination&lt;/em&gt; is returned. If the value of &lt;code&gt;status&lt;/code&gt; is &lt;code&gt;EXIT_FAILURE&lt;/code&gt;, an implementation-defined form of the status &lt;em&gt;unsuccessful termination&lt;/em&gt; is returned. Otherwise the status returned is implementation-defined.</source>
          <target state="translated">Finally5 Наконец, управление возвращается в среду хоста. Если значение &lt;code&gt;status&lt;/code&gt; равно нулю или &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; , возвращается определяемая реализацией форма &lt;em&gt;успешного завершения&lt;/em&gt; статуса. Если значением &lt;code&gt;status&lt;/code&gt; является &lt;code&gt;EXIT_FAILURE&lt;/code&gt; , возвращается определяемая реализацией форма &lt;em&gt;неудачного завершения&lt;/em&gt; статуса. В противном случае возвращаемый статус определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="75b067a9183eb49f341e4cb9b8899302c2bf5c32" translate="yes" xml:space="preserve">
          <source>&amp;para;6 The two forms of conforming implementation are &lt;em&gt;hosted&lt;/em&gt; and &lt;em&gt;freestanding&lt;/em&gt;. A &lt;em&gt;conforming hosted implementation&lt;/em&gt; shall accept any strictly conforming program. A &lt;em&gt;conforming freestanding implementation&lt;/em&gt; shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;,
  &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;, and
  &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;. A conforming implementation may have extensions (including
  additional library functions), provided they do not alter the behavior of any strictly conforming program.&lt;sup&gt;4)&lt;/sup&gt;</source>
          <target state="translated">&amp;para;6 Две формы соответствующей реализации &lt;em&gt;размещаются&lt;/em&gt; и являются &lt;em&gt;автономными&lt;/em&gt; . &lt;em&gt;Соответствующая размещенная реализация&lt;/em&gt; должна принимать любую строго соответствующую программу. &lt;em&gt;Соответствующая автономная реализация&lt;/em&gt; должна принимать любую строго соответствующую программу, в которой использование функций, указанных в разделе библиотеки (пункт 7), ограничено содержимым стандартных заголовков &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; limit . h&amp;gt; , &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt; . Соответствующая реализация может иметь расширения (включая дополнительные библиотечные функции), при условии, что они не изменяют поведение любой строго соответствующей программы. &lt;sup&gt;4)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="80e12995965674219f63848c639631125cf40efd" translate="yes" xml:space="preserve">
          <source>&amp;para;7 A &lt;em&gt;conforming program&lt;/em&gt; is one that is acceptable to a conforming implementation.&lt;sup&gt;5)&lt;/sup&gt;</source>
          <target state="translated">&amp;para;7 &lt;em&gt;Соответствующая программа&lt;/em&gt; - это &lt;em&gt;программа&lt;/em&gt; , приемлемая для соответствующей реализации. &lt;sup&gt;5)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ca1e412dcdcb69f2e17aed105715050d1052b4ce" translate="yes" xml:space="preserve">
          <source>&amp;para;7 Two kinds of implementations are defined: a &lt;em&gt;hosted implementation&lt;/em&gt; and a &lt;em&gt;freestanding implementation&lt;/em&gt;. For a hosted implementation, this International Standard defines the set of available libraries. A freestanding
  implementation is one in which execution may take place without the benefit of an operating system, and has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).</source>
          <target state="translated">&amp;para;7 Определены два вида реализаций: &lt;em&gt;размещенная реализация&lt;/em&gt; и &lt;em&gt;автономная реализация&lt;/em&gt; . Для размещенной реализации этот международный стандарт определяет набор доступных библиотек. Автономная реализация - это та реализация, в которой выполнение может осуществляться без использования операционной системы, и имеет определенный набор реализаций библиотек, который включает в себя определенные библиотеки поддержки языка (17.6.1.3).</target>
        </trans-unit>
        <trans-unit id="d7dc9283f7b16f5ee420119dfbaa6363dac4ba08" translate="yes" xml:space="preserve">
          <source>&amp;para;8 A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that
  use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.</source>
          <target state="translated">Implementation8 Соответствующая реализация может иметь расширения (включая дополнительные библиотечные функции), при условии, что они не изменяют поведение любой правильно сформированной программы. Внедрения необходимы для диагностики программ, использующих такие расширения, которые не соответствуют требованиям настоящего международного стандарта. Сделав это, однако, они могут компилировать и выполнять такие программы.</target>
        </trans-unit>
        <trans-unit id="aee57d8b42fa45a9c62d786d87e4e51641c9817b" translate="yes" xml:space="preserve">
          <source>&amp;para;8 EXAMPLE 3 In this example, the size of a variable length array is computed and returned from a function:</source>
          <target state="translated">Пример 8 В этом примере размер массива переменной длины вычисляется и возвращается из функции:</target>
        </trans-unit>
        <trans-unit id="7375209cbdea44802996e1ba4bfbb7ebf8bcffc8" translate="yes" xml:space="preserve">
          <source>&amp;para;9 Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support and defines all locale-specific characteristics.&lt;sup&gt;3&lt;/sup&gt;</source>
          <target state="translated">Each9 Каждая реализация должна включать документацию, которая идентифицирует все условно поддерживаемые конструкции, которые она не поддерживает, и определяет все специфичные для локали характеристики. &lt;sup&gt;3&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="f8c0fd5dd6b6ab8b703b27f9f230f0a90552ad70" translate="yes" xml:space="preserve">
          <source>0 for success, nonzero for failure.  Again, not something you need to (or get to) pick: it's defined by the interface you're supposed to be conforming to.</source>
          <target state="translated">0 за успех,ноль за провал.Опять же,не то,что нужно (или нужно)выбрать:это определяется интерфейсом,которому вы должны соответствовать.</target>
        </trans-unit>
        <trans-unit id="bc9b8d3e781ce73dbb246a75ec5a09339f47b503" translate="yes" xml:space="preserve">
          <source>1 If the return type of the &lt;code&gt;main&lt;/code&gt; function is a type compatible with &lt;code&gt;int&lt;/code&gt;, a return from the
  initial call to the &lt;code&gt;main&lt;/code&gt; function is equivalent to calling the &lt;code&gt;exit&lt;/code&gt; function with the value
  returned by the &lt;code&gt;main&lt;/code&gt; function as its argument;&lt;sup&gt;11)&lt;/sup&gt; reaching the &lt;code&gt;}&lt;/code&gt; that terminates the
  &lt;code&gt;main&lt;/code&gt; function returns a value of 0. If the return type is not compatible with &lt;code&gt;int&lt;/code&gt;, the
  termination status returned to the host environment is unspecified.</source>
          <target state="translated">1 Если возвращаемый тип &lt;code&gt;main&lt;/code&gt; функции является типом, совместимым с &lt;code&gt;int&lt;/code&gt; , возврат из начального вызова &lt;code&gt;main&lt;/code&gt; функции эквивалентен вызову функции &lt;code&gt;exit&lt;/code&gt; со значением, возвращаемым &lt;code&gt;main&lt;/code&gt; функцией в качестве аргумента; &lt;sup&gt;11) при&lt;/sup&gt; достижении &lt;code&gt;}&lt;/code&gt; , который завершает &lt;code&gt;main&lt;/code&gt; функцию, возвращается значение 0. Если возвращаемый тип не совместим с &lt;code&gt;int&lt;/code&gt; , состояние завершения, возвращаемое в хост-среду, не определено.</target>
        </trans-unit>
        <trans-unit id="9f3fffa3327d3ba52b48bca6ea15dcebe78e227a" translate="yes" xml:space="preserve">
          <source>1.4 Implementation compliance [intro.compliance]</source>
          <target state="translated">1.4 Соблюдение требований по внедрению [интро.соответствие]</target>
        </trans-unit>
        <trans-unit id="c6764c018e0ee51831b7edf8ba43133716139970" translate="yes" xml:space="preserve">
          <source>17.6.1.3 Freestanding implementations [compliance]</source>
          <target state="translated">17.6.1.3 Отдельно стоящие реализации [соответствие].</target>
        </trans-unit>
        <trans-unit id="c625fb551848e2eda9b2bcd7f1fbfbeae2205afb" translate="yes" xml:space="preserve">
          <source>3.6.1 Main function [basic.start.main]</source>
          <target state="translated">3.6.1 Главная функция [основные.пусковые функции].</target>
        </trans-unit>
        <trans-unit id="74939d480b030b4d0aca4a62a78baefa0b305245" translate="yes" xml:space="preserve">
          <source>5.1.2 Execution environments</source>
          <target state="translated">5.1.2 Среды выполнения</target>
        </trans-unit>
        <trans-unit id="a10709d6042407d378ae63fb597e3cb0c35f37a4" translate="yes" xml:space="preserve">
          <source>5.1.2.1 Freestanding environment</source>
          <target state="translated">5.1.2.1 Отличительная среда</target>
        </trans-unit>
        <trans-unit id="421d09a1018436b2d8a5dd11587decfcfcd9ac51" translate="yes" xml:space="preserve">
          <source>5.1.2.2.1 Program startup</source>
          <target state="translated">5.1.2.2.1 Программа запуска</target>
        </trans-unit>
        <trans-unit id="bf97d5d45eb7bf179cd39bc7a3476106465bd537" translate="yes" xml:space="preserve">
          <source>5.1.2.2.3 Program termination</source>
          <target state="translated">5.1.2.2.3 Прекращение действия программы</target>
        </trans-unit>
        <trans-unit id="aaeb27114e23ee14710f683d375b03fdb9b9be98" translate="yes" xml:space="preserve">
          <source>6.11.6 Function declarators</source>
          <target state="translated">6.11.6 Функциональные деклараторы</target>
        </trans-unit>
        <trans-unit id="fa42bbaed1d0a660afc0222443686a157a0e6ebd" translate="yes" xml:space="preserve">
          <source>6.5.3.4 The &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators</source>
          <target state="translated">6.5.3.4 Операторы &lt;code&gt;sizeof&lt;/code&gt; и &lt;code&gt;_Alignof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af39c61a22e5f25a61be3c526a6c974cd1ea404d" translate="yes" xml:space="preserve">
          <source>7.22.4.4 The &lt;code&gt;exit&lt;/code&gt; function</source>
          <target state="translated">7.22.4.4 Функция &lt;code&gt;exit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2259a4ab4a2439d3610778ec870b765036afd221" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main&quot;&gt;What is the proper declaration of &lt;code&gt;main()&lt;/code&gt;?&lt;/a&gt; &amp;mdash; For C++, with a very good answer indeed.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main&quot;&gt;Что такое правильное объявление &lt;code&gt;main()&lt;/code&gt; ?&lt;/a&gt; - Для C ++, с очень хорошим ответом.</target>
        </trans-unit>
        <trans-unit id="e29bc9e2848992cf6548652af8a5be14a9249467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argv[argc]&lt;/code&gt; shall be a null pointer.</source>
          <target state="translated">&lt;code&gt;argv[argc]&lt;/code&gt; должен быть нулевым указателем.</target>
        </trans-unit>
        <trans-unit id="4a37fed8f5445c4993b8c5da80701807ea9a23fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int main()&lt;/code&gt; vs &lt;code&gt;void main()&lt;/code&gt; in C</source>
          <target state="translated">&lt;code&gt;int main()&lt;/code&gt; против &lt;code&gt;void main()&lt;/code&gt; в C</target>
        </trans-unit>
        <trans-unit id="f8f60346f2e6dc9ec649d50698ae28dc37e9103d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt; in C89 and K&amp;amp;R C unspecified return types default to &amp;rsquo;int`.</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; в C89 и K &amp;amp; R C неопределенные типы возвращаемых значений по умолчанию 'int`.</target>
        </trans-unit>
        <trans-unit id="77a0a2cbf7bad637f5c880daeb2e835a409f5011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt; should be declared as either:</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; должен быть объявлен как:</target>
        </trans-unit>
        <trans-unit id="a99a4351928aa53be892994d830351307ef971d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt;'s signature in C++</source>
          <target state="translated">Подпись &lt;code&gt;main()&lt;/code&gt; в C ++</target>
        </trans-unit>
        <trans-unit id="3389bce9434a3b56c3264af85cd3f1e622526831" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return 0&lt;/code&gt; or &lt;code&gt;return 1&lt;/code&gt; will be received by the parent process. In a shell it goes into a shell variable, and if you are running your program form a shell and not using that variable then you need not worry about the return value of &lt;code&gt;main()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;return 0&lt;/code&gt; или &lt;code&gt;return 1&lt;/code&gt; будут получены родительским процессом. В оболочке она переходит в переменную оболочки, и если вы запускаете свою программу из оболочки и не используете эту переменную, вам не нужно беспокоиться о возвращаемом значении &lt;code&gt;main()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9357defb5f570731b5b1bc998cafabdff46afe41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;There are numerous duplicates of this question, including:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Существует множество дубликатов этого вопроса, в том числе:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24c37500e1d6539a78a2997986f25d358e54ee71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++03 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 03 автономная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ca7c7ddff5ac442add7172c71909b660ede292c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++03 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 03 размещенная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82a7ebec217d66e8b8c2d24ab3e3f5b1cacef4f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 11 автономная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2b3cabf96f4ea44d63a24449dabea2a53cf0512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ 11 размещенная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09f98f8248303be464d553d71fb5cf58e90f51b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C11 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C11 автономная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b60f1d79fd4fb894543c08e1c03275903168a46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C11 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;С11 размещенная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f08ea5864b7e3a0f044a93ec2f7398ca698c40b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C90 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C90 автономная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d214f0511b5d0b5572547a7e70a1324e68f71d7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C90 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C90 размещенная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="100ce1f0e56996aa7562559f1b8a172eabbb3b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 freestanding environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C99 автономная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aced90d316248fd18e7f601285666ee9656c0b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 hosted environment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C99 размещенная среда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39941c674be35df5a1e78497af6e5aefcc124f65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when I make this suggestion, it's almost invariably followed by one of two kinds of comments:  &quot;I didn't know that.&quot; or &quot;That's bad advice!&quot;  My rationale is that it's safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; когда я делаю это предложение, за ним почти всегда следует один из двух видов комментариев: &amp;laquo;Я этого не знал&amp;raquo;. или &quot;Это плохой совет!&quot; Мое обоснование заключается в том, что безопасно и полезно полагаться на поведение компилятора, явно поддерживаемое стандартом. Для C, начиная с C99; см. ИСО / МЭК 9899: 1999, раздел 5.1.2.2.3:</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ede2f6abb3f054287bbb931649c2f245bcaa1f0" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;10)&lt;/sup&gt; Thus, &lt;code&gt;int&lt;/code&gt; can be replaced by a typedef name defined as &lt;code&gt;int&lt;/code&gt;, or the type of &lt;code&gt;argv&lt;/code&gt; can be written as
  &lt;code&gt;char **argv&lt;/code&gt;, and so on.</source>
          <target state="translated">&lt;sup&gt;10)&lt;/sup&gt; Таким образом, &lt;code&gt;int&lt;/code&gt; может быть заменено именем typedef, определенным как &lt;code&gt;int&lt;/code&gt; , или тип &lt;code&gt;argv&lt;/code&gt; может быть записан как &lt;code&gt;char **argv&lt;/code&gt; , и так далее.</target>
        </trans-unit>
        <trans-unit id="011ebdf423d0eeaeb00bbe1f5e9f73f7e03f1379" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;11)&lt;/sup&gt; In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in &lt;code&gt;main&lt;/code&gt;
  will have ended in the former case, even where they would not have in the latter.</source>
          <target state="translated">&lt;sup&gt;11)&lt;/sup&gt; В соответствии с 6.2.4 время жизни объектов с автоматической продолжительностью хранения, объявленной в &lt;code&gt;main&lt;/code&gt; , закончится в первом случае, даже если в последнем случае их не будет.</target>
        </trans-unit>
        <trans-unit id="a58a7471bfb0770dd6b5ffe6f2124853a918a6d6" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3)&lt;/sup&gt; A strictly conforming program can use conditional features (see 6.10.8.3) provided the use is guarded by an appropriate conditional inclusion preprocessing directive using the related macro. For example:</source>
          <target state="translated">&lt;sup&gt;3)&lt;/sup&gt; Строго соответствующая программа может использовать условные функции (см. 6.10.8.3) при условии, что использование защищено соответствующей директивой предварительной обработки условного включения с использованием соответствующего макроса. Например:</target>
        </trans-unit>
        <trans-unit id="2a0e8c9db9d88c7fc9a217ed3b840fdfca0ad4c9" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3)&lt;/sup&gt; This documentation also defines implementation-defined behavior; see 1.9.</source>
          <target state="translated">&lt;sup&gt;3)&lt;/sup&gt; Эта документация также определяет поведение, определяемое реализацией; см. 1.9.</target>
        </trans-unit>
        <trans-unit id="60f63bd67cf9699a2930ead7ef8840e496fb4919" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4)&lt;/sup&gt; This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.</source>
          <target state="translated">&lt;sup&gt;4)&lt;/sup&gt; Это подразумевает, что соответствующая реализация не оставляет никаких идентификаторов, кроме тех, которые явно зарезервированы в настоящем международном стандарте.</target>
        </trans-unit>
        <trans-unit id="df6a402d9d62f5a27a627e0839825b19422b9ff0" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;5)&lt;/sup&gt; Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon non-portable features of a conforming implementation.</source>
          <target state="translated">&lt;sup&gt;5)&lt;/sup&gt; Строго соответствующие программы предназначены для максимальной переносимости среди соответствующих реализаций. Соответствующие программы могут зависеть от непереносимых функций соответствующей реализации.</target>
        </trans-unit>
        <trans-unit id="181254e8f9b948c18cf54289fc472931f4bcaf8c" translate="yes" xml:space="preserve">
          <source>A freestanding implementation has an implementation-defined set of headers. This set shall include at least the headers shown in Table 16.</source>
          <target state="translated">Отдельно стоящая реализация имеет определенный набор заголовков.Этот набор должен включать,по крайней мере,заголовки,указанные в таблице 16.</target>
        </trans-unit>
        <trans-unit id="80e91a530ec3d2ff8b86717bc9074b128cbda6a4" translate="yes" xml:space="preserve">
          <source>A strange, ambiguous sentence &quot;or in some other implementation-defined manner&quot; has been introduced. This can either be interpreted as &quot;the parameters to &lt;code&gt;int main()&lt;/code&gt; may vary&quot; or as &quot;main can have any implementation-defined form&quot;.</source>
          <target state="translated">Было введено странное, неоднозначное предложение &amp;laquo;или каким-то другим образом, определяемым реализацией&amp;raquo;. Это может быть либо интерпретировано как &amp;laquo;параметры &lt;code&gt;int main()&lt;/code&gt; могут различаться&amp;raquo;, либо как &amp;laquo;main может иметь любую форму, определяемую реализацией&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2ca23b0779eeca695d782b5b96f1577207241984" translate="yes" xml:space="preserve">
          <source>ANSI X3.159-1989 2.1.2.1 Freestanding environment:</source>
          <target state="translated">ANSI X3.159-1989 2.1.2.1 Отдельно стоящая среда:</target>
        </trans-unit>
        <trans-unit id="57a7155ea831c7e0d4282c280f1bb112dfa1e288" translate="yes" xml:space="preserve">
          <source>ANSI X3.159-1989 2.1.2.2 Hosted environment. &quot;Program startup&quot;</source>
          <target state="translated">ANSI X3.159-1989 2.1.2.2 Хостируемая среда.&quot;Запуск программы&quot;</target>
        </trans-unit>
        <trans-unit id="24cf3c85b055a0c58ef221fc468e8f9b43b2c027" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md&quot;&gt;C++ Core Guidelines&lt;/a&gt; contains multiple instances of omitting &lt;code&gt;return 0;&lt;/code&gt; at the end of &lt;code&gt;main&lt;/code&gt; and no instances in which an explicit return is written.  Although there is not yet a specific guideline on this particular topic in that document, that seems at least a tacit endorsement of the practice.</source>
          <target state="translated">Кроме того, &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md&quot;&gt;C ++ Core Guidelines&lt;/a&gt; содержит несколько примеров пропуска &lt;code&gt;return 0;&lt;/code&gt; в конце &lt;code&gt;main&lt;/code&gt; и ни одного экземпляра, в которых записан явный возврат. Хотя в этом документе пока нет конкретного руководства по этой конкретной теме, это, по крайней мере, является молчаливым одобрением этой практики.</target>
        </trans-unit>
        <trans-unit id="23e493e83a229c8a646ea40b97b496511adb8337" translate="yes" xml:space="preserve">
          <source>After the second line nothing is printed to the terminal since &quot;foo&quot; made grep return 1 and we check if the return code of grep was equal to 0. The second conditional statement echoes its message in the last line since it is true due to CHECK == 1.</source>
          <target state="translated">После второй строки в терминал ничего не выводится,так как &quot;foo&quot; сделал grep return 1,и мы проверяем,не равен ли код возврата grep 0.Второй условный оператор перекликается с его сообщением в последней строке,так как это правда из-за CHECK ==1.</target>
        </trans-unit>
        <trans-unit id="09933d4decfafb0faf055a060f94f61bcf140364" translate="yes" xml:space="preserve">
          <source>All versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit &lt;code&gt;return;&lt;/code&gt; statements at the end of a &lt;code&gt;void&lt;/code&gt; function.  Reasons against omitting seem to boil down to &lt;a href=&quot;https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015&quot;&gt;&quot;it looks weird&quot;&lt;/a&gt;.  If, like me, you're curious about the rationale for the change to the C standard &lt;a href=&quot;https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional&quot;&gt;read this question&lt;/a&gt;.  Also note that in the early 1990s this was considered &quot;sloppy practice&quot; because it was undefined behavior (although widely supported) at the time.</source>
          <target state="translated">С тех пор все версии обоих стандартов (C99 и C ++ 98) придерживались той же идеи. Мы полагаемся на автоматически сгенерированные функции-члены в C ++, и мало кто пишет явный &lt;code&gt;return;&lt;/code&gt; заявления в конце &lt;code&gt;void&lt;/code&gt; функции. Причины против пропуска, кажется, сводятся к тому, что &lt;a href=&quot;https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015&quot;&gt;&amp;laquo;это выглядит странно&amp;raquo;&lt;/a&gt; . Если, как и я, вам интересно узнать причину изменения стандарта C, &lt;a href=&quot;https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional&quot;&gt;прочтите этот вопрос&lt;/a&gt; . Также обратите внимание, что в начале 1990-х это считалось &amp;laquo;небрежной практикой&amp;raquo;, потому что в то время это было неопределенное поведение (хотя и широко поддерживаемое).</target>
        </trans-unit>
        <trans-unit id="83ff694899e1d845ab60582f3b73ef06850d2d34" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;11&lt;/sup&gt;:</source>
          <target state="translated">Разрешенные формы &lt;sup&gt;11&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="1ffdd2e9d11e5e754b0a9cf96f132585a0112b4d" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;1&lt;/sup&gt;:</source>
          <target state="translated">Разрешенные формы &lt;sup&gt;1&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="531b9bfacbabbde3a9ef0944158dd8da7569c421" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;3&lt;/sup&gt;:</source>
          <target state="translated">Разрешенные формы &lt;sup&gt;3&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="75815e021134ec0eba7ed2c0d9c5a844701da1d0" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;7&lt;/sup&gt;:</source>
          <target state="translated">Разрешенные формы &lt;sup&gt;7&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="4679a6ba8a0d1ca4986d60983e12b4e750ecdae5" translate="yes" xml:space="preserve">
          <source>Allowed forms &lt;sup&gt;9&lt;/sup&gt;:</source>
          <target state="translated">Разрешенные формы &lt;sup&gt;9&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="8ce86355d96de776927a38cfc34a124933831922" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;wmain&lt;/code&gt; functions can be declared as returning &lt;code&gt;void&lt;/code&gt; (no return value). If you declare &lt;code&gt;main&lt;/code&gt; or &lt;code&gt;wmain&lt;/code&gt; as returning void, you cannot return an exit code to the parent process or operating system by using a return statement. To return an exit code when &lt;code&gt;main&lt;/code&gt; or &lt;code&gt;wmain&lt;/code&gt; is declared as &lt;code&gt;void&lt;/code&gt;, you must use the &lt;code&gt;exit&lt;/code&gt; function.</source>
          <target state="translated">В качестве альтернативы, функции &lt;code&gt;main&lt;/code&gt; и &lt;code&gt;wmain&lt;/code&gt; могут быть объявлены как возвращающие &lt;code&gt;void&lt;/code&gt; (без возвращаемого значения). Если вы объявите &lt;code&gt;main&lt;/code&gt; или &lt;code&gt;wmain&lt;/code&gt; как возвращающие void, вы не сможете вернуть код завершения родительскому процессу или операционной системе с помощью оператора return. Чтобы вернуть код выхода, когда &lt;code&gt;main&lt;/code&gt; или &lt;code&gt;wmain&lt;/code&gt; объявлены как &lt;code&gt;void&lt;/code&gt; , вы должны использовать функцию &lt;code&gt;exit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="108ea3b40bdac1fa932e2881ce8b590bb80462aa" translate="yes" xml:space="preserve">
          <source>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall
  allow both</source>
          <target state="translated">Реализация не должна предопределять основную функцию.Эта функция не должна быть перегружена.Она должна иметь возвращаемый тип int,но в противном случае ее тип определяется реализацией.Все реализации должны позволять и то,и другое</target>
        </trans-unit>
        <trans-unit id="cceddadf6ec36d3e334ec1453776d68f0a30b419" translate="yes" xml:space="preserve">
          <source>An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both of the following definitions of main:</source>
          <target state="translated">Реализация не должна предопределять основную функцию.Эта функция не должна быть перегружена.Она должна иметь возвращаемый тип int,но в противном случае ее тип определяется реализацией.Все реализации должны допускать оба нижеследующих определения главной:</target>
        </trans-unit>
        <trans-unit id="abe62c12cbd384f011ace9ca713b8616f65c4574" translate="yes" xml:space="preserve">
          <source>Any form or name of main is allowed &lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">Разрешается любая форма или имя главного лица &lt;sup&gt;2&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="f259d290cdcbc9bbec44ad4bd545c173c869cb9a" translate="yes" xml:space="preserve">
          <source>Any form or name of main is allowed &lt;sup&gt;6&lt;/sup&gt;.</source>
          <target state="translated">Разрешается любая форма или имя основного лица &lt;sup&gt;6&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="e2314c2dd97eecb4a3e772641c44c357495c2a73" translate="yes" xml:space="preserve">
          <source>Any form or name of main is allowed &lt;sup&gt;8&lt;/sup&gt;.</source>
          <target state="translated">Разрешается любая форма или имя главного лица &lt;sup&gt;8&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="ef855fa906d52778c2fb1c45f521ea626f5689c2" translate="yes" xml:space="preserve">
          <source>As noted early on, the requirements above apply to hosted environments. If you are working with a freestanding environment (which is the alternative to a hosted environment), then the standard has much less to say. For a freestanding environment, the function called at program startup need not be called &lt;code&gt;main&lt;/code&gt; and there are no constraints on its return type.  The standard says:</source>
          <target state="translated">Как уже отмечалось ранее, вышеуказанные требования применяются к размещенным средам. Если вы работаете с автономной средой (которая является альтернативой размещенной среде), то о стандарте можно сказать гораздо меньше. Для автономной среды функцию, вызываемую при запуске программы, не нужно называть &lt;code&gt;main&lt;/code&gt; и нет никаких ограничений на ее тип возвращаемого значения. Стандарт гласит:</target>
        </trans-unit>
        <trans-unit id="6a69258566146688a6c3902485cea9ec71efe8ed" translate="yes" xml:space="preserve">
          <source>As you can see if you are calling this and that process it is sometimes essential to see what it has returned (by the return value of main()).</source>
          <target state="translated">Как видно,если вы вызываете этот и этот процесс,то иногда необходимо посмотреть,что он вернул (по возвращаемому значению main()).</target>
        </trans-unit>
        <trans-unit id="e46f165c0590a92b13364a7c8042f058136f6322" translate="yes" xml:space="preserve">
          <source>C++ &amp;mdash; &lt;code&gt;int main(int argc, char **argv)&lt;/code&gt;</source>
          <target state="translated">C ++ - &lt;code&gt;int main(int argc, char **argv)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76311ff27f1cf5e0babcefff7edb17a402c58861" translate="yes" xml:space="preserve">
          <source>C++ &amp;mdash; &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;</source>
          <target state="translated">C ++ - &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d70b6b60e0f24927bc4538fb0ceb71184d06bef0" translate="yes" xml:space="preserve">
          <source>C99 removed &quot;implicit int&quot; so &lt;code&gt;main()&lt;/code&gt; is no longer valid.</source>
          <target state="translated">C99 удалил &quot;неявный int&quot;, поэтому &lt;code&gt;main()&lt;/code&gt; больше не действителен.</target>
        </trans-unit>
        <trans-unit id="6c8395748074b451b2f55b5c5e4c263a6bbe2bef" translate="yes" xml:space="preserve">
          <source>Classically, Unix systems support a third variant:</source>
          <target state="translated">Классически системы Unix поддерживают третий вариант:</target>
        </trans-unit>
        <trans-unit id="e4ed7f96515dbdbe5f5d0ecace105efe68e6c3ec" translate="yes" xml:space="preserve">
          <source>Comments:</source>
          <target state="translated">Comments:</target>
        </trans-unit>
        <trans-unit id="cf3f840e63764cb35ea2eae778010a42f50e1375" translate="yes" xml:space="preserve">
          <source>Difference between &lt;code&gt;void main()&lt;/code&gt; and &lt;code&gt;int main()&lt;/code&gt;?</source>
          <target state="translated">Разница между &lt;code&gt;void main()&lt;/code&gt; и &lt;code&gt;int main()&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="8dd79bfba982dc335f30bf0edc8ada5d88da4914" translate="yes" xml:space="preserve">
          <source>Efficiency is not an issue with the &lt;code&gt;main&lt;/code&gt; function. It can only be entered and left once (marking the program's start and termination) according to the C++ standard. For C, re-entering &lt;code&gt;main()&lt;/code&gt; is allowed, but should be avoided.</source>
          <target state="translated">Эффективность не проблема с &lt;code&gt;main&lt;/code&gt; функцией. Он может быть введен и оставлен только один раз (отмечен запуск и завершение программы) в соответствии со стандартом C ++. Для C повторный ввод &lt;code&gt;main()&lt;/code&gt; разрешен, но его следует избегать.</target>
        </trans-unit>
        <trans-unit id="3fd215cf12ba7569beb5b6db1ee04c9f3d5989a2" translate="yes" xml:space="preserve">
          <source>Finally, there is nothing wrong from a standards point of view with calling &lt;code&gt;main()&lt;/code&gt; from a program.</source>
          <target state="translated">Наконец, нет ничего плохого с точки зрения стандартов в вызове &lt;code&gt;main()&lt;/code&gt; из программы.</target>
        </trans-unit>
        <trans-unit id="62b8c7d7dfd45c5f3d50a3d0e74887793a303162" translate="yes" xml:space="preserve">
          <source>For C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:</source>
          <target state="translated">Для С++,начиная с первого стандарта в 1998 году;см.ISOIEC 14882:1998 раздел 3.6.1:</target>
        </trans-unit>
        <trans-unit id="3500093e0edf7d6f4a566c3f4b7efdebecf64c37" translate="yes" xml:space="preserve">
          <source>For C99, everything is the same as above except:</source>
          <target state="translated">Для C99 все то же самое,что и выше,за исключением..:</target>
        </trans-unit>
        <trans-unit id="fc184e779fe2b354b692cb83c96360ac6578836a" translate="yes" xml:space="preserve">
          <source>For a hosted environment (that's the normal one), the C11 standard (ISO/IEC 9899:2011) says:</source>
          <target state="translated">Для хостируемой среды (это обычная среда),говорит стандарт C11 (ISOIEC 9899:2011):</target>
        </trans-unit>
        <trans-unit id="2c578db723c70cb97ef0753314ddb79e6ca46de7" translate="yes" xml:space="preserve">
          <source>Here is a small demonstration of the usage of return codes...</source>
          <target state="translated">Вот небольшая демонстрация использования кодов возврата...</target>
        </trans-unit>
        <trans-unit id="d082866f80f3c7b776d5b28ecd6c0bcbdc809faf" translate="yes" xml:space="preserve">
          <source>However I usually return 0.</source>
          <target state="translated">Однако я обычно возвращаю 0.</target>
        </trans-unit>
        <trans-unit id="bcc235a17e919b6165ee1c9df15ea0527e83ab84" translate="yes" xml:space="preserve">
          <source>However, to allow completely wild forms of &lt;code&gt;main()&lt;/code&gt; was probably(?) not the intention of this new sentence. The C99 rationale (not normative) implies that the sentence refers to additional parameters to &lt;code&gt;int main&lt;/code&gt;&lt;sup&gt;4&lt;/sup&gt;.</source>
          <target state="translated">Однако разрешить совершенно дикие формы &lt;code&gt;main()&lt;/code&gt; вероятно, (?) Не было целью этого нового предложения. Обоснование C99 (не нормативное) подразумевает, что предложение относится к дополнительным параметрам по отношению к &lt;code&gt;int main&lt;/code&gt; &lt;sup&gt;4&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="d1b1ad3f3ac01aeb1f1aa57b42231bc5e931e4f0" translate="yes" xml:space="preserve">
          <source>I believe that &lt;code&gt;main()&lt;/code&gt; should return either &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; or &lt;code&gt;EXIT_FAILURE&lt;/code&gt;. They are defined in &lt;code&gt;stdlib.h&lt;/code&gt;</source>
          <target state="translated">Я считаю, что &lt;code&gt;main()&lt;/code&gt; должен возвращать либо &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; , либо &lt;code&gt;EXIT_FAILURE&lt;/code&gt; . Они определены в &lt;code&gt;stdlib.h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c8ab38f22cccd2931145ee6336eedf191f6b30f" translate="yes" xml:space="preserve">
          <source>I was under the impression that standard specifies that main doesn't need a return value as a successful return was OS based (zero in one could be either a success or a failure in another), therefore the absence of return was a cue for the compiler to insert the successful return itself.</source>
          <target state="translated">У меня сложилось впечатление,что в стандарте указано,что main не нуждается в возвращаемом значении,так как успешное возвращение основано на ОС (ноль в одном случае может быть либо успехом,либо неудачей в другом),поэтому отсутствие возврата является подсказкой для компилятора,чтобы вставить само успешное возвращение.</target>
        </trans-unit>
        <trans-unit id="4fb16fcf1d38904d79af7bbdd1699672a66ac59e" translate="yes" xml:space="preserve">
          <source>ISO 14882:2003 3.6.1 Main function</source>
          <target state="translated">ISO 14882:2003 3.6.1 Основная функция</target>
        </trans-unit>
        <trans-unit id="6fcc9ab167f456cff52beb58f8604705b44e2080" translate="yes" xml:space="preserve">
          <source>ISO 14882:2011 3.6.1 Main function</source>
          <target state="translated">ISO 14882:2011 3.6.1 Основная функция</target>
        </trans-unit>
        <trans-unit id="072f40f89924efb24c9c0d91ec69c1b477accc60" translate="yes" xml:space="preserve">
          <source>ISO 9899:1999 5.1.2.1 Freestanding environment</source>
          <target state="translated">ISO 9899:1999 5.1.2.1 Отдельно стоящая среда</target>
        </trans-unit>
        <trans-unit id="6cb748bf92ce81daeb76259fcdc696d6d4a84f98" translate="yes" xml:space="preserve">
          <source>ISO 9899:1999 5.1.2.2 Hosted environment -&amp;gt; 5.1.2.2.1 Program startup</source>
          <target state="translated">ISO 9899: 1999 5.1.2.2 Размещенная среда -&amp;gt; 5.1.2.2.1 Запуск программы</target>
        </trans-unit>
        <trans-unit id="c570e7967aeae8d218c9500d8af0ccbb2c0999ed" translate="yes" xml:space="preserve">
          <source>ISO 9899:1999 5.1.2.2 Hosted environment --&amp;gt; 5.1.2.2.3 Program termination</source>
          <target state="translated">ISO 9899: 1999 5.1.2.2 Размещенная среда -&amp;gt; 5.1.2.2.3 Завершение программы</target>
        </trans-unit>
        <trans-unit id="5adf9fbb580920fe4e8bdb0b93849057aa5eaef0" translate="yes" xml:space="preserve">
          <source>ISO 9899:2011 5.1.2.2 Hosted environment -&amp;gt; 5.1.2.2.1 Program startup</source>
          <target state="translated">ISO 9899: 2011 5.1.2.2 Размещенная среда -&amp;gt; 5.1.2.2.1 Запуск программы</target>
        </trans-unit>
        <trans-unit id="c026b51c24ee5003420193d6a1c30eba041e8812" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1989 (C90):</source>
          <target state="translated">ИЗОЕК 9899:1989 (C90):</target>
        </trans-unit>
        <trans-unit id="7738b221c80b5304b0ca9410b351937992dbdba2" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (C99):</source>
          <target state="translated">ИЗОЙЕК 9899:1999 (С99):</target>
        </trans-unit>
        <trans-unit id="0dff1e972d7a65190eb694ffe563008167981bd6" translate="yes" xml:space="preserve">
          <source>If an implementation permits it, &lt;code&gt;main()&lt;/code&gt; can be declared in other ways, but this makes the program implementation defined, and no longer strictly conforming.</source>
          <target state="translated">Если реализация разрешает это, &lt;code&gt;main()&lt;/code&gt; может быть объявлена ​​другими способами, но это делает реализацию программы определенной и больше не строго соответствующей.</target>
        </trans-unit>
        <trans-unit id="36650763e12f75f89b51f84868ae093852daf601" translate="yes" xml:space="preserve">
          <source>If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;</source>
          <target state="translated">Если элемент управления достигает конца основного,не встречая возвратного сообщения,то это приводит к выполнению возвратного сообщения 0;</target>
        </trans-unit>
        <trans-unit id="f306c8b2bb84020137c0b44d4df475b5a3dfaf8b" translate="yes" xml:space="preserve">
          <source>If int main() then return 1 or return 0?</source>
          <target state="translated">Если int main(),то вернуть 1 или вернуть 0?</target>
        </trans-unit>
        <trans-unit id="bbe13bc0ccc90c42b104135b14e3c3f18c8e40da" translate="yes" xml:space="preserve">
          <source>If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;11) reaching the &lt;code&gt;}&lt;/code&gt; that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified.</source>
          <target state="translated">Если возвращаемый тип главной функции является типом, совместимым с int, возврат из начального вызова основной функции эквивалентен вызову функции выхода со значением, возвращаемым главной функцией в качестве аргумента; 11) достижение &lt;code&gt;}&lt;/code&gt; , который прекращает, основная функция возвращает значение 0. Если тип возвращаемого значения не совместим с int, состояние завершения, возвращаемое в среду хоста, не указывается.</target>
        </trans-unit>
        <trans-unit id="80d38b087bcd0bf8f8ae646ae8cfc61a04ed675e" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the array members &lt;code&gt;argv[0]&lt;/code&gt; through
  &lt;code&gt;argv[argc-1]&lt;/code&gt; inclusive shall contain pointers to strings, which are given
  implementation-defined values by the host environment prior to program startup. The
  intent is to supply to the program information determined prior to program startup
  from elsewhere in the hosted environment. If the host environment is not capable of
  supplying strings with letters in both uppercase and lowercase, the implementation
  shall ensure that the strings are received in lowercase.</source>
          <target state="translated">Если значение &lt;code&gt;argc&lt;/code&gt; больше нуля, члены массива от &lt;code&gt;argv[0]&lt;/code&gt; до &lt;code&gt;argv[argc-1]&lt;/code&gt; включительно должны содержать указатели на строки, которым перед установкой программы передаются значения, определяемые реализацией средой хоста. Намерение состоит в том, чтобы предоставить программе информацию, определенную до ее запуска, из другой части размещенной среды. Если среда хоста не способна снабжать строки буквами как в верхнем, так и в нижнем регистре, реализация должна обеспечивать получение строк в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="5477192590999db427c7b99a724d15f14138992a" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;argc&lt;/code&gt; is greater than zero, the string pointed to by &lt;code&gt;argv[0]&lt;/code&gt;
  represents the program name; &lt;code&gt;argv[0][0]&lt;/code&gt; shall be the null character if the
  program name is not available from the host environment. If the value of &lt;code&gt;argc&lt;/code&gt; is
  greater than one, the strings pointed to by &lt;code&gt;argv[1]&lt;/code&gt; through &lt;code&gt;argv[argc-1]&lt;/code&gt;
  represent the program parameters.</source>
          <target state="translated">Если значение &lt;code&gt;argc&lt;/code&gt; больше нуля, строка, на которую указывает &lt;code&gt;argv[0]&lt;/code&gt; представляет имя программы; &lt;code&gt;argv[0][0]&lt;/code&gt; должен быть нулевым символом, если имя программы недоступно из среды хоста. Если значение &lt;code&gt;argc&lt;/code&gt; больше единицы, строки, на которые указывают &lt;code&gt;argv[1]&lt;/code&gt; &lt;code&gt;argv[argc-1]&lt;/code&gt; представляют параметры программы.</target>
        </trans-unit>
        <trans-unit id="83b323b3be8c3ef77aecb667889dc3dd68d116df" translate="yes" xml:space="preserve">
          <source>If they are declared, the parameters to the main function shall obey the following
  constraints:</source>
          <target state="translated">Если они объявляются,то параметры основной функции должны соответствовать следующим ограничениям:</target>
        </trans-unit>
        <trans-unit id="d1a5b964a486551cab1f4315aeb05a3560a45f00" translate="yes" xml:space="preserve">
          <source>If you are doing this (call a process so many times), you should find a way to put your logic directly inside the caller, or in a DLL file, without allocate a specific process for each call; the multiple process allocations bring you the relevant efficiency problem in this case.</source>
          <target state="translated">Если вы делаете это (столько раз вызываете процесс),вы должны найти способ поместить свою логику непосредственно внутри вызывающего абонента,или в файл DLL,без выделения конкретного процесса для каждого вызова;многократное выделение процессов приносит вам соответствующую проблему эффективности в этом случае.</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">Если ты это сделаешь</target>
        </trans-unit>
        <trans-unit id="483a23176183f6c1305e90f13f59c790a7cd8b33" translate="yes" xml:space="preserve">
          <source>If you do not write a return statement in &lt;code&gt;int main()&lt;/code&gt;, the closing &lt;code&gt;{&lt;/code&gt; will return 0 by default.</source>
          <target state="translated">Если вы не пишете оператор возврата в &lt;code&gt;int main()&lt;/code&gt; , закрывающий &lt;code&gt;{&lt;/code&gt; по умолчанию вернет 0.</target>
        </trans-unit>
        <trans-unit id="850185e652bcc3094867daff9db6c1960eaf3346" translate="yes" xml:space="preserve">
          <source>If you really have issues related to efficiency of returning an integer from a process, you should probably avoid to call that process so many times that this return value becomes an issue.</source>
          <target state="translated">Если у вас действительно есть проблемы,связанные с эффективностью возврата целого числа из процесса,вам,вероятно,следует избегать вызовов этого процесса столько раз,что это возвращаемое значение становится проблемой.</target>
        </trans-unit>
        <trans-unit id="52092fcdfb7b4fbe87c5392e56ec14ab62dfac60" translate="yes" xml:space="preserve">
          <source>In C89 (and hence in Microsoft C), there is no statement about what happens if the &lt;code&gt;main()&lt;/code&gt; function returns but does not specify a return value; it therefore leads to undefined behaviour.</source>
          <target state="translated">В C89 (и, следовательно, в Microsoft C) нет заявления о том, что произойдет, если функция &lt;code&gt;main()&lt;/code&gt; вернется, но не определит возвращаемое значение; следовательно, это ведет к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="c87cc4b10f829842d58cbb57cfa34ee20cb520f0" translate="yes" xml:space="preserve">
          <source>In Unix and DOS scripting, &lt;code&gt;return 0&lt;/code&gt; on success and non-zero for error are usually returned. This is the standard used by Unix and DOS scripting to find out what happened with your program and controlling the whole flow.</source>
          <target state="translated">В сценариях Unix и DOS обычно &lt;code&gt;return 0&lt;/code&gt; в случае успеха и ненулевое значение в случае ошибки. Это стандарт, используемый сценариями Unix и DOS для выяснения того, что произошло с вашей программой, и контроля всего потока.</target>
        </trans-unit>
        <trans-unit id="8eaed3f6bd24cf0c2bf1a5f18894bccff46da0ac" translate="yes" xml:space="preserve">
          <source>In a freestanding environment (in which C program execution may take
  place without any benefit of an operating system), the name and type
  of the function called at program startup are implementation-defined.</source>
          <target state="translated">В отдельно стоящей среде (в которой выполнение программы на языке Си может происходить без каких-либо преимуществ операционной системы)имя и тип функции,вызываемой при запуске программы,определяются ее реализацией.</target>
        </trans-unit>
        <trans-unit id="e8f9653053b16c99b1cfc10e334bf69a6adf9d71" translate="yes" xml:space="preserve">
          <source>In a freestanding environment (in which C program execution may take place without any benefit of an operating system), the name and type of the function called at program startup are implementation-defined. Any library facilities available to a freestanding program, other than the minimal set required by clause 4, are implementation-defined.</source>
          <target state="translated">В отдельно стоящей среде (в которой выполнение программы на языке Си может происходить без каких-либо преимуществ операционной системы)имя и тип функции,вызываемой при запуске программы,определяются ее реализацией.Любые библиотечные возможности,доступные отдельно стоящей программе,кроме минимального набора,требуемого п.4,определяются реализацией.</target>
        </trans-unit>
        <trans-unit id="7e3919889d260828538ebba4f914ae5c8021bc7c" translate="yes" xml:space="preserve">
          <source>In detail, if you only want to know if returning 0 is more or less efficient than returning 1, it could depend from the compiler in some cases, but generically, assuming they are read from the same source (local, field, constant, embedded in the code, function result, etc.) it requires exactly the same number of clock cycles.</source>
          <target state="translated">Подробнее,если вы хотите знать только,более или менее эффективно ли возврат 0,чем возврат 1,то в некоторых случаях это может зависеть от компилятора,но в общем случае,предполагая,что они читаются из одного и того же источника (локального,полевого,константного,встроенного в код,результата функции и т.д.),это требует точно такого же количества тактовых импульсов.</target>
        </trans-unit>
        <trans-unit id="77bca36b5e136be0307abf4a901e487488fb4541" translate="yes" xml:space="preserve">
          <source>In the latter form &lt;code&gt;argc&lt;/code&gt; shall be the number of arguments passed to the program from the environment
  in which the program is run. If &lt;code&gt;argc&lt;/code&gt; is nonzero these arguments shall be supplied in &lt;code&gt;argv[0]&lt;/code&gt;
  through &lt;code&gt;argv[argc-1]&lt;/code&gt; as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and &lt;code&gt;argv[0]&lt;/code&gt; shall be the pointer to the initial character of a NTMBS that represents the
  name used to invoke the program or &lt;code&gt;&quot;&quot;&lt;/code&gt;. The value of &lt;code&gt;argc&lt;/code&gt; shall be non-negative. The value of &lt;code&gt;argv[argc]&lt;/code&gt;
  shall be 0. [ Note: It is recommended that any further (optional) parameters be added after &lt;code&gt;argv&lt;/code&gt;. &amp;mdash;end
  note ]</source>
          <target state="translated">В последней форме &lt;code&gt;argc&lt;/code&gt; - это число аргументов, переданных программе из среды, в которой она запущена. Если &lt;code&gt;argc&lt;/code&gt; отлично от нуля, эти аргументы должны быть переданы в &lt;code&gt;argv[0]&lt;/code&gt; через &lt;code&gt;argv[argc-1]&lt;/code&gt; как указатели на начальные символы многобайтовых строк с нулевым символом в конце (NTMBS) (17.5.2.1.4.2) и &lt;code&gt;argv[0]&lt;/code&gt; должны быть указатель на начальный символ NTMBS, который представляет имя, используемое для вызова программы или &lt;code&gt;&quot;&quot;&lt;/code&gt; . Значение &lt;code&gt;argc&lt;/code&gt; должно быть неотрицательным. Значение &lt;code&gt;argv[argc]&lt;/code&gt; должно быть 0. [Примечание: Рекомендуется добавлять любые дополнительные (необязательные) параметры после &lt;code&gt;argv&lt;/code&gt; . &amp;mdash;Конечная записка]</target>
        </trans-unit>
        <trans-unit id="edd6065f0058ea6d8f4719347b7def37199e2a44" translate="yes" xml:space="preserve">
          <source>Interestingly, MS does not prescribe the two-argument version of &lt;code&gt;main()&lt;/code&gt; that the C and C++ standards require. It only prescribes a three argument form where the third argument is &lt;code&gt;char **envp&lt;/code&gt;, a pointer to a list of environment variables.</source>
          <target state="translated">Интересно, что MS не предписывает версию &lt;code&gt;main()&lt;/code&gt; с двумя аргументами, которая требуется для стандартов C и C ++. Он только предписывает форму с тремя аргументами, где третий аргумент - &lt;code&gt;char **envp&lt;/code&gt; , указатель на список переменных среды.</target>
        </trans-unit>
        <trans-unit id="067bd54d24cbf0d635c159524fc85653cf8d1376" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;char *envp[]&lt;/code&gt; as a third argument to &lt;code&gt;main()&lt;/code&gt; portable?</source>
          <target state="translated">Является ли &lt;code&gt;char *envp[]&lt;/code&gt; в качестве третьего аргумента &lt;code&gt;main()&lt;/code&gt; переносимым?</target>
        </trans-unit>
        <trans-unit id="01cfa03c02ebf6b8044d17ebc260a7a7e23f1bc7" translate="yes" xml:space="preserve">
          <source>It also can be checked when you call a process yourself, and see if the program exited and finished properly.</source>
          <target state="translated">Ее также можно проверить,когда вы сами вызываете процесс,и посмотреть,правильно ли программа вышла и закончила работу.</target>
        </trans-unit>
        <trans-unit id="743cc09a1d17dd8e6d9ef3423b452c2f4c20a21e" translate="yes" xml:space="preserve">
          <source>It is also worth noting that in C++, &lt;code&gt;int main()&lt;/code&gt; can be left without a return-statement, at which point it defaults to returning 0. This is also true with a C99 program. Whether &lt;code&gt;return 0;&lt;/code&gt; should be omitted or not is open to debate. The range of valid C program main signatures is much greater.</source>
          <target state="translated">Также стоит отметить, что в C ++ &lt;code&gt;int main()&lt;/code&gt; можно оставить без оператора return, после чего он по умолчанию возвращает 0. Это также верно для программы на C99. Будь &lt;code&gt;return 0;&lt;/code&gt; должен быть опущен или не является открытым для обсуждения. Диапазон действительных основных сигнатур программы на Си намного больше.</target>
        </trans-unit>
        <trans-unit id="eba4f3e259ceb0adf19ace0c32c1391d84cbfe54" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether a program in a freestanding environment is required to define a main function.</source>
          <target state="translated">Реализация-определяется,требуется ли программа в отдельно стоящей среде для определения основной функции.</target>
        </trans-unit>
        <trans-unit id="3d63d53707bc8469db68ce1f74c203b133e06b93" translate="yes" xml:space="preserve">
          <source>It is not clear to me what happens (what exit code is returned to the parent or OS) when a program with &lt;code&gt;void main()&lt;/code&gt; does exit &amp;mdash; and the MS web site is silent too.</source>
          <target state="translated">Мне не ясно, что происходит (какой код выхода возвращается родительскому или ОС), когда программа с &lt;code&gt;void main()&lt;/code&gt; завершает работу - и веб-сайт MS тоже молчит.</target>
        </trans-unit>
        <trans-unit id="d1b1f744a8f0f327fd7f8ac8646e483671c5281c" translate="yes" xml:space="preserve">
          <source>It is noticeable that the only header required of a freestanding environment that actually defines any functions is &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; (and even those may be &amp;mdash; and often are &amp;mdash; just macros).</source>
          <target state="translated">Заметно, что единственный отдельный заголовок, необходимый для автономной среды, которая фактически определяет какие-либо функции, - это &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; (и даже они могут быть - и часто являются - просто макросами).</target>
        </trans-unit>
        <trans-unit id="f0d85260bc0a36b034db5734d9715240a02623e7" translate="yes" xml:space="preserve">
          <source>It's &lt;strong&gt;NOT&lt;/strong&gt; just a programming convention.</source>
          <target state="translated">Это &lt;strong&gt;НЕ&lt;/strong&gt; просто соглашение о программировании.</target>
        </trans-unit>
        <trans-unit id="777237599abc671bc567b78dd552b08e24fe0ff7" translate="yes" xml:space="preserve">
          <source>It's not what &lt;em&gt;should&lt;/em&gt;&lt;code&gt;main()&lt;/code&gt; return, it's what &lt;em&gt;does&lt;/em&gt;&lt;code&gt;main()&lt;/code&gt; return.  &lt;code&gt;main()&lt;/code&gt; is, of course, a function that someone else calls.  You don't have any control over the code that calls &lt;code&gt;main()&lt;/code&gt;.  Therefore, you must declare &lt;code&gt;main()&lt;/code&gt; with a type-correct signature to match its caller.  You simply don't have any choice in the matter.  You don't have to ask yourself what's more or less efficient, or what's better or worse style, or anything like that, because the answer is already perfectly well defined, for you, by the C and C+ standards.  Just follow them.</source>
          <target state="translated">Это не то, что &lt;em&gt;должно&lt;/em&gt; возвращать &lt;code&gt;main()&lt;/code&gt; , это то, что возвращает &lt;code&gt;main()&lt;/code&gt; . Конечно, &lt;code&gt;main()&lt;/code&gt; - это функция, которую кто-то вызывает. Вы не имеете никакого контроля над кодом, который вызывает &lt;code&gt;main()&lt;/code&gt; . Следовательно, вы должны объявить &lt;code&gt;main()&lt;/code&gt; с правильной сигнатурой, чтобы соответствовать вызывающей стороне. У вас просто нет выбора в этом вопросе. Вам не нужно спрашивать себя, что является более или менее эффективным, что лучше или хуже, или что-то в этом роде, потому что ответ для вас уже совершенно четко определен стандартами C и C +. Просто следуй за ними.</target>
        </trans-unit>
        <trans-unit id="ceda7d6ce3400641cfc2d2b305e73a181d717c83" translate="yes" xml:space="preserve">
          <source>J.5.1 Environment arguments</source>
          <target state="translated">J.5.1 Окружающая среда</target>
        </trans-unit>
        <trans-unit id="4646a05e59e1cdcc72d17eecf0ad0e9d72001305" translate="yes" xml:space="preserve">
          <source>Just as the C standard recognizes both hosted and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC 14882:2011.)</source>
          <target state="translated">Точно так же,как стандарт C распознает как хостируемую,так и отдельную среду,так и стандарт C++тоже.(Цитаты из ISOIEC 14882:2011).</target>
        </trans-unit>
        <trans-unit id="1cf33a289910a38b27ccf6fc406b6febbdf1f1a7" translate="yes" xml:space="preserve">
          <source>Keep in mind that,even though you're returning an int, some OSes (Windows) truncate the returned value to a single byte (0-255).</source>
          <target state="translated">Имейте в виду,что даже если вы возвращаете int,некоторые ОС (Windows)усекают возвращаемое значение до одного байта (0-255).</target>
        </trans-unit>
        <trans-unit id="52e3d5ebdbc06938d8f3e9175e5789910e8284cc" translate="yes" xml:space="preserve">
          <source>Legal definitions of &lt;code&gt;main()&lt;/code&gt; in C++14?</source>
          <target state="translated">Правовые определения &lt;code&gt;main()&lt;/code&gt; в C ++ 14?</target>
        </trans-unit>
        <trans-unit id="82be7a55804dc08de0168f6f592f149c8a430e44" translate="yes" xml:space="preserve">
          <source>Microsoft C</source>
          <target state="translated">Microsoft C</target>
        </trans-unit>
        <trans-unit id="73d9e90f1eeed7db4c1746200a40ba2e4ac70074" translate="yes" xml:space="preserve">
          <source>Must the &lt;code&gt;int main()&lt;/code&gt; function return a value in all compilers?</source>
          <target state="translated">Должна ли функция &lt;code&gt;int main()&lt;/code&gt; возвращать значение во всех компиляторах?</target>
        </trans-unit>
        <trans-unit id="2e35d4f77f18bcad3aefd139f948af15aa758b72" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;0&lt;/code&gt; is mandated as 'success'. You can use &lt;code&gt;EXIT_FAILURE&lt;/code&gt; and &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; from &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; if you prefer, but 0 is well established, and so is 1. See also &lt;a href=&quot;https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/&quot;&gt;Exit codes greater than 255 &amp;mdash; possible?&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;0&lt;/code&gt; обозначено как &amp;laquo;успех&amp;raquo;. Вы можете использовать &lt;code&gt;EXIT_FAILURE&lt;/code&gt; и &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; из &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; , если предпочитаете, но 0 точно установлено, и так же, как и 1. См. Также &lt;a href=&quot;https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/&quot;&gt;Коды выхода больше 255 - возможно?&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="bc19499ce0cd6befeb6d4ac0455d6a31e63efae2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;int main()&lt;/code&gt; was never listed as a valid form for any hosted implementation of C in any of the above versions. In C, unlike C++, &lt;code&gt;()&lt;/code&gt; and &lt;code&gt;(void)&lt;/code&gt; have different meanings. The former is an obsolescent feature which may be removed from the language. See C11 future language directions:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;int main()&lt;/code&gt; никогда не был указан в качестве допустимой формы для любой размещенной реализации C в любой из вышеуказанных версий. В C, в отличие от C ++, &lt;code&gt;()&lt;/code&gt; и &lt;code&gt;(void)&lt;/code&gt; имеют разные значения. Первый является устаревшей функцией, которая может быть удалена из языка. Смотрите C11 будущие языковые направления:</target>
        </trans-unit>
        <trans-unit id="2a43cb795cc790685cb419ee571a160ade1ccb63" translate="yes" xml:space="preserve">
          <source>Note that the C and C++ standards define two kinds of implementations: freestanding and hosted.</source>
          <target state="translated">Обратите внимание,что стандарты C и C++определяют два типа реализаций:отдельно стоящие и хостируемые.</target>
        </trans-unit>
        <trans-unit id="99eaa646b7b6e0082dbd4a6adae2c494f9eec0c8" translate="yes" xml:space="preserve">
          <source>Note the empty parenthesis in the first form. C++ and C are different in this case, because in C++ this means that the function takes no parameters. But in C it means that it may take any parameter.</source>
          <target state="translated">Обратите внимание на пустые скобки в первом виде.В данном случае C++и C отличаются,так как в C++это означает,что функция не принимает параметров.Но в Си это означает,что она может принять любой параметр.</target>
        </trans-unit>
        <trans-unit id="546cad710ccd581eadc450a0c74833e5bcaa545e" translate="yes" xml:space="preserve">
          <source>Now the following bash script (simply type it in a Linux terminal) although very basic should give some idea of error handling:</source>
          <target state="translated">Теперь следующий bash скрипт (просто введите его в терминале Linux),хотя очень простой должен дать некоторое представление об обработке ошибок:</target>
        </trans-unit>
        <trans-unit id="bb080a0718df6542d4433b03a9323560b055bb4d" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;return 0&lt;/code&gt;</source>
          <target state="translated">Пропустить &lt;code&gt;return 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71453973d6cd4b7d6dce02765e1aeb2c794927d7" translate="yes" xml:space="preserve">
          <source>Or equivalent. For example, &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt; is equivalent to the second one. Further, the &lt;code&gt;int&lt;/code&gt; return type can be omitted as it is a default.</source>
          <target state="translated">Или эквивалент. Например, &lt;code&gt;int main(int argc, char *argv[])&lt;/code&gt; эквивалентен второму. Кроме того, тип возвращаемого значения &lt;code&gt;int&lt;/code&gt; может быть опущен, так как это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1b4a599777a8efd1033fda40d60a3ac6da68728f" translate="yes" xml:space="preserve">
          <source>Program termination in C99 or C11</source>
          <target state="translated">Завершение программы в C99 или C11</target>
        </trans-unit>
        <trans-unit id="663f993e9b4f3d44ef4c0329debae8aeebbf12e3" translate="yes" xml:space="preserve">
          <source>Rationale for International Standard &amp;mdash; Programming Languages &amp;mdash; C, Revision 5.10. 5.1.2.2 Hosted environment --&amp;gt; 5.1.2.2.1 Program startup</source>
          <target state="translated">Обоснование международного стандарта - языки программирования - C, редакция 5.10. 5.1.2.2 Размещенная среда -&amp;gt; 5.1.2.2.1 Запуск программы</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="06951cda41c4c25e07384cc2d791df8051ddc4f0" translate="yes" xml:space="preserve">
          <source>Return 0 on success and non-zero for error. This is the standard used by UNIX and DOS scripting to find out what happened with your program.</source>
          <target state="translated">Возврат 0 в случае успеха и ненулевой в случае ошибки.Это стандарт,используемый UNIX и DOS-скриптингом,чтобы узнать,что случилось с вашей программой.</target>
        </trans-unit>
        <trans-unit id="c25bf9ecf87e37204aff4b7cbc681350ca825d5e" translate="yes" xml:space="preserve">
          <source>Return type of &lt;code&gt;main()&lt;/code&gt; method in C</source>
          <target state="translated">Возвращаемый тип метода &lt;code&gt;main()&lt;/code&gt; в C</target>
        </trans-unit>
        <trans-unit id="3675c5cbc8a91d96194988edd341f2880e76b8d4" translate="yes" xml:space="preserve">
          <source>Return value 0 usually means OK in most operating systems (the ones I can think of anyway).</source>
          <target state="translated">Возвращаемое значение 0 обычно означает OK в большинстве операционных систем (те,о которых я могу думать в любом случае).</target>
        </trans-unit>
        <trans-unit id="7e87f801e2a286959cf6dbceaaf5200c563638ca" translate="yes" xml:space="preserve">
          <source>Returning 0 should tell the programmer that the program has successfully finished the job.</source>
          <target state="translated">Возврат 0 должен сообщить программисту,что программа успешно выполнила задание.</target>
        </trans-unit>
        <trans-unit id="d0d3720869171e755af6d0b0e9c8fa9c47bded55" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/q/8626109/775964&quot;&gt;How can I get what my main function has returned?&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://stackoverflow.com/q/8626109/775964&quot;&gt;Как я могу получить то, что вернула моя основная функция?&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="58c7663db54efd33586550979f6f35585936911c" translate="yes" xml:space="preserve">
          <source>Since grep failed to match the token &quot;foo&quot; with the content of our file the return code is 1 (this is the usual case when a failure occurs but as stated above you have plenty of values to choose from).</source>
          <target state="translated">Так как grep не смог сопоставить маркер &quot;foo&quot; с содержимым нашего файла,код возврата равен 1 (это обычный случай,когда происходит сбой,но,как было сказано выше,у вас есть множество значений на выбор).</target>
        </trans-unit>
        <trans-unit id="58e729ae862197d2b4b8edf3be6c045cd942acef" translate="yes" xml:space="preserve">
          <source>So I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you'll know that it's explicitly supported by the standard and you'll know what it means.</source>
          <target state="translated">Поэтому я выступаю за то,чтобы пропустить его;другие не согласны (часто яростно!)В любом случае,если вы столкнетесь с кодом,который пропускает его,вы будете знать,что он явно поддерживается стандартом,и вы будете знать,что он означает.</target>
        </trans-unit>
        <trans-unit id="191c9d7581d1bc67cbc4954e3995712f84c74941" translate="yes" xml:space="preserve">
          <source>Some compilers have chosen to interpret the standard in the latter way. Arguably, one cannot easily state that they are not strictly conforming by citing the standard in itself, since it is is ambiguous.</source>
          <target state="translated">Некоторые компиляторы решили интерпретировать стандарт последним способом.Вероятно,нелегко утверждать,что они не совсем соответствуют,ссылаясь на стандарт как таковой,так как он неоднозначен.</target>
        </trans-unit>
        <trans-unit id="f98b7a7fbe66aa30604d46c9c186df5e7d476f7a" translate="yes" xml:space="preserve">
          <source>Standard C &amp;mdash; Common Extension</source>
          <target state="translated">Стандарт C - Общее расширение</target>
        </trans-unit>
        <trans-unit id="559fce21984836e0b4c09f404ccadb796a238608" translate="yes" xml:space="preserve">
          <source>Standard C &amp;mdash; Freestanding Environment</source>
          <target state="translated">Стандарт С - автономная среда</target>
        </trans-unit>
        <trans-unit id="bf0058befe2fe0784752a61367cd774b2170e902" translate="yes" xml:space="preserve">
          <source>Standard C &amp;mdash; Hosted Environment</source>
          <target state="translated">Стандарт С - размещенная среда</target>
        </trans-unit>
        <trans-unit id="ead9983c448c82a4bc2e4fa329267dd58510e74c" translate="yes" xml:space="preserve">
          <source>Standard C++ &amp;mdash; Freestanding Environment</source>
          <target state="translated">Стандарт C ++ - автономная среда</target>
        </trans-unit>
        <trans-unit id="17c880ba258c61c1f081e4f92072401258328c3f" translate="yes" xml:space="preserve">
          <source>Standard C++ &amp;mdash; Hosted Environment</source>
          <target state="translated">Стандарт C ++ - Хостинг-среда</target>
        </trans-unit>
        <trans-unit id="9e9bfc97678e1deb8fecca963cb28baa3742ac8f" translate="yes" xml:space="preserve">
          <source>Styles of &lt;code&gt;main()&lt;/code&gt; functions in C</source>
          <target state="translated">Стили функций &lt;code&gt;main()&lt;/code&gt; в C</target>
        </trans-unit>
        <trans-unit id="c32251a4dd807171928d97ccdcdf5412b6e1b584" translate="yes" xml:space="preserve">
          <source>Table 16 &amp;mdash; C++ headers for freestanding implementations</source>
          <target state="translated">Таблица 16 - Заголовки C ++ для автономных реализаций</target>
        </trans-unit>
        <trans-unit id="0b88a0ea077a1c835e53dcb3e5afe37a4a6880f1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx&quot;&gt;Microsoft VS 2010&lt;/a&gt; compiler is interesting. The web site says:</source>
          <target state="translated">Компилятор &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx&quot;&gt;Microsoft VS 2010&lt;/a&gt; интересен. Веб-сайт говорит:</target>
        </trans-unit>
        <trans-unit id="8364d6bdc8c6440426e1ae40049191ae42429996" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; return type may not be omitted.</source>
          <target state="translated">Тип возвращаемого значения &lt;code&gt;int&lt;/code&gt; не может быть опущен.</target>
        </trans-unit>
        <trans-unit id="1cf16e3e7d80a6df169adb6cfe5d5a70bd761eb9" translate="yes" xml:space="preserve">
          <source>The C++ standard explicitly says &quot;It [the main function] shall have a return type of type &lt;code&gt;int&lt;/code&gt;, but otherwise its type is implementation defined&quot;, and requires the same two signatures as the C standard to be supported as options. So a 'void main()' is directly not allowed by the C++ standard, though there's nothing it can do to stop a non-standard implementation allowing alternatives.  Note that C++ forbids the user from calling &lt;code&gt;main&lt;/code&gt; (but the C standard does not).</source>
          <target state="translated">Стандарт C ++ явно говорит: &amp;laquo;Он [основная функция] должен иметь тип возвращаемого значения типа &lt;code&gt;int&lt;/code&gt; , но в противном случае его тип определяется реализацией&amp;raquo;, и для поддержки в качестве опций требуются те же две подписи, что и для стандарта C. Так что void main () напрямую не разрешен стандартом C ++, хотя он ничего не может сделать, чтобы остановить нестандартную реализацию, допускающую альтернативы. Обратите внимание, что C ++ запрещает пользователю вызывать &lt;code&gt;main&lt;/code&gt; (но стандарт C этого не делает).</target>
        </trans-unit>
        <trans-unit id="8ffaebd7ec7fa463926f599cf1254982eb713376" translate="yes" xml:space="preserve">
          <source>The C++11 standard (ISO/IEC 14882:2011) says:</source>
          <target state="translated">Стандарт C++11 (ISOIEC 14882:2011)гласит:</target>
        </trans-unit>
        <trans-unit id="4a496911a1450193efc097e191321a84e102d3d2" translate="yes" xml:space="preserve">
          <source>The Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2005&lt;/a&gt; version of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx&quot;&gt;this page&lt;/a&gt; does not list &lt;code&gt;void main()&lt;/code&gt; as an alternative.  The &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx&quot;&gt;versions&lt;/a&gt; from Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008&quot;&gt;Visual&amp;nbsp;Studio&amp;nbsp;2008&lt;/a&gt; onwards do.</source>
          <target state="translated">Версия &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx&quot;&gt;этой страницы для&lt;/a&gt; Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005&quot;&gt;Visual Studio 2005&lt;/a&gt; не перечисляет &lt;code&gt;void main()&lt;/code&gt; в качестве альтернативы. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx&quot;&gt;Версии&lt;/a&gt; от Microsoft &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008&quot;&gt;Visual Studio 2008 и&lt;/a&gt; выше делают.</target>
        </trans-unit>
        <trans-unit id="33cca83a9e2b339c3446cbab746394360baf8d65" translate="yes" xml:space="preserve">
          <source>The Microsoft page also lists some other alternatives &amp;mdash; &lt;code&gt;wmain()&lt;/code&gt; which takes wide character strings, and some more.</source>
          <target state="translated">На странице Microsoft также перечислены некоторые другие альтернативы - &lt;code&gt;wmain()&lt;/code&gt; которая принимает строки широких символов, и некоторые другие.</target>
        </trans-unit>
        <trans-unit id="7b0070d4ea6e95a967d24e8102c2d33f422b3fe2" translate="yes" xml:space="preserve">
          <source>The accepted answer appears to be targetted for C++, so I thought I'd add an answer that pertains to C, and this differs in a few ways.</source>
          <target state="translated">Принятый ответ,похоже,ориентирован на C++,поэтому я решил добавить ответ,относящийся к C,и это отличается от ответа несколькими способами.</target>
        </trans-unit>
        <trans-unit id="546b26c20b5018e8e91b597a6abc305d7ad960ec" translate="yes" xml:space="preserve">
          <source>The behavior of the arguments to main, and of the interaction of exit, main and atexit
  (see &amp;sect;7.20.4.2) has been codified to curb some unwanted variety in the representation of argv
  strings, and in the meaning of values returned by main.</source>
          <target state="translated">Поведение аргументов main и взаимодействия exit, main и atexit (см. &amp;sect;7.20.4.2) было кодифицировано, чтобы обуздать некоторое нежелательное разнообразие в представлении строк argv и в значении значений, возвращаемых main.</target>
        </trans-unit>
        <trans-unit id="a1332b3e9a470eb6ea2ea721bb6e42f19fd7ef60" translate="yes" xml:space="preserve">
          <source>The cross-reference to clause 4 Conformance refers to this:</source>
          <target state="translated">На это указывает перекрестная ссылка на п.4 Соответствие:</target>
        </trans-unit>
        <trans-unit id="dc11d899a2bbef6b7ca7ebc05f3a76f63e6b3145" translate="yes" xml:space="preserve">
          <source>The declaration syntax for main is</source>
          <target state="translated">Синтаксис декларации для основного</target>
        </trans-unit>
        <trans-unit id="54d077d6bc220b344cc0c2c98d6bff99a69286f5" translate="yes" xml:space="preserve">
          <source>The effect of program termination in a freestanding environment is implementation-defined.</source>
          <target state="translated">Эффект завершения программы в отдельно стоящей среде определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="d7cf7c56944bc0e60c66b4dd6a3630c1023a7db0" translate="yes" xml:space="preserve">
          <source>The former two are explicitly stated as the allowed forms, the others are implicitly allowed because C90 allowed &quot;implicit int&quot; for return type and function parameters. No other form is allowed.</source>
          <target state="translated">Первые две формы явно указаны как разрешенные,остальные неявно разрешены,потому что C90 разрешает &quot;неявный int&quot; для возвращаемого типа и параметров функции.Никакая другая форма не разрешена.</target>
        </trans-unit>
        <trans-unit id="026f98c964de0d94f5fb9b6a1e303e50bcc1cdd6" translate="yes" xml:space="preserve">
          <source>The function called at program startup is named &lt;code&gt;main&lt;/code&gt;. The implementation declares no
  prototype for this function. It shall be defined with a return type of &lt;code&gt;int&lt;/code&gt; and with no
  parameters:</source>
          <target state="translated">Функция, вызываемая при запуске программы, называется &lt;code&gt;main&lt;/code&gt; . Реализация не объявляет прототип для этой функции. Он должен быть определен с типом возврата &lt;code&gt;int&lt;/code&gt; и без параметров:</target>
        </trans-unit>
        <trans-unit id="ca5968af6b9e074a35418f4f286474743cccbd2c" translate="yes" xml:space="preserve">
          <source>The function called at program startup is named main. The
  implementation declares no prototype for this function. It shall be
  defined with a return type of int and with no parameters:</source>
          <target state="translated">Функция,вызываемая при запуске программы,называется основной.Реализация не объявляет прототипа этой функции.Она должна быть определена с возвращаемым типом int и без параметров:</target>
        </trans-unit>
        <trans-unit id="0ae03504835ac4c96ab05373731aeafea22c07c0" translate="yes" xml:space="preserve">
          <source>The name of the function called at startup is implementation-defined. If it is named &lt;code&gt;main()&lt;/code&gt; it must follow the stated forms &lt;sup&gt;10&lt;/sup&gt;:</source>
          <target state="translated">Имя функции, вызываемой при запуске, определяется реализацией. Если он назван &lt;code&gt;main()&lt;/code&gt; он должен следовать указанным формам &lt;sup&gt;10&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="42cedb16b5fd329909d8d618d881e9149d7c8ddf" translate="yes" xml:space="preserve">
          <source>The name of the function called at startup is implementation-defined. If it is named &lt;code&gt;main()&lt;/code&gt; it must follow the stated forms &lt;sup&gt;12&lt;/sup&gt;:</source>
          <target state="translated">Имя функции, вызываемой при запуске, определяется реализацией. Если он назван &lt;code&gt;main()&lt;/code&gt; он должен следовать указанным формам &lt;sup&gt;12&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="f411eabfea18f4d722bb32c090c81895998e01e5" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; and the strings pointed to by the &lt;code&gt;argv&lt;/code&gt; array shall
  be modifiable by the program, and retain their last-stored values between program
  startup and program termination.</source>
          <target state="translated">Параметры &lt;code&gt;argc&lt;/code&gt; и &lt;code&gt;argv&lt;/code&gt; и строки, на которые указывает массив &lt;code&gt;argv&lt;/code&gt; , должны изменяться программой и сохранять свои последние сохраненные значения между запуском программы и ее завершением.</target>
        </trans-unit>
        <trans-unit id="71f2b4381bd48e53fc5bf7bb37600cda30ef7a72" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;main()&lt;/code&gt; function</source>
          <target state="translated">Тип возвращаемого значения функции &lt;code&gt;main()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30c22afa61a69f090f04a4b51d6f0da94397dc2d" translate="yes" xml:space="preserve">
          <source>The return value can be used by the operating system to check how the program was closed.</source>
          <target state="translated">Возвращаемое значение может быть использовано операционной системой для проверки того,как программа была закрыта.</target>
        </trans-unit>
        <trans-unit id="ba1f12ca047f8d89e6d47cc78475d9dc71642ebe" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;main&lt;/code&gt; indicates how the program exited. Normal exit is represented by a 0 return value from &lt;code&gt;main&lt;/code&gt;. Abnormal exit is signaled by a non-zero return, but there is no standard for how non-zero codes are interpreted. As noted by others, &lt;code&gt;void main()&lt;/code&gt; is prohibited by the C++ standard and should not be used. The valid C++ &lt;code&gt;main&lt;/code&gt; signatures are:</source>
          <target state="translated">Возвращаемое значение для &lt;code&gt;main&lt;/code&gt; указывает, как программа вышла. Нормальный выход представлен 0 возвращаемым значением из &lt;code&gt;main&lt;/code&gt; . Ненормальный выход сигнализируется ненулевым возвратом, но не существует стандарта для интерпретации ненулевых кодов. Как отмечалось другими, &lt;code&gt;void main()&lt;/code&gt; запрещен стандартом C ++ и не должен использоваться. Действительными &lt;code&gt;main&lt;/code&gt; сигнатурами C ++ являются:</target>
        </trans-unit>
        <trans-unit id="22dbe4ab7277e0bacb463020855fe29f4a135940" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;main()&lt;/code&gt; shows how the program exited. If the return value is &lt;code&gt;zero&lt;/code&gt; it means that the execution was successful while any non-zero value will represent that something went bad in the execution.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;main()&lt;/code&gt; показывает, как программа вышла. Если возвращаемое значение равно &lt;code&gt;zero&lt;/code&gt; это означает, что выполнение было успешным, в то время как любое ненулевое значение будет означать, что что-то пошло не так в выполнении.</target>
        </trans-unit>
        <trans-unit id="e22ad7a310bc1d275667315bd2dea731a9a4ebdc" translate="yes" xml:space="preserve">
          <source>The specification of argc and argv as arguments to main recognizes extensive prior practice.
  argv[argc] is required to be a null pointer to provide a redundant check for the end of the list, also on the basis of common practice.</source>
          <target state="translated">Спецификация аргументов argc и argv в качестве аргументов main признает обширную предшествующую практику.argv[argc]должен быть нулевым указателем,чтобы обеспечить избыточную проверку конца списка,также на основе общей практики.</target>
        </trans-unit>
        <trans-unit id="8e2e310f8d276bce8425174414a371db8d39f43f" translate="yes" xml:space="preserve">
          <source>The standard &amp;sect;5.1.2.2.1 of the C11 standard shows the preferred notation &amp;mdash;&amp;nbsp;&lt;code&gt;int main(void)&lt;/code&gt; &amp;mdash; but there are also two examples in the standard which show &lt;code&gt;int main()&lt;/code&gt;: &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8&quot;&gt;&amp;sect;6.5.3.4 &amp;para;8&lt;/a&gt; and &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20&quot;&gt;&amp;sect;6.7.6.3 &amp;para;20&lt;/a&gt;.  Now, it is important to note that examples are not 'normative'; they are only illustrative.  If there are bugs in the examples, they do not directly affect the main text of the standard.  That said, they are strongly indicative of expected behaviour, so if the standard includes &lt;code&gt;int main()&lt;/code&gt; in an example, it suggests that &lt;code&gt;int main()&lt;/code&gt; is not forbidden, even if it is not the preferred notation.</source>
          <target state="translated">Стандарт &amp;sect;5.1.2.2.1 стандарта C11 показывает предпочтительные обозначения - &lt;code&gt;int main(void)&lt;/code&gt; - но в стандарте также есть два примера, которые показывают &lt;code&gt;int main()&lt;/code&gt; : &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8&quot;&gt;&amp;sect;6.5.3.4 &amp;para;8&lt;/a&gt; и &lt;a href=&quot;https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20&quot;&gt;&amp;sect;6.7.6.3 &amp;para;20&lt;/a&gt; . Теперь важно отметить, что примеры не являются &amp;laquo;нормативными&amp;raquo;; они только иллюстративны. Если в примерах есть ошибки, они напрямую не влияют на основной текст стандарта. Тем не менее, они строго указывают на ожидаемое поведение, поэтому, если стандарт включает &lt;code&gt;int main()&lt;/code&gt; в примере, он предполагает, что &lt;code&gt;int main()&lt;/code&gt; не запрещена, даже если это не предпочтительная нотация.</target>
        </trans-unit>
        <trans-unit id="21097dd912cf311cfdb6f22df1d0503ba8d3b181" translate="yes" xml:space="preserve">
          <source>The standard defines 3 values for returning that are strictly conforming (that is, does not rely on implementation defined behaviour): &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; for a successful termination, and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; for an unsuccessful termination. Any other values are non-standard and implementation defined. &lt;code&gt;main()&lt;/code&gt; must have an explicit &lt;code&gt;return&lt;/code&gt; statement at the end to avoid undefined behaviour.</source>
          <target state="translated">Стандарт определяет 3 значения для возврата, которые строго соответствуют (то есть не зависят от поведения, определенного реализацией): &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; для успешного завершения и &lt;code&gt;EXIT_FAILURE&lt;/code&gt; для неуспешного завершения. Любые другие значения являются нестандартными и определяются реализацией. &lt;code&gt;main()&lt;/code&gt; должен быть явный оператор &lt;code&gt;return&lt;/code&gt; в конце, чтобы избежать неопределенного поведения.</target>
        </trans-unit>
        <trans-unit id="04c357fe47330fd474b14115ca9a3a38ddbd2e54" translate="yes" xml:space="preserve">
          <source>The supplied version of the header &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; shall declare at least the functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;atexit&lt;/code&gt;, &lt;code&gt;at_quick_exit&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;quick_exit&lt;/code&gt; (18.5). The other headers listed in this table shall meet the same requirements as for a hosted implementation.</source>
          <target state="translated">Предоставленная версия заголовка &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; должна объявлять как минимум функции &lt;code&gt;abort&lt;/code&gt; , &lt;code&gt;atexit&lt;/code&gt; , &lt;code&gt;at_quick_exit&lt;/code&gt; , &lt;code&gt;exit&lt;/code&gt; и &lt;code&gt;quick_exit&lt;/code&gt; (18.5). Другие заголовки, перечисленные в этой таблице, должны соответствовать тем же требованиям, что и для размещенной реализации.</target>
        </trans-unit>
        <trans-unit id="215b83b15446fc6e768d7de47de3d64d6250e81c" translate="yes" xml:space="preserve">
          <source>The text of the standard has been changed but it has the same meaning.</source>
          <target state="translated">Текст стандарта был изменен,но он имеет то же значение.</target>
        </trans-unit>
        <trans-unit id="3a96141f4a269d89eae9927fca95e222c0774ce2" translate="yes" xml:space="preserve">
          <source>The third argument is a null-terminated list of pointers to strings, each of which is an environment variable which has a name, an equals sign, and a value (possibly empty).  If you do not use this, you can still get at the environment via '&lt;code&gt;extern char **environ;&lt;/code&gt;'.  This global variable is unique among those in POSIX in that it does not have a header that declares it.</source>
          <target state="translated">Третий аргумент представляет собой список указателей на строки с нулевым символом в конце, каждый из которых представляет собой переменную окружения, которая имеет имя, знак равенства и значение (возможно, пустое). Если вы не используете это, вы все равно можете получить доступ к окружению через ' &lt;code&gt;extern char **environ;&lt;/code&gt; &amp;raquo;. Эта глобальная переменная уникальна среди тех, что в POSIX, потому что у нее нет заголовка, который ее объявляет.</target>
        </trans-unit>
        <trans-unit id="f1917f923748d24954167ac87cbedac4efe8c562" translate="yes" xml:space="preserve">
          <source>The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.</source>
          <target state="translated">Использование деклараторов функций с пустыми скобками (а не деклараторов типа параметра прототип-формата)является устаревшей особенностью.</target>
        </trans-unit>
        <trans-unit id="1e1d1d4c80a34abbd78d532e533e8e32a26baa46" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;argc&lt;/code&gt; shall be nonnegative.</source>
          <target state="translated">Значение &lt;code&gt;argc&lt;/code&gt; должно быть неотрицательным.</target>
        </trans-unit>
        <trans-unit id="3b6837137519a235145649ca26f22f77d0ac5ffc" translate="yes" xml:space="preserve">
          <source>The value returned from &lt;code&gt;main()&lt;/code&gt; is transmitted to the 'environment' in an implementation-defined way.</source>
          <target state="translated">Значение, возвращаемое из &lt;code&gt;main()&lt;/code&gt; , передается в &amp;laquo;среду&amp;raquo; способом, определяемым реализацией.</target>
        </trans-unit>
        <trans-unit id="ca8a9e03a294ed095d6a449285082fc38a13cce6" translate="yes" xml:space="preserve">
          <source>There's a paragraph of &amp;sect;18.5 &lt;strong&gt;Start and termination&lt;/strong&gt; in the C++11 standard that is identical to the paragraph from &amp;sect;7.22.4.4 &lt;strong&gt;The &lt;code&gt;exit&lt;/code&gt; function&lt;/strong&gt; in the C11 standard (quoted above), apart from a footnote (which simply documents that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; are defined in &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Есть параграф &amp;sect; 18.5 &lt;strong&gt;Начало и завершение&lt;/strong&gt; в стандарте C ++ 11, который идентичен параграфу из &amp;sect;7.22.4.4 &lt;strong&gt;Функция &lt;code&gt;exit&lt;/code&gt; &lt;/strong&gt; в стандарте C11 (цитируется выше), за исключением сноски (которая просто документирует, что &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; и &lt;code&gt;EXIT_FAILURE&lt;/code&gt; определены в &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8878897f94a88e2eb0a72b92a1a8eea14341dd7c" translate="yes" xml:space="preserve">
          <source>This is recognized by the C standard as a common extension, documented in Annex J:</source>
          <target state="translated">Это признано стандартом С в качестве общего расширения,документально подтвержденного в Приложении J:</target>
        </trans-unit>
        <trans-unit id="90c926db372e34ff57f910bfc2a6bb307fd78475" translate="yes" xml:space="preserve">
          <source>This is some example in order to check how grep works.</source>
          <target state="translated">Это пример,чтобы проверить,как работает grep.</target>
        </trans-unit>
        <trans-unit id="d9135e4649a5add9899348971cdf27790adec503" translate="yes" xml:space="preserve">
          <source>This section is identical to the C++03 one cited above.</source>
          <target state="translated">Этот раздел идентичен цитированному выше разделу на C++03.</target>
        </trans-unit>
        <trans-unit id="aff26f54c08ac6a220e320cf88a1cc85885f4a3d" translate="yes" xml:space="preserve">
          <source>This section is identical to the C99 one cited above.</source>
          <target state="translated">Этот раздел идентичен цитированному выше разделу C99.</target>
        </trans-unit>
        <trans-unit id="492f852c402b8701a3d8ac1e786125fd366f3983" translate="yes" xml:space="preserve">
          <source>This way you can see that it is the variable &lt;code&gt;$?&lt;/code&gt; which receives the least significant byte of the return value of &lt;code&gt;main()&lt;/code&gt;.</source>
          <target state="translated">Таким образом, вы можете видеть, что это переменная &lt;code&gt;$?&lt;/code&gt; который получает младший байт возвращаемого значения &lt;code&gt;main()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="083f523a48b50dec805c4b80d1381d0a4f4fa86b" translate="yes" xml:space="preserve">
          <source>Those words &quot;(most efficient)&quot; don't change the question.  Unless you're in a freestanding environment, there is one universally correct way to declare &lt;code&gt;main()&lt;/code&gt;, and that's as returning int.</source>
          <target state="translated">Эти слова &amp;laquo;(наиболее эффективные)&amp;raquo; не меняют вопрос. Если вы не находитесь в автономной среде, есть один универсально правильный способ объявления &lt;code&gt;main()&lt;/code&gt; , и это как возвращение int.</target>
        </trans-unit>
        <trans-unit id="dd1d619c61e03e7c3983d9cf6e51c9a460b55ae1" translate="yes" xml:space="preserve">
          <source>Two execution environments are defined: freestanding and hosted. In both cases,
  program startup occurs when a designated C function is called by the execution
  environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.</source>
          <target state="translated">Определены две среды исполнения:отдельно стоящая и хостируемая.В обоих случаях запуск программы происходит,когда указанная функция C вызывается окружением исполнения.Все объекты со статической длительностью хранения должны быть инициализированы (установлены на начальные значения)перед запуском программы.В противном случае способ и время такой инициализации не уточняются.Завершение программы возвращает управление в среду исполнения.</target>
        </trans-unit>
        <trans-unit id="7e6d901cc3741eac5e0d54d5f5f6b0f0c7091f78" translate="yes" xml:space="preserve">
          <source>Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this International Standard describes the set of available headers.</source>
          <target state="translated">Определены два типа реализаций:хостинговая и отдельностоящая (1.4).Для хостинговой реализации данный международный стандарт описывает набор доступных заголовков.</target>
        </trans-unit>
        <trans-unit id="c8ffe25090b0726f102193ed465ce10faae40214" translate="yes" xml:space="preserve">
          <source>What about using &lt;code&gt;int main()&lt;/code&gt; in C?</source>
          <target state="translated">Как насчет использования &lt;code&gt;int main()&lt;/code&gt; в C?</target>
        </trans-unit>
        <trans-unit id="8db9388f551bf79763f6d366a53d00645a18b452" translate="yes" xml:space="preserve">
          <source>What are the valid signatures for C's &lt;code&gt;main()&lt;/code&gt; function?</source>
          <target state="translated">Каковы действительные подписи для функции &lt;code&gt;main()&lt;/code&gt; C?</target>
        </trans-unit>
        <trans-unit id="e375a0bb38b5733f5e33aea178300914bf1fc13b" translate="yes" xml:space="preserve">
          <source>What is the correct (most efficient) way to define the &lt;code&gt;main()&lt;/code&gt; function in C and C++ &amp;mdash; &lt;code&gt;int main()&lt;/code&gt; or &lt;code&gt;void main()&lt;/code&gt; &amp;mdash; and why? 
If &lt;code&gt;int main()&lt;/code&gt; then &lt;code&gt;return 1&lt;/code&gt; or &lt;code&gt;return 0&lt;/code&gt;?</source>
          <target state="translated">Как правильно (наиболее эффективно) определить функцию &lt;code&gt;main()&lt;/code&gt; в C и C ++ - &lt;code&gt;int main()&lt;/code&gt; или &lt;code&gt;void main()&lt;/code&gt; - и почему? Если &lt;code&gt;int main()&lt;/code&gt; тогда &lt;code&gt;return 1&lt;/code&gt; или &lt;code&gt;return 0&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="ac7910d8738d0f6edbbbc837537320cc7243db50" translate="yes" xml:space="preserve">
          <source>What is the correct (most efficient) way to define the main() function in C and C++ &amp;mdash; int main() or void main() &amp;mdash; and why?</source>
          <target state="translated">Как правильно (наиболее эффективно) определить функцию main () в C и C ++ - int main () или void main () - и почему?</target>
        </trans-unit>
        <trans-unit id="b6fa6e7eb3c56c5443ca329d417a88f4f68960be" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;main()&lt;/code&gt; return in C and C++?</source>
          <target state="translated">Что должно возвращать &lt;code&gt;main()&lt;/code&gt; в C и C ++?</target>
        </trans-unit>
        <trans-unit id="486019aa245ddcb5e5499f2b26db2df46e934c65" translate="yes" xml:space="preserve">
          <source>What should main() return in C and C++</source>
          <target state="translated">Что должна возвращаться функцией main()в C и C++</target>
        </trans-unit>
        <trans-unit id="30ef05539959ff243c4e180d8cd581aaf97379b0" translate="yes" xml:space="preserve">
          <source>What to return depends on what you want to do with the executable. For example if you are using your program with a command line shell, then you need to return 0 for a success and a non zero for failure. Then you would be able to use the program in shells with conditional processing depending on the outcome of your code. Also you can assign any nonzero value as per your interpretation, for example for critical errors different program exit points could terminate a program with different exit values , and which is available to the calling shell which can decide what to do by inspecting the value returned.
If the code is not intended for use with shells and the returned value does not bother anybody then it might be omitted. I personally use the signature &lt;code&gt;int main (void) { .. return 0; .. }&lt;/code&gt;</source>
          <target state="translated">Что вернуть, зависит от того, что вы хотите сделать с исполняемым файлом. Например, если вы используете вашу программу с оболочкой командной строки, вам нужно вернуть 0 для успеха и ненулевое значение для ошибки. Тогда вы сможете использовать программу в оболочках с условной обработкой в ​​зависимости от результата вашего кода. Также вы можете назначить любое ненулевое значение в соответствии с вашей интерпретацией, например, для критических ошибок разные точки выхода из программы могут завершить программу с разными значениями выхода, и которая доступна вызывающей оболочке, которая может решить, что делать, проверив возвращаемое значение. Если код не предназначен для использования с оболочками и возвращаемое значение никого не беспокоит, его можно опустить. Я лично использую подпись &lt;code&gt;int main (void) { .. return 0; .. }&lt;/code&gt; ..}</target>
        </trans-unit>
        <trans-unit id="23877bc0573cb6974d91820ac2c5704526b909c4" translate="yes" xml:space="preserve">
          <source>When a C or C++ program reaches the end of &lt;code&gt;main&lt;/code&gt; the compiler will automatically generate code to return 0, so there is no need to put &lt;code&gt;return 0;&lt;/code&gt; explicitly at the end of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">Когда программа на C или C ++ достигает конца &lt;code&gt;main&lt;/code&gt; , компилятор автоматически сгенерирует код, возвращающий 0, поэтому нет необходимости помещать &lt;code&gt;return 0;&lt;/code&gt; явно в конце &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ff9c6d19528fc5ecbf1d4fd6390af8df49063b" translate="yes" xml:space="preserve">
          <source>When using the various tools that the Linux terminal provides one can use the return code for example for error handling after the process has been completed. Imagine that the following text file myfile is present:</source>
          <target state="translated">При использовании различных инструментов,которые предоставляет терминал Linux,можно использовать код возврата,например,для обработки ошибок после завершения процесса.Представьте себе следующий текстовый файл,в котором присутствует мой файл:</target>
        </trans-unit>
        <trans-unit id="1ed64c1ea746c88bec38d149c99f20765bec153b" translate="yes" xml:space="preserve">
          <source>When you execute the grep command a process is created. Once it is through (and didn't break) it returns some code between 0 and 255. For example:</source>
          <target state="translated">При выполнении команды grep создается процесс.После того,как он прошел (и не сломался),он возвращает некоторый код в диапазоне от 0 до 255.Например:</target>
        </trans-unit>
        <trans-unit id="96e3de3e6bf17276eac99869ea88fc0e71150b83" translate="yes" xml:space="preserve">
          <source>Why does &lt;code&gt;int main(){}&lt;/code&gt; compile?</source>
          <target state="translated">Почему &lt;code&gt;int main(){}&lt;/code&gt; компилируется?</target>
        </trans-unit>
        <trans-unit id="51b0c9e4f517672dab551e3f0c8fb3a773467020" translate="yes" xml:space="preserve">
          <source>Why is the type of the &lt;code&gt;main()&lt;/code&gt; function in C and C++ left to the user to define?</source>
          <target state="translated">Почему тип функции &lt;code&gt;main()&lt;/code&gt; в C и C ++ остается на усмотрение пользователя?</target>
        </trans-unit>
        <trans-unit id="2a862fb41af52a34873a9b301706a972cab7022b" translate="yes" xml:space="preserve">
          <source>Yet the section for hosted environment program termination then goes on arguing about the case where main does not return int &lt;sup&gt;5&lt;/sup&gt;. Although that section is not normative for how main should be declared, it definitely implies that main might be declared in a completely implementation-defined way even on hosted systems.</source>
          <target state="translated">Тем не менее, раздел для завершения программы в размещенной среде продолжает спорить о случае, когда main не возвращает int &lt;sup&gt;5&lt;/sup&gt; . Хотя этот раздел не является нормативным для того, как main должен быть объявлен, он определенно подразумевает, что main может быть объявлен полностью определяемым реализацией способом даже в размещенных системах.</target>
        </trans-unit>
        <trans-unit id="922180965ea438bfff3906a2def9f2352b5adb9b" translate="yes" xml:space="preserve">
          <source>You may omit the return statement from &lt;code&gt;main()&lt;/code&gt;. If you do, and &lt;code&gt;main()&lt;/code&gt; finished, there is an implicit &lt;code&gt;return 0&lt;/code&gt;.</source>
          <target state="translated">Вы можете опустить оператор return из &lt;code&gt;main()&lt;/code&gt; . Если вы это сделаете, и &lt;code&gt;main()&lt;/code&gt; завершит работу, вы получите неявный &lt;code&gt;return 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab226733ba35ae01df11c0190457de2d507d24e6" translate="yes" xml:space="preserve">
          <source>[...] a return from the initial call to the &lt;code&gt;main&lt;/code&gt; function is equivalent to calling the &lt;code&gt;exit&lt;/code&gt; function with the value returned by the &lt;code&gt;main&lt;/code&gt; function as its argument; reaching the &lt;code&gt;}&lt;/code&gt; that terminates the &lt;code&gt;main&lt;/code&gt; function returns a value of 0.</source>
          <target state="translated">[...] возврат из начального вызова &lt;code&gt;main&lt;/code&gt; функции эквивалентен вызову функции &lt;code&gt;exit&lt;/code&gt; со значением, возвращаемым &lt;code&gt;main&lt;/code&gt; функцией в качестве аргумента; достижение &lt;code&gt;}&lt;/code&gt; , завершающего функцию &lt;code&gt;main&lt;/code&gt; , возвращает значение 0.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="121d20b5045a7b17be1953b2f4b5b7d1193aba4f" translate="yes" xml:space="preserve">
          <source>as the type of main (8.3.5).</source>
          <target state="translated">как тип основного (8.3.5).</target>
        </trans-unit>
        <trans-unit id="8b4ea7908f3a8fca63af0e6ad2f61e8268c4885d" translate="yes" xml:space="preserve">
          <source>main is the only function that may portably be declared either with zero or two arguments. (The number of other functions&amp;rsquo; arguments must match exactly between invocation and definition.)
  This special case simply recognizes the widespread practice of leaving off the arguments to main when the program does not access the program argument strings. While many implementations support more than two arguments to main, such practice is neither blessed nor forbidden by the Standard; a program that defines main with three arguments is not strictly conforming (see &amp;sect;J.5.1.).</source>
          <target state="translated">main - единственная функция, которая может быть объявлена ​​переносимым образом с нулем или двумя аргументами. (Число аргументов других функций должно точно совпадать между вызовом и определением.) Этот особый случай просто признает широко распространенную практику исключения аргументов из main, когда программа не имеет доступа к строкам аргументов программы. Хотя многие реализации поддерживают более двух аргументов для main, такая практика не благословлена ​​и не запрещена Стандартом; программа, которая определяет main с тремя аргументами, не является строго соответствующей (см. &amp;sect;J.5.1.).</target>
        </trans-unit>
        <trans-unit id="622f82e8c075ada716a1cc9582aedc7d512d29d9" translate="yes" xml:space="preserve">
          <source>or equivalent;9) or in some other implementation-defined
  manner.</source>
          <target state="translated">или эквивалент;9)или каким-либо другим образом,определяемым реализацией.</target>
        </trans-unit>
        <trans-unit id="1afe888428199267b8fb21832c373dab7f683445" translate="yes" xml:space="preserve">
          <source>or equivalent;&lt;sup&gt;10)&lt;/sup&gt; or in some other implementation-defined manner.</source>
          <target state="translated">или эквивалент; &lt;sup&gt;10)&lt;/sup&gt; или каким-либо другим способом, определяемым реализацией.</target>
        </trans-unit>
        <trans-unit id="6270e8159f1807e121f60a87d982221f41402076" translate="yes" xml:space="preserve">
          <source>or with two parameters (referred to here as
  argc and argv, though any names may be used, as they are local to the
  function in which they are declared):</source>
          <target state="translated">или с двумя параметрами (здесь упоминаются как argc и argv,хотя могут использоваться любые имена,так как они локальны для функции,в которой они объявлены):</target>
        </trans-unit>
        <trans-unit id="c5dae6252c11ab5b0df3caf711c397701d6124cd" translate="yes" xml:space="preserve">
          <source>or with two parameters (referred to here as &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;, though any names may be
  used, as they are local to the function in which they are declared):</source>
          <target state="translated">или с двумя параметрами (именуемыми здесь как &lt;code&gt;argc&lt;/code&gt; и &lt;code&gt;argv&lt;/code&gt; , хотя могут использоваться любые имена, поскольку они являются локальными для функции, в которой они объявлены):</target>
        </trans-unit>
        <trans-unit id="f8a458ef7b858ad564adb1ed9a5adbf1c78ddb73" translate="yes" xml:space="preserve">
          <source>or, optionally,</source>
          <target state="translated">или,по желанию,</target>
        </trans-unit>
        <trans-unit id="04c6ac4120301d7049af98011b0e572414db64b0" translate="yes" xml:space="preserve">
          <source>which is equivalent to</source>
          <target state="translated">что эквивалентно</target>
        </trans-unit>
        <trans-unit id="e7bb9db27381610dba7df259669ffd179effc729" translate="yes" xml:space="preserve">
          <source>you will get a 0. Why? Because &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; found a match and returned an exit code 0, which is the usual value for exiting with a success. Let's check it out again but with something that is not inside our text file and thus no match will be found:</source>
          <target state="translated">вы получите 0. Почему? Потому что &lt;a href=&quot;http://en.wikipedia.org/wiki/Grep&quot;&gt;grep&lt;/a&gt; нашел совпадение и возвратил код выхода 0, который является обычным значением для успешного завершения. Давайте проверим это снова, но с чем-то, чего нет в нашем текстовом файле, и, следовательно, совпадение не будет найдено:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
