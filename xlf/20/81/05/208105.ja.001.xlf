<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/208105">
    <body>
      <group id="208105">
        <trans-unit id="d0c785d16c2347fee547f3127b424f77909312a7" translate="yes" xml:space="preserve">
          <source>(Destructuring + Spread operator)</source>
          <target state="translated">(破壊+スプレッド演算子)</target>
        </trans-unit>
        <trans-unit id="63d63c34165213cae85c0283076b58a13c886dbf" translate="yes" xml:space="preserve">
          <source>(ES6)</source>
          <target state="translated">(ES6)</target>
        </trans-unit>
        <trans-unit id="7d50cf7543cd430338fe6fd7172b5d7ec7565f89" translate="yes" xml:space="preserve">
          <source>* &lt;em&gt;&lt;code&gt;foo&lt;/code&gt; will be a new variable with the value of &lt;code&gt;a&lt;/code&gt; (which is 1).&lt;/em&gt;</source>
          <target state="translated">* &lt;em&gt; &lt;code&gt;foo&lt;/code&gt; はaの値（1）を持つ新しい変数になります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8aa44c32c47930ef0f4bc07bf1b584a5b6b0e2f" translate="yes" xml:space="preserve">
          <source>...It's stupid, I know.</source>
          <target state="translated">...馬鹿げている。</target>
        </trans-unit>
        <trans-unit id="ff34d7bfb44f74504dbcecb1c791e02877f620e3" translate="yes" xml:space="preserve">
          <source>1.With explicit prop key:</source>
          <target state="translated">1.明示的なプロップキーを持つ。</target>
        </trans-unit>
        <trans-unit id="145f4a070da96e31a48d8d444babf929a09a782a" translate="yes" xml:space="preserve">
          <source>2.With variable prop key:</source>
          <target state="translated">2.可変プロップキー付き。</target>
        </trans-unit>
        <trans-unit id="75c350f4599bd395c8e57950299bcd4efdaca57e" translate="yes" xml:space="preserve">
          <source>3.Cool arrow function 😎:</source>
          <target state="translated">3.クールアロー機能 😎。</target>
        </trans-unit>
        <trans-unit id="b31d7d6cbd9fc3e49f4feaeef410e7cee592b5fa" translate="yes" xml:space="preserve">
          <source>4. For multiple properties</source>
          <target state="translated">4.複数の物件の場合</target>
        </trans-unit>
        <trans-unit id="cecf2bde461c486918fed98467ea58414d0dd173" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze()&lt;/a&gt; makes all properties of object not configurable (besides other things). &lt;code&gt;deleteProperty&lt;/code&gt; function (as well as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt;) returns &lt;code&gt;false&lt;/code&gt; when tries to delete any of it's properties. If property is configurable it returns &lt;code&gt;true&lt;/code&gt;, even if property does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze（）&lt;/a&gt;は、オブジェクトの他のすべてのプロパティを構成不可能にします。 &lt;code&gt;deleteProperty&lt;/code&gt; 関数（および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt; ）は、そのプロパティのいずれかを削除しようとすると &lt;code&gt;false&lt;/code&gt; を返します。 プロパティが設定可能な場合、プロパティが存在しなくても &lt;code&gt;true&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="d2f5341f96365af83c99b7c7d47dba6c4b1a96cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;Spread Syntax&lt;/a&gt; (ES6)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;スプレッド構文&lt;/a&gt; （ES6）</target>
        </trans-unit>
        <trans-unit id="e4d9e924d09e0b750a05547c2f0bf5fa2c195878" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.slice()&lt;/code&gt; is non-destructive and returns a new array containing the indicated indices from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;. If &lt;code&gt;end&lt;/code&gt; is left unspecified, the behavior is the same as &lt;code&gt;.splice()&lt;/code&gt; (&lt;code&gt;end = array.length&lt;/code&gt;). The behavior is a bit tricky since, for some reason, &lt;code&gt;end&lt;/code&gt; indexes from 1 instead of 0. I don't know why it does this, but that's how it is. Also, if &lt;code&gt;end &amp;lt;= start&lt;/code&gt;, the result is an empty array.</source>
          <target state="translated">&lt;code&gt;.slice()&lt;/code&gt; は非破壊的で、指定されたインデックスを &lt;code&gt;start&lt;/code&gt; から &lt;code&gt;end&lt;/code&gt; まで含む新しい配列を返します。 &lt;code&gt;end&lt;/code&gt; を指定しない場合、動作は &lt;code&gt;.splice()&lt;/code&gt; （ &lt;code&gt;end = array.length&lt;/code&gt; ）と同じです。 何らかの理由で、インデックスを0ではなく1から &lt;code&gt;end&lt;/code&gt; するため、動作は少しトリッキーです。なぜこれが行われるのかはわかりませんが、そのようになっています。 また、 &lt;code&gt;end &amp;lt;= start&lt;/code&gt; 場合、結果は空の配列になります。</target>
        </trans-unit>
        <trans-unit id="da2a0c1e98a822064cc6b913222774a91ac62044" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.splice()&lt;/code&gt; mutates the array, and returns the removed indices. The array is sliced starting from the index, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; elements are sliced out. If n is unspecified, the entire array after &lt;code&gt;start&lt;/code&gt; is sliced out (&lt;code&gt;n = array.length - start&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;.splice()&lt;/code&gt; は配列を変更し、削除されたインデックスを返します。 配列は、インデックス &lt;code&gt;start&lt;/code&gt; からスライスされ、 &lt;code&gt;n&lt;/code&gt; 個の要素がスライスされます。 nが指定されていない場合、 &lt;code&gt;start&lt;/code&gt; 後の配列全体が &lt;code&gt;n = array.length - start&lt;/code&gt; れます（ n = array.length-start ）。</target>
        </trans-unit>
        <trans-unit id="578e0d997316ced94b2f7c292e4269507a0730b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Delete Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;演算子を削除&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10a7b7e3a95023fb9f5d4f97bbeb1e856756bc60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;EXTENDED ANSWER&lt;/em&gt;&lt;/strong&gt; 😇</source>
          <target state="translated">延長回答😇</target>
        </trans-unit>
        <trans-unit id="3393b3743a22fd0193ab2fa39735ae2f646b06ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="710a4e957cc23ae95eb9aa6e13030731ab1c9d56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e590196d99e29b0fb26cc981e8c241732f76e4ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Spread Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;スプレッドオペレーター&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64d050dff57dceee4d758cc0912b8d402b405b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b02479449faf2e3a74dc8a9ef6000bfbe7ea1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In other words, a JavaScript object gets killed as soon as there is no reference left in your code pointed to that object.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;言い換えると、JavaScriptオブジェクトは、そのオブジェクトを指す参照がコードに残っていない場合にすぐに強制終了されます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecc8000feff4d7f65f5786df06cc101796ac4edd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To clone object without property:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プロパティなしでオブジェクトを複製するには：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ca5c58827bf40e3a97a098228081f1f64d66b7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018-07-21:&lt;/strong&gt; For a long time, I have felt embarrassed about this answer, so I think it's time that I touch it up a little bit. Just a little commentary, clarification, and formatting to help expedite the reading of the needlessly long and convoluted parts of this answer.</source>
          <target state="translated">&lt;strong&gt;2018-07-21の更新：&lt;/strong&gt;長い間、この答えに戸惑いを感じていたので、少し&lt;strong&gt;修正するときがき&lt;/strong&gt;たと思います。 この回答の不必要に長く複雑な部分の読み取りを促進するためのほんの少しの解説、説明、およびフォーマット。</target>
        </trans-unit>
        <trans-unit id="c099f37767111dc60103bd8696ed4fcf3e7a64d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;
Thanks to @AgentME:</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt; @AgentMEに感謝：</target>
        </trans-unit>
        <trans-unit id="cd7c415e1d4039a5febeafd32c836a75f6b919e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;delete&lt;/code&gt;,&lt;/strong&gt; when you are passing the result object to the code on which you don't have control (or when you are not sure about your team or yourself).</source>
          <target state="translated">制御できないコードに結果オブジェクトを渡す場合（またはチームまたは自分自身が不明な場合）は&lt;strong&gt;、 &lt;code&gt;delete&lt;/code&gt; を使用し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="0af0c0606dbb967654f58c35fa2988459afb9a19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use setting to &lt;code&gt;undefined&lt;/code&gt;,&lt;/strong&gt; when you care about performance. It can give a serious boost to your code.</source>
          <target state="translated">パフォーマンス&lt;strong&gt;を &lt;code&gt;undefined&lt;/code&gt; する&lt;/strong&gt;場合は&lt;strong&gt;、設定をundefinedに&lt;/strong&gt;してください。 それはあなたのコードに深刻な後押しを与えることができます。</target>
        </trans-unit>
        <trans-unit id="9dfe20a67d61ae6b75beddf80cff0434cb3f7a9f" translate="yes" xml:space="preserve">
          <source>A live example to show:</source>
          <target state="translated">示すための生きたお手本。</target>
        </trans-unit>
        <trans-unit id="aabd2b7839024463c3c18626551d6893b70879bd" translate="yes" xml:space="preserve">
          <source>About now, you're at your wit's end. This guy has been complaining non-stop about your app, and you want to tell him to shut up and go get a better computer.</source>
          <target state="translated">今頃、あなたは途方に暮れています。この男はあなたのアプリに 不満を言ってきた あなたは彼に黙って 良いコンピュータを手に入れに行くように 言いたいのね</target>
        </trans-unit>
        <trans-unit id="692f82b2a7574a467099a421e634c28a19087f50" translate="yes" xml:space="preserve">
          <source>Alternatively, you could also do this:</source>
          <target state="translated">あるいは、このような方法もあります。</target>
        </trans-unit>
        <trans-unit id="8dd6b6a5cb398077b2e61b33860df5233162a369" translate="yes" xml:space="preserve">
          <source>An object may be seen as a set of key-value pairs. What I call a 'value' is a primitive or a reference to other object, connected to that 'key'.</source>
          <target state="translated">オブジェクトは、キーと値のペアの集合として見られるかもしれません。私が「値」と呼ぶものは、その「キー」に接続されたプリミティブまたは他のオブジェクトへの参照です。</target>
        </trans-unit>
        <trans-unit id="97f362e729192c077ada3f5241fec0dea0e6f9ad" translate="yes" xml:space="preserve">
          <source>And just like that, you've pleased Mr. PDP-11. Hooray! &lt;sub&gt;(I'd still tell him off, though...)&lt;/sub&gt;</source>
          <target state="translated">それと同じように、PDP-11氏を喜ばせました。 やったー！ &lt;sub&gt;（私はまだ彼を告げるだろう...）&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="38fedc2f5a59cd30ac658c92ac34226c9870e485" translate="yes" xml:space="preserve">
          <source>And we need to delete 'a'.</source>
          <target state="translated">そして、'a'を削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="15728408349a51726fa4d7a495f586b8e25e36f1" translate="yes" xml:space="preserve">
          <source>Another alternative is to use the &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt; library.</source>
          <target state="translated">別の方法は、 &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt;ライブラリを使用することです。</target>
        </trans-unit>
        <trans-unit id="130c3bce337f7ed92461a0af093bf0dd8b4d970c" translate="yes" xml:space="preserve">
          <source>Another solution, using &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array#reduce&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array#reduce&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;を使用した別のソリューション。</target>
        </trans-unit>
        <trans-unit id="75aa366398b31b18c07d678c84ff7223a1b76dbe" translate="yes" xml:space="preserve">
          <source>Any property declared with let or const cannot be deleted from the scope  within which they were defined. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().</source>
          <target state="translated">let または const で宣言されたプロパティは、それらが定義されているスコープから削除することはできません。非構成可能なプロパティを削除することはできません。これには、Math、Array、Object などの組み込みオブジェクトのプロパティや、Object.defineProperty()のようなメソッドで非構成可能として作成されたプロパティが含まれます。</target>
        </trans-unit>
        <trans-unit id="b2ecb35283325b0622c879acc81ba757d7accad0" translate="yes" xml:space="preserve">
          <source>Any property declared with var cannot be deleted from the global scope
  or from a function's scope.</source>
          <target state="translated">var で宣言されたプロパティは、グローバルスコープや関数のスコープから削除することはできません。</target>
        </trans-unit>
        <trans-unit id="6c333dd9449a548b822691fcab373abce8f8f850" translate="yes" xml:space="preserve">
          <source>Are you looking to achieve this in pure JavaScript or are you willing &amp;amp; able to use a 3rd-party library?</source>
          <target state="translated">純粋なJavaScriptでこれを実現することを望んでいますか、それともサードパーティのライブラリを使用したいと思いますか？</target>
        </trans-unit>
        <trans-unit id="1fea0155471c15e540c5b31c3594a45754e6cc6c" translate="yes" xml:space="preserve">
          <source>Array equivalent</source>
          <target state="translated">配列相当</target>
        </trans-unit>
        <trans-unit id="10f82eff0fb408011ffeabc374c6234764312dea" translate="yes" xml:space="preserve">
          <source>Array.prototype.slice(start, end)</source>
          <target state="translated">Array.prototype.slice(start,end)</target>
        </trans-unit>
        <trans-unit id="dfe829210c0c25d8779de7fe65fb3158cefd4290" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice vs Array.prototype.slice</source>
          <target state="translated">Array.prototype.splice vs Array.prototype.slice</target>
        </trans-unit>
        <trans-unit id="99ba4898ce91c3e3945c33ecd292283940427b38" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice(start, n)</source>
          <target state="translated">Array.prototype.splice(start,n)</target>
        </trans-unit>
        <trans-unit id="bc85e8ead32cd6185d2f6ca2b34c7fbc94aadd58" translate="yes" xml:space="preserve">
          <source>As others have said, you can use &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">他の人が言ったように、あなたは &lt;code&gt;delete&lt;/code&gt; を使うことができます。</target>
        </trans-unit>
        <trans-unit id="fc6de88f57fe2bcbd39aa2ddf8ca667c26f222a3" translate="yes" xml:space="preserve">
          <source>As seen in the above code snippet, there are some rare appropriate use cases for the &lt;code&gt;delete&lt;/code&gt; operator. However, do not worry about this problem too much. This will only become a problem with long-lifespan objects that get new keys constantly added to them. In any other case (which is almost every case in real-world programming), it is most appropriate to use &lt;code&gt;obj[prop] = undefined&lt;/code&gt;. The main purpose of this section is just to bring this to your attention so that in the rare chance that this does become a problem in your code, then you can more easily understand the problem and thus not have to waste hours dissecting your code to locate and understand this problem.</source>
          <target state="translated">上記のコードスニペットに見られるように、 &lt;code&gt;delete&lt;/code&gt; 演算子の適切なユースケースはまれです。 ただし、この問題をあまり気にしないでください。 これは、新しいキーが常に追加される長寿命オブジェクトでのみ問題になります。 それ以外の場合（これは実際のプログラミングではほとんどすべてのケースです）、 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; を使用するのが最も適切です。 このセクションの主な目的は、これを注意することです。これにより、まれにこれがコードで問題になる場合に、問題をより簡単に理解できるため、コードを分析するために時間を無駄にする必要がありません。この問題を理解してください。</target>
        </trans-unit>
        <trans-unit id="0a1a7281b5e3e0adcbcee6c0378231475ce1d077" translate="yes" xml:space="preserve">
          <source>As such, delete cannot delete any functions in the global scope (whether this is part from a function definition or a function  (expression).</source>
          <target state="translated">そのため、deleteはグローバルスコープ内の関数を削除することはできません(これが関数定義の一部であるか、関数(式)の一部であるかは問いません)。</target>
        </trans-unit>
        <trans-unit id="19292906404cfee69ce728ffea847a3cb5d23580" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;delete&lt;/code&gt; doesn't always work as one might expect. The value is overwritten, but the memory is not reallocated. That is to say, &lt;code&gt;array[4]&lt;/code&gt; isn't relocated to &lt;code&gt;array[3]&lt;/code&gt;. Which is in contrast to &lt;code&gt;Array.prototype.unshift&lt;/code&gt;, which inserts an element at the beginning of the array and shifts everything up (&lt;code&gt;array[0]&lt;/code&gt; becomes &lt;code&gt;array[1]&lt;/code&gt;, etc.)</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;delete&lt;/code&gt; は必ずしも期待どおりに機能するとは限りません。 値は上書きされますが、メモリは再割り当てされません。 つまり、 &lt;code&gt;array[4]&lt;/code&gt; は &lt;code&gt;array[3]&lt;/code&gt; 再配置されません。 これは、配列の先頭に要素を挿入してすべてを上にシフトする &lt;code&gt;Array.prototype.unshift&lt;/code&gt; とは対照的です（ &lt;code&gt;array[0]&lt;/code&gt; が &lt;code&gt;array[1]&lt;/code&gt; になるなど）。</target>
        </trans-unit>
        <trans-unit id="2c856c5e5c5be4265462b9644119ace1784d98d0" translate="yes" xml:space="preserve">
          <source>Beware Of Memory Leaks!</source>
          <target state="translated">メモリリークにご用心</target>
        </trans-unit>
        <trans-unit id="76829795257d4b98172b51f389192e4a9f633cf6" translate="yes" xml:space="preserve">
          <source>But if the property of the object is not configurable it cannot be deleted neither with deleteProperty function nor delete operator:</source>
          <target state="translated">しかし、オブジェクトのプロパティが設定できない場合は、deleteProperty関数でもdelete演算子でも削除できません。</target>
        </trans-unit>
        <trans-unit id="5d2ae2c0c3d231052d20df4bc0d378c5068295e8" translate="yes" xml:space="preserve">
          <source>But the point is if you care about memory and you want to whole the object gets removed from the memory, it is recommended to set it to null before you delete the key:</source>
          <target state="translated">しかし、メモリを気にしてオブジェクトを丸ごとメモリから削除したい場合は、キーを削除する前にNULLにしておくことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="083882684bcd539a61f754c832b4192934d833e3" translate="yes" xml:space="preserve">
          <source>But, how does a drug trip analogy relate to the &lt;code&gt;delete&lt;/code&gt; operation? The answer inheres the last line of code in the snippet above. Thus let it be reexamined, this time with a twist.</source>
          <target state="translated">しかし、ドラッグトリップのアナロジーは &lt;code&gt;delete&lt;/code&gt; 操作とどのように関連していますか？ 答えは、上記のスニペットの最後のコード行です。 したがって、今度はひねりを加えて再検討してみましょう。</target>
        </trans-unit>
        <trans-unit id="0eb16d4b50dbacc8475f57ed2dfb88409bd56da6" translate="yes" xml:space="preserve">
          <source>Consider creating a new object without the &lt;code&gt;&quot;regex&quot;&lt;/code&gt; property because the original object could always be referenced by other parts of your program. Thus you should avoid manipulating it.</source>
          <target state="translated">元のオブジェクトはプログラムの他の部分から常に参照される可能性があるため、 &lt;code&gt;&quot;regex&quot;&lt;/code&gt; プロパティなしで新しいオブジェクトを作成することを検討してください。 したがって、それを操作することは避けてください。</target>
        </trans-unit>
        <trans-unit id="1b8bae88ce3f716fc88f086ba5df71aa742b0ee5" translate="yes" xml:space="preserve">
          <source>Dan's assertion that 'delete' is very slow and the benchmark he posted were doubted. So I carried out the test myself in Chrome 59. It does seem that 'delete' is about 30 times slower:</source>
          <target state="translated">削除」が非常に遅いというダンの主張と、彼が投稿したベンチマークを疑った。ということで、自分でChrome 59でテストしてみました。確かに'delete'は30倍くらい遅いようだ。</target>
        </trans-unit>
        <trans-unit id="d8b13a816456ec85d6f3ace2de0c50288edaa6ea" translate="yes" xml:space="preserve">
          <source>Delete is the only true way to remove object's properties without any leftovers, but it works &lt;strong&gt;~ 100 times slower&lt;/strong&gt;, 
compared to its &quot;alternative&quot;, setting &lt;code&gt;object[key] = undefined&lt;/code&gt;.</source>
          <target state="translated">Deleteは、残り物を残さずにオブジェクトのプロパティを削除するための唯一の真の方法ですが、「代替」と比較して、 &lt;code&gt;object[key] = undefined&lt;/code&gt; 設定する場合と比べて、動作が&lt;strong&gt;100倍遅くなり&lt;/strong&gt; ます 。</target>
        </trans-unit>
        <trans-unit id="45dc7ea9ea6f9f47fa401db4115a5eee26a4be14" translate="yes" xml:space="preserve">
          <source>Deleting an array index</source>
          <target state="translated">配列インデックスの削除</target>
        </trans-unit>
        <trans-unit id="42034d05fb5ec8b92965ea89f328c840dc4a3ac4" translate="yes" xml:space="preserve">
          <source>Deleting an object property</source>
          <target state="translated">オブジェクトのプロパティを削除する</target>
        </trans-unit>
        <trans-unit id="e52c854d5631eec7468ba4727b4c77eb745f2965" translate="yes" xml:space="preserve">
          <source>Demo</source>
          <target state="translated">Demo</target>
        </trans-unit>
        <trans-unit id="0298196b206bc7b4a96725653dbc77fafc2e7815" translate="yes" xml:space="preserve">
          <source>Do Not Always Set To &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">常に &lt;code&gt;undefined&lt;/code&gt; 設定しないでください</target>
        </trans-unit>
        <trans-unit id="e813a63a91f53696f818ac595a5fddc09cb30338" translate="yes" xml:space="preserve">
          <source>Don't &lt;code&gt;delete&lt;/code&gt; from an array. Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead.</source>
          <target state="translated">配列から &lt;code&gt;delete&lt;/code&gt; しないでください 。 代わりに &lt;code&gt;Array.prototype.splice&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="9cff8f35d333fc23fef816a20f879c35c001ee7e" translate="yes" xml:space="preserve">
          <source>Due to the dynamic nature of JavaScript there are often cases where you simply don't know if the property exists or not. Checking if obj exists before the &amp;amp;&amp;amp; also makes sure you don't throw an error due to calling the hasOwnProperty() function on an undefined object.</source>
          <target state="translated">JavaScriptの動的な性質により、プロパティが存在するかどうかがわからない場合がよくあります。 &amp;amp;&amp;amp;の前にobjが存在するかどうかを確認すると、未定義のオブジェクトでhasOwnProperty（）関数を呼び出したためにエラーがスローされないことも確認できます。</target>
        </trans-unit>
        <trans-unit id="f30ca853155d96f4ff4a7523ad41da4989438529" translate="yes" xml:space="preserve">
          <source>E.g</source>
          <target state="translated">E.g</target>
        </trans-unit>
        <trans-unit id="48886c6e98adf5c4a9c9282a2441dfe3015faacb" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (or ES6) came with built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt; object. It is possible to delete object property by calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty()&lt;/a&gt; function with target object and property key as parameters:</source>
          <target state="translated">ECMAScript 2015（またはES6）には、組み込みの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt;オブジェクトが付属しています。 パラメータとしてターゲットオブジェクトとプロパティキーを指定して&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty（）&lt;/a&gt;関数を呼び出すことにより、オブジェクトプロパティを削除できます。</target>
        </trans-unit>
        <trans-unit id="4c2dbb36a3a214bec101207bfb72cd18b86e453e" translate="yes" xml:space="preserve">
          <source>Each one has it's own pros and cons (&lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;check this performance comparison&lt;/a&gt;):</source>
          <target state="translated">それぞれに長所と短所があります（ &lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;このパフォーマンス比較を確認してください&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="5cb7b7c35055238b90a33971ff368cff01dd0bbb" translate="yes" xml:space="preserve">
          <source>For anyone interested in reading more about it, Stack Overflow user &lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt; has written an incredibly in-depth blog post about the &lt;code&gt;delete&lt;/code&gt; statement on their blog, &lt;em&gt;&lt;a href=&quot;http://perfectionkills.com/understanding-delete/&quot;&gt;Understanding delete&lt;/a&gt;&lt;/em&gt;. It is highly recommended.</source>
          <target state="translated">Stack Overflowのユーザー&lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt;は、それについて詳しく読むことに関心のある人のために、自分のブログの &lt;code&gt;delete&lt;/code&gt; ステートメントについて、信じられないほど詳細なブログ投稿を投稿しています。 強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="7de0c8678ad3582ef48a786c2a12849c95f613d2" translate="yes" xml:space="preserve">
          <source>For arrays, &lt;code&gt;_.filter()&lt;/code&gt; and &lt;code&gt;_.reject()&lt;/code&gt; can be used in a similar manner.</source>
          <target state="translated">配列の場合、 &lt;code&gt;_.filter()&lt;/code&gt; および &lt;code&gt;_.reject()&lt;/code&gt; を同様の方法で使用できます。</target>
        </trans-unit>
        <trans-unit id="ae20664549d9e3ccd77991be79f76a86f10d159f" translate="yes" xml:space="preserve">
          <source>For example, say you are creating a webapp that uses JSON-serialization to store an array used for 'tabs' in a string (in this case, &lt;code&gt;localStorage&lt;/code&gt;). Let's also say that the code uses the numerical indices of the array's members to &quot;title&quot; them when drawing to the screen. Why are you doing this rather than just storing the &quot;title&quot; as well? Because... &lt;em&gt;reasons&lt;/em&gt;.</source>
          <target state="translated">たとえば、JSONシリアル化を使用して「タブ」に使用される配列を文字列（この場合は &lt;code&gt;localStorage&lt;/code&gt; ）に格納するWebアプリケーションを作成するとします。 また、画面に描画するときに、コードが配列のメンバーの数値インデックスを使用してそれらに「タイトルを付ける」としましょう。 「タイトル」だけを保存するのではなく、なぜこれを行うのですか？ なぜなら... &lt;em&gt;理由&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="cdad74d0486512dc3bc4f850907cd467e5fc5e3c" translate="yes" xml:space="preserve">
          <source>For more info about and seeing more example, visit the link below:</source>
          <target state="translated">より多くの例については、以下のリンクを参照してください。</target>
        </trans-unit>
        <trans-unit id="3053a4eaab6ecc9daa630f23887af0a663b64dcc" translate="yes" xml:space="preserve">
          <source>Functions which are part of an object (apart from the</source>
          <target state="translated">オブジェクトの一部である関数(</target>
        </trans-unit>
        <trans-unit id="a355b0b1f78d396cf69cf859538e8172e1e8345c" translate="yes" xml:space="preserve">
          <source>Hello You Can try this simple an sort</source>
          <target state="translated">こんにちは、あなたはこの単純なソートを試すことができます</target>
        </trans-unit>
        <trans-unit id="ca27c0a83d24961b91d263af64d922d82a55909c" translate="yes" xml:space="preserve">
          <source>Honestly, aside from setting to &lt;code&gt;null&lt;/code&gt; rather than &lt;code&gt;undefined&lt;/code&gt;--which is legitimately weird--this behavior &lt;em&gt;shouldn't&lt;/em&gt; be surprising, since &lt;code&gt;delete&lt;/code&gt; is a unary operator, like &lt;code&gt;typeof&lt;/code&gt;, that is hard-boiled into the language and is not supposed to care about the &lt;em&gt;type&lt;/em&gt; of object it's being used on, whereas &lt;code&gt;Array&lt;/code&gt; is a subclass of &lt;code&gt;Object&lt;/code&gt; with methods &lt;em&gt;specifically designed for&lt;/em&gt; working with arrays. So there's no good reason for &lt;code&gt;delete&lt;/code&gt; to have a special case cooked in for re-shifting the array, as that would just slow things down with unnecessary work. In retrospect, my expectations were unrealistic.</source>
          <target state="translated">正直に言うと、 &lt;code&gt;undefined&lt;/code&gt; はなく &lt;code&gt;null&lt;/code&gt; に設定することを除いて（これは合法的に奇妙です）、 &lt;code&gt;delete&lt;/code&gt; は &lt;code&gt;typeof&lt;/code&gt; のような単項演算子であり、言語にハードボイルされており、 気にする &lt;em&gt;必要がない&lt;/em&gt;ため、驚くべきことではありません &lt;code&gt;Array&lt;/code&gt; は、それが使用されているオブジェクトの&lt;em&gt;タイプ&lt;/em&gt;についてです。一方、 Arrayは、 配列を操作する&lt;em&gt;ために特別に設計された&lt;/em&gt;メソッドを持つ &lt;code&gt;Object&lt;/code&gt; のサブクラスです。 したがって、配列を再シフトするために特別なケースを &lt;code&gt;delete&lt;/code&gt; するように削除する理由はありません。不要な作業で速度が低下するだけだからです。 振り返ってみると、私の期待は非現実的でした。</target>
        </trans-unit>
        <trans-unit id="dc3989e98834042a9457a0de8b90b5c9f3024f13" translate="yes" xml:space="preserve">
          <source>How do I remove a property from a JavaScript object</source>
          <target state="translated">JavaScriptオブジェクトからプロパティを削除する方法</target>
        </trans-unit>
        <trans-unit id="b47475af69db5ae110b477abd31ec35a3c7d497a" translate="yes" xml:space="preserve">
          <source>However, be mindful! Do not suddenly start doing this with all your preexisting code now as it would likely break such preexisting code and/or introduce strange bugs. Rather, such an efficient practice needs to be implemented from the start, and when converting preexisting code, it is recommended that you double, triple, quadruple check all the lines relating to that as trying to upgrade old code to this new practice can be as risky as it is rewarding.</source>
          <target state="translated">しかし、注意が必要です。既存のコードを壊したり、奇妙なバグを導入したりする可能性が高いので、いきなり今から既存のコードを使ってこのようなことを始めないでください。むしろ、このような効率的な練習は最初から実装する必要があり、既存のコードを変換するときに、古いコードをこの新しい練習にアップグレードしようとすると、やりがいがあるのと同じくらい危険なことがありますので、それに関連するすべての行を二重、三重、四重にチェックすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="491f0bae14ec381e286ea282ba5b10bae8f240b9" translate="yes" xml:space="preserve">
          <source>However, it will &lt;strong&gt;mutate&lt;/strong&gt; the original object. If you want to create a new object &lt;strong&gt;without&lt;/strong&gt; the specified key, just assign the reduce function to a new variable, e.g.:</source>
          <target state="translated">ただし、元のオブジェクトは変更されます。 キーを指定&lt;strong&gt;せずに&lt;/strong&gt;新しいオブジェクトを作成する場合は、reduce関数を新しい変数に割り当てます。例：</target>
        </trans-unit>
        <trans-unit id="b18c3a88c501a6c91766f406a1e129e6aaa98cea" translate="yes" xml:space="preserve">
          <source>However, there are two major unfixable problems with polymorphic arrays:</source>
          <target state="translated">しかし,ポリモーフィック配列には,修正不可能な2つの大きな問題があります.</target>
        </trans-unit>
        <trans-unit id="3486394d0c7c983de3c5268328e537d9b15cb8f7" translate="yes" xml:space="preserve">
          <source>However, this code:</source>
          <target state="translated">しかし、このコード。</target>
        </trans-unit>
        <trans-unit id="4a71f7845929b0f0df07acdfaf7d379b182e9259" translate="yes" xml:space="preserve">
          <source>I feel it's important to point out the difference between these two similarly-named functions, as they are both very useful.</source>
          <target state="translated">この2つの似たような名前の関数は、どちらも非常に便利なので、その違いを指摘することは重要だと感じています。</target>
        </trans-unit>
        <trans-unit id="459a68f17b246b077cb24b6614e54636e1f0783c" translate="yes" xml:space="preserve">
          <source>I personally use &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; or &lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt; for object and array manipulation:</source>
          <target state="translated">私は個人的にオブジェクトと配列の操作に&lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;または&lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt;を使用しています。</target>
        </trans-unit>
        <trans-unit id="a8613a5b1880d971e632b3352e4bfe554f971c46" translate="yes" xml:space="preserve">
          <source>If a property with the same name exists on the object's prototype
  chain, then, after deletion, the object will use the property from the
  prototype chain (in other words, delete only has an effect on own
  properties).</source>
          <target state="translated">オブジェクトのプロトタイプ・チェーンに同名のプロパティが存在する場合、削除後、オブジェクトはプロトタイプ・チェーンのプロパティを使用します(言い換えれば、削除は自分のプロパティにのみ効果があります)。</target>
        </trans-unit>
        <trans-unit id="1e20c9e61654d816a6093dde8b64312b7bd4779b" translate="yes" xml:space="preserve">
          <source>If the property which you are trying to delete does not exist, delete
  will not have any effect and will return true</source>
          <target state="translated">削除しようとしているプロパティが存在しない場合、deleteは何の効果もなくtrueを返します。</target>
        </trans-unit>
        <trans-unit id="28ec183a3184d93a675028a4e725a85c94f1f649" translate="yes" xml:space="preserve">
          <source>If you do not know the index, you'll also have to do an index search:</source>
          <target state="translated">インデックスがわからない場合は、インデックス検索も必要になります。</target>
        </trans-unit>
        <trans-unit id="3204a3a58282102b99263134aa04e4bbd9031c97" translate="yes" xml:space="preserve">
          <source>If you do:</source>
          <target state="translated">もしそうなら</target>
        </trans-unit>
        <trans-unit id="3204f4d5aa25757c4ed3063f2b869d5fde0626d5" translate="yes" xml:space="preserve">
          <source>If you know the index of your staff member, you could simply do this:</source>
          <target state="translated">担当者の指標を知っていれば、単純にこうすればいいのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="9b546f76f9301b299e7ed78305baf0ef1addfe1c" translate="yes" xml:space="preserve">
          <source>If you want to delete a property deeply nested in the object then you can use the following recursive function with path to the property as the second argument:</source>
          <target state="translated">オブジェクトに深く入れ子になっているプロパティを削除したい場合は、そのプロパティへのパスを第2引数として、以下の再帰関数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="506bf20b873a7a4cd476c438c371ecd4bcca65fc" translate="yes" xml:space="preserve">
          <source>If you want to experiment with this, you can use &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt; as a starting point.</source>
          <target state="translated">これを試してみたい場合は、 &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;このフィドル&lt;/strong&gt;&lt;/a&gt;を出発点として使用できます。</target>
        </trans-unit>
        <trans-unit id="a4e72696da1b895cd7644dbb4f08034ae76c1836" translate="yes" xml:space="preserve">
          <source>If you want to use the entire &lt;code&gt;staff&lt;/code&gt; array, the proper way to do this, would be to do this:</source>
          <target state="translated">&lt;code&gt;staff&lt;/code&gt; 配列全体を使用する場合、これを行う適切な方法は、次のようにすることです。</target>
        </trans-unit>
        <trans-unit id="43cf8d099321d601790e8b3431ad74fdf17809c0" translate="yes" xml:space="preserve">
          <source>Ignoring the dangers and problems inherent in &lt;code&gt;null&lt;/code&gt;, and the space wasted, this can be problematic if the array needs to be precise.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; に固有の危険性と問題、および無駄なスペースを無視すると、配列を正確にする必要がある場合、これは問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c138b726889b4f8045cc8db17ba22f8faa709ac8" translate="yes" xml:space="preserve">
          <source>In addition, while mutating objects in-place isn't stateless, you can use the functional nature of &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; to do partial application and other functional techniques that aren't possible with &lt;code&gt;delete&lt;/code&gt; statements.</source>
          <target state="translated">さらに、オブジェクトをインプレースで変更することはステートレスではありませんが、 &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; の機能的な性質を使用して、部分的に適用したり、 &lt;code&gt;delete&lt;/code&gt; ステートメントでは不可能なその他の機能的なテクニックを実行したりできます。</target>
        </trans-unit>
        <trans-unit id="5b114aff6680bfc75db078ff75477b94c1c576aa" translate="yes" xml:space="preserve">
          <source>In arrays, unlike plain old objects, using &lt;code&gt;delete&lt;/code&gt; leaves behind garbage in the form of &lt;code&gt;null&lt;/code&gt;, creating a &quot;hole&quot; in the array.</source>
          <target state="translated">配列では、単純な古いオブジェクトとは異なり、 &lt;code&gt;delete&lt;/code&gt; を使用すると &lt;code&gt;null&lt;/code&gt; の形式でガベージが残り 、配列に「穴」が作成されます 。</target>
        </trans-unit>
        <trans-unit id="acf20d554a4832d04b9fb4c2dfc6cc9d34eda721" translate="yes" xml:space="preserve">
          <source>In the code above, simply doing &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; will cause a massive memory leak because each animation frame. Each frame, all 65536 DOM elements will take up another 65536 individual slots, but the previous 65536 slots will only be set to undefined which leaves them hanging in the memory. Go ahead, try to run the above code in the console and see for yourself. After forcing an out-of-memory error, attempt to run it again except with the following version of the code that uses the &lt;code&gt;delete&lt;/code&gt; operator instead.</source>
          <target state="translated">上記のコードでは、単純に &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; アニメーションフレームごとに大量のメモリリークが発生します。 フレームごとに、すべての65536 DOM要素が別の65536の個別スロットを占有しますが、以前の65536スロットは未定義に設定されるだけで、メモリ内でハングします。 さあ、コンソールで上記のコードを実行してみてください。 メモリー不足エラーを強制した後、代わりに &lt;code&gt;delete&lt;/code&gt; 演算子を使用する次のバージョンのコードを除いて、もう一度実行してみてください 。</target>
        </trans-unit>
        <trans-unit id="271f117734d63131f8d6a45f399a766357be7419" translate="yes" xml:space="preserve">
          <source>Increasingly stupid edge-case scenario aside, using &lt;code&gt;delete&lt;/code&gt; on said array will result in &lt;code&gt;null&lt;/code&gt; polluting the array, and probably causing bugs in the app later on. And if you check for &lt;code&gt;null&lt;/code&gt;, it would straight up skip the numbers resulting in the tabs being rendered like &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt;.</source>
          <target state="translated">ますます愚かなエッジケースシナリオはさておき、上記の配列で &lt;code&gt;delete&lt;/code&gt; を使用すると、配列が &lt;code&gt;null&lt;/code&gt; で汚染され、後でアプリにバグが発生する可能性があります。 また、 &lt;code&gt;null&lt;/code&gt; をチェックすると、数字がそのままスキップされ、タブが &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt; ようにレンダリングされます 。</target>
        </trans-unit>
        <trans-unit id="67a2e0451ade99e58384dc55f1327e29e5977c70" translate="yes" xml:space="preserve">
          <source>It &lt;strong&gt;deletes the key from the hashmap&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;ハッシュマップからキーを削除します&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="593fba807066e533a5fe4a2443019f46d7ca31da" translate="yes" xml:space="preserve">
          <source>JavaScript is an OOP Language, so everything is an object, including &lt;em&gt;arrays&lt;/em&gt;. Thus, I feel it necessary to point out a particular caveat.</source>
          <target state="translated">JavaScriptはOOP言語であるため、 &lt;em&gt;配列&lt;/em&gt;を含むすべてがオブジェクトです。 したがって、私は特定の警告を指摘する必要があると感じています。</target>
        </trans-unit>
        <trans-unit id="b86b332c3f3aa1433f370f7189813a6381eb2178" translate="yes" xml:space="preserve">
          <source>Library-based property omission</source>
          <target state="translated">ライブラリーベースのプロパティの省略</target>
        </trans-unit>
        <trans-unit id="59b86486aed4edafd59a372a9da15c32460385f0" translate="yes" xml:space="preserve">
          <source>Like this:</source>
          <target state="translated">こんな感じで。</target>
        </trans-unit>
        <trans-unit id="23ee237b458378f4f66052abb7c903c28cbb18e4" translate="yes" xml:space="preserve">
          <source>Look at the &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;benchmark&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;ベンチマークを&lt;/a&gt;&lt;/strong&gt;見てください。</target>
        </trans-unit>
        <trans-unit id="d0447456284f7feabbe03be15bd344b6f319890b" translate="yes" xml:space="preserve">
          <source>Luckily, arrays &lt;em&gt;do&lt;/em&gt; have a specialized method for deleting indices and reallocating memory: &lt;code&gt;Array.prototype.splice()&lt;/code&gt;. You could write something like this:</source>
          <target state="translated">幸いなことに、配列に&lt;em&gt;は&lt;/em&gt; 、インデックスを削除してメモリを再割り当てするための特別なメソッド &lt;code&gt;Array.prototype.splice()&lt;/code&gt; があります。 あなたはこのようなものを書くことができます：</target>
        </trans-unit>
        <trans-unit id="098d9f24825c866c84675902efcb46bcadb54327" translate="yes" xml:space="preserve">
          <source>More than 2X faster than &lt;code&gt;delete&lt;/code&gt;, however the property is &lt;strong&gt;not&lt;/strong&gt; deleted and can be iterated.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; よりも2倍以上高速ですが、プロパティは削除され&lt;strong&gt;ず&lt;/strong&gt; 、反復することができます。</target>
        </trans-unit>
        <trans-unit id="ccc762c5d3373bf8a3cde8b635c9825605d01c63" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, safe</source>
          <target state="translated">変異オブジェクトプロパティ削除、安全</target>
        </trans-unit>
        <trans-unit id="9ce68ac5a3111b339ada2a12dd8cc6eea0e45ffa" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, unsafe</source>
          <target state="translated">変異的オブジェクトプロパティ削除、安全ではない</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="089de7283699cfb1ed6d519cb14e7b0cf6326b5b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;_.pick()&lt;/code&gt; and &lt;code&gt;_.omit()&lt;/code&gt; both return a copy of the object and don't directly modify the original object. Assigning the result to the original object should do the trick (not shown).</source>
          <target state="translated">&lt;code&gt;_.pick()&lt;/code&gt; と &lt;code&gt;_.omit()&lt;/code&gt; はどちらもオブジェクトのコピーを返し、元のオブジェクトを直接変更しないことに注意してください。 結果を元のオブジェクトに割り当てると、うまくいくはずです（図には示されていません）。</target>
        </trans-unit>
        <trans-unit id="74d18dd16f1da3ac16685fb7e2b20e82dd3d4708" translate="yes" xml:space="preserve">
          <source>Note that I purposedly carried out more than one 'delete' operations in one loop cycle to minimize the effect caused by the other operations.</source>
          <target state="translated">なお、私は、他の操作による影響を最小限に抑えるために、1つのループサイクルで複数の「削除」操作をわざと行っています。</target>
        </trans-unit>
        <trans-unit id="cbc78d0538f8d0b1ea57d6e615c0173c54cc2f85" translate="yes" xml:space="preserve">
          <source>Note that the wrapper function is designed to be very strict about types, and will return &lt;code&gt;null&lt;/code&gt; if anything is off. That includes putting in a string like &lt;code&gt;&quot;3&quot;&lt;/code&gt;. It is left up to the programmer to be diligent about his types. This is to encourage good programming practice.</source>
          <target state="translated">ラッパー関数は型について非常に厳密になるように設計されており、オフになっているものがあれば &lt;code&gt;null&lt;/code&gt; を返します 。 これには &lt;code&gt;&quot;3&quot;&lt;/code&gt; のような文字列を入れることが含まれます。 彼のタイプについて勤勉であるかどうかはプログラマに任されています。 これは、プログラミングの実践を促すためです。</target>
        </trans-unit>
        <trans-unit id="0cd1e1c286ff1b960d2aa87f0e85fe9bd6a35fdd" translate="yes" xml:space="preserve">
          <source>Now, if you want to remove a single staff member or student, the procedure is a bit different, because both properties are arrays themselves.</source>
          <target state="translated">さて、一人のスタッフや学生を削除したい場合は、両方のプロパティが配列であるため、手順が少し異なります。</target>
        </trans-unit>
        <trans-unit id="e14273e8bb73415bec8db17e1b9d548211a7aed0" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;could&lt;/em&gt; keep a second iterator, like &lt;code&gt;j&lt;/code&gt;, to increment only when valid values are read from the array. But that wouldn't exactly solve the &lt;code&gt;null&lt;/code&gt; issue, and you still have to please that &lt;s&gt;troll&lt;/s&gt; PDP-11 user. Alas, his computer just &lt;em&gt;doesn't&lt;/em&gt; have enough memory to hold that last integer &lt;sub&gt;(don't ask how he manages to handle a variable-width array...)&lt;/sub&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;j&lt;/code&gt; などの2番目のイテレーターを保持して、配列から有効な値が読み取られたときにのみ増分できるようになりました。 しかし、それは &lt;code&gt;null&lt;/code&gt; の問題を正確に解決するわけではなく、その&lt;s&gt;トロール&lt;/s&gt; PDP-11ユーザーを満足させる必要があります。 悲しいかな、彼のコンピューターに&lt;em&gt;は&lt;/em&gt; 、その最後の整数を保持するのに十分なメモリが&lt;sub&gt;ありません（可変幅の配列をどのように処理するかについては質問しないでください...）&lt;/sub&gt; 。</target>
        </trans-unit>
        <trans-unit id="e28b55f542be9cce84f1cc3f1bdb29e2a2eb72e0" translate="yes" xml:space="preserve">
          <source>Object.assign() &amp;amp; Object.keys() &amp;amp; Array.map()</source>
          <target state="translated">Object.assign（）＆Object.keys（）＆Array.map（）</target>
        </trans-unit>
        <trans-unit id="c643fe374f1dfb8aa281ee046c5ea254b1b7b942" translate="yes" xml:space="preserve">
          <source>Observe. &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; does not coerce polymorphism whereas &lt;code&gt;bar[1] = undefined&lt;/code&gt; does. Therefore, one should always, whenever possible use the corresponding type for their objects so as to not accidentally cause polymorphism. One such person may use the following list as a general reference to get them going. However, please do not explicitly use the below ideas. Instead, use whatever works well for your code.</source>
          <target state="translated">観察する。 &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; はポリモーフィズムを強制しませんが、 &lt;code&gt;bar[1] = undefined&lt;/code&gt; は強制します。 したがって、ポリモーフィズムを誤って引き起こさないように、可能な場合は常にオブジェクトの対応するタイプを使用する必要があります。 そのような人の1人は、次のリストを一般的な参照として使用して、それらを実行できます。 ただし、以下のアイデアを明示的に使用しないでください。 代わりに、コードに適したものを使用してください。</target>
        </trans-unit>
        <trans-unit id="e583eed26b5bb4eb2fe3ea98e3d4481f60fbfae9" translate="yes" xml:space="preserve">
          <source>Of course, it &lt;em&gt;did&lt;/em&gt; surprise me. Because I wrote this to justify my crusade against &quot;null garbage&quot;:</source>
          <target state="translated">もちろん、驚きました。 私がこれを書いたのは、「ヌルゴミ」に対する私の十字軍を正当化するためです。</target>
        </trans-unit>
        <trans-unit id="9d008b07517f4d9dbae6df29270e3dfc66dcea5d" translate="yes" xml:space="preserve">
          <source>Okay, let's just say that you're trying to save memory at the request of this &lt;em&gt;one&lt;/em&gt; user who runs a PDP-11 minicomputer from the 1960's running UNIX and wrote his own Elinks-based, JavaScript-compliant, line-printer-friendly browser because X11 is &lt;em&gt;out of the question&lt;/em&gt;.</source>
          <target state="translated">さて、1960年代に実行されているUNIXからPDP-11ミニコンピューターを実行し、独自のElinksベースのJavaScript準拠のラインプリンター対応ブラウザーを作成したこの&lt;em&gt;1人の&lt;/em&gt;ユーザーの要求で、メモリを節約しようとしているとしましょう。 X11は&lt;em&gt;問題外な&lt;/em&gt;ので。</target>
        </trans-unit>
        <trans-unit id="0746b7ec72e10adab007597141d3dddd2450c60e" translate="yes" xml:space="preserve">
          <source>Old question, modern answer. Using object destructuring, an &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript&amp;nbsp;6&lt;/a&gt; feature, it's as simple as:</source>
          <target state="translated">古い質問、現代の答え。 &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6の&lt;/a&gt;機能であるオブジェクトの分解を使用すると、次のように簡単です。</target>
        </trans-unit>
        <trans-unit id="88891f47a253aa57bb1cb91937b9715b281db53b" translate="yes" xml:space="preserve">
          <source>Once polymorphic, always polymorphic. When an array is made polymorphic, the polymorphism cannot be undone in Webkit browsers. So, even if you restore a polymorphic array to being non-polymorphic, it will still be stored by the browser as a polymorphic array.</source>
          <target state="translated">一度ポリモーフィックにすると、常にポリモーフィックになります。配列をポリモーフィックにすると、Webkit ブラウザではポリモーフィックを元に戻すことができません。そのため、ポリモーフィック配列を非ポリモーフィック配列に復元しても、ブラウザによってポリモーフィック配列として保存されます。</target>
        </trans-unit>
        <trans-unit id="b248f1b8652c2d4ab474434fceed81458cb94383" translate="yes" xml:space="preserve">
          <source>Once those four queries have been answered, there are essentially four categories of &quot;property removal&quot; in JavaScript to chose from in order to meet your goals. They are:</source>
          <target state="translated">これらの4つのクエリに答えが出たら、目的を達成するために、JavaScriptの「プロパティの削除」には、基本的に4つのカテゴリーがあります。それらは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="547c95266578e4dba22f41101c7fbe880f75e156" translate="yes" xml:space="preserve">
          <source>One aspect of Javascript that is important to consider is polymorphism. Polymorphism is when assigning the same variable/slot-in-an-object different types as seen below.</source>
          <target state="translated">考慮すべき Javascript の重要な側面の一つにポリモーフィズムがあります。ポリモーフィズムとは、以下に示すように、同じ変数lot-in-an-objectに異なる型を割り当てる場合のことです。</target>
        </trans-unit>
        <trans-unit id="d59804a9108998189135354633d8b85aa6ac9872" translate="yes" xml:space="preserve">
          <source>One may liken polymorphism to a drug addiction. At first glance, it seems awesomely lucrative: nice pretty fluffy code. Then, the coder introduces their array to the drug of polymorphism. Instantly, the polymorphic array becomes less efficient, and it can never become as efficient as it was before since it is drugged. To correlate such circumstance to real life, someone on cocaine might not even be capable of operating a simple door handle, much less be able to calculate digits of PI. Likewise, an array on the drug of polymorphism cannot ever be as efficient as a monomorphic array.</source>
          <target state="translated">ポリモーフィズムを麻薬中毒に例えることができます。一見すると、とても儲かるように見えます。そして、コーダーは、多相性の薬物に配列を導入します。瞬間的に、多相性のある配列は効率が悪くなり、薬漬けにされているので、以前のように効率的になることはありません。このような状況を実生活に相関させるために、コカインの誰かが、単純なドアハンドルを操作することができないかもしれません、ましてやPIの桁を計算することができないかもしれません。同様に、多形性の薬物の配列は、単形性の配列と同じくらい効率的であることはできません。</target>
        </trans-unit>
        <trans-unit id="81ec1a879d1bcac8eaeb3bcd6cca8f51d459b6e9" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;delete&lt;/code&gt; is unexpectedly slow!</source>
          <target state="translated">オペレーターの &lt;code&gt;delete&lt;/code&gt; が予期せず遅い！</target>
        </trans-unit>
        <trans-unit id="b0213d049275e53829195e4fb176386bc570f98e" translate="yes" xml:space="preserve">
          <source>Or add it as a new pointer to another object like:</source>
          <target state="translated">あるいは、別のオブジェクトへの新しいポインタとして追加することもできます。</target>
        </trans-unit>
        <trans-unit id="b02fc9813af3fdbb140c9b950f4bb96861bf726a" translate="yes" xml:space="preserve">
          <source>Or with the questions sample:</source>
          <target state="translated">または質問サンプルと一緒に。</target>
        </trans-unit>
        <trans-unit id="e9b0d0e32654faf6fc06ca2ce8663172c501d507" translate="yes" xml:space="preserve">
          <source>Or you can also use array-like notation:</source>
          <target state="translated">あるいは、配列のような表記を使うこともできます。</target>
        </trans-unit>
        <trans-unit id="040435ad5191a6323d4b61a949b35014d90fb332" translate="yes" xml:space="preserve">
          <source>Or you can dynamically exclude properties like this,</source>
          <target state="translated">あるいは、このようにプロパティを動的に除外することもできます。</target>
        </trans-unit>
        <trans-unit id="a7ca816fcb165b225c5a6969cca6cd3afa101c70" translate="yes" xml:space="preserve">
          <source>Properties can be removed using &lt;strong&gt;destructuring&lt;/strong&gt; in combination with the &lt;strong&gt;rest operator&lt;/strong&gt;. In your example regex is destructured out (ignored) and the rest of the properties are returned as rest.</source>
          <target state="translated">プロパティは、 &lt;strong&gt;残りの演算子&lt;/strong&gt;と組み合わせて&lt;strong&gt;破壊&lt;/strong&gt;を使用して削除できます。 あなたの例では、正規表現が分解され（無視され）、残りのプロパティが残りとして返されます。</target>
        </trans-unit>
        <trans-unit id="257bb222f1c06e8c1d8edf559d64e06deb75f2f0" translate="yes" xml:space="preserve">
          <source>Property Removal in JavaScript</source>
          <target state="translated">JavaScriptでのプロパティの削除</target>
        </trans-unit>
        <trans-unit id="83a4727bcff27e1d95598a97b2a871336f59a8c8" translate="yes" xml:space="preserve">
          <source>Readable and short, however, it might not be the best choice if you are operating on a large number of objects as its performance is not optimized.</source>
          <target state="translated">読みやすく短いですが、性能が最適化されていないため、多数のオブジェクトを操作する場合には最適な選択とは言えないかもしれません。</target>
        </trans-unit>
        <trans-unit id="ce7827682ca4a098e50c7905bb13aa7c7e60006c" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt;.</source>
          <target state="translated">参照： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f02218cedd8e4fd7e585302dc05d8d0a5833d5f0" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.omit(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">参照： &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.omit（object、* keys）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a3c1aeff97f5a6d2ba0a975a623e96c949b36be" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.pick(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">リファレンス： &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.pick（object、* keys）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5817e749619edf322d60f85b86cab9c7f83094af" translate="yes" xml:space="preserve">
          <source>Rest-based string property omission</source>
          <target state="translated">レストベースの文字列プロパティの省略</target>
        </trans-unit>
        <trans-unit id="ab303515578a450fdf614933afe415b6528c01d1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to omit the 
blacklisted keys (or array of keys).</source>
          <target state="translated">オブジェクトのコピーを返し、ブラックリストに登録されたキー (またはキーの配列)を省略するようにフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="011a1cad4539d30348ba24adcd37dceade1f93c1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to only have values for the 
whitelisted keys (or array of valid keys).</source>
          <target state="translated">ホワイトリストされたキー (あるいは有効なキーの配列)の値のみを持つようにフィルタリングされたオブジェクトのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="650045349baef87a1fa74815eb1e6653f73e4e45" translate="yes" xml:space="preserve">
          <source>Say I create an object as follows:</source>
          <target state="translated">以下のようにオブジェクトを作成したとします。</target>
        </trans-unit>
        <trans-unit id="f5d2829fcf8f71f8331358342fe9021d00422606" translate="yes" xml:space="preserve">
          <source>Setting a property to null before deleting it doesn't accomplish
  anything (unless the object has been sealed by Object.seal and the
  delete fails. That's not usually the case unless you specifically
  try).</source>
          <target state="translated">削除する前にプロパティをnullに設定しても何の効果もありません(Object.sealによってオブジェクトがシールされていて削除に失敗した場合を除く)。通常は、特別な試みをしない限り、このようなことはありません)。)</target>
        </trans-unit>
        <trans-unit id="a1aeff6040cbaf4a052232c94541c2b536b4a1f3" translate="yes" xml:space="preserve">
          <source>Similarly, removing the entire students array would be done by calling &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; or &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt;.</source>
          <target state="translated">同様に、students配列全体を &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; 呼び出します。 または &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd410e78d809f27ec1e3bdad4ee5576324a4212e" translate="yes" xml:space="preserve">
          <source>So as it turns out, there actually IS a built-in way to tell if an array is truly an array, and that is &lt;code&gt;Array.isArray()&lt;/code&gt;, introduced in ECMAScript 5 (December 2009). I found this while looking to see if there was a question asking about telling arrays from objects, to see if there was either a better solution than mine, or to add mine if there were none. So, if you're using a version of JavaScript that is earlier than ECMA 5, there's your polyfill. However, I strongly recommend against using my &lt;code&gt;is_array()&lt;/code&gt; function, as continuing to support old versions of JavaScript means continuing to support the old browsers that implement them, which means encouraging the use of insecure software and putting users at risk for malware. So please, use &lt;code&gt;Array.isArray()&lt;/code&gt;. Use &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Use the new features that get added to the language. &lt;em&gt;Don't&lt;/em&gt; use vendor prefixes. &lt;em&gt;Delete&lt;/em&gt; that IE polyfill crap from your website. Delete that XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; crap, too--we moved to HTML5 back in 2014. The sooner everybody withdraws support for those old/esoteric browsers, the sooner the browser vendors will actually follow the web standard and embrace the new technology, and the sooner we can move on to a more secure web.</source>
          <target state="translated">&lt;code&gt;Array.isArray()&lt;/code&gt; 、実際には、配列が本当に配列であるかどうかを確認する組み込みの方法があり、それはECMAScript 5（2009年12月）で導入されたArray.isArray（ ）です。 配列をオブジェクトから区別することについて質問があるかどうか、自分よりも優れた解決策があるかどうか、またはない場合は追加するかどうかを調べているときに、これを見つけました。 したがって、ECMA 5より前のバージョンのJavaScriptを使用している場合は、ポリフィルがあります。 ただし、古いバージョンのJavaScriptを引き続きサポートすることは、それらを実装する古いブラウザーを引き続きサポートすることを意味するため、私の &lt;code&gt;is_array()&lt;/code&gt; 関数を使用しないことを強くお勧めします。つまり、安全でないソフトウェアの使用を奨励し、ユーザーをマルウェアのリスクにさらします。 したがって、 &lt;code&gt;Array.isArray()&lt;/code&gt; を使用してください。 &lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; を使用します。 言語に追加された新機能を使用します。 ベンダープレフィックスを使用&lt;em&gt;しないでください&lt;/em&gt; 。 そのIEポリフィルのがらくたをWebサイトから&lt;em&gt;削除&lt;/em&gt;します。 そのXHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; がらくたも削除します-2014年にHTML5に移行しました。古い/難解なブラウザーのサポートを誰もが撤回するのが早ければ早いほど、ブラウザーベンダーが実際にWeb標準に準拠し、新しいテクノロジー、そしてより早く安全なウェブに移行できるようになります。</target>
        </trans-unit>
        <trans-unit id="c1074a68b7264ece395e8476f70ae784fc36b406" translate="yes" xml:space="preserve">
          <source>So, he sends you an email in anger:</source>
          <target state="translated">そこで、彼は怒りのメールを送ります。</target>
        </trans-unit>
        <trans-unit id="1c63c8fdc7a32a45814f6f70f31838cecabdb16b" translate="yes" xml:space="preserve">
          <source>So, when deleting values from an object, always first consider whether you're dealing with object properties or whether you're dealing with array values, and choose the appropriate strategy based on that.</source>
          <target state="translated">ですから、オブジェクトから値を削除するときには、オブジェクトのプロパティを扱っているのか、配列の値を扱っているのかを常に最初に考えて、それに基づいて適切な戦略を選択してください。</target>
        </trans-unit>
        <trans-unit id="da5db28dd16264310f46eacb87a0cb2b9ceef675" translate="yes" xml:space="preserve">
          <source>Sorry if this didn't add to your specific use case but I believe this to be a good design to adapt when managing objects and their properties.</source>
          <target state="translated">特定のユースケースに当てはまらなかったら申し訳ありませんが、これはオブジェクトとそのプロパティを管理する際に適応するための良いデザインだと思います。</target>
        </trans-unit>
        <trans-unit id="ace92799b8ad9dc2af653b95d2a4f16910423d4b" translate="yes" xml:space="preserve">
          <source>Suppose you have an object that looks like this:</source>
          <target state="translated">このようなオブジェクトがあるとします。</target>
        </trans-unit>
        <trans-unit id="c5229642bf5961f2b277471727e88e647035ac9e" translate="yes" xml:space="preserve">
          <source>Syntax-based string property omission</source>
          <target state="translated">構文ベースの文字列プロパティの省略</target>
        </trans-unit>
        <trans-unit id="07c468c127104c88b077c6e07b9d9ec7d4fdbf7d" translate="yes" xml:space="preserve">
          <source>THE LONG VERSION</source>
          <target state="translated">長編</target>
        </trans-unit>
        <trans-unit id="11405ca028271229b8731c4ce6c20d04dc54cc92" translate="yes" xml:space="preserve">
          <source>THE SHORT VERSION</source>
          <target state="translated">短編</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="748beb2ad7204d2997b5d2a12f2e0bc89bcc8e5e" translate="yes" xml:space="preserve">
          <source>That actually isn't what's happening, but it's easier to think of that way. According to MDN, here's what's actually happening:</source>
          <target state="translated">実際に起きているのはそうではありませんが、その方が考えやすいでしょう。MDNによると、実際に起きていることはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="cf85fec62dde51f1637af10a625442c3baea4c48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt; is the best way to do so.</source>
          <target state="translated">これを行うには、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;削除演算子&lt;/a&gt;が最適です。</target>
        </trans-unit>
        <trans-unit id="881ea24ac20b3a2b7bbbd8208c871ee412db982f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;key remains on its place in the hashmap&lt;/strong&gt;, only the value is replaced with &lt;code&gt;undefined&lt;/code&gt;. Understand, that &lt;code&gt;for..in&lt;/code&gt; loop will still iterate over that key.</source>
          <target state="translated">&lt;strong&gt;キーはハッシュマップのその場所に残り&lt;/strong&gt; 、値だけが &lt;code&gt;undefined&lt;/code&gt; 置き換えられます。 その &lt;code&gt;for..in&lt;/code&gt; ループは、そのキーを繰り返し処理します。</target>
        </trans-unit>
        <trans-unit id="edc38116420d64a21ebfee30ed9c7476267110df" translate="yes" xml:space="preserve">
          <source>The Solution: &lt;code&gt;Array.prototype.splice&lt;/code&gt;</source>
          <target state="translated">ソリューション： &lt;code&gt;Array.prototype.splice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="071cbdf7a24a78eb243d7c493b80aadba4657908" translate="yes" xml:space="preserve">
          <source>The actual answer to the question</source>
          <target state="translated">実際の答えは</target>
        </trans-unit>
        <trans-unit id="c0ec14910cf4674ceea7f9ad991e964445d6c9ac" translate="yes" xml:space="preserve">
          <source>The answer would be to &lt;strong&gt;delete all the references you have in your code, pointed to that very object&lt;/strong&gt; and also &lt;strong&gt;not use &lt;code&gt;var&lt;/code&gt; statements to create new references to that object&lt;/strong&gt;. This last point regarding &lt;code&gt;var&lt;/code&gt; statements, is one of the most crucial issues that we are usually faced with, because using &lt;code&gt;var&lt;/code&gt; statements would prevent the created object from getting removed.</source>
          <target state="translated">答えは&lt;strong&gt;、コード内にあるすべての参照&lt;/strong&gt;を&lt;strong&gt;削除し、そのオブジェクト自体を指し示し、&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;var&lt;/code&gt; ステートメントを使用してそのオブジェクトへの新しい参照を作成しないこと&lt;/strong&gt;です。 &lt;code&gt;var&lt;/code&gt; ステートメントに関するこの最後のポイントは、 varステートメントを使用すると、作成されたオブジェクトが削除されなくなるため、通常直面する最も重要な問題の1つです。</target>
        </trans-unit>
        <trans-unit id="c25007fa1063a6b669074a068e8e0d9c200dbaad" translate="yes" xml:space="preserve">
          <source>The contrived and long-winded PDP-11 scenario</source>
          <target state="translated">捏造された長文のPDP-11のシナリオ</target>
        </trans-unit>
        <trans-unit id="f621835acbbff87822c037f614ae8feebd84f7e5" translate="yes" xml:space="preserve">
          <source>The delete operator removes a given property from an object. On
  successful deletion, it will return true, else false will be returned.
  However, it is important to consider the following scenarios:</source>
          <target state="translated">delete 演算子は、オブジェクトから指定されたプロパティを削除します。削除に成功した場合はtrueを返し、そうでない場合はfalseを返します。しかし、以下のシナリオを考慮することが重要です。</target>
        </trans-unit>
        <trans-unit id="88d438bbfeb05c4266f6e27b90dcb851c6f60ce6" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;deleteProperty&lt;/code&gt; is when using strict mode:</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; と &lt;code&gt;deleteProperty&lt;/code&gt; の違いは、strictモードを使用する場合です。</target>
        </trans-unit>
        <trans-unit id="efccd6cd704a79d07bccddefc3adbae94e968c39" translate="yes" xml:space="preserve">
          <source>The following snippet gives another simple example:</source>
          <target state="translated">以下のスニペットは、別の簡単な例を示しています。</target>
        </trans-unit>
        <trans-unit id="bf8a2a946389853c6d0799bf61400c9d604dd48d" translate="yes" xml:space="preserve">
          <source>The index specified by &lt;code&gt;end&lt;/code&gt; is simply excluded from the slice. The parenthesized indices indicate what gets sliced. Either way, the behavior is not intuitive and it's bound to cause its fair share of off-by-one errors, so you might find it useful to make a wrapper function to more closely emulate the behavior of &lt;code&gt;.splice()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; で指定されたインデックスは、単にスライスから除外されます。 括弧で囲まれたインデックスは、何がスライスされるかを示します。 どちらの方法でも、動作は直感的ではなく、オフ &lt;code&gt;.splice()&lt;/code&gt; エラーの公平な共有を引き起こすため、ラッパー関数を作成して.splice（）の動作をより厳密にエミュレートすると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="367c08658a0eaac4d7f551272d9531077bdd6a38" translate="yes" xml:space="preserve">
          <source>The other important point here is to be careful about your other references to the same object. For instance, if you create a variable like:</source>
          <target state="translated">ここでのもう一つの重要なポイントは、同じオブジェクトへの他の参照に注意することです。例えば、変数を作成した場合。</target>
        </trans-unit>
        <trans-unit id="556ff37bb94e5cbb3dd116d5ddf709d4c4f7ed56" translate="yes" xml:space="preserve">
          <source>The programming ethos/patterns you and your team use. Do you favor functional approaches and mutation is verboten on your team, or do you employ wild west mutative object-oriented techniques?</source>
          <target state="translated">あなたとあなたのチームが使用しているプログラミングの倫理パターン。あなたのチームでは機能的なアプローチが好まれ、突然変異は禁止されています。</target>
        </trans-unit>
        <trans-unit id="6357292b24fba94284af6389041f255b8a00f04f" translate="yes" xml:space="preserve">
          <source>The range of object types you want to remove properties on and the type of property names you need to be able to omit (Strings only? Symbols? Weak references mapped from arbitrary objects? These have all been types of property pointers in JavaScript for years now)</source>
          <target state="translated">プロパティを削除したいオブジェクトタイプの範囲と、省略できるようにする必要があるプロパティ名のタイプ(文字列のみ?記号のみ?任意のオブジェクトからマップされた弱い参照?これらはすべてJavaScriptのプロパティ・ポインタの型として何年も前から存在しています)</target>
        </trans-unit>
        <trans-unit id="3fea2fb86e2276224dff32e33243b1e22287ed2d" translate="yes" xml:space="preserve">
          <source>The reason for writing this new &lt;code&gt;unset&lt;/code&gt; function, is to keep the index of all other variables in this hash_map. Look at the following example, and see how the index of &quot;test2&quot; did not change after removing a value from the hash_map.</source>
          <target state="translated">この新しい &lt;code&gt;unset&lt;/code&gt; 関数を作成する理由は、このhash_map内の他のすべての変数のインデックスを保持するためです。 次の例を見て、hash_mapから値を削除した後、「test2」のインデックスがどのように変化しなかったかを確認してください。</target>
        </trans-unit>
        <trans-unit id="e16825f749b4e5fb7d1fecf43d4e6b653061e2e8" translate="yes" xml:space="preserve">
          <source>The result would be &lt;code&gt;false&lt;/code&gt;, which means that your delete statement haven't been executed as you expected. But if you had not created that variable before, and you only had &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; as your last existing reference, you could have done this just by removing it like:</source>
          <target state="translated">結果は &lt;code&gt;false&lt;/code&gt; になります 。これは、deleteステートメントが期待どおりに実行されなかったことを意味します。 しかし、その変数を以前に作成したことがなく、 &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; のみが最後の既存の参照である場合は、次のように削除するだけでこれを実行できます。</target>
        </trans-unit>
        <trans-unit id="f6481accf44872d4ef8745c055193c2829ccd3cb" translate="yes" xml:space="preserve">
          <source>The term you have used in your question title &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt;, can be interpreted in some different ways. The one is to remove it for whole the memory and the list of object keys or the other is just to remove it from your object. As it has been mentioned in some other answers, the &lt;code&gt;delete&lt;/code&gt; keyword is the main part. Let's say you have your object like:</source>
          <target state="translated">質問のタイトルで使用した用語 &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt; は、いくつかの異なる方法で解釈できます。 1つはメモリ全体とオブジェクトキーのリストから削除する方法、もう1つはオブジェクトから削除する方法です。 他のいくつかの回答で言及されているように、 &lt;code&gt;delete&lt;/code&gt; キーワードが主要な部分です。 次のようなオブジェクトがあるとします。</target>
        </trans-unit>
        <trans-unit id="d7c42d645c208dfd4e3c38a50db94ab5a07bdf03" translate="yes" xml:space="preserve">
          <source>The version of ECMAScript you're targeting</source>
          <target state="translated">対象とする ECMAScript のバージョン</target>
        </trans-unit>
        <trans-unit id="2d17e745883099706ab5b904d19b87cebce1764f" translate="yes" xml:space="preserve">
          <source>Then even if you remove it from your object &lt;code&gt;myJSONObject&lt;/code&gt;, that specific object won't get deleted from the memory, since the &lt;code&gt;regex&lt;/code&gt; variable and &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; still have their values. Then how could we remove the object from the memory for sure?</source>
          <target state="translated">次に、オブジェクト &lt;code&gt;myJSONObject&lt;/code&gt; から削除しても、 &lt;code&gt;regex&lt;/code&gt; 変数と &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; まだ値があるため、その特定のオブジェクトはメモリから削除されません。 では、どうすればオブジェクトをメモリから確実に削除できるでしょうか。</target>
        </trans-unit>
        <trans-unit id="9f315ff9ba259ec4af4aad477da9caf99c783595" translate="yes" xml:space="preserve">
          <source>Then your objects key using &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; would be:</source>
          <target state="translated">次に、 &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; を使用したオブジェクトキーは次のようになります。</target>
        </trans-unit>
        <trans-unit id="950ba1d1f6aad6e3258d15bc7f08a5e034f6a816" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I just want to chime in that when using delete to remove a property in JavaScript, it is often wise to first check if that property exists to prevent errors.</source>
          <target state="translated">ここには多くの良い答えがありますが、JavaScriptのプロパティを削除するためにdeleteを使用する場合、エラーを防ぐためにそのプロパティが存在するかどうかを最初に確認するのが賢明であることが多いということを述べておきたいと思います。</target>
        </trans-unit>
        <trans-unit id="57100a7adc73f2ac8fb1259dcb31d2cae8056822" translate="yes" xml:space="preserve">
          <source>There are few common ways to remove a property from an object.</source>
          <target state="translated">オブジェクトからプロパティを削除する一般的な方法はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="8604def9bd3e30573031d5be629fb2bb0c18ca39" translate="yes" xml:space="preserve">
          <source>There are many different options presented on this page, not because most of the options are wrong&amp;mdash;or because the answers are duplicates&amp;mdash;but because the appropriate technique depends on the situation you're in and the goals of the tasks you and/or you team are trying to fulfill. To answer you question unequivocally, one needs to know:</source>
          <target state="translated">このページにはさまざまなオプションが表示されますが、ほとんどのオプションが間違っているため、または回答が重複しているためではありませんが、適切な手法は、現在の状況と、あなたやあなた自身のタスクの目標によって異なります。チームは実現しようとしています。 明確に質問に答えるには、次のことを知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="5f1efa2f9fb405d638f74fe5349dbabb89e0514a" translate="yes" xml:space="preserve">
          <source>They are slow &amp;amp; memory inefficient. When accessing a specific index, instead of just getting the global type for the array, the browser instead has to get the type on a per-index basis whereby each index stores the additional metadata of its type.</source>
          <target state="translated">それらは遅く、メモリ効率が悪い。 特定のインデックスにアクセスする場合、ブラウザは配列のグローバルタイプを取得するだけでなく、インデックスごとにタイプを取得する必要があります。これにより、各インデックスはそのタイプの追加のメタデータを格納します。</target>
        </trans-unit>
        <trans-unit id="afa3b2f30890db447e4cf00d9f2dcec7b332b01b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;ES6&lt;/code&gt; operator allows us to return a brand new object, excluding any properties, without mutating the existing object. The downside is that it has the worse performance out of the above and not suggested to be used when you need to remove many properties at a time.</source>
          <target state="translated">この &lt;code&gt;ES6&lt;/code&gt; 演算子を使用すると、既存のオブジェクトを変更せずに、プロパティを除外した新しいオブジェクトを返すことができます。 欠点は、上記のパフォーマンスが低下することであり、一度に多くのプロパティを削除する必要がある場合に使用することは推奨されません。</target>
        </trans-unit>
        <trans-unit id="9e7248bc6c7cf17aeb43a8906d8cc8e3b531512b" translate="yes" xml:space="preserve">
          <source>This alternative is not the correct answer to this question! But, if you use it with care, you can dramatically speed up some algorithms. If you are using &lt;code&gt;delete&lt;/code&gt; in loops and you have problems with performance, read the verbose explanation.</source>
          <target state="translated">この選択肢は、この質問に対する正しい答えではありません！ ただし、注意して使用すると、一部のアルゴリズムを大幅に高速化できます。 ループ内で &lt;code&gt;delete&lt;/code&gt; を使用していて、パフォーマンスに問題がある場合は、詳細な説明を読んでください。</target>
        </trans-unit>
        <trans-unit id="d2696a11c056f55fc8c70ea4ff94e4f5922248e1" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference and aren't using stateless functional principles in your code. An example piece of syntax in this category:</source>
          <target state="translated">このカテゴリは、元の参照を継続して使用し、コードでステートレスな機能原理を使用していない場合に、オブジェクト リテラルまたはオブジェクト インスタンスを操作するためのカテゴリです。このカテゴリの構文の例。</target>
        </trans-unit>
        <trans-unit id="1f8c0c20dd501470cb117b73c855e583ae2e0193" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference while guarding against exceptions being thrown on unconfigurable properties:</source>
          <target state="translated">このカテゴリは、構成不可能なプロパティに対して例外がスローされることを防ぎながら、元の参照を継続して使用したい場合に、オブジェクト・リテラルやオブジェクト・インスタンスを操作するためのカテゴリです。</target>
        </trans-unit>
        <trans-unit id="94bdb987c00caa2e598854f97ea3c6de4e30eedf" translate="yes" xml:space="preserve">
          <source>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</source>
          <target state="translated">このカテゴリは、新しいECMAScriptのフレーバーのプレーンオブジェクトや配列インスタンスを操作するためのもので、非互変的なアプローチが必要な場合や、Symbolキーを考慮する必要がない場合に使用します。</target>
        </trans-unit>
        <trans-unit id="aba34382b27aca74b69be04c741119ab744a49b9" translate="yes" xml:space="preserve">
          <source>This category is generally allows for greater functional flexibility, including accounting for Symbols &amp;amp; omitting more than one property in one statement:</source>
          <target state="translated">このカテゴリでは通常、記号の考慮や1つのステートメントでの複数のプロパティの省略など、機能の柔軟性が向上します。</target>
        </trans-unit>
        <trans-unit id="17ff7f9c0c298023ffef1288d23c2efc74ebdf5c" translate="yes" xml:space="preserve">
          <source>This category is the oldest, most straightforward &amp;amp; most widely supported category of property removal. It supports &lt;code&gt;Symbol&lt;/code&gt; &amp;amp; array indexes in addition to strings and works in every version of JavaScript except for the very first release. However, it's mutative which violates some programming principles and has performance implications. It also can result in uncaught exceptions when used on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;non-configurable properties in strict mode&lt;/a&gt;.</source>
          <target state="translated">このカテゴリは、最も古く、最もわかりやすく、最も広くサポートされているプロパティの削除のカテゴリです。 文字列に加えて &lt;code&gt;Symbol&lt;/code&gt; と配列のインデックスをサポートし、最初のリリースを除くすべてのバージョンのJavaScriptで機能します。 ただし、一部のプログラミング原則に違反し、パフォーマンスに影響を与える変異です。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;strictモードの設定不可能なプロパティで&lt;/a&gt;使用すると、キャッチされない例外が発生する可能性もあります 。</target>
        </trans-unit>
        <trans-unit id="4ad77472ac7767c23050851eada92d065c2bd943" translate="yes" xml:space="preserve">
          <source>This is in regard to this (now-removed) snippet:</source>
          <target state="translated">これは、この(現在は削除された)スニペットに関するものです。</target>
        </trans-unit>
        <trans-unit id="21292c660408d1ff92d4a1c2c4eafdd76c276e51" translate="yes" xml:space="preserve">
          <source>This post is very old and I find it very helpful so I decided to share the unset function I wrote in case someone else see this post and think why it's not so simple as it in PHP unset function.</source>
          <target state="translated">この記事は非常に古く、私はそれが非常に有用であることを見つけるので、私は他の誰かがこの記事を見て、なぜそれはPHPのアンセット関数でそれのように単純ではないと思う場合には、私が書いたアンセット関数を共有することにしました。</target>
        </trans-unit>
        <trans-unit id="9603916ceb02f62ecad35613c65fb5ceed83b60d" translate="yes" xml:space="preserve">
          <source>This works in Firefox and Internet&amp;nbsp;Explorer, and I think it works in all others.</source>
          <target state="translated">これはFirefoxとInternet Explorerで機能し、他のすべての機能で機能すると思います。</target>
        </trans-unit>
        <trans-unit id="c685cc94e2b05416a2b9215116753bb12c7af729" translate="yes" xml:space="preserve">
          <source>To complete @Koen answer in this thread, in case you want to remove dynamic variable using the spread syntax, you can do it like so:</source>
          <target state="translated">このスレッドでの@Koenさんの回答を完結させるために、スプレッド構文を使って動的変数を削除したい場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="a792292997434d58f8b1d7da4af78863ac5e4684" translate="yes" xml:space="preserve">
          <source>To get more info on &lt;code&gt;Object.seal&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal()&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Object.seal&lt;/code&gt; の詳細情報を取得するには： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96589c0ac9acf3a6b58f6928336639e582088ee3" translate="yes" xml:space="preserve">
          <source>To reassign to the same variable, use a &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">同じ変数に再度割り当てるには、 &lt;code&gt;let&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="21af806df3feb60911002a77c4380b2b484f7bbf" translate="yes" xml:space="preserve">
          <source>To remove any property, say &lt;code&gt;key1&lt;/code&gt;, use the &lt;code&gt;delete&lt;/code&gt; keyword like this:</source>
          <target state="translated">&lt;code&gt;key1&lt;/code&gt; などのプロパティを削除するには、次のように &lt;code&gt;delete&lt;/code&gt; キーワードを使用します。</target>
        </trans-unit>
        <trans-unit id="fa15c129befde7656ac754122a25210685ef2188" translate="yes" xml:space="preserve">
          <source>To summarize, differences are all about ways of determining the property existence, and about &lt;code&gt;for..in&lt;/code&gt; loop.</source>
          <target state="translated">要約すると、違いはすべて、プロパティの存在を判断する方法と、 &lt;code&gt;for..in&lt;/code&gt; ループについてです 。</target>
        </trans-unit>
        <trans-unit id="87501fb0e92ec552bdf306c07f48852286e9c8c8" translate="yes" xml:space="preserve">
          <source>To whoever needs it...</source>
          <target state="translated">必要な人に...</target>
        </trans-unit>
        <trans-unit id="b7ff74710b25d787ff3d518b1667a655a5936c78" translate="yes" xml:space="preserve">
          <source>Try the following method. Assign the &lt;code&gt;Object&lt;/code&gt; property value to &lt;code&gt;undefined&lt;/code&gt;. Then &lt;code&gt;stringify&lt;/code&gt; the object and &lt;code&gt;parse&lt;/code&gt;.</source>
          <target state="translated">次の方法を試してください。 &lt;code&gt;Object&lt;/code&gt; プロパティの値を &lt;code&gt;undefined&lt;/code&gt; に割り当てます。 次に、オブジェクトを &lt;code&gt;stringify&lt;/code&gt; て &lt;code&gt;parse&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="3d82a9f15156c36519fc72f9af221c32d7422e29" translate="yes" xml:space="preserve">
          <source>Try this</source>
          <target state="translated">これを試してみてください</target>
        </trans-unit>
        <trans-unit id="828f97e6c91f157ecd45fc8183a07ca7b4e95e6f" translate="yes" xml:space="preserve">
          <source>Update regarding &lt;code&gt;is_array()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_array()&lt;/code&gt; に関する更新</target>
        </trans-unit>
        <trans-unit id="d45aa1f9d8100f951a216d7ce715ec8d99477eb3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda#dissoc&lt;/a&gt; you will get a new object without the attribute &lt;code&gt;regex&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda＃dissoc&lt;/a&gt;を使用すると、属性 &lt;code&gt;regex&lt;/code&gt; なしで新しいオブジェクトを取得できます。</target>
        </trans-unit>
        <trans-unit id="930151a2e26bf074e4b81d244de5799b750be707" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;delete&lt;/strong&gt; method is the best way to do that, as per MDN description, the delete operator removes a property from an object. So you can simply write:</source>
          <target state="translated">これを行うには、MDNの説明に従って、 &lt;strong&gt;delete&lt;/strong&gt;メソッドを使用&lt;strong&gt;するの&lt;/strong&gt;が最良の方法です。delete演算子は、オブジェクトからプロパティを削除します。 だからあなたは単に書くことができます：</target>
        </trans-unit>
        <trans-unit id="855d634ee489e4e0a2c811671f665628a0a0df6f" translate="yes" xml:space="preserve">
          <source>Using ES6:</source>
          <target state="translated">ES6を使用しています。</target>
        </trans-unit>
        <trans-unit id="9fb406e463a70799e2a3db3cb0956dde6058516c" translate="yes" xml:space="preserve">
          <source>Using this method, not all &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;ways of determining property existence&lt;/a&gt; will work as expected.</source>
          <target state="translated">この方法を使用すると、 &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;プロパティの存在を判別する&lt;/a&gt;すべての方法が期待どおりに機能するわけではありません。</target>
        </trans-unit>
        <trans-unit id="7d56ccd01dc2c25715aa91cc5c3b3239162d1db4" translate="yes" xml:space="preserve">
          <source>What follows is a contrived scenario that gets pretty long-winded, so you can skip to the section, &lt;strong&gt;The Solution&lt;/strong&gt;, if you want. The only reason I leave this section it is that I think some people probably think it's funny, and I don't want to be &quot;that guy&quot; who posts a &quot;funny&quot; answer and then deletes all the &quot;funny&quot; from it later on.</source>
          <target state="translated">以下のシナリオはかなり長くかかる不自然なシナリオなので、必要に応じて、 &lt;strong&gt;「ソリューション&lt;/strong&gt; 」のセクションにスキップできます。 私がこのセクションを離れる唯一の理由は、おそらく面白いと思う人もいるだろうと思うし、「面白い」回答を投稿し、後で「面白い」をすべて削除する「あの男」になりたくないからです。 。</target>
        </trans-unit>
        <trans-unit id="e8a0f3d5fef79ddff6c740f20faf1841e9c8a913" translate="yes" xml:space="preserve">
          <source>What is the best way to remove the property &lt;code&gt;regex&lt;/code&gt; to end up with new &lt;code&gt;myObject&lt;/code&gt; as follows?</source>
          <target state="translated">プロパティの &lt;code&gt;regex&lt;/code&gt; を削除して、新しい &lt;code&gt;myObject&lt;/code&gt; を次のように削除する最良の方法は何ですか？</target>
        </trans-unit>
        <trans-unit id="269ad8f4ba0c959d755966ae84263f7c06ef0a98" translate="yes" xml:space="preserve">
          <source>When should one use &lt;code&gt;delete&lt;/code&gt; and when set value to &lt;code&gt;undefined&lt;/code&gt; ?</source>
          <target state="translated">いつ &lt;code&gt;delete&lt;/code&gt; を使用し、値を &lt;code&gt;undefined&lt;/code&gt; に設定する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="f73054e5169db0bc5c2ed5932270c4a709d901aa" translate="yes" xml:space="preserve">
          <source>When using a Symbol, wait, why are you using a Symbol?!?! Symbols are bad  juju for performance. Everything programmed to use Symbols can be reprogrammed to not use Symbols, resulting in a faster code without Symbols. Symbols are really just super inefficient meta-sugar.</source>
          <target state="translated">シンボルを使うときは、待って、なぜシンボルを使うのか!?シンボルはパフォーマンスに悪影響を与えます。シンボルを使うようにプログラムされたものはすべてシンボルを使わないようにプログラムし直すことができます。シンボルは本当に非効率的なメタ糖です。</target>
        </trans-unit>
        <trans-unit id="602ae3083b5ceb94cfa5bb3b6f0e1f19f1f16418" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the boolean primitive, use either &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the empty value. While avoiding unnecessary polymorphism is good, rewriting all your code to explicitly forbid it will likely actually result in a decrease in performance. Use common judgement!</source>
          <target state="translated">ブールプリミティブに型指定された配列/変数を使用する場合は、空の値として &lt;code&gt;false&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を使用します。 不要なポリモーフィズムを回避することは良いことですが、明示的に禁止するようにすべてのコードを書き直すと、実際にパフォーマンスが低下する可能性があります。 一般的な判断を使用してください！</target>
        </trans-unit>
        <trans-unit id="97e2c329b633d1758a70203709d67ea5a41bbc86" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the number primitive, use &lt;code&gt;0&lt;/code&gt; as the empty value. Note that internally, there are two types of numbers: fast integers (2147483647 to -2147483648 inclusive) and slow floating point doubles (anything other than that including &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt;). When an integer is demoted to a double, it cannot be promoted back to an integer.</source>
          <target state="translated">数値プリミティブに型指定された配列/変数を使用する場合は、空の値として &lt;code&gt;0&lt;/code&gt; を使用します。 内部的には、2つのタイプの数値があることに注意してください：高速整数（2147483647から-2147483648まで）および低速浮動小数点の倍精度浮動小数点数（ &lt;code&gt;NaN&lt;/code&gt; および &lt;code&gt;Infinity&lt;/code&gt; を含むそれ以外のもの）。 整数がdoubleに降格されると、昇格して整数に戻すことはできません。</target>
        </trans-unit>
        <trans-unit id="363e06ebcbb46e5d020be755b34062c111648564" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the string primitive, use &lt;code&gt;&quot;&quot;&lt;/code&gt; as the empty value.</source>
          <target state="translated">文字列プリミティブに型指定された配列/変数を使用する場合は、空の値として &lt;code&gt;&quot;&quot;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="2daf2d7377c143fd1982ce05f553ab2ba4bd19a7" translate="yes" xml:space="preserve">
          <source>When using anything else, use &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">それ以外のものを使用する場合は、 &lt;code&gt;null&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="99129be375514e4d040c762996086e2002e66f2e" translate="yes" xml:space="preserve">
          <source>Which is a terrible justification for getting rid of the &lt;code&gt;null&lt;/code&gt;s--&lt;code&gt;null&lt;/code&gt; is only dangerous if used improperly, and it has nothing to do with &quot;precision&quot;. The real reason you shouldn't &lt;code&gt;delete&lt;/code&gt; from an array is that leaving garbage-filled and messy data structures around is sloppy and bug-prone.</source>
          <target state="translated">これは、 &lt;code&gt;null&lt;/code&gt; sを取り除くための恐ろしい正当化です。 &lt;code&gt;null&lt;/code&gt; は、不適切に使用された場合にのみ危険であり、「精度」とは何の関係もありません。 配列から &lt;code&gt;delete&lt;/code&gt; すべきではない本当の理由は、ガベージで乱雑なデータ構造を残しておくと、ずさんでバグが発生しやすくなるためです。</target>
        </trans-unit>
        <trans-unit id="1f5947457b95655f5329f1cfd08d1b56c64dd6e7" translate="yes" xml:space="preserve">
          <source>Which means in this case you won't be able to remove that object because you have created the &lt;code&gt;regex&lt;/code&gt; variable via a &lt;code&gt;var&lt;/code&gt; statement, and if you do:</source>
          <target state="translated">つまり、この場合、 &lt;code&gt;var&lt;/code&gt; ステートメントを使用して &lt;code&gt;regex&lt;/code&gt; 変数を作成したため、そのオブジェクトを削除できません。</target>
        </trans-unit>
        <trans-unit id="4f17f120087f0ca40e417b064249125802d82ec5" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; is faster than doing &lt;code&gt;delete obj[prop]&lt;/code&gt;, another important consideration is that &lt;code&gt;obj[prop] = undefined&lt;/code&gt; may not always be appropriate. &lt;code&gt;delete obj[prop]&lt;/code&gt; removes &lt;code&gt;prop&lt;/code&gt; from &lt;code&gt;obj&lt;/code&gt; and erases it from memory whereas &lt;code&gt;obj[prop] = undefined&lt;/code&gt; simply sets the value of &lt;code&gt;prop&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; which leaves &lt;code&gt;prop&lt;/code&gt; still in memory. Therefore, in circumstances where there are many keys being created and deleted, using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; can force expensive memory reconciliation (causing the page to freeze up) and potentially an out-of-memory error. Examine the following code.</source>
          <target state="translated">&lt;code&gt;obj[prop] = undefined&lt;/code&gt; を &lt;code&gt;delete obj[prop]&lt;/code&gt; 方がdelete obj [prop]を実行するより高速ですが、もう1つの重要な考慮事項は、 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; が常に適切であるとは限らないことです。 &lt;code&gt;delete obj[prop]&lt;/code&gt; は、 &lt;code&gt;prop&lt;/code&gt; を &lt;code&gt;obj&lt;/code&gt; から削除してメモリから消去しますが、 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; は、 &lt;code&gt;prop&lt;/code&gt; の値をundefinedに設定するだけで、 propをメモリに残します。 したがって、多くのキーが作成および削除される状況で、 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; を使用すると、 負荷の高いメモリ調整（ページがフリーズする原因）が発生し、メモリ不足エラーが発生する可能性があります。 次のコードを調べます。</target>
        </trans-unit>
        <trans-unit id="9fc668854fffc36979144c2d4415e9f9721712c0" translate="yes" xml:space="preserve">
          <source>While you technically can use &lt;code&gt;delete&lt;/code&gt; for an array, using it would result in getting incorrect results when calling for example &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; later on. In other words, &lt;code&gt;delete&lt;/code&gt; would remove the element, but it wouldn't update the value of &lt;code&gt;length&lt;/code&gt; property. Using &lt;code&gt;delete&lt;/code&gt; would also mess up your indexing.</source>
          <target state="translated">技術的には配列の &lt;code&gt;delete&lt;/code&gt; を使用できますが、これを使用すると、たとえば &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; を後で呼び出すときに誤った結果が得られます。 つまり、 &lt;code&gt;delete&lt;/code&gt; は要素を削除しますが、 &lt;code&gt;length&lt;/code&gt; プロパティの値を更新しません。 &lt;code&gt;delete&lt;/code&gt; を使用すると、インデックスがめちゃくちゃになります。</target>
        </trans-unit>
        <trans-unit id="4be2ecd11ba0e212cafbe9f3ed4567f70ea3cc57" translate="yes" xml:space="preserve">
          <source>Yeah, that's definitely not what you wanted.</source>
          <target state="translated">ああ、それは間違いなく君が望んでいたものではない。</target>
        </trans-unit>
        <trans-unit id="02c5f4541ba087fe996da9eb1271ebfb81156d83" translate="yes" xml:space="preserve">
          <source>You can also use other functions to achieve the same effect - omit, pick, ...</source>
          <target state="translated">また、同じ効果を得るために他の機能を使用することができます-省略、ピック、...</target>
        </trans-unit>
        <trans-unit id="95e9a3221d0ebd0cc77f374d7ddfa95d905aef6a" translate="yes" xml:space="preserve">
          <source>You can delete that specific key from your object keys like:</source>
          <target state="translated">のようにオブジェクトキーからその特定のキーを削除することができます。</target>
        </trans-unit>
        <trans-unit id="df5ae996f80ec18df6459baf979a058b543794dd" translate="yes" xml:space="preserve">
          <source>You can see it in action in the Babel try-out editor.</source>
          <target state="translated">バベルのトライアウトエディタで実際に見ることができます。</target>
        </trans-unit>
        <trans-unit id="ba4ef71e846efa414e359524a525c5bda890d6bb" translate="yes" xml:space="preserve">
          <source>You can simply delete any property of an object using the &lt;code&gt;delete&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; キーワードを使用して、オブジェクトの任意のプロパティを削除できます。</target>
        </trans-unit>
        <trans-unit id="6902cdb7c6341debc4ec1b8c5eaf6794e483c684" translate="yes" xml:space="preserve">
          <source>You can use ES6 destructuring with rest operator.</source>
          <target state="translated">rest演算子を使ってES6のデストラクチャリングを使うことができます。</target>
        </trans-unit>
        <trans-unit id="121a5978b1bee631af70ab1aaec00b53de7645b2" translate="yes" xml:space="preserve">
          <source>global scope) can be deleted with delete.</source>
          <target state="translated">グローバルスコープ)はdeleteで削除できます。</target>
        </trans-unit>
        <trans-unit id="5be9ceecc2f03bc42e4d234aec808162f9c2f9d1" translate="yes" xml:space="preserve">
          <source>the result would be:</source>
          <target state="translated">という結果になるのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">に相当する。</target>
        </trans-unit>
        <trans-unit id="b9a0331930f5ae83ac7b458124a7b5021f44ea5d" translate="yes" xml:space="preserve">
          <source>will behave equivalently for both methods.</source>
          <target state="translated">はどちらの方法でも同等の挙動を示します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
