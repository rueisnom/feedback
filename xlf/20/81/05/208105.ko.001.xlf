<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/208105">
    <body>
      <group id="208105">
        <trans-unit id="d0c785d16c2347fee547f3127b424f77909312a7" translate="yes" xml:space="preserve">
          <source>(Destructuring + Spread operator)</source>
          <target state="translated">(파괴 + 확산 연산자)</target>
        </trans-unit>
        <trans-unit id="63d63c34165213cae85c0283076b58a13c886dbf" translate="yes" xml:space="preserve">
          <source>(ES6)</source>
          <target state="translated">(ES6)</target>
        </trans-unit>
        <trans-unit id="7d50cf7543cd430338fe6fd7172b5d7ec7565f89" translate="yes" xml:space="preserve">
          <source>* &lt;em&gt;&lt;code&gt;foo&lt;/code&gt; will be a new variable with the value of &lt;code&gt;a&lt;/code&gt; (which is 1).&lt;/em&gt;</source>
          <target state="translated">* &lt;em&gt; &lt;code&gt;foo&lt;/code&gt; 는 값이 1 인 새 변수입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8aa44c32c47930ef0f4bc07bf1b584a5b6b0e2f" translate="yes" xml:space="preserve">
          <source>...It's stupid, I know.</source>
          <target state="translated">... 멍청하다.</target>
        </trans-unit>
        <trans-unit id="ff34d7bfb44f74504dbcecb1c791e02877f620e3" translate="yes" xml:space="preserve">
          <source>1.With explicit prop key:</source>
          <target state="translated">1. 명시 적 소품 키로 :</target>
        </trans-unit>
        <trans-unit id="145f4a070da96e31a48d8d444babf929a09a782a" translate="yes" xml:space="preserve">
          <source>2.With variable prop key:</source>
          <target state="translated">2. 가변 소품 키 :</target>
        </trans-unit>
        <trans-unit id="75c350f4599bd395c8e57950299bcd4efdaca57e" translate="yes" xml:space="preserve">
          <source>3.Cool arrow function 😎:</source>
          <target state="translated">3. 쿨 화살표 기능 😎 :</target>
        </trans-unit>
        <trans-unit id="b31d7d6cbd9fc3e49f4feaeef410e7cee592b5fa" translate="yes" xml:space="preserve">
          <source>4. For multiple properties</source>
          <target state="translated">4. 여러 속성</target>
        </trans-unit>
        <trans-unit id="cecf2bde461c486918fed98467ea58414d0dd173" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze()&lt;/a&gt; makes all properties of object not configurable (besides other things). &lt;code&gt;deleteProperty&lt;/code&gt; function (as well as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt;) returns &lt;code&gt;false&lt;/code&gt; when tries to delete any of it's properties. If property is configurable it returns &lt;code&gt;true&lt;/code&gt;, even if property does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze ()&lt;/a&gt; 는 객체의 모든 속성을 구성 할 수 없게 만듭니다 (다른 것 외에도). &lt;code&gt;deleteProperty&lt;/code&gt; 함수 (및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete 연산자&lt;/a&gt; )는 해당 속성을 삭제하려고하면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. property를 구성 할 수있는 경우 property가 존재하지 않더라도 &lt;code&gt;true&lt;/code&gt; 를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d2f5341f96365af83c99b7c7d47dba6c4b1a96cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;Spread Syntax&lt;/a&gt; (ES6)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;스프레드 구문&lt;/a&gt; (ES6)</target>
        </trans-unit>
        <trans-unit id="e4d9e924d09e0b750a05547c2f0bf5fa2c195878" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.slice()&lt;/code&gt; is non-destructive and returns a new array containing the indicated indices from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;. If &lt;code&gt;end&lt;/code&gt; is left unspecified, the behavior is the same as &lt;code&gt;.splice()&lt;/code&gt; (&lt;code&gt;end = array.length&lt;/code&gt;). The behavior is a bit tricky since, for some reason, &lt;code&gt;end&lt;/code&gt; indexes from 1 instead of 0. I don't know why it does this, but that's how it is. Also, if &lt;code&gt;end &amp;lt;= start&lt;/code&gt;, the result is an empty array.</source>
          <target state="translated">&lt;code&gt;.slice()&lt;/code&gt; 는 비파괴 적이며 &lt;code&gt;start&lt;/code&gt; 부터 &lt;code&gt;end&lt;/code&gt; 표시된 인덱스를 포함하는 새 배열을 반환합니다. &lt;code&gt;end&lt;/code&gt; 를 지정하지 않으면 동작은 &lt;code&gt;.splice()&lt;/code&gt; 와 같습니다 ( &lt;code&gt;end = array.length&lt;/code&gt; ). 어떤 이유로 든 0 대신 1부터 인덱스를 &lt;code&gt;end&lt;/code&gt; 때문에 동작이 약간 까다로워집니다. 왜 그렇게하는지 모르겠지만 그 방법입니다. 또한 &lt;code&gt;end &amp;lt;= start&lt;/code&gt; 인 경우 결과는 빈 배열입니다.</target>
        </trans-unit>
        <trans-unit id="da2a0c1e98a822064cc6b913222774a91ac62044" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.splice()&lt;/code&gt; mutates the array, and returns the removed indices. The array is sliced starting from the index, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; elements are sliced out. If n is unspecified, the entire array after &lt;code&gt;start&lt;/code&gt; is sliced out (&lt;code&gt;n = array.length - start&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;.splice()&lt;/code&gt; 는 배열을 변경하고 제거 된 인덱스를 반환합니다. 배열은 index, &lt;code&gt;start&lt;/code&gt; 에서 시작하여 슬라이스되고 &lt;code&gt;n&lt;/code&gt; 개의 요소가 슬라이스됩니다. n을 지정하지 않으면 &lt;code&gt;start&lt;/code&gt; 후 전체 배열이 분리됩니다 ( &lt;code&gt;n = array.length - start&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="578e0d997316ced94b2f7c292e4269507a0730b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Delete Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;연산자 삭제&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10a7b7e3a95023fb9f5d4f97bbeb1e856756bc60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;EXTENDED ANSWER&lt;/em&gt;&lt;/strong&gt; 😇</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;확장 된 답변&lt;/em&gt;&lt;/strong&gt; 😇</target>
        </trans-unit>
        <trans-unit id="3393b3743a22fd0193ab2fa39735ae2f646b06ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="710a4e957cc23ae95eb9aa6e13030731ab1c9d56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e590196d99e29b0fb26cc981e8c241732f76e4ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Spread Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;스프레드 연산자&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64d050dff57dceee4d758cc0912b8d402b405b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b02479449faf2e3a74dc8a9ef6000bfbe7ea1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In other words, a JavaScript object gets killed as soon as there is no reference left in your code pointed to that object.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;즉, 코드에 해당 객체를 가리키는 참조가 남아 있지 않으면 JavaScript 객체가 종료됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecc8000feff4d7f65f5786df06cc101796ac4edd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To clone object without property:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;속성없이 객체를 복제하려면 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ca5c58827bf40e3a97a098228081f1f64d66b7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018-07-21:&lt;/strong&gt; For a long time, I have felt embarrassed about this answer, so I think it's time that I touch it up a little bit. Just a little commentary, clarification, and formatting to help expedite the reading of the needlessly long and convoluted parts of this answer.</source>
          <target state="translated">&lt;strong&gt;2018-07-21 업데이트 :&lt;/strong&gt; 오랫동안이 답변에 대해 당황한 느낌이 들었습니다. 그래서 조금 만질 때입니다. 이 답변의 불필요하게 길고 복잡한 부분을 빨리 읽을 수 있도록 약간의 주석, 설명 및 형식을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c099f37767111dc60103bd8696ed4fcf3e7a64d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;
Thanks to @AgentME:</source>
          <target state="translated">&lt;strong&gt;업데이트 :&lt;/strong&gt; @AgentME 덕분에 :</target>
        </trans-unit>
        <trans-unit id="cd7c415e1d4039a5febeafd32c836a75f6b919e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;delete&lt;/code&gt;,&lt;/strong&gt; when you are passing the result object to the code on which you don't have control (or when you are not sure about your team or yourself).</source>
          <target state="translated">결과 객체를 제어 권한이없는 코드로 전달할 때 (또는 팀이나 자신에 대해 잘 모르는 경우) &lt;strong&gt; &lt;code&gt;delete&lt;/code&gt; 를 사용하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0af0c0606dbb967654f58c35fa2988459afb9a19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use setting to &lt;code&gt;undefined&lt;/code&gt;,&lt;/strong&gt; when you care about performance. It can give a serious boost to your code.</source>
          <target state="translated">성능에 관심이있을 때 &lt;strong&gt;설정을 &lt;code&gt;undefined&lt;/code&gt; 로 사용하십시오&lt;/strong&gt; . 코드를 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dfe20a67d61ae6b75beddf80cff0434cb3f7a9f" translate="yes" xml:space="preserve">
          <source>A live example to show:</source>
          <target state="translated">보여주는 실제 예 :</target>
        </trans-unit>
        <trans-unit id="aabd2b7839024463c3c18626551d6893b70879bd" translate="yes" xml:space="preserve">
          <source>About now, you're at your wit's end. This guy has been complaining non-stop about your app, and you want to tell him to shut up and go get a better computer.</source>
          <target state="translated">지금, 당신은 당신의 재치 끝에 있습니다. 이 사람은 당신의 앱에 대해 논란을 계속하고 있습니다. 그리고 당신은 그 사람에게 닥치고 더 나은 컴퓨터를 가지라고 말하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="692f82b2a7574a467099a421e634c28a19087f50" translate="yes" xml:space="preserve">
          <source>Alternatively, you could also do this:</source>
          <target state="translated">또는 다음을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dd6b6a5cb398077b2e61b33860df5233162a369" translate="yes" xml:space="preserve">
          <source>An object may be seen as a set of key-value pairs. What I call a 'value' is a primitive or a reference to other object, connected to that 'key'.</source>
          <target state="translated">객체는 일련의 키-값 쌍으로 볼 수 있습니다. 내가 '값'이라고 부르는 것은 해당 '키'에 연결된 기본 또는 다른 객체에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="97f362e729192c077ada3f5241fec0dea0e6f9ad" translate="yes" xml:space="preserve">
          <source>And just like that, you've pleased Mr. PDP-11. Hooray! &lt;sub&gt;(I'd still tell him off, though...)&lt;/sub&gt;</source>
          <target state="translated">PDP-11 씨도 기뻐했습니다. 만세! &lt;sub&gt;(하지만 여전히 그에게 말을 걸었습니다 ...)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="38fedc2f5a59cd30ac658c92ac34226c9870e485" translate="yes" xml:space="preserve">
          <source>And we need to delete 'a'.</source>
          <target state="translated">그리고 'a'를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="15728408349a51726fa4d7a495f586b8e25e36f1" translate="yes" xml:space="preserve">
          <source>Another alternative is to use the &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt; library.</source>
          <target state="translated">또 다른 대안은 &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt; 라이브러리를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="130c3bce337f7ed92461a0af093bf0dd8b4d970c" translate="yes" xml:space="preserve">
          <source>Another solution, using &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array#reduce&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array#reduce&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; 사용하는 다른 솔루션.</target>
        </trans-unit>
        <trans-unit id="75aa366398b31b18c07d678c84ff7223a1b76dbe" translate="yes" xml:space="preserve">
          <source>Any property declared with let or const cannot be deleted from the scope  within which they were defined. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().</source>
          <target state="translated">let 또는 const로 선언 된 속성은 정의 된 범위에서 삭제할 수 없습니다. 구성 할 수없는 속성은 제거 할 수 없습니다. 여기에는 Math, Array, Object와 같은 내장 객체의 속성과 Object.defineProperty ()와 같은 메서드로 구성 할 수없는 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b2ecb35283325b0622c879acc81ba757d7accad0" translate="yes" xml:space="preserve">
          <source>Any property declared with var cannot be deleted from the global scope
  or from a function's scope.</source>
          <target state="translated">var로 선언 된 속성은 전역 범위 나 함수 범위에서 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c333dd9449a548b822691fcab373abce8f8f850" translate="yes" xml:space="preserve">
          <source>Are you looking to achieve this in pure JavaScript or are you willing &amp;amp; able to use a 3rd-party library?</source>
          <target state="translated">순수한 JavaScript로 이것을 달성하려고합니까? 아니면 타사 라이브러리를 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1fea0155471c15e540c5b31c3594a45754e6cc6c" translate="yes" xml:space="preserve">
          <source>Array equivalent</source>
          <target state="translated">동등한 배열</target>
        </trans-unit>
        <trans-unit id="10f82eff0fb408011ffeabc374c6234764312dea" translate="yes" xml:space="preserve">
          <source>Array.prototype.slice(start, end)</source>
          <target state="translated">Array.prototype.slice (시작, 끝)</target>
        </trans-unit>
        <trans-unit id="dfe829210c0c25d8779de7fe65fb3158cefd4290" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice vs Array.prototype.slice</source>
          <target state="translated">Array.prototype.splice 대 Array.prototype.slice</target>
        </trans-unit>
        <trans-unit id="99ba4898ce91c3e3945c33ecd292283940427b38" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice(start, n)</source>
          <target state="translated">Array.prototype.splice (시작, n)</target>
        </trans-unit>
        <trans-unit id="bc85e8ead32cd6185d2f6ca2b34c7fbc94aadd58" translate="yes" xml:space="preserve">
          <source>As others have said, you can use &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">다른 사람들이 말했듯이 &lt;code&gt;delete&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc6de88f57fe2bcbd39aa2ddf8ca667c26f222a3" translate="yes" xml:space="preserve">
          <source>As seen in the above code snippet, there are some rare appropriate use cases for the &lt;code&gt;delete&lt;/code&gt; operator. However, do not worry about this problem too much. This will only become a problem with long-lifespan objects that get new keys constantly added to them. In any other case (which is almost every case in real-world programming), it is most appropriate to use &lt;code&gt;obj[prop] = undefined&lt;/code&gt;. The main purpose of this section is just to bring this to your attention so that in the rare chance that this does become a problem in your code, then you can more easily understand the problem and thus not have to waste hours dissecting your code to locate and understand this problem.</source>
          <target state="translated">위의 코드 스 니펫에서 볼 수 있듯이 &lt;code&gt;delete&lt;/code&gt; 연산자에 대한 적절한 사용 사례가 있습니다. 그러나이 문제에 대해 너무 걱정하지 마십시오. 이것은 새로운 키를 지속적으로 추가하는 수명이 긴 객체에만 문제가됩니다. 다른 경우 (실제 프로그래밍에서는 거의 모든 경우에 해당), &lt;code&gt;obj[prop] = undefined&lt;/code&gt; 를 사용하는 것이 가장 적합합니다. 이 섹션의 주요 목적은 코드에 문제가 될 가능성이 거의없는 경우가 많으므로 문제를보다 쉽게 ​​이해할 수 있으므로 코드를 찾는 데 시간을 낭비하지 않아도됩니다. 이 문제를 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="0a1a7281b5e3e0adcbcee6c0378231475ce1d077" translate="yes" xml:space="preserve">
          <source>As such, delete cannot delete any functions in the global scope (whether this is part from a function definition or a function  (expression).</source>
          <target state="translated">따라서 delete는 전역 범위에서 함수를 삭제할 수 없습니다 (이것이 함수 정의 또는 함수 (표현)의 일부인지 여부).</target>
        </trans-unit>
        <trans-unit id="19292906404cfee69ce728ffea847a3cb5d23580" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;delete&lt;/code&gt; doesn't always work as one might expect. The value is overwritten, but the memory is not reallocated. That is to say, &lt;code&gt;array[4]&lt;/code&gt; isn't relocated to &lt;code&gt;array[3]&lt;/code&gt;. Which is in contrast to &lt;code&gt;Array.prototype.unshift&lt;/code&gt;, which inserts an element at the beginning of the array and shifts everything up (&lt;code&gt;array[0]&lt;/code&gt; becomes &lt;code&gt;array[1]&lt;/code&gt;, etc.)</source>
          <target state="translated">보시다시피 &lt;code&gt;delete&lt;/code&gt; 가 항상 예상대로 작동하지는 않습니다. 값을 덮어 쓰지만 메모리가 재 할당되지 않습니다. 즉, &lt;code&gt;array[4]&lt;/code&gt; 는 &lt;code&gt;array[3]&lt;/code&gt; 로 재배치되지 않습니다. &lt;code&gt;Array.prototype.unshift&lt;/code&gt; 와 대조적으로 배열의 시작 부분에 요소를 삽입하고 모든 것을 위로 이동합니다 ( &lt;code&gt;array[0]&lt;/code&gt; 은 &lt;code&gt;array[1]&lt;/code&gt; 등이 됨)</target>
        </trans-unit>
        <trans-unit id="2c856c5e5c5be4265462b9644119ace1784d98d0" translate="yes" xml:space="preserve">
          <source>Beware Of Memory Leaks!</source>
          <target state="translated">메모리 누수를 조심하십시오!</target>
        </trans-unit>
        <trans-unit id="76829795257d4b98172b51f389192e4a9f633cf6" translate="yes" xml:space="preserve">
          <source>But if the property of the object is not configurable it cannot be deleted neither with deleteProperty function nor delete operator:</source>
          <target state="translated">그러나 객체의 속성을 구성 할 수 없으면 deleteProperty 함수 나 delete 연산자를 사용하여 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d2ae2c0c3d231052d20df4bc0d378c5068295e8" translate="yes" xml:space="preserve">
          <source>But the point is if you care about memory and you want to whole the object gets removed from the memory, it is recommended to set it to null before you delete the key:</source>
          <target state="translated">그러나 요점은 메모리에 관심이 있고 객체가 메모리에서 완전히 제거되도록하려면 키를 삭제하기 전에 null로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="083882684bcd539a61f754c832b4192934d833e3" translate="yes" xml:space="preserve">
          <source>But, how does a drug trip analogy relate to the &lt;code&gt;delete&lt;/code&gt; operation? The answer inheres the last line of code in the snippet above. Thus let it be reexamined, this time with a twist.</source>
          <target state="translated">그러나, 약물 트립 비유는 &lt;code&gt;delete&lt;/code&gt; 작업과 어떤 관련이 있습니까? 대답은 위의 코드 조각에서 마지막 코드 줄을 나타냅니다. 따라서 이번에는 비틀어 다시 검토하자.</target>
        </trans-unit>
        <trans-unit id="0eb16d4b50dbacc8475f57ed2dfb88409bd56da6" translate="yes" xml:space="preserve">
          <source>Consider creating a new object without the &lt;code&gt;&quot;regex&quot;&lt;/code&gt; property because the original object could always be referenced by other parts of your program. Thus you should avoid manipulating it.</source>
          <target state="translated">원래 객체는 항상 프로그램의 다른 부분에서 참조 할 수 있으므로 &lt;code&gt;&quot;regex&quot;&lt;/code&gt; 속성없이 새 객체를 만드는 것이 좋습니다. 따라서 조작하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1b8bae88ce3f716fc88f086ba5df71aa742b0ee5" translate="yes" xml:space="preserve">
          <source>Dan's assertion that 'delete' is very slow and the benchmark he posted were doubted. So I carried out the test myself in Chrome 59. It does seem that 'delete' is about 30 times slower:</source>
          <target state="translated">Dan의 '삭제'는 매우 느리며 자신이 게시 한 벤치 마크에 대해서는 의문의 여지가 있습니다. 그래서 Chrome 59에서 직접 테스트를 수행했습니다. '삭제'가 약 30 배 느리게 보입니다.</target>
        </trans-unit>
        <trans-unit id="d8b13a816456ec85d6f3ace2de0c50288edaa6ea" translate="yes" xml:space="preserve">
          <source>Delete is the only true way to remove object's properties without any leftovers, but it works &lt;strong&gt;~ 100 times slower&lt;/strong&gt;, 
compared to its &quot;alternative&quot;, setting &lt;code&gt;object[key] = undefined&lt;/code&gt;.</source>
          <target state="translated">삭제는 남은 부분없이 객체의 속성을 제거 할 수있는 유일한 방법이지만, &quot;alternative&quot;와 비교하여 &lt;strong&gt;~ 100 배 느리게&lt;/strong&gt; 작동합니다. setting &lt;code&gt;object[key] = undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45dc7ea9ea6f9f47fa401db4115a5eee26a4be14" translate="yes" xml:space="preserve">
          <source>Deleting an array index</source>
          <target state="translated">배열 인덱스 삭제</target>
        </trans-unit>
        <trans-unit id="42034d05fb5ec8b92965ea89f328c840dc4a3ac4" translate="yes" xml:space="preserve">
          <source>Deleting an object property</source>
          <target state="translated">객체 속성 삭제</target>
        </trans-unit>
        <trans-unit id="e52c854d5631eec7468ba4727b4c77eb745f2965" translate="yes" xml:space="preserve">
          <source>Demo</source>
          <target state="translated">Demo</target>
        </trans-unit>
        <trans-unit id="0298196b206bc7b4a96725653dbc77fafc2e7815" translate="yes" xml:space="preserve">
          <source>Do Not Always Set To &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">항상 &lt;code&gt;undefined&lt;/code&gt; 설정하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e813a63a91f53696f818ac595a5fddc09cb30338" translate="yes" xml:space="preserve">
          <source>Don't &lt;code&gt;delete&lt;/code&gt; from an array. Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead.</source>
          <target state="translated">배열에서 &lt;code&gt;delete&lt;/code&gt; 하지 마십시오. 대신 &lt;code&gt;Array.prototype.splice&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9cff8f35d333fc23fef816a20f879c35c001ee7e" translate="yes" xml:space="preserve">
          <source>Due to the dynamic nature of JavaScript there are often cases where you simply don't know if the property exists or not. Checking if obj exists before the &amp;amp;&amp;amp; also makes sure you don't throw an error due to calling the hasOwnProperty() function on an undefined object.</source>
          <target state="translated">JavaScript의 동적 특성으로 인해 속성의 존재 여부를 모르는 경우가 종종 있습니다. &amp;amp;&amp;amp; 앞에 obj가 있는지 확인하면 정의되지 않은 객체에서 hasOwnProperty () 함수를 호출하여 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f30ca853155d96f4ff4a7523ad41da4989438529" translate="yes" xml:space="preserve">
          <source>E.g</source>
          <target state="translated">E.g</target>
        </trans-unit>
        <trans-unit id="48886c6e98adf5c4a9c9282a2441dfe3015faacb" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (or ES6) came with built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt; object. It is possible to delete object property by calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty()&lt;/a&gt; function with target object and property key as parameters:</source>
          <target state="translated">ECMAScript 2015 (또는 ES6)는 내장 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt; 객체와 함께 제공됩니다. 대상 객체와 속성 키를 매개 변수로 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty ()&lt;/a&gt; 함수를 호출하여 객체 속성을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c2dbb36a3a214bec101207bfb72cd18b86e453e" translate="yes" xml:space="preserve">
          <source>Each one has it's own pros and cons (&lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;check this performance comparison&lt;/a&gt;):</source>
          <target state="translated">각각에는 자체 장단점 &lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;이&lt;/a&gt; 있습니다 ( 이 성능 비교를 확인하십시오 ).</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="5cb7b7c35055238b90a33971ff368cff01dd0bbb" translate="yes" xml:space="preserve">
          <source>For anyone interested in reading more about it, Stack Overflow user &lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt; has written an incredibly in-depth blog post about the &lt;code&gt;delete&lt;/code&gt; statement on their blog, &lt;em&gt;&lt;a href=&quot;http://perfectionkills.com/understanding-delete/&quot;&gt;Understanding delete&lt;/a&gt;&lt;/em&gt;. It is highly recommended.</source>
          <target state="translated">그것에 대해 더 자세히 &lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;알고 싶은 사람&lt;/a&gt; 은 Stack Overflow 사용자 kangax 가 블로그의 &lt;code&gt;delete&lt;/code&gt; 문에 대한 믿을 수 없을 정도로 심도 깊은 블로그 게시물을 작성했습니다. 적극 권장합니다.</target>
        </trans-unit>
        <trans-unit id="7de0c8678ad3582ef48a786c2a12849c95f613d2" translate="yes" xml:space="preserve">
          <source>For arrays, &lt;code&gt;_.filter()&lt;/code&gt; and &lt;code&gt;_.reject()&lt;/code&gt; can be used in a similar manner.</source>
          <target state="translated">배열의 경우 &lt;code&gt;_.filter()&lt;/code&gt; 및 &lt;code&gt;_.reject()&lt;/code&gt; 를 비슷한 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae20664549d9e3ccd77991be79f76a86f10d159f" translate="yes" xml:space="preserve">
          <source>For example, say you are creating a webapp that uses JSON-serialization to store an array used for 'tabs' in a string (in this case, &lt;code&gt;localStorage&lt;/code&gt;). Let's also say that the code uses the numerical indices of the array's members to &quot;title&quot; them when drawing to the screen. Why are you doing this rather than just storing the &quot;title&quot; as well? Because... &lt;em&gt;reasons&lt;/em&gt;.</source>
          <target state="translated">예를 들어 JSON 직렬화를 사용하여 '탭'에 사용되는 배열을 문자열 (이 경우 &lt;code&gt;localStorage&lt;/code&gt; )로 저장하는 웹 애플리케이션을 작성한다고 가정하십시오. 또한 코드에서 배열 멤버의 숫자 인덱스를 사용하여 화면에 그릴 때 &quot;제목&quot;을 지정한다고 가정하겠습니다. 왜 &quot;제목&quot;을 저장하지 않고 왜이 작업을 수행합니까? 왜냐면 ... &lt;em&gt;이유&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdad74d0486512dc3bc4f850907cd467e5fc5e3c" translate="yes" xml:space="preserve">
          <source>For more info about and seeing more example, visit the link below:</source>
          <target state="translated">더 많은 정보를보고 더 많은 예를 보려면 아래 링크를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="3053a4eaab6ecc9daa630f23887af0a663b64dcc" translate="yes" xml:space="preserve">
          <source>Functions which are part of an object (apart from the</source>
          <target state="translated">객체의 일부인 기능 (</target>
        </trans-unit>
        <trans-unit id="a355b0b1f78d396cf69cf859538e8172e1e8345c" translate="yes" xml:space="preserve">
          <source>Hello You Can try this simple an sort</source>
          <target state="translated">안녕하세요 당신은이 간단한 종류를 시도 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ca27c0a83d24961b91d263af64d922d82a55909c" translate="yes" xml:space="preserve">
          <source>Honestly, aside from setting to &lt;code&gt;null&lt;/code&gt; rather than &lt;code&gt;undefined&lt;/code&gt;--which is legitimately weird--this behavior &lt;em&gt;shouldn't&lt;/em&gt; be surprising, since &lt;code&gt;delete&lt;/code&gt; is a unary operator, like &lt;code&gt;typeof&lt;/code&gt;, that is hard-boiled into the language and is not supposed to care about the &lt;em&gt;type&lt;/em&gt; of object it's being used on, whereas &lt;code&gt;Array&lt;/code&gt; is a subclass of &lt;code&gt;Object&lt;/code&gt; with methods &lt;em&gt;specifically designed for&lt;/em&gt; working with arrays. So there's no good reason for &lt;code&gt;delete&lt;/code&gt; to have a special case cooked in for re-shifting the array, as that would just slow things down with unnecessary work. In retrospect, my expectations were unrealistic.</source>
          <target state="translated">솔직히 &lt;code&gt;undefined&lt;/code&gt; 것이 아닌 &lt;code&gt;null&lt;/code&gt; 로 설정하는 것 외에도 합법적으로 이상 &lt;em&gt;합니다.&lt;/em&gt; &lt;code&gt;delete&lt;/code&gt; 는 &lt;code&gt;typeof&lt;/code&gt; 와 같은 단항 연산자이므로 언어에 끓여서 신경 쓰지 않아야합니다. &lt;code&gt;Array&lt;/code&gt; 는 배열 작업을 &lt;em&gt;위해 특별히 설계된&lt;/em&gt; 메소드가있는 &lt;code&gt;Object&lt;/code&gt; 의 하위 클래스 인 반면 Array 는 사용중인 객체의 &lt;em&gt;유형&lt;/em&gt; 에 관한 것입니다. 따라서 &lt;code&gt;delete&lt;/code&gt; 로 인해 어레이를 다시 이동시키는 데 특별한 경우가 필요한 이유는 없습니다. 불필요한 작업으로 인해 속도가 느려질 수 있습니다. 돌이켜 보면 제 기대는 비현실적이었습니다.</target>
        </trans-unit>
        <trans-unit id="dc3989e98834042a9457a0de8b90b5c9f3024f13" translate="yes" xml:space="preserve">
          <source>How do I remove a property from a JavaScript object</source>
          <target state="translated">JavaScript 객체에서 속성을 제거하는 방법</target>
        </trans-unit>
        <trans-unit id="b47475af69db5ae110b477abd31ec35a3c7d497a" translate="yes" xml:space="preserve">
          <source>However, be mindful! Do not suddenly start doing this with all your preexisting code now as it would likely break such preexisting code and/or introduce strange bugs. Rather, such an efficient practice needs to be implemented from the start, and when converting preexisting code, it is recommended that you double, triple, quadruple check all the lines relating to that as trying to upgrade old code to this new practice can be as risky as it is rewarding.</source>
          <target state="translated">그러나주의하십시오! 기존 코드를 모두 깨뜨 리거나 이상한 버그를 유발할 수 있으므로 기존 코드를 모두 사용하여 갑자기이 작업을 시작하지 마십시오. 오히려 이러한 효율적인 연습은 처음부터 구현해야하며 기존 코드를 변환 할 때 이전 코드를이 새로운 연습으로 업그레이드하려고 할 때와 관련된 모든 행을 두 배, 세 배, 네 배로 확인하는 것이 좋습니다. 보람있는 것처럼 위험합니다.</target>
        </trans-unit>
        <trans-unit id="491f0bae14ec381e286ea282ba5b10bae8f240b9" translate="yes" xml:space="preserve">
          <source>However, it will &lt;strong&gt;mutate&lt;/strong&gt; the original object. If you want to create a new object &lt;strong&gt;without&lt;/strong&gt; the specified key, just assign the reduce function to a new variable, e.g.:</source>
          <target state="translated">그러나 원본 객체는 &lt;strong&gt;변경&lt;/strong&gt; 됩니다. 지정된 키 &lt;strong&gt;없이&lt;/strong&gt; 새 객체를 만들려면 다음과 같이 reduce 함수를 새 변수에 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="b18c3a88c501a6c91766f406a1e129e6aaa98cea" translate="yes" xml:space="preserve">
          <source>However, there are two major unfixable problems with polymorphic arrays:</source>
          <target state="translated">그러나 다형성 배열에는 두 가지 주요 수정 불가능한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3486394d0c7c983de3c5268328e537d9b15cb8f7" translate="yes" xml:space="preserve">
          <source>However, this code:</source>
          <target state="translated">그러나이 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a71f7845929b0f0df07acdfaf7d379b182e9259" translate="yes" xml:space="preserve">
          <source>I feel it's important to point out the difference between these two similarly-named functions, as they are both very useful.</source>
          <target state="translated">비슷한 이름을 가진이 두 함수의 차이점이 매우 유용하다는 점을 지적하는 것이 중요하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="459a68f17b246b077cb24b6614e54636e1f0783c" translate="yes" xml:space="preserve">
          <source>I personally use &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; or &lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt; for object and array manipulation:</source>
          <target state="translated">개인적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; 또는 &lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt; 를 사용하여 객체 및 배열 조작을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a8613a5b1880d971e632b3352e4bfe554f971c46" translate="yes" xml:space="preserve">
          <source>If a property with the same name exists on the object's prototype
  chain, then, after deletion, the object will use the property from the
  prototype chain (in other words, delete only has an effect on own
  properties).</source>
          <target state="translated">동일한 이름의 속성이 객체의 프로토 타입 체인에 존재하면 삭제 후 객체는 프로토 타입 체인의 속성을 사용합니다 (즉, 삭제는 자신의 속성에만 영향을 미칩니다).</target>
        </trans-unit>
        <trans-unit id="1e20c9e61654d816a6093dde8b64312b7bd4779b" translate="yes" xml:space="preserve">
          <source>If the property which you are trying to delete does not exist, delete
  will not have any effect and will return true</source>
          <target state="translated">삭제하려는 속성이 존재하지 않으면 삭제는 아무런 영향을 미치지 않으며 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28ec183a3184d93a675028a4e725a85c94f1f649" translate="yes" xml:space="preserve">
          <source>If you do not know the index, you'll also have to do an index search:</source>
          <target state="translated">색인을 모르는 경우 색인 검색도 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="3204a3a58282102b99263134aa04e4bbd9031c97" translate="yes" xml:space="preserve">
          <source>If you do:</source>
          <target state="translated">당신이 할 경우 :</target>
        </trans-unit>
        <trans-unit id="3204f4d5aa25757c4ed3063f2b869d5fde0626d5" translate="yes" xml:space="preserve">
          <source>If you know the index of your staff member, you could simply do this:</source>
          <target state="translated">직원의 색인을 알고 있다면 간단히 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b546f76f9301b299e7ed78305baf0ef1addfe1c" translate="yes" xml:space="preserve">
          <source>If you want to delete a property deeply nested in the object then you can use the following recursive function with path to the property as the second argument:</source>
          <target state="translated">객체에 깊게 중첩 된 속성을 삭제하려면 속성에 대한 경로와 함께 두 번째 인수로 다음과 같은 재귀 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="506bf20b873a7a4cd476c438c371ecd4bcca65fc" translate="yes" xml:space="preserve">
          <source>If you want to experiment with this, you can use &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt; as a starting point.</source>
          <target state="translated">이것을 실험하고 싶다면 &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;이 바이올린&lt;/strong&gt;&lt;/a&gt; 을 출발점으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e72696da1b895cd7644dbb4f08034ae76c1836" translate="yes" xml:space="preserve">
          <source>If you want to use the entire &lt;code&gt;staff&lt;/code&gt; array, the proper way to do this, would be to do this:</source>
          <target state="translated">전체 &lt;code&gt;staff&lt;/code&gt; 배열을 사용하려는 경우이를 수행하는 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43cf8d099321d601790e8b3431ad74fdf17809c0" translate="yes" xml:space="preserve">
          <source>Ignoring the dangers and problems inherent in &lt;code&gt;null&lt;/code&gt;, and the space wasted, this can be problematic if the array needs to be precise.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 에 내재 된 위험과 문제를 무시하고 공간을 낭비하면 배열이 정확해야하는 경우 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c138b726889b4f8045cc8db17ba22f8faa709ac8" translate="yes" xml:space="preserve">
          <source>In addition, while mutating objects in-place isn't stateless, you can use the functional nature of &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; to do partial application and other functional techniques that aren't possible with &lt;code&gt;delete&lt;/code&gt; statements.</source>
          <target state="translated">또한, 내부에서 객체를 변경하는 것은 상태 비 저장이 아니지만 &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; 의 기능적 특성을 사용하여 &lt;code&gt;delete&lt;/code&gt; 문으로는 불가능한 부분적 응용 프로그램 및 기타 기능 기술을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b114aff6680bfc75db078ff75477b94c1c576aa" translate="yes" xml:space="preserve">
          <source>In arrays, unlike plain old objects, using &lt;code&gt;delete&lt;/code&gt; leaves behind garbage in the form of &lt;code&gt;null&lt;/code&gt;, creating a &quot;hole&quot; in the array.</source>
          <target state="translated">일반 오래된 객체와 달리 배열에서는 가비지 뒤에 &lt;code&gt;delete&lt;/code&gt; leaves을 &lt;code&gt;null&lt;/code&gt; 형식으로 사용하여 배열에 &quot;구멍&quot;을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="acf20d554a4832d04b9fb4c2dfc6cc9d34eda721" translate="yes" xml:space="preserve">
          <source>In the code above, simply doing &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; will cause a massive memory leak because each animation frame. Each frame, all 65536 DOM elements will take up another 65536 individual slots, but the previous 65536 slots will only be set to undefined which leaves them hanging in the memory. Go ahead, try to run the above code in the console and see for yourself. After forcing an out-of-memory error, attempt to run it again except with the following version of the code that uses the &lt;code&gt;delete&lt;/code&gt; operator instead.</source>
          <target state="translated">위 코드에서 간단히 &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; 각 애니메이션 프레임으로 인해 엄청난 메모리 누수가 발생합니다. 각 프레임, 모든 65536 DOM 요소는 다른 65536 개별 슬롯을 차지하지만 이전 65536 슬롯은 정의되지 않은 상태로 설정되어 메모리에 걸려 있습니다. 콘솔에서 위의 코드를 실행하고 직접 확인하십시오. 메모리 부족 오류가 발생하면 &lt;code&gt;delete&lt;/code&gt; 연산자를 대신 사용하는 다음 버전의 코드를 제외하고 다시 실행 해보십시오.</target>
        </trans-unit>
        <trans-unit id="271f117734d63131f8d6a45f399a766357be7419" translate="yes" xml:space="preserve">
          <source>Increasingly stupid edge-case scenario aside, using &lt;code&gt;delete&lt;/code&gt; on said array will result in &lt;code&gt;null&lt;/code&gt; polluting the array, and probably causing bugs in the app later on. And if you check for &lt;code&gt;null&lt;/code&gt;, it would straight up skip the numbers resulting in the tabs being rendered like &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt;.</source>
          <target state="translated">어리석은 대소 문자 시나리오를 제외하고, 상기 배열에서 &lt;code&gt;delete&lt;/code&gt; 를 사용하면 배열을 &lt;code&gt;null&lt;/code&gt; 로 오염시키고 나중에 앱에 버그가 발생할 수 있습니다. 그리고 &lt;code&gt;null&lt;/code&gt; 을 확인하면 &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt; 와 같이 탭이 렌더링되는 숫자를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="67a2e0451ade99e58384dc55f1327e29e5977c70" translate="yes" xml:space="preserve">
          <source>It &lt;strong&gt;deletes the key from the hashmap&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;해시 맵에서 키를 삭제합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="593fba807066e533a5fe4a2443019f46d7ca31da" translate="yes" xml:space="preserve">
          <source>JavaScript is an OOP Language, so everything is an object, including &lt;em&gt;arrays&lt;/em&gt;. Thus, I feel it necessary to point out a particular caveat.</source>
          <target state="translated">JavaScript는 OOP 언어이므로 &lt;em&gt;arrays를&lt;/em&gt; 포함한 모든 것이 객체입니다. 따라서 특정 경고 사항을 지적해야한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="b86b332c3f3aa1433f370f7189813a6381eb2178" translate="yes" xml:space="preserve">
          <source>Library-based property omission</source>
          <target state="translated">도서관 기반 부동산 누락</target>
        </trans-unit>
        <trans-unit id="59b86486aed4edafd59a372a9da15c32460385f0" translate="yes" xml:space="preserve">
          <source>Like this:</source>
          <target state="translated">이처럼 :</target>
        </trans-unit>
        <trans-unit id="23ee237b458378f4f66052abb7c903c28cbb18e4" translate="yes" xml:space="preserve">
          <source>Look at the &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;benchmark&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;벤치 마크를보십시오&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d0447456284f7feabbe03be15bd344b6f319890b" translate="yes" xml:space="preserve">
          <source>Luckily, arrays &lt;em&gt;do&lt;/em&gt; have a specialized method for deleting indices and reallocating memory: &lt;code&gt;Array.prototype.splice()&lt;/code&gt;. You could write something like this:</source>
          <target state="translated">운 좋게도, 배열에는 인덱스를 삭제하고 메모리를 재 할당하는 특수한 메소드 인 &lt;code&gt;Array.prototype.splice()&lt;/code&gt; 있습니다. 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098d9f24825c866c84675902efcb46bcadb54327" translate="yes" xml:space="preserve">
          <source>More than 2X faster than &lt;code&gt;delete&lt;/code&gt;, however the property is &lt;strong&gt;not&lt;/strong&gt; deleted and can be iterated.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 보다 2 배 이상 빠르지 만 속성은 삭제 &lt;strong&gt;되지 않고&lt;/strong&gt; 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc762c5d3373bf8a3cde8b635c9825605d01c63" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, safe</source>
          <target state="translated">안전한 돌연변이 객체 속성 삭제</target>
        </trans-unit>
        <trans-unit id="9ce68ac5a3111b339ada2a12dd8cc6eea0e45ffa" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, unsafe</source>
          <target state="translated">안전하지 않은 돌연변이 객체 속성 삭제</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="089de7283699cfb1ed6d519cb14e7b0cf6326b5b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;_.pick()&lt;/code&gt; and &lt;code&gt;_.omit()&lt;/code&gt; both return a copy of the object and don't directly modify the original object. Assigning the result to the original object should do the trick (not shown).</source>
          <target state="translated">&lt;code&gt;_.pick()&lt;/code&gt; 및 &lt;code&gt;_.omit()&lt;/code&gt; 모두 객체의 복사본을 반환하며 원래 객체를 직접 수정하지는 않습니다. 원래 객체에 결과를 할당하면 트릭을 수행해야합니다 (표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="74d18dd16f1da3ac16685fb7e2b20e82dd3d4708" translate="yes" xml:space="preserve">
          <source>Note that I purposedly carried out more than one 'delete' operations in one loop cycle to minimize the effect caused by the other operations.</source>
          <target state="translated">다른 작업으로 인한 영향을 최소화하기 위해 한 루프주기에서 여러 개의 '삭제'작업을 의도적으로 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="cbc78d0538f8d0b1ea57d6e615c0173c54cc2f85" translate="yes" xml:space="preserve">
          <source>Note that the wrapper function is designed to be very strict about types, and will return &lt;code&gt;null&lt;/code&gt; if anything is off. That includes putting in a string like &lt;code&gt;&quot;3&quot;&lt;/code&gt;. It is left up to the programmer to be diligent about his types. This is to encourage good programming practice.</source>
          <target state="translated">랩퍼 함수는 유형에 대해 매우 엄격하게 설계되었으며, 꺼져있는 경우 &lt;code&gt;null&lt;/code&gt; 을 리턴합니다. 여기에는 &lt;code&gt;&quot;3&quot;&lt;/code&gt; 과 같은 문자열을 넣는 것이 포함됩니다. 그의 타입에 대해 부지런히하는 것은 프로그래머에게 달려 있습니다. 이것은 좋은 프로그래밍 연습을 장려하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0cd1e1c286ff1b960d2aa87f0e85fe9bd6a35fdd" translate="yes" xml:space="preserve">
          <source>Now, if you want to remove a single staff member or student, the procedure is a bit different, because both properties are arrays themselves.</source>
          <target state="translated">이제 단일 직원이나 학생을 제거하려는 경우 두 속성이 모두 배열이므로 절차가 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e14273e8bb73415bec8db17e1b9d548211a7aed0" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;could&lt;/em&gt; keep a second iterator, like &lt;code&gt;j&lt;/code&gt;, to increment only when valid values are read from the array. But that wouldn't exactly solve the &lt;code&gt;null&lt;/code&gt; issue, and you still have to please that &lt;s&gt;troll&lt;/s&gt; PDP-11 user. Alas, his computer just &lt;em&gt;doesn't&lt;/em&gt; have enough memory to hold that last integer &lt;sub&gt;(don't ask how he manages to handle a variable-width array...)&lt;/sub&gt;.</source>
          <target state="translated">이제 배열에서 유효한 값을 읽을 때만 증가하도록 &lt;code&gt;j&lt;/code&gt; 와 같은 두 번째 반복자를 유지할 &lt;em&gt;수&lt;/em&gt; 있습니다. 그러나 이것이 &lt;code&gt;null&lt;/code&gt; 문제를 정확하게 해결하지는 &lt;s&gt;못하지만&lt;/s&gt; 여전히 &lt;s&gt;트롤&lt;/s&gt; PDP-11 사용자를 기쁘게해야합니다. 아아, 그의 컴퓨터에는 마지막 정수를 담을 수있는 메모리가 충분 &lt;em&gt;하지 않습니다&lt;/em&gt; &lt;sub&gt;(변수 너비 배열을 처리하는 방법을 묻지 마십시오 ...)&lt;/sub&gt; .</target>
        </trans-unit>
        <trans-unit id="e28b55f542be9cce84f1cc3f1bdb29e2a2eb72e0" translate="yes" xml:space="preserve">
          <source>Object.assign() &amp;amp; Object.keys() &amp;amp; Array.map()</source>
          <target state="translated">Object.assign () 및 Object.keys () 및 Array.map ()</target>
        </trans-unit>
        <trans-unit id="c643fe374f1dfb8aa281ee046c5ea254b1b7b942" translate="yes" xml:space="preserve">
          <source>Observe. &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; does not coerce polymorphism whereas &lt;code&gt;bar[1] = undefined&lt;/code&gt; does. Therefore, one should always, whenever possible use the corresponding type for their objects so as to not accidentally cause polymorphism. One such person may use the following list as a general reference to get them going. However, please do not explicitly use the below ideas. Instead, use whatever works well for your code.</source>
          <target state="translated">관찰하십시오. &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; 는 다형성을 강제하지 않지만 &lt;code&gt;bar[1] = undefined&lt;/code&gt; 는 그렇지 않습니다. 따라서 우연히 다형성을 일으키지 않도록 가능한 한 항상 객체에 해당 유형을 사용해야합니다. 그러한 사람 중 한 명이 다음 목록을 일반적인 참조로 사용하여 진행할 수 있습니다. 그러나 아래 아이디어를 명시 적으로 사용하지 마십시오. 대신 코드에 잘 맞는 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e583eed26b5bb4eb2fe3ea98e3d4481f60fbfae9" translate="yes" xml:space="preserve">
          <source>Of course, it &lt;em&gt;did&lt;/em&gt; surprise me. Because I wrote this to justify my crusade against &quot;null garbage&quot;:</source>
          <target state="translated">물론 놀랐습니다. 나는 &quot;널 쓰레기&quot;에 대한 내 성전을 정당화하기 위해 이것을 썼기 때문에 :</target>
        </trans-unit>
        <trans-unit id="9d008b07517f4d9dbae6df29270e3dfc66dcea5d" translate="yes" xml:space="preserve">
          <source>Okay, let's just say that you're trying to save memory at the request of this &lt;em&gt;one&lt;/em&gt; user who runs a PDP-11 minicomputer from the 1960's running UNIX and wrote his own Elinks-based, JavaScript-compliant, line-printer-friendly browser because X11 is &lt;em&gt;out of the question&lt;/em&gt;.</source>
          <target state="translated">자, 1960 년대 UNIX를 실행하는 PDP-11 미니 컴퓨터를 실행하고 자체 Elinks 기반의 JavaScript 호환 라인 프린터 친화적 브라우저를 작성한이 사용자의 요청에 따라 메모리를 절약하려고한다고 가정 해 봅시다. X11이 &lt;em&gt;문제&lt;/em&gt; 가 아니기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0746b7ec72e10adab007597141d3dddd2450c60e" translate="yes" xml:space="preserve">
          <source>Old question, modern answer. Using object destructuring, an &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript&amp;nbsp;6&lt;/a&gt; feature, it's as simple as:</source>
          <target state="translated">오래된 질문, 현대적인 답변. &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6&lt;/a&gt; 기능인 객체 디스트 럭처링을 사용하면 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="88891f47a253aa57bb1cb91937b9715b281db53b" translate="yes" xml:space="preserve">
          <source>Once polymorphic, always polymorphic. When an array is made polymorphic, the polymorphism cannot be undone in Webkit browsers. So, even if you restore a polymorphic array to being non-polymorphic, it will still be stored by the browser as a polymorphic array.</source>
          <target state="translated">다형성이되면 항상 다형성이됩니다. 배열을 다형성으로 만들면 웹킷 브라우저에서 다형성을 취소 할 수 없습니다. 따라서 다형성 배열을 다형성이 아닌 것으로 복원하더라도 브라우저에서는 여전히 다형성 배열로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b248f1b8652c2d4ab474434fceed81458cb94383" translate="yes" xml:space="preserve">
          <source>Once those four queries have been answered, there are essentially four categories of &quot;property removal&quot; in JavaScript to chose from in order to meet your goals. They are:</source>
          <target state="translated">이 네 가지 질문에 대한 답변이 나오면, 목표를 달성하기 위해 JavaScript에서 선택할 수있는 네 가지 범주의 &quot;속성 제거&quot;가 있습니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="547c95266578e4dba22f41101c7fbe880f75e156" translate="yes" xml:space="preserve">
          <source>One aspect of Javascript that is important to consider is polymorphism. Polymorphism is when assigning the same variable/slot-in-an-object different types as seen below.</source>
          <target state="translated">고려해야 할 Javascript의 한 가지 측면은 다형성입니다. 다형성은 아래와 같이 동일한 변수 / 슬롯-인-오브젝트 다른 유형을 지정할 때입니다.</target>
        </trans-unit>
        <trans-unit id="d59804a9108998189135354633d8b85aa6ac9872" translate="yes" xml:space="preserve">
          <source>One may liken polymorphism to a drug addiction. At first glance, it seems awesomely lucrative: nice pretty fluffy code. Then, the coder introduces their array to the drug of polymorphism. Instantly, the polymorphic array becomes less efficient, and it can never become as efficient as it was before since it is drugged. To correlate such circumstance to real life, someone on cocaine might not even be capable of operating a simple door handle, much less be able to calculate digits of PI. Likewise, an array on the drug of polymorphism cannot ever be as efficient as a monomorphic array.</source>
          <target state="translated">다형성을 약물 중독에 비유 할 수있다. 언뜻보기에는 멋진 수익성이있는 것처럼 보입니다. 그런 다음 코더는 다형성 약물에 배열을 도입합니다. 즉시, 다형성 어레이는 덜 효율적이되고, 약물 투여 된 이후로 예전만큼 효율적이 될 수 없다. 이러한 상황을 실제 생활과 연관시키기 위해 코카인을 사용하는 사람은 간단한 문 손잡이를 조작 할 수없고 PI의 자릿수를 계산할 수있는 능력이 훨씬 떨어질 수 있습니다. 마찬가지로, 다형성 약물의 어레이는 단일 어레이만큼 효율적일 수 없다.</target>
        </trans-unit>
        <trans-unit id="81ec1a879d1bcac8eaeb3bcd6cca8f51d459b6e9" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;delete&lt;/code&gt; is unexpectedly slow!</source>
          <target state="translated">운영자 &lt;code&gt;delete&lt;/code&gt; 가 예기치 않게 느립니다!</target>
        </trans-unit>
        <trans-unit id="b0213d049275e53829195e4fb176386bc570f98e" translate="yes" xml:space="preserve">
          <source>Or add it as a new pointer to another object like:</source>
          <target state="translated">또는 다음과 같은 다른 객체에 대한 새 포인터로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b02fc9813af3fdbb140c9b950f4bb96861bf726a" translate="yes" xml:space="preserve">
          <source>Or with the questions sample:</source>
          <target state="translated">또는 질문 샘플의 경우 :</target>
        </trans-unit>
        <trans-unit id="e9b0d0e32654faf6fc06ca2ce8663172c501d507" translate="yes" xml:space="preserve">
          <source>Or you can also use array-like notation:</source>
          <target state="translated">또는 배열과 같은 표기법을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="040435ad5191a6323d4b61a949b35014d90fb332" translate="yes" xml:space="preserve">
          <source>Or you can dynamically exclude properties like this,</source>
          <target state="translated">또는 이와 같은 속성을 동적으로 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7ca816fcb165b225c5a6969cca6cd3afa101c70" translate="yes" xml:space="preserve">
          <source>Properties can be removed using &lt;strong&gt;destructuring&lt;/strong&gt; in combination with the &lt;strong&gt;rest operator&lt;/strong&gt;. In your example regex is destructured out (ignored) and the rest of the properties are returned as rest.</source>
          <target state="translated">&lt;strong&gt;나머지 연산자&lt;/strong&gt; 와 함께 구조를 제거하여 속성을 제거 할 수 있습니다. 귀하의 예에서 정규 표현식은 구조화되지 않고 (무시) ​​나머지 속성은 나머지로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="257bb222f1c06e8c1d8edf559d64e06deb75f2f0" translate="yes" xml:space="preserve">
          <source>Property Removal in JavaScript</source>
          <target state="translated">JavaScript에서 속성 제거</target>
        </trans-unit>
        <trans-unit id="83a4727bcff27e1d95598a97b2a871336f59a8c8" translate="yes" xml:space="preserve">
          <source>Readable and short, however, it might not be the best choice if you are operating on a large number of objects as its performance is not optimized.</source>
          <target state="translated">그러나 읽기 쉽고 짧지 만 성능이 최적화되지 않았기 때문에 많은 수의 객체에서 작업하는 경우 최선의 선택이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce7827682ca4a098e50c7905bb13aa7c7e60006c" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt;.</source>
          <target state="translated">참조 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f02218cedd8e4fd7e585302dc05d8d0a5833d5f0" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.omit(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.omit (object, * keys)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a3c1aeff97f5a6d2ba0a975a623e96c949b36be" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.pick(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.pick (object, * keys)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5817e749619edf322d60f85b86cab9c7f83094af" translate="yes" xml:space="preserve">
          <source>Rest-based string property omission</source>
          <target state="translated">나머지 기반 문자열 속성 생략</target>
        </trans-unit>
        <trans-unit id="ab303515578a450fdf614933afe415b6528c01d1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to omit the 
blacklisted keys (or array of keys).</source>
          <target state="translated">차단 된 키 (또는 키 배열)를 생략하도록 필터링 된 객체의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="011a1cad4539d30348ba24adcd37dceade1f93c1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to only have values for the 
whitelisted keys (or array of valid keys).</source>
          <target state="translated">허용 된 키 (또는 유효한 키 배열)의 값만 갖도록 필터링 된 객체의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="650045349baef87a1fa74815eb1e6653f73e4e45" translate="yes" xml:space="preserve">
          <source>Say I create an object as follows:</source>
          <target state="translated">다음과 같이 객체를 생성한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="f5d2829fcf8f71f8331358342fe9021d00422606" translate="yes" xml:space="preserve">
          <source>Setting a property to null before deleting it doesn't accomplish
  anything (unless the object has been sealed by Object.seal and the
  delete fails. That's not usually the case unless you specifically
  try).</source>
          <target state="translated">속성을 삭제하기 전에 null로 설정하면 아무것도 달성되지 않습니다 (객체가 Object.seal에 의해 봉인되어 있고 삭제가 실패하지 않는 한, 특별히 시도하지 않는 한 일반적으로 그렇지 않습니다).</target>
        </trans-unit>
        <trans-unit id="a1aeff6040cbaf4a052232c94541c2b536b4a1f3" translate="yes" xml:space="preserve">
          <source>Similarly, removing the entire students array would be done by calling &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; or &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 전체 학생 배열을 제거하는 것은 &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; 또는 &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd410e78d809f27ec1e3bdad4ee5576324a4212e" translate="yes" xml:space="preserve">
          <source>So as it turns out, there actually IS a built-in way to tell if an array is truly an array, and that is &lt;code&gt;Array.isArray()&lt;/code&gt;, introduced in ECMAScript 5 (December 2009). I found this while looking to see if there was a question asking about telling arrays from objects, to see if there was either a better solution than mine, or to add mine if there were none. So, if you're using a version of JavaScript that is earlier than ECMA 5, there's your polyfill. However, I strongly recommend against using my &lt;code&gt;is_array()&lt;/code&gt; function, as continuing to support old versions of JavaScript means continuing to support the old browsers that implement them, which means encouraging the use of insecure software and putting users at risk for malware. So please, use &lt;code&gt;Array.isArray()&lt;/code&gt;. Use &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Use the new features that get added to the language. &lt;em&gt;Don't&lt;/em&gt; use vendor prefixes. &lt;em&gt;Delete&lt;/em&gt; that IE polyfill crap from your website. Delete that XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; crap, too--we moved to HTML5 back in 2014. The sooner everybody withdraws support for those old/esoteric browsers, the sooner the browser vendors will actually follow the web standard and embrace the new technology, and the sooner we can move on to a more secure web.</source>
          <target state="translated">&lt;code&gt;Array.isArray()&lt;/code&gt; 으로 배열이 실제로 배열인지 ECMAScript 5 (2009 년 12 월 ) 에 도입 된 Array.isArray () 인지 알 수있는 기본 제공 방법이 있습니다. 객체에서 배열을 알려주는 것에 대한 질문이 있는지, 내 것보다 더 나은 솔루션이 있는지 확인하거나없는 경우 광산을 추가하는 것에 대해 질문하는 동안 이것을 발견했습니다. 따라서 ECMA 5 이전의 JavaScript 버전을 사용하는 경우 폴리 필이 있습니다. 그러나 이전 버전의 JavaScript를 계속 지원한다는 것은 JavaScript를 구현하는 이전 브라우저를 계속 지원한다는 것을 의미하므로 안전하지 않은 소프트웨어의 사용을 장려하고 사용자에게 맬웨어 위험을 초래할 수 있으므로 &lt;code&gt;is_array()&lt;/code&gt; 함수를 사용하지 않는 것이 좋습니다. 따라서 &lt;code&gt;Array.isArray()&lt;/code&gt; 사용하십시오. &lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 를 사용하십시오. 언어에 추가 된 새로운 기능을 사용하십시오. 공급 업체 접두사를 사용 &lt;em&gt;하지 마십시오&lt;/em&gt; . 웹 사이트에서 해당 IE 폴리 필 크랩을 &lt;em&gt;삭제&lt;/em&gt; 하십시오. XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; crap도 마찬가지입니다 .-- 2014 년에 HTML5로 이전했습니다. 모두가 이전 / 비밀 브라우저에 대한 지원을 철회할수록 브라우저 공급 업체는 실제로 웹 표준을 더 빨리 따르고 보다 안전한 웹으로 이전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1074a68b7264ece395e8476f70ae784fc36b406" translate="yes" xml:space="preserve">
          <source>So, he sends you an email in anger:</source>
          <target state="translated">그래서 그는 분노한 이메일을 당신에게 보냅니다 :</target>
        </trans-unit>
        <trans-unit id="1c63c8fdc7a32a45814f6f70f31838cecabdb16b" translate="yes" xml:space="preserve">
          <source>So, when deleting values from an object, always first consider whether you're dealing with object properties or whether you're dealing with array values, and choose the appropriate strategy based on that.</source>
          <target state="translated">따라서 객체에서 값을 삭제할 때는 항상 객체 속성을 처리하는지 또는 배열 값을 처리하는지 여부를 고려하고이를 기반으로 적절한 전략을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="da5db28dd16264310f46eacb87a0cb2b9ceef675" translate="yes" xml:space="preserve">
          <source>Sorry if this didn't add to your specific use case but I believe this to be a good design to adapt when managing objects and their properties.</source>
          <target state="translated">이것이 특정 사용 사례에 추가되지 않은 경우 죄송하지만 객체 및 해당 속성을 관리 할 때이 디자인이 적합하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ace92799b8ad9dc2af653b95d2a4f16910423d4b" translate="yes" xml:space="preserve">
          <source>Suppose you have an object that looks like this:</source>
          <target state="translated">다음과 같은 객체가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="c5229642bf5961f2b277471727e88e647035ac9e" translate="yes" xml:space="preserve">
          <source>Syntax-based string property omission</source>
          <target state="translated">구문 기반 문자열 속성 생략</target>
        </trans-unit>
        <trans-unit id="07c468c127104c88b077c6e07b9d9ec7d4fdbf7d" translate="yes" xml:space="preserve">
          <source>THE LONG VERSION</source>
          <target state="translated">긴 버전</target>
        </trans-unit>
        <trans-unit id="11405ca028271229b8731c4ce6c20d04dc54cc92" translate="yes" xml:space="preserve">
          <source>THE SHORT VERSION</source>
          <target state="translated">짧은 버전</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="748beb2ad7204d2997b5d2a12f2e0bc89bcc8e5e" translate="yes" xml:space="preserve">
          <source>That actually isn't what's happening, but it's easier to think of that way. According to MDN, here's what's actually happening:</source>
          <target state="translated">실제로는 일어나지 않지만 그렇게 생각하는 것이 더 쉽습니다. MDN에 따르면 실제로 다음과 같은 상황이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf85fec62dde51f1637af10a625442c3baea4c48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt; is the best way to do so.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;삭제 연산자&lt;/a&gt; 가 가장 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="881ea24ac20b3a2b7bbbd8208c871ee412db982f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;key remains on its place in the hashmap&lt;/strong&gt;, only the value is replaced with &lt;code&gt;undefined&lt;/code&gt;. Understand, that &lt;code&gt;for..in&lt;/code&gt; loop will still iterate over that key.</source>
          <target state="translated">&lt;strong&gt;키는 해시 맵에서 그대로 유지되며&lt;/strong&gt; 값만 &lt;code&gt;undefined&lt;/code&gt; 로 바뀝니다. &lt;code&gt;for..in&lt;/code&gt; 루프는 여전히 해당 키를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="edc38116420d64a21ebfee30ed9c7476267110df" translate="yes" xml:space="preserve">
          <source>The Solution: &lt;code&gt;Array.prototype.splice&lt;/code&gt;</source>
          <target state="translated">해결책 : &lt;code&gt;Array.prototype.splice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="071cbdf7a24a78eb243d7c493b80aadba4657908" translate="yes" xml:space="preserve">
          <source>The actual answer to the question</source>
          <target state="translated">질문에 대한 실제 답변</target>
        </trans-unit>
        <trans-unit id="c0ec14910cf4674ceea7f9ad991e964445d6c9ac" translate="yes" xml:space="preserve">
          <source>The answer would be to &lt;strong&gt;delete all the references you have in your code, pointed to that very object&lt;/strong&gt; and also &lt;strong&gt;not use &lt;code&gt;var&lt;/code&gt; statements to create new references to that object&lt;/strong&gt;. This last point regarding &lt;code&gt;var&lt;/code&gt; statements, is one of the most crucial issues that we are usually faced with, because using &lt;code&gt;var&lt;/code&gt; statements would prevent the created object from getting removed.</source>
          <target state="translated">대답은 &lt;strong&gt;코드에서 가지고있는 모든 참조&lt;/strong&gt; 를 &lt;strong&gt;삭제하고 해당 객체를 가리키고&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;var&lt;/code&gt; 문을 사용하여 해당 객체에 대한 새로운 참조를 작성하지 않는 것&lt;/strong&gt; 입니다. &lt;code&gt;var&lt;/code&gt; 문에 관한 마지막 요점은 var 문을 사용하면 생성 된 객체가 제거되지 않기 때문에 일반적으로 직면하는 가장 중요한 문제 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="c25007fa1063a6b669074a068e8e0d9c200dbaad" translate="yes" xml:space="preserve">
          <source>The contrived and long-winded PDP-11 scenario</source>
          <target state="translated">숙고되고 오래 지속 된 PDP-11 시나리오</target>
        </trans-unit>
        <trans-unit id="f621835acbbff87822c037f614ae8feebd84f7e5" translate="yes" xml:space="preserve">
          <source>The delete operator removes a given property from an object. On
  successful deletion, it will return true, else false will be returned.
  However, it is important to consider the following scenarios:</source>
          <target state="translated">delete 연산자는 객체에서 지정된 속성을 제거합니다. 성공적으로 삭제되면 true를 반환하고 그렇지 않으면 false를 반환합니다. 그러나 다음 시나리오를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="88d438bbfeb05c4266f6e27b90dcb851c6f60ce6" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;deleteProperty&lt;/code&gt; is when using strict mode:</source>
          <target state="translated">엄격 모드를 사용할 때 &lt;code&gt;delete&lt;/code&gt; 와 &lt;code&gt;deleteProperty&lt;/code&gt; 의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="efccd6cd704a79d07bccddefc3adbae94e968c39" translate="yes" xml:space="preserve">
          <source>The following snippet gives another simple example:</source>
          <target state="translated">다음 스 니펫은 또 다른 간단한 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf8a2a946389853c6d0799bf61400c9d604dd48d" translate="yes" xml:space="preserve">
          <source>The index specified by &lt;code&gt;end&lt;/code&gt; is simply excluded from the slice. The parenthesized indices indicate what gets sliced. Either way, the behavior is not intuitive and it's bound to cause its fair share of off-by-one errors, so you might find it useful to make a wrapper function to more closely emulate the behavior of &lt;code&gt;.splice()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; 에 의해 지정된 인덱스는 단순히 슬라이스에서 제외됩니다. 괄호 안의 인덱스는 얇게 썬 것을 나타냅니다. 어느 쪽이든, 동작은 직관적이지 않으며 일대일 오류를 공평하게 분배해야하므로 래퍼 함수를 ​​사용하여 &lt;code&gt;.splice()&lt;/code&gt; 의 동작을 더 가깝게 에뮬레이트하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="367c08658a0eaac4d7f551272d9531077bdd6a38" translate="yes" xml:space="preserve">
          <source>The other important point here is to be careful about your other references to the same object. For instance, if you create a variable like:</source>
          <target state="translated">여기서 또 다른 중요한 점은 동일한 객체에 대한 다른 참조에주의해야합니다. 예를 들어 다음과 같은 변수를 만드는 경우</target>
        </trans-unit>
        <trans-unit id="556ff37bb94e5cbb3dd116d5ddf709d4c4f7ed56" translate="yes" xml:space="preserve">
          <source>The programming ethos/patterns you and your team use. Do you favor functional approaches and mutation is verboten on your team, or do you employ wild west mutative object-oriented techniques?</source>
          <target state="translated">프로그래밍 정신 및 패턴은 당신과 당신의 팀이 사용합니다. 기능적 접근 방식을 선호하고 팀에서 돌연변이가 발생하거나 와일드 웨스트 돌연변이 체 객체 지향 기술을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="6357292b24fba94284af6389041f255b8a00f04f" translate="yes" xml:space="preserve">
          <source>The range of object types you want to remove properties on and the type of property names you need to be able to omit (Strings only? Symbols? Weak references mapped from arbitrary objects? These have all been types of property pointers in JavaScript for years now)</source>
          <target state="translated">속성을 제거하려는 객체 유형의 범위와 생략 할 수있는 속성 이름 유형 (문자열 만? 기호? 임의의 객체에서 약한 참조가 매핑 되었습니까?) 이제 몇 년 동안 JavaScript에서 속성 포인터 유형이되었습니다. )</target>
        </trans-unit>
        <trans-unit id="3fea2fb86e2276224dff32e33243b1e22287ed2d" translate="yes" xml:space="preserve">
          <source>The reason for writing this new &lt;code&gt;unset&lt;/code&gt; function, is to keep the index of all other variables in this hash_map. Look at the following example, and see how the index of &quot;test2&quot; did not change after removing a value from the hash_map.</source>
          <target state="translated">이 새로운 &lt;code&gt;unset&lt;/code&gt; 함수를 작성하는 이유는이 hash_map에 다른 모든 변수의 인덱스를 유지하기 위해서입니다. 다음 예제를보고 hash_map에서 값을 제거한 후 &quot;test2&quot;의 색인이 어떻게 변경되지 않았는지보십시오.</target>
        </trans-unit>
        <trans-unit id="e16825f749b4e5fb7d1fecf43d4e6b653061e2e8" translate="yes" xml:space="preserve">
          <source>The result would be &lt;code&gt;false&lt;/code&gt;, which means that your delete statement haven't been executed as you expected. But if you had not created that variable before, and you only had &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; as your last existing reference, you could have done this just by removing it like:</source>
          <target state="translated">결과는 &lt;code&gt;false&lt;/code&gt; 이며, 예상대로 delete 문이 실행되지 않았 음을 의미합니다. 그러나 이전에 해당 변수를 작성하지 않았고 마지막 기존 참조로 &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; 만있는 경우 다음과 같이 제거하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f6481accf44872d4ef8745c055193c2829ccd3cb" translate="yes" xml:space="preserve">
          <source>The term you have used in your question title &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt;, can be interpreted in some different ways. The one is to remove it for whole the memory and the list of object keys or the other is just to remove it from your object. As it has been mentioned in some other answers, the &lt;code&gt;delete&lt;/code&gt; keyword is the main part. Let's say you have your object like:</source>
          <target state="translated">질문 제목에 사용한 용어 &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt; 몇 가지 다른 방식으로 해석 될 수 있습니다. 하나는 메모리 전체를 제거하고 객체 키 목록을 제거하거나 다른 것은 객체에서 제거하는 것입니다. 다른 답변에서 언급했듯이 &lt;code&gt;delete&lt;/code&gt; 키워드가 주요 부분입니다. 다음과 같은 객체가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="d7c42d645c208dfd4e3c38a50db94ab5a07bdf03" translate="yes" xml:space="preserve">
          <source>The version of ECMAScript you're targeting</source>
          <target state="translated">대상으로하는 ECMAScript의 버전</target>
        </trans-unit>
        <trans-unit id="2d17e745883099706ab5b904d19b87cebce1764f" translate="yes" xml:space="preserve">
          <source>Then even if you remove it from your object &lt;code&gt;myJSONObject&lt;/code&gt;, that specific object won't get deleted from the memory, since the &lt;code&gt;regex&lt;/code&gt; variable and &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; still have their values. Then how could we remove the object from the memory for sure?</source>
          <target state="translated">그런 다음 객체 &lt;code&gt;myJSONObject&lt;/code&gt; 에서 객체를 제거하더라도 &lt;code&gt;regex&lt;/code&gt; 변수 및 &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; 에 여전히 값이 있으므로 해당 객체는 메모리에서 삭제되지 않습니다. 그렇다면 어떻게 메모리에서 객체를 제거 할 수 있을까요?</target>
        </trans-unit>
        <trans-unit id="9f315ff9ba259ec4af4aad477da9caf99c783595" translate="yes" xml:space="preserve">
          <source>Then your objects key using &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; would be:</source>
          <target state="translated">그런 다음 &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; 사용하는 객체 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="950ba1d1f6aad6e3258d15bc7f08a5e034f6a816" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I just want to chime in that when using delete to remove a property in JavaScript, it is often wise to first check if that property exists to prevent errors.</source>
          <target state="translated">여기에는 좋은 대답이 많이 있지만 delete를 사용하여 JavaScript에서 속성을 제거 할 때 오류를 방지하기 위해 해당 속성이 있는지 먼저 확인하는 것이 현명합니다.</target>
        </trans-unit>
        <trans-unit id="57100a7adc73f2ac8fb1259dcb31d2cae8056822" translate="yes" xml:space="preserve">
          <source>There are few common ways to remove a property from an object.</source>
          <target state="translated">객체에서 속성을 제거하는 일반적인 방법은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="8604def9bd3e30573031d5be629fb2bb0c18ca39" translate="yes" xml:space="preserve">
          <source>There are many different options presented on this page, not because most of the options are wrong&amp;mdash;or because the answers are duplicates&amp;mdash;but because the appropriate technique depends on the situation you're in and the goals of the tasks you and/or you team are trying to fulfill. To answer you question unequivocally, one needs to know:</source>
          <target state="translated">이 페이지에는 여러 가지 옵션이 있습니다. 대부분의 옵션이 잘못되었거나 답변이 중복 되었기 때문이 아니라 적절한 기술이 현재 상황과 귀하 및 / 또는 귀하의 작업 목표에 따라 달라지기 때문입니다. 팀은 성취하려고합니다. 확실하게 질문에 대답하려면 다음을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="5f1efa2f9fb405d638f74fe5349dbabb89e0514a" translate="yes" xml:space="preserve">
          <source>They are slow &amp;amp; memory inefficient. When accessing a specific index, instead of just getting the global type for the array, the browser instead has to get the type on a per-index basis whereby each index stores the additional metadata of its type.</source>
          <target state="translated">그들은 느리고 메모리 비효율적입니다. 특정 인덱스에 액세스 할 때 배열의 전역 유형을 가져 오는 대신 브라우저는 인덱스별로 유형을 가져와 각 인덱스가 해당 유형의 추가 메타 데이터를 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="afa3b2f30890db447e4cf00d9f2dcec7b332b01b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;ES6&lt;/code&gt; operator allows us to return a brand new object, excluding any properties, without mutating the existing object. The downside is that it has the worse performance out of the above and not suggested to be used when you need to remove many properties at a time.</source>
          <target state="translated">이 &lt;code&gt;ES6&lt;/code&gt; 연산자를 사용하면 기존 객체를 변경하지 않고 속성을 제외한 완전히 새로운 객체를 반환 할 수 있습니다. 단점은 위의 성능이 저하되어 한 번에 많은 속성을 제거해야 할 때 사용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e7248bc6c7cf17aeb43a8906d8cc8e3b531512b" translate="yes" xml:space="preserve">
          <source>This alternative is not the correct answer to this question! But, if you use it with care, you can dramatically speed up some algorithms. If you are using &lt;code&gt;delete&lt;/code&gt; in loops and you have problems with performance, read the verbose explanation.</source>
          <target state="translated">이 대안은이 질문에 대한 정답이 아닙니다! 그러나주의해서 사용하면 일부 알고리즘의 속도를 크게 높일 수 있습니다. 루프에서 &lt;code&gt;delete&lt;/code&gt; 를 사용하고 성능에 문제가있는 경우 자세한 설명을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="d2696a11c056f55fc8c70ea4ff94e4f5922248e1" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference and aren't using stateless functional principles in your code. An example piece of syntax in this category:</source>
          <target state="translated">이 범주는 원래 참조를 유지 / 계속 사용하려고하고 코드에서 상태 비 저장 기능 원리를 사용하지 않는 경우 객체 리터럴 또는 객체 인스턴스에서 작동합니다. 이 카테고리의 구문 예제 :</target>
        </trans-unit>
        <trans-unit id="1f8c0c20dd501470cb117b73c855e583ae2e0193" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference while guarding against exceptions being thrown on unconfigurable properties:</source>
          <target state="translated">이 범주는 구성 할 수없는 속성에서 발생하는 예외를 방지하면서 원래 참조를 유지 / 계속 사용하려는 경우 객체 리터럴 또는 객체 인스턴스에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="94bdb987c00caa2e598854f97ea3c6de4e30eedf" translate="yes" xml:space="preserve">
          <source>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</source>
          <target state="translated">이 범주는 비변 이적 접근 방식이 필요하고 기호 키를 고려할 필요가없는 경우 최신 ECMAScript 버전의 일반 객체 또는 배열 인스턴스에서 작동하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="aba34382b27aca74b69be04c741119ab744a49b9" translate="yes" xml:space="preserve">
          <source>This category is generally allows for greater functional flexibility, including accounting for Symbols &amp;amp; omitting more than one property in one statement:</source>
          <target state="translated">이 범주는 일반적으로 기호 설명 및 하나의 명령문에서 둘 이상의 특성 생략을 포함하여 더 큰 기능적 유연성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="17ff7f9c0c298023ffef1288d23c2efc74ebdf5c" translate="yes" xml:space="preserve">
          <source>This category is the oldest, most straightforward &amp;amp; most widely supported category of property removal. It supports &lt;code&gt;Symbol&lt;/code&gt; &amp;amp; array indexes in addition to strings and works in every version of JavaScript except for the very first release. However, it's mutative which violates some programming principles and has performance implications. It also can result in uncaught exceptions when used on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;non-configurable properties in strict mode&lt;/a&gt;.</source>
          <target state="translated">이 카테고리는 가장 오래되고 가장 간단하며 가장 광범위하게 지원되는 부동산 제거 카테고리입니다. 문자열뿐만 아니라 &lt;code&gt;Symbol&lt;/code&gt; 및 배열 인덱스를 지원하며 첫 번째 릴리스를 제외한 모든 버전의 JavaScript에서 작동합니다. 그러나 일부 프로그래밍 원칙을 위반하고 성능에 영향을 미치는 것은 돌연변이입니다. 또한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;엄격 모드에서 구성 할 수없는 특성에&lt;/a&gt; 사용될 때 예외가 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ad77472ac7767c23050851eada92d065c2bd943" translate="yes" xml:space="preserve">
          <source>This is in regard to this (now-removed) snippet:</source>
          <target state="translated">이것은 (이제 제거 된) 스 니펫과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="21292c660408d1ff92d4a1c2c4eafdd76c276e51" translate="yes" xml:space="preserve">
          <source>This post is very old and I find it very helpful so I decided to share the unset function I wrote in case someone else see this post and think why it's not so simple as it in PHP unset function.</source>
          <target state="translated">이 게시물은 매우 오래되어 매우 유용하므로 다른 사람 이이 게시물을보고 PHP unset 함수에서 그렇게 간단하지 않은 이유를 생각한 경우 작성한 unset 함수를 공유하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="9603916ceb02f62ecad35613c65fb5ceed83b60d" translate="yes" xml:space="preserve">
          <source>This works in Firefox and Internet&amp;nbsp;Explorer, and I think it works in all others.</source>
          <target state="translated">이것은 Firefox 및 Internet Explorer에서 작동하며 다른 모든에서도 작동한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="c685cc94e2b05416a2b9215116753bb12c7af729" translate="yes" xml:space="preserve">
          <source>To complete @Koen answer in this thread, in case you want to remove dynamic variable using the spread syntax, you can do it like so:</source>
          <target state="translated">이 스레드에서 @Koen 답변을 완료하려면 스프레드 구문을 사용하여 동적 변수를 제거하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="a792292997434d58f8b1d7da4af78863ac5e4684" translate="yes" xml:space="preserve">
          <source>To get more info on &lt;code&gt;Object.seal&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal()&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Object.seal&lt;/code&gt; 에 대한 자세한 정보를 얻으려면 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96589c0ac9acf3a6b58f6928336639e582088ee3" translate="yes" xml:space="preserve">
          <source>To reassign to the same variable, use a &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">동일한 변수에 다시 할당하려면 &lt;code&gt;let&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="21af806df3feb60911002a77c4380b2b484f7bbf" translate="yes" xml:space="preserve">
          <source>To remove any property, say &lt;code&gt;key1&lt;/code&gt;, use the &lt;code&gt;delete&lt;/code&gt; keyword like this:</source>
          <target state="translated">&lt;code&gt;key1&lt;/code&gt; 과 같은 속성을 제거하려면 다음과 같이 &lt;code&gt;delete&lt;/code&gt; 키워드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa15c129befde7656ac754122a25210685ef2188" translate="yes" xml:space="preserve">
          <source>To summarize, differences are all about ways of determining the property existence, and about &lt;code&gt;for..in&lt;/code&gt; loop.</source>
          <target state="translated">요약하면, 차이점은 속성 존재를 결정하는 방법과 &lt;code&gt;for..in&lt;/code&gt; 루프에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="87501fb0e92ec552bdf306c07f48852286e9c8c8" translate="yes" xml:space="preserve">
          <source>To whoever needs it...</source>
          <target state="translated">그것을 필요로하는 사람에게는 ...</target>
        </trans-unit>
        <trans-unit id="b7ff74710b25d787ff3d518b1667a655a5936c78" translate="yes" xml:space="preserve">
          <source>Try the following method. Assign the &lt;code&gt;Object&lt;/code&gt; property value to &lt;code&gt;undefined&lt;/code&gt;. Then &lt;code&gt;stringify&lt;/code&gt; the object and &lt;code&gt;parse&lt;/code&gt;.</source>
          <target state="translated">다음 방법을 시도하십시오. &lt;code&gt;Object&lt;/code&gt; 속성 값을 &lt;code&gt;undefined&lt;/code&gt; 에 할당하십시오. 그런 다음 객체를 &lt;code&gt;stringify&lt;/code&gt; 하고 &lt;code&gt;parse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d82a9f15156c36519fc72f9af221c32d7422e29" translate="yes" xml:space="preserve">
          <source>Try this</source>
          <target state="translated">이 시도</target>
        </trans-unit>
        <trans-unit id="828f97e6c91f157ecd45fc8183a07ca7b4e95e6f" translate="yes" xml:space="preserve">
          <source>Update regarding &lt;code&gt;is_array()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_array()&lt;/code&gt; 관련 업데이트</target>
        </trans-unit>
        <trans-unit id="d45aa1f9d8100f951a216d7ce715ec8d99477eb3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda#dissoc&lt;/a&gt; you will get a new object without the attribute &lt;code&gt;regex&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda # dissoc&lt;/a&gt; 을 사용하면 속성 &lt;code&gt;regex&lt;/code&gt; 없이 새로운 객체를 얻게됩니다 :</target>
        </trans-unit>
        <trans-unit id="930151a2e26bf074e4b81d244de5799b750be707" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;delete&lt;/strong&gt; method is the best way to do that, as per MDN description, the delete operator removes a property from an object. So you can simply write:</source>
          <target state="translated">MDN 설명에 따라 delete 연산자를 사용하는 것이 가장 좋은 방법입니다. delete 연산자는 객체에서 속성을 제거합니다. 따라서 간단하게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="855d634ee489e4e0a2c811671f665628a0a0df6f" translate="yes" xml:space="preserve">
          <source>Using ES6:</source>
          <target state="translated">ES6 사용 :</target>
        </trans-unit>
        <trans-unit id="9fb406e463a70799e2a3db3cb0956dde6058516c" translate="yes" xml:space="preserve">
          <source>Using this method, not all &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;ways of determining property existence&lt;/a&gt; will work as expected.</source>
          <target state="translated">이 방법을 사용하면 &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;속성 존재를 결정하는&lt;/a&gt; 모든 방법이 예상대로 작동하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d56ccd01dc2c25715aa91cc5c3b3239162d1db4" translate="yes" xml:space="preserve">
          <source>What follows is a contrived scenario that gets pretty long-winded, so you can skip to the section, &lt;strong&gt;The Solution&lt;/strong&gt;, if you want. The only reason I leave this section it is that I think some people probably think it's funny, and I don't want to be &quot;that guy&quot; who posts a &quot;funny&quot; answer and then deletes all the &quot;funny&quot; from it later on.</source>
          <target state="translated">다음은 꽤 오래 걸리는 시나리오이므로, 원하는 경우 &lt;strong&gt;솔루션&lt;/strong&gt; 섹션으로 건너 뛸 수 있습니다. 내가이 섹션을 떠나는 유일한 이유는 아마 어떤 사람들은 그것이 재미 있다고 생각하고 &quot;재미있는&quot;답변을 게시 한 후 &quot;재미있는&quot;모든 사람을 삭제하는 &quot;그 사람&quot;이되고 싶지 않기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="e8a0f3d5fef79ddff6c740f20faf1841e9c8a913" translate="yes" xml:space="preserve">
          <source>What is the best way to remove the property &lt;code&gt;regex&lt;/code&gt; to end up with new &lt;code&gt;myObject&lt;/code&gt; as follows?</source>
          <target state="translated">다음과 같이 새 &lt;code&gt;myObject&lt;/code&gt; 로 끝나기 위해 &lt;code&gt;regex&lt;/code&gt; 속성을 제거하는 가장 좋은 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="269ad8f4ba0c959d755966ae84263f7c06ef0a98" translate="yes" xml:space="preserve">
          <source>When should one use &lt;code&gt;delete&lt;/code&gt; and when set value to &lt;code&gt;undefined&lt;/code&gt; ?</source>
          <target state="translated">언제 &lt;code&gt;delete&lt;/code&gt; 를 사용해야하고 value를 &lt;code&gt;undefined&lt;/code&gt; 로 설정해야합니까?</target>
        </trans-unit>
        <trans-unit id="f73054e5169db0bc5c2ed5932270c4a709d901aa" translate="yes" xml:space="preserve">
          <source>When using a Symbol, wait, why are you using a Symbol?!?! Symbols are bad  juju for performance. Everything programmed to use Symbols can be reprogrammed to not use Symbols, resulting in a faster code without Symbols. Symbols are really just super inefficient meta-sugar.</source>
          <target state="translated">Symbol을 사용할 때 기다리십시오. 왜 Symbol을 사용하고 있습니까?!?! 기호는 성능면에서 좋지 않습니다. Symbol을 사용하도록 프로그래밍 된 모든 것을 Symbol을 사용하지 않도록 재 프로그래밍 할 수 있으므로 Symbol이없는 더 빠른 코드가 생성됩니다. 기호는 실제로 매우 비효율적 인 메타 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="602ae3083b5ceb94cfa5bb3b6f0e1f19f1f16418" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the boolean primitive, use either &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the empty value. While avoiding unnecessary polymorphism is good, rewriting all your code to explicitly forbid it will likely actually result in a decrease in performance. Use common judgement!</source>
          <target state="translated">부울 프리미티브에 유형이 지정된 배열 / 변수를 사용하는 경우 빈 값으로 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 사용하십시오. 불필요한 다형성을 피하는 것이 좋지만 명시 적으로 금지하도록 모든 코드를 다시 작성하면 실제로 성능이 저하 될 수 있습니다. 일반적인 판단을 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="97e2c329b633d1758a70203709d67ea5a41bbc86" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the number primitive, use &lt;code&gt;0&lt;/code&gt; as the empty value. Note that internally, there are two types of numbers: fast integers (2147483647 to -2147483648 inclusive) and slow floating point doubles (anything other than that including &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt;). When an integer is demoted to a double, it cannot be promoted back to an integer.</source>
          <target state="translated">숫자 프리미티브로 유형이 지정된 배열 / 변수를 사용하는 경우 &lt;code&gt;0&lt;/code&gt; 을 빈 값으로 사용하십시오. 내부에는 빠른 정수 (2147483647 ~ -2147483648 포함)와 느린 부동 소수점 두 배 ( &lt;code&gt;NaN&lt;/code&gt; 및 &lt;code&gt;Infinity&lt;/code&gt; 포함 이외의 숫자)라는 두 가지 유형의 숫자가 있습니다. 정수가 두 배로 강등되면 정수로 다시 승격 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="363e06ebcbb46e5d020be755b34062c111648564" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the string primitive, use &lt;code&gt;&quot;&quot;&lt;/code&gt; as the empty value.</source>
          <target state="translated">문자열 기본 형식으로 입력 된 배열 / 변수를 사용하는 경우 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 빈 값으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2daf2d7377c143fd1982ce05f553ab2ba4bd19a7" translate="yes" xml:space="preserve">
          <source>When using anything else, use &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">다른 것을 사용할 때는 &lt;code&gt;null&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="99129be375514e4d040c762996086e2002e66f2e" translate="yes" xml:space="preserve">
          <source>Which is a terrible justification for getting rid of the &lt;code&gt;null&lt;/code&gt;s--&lt;code&gt;null&lt;/code&gt; is only dangerous if used improperly, and it has nothing to do with &quot;precision&quot;. The real reason you shouldn't &lt;code&gt;delete&lt;/code&gt; from an array is that leaving garbage-filled and messy data structures around is sloppy and bug-prone.</source>
          <target state="translated">이것은 &lt;code&gt;null&lt;/code&gt; 을 제거하는 데있어 끔찍한 정당화입니다. &lt;code&gt;null&lt;/code&gt; 은 부적절하게 사용될 경우에만 위험하며 &quot;정밀도&quot;와는 아무 관련이 없습니다. 배열에서 &lt;code&gt;delete&lt;/code&gt; 해서는 안되는 실제 이유는 가비지 가득하고 지저분한 데이터 구조를 남겨 두는 것이 느슨하고 버그가 발생하기 쉽기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1f5947457b95655f5329f1cfd08d1b56c64dd6e7" translate="yes" xml:space="preserve">
          <source>Which means in this case you won't be able to remove that object because you have created the &lt;code&gt;regex&lt;/code&gt; variable via a &lt;code&gt;var&lt;/code&gt; statement, and if you do:</source>
          <target state="translated">이 경우 &lt;code&gt;var&lt;/code&gt; 문을 통해 &lt;code&gt;regex&lt;/code&gt; 변수를 만들었으므로 다음과 같은 경우 해당 개체를 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f17f120087f0ca40e417b064249125802d82ec5" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; is faster than doing &lt;code&gt;delete obj[prop]&lt;/code&gt;, another important consideration is that &lt;code&gt;obj[prop] = undefined&lt;/code&gt; may not always be appropriate. &lt;code&gt;delete obj[prop]&lt;/code&gt; removes &lt;code&gt;prop&lt;/code&gt; from &lt;code&gt;obj&lt;/code&gt; and erases it from memory whereas &lt;code&gt;obj[prop] = undefined&lt;/code&gt; simply sets the value of &lt;code&gt;prop&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; which leaves &lt;code&gt;prop&lt;/code&gt; still in memory. Therefore, in circumstances where there are many keys being created and deleted, using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; can force expensive memory reconciliation (causing the page to freeze up) and potentially an out-of-memory error. Examine the following code.</source>
          <target state="translated">&lt;code&gt;obj[prop] = undefined&lt;/code&gt; 것이 &lt;code&gt;delete obj[prop]&lt;/code&gt; 수행하는 것보다 빠르지 만, 또 다른 중요한 고려 사항은 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; 가 항상 적절하지 않을 수도 있다는 것입니다. &lt;code&gt;delete obj[prop]&lt;/code&gt; 는 &lt;code&gt;obj&lt;/code&gt; 에서 &lt;code&gt;prop&lt;/code&gt; 을 제거하고 메모리에서 지 웁니다. 반면 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; 는 &lt;code&gt;prop&lt;/code&gt; 의 값을 undefined 로 설정하여 prop 을 메모리에 그대로 둡니다. 따라서 많은 키가 생성 및 삭제되는 상황에서 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; 하면 값 비싼 메모리 조정 (페이지 중지로 인한) 및 메모리 부족 오류가 발생할 수 있습니다. 다음 코드를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="9fc668854fffc36979144c2d4415e9f9721712c0" translate="yes" xml:space="preserve">
          <source>While you technically can use &lt;code&gt;delete&lt;/code&gt; for an array, using it would result in getting incorrect results when calling for example &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; later on. In other words, &lt;code&gt;delete&lt;/code&gt; would remove the element, but it wouldn't update the value of &lt;code&gt;length&lt;/code&gt; property. Using &lt;code&gt;delete&lt;/code&gt; would also mess up your indexing.</source>
          <target state="translated">기술적으로 배열에 &lt;code&gt;delete&lt;/code&gt; 를 사용할 수 있지만 나중에 배열을 사용하면 예를 들어 &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; 를 호출 할 때 잘못된 결과가 발생합니다. 즉, &lt;code&gt;delete&lt;/code&gt; 는 요소를 제거하지만 &lt;code&gt;length&lt;/code&gt; 속성 값은 업데이트하지 않습니다. &lt;code&gt;delete&lt;/code&gt; 를 사용하면 인덱싱이 엉망이됩니다.</target>
        </trans-unit>
        <trans-unit id="4be2ecd11ba0e212cafbe9f3ed4567f70ea3cc57" translate="yes" xml:space="preserve">
          <source>Yeah, that's definitely not what you wanted.</source>
          <target state="translated">그래, 그건 네가 원하는 것이 아니야.</target>
        </trans-unit>
        <trans-unit id="02c5f4541ba087fe996da9eb1271ebfb81156d83" translate="yes" xml:space="preserve">
          <source>You can also use other functions to achieve the same effect - omit, pick, ...</source>
          <target state="translated">다른 기능을 사용하여 동일한 효과를 얻을 수 있습니다-생략, 선택, ...</target>
        </trans-unit>
        <trans-unit id="95e9a3221d0ebd0cc77f374d7ddfa95d905aef6a" translate="yes" xml:space="preserve">
          <source>You can delete that specific key from your object keys like:</source>
          <target state="translated">다음과 같이 객체 키에서 해당 키를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df5ae996f80ec18df6459baf979a058b543794dd" translate="yes" xml:space="preserve">
          <source>You can see it in action in the Babel try-out editor.</source>
          <target state="translated">Babel 시험판 편집기에서 작동중인 것을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba4ef71e846efa414e359524a525c5bda890d6bb" translate="yes" xml:space="preserve">
          <source>You can simply delete any property of an object using the &lt;code&gt;delete&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 키워드를 사용하여 객체의 속성을 간단히 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6902cdb7c6341debc4ec1b8c5eaf6794e483c684" translate="yes" xml:space="preserve">
          <source>You can use ES6 destructuring with rest operator.</source>
          <target state="translated">rest 연산자와 함께 ES6 파괴를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="121a5978b1bee631af70ab1aaec00b53de7645b2" translate="yes" xml:space="preserve">
          <source>global scope) can be deleted with delete.</source>
          <target state="translated">전역 범위)를 삭제하여 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5be9ceecc2f03bc42e4d234aec808162f9c2f9d1" translate="yes" xml:space="preserve">
          <source>the result would be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9a0331930f5ae83ac7b458124a7b5021f44ea5d" translate="yes" xml:space="preserve">
          <source>will behave equivalently for both methods.</source>
          <target state="translated">두 방법 모두 동일하게 작동합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
