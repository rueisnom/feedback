<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/208105">
    <body>
      <group id="208105">
        <trans-unit id="d0c785d16c2347fee547f3127b424f77909312a7" translate="yes" xml:space="preserve">
          <source>(Destructuring + Spread operator)</source>
          <target state="translated">(解构+点差运算器)</target>
        </trans-unit>
        <trans-unit id="63d63c34165213cae85c0283076b58a13c886dbf" translate="yes" xml:space="preserve">
          <source>(ES6)</source>
          <target state="translated">(ES6)</target>
        </trans-unit>
        <trans-unit id="7d50cf7543cd430338fe6fd7172b5d7ec7565f89" translate="yes" xml:space="preserve">
          <source>* &lt;em&gt;&lt;code&gt;foo&lt;/code&gt; will be a new variable with the value of &lt;code&gt;a&lt;/code&gt; (which is 1).&lt;/em&gt;</source>
          <target state="translated">* &lt;em&gt; &lt;code&gt;foo&lt;/code&gt; 将是一个新变量，其值为 &lt;code&gt;a&lt;/code&gt; （为1）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8aa44c32c47930ef0f4bc07bf1b584a5b6b0e2f" translate="yes" xml:space="preserve">
          <source>...It's stupid, I know.</source>
          <target state="translated">...这很蠢,我知道。</target>
        </trans-unit>
        <trans-unit id="ff34d7bfb44f74504dbcecb1c791e02877f620e3" translate="yes" xml:space="preserve">
          <source>1.With explicit prop key:</source>
          <target state="translated">1、有明确的道具键。</target>
        </trans-unit>
        <trans-unit id="145f4a070da96e31a48d8d444babf929a09a782a" translate="yes" xml:space="preserve">
          <source>2.With variable prop key:</source>
          <target state="translated">2、带可变道具键。</target>
        </trans-unit>
        <trans-unit id="75c350f4599bd395c8e57950299bcd4efdaca57e" translate="yes" xml:space="preserve">
          <source>3.Cool arrow function 😎:</source>
          <target state="translated">3.冷箭功能😎。</target>
        </trans-unit>
        <trans-unit id="b31d7d6cbd9fc3e49f4feaeef410e7cee592b5fa" translate="yes" xml:space="preserve">
          <source>4. For multiple properties</source>
          <target state="translated">4.对于多属性</target>
        </trans-unit>
        <trans-unit id="cecf2bde461c486918fed98467ea58414d0dd173" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze()&lt;/a&gt; makes all properties of object not configurable (besides other things). &lt;code&gt;deleteProperty&lt;/code&gt; function (as well as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt;) returns &lt;code&gt;false&lt;/code&gt; when tries to delete any of it's properties. If property is configurable it returns &lt;code&gt;true&lt;/code&gt;, even if property does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze（）&lt;/a&gt;使对象的所有属性均不可配置（除其他因素外）。 当试图删除其任何属性时， &lt;code&gt;deleteProperty&lt;/code&gt; 函数（以及&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete运算符&lt;/a&gt; ）将返回 &lt;code&gt;false&lt;/code&gt; 。 如果property是可配置的，则即使property不存在，它也会返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2f5341f96365af83c99b7c7d47dba6c4b1a96cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;Spread Syntax&lt;/a&gt; (ES6)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;传播语法&lt;/a&gt; （ES6）</target>
        </trans-unit>
        <trans-unit id="e4d9e924d09e0b750a05547c2f0bf5fa2c195878" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.slice()&lt;/code&gt; is non-destructive and returns a new array containing the indicated indices from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;. If &lt;code&gt;end&lt;/code&gt; is left unspecified, the behavior is the same as &lt;code&gt;.splice()&lt;/code&gt; (&lt;code&gt;end = array.length&lt;/code&gt;). The behavior is a bit tricky since, for some reason, &lt;code&gt;end&lt;/code&gt; indexes from 1 instead of 0. I don't know why it does this, but that's how it is. Also, if &lt;code&gt;end &amp;lt;= start&lt;/code&gt;, the result is an empty array.</source>
          <target state="translated">&lt;code&gt;.slice()&lt;/code&gt; 是非破坏性的， 从头到尾返回一个包含指定索引的新数组。 如果未指定 &lt;code&gt;end&lt;/code&gt; ，则其行为与 &lt;code&gt;.splice()&lt;/code&gt; 相同（ &lt;code&gt;end = array.length&lt;/code&gt; ）。 行为有点棘手，因为出于某种原因， &lt;code&gt;end&lt;/code&gt; 索引从1而不是0开始。我不知道为什么这样做，但是事实就是如此。 另外，如果 &lt;code&gt;end &amp;lt;= start&lt;/code&gt; ，则结果为空数组。</target>
        </trans-unit>
        <trans-unit id="da2a0c1e98a822064cc6b913222774a91ac62044" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.splice()&lt;/code&gt; mutates the array, and returns the removed indices. The array is sliced starting from the index, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; elements are sliced out. If n is unspecified, the entire array after &lt;code&gt;start&lt;/code&gt; is sliced out (&lt;code&gt;n = array.length - start&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;.splice()&lt;/code&gt; 更改数组，并返回删除的索引。 从索引index &lt;code&gt;start&lt;/code&gt; ，对数组进行切片，对 &lt;code&gt;n&lt;/code&gt; 个元素进行切片。 如果未指定n，则将 &lt;code&gt;start&lt;/code&gt; 之后的整个数组切出（ &lt;code&gt;n = array.length - start&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="578e0d997316ced94b2f7c292e4269507a0730b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Delete Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;删除运算符&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10a7b7e3a95023fb9f5d4f97bbeb1e856756bc60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;EXTENDED ANSWER&lt;/em&gt;&lt;/strong&gt; 😇</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;扩展答案&lt;/em&gt;&lt;/strong&gt; 😇</target>
        </trans-unit>
        <trans-unit id="3393b3743a22fd0193ab2fa39735ae2f646b06ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="710a4e957cc23ae95eb9aa6e13030731ab1c9d56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e590196d99e29b0fb26cc981e8c241732f76e4ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Spread Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;点差算子&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64d050dff57dceee4d758cc0912b8d402b405b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b02479449faf2e3a74dc8a9ef6000bfbe7ea1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In other words, a JavaScript object gets killed as soon as there is no reference left in your code pointed to that object.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;换句话说，只要您的代码中没有指向该对象的引用，JavaScript对象就会被杀死。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecc8000feff4d7f65f5786df06cc101796ac4edd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To clone object without property:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;要克隆没有属性的对象：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ca5c58827bf40e3a97a098228081f1f64d66b7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018-07-21:&lt;/strong&gt; For a long time, I have felt embarrassed about this answer, so I think it's time that I touch it up a little bit. Just a little commentary, clarification, and formatting to help expedite the reading of the needlessly long and convoluted parts of this answer.</source>
          <target state="translated">&lt;strong&gt;2018年7月21日更新：&lt;/strong&gt;很长一段时间以来，我对这个答案感到很尴尬，所以我认为现在是我应该稍微加以解决的时候了。 只需一点注释，澄清和格式化，即可帮助快速阅读此答案中不必要的冗长和复杂的部分。</target>
        </trans-unit>
        <trans-unit id="c099f37767111dc60103bd8696ed4fcf3e7a64d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;
Thanks to @AgentME:</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;感谢@AgentME：</target>
        </trans-unit>
        <trans-unit id="cd7c415e1d4039a5febeafd32c836a75f6b919e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;delete&lt;/code&gt;,&lt;/strong&gt; when you are passing the result object to the code on which you don't have control (or when you are not sure about your team or yourself).</source>
          <target state="translated">当您将结果对象传递给您无法控制的代码时（或者不确定您的团队或您自己时） &lt;strong&gt;，请使用 &lt;code&gt;delete&lt;/code&gt; &lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="0af0c0606dbb967654f58c35fa2988459afb9a19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use setting to &lt;code&gt;undefined&lt;/code&gt;,&lt;/strong&gt; when you care about performance. It can give a serious boost to your code.</source>
          <target state="translated">当您关心性能时&lt;strong&gt;，请使用设置为 &lt;code&gt;undefined&lt;/code&gt; &lt;/strong&gt; 。 它可以大大提高您的代码。</target>
        </trans-unit>
        <trans-unit id="9dfe20a67d61ae6b75beddf80cff0434cb3f7a9f" translate="yes" xml:space="preserve">
          <source>A live example to show:</source>
          <target state="translated">一个活生生生的例子来说明。</target>
        </trans-unit>
        <trans-unit id="aabd2b7839024463c3c18626551d6893b70879bd" translate="yes" xml:space="preserve">
          <source>About now, you're at your wit's end. This guy has been complaining non-stop about your app, and you want to tell him to shut up and go get a better computer.</source>
          <target state="translated">现在,你已经无计可施了。这家伙一直在不停地抱怨你的应用程序,你想让他闭嘴,去换一台更好的电脑。</target>
        </trans-unit>
        <trans-unit id="692f82b2a7574a467099a421e634c28a19087f50" translate="yes" xml:space="preserve">
          <source>Alternatively, you could also do this:</source>
          <target state="translated">另外,你也可以这样做。</target>
        </trans-unit>
        <trans-unit id="8dd6b6a5cb398077b2e61b33860df5233162a369" translate="yes" xml:space="preserve">
          <source>An object may be seen as a set of key-value pairs. What I call a 'value' is a primitive or a reference to other object, connected to that 'key'.</source>
          <target state="translated">一个对象可以被看作是一组键-值对。我所说的 &quot;值 &quot;是一个基元或对其他对象的引用,连接到这个 &quot;键&quot;。</target>
        </trans-unit>
        <trans-unit id="97f362e729192c077ada3f5241fec0dea0e6f9ad" translate="yes" xml:space="preserve">
          <source>And just like that, you've pleased Mr. PDP-11. Hooray! &lt;sub&gt;(I'd still tell him off, though...)&lt;/sub&gt;</source>
          <target state="translated">就像那样，您使PDP-11先生感到高兴。 万岁！ &lt;sub&gt;（不过，我还是告诉他...）&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="38fedc2f5a59cd30ac658c92ac34226c9870e485" translate="yes" xml:space="preserve">
          <source>And we need to delete 'a'.</source>
          <target state="translated">而我们需要删除 &quot;A&quot;。</target>
        </trans-unit>
        <trans-unit id="15728408349a51726fa4d7a495f586b8e25e36f1" translate="yes" xml:space="preserve">
          <source>Another alternative is to use the &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt; library.</source>
          <target state="translated">另一种选择是使用&lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt;库。</target>
        </trans-unit>
        <trans-unit id="130c3bce337f7ed92461a0af093bf0dd8b4d970c" translate="yes" xml:space="preserve">
          <source>Another solution, using &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array#reduce&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">另一种解决方案，使用&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array#reduce&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="75aa366398b31b18c07d678c84ff7223a1b76dbe" translate="yes" xml:space="preserve">
          <source>Any property declared with let or const cannot be deleted from the scope  within which they were defined. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().</source>
          <target state="translated">任何用let或const声明的属性都不能从定义它们的范围中删除。不可配置的属性不能被删除。这包括内置对象(如Math、Array、Object)的属性,以及使用Object.defineProperty()等方法创建的不可配置属性。</target>
        </trans-unit>
        <trans-unit id="b2ecb35283325b0622c879acc81ba757d7accad0" translate="yes" xml:space="preserve">
          <source>Any property declared with var cannot be deleted from the global scope
  or from a function's scope.</source>
          <target state="translated">任何用var声明的属性都不能从全局作用域或函数的作用域中删除。</target>
        </trans-unit>
        <trans-unit id="6c333dd9449a548b822691fcab373abce8f8f850" translate="yes" xml:space="preserve">
          <source>Are you looking to achieve this in pure JavaScript or are you willing &amp;amp; able to use a 3rd-party library?</source>
          <target state="translated">您是要使用纯JavaScript实现这一目标，还是愿意并能够使用第三方库？</target>
        </trans-unit>
        <trans-unit id="1fea0155471c15e540c5b31c3594a45754e6cc6c" translate="yes" xml:space="preserve">
          <source>Array equivalent</source>
          <target state="translated">阵列等价物</target>
        </trans-unit>
        <trans-unit id="10f82eff0fb408011ffeabc374c6234764312dea" translate="yes" xml:space="preserve">
          <source>Array.prototype.slice(start, end)</source>
          <target state="translated">Array.prototype.slice(start,end)</target>
        </trans-unit>
        <trans-unit id="dfe829210c0c25d8779de7fe65fb3158cefd4290" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice vs Array.prototype.slice</source>
          <target state="translated">Array.prototype.splice vs Array.prototype.slice</target>
        </trans-unit>
        <trans-unit id="99ba4898ce91c3e3945c33ecd292283940427b38" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice(start, n)</source>
          <target state="translated">Array.prototype.splice(start,n)</target>
        </trans-unit>
        <trans-unit id="bc85e8ead32cd6185d2f6ca2b34c7fbc94aadd58" translate="yes" xml:space="preserve">
          <source>As others have said, you can use &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">正如其他人所说，可以使用 &lt;code&gt;delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc6de88f57fe2bcbd39aa2ddf8ca667c26f222a3" translate="yes" xml:space="preserve">
          <source>As seen in the above code snippet, there are some rare appropriate use cases for the &lt;code&gt;delete&lt;/code&gt; operator. However, do not worry about this problem too much. This will only become a problem with long-lifespan objects that get new keys constantly added to them. In any other case (which is almost every case in real-world programming), it is most appropriate to use &lt;code&gt;obj[prop] = undefined&lt;/code&gt;. The main purpose of this section is just to bring this to your attention so that in the rare chance that this does become a problem in your code, then you can more easily understand the problem and thus not have to waste hours dissecting your code to locate and understand this problem.</source>
          <target state="translated">如上面的代码片段所示，对于 &lt;code&gt;delete&lt;/code&gt; 运算符，有一些罕见的适当用例。 但是，不必过多担心此问题。 这将成为具有长寿命对象的问题，这些对象会不断向其添加新密钥。 在任何其他情况下（在现实世界编程中几乎是所有情况），最适合使用 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; 。 本部分的主要目的只是引起您的注意，以便在极少数情况下确实在代码中成为问题，然后您可以更轻松地理解问题，因此不必浪费时间剖析代码来查找并了解这个问题。</target>
        </trans-unit>
        <trans-unit id="0a1a7281b5e3e0adcbcee6c0378231475ce1d077" translate="yes" xml:space="preserve">
          <source>As such, delete cannot delete any functions in the global scope (whether this is part from a function definition or a function  (expression).</source>
          <target state="translated">因此,delete不能删除全局范围内的任何函数(不管是来自函数定义的一部分还是函数(表达式)。</target>
        </trans-unit>
        <trans-unit id="19292906404cfee69ce728ffea847a3cb5d23580" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;delete&lt;/code&gt; doesn't always work as one might expect. The value is overwritten, but the memory is not reallocated. That is to say, &lt;code&gt;array[4]&lt;/code&gt; isn't relocated to &lt;code&gt;array[3]&lt;/code&gt;. Which is in contrast to &lt;code&gt;Array.prototype.unshift&lt;/code&gt;, which inserts an element at the beginning of the array and shifts everything up (&lt;code&gt;array[0]&lt;/code&gt; becomes &lt;code&gt;array[1]&lt;/code&gt;, etc.)</source>
          <target state="translated">如您所见， &lt;code&gt;delete&lt;/code&gt; 并非总是可以像预期的那样进行。 该值将被覆盖，但不会重新分配内存。 也就是说， &lt;code&gt;array[4]&lt;/code&gt; 不会重定位到 &lt;code&gt;array[3]&lt;/code&gt; 。 与 &lt;code&gt;Array.prototype.unshift&lt;/code&gt; 相反，后者在数组的开头插入一个元素并将所有内容向上移动（ &lt;code&gt;array[0]&lt;/code&gt; 变为 &lt;code&gt;array[1]&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="2c856c5e5c5be4265462b9644119ace1784d98d0" translate="yes" xml:space="preserve">
          <source>Beware Of Memory Leaks!</source>
          <target state="translated">小心记忆泄漏!</target>
        </trans-unit>
        <trans-unit id="76829795257d4b98172b51f389192e4a9f633cf6" translate="yes" xml:space="preserve">
          <source>But if the property of the object is not configurable it cannot be deleted neither with deleteProperty function nor delete operator:</source>
          <target state="translated">但是,如果对象的属性是不可配置的,那么无论是DeleteProperty函数还是Deleteoperator都无法删除。</target>
        </trans-unit>
        <trans-unit id="5d2ae2c0c3d231052d20df4bc0d378c5068295e8" translate="yes" xml:space="preserve">
          <source>But the point is if you care about memory and you want to whole the object gets removed from the memory, it is recommended to set it to null before you delete the key:</source>
          <target state="translated">但问题是,如果你关心内存,想把对象从内存中整体删除,建议将其设置为空,然后再删除密钥。</target>
        </trans-unit>
        <trans-unit id="083882684bcd539a61f754c832b4192934d833e3" translate="yes" xml:space="preserve">
          <source>But, how does a drug trip analogy relate to the &lt;code&gt;delete&lt;/code&gt; operation? The answer inheres the last line of code in the snippet above. Thus let it be reexamined, this time with a twist.</source>
          <target state="translated">但是，毒品旅行类推与 &lt;code&gt;delete&lt;/code&gt; 操作有何关系？ 答案位于上面代码段的最后一行代码中。 因此，这一次要重新检查一下。</target>
        </trans-unit>
        <trans-unit id="0eb16d4b50dbacc8475f57ed2dfb88409bd56da6" translate="yes" xml:space="preserve">
          <source>Consider creating a new object without the &lt;code&gt;&quot;regex&quot;&lt;/code&gt; property because the original object could always be referenced by other parts of your program. Thus you should avoid manipulating it.</source>
          <target state="translated">考虑创建没有 &lt;code&gt;&quot;regex&quot;&lt;/code&gt; 属性的新对象，因为原始对象始终可以被程序的其他部分引用。 因此，您应该避免对其进行操作。</target>
        </trans-unit>
        <trans-unit id="1b8bae88ce3f716fc88f086ba5df71aa742b0ee5" translate="yes" xml:space="preserve">
          <source>Dan's assertion that 'delete' is very slow and the benchmark he posted were doubted. So I carried out the test myself in Chrome 59. It does seem that 'delete' is about 30 times slower:</source>
          <target state="translated">Dan说'删除'速度很慢,他贴出的标杆也受到了怀疑。于是我自己在Chrome 59中进行了测试。看来'删除'确实慢了30倍左右。</target>
        </trans-unit>
        <trans-unit id="d8b13a816456ec85d6f3ace2de0c50288edaa6ea" translate="yes" xml:space="preserve">
          <source>Delete is the only true way to remove object's properties without any leftovers, but it works &lt;strong&gt;~ 100 times slower&lt;/strong&gt;, 
compared to its &quot;alternative&quot;, setting &lt;code&gt;object[key] = undefined&lt;/code&gt;.</source>
          <target state="translated">删除是删除对象属性而没有任何剩余物的唯一正确方法，但与&amp;ldquo;替代&amp;rdquo;设置 &lt;code&gt;object[key] = undefined&lt;/code&gt; 相比，它的工作&lt;strong&gt;速度要慢大约100倍&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="45dc7ea9ea6f9f47fa401db4115a5eee26a4be14" translate="yes" xml:space="preserve">
          <source>Deleting an array index</source>
          <target state="translated">删除一个数组索引</target>
        </trans-unit>
        <trans-unit id="42034d05fb5ec8b92965ea89f328c840dc4a3ac4" translate="yes" xml:space="preserve">
          <source>Deleting an object property</source>
          <target state="translated">删除一个对象属性</target>
        </trans-unit>
        <trans-unit id="e52c854d5631eec7468ba4727b4c77eb745f2965" translate="yes" xml:space="preserve">
          <source>Demo</source>
          <target state="translated">Demo</target>
        </trans-unit>
        <trans-unit id="0298196b206bc7b4a96725653dbc77fafc2e7815" translate="yes" xml:space="preserve">
          <source>Do Not Always Set To &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">并不总是设置为 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e813a63a91f53696f818ac595a5fddc09cb30338" translate="yes" xml:space="preserve">
          <source>Don't &lt;code&gt;delete&lt;/code&gt; from an array. Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead.</source>
          <target state="translated">不要从数组中 &lt;code&gt;delete&lt;/code&gt; 。 请改用 &lt;code&gt;Array.prototype.splice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cff8f35d333fc23fef816a20f879c35c001ee7e" translate="yes" xml:space="preserve">
          <source>Due to the dynamic nature of JavaScript there are often cases where you simply don't know if the property exists or not. Checking if obj exists before the &amp;amp;&amp;amp; also makes sure you don't throw an error due to calling the hasOwnProperty() function on an undefined object.</source>
          <target state="translated">由于JavaScript的动态特性，通常在某些情况下您根本不知道该属性是否存在。 检查obj在&amp;amp;&amp;amp;之前是否存在，还可以确保您不会由于未定义对象上调用hasOwnProperty（）函数而引发错误。</target>
        </trans-unit>
        <trans-unit id="f30ca853155d96f4ff4a7523ad41da4989438529" translate="yes" xml:space="preserve">
          <source>E.g</source>
          <target state="translated">E.g</target>
        </trans-unit>
        <trans-unit id="48886c6e98adf5c4a9c9282a2441dfe3015faacb" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (or ES6) came with built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt; object. It is possible to delete object property by calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty()&lt;/a&gt; function with target object and property key as parameters:</source>
          <target state="translated">ECMAScript 2015（或ES6）带有内置的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt;对象。 可以通过使用目标对象和属性键作为参数调用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty（）&lt;/a&gt;函数来删除对象属性：</target>
        </trans-unit>
        <trans-unit id="4c2dbb36a3a214bec101207bfb72cd18b86e453e" translate="yes" xml:space="preserve">
          <source>Each one has it's own pros and cons (&lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;check this performance comparison&lt;/a&gt;):</source>
          <target state="translated">每个人都有自己的优缺点（ &lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;请检查此性能比较&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="5cb7b7c35055238b90a33971ff368cff01dd0bbb" translate="yes" xml:space="preserve">
          <source>For anyone interested in reading more about it, Stack Overflow user &lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt; has written an incredibly in-depth blog post about the &lt;code&gt;delete&lt;/code&gt; statement on their blog, &lt;em&gt;&lt;a href=&quot;http://perfectionkills.com/understanding-delete/&quot;&gt;Understanding delete&lt;/a&gt;&lt;/em&gt;. It is highly recommended.</source>
          <target state="translated">对于任何有兴趣阅读更多内容的人，Stack Overflow用户&lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt;都写了一篇非常深入的博客文章，关于其博客上的 &lt;code&gt;delete&lt;/code&gt; 语句，&amp;ldquo; &lt;em&gt;&lt;a href=&quot;http://perfectionkills.com/understanding-delete/&quot;&gt;了解删除&amp;rdquo;&lt;/a&gt;&lt;/em&gt; 。 强烈建议。</target>
        </trans-unit>
        <trans-unit id="7de0c8678ad3582ef48a786c2a12849c95f613d2" translate="yes" xml:space="preserve">
          <source>For arrays, &lt;code&gt;_.filter()&lt;/code&gt; and &lt;code&gt;_.reject()&lt;/code&gt; can be used in a similar manner.</source>
          <target state="translated">对于数组，可以类似的方式使用 &lt;code&gt;_.filter()&lt;/code&gt; 和 &lt;code&gt;_.reject()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae20664549d9e3ccd77991be79f76a86f10d159f" translate="yes" xml:space="preserve">
          <source>For example, say you are creating a webapp that uses JSON-serialization to store an array used for 'tabs' in a string (in this case, &lt;code&gt;localStorage&lt;/code&gt;). Let's also say that the code uses the numerical indices of the array's members to &quot;title&quot; them when drawing to the screen. Why are you doing this rather than just storing the &quot;title&quot; as well? Because... &lt;em&gt;reasons&lt;/em&gt;.</source>
          <target state="translated">例如，假设您正在创建一个使用JSON序列化的Web应用程序，以将用于&amp;ldquo;选项卡&amp;rdquo;的数组存储在字符串中（本例中为 &lt;code&gt;localStorage&lt;/code&gt; ）。 我们还说，代码在绘制到屏幕时使用数组成员的数字索引为它们&amp;ldquo;添加标题&amp;rdquo;。 您为什么要这样做，而不仅仅是存储&amp;ldquo;标题&amp;rdquo;？ 因为... &lt;em&gt;原因&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="cdad74d0486512dc3bc4f850907cd467e5fc5e3c" translate="yes" xml:space="preserve">
          <source>For more info about and seeing more example, visit the link below:</source>
          <target state="translated">欲了解更多信息和查看更多示例,请访问下面的链接。</target>
        </trans-unit>
        <trans-unit id="3053a4eaab6ecc9daa630f23887af0a663b64dcc" translate="yes" xml:space="preserve">
          <source>Functions which are part of an object (apart from the</source>
          <target state="translated">作为对象的一部分的函数(除了</target>
        </trans-unit>
        <trans-unit id="a355b0b1f78d396cf69cf859538e8172e1e8345c" translate="yes" xml:space="preserve">
          <source>Hello You Can try this simple an sort</source>
          <target state="translated">你好,你可以试试这个简单的排序</target>
        </trans-unit>
        <trans-unit id="ca27c0a83d24961b91d263af64d922d82a55909c" translate="yes" xml:space="preserve">
          <source>Honestly, aside from setting to &lt;code&gt;null&lt;/code&gt; rather than &lt;code&gt;undefined&lt;/code&gt;--which is legitimately weird--this behavior &lt;em&gt;shouldn't&lt;/em&gt; be surprising, since &lt;code&gt;delete&lt;/code&gt; is a unary operator, like &lt;code&gt;typeof&lt;/code&gt;, that is hard-boiled into the language and is not supposed to care about the &lt;em&gt;type&lt;/em&gt; of object it's being used on, whereas &lt;code&gt;Array&lt;/code&gt; is a subclass of &lt;code&gt;Object&lt;/code&gt; with methods &lt;em&gt;specifically designed for&lt;/em&gt; working with arrays. So there's no good reason for &lt;code&gt;delete&lt;/code&gt; to have a special case cooked in for re-shifting the array, as that would just slow things down with unnecessary work. In retrospect, my expectations were unrealistic.</source>
          <target state="translated">坦白地说，除了设置为 &lt;code&gt;null&lt;/code&gt; 而不是 &lt;code&gt;undefined&lt;/code&gt; （这确实很奇怪）之外，这种行为也就不足为奇了，因为 &lt;code&gt;delete&lt;/code&gt; 是一元运算符，例如 &lt;code&gt;typeof&lt;/code&gt; ，它被硬化到语言中并且不应该在意关于它所使用的对象的&lt;em&gt;类型&lt;/em&gt; ，而 &lt;code&gt;Array&lt;/code&gt; 是 &lt;code&gt;Object&lt;/code&gt; 的子类，其对象 &lt;em&gt;专门用于&lt;/em&gt;处理数组。 因此，没有充分的理由 &lt;code&gt;delete&lt;/code&gt; 来准备特殊情况以重新移动阵列，因为那样只会因不必要的工作而减慢速度。 回想起来，我的期望是不现实的。</target>
        </trans-unit>
        <trans-unit id="dc3989e98834042a9457a0de8b90b5c9f3024f13" translate="yes" xml:space="preserve">
          <source>How do I remove a property from a JavaScript object</source>
          <target state="translated">如何从JavaScript对象中删除一个属性?</target>
        </trans-unit>
        <trans-unit id="b47475af69db5ae110b477abd31ec35a3c7d497a" translate="yes" xml:space="preserve">
          <source>However, be mindful! Do not suddenly start doing this with all your preexisting code now as it would likely break such preexisting code and/or introduce strange bugs. Rather, such an efficient practice needs to be implemented from the start, and when converting preexisting code, it is recommended that you double, triple, quadruple check all the lines relating to that as trying to upgrade old code to this new practice can be as risky as it is rewarding.</source>
          <target state="translated">但是,要注意!不要突然开始对所有已经存在的代码进行这样的操作。不要突然开始对你所有的预存代码进行这样的操作,因为这样做很可能会破坏这样的预存代码,或者引入奇怪的bug。相反,这种有效的做法需要从一开始就开始实施,在转换之前已经存在的代码时,建议你对所有与之相关的行进行两遍、三遍、四遍的检查,因为试图将旧的代码升级到这个新的做法可能会有很大的风险,也会有很大的收获。</target>
        </trans-unit>
        <trans-unit id="491f0bae14ec381e286ea282ba5b10bae8f240b9" translate="yes" xml:space="preserve">
          <source>However, it will &lt;strong&gt;mutate&lt;/strong&gt; the original object. If you want to create a new object &lt;strong&gt;without&lt;/strong&gt; the specified key, just assign the reduce function to a new variable, e.g.:</source>
          <target state="translated">但是，它将&lt;strong&gt;变异&lt;/strong&gt;原始对象。 如果要创建&lt;strong&gt;没有&lt;/strong&gt;指定键的新对象，只需将reduce函数分配给新变量，例如：</target>
        </trans-unit>
        <trans-unit id="b18c3a88c501a6c91766f406a1e129e6aaa98cea" translate="yes" xml:space="preserve">
          <source>However, there are two major unfixable problems with polymorphic arrays:</source>
          <target state="translated">然而,多态数组有两大无法解决的问题。</target>
        </trans-unit>
        <trans-unit id="3486394d0c7c983de3c5268328e537d9b15cb8f7" translate="yes" xml:space="preserve">
          <source>However, this code:</source>
          <target state="translated">然而,这个代码。</target>
        </trans-unit>
        <trans-unit id="4a71f7845929b0f0df07acdfaf7d379b182e9259" translate="yes" xml:space="preserve">
          <source>I feel it's important to point out the difference between these two similarly-named functions, as they are both very useful.</source>
          <target state="translated">我觉得有必要指出这两个同名功能的区别,因为这两个同名功能都很有用。</target>
        </trans-unit>
        <trans-unit id="459a68f17b246b077cb24b6614e54636e1f0783c" translate="yes" xml:space="preserve">
          <source>I personally use &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; or &lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt; for object and array manipulation:</source>
          <target state="translated">我个人使用&lt;a href=&quot;https://lodash.com&quot;&gt;Underscore.js&lt;/a&gt;或Lodash进行对象和数组操作：</target>
        </trans-unit>
        <trans-unit id="a8613a5b1880d971e632b3352e4bfe554f971c46" translate="yes" xml:space="preserve">
          <source>If a property with the same name exists on the object's prototype
  chain, then, after deletion, the object will use the property from the
  prototype chain (in other words, delete only has an effect on own
  properties).</source>
          <target state="translated">如果对象的原型链上存在同名的属性,那么删除后,该对象将使用原型链中的属性(换句话说,删除只对自己的属性有影响)。</target>
        </trans-unit>
        <trans-unit id="1e20c9e61654d816a6093dde8b64312b7bd4779b" translate="yes" xml:space="preserve">
          <source>If the property which you are trying to delete does not exist, delete
  will not have any effect and will return true</source>
          <target state="translated">如果您要删除的属性不存在,删除将没有任何效果,并返回true。</target>
        </trans-unit>
        <trans-unit id="28ec183a3184d93a675028a4e725a85c94f1f649" translate="yes" xml:space="preserve">
          <source>If you do not know the index, you'll also have to do an index search:</source>
          <target state="translated">如果你不知道索引,也要做一个索引查询。</target>
        </trans-unit>
        <trans-unit id="3204a3a58282102b99263134aa04e4bbd9031c97" translate="yes" xml:space="preserve">
          <source>If you do:</source>
          <target state="translated">如果你有的话。</target>
        </trans-unit>
        <trans-unit id="3204f4d5aa25757c4ed3063f2b869d5fde0626d5" translate="yes" xml:space="preserve">
          <source>If you know the index of your staff member, you could simply do this:</source>
          <target state="translated">如果你知道你的工作人员的指数,你可以简单地这样做。</target>
        </trans-unit>
        <trans-unit id="9b546f76f9301b299e7ed78305baf0ef1addfe1c" translate="yes" xml:space="preserve">
          <source>If you want to delete a property deeply nested in the object then you can use the following recursive function with path to the property as the second argument:</source>
          <target state="translated">如果你想删除一个深嵌套在对象中的属性,那么你可以使用下面的递归函数,并将该属性的路径作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="506bf20b873a7a4cd476c438c371ecd4bcca65fc" translate="yes" xml:space="preserve">
          <source>If you want to experiment with this, you can use &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt; as a starting point.</source>
          <target state="translated">如果您想尝试一下，可以使用&lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;此小提琴&lt;/strong&gt;&lt;/a&gt;作为起点。</target>
        </trans-unit>
        <trans-unit id="a4e72696da1b895cd7644dbb4f08034ae76c1836" translate="yes" xml:space="preserve">
          <source>If you want to use the entire &lt;code&gt;staff&lt;/code&gt; array, the proper way to do this, would be to do this:</source>
          <target state="translated">如果要使用整个 &lt;code&gt;staff&lt;/code&gt; 数组，执行此操作的正确方法是：</target>
        </trans-unit>
        <trans-unit id="43cf8d099321d601790e8b3431ad74fdf17809c0" translate="yes" xml:space="preserve">
          <source>Ignoring the dangers and problems inherent in &lt;code&gt;null&lt;/code&gt;, and the space wasted, this can be problematic if the array needs to be precise.</source>
          <target state="translated">忽略 &lt;code&gt;null&lt;/code&gt; 固有的危险和问题以及浪费的空间，如果数组需要精确，则可能会出现问题。</target>
        </trans-unit>
        <trans-unit id="c138b726889b4f8045cc8db17ba22f8faa709ac8" translate="yes" xml:space="preserve">
          <source>In addition, while mutating objects in-place isn't stateless, you can use the functional nature of &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; to do partial application and other functional techniques that aren't possible with &lt;code&gt;delete&lt;/code&gt; statements.</source>
          <target state="translated">此外，尽管就地改变对象不是无状态的，但您可以使用 &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; 的功能性质来执行部分应用程序和其他 &lt;code&gt;delete&lt;/code&gt; 语句无法实现的功能技术。</target>
        </trans-unit>
        <trans-unit id="5b114aff6680bfc75db078ff75477b94c1c576aa" translate="yes" xml:space="preserve">
          <source>In arrays, unlike plain old objects, using &lt;code&gt;delete&lt;/code&gt; leaves behind garbage in the form of &lt;code&gt;null&lt;/code&gt;, creating a &quot;hole&quot; in the array.</source>
          <target state="translated">在数组中，与普通的旧对象不同，使用 &lt;code&gt;delete&lt;/code&gt; 会以 &lt;code&gt;null&lt;/code&gt; 的形式在垃圾后面留下垃圾，从而在数组中创建一个&amp;ldquo;洞&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="acf20d554a4832d04b9fb4c2dfc6cc9d34eda721" translate="yes" xml:space="preserve">
          <source>In the code above, simply doing &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; will cause a massive memory leak because each animation frame. Each frame, all 65536 DOM elements will take up another 65536 individual slots, but the previous 65536 slots will only be set to undefined which leaves them hanging in the memory. Go ahead, try to run the above code in the console and see for yourself. After forcing an out-of-memory error, attempt to run it again except with the following version of the code that uses the &lt;code&gt;delete&lt;/code&gt; operator instead.</source>
          <target state="translated">在上面的代码中，只需执行 &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; 因为每个动画帧都会导致大量内存泄漏。 每帧，所有65536个DOM元素将占用另一个65536个单独的插槽，但是以前的65536个插槽将仅被设置为undefined，这会使它们挂在内存中。 继续，尝试在控制台中运行以上代码并亲自查看。 强制执行内存不足错误后，请尝试再次运行它，但以下版本的代码使用 &lt;code&gt;delete&lt;/code&gt; 运算符代替。</target>
        </trans-unit>
        <trans-unit id="271f117734d63131f8d6a45f399a766357be7419" translate="yes" xml:space="preserve">
          <source>Increasingly stupid edge-case scenario aside, using &lt;code&gt;delete&lt;/code&gt; on said array will result in &lt;code&gt;null&lt;/code&gt; polluting the array, and probably causing bugs in the app later on. And if you check for &lt;code&gt;null&lt;/code&gt;, it would straight up skip the numbers resulting in the tabs being rendered like &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt;.</source>
          <target state="translated">除了越来越愚蠢的边缘情况之外，在所述阵列上使用 &lt;code&gt;delete&lt;/code&gt; 将导致 &lt;code&gt;null&lt;/code&gt; 污染阵列，并可能稍后导致应用程序中的错误。 并且，如果您检查是否为 &lt;code&gt;null&lt;/code&gt; ，它将直接跳过数字，从而导致制表符像 &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt; 那样呈现。</target>
        </trans-unit>
        <trans-unit id="67a2e0451ade99e58384dc55f1327e29e5977c70" translate="yes" xml:space="preserve">
          <source>It &lt;strong&gt;deletes the key from the hashmap&lt;/strong&gt;.</source>
          <target state="translated">它&lt;strong&gt;从哈希图中删除密钥&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="593fba807066e533a5fe4a2443019f46d7ca31da" translate="yes" xml:space="preserve">
          <source>JavaScript is an OOP Language, so everything is an object, including &lt;em&gt;arrays&lt;/em&gt;. Thus, I feel it necessary to point out a particular caveat.</source>
          <target state="translated">JavaScript是一种OOP语言，因此一切都是对象，包括&lt;em&gt;arrays&lt;/em&gt; 。 因此，我觉得有必要指出一个特别的警告。</target>
        </trans-unit>
        <trans-unit id="b86b332c3f3aa1433f370f7189813a6381eb2178" translate="yes" xml:space="preserve">
          <source>Library-based property omission</source>
          <target state="translated">基于图书馆的财产遗漏</target>
        </trans-unit>
        <trans-unit id="59b86486aed4edafd59a372a9da15c32460385f0" translate="yes" xml:space="preserve">
          <source>Like this:</source>
          <target state="translated">就像这样。</target>
        </trans-unit>
        <trans-unit id="23ee237b458378f4f66052abb7c903c28cbb18e4" translate="yes" xml:space="preserve">
          <source>Look at the &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;benchmark&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">看&lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;基准&lt;/a&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0447456284f7feabbe03be15bd344b6f319890b" translate="yes" xml:space="preserve">
          <source>Luckily, arrays &lt;em&gt;do&lt;/em&gt; have a specialized method for deleting indices and reallocating memory: &lt;code&gt;Array.prototype.splice()&lt;/code&gt;. You could write something like this:</source>
          <target state="translated">幸运的是，数组&lt;em&gt;确实&lt;/em&gt;具有删除索引和重新分配内存的专用方法： &lt;code&gt;Array.prototype.splice()&lt;/code&gt; 。 您可以这样写：</target>
        </trans-unit>
        <trans-unit id="098d9f24825c866c84675902efcb46bcadb54327" translate="yes" xml:space="preserve">
          <source>More than 2X faster than &lt;code&gt;delete&lt;/code&gt;, however the property is &lt;strong&gt;not&lt;/strong&gt; deleted and can be iterated.</source>
          <target state="translated">比 &lt;code&gt;delete&lt;/code&gt; 快2倍以上，但是&lt;strong&gt;不会&lt;/strong&gt;删除该属性，并且可以对其进行迭代。</target>
        </trans-unit>
        <trans-unit id="ccc762c5d3373bf8a3cde8b635c9825605d01c63" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, safe</source>
          <target state="translated">突变对象属性删除,安全</target>
        </trans-unit>
        <trans-unit id="9ce68ac5a3111b339ada2a12dd8cc6eea0e45ffa" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, unsafe</source>
          <target state="translated">突变对象属性删除,不安全</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="089de7283699cfb1ed6d519cb14e7b0cf6326b5b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;_.pick()&lt;/code&gt; and &lt;code&gt;_.omit()&lt;/code&gt; both return a copy of the object and don't directly modify the original object. Assigning the result to the original object should do the trick (not shown).</source>
          <target state="translated">请注意， &lt;code&gt;_.pick()&lt;/code&gt; 和 &lt;code&gt;_.omit()&lt;/code&gt; 都返回对象的副本，并且不直接修改原始对象。 将结果分配给原始对象应该可以解决这个问题（未显示）。</target>
        </trans-unit>
        <trans-unit id="74d18dd16f1da3ac16685fb7e2b20e82dd3d4708" translate="yes" xml:space="preserve">
          <source>Note that I purposedly carried out more than one 'delete' operations in one loop cycle to minimize the effect caused by the other operations.</source>
          <target state="translated">注意,我特意在一个循环周期内进行了多个 &quot;删除 &quot;操作,以减少其他操作造成的影响。</target>
        </trans-unit>
        <trans-unit id="cbc78d0538f8d0b1ea57d6e615c0173c54cc2f85" translate="yes" xml:space="preserve">
          <source>Note that the wrapper function is designed to be very strict about types, and will return &lt;code&gt;null&lt;/code&gt; if anything is off. That includes putting in a string like &lt;code&gt;&quot;3&quot;&lt;/code&gt;. It is left up to the programmer to be diligent about his types. This is to encourage good programming practice.</source>
          <target state="translated">请注意，包装函数的类型非常严格，如果禁用任何内容，则返回 &lt;code&gt;null&lt;/code&gt; 。 这包括放入类似 &lt;code&gt;&quot;3&quot;&lt;/code&gt; 的字符串。 程序员要勤于自己的类型。 这是为了鼓励良好的编程习惯。</target>
        </trans-unit>
        <trans-unit id="0cd1e1c286ff1b960d2aa87f0e85fe9bd6a35fdd" translate="yes" xml:space="preserve">
          <source>Now, if you want to remove a single staff member or student, the procedure is a bit different, because both properties are arrays themselves.</source>
          <target state="translated">现在,如果你想删除单个教职工或学生,过程就有点不同了,因为这两个属性本身就是数组。</target>
        </trans-unit>
        <trans-unit id="e14273e8bb73415bec8db17e1b9d548211a7aed0" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;could&lt;/em&gt; keep a second iterator, like &lt;code&gt;j&lt;/code&gt;, to increment only when valid values are read from the array. But that wouldn't exactly solve the &lt;code&gt;null&lt;/code&gt; issue, and you still have to please that &lt;s&gt;troll&lt;/s&gt; PDP-11 user. Alas, his computer just &lt;em&gt;doesn't&lt;/em&gt; have enough memory to hold that last integer &lt;sub&gt;(don't ask how he manages to handle a variable-width array...)&lt;/sub&gt;.</source>
          <target state="translated">现在，您&lt;em&gt;可以&lt;/em&gt;保留第二个迭代器，如 &lt;code&gt;j&lt;/code&gt; ，仅在从数组中读取有效值时才递增。 但这并不能完全解决 &lt;code&gt;null&lt;/code&gt; 问题，您仍然必须请那个&lt;s&gt;巨魔&lt;/s&gt; PDP-11用户使用。 las，他的计算机&lt;em&gt;没有&lt;/em&gt;足够的内存来容纳最后一个整数&lt;sub&gt;（不要问他如何处理可变宽度数组...）&lt;/sub&gt; 。</target>
        </trans-unit>
        <trans-unit id="e28b55f542be9cce84f1cc3f1bdb29e2a2eb72e0" translate="yes" xml:space="preserve">
          <source>Object.assign() &amp;amp; Object.keys() &amp;amp; Array.map()</source>
          <target state="translated">Object.assign（）和Object.keys（）和Array.map（）</target>
        </trans-unit>
        <trans-unit id="c643fe374f1dfb8aa281ee046c5ea254b1b7b942" translate="yes" xml:space="preserve">
          <source>Observe. &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; does not coerce polymorphism whereas &lt;code&gt;bar[1] = undefined&lt;/code&gt; does. Therefore, one should always, whenever possible use the corresponding type for their objects so as to not accidentally cause polymorphism. One such person may use the following list as a general reference to get them going. However, please do not explicitly use the below ideas. Instead, use whatever works well for your code.</source>
          <target state="translated">观察一下。 &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; 不会强制多态性，而 &lt;code&gt;bar[1] = undefined&lt;/code&gt; 可以。 因此，应该始终尽可能地为其对象使用相应的类型，以免偶然导致多态。 一个这样的人可以使用以下列表作为一般参考，以使他们继续前进。 但是，请不要明确使用以下想法。 相反，请使用适用于您代码的任何方法。</target>
        </trans-unit>
        <trans-unit id="e583eed26b5bb4eb2fe3ea98e3d4481f60fbfae9" translate="yes" xml:space="preserve">
          <source>Of course, it &lt;em&gt;did&lt;/em&gt; surprise me. Because I wrote this to justify my crusade against &quot;null garbage&quot;:</source>
          <target state="translated">当然，这&lt;em&gt;确实&lt;/em&gt;让我感到惊讶。 因为我写这是为了证明我的运动反对&amp;ldquo;空垃圾&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="9d008b07517f4d9dbae6df29270e3dfc66dcea5d" translate="yes" xml:space="preserve">
          <source>Okay, let's just say that you're trying to save memory at the request of this &lt;em&gt;one&lt;/em&gt; user who runs a PDP-11 minicomputer from the 1960's running UNIX and wrote his own Elinks-based, JavaScript-compliant, line-printer-friendly browser because X11 is &lt;em&gt;out of the question&lt;/em&gt;.</source>
          <target state="translated">好的，我们只是说，您正在尝试根据一位运行1960年代运行UNIX的PDP-11微型计算机的用户的请求来节省内存，并编写了自己的基于Elinks，JavaScript兼容，对行打印机友好的浏览器因为X11是不可能&lt;em&gt;的&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="0746b7ec72e10adab007597141d3dddd2450c60e" translate="yes" xml:space="preserve">
          <source>Old question, modern answer. Using object destructuring, an &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript&amp;nbsp;6&lt;/a&gt; feature, it's as simple as:</source>
          <target state="translated">旧问题，现代答案。 使用对象分解（ &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6&lt;/a&gt;功能），它很简单：</target>
        </trans-unit>
        <trans-unit id="88891f47a253aa57bb1cb91937b9715b281db53b" translate="yes" xml:space="preserve">
          <source>Once polymorphic, always polymorphic. When an array is made polymorphic, the polymorphism cannot be undone in Webkit browsers. So, even if you restore a polymorphic array to being non-polymorphic, it will still be stored by the browser as a polymorphic array.</source>
          <target state="translated">一旦多态化,就永远是多态化。当一个数组被多态化后,在Webkit浏览器中无法撤销多态化。因此,即使你将一个多态化的数组恢复为非多态化,它仍然会被浏览器作为多态化数组存储。</target>
        </trans-unit>
        <trans-unit id="b248f1b8652c2d4ab474434fceed81458cb94383" translate="yes" xml:space="preserve">
          <source>Once those four queries have been answered, there are essentially four categories of &quot;property removal&quot; in JavaScript to chose from in order to meet your goals. They are:</source>
          <target state="translated">在回答了这四个问题之后,基本上有四类 &quot;属性删除 &quot;JavaScript中的 &quot;属性删除 &quot;可以选择,以满足你的目标。它们分别是。</target>
        </trans-unit>
        <trans-unit id="547c95266578e4dba22f41101c7fbe880f75e156" translate="yes" xml:space="preserve">
          <source>One aspect of Javascript that is important to consider is polymorphism. Polymorphism is when assigning the same variable/slot-in-an-object different types as seen below.</source>
          <target state="translated">Javascript中需要考虑的一个方面是多态性。多态性是当分配相同的变量lot-in-an-object不同的类型时,如下图所示。</target>
        </trans-unit>
        <trans-unit id="d59804a9108998189135354633d8b85aa6ac9872" translate="yes" xml:space="preserve">
          <source>One may liken polymorphism to a drug addiction. At first glance, it seems awesomely lucrative: nice pretty fluffy code. Then, the coder introduces their array to the drug of polymorphism. Instantly, the polymorphic array becomes less efficient, and it can never become as efficient as it was before since it is drugged. To correlate such circumstance to real life, someone on cocaine might not even be capable of operating a simple door handle, much less be able to calculate digits of PI. Likewise, an array on the drug of polymorphism cannot ever be as efficient as a monomorphic array.</source>
          <target state="translated">有人可能会把多态性比喻为吸毒成瘾。乍看之下,它似乎非常有利可图:漂亮漂亮的蓬松的代码。然后,编码员将他们的数组引入到多态化的毒品中。瞬间,多态数组的效率就会变得很低,自从被下药后,它的效率就再也无法像以前那样高了。将这样的情况与现实生活联系起来,一个人吸食了可卡因,可能连简单的门把手都无法操作,更不用说能够计算出PI的数字了。同样的,多态性的药物上的阵列也不可能像单态性的阵列那样高效。</target>
        </trans-unit>
        <trans-unit id="81ec1a879d1bcac8eaeb3bcd6cca8f51d459b6e9" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;delete&lt;/code&gt; is unexpectedly slow!</source>
          <target state="translated">操作员 &lt;code&gt;delete&lt;/code&gt; 异常缓慢！</target>
        </trans-unit>
        <trans-unit id="b0213d049275e53829195e4fb176386bc570f98e" translate="yes" xml:space="preserve">
          <source>Or add it as a new pointer to another object like:</source>
          <target state="translated">或者将其作为一个新的指针添加到另一个对象,如。</target>
        </trans-unit>
        <trans-unit id="b02fc9813af3fdbb140c9b950f4bb96861bf726a" translate="yes" xml:space="preserve">
          <source>Or with the questions sample:</source>
          <target state="translated">或带着问题的样本。</target>
        </trans-unit>
        <trans-unit id="e9b0d0e32654faf6fc06ca2ce8663172c501d507" translate="yes" xml:space="preserve">
          <source>Or you can also use array-like notation:</source>
          <target state="translated">或者你也可以使用类似数组的记号法。</target>
        </trans-unit>
        <trans-unit id="040435ad5191a6323d4b61a949b35014d90fb332" translate="yes" xml:space="preserve">
          <source>Or you can dynamically exclude properties like this,</source>
          <target state="translated">或者你可以像这样动态排除属性。</target>
        </trans-unit>
        <trans-unit id="a7ca816fcb165b225c5a6969cca6cd3afa101c70" translate="yes" xml:space="preserve">
          <source>Properties can be removed using &lt;strong&gt;destructuring&lt;/strong&gt; in combination with the &lt;strong&gt;rest operator&lt;/strong&gt;. In your example regex is destructured out (ignored) and the rest of the properties are returned as rest.</source>
          <target state="translated">可以通过与&lt;strong&gt;rest运算符&lt;/strong&gt;结合使用&lt;strong&gt;分解&lt;/strong&gt;来删除属性。 在您的示例中，正则表达式被解构（忽略），其余属性作为其余部分返回。</target>
        </trans-unit>
        <trans-unit id="257bb222f1c06e8c1d8edf559d64e06deb75f2f0" translate="yes" xml:space="preserve">
          <source>Property Removal in JavaScript</source>
          <target state="translated">JavaScript中的属性移除</target>
        </trans-unit>
        <trans-unit id="83a4727bcff27e1d95598a97b2a871336f59a8c8" translate="yes" xml:space="preserve">
          <source>Readable and short, however, it might not be the best choice if you are operating on a large number of objects as its performance is not optimized.</source>
          <target state="translated">可读性强,时间短,但是,如果你在操作大量的对象时,它可能不是最好的选择,因为它的性能没有得到优化。</target>
        </trans-unit>
        <trans-unit id="ce7827682ca4a098e50c7905bb13aa7c7e60006c" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt;.</source>
          <target state="translated">参考： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f02218cedd8e4fd7e585302dc05d8d0a5833d5f0" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.omit(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">参考： &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.omit（object，* keys）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a3c1aeff97f5a6d2ba0a975a623e96c949b36be" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.pick(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">参考： &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;链接&lt;/a&gt; &lt;strong&gt;_.pick（object，* keys）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5817e749619edf322d60f85b86cab9c7f83094af" translate="yes" xml:space="preserve">
          <source>Rest-based string property omission</source>
          <target state="translated">基于休息的字符串属性省略</target>
        </trans-unit>
        <trans-unit id="ab303515578a450fdf614933afe415b6528c01d1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to omit the 
blacklisted keys (or array of keys).</source>
          <target state="translated">返回一个对象的副本,通过过滤来省略黑名单中的密钥(或密钥数组)。</target>
        </trans-unit>
        <trans-unit id="011a1cad4539d30348ba24adcd37dceade1f93c1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to only have values for the 
whitelisted keys (or array of valid keys).</source>
          <target state="translated">返回一个对象的副本,过滤后仅有白键(或有效键数组)的值。</target>
        </trans-unit>
        <trans-unit id="650045349baef87a1fa74815eb1e6653f73e4e45" translate="yes" xml:space="preserve">
          <source>Say I create an object as follows:</source>
          <target state="translated">说我创建一个对象如下:</target>
        </trans-unit>
        <trans-unit id="f5d2829fcf8f71f8331358342fe9021d00422606" translate="yes" xml:space="preserve">
          <source>Setting a property to null before deleting it doesn't accomplish
  anything (unless the object has been sealed by Object.seal and the
  delete fails. That's not usually the case unless you specifically
  try).</source>
          <target state="translated">在删除之前将属性设置为null并没有什么效果(除非对象已经被Object.seal封印,并且删除失败。除非你特别尝试,否则通常不会出现这种情况)。)</target>
        </trans-unit>
        <trans-unit id="a1aeff6040cbaf4a052232c94541c2b536b4a1f3" translate="yes" xml:space="preserve">
          <source>Similarly, removing the entire students array would be done by calling &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; or &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt;.</source>
          <target state="translated">同样，删除整个学生数组可以通过调用 &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; 来完成。 或 &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd410e78d809f27ec1e3bdad4ee5576324a4212e" translate="yes" xml:space="preserve">
          <source>So as it turns out, there actually IS a built-in way to tell if an array is truly an array, and that is &lt;code&gt;Array.isArray()&lt;/code&gt;, introduced in ECMAScript 5 (December 2009). I found this while looking to see if there was a question asking about telling arrays from objects, to see if there was either a better solution than mine, or to add mine if there were none. So, if you're using a version of JavaScript that is earlier than ECMA 5, there's your polyfill. However, I strongly recommend against using my &lt;code&gt;is_array()&lt;/code&gt; function, as continuing to support old versions of JavaScript means continuing to support the old browsers that implement them, which means encouraging the use of insecure software and putting users at risk for malware. So please, use &lt;code&gt;Array.isArray()&lt;/code&gt;. Use &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Use the new features that get added to the language. &lt;em&gt;Don't&lt;/em&gt; use vendor prefixes. &lt;em&gt;Delete&lt;/em&gt; that IE polyfill crap from your website. Delete that XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; crap, too--we moved to HTML5 back in 2014. The sooner everybody withdraws support for those old/esoteric browsers, the sooner the browser vendors will actually follow the web standard and embrace the new technology, and the sooner we can move on to a more secure web.</source>
          <target state="translated">事实证明，实际上存在一种内置方法来判断数组是否真正是数组，这就是ECMAScript 5（2009年12月）中引入的 &lt;code&gt;Array.isArray()&lt;/code&gt; ）。 我在寻找是否有一个问题来询问对象数组时发现了这个问题，以查看是否有比我的更好的解决方案，或者是否有没有比我的更好的解决方案。 因此，如果使用的JavaScript版本早于ECMA 5，则可以使用polyfill。 但是，我强烈建议您不要使用 &lt;code&gt;is_array()&lt;/code&gt; 函数，因为继续支持旧版本的JavaScript意味着继续支持实现旧版本JavaScript的浏览器，这意味着鼓励使用不安全的软件，并使用户面临恶意软件的风险。 因此，请使用 &lt;code&gt;Array.isArray()&lt;/code&gt; 。 使用 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 。 使用添加到该语言的新功能。 &lt;em&gt;不要&lt;/em&gt;使用供应商前缀。 从您的网站中&lt;em&gt;删除&lt;/em&gt;该IE polyfill废话。 删除XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; 废话，也废话了&amp;ndash;我们在2014年改用了HTML5。新技术，因此我们可以尽快进入更安全的网络。</target>
        </trans-unit>
        <trans-unit id="c1074a68b7264ece395e8476f70ae784fc36b406" translate="yes" xml:space="preserve">
          <source>So, he sends you an email in anger:</source>
          <target state="translated">所以,他生气地给你发了一封邮件。</target>
        </trans-unit>
        <trans-unit id="1c63c8fdc7a32a45814f6f70f31838cecabdb16b" translate="yes" xml:space="preserve">
          <source>So, when deleting values from an object, always first consider whether you're dealing with object properties or whether you're dealing with array values, and choose the appropriate strategy based on that.</source>
          <target state="translated">所以,在删除对象中的值时,一定要先考虑你是在处理对象的属性,还是在处理数组的值,并根据这一点选择合适的策略。</target>
        </trans-unit>
        <trans-unit id="da5db28dd16264310f46eacb87a0cb2b9ceef675" translate="yes" xml:space="preserve">
          <source>Sorry if this didn't add to your specific use case but I believe this to be a good design to adapt when managing objects and their properties.</source>
          <target state="translated">如果这没有增加你的具体用例,很抱歉,但我相信这是一个很好的设计,可以在管理对象及其属性时进行调整。</target>
        </trans-unit>
        <trans-unit id="ace92799b8ad9dc2af653b95d2a4f16910423d4b" translate="yes" xml:space="preserve">
          <source>Suppose you have an object that looks like this:</source>
          <target state="translated">假设你有一个看起来像这样的对象。</target>
        </trans-unit>
        <trans-unit id="c5229642bf5961f2b277471727e88e647035ac9e" translate="yes" xml:space="preserve">
          <source>Syntax-based string property omission</source>
          <target state="translated">基于语法的字符串属性省略</target>
        </trans-unit>
        <trans-unit id="07c468c127104c88b077c6e07b9d9ec7d4fdbf7d" translate="yes" xml:space="preserve">
          <source>THE LONG VERSION</source>
          <target state="translated">长篇</target>
        </trans-unit>
        <trans-unit id="11405ca028271229b8731c4ce6c20d04dc54cc92" translate="yes" xml:space="preserve">
          <source>THE SHORT VERSION</source>
          <target state="translated">简略版</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="748beb2ad7204d2997b5d2a12f2e0bc89bcc8e5e" translate="yes" xml:space="preserve">
          <source>That actually isn't what's happening, but it's easier to think of that way. According to MDN, here's what's actually happening:</source>
          <target state="translated">实际上不是这样的,但这样想起来比较容易。根据MDN的说法,实际情况是这样的。</target>
        </trans-unit>
        <trans-unit id="cf85fec62dde51f1637af10a625442c3baea4c48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt; is the best way to do so.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;删除运算符&lt;/a&gt;是最好的方法。</target>
        </trans-unit>
        <trans-unit id="881ea24ac20b3a2b7bbbd8208c871ee412db982f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;key remains on its place in the hashmap&lt;/strong&gt;, only the value is replaced with &lt;code&gt;undefined&lt;/code&gt;. Understand, that &lt;code&gt;for..in&lt;/code&gt; loop will still iterate over that key.</source>
          <target state="translated">&lt;strong&gt;键保留在哈希图中的位置&lt;/strong&gt; ，仅将值替换为 &lt;code&gt;undefined&lt;/code&gt; 。 可以理解， &lt;code&gt;for..in&lt;/code&gt; 循环仍会对该键进行迭代。</target>
        </trans-unit>
        <trans-unit id="edc38116420d64a21ebfee30ed9c7476267110df" translate="yes" xml:space="preserve">
          <source>The Solution: &lt;code&gt;Array.prototype.splice&lt;/code&gt;</source>
          <target state="translated">解决方案： &lt;code&gt;Array.prototype.splice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="071cbdf7a24a78eb243d7c493b80aadba4657908" translate="yes" xml:space="preserve">
          <source>The actual answer to the question</source>
          <target state="translated">实际回答这个问题</target>
        </trans-unit>
        <trans-unit id="c0ec14910cf4674ceea7f9ad991e964445d6c9ac" translate="yes" xml:space="preserve">
          <source>The answer would be to &lt;strong&gt;delete all the references you have in your code, pointed to that very object&lt;/strong&gt; and also &lt;strong&gt;not use &lt;code&gt;var&lt;/code&gt; statements to create new references to that object&lt;/strong&gt;. This last point regarding &lt;code&gt;var&lt;/code&gt; statements, is one of the most crucial issues that we are usually faced with, because using &lt;code&gt;var&lt;/code&gt; statements would prevent the created object from getting removed.</source>
          <target state="translated">答案是&lt;strong&gt;删除代码中指向该对象的所有引用，&lt;/strong&gt;并且&lt;strong&gt;不使用 &lt;code&gt;var&lt;/code&gt; 语句创建对该对象的新引用&lt;/strong&gt; 。 关于 &lt;code&gt;var&lt;/code&gt; 语句的最后一点是我们通常面临的最关键的问题之一，因为使用 &lt;code&gt;var&lt;/code&gt; 语句将阻止删除创建的对象。</target>
        </trans-unit>
        <trans-unit id="c25007fa1063a6b669074a068e8e0d9c200dbaad" translate="yes" xml:space="preserve">
          <source>The contrived and long-winded PDP-11 scenario</source>
          <target state="translated">迂回曲折的PDP-11计划方案</target>
        </trans-unit>
        <trans-unit id="f621835acbbff87822c037f614ae8feebd84f7e5" translate="yes" xml:space="preserve">
          <source>The delete operator removes a given property from an object. On
  successful deletion, it will return true, else false will be returned.
  However, it is important to consider the following scenarios:</source>
          <target state="translated">删除操作符将从一个对象中删除给定的属性。在成功删除时,它将返回true,否则将返回false。但是,必须考虑以下情况。</target>
        </trans-unit>
        <trans-unit id="88d438bbfeb05c4266f6e27b90dcb851c6f60ce6" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;deleteProperty&lt;/code&gt; is when using strict mode:</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 和 &lt;code&gt;deleteProperty&lt;/code&gt; 之间的区别在于使用严格模式时：</target>
        </trans-unit>
        <trans-unit id="efccd6cd704a79d07bccddefc3adbae94e968c39" translate="yes" xml:space="preserve">
          <source>The following snippet gives another simple example:</source>
          <target state="translated">下面的片段再举一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="bf8a2a946389853c6d0799bf61400c9d604dd48d" translate="yes" xml:space="preserve">
          <source>The index specified by &lt;code&gt;end&lt;/code&gt; is simply excluded from the slice. The parenthesized indices indicate what gets sliced. Either way, the behavior is not intuitive and it's bound to cause its fair share of off-by-one errors, so you might find it useful to make a wrapper function to more closely emulate the behavior of &lt;code&gt;.splice()&lt;/code&gt;:</source>
          <target state="translated">由 &lt;code&gt;end&lt;/code&gt; 指定的索引仅从切片中排除。 括号中的索引指示要切的内容。 无论哪种方式，行为都不是直观的，并且势必会造成一定比例的一次性错误，因此您可能会发现使包装函数更紧密地模拟 &lt;code&gt;.splice()&lt;/code&gt; 的行为很有用 ：</target>
        </trans-unit>
        <trans-unit id="367c08658a0eaac4d7f551272d9531077bdd6a38" translate="yes" xml:space="preserve">
          <source>The other important point here is to be careful about your other references to the same object. For instance, if you create a variable like:</source>
          <target state="translated">这里还有一点很重要,那就是要注意你对同一对象的其他引用。例如,如果你创建了一个像.....这样的变量。</target>
        </trans-unit>
        <trans-unit id="556ff37bb94e5cbb3dd116d5ddf709d4c4f7ed56" translate="yes" xml:space="preserve">
          <source>The programming ethos/patterns you and your team use. Do you favor functional approaches and mutation is verboten on your team, or do you employ wild west mutative object-oriented techniques?</source>
          <target state="translated">你和你的团队使用的编程伦理模式。在你的团队中,你是偏向于功能化的方法,禁止突变,还是采用西部突变的面向对象技术?</target>
        </trans-unit>
        <trans-unit id="6357292b24fba94284af6389041f255b8a00f04f" translate="yes" xml:space="preserve">
          <source>The range of object types you want to remove properties on and the type of property names you need to be able to omit (Strings only? Symbols? Weak references mapped from arbitrary objects? These have all been types of property pointers in JavaScript for years now)</source>
          <target state="translated">你要删除的对象类型范围,以及你需要省略的属性名称类型(只用字符串?符号?从任意对象中映射的弱引用?这些都是多年来JavaScript中的属性指针类型)。)</target>
        </trans-unit>
        <trans-unit id="3fea2fb86e2276224dff32e33243b1e22287ed2d" translate="yes" xml:space="preserve">
          <source>The reason for writing this new &lt;code&gt;unset&lt;/code&gt; function, is to keep the index of all other variables in this hash_map. Look at the following example, and see how the index of &quot;test2&quot; did not change after removing a value from the hash_map.</source>
          <target state="translated">编写此新的 &lt;code&gt;unset&lt;/code&gt; 函数的原因是将所有其他变量的索引保留在此hash_map中。 查看下面的示例，看看从hash_map中删除一个值后，&amp;ldquo; test2&amp;rdquo;的索引如何保持不变。</target>
        </trans-unit>
        <trans-unit id="e16825f749b4e5fb7d1fecf43d4e6b653061e2e8" translate="yes" xml:space="preserve">
          <source>The result would be &lt;code&gt;false&lt;/code&gt;, which means that your delete statement haven't been executed as you expected. But if you had not created that variable before, and you only had &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; as your last existing reference, you could have done this just by removing it like:</source>
          <target state="translated">结果将为 &lt;code&gt;false&lt;/code&gt; ，这意味着您的delete语句未按预期执行。 但是，如果您以前没有创建过该变量，而仅使用 &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; 作为最后一个现有引用，则可以通过删除它来完成此操作，例如：</target>
        </trans-unit>
        <trans-unit id="f6481accf44872d4ef8745c055193c2829ccd3cb" translate="yes" xml:space="preserve">
          <source>The term you have used in your question title &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt;, can be interpreted in some different ways. The one is to remove it for whole the memory and the list of object keys or the other is just to remove it from your object. As it has been mentioned in some other answers, the &lt;code&gt;delete&lt;/code&gt; keyword is the main part. Let's say you have your object like:</source>
          <target state="translated">您在问题标题中使用的术语 &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt; 可以用几种不同的方式解释。 一种是将其整个内存和对象键列表删除，另一种是将其从对象中删除。 正如在其他一些答案中提到的那样， &lt;code&gt;delete&lt;/code&gt; 关键字是主要部分。 假设您有如下对象：</target>
        </trans-unit>
        <trans-unit id="d7c42d645c208dfd4e3c38a50db94ab5a07bdf03" translate="yes" xml:space="preserve">
          <source>The version of ECMAScript you're targeting</source>
          <target state="translated">您所针对的ECMAScript的版本</target>
        </trans-unit>
        <trans-unit id="2d17e745883099706ab5b904d19b87cebce1764f" translate="yes" xml:space="preserve">
          <source>Then even if you remove it from your object &lt;code&gt;myJSONObject&lt;/code&gt;, that specific object won't get deleted from the memory, since the &lt;code&gt;regex&lt;/code&gt; variable and &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; still have their values. Then how could we remove the object from the memory for sure?</source>
          <target state="translated">然后，即使将其从对象 &lt;code&gt;myJSONObject&lt;/code&gt; 中删除，该特定对象也不会从内存中删除，因为 &lt;code&gt;regex&lt;/code&gt; 变量和 &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; 仍然具有其值。 那么我们如何才能确定从内存中删除对象呢？</target>
        </trans-unit>
        <trans-unit id="9f315ff9ba259ec4af4aad477da9caf99c783595" translate="yes" xml:space="preserve">
          <source>Then your objects key using &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; would be:</source>
          <target state="translated">然后，使用 &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; 的对象键将是：</target>
        </trans-unit>
        <trans-unit id="950ba1d1f6aad6e3258d15bc7f08a5e034f6a816" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I just want to chime in that when using delete to remove a property in JavaScript, it is often wise to first check if that property exists to prevent errors.</source>
          <target state="translated">这里有很多好的答案,但我只想说,在使用delete来删除JavaScript中的一个属性时,通常明智的做法是首先检查该属性是否存在,以防止错误。</target>
        </trans-unit>
        <trans-unit id="57100a7adc73f2ac8fb1259dcb31d2cae8056822" translate="yes" xml:space="preserve">
          <source>There are few common ways to remove a property from an object.</source>
          <target state="translated">从对象中删除属性的常见方法不多。</target>
        </trans-unit>
        <trans-unit id="8604def9bd3e30573031d5be629fb2bb0c18ca39" translate="yes" xml:space="preserve">
          <source>There are many different options presented on this page, not because most of the options are wrong&amp;mdash;or because the answers are duplicates&amp;mdash;but because the appropriate technique depends on the situation you're in and the goals of the tasks you and/or you team are trying to fulfill. To answer you question unequivocally, one needs to know:</source>
          <target state="translated">此页面上提供了许多不同的选项，不是因为大多数选项是错误的，或者不是答案是重复的，而是因为适当的技术取决于您所处的情况以及您和/或您的任务目标团队正在努力实现。 要明确回答您的问题，您需要知道：</target>
        </trans-unit>
        <trans-unit id="5f1efa2f9fb405d638f74fe5349dbabb89e0514a" translate="yes" xml:space="preserve">
          <source>They are slow &amp;amp; memory inefficient. When accessing a specific index, instead of just getting the global type for the array, the browser instead has to get the type on a per-index basis whereby each index stores the additional metadata of its type.</source>
          <target state="translated">它们速度慢且内存效率低下。 当访问特定索引时，浏览器必须获取每个索引的类型，而不是仅获取数组的全局类型，而必须按每个索引获取类型。</target>
        </trans-unit>
        <trans-unit id="afa3b2f30890db447e4cf00d9f2dcec7b332b01b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;ES6&lt;/code&gt; operator allows us to return a brand new object, excluding any properties, without mutating the existing object. The downside is that it has the worse performance out of the above and not suggested to be used when you need to remove many properties at a time.</source>
          <target state="translated">该 &lt;code&gt;ES6&lt;/code&gt; 运算符允许我们返回一个全新的对象（不包括任何属性），而无需更改现有对象。 不利的一面是，它的性能比以上更差，因此当您需要一次删除许多属性时，建议不要使用它。</target>
        </trans-unit>
        <trans-unit id="9e7248bc6c7cf17aeb43a8906d8cc8e3b531512b" translate="yes" xml:space="preserve">
          <source>This alternative is not the correct answer to this question! But, if you use it with care, you can dramatically speed up some algorithms. If you are using &lt;code&gt;delete&lt;/code&gt; in loops and you have problems with performance, read the verbose explanation.</source>
          <target state="translated">此替代方法不是此问题的正确答案！ 但是，如果谨慎使用它，则可以大大加快某些算法的速度。 如果您正在使用 &lt;code&gt;delete&lt;/code&gt; in循环，并且在性能方面遇到问题，请阅读详细说明。</target>
        </trans-unit>
        <trans-unit id="d2696a11c056f55fc8c70ea4ff94e4f5922248e1" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference and aren't using stateless functional principles in your code. An example piece of syntax in this category:</source>
          <target state="translated">这一类是用于在对象字面或对象实例上进行操作,当你想保留继续使用原始引用,并且在你的代码中不使用无状态功能原理时。这个类别中的一个语法例子。</target>
        </trans-unit>
        <trans-unit id="1f8c0c20dd501470cb117b73c855e583ae2e0193" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference while guarding against exceptions being thrown on unconfigurable properties:</source>
          <target state="translated">这个类别用于在对象字面符号或对象实例上进行操作,当你想保留继续使用原始引用,同时防止在不可配置的属性上抛出异常。</target>
        </trans-unit>
        <trans-unit id="94bdb987c00caa2e598854f97ea3c6de4e30eedf" translate="yes" xml:space="preserve">
          <source>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</source>
          <target state="translated">这个类别适用于在较新的ECMAScript风格中的纯对象或数组实例上进行操作,当你需要使用非互换的方法,并且不需要考虑到符号键。</target>
        </trans-unit>
        <trans-unit id="aba34382b27aca74b69be04c741119ab744a49b9" translate="yes" xml:space="preserve">
          <source>This category is generally allows for greater functional flexibility, including accounting for Symbols &amp;amp; omitting more than one property in one statement:</source>
          <target state="translated">通常，此类别可提供更大的功能灵活性，包括考虑符号并在一个语句中省略多个属性：</target>
        </trans-unit>
        <trans-unit id="17ff7f9c0c298023ffef1288d23c2efc74ebdf5c" translate="yes" xml:space="preserve">
          <source>This category is the oldest, most straightforward &amp;amp; most widely supported category of property removal. It supports &lt;code&gt;Symbol&lt;/code&gt; &amp;amp; array indexes in addition to strings and works in every version of JavaScript except for the very first release. However, it's mutative which violates some programming principles and has performance implications. It also can result in uncaught exceptions when used on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;non-configurable properties in strict mode&lt;/a&gt;.</source>
          <target state="translated">此类别是属性删除的最古老，最直接和最广泛支持的类别。 除字符串外，它还支持 &lt;code&gt;Symbol&lt;/code&gt; 和数组索引，并且除了第一个发行版以外，它都可以在所有JavaScript版本中使用。 但是，它是变异的，它违反了一些编程原则，并且对性能有影响。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;在严格模式下&lt;/a&gt;在不可配置的属性上使用时，也会导致未捕获的异常。</target>
        </trans-unit>
        <trans-unit id="4ad77472ac7767c23050851eada92d065c2bd943" translate="yes" xml:space="preserve">
          <source>This is in regard to this (now-removed) snippet:</source>
          <target state="translated">这是关于这个(现已删除的)片段。</target>
        </trans-unit>
        <trans-unit id="21292c660408d1ff92d4a1c2c4eafdd76c276e51" translate="yes" xml:space="preserve">
          <source>This post is very old and I find it very helpful so I decided to share the unset function I wrote in case someone else see this post and think why it's not so simple as it in PHP unset function.</source>
          <target state="translated">这个帖子很老,我觉得很有帮助,所以我决定分享一下我写的 unset 函数,以防别人看到这个帖子后,觉得为什么在 PHP unset 函数中没有那么简单。</target>
        </trans-unit>
        <trans-unit id="9603916ceb02f62ecad35613c65fb5ceed83b60d" translate="yes" xml:space="preserve">
          <source>This works in Firefox and Internet&amp;nbsp;Explorer, and I think it works in all others.</source>
          <target state="translated">这适用于Firefox和Internet Explorer，我认为它适用于所有其他产品。</target>
        </trans-unit>
        <trans-unit id="c685cc94e2b05416a2b9215116753bb12c7af729" translate="yes" xml:space="preserve">
          <source>To complete @Koen answer in this thread, in case you want to remove dynamic variable using the spread syntax, you can do it like so:</source>
          <target state="translated">为了完成@Koen在这个线程中的回答,如果你想用spread语法删除动态变量,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="a792292997434d58f8b1d7da4af78863ac5e4684" translate="yes" xml:space="preserve">
          <source>To get more info on &lt;code&gt;Object.seal&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal()&lt;/a&gt;</source>
          <target state="translated">要获取有关 &lt;code&gt;Object.seal&lt;/code&gt; 的更多信息： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96589c0ac9acf3a6b58f6928336639e582088ee3" translate="yes" xml:space="preserve">
          <source>To reassign to the same variable, use a &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">要重新分配给同一变量，请使用 &lt;code&gt;let&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="21af806df3feb60911002a77c4380b2b484f7bbf" translate="yes" xml:space="preserve">
          <source>To remove any property, say &lt;code&gt;key1&lt;/code&gt;, use the &lt;code&gt;delete&lt;/code&gt; keyword like this:</source>
          <target state="translated">要删除任何属性，例如 &lt;code&gt;key1&lt;/code&gt; ，请使用 &lt;code&gt;delete&lt;/code&gt; 关键字，如下所示：</target>
        </trans-unit>
        <trans-unit id="fa15c129befde7656ac754122a25210685ef2188" translate="yes" xml:space="preserve">
          <source>To summarize, differences are all about ways of determining the property existence, and about &lt;code&gt;for..in&lt;/code&gt; loop.</source>
          <target state="translated">总而言之，差异都是关于确定属性存在的方式以及 &lt;code&gt;for..in&lt;/code&gt; 循环的。</target>
        </trans-unit>
        <trans-unit id="87501fb0e92ec552bdf306c07f48852286e9c8c8" translate="yes" xml:space="preserve">
          <source>To whoever needs it...</source>
          <target state="translated">给需要它的人.....</target>
        </trans-unit>
        <trans-unit id="b7ff74710b25d787ff3d518b1667a655a5936c78" translate="yes" xml:space="preserve">
          <source>Try the following method. Assign the &lt;code&gt;Object&lt;/code&gt; property value to &lt;code&gt;undefined&lt;/code&gt;. Then &lt;code&gt;stringify&lt;/code&gt; the object and &lt;code&gt;parse&lt;/code&gt;.</source>
          <target state="translated">请尝试以下方法。 将 &lt;code&gt;Object&lt;/code&gt; 属性值分配给 &lt;code&gt;undefined&lt;/code&gt; 。 然后将对象 &lt;code&gt;stringify&lt;/code&gt; 并 &lt;code&gt;parse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d82a9f15156c36519fc72f9af221c32d7422e29" translate="yes" xml:space="preserve">
          <source>Try this</source>
          <target state="translated">试试这个</target>
        </trans-unit>
        <trans-unit id="828f97e6c91f157ecd45fc8183a07ca7b4e95e6f" translate="yes" xml:space="preserve">
          <source>Update regarding &lt;code&gt;is_array()&lt;/code&gt;</source>
          <target state="translated">有关 &lt;code&gt;is_array()&lt;/code&gt; 的更新</target>
        </trans-unit>
        <trans-unit id="d45aa1f9d8100f951a216d7ce715ec8d99477eb3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda#dissoc&lt;/a&gt; you will get a new object without the attribute &lt;code&gt;regex&lt;/code&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda＃dissoc，&lt;/a&gt;您将获得一个不带 &lt;code&gt;regex&lt;/code&gt; 属性的新对象：</target>
        </trans-unit>
        <trans-unit id="930151a2e26bf074e4b81d244de5799b750be707" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;delete&lt;/strong&gt; method is the best way to do that, as per MDN description, the delete operator removes a property from an object. So you can simply write:</source>
          <target state="translated">使用&lt;strong&gt;删除&lt;/strong&gt;方法是最好的方法，根据MDN描述，删除运算符将从对象中删除属性。 所以你可以简单地写：</target>
        </trans-unit>
        <trans-unit id="855d634ee489e4e0a2c811671f665628a0a0df6f" translate="yes" xml:space="preserve">
          <source>Using ES6:</source>
          <target state="translated">使用ES6。</target>
        </trans-unit>
        <trans-unit id="9fb406e463a70799e2a3db3cb0956dde6058516c" translate="yes" xml:space="preserve">
          <source>Using this method, not all &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;ways of determining property existence&lt;/a&gt; will work as expected.</source>
          <target state="translated">使用此方法，并非所有&lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;确定属性存在的方法&lt;/a&gt;都可以按预期工作。</target>
        </trans-unit>
        <trans-unit id="7d56ccd01dc2c25715aa91cc5c3b3239162d1db4" translate="yes" xml:space="preserve">
          <source>What follows is a contrived scenario that gets pretty long-winded, so you can skip to the section, &lt;strong&gt;The Solution&lt;/strong&gt;, if you want. The only reason I leave this section it is that I think some people probably think it's funny, and I don't want to be &quot;that guy&quot; who posts a &quot;funny&quot; answer and then deletes all the &quot;funny&quot; from it later on.</source>
          <target state="translated">接下来是一个人为scenario绕的人为场景，因此，如果需要，您可以跳至&lt;strong&gt;&amp;ldquo;解决方案&lt;/strong&gt; &amp;rdquo;部分。 我离开本节的唯一原因是，我认为有些人可能认为这很有趣，并且我不想成为发布&amp;ldquo;搞笑&amp;rdquo;答案然后稍后将其删除的所有&amp;ldquo;搞笑&amp;rdquo;家伙。 。</target>
        </trans-unit>
        <trans-unit id="e8a0f3d5fef79ddff6c740f20faf1841e9c8a913" translate="yes" xml:space="preserve">
          <source>What is the best way to remove the property &lt;code&gt;regex&lt;/code&gt; to end up with new &lt;code&gt;myObject&lt;/code&gt; as follows?</source>
          <target state="translated">删除属性 &lt;code&gt;regex&lt;/code&gt; 以产生新的 &lt;code&gt;myObject&lt;/code&gt; 的最佳方法是什么？</target>
        </trans-unit>
        <trans-unit id="269ad8f4ba0c959d755966ae84263f7c06ef0a98" translate="yes" xml:space="preserve">
          <source>When should one use &lt;code&gt;delete&lt;/code&gt; and when set value to &lt;code&gt;undefined&lt;/code&gt; ?</source>
          <target state="translated">什么时候应该使用 &lt;code&gt;delete&lt;/code&gt; 和何时将值设置为 &lt;code&gt;undefined&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="f73054e5169db0bc5c2ed5932270c4a709d901aa" translate="yes" xml:space="preserve">
          <source>When using a Symbol, wait, why are you using a Symbol?!?! Symbols are bad  juju for performance. Everything programmed to use Symbols can be reprogrammed to not use Symbols, resulting in a faster code without Symbols. Symbols are really just super inefficient meta-sugar.</source>
          <target state="translated">使用符号的时候,等等,你为什么要用符号?符号对性能的影响是很糟糕的。所有被编程为使用Symbols的东西都可以被重新编程为不使用Symbols,结果是没有Symbols的代码速度更快。符号真的只是超级低效的元糖。</target>
        </trans-unit>
        <trans-unit id="602ae3083b5ceb94cfa5bb3b6f0e1f19f1f16418" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the boolean primitive, use either &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the empty value. While avoiding unnecessary polymorphism is good, rewriting all your code to explicitly forbid it will likely actually result in a decrease in performance. Use common judgement!</source>
          <target state="translated">当使用类型为布尔基元的数组/变量时，请使用 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 作为空值。 虽然避免不必要的多态性是好的，但是重写所有代码以明确禁止它可能实际上会导致性能下降。 使用共同的判断！</target>
        </trans-unit>
        <trans-unit id="97e2c329b633d1758a70203709d67ea5a41bbc86" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the number primitive, use &lt;code&gt;0&lt;/code&gt; as the empty value. Note that internally, there are two types of numbers: fast integers (2147483647 to -2147483648 inclusive) and slow floating point doubles (anything other than that including &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt;). When an integer is demoted to a double, it cannot be promoted back to an integer.</source>
          <target state="translated">使用类型为数字基元的数组/变量时，请使用 &lt;code&gt;0&lt;/code&gt; 作为空值。 请注意，内部有两种类型的数字：快速整数（包括2147483647至-2147483648）和慢速浮点双精度（除 &lt;code&gt;NaN&lt;/code&gt; 和 &lt;code&gt;Infinity&lt;/code&gt; 之外的任何数字）。 当整数降为双精度整数时，不能将其提升回整数。</target>
        </trans-unit>
        <trans-unit id="363e06ebcbb46e5d020be755b34062c111648564" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the string primitive, use &lt;code&gt;&quot;&quot;&lt;/code&gt; as the empty value.</source>
          <target state="translated">当使用类型为字符串基元的数组/变量时，请使用 &lt;code&gt;&quot;&quot;&lt;/code&gt; 作为空值。</target>
        </trans-unit>
        <trans-unit id="2daf2d7377c143fd1982ce05f553ab2ba4bd19a7" translate="yes" xml:space="preserve">
          <source>When using anything else, use &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">使用其他任何东西时，请使用 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99129be375514e4d040c762996086e2002e66f2e" translate="yes" xml:space="preserve">
          <source>Which is a terrible justification for getting rid of the &lt;code&gt;null&lt;/code&gt;s--&lt;code&gt;null&lt;/code&gt; is only dangerous if used improperly, and it has nothing to do with &quot;precision&quot;. The real reason you shouldn't &lt;code&gt;delete&lt;/code&gt; from an array is that leaving garbage-filled and messy data structures around is sloppy and bug-prone.</source>
          <target state="translated">这是摆脱 &lt;code&gt;null&lt;/code&gt; 的可怕理由-null仅在使用不当的情况下才是危险的，并且与&amp;ldquo;精度&amp;rdquo;无关。 您不应该从数组中 &lt;code&gt;delete&lt;/code&gt; 的真正原因是，周围乱七八糟的数据结构很乱而且容易出错。</target>
        </trans-unit>
        <trans-unit id="1f5947457b95655f5329f1cfd08d1b56c64dd6e7" translate="yes" xml:space="preserve">
          <source>Which means in this case you won't be able to remove that object because you have created the &lt;code&gt;regex&lt;/code&gt; variable via a &lt;code&gt;var&lt;/code&gt; statement, and if you do:</source>
          <target state="translated">这意味着在这种情况下，您将无法删除该对象，因为已经通过 &lt;code&gt;var&lt;/code&gt; 语句创建了 &lt;code&gt;regex&lt;/code&gt; 变量，并且如果这样做了：</target>
        </trans-unit>
        <trans-unit id="4f17f120087f0ca40e417b064249125802d82ec5" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; is faster than doing &lt;code&gt;delete obj[prop]&lt;/code&gt;, another important consideration is that &lt;code&gt;obj[prop] = undefined&lt;/code&gt; may not always be appropriate. &lt;code&gt;delete obj[prop]&lt;/code&gt; removes &lt;code&gt;prop&lt;/code&gt; from &lt;code&gt;obj&lt;/code&gt; and erases it from memory whereas &lt;code&gt;obj[prop] = undefined&lt;/code&gt; simply sets the value of &lt;code&gt;prop&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; which leaves &lt;code&gt;prop&lt;/code&gt; still in memory. Therefore, in circumstances where there are many keys being created and deleted, using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; can force expensive memory reconciliation (causing the page to freeze up) and potentially an out-of-memory error. Examine the following code.</source>
          <target state="translated">尽管使用 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; 比 &lt;code&gt;delete obj[prop]&lt;/code&gt; 快，但另一个重要的考虑因素是 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; 可能并不总是合适的。 &lt;code&gt;delete obj[prop]&lt;/code&gt; 从 &lt;code&gt;obj&lt;/code&gt; 中删除 &lt;code&gt;prop&lt;/code&gt; 并将其从内存中删除，而 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; 只是将 &lt;code&gt;prop&lt;/code&gt; 的值设置为 &lt;code&gt;undefined&lt;/code&gt; ，从而使 &lt;code&gt;prop&lt;/code&gt; 仍保留在内存中。 因此，在创建和删除许多键的情况下，使用 &lt;code&gt;obj[prop] = undefined&lt;/code&gt; 可能会强制进行昂贵的内存协调（导致页面冻结），并可能导致内存不足错误。 检查以下代码。</target>
        </trans-unit>
        <trans-unit id="9fc668854fffc36979144c2d4415e9f9721712c0" translate="yes" xml:space="preserve">
          <source>While you technically can use &lt;code&gt;delete&lt;/code&gt; for an array, using it would result in getting incorrect results when calling for example &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; later on. In other words, &lt;code&gt;delete&lt;/code&gt; would remove the element, but it wouldn't update the value of &lt;code&gt;length&lt;/code&gt; property. Using &lt;code&gt;delete&lt;/code&gt; would also mess up your indexing.</source>
          <target state="translated">从技术上讲，您可以对数组使用 &lt;code&gt;delete&lt;/code&gt; ，但是稍后使用它会导致在调用例如 &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; 时得到不正确的结果。 换句话说， &lt;code&gt;delete&lt;/code&gt; 会删除该元素，但不会更新 &lt;code&gt;length&lt;/code&gt; 属性的值。 使用 &lt;code&gt;delete&lt;/code&gt; 也会使您的索引混乱。</target>
        </trans-unit>
        <trans-unit id="4be2ecd11ba0e212cafbe9f3ed4567f70ea3cc57" translate="yes" xml:space="preserve">
          <source>Yeah, that's definitely not what you wanted.</source>
          <target state="translated">是啊,这绝对不是你想要的。</target>
        </trans-unit>
        <trans-unit id="02c5f4541ba087fe996da9eb1271ebfb81156d83" translate="yes" xml:space="preserve">
          <source>You can also use other functions to achieve the same effect - omit, pick, ...</source>
          <target state="translated">你也可以使用其他功能来达到同样的效果--省略、摘取、.....</target>
        </trans-unit>
        <trans-unit id="95e9a3221d0ebd0cc77f374d7ddfa95d905aef6a" translate="yes" xml:space="preserve">
          <source>You can delete that specific key from your object keys like:</source>
          <target state="translated">你可以像这样从你的对象键中删除那个特定的键。</target>
        </trans-unit>
        <trans-unit id="df5ae996f80ec18df6459baf979a058b543794dd" translate="yes" xml:space="preserve">
          <source>You can see it in action in the Babel try-out editor.</source>
          <target state="translated">你可以在Babel试用编辑器中看到它的动作。</target>
        </trans-unit>
        <trans-unit id="ba4ef71e846efa414e359524a525c5bda890d6bb" translate="yes" xml:space="preserve">
          <source>You can simply delete any property of an object using the &lt;code&gt;delete&lt;/code&gt; keyword.</source>
          <target state="translated">您可以简单地使用 &lt;code&gt;delete&lt;/code&gt; 关键字删除对象的任何属性。</target>
        </trans-unit>
        <trans-unit id="6902cdb7c6341debc4ec1b8c5eaf6794e483c684" translate="yes" xml:space="preserve">
          <source>You can use ES6 destructuring with rest operator.</source>
          <target state="translated">你可以使用ES6的rest操作符进行解构。</target>
        </trans-unit>
        <trans-unit id="121a5978b1bee631af70ab1aaec00b53de7645b2" translate="yes" xml:space="preserve">
          <source>global scope) can be deleted with delete.</source>
          <target state="translated">全局范围)可以用delete删除。</target>
        </trans-unit>
        <trans-unit id="5be9ceecc2f03bc42e4d234aec808162f9c2f9d1" translate="yes" xml:space="preserve">
          <source>the result would be:</source>
          <target state="translated">结果会是:</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="b9a0331930f5ae83ac7b458124a7b5021f44ea5d" translate="yes" xml:space="preserve">
          <source>will behave equivalently for both methods.</source>
          <target state="translated">对这两种方法来说,都会有同样的表现。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
