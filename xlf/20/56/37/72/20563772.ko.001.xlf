<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/20563772">
    <body>
      <group id="20563772">
        <trans-unit id="04c55724768058d5a9709a1afac88b7e9e8c36de" translate="yes" xml:space="preserve">
          <source>&quot;Pretty links&quot; is an often requested topic, but it is rarely fully explained. &lt;a href=&quot;https://en.wikipedia.org/wiki/URL_redirection#Apache_HTTP_Server_mod_rewrite&quot;&gt;mod_rewrite&lt;/a&gt; is one way to make &quot;pretty links&quot;, but it's complex and its syntax is very terse, hard to grok, and the documentation assumes a certain level of proficiency in HTTP. Can someone explain in simple terms how &quot;pretty links&quot; work and how mod_rewrite can be used to create them?</source>
          <target state="translated">&quot;예쁜 링크&quot;는 자주 요청되는 주제이지만 그에 대한 설명은 거의 없습니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/URL_redirection#Apache_HTTP_Server_mod_rewrite&quot;&gt;mod_rewrite&lt;/a&gt; 는 &quot;예쁜 링크&quot;를 만드는 한 가지 방법이지만, 복잡하고 구문이 매우 간결하고 이해하기 어려우며이 문서는 HTTP의 특정 수준의 숙련도를 가정합니다. 누군가 &quot;예쁜 링크&quot;가 어떻게 작동하는지 mod_rewrite를 사용하여 어떻게 만들 수 있는지 간단한 용어로 설명 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a0144ea22bd63e090c9a57002ef4dca43f06244e" translate="yes" xml:space="preserve">
          <source>&quot;Removing&quot; the PHP extension</source>
          <target state="translated">PHP 확장 &quot;제거&quot;</target>
        </trans-unit>
        <trans-unit id="597d8e063a87f940aba17a58c3d20ee1aa29b5aa" translate="yes" xml:space="preserve">
          <source>&amp;larr;&amp;rarr;</source>
          <target state="translated">&amp;larr;&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="b5513ad1a21d7a31373a546022f3c58ec77d271b" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/234723/generic-htaccess-redirect-www-to-non-www&quot;&gt;Generic htaccess redirect www to non-www&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/234723/generic-htaccess-redirect-www-to-non-www&quot;&gt;일반 htaccess를 www가 아닌 ​​www로 리디렉션&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e9d10a73898648b0aedc5f97de4fe51653ebbb0" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/3634101/url-rewriting-for-different-protocols-in-htaccess&quot;&gt;URL rewriting for different protocols in .htaccess&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/3634101/url-rewriting-for-different-protocols-in-htaccess&quot;&gt;.htaccess의 다른 프로토콜에 대한 URL 재 작성&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11664097a8ffb0d8f28dc915df0128cf941e154f" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/4916222/htaccess-how-to-force-www-in-a-generic-way&quot;&gt;.htaccess - how to force &quot;www.&quot; in a generic way?&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/4916222/htaccess-how-to-force-www-in-a-generic-way&quot;&gt;.htaccess- &quot;www&quot;를 강제하는 방법&lt;/a&gt; 일반적인 방법으로?</target>
        </trans-unit>
        <trans-unit id="49874443e813166bc4fdbfa82a1bbca93286ff6a" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/9153262/tips-for-debugging-htaccess-rewrite-rules&quot;&gt;Tips for debugging .htaccess rewrite rules&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/9153262/tips-for-debugging-htaccess-rewrite-rules&quot;&gt;.htaccess 재 작성 규칙 디버깅 팁&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23f298a47c3d469e691054bf2fb011ca932d6db4" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/945047/htaccess-not-working-mod-rewrite&quot;&gt;.htaccess not working (mod_rewrite)&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/945047/htaccess-not-working-mod-rewrite&quot;&gt;.htaccess가 작동하지 않습니다 (mod_rewrite)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="90b7f713187e69c77adcad3d9680fb1827b33af5" translate="yes" xml:space="preserve">
          <source>&amp;middot; Note that the leading slash is still correct in &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; sections though. Which is why you often see it &lt;code&gt;^/?&lt;/code&gt; optionalized for rule parity.</source>
          <target state="translated">&lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 섹션에서 선행 슬래시는 여전히 옳습니다. 왜 당신은 종종 &lt;code&gt;^/?&lt;/code&gt; 규칙 패리티에 대해 선택적입니다.</target>
        </trans-unit>
        <trans-unit id="cbe50ec46e66e9fc50014beb0301950e6ccf42b2" translate="yes" xml:space="preserve">
          <source>&amp;middot; Or when using a &lt;code&gt;RewriteCond %{REQUEST_URI}&lt;/code&gt; you'd still match for a leading &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">또는 &lt;code&gt;RewriteCond %{REQUEST_URI}&lt;/code&gt; 를 사용하는 경우에도 선행 &lt;code&gt;/&lt;/code&gt; 과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="751229f868612475f9aa274c27c6748c3d39d97a" translate="yes" xml:space="preserve">
          <source>&amp;middot; See also &lt;a href=&quot;https://webmasters.stackexchange.com/questions/27118/when-is-the-leading-slash-needed-in-mod-rewrite-patterns&quot;&gt;Webmaster.SE: When is the leading slash (/) needed in mod_rewrite patterns?&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://webmasters.stackexchange.com/questions/27118/when-is-the-leading-slash-needed-in-mod-rewrite-patterns&quot;&gt;Webmaster.SE&lt;/a&gt; 참고 : mod_rewrite 패턴에서 선행 슬래시 (/)는 언제 필요합니까?</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="09ff1d5e4b8bdd76ba405a3bed899d1c8bef75b6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_alias.html#scriptaliasmatch&quot;&gt;&lt;code&gt;ScriptAliasMatch&lt;/code&gt;&lt;/a&gt; is primarily for CGI scripts, but also ought to works for PHP. It allows regexps just like any &lt;code&gt;RewriteRule&lt;/code&gt;. In fact it's perhaps the most robust option to configurate a catch-all front controller.</source>
          <target state="translated">&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_alias.html#scriptaliasmatch&quot;&gt; &lt;code&gt;ScriptAliasMatch&lt;/code&gt; &lt;/a&gt; 는 주로 CGI 스크립트 용이지만 PHP에서도 작동합니다. &lt;code&gt;RewriteRule&lt;/code&gt; 과 마찬가지로 정규 표현식을 허용합니다. 실제로 모든 전면 컨트롤러를 구성하는 것이 가장 강력한 옵션 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="9a549849bbb01109ba011c5521c50e9b4dab2ca6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritecond&quot;&gt;Rewrite conditions&lt;/a&gt; make rewrites even more powerful, allowing you to specify rewrites for more specific situations. There are a lot of conditions which you can read about in &lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritecond&quot;&gt;the documentation&lt;/a&gt;, but I'll touch on a few common examples and explain them:</source>
          <target state="translated">&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritecond&quot;&gt;다시 쓰기 조건을&lt;/a&gt; 사용하면 다시 쓰기가 더욱 강력 해져서보다 구체적인 상황에 대한 다시 쓰기 를 지정할 수 있습니다. &lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritecond&quot;&gt;documentation&lt;/a&gt; 에서 읽을 수있는 조건이 많이 있지만 몇 가지 일반적인 예를 터치하고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dabf9d101070ea48e2e85c726ecf5e80fe0caccb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; indicates this is the end of the string we want to match</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 는 이것이 우리가 일치시키고 싶은 문자열의 끝을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="3841678c9eead3827e8ffd336e806cea70870cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%{REQUEST_FILENAME} !-d&lt;/code&gt; will check to see if the file exists on the current server, and only execute the rewrite if it doesn't</source>
          <target state="translated">&lt;code&gt;%{REQUEST_FILENAME} !-d&lt;/code&gt; 는 파일이 현재 서버에 있는지 확인하고 파일이없는 경우에만 다시 쓰기를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="52ef5672eb064f0ebc113e70140ea1eadd1d8617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%{REQUEST_FILENAME} !-f&lt;/code&gt; will check to see if the file exists on the current server, and only execute the rewrite if it doesn't</source>
          <target state="translated">&lt;code&gt;%{REQUEST_FILENAME} !-f&lt;/code&gt; 는 파일이 현재 서버에 있는지 확인하고 파일이없는 경우에만 다시 쓰기를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b5f7869488f52b18660937317e48137ddb57255d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%{REQUEST_URI} \.(jpg|jpeg|gif|png)$ [NC]&lt;/code&gt; will only execute the rewrite for files with a file extension of jpg, jpeg, gif or png (case insensitive).</source>
          <target state="translated">&lt;code&gt;%{REQUEST_URI} \.(jpg|jpeg|gif|png)$ [NC]&lt;/code&gt; 는 파일 확장자가 jpg, jpeg, gif 또는 png (대소 문자 구분 안 함) 인 파일에 대해서만 다시 쓰기를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="84f88a1c5e685a84649de8e1bb782d50117ee3d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;IfModule *&amp;gt;&lt;/code&gt; wrappers begone!</source>
          <target state="translated">&lt;code&gt;&amp;lt;IfModule *&amp;gt;&lt;/code&gt; 래퍼가 시작되었습니다!</target>
        </trans-unit>
        <trans-unit id="740e3c6f83451b565f345cfff88bed98503f3438" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.*&lt;/code&gt; matches anything, even an empty string. You don't want to use this pattern everywhere, but often in the last fallback rule.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 는 빈 문자열까지도 일치합니다. 이 패턴을 모든 곳에서 사용하고 싶지는 않지만 종종 마지막 대체 규칙에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="57a8bb9a55be2beb96f900e52fa775ececf4eb4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.htaccess&lt;/code&gt; vs. &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; 대 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd8275fe29a7eea617f1c546405e782cf8821462" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; means that the preceding character is optional, so in this case both &lt;code&gt;/blog/1/foo/&lt;/code&gt; and &lt;code&gt;/blog/1/foo&lt;/code&gt; would rewrite to the same place</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 앞의 문자는 선택 사항이므로이 경우 &lt;code&gt;/blog/1/foo/&lt;/code&gt; 와 &lt;code&gt;/blog/1/foo&lt;/code&gt; 는 모두 같은 위치에 다시 씁니다.</target>
        </trans-unit>
        <trans-unit id="53ff5984a739c16e5b086e2a03847c8c36b495a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RewriteRule&lt;/code&gt; - starts the rewrite rule</source>
          <target state="translated">&lt;code&gt;RewriteRule&lt;/code&gt; - 다시 쓰기 규칙을 시작합니다</target>
        </trans-unit>
        <trans-unit id="f6bc4be5b28507c8732dee618da29f11552edf76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[NC,L,QSA]&lt;/code&gt; are flags for the rewrite rule, separated by a comma, which I will explain more on later</source>
          <target state="translated">&lt;code&gt;[NC,L,QSA]&lt;/code&gt; 는 다시 쓰기 규칙에 대한 플래그이며 쉼표로 구분되며 나중에 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="7f10bfcb87252edf50ae9c562e503f26dba99880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[\w\-.,]+&lt;/code&gt; adds periods and commas. Prefer an escaped &lt;code&gt;\-&lt;/code&gt; dash in &lt;code&gt;[&amp;hellip;]&lt;/code&gt; charclasses.</source>
          <target state="translated">&lt;code&gt;[\w\-.,]+&lt;/code&gt; 는 마침표와 쉼표를 추가합니다. &lt;code&gt;[&amp;hellip;]&lt;/code&gt; charclasses에서 이스케이프 된 &lt;code&gt;\-&lt;/code&gt; 대시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="652e235ffc34df09e53fb0c478bb6569c2f6220f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[\w\-]+&lt;/code&gt; for &quot;slug&quot;-style path segments, using letters, numbers, dash &lt;code&gt;-&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;_&lt;/code&gt;</source>
          <target state="translated">문자, 숫자, 대시 &lt;em&gt;및&lt;/em&gt; &lt;code&gt;_&lt;/code&gt; 를 사용하여 &quot;슬러그&quot;스타일 경로 세그먼트의 경우 &lt;code&gt;[\w\-]+&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eefc1f169daf6dd207f047f1eca8ec66ccf23d21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^/]+&lt;/code&gt; is more often used for path segments. It matches anything but the forward slash.</source>
          <target state="translated">&lt;code&gt;[^/]+&lt;/code&gt; 는 경로 세그먼트에 더 자주 사용됩니다. 슬래시 이외의 항목과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="007f7af81afda692adf95fb0f0ea88501e1bf3b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\.&lt;/code&gt; denotes a literal period. Otherwise &lt;code&gt;.&lt;/code&gt; outside of &lt;code&gt;[&amp;hellip;]&lt;/code&gt; is placeholder for any symbol.</source>
          <target state="translated">&lt;code&gt;\.&lt;/code&gt; 리터럴 기간을 나타냅니다. 그렇지 않으면 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;[&amp;hellip;]&lt;/code&gt; 외부는 모든 기호의 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="5a4fb0ae48ecd50b05579d0b16175b9faa2f9145" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d+&lt;/code&gt; only matches numeric strings.</source>
          <target state="translated">&lt;code&gt;\d+&lt;/code&gt; 는 숫자 문자열과 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="88dd17205e1d1eb1880a3862d44c47469b59bc65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w+&lt;/code&gt; matches alphanumeric characters. It's basically shorthand for &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\w+&lt;/code&gt; 는 영숫자 문자와 일치합니다. 기본적으로 &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; 의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="ecd5b35217c81c63b4a74c2649897e0738e78196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; indicates the start of the page name - so it will rewrite &lt;code&gt;example.com/blog/...&lt;/code&gt; but not &lt;code&gt;example.com/foo/blog/...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 는 페이지 이름의 시작을 나타냅니다. 따라서 &lt;code&gt;example.com/blog/...&lt;/code&gt; 는 다시 작성하지 않습니다 &lt;code&gt;example.com/foo/blog/...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c35aed0c9b66dedf952907da4ac7c5d1e91082" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^blog/([0-9]+)/([A-Za-z0-9-\+]+)/?$&lt;/code&gt; - This is called the pattern, however I'll just refer to it as the left hand side of the rule - what you want to rewrite from</source>
          <target state="translated">&lt;code&gt;^blog/([0-9]+)/([A-Za-z0-9-\+]+)/?$&lt;/code&gt; -패턴이라고하는데, 그냥 왼쪽이라고하겠습니다 규칙의-당신이 다시 쓰고 싶은 것</target>
        </trans-unit>
        <trans-unit id="3c3e47bd9da371a8d996ad9238fb7d0a846ed34f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blog/index.php?id=$1&amp;amp;title=$2&lt;/code&gt; - called the substitution, or right hand side of a rewrite rule - what you want to rewrite to</source>
          <target state="translated">&lt;code&gt;blog/index.php?id=$1&amp;amp;title=$2&lt;/code&gt; 대체 또는 재 작성 규칙의 오른쪽-재 작성하려는 항목</target>
        </trans-unit>
        <trans-unit id="c018111bc70724dcfa8cb1f7668165f1f8338ea1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(One could use &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_substitute.html&quot;&gt;&lt;code&gt;mod_substitute&lt;/code&gt;&lt;/a&gt; in conjunction to transform outgoing HTML pages and their contained links. Though this is usally more effort than just updating your HTML resources.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;발신 HTML 페이지와 포함 된 링크를 변환하기 위해 &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_substitute.html&quot;&gt; &lt;code&gt;mod_substitute&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다. HTML 리소스를 업데이트하는 것보다 일반적으로 더 많은 노력이 필요합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13b7ff54bd60680e79ae5fbe5d410830c1d4ba46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: Just a pet peeve.&lt;/em&gt; You often hear pretty URL rewriting schemes referred to as &quot;SEO&quot; links or something. While this is useful for googling examples, it's a dated misnomer.</source>
          <target state="translated">&lt;em&gt;면책 조항 : 단지 애완 동물 친구.&lt;/em&gt; 종종 &quot;SEO&quot;링크 또는 무언가라는 URL 재 작성 체계가 들립니다. 이것은 인터넷 검색 예제에 유용하지만 날짜가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="eac2e867209bf4cc7ac3e6c6c4fa20816e1a9de4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Frequent duplicates:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;자주 복제 :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97e1889f04dc3ae76733cf1c73e291e1aa7e9fa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before asking your own question&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자신의 질문을하기 전에&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c93e3a38d537bf6691059af6469a46eaab5ed161" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compare &lt;code&gt;access.log&lt;/code&gt; and &lt;code&gt;error.log&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;access.log&lt;/code&gt; 와 &lt;code&gt;error.log&lt;/code&gt; 비교&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2eb684fba0d3ae631715207143e21b416e87c173" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enable the RewriteLog&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RewriteLog 활성화&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ad2c732c9574e224486865e3a43750bf1d28e9c" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* &lt;em&gt;If&lt;/em&gt; allowed by the primary Apache configuration file; it's optional, but often enabled.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;* 기본 Apache 구성 파일에서 허용하는 &lt;em&gt;경우&lt;/em&gt;&lt;/sub&gt; &lt;sub&gt;선택 사항이지만 종종 사용됩니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2ac572067e403e7daf793fe6e0ac4b75ec0f146e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Keep in mind to remove the slash in &lt;code&gt;^/&lt;/code&gt; pattern prefixes for &lt;code&gt;.htaccess&lt;/code&gt; usage.)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;( &lt;code&gt;.htaccess&lt;/code&gt; 사용을 위해 &lt;code&gt;^/&lt;/code&gt; 패턴 접두사에서 슬래시를 제거하십시오.)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1d70018b10d872204ec89158898067f937b2f3f7" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/intro.html&quot;&gt;Apache manual - mod_rewrite intro&lt;/a&gt;, Copyright 2015 The Apache Software Foundation, AL-2.0&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/intro.html&quot;&gt;아파치 매뉴얼-mod_rewrite intro&lt;/a&gt; , Copyright 2015 The Apache Software Foundation, AL-2.0&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="3bb0577c12be030ceb402e055b81983cbc559dc7" translate="yes" xml:space="preserve">
          <source>A common misinterpetation is that a RewriteCond blocks multiple RewriteRules (because they're visually arranged together):</source>
          <target state="translated">일반적인 오해는 RewriteCond가 여러 RewriteRules를 시각적으로 정렬하여 차단한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d6fc1b11df2a64cfc4257b5e2e334dcee5fdb582" translate="yes" xml:space="preserve">
          <source>A common variation is to have optional prefixes &lt;em&gt;within&lt;/em&gt; a rule. This usually makes sense if you have static strings or more constrained placeholders around:</source>
          <target state="translated">일반적인 변형은 규칙 &lt;em&gt;내에&lt;/em&gt; 선택적 접두사 &lt;em&gt;를 사용&lt;/em&gt; 하는 것입니다. 정적 문자열이나 더 제한된 자리 표시자가있는 경우 일반적으로 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7d27b8628cafc228ce03267fced905dd8074078" translate="yes" xml:space="preserve">
          <source>A more directed approach to avoid carrying around &lt;code&gt;.php&lt;/code&gt; suffixes in URLs is &lt;a href=&quot;http://php.net/manual/en/security.hiding.php&quot;&gt;configuring the PHP handler&lt;/a&gt; for other file schemes. The simplest option is overriding the default MIME/handler type via &lt;code&gt;.htaccess&lt;/code&gt;:</source>
          <target state="translated">URL에서 &lt;code&gt;.php&lt;/code&gt; 접미사를 사용하지 않는보다 직접적인 접근 방식은 다른 파일 체계에 맞게 &lt;a href=&quot;http://php.net/manual/en/security.hiding.php&quot;&gt;PHP 처리기&lt;/a&gt; 를 구성하는 것 입니다. 가장 간단한 옵션은 &lt;code&gt;.htaccess&lt;/code&gt; 를 통해 기본 MIME / 핸들러 유형을 재정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="20fc23c4cb699185bba8ced01fc05186ba75a0a1" translate="yes" xml:space="preserve">
          <source>A more practical use of alternative lists are mapping request paths to distinct scripts. For example to provide uniform URLs for an older and a newer web application based on dates:</source>
          <target state="translated">대체 목록의보다 실용적인 사용은 요청 경로를 고유 한 스크립트로 맵핑하는 것입니다. 예를 들어 날짜를 기준으로 이전 및 최신 웹 응용 프로그램에 균일 한 URL을 제공하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="124f0e78269a525e3a84a54aeffe59146bd971ec" translate="yes" xml:space="preserve">
          <source>A request for &lt;code&gt;/article/123&lt;/code&gt; for example could map to &lt;code&gt;article.php&lt;/code&gt; with a &lt;code&gt;/123&lt;/code&gt; PATH_INFO implicitly. You'd either have to guard your rules then with the commonplace &lt;code&gt;RewriteCond&lt;/code&gt;&lt;code&gt;!-f&lt;/code&gt;+&lt;code&gt;!-d&lt;/code&gt;, and/or disable PATH_INFO support, or perhaps just disable &lt;code&gt;Options -MultiViews&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;/article/123&lt;/code&gt; 에 대한 요청은 암시 적으로 &lt;code&gt;/123&lt;/code&gt; PATH_INFO를 사용하여 &lt;code&gt;article.php&lt;/code&gt; 에 매핑 될 수 있습니다. 일반 &lt;code&gt;RewriteCond&lt;/code&gt; &lt;code&gt;!-f&lt;/code&gt; + &lt;code&gt;!-d&lt;/code&gt; 규칙을 지키거나 PATH_INFO 지원을 비활성화하거나 &lt;code&gt;Options -MultiViews&lt;/code&gt; 만 비활성화 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="433be67f13d6a6039d826a3ae6dabfa87aeb67b2" translate="yes" xml:space="preserve">
          <source>Again take note that such settings propagate from one &lt;code&gt;.htaccess&lt;/code&gt; to subfolders. You always should disable script execution (&lt;code&gt;SetHandler None&lt;/code&gt; and &lt;code&gt;Options -Exec&lt;/code&gt; or &lt;code&gt;php_flag engine off&lt;/code&gt; etc.) for static resources, and upload/ directories etc.</source>
          <target state="translated">이러한 설정은 하나의 &lt;code&gt;.htaccess&lt;/code&gt; 에서 하위 폴더로 전파됩니다. 정적 리소스에 대해서는 항상 스크립트 실행 ( &lt;code&gt;SetHandler None&lt;/code&gt; 및 &lt;code&gt;Options -Exec&lt;/code&gt; 또는 &lt;code&gt;php_flag engine off&lt;/code&gt; 등)을 비활성화하고 업로드 / 디렉토리 등을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6c86f75fe82e60b09e41ad6e136753d057e4146d" translate="yes" xml:space="preserve">
          <source>Aliasing old .html paths to .php scripts</source>
          <target state="translated">오래된 .html 경로를 .php 스크립트로 별칭 지정</target>
        </trans-unit>
        <trans-unit id="11b618e5bc8ecbd76c5f38a2fe95c312ffdef55a" translate="yes" xml:space="preserve">
          <source>All of the below examples assume that you have already included &lt;code&gt;RewriteEngine On&lt;/code&gt; in your &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="translated">아래 예제는 모두 &lt;code&gt;.htaccess&lt;/code&gt; 파일에 &lt;code&gt;RewriteEngine On&lt;/code&gt; 을 이미 포함했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="27a22e164a7b422c5235f0d0b21b0dc4423cefeb" translate="yes" xml:space="preserve">
          <source>Alternatively you can utilize PHPs array parameters via &lt;code&gt;?p[]=$1&amp;amp;p[]=$2&amp;amp;p[]=3&lt;/code&gt; query string here - if your script merely prefers them pre-split.
(Though it's more common to just use a catch-all rule, and let the script itself expand the segments out of the REQUEST_URI.)</source>
          <target state="translated">또는 &lt;code&gt;?p[]=$1&amp;amp;p[]=$2&amp;amp;p[]=3&lt;/code&gt; 쿼리 문자열을 통해 PHP 배열 매개 변수를 활용할 수 있습니다. 스크립트가 단순히 사전 분할을 선호하는 경우. (포괄적 인 규칙 만 사용하고 스크립트 자체가 REQUEST_URI에서 세그먼트를 확장하도록하는 것이 더 일반적이지만)</target>
        </trans-unit>
        <trans-unit id="e47f4e5a309adcf1b040c5210b5bc773d2eb8468" translate="yes" xml:space="preserve">
          <source>Alternatives to mod_rewrite</source>
          <target state="translated">mod_rewrite의 대안</target>
        </trans-unit>
        <trans-unit id="a2ff10145ba39fbaf7ef21bb614d55aaa77793a9" translate="yes" xml:space="preserve">
          <source>Among its many options, Apache provides &lt;code&gt;mod_alias&lt;/code&gt; features - which sometimes work just as well as &lt;code&gt;mod_rewrite&lt;/code&gt;s RewriteRules. Note that most of those must be set up in a &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section however, not in per-directory &lt;code&gt;.htaccess&lt;/code&gt; config files.</source>
          <target state="translated">많은 옵션 중에서 Apache는 &lt;code&gt;mod_alias&lt;/code&gt; 기능을 제공합니다. 때로는 &lt;code&gt;mod_rewrite&lt;/code&gt; 의 RewriteRules와 마찬가지로 작동합니다. 그러나 이들 중 대부분은 디렉토리 별 &lt;code&gt;.htaccess&lt;/code&gt; 구성 파일이 아니라 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 섹션에서 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="af99096848ed8cb0eea299166a097937fc97e50b" translate="yes" xml:space="preserve">
          <source>An excerpt from your &lt;code&gt;access.log&lt;/code&gt; and &lt;code&gt;error.log&lt;/code&gt; to verify what the existing rules resolved to. Better yet, a &lt;code&gt;rewrite.log&lt;/code&gt; summary.</source>
          <target state="translated">&lt;code&gt;access.log&lt;/code&gt; 및 &lt;code&gt;error.log&lt;/code&gt; 에서 발췌하여 기존 규칙이 해결 된 내용을 확인합니다. 더 좋은 것은 &lt;code&gt;rewrite.log&lt;/code&gt; 요약입니다.</target>
        </trans-unit>
        <trans-unit id="ba6a9ee04d540d46321a6a706abef24c659c81df" translate="yes" xml:space="preserve">
          <source>And a plain &lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_alias.html#alias&quot;&gt;&lt;code&gt;Alias&lt;/code&gt;&lt;/a&gt; helps with a few simple rewriting schemes as well.</source>
          <target state="translated">그리고 일반 &lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_alias.html#alias&quot;&gt; &lt;code&gt;Alias&lt;/code&gt; &lt;/a&gt; 은 몇 가지 간단한 재 작성 체계에도 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ef9d8db5d3dfaf745489b854e4b254c552aab203" translate="yes" xml:space="preserve">
          <source>And it's commonly distributed for default &lt;code&gt;.htaccess&lt;/code&gt; rulesets with many open source projects. There it's just meant as fallback, and keeps &quot;ugly&quot; URLs work as default.</source>
          <target state="translated">그리고 많은 오픈 소스 프로젝트와 함께 기본 &lt;code&gt;.htaccess&lt;/code&gt; 규칙 세트에 일반적으로 배포됩니다. 그것은 단지 폴백 (fallback)과 같은 의미이며 &quot;추악한&quot;URL을 기본값으로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="86da803ab52102ad28a3f8ecce52c7d4a8621043" translate="yes" xml:space="preserve">
          <source>And newcomer-friendly regex overviews even:</source>
          <target state="translated">그리고 새로 온 친절한 정규식 개요 :</target>
        </trans-unit>
        <trans-unit id="9d30c141612d532ddc9ac96890f3f30fd7097b62" translate="yes" xml:space="preserve">
          <source>And the &lt;a href=&quot;/questions/tagged/mod-rewrite&quot;&gt;mod-rewrite&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/tags/mod-rewrite/info&quot;&gt;tag wiki references&lt;/a&gt;.</source>
          <target state="translated">그리고 &lt;a href=&quot;/questions/tagged/mod-rewrite&quot;&gt;mod-rewrite&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/tags/mod-rewrite/info&quot;&gt;태그 위키 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe62757cd069906fac22465f642c8b25e045beee" translate="yes" xml:space="preserve">
          <source>And the short &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/intro.html#regex&quot;&gt;Apache regex summary&lt;/a&gt;.</source>
          <target state="translated">그리고 짧은 &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/intro.html#regex&quot;&gt;아파치 정규식 요약&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5408edd8784686bb03f95bd3cfbf8d5c4d025f1b" translate="yes" xml:space="preserve">
          <source>Another often encountered rule is this:</source>
          <target state="translated">자주 발생하는 또 다른 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf5c556e294b25711a0b5a44327bf833cd3e101a" translate="yes" xml:space="preserve">
          <source>Apache &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/remapping.html&quot;&gt;redirecting and remapping&lt;/a&gt; guide.</source>
          <target state="translated">아파치 &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/remapping.html&quot;&gt;리디렉션 및 리매핑&lt;/a&gt; 가이드.</target>
        </trans-unit>
        <trans-unit id="284ef6600e99697d0d7d8d2957a4e47dd26fa3af" translate="yes" xml:space="preserve">
          <source>Apache and PHP versions, OS type, filesystem, DOCUMENT_ROOT, and PHPs &lt;code&gt;$_SERVER&lt;/code&gt; environment if it's about a parameter mismatch.</source>
          <target state="translated">매개 변수 불일치에 관한 Apache 및 PHP 버전, OS 유형, 파일 시스템, DOCUMENT_ROOT 및 PHP &lt;code&gt;$_SERVER&lt;/code&gt; 환경.</target>
        </trans-unit>
        <trans-unit id="cfe353f8853a9f04a5bdabbcdc53ebd267952363" translate="yes" xml:space="preserve">
          <source>As said before, you don't often want too generic rewrite patterns. It does however make sense to combine static and specific comparisons with a &lt;code&gt;.*&lt;/code&gt; sometimes.</source>
          <target state="translated">앞에서 말했듯이 너무 일반적인 재 작성 패턴을 원하지 않는 경우가 많습니다. 그러나 정적 및 특정 비교를 때때로. &lt;code&gt;.*&lt;/code&gt; 와 결합하는 것이 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="d76c15ceb6076c092e88bddbb37d48859289c9a8" translate="yes" xml:space="preserve">
          <source>As you might know, Stack Overflow is very suitable for asking questions on mod_rewrite. Make them &lt;a href=&quot;https://stackoverflow.com/help/on-topic&quot;&gt;on-topic&lt;/a&gt;
by including prior research and attempts (avoid redundant answers), demonstrate basic &lt;a href=&quot;/questions/tagged/regex&quot;&gt;regex&lt;/a&gt; understanding, and:</source>
          <target state="translated">아시다시피, 스택 오버플로는 mod_rewrite에 대한 질문을하는 데 매우 적합합니다. 사전 연구 및 시도를 포함하여 &lt;a href=&quot;https://stackoverflow.com/help/on-topic&quot;&gt;주제&lt;/a&gt; 에 대한 토픽 을 만들고 (중복 답변은 피함) 기본적인 &lt;a href=&quot;/questions/tagged/regex&quot;&gt;정규식&lt;/a&gt; 이해를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dff94f3ae82bd649b875179b762ba9d36b194992" translate="yes" xml:space="preserve">
          <source>AskApache &lt;a href=&quot;http://www.askapache.com/htaccess/htaccess.html&quot;&gt;ultimate .htaccess guide&lt;/a&gt;</source>
          <target state="translated">AskApache &lt;a href=&quot;http://www.askapache.com/htaccess/htaccess.html&quot;&gt;Ultimate .htaccess guide&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84507ed5b78e9f12ea3e3bf7c3287d27ecaf1074" translate="yes" xml:space="preserve">
          <source>Capture the remainder</source>
          <target state="translated">나머지를 캡처</target>
        </trans-unit>
        <trans-unit id="bc24e00f0d506c472f2be3ee5fbfbf1041e1d18a" translate="yes" xml:space="preserve">
          <source>Catch-all for a &lt;a href=&quot;https://stackoverflow.com/questions/8595964/redirect-all-traffic-to-index-php-using-mod-rewrite&quot;&gt;central dispatcher&lt;/a&gt; / front-controller script</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/8595964/redirect-all-traffic-to-index-php-using-mod-rewrite&quot;&gt;중앙 디스패처&lt;/a&gt; / 전면 컨트롤러 스크립트를위한 포괄</target>
        </trans-unit>
        <trans-unit id="d5e664288f7b3dfc0c3af90aa9c7fec3210b2112" translate="yes" xml:space="preserve">
          <source>Change the link to a pretty link:</source>
          <target state="translated">링크를 예쁜 링크로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="edb59b056b2f75d0d2c02a13ae36b3214b3072e9" translate="yes" xml:space="preserve">
          <source>Check that your server has &lt;a href=&quot;https://stackoverflow.com/questions/9234289/verify-if-htaccess-file-is-running&quot;&gt;&lt;code&gt;AllowOverride All&lt;/code&gt; enabled&lt;/a&gt;. Otherwise your per-directory &lt;code&gt;.htaccess&lt;/code&gt; directives will go ignored, and RewriteRules won't work.</source>
          <target state="translated">서버에 &lt;a href=&quot;https://stackoverflow.com/questions/9234289/verify-if-htaccess-file-is-running&quot;&gt; &lt;code&gt;AllowOverride All&lt;/code&gt; 이 활성화&lt;/a&gt; 되어 있는지 확인하십시오. 그렇지 않으면 디렉토리 별 &lt;code&gt;.htaccess&lt;/code&gt; 지시문이 무시되고 RewriteRules가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43e02a0b48e4866d690b1c507a06fd483627e959" translate="yes" xml:space="preserve">
          <source>Clients serialize URLs with &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;%20&lt;/code&gt; for spaces. Yet in RewriteRules they're interpreted with literal characters for all relative path segments.</source>
          <target state="translated">클라이언트는 공백으로 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;%20&lt;/code&gt; URL을 직렬화합니다. 그러나 RewriteRules에서는 모든 상대 경로 세그먼트에 대한 리터럴 문자로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="46769ed18c1d5803b546e2a6cb333b52cf026f52" translate="yes" xml:space="preserve">
          <source>Comment your &lt;code&gt;.htaccess&lt;/code&gt;</source>
          <target state="translated">당신의 &lt;code&gt;.htaccess&lt;/code&gt; 를 주석</target>
        </trans-unit>
        <trans-unit id="2596cd693395e24245479f2e31c3c578dd845a59" translate="yes" xml:space="preserve">
          <source>Disable &lt;code&gt;MultiViews&lt;/code&gt; when virtual paths overlap</source>
          <target state="translated">가상 경로가 겹칠 때 &lt;code&gt;MultiViews&lt;/code&gt; 비활성화</target>
        </trans-unit>
        <trans-unit id="36883655179b6ab85d480c08f87d30869c5f79e2" translate="yes" xml:space="preserve">
          <source>Dispatching related URLs to different backends</source>
          <target state="translated">관련 URL을 다른 백엔드로 디스패치</target>
        </trans-unit>
        <trans-unit id="e0840dbd1ccf3f820f75b9f6644ac7b4d5be4bb3" translate="yes" xml:space="preserve">
          <source>Do's and Dont's in &lt;a href=&quot;https://stackoverflow.com/questions/286004/hidden-features-of-mod-rewrite&quot;&gt;Hidden features of mod_rewrite&lt;/a&gt;.</source>
          <target state="translated">해야 할 것과하지 말아야 할 &lt;a href=&quot;https://stackoverflow.com/questions/286004/hidden-features-of-mod-rewrite&quot;&gt;것은 mod_rewrite의 숨겨진 기능입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="834ed7f21faa963f6520622a494bfc3b58b1ba55" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;RewriteBase&lt;/code&gt; unless needed</source>
          <target state="translated">필요한 경우가 아니면 &lt;code&gt;RewriteBase&lt;/code&gt; 를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="21f659d7912dac24fb0f151d94dc06f47abae6ad" translate="yes" xml:space="preserve">
          <source>Each of these placeholders is usually wrapped in &lt;code&gt;(&amp;hellip;)&lt;/code&gt; parentheses as capture group. And the whole pattern often in &lt;code&gt;^&amp;hellip;&amp;hellip;&amp;hellip;$&lt;/code&gt; start + end markers. Quoting &quot;patterns&quot; is optional.</source>
          <target state="translated">이러한 각 자리 표시자는 일반적으로 캡처 그룹으로 &lt;code&gt;(&amp;hellip;)&lt;/code&gt; 괄호로 묶습니다. 그리고 전체 패턴은 종종 &lt;code&gt;^&amp;hellip;&amp;hellip;&amp;hellip;$&lt;/code&gt; 시작 + 끝 마커로 표시됩니다. &quot;패턴&quot;을 인용하는 것은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="9b7029c092a10a71829815573236b3eb076aec29" translate="yes" xml:space="preserve">
          <source>Each set of &lt;code&gt;(&amp;hellip;)&lt;/code&gt; parentheses represents a regular expression that we can capture as a variable in the right hand side of the rule. In this example:</source>
          <target state="translated">각 &lt;code&gt;(&amp;hellip;)&lt;/code&gt; 괄호 세트는 규칙의 오른쪽에서 변수로 캡처 할 수있는 정규식을 나타냅니다. 이 예에서 :</target>
        </trans-unit>
        <trans-unit id="db48663f832a68a6cc97ff86160706f75f79b09e" translate="yes" xml:space="preserve">
          <source>Else &lt;a href=&quot;http://www.regular-expressions.info/quickstart.html&quot;&gt;regexp.info&lt;/a&gt; for easy-to-understand basics.</source>
          <target state="translated">이해하기 쉬운 기본 사항에 대해서는 &lt;a href=&quot;http://www.regular-expressions.info/quickstart.html&quot;&gt;regexp.info&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d919900346eee940f930da58592f8601027964df" translate="yes" xml:space="preserve">
          <source>Enable &lt;a href=&quot;http://httpd.apache.org/docs/2.4/mod/mod_negotiation.html&quot;&gt;MultiViews&lt;/a&gt; to hide the &lt;code&gt;.php&lt;/code&gt; extension</source>
          <target state="translated">&lt;a href=&quot;http://httpd.apache.org/docs/2.4/mod/mod_negotiation.html&quot;&gt;MultiViews&lt;/a&gt; 가 &lt;code&gt;.php&lt;/code&gt; 확장자를 숨기도록 설정</target>
        </trans-unit>
        <trans-unit id="d89cfbe7e9590212bd8db77d7953dd70c27090a7" translate="yes" xml:space="preserve">
          <source>Enable &lt;code&gt;mod_rewrite&lt;/code&gt; and &lt;code&gt;.htaccess&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mod_rewrite&lt;/code&gt; 및 &lt;code&gt;.htaccess&lt;/code&gt; 활성화</target>
        </trans-unit>
        <trans-unit id="67f47d9d91b10c7848ba3ab2eb234427fa6f3b4d" translate="yes" xml:space="preserve">
          <source>Ensuring URLs are long-lived (AKA &lt;a href=&quot;https://en.wikipedia.org/wiki/Permalink&quot;&gt;permalinks&lt;/a&gt;).</source>
          <target state="translated">URL의 수명이 길다 (AKA &lt;a href=&quot;https://en.wikipedia.org/wiki/Permalink&quot;&gt;permalinks&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d77e818c790de6920af7153aa064da2c1e29276" translate="yes" xml:space="preserve">
          <source>Even a plain &lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/core.html#errordocument&quot;&gt;&lt;code&gt;ErrorDocument&lt;/code&gt;&lt;/a&gt; directive could be used to let a PHP script handle virtual paths. Note that this is a kludgy workaround however, prohibits anything but GET requests, and floods the error.log by definition.</source>
          <target state="translated">PHP 스크립트가 가상 경로를 처리하도록 일반 &lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/core.html#errordocument&quot;&gt; &lt;code&gt;ErrorDocument&lt;/code&gt; &lt;/a&gt; 지시문도 사용할 수 있습니다. 그러나 이것은 해결하기 어려운 해결책이지만 GET 요청 이외의 것은 금지하고 error.log를 정의에 따라 넘칩니다.</target>
        </trans-unit>
        <trans-unit id="83ec6145cb84f0dee900769119e35d59b3e7d752" translate="yes" xml:space="preserve">
          <source>Firstly, mod_rewrite does not randomly disengage. (If it did, you'd have bigger problems).</source>
          <target state="translated">첫째, mod_rewrite는 임의로 분리되지 않습니다. (그렇다면 더 큰 문제가 생길 것입니다).</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="b6f02d776f09f6cec4c828de71faf43799655041" translate="yes" xml:space="preserve">
          <source>Flexible segments for virtual paths</source>
          <target state="translated">가상 경로를위한 유연한 세그먼트</target>
        </trans-unit>
        <trans-unit id="09583105ba9e06aa15f198d86b54559183928403" translate="yes" xml:space="preserve">
          <source>For the also common</source>
          <target state="translated">또한 일반적인</target>
        </trans-unit>
        <trans-unit id="8ca49966ea1f0234f7d955d0b2e1ff4363d986f2" translate="yes" xml:space="preserve">
          <source>Fret not.</source>
          <target state="translated">걱정하지 마세요.</target>
        </trans-unit>
        <trans-unit id="8f0e67b093d5ce42b53747a234dad6c49e986688" translate="yes" xml:space="preserve">
          <source>Having readable and obvious resource schemes.</source>
          <target state="translated">읽기 쉽고 명백한 리소스 체계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="10aa48f30ba9eb1d996b4bdcdaa78b540e6ae835" translate="yes" xml:space="preserve">
          <source>However don't sacrifice unique requirements for conformism.</source>
          <target state="translated">그러나 적합성에 대한 고유 한 요구 사항을 희생하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1fba90fa899b377cb4751fbd5881d6c42e5b6ba4" translate="yes" xml:space="preserve">
          <source>However you &lt;strong&gt;don't want&lt;/strong&gt; that usually in your own &lt;code&gt;.htaccess&lt;/code&gt; files.</source>
          <target state="translated">그러나 일반적으로 자신의 &lt;code&gt;.htaccess&lt;/code&gt; 파일 &lt;strong&gt;에는 원하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="daa5192ba9695ec4caf7b9bc31881436591ba4e2" translate="yes" xml:space="preserve">
          <source>If you copy examples from somewhere, take care to include a &lt;code&gt;# comment and origin link&lt;/code&gt;. While it's merely bad manners to omit attribution,
it often really hurts maintenance later. Document any code or tutorial source. In particular while unversed you should be
all the more interested in not treating them like magic blackboxes.</source>
          <target state="translated">어딘가에서 예제를 복사하는 경우 &lt;code&gt;# comment and origin link&lt;/code&gt; 를 포함하도록주의 하십시오 . 속성을 생략하는 것은 나쁜 방법 일 뿐이지 만 나중에 유지 관리에 많은 영향을줍니다. 모든 코드 또는 튜토리얼 소스를 문서화하십시오. 특히 미지의 동안 당신은 그들을 마법의 블랙 박스처럼 취급하지 않는 것에 더 관심을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="7bc07c648dc6661d82cf032a6a1256aa5c8a86f1" translate="yes" xml:space="preserve">
          <source>If you have similar rules for multiple virtual page paths, then you can match and compact them with &lt;code&gt;|&lt;/code&gt; alternative lists. And again just reassign them to internal GET parameters:</source>
          <target state="translated">여러 가상 페이지 경로에 대해 유사한 규칙이있는 경우 &lt;code&gt;|&lt;/code&gt; 대체 목록. 그리고 다시 내부 GET 매개 변수에 다시 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="40f9b2a7a4a9787f861888f20e6f6fee7c69fed5" translate="yes" xml:space="preserve">
          <source>If you need up to five path segments, then copy this scheme along into five rules. You can of course use a more specific &lt;code&gt;[^/]+&lt;/code&gt; placeholder each.
Here the ordering isn't as important, as neither overlaps. So having the most frequently used paths first is okay.</source>
          <target state="translated">최대 5 개의 경로 세그먼트가 필요한 경우이 체계를 5 개의 규칙으로 복사하십시오. 물론보다 구체적인 &lt;code&gt;[^/]+&lt;/code&gt; 자리 표시자를 각각 사용할 수 있습니다. 여기서 순서는 겹치지 않기 때문에 중요하지 않습니다. 따라서 가장 자주 사용되는 경로를 먼저 갖는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f71191a5e264cb63bd6f631ed5e3481ceef06433" translate="yes" xml:space="preserve">
          <source>If you're using RewriteRules in a per-directory config file, then worrying about regex performance is pointless. Apache retains
compiled PCRE patterns longer than a PHP process with a common routing framework. For high-traffic sites you should however consider
moving rulesets into the vhost server configuration, once they've been battle-tested.</source>
          <target state="translated">디렉토리 별 구성 파일에서 RewriteRules를 사용하는 경우 정규 표현식 성능에 대한 걱정은 의미가 없습니다. Apache는 공통 라우팅 프레임 워크를 사용하여 PHP 프로세스보다 더 긴 컴파일 된 PCRE 패턴을 유지합니다. 트래픽이 많은 사이트의 경우 규칙 테스트가 완료되면 규칙 세트를 가상 호스트 서버 구성으로 이동하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="273b2c2b5a292ce481ed96ebfa83369d2f85daa8" translate="yes" xml:space="preserve">
          <source>In this case, prefer the optionalized &lt;code&gt;^/?&lt;/code&gt; directory separator prefix. This allows to move RewriteRules freely between PerDir and server
config files.</source>
          <target state="translated">이 경우 선택 사항 인 &lt;code&gt;^/?&lt;/code&gt; 디렉토리 구분 기호 접두사. 이를 통해 PerDir과 서버 구성 파일간에 RewriteRules를 자유롭게 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef9108cecb21bfcd735b644678196233a16cf35" translate="yes" xml:space="preserve">
          <source>Include &lt;em&gt;full&lt;/em&gt; examples of input URLs, falsly rewritten target paths, your real directory structure.</source>
          <target state="translated">입력 URL, 잘못 작성된 대상 경로, 실제 디렉토리 구조의 &lt;em&gt;전체&lt;/em&gt; 예제를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="f296f7312d86d0df48d961f47b8c11e9d5bcef5b" translate="yes" xml:space="preserve">
          <source>Introducing shortcuts like &lt;code&gt;http://example.com/article/531&lt;/code&gt; to existing PHP scripts is also easy. The numeric placeholder can just be remapped to a &lt;code&gt;$_GET&lt;/code&gt; parameter:</source>
          <target state="translated">기존 PHP 스크립트에 &lt;code&gt;http://example.com/article/531&lt;/code&gt; 과 같은 바로 가기를 소개하는 것도 쉽습니다. 숫자 자리 표시자는 &lt;code&gt;$_GET&lt;/code&gt; 매개 변수로 다시 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deccb5a329125b3a2543074f3d0db866e73f9a4d" translate="yes" xml:space="preserve">
          <source>It &lt;em&gt;does&lt;/em&gt; make sense in &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; sections - if it was combined with another fallback option, such as ScriptAliasMatch. (But nobody ever does that).</source>
          <target state="translated">ScriptAliasMatch와 같은 다른 폴백 옵션과 결합 된 경우 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 섹션에서 의미가 있습니다. (그러나 아무도 그렇게하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="0301879fb32bdc77402f7413db66117a874fb2e3" translate="yes" xml:space="preserve">
          <source>It makes sense to use with individual web applications in deeper subdirectories. It can shorten RewriteRule patterns in such cases. Generally it's best to prefer relative path specifiers in per-directory rule sets.</source>
          <target state="translated">더 깊은 하위 디렉토리의 개별 웹 응용 프로그램과 함께 사용하는 것이 좋습니다. 이러한 경우 RewriteRule 패턴을 단축 할 수 있습니다. 일반적으로 디렉토리 별 규칙 세트에서 상대 경로 지정자를 선호하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5f40de2ca60f034f9b89abc054587e9fe0b8a168" translate="yes" xml:space="preserve">
          <source>It's meant to prevent HTTP &lt;code&gt;500&lt;/code&gt; errors. What it usually accomplishes is gracing your users with HTTP &lt;code&gt;404&lt;/code&gt; errors instead. (Not &lt;em&gt;so much&lt;/em&gt; more user-friendly if you think about it.)</source>
          <target state="translated">HTTP &lt;code&gt;500&lt;/code&gt; 오류를 방지하기위한 것입니다. 일반적으로 달성하는 것은 HTTP &lt;code&gt;404&lt;/code&gt; 오류로 사용자를 매기는 것입니다. (생각하면 &lt;em&gt;훨씬&lt;/em&gt; 사용자 친화적이지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="fe7d59926a852a088beeaaee3db79063e7eb9f5e" translate="yes" xml:space="preserve">
          <source>It's not &quot;SEO&quot;-URLs</source>
          <target state="translated">&quot;SEO&quot;가 아닙니다. URL</target>
        </trans-unit>
        <trans-unit id="60cd4fcec9f18f17da87abdc46607c7a489cd1f3" translate="yes" xml:space="preserve">
          <source>It's not &lt;em&gt;that pretty&lt;/em&gt; in browser address bars, but you can use spaces in URLs. For rewrite patterns use backslash-escaped &lt;code&gt;\␣&lt;/code&gt; spaces.
Else just &lt;code&gt;&quot;&lt;/code&gt;-quote the whole pattern or substitution:</source>
          <target state="translated">브라우저 주소 표시 줄에는 그다지 좋지 않지만 URL에 공백을 사용할 수 있습니다. 다시 쓰기 패턴의 경우 백 슬래시 이스케이프 된 &lt;code&gt;\␣&lt;/code&gt; 공백을 사용하십시오. 그렇지 않으면 &lt;code&gt;&quot;&lt;/code&gt; 전체 패턴 또는 대체를 인용하십시오.</target>
        </trans-unit>
        <trans-unit id="bfc7e888699007054c60bf571793536b40294c92" translate="yes" xml:space="preserve">
          <source>Left hand side of the rule</source>
          <target state="translated">규칙의 왼쪽</target>
        </trans-unit>
        <trans-unit id="6bee440a86949e7ccce05e9ca4299268e30a2049" translate="yes" xml:space="preserve">
          <source>Lets take this example:</source>
          <target state="translated">이 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="3d960efa71adf65b880313cd6447fa5c5f98e928" translate="yes" xml:space="preserve">
          <source>Look through our &lt;a href=&quot;https://stackoverflow.com/questions/tagged/mod-rewrite?sort=frequent&quot;&gt;most popular mod-rewrite&lt;/a&gt; questions and answers.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/tagged/mod-rewrite?sort=frequent&quot;&gt;가장 인기있는 모드 재 작성&lt;/a&gt; 질문과 답변을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="fe7bfd847a60a74d96670220635ed35de8d744bc" translate="yes" xml:space="preserve">
          <source>Many basic virtual URL schemes can be achieved without using RewriteRules. Apache allows PHP scripts to be invoked without &lt;code&gt;.php&lt;/code&gt; extension, and with a virtual &lt;code&gt;PATH_INFO&lt;/code&gt; argument.</source>
          <target state="translated">RewriteRules를 사용하지 않고도 많은 기본 가상 URL 체계를 달성 할 수 있습니다. Apache는 PHP 스크립트를 &lt;code&gt;.php&lt;/code&gt; 확장자없이 가상 &lt;code&gt;PATH_INFO&lt;/code&gt; 인수로 호출 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2488526091aa3f6c4f0c336210e3a1890b4fed46" translate="yes" xml:space="preserve">
          <source>Many copy+paste examples contain a &lt;code&gt;RewriteBase /&lt;/code&gt; directive. Which happens to be the implicit default anyway. So you don't actually need this. It's a workaround for fancy VirtualHost rewriting schemes, and misguessed DOCUMENT_ROOT paths for some shared hosters.</source>
          <target state="translated">많은 복사 + 붙여 넣기 예에는 &lt;code&gt;RewriteBase /&lt;/code&gt; 지시문이 포함되어 있습니다. 어쨌든 암시 적 기본값이됩니다. 따라서 실제로는 필요하지 않습니다. 멋진 VirtualHost 다시 쓰기 체계에 대한 해결 방법이며 일부 공유 호스팅 업체의 DOCUMENT_ROOT 경로를 잘못 추측했습니다.</target>
        </trans-unit>
        <trans-unit id="b6ec4f0b45ba608dc99259ba104501c3006e2b98" translate="yes" xml:space="preserve">
          <source>Most rules you'll encounter map a constrained set of &lt;code&gt;/&amp;hellip;/&lt;/code&gt; resource path segments to individual GET parameters. Some scripts &lt;a href=&quot;https://stackoverflow.com/q/3655893&quot;&gt;handle a variable number of options&lt;/a&gt; however.
The Apache regexp engine doesn't allow optionalizing an arbitrary number of them. But you can easily expand it into a rule block yourself:</source>
          <target state="translated">발생하는 대부분의 규칙은 제한된 /.../ 자원 경로 세그먼트 세트를 개별 GET 매개 변수에 맵핑합니다. 그러나 일부 스크립트 &lt;a href=&quot;https://stackoverflow.com/q/3655893&quot;&gt;는 다양한 옵션을 처리합니다&lt;/a&gt; . Apache regexp 엔진은 임의의 수의 옵션을 선택할 수 없습니다. 그러나 쉽게 규칙 블록으로 쉽게 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91486619ecb50e8edbf96d3a9061ef481aa26b8d" translate="yes" xml:space="preserve">
          <source>Mostly just output &lt;code&gt;[^/]+&lt;/code&gt; generic placeholders, but likely suffices for trivial sites.</source>
          <target state="translated">일반적으로 &lt;code&gt;[^/]+&lt;/code&gt; 일반 자리 표시 자만 출력하지만 사소한 사이트에는 충분합니다.</target>
        </trans-unit>
        <trans-unit id="1d74e7db0e0fdb1eefe36a8b715de7d180085193" translate="yes" xml:space="preserve">
          <source>None of the modern search engines are really disturbed by &lt;code&gt;.html&lt;/code&gt; and &lt;code&gt;.php&lt;/code&gt; in path segments, or &lt;code&gt;?id=123&lt;/code&gt; query strings for that matter. Search engines of old, such as AltaVista, &lt;em&gt;did&lt;/em&gt; avoid crawling websites with potentially ambigious access paths. Modern crawlers are often even craving for deep web resources.</source>
          <target state="translated">현대 검색 엔진은 경로 세그먼트의 &lt;code&gt;.html&lt;/code&gt; 및 &lt;code&gt;.php&lt;/code&gt; 또는 그 문제에 대한 &lt;code&gt;?id=123&lt;/code&gt; 쿼리 문자열로 실제로 방해받지 않습니다. AltaVista와 같은 오래된 검색 엔진은 잠재적으로 모호한 액세스 경로를 가진 웹 사이트를 크롤링 &lt;em&gt;하지 않았습니다&lt;/em&gt; . 최신 크롤러는 종종 깊은 웹 리소스를 원합니다.</target>
        </trans-unit>
        <trans-unit id="f315ee6a0a369040aac7c320f6906f7802ad2aa3" translate="yes" xml:space="preserve">
          <source>Note how this example just uses &lt;code&gt;[END]&lt;/code&gt; instead of &lt;code&gt;[L]&lt;/code&gt; to safely alternate. For older Apache 2.2 versions you can use other workarounds, besides also remapping
query string parameters for example:
&lt;a href=&quot;https://stackoverflow.com/questions/11629896/mod-rewrite-redirect-url-with-query-string-to-pretty-url&quot;&gt;Redirect ugly to pretty URL, remap  back to the ugly path, without infinite loops&lt;/a&gt;</source>
          <target state="translated">이 예제는 &lt;code&gt;[L]&lt;/code&gt; 대신 &lt;code&gt;[END]&lt;/code&gt; 를 사용하여 안전하게 대체하는 방법에 유의하십시오. 이전 Apache 2.2 버전의 경우 쿼리 문자열 매개 변수를 다시 매핑하는 것 외에도 다른 해결 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc7223f3c5a01865151b0532dd2483e959ec3aa6" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;your script&lt;/em&gt;&lt;strong&gt;must&lt;/strong&gt; be able (or be adapted) to map those titles back to database-ids. RewriteRules alone can't create or guess information out of thin air.</source>
          <target state="translated">&lt;em&gt;스크립트&lt;/em&gt; &lt;strong&gt;가&lt;/strong&gt; 해당 제목을 다시 데이터베이스 ID에 매핑 할 수 &lt;strong&gt;있어야합니다&lt;/strong&gt; . 규칙만으로는 정보가 허술한 정보를 만들거나 추측 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c2965817441b972dd6422436654a2df9f92c29e" translate="yes" xml:space="preserve">
          <source>Note that MultiViews has a different/broader purpose though. It incurs a &lt;em&gt;very minor&lt;/em&gt; performance penalty, because Apache always looks for other files with matching basenames. It's actually meant for &lt;a href=&quot;https://en.wikipedia.org/wiki/Content_negotiation&quot;&gt;Content-Negotiation&lt;/a&gt;, so browsers receive the best alternative among available resources (such as &lt;code&gt;article.en.php&lt;/code&gt;, &lt;code&gt;article.fr.php&lt;/code&gt;, &lt;code&gt;article.jp.mp4&lt;/code&gt;).</source>
          <target state="translated">MultiViews는 다른 / 광범위한 목적을 가지고 있습니다. Apache는 항상 기본 이름이 일치하는 다른 파일을 찾기 때문에 성능이 &lt;em&gt;약간&lt;/em&gt; 저하됩니다. 실제로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Content_negotiation&quot;&gt;Content-Negotiation을&lt;/a&gt; 의미하므로 브라우저는 사용 가능한 리소스 중에서 가장 좋은 대안을받습니다 (예 : &lt;code&gt;article.en.php&lt;/code&gt; , &lt;code&gt;article.fr.php&lt;/code&gt; , &lt;code&gt;article.jp.mp4&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="421dacfb060756bed4005a3f4a19279a8d0a45ad" translate="yes" xml:space="preserve">
          <source>Note that RewriteCond/RewriteRule combos can be more complex, with matches (&lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt;) interacting in both directions even:</source>
          <target state="translated">RewriteCond / RewriteRule 콤보는 다음과 같은 경우에도 일치하는 항목 ( &lt;code&gt;%1&lt;/code&gt; 및 &lt;code&gt;$1&lt;/code&gt; )을 사용하여 더 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed12e6e43435545c959aae1c59102e543bb2d305" translate="yes" xml:space="preserve">
          <source>Note that this doesn't copy a query string along, etc.</source>
          <target state="translated">이것은 쿼리 문자열을 복사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8965d98cc2645af0da6247a2206e79a972c91350" translate="yes" xml:space="preserve">
          <source>Now take this with a grain of salt. Not every advise can be generalized to all contexts.
This is just a simple summary of well-known and a few unobvious stumbling blocks:</source>
          <target state="translated">이제 소금 한알로 이것을 가져 가십시오. 모든 조언을 모든 상황에 대해 일반화 할 수있는 것은 아닙니다. 이것은 잘 알려진 몇 가지 명백한 걸림돌에 대한 간단한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="d1728adec405a6b225772abbd6bd1fd0974106ab" translate="yes" xml:space="preserve">
          <source>Now the more complex pattern &lt;code&gt;(?:/([^/])+)?&lt;/code&gt; there simply wraps a &lt;em&gt;non-capturing&lt;/em&gt;&lt;code&gt;(?:&amp;hellip;)&lt;/code&gt; group, and makes it optional &lt;code&gt;)?&lt;/code&gt;. The contained
placeholder &lt;code&gt;([^/]+)&lt;/code&gt; would be substitution pattern &lt;code&gt;$2&lt;/code&gt;, but be empty if there's no middle &lt;code&gt;/&amp;hellip;/&lt;/code&gt; path.</source>
          <target state="translated">이제 더 복잡한 패턴 &lt;code&gt;(?:/([^/])+)?&lt;/code&gt; 단순히 &lt;em&gt;캡처하지 않는&lt;/em&gt; &lt;code&gt;(?:&amp;hellip;)&lt;/code&gt; 그룹을 래핑하고 선택적으로 만듭니다 &lt;code&gt;)?&lt;/code&gt; . 포함 된 자리 표시 자 &lt;code&gt;([^/]+)&lt;/code&gt; 는 대체 패턴 &lt;code&gt;$2&lt;/code&gt; 이지만 중간 &lt;code&gt;/&amp;hellip;/&lt;/code&gt; 경로가 없으면 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="45683ef59f00892047993aca6b972c98e9a0ee43" translate="yes" xml:space="preserve">
          <source>Now this &lt;code&gt;/virtual/path&lt;/code&gt; shows up in PHP as &lt;a href=&quot;https://secure.php.net/manual/en/reserved.variables.server.php#~PATH_INFO&quot;&gt;&lt;code&gt;$_SERVER[&quot;PATH_INFO&quot;]&lt;/code&gt;&lt;/a&gt; where you can handle any extra arguments however you like.</source>
          <target state="translated">이제이 &lt;code&gt;/virtual/path&lt;/code&gt; 는 PHP에서 &lt;a href=&quot;https://secure.php.net/manual/en/reserved.variables.server.php#~PATH_INFO&quot;&gt; &lt;code&gt;$_SERVER[&quot;PATH_INFO&quot;]&lt;/code&gt; &lt;/a&gt; 되어 원하는대로 추가 인수를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f37afffd1053ca926ca822a035ccdafe43d5cba9" translate="yes" xml:space="preserve">
          <source>Now this can have some security and performance implications, because all extensionless files would be piped through PHP now. Therefore you can alternatively set this behaviour for individual files only:</source>
          <target state="translated">이제 모든 확장 파일이 PHP를 통해 파이프되기 때문에 보안 및 성능에 영향을 줄 수 있습니다. 따라서 개별 파일에 대해서만이 동작을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7867d100537d9098a99e4b192ff17b1002e490bb" translate="yes" xml:space="preserve">
          <source>Now this handles both &lt;code&gt;http://example.com/blog/123&lt;/code&gt; and &lt;code&gt;/blog/123/&lt;/code&gt;. And the</source>
          <target state="translated">이제 &lt;code&gt;http://example.com/blog/123&lt;/code&gt; 및 &lt;code&gt;/blog/123/&lt;/code&gt; 모두를 처리합니다. 그리고</target>
        </trans-unit>
        <trans-unit id="b48064afbe59853d0a5c42248122b5a14e1f1c10" translate="yes" xml:space="preserve">
          <source>Now you could just skip passing the &lt;code&gt;title=$2&lt;/code&gt; anyway, because your script will typically rely on the database-id anyway. The &lt;code&gt;-title-slug&lt;/code&gt; has become arbitrary URL decoration.</source>
          <target state="translated">스크립트는 일반적으로 데이터베이스 ID에 의존하기 때문에 &lt;code&gt;title=$2&lt;/code&gt; 전달을 건너 뛸 수 있습니다. &lt;code&gt;-title-slug&lt;/code&gt; 는 임의의 URL 장식이되었습니다.</target>
        </trans-unit>
        <trans-unit id="ed748a9515391cfb1af34a967ee70140171d18c6" translate="yes" xml:space="preserve">
          <source>Nowadays &lt;a href=&quot;http://httpd.apache.org/docs/2.4/en/mod/core.html#acceptpathinfo&quot;&gt;&lt;code&gt;AcceptPathInfo On&lt;/code&gt;&lt;/a&gt; is often enabled by default. Which basically allows &lt;code&gt;.php&lt;/code&gt; and other resource URLs to carry a virtual argument:</source>
          <target state="translated">요즘 &lt;a href=&quot;http://httpd.apache.org/docs/2.4/en/mod/core.html#acceptpathinfo&quot;&gt; &lt;code&gt;AcceptPathInfo On&lt;/code&gt; &lt;/a&gt; 은 종종 기본적으로 활성화되어 있습니다. 기본적으로 &lt;code&gt;.php&lt;/code&gt; 및 기타 리소스 URL이 가상 인수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0afd56482356096622a5660a16723100cd4fa634" translate="yes" xml:space="preserve">
          <source>Numeric identifiers</source>
          <target state="translated">숫자 식별자</target>
        </trans-unit>
        <trans-unit id="5f378de1046672c4099905b347e55ac91af76926" translate="yes" xml:space="preserve">
          <source>Obviously &lt;a href=&quot;https://stackoverflow.com/questions/869092/how-to-enable-mod-rewrite-for-apache-2-2&quot;&gt;have &lt;code&gt;mod_rewrite&lt;/code&gt; enabled&lt;/a&gt; in your &lt;code&gt;httpd.conf&lt;/code&gt; modules section.</source>
          <target state="translated">&lt;code&gt;httpd.conf&lt;/code&gt; 모듈 섹션에서 &lt;a href=&quot;https://stackoverflow.com/questions/869092/how-to-enable-mod-rewrite-for-apache-2-2&quot;&gt; &lt;code&gt;mod_rewrite&lt;/code&gt; 를 활성화&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="5ddb71358a682b6ae3c886c00e05b6ee0351e570" translate="yes" xml:space="preserve">
          <source>Occasionally it's suitable to alternate between &lt;code&gt;/&lt;/code&gt;-delimiters and &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; in the same rule even. Or have two RewriteRules again to map variants onto different scripts.</source>
          <target state="translated">때때로 &lt;code&gt;/&lt;/code&gt; 구분 기호와 &lt;code&gt;:&lt;/code&gt; 또는 사이를 번갈아 사용하는 것이 적합합니다 &lt;code&gt;.&lt;/code&gt; 같은 규칙으로도. 또는 변형을 다른 스크립트에 매핑하려면 두 개의 RewriteRules를 다시 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="382738c5157f5ee201cf389409adf7a1a5d95f2c" translate="yes" xml:space="preserve">
          <source>Oft-used placeholders</source>
          <target state="translated">자주 사용되는 자리 표시 자</target>
        </trans-unit>
        <trans-unit id="a4d4b59e499759015fe91837364116829ea9c319" translate="yes" xml:space="preserve">
          <source>Often simply by adding &lt;code&gt;&amp;lt;base href=&quot;/index&quot;&amp;gt;&lt;/code&gt; into your HTML &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; section.
This implicitly rebinds relative references to what they were before.</source>
          <target state="translated">종종 &lt;code&gt;&amp;lt;base href=&quot;/index&quot;&amp;gt;&lt;/code&gt; 를 HTML &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 섹션에 추가하면됩니다. 이것은 이전에 있던 것에 대한 상대적 참조를 암시 적으로 리 바인드합니다.</target>
        </trans-unit>
        <trans-unit id="64dd841b1c90885ac80fd0d55f39f4aa949aefcb" translate="yes" xml:space="preserve">
          <source>Often you can figure out how a RewriteRule misbehaves just from looking at your &lt;code&gt;error.log&lt;/code&gt; and &lt;code&gt;access.log&lt;/code&gt;.
Correlate access times to see which request path originally came in, and which path/file Apache couldn't resolve to (error 404/500).</source>
          <target state="translated">&lt;code&gt;error.log&lt;/code&gt; 및 &lt;code&gt;access.log&lt;/code&gt; 를 보면 RewriteRule이 어떻게 오작동하는지 파악할 수 있습니다. 액세스 시간을 연관시켜 원래 요청 경로와 Apache가 해석 할 수없는 경로 / 파일을 확인하십시오 (오류 404/500).</target>
        </trans-unit>
        <trans-unit id="0df724c30480f21eaa050c58057282993948b80e" translate="yes" xml:space="preserve">
          <source>Only using server-absolute references &lt;code&gt;href=&quot;/old.html&quot;&lt;/code&gt; or &lt;code&gt;src=&quot;/logo.png&quot;&lt;/code&gt;</source>
          <target state="translated">서버 절대 참조 만 사용 &lt;code&gt;href=&quot;/old.html&quot;&lt;/code&gt; 또는 &lt;code&gt;src=&quot;/logo.png&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="154c95281c3d555dc7266790046d6d0c55b5ef77" translate="yes" xml:space="preserve">
          <source>Optional segments</source>
          <target state="translated">선택적 세그먼트</target>
        </trans-unit>
        <trans-unit id="bf0dfa52ba48f0808d587223064703f75f816c3a" translate="yes" xml:space="preserve">
          <source>Optional trailing &lt;code&gt;/&lt;/code&gt; slash</source>
          <target state="translated">선택적 후행 &lt;code&gt;/&lt;/code&gt; 슬래시</target>
        </trans-unit>
        <trans-unit id="bd4bedf42533e868451f1a4c9022eac830c1394e" translate="yes" xml:space="preserve">
          <source>Ordering is important</source>
          <target state="translated">주문이 중요하다</target>
        </trans-unit>
        <trans-unit id="ed609198a95c9be6f04ce9d1d822a9807996d79c" translate="yes" xml:space="preserve">
          <source>Other Apache rewriting schemes</source>
          <target state="translated">다른 Apache 재 작성 체계</target>
        </trans-unit>
        <trans-unit id="81af1ba5d512fd109cf684ae0943af6787277fa0" translate="yes" xml:space="preserve">
          <source>Other common names, aliases, terms for clean URLs: &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; URLs, user-friendly URLs, &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt;-friendly URLs, &lt;a href=&quot;https://en.wikipedia.org/wiki/Clean_URL#Slug&quot;&gt;slugging&lt;/a&gt;, and MVC URLs (probably a misnomer)</source>
          <target state="translated">클린 URL에 대한 다른 일반적인 이름, 별명, 용어 : &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; URL, 사용자 친화적 URL, &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt; 친화적 URL, &lt;a href=&quot;https://en.wikipedia.org/wiki/Clean_URL#Slug&quot;&gt;슬러 깅&lt;/a&gt; 및 MVC URL (아마도 잘못된 이름)</target>
        </trans-unit>
        <trans-unit id="a2d1e8d66be83edd5b4bb78c85706e2242b6ca4d" translate="yes" xml:space="preserve">
          <source>Other common uses are remapping obsolete &lt;code&gt;.html&lt;/code&gt; paths to newer &lt;code&gt;.php&lt;/code&gt; handlers, or just aliasing directory names only for individual (actual/real) files.</source>
          <target state="translated">다른 일반적인 용도는 더 이상 사용되지 않는 &lt;code&gt;.html&lt;/code&gt; 경로를 최신 &lt;code&gt;.php&lt;/code&gt; 처리기로 다시 매핑하거나 개별 (실제 / 실제) 파일에 대해서만 별칭을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e22c6117eec085066b8864ee86848a7fc70b8391" translate="yes" xml:space="preserve">
          <source>Other delimiters than just &lt;code&gt;/&lt;/code&gt; path slashes</source>
          <target state="translated">그냥 &lt;code&gt;/&lt;/code&gt; 경로 슬래시 이외의 다른 구분 기호</target>
        </trans-unit>
        <trans-unit id="ad8bf9cefe3a521ea2a0949d248eaeec3191518a" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;/questions/tagged/regex&quot;&gt;regex&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/tags/regex/info&quot;&gt;tag wiki&lt;/a&gt; for a syntax compendium.</source>
          <target state="translated">구문 개요를위한 &lt;a href=&quot;/questions/tagged/regex&quot;&gt;정규식&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/tags/regex/info&quot;&gt;태그 위키&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed7ce6a62d983c526aa157e7a48cda050f92f59e" translate="yes" xml:space="preserve">
          <source>Ping-Pong (redirects and rewrites in unison)</source>
          <target state="translated">탁구 (일대일 리디렉션 및 재 작성)</target>
        </trans-unit>
        <trans-unit id="735003089a236c0d060fcfb96e6c5c0337f5d272" translate="yes" xml:space="preserve">
          <source>Practically it just suppresses the more useful log entries, or server notification mails. You'd be &lt;strong&gt;none the wiser&lt;/strong&gt; as to why your RewriteRules never work.</source>
          <target state="translated">실제로 더 유용한 로그 항목 또는 서버 알림 메일을 억제합니다. 왜 RewriteRules가 작동하지 않는지에 &lt;strong&gt;대해 더 현명한 사람은&lt;/strong&gt; 아닙니다.</target>
        </trans-unit>
        <trans-unit id="62b88add85f24690a5fdaa48492419bf137450cf" translate="yes" xml:space="preserve">
          <source>Prepend each list of rules with &lt;code&gt;RewriteEngine On&lt;/code&gt; still. While mod_rewrite is implicitly active in &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; sections,
the per-directory &lt;code&gt;.htaccess&lt;/code&gt; files need it individually summoned.</source>
          <target state="translated">&lt;code&gt;RewriteEngine On&lt;/code&gt; 을 사용 하여 각 규칙 목록을 앞에 추가하십시오. &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; 섹션에서 mod_rewrite가 암시 적으로 활성화되어 있지만 디렉토리 별 &lt;code&gt;.htaccess&lt;/code&gt; 파일은 개별적으로 소환해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d460c402637ee80e5cbe8fb8827d4a768e09bd5" translate="yes" xml:space="preserve">
          <source>Prevalent &lt;code&gt;.htaccess&lt;/code&gt; pitfalls</source>
          <target state="translated">널리 퍼진 &lt;code&gt;.htaccess&lt;/code&gt; 함정</target>
        </trans-unit>
        <trans-unit id="20511274c0bc24f9a1ab6b20592c13f82d99001b" translate="yes" xml:space="preserve">
          <source>Primarily you put these rewrite rules into your &lt;em&gt;web server configuration file&lt;/em&gt;. Apache also allows* you to put them into a file called &lt;code&gt;.htaccess&lt;/code&gt; within your document root (i.e. next to your .php files).</source>
          <target state="translated">기본적으로 이러한 다시 쓰기 규칙을 &lt;em&gt;웹 서버 구성 파일에&lt;/em&gt; 넣습니다. 또한 아파치는 문서 루트 내 (즉, .php 파일 옆)에 &lt;code&gt;.htaccess&lt;/code&gt; 라는 파일에 파일을 넣을 수 있도록한다.</target>
        </trans-unit>
        <trans-unit id="06be8bc5c902a2c2133ad9c03a3c1779b99bf463" translate="yes" xml:space="preserve">
          <source>Providing discoverability through &lt;code&gt;/common/tree/nesting&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/common/tree/nesting&lt;/code&gt; 을 통한 검색 가능성 제공</target>
        </trans-unit>
        <trans-unit id="e64b81cf93d82d98226806bc2fc8bb197ca884ba" translate="yes" xml:space="preserve">
          <source>QUERY_STRING exempt from RewriteRules</source>
          <target state="translated">QUERY_STRING이 RewriteRules에서 면제</target>
        </trans-unit>
        <trans-unit id="4d404d57141e26e7d22d02e55784084ff540a4ad" translate="yes" xml:space="preserve">
          <source>Redirect subdomain to a folder</source>
          <target state="translated">하위 도메인을 폴더로 리디렉션</target>
        </trans-unit>
        <trans-unit id="063e567c28ac61d9564af15349713acbb573d5e8" translate="yes" xml:space="preserve">
          <source>Redirect to &lt;code&gt;HTTPS://&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HTTPS://&lt;/code&gt; 로 리디렉션</target>
        </trans-unit>
        <trans-unit id="722b8910bdb4f2c78164bcda5bd90f374a6c66ef" translate="yes" xml:space="preserve">
          <source>Reference: mod_rewrite, URL rewriting and “pretty links” explained</source>
          <target state="translated">참조 : mod_rewrite, URL 재 작성 및 &quot;pretty 링크&quot;설명</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="b3a5d38cea5644b9e304ef62096e6a606a4a0fc6" translate="yes" xml:space="preserve">
          <source>Remove &lt;code&gt;www.&lt;/code&gt; from hostname</source>
          <target state="translated">&lt;code&gt;www.&lt;/code&gt; 제거하십시오 . 호스트 이름에서</target>
        </trans-unit>
        <trans-unit id="8dc518c3281af6a76845d45893812e8170cd0c54" translate="yes" xml:space="preserve">
          <source>Rewrite Conditions</source>
          <target state="translated">재 작성 조건</target>
        </trans-unit>
        <trans-unit id="0415eb50a540339c28aa38e25535d693e139d107" translate="yes" xml:space="preserve">
          <source>Rewrite Example</source>
          <target state="translated">재 작성 예</target>
        </trans-unit>
        <trans-unit id="87715289f6fd0761155779b729e2b1ef1f55f404" translate="yes" xml:space="preserve">
          <source>Rewrite from URL like &quot;/page&quot; to a script such as &quot;/index.php/page&quot;</source>
          <target state="translated">&quot;/ page&quot;와 같은 URL에서 &quot;/index.php/page&quot;와 같은 스크립트로 다시 작성</target>
        </trans-unit>
        <trans-unit id="54ae8a2bb1e1e0463d622aac404cc75b66ddf407" translate="yes" xml:space="preserve">
          <source>RewriteConds just mask one RewriteRule</source>
          <target state="translated">RewriteConds는 하나의 RewriteRule 만 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="243d3756aea59bb3aca4be6b1c289ef6f5eac31f" translate="yes" xml:space="preserve">
          <source>RewriteRules</source>
          <target state="translated">RewriteRules</target>
        </trans-unit>
        <trans-unit id="6f3c0b0fa9441f73d1225a5ad3aebf8aa68e29c8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://httpd.apache.org/docs/2.2/urlmapping.html&quot;&gt;http://httpd.apache.org/docs/2.2/urlmapping.html&lt;/a&gt; for further tips.</source>
          <target state="translated">추가 팁은 &lt;a href=&quot;http://httpd.apache.org/docs/2.2/urlmapping.html&quot;&gt;http://httpd.apache.org/docs/2.2/urlmapping.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7734994bbf366e6199ab98306f2955556acb72dc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://serverfault.com/questions/214512/redirect-change-urls-or-redirect-http-to-https-in-apache-everything-you-ever&quot;&gt;Everything you ever wanted to know about mod_rewrite&lt;/a&gt;
if you haven't already. Combining multiple RewriteRules often leads to interaction. This isn't something to prevent habitually per &lt;code&gt;[L]&lt;/code&gt; flag, but a scheme you'll embrace once versed.
You &lt;strong&gt;can &lt;em&gt;re-re-re&lt;/em&gt;write&lt;/strong&gt; virtual paths from one rule to another, until it reaches an actual target handler.</source>
          <target state="translated">&lt;a href=&quot;https://serverfault.com/questions/214512/redirect-change-urls-or-redirect-http-to-https-in-apache-everything-you-ever&quot;&gt;mod_rewrite에 대해 알고 싶은 모든 것을&lt;/a&gt; 참조하십시오. 여러 RewriteRules를 결합하면 종종 상호 작용이 발생합니다. 이것은 &lt;code&gt;[L]&lt;/code&gt; 플래그에 따라 습관적으로 방지 할 수있는 것이 아니라 한 번 정복 한 계획입니다. 가상 경로가 실제 대상 핸들러에 도달 할 때까지 한 규칙에서 다른 규칙으로 가상 경로를 &lt;strong&gt;&lt;em&gt;다시 다시&lt;/em&gt; 작성할&lt;/strong&gt; 수 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="769cf2ef46bdfff4b362894473e1b5713284e118" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/q/265898&quot;&gt;mod_rewrite, php and the .htaccess file&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/265898&quot;&gt;mod_rewrite, php 및 .htaccess 파일을&lt;/a&gt; 참조하십시오</target>
        </trans-unit>
        <trans-unit id="22c8fcf96a97b6e5abcdae84c4db3db1d01058d9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/questions/2978907/how-can-i-get-my-htaccess-to-work-subdomains&quot;&gt;How can i get my htaccess to work (subdomains)?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/2978907/how-can-i-get-my-htaccess-to-work-subdomains&quot;&gt;htaccess를 어떻게 작동시킬 수 있습니까 (하위 도메인)?를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="006a84e14e20a75e524061fa1fe8dba5660bdff1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://wiki.apache.org/httpd/RewriteLog&quot;&gt;Apache RewriteLog&lt;/a&gt; docs. For debugging you can enable it in the vhost sections:</source>
          <target state="translated">&lt;a href=&quot;https://wiki.apache.org/httpd/RewriteLog&quot;&gt;Apache RewriteLog&lt;/a&gt; 문서를 참조하십시오. 디버깅을 위해 vhost 섹션에서이를 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cd936e48a20e2da69c8f25159cd8cbee422363f" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/questions/2252238/how-can-i-match-query-string-variables-with-mod-rewrite&quot;&gt;How can I match query string variables with mod_rewrite?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/2252238/how-can-i-match-query-string-variables-with-mod-rewrite&quot;&gt;쿼리 문자열 변수를 mod_rewrite와 어떻게 일치시킬 수 있습니까?를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef15dc12c82e77842eafff393a8434759690e4c5" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/questions/704102/how-does-rewritebase-work-in-htaccess&quot;&gt;How does RewriteBase work in .htaccess&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/704102/how-does-rewritebase-work-in-htaccess&quot;&gt;.htaccess에서 RewriteBase의 작동 방식을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="8de810eb4c19512b1bcf1333a62369476c4d7c77" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;https://stackoverflow.com/questions/27744603/css-js-and-images-do-not-display-with-pretty-url&quot;&gt;CSS, JS and images do not display with pretty url&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/27744603/css-js-and-images-do-not-display-with-pretty-url&quot;&gt;CSS, JS 및 이미지가 예쁜 URL로 표시되지 않음&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3db13cb00377ed34be5480543c7e55ed4f98496" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;https://stackoverflow.com/questions/3655893&quot;&gt;How do I transform my URL path segments into query string key-value pairs?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/3655893&quot;&gt;URL 경로 세그먼트를 쿼리 문자열 키-값 쌍으로 변환하려면 어떻게합니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b77f4be08babffac9435d191760ac9736013dd5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;https://stackoverflow.com/questions/4908122/removing-the-php-extension-with-mod-rewrite&quot;&gt;Removing the .php extension with mod_rewrite&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4908122/removing-the-php-extension-with-mod-rewrite&quot;&gt;mod_rewrite를 사용하여 .php 확장자 제거&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="566b13b8f401ee2428d3cd8f11f3c6fe104dc463" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;https://wiki.apache.org/httpd/RewriteHTTPToHTTPS&quot;&gt;https://wiki.apache.org/httpd/RewriteHTTPToHTTPS&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;https://wiki.apache.org/httpd/RewriteHTTPToHTTPS&quot;&gt;https://wiki.apache.org/httpd/RewriteHTTPToHTTPS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f1913e2533a26bdd25c26d90fab7cc90bd95e2a" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;official documentation&lt;/a&gt; for all the possible flags and options.</source>
          <target state="translated">가능한 모든 플래그 및 옵션에 대해서는 &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;공식 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9fa04c4d408fbb4f618dc13714c5ebc1ab770915" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/remapping.html#backward-compatibility&quot;&gt;http://httpd.apache.org/docs/2.4/rewrite/remapping.html#backward-compatibility&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/remapping.html#backward-compatibility&quot;&gt;http://httpd.apache.org/docs/2.4/rewrite/remapping.html#backward-compatibility&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99e6a073ff5e6c011154a5c38d8a47d031eb6740" translate="yes" xml:space="preserve">
          <source>Serverfault: &lt;strong&gt;Everything you ever wanted to know about mod_rewrite&lt;/strong&gt;</source>
          <target state="translated">Serverfault : &lt;strong&gt;mod_rewrite에 대해 알고 싶은 모든 것&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="153142254f89758d473a9ea12c5e164444dc53cf" translate="yes" xml:space="preserve">
          <source>SetType or SetHandler for extensionless &lt;code&gt;.php&lt;/code&gt; scripts</source>
          <target state="translated">확장없는 &lt;code&gt;.php&lt;/code&gt; 스크립트를위한 SetType 또는 SetHandler</target>
        </trans-unit>
        <trans-unit id="5a864b80ff234f7cae642c6501bfd4c017e44fd0" translate="yes" xml:space="preserve">
          <source>Shortening a few page names to internal file schemes is most simple:</source>
          <target state="translated">내부 파일 체계로 몇 개의 페이지 이름을 줄이는 것이 가장 간단합니다.</target>
        </trans-unit>
        <trans-unit id="0b832bc70477bdef81bfff11de849565e3c94623" translate="yes" xml:space="preserve">
          <source>Since Apache 2.4 you can also use the &lt;code&gt;[END]&lt;/code&gt; flag. A matching rule with it will &lt;em&gt;completely&lt;/em&gt; terminate further alias/rewrite processing. (Whereas the &lt;code&gt;[L]&lt;/code&gt; flag can oftentimes trigger a second round, for example when rewriting into or out of subdirectories.)</source>
          <target state="translated">Apache 2.4부터 &lt;code&gt;[END]&lt;/code&gt; 플래그를 사용할 수도 있습니다. 이것과 일치하는 규칙은 추가 별칭 / 다시 쓰기 처리를 &lt;em&gt;완전히&lt;/em&gt; 종료합니다. (예를 들어 &lt;code&gt;[L]&lt;/code&gt; 플래그는 종종 하위 디렉토리에 또는 외부 디렉토리를 다시 쓸 때와 같이 두 번째 라운드를 트리거 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0b205cd34e49d99ca6bc4b7cfdc75f4c82118ad9" translate="yes" xml:space="preserve">
          <source>Slug-style placeholders</source>
          <target state="translated">슬러그 스타일 플레이스 홀더</target>
        </trans-unit>
        <trans-unit id="0126c12f6cbf075a76cababf0457921f8420def3" translate="yes" xml:space="preserve">
          <source>Slugs with numeric prefixes</source>
          <target state="translated">숫자 접두사가있는 슬러그</target>
        </trans-unit>
        <trans-unit id="ecebb061edd3e7bf58aa5e1134401163d6e5ea2c" translate="yes" xml:space="preserve">
          <source>So at some point you're rewriting your HTML pages to carry only pretty links, as &lt;a href=&quot;https://stackoverflow.com/a/20563773#~What+mod_rewrite+does+not+do&quot;&gt;outlined by deceze&lt;/a&gt;.
Meanwhile you'll still receive requests for the &lt;em&gt;old&lt;/em&gt; paths, sometimes even from bookmarks. As &lt;em&gt;workaround&lt;/em&gt;, you can ping-pong browsers to display/establish
the new URLs.</source>
          <target state="translated">따라서 어느 시점에서 &lt;a href=&quot;https://stackoverflow.com/a/20563773#~What+mod_rewrite+does+not+do&quot;&gt;deceze&lt;/a&gt; 로 요약 된 것처럼 예쁜 링크 만 전달하도록 HTML 페이지를 다시 작성합니다. 그 사이에도 여전히 &lt;em&gt;이전&lt;/em&gt; 경로에 대한 요청이, 때로는 책갈피로부터도 수신됩니다. &lt;em&gt;해결 방법&lt;/em&gt; 으로 핑퐁 브라우저를 사용하여 새 URL을 표시 / 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b584b52b28402594628cea231d8d1cd0eb03d50" translate="yes" xml:space="preserve">
          <source>Spaces</source>
          <target state="translated">Spaces</target>
        </trans-unit>
        <trans-unit id="85e989878c716e36b051efddbe0395a8c643d71a" translate="yes" xml:space="preserve">
          <source>Stack Overflow has &lt;em&gt;many&lt;/em&gt; other great resources to get started:</source>
          <target state="translated">스택 오버플로에는 시작할 수있는 다른 많은 리소스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="48fc570e8e866f7f574a291b7bacd57b75c6ab5b" translate="yes" xml:space="preserve">
          <source>Static mapping</source>
          <target state="translated">정적 매핑</target>
        </trans-unit>
        <trans-unit id="8001a2b0ee6473dba8f8f19c9bcf26b8ca6205c1" translate="yes" xml:space="preserve">
          <source>Still you'd &lt;em&gt;often&lt;/em&gt; want to have the most specific rules (fixed string &lt;code&gt;/forum/&amp;hellip;&lt;/code&gt; patterns, or more restrictive placeholders &lt;code&gt;[^/.]+&lt;/code&gt;) in the &lt;em&gt;early&lt;/em&gt; rules.
Generic slurp-all rules (&lt;code&gt;.*&lt;/code&gt;) are better left to the &lt;em&gt;later&lt;/em&gt; ones. (An exception is a &lt;code&gt;RewriteCond -f/-d&lt;/code&gt; guard as primary block.)</source>
          <target state="translated">여전히 &lt;em&gt;초기&lt;/em&gt; 규칙에서 가장 구체적인 규칙 (고정 문자열 &lt;code&gt;/forum/&amp;hellip;&lt;/code&gt; 패턴 또는보다 제한적인 자리 표시 자 &lt;code&gt;[^/.]+&lt;/code&gt; )을 원할 것입니다. 일반적인 말 괄호 규칙 ( &lt;code&gt;.*&lt;/code&gt; )이 &lt;em&gt;나중&lt;/em&gt; 규칙에 더 유리합니다. (기본 블록으로서의 &lt;code&gt;RewriteCond -f/-d&lt;/code&gt; 보호는 예외입니다.)</target>
        </trans-unit>
        <trans-unit id="e88877188929b587a6202b5d626e2de4ef74c025" translate="yes" xml:space="preserve">
          <source>Stylesheets and images stop working</source>
          <target state="translated">스타일 시트 및 이미지 작동이 중지됩니다</target>
        </trans-unit>
        <trans-unit id="1a378406d18f6750149ae24909a93a9ccb6fc19e" translate="yes" xml:space="preserve">
          <source>That yields a detailed summary of how incoming request paths get modified by each rule:</source>
          <target state="translated">그러면 각 요청에 따라 들어오는 요청 경로가 어떻게 수정되는지에 대한 자세한 요약이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6d6fab96ebe243a8ed7f16439ab504edd8a35174" translate="yes" xml:space="preserve">
          <source>The above rewrite would allow you to link to something like &lt;code&gt;/blog/1/foo/&lt;/code&gt; and it would actually load &lt;code&gt;/blog/index.php?id=1&amp;amp;title=foo&lt;/code&gt;.</source>
          <target state="translated">위의 다시 쓰기를 사용하면 &lt;code&gt;/blog/1/foo/&lt;/code&gt; 와 같은 링크에 연결할 수 있으며 실제로 &lt;code&gt;/blog/index.php?id=1&amp;amp;title=foo&lt;/code&gt; 로드 됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ba4a51130ff56537f6d3a9055715230bfef9e5f" translate="yes" xml:space="preserve">
          <source>The complete RewriteRule set, but &lt;em&gt;also&lt;/em&gt; single out the presumed defective one.</source>
          <target state="translated">전체 RewriteRule 세트는 물론 결함이있는 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="e228ac5b8f8d575c20a15333bcfad05518e80ac0" translate="yes" xml:space="preserve">
          <source>The default configuration of most web servers is to look for a file that matches the URL on the hard disk. If the &lt;em&gt;document root&lt;/em&gt; of the server is set to, say, &lt;code&gt;/var/www&lt;/code&gt;, it may look whether the file &lt;code&gt;/var/www/foo/bar.html&lt;/code&gt; exists and serve it if so. If the file ends in &quot;.php&quot; it will invoke the PHP interpreter and &lt;em&gt;then&lt;/em&gt; return the result. All this association is completely configurable; a file doesn't have to end in &quot;.php&quot; for the web server to run it through the PHP interpreter, and the URL doesn't have to match any particular file on disk for something to happen.</source>
          <target state="translated">대부분의 웹 서버의 기본 구성은 하드 디스크의 URL과 일치하는 파일을 찾는 것입니다. 서버의 &lt;em&gt;문서 루트&lt;/em&gt; 가 &lt;code&gt;/var/www&lt;/code&gt; 로 설정되어 있으면 &lt;code&gt;/var/www/foo/bar.html&lt;/code&gt; 파일이 있는지 확인하여 파일을 제공 할 수 있습니다. 파일이 &quot;.php&quot;로 끝나면 PHP 인터프리터를 호출 &lt;em&gt;한 다음&lt;/em&gt; 결과 &lt;em&gt;를&lt;/em&gt; 반환합니다. 이 모든 연관성을 완전히 구성 할 수 있습니다. 웹 서버가 PHP 인터프리터를 통해 파일을 실행하기 위해 파일이 &quot;.php&quot;로 끝나지 않아도되며 URL은 디스크의 특정 파일과 일치하지 않아도 발생합니다.</target>
        </trans-unit>
        <trans-unit id="46df60a282712a506bc72414500b3830c3f7622b" translate="yes" xml:space="preserve">
          <source>The first set of brackets - &lt;code&gt;([0-9]+)&lt;/code&gt; - matches a string with a minimum of 1 character in length and with only numeric values (i.e. 0-9). This can be referenced with &lt;code&gt;$1&lt;/code&gt; in the right hand side of the rule</source>
          <target state="translated">첫 번째 대괄호 세트 &lt;code&gt;([0-9]+)&lt;/code&gt; 는 최소 1 자 길이의 문자열과 숫자 값 (예 : 0-9) 만 일치합니다. 이것은 규칙의 오른쪽에 &lt;code&gt;$1&lt;/code&gt; 로 참조 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7ac23b9ac3e8ebb020e1a5fab826fbe6cccd47f8" translate="yes" xml:space="preserve">
          <source>The following examples are PHP-centric and a bit more incremental, easier to adapt for similar cases.
They're just summaries, often link to more variations or detailed Q&amp;amp;As.</source>
          <target state="translated">다음 예제는 PHP 중심이며 조금 더 점진적이며 유사한 경우에 더 쉽게 적용 할 수 있습니다. 그것들은 요약 일 뿐이며, 종종 더 많은 변형이나 상세한 Q &amp;amp; A에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a54a48205d3f14912b7eeff2751a1df039b641ef" translate="yes" xml:space="preserve">
          <source>The last flag indicates that this is the last rule that should be processed. This means that if and only if this rule matches, no further rules will be evaluated in the current rewrite processing run. If the rule does not match, all other rules will be tried in order as usual. If you do not set the &lt;code&gt;L&lt;/code&gt; flag, all following rules will be applied to the &lt;em&gt;rewritten&lt;/em&gt; URL afterwards.</source>
          <target state="translated">마지막 플래그는 이것이 처리되어야하는 마지막 규칙임을 나타냅니다. 이는이 규칙이 일치하는 경우에만 현재 다시 쓰기 처리 실행에서 더 이상 규칙이 평가되지 않음을 의미합니다. 규칙이 일치하지 않으면 평소대로 다른 모든 규칙이 시도됩니다. &lt;code&gt;L&lt;/code&gt; 플래그를 설정하지 않으면 나중에 다음 규칙이 &lt;em&gt;다시 작성된&lt;/em&gt; URL에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e2dcea71d18770c2097f41c39eae9392bca0c8a4" translate="yes" xml:space="preserve">
          <source>The leading slash &lt;code&gt;^/&lt;/code&gt; won't match</source>
          <target state="translated">선행 슬래시 &lt;code&gt;^/&lt;/code&gt; 는 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="549c3e4d9d2e3d169f232931ea8636c3d1480369" translate="yes" xml:space="preserve">
          <source>The no case flag means that the rewrite rule is case insensitive, so for the example rule above this would mean that both &lt;code&gt;/blog/1/foo/&lt;/code&gt; and &lt;code&gt;/BLOG/1/foo/&lt;/code&gt; (or any variation of this) would be matched.</source>
          <target state="translated">대소 문자 없음 플래그는 다시 쓰기 규칙이 대소 문자를 구분하지 않음을 의미하므로 위의 규칙 예에서는 &lt;code&gt;/blog/1/foo/&lt;/code&gt; 및 &lt;code&gt;/BLOG/1/foo/&lt;/code&gt; (또는이 변형)가 모두 일치 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="83c803d5174f2e1e70b82894f7bc34cb1d99cf98" translate="yes" xml:space="preserve">
          <source>The query string append flag allows us to pass in extra variables to the specified URL which will get added to the original get parameters. For our example this means that something like &lt;code&gt;/blog/1/foo/?comments=15&lt;/code&gt; would load &lt;code&gt;/blog/index.php?id=1&amp;amp;title=foo&amp;amp;comments=15&lt;/code&gt;</source>
          <target state="translated">쿼리 문자열 추가 플래그를 사용하면 추가 변수를 지정된 URL로 전달하여 원래 get 매개 변수에 추가 할 수 있습니다. 이 예에서 이것은 &lt;code&gt;/blog/1/foo/?comments=15&lt;/code&gt; 것이 &lt;code&gt;/blog/index.php?id=1&amp;amp;title=foo&amp;amp;comments=15&lt;/code&gt; 를 로드 함을 의미합니다</target>
        </trans-unit>
        <trans-unit id="1a75416b595fbf14696df582ef4381352dbaaade" translate="yes" xml:space="preserve">
          <source>The rewrite will attempt to load the same file on another domain</source>
          <target state="translated">다시 쓰기는 다른 도메인에 동일한 파일을로드하려고 시도합니다</target>
        </trans-unit>
        <trans-unit id="833afbd5f1f23c47a97009c28e05f47b2667d6ea" translate="yes" xml:space="preserve">
          <source>The rule is split into 4 sections:</source>
          <target state="translated">규칙은 4 개의 섹션으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="7aebe4dbf5a75928bd1986451a2093d287864dbd" translate="yes" xml:space="preserve">
          <source>The second set of parentheses matches a string with a minimum of 1 character in length, containing only alphanumeric characters (A-Z, a-z, or 0-9) or &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; (note &lt;code&gt;+&lt;/code&gt; is escaped with a backslash as without escaping it this will execute as a &lt;a href=&quot;http://www.regular-expressions.info/repeat.html&quot;&gt;regex repetition character&lt;/a&gt;). This can be referenced with &lt;code&gt;$2&lt;/code&gt; in the right hand side of the rule</source>
          <target state="translated">두 번째 괄호 세트는 영숫자 (AZ, az 또는 0-9) 또는 &lt;code&gt;-&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; (참고 &lt;code&gt;+&lt;/code&gt; 는 이스케이프하지 않고 백 슬래시로 이스케이프 처리됨)를 포함하여 최소 1 자 길이의 문자열과 일치합니다. &lt;a href=&quot;http://www.regular-expressions.info/repeat.html&quot;&gt;정규 표현식 반복 문자로&lt;/a&gt; ). 이것은 규칙의 오른쪽에 &lt;code&gt;$2&lt;/code&gt; 로 참조 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="04c8e0a990ad304eb54df5972cfebfc98f757529" translate="yes" xml:space="preserve">
          <source>The simplest option to also eschew &lt;code&gt;.php&lt;/code&gt; &quot;file extensions&quot; in URLs is enabling:</source>
          <target state="translated">URL에서 &lt;code&gt;.php&lt;/code&gt; &quot;파일 확장자&quot;를 피하는 가장 간단한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e2f7a407bd6041b3f1f32b83f940cec25221f9b" translate="yes" xml:space="preserve">
          <source>The web server is an application listening on a port, accepting HTTP requests coming in on that port and returning a response. A web server is entirely free to respond to any request in any way it sees fit/in any way you have configured it to respond. This response is not a file, it's an &lt;em&gt;HTTP response&lt;/em&gt; which may or may not have anything to do with physical files on any disk. A web server doesn't have to be Apache, there are many other web servers which are all just programs which run persistently and are attached to a port which respond to HTTP requests. You can write one yourself. This paragraph was intended to divorce you from any notion that URLs directly equal files, which is really important to understand. :)</source>
          <target state="translated">웹 서버는 포트에서 수신하는 응용 프로그램으로, 해당 포트에서 들어오는 HTTP 요청을 수락하고 응답을 반환합니다. 웹 서버는 응답하도록 구성한 방식에 맞게 어떤 방식 으로든 요청에 ​​응답 할 수 있습니다. 이 응답은 파일이 아니며 &lt;em&gt;HTTP 응답&lt;/em&gt; 이므로 디스크의 실제 파일과 관련이 있거나 없을 수 있습니다. 웹 서버는 아파치 일 필요는 없으며, 지속적으로 실행되고 HTTP 요청에 응답하는 포트에 연결된 프로그램 일 뿐인 다른 많은 웹 서버가 있습니다. 직접 쓸 수 있습니다. 이 단락은 URL이 파일과 직접 동일한 개념으로 이해하기 위해 작성되었습니다. 이해해야합니다. :)</target>
        </trans-unit>
        <trans-unit id="159c459f715b62a82d49181a2596095e72ac845a" translate="yes" xml:space="preserve">
          <source>There are various online tools to generate RewriteRules for most GET-parameterish URLs:</source>
          <target state="translated">대부분의 GET 매개 변수 URL에 대해 RewriteRules를 생성하는 다양한 온라인 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82a2f0ef8ac4ecf1da9d191346d5140c761cc14" translate="yes" xml:space="preserve">
          <source>There's a lot mod_rewrite can do and very complex matching rules you can create, including chaining several rewrites, proxying requests to a completely different service or machine, returning specific HTTP status codes as responses, redirecting requests etc. It's very powerful and can be used to great good if you understand the fundamental HTTP request-response mechanism. It does &lt;em&gt;not&lt;/em&gt; automatically make your links pretty.</source>
          <target state="translated">mod_rewrite가 수행 할 수있는 작업과 여러 번의 다시 쓰기 연결, 완전히 다른 서비스 또는 시스템에 대한 요청 프록시, 특정 HTTP 상태 코드를 응답으로 반환, 요청 리디렉션 등을 포함하여 생성 할 수있는 매우 복잡한 일치 규칙이 있습니다. 매우 강력하고 사용할 수 있습니다. 기본 HTTP 요청-응답 메커니즘을 이해하면 좋습니다. 자동으로 링크를 예쁘게 만들지는 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c9ba3f02e7e2d45a3c1fdc93f62d6055d0ba77ad" translate="yes" xml:space="preserve">
          <source>Therefore you'll often see mixed &lt;code&gt;/article/529-title-slug&lt;/code&gt; paths used in practice:</source>
          <target state="translated">따라서 실제로 사용되는 혼합 &lt;code&gt;/article/529-title-slug&lt;/code&gt; 경로가 종종 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cb15bb19b67a700556e5d4e90ad59605ca293dde" translate="yes" xml:space="preserve">
          <source>These are options that are added in square brackets at the end of your rewrite rule to specify certain conditions. Again, there are a lot of different flags which you can read up on in &lt;a href=&quot;http://httpd.apache.org/docs/2.2/rewrite/flags.html&quot;&gt;the documentation&lt;/a&gt;, but I'll go through some of the more common flags:</source>
          <target state="translated">재 작성 규칙 끝에 특정 조건을 지정하기 위해 대괄호 안에 추가되는 옵션입니다. 다시 말하지만, &lt;a href=&quot;http://httpd.apache.org/docs/2.2/rewrite/flags.html&quot;&gt;문서&lt;/a&gt; 에서 읽을 수있는 많은 다른 플래그가 있지만 더 일반적인 플래그 중 일부를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7cb52ffb24a80ad734695950723670b446fd208a" translate="yes" xml:space="preserve">
          <source>This common trick involves sending a 30x/Location &lt;em&gt;redirect&lt;/em&gt; whenever an incoming URL follows the obsolete/ugly naming scheme.
Browsers will then &lt;em&gt;rerequest&lt;/em&gt; the new/pretty URL, which afterwards is rewritten (just internally) to the original or new location.</source>
          <target state="translated">이 일반적인 속임수는 들어오는 URL이 더 이상 사용되지 않는 추악한 이름 지정 체계를 따르는 경우 30 배 / 위치 &lt;em&gt;리디렉션을&lt;/em&gt; 보내는 것입니다. 그런 다음 브라우저는 새 / 예쁜 URL을 다시 요청하며,이 URL은 나중에 내부 또는 원래 위치로 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="eac456246f01a69b6fa960c525f4d3493e5955b6" translate="yes" xml:space="preserve">
          <source>This doesn't tell you which RewriteRule is the culprit. But inaccessible final paths like &lt;code&gt;/docroot/21-.itle?index.php&lt;/code&gt; may give away where to inspect further.
Otherwise disable rules until you get some predictable paths.</source>
          <target state="translated">이것은 어느 RewriteRule이 범인인지는 알려주지 않습니다. 그러나 &lt;code&gt;/docroot/21-.itle?index.php&lt;/code&gt; 와 같은 액세스 할 수없는 최종 경로는 추가 검사 위치를 제공 할 수 있습니다. 그렇지 않으면 예측 가능한 경로를 얻을 때까지 규칙을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="126b9d7dfbd968a54edaca8a4d158902a1949796" translate="yes" xml:space="preserve">
          <source>This flag isn't one I used in the example above, but is one I thought is worth mentioning. This allows you to specify a http redirect, with the option to include a status code (e.g. &lt;code&gt;R=301&lt;/code&gt;). For example if you wanted to do a 301 redirect on /myblog/ to /blog/ you would simply write a rule something like this:</source>
          <target state="translated">이 플래그는 위 예제에서 사용한 것이 아니지만 언급 할 가치가있는 것으로 생각됩니다. 이를 통해 상태 코드를 포함하는 옵션 (예 : &lt;code&gt;R=301&lt;/code&gt; )과 함께 http 리디렉션을 지정할 수 있습니다. 예를 들어, / myblog /에서 / blog /로 301 리디렉션을 수행하려면 다음과 같은 규칙을 작성하면됩니다.</target>
        </trans-unit>
        <trans-unit id="37b731c00b0df987bf9c1b533cd5f5cce0e31a8d" translate="yes" xml:space="preserve">
          <source>This has Apache select &lt;code&gt;article.php&lt;/code&gt; for HTTP requests on &lt;code&gt;/article&lt;/code&gt; due to the matching basename. And this works well together with the aforementioned PATH_INFO feature. So you can just use URLs like &lt;code&gt;http://example.com/article/virtual/title&lt;/code&gt;. Which makes sense if you have a traditional web application with multiple PHP invocation points/scripts.</source>
          <target state="translated">일치하는 기본 이름으로 인해 &lt;code&gt;/article&lt;/code&gt; 의 HTTP 요청에 대해 Apache select &lt;code&gt;article.php&lt;/code&gt; 가 있습니다. 그리고 이것은 위에서 언급 한 PATH_INFO 기능과 함께 잘 작동합니다. 따라서 &lt;code&gt;http://example.com/article/virtual/title&lt;/code&gt; 과 같은 URL을 사용할 수 있습니다. 여러 PHP 호출 지점 / 스크립트가있는 전통적인 웹 응용 프로그램이있는 경우 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7821c92c23729c6e3b5d689391cb1070c9721c06" translate="yes" xml:space="preserve">
          <source>This is a very common practice, which will prepend your domain with &lt;code&gt;www.&lt;/code&gt; (if it isn't there already) and execute a 301 redirect. For example, loading up &lt;code&gt;http://example.com/blog/&lt;/code&gt; it would redirect you to &lt;code&gt;http://www.example.com/blog/&lt;/code&gt;</source>
          <target state="translated">이것은 매우 일반적인 관행이며 도메인을 &lt;code&gt;www.&lt;/code&gt; 앞에 추가합니다 . (없는 경우) 301 리디렉션을 실행하십시오. 예를 들어 &lt;code&gt;http://example.com/blog/&lt;/code&gt; 를 로드하면 &lt;code&gt;http://www.example.com/blog/&lt;/code&gt; 로 리디렉션됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d80c4ef1a166355292a1990b7a7af44ad9122e8" translate="yes" xml:space="preserve">
          <source>This is just as valid a request for a URL, and it has more obviously nothing to do with files.</source>
          <target state="translated">이것은 URL에 대한 유효한 요청이며 파일과는 더 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c69886ec55e1ba20b0fa5f101a1225eaf0019fd1" translate="yes" xml:space="preserve">
          <source>This is often seen in old tutorials. And it used to be correct for ancient Apache 1.x versions. Nowadays request paths are conveniently &lt;em&gt;fully &lt;strong&gt;directory-relative&lt;/strong&gt;&lt;/em&gt; in &lt;code&gt;.htaccess&lt;/code&gt; RewriteRules. Just leave the leading &lt;code&gt;/&lt;/code&gt; out.</source>
          <target state="translated">이것은 종종 오래된 튜토리얼에서 볼 수 있습니다. 그리고 그것은 고대 아파치 1.x 버전에 맞았습니다. 요즘 요청 경로는 &lt;code&gt;.htaccess&lt;/code&gt; RewriteRules에서 편리 &lt;em&gt;하게 &lt;strong&gt;디렉토리에 상대적&lt;/strong&gt;&lt;/em&gt; 입니다. 그냥 앞 &lt;code&gt;/&lt;/code&gt; 밖으로 나가십시오.</target>
        </trans-unit>
        <trans-unit id="52a895915ec9566af7e25dd82c968182fc5c0f3e" translate="yes" xml:space="preserve">
          <source>This is slightly less common, but is a good example of a rule that doesn't execute if the filename is a directory or file that exists on the server.</source>
          <target state="translated">이것은 일반적이지 않지만 파일 이름이 서버에 존재하는 디렉토리 또는 파일 인 경우 실행되지 않는 규칙의 좋은 예입니다.</target>
        </trans-unit>
        <trans-unit id="77620a284d982bf7c67daa1601fbd5c8de86c151" translate="yes" xml:space="preserve">
          <source>This is somewhat dependent on your server setup and the used PHP SAPI. Common alternatives include &lt;code&gt;ForceType application/x-httpd-php&lt;/code&gt; or &lt;code&gt;AddHandler php5-script&lt;/code&gt;.</source>
          <target state="translated">이것은 서버 설정과 사용 된 PHP SAPI에 따라 다소 다릅니다. 일반적인 대안으로는 &lt;code&gt;ForceType application/x-httpd-php&lt;/code&gt; 또는 &lt;code&gt;AddHandler php5-script&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e43a1df57f3dcef1bda106987332480923a8e7b2" translate="yes" xml:space="preserve">
          <source>This is the simple request of a browser to a web server requesting the &lt;em&gt;URL&lt;/em&gt;&lt;code&gt;/foo/bar.html&lt;/code&gt; from it. It is important to stress that it does not request a &lt;em&gt;file&lt;/em&gt;, it requests just some arbitrary URL. The request may also look like this:</source>
          <target state="translated">이것은 웹 서버에 브라우저에서 &lt;em&gt;URL&lt;/em&gt; &lt;code&gt;/foo/bar.html&lt;/code&gt; 을 요청하는 간단한 요청입니다. &lt;em&gt;파일을&lt;/em&gt; 요청하지 않고 임의의 URL 만 요청한다는 점을 강조하는 것이 중요합니다. 요청은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01e466565580b17decbd9ff474a0fe27c298e507" translate="yes" xml:space="preserve">
          <source>This isn't as convenient as having Apache separate input path segments into &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt; and passing them as distinct &lt;code&gt;$_GET&lt;/code&gt; variables to PHP. It's merely emulating &quot;pretty URLs&quot; with less configuration effort.</source>
          <target state="translated">이것은 아파치가 별도의 입력 경로 세그먼트를 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; 로 나누고 별개의 &lt;code&gt;$_GET&lt;/code&gt; 변수로 PHP에 전달하는 것만 큼 편리하지 않습니다. 적은 노력으로 &quot;예쁜 URL&quot;을 모방 할뿐입니다.</target>
        </trans-unit>
        <trans-unit id="678cdd0d663cc49ab66acef486598ae2d96c6601" translate="yes" xml:space="preserve">
          <source>This nets quicker and more exact answers, and makes them more useful to others.</source>
          <target state="translated">이를 통해 더 빠르고 정확한 답변을 얻을 수 있으며 다른 사람들에게 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f16dfc9b713dca91d180a83ddd93a12f0f5f49f9" translate="yes" xml:space="preserve">
          <source>This optionalized any &lt;code&gt;/&amp;hellip;/&amp;hellip;/&amp;hellip;&lt;/code&gt; trailing path segments. Which then of course requires the handling script to split them up, and &lt;em&gt;variabl-ify&lt;/em&gt; extracted parameters
itself (which is what &lt;em&gt;Web-&quot;MVC&quot;&lt;/em&gt; frameworks do).</source>
          <target state="translated">이것은 /.../&amp;hellip;/&amp;hellip; 후행 경로 세그먼트를 선택적으로 설정했습니다. 물론,이를 처리하기 위해 처리 스크립트가 필요하며 추출 된 매개 변수 자체를 &lt;em&gt;variabl-ify&lt;/em&gt; ( &lt;em&gt;웹- &quot;MVC&quot;&lt;/em&gt; 프레임 워크가하는 것)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4f0a25ea5b6c1efa50d189b93b865b7cd7502f46" translate="yes" xml:space="preserve">
          <source>This rule matches anything (&lt;code&gt;.*&lt;/code&gt;) and &lt;em&gt;captures&lt;/em&gt; it (&lt;code&gt;(..)&lt;/code&gt;), then rewrites it to append &quot;.html&quot;. In other words, if &lt;code&gt;/foo/bar&lt;/code&gt; was the requested URL, it will be handled as if &lt;code&gt;/foo/bar.html&lt;/code&gt; had been requested. See &lt;a href=&quot;http://regular-expressions.info&quot;&gt;http://regular-expressions.info&lt;/a&gt; for more information about regular expression matching, capturing and replacements.</source>
          <target state="translated">이 규칙은 모든 항목 ( &lt;code&gt;.*&lt;/code&gt; )을 일치시키고 &lt;em&gt;캡처&lt;/em&gt; ( &lt;code&gt;(..)&lt;/code&gt; ) 한 다음 &quot;.html&quot;을 추가하도록 다시 씁니다. 즉, &lt;code&gt;/foo/bar&lt;/code&gt; 가 요청 된 URL 인 경우 &lt;code&gt;/foo/bar.html&lt;/code&gt; 이 요청 된 것처럼 처리됩니다. 정규식 일치, 캡처 및 대체에 대한 자세한 내용은 &lt;a href=&quot;http://regular-expressions.info&quot;&gt;http://regular-expressions.info&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b2ea9bc6efb3aff08b2c67c59e0c49c40b9a8b9" translate="yes" xml:space="preserve">
          <source>This rule says &lt;em&gt;whenever a request matches &quot;/foo/bar&quot;, rewrite it to &quot;/foo/baz&quot;.&lt;/em&gt; The request will then be handled as if &lt;code&gt;/foo/baz&lt;/code&gt; had been requested instead. This can be used for various effects, for example:</source>
          <target state="translated">이 규칙은 &lt;em&gt;요청이 &quot;/ foo / bar&quot;와 일치 할 때마다 &quot;/ foo / baz&quot;로 다시 작성합니다.&lt;/em&gt; 그러면 요청은 &lt;code&gt;/foo/baz&lt;/code&gt; 가 대신 요청 된 것처럼 처리됩니다. 다음과 같은 다양한 효과에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e5c51f6d07a6fda3f35853c7cbc032504a01a3" translate="yes" xml:space="preserve">
          <source>This simply remaps 2009-2011 posts onto one script, and all other years implicitly to another handler.
Note the &lt;em&gt;more specific rule coming first&lt;/em&gt;. Each script might use different GET params.</source>
          <target state="translated">이것은 2009-2011 게시물을 한 스크립트에 다시 매핑하고 다른 모든 연도는 다른 처리기에 암시 적으로 다시 매핑합니다. &lt;em&gt;보다 구체적인 규칙이 먼저 나옵니다&lt;/em&gt; . 각 스크립트는 다른 GET 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1c37412960d01550e537eeede8eb49d03ce4cc9" translate="yes" xml:space="preserve">
          <source>This way you could just rename your &lt;code&gt;article.php&lt;/code&gt; script to just &lt;code&gt;article&lt;/code&gt; (without extension), but still have it processed as PHP script.</source>
          <target state="translated">이 방법으로 &lt;code&gt;article.php&lt;/code&gt; 스크립트의 이름을 &lt;code&gt;article&lt;/code&gt; (확장자없이)으로 바꿀 수는 있지만 여전히 PHP 스크립트로 처리되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="211b69704ff35b0a39c4be33762622ae6379f372" translate="yes" xml:space="preserve">
          <source>This, again, matches anything and rewrites it to the file index.php with the originally requested URL appended in the &lt;code&gt;url&lt;/code&gt; query parameter. I.e., for any and all requests coming in, the file index.php is executed and this file will have access to the original request in &lt;code&gt;$_GET['url']&lt;/code&gt;, so it can do anything it wants with it.</source>
          <target state="translated">이것은 다시 무엇이든 일치시키고 &lt;code&gt;url&lt;/code&gt; 쿼리 매개 변수에 원래 요청 된 URL을 추가하여 index.php 파일에 다시 씁니다. 즉, 들어오는 모든 요청에 ​​대해 index.php 파일이 실행 되고이 파일은 &lt;code&gt;$_GET['url']&lt;/code&gt; 의 원래 요청에 액세스 할 수 있으므로 원하는 모든 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8c5fe091e3cffc8b0c5e5c2b1598310dff0e558" translate="yes" xml:space="preserve">
          <source>To actually use RewriteRules in per-directory configuration files you must:</source>
          <target state="translated">디렉토리 별 구성 파일에서 실제로 RewriteRules를 사용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="302e8c9231b475103b1b38d200a19d9417800479" translate="yes" xml:space="preserve">
          <source>To expand on &lt;a href=&quot;https://stackoverflow.com/a/20563773/1011145&quot;&gt;deceze's answer&lt;/a&gt;, I wanted to provide a few examples and explanation of some other mod_rewrite functionality.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/20563773/1011145&quot;&gt;deceze의 답변&lt;/a&gt; 을 확장하기 위해 다른 mod_rewrite 기능에 대한 몇 가지 예와 설명을 제공하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="e0bb75b10308d21179997cfdc7b880808864c79a" translate="yes" xml:space="preserve">
          <source>To understand what mod_rewrite does you first need to understand how a web server works. A web server responds to &lt;a href=&quot;http://en.wikipedia.org/wiki/Http&quot;&gt;&lt;em&gt;HTTP requests&lt;/em&gt;&lt;/a&gt;. An HTTP request at its most basic level looks like this:</source>
          <target state="translated">mod_rewrite의 기능을 이해하려면 먼저 웹 서버의 작동 방식을 이해해야합니다. 웹 서버는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Http&quot;&gt;&lt;em&gt;HTTP 요청에&lt;/em&gt;&lt;/a&gt; 응답 &lt;em&gt;합니다&lt;/em&gt; . 가장 기본적인 수준의 HTTP 요청은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="58245d2ae3eef010b5b66c0f91d98d0ced9ae5a7" translate="yes" xml:space="preserve">
          <source>Trailing file &quot;extensions&quot;</source>
          <target state="translated">후행 파일 &quot;확장명&quot;</target>
        </trans-unit>
        <trans-unit id="42c250d9422aa8b9548f27e829e74fff8a6655de" translate="yes" xml:space="preserve">
          <source>URL rewriting is primarily used for supporting &lt;em&gt;virtual&lt;/em&gt; incoming paths. Commonly you just have one dispatcher script (&lt;code&gt;index.php&lt;/code&gt;) or a few individual handlers (&lt;code&gt;articles.php&lt;/code&gt;, &lt;code&gt;blog.php&lt;/code&gt;, &lt;code&gt;wiki.php&lt;/code&gt;, &amp;hellip;). The latter &lt;a href=&quot;https://stackoverflow.com/a/1298917&quot;&gt;might clash&lt;/a&gt; with similar virtual RewriteRule paths.</source>
          <target state="translated">URL 재 작성은 주로 &lt;em&gt;가상&lt;/em&gt; 수신 경로를 지원하는 데 사용됩니다. 일반적으로 하나의 디스패처 스크립트 ( &lt;code&gt;index.php&lt;/code&gt; ) 또는 몇 개의 개별 처리기 ( &lt;code&gt;articles.php&lt;/code&gt; , &lt;code&gt;blog.php&lt;/code&gt; , &lt;code&gt;wiki.php&lt;/code&gt; ,&amp;hellip;) 만 있습니다. 후자 &lt;a href=&quot;https://stackoverflow.com/a/1298917&quot;&gt;는&lt;/a&gt; 유사한 가상 RewriteRule 경로와 충돌 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="936c1eadd423e11d0419edc5c0a50907603bcf5b" translate="yes" xml:space="preserve">
          <source>URLs don't really have file extensions. Which is what this entire reference is about (= URLs are virtual locators, not necessarily a direct filesystem image).
However if you had a 1:1 file mapping before, you &lt;em&gt;can&lt;/em&gt; craft simpler rules:</source>
          <target state="translated">URL에는 실제로 파일 확장자가 없습니다. 이 전체 참조 내용은 다음과 같습니다 (= URL은 가상 로케이터이며 반드시 직접 파일 시스템 이미지는 아님). 그러나 이전에 1 : 1 파일 매핑이 있었다면 더 간단한 규칙을 만들 &lt;em&gt;수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="748dcaf65cc260bb40913050765500212f87a4c3" translate="yes" xml:space="preserve">
          <source>Uniformity with alternative lists</source>
          <target state="translated">대체 목록과의 균일 성</target>
        </trans-unit>
        <trans-unit id="171f5f83a5e1cc88faf76682f9ab5dec103babb8" translate="yes" xml:space="preserve">
          <source>Use mod_rewrite on the server to handle the request to the URL &lt;code&gt;/my/pretty/link&lt;/code&gt; using any one of the methods described above.</source>
          <target state="translated">서버에서 mod_rewrite를 사용하여 위에서 설명한 방법 중 하나를 사용하여 URL &lt;code&gt;/my/pretty/link&lt;/code&gt; 에 대한 요청을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="314b923c11804470bedda27a5e010368e52f966a" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://stackoverflow.com/questions/2261951/what-exactly-is-path-info-in-php&quot;&gt;PATH_INFO&lt;/a&gt;, Luke</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/2261951/what-exactly-is-path-info-in-php&quot;&gt;PATH_INFO&lt;/a&gt; , Luke 사용</target>
        </trans-unit>
        <trans-unit id="b06ad5cb5d4d5adc3d4c61b06b4b81b4e2fc280c" translate="yes" xml:space="preserve">
          <source>Were it really be disabled, your RewriteRules still wouldn't work anyway.</source>
          <target state="translated">실제로 비활성화되어 있으면 RewriteRules가 여전히 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0cbc1290725122d94fb5a18b92c5702e6822572" translate="yes" xml:space="preserve">
          <source>What &quot;pretty&quot; URLs should conceptionally be used for is making websites &lt;strong&gt;&lt;em&gt;user-friendly&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">개념적으로 &quot;예쁜&quot;URL을 사용해야하는 것은 웹 사이트를 &lt;strong&gt;&lt;em&gt;사용자에게 친숙&lt;/em&gt;&lt;/strong&gt; 하게 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="09b7efa758045019b58e1428653c1f860a31dcd6" translate="yes" xml:space="preserve">
          <source>What mod_rewrite does &lt;em&gt;not&lt;/em&gt; do</source>
          <target state="translated">mod_rewrite가하지 &lt;em&gt;않는&lt;/em&gt; 것</target>
        </trans-unit>
        <trans-unit id="360f3bc410da35a3cfaf91a34475047f7d1fbd2b" translate="yes" xml:space="preserve">
          <source>What seems enticing as generalized safeguard, often turns out to be an obstacle in practice.</source>
          <target state="translated">일반화 된 보호 수단으로 유혹되는 것들은 종종 실제로 장애물로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="60ab540d4d5fa82c04683e07b642ce0708dabbf4" translate="yes" xml:space="preserve">
          <source>When opting for directory-style paths, you can make it reachable with and without a final</source>
          <target state="translated">디렉토리 스타일 경로를 선택할 때 최종 경로 유무에 관계없이 경로에 도달 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c5b3b194631676b25d479ba8960b569223e4c363" translate="yes" xml:space="preserve">
          <source>When you introduce virtual directory structures &lt;code&gt;/blog/article/123&lt;/code&gt; this impacts relative resource references in HTML (such as &lt;code&gt;&amp;lt;img src=mouse.png&amp;gt;&lt;/code&gt;).
Which can be solved by:</source>
          <target state="translated">가상 디렉토리 구조 &lt;code&gt;/blog/article/123&lt;/code&gt; 을 도입하면 HTML의 상대 자원 참조 (예 : &lt;code&gt;&amp;lt;img src=mouse.png&amp;gt;&lt;/code&gt; )에 영향을줍니다. 다음으로 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22eb5ad30eff3a83a982c487a7eeafa78266307c" translate="yes" xml:space="preserve">
          <source>Whenever something &lt;em&gt;doesn't work&lt;/em&gt;</source>
          <target state="translated">무언가 &lt;em&gt;가 작동하지 않을&lt;/em&gt; 때마다</target>
        </trans-unit>
        <trans-unit id="73279bd5b2034996f948348aaf4405c0d1d8ebfc" translate="yes" xml:space="preserve">
          <source>Which helps to narrow down overly generic rules and regex mishaps.</source>
          <target state="translated">지나치게 일반적인 규칙과 정규식 사고를 좁히는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ef42d9dca7c76ff93fcf4f46cc65e5e50e1ea14b" translate="yes" xml:space="preserve">
          <source>Which is not to say you always &lt;em&gt;have to&lt;/em&gt;. Content-Negotiation is just an automatism to virtual resources.</source>
          <target state="translated">항상 그렇다고 말하는 것은 아닙니다. 컨텐츠 협상은 가상 자원에 대한 자동화입니다.</target>
        </trans-unit>
        <trans-unit id="8178d60b1be6e325d969a1f01cbe50a62bca55c9" translate="yes" xml:space="preserve">
          <source>Which is often used by PHP frameworks or WebCMS / portal scripts. The actual path splitting then is handled in PHP using &lt;code&gt;$_SERVER[&quot;REQUEST_URI&quot;]&lt;/code&gt;. So conceptionally it's pretty much the opposite of URL handling &quot;per mod_rewrite&quot;. (Just use &lt;a href=&quot;https://httpd.apache.org/docs/2.4/rewrite/remapping.html#fallback-resource&quot;&gt;&lt;code&gt;FallBackResource&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">PHP 프레임 워크 또는 WebCMS / 포털 스크립트에서 자주 사용됩니다. 실제 경로 분할은 &lt;code&gt;$_SERVER[&quot;REQUEST_URI&quot;]&lt;/code&gt; 사용하여 PHP에서 처리됩니다. 개념적으로 그것은 &quot;mod_rewrite 당&quot;URL 처리와 거의 반대입니다. 대신 &lt;a href=&quot;https://httpd.apache.org/docs/2.4/rewrite/remapping.html#fallback-resource&quot;&gt; &lt;code&gt;FallBackResource&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66300ff1c036bd0e881fe379dec2cb88970a4d4c" translate="yes" xml:space="preserve">
          <source>Which it doesn't per default. You can &lt;a href=&quot;https://stackoverflow.com/questions/7218164/multiple-rewriterules-for-single-rewritecond-in-htaccess&quot;&gt;chain them&lt;/a&gt; using the &lt;code&gt;[S=2]&lt;/code&gt; flag. Else you'll have to repeat them. While sometimes you can craft an &quot;inverted&quot; primary rule to [END] the rewrite processing early.</source>
          <target state="translated">기본값이 아닌 &lt;code&gt;[S=2]&lt;/code&gt; 플래그를 사용하여 연결할 수 있습니다. 그렇지 않으면 반복해야합니다. 재 작성 처리를 일찍 [END] 수행하기 위해 &quot;반전 된&quot;기본 규칙을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfa0314a5be793cf2743f125195fe1bfb6a4399d" translate="yes" xml:space="preserve">
          <source>You can easily extend that rule to allow for &lt;code&gt;/article/title-string&lt;/code&gt; placeholders:</source>
          <target state="translated">&lt;code&gt;/article/title-string&lt;/code&gt; 플레이스 홀더를 허용하도록 해당 규칙을 쉽게 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a6877229f800cd4d7bb88f9850b271d0487be6f" translate="yes" xml:space="preserve">
          <source>You can split them out into individual &lt;code&gt;RewriteRule&lt;/code&gt;s should this get too complex.</source>
          <target state="translated">너무 복잡해지면 개별 &lt;code&gt;RewriteRule&lt;/code&gt; 로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8585e0db233781f56ebd06de62c7eb1f8f5b3a5a" translate="yes" xml:space="preserve">
          <source>You can't match &lt;code&gt;RewriteRule index.php\?x=y&lt;/code&gt;, because mod_rewrite compares just against relative paths per default. You can match them separately however via:</source>
          <target state="translated">mod_rewrite는 기본값 당 상대 경로와 비교하기 때문에 &lt;code&gt;RewriteRule index.php\?x=y&lt;/code&gt; 와 일치 할 수 없습니다. 그러나 다음을 통해 별도로 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d222b87fbace9b84595f1388716086c2a42d24b7" translate="yes" xml:space="preserve">
          <source>You could alternatively craft further RewriteRules to rebind &lt;code&gt;.css&lt;/code&gt; or &lt;code&gt;.png&lt;/code&gt; paths to their original locations.
But that's both unneeded, or incurs extra redirects and hampers caching.</source>
          <target state="translated">다른 RewriteRules를 만들어 &lt;code&gt;.css&lt;/code&gt; 또는 &lt;code&gt;.png&lt;/code&gt; 경로를 원래 위치로 리 바인드 할 수도 있습니다. 그러나 그것은 불필요하거나 여분의 리디렉션이 발생하고 캐싱을 방해합니다.</target>
        </trans-unit>
        <trans-unit id="44a6fa9efc666a65a1bd62ec9dc5ea3f7942e480" translate="yes" xml:space="preserve">
          <source>You shouldn't start your &lt;code&gt;.htaccess&lt;/code&gt; RewriteRule patterns with &lt;code&gt;^/&lt;/code&gt; normally:</source>
          <target state="translated">일반적으로 &lt;code&gt;^/&lt;/code&gt; &lt;code&gt;.htaccess&lt;/code&gt; RewriteRule 패턴을 시작하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="815d892a020c87eb8dcd1e707d7e6e98c8c8c3ca" translate="yes" xml:space="preserve">
          <source>You're most commonly seeing RewriteRules to simulate a virtual directory structure. But you're not forced to be uncreative. You can as well use &lt;code&gt;-&lt;/code&gt; hyphens for segmenting or structure.</source>
          <target state="translated">가상 디렉토리 구조를 시뮬레이션하기 위해 가장 일반적으로 RewriteRules가 표시됩니다. 그러나 창의력을 발휘하지 않아도됩니다. 분할 또는 구조에 하이픈을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f0d732863ee895a309758e84227312d39f3171" translate="yes" xml:space="preserve">
          <source>You've probably seen this in many examples:</source>
          <target state="translated">많은 예에서 이것을 보았을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a8f5998b0f4e9bd3bbc4db8f81b5de80b7f6c2ed" translate="yes" xml:space="preserve">
          <source>approach is easy to append onto any other RewriteRule.</source>
          <target state="translated">접근 방식은 다른 RewriteRule에 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ec7f782439e58bed3a8696b026c30a1d9093ec8" translate="yes" xml:space="preserve">
          <source>in patterns</source>
          <target state="translated">패턴으로</target>
        </trans-unit>
        <trans-unit id="a56c70ab2c290c7937cb7e100dd4b3b8f2b82d94" translate="yes" xml:space="preserve">
          <source>mod_rewrite does not magically make all your URLs &quot;pretty&quot;. This is a common misunderstanding. If you have this link in your web site:</source>
          <target state="translated">mod_rewrite가 모든 URL을 마술처럼 아름답게 만들지는 않습니다. 이것은 일반적인 오해입니다. 웹 사이트에이 링크가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="043d0819e92bf8f0d7f33ab50480ff32c04dd7c1" translate="yes" xml:space="preserve">
          <source>mod_rewrite is a way to &lt;em&gt;rewrite&lt;/em&gt; the internal request handling. When the web server receives a request for the URL &lt;code&gt;/foo/bar&lt;/code&gt;, you can &lt;em&gt;rewrite&lt;/em&gt; that URL into something else before the web server will look for a file on disk to match it. Simple example:</source>
          <target state="translated">mod_rewrite는 내부 요청 처리를 &lt;em&gt;다시 쓰는&lt;/em&gt; 방법입니다. 웹 서버가 URL &lt;code&gt;/foo/bar&lt;/code&gt; 에 대한 요청을 수신하면 웹 서버가 디스크에서 파일과 일치하는 파일을 찾기 전에 해당 URL을 다른 URL로 &lt;em&gt;다시 쓸&lt;/em&gt; 수 있습니다. 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="c838466232ea0f7c751192a9afce76a1b060ebe8" translate="yes" xml:space="preserve">
          <source>scheme:</source>
          <target state="translated">scheme:</target>
        </trans-unit>
        <trans-unit id="f37e25064bedecaffcd022221184a14425448ecb" translate="yes" xml:space="preserve">
          <source>there's nothing mod_rewrite can do to make that pretty. In order to make this a pretty link, you have to:</source>
          <target state="translated">그것을 mod_rewrite가 예쁘게 만들기 위해 할 수있는 일은 없습니다. 이 링크를 예쁘게 만들려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="72bba5fd6da4f8012e901d27e8f7631e871b0922" translate="yes" xml:space="preserve">
          <source>␣</source>
          <target state="translated">␣</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
