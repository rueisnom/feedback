<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/20563772">
    <body>
      <group id="20563772">
        <trans-unit id="04c55724768058d5a9709a1afac88b7e9e8c36de" translate="yes" xml:space="preserve">
          <source>&quot;Pretty links&quot; is an often requested topic, but it is rarely fully explained. &lt;a href=&quot;https://en.wikipedia.org/wiki/URL_redirection#Apache_HTTP_Server_mod_rewrite&quot;&gt;mod_rewrite&lt;/a&gt; is one way to make &quot;pretty links&quot;, but it's complex and its syntax is very terse, hard to grok, and the documentation assumes a certain level of proficiency in HTTP. Can someone explain in simple terms how &quot;pretty links&quot; work and how mod_rewrite can be used to create them?</source>
          <target state="translated">&amp;ldquo;漂亮的链接&amp;rdquo;是一个经常要求的主题，但是很少对其进行充分解释。 &lt;a href=&quot;https://en.wikipedia.org/wiki/URL_redirection#Apache_HTTP_Server_mod_rewrite&quot;&gt;mod_rewrite&lt;/a&gt;是创建&amp;ldquo;漂亮链接&amp;rdquo;的一种方法，但是它很复杂，语法非常简洁，难以理解，并且文档假定HTTP具备一定的熟练程度。 有人可以简单地解释&amp;ldquo;漂亮链接&amp;rdquo;如何工作以及如何使用mod_rewrite创建它们吗？</target>
        </trans-unit>
        <trans-unit id="a0144ea22bd63e090c9a57002ef4dca43f06244e" translate="yes" xml:space="preserve">
          <source>&quot;Removing&quot; the PHP extension</source>
          <target state="translated">&quot;删除 &quot;PHP扩展</target>
        </trans-unit>
        <trans-unit id="597d8e063a87f940aba17a58c3d20ee1aa29b5aa" translate="yes" xml:space="preserve">
          <source>&amp;larr;&amp;rarr;</source>
          <target state="translated">&amp;larr;&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="b5513ad1a21d7a31373a546022f3c58ec77d271b" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/234723/generic-htaccess-redirect-www-to-non-www&quot;&gt;Generic htaccess redirect www to non-www&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/234723/generic-htaccess-redirect-www-to-non-www&quot;&gt;通用htaccess将www重定向到非www&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e9d10a73898648b0aedc5f97de4fe51653ebbb0" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/3634101/url-rewriting-for-different-protocols-in-htaccess&quot;&gt;URL rewriting for different protocols in .htaccess&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/3634101/url-rewriting-for-different-protocols-in-htaccess&quot;&gt;.htaccess中不同协议的URL重写&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11664097a8ffb0d8f28dc915df0128cf941e154f" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/4916222/htaccess-how-to-force-www-in-a-generic-way&quot;&gt;.htaccess - how to force &quot;www.&quot; in a generic way?&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/4916222/htaccess-how-to-force-www-in-a-generic-way&quot;&gt;.htaccess-如何强制使用&amp;ldquo; www&amp;rdquo;。&lt;/a&gt; 以一般的方式？</target>
        </trans-unit>
        <trans-unit id="49874443e813166bc4fdbfa82a1bbca93286ff6a" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/9153262/tips-for-debugging-htaccess-rewrite-rules&quot;&gt;Tips for debugging .htaccess rewrite rules&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/9153262/tips-for-debugging-htaccess-rewrite-rules&quot;&gt;调试.htaccess重写规则的提示&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23f298a47c3d469e691054bf2fb011ca932d6db4" translate="yes" xml:space="preserve">
          <source>&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/945047/htaccess-not-working-mod-rewrite&quot;&gt;.htaccess not working (mod_rewrite)&lt;/a&gt;</source>
          <target state="translated">&amp;middot; &lt;a href=&quot;https://stackoverflow.com/questions/945047/htaccess-not-working-mod-rewrite&quot;&gt;.htaccess不起作用（mod_rewrite）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="90b7f713187e69c77adcad3d9680fb1827b33af5" translate="yes" xml:space="preserve">
          <source>&amp;middot; Note that the leading slash is still correct in &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; sections though. Which is why you often see it &lt;code&gt;^/?&lt;/code&gt; optionalized for rule parity.</source>
          <target state="translated">&amp;middot;请注意，尽管 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 部分中的斜杠仍然是正确的。 这就是为什么您经常看到它的原因 &lt;code&gt;^/?&lt;/code&gt; 可选用于规则奇偶校验。</target>
        </trans-unit>
        <trans-unit id="cbe50ec46e66e9fc50014beb0301950e6ccf42b2" translate="yes" xml:space="preserve">
          <source>&amp;middot; Or when using a &lt;code&gt;RewriteCond %{REQUEST_URI}&lt;/code&gt; you'd still match for a leading &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">&amp;middot;或者，当使用 &lt;code&gt;RewriteCond %{REQUEST_URI}&lt;/code&gt; 您仍然会匹配前导 &lt;code&gt;/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="751229f868612475f9aa274c27c6748c3d39d97a" translate="yes" xml:space="preserve">
          <source>&amp;middot; See also &lt;a href=&quot;https://webmasters.stackexchange.com/questions/27118/when-is-the-leading-slash-needed-in-mod-rewrite-patterns&quot;&gt;Webmaster.SE: When is the leading slash (/) needed in mod_rewrite patterns?&lt;/a&gt;</source>
          <target state="translated">&amp;middot;另请参阅&lt;a href=&quot;https://webmasters.stackexchange.com/questions/27118/when-is-the-leading-slash-needed-in-mod-rewrite-patterns&quot;&gt;Webmaster.SE：什么时候在mod_rewrite模式中需要使用斜杠（/）？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="09ff1d5e4b8bdd76ba405a3bed899d1c8bef75b6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_alias.html#scriptaliasmatch&quot;&gt;&lt;code&gt;ScriptAliasMatch&lt;/code&gt;&lt;/a&gt; is primarily for CGI scripts, but also ought to works for PHP. It allows regexps just like any &lt;code&gt;RewriteRule&lt;/code&gt;. In fact it's perhaps the most robust option to configurate a catch-all front controller.</source>
          <target state="translated">&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_alias.html#scriptaliasmatch&quot;&gt; &lt;code&gt;ScriptAliasMatch&lt;/code&gt; &lt;/a&gt;主要用于CGI脚本，但也应该适用于PHP。 就像任何 &lt;code&gt;RewriteRule&lt;/code&gt; 一样，它允许正则表达式 。 实际上，它可能是配置通用前端控制器的最强大的选项。</target>
        </trans-unit>
        <trans-unit id="9a549849bbb01109ba011c5521c50e9b4dab2ca6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritecond&quot;&gt;Rewrite conditions&lt;/a&gt; make rewrites even more powerful, allowing you to specify rewrites for more specific situations. There are a lot of conditions which you can read about in &lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritecond&quot;&gt;the documentation&lt;/a&gt;, but I'll touch on a few common examples and explain them:</source>
          <target state="translated">&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritecond&quot;&gt;重写条件&lt;/a&gt;使重写功能更加强大，允许您为更特定的情况指定重写。 您可以在&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritecond&quot;&gt;文档中&lt;/a&gt;阅读很多条件，但我将介绍一些常见示例并进行解释：</target>
        </trans-unit>
        <trans-unit id="dabf9d101070ea48e2e85c726ecf5e80fe0caccb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$&lt;/code&gt; indicates this is the end of the string we want to match</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 表示这是我们要匹配的字符串的结尾</target>
        </trans-unit>
        <trans-unit id="3841678c9eead3827e8ffd336e806cea70870cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%{REQUEST_FILENAME} !-d&lt;/code&gt; will check to see if the file exists on the current server, and only execute the rewrite if it doesn't</source>
          <target state="translated">&lt;code&gt;%{REQUEST_FILENAME} !-d&lt;/code&gt; 将检查文件是否在当前服务器上，并且仅在不存在的情况下执行重写</target>
        </trans-unit>
        <trans-unit id="52ef5672eb064f0ebc113e70140ea1eadd1d8617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%{REQUEST_FILENAME} !-f&lt;/code&gt; will check to see if the file exists on the current server, and only execute the rewrite if it doesn't</source>
          <target state="translated">&lt;code&gt;%{REQUEST_FILENAME} !-f&lt;/code&gt; 将检查文件是否在当前服务器上，并且仅在不存在的情况下执行重写</target>
        </trans-unit>
        <trans-unit id="b5f7869488f52b18660937317e48137ddb57255d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%{REQUEST_URI} \.(jpg|jpeg|gif|png)$ [NC]&lt;/code&gt; will only execute the rewrite for files with a file extension of jpg, jpeg, gif or png (case insensitive).</source>
          <target state="translated">&lt;code&gt;%{REQUEST_URI} \.(jpg|jpeg|gif|png)$ [NC]&lt;/code&gt; 仅对文件扩展名为jpg，jpeg，gif或png（不区分大小写）的文件执行重写。</target>
        </trans-unit>
        <trans-unit id="84f88a1c5e685a84649de8e1bb782d50117ee3d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;IfModule *&amp;gt;&lt;/code&gt; wrappers begone!</source>
          <target state="translated">&lt;code&gt;&amp;lt;IfModule *&amp;gt;&lt;/code&gt; 包装器即将出现！</target>
        </trans-unit>
        <trans-unit id="740e3c6f83451b565f345cfff88bed98503f3438" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.*&lt;/code&gt; matches anything, even an empty string. You don't want to use this pattern everywhere, but often in the last fallback rule.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 匹配任何内容，甚至是空字符串。 您不想在所有地方都使用此模式，但通常在最后一个后备规则中使用。</target>
        </trans-unit>
        <trans-unit id="57a8bb9a55be2beb96f900e52fa775ececf4eb4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.htaccess&lt;/code&gt; vs. &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; 与 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd8275fe29a7eea617f1c546405e782cf8821462" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; means that the preceding character is optional, so in this case both &lt;code&gt;/blog/1/foo/&lt;/code&gt; and &lt;code&gt;/blog/1/foo&lt;/code&gt; would rewrite to the same place</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 表示前面的字符是可选的，因此在这种情况下， &lt;code&gt;/blog/1/foo/&lt;/code&gt; 和 &lt;code&gt;/blog/1/foo&lt;/code&gt; 都将重写到同一位置</target>
        </trans-unit>
        <trans-unit id="53ff5984a739c16e5b086e2a03847c8c36b495a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RewriteRule&lt;/code&gt; - starts the rewrite rule</source>
          <target state="translated">&lt;code&gt;RewriteRule&lt;/code&gt; -启动重写规则</target>
        </trans-unit>
        <trans-unit id="f6bc4be5b28507c8732dee618da29f11552edf76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[NC,L,QSA]&lt;/code&gt; are flags for the rewrite rule, separated by a comma, which I will explain more on later</source>
          <target state="translated">&lt;code&gt;[NC,L,QSA]&lt;/code&gt; 是重写规则的标志，以逗号分隔，我将在后面解释</target>
        </trans-unit>
        <trans-unit id="7f10bfcb87252edf50ae9c562e503f26dba99880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[\w\-.,]+&lt;/code&gt; adds periods and commas. Prefer an escaped &lt;code&gt;\-&lt;/code&gt; dash in &lt;code&gt;[&amp;hellip;]&lt;/code&gt; charclasses.</source>
          <target state="translated">&lt;code&gt;[\w\-.,]+&lt;/code&gt; 加上句点和逗号。 在 &lt;code&gt;[&amp;hellip;]&lt;/code&gt; charclass中更喜欢使用转义的 &lt;code&gt;\-&lt;/code&gt; 破折号。</target>
        </trans-unit>
        <trans-unit id="652e235ffc34df09e53fb0c478bb6569c2f6220f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[\w\-]+&lt;/code&gt; for &quot;slug&quot;-style path segments, using letters, numbers, dash &lt;code&gt;-&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[\w\-]+&lt;/code&gt; 用于&amp;ldquo;子弹&amp;rdquo;式路径段，使用字母，数字，破折号 &lt;code&gt;-&lt;/code&gt; &lt;em&gt;和&lt;/em&gt; &lt;code&gt;_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eefc1f169daf6dd207f047f1eca8ec66ccf23d21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^/]+&lt;/code&gt; is more often used for path segments. It matches anything but the forward slash.</source>
          <target state="translated">&lt;code&gt;[^/]+&lt;/code&gt; 通常用于路径段。 除正斜杠外，它都匹配。</target>
        </trans-unit>
        <trans-unit id="007f7af81afda692adf95fb0f0ea88501e1bf3b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\.&lt;/code&gt; denotes a literal period. Otherwise &lt;code&gt;.&lt;/code&gt; outside of &lt;code&gt;[&amp;hellip;]&lt;/code&gt; is placeholder for any symbol.</source>
          <target state="translated">&lt;code&gt;\.&lt;/code&gt; 表示原义时期。 否则 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;[&amp;hellip;]&lt;/code&gt; 外部是任何符号的占位符。</target>
        </trans-unit>
        <trans-unit id="5a4fb0ae48ecd50b05579d0b16175b9faa2f9145" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d+&lt;/code&gt; only matches numeric strings.</source>
          <target state="translated">&lt;code&gt;\d+&lt;/code&gt; 仅匹配数字字符串。</target>
        </trans-unit>
        <trans-unit id="88dd17205e1d1eb1880a3862d44c47469b59bc65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w+&lt;/code&gt; matches alphanumeric characters. It's basically shorthand for &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\w+&lt;/code&gt; 匹配字母数字字符。 它基本上是 &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="ecd5b35217c81c63b4a74c2649897e0738e78196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; indicates the start of the page name - so it will rewrite &lt;code&gt;example.com/blog/...&lt;/code&gt; but not &lt;code&gt;example.com/foo/blog/...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 表示页面名称的开头-因此它将重写 &lt;code&gt;example.com/blog/...&lt;/code&gt; ,但不会重写 &lt;code&gt;example.com/foo/blog/...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c35aed0c9b66dedf952907da4ac7c5d1e91082" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^blog/([0-9]+)/([A-Za-z0-9-\+]+)/?$&lt;/code&gt; - This is called the pattern, however I'll just refer to it as the left hand side of the rule - what you want to rewrite from</source>
          <target state="translated">&lt;code&gt;^blog/([0-9]+)/([A-Za-z0-9-\+]+)/?$&lt;/code&gt; -这称为模式，但是我仅将其称为左侧规则-您要重写的内容</target>
        </trans-unit>
        <trans-unit id="3c3e47bd9da371a8d996ad9238fb7d0a846ed34f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blog/index.php?id=$1&amp;amp;title=$2&lt;/code&gt; - called the substitution, or right hand side of a rewrite rule - what you want to rewrite to</source>
          <target state="translated">&lt;code&gt;blog/index.php?id=$1&amp;amp;title=$2&lt;/code&gt; 称为替换或重写规则的右侧-您要重写的内容</target>
        </trans-unit>
        <trans-unit id="c018111bc70724dcfa8cb1f7668165f1f8338ea1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(One could use &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_substitute.html&quot;&gt;&lt;code&gt;mod_substitute&lt;/code&gt;&lt;/a&gt; in conjunction to transform outgoing HTML pages and their contained links. Though this is usally more effort than just updating your HTML resources.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（一个人可以结合使用&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_substitute.html&quot;&gt; &lt;code&gt;mod_substitute&lt;/code&gt; &lt;/a&gt;来转换传出的HTML页面及其包含的链接。尽管这通常比更新HTML资源还要费劲。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13b7ff54bd60680e79ae5fbe5d410830c1d4ba46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: Just a pet peeve.&lt;/em&gt; You often hear pretty URL rewriting schemes referred to as &quot;SEO&quot; links or something. While this is useful for googling examples, it's a dated misnomer.</source>
          <target state="translated">&lt;em&gt;免责声明：只是一个宠物。&lt;/em&gt; 您经常听到漂亮的URL重写方案，称为&amp;ldquo; SEO&amp;rdquo;链接或其他内容。 尽管这对于谷歌搜索示例很有用，但它已过时。</target>
        </trans-unit>
        <trans-unit id="eac2e867209bf4cc7ac3e6c6c4fa20816e1a9de4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Frequent duplicates:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;经常重复：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97e1889f04dc3ae76733cf1c73e291e1aa7e9fa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before asking your own question&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在问自己的问题之前&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c93e3a38d537bf6691059af6469a46eaab5ed161" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compare &lt;code&gt;access.log&lt;/code&gt; and &lt;code&gt;error.log&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;比较 &lt;code&gt;access.log&lt;/code&gt; 和 &lt;code&gt;error.log&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2eb684fba0d3ae631715207143e21b416e87c173" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enable the RewriteLog&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;启用重写日志&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ad2c732c9574e224486865e3a43750bf1d28e9c" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* &lt;em&gt;If&lt;/em&gt; allowed by the primary Apache configuration file; it's optional, but often enabled.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;* &lt;em&gt;如果&lt;/em&gt;主要的Apache配置文件允许；&lt;/sub&gt; &lt;sub&gt;它是可选的，但经常启用。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2ac572067e403e7daf793fe6e0ac4b75ec0f146e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(Keep in mind to remove the slash in &lt;code&gt;^/&lt;/code&gt; pattern prefixes for &lt;code&gt;.htaccess&lt;/code&gt; usage.)&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（请记住要删除 &lt;code&gt;.htaccess&lt;/code&gt; 用法的 &lt;code&gt;^/&lt;/code&gt; 模式前缀中的斜杠。）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1d70018b10d872204ec89158898067f937b2f3f7" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/intro.html&quot;&gt;Apache manual - mod_rewrite intro&lt;/a&gt;, Copyright 2015 The Apache Software Foundation, AL-2.0&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/intro.html&quot;&gt;Apache手册-mod_rewrite简介&lt;/a&gt; ，版权所有2015 The Apache Software Foundation，AL-2.0&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="3bb0577c12be030ceb402e055b81983cbc559dc7" translate="yes" xml:space="preserve">
          <source>A common misinterpetation is that a RewriteCond blocks multiple RewriteRules (because they're visually arranged together):</source>
          <target state="translated">一个常见的误区是,一个RewriteCond阻挡了多个RewriteRules(因为它们在视觉上排列在一起)。</target>
        </trans-unit>
        <trans-unit id="d6fc1b11df2a64cfc4257b5e2e334dcee5fdb582" translate="yes" xml:space="preserve">
          <source>A common variation is to have optional prefixes &lt;em&gt;within&lt;/em&gt; a rule. This usually makes sense if you have static strings or more constrained placeholders around:</source>
          <target state="translated">一个常见的变化是&lt;em&gt;在&lt;/em&gt;规则中具有可选的前缀。 如果您有静态字符串或更多受约束的占位符，通常这是有意义的：</target>
        </trans-unit>
        <trans-unit id="b7d27b8628cafc228ce03267fced905dd8074078" translate="yes" xml:space="preserve">
          <source>A more directed approach to avoid carrying around &lt;code&gt;.php&lt;/code&gt; suffixes in URLs is &lt;a href=&quot;http://php.net/manual/en/security.hiding.php&quot;&gt;configuring the PHP handler&lt;/a&gt; for other file schemes. The simplest option is overriding the default MIME/handler type via &lt;code&gt;.htaccess&lt;/code&gt;:</source>
          <target state="translated">避免在URL中携带 &lt;code&gt;.php&lt;/code&gt; 后缀的更直接的方法是为其他文件方案&lt;a href=&quot;http://php.net/manual/en/security.hiding.php&quot;&gt;配置PHP处理程序&lt;/a&gt; 。 最简单的选项是通过 &lt;code&gt;.htaccess&lt;/code&gt; 覆盖默认的MIME /处理程序类型：</target>
        </trans-unit>
        <trans-unit id="20fc23c4cb699185bba8ced01fc05186ba75a0a1" translate="yes" xml:space="preserve">
          <source>A more practical use of alternative lists are mapping request paths to distinct scripts. For example to provide uniform URLs for an older and a newer web application based on dates:</source>
          <target state="translated">替代列表的一个更实际的用途是将请求路径映射到不同的脚本。例如,根据日期为一个较旧的和一个较新的Web应用提供统一的URL。</target>
        </trans-unit>
        <trans-unit id="124f0e78269a525e3a84a54aeffe59146bd971ec" translate="yes" xml:space="preserve">
          <source>A request for &lt;code&gt;/article/123&lt;/code&gt; for example could map to &lt;code&gt;article.php&lt;/code&gt; with a &lt;code&gt;/123&lt;/code&gt; PATH_INFO implicitly. You'd either have to guard your rules then with the commonplace &lt;code&gt;RewriteCond&lt;/code&gt;&lt;code&gt;!-f&lt;/code&gt;+&lt;code&gt;!-d&lt;/code&gt;, and/or disable PATH_INFO support, or perhaps just disable &lt;code&gt;Options -MultiViews&lt;/code&gt;.</source>
          <target state="translated">例如，对 &lt;code&gt;/article/123&lt;/code&gt; 的请求可以隐式地映射到具有 &lt;code&gt;/123&lt;/code&gt; PATH_INFO的 &lt;code&gt;article.php&lt;/code&gt; 。 您要么必须使用常见的 &lt;code&gt;RewriteCond&lt;/code&gt; &lt;code&gt;!-f&lt;/code&gt; + &lt;code&gt;!-d&lt;/code&gt; 来保护自己的规则，要么禁用PATH_INFO支持，要么仅禁用 &lt;code&gt;Options -MultiViews&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="433be67f13d6a6039d826a3ae6dabfa87aeb67b2" translate="yes" xml:space="preserve">
          <source>Again take note that such settings propagate from one &lt;code&gt;.htaccess&lt;/code&gt; to subfolders. You always should disable script execution (&lt;code&gt;SetHandler None&lt;/code&gt; and &lt;code&gt;Options -Exec&lt;/code&gt; or &lt;code&gt;php_flag engine off&lt;/code&gt; etc.) for static resources, and upload/ directories etc.</source>
          <target state="translated">再次注意，这些设置从一个 &lt;code&gt;.htaccess&lt;/code&gt; 传播到子文件夹。 您始终应该为静态资源，上传/目录等禁用脚本执行（ &lt;code&gt;SetHandler None&lt;/code&gt; 和 &lt;code&gt;Options -Exec&lt;/code&gt; 或 &lt;code&gt;php_flag engine off&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="6c86f75fe82e60b09e41ad6e136753d057e4146d" translate="yes" xml:space="preserve">
          <source>Aliasing old .html paths to .php scripts</source>
          <target state="translated">将旧的.html路径别名化为.php脚本</target>
        </trans-unit>
        <trans-unit id="11b618e5bc8ecbd76c5f38a2fe95c312ffdef55a" translate="yes" xml:space="preserve">
          <source>All of the below examples assume that you have already included &lt;code&gt;RewriteEngine On&lt;/code&gt; in your &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="translated">以下所有示例均假定您已在 &lt;code&gt;.htaccess&lt;/code&gt; 文件中包括 &lt;code&gt;RewriteEngine On&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27a22e164a7b422c5235f0d0b21b0dc4423cefeb" translate="yes" xml:space="preserve">
          <source>Alternatively you can utilize PHPs array parameters via &lt;code&gt;?p[]=$1&amp;amp;p[]=$2&amp;amp;p[]=3&lt;/code&gt; query string here - if your script merely prefers them pre-split.
(Though it's more common to just use a catch-all rule, and let the script itself expand the segments out of the REQUEST_URI.)</source>
          <target state="translated">或者，您可以在此处通过 &lt;code&gt;?p[]=$1&amp;amp;p[]=$2&amp;amp;p[]=3&lt;/code&gt; 查询字符串来使用PHP数组参数-如果您的脚本只希望将它们预分割。 （尽管更普遍的是只使用包罗万象的规则，然后让脚本本身将这些段扩展到REQUEST_URI之外。）</target>
        </trans-unit>
        <trans-unit id="e47f4e5a309adcf1b040c5210b5bc773d2eb8468" translate="yes" xml:space="preserve">
          <source>Alternatives to mod_rewrite</source>
          <target state="translated">mod_rewrite的替代产品</target>
        </trans-unit>
        <trans-unit id="a2ff10145ba39fbaf7ef21bb614d55aaa77793a9" translate="yes" xml:space="preserve">
          <source>Among its many options, Apache provides &lt;code&gt;mod_alias&lt;/code&gt; features - which sometimes work just as well as &lt;code&gt;mod_rewrite&lt;/code&gt;s RewriteRules. Note that most of those must be set up in a &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section however, not in per-directory &lt;code&gt;.htaccess&lt;/code&gt; config files.</source>
          <target state="translated">Apache提供了许多选项，其中包括 &lt;code&gt;mod_alias&lt;/code&gt; 功能-有时与 &lt;code&gt;mod_rewrite&lt;/code&gt; 的RewriteRules一样有效。 请注意，其中大多数必须在 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 部分中设置，而不是在每个目录的 &lt;code&gt;.htaccess&lt;/code&gt; 配置文件中设置。</target>
        </trans-unit>
        <trans-unit id="af99096848ed8cb0eea299166a097937fc97e50b" translate="yes" xml:space="preserve">
          <source>An excerpt from your &lt;code&gt;access.log&lt;/code&gt; and &lt;code&gt;error.log&lt;/code&gt; to verify what the existing rules resolved to. Better yet, a &lt;code&gt;rewrite.log&lt;/code&gt; summary.</source>
          <target state="translated">您的 &lt;code&gt;access.log&lt;/code&gt; 和 &lt;code&gt;error.log&lt;/code&gt; 的摘录，以验证现有规则解决的问题。 更好的是一个 &lt;code&gt;rewrite.log&lt;/code&gt; 摘要。</target>
        </trans-unit>
        <trans-unit id="ba6a9ee04d540d46321a6a706abef24c659c81df" translate="yes" xml:space="preserve">
          <source>And a plain &lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_alias.html#alias&quot;&gt;&lt;code&gt;Alias&lt;/code&gt;&lt;/a&gt; helps with a few simple rewriting schemes as well.</source>
          <target state="translated">普通的&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/mod_alias.html#alias&quot;&gt; &lt;code&gt;Alias&lt;/code&gt; &lt;/a&gt;可以帮助一些简单的重写方案。</target>
        </trans-unit>
        <trans-unit id="ef9d8db5d3dfaf745489b854e4b254c552aab203" translate="yes" xml:space="preserve">
          <source>And it's commonly distributed for default &lt;code&gt;.htaccess&lt;/code&gt; rulesets with many open source projects. There it's just meant as fallback, and keeps &quot;ugly&quot; URLs work as default.</source>
          <target state="translated">通常，它与许多开源项目一起分发给默认的 &lt;code&gt;.htaccess&lt;/code&gt; 规则集。 在这里，它只是作为备用广告，并保留&amp;ldquo;丑陋&amp;rdquo;的URL作为默认URL。</target>
        </trans-unit>
        <trans-unit id="86da803ab52102ad28a3f8ecce52c7d4a8621043" translate="yes" xml:space="preserve">
          <source>And newcomer-friendly regex overviews even:</source>
          <target state="translated">而对新人友好的regex概述甚至。</target>
        </trans-unit>
        <trans-unit id="9d30c141612d532ddc9ac96890f3f30fd7097b62" translate="yes" xml:space="preserve">
          <source>And the &lt;a href=&quot;/questions/tagged/mod-rewrite&quot;&gt;mod-rewrite&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/tags/mod-rewrite/info&quot;&gt;tag wiki references&lt;/a&gt;.</source>
          <target state="translated">和&lt;a href=&quot;/questions/tagged/mod-rewrite&quot;&gt;mod-rewrite&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/tags/mod-rewrite/info&quot;&gt;标签wiki参考&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe62757cd069906fac22465f642c8b25e045beee" translate="yes" xml:space="preserve">
          <source>And the short &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/intro.html#regex&quot;&gt;Apache regex summary&lt;/a&gt;.</source>
          <target state="translated">以及简短的&lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/intro.html#regex&quot;&gt;Apache regex摘要&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="5408edd8784686bb03f95bd3cfbf8d5c4d025f1b" translate="yes" xml:space="preserve">
          <source>Another often encountered rule is this:</source>
          <target state="translated">另一个经常遇到的规则是这样的。</target>
        </trans-unit>
        <trans-unit id="bf5c556e294b25711a0b5a44327bf833cd3e101a" translate="yes" xml:space="preserve">
          <source>Apache &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/remapping.html&quot;&gt;redirecting and remapping&lt;/a&gt; guide.</source>
          <target state="translated">Apache &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/remapping.html&quot;&gt;重定向和重新映射&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="284ef6600e99697d0d7d8d2957a4e47dd26fa3af" translate="yes" xml:space="preserve">
          <source>Apache and PHP versions, OS type, filesystem, DOCUMENT_ROOT, and PHPs &lt;code&gt;$_SERVER&lt;/code&gt; environment if it's about a parameter mismatch.</source>
          <target state="translated">Apache和PHP版本，操作系统类型，文件系统，DOCUMENT_ROOT和PHP &lt;code&gt;$_SERVER&lt;/code&gt; 环境，如果这与参数不匹配有关。</target>
        </trans-unit>
        <trans-unit id="cfe353f8853a9f04a5bdabbcdc53ebd267952363" translate="yes" xml:space="preserve">
          <source>As said before, you don't often want too generic rewrite patterns. It does however make sense to combine static and specific comparisons with a &lt;code&gt;.*&lt;/code&gt; sometimes.</source>
          <target state="translated">如前所述，您通常不需要太通用的重写模式。 但是，有时将静态比较和特定比较与 &lt;code&gt;.*&lt;/code&gt; 组合在一起是有意义的。</target>
        </trans-unit>
        <trans-unit id="d76c15ceb6076c092e88bddbb37d48859289c9a8" translate="yes" xml:space="preserve">
          <source>As you might know, Stack Overflow is very suitable for asking questions on mod_rewrite. Make them &lt;a href=&quot;https://stackoverflow.com/help/on-topic&quot;&gt;on-topic&lt;/a&gt;
by including prior research and attempts (avoid redundant answers), demonstrate basic &lt;a href=&quot;/questions/tagged/regex&quot;&gt;regex&lt;/a&gt; understanding, and:</source>
          <target state="translated">您可能知道，Stack Overflow非常适合在mod_rewrite上提问。 通过包括先前的研究和尝试（避免重复的答案），使它们成为&lt;a href=&quot;https://stackoverflow.com/help/on-topic&quot;&gt;主题&lt;/a&gt; ，展示对&lt;a href=&quot;/questions/tagged/regex&quot;&gt;正则表达式的&lt;/a&gt;基本理解，并：</target>
        </trans-unit>
        <trans-unit id="dff94f3ae82bd649b875179b762ba9d36b194992" translate="yes" xml:space="preserve">
          <source>AskApache &lt;a href=&quot;http://www.askapache.com/htaccess/htaccess.html&quot;&gt;ultimate .htaccess guide&lt;/a&gt;</source>
          <target state="translated">AskApache Ultimate &lt;a href=&quot;http://www.askapache.com/htaccess/htaccess.html&quot;&gt;.htaccess指南&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84507ed5b78e9f12ea3e3bf7c3287d27ecaf1074" translate="yes" xml:space="preserve">
          <source>Capture the remainder</source>
          <target state="translated">捕获剩余部分</target>
        </trans-unit>
        <trans-unit id="bc24e00f0d506c472f2be3ee5fbfbf1041e1d18a" translate="yes" xml:space="preserve">
          <source>Catch-all for a &lt;a href=&quot;https://stackoverflow.com/questions/8595964/redirect-all-traffic-to-index-php-using-mod-rewrite&quot;&gt;central dispatcher&lt;/a&gt; / front-controller script</source>
          <target state="translated">全面掌握&lt;a href=&quot;https://stackoverflow.com/questions/8595964/redirect-all-traffic-to-index-php-using-mod-rewrite&quot;&gt;中央调度员&lt;/a&gt; /前端控制器脚本</target>
        </trans-unit>
        <trans-unit id="d5e664288f7b3dfc0c3af90aa9c7fec3210b2112" translate="yes" xml:space="preserve">
          <source>Change the link to a pretty link:</source>
          <target state="translated">把链接改成漂亮的链接。</target>
        </trans-unit>
        <trans-unit id="edb59b056b2f75d0d2c02a13ae36b3214b3072e9" translate="yes" xml:space="preserve">
          <source>Check that your server has &lt;a href=&quot;https://stackoverflow.com/questions/9234289/verify-if-htaccess-file-is-running&quot;&gt;&lt;code&gt;AllowOverride All&lt;/code&gt; enabled&lt;/a&gt;. Otherwise your per-directory &lt;code&gt;.htaccess&lt;/code&gt; directives will go ignored, and RewriteRules won't work.</source>
          <target state="translated">检查您的服务器是否&lt;a href=&quot;https://stackoverflow.com/questions/9234289/verify-if-htaccess-file-is-running&quot;&gt;启用了 &lt;code&gt;AllowOverride All&lt;/code&gt; &lt;/a&gt; 。 否则，按目录的 &lt;code&gt;.htaccess&lt;/code&gt; 指令将被忽略，并且RewriteRules将不起作用。</target>
        </trans-unit>
        <trans-unit id="43e02a0b48e4866d690b1c507a06fd483627e959" translate="yes" xml:space="preserve">
          <source>Clients serialize URLs with &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;%20&lt;/code&gt; for spaces. Yet in RewriteRules they're interpreted with literal characters for all relative path segments.</source>
          <target state="translated">客户端使用 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;%20&lt;/code&gt; 的空格序列化URL。 但是在RewriteRules中，它们使用所有相对路径段的文字字符进行解释。</target>
        </trans-unit>
        <trans-unit id="46769ed18c1d5803b546e2a6cb333b52cf026f52" translate="yes" xml:space="preserve">
          <source>Comment your &lt;code&gt;.htaccess&lt;/code&gt;</source>
          <target state="translated">评论您的 &lt;code&gt;.htaccess&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2596cd693395e24245479f2e31c3c578dd845a59" translate="yes" xml:space="preserve">
          <source>Disable &lt;code&gt;MultiViews&lt;/code&gt; when virtual paths overlap</source>
          <target state="translated">虚拟路径重叠时禁用 &lt;code&gt;MultiViews&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36883655179b6ab85d480c08f87d30869c5f79e2" translate="yes" xml:space="preserve">
          <source>Dispatching related URLs to different backends</source>
          <target state="translated">将相关的URL发送至不同的后端</target>
        </trans-unit>
        <trans-unit id="e0840dbd1ccf3f820f75b9f6644ac7b4d5be4bb3" translate="yes" xml:space="preserve">
          <source>Do's and Dont's in &lt;a href=&quot;https://stackoverflow.com/questions/286004/hidden-features-of-mod-rewrite&quot;&gt;Hidden features of mod_rewrite&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://stackoverflow.com/questions/286004/hidden-features-of-mod-rewrite&quot;&gt;mod_rewrite&lt;/a&gt;的隐藏功能中执行和不执行。</target>
        </trans-unit>
        <trans-unit id="834ed7f21faa963f6520622a494bfc3b58b1ba55" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;RewriteBase&lt;/code&gt; unless needed</source>
          <target state="translated">除非需要，否则不要使用 &lt;code&gt;RewriteBase&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21f659d7912dac24fb0f151d94dc06f47abae6ad" translate="yes" xml:space="preserve">
          <source>Each of these placeholders is usually wrapped in &lt;code&gt;(&amp;hellip;)&lt;/code&gt; parentheses as capture group. And the whole pattern often in &lt;code&gt;^&amp;hellip;&amp;hellip;&amp;hellip;$&lt;/code&gt; start + end markers. Quoting &quot;patterns&quot; is optional.</source>
          <target state="translated">这些占位符通常都用 &lt;code&gt;(&amp;hellip;)&lt;/code&gt; 括起来作为捕获组。 整个模式通常以 &lt;code&gt;^&amp;hellip;&amp;hellip;&amp;hellip;$&lt;/code&gt; 开头+结尾标记为准。 引用&amp;ldquo;模式&amp;rdquo;是可选的。</target>
        </trans-unit>
        <trans-unit id="9b7029c092a10a71829815573236b3eb076aec29" translate="yes" xml:space="preserve">
          <source>Each set of &lt;code&gt;(&amp;hellip;)&lt;/code&gt; parentheses represents a regular expression that we can capture as a variable in the right hand side of the rule. In this example:</source>
          <target state="translated">每组 &lt;code&gt;(&amp;hellip;)&lt;/code&gt; 括号都代表一个正则表达式，我们可以将其捕获为规则右侧的变量。 在此示例中：</target>
        </trans-unit>
        <trans-unit id="db48663f832a68a6cc97ff86160706f75f79b09e" translate="yes" xml:space="preserve">
          <source>Else &lt;a href=&quot;http://www.regular-expressions.info/quickstart.html&quot;&gt;regexp.info&lt;/a&gt; for easy-to-understand basics.</source>
          <target state="translated">其他&lt;a href=&quot;http://www.regular-expressions.info/quickstart.html&quot;&gt;regexp.info&lt;/a&gt;提供了易于理解的基础知识。</target>
        </trans-unit>
        <trans-unit id="d919900346eee940f930da58592f8601027964df" translate="yes" xml:space="preserve">
          <source>Enable &lt;a href=&quot;http://httpd.apache.org/docs/2.4/mod/mod_negotiation.html&quot;&gt;MultiViews&lt;/a&gt; to hide the &lt;code&gt;.php&lt;/code&gt; extension</source>
          <target state="translated">启用&lt;a href=&quot;http://httpd.apache.org/docs/2.4/mod/mod_negotiation.html&quot;&gt;MultiViews&lt;/a&gt;隐藏 &lt;code&gt;.php&lt;/code&gt; 扩展名</target>
        </trans-unit>
        <trans-unit id="d89cfbe7e9590212bd8db77d7953dd70c27090a7" translate="yes" xml:space="preserve">
          <source>Enable &lt;code&gt;mod_rewrite&lt;/code&gt; and &lt;code&gt;.htaccess&lt;/code&gt;</source>
          <target state="translated">启用 &lt;code&gt;mod_rewrite&lt;/code&gt; 和 &lt;code&gt;.htaccess&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67f47d9d91b10c7848ba3ab2eb234427fa6f3b4d" translate="yes" xml:space="preserve">
          <source>Ensuring URLs are long-lived (AKA &lt;a href=&quot;https://en.wikipedia.org/wiki/Permalink&quot;&gt;permalinks&lt;/a&gt;).</source>
          <target state="translated">确保URL是长期有效的（又称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Permalink&quot;&gt;永久链接&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0d77e818c790de6920af7153aa064da2c1e29276" translate="yes" xml:space="preserve">
          <source>Even a plain &lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/core.html#errordocument&quot;&gt;&lt;code&gt;ErrorDocument&lt;/code&gt;&lt;/a&gt; directive could be used to let a PHP script handle virtual paths. Note that this is a kludgy workaround however, prohibits anything but GET requests, and floods the error.log by definition.</source>
          <target state="translated">甚至可以使用简单的&lt;a href=&quot;http://httpd.apache.org/docs/2.2/mod/core.html#errordocument&quot;&gt; &lt;code&gt;ErrorDocument&lt;/code&gt; &lt;/a&gt;指令来使PHP脚本处理虚拟路径。 请注意，这是一种繁琐的解决方法，但是禁止除GET请求之外的任何操作，并按定义泛洪error.log。</target>
        </trans-unit>
        <trans-unit id="83ec6145cb84f0dee900769119e35d59b3e7d752" translate="yes" xml:space="preserve">
          <source>Firstly, mod_rewrite does not randomly disengage. (If it did, you'd have bigger problems).</source>
          <target state="translated">首先,mod_rewrite不会随机脱离。如果有的话,你会有更大的问题)。</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="b6f02d776f09f6cec4c828de71faf43799655041" translate="yes" xml:space="preserve">
          <source>Flexible segments for virtual paths</source>
          <target state="translated">用于虚拟路径的灵活段</target>
        </trans-unit>
        <trans-unit id="09583105ba9e06aa15f198d86b54559183928403" translate="yes" xml:space="preserve">
          <source>For the also common</source>
          <target state="translated">对于同样常见的</target>
        </trans-unit>
        <trans-unit id="8ca49966ea1f0234f7d955d0b2e1ff4363d986f2" translate="yes" xml:space="preserve">
          <source>Fret not.</source>
          <target state="translated">别担心。</target>
        </trans-unit>
        <trans-unit id="8f0e67b093d5ce42b53747a234dad6c49e986688" translate="yes" xml:space="preserve">
          <source>Having readable and obvious resource schemes.</source>
          <target state="translated">具有可读性和明显的资源方案;</target>
        </trans-unit>
        <trans-unit id="10aa48f30ba9eb1d996b4bdcdaa78b540e6ae835" translate="yes" xml:space="preserve">
          <source>However don't sacrifice unique requirements for conformism.</source>
          <target state="translated">然而,不要为了符合主义而牺牲独特的要求。</target>
        </trans-unit>
        <trans-unit id="1fba90fa899b377cb4751fbd5881d6c42e5b6ba4" translate="yes" xml:space="preserve">
          <source>However you &lt;strong&gt;don't want&lt;/strong&gt; that usually in your own &lt;code&gt;.htaccess&lt;/code&gt; files.</source>
          <target state="translated">但是，您&lt;strong&gt;通常不希望&lt;/strong&gt;在自己的 &lt;code&gt;.htaccess&lt;/code&gt; 文件中使用该文件。</target>
        </trans-unit>
        <trans-unit id="daa5192ba9695ec4caf7b9bc31881436591ba4e2" translate="yes" xml:space="preserve">
          <source>If you copy examples from somewhere, take care to include a &lt;code&gt;# comment and origin link&lt;/code&gt;. While it's merely bad manners to omit attribution,
it often really hurts maintenance later. Document any code or tutorial source. In particular while unversed you should be
all the more interested in not treating them like magic blackboxes.</source>
          <target state="translated">如果您从某个地方复制示例，请注意包含 &lt;code&gt;# comment and origin link&lt;/code&gt; 。 尽管忽略归因只是一种不好的举止，但它通常确实会在以后损害维护。 记录任何代码或教程源。 尤其是当您不熟悉它时，您应该对不将它们像魔术黑匣子那样对待更加感兴趣。</target>
        </trans-unit>
        <trans-unit id="7bc07c648dc6661d82cf032a6a1256aa5c8a86f1" translate="yes" xml:space="preserve">
          <source>If you have similar rules for multiple virtual page paths, then you can match and compact them with &lt;code&gt;|&lt;/code&gt; alternative lists. And again just reassign them to internal GET parameters:</source>
          <target state="translated">如果您对多个虚拟页面路径具有相似的规则，则可以使用 &lt;code&gt;|&lt;/code&gt; 对其进行匹配和压缩。 替代清单。 再次将它们重新分配给内部GET参数：</target>
        </trans-unit>
        <trans-unit id="40f9b2a7a4a9787f861888f20e6f6fee7c69fed5" translate="yes" xml:space="preserve">
          <source>If you need up to five path segments, then copy this scheme along into five rules. You can of course use a more specific &lt;code&gt;[^/]+&lt;/code&gt; placeholder each.
Here the ordering isn't as important, as neither overlaps. So having the most frequently used paths first is okay.</source>
          <target state="translated">如果最多需要五个路径段，则将此方案复制到五个规则中。 当然，您每个都可以使用更具体的 &lt;code&gt;[^/]+&lt;/code&gt; 占位符。 这里的顺序并不重要，因为两者都不重叠。 因此首先拥有最常用的路径是可以的。</target>
        </trans-unit>
        <trans-unit id="f71191a5e264cb63bd6f631ed5e3481ceef06433" translate="yes" xml:space="preserve">
          <source>If you're using RewriteRules in a per-directory config file, then worrying about regex performance is pointless. Apache retains
compiled PCRE patterns longer than a PHP process with a common routing framework. For high-traffic sites you should however consider
moving rulesets into the vhost server configuration, once they've been battle-tested.</source>
          <target state="translated">如果你在每个目录的配置文件中使用RewriteRules,那么担心regex性能是没有意义的。Apache保留编译后的PCRE模式的时间比使用通用路由框架的PHP进程要长。但是对于高流量的网站,你应该考虑将规则集移到vhost服务器配置中,一旦它们经过了实战测试,你就应该考虑将它们移到vhost服务器配置中。</target>
        </trans-unit>
        <trans-unit id="273b2c2b5a292ce481ed96ebfa83369d2f85daa8" translate="yes" xml:space="preserve">
          <source>In this case, prefer the optionalized &lt;code&gt;^/?&lt;/code&gt; directory separator prefix. This allows to move RewriteRules freely between PerDir and server
config files.</source>
          <target state="translated">在这种情况下，最好使用可选的 &lt;code&gt;^/?&lt;/code&gt; 目录分隔符前缀。 这允许在PerDir和服务器配置文件之间自由移动RewriteRules。</target>
        </trans-unit>
        <trans-unit id="aef9108cecb21bfcd735b644678196233a16cf35" translate="yes" xml:space="preserve">
          <source>Include &lt;em&gt;full&lt;/em&gt; examples of input URLs, falsly rewritten target paths, your real directory structure.</source>
          <target state="translated">包括输入URL的&lt;em&gt;完整&lt;/em&gt;示例，错误重写的目标路径以及您的真实目录结构。</target>
        </trans-unit>
        <trans-unit id="f296f7312d86d0df48d961f47b8c11e9d5bcef5b" translate="yes" xml:space="preserve">
          <source>Introducing shortcuts like &lt;code&gt;http://example.com/article/531&lt;/code&gt; to existing PHP scripts is also easy. The numeric placeholder can just be remapped to a &lt;code&gt;$_GET&lt;/code&gt; parameter:</source>
          <target state="translated">向现有的PHP脚本引入诸如 &lt;code&gt;http://example.com/article/531&lt;/code&gt; 之类的快捷方式也很容易。 可以将数字占位符重新映射到 &lt;code&gt;$_GET&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="deccb5a329125b3a2543074f3d0db866e73f9a4d" translate="yes" xml:space="preserve">
          <source>It &lt;em&gt;does&lt;/em&gt; make sense in &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; sections - if it was combined with another fallback option, such as ScriptAliasMatch. (But nobody ever does that).</source>
          <target state="translated">如果将它与另一个回退选项（例如ScriptAliasMatch）结合使用，则在 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 部分中&lt;em&gt;确实&lt;/em&gt;有意义。 （但是没有人这样做）。</target>
        </trans-unit>
        <trans-unit id="0301879fb32bdc77402f7413db66117a874fb2e3" translate="yes" xml:space="preserve">
          <source>It makes sense to use with individual web applications in deeper subdirectories. It can shorten RewriteRule patterns in such cases. Generally it's best to prefer relative path specifiers in per-directory rule sets.</source>
          <target state="translated">它与更深的子目录中的单个Web应用程序一起使用是有意义的。在这种情况下,它可以缩短RewriteRule模式。一般来说,在每个目录规则集中最好使用相对路径指定器。</target>
        </trans-unit>
        <trans-unit id="5f40de2ca60f034f9b89abc054587e9fe0b8a168" translate="yes" xml:space="preserve">
          <source>It's meant to prevent HTTP &lt;code&gt;500&lt;/code&gt; errors. What it usually accomplishes is gracing your users with HTTP &lt;code&gt;404&lt;/code&gt; errors instead. (Not &lt;em&gt;so much&lt;/em&gt; more user-friendly if you think about it.)</source>
          <target state="translated">这是为了防止HTTP &lt;code&gt;500&lt;/code&gt; 错误。 它通常完成的工作是使用户遭受HTTP &lt;code&gt;404&lt;/code&gt; 错误的困扰。 （如果您考虑的话，它并不会更加人性化。）</target>
        </trans-unit>
        <trans-unit id="fe7d59926a852a088beeaaee3db79063e7eb9f5e" translate="yes" xml:space="preserve">
          <source>It's not &quot;SEO&quot;-URLs</source>
          <target state="translated">这不是 &quot;SEO&quot;--URLs</target>
        </trans-unit>
        <trans-unit id="60cd4fcec9f18f17da87abdc46607c7a489cd1f3" translate="yes" xml:space="preserve">
          <source>It's not &lt;em&gt;that pretty&lt;/em&gt; in browser address bars, but you can use spaces in URLs. For rewrite patterns use backslash-escaped &lt;code&gt;\␣&lt;/code&gt; spaces.
Else just &lt;code&gt;&quot;&lt;/code&gt;-quote the whole pattern or substitution:</source>
          <target state="translated">浏览器地址栏中的效果不是&lt;em&gt;很好&lt;/em&gt; ，但是您可以在URL中使用空格。 对于重写模式，请使用反斜杠转义的 &lt;code&gt;\␣&lt;/code&gt; 空格。 否则只用 &lt;code&gt;&quot;&lt;/code&gt; 引用整个模式或替换：</target>
        </trans-unit>
        <trans-unit id="bfc7e888699007054c60bf571793536b40294c92" translate="yes" xml:space="preserve">
          <source>Left hand side of the rule</source>
          <target state="translated">规则的左手边</target>
        </trans-unit>
        <trans-unit id="6bee440a86949e7ccce05e9ca4299268e30a2049" translate="yes" xml:space="preserve">
          <source>Lets take this example:</source>
          <target state="translated">就拿这个例子来说吧。</target>
        </trans-unit>
        <trans-unit id="3d960efa71adf65b880313cd6447fa5c5f98e928" translate="yes" xml:space="preserve">
          <source>Look through our &lt;a href=&quot;https://stackoverflow.com/questions/tagged/mod-rewrite?sort=frequent&quot;&gt;most popular mod-rewrite&lt;/a&gt; questions and answers.</source>
          <target state="translated">查看我们&lt;a href=&quot;https://stackoverflow.com/questions/tagged/mod-rewrite?sort=frequent&quot;&gt;最受欢迎的mod-rewrite&lt;/a&gt;问题和答案。</target>
        </trans-unit>
        <trans-unit id="fe7bfd847a60a74d96670220635ed35de8d744bc" translate="yes" xml:space="preserve">
          <source>Many basic virtual URL schemes can be achieved without using RewriteRules. Apache allows PHP scripts to be invoked without &lt;code&gt;.php&lt;/code&gt; extension, and with a virtual &lt;code&gt;PATH_INFO&lt;/code&gt; argument.</source>
          <target state="translated">不使用RewriteRules即可实现许多基本的虚拟URL方案。 Apache允许在不带 &lt;code&gt;.php&lt;/code&gt; 扩展名且带有虚拟 &lt;code&gt;PATH_INFO&lt;/code&gt; 参数的情况下调用PHP脚本。</target>
        </trans-unit>
        <trans-unit id="2488526091aa3f6c4f0c336210e3a1890b4fed46" translate="yes" xml:space="preserve">
          <source>Many copy+paste examples contain a &lt;code&gt;RewriteBase /&lt;/code&gt; directive. Which happens to be the implicit default anyway. So you don't actually need this. It's a workaround for fancy VirtualHost rewriting schemes, and misguessed DOCUMENT_ROOT paths for some shared hosters.</source>
          <target state="translated">许多复制+粘贴示例都包含 &lt;code&gt;RewriteBase /&lt;/code&gt; 指令。 无论如何，这恰好是隐式默认值。 因此，您实际上不需要此。 这是一种不错的VirtualHost重写方案的解决方法，并且为某些共享托管者误导了DOCUMENT_ROOT路径。</target>
        </trans-unit>
        <trans-unit id="b6ec4f0b45ba608dc99259ba104501c3006e2b98" translate="yes" xml:space="preserve">
          <source>Most rules you'll encounter map a constrained set of &lt;code&gt;/&amp;hellip;/&lt;/code&gt; resource path segments to individual GET parameters. Some scripts &lt;a href=&quot;https://stackoverflow.com/q/3655893&quot;&gt;handle a variable number of options&lt;/a&gt; however.
The Apache regexp engine doesn't allow optionalizing an arbitrary number of them. But you can easily expand it into a rule block yourself:</source>
          <target state="translated">您将遇到的大多数规则将一组受约束的 &lt;code&gt;/&amp;hellip;/&lt;/code&gt; 资源路径段映射到各个GET参数。 但是，某些脚本&lt;a href=&quot;https://stackoverflow.com/q/3655893&quot;&gt;处理可变数量的选项&lt;/a&gt; 。 Apache regexp引擎不允许任意选择它们。 但是您可以自己轻松地将其扩展为规则块：</target>
        </trans-unit>
        <trans-unit id="91486619ecb50e8edbf96d3a9061ef481aa26b8d" translate="yes" xml:space="preserve">
          <source>Mostly just output &lt;code&gt;[^/]+&lt;/code&gt; generic placeholders, but likely suffices for trivial sites.</source>
          <target state="translated">通常只输出 &lt;code&gt;[^/]+&lt;/code&gt; 通用占位符，但对于琐碎的网站可能就足够了。</target>
        </trans-unit>
        <trans-unit id="1d74e7db0e0fdb1eefe36a8b715de7d180085193" translate="yes" xml:space="preserve">
          <source>None of the modern search engines are really disturbed by &lt;code&gt;.html&lt;/code&gt; and &lt;code&gt;.php&lt;/code&gt; in path segments, or &lt;code&gt;?id=123&lt;/code&gt; query strings for that matter. Search engines of old, such as AltaVista, &lt;em&gt;did&lt;/em&gt; avoid crawling websites with potentially ambigious access paths. Modern crawlers are often even craving for deep web resources.</source>
          <target state="translated">没有现代的搜索引擎真正受到路径段中的 &lt;code&gt;.html&lt;/code&gt; 和 &lt;code&gt;.php&lt;/code&gt; 或此问题的 &lt;code&gt;?id=123&lt;/code&gt; 查询字符串的干扰。 诸如AltaVista之类的老式搜索引擎&lt;em&gt;的确&lt;/em&gt;避免了对具有潜在歧义访问路径的网站进行爬网。 现代的爬虫甚至甚至渴望获得深层的Web资源。</target>
        </trans-unit>
        <trans-unit id="f315ee6a0a369040aac7c320f6906f7802ad2aa3" translate="yes" xml:space="preserve">
          <source>Note how this example just uses &lt;code&gt;[END]&lt;/code&gt; instead of &lt;code&gt;[L]&lt;/code&gt; to safely alternate. For older Apache 2.2 versions you can use other workarounds, besides also remapping
query string parameters for example:
&lt;a href=&quot;https://stackoverflow.com/questions/11629896/mod-rewrite-redirect-url-with-query-string-to-pretty-url&quot;&gt;Redirect ugly to pretty URL, remap  back to the ugly path, without infinite loops&lt;/a&gt;</source>
          <target state="translated">请注意，本示例仅使用 &lt;code&gt;[END]&lt;/code&gt; 而非 &lt;code&gt;[L]&lt;/code&gt; 进行安全交替。 对于较旧的Apache 2.2版本，除了重新映射查询字符串参数外，您还可以使用其他解决方法： &lt;a href=&quot;https://stackoverflow.com/questions/11629896/mod-rewrite-redirect-url-with-query-string-to-pretty-url&quot;&gt;将丑陋重定向到漂亮的URL，重新映射回丑陋的路径，而没有无限循环&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc7223f3c5a01865151b0532dd2483e959ec3aa6" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;your script&lt;/em&gt;&lt;strong&gt;must&lt;/strong&gt; be able (or be adapted) to map those titles back to database-ids. RewriteRules alone can't create or guess information out of thin air.</source>
          <target state="translated">请注意， &lt;em&gt;您的脚本&lt;/em&gt; &lt;strong&gt;必须&lt;/strong&gt;能够（或适应）将这些标题映射回数据库ID。 仅RewriteRules不能凭空创造或猜测信息。</target>
        </trans-unit>
        <trans-unit id="0c2965817441b972dd6422436654a2df9f92c29e" translate="yes" xml:space="preserve">
          <source>Note that MultiViews has a different/broader purpose though. It incurs a &lt;em&gt;very minor&lt;/em&gt; performance penalty, because Apache always looks for other files with matching basenames. It's actually meant for &lt;a href=&quot;https://en.wikipedia.org/wiki/Content_negotiation&quot;&gt;Content-Negotiation&lt;/a&gt;, so browsers receive the best alternative among available resources (such as &lt;code&gt;article.en.php&lt;/code&gt;, &lt;code&gt;article.fr.php&lt;/code&gt;, &lt;code&gt;article.jp.mp4&lt;/code&gt;).</source>
          <target state="translated">请注意，尽管MultiViews具有不同/更广泛的用途。 由于Apache始终会寻找具有匹配基名的其他文件，因此它对性能的&lt;em&gt;影响很小&lt;/em&gt; 。 它实际上是用于&lt;a href=&quot;https://en.wikipedia.org/wiki/Content_negotiation&quot;&gt;内容协商的&lt;/a&gt; ，因此浏览器会在可用资源（例如 &lt;code&gt;article.en.php&lt;/code&gt; ， &lt;code&gt;article.fr.php&lt;/code&gt; ， &lt;code&gt;article.jp.mp4&lt;/code&gt; ）中获得最佳选择。</target>
        </trans-unit>
        <trans-unit id="421dacfb060756bed4005a3f4a19279a8d0a45ad" translate="yes" xml:space="preserve">
          <source>Note that RewriteCond/RewriteRule combos can be more complex, with matches (&lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt;) interacting in both directions even:</source>
          <target state="translated">请注意，RewriteCond / RewriteRule组合可能更复杂，甚至匹配（ &lt;code&gt;%1&lt;/code&gt; 和 &lt;code&gt;$1&lt;/code&gt; ）在两个方向上都可以交互：</target>
        </trans-unit>
        <trans-unit id="ed12e6e43435545c959aae1c59102e543bb2d305" translate="yes" xml:space="preserve">
          <source>Note that this doesn't copy a query string along, etc.</source>
          <target state="translated">注意,这并不能复制一个查询字符串沿等。</target>
        </trans-unit>
        <trans-unit id="8965d98cc2645af0da6247a2206e79a972c91350" translate="yes" xml:space="preserve">
          <source>Now take this with a grain of salt. Not every advise can be generalized to all contexts.
This is just a simple summary of well-known and a few unobvious stumbling blocks:</source>
          <target state="translated">现在,我们要谨慎对待这一点。并非每一条建议都能一概而论。这只是简单总结了一些众所周知的和一些不明显的绊脚石。</target>
        </trans-unit>
        <trans-unit id="d1728adec405a6b225772abbd6bd1fd0974106ab" translate="yes" xml:space="preserve">
          <source>Now the more complex pattern &lt;code&gt;(?:/([^/])+)?&lt;/code&gt; there simply wraps a &lt;em&gt;non-capturing&lt;/em&gt;&lt;code&gt;(?:&amp;hellip;)&lt;/code&gt; group, and makes it optional &lt;code&gt;)?&lt;/code&gt;. The contained
placeholder &lt;code&gt;([^/]+)&lt;/code&gt; would be substitution pattern &lt;code&gt;$2&lt;/code&gt;, but be empty if there's no middle &lt;code&gt;/&amp;hellip;/&lt;/code&gt; path.</source>
          <target state="translated">现在更复杂的模式 &lt;code&gt;(?:/([^/])+)?&lt;/code&gt; 那里只是包装了一个&lt;em&gt;非捕获&lt;/em&gt; &lt;code&gt;(?:&amp;hellip;)&lt;/code&gt; 组，并使其成为可选的 &lt;code&gt;)?&lt;/code&gt; 。 包含的占位符 &lt;code&gt;([^/]+)&lt;/code&gt; 将是替换模式 &lt;code&gt;$2&lt;/code&gt; ，但如果没有中间 &lt;code&gt;/&amp;hellip;/&lt;/code&gt; 路径， 则为空。</target>
        </trans-unit>
        <trans-unit id="45683ef59f00892047993aca6b972c98e9a0ee43" translate="yes" xml:space="preserve">
          <source>Now this &lt;code&gt;/virtual/path&lt;/code&gt; shows up in PHP as &lt;a href=&quot;https://secure.php.net/manual/en/reserved.variables.server.php#~PATH_INFO&quot;&gt;&lt;code&gt;$_SERVER[&quot;PATH_INFO&quot;]&lt;/code&gt;&lt;/a&gt; where you can handle any extra arguments however you like.</source>
          <target state="translated">现在，此 &lt;code&gt;/virtual/path&lt;/code&gt; 在PHP中显示为&lt;a href=&quot;https://secure.php.net/manual/en/reserved.variables.server.php#~PATH_INFO&quot;&gt; &lt;code&gt;$_SERVER[&quot;PATH_INFO&quot;]&lt;/code&gt; &lt;/a&gt; ，您可以在其中处理所需的任何其他参数。</target>
        </trans-unit>
        <trans-unit id="f37afffd1053ca926ca822a035ccdafe43d5cba9" translate="yes" xml:space="preserve">
          <source>Now this can have some security and performance implications, because all extensionless files would be piped through PHP now. Therefore you can alternatively set this behaviour for individual files only:</source>
          <target state="translated">现在,这可能会对安全和性能产生一些影响,因为所有无扩展的文件都会通过PHP进行管道传输。因此你可以选择只对单个文件设置这个行为。</target>
        </trans-unit>
        <trans-unit id="7867d100537d9098a99e4b192ff17b1002e490bb" translate="yes" xml:space="preserve">
          <source>Now this handles both &lt;code&gt;http://example.com/blog/123&lt;/code&gt; and &lt;code&gt;/blog/123/&lt;/code&gt;. And the</source>
          <target state="translated">现在，它可以处理 &lt;code&gt;http://example.com/blog/123&lt;/code&gt; 和 &lt;code&gt;/blog/123/&lt;/code&gt; 。 和</target>
        </trans-unit>
        <trans-unit id="b48064afbe59853d0a5c42248122b5a14e1f1c10" translate="yes" xml:space="preserve">
          <source>Now you could just skip passing the &lt;code&gt;title=$2&lt;/code&gt; anyway, because your script will typically rely on the database-id anyway. The &lt;code&gt;-title-slug&lt;/code&gt; has become arbitrary URL decoration.</source>
          <target state="translated">现在您无论如何都可以跳过传递 &lt;code&gt;title=$2&lt;/code&gt; ，因为您的脚本通常总是依赖于数据库ID。 &lt;code&gt;-title-slug&lt;/code&gt; 已成为任意URL装饰。</target>
        </trans-unit>
        <trans-unit id="ed748a9515391cfb1af34a967ee70140171d18c6" translate="yes" xml:space="preserve">
          <source>Nowadays &lt;a href=&quot;http://httpd.apache.org/docs/2.4/en/mod/core.html#acceptpathinfo&quot;&gt;&lt;code&gt;AcceptPathInfo On&lt;/code&gt;&lt;/a&gt; is often enabled by default. Which basically allows &lt;code&gt;.php&lt;/code&gt; and other resource URLs to carry a virtual argument:</source>
          <target state="translated">如今，默认情况下通常启用&lt;a href=&quot;http://httpd.apache.org/docs/2.4/en/mod/core.html#acceptpathinfo&quot;&gt; &lt;code&gt;AcceptPathInfo On&lt;/code&gt; &lt;/a&gt; 。 它基本上允许 &lt;code&gt;.php&lt;/code&gt; 和其他资源URL携带虚拟参数：</target>
        </trans-unit>
        <trans-unit id="0afd56482356096622a5660a16723100cd4fa634" translate="yes" xml:space="preserve">
          <source>Numeric identifiers</source>
          <target state="translated">数字标识符</target>
        </trans-unit>
        <trans-unit id="5f378de1046672c4099905b347e55ac91af76926" translate="yes" xml:space="preserve">
          <source>Obviously &lt;a href=&quot;https://stackoverflow.com/questions/869092/how-to-enable-mod-rewrite-for-apache-2-2&quot;&gt;have &lt;code&gt;mod_rewrite&lt;/code&gt; enabled&lt;/a&gt; in your &lt;code&gt;httpd.conf&lt;/code&gt; modules section.</source>
          <target state="translated">显然，在您的 &lt;code&gt;httpd.conf&lt;/code&gt; 模块部分中&lt;a href=&quot;https://stackoverflow.com/questions/869092/how-to-enable-mod-rewrite-for-apache-2-2&quot;&gt;启用&lt;/a&gt;了 &lt;code&gt;mod_rewrite&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ddb71358a682b6ae3c886c00e05b6ee0351e570" translate="yes" xml:space="preserve">
          <source>Occasionally it's suitable to alternate between &lt;code&gt;/&lt;/code&gt;-delimiters and &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; in the same rule even. Or have two RewriteRules again to map variants onto different scripts.</source>
          <target state="translated">偶尔适合在 &lt;code&gt;/&lt;/code&gt; -分隔符和 &lt;code&gt;:&lt;/code&gt; 或之间切换 &lt;code&gt;.&lt;/code&gt; 同样的规则 或者再次使用两个RewriteRules将变体映射到不同的脚本。</target>
        </trans-unit>
        <trans-unit id="382738c5157f5ee201cf389409adf7a1a5d95f2c" translate="yes" xml:space="preserve">
          <source>Oft-used placeholders</source>
          <target state="translated">经常使用的占位符</target>
        </trans-unit>
        <trans-unit id="a4d4b59e499759015fe91837364116829ea9c319" translate="yes" xml:space="preserve">
          <source>Often simply by adding &lt;code&gt;&amp;lt;base href=&quot;/index&quot;&amp;gt;&lt;/code&gt; into your HTML &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; section.
This implicitly rebinds relative references to what they were before.</source>
          <target state="translated">通常，只需将 &lt;code&gt;&amp;lt;base href=&quot;/index&quot;&amp;gt;&lt;/code&gt; 到HTML &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 部分中即可。 这隐式地将相对引用重新绑定到以前的内容。</target>
        </trans-unit>
        <trans-unit id="64dd841b1c90885ac80fd0d55f39f4aa949aefcb" translate="yes" xml:space="preserve">
          <source>Often you can figure out how a RewriteRule misbehaves just from looking at your &lt;code&gt;error.log&lt;/code&gt; and &lt;code&gt;access.log&lt;/code&gt;.
Correlate access times to see which request path originally came in, and which path/file Apache couldn't resolve to (error 404/500).</source>
          <target state="translated">通常，仅通过查看 &lt;code&gt;error.log&lt;/code&gt; 和 &lt;code&gt;access.log&lt;/code&gt; ，您就可以弄清楚RewriteRule的行为方式。 关联访问时间，以查看最初进入哪个请求路径以及Apache无法解析的路径/文件（错误404/500）。</target>
        </trans-unit>
        <trans-unit id="0df724c30480f21eaa050c58057282993948b80e" translate="yes" xml:space="preserve">
          <source>Only using server-absolute references &lt;code&gt;href=&quot;/old.html&quot;&lt;/code&gt; or &lt;code&gt;src=&quot;/logo.png&quot;&lt;/code&gt;</source>
          <target state="translated">仅使用服务器绝对引用 &lt;code&gt;href=&quot;/old.html&quot;&lt;/code&gt; 或 &lt;code&gt;src=&quot;/logo.png&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="154c95281c3d555dc7266790046d6d0c55b5ef77" translate="yes" xml:space="preserve">
          <source>Optional segments</source>
          <target state="translated">可选部分</target>
        </trans-unit>
        <trans-unit id="bf0dfa52ba48f0808d587223064703f75f816c3a" translate="yes" xml:space="preserve">
          <source>Optional trailing &lt;code&gt;/&lt;/code&gt; slash</source>
          <target state="translated">可选的尾随 &lt;code&gt;/&lt;/code&gt; 斜杠</target>
        </trans-unit>
        <trans-unit id="bd4bedf42533e868451f1a4c9022eac830c1394e" translate="yes" xml:space="preserve">
          <source>Ordering is important</source>
          <target state="translated">订购是很重要的</target>
        </trans-unit>
        <trans-unit id="ed609198a95c9be6f04ce9d1d822a9807996d79c" translate="yes" xml:space="preserve">
          <source>Other Apache rewriting schemes</source>
          <target state="translated">其他Apache重写方案</target>
        </trans-unit>
        <trans-unit id="81af1ba5d512fd109cf684ae0943af6787277fa0" translate="yes" xml:space="preserve">
          <source>Other common names, aliases, terms for clean URLs: &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; URLs, user-friendly URLs, &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt;-friendly URLs, &lt;a href=&quot;https://en.wikipedia.org/wiki/Clean_URL#Slug&quot;&gt;slugging&lt;/a&gt;, and MVC URLs (probably a misnomer)</source>
          <target state="translated">其他通用名称，别名，干净URL的术语： &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services&quot;&gt;RESTful&lt;/a&gt; URL，用户友好的URL， &lt;a href=&quot;http://en.wikipedia.org/wiki/Search_engine_optimization&quot;&gt;SEO&lt;/a&gt;友好的URL， &lt;a href=&quot;https://en.wikipedia.org/wiki/Clean_URL#Slug&quot;&gt;慢速运行&lt;/a&gt;和MVC URL（可能是用词不当）</target>
        </trans-unit>
        <trans-unit id="a2d1e8d66be83edd5b4bb78c85706e2242b6ca4d" translate="yes" xml:space="preserve">
          <source>Other common uses are remapping obsolete &lt;code&gt;.html&lt;/code&gt; paths to newer &lt;code&gt;.php&lt;/code&gt; handlers, or just aliasing directory names only for individual (actual/real) files.</source>
          <target state="translated">其他常见用法是将过时的 &lt;code&gt;.html&lt;/code&gt; 路径重新映射到较新的 &lt;code&gt;.php&lt;/code&gt; 处理程序，或者仅为单独的（实际/实际）文件别名目录名称。</target>
        </trans-unit>
        <trans-unit id="e22c6117eec085066b8864ee86848a7fc70b8391" translate="yes" xml:space="preserve">
          <source>Other delimiters than just &lt;code&gt;/&lt;/code&gt; path slashes</source>
          <target state="translated">除 &lt;code&gt;/&lt;/code&gt; 斜杠以外的其他定界符</target>
        </trans-unit>
        <trans-unit id="ad8bf9cefe3a521ea2a0949d248eaeec3191518a" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;/questions/tagged/regex&quot;&gt;regex&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/tags/regex/info&quot;&gt;tag wiki&lt;/a&gt; for a syntax compendium.</source>
          <target state="translated">我们的&lt;a href=&quot;/questions/tagged/regex&quot;&gt;regex&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/tags/regex/info&quot;&gt;标签wiki，&lt;/a&gt;用于语法汇编。</target>
        </trans-unit>
        <trans-unit id="ed7ce6a62d983c526aa157e7a48cda050f92f59e" translate="yes" xml:space="preserve">
          <source>Ping-Pong (redirects and rewrites in unison)</source>
          <target state="translated">乒乓球(转发和改写不同步)</target>
        </trans-unit>
        <trans-unit id="735003089a236c0d060fcfb96e6c5c0337f5d272" translate="yes" xml:space="preserve">
          <source>Practically it just suppresses the more useful log entries, or server notification mails. You'd be &lt;strong&gt;none the wiser&lt;/strong&gt; as to why your RewriteRules never work.</source>
          <target state="translated">实际上，它只是禁止显示更有用的日志条目或服务器通知邮件。 对于您的RewriteRules为何行不通，您将毫无&lt;strong&gt;智慧&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="62b88add85f24690a5fdaa48492419bf137450cf" translate="yes" xml:space="preserve">
          <source>Prepend each list of rules with &lt;code&gt;RewriteEngine On&lt;/code&gt; still. While mod_rewrite is implicitly active in &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; sections,
the per-directory &lt;code&gt;.htaccess&lt;/code&gt; files need it individually summoned.</source>
          <target state="translated">将规则的每个列表 &lt;code&gt;RewriteEngine On&lt;/code&gt; 。 虽然 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; 部分中的mod_rewrite隐式处于活动状态，但每个目录的 &lt;code&gt;.htaccess&lt;/code&gt; 文件需要分别将其召唤。</target>
        </trans-unit>
        <trans-unit id="0d460c402637ee80e5cbe8fb8827d4a768e09bd5" translate="yes" xml:space="preserve">
          <source>Prevalent &lt;code&gt;.htaccess&lt;/code&gt; pitfalls</source>
          <target state="translated">普遍的 &lt;code&gt;.htaccess&lt;/code&gt; 陷阱</target>
        </trans-unit>
        <trans-unit id="20511274c0bc24f9a1ab6b20592c13f82d99001b" translate="yes" xml:space="preserve">
          <source>Primarily you put these rewrite rules into your &lt;em&gt;web server configuration file&lt;/em&gt;. Apache also allows* you to put them into a file called &lt;code&gt;.htaccess&lt;/code&gt; within your document root (i.e. next to your .php files).</source>
          <target state="translated">首先，您将这些重写规则放入&lt;em&gt;Web服务器配置文件中&lt;/em&gt; 。 Apache还允许*将它们放入文档根目录下的 &lt;code&gt;.htaccess&lt;/code&gt; 文件中（即.php文件旁边）。</target>
        </trans-unit>
        <trans-unit id="06be8bc5c902a2c2133ad9c03a3c1779b99bf463" translate="yes" xml:space="preserve">
          <source>Providing discoverability through &lt;code&gt;/common/tree/nesting&lt;/code&gt;.</source>
          <target state="translated">通过 &lt;code&gt;/common/tree/nesting&lt;/code&gt; 提供可发现性。</target>
        </trans-unit>
        <trans-unit id="e64b81cf93d82d98226806bc2fc8bb197ca884ba" translate="yes" xml:space="preserve">
          <source>QUERY_STRING exempt from RewriteRules</source>
          <target state="translated">QUERY_STRING豁免于RewriteRules。</target>
        </trans-unit>
        <trans-unit id="4d404d57141e26e7d22d02e55784084ff540a4ad" translate="yes" xml:space="preserve">
          <source>Redirect subdomain to a folder</source>
          <target state="translated">将子域重定向到一个文件夹</target>
        </trans-unit>
        <trans-unit id="063e567c28ac61d9564af15349713acbb573d5e8" translate="yes" xml:space="preserve">
          <source>Redirect to &lt;code&gt;HTTPS://&lt;/code&gt;</source>
          <target state="translated">重定向到 &lt;code&gt;HTTPS://&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="722b8910bdb4f2c78164bcda5bd90f374a6c66ef" translate="yes" xml:space="preserve">
          <source>Reference: mod_rewrite, URL rewriting and “pretty links” explained</source>
          <target state="translated">参考:mod_rewrite,URL重写和 &quot;漂亮链接 &quot;的解释</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="b3a5d38cea5644b9e304ef62096e6a606a4a0fc6" translate="yes" xml:space="preserve">
          <source>Remove &lt;code&gt;www.&lt;/code&gt; from hostname</source>
          <target state="translated">删除 &lt;code&gt;www.&lt;/code&gt; 来自主机名</target>
        </trans-unit>
        <trans-unit id="8dc518c3281af6a76845d45893812e8170cd0c54" translate="yes" xml:space="preserve">
          <source>Rewrite Conditions</source>
          <target state="translated">重写条件</target>
        </trans-unit>
        <trans-unit id="0415eb50a540339c28aa38e25535d693e139d107" translate="yes" xml:space="preserve">
          <source>Rewrite Example</source>
          <target state="translated">重写示例</target>
        </trans-unit>
        <trans-unit id="87715289f6fd0761155779b729e2b1ef1f55f404" translate="yes" xml:space="preserve">
          <source>Rewrite from URL like &quot;/page&quot; to a script such as &quot;/index.php/page&quot;</source>
          <target state="translated">将 &quot;page &quot;这样的URL重写成 &quot;index.phppage &quot;这样的脚本</target>
        </trans-unit>
        <trans-unit id="54ae8a2bb1e1e0463d622aac404cc75b66ddf407" translate="yes" xml:space="preserve">
          <source>RewriteConds just mask one RewriteRule</source>
          <target state="translated">RewriteConds只是屏蔽一个RewriteRule</target>
        </trans-unit>
        <trans-unit id="243d3756aea59bb3aca4be6b1c289ef6f5eac31f" translate="yes" xml:space="preserve">
          <source>RewriteRules</source>
          <target state="translated">RewriteRules</target>
        </trans-unit>
        <trans-unit id="6f3c0b0fa9441f73d1225a5ad3aebf8aa68e29c8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://httpd.apache.org/docs/2.2/urlmapping.html&quot;&gt;http://httpd.apache.org/docs/2.2/urlmapping.html&lt;/a&gt; for further tips.</source>
          <target state="translated">有关更多提示，请参见&lt;a href=&quot;http://httpd.apache.org/docs/2.2/urlmapping.html&quot;&gt;http://httpd.apache.org/docs/2.2/urlmapping.html&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7734994bbf366e6199ab98306f2955556acb72dc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://serverfault.com/questions/214512/redirect-change-urls-or-redirect-http-to-https-in-apache-everything-you-ever&quot;&gt;Everything you ever wanted to know about mod_rewrite&lt;/a&gt;
if you haven't already. Combining multiple RewriteRules often leads to interaction. This isn't something to prevent habitually per &lt;code&gt;[L]&lt;/code&gt; flag, but a scheme you'll embrace once versed.
You &lt;strong&gt;can &lt;em&gt;re-re-re&lt;/em&gt;write&lt;/strong&gt; virtual paths from one rule to another, until it reaches an actual target handler.</source>
          <target state="translated">如果尚未，请参阅&lt;a href=&quot;https://serverfault.com/questions/214512/redirect-change-urls-or-redirect-http-to-https-in-apache-everything-you-ever&quot;&gt;有关mod_rewrite的所有内容&lt;/a&gt; 。 组合多个RewriteRules通常会导致交互。 这并不是每个 &lt;code&gt;[L]&lt;/code&gt; 标记都可以防止的习惯，而是您一旦熟悉就会采用的方案。 您&lt;strong&gt;可以&lt;em&gt;重新&lt;/em&gt;编写&lt;/strong&gt;从一条规则到另一条规则的虚拟路径，直到它到达实际的目标处理程序为止。</target>
        </trans-unit>
        <trans-unit id="769cf2ef46bdfff4b362894473e1b5713284e118" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/q/265898&quot;&gt;mod_rewrite, php and the .htaccess file&lt;/a&gt;</source>
          <target state="translated">参见&lt;a href=&quot;https://stackoverflow.com/q/265898&quot;&gt;mod_rewrite，php和.htaccess文件&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="22c8fcf96a97b6e5abcdae84c4db3db1d01058d9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/questions/2978907/how-can-i-get-my-htaccess-to-work-subdomains&quot;&gt;How can i get my htaccess to work (subdomains)?&lt;/a&gt;</source>
          <target state="translated">请参阅&lt;a href=&quot;https://stackoverflow.com/questions/2978907/how-can-i-get-my-htaccess-to-work-subdomains&quot;&gt;如何使htaccess正常工作（子域）？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="006a84e14e20a75e524061fa1fe8dba5660bdff1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://wiki.apache.org/httpd/RewriteLog&quot;&gt;Apache RewriteLog&lt;/a&gt; docs. For debugging you can enable it in the vhost sections:</source>
          <target state="translated">请参阅&lt;a href=&quot;https://wiki.apache.org/httpd/RewriteLog&quot;&gt;Apache RewriteLog&lt;/a&gt;文档。 要进行调试，您可以在vhost部分中启用它：</target>
        </trans-unit>
        <trans-unit id="9cd936e48a20e2da69c8f25159cd8cbee422363f" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/questions/2252238/how-can-i-match-query-string-variables-with-mod-rewrite&quot;&gt;How can I match query string variables with mod_rewrite?&lt;/a&gt;</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://stackoverflow.com/questions/2252238/how-can-i-match-query-string-variables-with-mod-rewrite&quot;&gt;如何将查询字符串变量与mod_rewrite匹配？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef15dc12c82e77842eafff393a8434759690e4c5" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://stackoverflow.com/questions/704102/how-does-rewritebase-work-in-htaccess&quot;&gt;How does RewriteBase work in .htaccess&lt;/a&gt;</source>
          <target state="translated">另请参见&lt;a href=&quot;https://stackoverflow.com/questions/704102/how-does-rewritebase-work-in-htaccess&quot;&gt;RewriteBase如何在.htaccess中工作&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">也见。</target>
        </trans-unit>
        <trans-unit id="8de810eb4c19512b1bcf1333a62369476c4d7c77" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;https://stackoverflow.com/questions/27744603/css-js-and-images-do-not-display-with-pretty-url&quot;&gt;CSS, JS and images do not display with pretty url&lt;/a&gt;</source>
          <target state="translated">另请参阅： &lt;a href=&quot;https://stackoverflow.com/questions/27744603/css-js-and-images-do-not-display-with-pretty-url&quot;&gt;CSS，JS和图像无法以漂亮的网址显示&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3db13cb00377ed34be5480543c7e55ed4f98496" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;https://stackoverflow.com/questions/3655893&quot;&gt;How do I transform my URL path segments into query string key-value pairs?&lt;/a&gt;</source>
          <target state="translated">另请参阅： &lt;a href=&quot;https://stackoverflow.com/questions/3655893&quot;&gt;如何将URL路径段转换为查询字符串键值对？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b77f4be08babffac9435d191760ac9736013dd5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;https://stackoverflow.com/questions/4908122/removing-the-php-extension-with-mod-rewrite&quot;&gt;Removing the .php extension with mod_rewrite&lt;/a&gt;</source>
          <target state="translated">另请参阅： &lt;a href=&quot;https://stackoverflow.com/questions/4908122/removing-the-php-extension-with-mod-rewrite&quot;&gt;使用mod_rewrite删除.php扩展名&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="566b13b8f401ee2428d3cd8f11f3c6fe104dc463" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;https://wiki.apache.org/httpd/RewriteHTTPToHTTPS&quot;&gt;https://wiki.apache.org/httpd/RewriteHTTPToHTTPS&lt;/a&gt;</source>
          <target state="translated">另请参阅： &lt;a href=&quot;https://wiki.apache.org/httpd/RewriteHTTPToHTTPS&quot;&gt;https&lt;/a&gt; : //wiki.apache.org/httpd/RewriteHTTPToHTTPS</target>
        </trans-unit>
        <trans-unit id="8f1913e2533a26bdd25c26d90fab7cc90bd95e2a" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;official documentation&lt;/a&gt; for all the possible flags and options.</source>
          <target state="translated">有关所有可能的标志和选项，请参见&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;官方文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fa04c4d408fbb4f618dc13714c5ebc1ab770915" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/remapping.html#backward-compatibility&quot;&gt;http://httpd.apache.org/docs/2.4/rewrite/remapping.html#backward-compatibility&lt;/a&gt;</source>
          <target state="translated">请参阅： &lt;a href=&quot;http://httpd.apache.org/docs/2.4/rewrite/remapping.html#backward-compatibility&quot;&gt;http&lt;/a&gt; : //httpd.apache.org/docs/2.4/rewrite/remapping.html#backward-compatibility</target>
        </trans-unit>
        <trans-unit id="99e6a073ff5e6c011154a5c38d8a47d031eb6740" translate="yes" xml:space="preserve">
          <source>Serverfault: &lt;strong&gt;Everything you ever wanted to know about mod_rewrite&lt;/strong&gt;</source>
          <target state="translated">Serverfault： &lt;strong&gt;您想了解的有关mod_rewrite的所有信息&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="153142254f89758d473a9ea12c5e164444dc53cf" translate="yes" xml:space="preserve">
          <source>SetType or SetHandler for extensionless &lt;code&gt;.php&lt;/code&gt; scripts</source>
          <target state="translated">用于无扩展名 &lt;code&gt;.php&lt;/code&gt; 脚本的SetType或SetHandler</target>
        </trans-unit>
        <trans-unit id="5a864b80ff234f7cae642c6501bfd4c017e44fd0" translate="yes" xml:space="preserve">
          <source>Shortening a few page names to internal file schemes is most simple:</source>
          <target state="translated">将几个页面名称缩短为内部文件方案是最简单的。</target>
        </trans-unit>
        <trans-unit id="0b832bc70477bdef81bfff11de849565e3c94623" translate="yes" xml:space="preserve">
          <source>Since Apache 2.4 you can also use the &lt;code&gt;[END]&lt;/code&gt; flag. A matching rule with it will &lt;em&gt;completely&lt;/em&gt; terminate further alias/rewrite processing. (Whereas the &lt;code&gt;[L]&lt;/code&gt; flag can oftentimes trigger a second round, for example when rewriting into or out of subdirectories.)</source>
          <target state="translated">从Apache 2.4开始，您还可以使用 &lt;code&gt;[END]&lt;/code&gt; 标志。 与之匹配的规则将&lt;em&gt;完全&lt;/em&gt;终止进一步的别名/重写处理。 （而 &lt;code&gt;[L]&lt;/code&gt; 标志通常可以触发第二轮，例如在重写子目录或从子目录中重写时。）</target>
        </trans-unit>
        <trans-unit id="0b205cd34e49d99ca6bc4b7cfdc75f4c82118ad9" translate="yes" xml:space="preserve">
          <source>Slug-style placeholders</source>
          <target state="translated">软木塞式的占位符</target>
        </trans-unit>
        <trans-unit id="0126c12f6cbf075a76cababf0457921f8420def3" translate="yes" xml:space="preserve">
          <source>Slugs with numeric prefixes</source>
          <target state="translated">带数字前缀的蛞蝓</target>
        </trans-unit>
        <trans-unit id="ecebb061edd3e7bf58aa5e1134401163d6e5ea2c" translate="yes" xml:space="preserve">
          <source>So at some point you're rewriting your HTML pages to carry only pretty links, as &lt;a href=&quot;https://stackoverflow.com/a/20563773#~What+mod_rewrite+does+not+do&quot;&gt;outlined by deceze&lt;/a&gt;.
Meanwhile you'll still receive requests for the &lt;em&gt;old&lt;/em&gt; paths, sometimes even from bookmarks. As &lt;em&gt;workaround&lt;/em&gt;, you can ping-pong browsers to display/establish
the new URLs.</source>
          <target state="translated">因此，在某些时候，您正在重写HTML页面，以仅包含漂亮的链接（如&lt;a href=&quot;https://stackoverflow.com/a/20563773#~What+mod_rewrite+does+not+do&quot;&gt;deceze概述）&lt;/a&gt; 。 同时，您仍然会收到&lt;em&gt;旧&lt;/em&gt;路径的请求，有时甚至来自书签。 &lt;em&gt;解决方法是&lt;/em&gt; ，您可以对浏览器进行乒乓球显示/建立新的URL。</target>
        </trans-unit>
        <trans-unit id="9b584b52b28402594628cea231d8d1cd0eb03d50" translate="yes" xml:space="preserve">
          <source>Spaces</source>
          <target state="translated">Spaces</target>
        </trans-unit>
        <trans-unit id="85e989878c716e36b051efddbe0395a8c643d71a" translate="yes" xml:space="preserve">
          <source>Stack Overflow has &lt;em&gt;many&lt;/em&gt; other great resources to get started:</source>
          <target state="translated">堆栈溢出还有&lt;em&gt;许多&lt;/em&gt;其他入门资源：</target>
        </trans-unit>
        <trans-unit id="48fc570e8e866f7f574a291b7bacd57b75c6ab5b" translate="yes" xml:space="preserve">
          <source>Static mapping</source>
          <target state="translated">静态映射</target>
        </trans-unit>
        <trans-unit id="8001a2b0ee6473dba8f8f19c9bcf26b8ca6205c1" translate="yes" xml:space="preserve">
          <source>Still you'd &lt;em&gt;often&lt;/em&gt; want to have the most specific rules (fixed string &lt;code&gt;/forum/&amp;hellip;&lt;/code&gt; patterns, or more restrictive placeholders &lt;code&gt;[^/.]+&lt;/code&gt;) in the &lt;em&gt;early&lt;/em&gt; rules.
Generic slurp-all rules (&lt;code&gt;.*&lt;/code&gt;) are better left to the &lt;em&gt;later&lt;/em&gt; ones. (An exception is a &lt;code&gt;RewriteCond -f/-d&lt;/code&gt; guard as primary block.)</source>
          <target state="translated">仍然需要在&lt;em&gt;早期&lt;/em&gt;规则中使用最具体的规则（固定的字符串 &lt;code&gt;/forum/&amp;hellip;&lt;/code&gt; 模式，或更严格的占位符 &lt;code&gt;[^/.]+&lt;/code&gt; ）。 通用的所有规则（ &lt;code&gt;.*&lt;/code&gt; ）最好留给&lt;em&gt;后面&lt;/em&gt;的规则。 （一个例外是 &lt;code&gt;RewriteCond -f/-d&lt;/code&gt; 保护作为主要块。）</target>
        </trans-unit>
        <trans-unit id="e88877188929b587a6202b5d626e2de4ef74c025" translate="yes" xml:space="preserve">
          <source>Stylesheets and images stop working</source>
          <target state="translated">樣式表和圖像停止工作</target>
        </trans-unit>
        <trans-unit id="1a378406d18f6750149ae24909a93a9ccb6fc19e" translate="yes" xml:space="preserve">
          <source>That yields a detailed summary of how incoming request paths get modified by each rule:</source>
          <target state="translated">这就得出了每个规则如何修改传入的请求路径的详细摘要。</target>
        </trans-unit>
        <trans-unit id="6d6fab96ebe243a8ed7f16439ab504edd8a35174" translate="yes" xml:space="preserve">
          <source>The above rewrite would allow you to link to something like &lt;code&gt;/blog/1/foo/&lt;/code&gt; and it would actually load &lt;code&gt;/blog/index.php?id=1&amp;amp;title=foo&lt;/code&gt;.</source>
          <target state="translated">上面的重写将允许您链接到 &lt;code&gt;/blog/1/foo/&lt;/code&gt; ，它实际上将加载 &lt;code&gt;/blog/index.php?id=1&amp;amp;title=foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ba4a51130ff56537f6d3a9055715230bfef9e5f" translate="yes" xml:space="preserve">
          <source>The complete RewriteRule set, but &lt;em&gt;also&lt;/em&gt; single out the presumed defective one.</source>
          <target state="translated">完整的RewriteRule集，但&lt;em&gt;也&lt;/em&gt;可以选择假定的缺陷集。</target>
        </trans-unit>
        <trans-unit id="e228ac5b8f8d575c20a15333bcfad05518e80ac0" translate="yes" xml:space="preserve">
          <source>The default configuration of most web servers is to look for a file that matches the URL on the hard disk. If the &lt;em&gt;document root&lt;/em&gt; of the server is set to, say, &lt;code&gt;/var/www&lt;/code&gt;, it may look whether the file &lt;code&gt;/var/www/foo/bar.html&lt;/code&gt; exists and serve it if so. If the file ends in &quot;.php&quot; it will invoke the PHP interpreter and &lt;em&gt;then&lt;/em&gt; return the result. All this association is completely configurable; a file doesn't have to end in &quot;.php&quot; for the web server to run it through the PHP interpreter, and the URL doesn't have to match any particular file on disk for something to happen.</source>
          <target state="translated">大多数Web服务器的默认配置是在硬盘上查找与URL匹配的文件。 如果服务器的&lt;em&gt;文档根目录&lt;/em&gt;设置为 &lt;code&gt;/var/www&lt;/code&gt; ，则可能会查看文件 &lt;code&gt;/var/www/foo/bar.html&lt;/code&gt; 是否存在并提供文件。 如果文件以&amp;ldquo; .php&amp;rdquo;结尾，它将调用PHP解释器， &lt;em&gt;然后&lt;/em&gt;返回结果。 所有这些关联都是完全可配置的。 文件不必以&amp;ldquo; .php&amp;rdquo;结尾，Web服务器就可以通过PHP解释器运行该文件，并且URL不必与磁盘上的任何特定文件匹配就可以进行操作。</target>
        </trans-unit>
        <trans-unit id="46df60a282712a506bc72414500b3830c3f7622b" translate="yes" xml:space="preserve">
          <source>The first set of brackets - &lt;code&gt;([0-9]+)&lt;/code&gt; - matches a string with a minimum of 1 character in length and with only numeric values (i.e. 0-9). This can be referenced with &lt;code&gt;$1&lt;/code&gt; in the right hand side of the rule</source>
          <target state="translated">第一组方括号- &lt;code&gt;([0-9]+)&lt;/code&gt; -匹配长度至少为1个字符且仅包含数字值（即0-9）的字符串。 可以在规则的右侧用 &lt;code&gt;$1&lt;/code&gt; 进行引用</target>
        </trans-unit>
        <trans-unit id="7ac23b9ac3e8ebb020e1a5fab826fbe6cccd47f8" translate="yes" xml:space="preserve">
          <source>The following examples are PHP-centric and a bit more incremental, easier to adapt for similar cases.
They're just summaries, often link to more variations or detailed Q&amp;amp;As.</source>
          <target state="translated">以下示例以PHP为中心，并且增量更多，更易于适应类似情况。 它们只是摘要，通常链接到更多变体或详细的问答。</target>
        </trans-unit>
        <trans-unit id="a54a48205d3f14912b7eeff2751a1df039b641ef" translate="yes" xml:space="preserve">
          <source>The last flag indicates that this is the last rule that should be processed. This means that if and only if this rule matches, no further rules will be evaluated in the current rewrite processing run. If the rule does not match, all other rules will be tried in order as usual. If you do not set the &lt;code&gt;L&lt;/code&gt; flag, all following rules will be applied to the &lt;em&gt;rewritten&lt;/em&gt; URL afterwards.</source>
          <target state="translated">最后一个标志指示这是应该处理的最后一条规则。 这意味着，当且仅当此规则匹配时，在当前重写处理运行中不会再评估其他规则。 如果该规则不匹配，则将照常尝试所有其他规则。 如果您未设置 &lt;code&gt;L&lt;/code&gt; 标志，则随后的所有以下规则将应用于&lt;em&gt;重写的&lt;/em&gt; URL。</target>
        </trans-unit>
        <trans-unit id="e2dcea71d18770c2097f41c39eae9392bca0c8a4" translate="yes" xml:space="preserve">
          <source>The leading slash &lt;code&gt;^/&lt;/code&gt; won't match</source>
          <target state="translated">前导斜杠 &lt;code&gt;^/&lt;/code&gt; 不匹配</target>
        </trans-unit>
        <trans-unit id="549c3e4d9d2e3d169f232931ea8636c3d1480369" translate="yes" xml:space="preserve">
          <source>The no case flag means that the rewrite rule is case insensitive, so for the example rule above this would mean that both &lt;code&gt;/blog/1/foo/&lt;/code&gt; and &lt;code&gt;/BLOG/1/foo/&lt;/code&gt; (or any variation of this) would be matched.</source>
          <target state="translated">no case标志表示重写规则不区分大小写，因此对于上面的示例规则，这将意味着 &lt;code&gt;/blog/1/foo/&lt;/code&gt; 和 &lt;code&gt;/BLOG/1/foo/&lt;/code&gt; （或其任何变体）都将匹配。</target>
        </trans-unit>
        <trans-unit id="83c803d5174f2e1e70b82894f7bc34cb1d99cf98" translate="yes" xml:space="preserve">
          <source>The query string append flag allows us to pass in extra variables to the specified URL which will get added to the original get parameters. For our example this means that something like &lt;code&gt;/blog/1/foo/?comments=15&lt;/code&gt; would load &lt;code&gt;/blog/index.php?id=1&amp;amp;title=foo&amp;amp;comments=15&lt;/code&gt;</source>
          <target state="translated">查询字符串附加标志允许我们将额外的变量传递到指定的URL，该URL将被添加到原始的get参数中。 对于我们的示例，这意味着 &lt;code&gt;/blog/1/foo/?comments=15&lt;/code&gt; 会加载 &lt;code&gt;/blog/index.php?id=1&amp;amp;title=foo&amp;amp;comments=15&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a75416b595fbf14696df582ef4381352dbaaade" translate="yes" xml:space="preserve">
          <source>The rewrite will attempt to load the same file on another domain</source>
          <target state="translated">重写将尝试在另一个域中加载相同的文件。</target>
        </trans-unit>
        <trans-unit id="833afbd5f1f23c47a97009c28e05f47b2667d6ea" translate="yes" xml:space="preserve">
          <source>The rule is split into 4 sections:</source>
          <target state="translated">该规则分为4个部分。</target>
        </trans-unit>
        <trans-unit id="7aebe4dbf5a75928bd1986451a2093d287864dbd" translate="yes" xml:space="preserve">
          <source>The second set of parentheses matches a string with a minimum of 1 character in length, containing only alphanumeric characters (A-Z, a-z, or 0-9) or &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; (note &lt;code&gt;+&lt;/code&gt; is escaped with a backslash as without escaping it this will execute as a &lt;a href=&quot;http://www.regular-expressions.info/repeat.html&quot;&gt;regex repetition character&lt;/a&gt;). This can be referenced with &lt;code&gt;$2&lt;/code&gt; in the right hand side of the rule</source>
          <target state="translated">第二组括号匹配一个长度至少为1个字符的字符串，该字符串仅包含字母数字字符（AZ，az或0-9）或 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; （请注意 &lt;code&gt;+&lt;/code&gt; 以反斜杠转义，因为会转义而不会转义）作为&lt;a href=&quot;http://www.regular-expressions.info/repeat.html&quot;&gt;正则表达式的重复字符&lt;/a&gt; ）。 可以在规则的右侧用 &lt;code&gt;$2&lt;/code&gt; 进行引用</target>
        </trans-unit>
        <trans-unit id="04c8e0a990ad304eb54df5972cfebfc98f757529" translate="yes" xml:space="preserve">
          <source>The simplest option to also eschew &lt;code&gt;.php&lt;/code&gt; &quot;file extensions&quot; in URLs is enabling:</source>
          <target state="translated">在网址中也避开 &lt;code&gt;.php&lt;/code&gt; &amp;ldquo;文件扩展名&amp;rdquo;的最简单选择是启用：</target>
        </trans-unit>
        <trans-unit id="0e2f7a407bd6041b3f1f32b83f940cec25221f9b" translate="yes" xml:space="preserve">
          <source>The web server is an application listening on a port, accepting HTTP requests coming in on that port and returning a response. A web server is entirely free to respond to any request in any way it sees fit/in any way you have configured it to respond. This response is not a file, it's an &lt;em&gt;HTTP response&lt;/em&gt; which may or may not have anything to do with physical files on any disk. A web server doesn't have to be Apache, there are many other web servers which are all just programs which run persistently and are attached to a port which respond to HTTP requests. You can write one yourself. This paragraph was intended to divorce you from any notion that URLs directly equal files, which is really important to understand. :)</source>
          <target state="translated">Web服务器是在端口上侦听的应用程序，它接受来自该端口的HTTP请求并返回响应。 Web服务器完全可以自由选择以其认为合适的方式/以您配置为响应的任何方式来响应任何请求。 此响应不是文件，它是&lt;em&gt;HTTP响应&lt;/em&gt; ，它与任何磁盘上的物理文件可能有关系也可能没有关系。 Web服务器不必是Apache，还有许多其他Web服务器都只是永久运行的程序，并附加到响应HTTP请求的端口上。 您可以自己写一个。 本段旨在使您脱离URL直接等于文件的任何观念，这一点很重要。 :)</target>
        </trans-unit>
        <trans-unit id="159c459f715b62a82d49181a2596095e72ac845a" translate="yes" xml:space="preserve">
          <source>There are various online tools to generate RewriteRules for most GET-parameterish URLs:</source>
          <target state="translated">有各种在线工具可以为大多数GET-参数型URL生成RewriteRules。</target>
        </trans-unit>
        <trans-unit id="c82a2f0ef8ac4ecf1da9d191346d5140c761cc14" translate="yes" xml:space="preserve">
          <source>There's a lot mod_rewrite can do and very complex matching rules you can create, including chaining several rewrites, proxying requests to a completely different service or machine, returning specific HTTP status codes as responses, redirecting requests etc. It's very powerful and can be used to great good if you understand the fundamental HTTP request-response mechanism. It does &lt;em&gt;not&lt;/em&gt; automatically make your links pretty.</source>
          <target state="translated">mod_rewrite可以做很多事情，您可以创建非常复杂的匹配规则，包括链接多个重写，将请求代理到完全不同的服务或机器，返回特定的HTTP状态代码作为响应，重定向请求等。它非常强大，可用于如果您了解基本的HTTP请求-响应机制，那就太好了。 它不会自动使您的链接漂亮。</target>
        </trans-unit>
        <trans-unit id="c9ba3f02e7e2d45a3c1fdc93f62d6055d0ba77ad" translate="yes" xml:space="preserve">
          <source>Therefore you'll often see mixed &lt;code&gt;/article/529-title-slug&lt;/code&gt; paths used in practice:</source>
          <target state="translated">因此，您经常会在实践中看到混合使用 &lt;code&gt;/article/529-title-slug&lt;/code&gt; 路径：</target>
        </trans-unit>
        <trans-unit id="cb15bb19b67a700556e5d4e90ad59605ca293dde" translate="yes" xml:space="preserve">
          <source>These are options that are added in square brackets at the end of your rewrite rule to specify certain conditions. Again, there are a lot of different flags which you can read up on in &lt;a href=&quot;http://httpd.apache.org/docs/2.2/rewrite/flags.html&quot;&gt;the documentation&lt;/a&gt;, but I'll go through some of the more common flags:</source>
          <target state="translated">这些选项在重写规则的末尾添加在方括号中，以指定某些条件。 同样，您可以在&lt;a href=&quot;http://httpd.apache.org/docs/2.2/rewrite/flags.html&quot;&gt;文档中&lt;/a&gt;阅读很多不同的标志，但是我将介绍一些更常见的标志：</target>
        </trans-unit>
        <trans-unit id="7cb52ffb24a80ad734695950723670b446fd208a" translate="yes" xml:space="preserve">
          <source>This common trick involves sending a 30x/Location &lt;em&gt;redirect&lt;/em&gt; whenever an incoming URL follows the obsolete/ugly naming scheme.
Browsers will then &lt;em&gt;rerequest&lt;/em&gt; the new/pretty URL, which afterwards is rewritten (just internally) to the original or new location.</source>
          <target state="translated">这个常见技巧是，只要传入URL遵循过时/难看的命名方案，就发送30x / Location &lt;em&gt;重定向&lt;/em&gt; 。 然后，浏览器将重新&lt;em&gt;请求&lt;/em&gt;新的/漂亮的URL，然后将其（仅在内部）重写为原始或新的位置。</target>
        </trans-unit>
        <trans-unit id="eac456246f01a69b6fa960c525f4d3493e5955b6" translate="yes" xml:space="preserve">
          <source>This doesn't tell you which RewriteRule is the culprit. But inaccessible final paths like &lt;code&gt;/docroot/21-.itle?index.php&lt;/code&gt; may give away where to inspect further.
Otherwise disable rules until you get some predictable paths.</source>
          <target state="translated">这并不能告诉您是哪个RewriteRule是罪魁祸首。 但是 &lt;code&gt;/docroot/21-.itle?index.php&lt;/code&gt; 之类无法访问的最终路径可能会放弃进一步检查的位置。 否则，请禁用规则，直到获得一些可预测的路径。</target>
        </trans-unit>
        <trans-unit id="126b9d7dfbd968a54edaca8a4d158902a1949796" translate="yes" xml:space="preserve">
          <source>This flag isn't one I used in the example above, but is one I thought is worth mentioning. This allows you to specify a http redirect, with the option to include a status code (e.g. &lt;code&gt;R=301&lt;/code&gt;). For example if you wanted to do a 301 redirect on /myblog/ to /blog/ you would simply write a rule something like this:</source>
          <target state="translated">这个标志不是我在上面的示例中使用的一个标志，但是我认为值得一提。 这使您可以指定http重定向，并可以选择包括状态码（例如 &lt;code&gt;R=301&lt;/code&gt; ）。 例如，如果您想在/ myblog /上执行301重定向到/ blog /，则只需编写如下规则：</target>
        </trans-unit>
        <trans-unit id="37b731c00b0df987bf9c1b533cd5f5cce0e31a8d" translate="yes" xml:space="preserve">
          <source>This has Apache select &lt;code&gt;article.php&lt;/code&gt; for HTTP requests on &lt;code&gt;/article&lt;/code&gt; due to the matching basename. And this works well together with the aforementioned PATH_INFO feature. So you can just use URLs like &lt;code&gt;http://example.com/article/virtual/title&lt;/code&gt;. Which makes sense if you have a traditional web application with multiple PHP invocation points/scripts.</source>
          <target state="translated">由于匹配的基本名称，因此在 &lt;code&gt;/article&lt;/code&gt; 上有Apache select &lt;code&gt;article.php&lt;/code&gt; 用于HTTP请求。 并与前面提到的PATH_INFO功能一起很好地工作。 因此，您可以只使用 &lt;code&gt;http://example.com/article/virtual/title&lt;/code&gt; 之类的 URL。 如果您有一个具有多个PHP调用点/脚本的传统Web应用程序，则这很有意义。</target>
        </trans-unit>
        <trans-unit id="7821c92c23729c6e3b5d689391cb1070c9721c06" translate="yes" xml:space="preserve">
          <source>This is a very common practice, which will prepend your domain with &lt;code&gt;www.&lt;/code&gt; (if it isn't there already) and execute a 301 redirect. For example, loading up &lt;code&gt;http://example.com/blog/&lt;/code&gt; it would redirect you to &lt;code&gt;http://www.example.com/blog/&lt;/code&gt;</source>
          <target state="translated">这是一种非常普遍的做法，它将在您的域名之前加上 &lt;code&gt;www.&lt;/code&gt; （如果尚不存在）并执行301重定向。 例如，加载 &lt;code&gt;http://example.com/blog/&lt;/code&gt; 会将其重定向到 &lt;code&gt;http://www.example.com/blog/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d80c4ef1a166355292a1990b7a7af44ad9122e8" translate="yes" xml:space="preserve">
          <source>This is just as valid a request for a URL, and it has more obviously nothing to do with files.</source>
          <target state="translated">这和URL的请求一样有效,而且更明显的是与文件无关。</target>
        </trans-unit>
        <trans-unit id="c69886ec55e1ba20b0fa5f101a1225eaf0019fd1" translate="yes" xml:space="preserve">
          <source>This is often seen in old tutorials. And it used to be correct for ancient Apache 1.x versions. Nowadays request paths are conveniently &lt;em&gt;fully &lt;strong&gt;directory-relative&lt;/strong&gt;&lt;/em&gt; in &lt;code&gt;.htaccess&lt;/code&gt; RewriteRules. Just leave the leading &lt;code&gt;/&lt;/code&gt; out.</source>
          <target state="translated">这在旧教程中很常见。 而且它过去对于古老的Apache 1.x版本是正确的。 如今，请求路径在 &lt;code&gt;.htaccess&lt;/code&gt; RewriteRules中很方便是&lt;em&gt;完全&lt;strong&gt;相对于目录的&lt;/strong&gt;&lt;/em&gt; 。 只是离开领先 &lt;code&gt;/&lt;/code&gt; 退出。</target>
        </trans-unit>
        <trans-unit id="52a895915ec9566af7e25dd82c968182fc5c0f3e" translate="yes" xml:space="preserve">
          <source>This is slightly less common, but is a good example of a rule that doesn't execute if the filename is a directory or file that exists on the server.</source>
          <target state="translated">这种情况稍显少见,但也是一个很好的例子,如果文件名是服务器上存在的目录或文件,则不执行该规则。</target>
        </trans-unit>
        <trans-unit id="77620a284d982bf7c67daa1601fbd5c8de86c151" translate="yes" xml:space="preserve">
          <source>This is somewhat dependent on your server setup and the used PHP SAPI. Common alternatives include &lt;code&gt;ForceType application/x-httpd-php&lt;/code&gt; or &lt;code&gt;AddHandler php5-script&lt;/code&gt;.</source>
          <target state="translated">这在某种程度上取决于您的服务器设置和使用的PHP SAPI。 常见的替代方法包括 &lt;code&gt;ForceType application/x-httpd-php&lt;/code&gt; 或 &lt;code&gt;AddHandler php5-script&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e43a1df57f3dcef1bda106987332480923a8e7b2" translate="yes" xml:space="preserve">
          <source>This is the simple request of a browser to a web server requesting the &lt;em&gt;URL&lt;/em&gt;&lt;code&gt;/foo/bar.html&lt;/code&gt; from it. It is important to stress that it does not request a &lt;em&gt;file&lt;/em&gt;, it requests just some arbitrary URL. The request may also look like this:</source>
          <target state="translated">这是浏览器对Web服务器的简单请求，从中请求&lt;em&gt;URL&lt;/em&gt; &lt;code&gt;/foo/bar.html&lt;/code&gt; 。 需要强调的是，它不请求&lt;em&gt;文件&lt;/em&gt; ，它仅请求某个任意URL。 该请求也可能如下所示：</target>
        </trans-unit>
        <trans-unit id="01e466565580b17decbd9ff474a0fe27c298e507" translate="yes" xml:space="preserve">
          <source>This isn't as convenient as having Apache separate input path segments into &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt; and passing them as distinct &lt;code&gt;$_GET&lt;/code&gt; variables to PHP. It's merely emulating &quot;pretty URLs&quot; with less configuration effort.</source>
          <target state="translated">这不像让Apache将输入路径段分成 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; 并将它们作为不同的 &lt;code&gt;$_GET&lt;/code&gt; 变量传递给PHP那样方便。 它只是以较少的配置工作来模拟&amp;ldquo;漂亮的URL&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="678cdd0d663cc49ab66acef486598ae2d96c6601" translate="yes" xml:space="preserve">
          <source>This nets quicker and more exact answers, and makes them more useful to others.</source>
          <target state="translated">这种网罗更快、更准确的答案,使其对别人更有用。</target>
        </trans-unit>
        <trans-unit id="f16dfc9b713dca91d180a83ddd93a12f0f5f49f9" translate="yes" xml:space="preserve">
          <source>This optionalized any &lt;code&gt;/&amp;hellip;/&amp;hellip;/&amp;hellip;&lt;/code&gt; trailing path segments. Which then of course requires the handling script to split them up, and &lt;em&gt;variabl-ify&lt;/em&gt; extracted parameters
itself (which is what &lt;em&gt;Web-&quot;MVC&quot;&lt;/em&gt; frameworks do).</source>
          <target state="translated">这是可选的任何 &lt;code&gt;/&amp;hellip;/&amp;hellip;/&amp;hellip;&lt;/code&gt; 尾随路径段。 然后，这当然需要处理脚本将其拆分，并可变化提取的参数本身（这是&lt;em&gt;Web&amp;ldquo; MVC&amp;rdquo;&lt;/em&gt;框架的作用）。</target>
        </trans-unit>
        <trans-unit id="4f0a25ea5b6c1efa50d189b93b865b7cd7502f46" translate="yes" xml:space="preserve">
          <source>This rule matches anything (&lt;code&gt;.*&lt;/code&gt;) and &lt;em&gt;captures&lt;/em&gt; it (&lt;code&gt;(..)&lt;/code&gt;), then rewrites it to append &quot;.html&quot;. In other words, if &lt;code&gt;/foo/bar&lt;/code&gt; was the requested URL, it will be handled as if &lt;code&gt;/foo/bar.html&lt;/code&gt; had been requested. See &lt;a href=&quot;http://regular-expressions.info&quot;&gt;http://regular-expressions.info&lt;/a&gt; for more information about regular expression matching, capturing and replacements.</source>
          <target state="translated">此规则匹配任何内容（ &lt;code&gt;.*&lt;/code&gt; ）并&lt;em&gt;捕获&lt;/em&gt;它（ &lt;code&gt;(..)&lt;/code&gt; ），然后将其重写以附加&amp;ldquo; .html&amp;rdquo;。 换句话说，如果 &lt;code&gt;/foo/bar&lt;/code&gt; 是请求的URL，则将如同请求 &lt;code&gt;/foo/bar.html&lt;/code&gt; 一样进行处理。 有关正则表达式匹配，捕获和替换的更多信息，请参见&lt;a href=&quot;http://regular-expressions.info&quot;&gt;http://regular-expressions.info&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b2ea9bc6efb3aff08b2c67c59e0c49c40b9a8b9" translate="yes" xml:space="preserve">
          <source>This rule says &lt;em&gt;whenever a request matches &quot;/foo/bar&quot;, rewrite it to &quot;/foo/baz&quot;.&lt;/em&gt; The request will then be handled as if &lt;code&gt;/foo/baz&lt;/code&gt; had been requested instead. This can be used for various effects, for example:</source>
          <target state="translated">该规则表示， &lt;em&gt;每当请求匹配&amp;ldquo; / foo / bar&amp;rdquo;时，都将其重写为&amp;ldquo; / foo / baz&amp;rdquo;。&lt;/em&gt; 然后将处理该请求，就好像已请求了 &lt;code&gt;/foo/baz&lt;/code&gt; 一样。 这可以用于各种效果，例如：</target>
        </trans-unit>
        <trans-unit id="f6e5c51f6d07a6fda3f35853c7cbc032504a01a3" translate="yes" xml:space="preserve">
          <source>This simply remaps 2009-2011 posts onto one script, and all other years implicitly to another handler.
Note the &lt;em&gt;more specific rule coming first&lt;/em&gt;. Each script might use different GET params.</source>
          <target state="translated">这只是将2009-2011年的帖子重新映射到一个脚本上，而其他所有年份则隐式地映射到另一个处理程序上。 请注意， &lt;em&gt;更具体的规则排在第一位&lt;/em&gt; 。 每个脚本可能使用不同的GET参数。</target>
        </trans-unit>
        <trans-unit id="a1c37412960d01550e537eeede8eb49d03ce4cc9" translate="yes" xml:space="preserve">
          <source>This way you could just rename your &lt;code&gt;article.php&lt;/code&gt; script to just &lt;code&gt;article&lt;/code&gt; (without extension), but still have it processed as PHP script.</source>
          <target state="translated">这样，您可以将 &lt;code&gt;article.php&lt;/code&gt; 脚本重命名为仅 &lt;code&gt;article&lt;/code&gt; （不带扩展名），但仍将其作为PHP脚本进行处理。</target>
        </trans-unit>
        <trans-unit id="211b69704ff35b0a39c4be33762622ae6379f372" translate="yes" xml:space="preserve">
          <source>This, again, matches anything and rewrites it to the file index.php with the originally requested URL appended in the &lt;code&gt;url&lt;/code&gt; query parameter. I.e., for any and all requests coming in, the file index.php is executed and this file will have access to the original request in &lt;code&gt;$_GET['url']&lt;/code&gt;, so it can do anything it wants with it.</source>
          <target state="translated">再次匹配任何内容，并将其重写为文件index.php，并在 &lt;code&gt;url&lt;/code&gt; 查询参数中附加最初请求的URL。 也就是说，对于所有传入的所有请求，都将执行文件index.php，并且该文件将有权访问 &lt;code&gt;$_GET['url']&lt;/code&gt; 的原始请求，因此它可以执行任何所需的操作。</target>
        </trans-unit>
        <trans-unit id="a8c5fe091e3cffc8b0c5e5c2b1598310dff0e558" translate="yes" xml:space="preserve">
          <source>To actually use RewriteRules in per-directory configuration files you must:</source>
          <target state="translated">要在每个目录配置文件中实际使用RewriteRules,你必须。</target>
        </trans-unit>
        <trans-unit id="302e8c9231b475103b1b38d200a19d9417800479" translate="yes" xml:space="preserve">
          <source>To expand on &lt;a href=&quot;https://stackoverflow.com/a/20563773/1011145&quot;&gt;deceze's answer&lt;/a&gt;, I wanted to provide a few examples and explanation of some other mod_rewrite functionality.</source>
          <target state="translated">为了扩展&lt;a href=&quot;https://stackoverflow.com/a/20563773/1011145&quot;&gt;deceze的答案&lt;/a&gt; ，我想提供一些示例和一些其他mod_rewrite功能的解释。</target>
        </trans-unit>
        <trans-unit id="e0bb75b10308d21179997cfdc7b880808864c79a" translate="yes" xml:space="preserve">
          <source>To understand what mod_rewrite does you first need to understand how a web server works. A web server responds to &lt;a href=&quot;http://en.wikipedia.org/wiki/Http&quot;&gt;&lt;em&gt;HTTP requests&lt;/em&gt;&lt;/a&gt;. An HTTP request at its most basic level looks like this:</source>
          <target state="translated">要了解什么是mod_rewrite，首先需要了解Web服务器的工作方式。 Web服务器响应&lt;a href=&quot;http://en.wikipedia.org/wiki/Http&quot;&gt;&lt;em&gt;HTTP请求&lt;/em&gt;&lt;/a&gt; 。 最基本的HTTP请求如下所示：</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="58245d2ae3eef010b5b66c0f91d98d0ced9ae5a7" translate="yes" xml:space="preserve">
          <source>Trailing file &quot;extensions&quot;</source>
          <target state="translated">拖尾文件 &quot;扩展&quot;</target>
        </trans-unit>
        <trans-unit id="42c250d9422aa8b9548f27e829e74fff8a6655de" translate="yes" xml:space="preserve">
          <source>URL rewriting is primarily used for supporting &lt;em&gt;virtual&lt;/em&gt; incoming paths. Commonly you just have one dispatcher script (&lt;code&gt;index.php&lt;/code&gt;) or a few individual handlers (&lt;code&gt;articles.php&lt;/code&gt;, &lt;code&gt;blog.php&lt;/code&gt;, &lt;code&gt;wiki.php&lt;/code&gt;, &amp;hellip;). The latter &lt;a href=&quot;https://stackoverflow.com/a/1298917&quot;&gt;might clash&lt;/a&gt; with similar virtual RewriteRule paths.</source>
          <target state="translated">URL重写主要用于支持&lt;em&gt;虚拟&lt;/em&gt;传入路径。 通常，您只有一个调度程序脚本（ &lt;code&gt;index.php&lt;/code&gt; ）或几个单独的处理程序（ &lt;code&gt;articles.php&lt;/code&gt; ， &lt;code&gt;blog.php&lt;/code&gt; ， &lt;code&gt;wiki.php&lt;/code&gt; &amp;hellip;）。 后者&lt;a href=&quot;https://stackoverflow.com/a/1298917&quot;&gt;可能&lt;/a&gt;与类似的虚拟RewriteRule路径发生冲突 。</target>
        </trans-unit>
        <trans-unit id="936c1eadd423e11d0419edc5c0a50907603bcf5b" translate="yes" xml:space="preserve">
          <source>URLs don't really have file extensions. Which is what this entire reference is about (= URLs are virtual locators, not necessarily a direct filesystem image).
However if you had a 1:1 file mapping before, you &lt;em&gt;can&lt;/em&gt; craft simpler rules:</source>
          <target state="translated">网址实际上没有文件扩展名。 整个引用所针对的是（URL是虚拟定位符，不一定是直接文件系统映像）。 但是，如果以前有1：1的文件映射，则&lt;em&gt;可以&lt;/em&gt;制定更简单的规则：</target>
        </trans-unit>
        <trans-unit id="748dcaf65cc260bb40913050765500212f87a4c3" translate="yes" xml:space="preserve">
          <source>Uniformity with alternative lists</source>
          <target state="translated">备选名单的统一性</target>
        </trans-unit>
        <trans-unit id="171f5f83a5e1cc88faf76682f9ab5dec103babb8" translate="yes" xml:space="preserve">
          <source>Use mod_rewrite on the server to handle the request to the URL &lt;code&gt;/my/pretty/link&lt;/code&gt; using any one of the methods described above.</source>
          <target state="translated">使用上述任何一种方法，在服务器上使用mod_rewrite处理对URL &lt;code&gt;/my/pretty/link&lt;/code&gt; 的请求。</target>
        </trans-unit>
        <trans-unit id="314b923c11804470bedda27a5e010368e52f966a" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://stackoverflow.com/questions/2261951/what-exactly-is-path-info-in-php&quot;&gt;PATH_INFO&lt;/a&gt;, Luke</source>
          <target state="translated">使用&lt;a href=&quot;https://stackoverflow.com/questions/2261951/what-exactly-is-path-info-in-php&quot;&gt;PATH_INFO&lt;/a&gt; ，卢克</target>
        </trans-unit>
        <trans-unit id="b06ad5cb5d4d5adc3d4c61b06b4b81b4e2fc280c" translate="yes" xml:space="preserve">
          <source>Were it really be disabled, your RewriteRules still wouldn't work anyway.</source>
          <target state="translated">如果它真的被禁用了,你的RewriteRules仍然无法工作。</target>
        </trans-unit>
        <trans-unit id="d0cbc1290725122d94fb5a18b92c5702e6822572" translate="yes" xml:space="preserve">
          <source>What &quot;pretty&quot; URLs should conceptionally be used for is making websites &lt;strong&gt;&lt;em&gt;user-friendly&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">概念上应使用的&amp;ldquo;漂亮&amp;rdquo; URL是使网站变得&lt;strong&gt;&lt;em&gt;用户友好&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="09b7efa758045019b58e1428653c1f860a31dcd6" translate="yes" xml:space="preserve">
          <source>What mod_rewrite does &lt;em&gt;not&lt;/em&gt; do</source>
          <target state="translated">mod_rewrite不做什么</target>
        </trans-unit>
        <trans-unit id="360f3bc410da35a3cfaf91a34475047f7d1fbd2b" translate="yes" xml:space="preserve">
          <source>What seems enticing as generalized safeguard, often turns out to be an obstacle in practice.</source>
          <target state="translated">看似诱人的泛化保障,在实践中往往会变成障碍。</target>
        </trans-unit>
        <trans-unit id="60ab540d4d5fa82c04683e07b642ce0708dabbf4" translate="yes" xml:space="preserve">
          <source>When opting for directory-style paths, you can make it reachable with and without a final</source>
          <target state="translated">当选择目录式的路径时,你可以让它在有和没有最终的</target>
        </trans-unit>
        <trans-unit id="c5b3b194631676b25d479ba8960b569223e4c363" translate="yes" xml:space="preserve">
          <source>When you introduce virtual directory structures &lt;code&gt;/blog/article/123&lt;/code&gt; this impacts relative resource references in HTML (such as &lt;code&gt;&amp;lt;img src=mouse.png&amp;gt;&lt;/code&gt;).
Which can be solved by:</source>
          <target state="translated">当您引入虚拟目录结构 &lt;code&gt;/blog/article/123&lt;/code&gt; 时,这会影响HTML中的相对资源引用（例如 &lt;code&gt;&amp;lt;img src=mouse.png&amp;gt;&lt;/code&gt; ）。 可以通过以下方法解决：</target>
        </trans-unit>
        <trans-unit id="22eb5ad30eff3a83a982c487a7eeafa78266307c" translate="yes" xml:space="preserve">
          <source>Whenever something &lt;em&gt;doesn't work&lt;/em&gt;</source>
          <target state="translated">每当某事&lt;em&gt;不起作用&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="73279bd5b2034996f948348aaf4405c0d1d8ebfc" translate="yes" xml:space="preserve">
          <source>Which helps to narrow down overly generic rules and regex mishaps.</source>
          <target state="translated">这有助于缩小过于笼统的规则和语法错误。</target>
        </trans-unit>
        <trans-unit id="ef42d9dca7c76ff93fcf4f46cc65e5e50e1ea14b" translate="yes" xml:space="preserve">
          <source>Which is not to say you always &lt;em&gt;have to&lt;/em&gt;. Content-Negotiation is just an automatism to virtual resources.</source>
          <target state="translated">这并不是说您始终&lt;em&gt;必须这样做&lt;/em&gt; 。 内容协商只是虚拟资源的自动化。</target>
        </trans-unit>
        <trans-unit id="8178d60b1be6e325d969a1f01cbe50a62bca55c9" translate="yes" xml:space="preserve">
          <source>Which is often used by PHP frameworks or WebCMS / portal scripts. The actual path splitting then is handled in PHP using &lt;code&gt;$_SERVER[&quot;REQUEST_URI&quot;]&lt;/code&gt;. So conceptionally it's pretty much the opposite of URL handling &quot;per mod_rewrite&quot;. (Just use &lt;a href=&quot;https://httpd.apache.org/docs/2.4/rewrite/remapping.html#fallback-resource&quot;&gt;&lt;code&gt;FallBackResource&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">PHP框架或WebCMS /门户网站脚本经常使用该脚本。 然后使用 &lt;code&gt;$_SERVER[&quot;REQUEST_URI&quot;]&lt;/code&gt; 在PHP中处理实际的路径拆分。 因此，从概念上讲，它与&amp;ldquo; per mod_rewrite&amp;rdquo; URL处理几乎相反。 （只需使用&lt;a href=&quot;https://httpd.apache.org/docs/2.4/rewrite/remapping.html#fallback-resource&quot;&gt; &lt;code&gt;FallBackResource&lt;/code&gt; 即可&lt;/a&gt; 。）</target>
        </trans-unit>
        <trans-unit id="66300ff1c036bd0e881fe379dec2cb88970a4d4c" translate="yes" xml:space="preserve">
          <source>Which it doesn't per default. You can &lt;a href=&quot;https://stackoverflow.com/questions/7218164/multiple-rewriterules-for-single-rewritecond-in-htaccess&quot;&gt;chain them&lt;/a&gt; using the &lt;code&gt;[S=2]&lt;/code&gt; flag. Else you'll have to repeat them. While sometimes you can craft an &quot;inverted&quot; primary rule to [END] the rewrite processing early.</source>
          <target state="translated">它不是默认值。 您可以使用 &lt;code&gt;[S=2]&lt;/code&gt; 标志&lt;a href=&quot;https://stackoverflow.com/questions/7218164/multiple-rewriterules-for-single-rewritecond-in-htaccess&quot;&gt;链接它们&lt;/a&gt; 。 否则，您将不得不重复它们。 尽管有时您可以制作&amp;ldquo;反向&amp;rdquo;主要规则以尽早[END]进行重写处理。</target>
        </trans-unit>
        <trans-unit id="dfa0314a5be793cf2743f125195fe1bfb6a4399d" translate="yes" xml:space="preserve">
          <source>You can easily extend that rule to allow for &lt;code&gt;/article/title-string&lt;/code&gt; placeholders:</source>
          <target state="translated">您可以轻松地扩展该规则以允许 &lt;code&gt;/article/title-string&lt;/code&gt; 占位符：</target>
        </trans-unit>
        <trans-unit id="6a6877229f800cd4d7bb88f9850b271d0487be6f" translate="yes" xml:space="preserve">
          <source>You can split them out into individual &lt;code&gt;RewriteRule&lt;/code&gt;s should this get too complex.</source>
          <target state="translated">如果这变得太复杂，则可以将它们分成单独的 &lt;code&gt;RewriteRule&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8585e0db233781f56ebd06de62c7eb1f8f5b3a5a" translate="yes" xml:space="preserve">
          <source>You can't match &lt;code&gt;RewriteRule index.php\?x=y&lt;/code&gt;, because mod_rewrite compares just against relative paths per default. You can match them separately however via:</source>
          <target state="translated">您无法匹配 &lt;code&gt;RewriteRule index.php\?x=y&lt;/code&gt; ，因为默认情况下mod_rewrite仅与相对路径进行比较。 您可以通过以下方式分别匹配它们：</target>
        </trans-unit>
        <trans-unit id="d222b87fbace9b84595f1388716086c2a42d24b7" translate="yes" xml:space="preserve">
          <source>You could alternatively craft further RewriteRules to rebind &lt;code&gt;.css&lt;/code&gt; or &lt;code&gt;.png&lt;/code&gt; paths to their original locations.
But that's both unneeded, or incurs extra redirects and hampers caching.</source>
          <target state="translated">您也可以制作其他RewriteRules，以将 &lt;code&gt;.css&lt;/code&gt; 或 &lt;code&gt;.png&lt;/code&gt; 路径重新绑定到其原始位置。 但这都不是必需的，否则会导致额外的重定向并阻碍缓存。</target>
        </trans-unit>
        <trans-unit id="44a6fa9efc666a65a1bd62ec9dc5ea3f7942e480" translate="yes" xml:space="preserve">
          <source>You shouldn't start your &lt;code&gt;.htaccess&lt;/code&gt; RewriteRule patterns with &lt;code&gt;^/&lt;/code&gt; normally:</source>
          <target state="translated">通常，您不应该使用 &lt;code&gt;^/&lt;/code&gt; 开始 &lt;code&gt;.htaccess&lt;/code&gt; RewriteRule模式：</target>
        </trans-unit>
        <trans-unit id="815d892a020c87eb8dcd1e707d7e6e98c8c8c3ca" translate="yes" xml:space="preserve">
          <source>You're most commonly seeing RewriteRules to simulate a virtual directory structure. But you're not forced to be uncreative. You can as well use &lt;code&gt;-&lt;/code&gt; hyphens for segmenting or structure.</source>
          <target state="translated">您最常见的情况是看到RewriteRules来模拟虚拟目录结构。 但是，您不会被迫独创。 您也可以使用 &lt;code&gt;-&lt;/code&gt; 连字符进行分段或结构化。</target>
        </trans-unit>
        <trans-unit id="d0f0d732863ee895a309758e84227312d39f3171" translate="yes" xml:space="preserve">
          <source>You've probably seen this in many examples:</source>
          <target state="translated">你可能在很多例子中都看到过这种情况。</target>
        </trans-unit>
        <trans-unit id="a8f5998b0f4e9bd3bbc4db8f81b5de80b7f6c2ed" translate="yes" xml:space="preserve">
          <source>approach is easy to append onto any other RewriteRule.</source>
          <target state="translated">这种方法很容易附加到任何其他RewriteRule上。</target>
        </trans-unit>
        <trans-unit id="6ec7f782439e58bed3a8696b026c30a1d9093ec8" translate="yes" xml:space="preserve">
          <source>in patterns</source>
          <target state="translated">有规律</target>
        </trans-unit>
        <trans-unit id="a56c70ab2c290c7937cb7e100dd4b3b8f2b82d94" translate="yes" xml:space="preserve">
          <source>mod_rewrite does not magically make all your URLs &quot;pretty&quot;. This is a common misunderstanding. If you have this link in your web site:</source>
          <target state="translated">mod_rewrite不会神奇地让你的所有URL都变得 &quot;漂亮&quot;。这是一个常见的误解。如果你的网站有这个链接,。</target>
        </trans-unit>
        <trans-unit id="043d0819e92bf8f0d7f33ab50480ff32c04dd7c1" translate="yes" xml:space="preserve">
          <source>mod_rewrite is a way to &lt;em&gt;rewrite&lt;/em&gt; the internal request handling. When the web server receives a request for the URL &lt;code&gt;/foo/bar&lt;/code&gt;, you can &lt;em&gt;rewrite&lt;/em&gt; that URL into something else before the web server will look for a file on disk to match it. Simple example:</source>
          <target state="translated">mod_rewrite是一种&lt;em&gt;重写&lt;/em&gt;内部请求处理的方法。 当Web服务器收到对URL &lt;code&gt;/foo/bar&lt;/code&gt; 的请求时，您可以在将该URL &lt;em&gt;重写&lt;/em&gt;为其他内容之前，Web服务器将在磁盘上查找与之匹配的文件。 简单的例子：</target>
        </trans-unit>
        <trans-unit id="c838466232ea0f7c751192a9afce76a1b060ebe8" translate="yes" xml:space="preserve">
          <source>scheme:</source>
          <target state="translated">scheme:</target>
        </trans-unit>
        <trans-unit id="f37e25064bedecaffcd022221184a14425448ecb" translate="yes" xml:space="preserve">
          <source>there's nothing mod_rewrite can do to make that pretty. In order to make this a pretty link, you have to:</source>
          <target state="translated">没有什么mod_rewrite可以让这个链接变得漂亮。为了让这个链接变得漂亮,你必须:</target>
        </trans-unit>
        <trans-unit id="72bba5fd6da4f8012e901d27e8f7631e871b0922" translate="yes" xml:space="preserve">
          <source>␣</source>
          <target state="translated">␣</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
