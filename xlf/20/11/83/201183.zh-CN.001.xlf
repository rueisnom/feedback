<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/201183">
    <body>
      <group id="201183">
        <trans-unit id="d422201f51a81e209559bb1db5e0da07c6517b20" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://code.google.com/p/pageforest/source/browse/appengine/static/src/js/base.js&quot;&gt;Source code&lt;/a&gt; (including the helper functions, generalType and uniqueArray):
&lt;a href=&quot;http://code.google.com/p/pageforest/source/browse/appengine/static/src/js/tests/test-base.js&quot;&gt;Unit Test&lt;/a&gt; and &lt;a href=&quot;http://pageforest.googlecode.com/hg/appengine/static/src/js/tests/test-runner.html#base&quot;&gt;Test Runner here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/pageforest/source/browse/appengine/static/src/js/base.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;源代码&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（包括辅助函数，generalType和uniqueArray）： &lt;/font&gt;&lt;a href=&quot;http://pageforest.googlecode.com/hg/appengine/static/src/js/tests/test-runner.html#base&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此处是&lt;/font&gt;&lt;/a&gt;&lt;/font&gt;&lt;a href=&quot;http://code.google.com/p/pageforest/source/browse/appengine/static/src/js/tests/test-base.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单元测试&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;测试运行器&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75935ce922d2a3772ab7768478f8a8e13aaa8ad6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.w3schools.com/js/js_json_stringify.asp&quot;&gt;JSON.stringify()&lt;/a&gt; works for deep and non-deep both types of objects, not very sure of performance aspects:</source>
          <target state="translated">&lt;a href=&quot;https://www.w3schools.com/js/js_json_stringify.asp&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSON.stringify（）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;适用于两种类型的对象的深层和非深层，对性能方面不是很确定：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="130fc136bbb8804229578007e60b620a3dca4059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;angular.equals&lt;/code&gt; - See the &lt;a href=&quot;http://docs.angularjs.org/api/angular.equals&quot;&gt;docs&lt;/a&gt; or &lt;a href=&quot;https://github.com/angular/angular.js/blob/6c59e770084912d2345e7f83f983092a2d305ae3/src/Angular.js#L670&quot;&gt;source&lt;/a&gt; for more on this method. It does a deep compare on arrays too.</source>
          <target state="translated">&lt;code&gt;angular.equals&lt;/code&gt; -&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关此方法的更多信息，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参见&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.angularjs.org/api/angular.equals&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文档&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/angular/angular.js/blob/6c59e770084912d2345e7f83f983092a2d305ae3/src/Angular.js#L670&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来源&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它也对数组进行了深入的比较。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d616314b6e49275e7f07289af7887af8e3695da3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Assuming that the order of the properties in the object is not changed.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假定对象中属性的顺序未更改。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c41148899f7a79b0e52367560157187080f81e6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6:&lt;/strong&gt; The minimum code I could get it done, is this. It do deep comparison recursively by stringifying all objects, the only limitation is no methods or symbols are compare.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES6：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我能完成的最少代码是这样。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它通过对所有对象进行字符串化来进行深度比较，唯一的限制是没有方法或符号可以进行比较。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0aa990d7c40383d4083d7824eff0ce8efa3a4cec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: version 2, using jib's suggestion and ES6 arrow functions:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编辑&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：版本2，使用臂架的建议和ES6箭头功能：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1664aea62eb13b77137a5ca0dfd963515c1ffe11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE: While this answer will work in many cases, as several people have pointed out in the comments it's problematic for a variety of reasons. In pretty much all cases you'll want to find a more robust solution.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：尽管此答案在许多情况下都有效，但正如一些人在评论中指出的那样，由于多种原因，这是有问题的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在几乎所有情况下，您都想找到一个更强大的解决方案。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="052815ea50d3f7ac9ceed0a151b7d24249d5a175" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplest&lt;/strong&gt; and &lt;strong&gt;logical&lt;/strong&gt; solutions for comparing everything Like &lt;strong&gt;Object, Array, String, Int...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比较&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象，数组，字符串，整数等&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有内容的&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最简单&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;逻辑的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决方案&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="154442026c578bde4bf91577672771cbf7120401" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The long answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;长答案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f3ca1d0829015a6a21caa4e5649f4c54d908c0b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The short answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;简短的答案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="117325da892f4e34ebca280c275c11f3989aeeca" translate="yes" xml:space="preserve">
          <source>A function that implements this definition of equality:</source>
          <target state="translated">实现这一平等定义的函数;</target>
        </trans-unit>
        <trans-unit id="8a3343ce56eab4c47b420d306cb822a037d6df0c" translate="yes" xml:space="preserve">
          <source>A simple solution to this issue that many people don't realize is to sort the JSON strings (per character). This is also usually faster than the other solutions mentioned here:</source>
          <target state="translated">很多人没有意识到的一个简单的解决方案是对JSON字符串进行排序(每个字符)。这通常也比这里提到的其他解决方案要快。</target>
        </trans-unit>
        <trans-unit id="87a8d1e5f254712f960f4d6c115f25b690949194" translate="yes" xml:space="preserve">
          <source>A strict equality operator will tell you if two object &lt;strong&gt;types&lt;/strong&gt; are equal. However, is there a way to tell if two objects are equal, &lt;strong&gt;much like the hash code&lt;/strong&gt; value in Java?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;严格的相等运算符将告诉您两个对象&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是否相等。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，有没有办法判断两个对象是否相等，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就像&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Java中&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的哈希码&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一样&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="93f1b6742bf696c646d33eb65a0d3154692a9201" translate="yes" xml:space="preserve">
          <source>Also, it's recursive, so it can also check for deep equality, if that's what you call it.</source>
          <target state="translated">另外,它是递归的,所以它还可以检查深层的平等,如果你说的是这样的话。</target>
        </trans-unit>
        <trans-unit id="d12df9b949c4bf605e35cab7117e631709b6570b" translate="yes" xml:space="preserve">
          <source>An object may reference a method that is to be called as an event handler, and this would likely not be considered part of its 'value state'. Whereas another object may well be assigned a function that performs an important calculation and thereby makes this instance different from others simply because it references a different function.</source>
          <target state="translated">一个对象可能会引用一个要作为事件处理程序调用的方法,这很可能不被认为是它的 &quot;值状态 &quot;的一部分。而另一个对象很可能被分配了一个函数来执行重要的计算,从而使这个实例与其他的实例不同,仅仅因为它引用了不同的函数。</target>
        </trans-unit>
        <trans-unit id="3d672c90a0834a45b1eeaacfa7147f96ac95f799" translate="yes" xml:space="preserve">
          <source>Another example that returns &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; instead of returning errors:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一个返回&lt;/font&gt;&lt;/font&gt; &lt;code&gt;true&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; / &lt;/font&gt;&lt;/font&gt; &lt;code&gt;false&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不返回错误的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="19bfe63a68a7d33bfb5d996e3b4f92cadb237fd5" translate="yes" xml:space="preserve">
          <source>Another useful thing about this method is you can filter comparisons by passing a &quot;replacer&quot; function to the JSON.stringify functions (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Example_of_using_replacer_parameter&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Example_of_using_replacer_parameter&lt;/a&gt;). The following will only compare all objects keys that are named &quot;derp&quot;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于此方法的另一有用之处是，您可以通过将&amp;ldquo;替换器&amp;rdquo;函数传递给JSON.stringify函数来过滤比较。（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Example_of_using_replacer_parameter&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON / stringify＃Example_of_using_replacer_parameter&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下面将仅比较所有名为&amp;ldquo; derp&amp;rdquo;的对象键：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b53c1d41a5759c78ee2b320f2d132bf26a7b1af6" translate="yes" xml:space="preserve">
          <source>Are you trying to test if two objects are the equal? ie: their properties are equal?</source>
          <target state="translated">你是想测试两个物体是否相等? 即:它们的属性是否相等?</target>
        </trans-unit>
        <trans-unit id="0dc2d4cd771fd05e87df351ac6aede40cfe91919" translate="yes" xml:space="preserve">
          <source>As FOR pointed out, you might have to adapt this for your own purposes, eg: different classes may have different definitions of &quot;equal&quot;. If you're just working with plain objects, the above may suffice, otherwise a custom &lt;code&gt;MyClass.equals()&lt;/code&gt; function may be the way to go.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正如FOR指出的那样，您可能必须出于自己的目的对此进行调整，例如：不同的类可能具有不同的&amp;ldquo;等于&amp;rdquo;定义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果仅使用普通对象，则上面的内容就足够了，否则，可以使用自定义&lt;/font&gt;&lt;/font&gt; &lt;code&gt;MyClass.equals()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c61005452385f8bd1840730fb08806a391d1bf4" translate="yes" xml:space="preserve">
          <source>As stated earlier, the exception would be a strictly typeless object. In which case the only sensible choice is an iterative and recursive comparison of each member. Even then one has to ask what is the 'value' of a function?</source>
          <target state="translated">如前所述,例外是一个严格意义上的无类型对象。在这种情况下,唯一明智的选择是对每个成员进行迭代和递归比较。即便如此,人们也要问,什么是函数的 &quot;值&quot;?</target>
        </trans-unit>
        <trans-unit id="c0c4c8ac002583533ff6674c083fe94db4c83220" translate="yes" xml:space="preserve">
          <source>Comes in handy in tests (most test frameworks have an &lt;code&gt;is&lt;/code&gt; function). E.g.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在测试中派上用场（大多数测试框架都具有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;is&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9e5a40518a875431511860c5d9e95e874e31014" translate="yes" xml:space="preserve">
          <source>Complexity is O(N*N) with N is the number of keys.</source>
          <target state="translated">复杂度为O(N*N),N为密钥数。</target>
        </trans-unit>
        <trans-unit id="614666f0a7527742ff0e56774d57de0846f19ad3" translate="yes" xml:space="preserve">
          <source>Demo: &lt;a href=&quot;http://jsfiddle.net/CU3vb/3/&quot;&gt;http://jsfiddle.net/CU3vb/3/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;演示：&lt;/font&gt;&lt;a href=&quot;http://jsfiddle.net/CU3vb/3/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//jsfiddle.net/CU3vb/3/&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c2d9e61dfdd0566e4a5c134324d8b75fe38fd9af" translate="yes" xml:space="preserve">
          <source>Ember.js &lt;code&gt;isEqual&lt;/code&gt; - See the &lt;a href=&quot;http://emberjs.com/api/#method_isEqual&quot;&gt;docs&lt;/a&gt; or &lt;a href=&quot;https://github.com/emberjs/ember.js/blob/dfbdbea00bb94f3c1620bd09145540a8bbb8e224/packages/ember-runtime/lib/is-equal.js&quot;&gt;source&lt;/a&gt; for more on this method. It does not do a deep compare on arrays.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ember.js &lt;/font&gt;&lt;/font&gt; &lt;code&gt;isEqual&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -查看&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://emberjs.com/api/#method_isEqual&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文档&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/emberjs/ember.js/blob/dfbdbea00bb94f3c1620bd09145540a8bbb8e224/packages/ember-runtime/lib/is-equal.js&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;源&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以获得更多关于这种方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它没有对数组做深入的比较。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="9bf6b914418f6ff5b699882d36b4e76c0165bbbb" translate="yes" xml:space="preserve">
          <source>Firstly sort the two objects by key their key names.</source>
          <target state="translated">首先将两个对象按键名进行排序。</target>
        </trans-unit>
        <trans-unit id="6e5947c83c30e1a19b642ffa16b6d6098d8bf522" translate="yes" xml:space="preserve">
          <source>For comparing keys for simple key/value pairs object instances, I use:</source>
          <target state="translated">为了比较简单的key-value对对象实例的键值比较,我使用。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="c5bd7b0ace095776ee4b6b5dfd3059ad20f1e805" translate="yes" xml:space="preserve">
          <source>For those of you using NodeJS, there is a convenient method called &lt;code&gt;isDeepStrictEqual&lt;/code&gt; on the native Util library that can achieve this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;isDeepStrictEqual&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，本机Util库上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有一个方便的方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;isDeepStrictEqual&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以实现此目的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bdb53b577aeda6276096be96b953c9f6de0609fc" translate="yes" xml:space="preserve">
          <source>Further complicating things is that in JavaScript the distinction between data and method is blurred.</source>
          <target state="translated">更加复杂的是,在JavaScript中,数据和方法之间的区别是模糊的。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="baa059ac55b3a5589ea7c8841e51d303749963bf" translate="yes" xml:space="preserve">
          <source>Here's a playing card example:</source>
          <target state="translated">这里有一个扑克牌的例子。</target>
        </trans-unit>
        <trans-unit id="3b49d62cac40c4f166746579d98fd2e9560dafb3" translate="yes" xml:space="preserve">
          <source>Heres's a solution in ES6/ES2015 using a functional-style approach:</source>
          <target state="translated">下面是ES6ES2015中使用功能型的解决方案。</target>
        </trans-unit>
        <trans-unit id="32d8802faf36f90d72a5d340e1a53fdbdca81d37" translate="yes" xml:space="preserve">
          <source>How to determine equality for two JavaScript objects</source>
          <target state="translated">如何确定两个JavaScript对象的平等性</target>
        </trans-unit>
        <trans-unit id="d92b8b9b0b56b28284edbfd97a5a4c71ea1cfa30" translate="yes" xml:space="preserve">
          <source>I don't know if anyone's posted anything similar to this, but here's a function I made to check for object equalities.</source>
          <target state="translated">我不知道有没有人发布过类似的东西,但这是我做的一个检查对象是否相等的函数。</target>
        </trans-unit>
        <trans-unit id="25541bfbd383408f58434a09bb44967257688815" translate="yes" xml:space="preserve">
          <source>I faced the same problem and deccided to write my own solution. But because I want to also compare Arrays with Objects and vice-versa, I crafted a generic solution. I decided to add the functions to the prototype, but one can easily rewrite them to standalone functions. Here is the code:</source>
          <target state="translated">我遇到了同样的问题,于是决定写出自己的解决方案。但是因为我也想把Arrays和Objects进行比较,反之亦然,所以我精心设计了一个通用的解决方案。我决定把这些函数添加到原型中,但也可以很容易地把它们改写成独立的函数。下面是代码。</target>
        </trans-unit>
        <trans-unit id="620676ac1f2a40da4c05d22910d2f0c26068b7ed" translate="yes" xml:space="preserve">
          <source>I hope/guess objects I define won't hold more than 1000 properties...</source>
          <target state="translated">我希望我定义的对象不会拥有超过1000个属性......</target>
        </trans-unit>
        <trans-unit id="72c1020d591149dffba7f2c4297fa3a18961c774" translate="yes" xml:space="preserve">
          <source>I know this is a bit old, but I would like to add a solution that I came up with for this problem.
I had an object  and I wanted to know when its data changed. &quot;something similar to Object.observe&quot; and what I did was:</source>
          <target state="translated">我知道这个问题有点老了,但我想补充一个我想出来的解决方法。我有一个对象,我想知道它的数据何时改变。&quot;类似于Object.observation的东西&quot;,我所做的是:</target>
        </trans-unit>
        <trans-unit id="0883f0456d3e8799dcde764db81c843dcc4dd20a" translate="yes" xml:space="preserve">
          <source>I see spaghetti code answers.
Without using any third party libs, this is very easy.</source>
          <target state="translated">我看到意大利面条代码的答案。在不使用任何第三方lib的情况下,这是非常容易的。</target>
        </trans-unit>
        <trans-unit id="8a1ed8709f0cb36a073cbc8520873d0a5cff9592" translate="yes" xml:space="preserve">
          <source>I use this &lt;code&gt;comparable&lt;/code&gt; function to produce copies of my objects that are JSON comparable:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我使用此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;comparable&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;功能来生成与JSON可比的对象副本：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2b332b03edb7d73add355c3fa91804a0f84f41d0" translate="yes" xml:space="preserve">
          <source>I'd advise against hashing or serialization (as the JSON solution suggest).  If you need to test if two objects are equal, then you need to define what equals means.  It could be that all data members in both objects match, or it could be that must the memory locations match (meaning both variables reference the same object in memory), or may be that only one data member in each object must match.</source>
          <target state="translated">我建议不要使用散列或序列化(如JSON解决方案所建议的那样)。如果你需要测试两个对象是否相等,那么你需要定义equals是什么意思。有可能是两个对象中的所有数据成员都匹配,也有可能是内存位置必须匹配(意味着两个变量在内存中引用同一个对象),也有可能是每个对象中只有一个数据成员必须匹配。</target>
        </trans-unit>
        <trans-unit id="9ac338fd648b3ef084c966e05557018ab32e0a89" translate="yes" xml:space="preserve">
          <source>I'm making the following assumptions with this function:</source>
          <target state="translated">我用这个功能做了如下假设。</target>
        </trans-unit>
        <trans-unit id="6811822354e95921e162ee0b9000eabda79d6902" translate="yes" xml:space="preserve">
          <source>If a difference is caught, strings get logged, making differences spottable:</source>
          <target state="translated">如果差异被捕捉到,字符串会被记录下来,使差异可被记录下来。</target>
        </trans-unit>
        <trans-unit id="0b5f5e8bbf5ed9e96e92dffd1ecf50f1cb169a64" translate="yes" xml:space="preserve">
          <source>If this is the case, you'll probably have noticed this situation:</source>
          <target state="translated">如果是这种情况,你可能已经注意到这种情况了。</target>
        </trans-unit>
        <trans-unit id="efb5c886702935c4ce12a4d3bc9c07efaf9ad546" translate="yes" xml:space="preserve">
          <source>If two objects are different, a MongoDB compatible &lt;code&gt;{$rename:{...}, $unset:{...}, $set:{...}}&lt;/code&gt; like object is returned.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果两个对象不同，则返回与对象兼容的MongoDB兼容&lt;/font&gt;&lt;/font&gt; &lt;code&gt;{$rename:{...}, $unset:{...}, $set:{...}}&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29708321ba5aaec34c1a7215a84b07aa3bddff04" translate="yes" xml:space="preserve">
          <source>If you are comparing JSON objects you can use &lt;a href=&quot;https://github.com/mirek/node-rus-diff&quot;&gt;https://github.com/mirek/node-rus-diff&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要比较JSON对象，则可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/mirek/node-rus-diff&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/mirek/node-rus-diff&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="90393fa8bdd43cbf52b4b9cc3a69939fe3b3b483" translate="yes" xml:space="preserve">
          <source>If you are using a JSON library, you can encode each object as JSON, then compare the resulting strings for equality.</source>
          <target state="translated">如果你使用的是JSON库,你可以将每个对象编码为JSON,然后比较所产生的字符串是否平等。</target>
        </trans-unit>
        <trans-unit id="afbad5f8a046eb65d172d7051b1ddb9f5c6cc6b4" translate="yes" xml:space="preserve">
          <source>If you are working in &lt;a href=&quot;http://docs.angularjs.org&quot;&gt;AngularJS&lt;/a&gt;, the &lt;code&gt;angular.equals&lt;/code&gt; function will determine if two objects are equal. In &lt;a href=&quot;http://emberjs.com/api/&quot;&gt;Ember.js&lt;/a&gt; use &lt;code&gt;isEqual&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您使用的是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.angularjs.org&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AngularJS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则&lt;/font&gt;&lt;/font&gt; &lt;code&gt;angular.equals&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数将确定两个对象是否相等。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://emberjs.com/api/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ember.js中，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;isEqual&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e6cb400c64de748532aa8fe2758bdb1f628afec2" translate="yes" xml:space="preserve">
          <source>If you have a deep copy function handy, you can use the following trick to &lt;em&gt;still&lt;/em&gt; use &lt;code&gt;JSON.stringify&lt;/code&gt; while matching the order of properties:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您方便使用深层复制功能，则可以使用以下技巧&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在匹配属性顺序时&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仍&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;JSON.stringify&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="075e90365c1c07522501910e3b40364a67c0390e" translate="yes" xml:space="preserve">
          <source>If you require a different equality operator you'll need to add an &lt;code&gt;equals(other)&lt;/code&gt; method, or something like it to your classes and the specifics of your problem domain will determine what exactly that means.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您需要其他相等运算符，则需要在类中添加一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;equals(other)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法或类似的方法，问题域的具体内容将确定这到底意味着什么。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f230fda54d534adc6e4df446991e11b55e4293ee" translate="yes" xml:space="preserve">
          <source>In Node.js, you can use its native &lt;code&gt;require(&quot;assert&quot;).deepStrictEqual&lt;/code&gt;. More info: 
&lt;a href=&quot;http://nodejs.org/api/assert.html&quot;&gt;http://nodejs.org/api/assert.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在Node.js中，您可以使用其本机的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;require(&quot;assert&quot;).deepStrictEqual&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更多信息：&lt;/font&gt;&lt;a href=&quot;http://nodejs.org/api/assert.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//nodejs.org/api/assert.html&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fe48a5c70a6f7c4c6a94ec61cd153febf7ef3d33" translate="yes" xml:space="preserve">
          <source>In that case I defined &quot;equal&quot; as meaning the the id values match.  Given that each instance has a unique id this could be used to enforce the idea that matching objects also occupy the same memory location.  Although that is not necessary.</source>
          <target state="translated">在这种情况下,我将 &quot;相等 &quot;定义为id值匹配。考虑到每个实例都有一个唯一的id,这可以用来强制执行匹配对象也占用相同的内存位置的想法。虽然这并不是必须的。</target>
        </trans-unit>
        <trans-unit id="f0691b66899e23aa3d4aea59975b85e6520536eb" translate="yes" xml:space="preserve">
          <source>In this above case, &lt;code&gt;c&lt;/code&gt; is not really important to determine whether any two instances of MyClass are equal, only &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are important. In some cases &lt;code&gt;c&lt;/code&gt; might vary between instances and yet not be significant during comparison.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在上述情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于确定MyClass的任何两个实例是否相等&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并不十分重要&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，只有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是重要的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在某些情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在各个实例之间可能有所不同，但在比较过程中并不重要。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8258ec58264eb0921c797310f548d8b602d664d9" translate="yes" xml:space="preserve">
          <source>It will brute force check each key value - just like the other examples on this page - using &lt;a href=&quot;http://en.wikipedia.org/wiki/ECMAScript#Versions&quot;&gt;ECMAScript&amp;nbsp;5&lt;/a&gt; and native optimizations if they're available in the browser.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就像本页中的其他示例一样，它将使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/ECMAScript#Versions&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ECMAScript 5&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和本机优化（如果浏览器中可用）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;蛮力检查每个键值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cb20f901fefd383c1d242ee19542c1609444033" translate="yes" xml:space="preserve">
          <source>It's useful to consider two objects equal if they have all the same values for all properties and recursively for all nested objects and arrays.  I also consider the following two objects equal:</source>
          <target state="translated">如果两个对象的所有属性值都相同,并且对所有嵌套的对象和数组都是递归的,那么认为两个对象是平等的,这是很有用的。我也认为以下两个对象是平等的。</target>
        </trans-unit>
        <trans-unit id="dc34201504cc5166081377b5b96498a67878d000" translate="yes" xml:space="preserve">
          <source>Just wanted to contribute my version of objects comparison utilizing some es6 features. It doesn't take an order into account. After converting all if/else's to ternary I've came with following:</source>
          <target state="translated">只是想贡献一下我的版本,利用ES6的一些功能进行对象比较。它不考虑顺序的问题。在将所有的ifelse转换为三元函数后,我得出了以下结果。</target>
        </trans-unit>
        <trans-unit id="47c8c9aee02fc7cf827f57dbf1ede0ad0a9a951c" translate="yes" xml:space="preserve">
          <source>Needing a more generic object comparison function than had been posted, I cooked up the following. Critique appreciated...</source>
          <target state="translated">由于需要一个更通用的对象比较功能,我想出了下面这个功能。请大家批评指正.....</target>
        </trans-unit>
        <trans-unit id="d24d4b5a369eb9020cd7ee78de6676d60a8db114" translate="yes" xml:space="preserve">
          <source>Note this issue applies when members may themselves also be instances of a type and these each would all be required to have a means of determining equality.</source>
          <target state="translated">请注意,这个问题适用于成员本身也可能是一种类型的实例,而且这些成员都必须有确定平等的手段。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="e0e0c0e31745b9915640f06ed8b5f58ce68f53d6" translate="yes" xml:space="preserve">
          <source>Note: Previously this answer recommended &lt;a href=&quot;http://underscorejs.org/&quot;&gt;Underscore.js&lt;/a&gt;, but &lt;a href=&quot;http://lodash.com&quot;&gt;lodash&lt;/a&gt; has done a better job of getting bugs fixed and addressing issues with consistency.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注：以前这个答案推荐&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://underscorejs.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Underscore.js&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://lodash.com&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lodash&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;做得越来越修复的错误，并与一致性解决问题的一个更好的工作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2cd91d91d61190347de340dda1b9a0bfd5b9b415" translate="yes" xml:space="preserve">
          <source>Obviously that function could do with quite a bit of optimisation, and the ability to do deep checking (to handle nested objects: &lt;code&gt;var a = { foo : { fu : &quot;bar&quot; } }&lt;/code&gt;) but you get the idea.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显然，该功能可以进行很多优化，并且可以进行深度检查（以处理嵌套对象：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;var a = { foo : { fu : &quot;bar&quot; } }&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）），但是您明白了。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c259dd5022babfb3a5506b979118e875e3ce4353" translate="yes" xml:space="preserve">
          <source>Once keys are compared, a simple additional &lt;code&gt;for..in&lt;/code&gt; loop is enough.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一旦比较了键，一个简单的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;for..in&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;循环就足够了。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d43a43abf441a7f90425c52eb98bd94ce24e3a32" translate="yes" xml:space="preserve">
          <source>One can call it like this:</source>
          <target state="translated">人们可以这样称呼它。</target>
        </trans-unit>
        <trans-unit id="49a58e13d9a842b9110b1f0e1757f9dede780a67" translate="yes" xml:space="preserve">
          <source>Rationale:</source>
          <target state="translated">Rationale:</target>
        </trans-unit>
        <trans-unit id="37b77573764cd6d5d483d8c43c8e096f07ba30e6" translate="yes" xml:space="preserve">
          <source>Recently I developed an object whose constructor creates a new id (starting from 1 and incrementing by 1) each time an instance is created.  This object has an isEqual function that compares that id value with the id value of another object and returns true if they match.</source>
          <target state="translated">最近,我开发了一个对象,每次创建一个实例时,其构造函数都会创建一个新的id(从1开始,然后递增1)。这个对象有一个isEqual函数,它将这个id值与另一个对象的id值进行比较,如果匹配,则返回true。</target>
        </trans-unit>
        <trans-unit id="b3525dcb35efc16cb120bff9914a470cf37ff191" translate="yes" xml:space="preserve">
          <source>See the official documentation from here: &lt;a href=&quot;http://underscorejs.org/#isEqual&quot;&gt;http://underscorejs.org/#isEqual&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅此处的官方文档：&lt;/font&gt;&lt;a href=&quot;http://underscorejs.org/#isEqual&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//underscorejs.org/#isEqual&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fbc69581b83927a8f474cd6ebce2465ed785fc17" translate="yes" xml:space="preserve">
          <source>Short functional &lt;code&gt;deepEqual&lt;/code&gt; implementation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;简短的功能&lt;/font&gt;&lt;/font&gt; &lt;code&gt;deepEqual&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d6bdafed7f2e05a9c430cc0058bbec81f55eef6b" translate="yes" xml:space="preserve">
          <source>Similarly, arrays can have &quot;missing&quot; elements and undefined elements.  I would treat those the same as well:</source>
          <target state="translated">同样,数组也会有 &quot;缺失 &quot;元素和未定义元素。我也会同样对待这些元素。</target>
        </trans-unit>
        <trans-unit id="c81edfd008d4c1731ec44ab60d932a907f338782" translate="yes" xml:space="preserve">
          <source>Since the properties of &lt;code&gt;obj1&lt;/code&gt; are copied to the clone one by one, their order in the clone will be preserved. And when the properties of &lt;code&gt;obj2&lt;/code&gt; are copied to the clone, since properties already existing in &lt;code&gt;obj1&lt;/code&gt; will simply be overwritten, their orders in the clone will be preserved.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;obj1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的属性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被一一复制到克隆，因此将保留其在克隆中的顺序。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且，当将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;obj2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的属性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;复制到克隆中时，由于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;obj1&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已经存在的属性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将被简单地覆盖，因此它们在克隆中的顺序将得以保留。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92e40bfd5cf1b972d5b743a5a61761a1f2225cb9" translate="yes" xml:space="preserve">
          <source>Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/194846&quot;&gt;Is there any kind of hashCode function in JavaScript?&lt;/a&gt;&lt;/em&gt; is similar to this question, but requires a more academic answer. The scenario above demonstrates why it would be necessary to have one, and I'm wondering if there is any &lt;strong&gt;equivalent solution&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;堆栈溢出问题&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/194846&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaScript中是否存在某种hashCode函数？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与这个问题相似，但需要更多的学术答案。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面的场景演示了为什么必须要有一个，而我想知道是否有任何&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等效的解决方案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3248ac49043c7d1a8816748bc2b7bdd38a95701b" translate="yes" xml:space="preserve">
          <source>The concept is that of an Equals method that compares two different instances of an object to indicate whether they are equal at a value level. However, it is up to the specific type to define how an &lt;code&gt;Equals&lt;/code&gt; method should be implemented. An iterative comparison of attributes that have primitive values may not be enough, there may well be attributes which are not to be considered part of the object value. For example,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该概念是一种Equals方法的概念，该方法比较对象的两个不同实例以指示它们在值级别上是否相等。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，由特定类型决定如何&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Equals&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有原始值的属性的迭代比较可能还不够，可能存在一些不被视为对象值一部分的属性。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5dae3164b37783ade9b11ff3acb22344db75238" translate="yes" xml:space="preserve">
          <source>The default equality operator in JavaScript for Objects yields true when they refer to the same location in memory.</source>
          <target state="translated">在JavaScript for Objects中,当它们引用到内存中的相同位置时,默认的平等运算符会产生真值。</target>
        </trans-unit>
        <trans-unit id="f47fc7cc0217e32f8128f8cb6829359ad7f70762" translate="yes" xml:space="preserve">
          <source>The function either returns true or false, in this case true.
The algorithm als allows comparison between very complex objects:</source>
          <target state="translated">该函数要么返回true,要么返回false,在这里是true。该算法允许在非常复杂的对象之间进行比较。</target>
        </trans-unit>
        <trans-unit id="5c4fb9540b37ba4c6f473dc93528da4bdcca078c" translate="yes" xml:space="preserve">
          <source>The simple answer is: No, there is no generic means to determine that an object is equal to another in the sense you mean. The exception is when you are strictly thinking of an object being typeless.</source>
          <target state="translated">简单的答案是:不,没有通用的手段来确定一个对象与另一个对象在你的意义上是平等的。例外的情况是,当你严格意义上认为一个对象是无类型的时候。</target>
        </trans-unit>
        <trans-unit id="9887c1e44990a19a15ca805db7dd0e64078c6d2d" translate="yes" xml:space="preserve">
          <source>The upper example will return true, even tho the properties have a different ordering. One small detail to look out for: This code also checks for the same type of two variables, so &quot;3&quot; is not the same as 3.</source>
          <target state="translated">上面的例子会返回true,即使属性的顺序不同。有一个小细节需要注意。这个代码也会检查两个变量的相同类型,所以 &quot;3 &quot;和3不一样。</target>
        </trans-unit>
        <trans-unit id="9bc2b512f582f1094f90e407b5398a6a0d03c739" translate="yes" xml:space="preserve">
          <source>Then simply use a string to compare them.</source>
          <target state="translated">然后简单地用一个字符串来比较它们。</target>
        </trans-unit>
        <trans-unit id="df881162c43f80bfc47bc0e210b19496cec86b50" translate="yes" xml:space="preserve">
          <source>This Algorithm is split into two parts; The equals function itself and a function to find the numeric index of a property in an array / object. The find function is only needed because indexof only finds numbers and strings and no objects .</source>
          <target state="translated">这个算法分为两个部分;等号函数本身和查找数组对象中属性的数字索引的函数。只需要查找函数,因为indexof只能查找数字和字符串,而不能查找对象。</target>
        </trans-unit>
        <trans-unit id="754f106228e194f1279ec0c2c82d2ff928ed3a74" translate="yes" xml:space="preserve">
          <source>This compares for: 1) Equality of number of own properties, 2) Equality of key names, 3) if bCompareValues == true, Equality of corresponding property values and their types (triple equality)</source>
          <target state="translated">这个比较的目的是 1)自有属性的数量相等,2)键名的数量相等,3)如果bCompareValues ==true,对应的属性值及其类型的相等(三等分)。</target>
        </trans-unit>
        <trans-unit id="71c2f715419ebeaf9d7d96b150a8a8d110a88340" translate="yes" xml:space="preserve">
          <source>This here can be duplicated and create an other set of arrays to compare the values and keys.
It is very simple because they are now arrays and will return false if objects have different sizes.</source>
          <target state="translated">这里可以复制,并创建另一组数组来比较值和键值。很简单,因为它们现在是数组,如果对象的大小不同,会返回false。</target>
        </trans-unit>
        <trans-unit id="aa46560f12acee3169cd00cd4bd44d11148f1815" translate="yes" xml:space="preserve">
          <source>This is an addition for all the above, not a replacement. If you need to fast shallow-compare objects without need to check extra recursive cases. Here is a shot.</source>
          <target state="translated">这是对上述所有的补充,而不是替代。如果你需要快速浅层比较对象,而不需要检查额外的递归情况。这里有一个镜头。</target>
        </trans-unit>
        <trans-unit id="c9505525e3bdc04fda5bed77005de531d43cb56e" translate="yes" xml:space="preserve">
          <source>This is my version. It is using new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;Object.keys&lt;/a&gt; feature that is introduced in ES5 and ideas/tests from &lt;a href=&quot;https://stackoverflow.com/a/3849480/1414809&quot;&gt;+&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/a/6713782/1414809&quot;&gt;+&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/5522917/1414809&quot;&gt;+&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是我的版本。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ES5中引入的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Object.keys&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;功能以及&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/3849480/1414809&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;+&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/6713782/1414809&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;+&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/5522917/1414809&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;+的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;想法/测试&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90ec7ca1035450e2a6f8682ad4006417b0d98196" translate="yes" xml:space="preserve">
          <source>This should be treated as a demonstration of a simple strategy.</source>
          <target state="translated">这应该作为一种简单策略的示范。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="792b7493198c3be198997add4b384b829f08681c" translate="yes" xml:space="preserve">
          <source>What about an object that has one of its existing prototype methods overridden by another function? Could it still be considered equal to another instance that it otherwise identical? That question can only be answered in each specific case for each type.</source>
          <target state="translated">如果一个对象的现有原型方法中的一个被另一个函数重写了怎么办?它还能被认为与另一个实例相同吗?这个问题只能在每种类型的每一种特定情况下回答。</target>
        </trans-unit>
        <trans-unit id="e04a49ef2f49a2ac92317cdbde251081ad8bec35" translate="yes" xml:space="preserve">
          <source>Why reinvent the wheel? Give &lt;a href=&quot;http://lodash.com/docs#isEqual&quot;&gt;Lodash&lt;/a&gt; a try. It has a number of must-have functions such as &lt;a href=&quot;http://lodash.com/docs#isEqual&quot;&gt;isEqual()&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么要重新发明轮子？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://lodash.com/docs#isEqual&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lodash&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一试。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它具有许多必备功能，例如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://lodash.com/docs#isEqual&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;isEqual（）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="512892a6d2cc9a3dfc510df95d685bde807508de" translate="yes" xml:space="preserve">
          <source>You control the objects you are comparing and you only have primitive values (ie. not nested objects, functions, etc.).</source>
          <target state="translated">你控制了你要比较的对象,而且你只有原始值(即不是嵌套对象、函数等)。</target>
        </trans-unit>
        <trans-unit id="7205aa9b0944c9842020e4e256fcee8da21ce962" translate="yes" xml:space="preserve">
          <source>Your browser has support for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;Object.keys&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您的浏览器支持&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Object.keys&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee619071b38ecc7251b25b3efb7ade8477c0785b" translate="yes" xml:space="preserve">
          <source>demo available here</source>
          <target state="translated">试用版</target>
        </trans-unit>
        <trans-unit id="c472e218b2a3d97cf9c8918237425bf7f39e1ee9" translate="yes" xml:space="preserve">
          <source>for the object, you have to sort(by key) recursively for both side objects</source>
          <target state="translated">的对象,你必须对两边的对象递归排序(按键)。</target>
        </trans-unit>
        <trans-unit id="371bf4463174918cf4efbd1b49aa07e5ff9dfcc7" translate="yes" xml:space="preserve">
          <source>you can use &lt;code&gt;_.isEqual(obj1, obj2)&lt;/code&gt; from the underscore.js library.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;underscore.js库中的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;_.isEqual(obj1, obj2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b13d95866739a1930d09680ea4155d3c01de73bc" translate="yes" xml:space="preserve">
          <source>you might have to do something like this:</source>
          <target state="translated">你可能要做这样的事情。</target>
        </trans-unit>
        <trans-unit id="1209354b665bb8fe81c2c3efa5bc0a6e92839803" translate="yes" xml:space="preserve">
          <source>you need to replace &lt;code&gt;val1&lt;/code&gt;and &lt;code&gt;val2&lt;/code&gt; with your Object</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您需要&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;替换&lt;/font&gt;&lt;/font&gt; &lt;code&gt;val1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;val2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
