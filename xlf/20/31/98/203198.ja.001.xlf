<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/203198">
    <body>
      <group id="203198">
        <trans-unit id="a8972a57acbe818041fa966cc2b28f0cad18bfb0" translate="yes" xml:space="preserve">
          <source>... can be replaced with the following &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;&lt;code&gt;on()&lt;/code&gt;&lt;/a&gt; signature:</source>
          <target state="translated">...は次の&lt;a href=&quot;http://api.jquery.com/on/&quot;&gt; &lt;code&gt;on()&lt;/code&gt; &lt;/a&gt;シグネチャで置き換えることができます：</target>
        </trans-unit>
        <trans-unit id="20a87a21d1dee1ba19a2c9f1d66cddfec7e6bd9f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Credit goes to Dave and Sime Vidas&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;クレジットはDaveとSime Vidasに送られます&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65137a7187fce4b4490f883134f495f236293189" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/ramswaroop/Nrxp5/28/&quot;&gt;Live demo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/ramswaroop/Nrxp5/28/&quot;&gt;ライブデモ&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="575fe48fa4d16cc654b3160eaa356af8d60920af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;This is done by event delegation&lt;/em&gt;&lt;/strong&gt;. Event will bind on wrapper-class element but will be delegated to selector-class element. This is how it works.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;これは、イベントの委任によって行われ&lt;/em&gt;&lt;/strong&gt;ます。 イベントはwrapper-class要素にバインドされますが、selector-class要素に委任されます。 これがどのように機能するかです。</target>
        </trans-unit>
        <trans-unit id="4ceac39fa6838552a173a073715a84bd3223cfb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of jQuery 1.7&lt;/strong&gt; you should use &lt;a href=&quot;https://api.jquery.com/on/#on-events-selector-data-handler&quot;&gt;&lt;code&gt;jQuery.fn.on&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;jQuery 1.7以降&lt;/strong&gt;では、 &lt;a href=&quot;https://api.jquery.com/on/#on-events-selector-data-handler&quot;&gt; &lt;code&gt;jQuery.fn.on&lt;/code&gt; &lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7cf3ad54791f3845059488958d2790178f82afe4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of jQuery 1.8&lt;/strong&gt;, any jQuery instance method (a method of &lt;code&gt;jQuery.fn&lt;/code&gt;) can be used as a property of the object passed to the
  second parameter:</source>
          <target state="translated">&lt;strong&gt;jQuery 1.8&lt;/strong&gt;以降では、任意のjQueryインスタンスメソッド（ &lt;code&gt;jQuery.fn&lt;/code&gt; のメソッド ）を、2番目のパラメーターに渡されるオブジェクトのプロパティとして使用できます。</target>
        </trans-unit>
        <trans-unit id="8121f33e15ae3270016b626cba0d1f05c03ad837" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Child Element:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;子要素：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f858e011c800a6613bd354fb690ab08482220aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Delegated events&lt;/strong&gt; have the advantage that they can process events from descendant elements that are added to the document at a later time. For example, if the table exists, but the rows are added dynamically using code, the following will handle it:</source>
          <target state="translated">&lt;strong&gt;委任イベントに&lt;/strong&gt;は、後でドキュメントに追加される子孫要素からのイベントを処理できるという利点があります。 たとえば、テーブルは存在するが行がコードを使用して動的に追加される場合、次のように処理します。</target>
        </trans-unit>
        <trans-unit id="5ad6ec00b70205934534ed66186e46766e431a7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Delegated events do not work for &lt;a href=&quot;http://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;委任されたイベントは&lt;a href=&quot;http://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;では機能しません。</target>
        </trans-unit>
        <trans-unit id="1396f709940aace150fc43d0022737a6382f4d9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prior to this&lt;/strong&gt;, the recommended approach was to use &lt;a href=&quot;http://api.jquery.com/live&quot;&gt;&lt;code&gt;live()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;これ以前&lt;/strong&gt;は、 &lt;a href=&quot;http://api.jquery.com/live&quot;&gt; &lt;code&gt;live()&lt;/code&gt; &lt;/a&gt;を使用することが推奨されていました。</target>
        </trans-unit>
        <trans-unit id="143ccabf09bfc2410ef1aef7440a4c4bf5b74242" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Single element:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;単一要素：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e79b4193d9abf560434046dc211121399a27306" translate="yes" xml:space="preserve">
          <source>A delegated-events approach (the second code example) attaches an event handler to only one element, the &lt;code&gt;tbody&lt;/code&gt;, and the event only needs to bubble up one level (from the clicked &lt;code&gt;tr&lt;/code&gt; to &lt;code&gt;tbody&lt;/code&gt;).</source>
          <target state="translated">委任イベントアプローチ（2番目のコード例）は、イベントハンドラーを1つの要素である &lt;code&gt;tbody&lt;/code&gt; にのみアタッチし、イベントは1つのレベル（クリックされた &lt;code&gt;tr&lt;/code&gt; から &lt;code&gt;tbody&lt;/code&gt; まで ）をバブルアップするだけで済みます。</target>
        </trans-unit>
        <trans-unit id="bca51f7c9a8ef157c2eb1f3a0badc598bf24fbdc" translate="yes" xml:space="preserve">
          <source>Also as of version 1.9 &lt;code&gt;.live()&lt;/code&gt; method is removed.</source>
          <target state="translated">また、バージョン1.9 &lt;code&gt;.live()&lt;/code&gt; メソッドは削除されました。</target>
        </trans-unit>
        <trans-unit id="520437ca88dd120a5b62eec01ddd5fb91366f135" translate="yes" xml:space="preserve">
          <source>Another flexible solution to create elements and bind events  (&lt;a href=&quot;https://stackoverflow.com/questions/10619445/the-preferred-way-of-creating-a-new-element-with-jquery&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">要素を作成してイベントをバインドするもう1つの柔軟なソリューション（ &lt;a href=&quot;https://stackoverflow.com/questions/10619445/the-preferred-way-of-creating-a-new-element-with-jquery&quot;&gt;ソース&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="9564d129a95bb8da226e634ff72c645d32f4388f" translate="yes" xml:space="preserve">
          <source>Another solution is to add the listener when creating the element. Instead of put the listener in the body, you put the listener in the element in the moment that you create it:</source>
          <target state="translated">もう一つの解決策は、要素を作成する際にリスナーを追加することです。リスナーをボディに入れるのではなく、要素を作成した瞬間にリスナーを要素に入れます。</target>
        </trans-unit>
        <trans-unit id="43044a5260912f835cd862881dbcce424864025a" translate="yes" xml:space="preserve">
          <source>Any p&lt;strong&gt;arent that exists&lt;/strong&gt; at the time the event is bound and if your page was &lt;strong&gt;dynamically creating elements&lt;/strong&gt; with the class name &lt;strong&gt;button&lt;/strong&gt; you would bind the event to a parent which already exists</source>
          <target state="translated">イベントがバインドされるときに&lt;strong&gt;存在する&lt;/strong&gt;任意のペアレント。ページがクラス名&lt;strong&gt;ボタン&lt;/strong&gt;を使用して&lt;strong&gt;動的に要素&lt;/strong&gt;を&lt;strong&gt;作成&lt;/strong&gt;している場合は、既存の親にイベントをバインドします。</target>
        </trans-unit>
        <trans-unit id="a28fbdb9a58de11fbc1879e841aecb020b6f3a51" translate="yes" xml:space="preserve">
          <source>Any parent that exists at the time the event is bound is fine. For example</source>
          <target state="translated">イベントがバインドされた時点で存在する親は何でも構いません。例えば</target>
        </trans-unit>
        <trans-unit id="f970c18459a7c2d0b314f828c4413440bf8ad720" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;on()&lt;/a&gt; makes the trick to attach events, in order to create a fake unbind on those I came to:</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;on（）&lt;/a&gt;がイベントをアタッチするトリックを作るので、私が来たものにバインドされていない偽のものを作成するために：</target>
        </trans-unit>
        <trans-unit id="0e975b5a75355cd02b8540ca3f3913b901d617aa" translate="yes" xml:space="preserve">
          <source>As a workaround, you have to listen to all clicks and check the source element&amp;nbsp;:</source>
          <target state="translated">回避策として、すべてのクリックをリッスンし、ソース要素を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="4001dba9ad59edc09c4afd8f7dea4e2524de2fde" translate="yes" xml:space="preserve">
          <source>Bind the event to a parent which already exists:</source>
          <target state="translated">イベントを既に存在する親にバインドします。</target>
        </trans-unit>
        <trans-unit id="23a669435afc0aec4042f83f8d933fab3832876c" translate="yes" xml:space="preserve">
          <source>Event binding on dynamically created elements</source>
          <target state="translated">動的に作成された要素のイベントバインディング</target>
        </trans-unit>
        <trans-unit id="bbae10adc7d50b259bc0e19531b06621889913be" translate="yes" xml:space="preserve">
          <source>Event handlers are bound only to the currently selected elements; they must exist on the page at the time your code makes the call to &lt;code&gt;.on()&lt;/code&gt;.</source>
          <target state="translated">イベントハンドラーは、現在選択されている要素にのみバインドされます。 これらは、コードが &lt;code&gt;.on()&lt;/code&gt; を呼び出すときにページ上に存在している必要があります。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="09a4c4ab2bd8bc5a70d89eb8a77f473ea61d8c69" translate="yes" xml:space="preserve">
          <source>For example, if your page was dynamically creating elements with the class name &lt;code&gt;dosomething&lt;/code&gt; you would bind the event to &lt;strong&gt;a parent which already exists&lt;/strong&gt; (this is the nub of the problem here, you need something that exists to bind to, don't bind to the dynamic content), this can be (and the easiest option) is &lt;code&gt;document&lt;/code&gt;. Though bear in mind &lt;a href=&quot;https://stackoverflow.com/questions/12824549/should-all-jquery-events-be-bound-to-document&quot;&gt;&lt;code&gt;document&lt;/code&gt; may not be the most efficient option&lt;/a&gt;.</source>
          <target state="translated">たとえば、ページが動的にクラス名 &lt;code&gt;dosomething&lt;/code&gt; で要素を作成している場合、イベントを&lt;strong&gt;既存の親に&lt;/strong&gt;バインドし&lt;strong&gt;ます&lt;/strong&gt; （これはここでの問題の要点です。バインドするために存在するものが必要ですが、バインドしないでください）動的コンテンツ）、これは（そして最も簡単なオプションは） &lt;code&gt;document&lt;/code&gt; です。 ただし、 &lt;a href=&quot;https://stackoverflow.com/questions/12824549/should-all-jquery-events-be-bound-to-document&quot;&gt; &lt;code&gt;document&lt;/code&gt; は最も効率的なオプションではない場合があります&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="74d1a19a05c414d5c3d9d18b75ee5e3108b41b64" translate="yes" xml:space="preserve">
          <source>Here is a sample code I have written, where you can see how the live() method binds chosen elements, even newly created ones, to events:</source>
          <target state="translated">ここに私が書いたサンプルコードがあります。ここでは、live()メソッドが選択された要素(新しく作成されたものであっても)をどのようにイベントに結合するかを見ることができます。</target>
        </trans-unit>
        <trans-unit id="7f010a4d150b400288dc5a4b619b03371e707377" translate="yes" xml:space="preserve">
          <source>Here is why dynamically created elements do not respond to clicks&amp;nbsp;:</source>
          <target state="translated">動的に作成された要素がクリックに反応しない理由は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5c81c0b216fd0f102fb2ba399de807bd3e0bee13" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;live()&lt;/code&gt; was deprecated in 1.7 in favour of &lt;code&gt;on()&lt;/code&gt;, and completely removed in 1.9. The &lt;code&gt;live()&lt;/code&gt; signature:</source>
          <target state="translated">ただし、 &lt;code&gt;live()&lt;/code&gt; は1.7で非推奨となり、 &lt;code&gt;on()&lt;/code&gt; が採用され、1.9で完全に削除されました。 &lt;code&gt;live()&lt;/code&gt; 署名：</target>
        </trans-unit>
        <trans-unit id="bea31d79a2f1fd37a468570dea30fb2473747abe" translate="yes" xml:space="preserve">
          <source>I have a bit of code where I am looping through all the select boxes on a page and binding a &lt;code&gt;.hover&lt;/code&gt; event to them to do a bit of twiddling with their width on &lt;code&gt;mouse on/off&lt;/code&gt;.</source>
          <target state="translated">ページ上のすべての選択ボックスをループし、それらに &lt;code&gt;.hover&lt;/code&gt; イベントをバインドして、 &lt;code&gt;mouse on/off&lt;/code&gt; 幅を少し調整するコードを少し持っています。</target>
        </trans-unit>
        <trans-unit id="0166e850a3cacd1ad5c76193c5748e46bd35cbbc" translate="yes" xml:space="preserve">
          <source>I have found this plugin (&lt;a href=&quot;http://brandonaaron.net/docs/livequery/#getting-started&quot;&gt;jQuery Live Query Plugin&lt;/a&gt;), but before I add another 5k to my pages with a plugin, I want to see if anyone knows a way to do this, either with jQuery directly or by another option.</source>
          <target state="translated">私はこのプラグイン（ &lt;a href=&quot;http://brandonaaron.net/docs/livequery/#getting-started&quot;&gt;jQuery Live Query Plugin&lt;/a&gt; ）を見つけましたが、プラグインを使用してページに5kを追加する前に、jQueryを直接または別のオプションを使用してこれを行う方法を誰かが知っているかどうかを確認したいと思います。</target>
        </trans-unit>
        <trans-unit id="ccea30520e256f544ca7731ee1f90989cc557d6b" translate="yes" xml:space="preserve">
          <source>I have noticed that:</source>
          <target state="translated">そのことに気づいたことがあります。</target>
        </trans-unit>
        <trans-unit id="a93ff81926a62d3a9f49d9c2a7c673b736a1ea74" translate="yes" xml:space="preserve">
          <source>I prefer to have event listeners deployed in a modular function fashion rather than scripting a &lt;code&gt;document&lt;/code&gt; level event listener. So, I do like below. &lt;em&gt;Note, you can't oversubscribe an element with the same event listener so don't worry about attaching a listener more than once - only one sticks.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;document&lt;/code&gt; レベルのイベントリスナーをスクリプト化するのではなく、モジュール関数形式でイベントリスナーを展開することを好みます。 だから、私は以下が好きです。 &lt;em&gt;同じイベントリスナーで要素をオーバーサブスクライブすることはできないので、リスナーを2回以上アタッチすることを心配しないでください。スティックは1つだけです。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba293bc4610d370b65094817ce4a70833808d6ac" translate="yes" xml:space="preserve">
          <source>I prefer using the selector and I apply it on the document.</source>
          <target state="translated">私はセレクタを使うのが好きで、それを文書に適用しています。</target>
        </trans-unit>
        <trans-unit id="3f633aff3611d5b9a4ec0f1a72062fa2b919ca9d" translate="yes" xml:space="preserve">
          <source>I was looking a solution to get &lt;code&gt;$.bind&lt;/code&gt; and &lt;code&gt;$.unbind&lt;/code&gt; working without problems in dynamically added elements.</source>
          <target state="translated">&lt;code&gt;$.bind&lt;/code&gt; と &lt;code&gt;$.unbind&lt;/code&gt; を動的に追加された要素で問題なく動作させるソリューションを探していました。</target>
        </trans-unit>
        <trans-unit id="121526c28eb4d17e924957f03145fd2a3bc2d327" translate="yes" xml:space="preserve">
          <source>If new HTML is being injected into the page, it is preferable to use delegated events to attach an event handler, as described next.</source>
          <target state="translated">新しいHTMLがページに注入されている場合は、次に説明するように、イベントハンドラをアタッチするためにデリゲートイベントを使用することが望ましいです。</target>
        </trans-unit>
        <trans-unit id="e4ee1c304d91b4ba5db3b6662131800422aa2845" translate="yes" xml:space="preserve">
          <source>In addition to their ability to handle events on descendant elements which are not yet created, another advantage of delegated events is their potential for much lower overhead when many elements must be monitored. On a data table with 1,000 rows in its &lt;code&gt;tbody&lt;/code&gt;, the first code example attaches a handler to 1,000 elements.</source>
          <target state="translated">まだ作成されていない子孫要素のイベントを処理する機能に加えて、委任されたイベントのもう1つの利点は、多くの要素を監視する必要がある場合にオーバーヘッドを大幅に削減できることです。 &lt;code&gt;tbody&lt;/code&gt; に 1,000行があるデータテーブルで、最初のコード例はハンドラーを1,000要素にアタッチします。</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">要するに</target>
        </trans-unit>
        <trans-unit id="55a55d75376d28ae5354a117f07c81ced1f380a0" translate="yes" xml:space="preserve">
          <source>In the above scenario, the MAIN object the jQuery will watch is &quot;container&quot;.</source>
          <target state="translated">上記のシナリオでは、jQueryがウォッチするメインオブジェクトは「コンテナ」です。</target>
        </trans-unit>
        <trans-unit id="3ddf3717de1bf8871ba637caa0e3dbd804ec8fc6" translate="yes" xml:space="preserve">
          <source>It is not working any more, but it was working before. I have been using jQuery from Google &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN&lt;/a&gt;, but I don't know if they changed it.</source>
          <target state="translated">もう機能していませんが、以前は機能していました。 私はGoogle &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDNの&lt;/a&gt; jQueryを使用していますが、変更されたかどうかはわかりません。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="16d7fbf005872626c8808a92955de061d24efd73" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;This will create an event handler instance for each element&lt;/strong&gt; (may affect performance when used in loops)</source>
          <target state="translated">注： &lt;strong&gt;これにより、各要素のイベントハンドラーインスタンスが作成&lt;/strong&gt;されます（ループで使用するとパフォーマンスに影響する可能性があります）</target>
        </trans-unit>
        <trans-unit id="04147083b7d8a7196770879875a0ca9cf282f07f" translate="yes" xml:space="preserve">
          <source>Notice the added &lt;code&gt;*&lt;/code&gt;. An event will be triggered for all children of that element.</source>
          <target state="translated">追加された &lt;code&gt;*&lt;/code&gt; に注意してください。 その要素のすべての子に対してイベントがトリガーされます。</target>
        </trans-unit>
        <trans-unit id="1a7e0e2bd50a0ef759671c87699bcc951dcac085" translate="yes" xml:space="preserve">
          <source>Take note of &quot;MAIN&quot; class the element is placed, for example,</source>
          <target state="translated">例えば、要素が配置されている &quot;MAIN &quot;クラスに注意してください。</target>
        </trans-unit>
        <trans-unit id="2a72daceef89d806147f11539b1d54a9c390a5ab" translate="yes" xml:space="preserve">
          <source>The problem I have is that any select boxes I add via Ajax or DOM after the initial loop won't have the event bound.</source>
          <target state="translated">問題は、最初のループの後にAjaxやDOMで追加したセレクトボックスがイベントバインドされないことです。</target>
        </trans-unit>
        <trans-unit id="979b5ad8b60b8542eef0babcc9943887de13fd59" translate="yes" xml:space="preserve">
          <source>Then you will basically have elements names under container such as &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;li&lt;/code&gt;, and &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">次に、基本的に &lt;code&gt;ul&lt;/code&gt; 、 &lt;code&gt;li&lt;/code&gt; 、 &lt;code&gt;select&lt;/code&gt; などの要素名がコンテナの下にあります 。</target>
        </trans-unit>
        <trans-unit id="59b38c9e93aa7726ab7323559170eed1fcbfe18b" translate="yes" xml:space="preserve">
          <source>There is a good explanation in the documentation of &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;&lt;code&gt;jQuery.fn.on&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/on/&quot;&gt; &lt;code&gt;jQuery.fn.on&lt;/code&gt; &lt;/a&gt;のドキュメントに説明があります。</target>
        </trans-unit>
        <trans-unit id="393b62080db3f3cc932d8c6de03d8c4130e58885" translate="yes" xml:space="preserve">
          <source>This binds itself on the document and will be applicable to the elements that will be rendered after page load.</source>
          <target state="translated">これはそれ自体がドキュメントにバインドされ、ページロード後にレンダリングされる要素に適用されます。</target>
        </trans-unit>
        <trans-unit id="a26f58f69215da3541ad28e6f186f321c1e4c5d7" translate="yes" xml:space="preserve">
          <source>This happens on page ready and works just fine.</source>
          <target state="translated">これは、ページの準備ができているときに発生し、正常に動作します。</target>
        </trans-unit>
        <trans-unit id="03fccd37ed823050c43f5256a26856f5b806cdcd" translate="yes" xml:space="preserve">
          <source>This is a &lt;strong&gt;pure JavaScript&lt;/strong&gt; solution without any libraries or plugins:</source>
          <target state="translated">これは、ライブラリやプラグインのない&lt;strong&gt;純粋なJavaScript&lt;/strong&gt;ソリューションです。</target>
        </trans-unit>
        <trans-unit id="ab54cbd9ffd4bba14eb8fbdb8033b05d53d35bd0" translate="yes" xml:space="preserve">
          <source>This is called &quot;Event Delegation&quot;. Good news, it's a builtin feature in jQuery :-)</source>
          <target state="translated">これは「イベントデリゲーション」と呼ばれています。これはjQueryに組み込まれた機能です。)</target>
        </trans-unit>
        <trans-unit id="46c820f1b2cb216120b87ff216b232a5acd72c52" translate="yes" xml:space="preserve">
          <source>Thus in the following example &lt;code&gt;#dataTable tbody tr&lt;/code&gt; must exist before the code is generated.</source>
          <target state="translated">したがって、次の例では、 &lt;code&gt;#dataTable tbody tr&lt;/code&gt; がコードが生成される前に存在している必要があります。</target>
        </trans-unit>
        <trans-unit id="91c7af6f3bf60017455d98ea1e4ea34dc694a936" translate="yes" xml:space="preserve">
          <source>Try like this way -</source>
          <target state="translated">このようにしてみてください。</target>
        </trans-unit>
        <trans-unit id="10e8f62ba0b5574d62e1072ef78ab99ceb280730" translate="yes" xml:space="preserve">
          <source>Try to use &lt;code&gt;.live()&lt;/code&gt; instead of &lt;code&gt;.bind()&lt;/code&gt;; the &lt;code&gt;.live()&lt;/code&gt; will bind &lt;code&gt;.hover&lt;/code&gt; to your checkbox after the Ajax request executes.</source>
          <target state="translated">&lt;code&gt;.live()&lt;/code&gt; 代わりに &lt;code&gt;.bind()&lt;/code&gt; を使用してください。 &lt;code&gt;.live()&lt;/code&gt; は、Ajaxリクエストの実行後に &lt;code&gt;.hover&lt;/code&gt; をチェックボックスにバインドします。</target>
        </trans-unit>
        <trans-unit id="7b7ce60f27087cdb8816a25d6f46dc0cbcb1f006" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;.on()&lt;/code&gt; method of jQuery &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;http://api.jquery.com/on/&lt;/a&gt; to attach event handlers to live element.</source>
          <target state="translated">jQuery &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;http://api.jquery.com/on/&lt;/a&gt;の &lt;code&gt;.on()&lt;/code&gt; メソッドを使用して、ライブエレメントにイベントハンドラーをアタッチします。</target>
        </trans-unit>
        <trans-unit id="7428279e9da2bd5262728e5675af669aa9658310" translate="yes" xml:space="preserve">
          <source>Using more modern JS, &lt;code&gt;hasClass&lt;/code&gt; can be implemented as:</source>
          <target state="translated">より &lt;code&gt;hasClass&lt;/code&gt; JSを使用すると、 hasClassは次のように実装できます。</target>
        </trans-unit>
        <trans-unit id="32d3c9bfc640d88fdd5921bd366e94eb2506eb4b" translate="yes" xml:space="preserve">
          <source>You can add events to objects when you create them. If you are adding the same events to multiple objects at different times, creating a named function might be the way to go.</source>
          <target state="translated">オブジェクトを作成したときにイベントを追加することができます。複数のオブジェクトに同じイベントを異なるタイミングで追加する場合は、名前付き関数を作成するのが良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="5ecdaaefd58d99b1f8b90be889af14b3fc1cc97b" translate="yes" xml:space="preserve">
          <source>You can attach event to element when dynamically created using &lt;a href=&quot;https://api.jquery.com/jQuery/#jQuery-html-attributes&quot;&gt;&lt;code&gt;jQuery(html, attributes)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/jQuery/#jQuery-html-attributes&quot;&gt; &lt;code&gt;jQuery(html, attributes)&lt;/code&gt; &lt;/a&gt;を使用して動的に作成されたときに、要素にイベントをアタッチできます 。</target>
        </trans-unit>
        <trans-unit id="e058f96e8fbbf0d1d5e0eff215fc238e8278526c" translate="yes" xml:space="preserve">
          <source>You can use the live() method to bind elements (even newly created ones) to events and handlers, like the onclick event.</source>
          <target state="translated">live()メソッドを使って、要素を(新しく作成したものであっても)onclickイベントのようなイベントやハンドラにバインドすることができます。</target>
        </trans-unit>
        <trans-unit id="24e3cbdcb07a60f184ceb7d41c5a224d7c34d445" translate="yes" xml:space="preserve">
          <source>You could simply wrap your event binding call up into a function and then invoke it twice: once on document ready and once after your event that adds the new DOM elements. If you do that you'll want to avoid binding the same event twice on the existing elements so you'll need either unbind the existing events or (better) only bind to the DOM elements that are newly created. The code would look something like this:</source>
          <target state="translated">単純にイベントバインディングの呼び出しを関数にまとめて、それを 2 回呼び出すことができます:1 回はドキュメントの準備ができたときに、もう 1 回は新しい DOM 要素を追加するイベントの後に、です。その場合、既存の要素に同じイベントを二度バインドするのは避けたいので、既存のイベントのバインドを解除するか、(より良い方法で)新しく作成された DOM 要素にのみバインドする必要があります。コードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="5fe10e66f48323f79d7241340dee2b7b5afb7f57" translate="yes" xml:space="preserve">
          <source>see: &lt;a href=&quot;http://api.jquery.com/delegate/&quot;&gt;jQuery Delegate Event&lt;/a&gt;</source>
          <target state="translated">参照： &lt;a href=&quot;http://api.jquery.com/delegate/&quot;&gt;jQuery Delegateイベント&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="268da60403559674a925e83b8f5019a089c41e7e" translate="yes" xml:space="preserve">
          <source>these two methods are equivalent but have a different order of parameters.</source>
          <target state="translated">これら2つの方法は同等ですが、パラメータの順序が異なります。</target>
        </trans-unit>
        <trans-unit id="f4a351527973325870be8cbbdc60883232cdbc1c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;hasClass&lt;/code&gt; is</source>
          <target state="translated">ここで、 &lt;code&gt;hasClass&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="e1aaaf53a6211629990be58cbd8bd15b9fc1d708" translate="yes" xml:space="preserve">
          <source>would apply to</source>
          <target state="translated">に該当する</target>
        </trans-unit>
        <trans-unit id="e65f2d7ea578436d8c5de9d0f81693c839400dd3" translate="yes" xml:space="preserve">
          <source>wrapper-class element can be anything ex. document, body or your wrapper. &lt;strong&gt;Wrapper should already exist&lt;/strong&gt;. However, &lt;code&gt;selector&lt;/code&gt; doesn't necessarily needs to be presented at page loading time. It may come later and the event will bind on &lt;code&gt;selector&lt;/code&gt;&lt;strong&gt;without fail&lt;/strong&gt;.</source>
          <target state="translated">wrapper-class要素は、exなど、何でもかまいません。 ドキュメント、本文、またはラッパー。 &lt;strong&gt;ラッパーはすでに存在して&lt;/strong&gt;いる&lt;strong&gt;はず&lt;/strong&gt;です。 ただし、 &lt;code&gt;selector&lt;/code&gt; は必ずしもページの読み込み時に提示する必要はありません。 後で来る可能性があり、イベントは&lt;strong&gt;必ず&lt;/strong&gt; &lt;code&gt;selector&lt;/code&gt; バインドされます。</target>
        </trans-unit>
        <trans-unit id="71dc20406e9920e5d8c00dc97939bb6e2c087e28" translate="yes" xml:space="preserve">
          <source>you could use</source>
          <target state="translated">使えます</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
