<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/203198">
    <body>
      <group id="203198">
        <trans-unit id="a8972a57acbe818041fa966cc2b28f0cad18bfb0" translate="yes" xml:space="preserve">
          <source>... can be replaced with the following &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;&lt;code&gt;on()&lt;/code&gt;&lt;/a&gt; signature:</source>
          <target state="translated">... может быть заменено следующей подписью &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt; &lt;code&gt;on()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="20a87a21d1dee1ba19a2c9f1d66cddfec7e6bd9f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Credit goes to Dave and Sime Vidas&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Кредит идет на Дейва и Симе Видас&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65137a7187fce4b4490f883134f495f236293189" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/ramswaroop/Nrxp5/28/&quot;&gt;Live demo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/ramswaroop/Nrxp5/28/&quot;&gt;Живая демо&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="575fe48fa4d16cc654b3160eaa356af8d60920af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;This is done by event delegation&lt;/em&gt;&lt;/strong&gt;. Event will bind on wrapper-class element but will be delegated to selector-class element. This is how it works.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Это делается делегированием мероприятия&lt;/em&gt;&lt;/strong&gt; . Событие будет привязано к элементу класса-оболочки, но будет делегировано элементу класса-селектора. Вот как это работает.</target>
        </trans-unit>
        <trans-unit id="4ceac39fa6838552a173a073715a84bd3223cfb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of jQuery 1.7&lt;/strong&gt; you should use &lt;a href=&quot;https://api.jquery.com/on/#on-events-selector-data-handler&quot;&gt;&lt;code&gt;jQuery.fn.on&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Начиная с jQuery 1.7,&lt;/strong&gt; вы должны использовать &lt;a href=&quot;https://api.jquery.com/on/#on-events-selector-data-handler&quot;&gt; &lt;code&gt;jQuery.fn.on&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7cf3ad54791f3845059488958d2790178f82afe4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of jQuery 1.8&lt;/strong&gt;, any jQuery instance method (a method of &lt;code&gt;jQuery.fn&lt;/code&gt;) can be used as a property of the object passed to the
  second parameter:</source>
          <target state="translated">&lt;strong&gt;Начиная с jQuery 1.8&lt;/strong&gt; , любой метод экземпляра jQuery (метод &lt;code&gt;jQuery.fn&lt;/code&gt; ) может использоваться как свойство объекта, передаваемого второму параметру:</target>
        </trans-unit>
        <trans-unit id="8121f33e15ae3270016b626cba0d1f05c03ad837" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Child Element:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Детский элемент:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f858e011c800a6613bd354fb690ab08482220aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Delegated events&lt;/strong&gt; have the advantage that they can process events from descendant elements that are added to the document at a later time. For example, if the table exists, but the rows are added dynamically using code, the following will handle it:</source>
          <target state="translated">Преимущество &lt;strong&gt;делегированных событий&lt;/strong&gt; заключается в том, что они могут обрабатывать события от элементов-потомков, которые добавляются в документ позднее. Например, если таблица существует, но строки добавляются динамически с использованием кода, следующее будет обрабатывать это:</target>
        </trans-unit>
        <trans-unit id="5ad6ec00b70205934534ed66186e46766e431a7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Delegated events do not work for &lt;a href=&quot;http://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; делегированные события не работают для &lt;a href=&quot;http://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1396f709940aace150fc43d0022737a6382f4d9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prior to this&lt;/strong&gt;, the recommended approach was to use &lt;a href=&quot;http://api.jquery.com/live&quot;&gt;&lt;code&gt;live()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;До этого&lt;/strong&gt; рекомендованным подходом было использование &lt;a href=&quot;http://api.jquery.com/live&quot;&gt; &lt;code&gt;live()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="143ccabf09bfc2410ef1aef7440a4c4bf5b74242" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Single element:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Единственный элемент:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e79b4193d9abf560434046dc211121399a27306" translate="yes" xml:space="preserve">
          <source>A delegated-events approach (the second code example) attaches an event handler to only one element, the &lt;code&gt;tbody&lt;/code&gt;, and the event only needs to bubble up one level (from the clicked &lt;code&gt;tr&lt;/code&gt; to &lt;code&gt;tbody&lt;/code&gt;).</source>
          <target state="translated">Подход с делегированными событиями (второй пример кода) прикрепляет обработчик событий только к одному элементу, &lt;code&gt;tbody&lt;/code&gt; , и событие должно подниматься только на один уровень (от нажатого &lt;code&gt;tr&lt;/code&gt; до &lt;code&gt;tbody&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bca51f7c9a8ef157c2eb1f3a0badc598bf24fbdc" translate="yes" xml:space="preserve">
          <source>Also as of version 1.9 &lt;code&gt;.live()&lt;/code&gt; method is removed.</source>
          <target state="translated">Также с версии 1.9 &lt;code&gt;.live()&lt;/code&gt; метод .live () .</target>
        </trans-unit>
        <trans-unit id="520437ca88dd120a5b62eec01ddd5fb91366f135" translate="yes" xml:space="preserve">
          <source>Another flexible solution to create elements and bind events  (&lt;a href=&quot;https://stackoverflow.com/questions/10619445/the-preferred-way-of-creating-a-new-element-with-jquery&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">Еще одно гибкое решение для создания элементов и привязки событий ( &lt;a href=&quot;https://stackoverflow.com/questions/10619445/the-preferred-way-of-creating-a-new-element-with-jquery&quot;&gt;источник&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9564d129a95bb8da226e634ff72c645d32f4388f" translate="yes" xml:space="preserve">
          <source>Another solution is to add the listener when creating the element. Instead of put the listener in the body, you put the listener in the element in the moment that you create it:</source>
          <target state="translated">Другим решением является добавление слушателя при создании элемента.Вместо того,чтобы помещать слушателя в тело,вы помещаете слушателя в элемент в момент его создания:</target>
        </trans-unit>
        <trans-unit id="43044a5260912f835cd862881dbcce424864025a" translate="yes" xml:space="preserve">
          <source>Any p&lt;strong&gt;arent that exists&lt;/strong&gt; at the time the event is bound and if your page was &lt;strong&gt;dynamically creating elements&lt;/strong&gt; with the class name &lt;strong&gt;button&lt;/strong&gt; you would bind the event to a parent which already exists</source>
          <target state="translated">Любая часть, &lt;strong&gt;которая существует&lt;/strong&gt; в то время, когда событие связано, и если бы ваша страница &lt;strong&gt;динамически создавала элементы&lt;/strong&gt; с помощью &lt;strong&gt;кнопки&lt;/strong&gt; имени класса &lt;strong&gt;,&lt;/strong&gt; вы бы связали событие с родительским объектом, который уже существует.</target>
        </trans-unit>
        <trans-unit id="a28fbdb9a58de11fbc1879e841aecb020b6f3a51" translate="yes" xml:space="preserve">
          <source>Any parent that exists at the time the event is bound is fine. For example</source>
          <target state="translated">Любой родитель,который существует на момент привязки события,в порядке.Например</target>
        </trans-unit>
        <trans-unit id="f970c18459a7c2d0b314f828c4413440bf8ad720" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;on()&lt;/a&gt; makes the trick to attach events, in order to create a fake unbind on those I came to:</source>
          <target state="translated">As &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;on ()&lt;/a&gt; делает трюк для прикрепления событий, чтобы создать ложную привязку к тем, к кому я пришел:</target>
        </trans-unit>
        <trans-unit id="0e975b5a75355cd02b8540ca3f3913b901d617aa" translate="yes" xml:space="preserve">
          <source>As a workaround, you have to listen to all clicks and check the source element&amp;nbsp;:</source>
          <target state="translated">В качестве обходного пути вы должны прослушать все клики и проверить элемент источника:</target>
        </trans-unit>
        <trans-unit id="4001dba9ad59edc09c4afd8f7dea4e2524de2fde" translate="yes" xml:space="preserve">
          <source>Bind the event to a parent which already exists:</source>
          <target state="translated">Привязать событие к родителю,который уже существует:</target>
        </trans-unit>
        <trans-unit id="23a669435afc0aec4042f83f8d933fab3832876c" translate="yes" xml:space="preserve">
          <source>Event binding on dynamically created elements</source>
          <target state="translated">Привязка событий к динамически создаваемым элементам</target>
        </trans-unit>
        <trans-unit id="bbae10adc7d50b259bc0e19531b06621889913be" translate="yes" xml:space="preserve">
          <source>Event handlers are bound only to the currently selected elements; they must exist on the page at the time your code makes the call to &lt;code&gt;.on()&lt;/code&gt;.</source>
          <target state="translated">Обработчики событий связаны только с выбранными в данный момент элементами; они должны существовать на странице в тот момент, когда ваш код вызывает &lt;code&gt;.on()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="09a4c4ab2bd8bc5a70d89eb8a77f473ea61d8c69" translate="yes" xml:space="preserve">
          <source>For example, if your page was dynamically creating elements with the class name &lt;code&gt;dosomething&lt;/code&gt; you would bind the event to &lt;strong&gt;a parent which already exists&lt;/strong&gt; (this is the nub of the problem here, you need something that exists to bind to, don't bind to the dynamic content), this can be (and the easiest option) is &lt;code&gt;document&lt;/code&gt;. Though bear in mind &lt;a href=&quot;https://stackoverflow.com/questions/12824549/should-all-jquery-events-be-bound-to-document&quot;&gt;&lt;code&gt;document&lt;/code&gt; may not be the most efficient option&lt;/a&gt;.</source>
          <target state="translated">Например, если на вашей странице динамически создавались элементы с именем класса &lt;code&gt;dosomething&lt;/code&gt; , вы бы связали событие с &lt;strong&gt;уже существующим родителем&lt;/strong&gt; (здесь суть проблемы, вам нужно нечто, с чем можно связываться, не связывайтесь с динамический контент), это может быть (и самый простой вариант) &lt;code&gt;document&lt;/code&gt; . Хотя имейте в виду, что &lt;a href=&quot;https://stackoverflow.com/questions/12824549/should-all-jquery-events-be-bound-to-document&quot;&gt; &lt;code&gt;document&lt;/code&gt; может быть не самым эффективным вариантом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="74d1a19a05c414d5c3d9d18b75ee5e3108b41b64" translate="yes" xml:space="preserve">
          <source>Here is a sample code I have written, where you can see how the live() method binds chosen elements, even newly created ones, to events:</source>
          <target state="translated">Вот пример кода,который я написал,где видно,как метод live()привязывает выбранные элементы,даже вновь созданные,к событиям:</target>
        </trans-unit>
        <trans-unit id="7f010a4d150b400288dc5a4b619b03371e707377" translate="yes" xml:space="preserve">
          <source>Here is why dynamically created elements do not respond to clicks&amp;nbsp;:</source>
          <target state="translated">Вот почему динамически созданные элементы не реагируют на клики:</target>
        </trans-unit>
        <trans-unit id="5c81c0b216fd0f102fb2ba399de807bd3e0bee13" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;live()&lt;/code&gt; was deprecated in 1.7 in favour of &lt;code&gt;on()&lt;/code&gt;, and completely removed in 1.9. The &lt;code&gt;live()&lt;/code&gt; signature:</source>
          <target state="translated">Однако &lt;code&gt;live()&lt;/code&gt; устарела в 1.7 в пользу &lt;code&gt;on()&lt;/code&gt; и полностью удалена в 1.9. Подпись &lt;code&gt;live()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bea31d79a2f1fd37a468570dea30fb2473747abe" translate="yes" xml:space="preserve">
          <source>I have a bit of code where I am looping through all the select boxes on a page and binding a &lt;code&gt;.hover&lt;/code&gt; event to them to do a bit of twiddling with their width on &lt;code&gt;mouse on/off&lt;/code&gt;.</source>
          <target state="translated">У меня есть немного кода, в котором я перебираю все поля выбора на странице и привязываю к ним событие &lt;code&gt;.hover&lt;/code&gt; , чтобы сделать небольшой поворот с их шириной при &lt;code&gt;mouse on/off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0166e850a3cacd1ad5c76193c5748e46bd35cbbc" translate="yes" xml:space="preserve">
          <source>I have found this plugin (&lt;a href=&quot;http://brandonaaron.net/docs/livequery/#getting-started&quot;&gt;jQuery Live Query Plugin&lt;/a&gt;), but before I add another 5k to my pages with a plugin, I want to see if anyone knows a way to do this, either with jQuery directly or by another option.</source>
          <target state="translated">Я нашел этот плагин ( &lt;a href=&quot;http://brandonaaron.net/docs/livequery/#getting-started&quot;&gt;jQuery Live Query Plugin&lt;/a&gt; ), но прежде чем я добавлю еще 5k на мои страницы с помощью плагина, я хочу посмотреть, знает ли кто-нибудь способ сделать это, либо с помощью jQuery напрямую, либо с помощью другого варианта.</target>
        </trans-unit>
        <trans-unit id="ccea30520e256f544ca7731ee1f90989cc557d6b" translate="yes" xml:space="preserve">
          <source>I have noticed that:</source>
          <target state="translated">Я заметил это:</target>
        </trans-unit>
        <trans-unit id="a93ff81926a62d3a9f49d9c2a7c673b736a1ea74" translate="yes" xml:space="preserve">
          <source>I prefer to have event listeners deployed in a modular function fashion rather than scripting a &lt;code&gt;document&lt;/code&gt; level event listener. So, I do like below. &lt;em&gt;Note, you can't oversubscribe an element with the same event listener so don't worry about attaching a listener more than once - only one sticks.&lt;/em&gt;</source>
          <target state="translated">Я предпочитаю, чтобы прослушиватели событий были развернуты в модульном режиме, а не в сценарии прослушивателя событий уровня &lt;code&gt;document&lt;/code&gt; . Итак, мне нравится ниже. &lt;em&gt;Обратите внимание, что вы не можете переподписать элемент с одним и тем же прослушивателем событий, поэтому не беспокойтесь о подключении прослушивателя более одного раза - только одна палочка.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba293bc4610d370b65094817ce4a70833808d6ac" translate="yes" xml:space="preserve">
          <source>I prefer using the selector and I apply it on the document.</source>
          <target state="translated">Я предпочитаю использовать селектор и применять его на документе.</target>
        </trans-unit>
        <trans-unit id="3f633aff3611d5b9a4ec0f1a72062fa2b919ca9d" translate="yes" xml:space="preserve">
          <source>I was looking a solution to get &lt;code&gt;$.bind&lt;/code&gt; and &lt;code&gt;$.unbind&lt;/code&gt; working without problems in dynamically added elements.</source>
          <target state="translated">Я искал решение, чтобы &lt;code&gt;$.bind&lt;/code&gt; и &lt;code&gt;$.unbind&lt;/code&gt; работали без проблем в динамически добавленных элементах.</target>
        </trans-unit>
        <trans-unit id="121526c28eb4d17e924957f03145fd2a3bc2d327" translate="yes" xml:space="preserve">
          <source>If new HTML is being injected into the page, it is preferable to use delegated events to attach an event handler, as described next.</source>
          <target state="translated">Если в страницу вводится новый HTML,предпочтительнее использовать делегированные события для прикрепления обработчика событий,как описано ниже.</target>
        </trans-unit>
        <trans-unit id="e4ee1c304d91b4ba5db3b6662131800422aa2845" translate="yes" xml:space="preserve">
          <source>In addition to their ability to handle events on descendant elements which are not yet created, another advantage of delegated events is their potential for much lower overhead when many elements must be monitored. On a data table with 1,000 rows in its &lt;code&gt;tbody&lt;/code&gt;, the first code example attaches a handler to 1,000 elements.</source>
          <target state="translated">В дополнение к их способности обрабатывать события на дочерних элементах, которые еще не созданы, еще одним преимуществом делегированных событий является их возможность значительно снизить накладные расходы, когда необходимо отслеживать многие элементы. В таблице данных с 1000 строк в своем &lt;code&gt;tbody&lt;/code&gt; , первый пример кода присоединяет обработчик к 1000 элементам.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">Короче говоря:</target>
        </trans-unit>
        <trans-unit id="55a55d75376d28ae5354a117f07c81ced1f380a0" translate="yes" xml:space="preserve">
          <source>In the above scenario, the MAIN object the jQuery will watch is &quot;container&quot;.</source>
          <target state="translated">В вышеприведенном сценарии объект MAIN,который будет смотреть jQuery-&quot;контейнер&quot;.</target>
        </trans-unit>
        <trans-unit id="3ddf3717de1bf8871ba637caa0e3dbd804ec8fc6" translate="yes" xml:space="preserve">
          <source>It is not working any more, but it was working before. I have been using jQuery from Google &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN&lt;/a&gt;, but I don't know if they changed it.</source>
          <target state="translated">Он больше не работает, но работал раньше. Я использовал jQuery из Google &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN&lt;/a&gt; , но я не знаю, изменили ли они его.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="16d7fbf005872626c8808a92955de061d24efd73" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;This will create an event handler instance for each element&lt;/strong&gt; (may affect performance when used in loops)</source>
          <target state="translated">Примечание: &lt;strong&gt;это создаст экземпляр обработчика событий для каждого элемента&lt;/strong&gt; (может повлиять на производительность при использовании в циклах)</target>
        </trans-unit>
        <trans-unit id="04147083b7d8a7196770879875a0ca9cf282f07f" translate="yes" xml:space="preserve">
          <source>Notice the added &lt;code&gt;*&lt;/code&gt;. An event will be triggered for all children of that element.</source>
          <target state="translated">Обратите внимание на добавленные &lt;code&gt;*&lt;/code&gt; . Событие будет запущено для всех дочерних элементов этого элемента.</target>
        </trans-unit>
        <trans-unit id="1a7e0e2bd50a0ef759671c87699bcc951dcac085" translate="yes" xml:space="preserve">
          <source>Take note of &quot;MAIN&quot; class the element is placed, for example,</source>
          <target state="translated">Обратите внимание на класс &quot;MAIN&quot;,в котором находится элемент,</target>
        </trans-unit>
        <trans-unit id="2a72daceef89d806147f11539b1d54a9c390a5ab" translate="yes" xml:space="preserve">
          <source>The problem I have is that any select boxes I add via Ajax or DOM after the initial loop won't have the event bound.</source>
          <target state="translated">Проблема заключается в том,что любые поля выбора,которые я добавляю через Ajax или DOM после начального цикла,не будут привязаны к событию.</target>
        </trans-unit>
        <trans-unit id="979b5ad8b60b8542eef0babcc9943887de13fd59" translate="yes" xml:space="preserve">
          <source>Then you will basically have elements names under container such as &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;li&lt;/code&gt;, and &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">Тогда у вас будут в основном имена элементов в контейнере, такие как &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;li&lt;/code&gt; , и &lt;code&gt;select&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="59b38c9e93aa7726ab7323559170eed1fcbfe18b" translate="yes" xml:space="preserve">
          <source>There is a good explanation in the documentation of &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;&lt;code&gt;jQuery.fn.on&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В документации &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt; &lt;code&gt;jQuery.fn.on&lt;/code&gt; &lt;/a&gt; есть хорошее объяснение.</target>
        </trans-unit>
        <trans-unit id="393b62080db3f3cc932d8c6de03d8c4130e58885" translate="yes" xml:space="preserve">
          <source>This binds itself on the document and will be applicable to the elements that will be rendered after page load.</source>
          <target state="translated">Это привязывается к документу и будет применяться к элементам,которые будут отображаться после загрузки страницы.</target>
        </trans-unit>
        <trans-unit id="a26f58f69215da3541ad28e6f186f321c1e4c5d7" translate="yes" xml:space="preserve">
          <source>This happens on page ready and works just fine.</source>
          <target state="translated">Это происходит на странице готово и работает просто отлично.</target>
        </trans-unit>
        <trans-unit id="03fccd37ed823050c43f5256a26856f5b806cdcd" translate="yes" xml:space="preserve">
          <source>This is a &lt;strong&gt;pure JavaScript&lt;/strong&gt; solution without any libraries or plugins:</source>
          <target state="translated">Это &lt;strong&gt;чистое&lt;/strong&gt; решение &lt;strong&gt;JavaScript&lt;/strong&gt; без каких-либо библиотек или плагинов:</target>
        </trans-unit>
        <trans-unit id="ab54cbd9ffd4bba14eb8fbdb8033b05d53d35bd0" translate="yes" xml:space="preserve">
          <source>This is called &quot;Event Delegation&quot;. Good news, it's a builtin feature in jQuery :-)</source>
          <target state="translated">Это называется &quot;Делегирование мероприятий&quot;.Хорошие новости,это встроенная функция в jQuery :-).</target>
        </trans-unit>
        <trans-unit id="46c820f1b2cb216120b87ff216b232a5acd72c52" translate="yes" xml:space="preserve">
          <source>Thus in the following example &lt;code&gt;#dataTable tbody tr&lt;/code&gt; must exist before the code is generated.</source>
          <target state="translated">Таким образом, в следующем примере &lt;code&gt;#dataTable tbody tr&lt;/code&gt; должен существовать до генерации кода.</target>
        </trans-unit>
        <trans-unit id="91c7af6f3bf60017455d98ea1e4ea34dc694a936" translate="yes" xml:space="preserve">
          <source>Try like this way -</source>
          <target state="translated">Попробуйте вот так -</target>
        </trans-unit>
        <trans-unit id="10e8f62ba0b5574d62e1072ef78ab99ceb280730" translate="yes" xml:space="preserve">
          <source>Try to use &lt;code&gt;.live()&lt;/code&gt; instead of &lt;code&gt;.bind()&lt;/code&gt;; the &lt;code&gt;.live()&lt;/code&gt; will bind &lt;code&gt;.hover&lt;/code&gt; to your checkbox after the Ajax request executes.</source>
          <target state="translated">Попробуйте использовать &lt;code&gt;.live()&lt;/code&gt; вместо &lt;code&gt;.bind()&lt;/code&gt; ; &lt;code&gt;.live()&lt;/code&gt; свяжет &lt;code&gt;.hover&lt;/code&gt; с вашим флажком после выполнения Ajax-запроса.</target>
        </trans-unit>
        <trans-unit id="7b7ce60f27087cdb8816a25d6f46dc0cbcb1f006" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;.on()&lt;/code&gt; method of jQuery &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;http://api.jquery.com/on/&lt;/a&gt; to attach event handlers to live element.</source>
          <target state="translated">Используйте метод &lt;code&gt;.on()&lt;/code&gt; jQuery &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;http://api.jquery.com/on/,&lt;/a&gt; чтобы прикрепить обработчики событий к активному элементу.</target>
        </trans-unit>
        <trans-unit id="7428279e9da2bd5262728e5675af669aa9658310" translate="yes" xml:space="preserve">
          <source>Using more modern JS, &lt;code&gt;hasClass&lt;/code&gt; can be implemented as:</source>
          <target state="translated">Используя более современный JS, &lt;code&gt;hasClass&lt;/code&gt; может быть реализован как:</target>
        </trans-unit>
        <trans-unit id="32d3c9bfc640d88fdd5921bd366e94eb2506eb4b" translate="yes" xml:space="preserve">
          <source>You can add events to objects when you create them. If you are adding the same events to multiple objects at different times, creating a named function might be the way to go.</source>
          <target state="translated">Вы можете добавлять события к объектам при их создании.Если вы добавляете одни и те же события к нескольким объектам в разное время,создание именованной функции может быть способом.</target>
        </trans-unit>
        <trans-unit id="5ecdaaefd58d99b1f8b90be889af14b3fc1cc97b" translate="yes" xml:space="preserve">
          <source>You can attach event to element when dynamically created using &lt;a href=&quot;https://api.jquery.com/jQuery/#jQuery-html-attributes&quot;&gt;&lt;code&gt;jQuery(html, attributes)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вы можете прикрепить событие к элементу при динамическом создании с использованием &lt;a href=&quot;https://api.jquery.com/jQuery/#jQuery-html-attributes&quot;&gt; &lt;code&gt;jQuery(html, attributes)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e058f96e8fbbf0d1d5e0eff215fc238e8278526c" translate="yes" xml:space="preserve">
          <source>You can use the live() method to bind elements (even newly created ones) to events and handlers, like the onclick event.</source>
          <target state="translated">Вы можете использовать метод live()для привязки элементов (даже только что созданных)к событиям и обработчикам,например,к событию клика.</target>
        </trans-unit>
        <trans-unit id="24e3cbdcb07a60f184ceb7d41c5a224d7c34d445" translate="yes" xml:space="preserve">
          <source>You could simply wrap your event binding call up into a function and then invoke it twice: once on document ready and once after your event that adds the new DOM elements. If you do that you'll want to avoid binding the same event twice on the existing elements so you'll need either unbind the existing events or (better) only bind to the DOM elements that are newly created. The code would look something like this:</source>
          <target state="translated">Вы можете просто завернуть вызов привязки событий в функцию,а затем вызвать ее дважды:один раз на готовый документ и один раз после события,которое добавляет новые DOM-элементы.Если вы сделаете это,вы захотите избежать привязки одного и того же события дважды к существующим элементам,поэтому вам придется либо развязывать существующие события,либо (лучше)привязывать только к вновь создаваемым элементам DOM.Код будет выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="5fe10e66f48323f79d7241340dee2b7b5afb7f57" translate="yes" xml:space="preserve">
          <source>see: &lt;a href=&quot;http://api.jquery.com/delegate/&quot;&gt;jQuery Delegate Event&lt;/a&gt;</source>
          <target state="translated">см .: &lt;a href=&quot;http://api.jquery.com/delegate/&quot;&gt;jQuery Delegate Event&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="268da60403559674a925e83b8f5019a089c41e7e" translate="yes" xml:space="preserve">
          <source>these two methods are equivalent but have a different order of parameters.</source>
          <target state="translated">эти два метода эквивалентны,но имеют разный порядок параметров.</target>
        </trans-unit>
        <trans-unit id="f4a351527973325870be8cbbdc60883232cdbc1c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;hasClass&lt;/code&gt; is</source>
          <target state="translated">где &lt;code&gt;hasClass&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1aaaf53a6211629990be58cbd8bd15b9fc1d708" translate="yes" xml:space="preserve">
          <source>would apply to</source>
          <target state="translated">распространялся бы на</target>
        </trans-unit>
        <trans-unit id="e65f2d7ea578436d8c5de9d0f81693c839400dd3" translate="yes" xml:space="preserve">
          <source>wrapper-class element can be anything ex. document, body or your wrapper. &lt;strong&gt;Wrapper should already exist&lt;/strong&gt;. However, &lt;code&gt;selector&lt;/code&gt; doesn't necessarily needs to be presented at page loading time. It may come later and the event will bind on &lt;code&gt;selector&lt;/code&gt;&lt;strong&gt;without fail&lt;/strong&gt;.</source>
          <target state="translated">Элемент класса-обертки может быть чем угодно. документ, тело или ваша обертка. &lt;strong&gt;Оболочка уже должна существовать&lt;/strong&gt; . Однако &lt;code&gt;selector&lt;/code&gt; не обязательно должен быть представлен во время загрузки страницы. Это может произойти позже, и событие обязательно свяжется с &lt;code&gt;selector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71dc20406e9920e5d8c00dc97939bb6e2c087e28" translate="yes" xml:space="preserve">
          <source>you could use</source>
          <target state="translated">вам не помешает</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
