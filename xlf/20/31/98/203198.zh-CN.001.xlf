<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/203198">
    <body>
      <group id="203198">
        <trans-unit id="a8972a57acbe818041fa966cc2b28f0cad18bfb0" translate="yes" xml:space="preserve">
          <source>... can be replaced with the following &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;&lt;code&gt;on()&lt;/code&gt;&lt;/a&gt; signature:</source>
          <target state="translated">...可以替换为以下&lt;a href=&quot;http://api.jquery.com/on/&quot;&gt; &lt;code&gt;on()&lt;/code&gt; &lt;/a&gt;签名：</target>
        </trans-unit>
        <trans-unit id="20a87a21d1dee1ba19a2c9f1d66cddfec7e6bd9f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Credit goes to Dave and Sime Vidas&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;归功于Dave和Sime Vidas&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65137a7187fce4b4490f883134f495f236293189" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/ramswaroop/Nrxp5/28/&quot;&gt;Live demo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/ramswaroop/Nrxp5/28/&quot;&gt;现场演示&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="575fe48fa4d16cc654b3160eaa356af8d60920af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;This is done by event delegation&lt;/em&gt;&lt;/strong&gt;. Event will bind on wrapper-class element but will be delegated to selector-class element. This is how it works.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;这是通过事件委托完成的&lt;/em&gt;&lt;/strong&gt; 。 事件将绑定在包装类元素上，但将委派给选择器类元素。 这就是它的工作方式。</target>
        </trans-unit>
        <trans-unit id="4ceac39fa6838552a173a073715a84bd3223cfb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of jQuery 1.7&lt;/strong&gt; you should use &lt;a href=&quot;https://api.jquery.com/on/#on-events-selector-data-handler&quot;&gt;&lt;code&gt;jQuery.fn.on&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;从jQuery 1.7开始，&lt;/strong&gt;您应该使用&lt;a href=&quot;https://api.jquery.com/on/#on-events-selector-data-handler&quot;&gt; &lt;code&gt;jQuery.fn.on&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="7cf3ad54791f3845059488958d2790178f82afe4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of jQuery 1.8&lt;/strong&gt;, any jQuery instance method (a method of &lt;code&gt;jQuery.fn&lt;/code&gt;) can be used as a property of the object passed to the
  second parameter:</source>
          <target state="translated">&lt;strong&gt;从jQuery 1.8开始&lt;/strong&gt; ，任何jQuery实例方法（ &lt;code&gt;jQuery.fn&lt;/code&gt; 的方法）都可以用作传递给第二个参数的对象的属性：</target>
        </trans-unit>
        <trans-unit id="8121f33e15ae3270016b626cba0d1f05c03ad837" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Child Element:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;子元素：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f858e011c800a6613bd354fb690ab08482220aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Delegated events&lt;/strong&gt; have the advantage that they can process events from descendant elements that are added to the document at a later time. For example, if the table exists, but the rows are added dynamically using code, the following will handle it:</source>
          <target state="translated">&lt;strong&gt;委派事件&lt;/strong&gt;的优势在于，它们可以处理以后在以后添加到文档中的后代元素中的事件。 例如，如果该表存在，但是使用代码动态添加了行，则将通过以下方式进行处理：</target>
        </trans-unit>
        <trans-unit id="5ad6ec00b70205934534ed66186e46766e431a7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Delegated events do not work for &lt;a href=&quot;http://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;委托事件不适用于&lt;a href=&quot;http://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="1396f709940aace150fc43d0022737a6382f4d9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prior to this&lt;/strong&gt;, the recommended approach was to use &lt;a href=&quot;http://api.jquery.com/live&quot;&gt;&lt;code&gt;live()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;在此之前&lt;/strong&gt; ，推荐的方法是使用&lt;a href=&quot;http://api.jquery.com/live&quot;&gt; &lt;code&gt;live()&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="143ccabf09bfc2410ef1aef7440a4c4bf5b74242" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Single element:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;单个元素：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e79b4193d9abf560434046dc211121399a27306" translate="yes" xml:space="preserve">
          <source>A delegated-events approach (the second code example) attaches an event handler to only one element, the &lt;code&gt;tbody&lt;/code&gt;, and the event only needs to bubble up one level (from the clicked &lt;code&gt;tr&lt;/code&gt; to &lt;code&gt;tbody&lt;/code&gt;).</source>
          <target state="translated">委托事件方法（第二个代码示例）将事件处理程序仅附加到一个元素 &lt;code&gt;tbody&lt;/code&gt; ，事件仅需要起泡一个级别（从单击的 &lt;code&gt;tr&lt;/code&gt; 到 &lt;code&gt;tbody&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bca51f7c9a8ef157c2eb1f3a0badc598bf24fbdc" translate="yes" xml:space="preserve">
          <source>Also as of version 1.9 &lt;code&gt;.live()&lt;/code&gt; method is removed.</source>
          <target state="translated">从1.9版本开始， &lt;code&gt;.live()&lt;/code&gt; 方法也被删除。</target>
        </trans-unit>
        <trans-unit id="520437ca88dd120a5b62eec01ddd5fb91366f135" translate="yes" xml:space="preserve">
          <source>Another flexible solution to create elements and bind events  (&lt;a href=&quot;https://stackoverflow.com/questions/10619445/the-preferred-way-of-creating-a-new-element-with-jquery&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">创建元素和绑定事件的另一种灵活解决方案（ &lt;a href=&quot;https://stackoverflow.com/questions/10619445/the-preferred-way-of-creating-a-new-element-with-jquery&quot;&gt;源&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="9564d129a95bb8da226e634ff72c645d32f4388f" translate="yes" xml:space="preserve">
          <source>Another solution is to add the listener when creating the element. Instead of put the listener in the body, you put the listener in the element in the moment that you create it:</source>
          <target state="translated">另一个解决方案是在创建元素时添加监听器。不把监听器放在主体中,而是在创建元素的瞬间把监听器放在元素中。</target>
        </trans-unit>
        <trans-unit id="43044a5260912f835cd862881dbcce424864025a" translate="yes" xml:space="preserve">
          <source>Any p&lt;strong&gt;arent that exists&lt;/strong&gt; at the time the event is bound and if your page was &lt;strong&gt;dynamically creating elements&lt;/strong&gt; with the class name &lt;strong&gt;button&lt;/strong&gt; you would bind the event to a parent which already exists</source>
          <target state="translated">绑定事件时&lt;strong&gt;存在的&lt;/strong&gt;任何内容&lt;strong&gt;，&lt;/strong&gt;并且如果您的页面正在使用类名&lt;strong&gt;按钮&lt;/strong&gt; &lt;strong&gt;动态创建元素&lt;/strong&gt; ，则会将事件绑定到已存在的父对象上</target>
        </trans-unit>
        <trans-unit id="a28fbdb9a58de11fbc1879e841aecb020b6f3a51" translate="yes" xml:space="preserve">
          <source>Any parent that exists at the time the event is bound is fine. For example</source>
          <target state="translated">任何在事件绑定时存在的父节点都可以。举例来说</target>
        </trans-unit>
        <trans-unit id="f970c18459a7c2d0b314f828c4413440bf8ad720" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;on()&lt;/a&gt; makes the trick to attach events, in order to create a fake unbind on those I came to:</source>
          <target state="translated">由于&lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;on（）&lt;/a&gt;会引发附加事件的技巧，以便在我来到的事件上创建假的取消绑定：</target>
        </trans-unit>
        <trans-unit id="0e975b5a75355cd02b8540ca3f3913b901d617aa" translate="yes" xml:space="preserve">
          <source>As a workaround, you have to listen to all clicks and check the source element&amp;nbsp;:</source>
          <target state="translated">解决方法是，您必须听所有点击并检查source元素：</target>
        </trans-unit>
        <trans-unit id="4001dba9ad59edc09c4afd8f7dea4e2524de2fde" translate="yes" xml:space="preserve">
          <source>Bind the event to a parent which already exists:</source>
          <target state="translated">将事件绑定到已经存在的父体上。</target>
        </trans-unit>
        <trans-unit id="23a669435afc0aec4042f83f8d933fab3832876c" translate="yes" xml:space="preserve">
          <source>Event binding on dynamically created elements</source>
          <target state="translated">动态创建元素的事件绑定</target>
        </trans-unit>
        <trans-unit id="bbae10adc7d50b259bc0e19531b06621889913be" translate="yes" xml:space="preserve">
          <source>Event handlers are bound only to the currently selected elements; they must exist on the page at the time your code makes the call to &lt;code&gt;.on()&lt;/code&gt;.</source>
          <target state="translated">事件处理程序仅绑定到当前选定的元素。 它们必须在您的代码调用 &lt;code&gt;.on()&lt;/code&gt; 时在页面上存在。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="09a4c4ab2bd8bc5a70d89eb8a77f473ea61d8c69" translate="yes" xml:space="preserve">
          <source>For example, if your page was dynamically creating elements with the class name &lt;code&gt;dosomething&lt;/code&gt; you would bind the event to &lt;strong&gt;a parent which already exists&lt;/strong&gt; (this is the nub of the problem here, you need something that exists to bind to, don't bind to the dynamic content), this can be (and the easiest option) is &lt;code&gt;document&lt;/code&gt;. Though bear in mind &lt;a href=&quot;https://stackoverflow.com/questions/12824549/should-all-jquery-events-be-bound-to-document&quot;&gt;&lt;code&gt;document&lt;/code&gt; may not be the most efficient option&lt;/a&gt;.</source>
          <target state="translated">例如，如果您的页面正在动态创建具有类名称 &lt;code&gt;dosomething&lt;/code&gt; 的元素，则可以将事件绑定到&lt;strong&gt;已经存在的父级&lt;/strong&gt; （这是问题的小结，您需要绑定到现有的东西，而不要绑定到动态内容），这可以（也是最简单的选择）是 &lt;code&gt;document&lt;/code&gt; 。 尽管记住&lt;a href=&quot;https://stackoverflow.com/questions/12824549/should-all-jquery-events-be-bound-to-document&quot;&gt; &lt;code&gt;document&lt;/code&gt; 可能不是最有效的选择&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="74d1a19a05c414d5c3d9d18b75ee5e3108b41b64" translate="yes" xml:space="preserve">
          <source>Here is a sample code I have written, where you can see how the live() method binds chosen elements, even newly created ones, to events:</source>
          <target state="translated">下面是我写的一个示例代码,在这里你可以看到live()方法是如何将选定的元素(即使是新创建的元素)与事件绑定的。</target>
        </trans-unit>
        <trans-unit id="7f010a4d150b400288dc5a4b619b03371e707377" translate="yes" xml:space="preserve">
          <source>Here is why dynamically created elements do not respond to clicks&amp;nbsp;:</source>
          <target state="translated">这就是为什么动态创建的元素不响应点击的原因：</target>
        </trans-unit>
        <trans-unit id="5c81c0b216fd0f102fb2ba399de807bd3e0bee13" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;live()&lt;/code&gt; was deprecated in 1.7 in favour of &lt;code&gt;on()&lt;/code&gt;, and completely removed in 1.9. The &lt;code&gt;live()&lt;/code&gt; signature:</source>
          <target state="translated">但是， &lt;code&gt;live()&lt;/code&gt; 在1.7中弃用了 &lt;code&gt;on()&lt;/code&gt; ，在1.9中已将其完全删除。 &lt;code&gt;live()&lt;/code&gt; 签名：</target>
        </trans-unit>
        <trans-unit id="bea31d79a2f1fd37a468570dea30fb2473747abe" translate="yes" xml:space="preserve">
          <source>I have a bit of code where I am looping through all the select boxes on a page and binding a &lt;code&gt;.hover&lt;/code&gt; event to them to do a bit of twiddling with their width on &lt;code&gt;mouse on/off&lt;/code&gt;.</source>
          <target state="translated">我有一些代码，我在其中循环浏览页面上的所有选择框，并将 &lt;code&gt;.hover&lt;/code&gt; 事件绑定到它们，以便在 &lt;code&gt;mouse on/off&lt;/code&gt; 对其宽度进行一些调整。</target>
        </trans-unit>
        <trans-unit id="0166e850a3cacd1ad5c76193c5748e46bd35cbbc" translate="yes" xml:space="preserve">
          <source>I have found this plugin (&lt;a href=&quot;http://brandonaaron.net/docs/livequery/#getting-started&quot;&gt;jQuery Live Query Plugin&lt;/a&gt;), but before I add another 5k to my pages with a plugin, I want to see if anyone knows a way to do this, either with jQuery directly or by another option.</source>
          <target state="translated">我已经找到了这个插件（ &lt;a href=&quot;http://brandonaaron.net/docs/livequery/#getting-started&quot;&gt;jQuery Live Query Plugin&lt;/a&gt; ），但是在我使用插件向页面添加另外的5k之前，我想看看是否有人知道直接使用jQuery还是通过其他方法做到这一点。</target>
        </trans-unit>
        <trans-unit id="ccea30520e256f544ca7731ee1f90989cc557d6b" translate="yes" xml:space="preserve">
          <source>I have noticed that:</source>
          <target state="translated">我注意到了这一点。</target>
        </trans-unit>
        <trans-unit id="a93ff81926a62d3a9f49d9c2a7c673b736a1ea74" translate="yes" xml:space="preserve">
          <source>I prefer to have event listeners deployed in a modular function fashion rather than scripting a &lt;code&gt;document&lt;/code&gt; level event listener. So, I do like below. &lt;em&gt;Note, you can't oversubscribe an element with the same event listener so don't worry about attaching a listener more than once - only one sticks.&lt;/em&gt;</source>
          <target state="translated">我更喜欢以模块化功能的方式部署事件侦听器，而不是编写 &lt;code&gt;document&lt;/code&gt; 级事件侦听器的脚本。 因此，我喜欢以下内容。 &lt;em&gt;请注意，您不能为具有相同事件监听器的元素超额预订，因此不必担心附加监听器不止一次-只能一根棍子。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba293bc4610d370b65094817ce4a70833808d6ac" translate="yes" xml:space="preserve">
          <source>I prefer using the selector and I apply it on the document.</source>
          <target state="translated">我更喜欢使用选择器,我把它应用在文档上。</target>
        </trans-unit>
        <trans-unit id="3f633aff3611d5b9a4ec0f1a72062fa2b919ca9d" translate="yes" xml:space="preserve">
          <source>I was looking a solution to get &lt;code&gt;$.bind&lt;/code&gt; and &lt;code&gt;$.unbind&lt;/code&gt; working without problems in dynamically added elements.</source>
          <target state="translated">我正在寻找一种解决方案，以使 &lt;code&gt;$.bind&lt;/code&gt; 和 &lt;code&gt;$.unbind&lt;/code&gt; 能够在动态添加的元素中正常工作。</target>
        </trans-unit>
        <trans-unit id="121526c28eb4d17e924957f03145fd2a3bc2d327" translate="yes" xml:space="preserve">
          <source>If new HTML is being injected into the page, it is preferable to use delegated events to attach an event handler, as described next.</source>
          <target state="translated">如果新的HTML被注入到页面中,最好使用委托事件来附加一个事件处理程序,如下文所述。</target>
        </trans-unit>
        <trans-unit id="e4ee1c304d91b4ba5db3b6662131800422aa2845" translate="yes" xml:space="preserve">
          <source>In addition to their ability to handle events on descendant elements which are not yet created, another advantage of delegated events is their potential for much lower overhead when many elements must be monitored. On a data table with 1,000 rows in its &lt;code&gt;tbody&lt;/code&gt;, the first code example attaches a handler to 1,000 elements.</source>
          <target state="translated">除了具有处理尚未创建的后代元素上的事件的能力外，委托事件的另一个优点是，当必须监视许多元素时，它们有可能大大降低开销。 在其 &lt;code&gt;tbody&lt;/code&gt; 中具有1,000行的数据表上，第一个代码示例将处理程序附加到1,000个元素。</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">简而言之。</target>
        </trans-unit>
        <trans-unit id="55a55d75376d28ae5354a117f07c81ced1f380a0" translate="yes" xml:space="preserve">
          <source>In the above scenario, the MAIN object the jQuery will watch is &quot;container&quot;.</source>
          <target state="translated">在上面的场景中,jQuery要看的主要对象是 &quot;容器&quot;。</target>
        </trans-unit>
        <trans-unit id="3ddf3717de1bf8871ba637caa0e3dbd804ec8fc6" translate="yes" xml:space="preserve">
          <source>It is not working any more, but it was working before. I have been using jQuery from Google &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN&lt;/a&gt;, but I don't know if they changed it.</source>
          <target state="translated">它不再工作了，但是以前已经工作了。 我一直在使用Google &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN的&lt;/a&gt; jQuery，但不知道他们是否更改了它。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="16d7fbf005872626c8808a92955de061d24efd73" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;This will create an event handler instance for each element&lt;/strong&gt; (may affect performance when used in loops)</source>
          <target state="translated">注意： &lt;strong&gt;这将为每个元素创建一个事件处理程序实例&lt;/strong&gt; （在循环中使用时可能会影响性能）</target>
        </trans-unit>
        <trans-unit id="04147083b7d8a7196770879875a0ca9cf282f07f" translate="yes" xml:space="preserve">
          <source>Notice the added &lt;code&gt;*&lt;/code&gt;. An event will be triggered for all children of that element.</source>
          <target state="translated">请注意添加的 &lt;code&gt;*&lt;/code&gt; 。 该元素的所有子级都会触发一个事件。</target>
        </trans-unit>
        <trans-unit id="1a7e0e2bd50a0ef759671c87699bcc951dcac085" translate="yes" xml:space="preserve">
          <source>Take note of &quot;MAIN&quot; class the element is placed, for example,</source>
          <target state="translated">注意元素放置的 &quot;MAIN &quot;类,例如。</target>
        </trans-unit>
        <trans-unit id="2a72daceef89d806147f11539b1d54a9c390a5ab" translate="yes" xml:space="preserve">
          <source>The problem I have is that any select boxes I add via Ajax or DOM after the initial loop won't have the event bound.</source>
          <target state="translated">我遇到的问题是,在初始循环后,我通过Ajax或DOM添加的任何选择框都不会有事件绑定。</target>
        </trans-unit>
        <trans-unit id="979b5ad8b60b8542eef0babcc9943887de13fd59" translate="yes" xml:space="preserve">
          <source>Then you will basically have elements names under container such as &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;li&lt;/code&gt;, and &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">然后，您将基本上在 &lt;code&gt;ul&lt;/code&gt; ， &lt;code&gt;li&lt;/code&gt; 等容器下具有元素名称，然后 &lt;code&gt;select&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="59b38c9e93aa7726ab7323559170eed1fcbfe18b" translate="yes" xml:space="preserve">
          <source>There is a good explanation in the documentation of &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;&lt;code&gt;jQuery.fn.on&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;http://api.jquery.com/on/&quot;&gt; &lt;code&gt;jQuery.fn.on&lt;/code&gt; &lt;/a&gt;的文档中有很好的解释。</target>
        </trans-unit>
        <trans-unit id="393b62080db3f3cc932d8c6de03d8c4130e58885" translate="yes" xml:space="preserve">
          <source>This binds itself on the document and will be applicable to the elements that will be rendered after page load.</source>
          <target state="translated">这将绑定在文档上,并将适用于页面加载后渲染的元素。</target>
        </trans-unit>
        <trans-unit id="a26f58f69215da3541ad28e6f186f321c1e4c5d7" translate="yes" xml:space="preserve">
          <source>This happens on page ready and works just fine.</source>
          <target state="translated">这种情况发生在准备好的页面上,效果很好。</target>
        </trans-unit>
        <trans-unit id="03fccd37ed823050c43f5256a26856f5b806cdcd" translate="yes" xml:space="preserve">
          <source>This is a &lt;strong&gt;pure JavaScript&lt;/strong&gt; solution without any libraries or plugins:</source>
          <target state="translated">这是一个&lt;strong&gt;纯JavaScript&lt;/strong&gt;解决方案，没有任何库或插件：</target>
        </trans-unit>
        <trans-unit id="ab54cbd9ffd4bba14eb8fbdb8033b05d53d35bd0" translate="yes" xml:space="preserve">
          <source>This is called &quot;Event Delegation&quot;. Good news, it's a builtin feature in jQuery :-)</source>
          <target state="translated">这就是所谓的 &quot;事件委托&quot;。好消息,这是jQuery中的一个内置功能:-)</target>
        </trans-unit>
        <trans-unit id="46c820f1b2cb216120b87ff216b232a5acd72c52" translate="yes" xml:space="preserve">
          <source>Thus in the following example &lt;code&gt;#dataTable tbody tr&lt;/code&gt; must exist before the code is generated.</source>
          <target state="translated">因此，在以下示例中，在生成代码之前， &lt;code&gt;#dataTable tbody tr&lt;/code&gt; 必须存在。</target>
        </trans-unit>
        <trans-unit id="91c7af6f3bf60017455d98ea1e4ea34dc694a936" translate="yes" xml:space="preserve">
          <source>Try like this way -</source>
          <target state="translated">试试这样的方式</target>
        </trans-unit>
        <trans-unit id="10e8f62ba0b5574d62e1072ef78ab99ceb280730" translate="yes" xml:space="preserve">
          <source>Try to use &lt;code&gt;.live()&lt;/code&gt; instead of &lt;code&gt;.bind()&lt;/code&gt;; the &lt;code&gt;.live()&lt;/code&gt; will bind &lt;code&gt;.hover&lt;/code&gt; to your checkbox after the Ajax request executes.</source>
          <target state="translated">尝试使用 &lt;code&gt;.live()&lt;/code&gt; 而不是 &lt;code&gt;.bind()&lt;/code&gt; ; 在执行Ajax请求之后， &lt;code&gt;.live()&lt;/code&gt; 会将 &lt;code&gt;.hover&lt;/code&gt; 绑定到您的复选框。</target>
        </trans-unit>
        <trans-unit id="7b7ce60f27087cdb8816a25d6f46dc0cbcb1f006" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;.on()&lt;/code&gt; method of jQuery &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;http://api.jquery.com/on/&lt;/a&gt; to attach event handlers to live element.</source>
          <target state="translated">使用jQuery &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;http://api.jquery.com/on/&lt;/a&gt;的 &lt;code&gt;.on()&lt;/code&gt; 方法将事件处理程序附加到实时元素。</target>
        </trans-unit>
        <trans-unit id="7428279e9da2bd5262728e5675af669aa9658310" translate="yes" xml:space="preserve">
          <source>Using more modern JS, &lt;code&gt;hasClass&lt;/code&gt; can be implemented as:</source>
          <target state="translated">使用更现代的JS， &lt;code&gt;hasClass&lt;/code&gt; 可以实现为：</target>
        </trans-unit>
        <trans-unit id="32d3c9bfc640d88fdd5921bd366e94eb2506eb4b" translate="yes" xml:space="preserve">
          <source>You can add events to objects when you create them. If you are adding the same events to multiple objects at different times, creating a named function might be the way to go.</source>
          <target state="translated">你可以在创建对象时将事件添加到对象中。如果你要在不同的时间向多个对象添加相同的事件,那么创建一个命名的函数可能是个好办法。</target>
        </trans-unit>
        <trans-unit id="5ecdaaefd58d99b1f8b90be889af14b3fc1cc97b" translate="yes" xml:space="preserve">
          <source>You can attach event to element when dynamically created using &lt;a href=&quot;https://api.jquery.com/jQuery/#jQuery-html-attributes&quot;&gt;&lt;code&gt;jQuery(html, attributes)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://api.jquery.com/jQuery/#jQuery-html-attributes&quot;&gt; &lt;code&gt;jQuery(html, attributes)&lt;/code&gt; &lt;/a&gt;动态创建时，可以将事件附加到元素。</target>
        </trans-unit>
        <trans-unit id="e058f96e8fbbf0d1d5e0eff215fc238e8278526c" translate="yes" xml:space="preserve">
          <source>You can use the live() method to bind elements (even newly created ones) to events and handlers, like the onclick event.</source>
          <target state="translated">你可以使用 live()方法将元素(即使是新创建的元素)与事件和处理程序绑定,比如 onclick 事件。</target>
        </trans-unit>
        <trans-unit id="24e3cbdcb07a60f184ceb7d41c5a224d7c34d445" translate="yes" xml:space="preserve">
          <source>You could simply wrap your event binding call up into a function and then invoke it twice: once on document ready and once after your event that adds the new DOM elements. If you do that you'll want to avoid binding the same event twice on the existing elements so you'll need either unbind the existing events or (better) only bind to the DOM elements that are newly created. The code would look something like this:</source>
          <target state="translated">你可以简单地将事件绑定调用打包成一个函数,然后调用两次:在文档准备就绪时调用一次,在添加新的DOM元素的事件之后调用一次。如果你这样做的话,你要避免在现有的元素上绑定两次相同的事件,所以你需要解绑现有的事件,或者(最好)只绑定新创建的DOM元素。代码看起来会是这样的。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="5fe10e66f48323f79d7241340dee2b7b5afb7f57" translate="yes" xml:space="preserve">
          <source>see: &lt;a href=&quot;http://api.jquery.com/delegate/&quot;&gt;jQuery Delegate Event&lt;/a&gt;</source>
          <target state="translated">请参阅： &lt;a href=&quot;http://api.jquery.com/delegate/&quot;&gt;jQuery委托事件&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="268da60403559674a925e83b8f5019a089c41e7e" translate="yes" xml:space="preserve">
          <source>these two methods are equivalent but have a different order of parameters.</source>
          <target state="translated">这两种方法是等价的,但参数顺序不同。</target>
        </trans-unit>
        <trans-unit id="f4a351527973325870be8cbbdc60883232cdbc1c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;hasClass&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;hasClass&lt;/code&gt; 在哪里</target>
        </trans-unit>
        <trans-unit id="e1aaaf53a6211629990be58cbd8bd15b9fc1d708" translate="yes" xml:space="preserve">
          <source>would apply to</source>
          <target state="translated">将适用于</target>
        </trans-unit>
        <trans-unit id="e65f2d7ea578436d8c5de9d0f81693c839400dd3" translate="yes" xml:space="preserve">
          <source>wrapper-class element can be anything ex. document, body or your wrapper. &lt;strong&gt;Wrapper should already exist&lt;/strong&gt;. However, &lt;code&gt;selector&lt;/code&gt; doesn't necessarily needs to be presented at page loading time. It may come later and the event will bind on &lt;code&gt;selector&lt;/code&gt;&lt;strong&gt;without fail&lt;/strong&gt;.</source>
          <target state="translated">wrapper-class元素可以是任何ex。 文件，正文或包装纸。 &lt;strong&gt;包装器应该已经存在&lt;/strong&gt; 。 但是，不一定需要在页面加载时显示 &lt;code&gt;selector&lt;/code&gt; 。 它可能稍后出现，并且该事件将绑定到 &lt;code&gt;selector&lt;/code&gt; &lt;strong&gt;而不会失败&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="71dc20406e9920e5d8c00dc97939bb6e2c087e28" translate="yes" xml:space="preserve">
          <source>you could use</source>
          <target state="translated">你可以用</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
