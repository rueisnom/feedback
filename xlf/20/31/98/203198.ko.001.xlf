<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/203198">
    <body>
      <group id="203198">
        <trans-unit id="a8972a57acbe818041fa966cc2b28f0cad18bfb0" translate="yes" xml:space="preserve">
          <source>... can be replaced with the following &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;&lt;code&gt;on()&lt;/code&gt;&lt;/a&gt; signature:</source>
          <target state="translated">...는 다음 &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt; &lt;code&gt;on()&lt;/code&gt; &lt;/a&gt; 서명으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a87a21d1dee1ba19a2c9f1d66cddfec7e6bd9f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Credit goes to Dave and Sime Vidas&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;신용은 Dave와 Sime Vidas에게갑니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65137a7187fce4b4490f883134f495f236293189" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/ramswaroop/Nrxp5/28/&quot;&gt;Live demo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net/ramswaroop/Nrxp5/28/&quot;&gt;라이브 데모&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="575fe48fa4d16cc654b3160eaa356af8d60920af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;This is done by event delegation&lt;/em&gt;&lt;/strong&gt;. Event will bind on wrapper-class element but will be delegated to selector-class element. This is how it works.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;이것은 이벤트 위임에 의해 수행됩니다&lt;/em&gt;&lt;/strong&gt; . 이벤트는 랩퍼 클래스 요소에 바인드되지만 선택자 클래스 요소에 위임됩니다. 이것이 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="4ceac39fa6838552a173a073715a84bd3223cfb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of jQuery 1.7&lt;/strong&gt; you should use &lt;a href=&quot;https://api.jquery.com/on/#on-events-selector-data-handler&quot;&gt;&lt;code&gt;jQuery.fn.on&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;jQuery 1.7부터&lt;/strong&gt; &lt;a href=&quot;https://api.jquery.com/on/#on-events-selector-data-handler&quot;&gt; &lt;code&gt;jQuery.fn.on&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7cf3ad54791f3845059488958d2790178f82afe4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of jQuery 1.8&lt;/strong&gt;, any jQuery instance method (a method of &lt;code&gt;jQuery.fn&lt;/code&gt;) can be used as a property of the object passed to the
  second parameter:</source>
          <target state="translated">&lt;strong&gt;jQuery 1.8&lt;/strong&gt; &lt;code&gt;jQuery.fn&lt;/code&gt; 모든 jQuery 인스턴스 메소드 ( jQuery.fn 의 메소드)를 두 번째 매개 변수에 전달 된 오브젝트의 특성으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8121f33e15ae3270016b626cba0d1f05c03ad837" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Child Element:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자식 요소 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f858e011c800a6613bd354fb690ab08482220aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Delegated events&lt;/strong&gt; have the advantage that they can process events from descendant elements that are added to the document at a later time. For example, if the table exists, but the rows are added dynamically using code, the following will handle it:</source>
          <target state="translated">&lt;strong&gt;위임 된 이벤트&lt;/strong&gt; 는 나중에 문서에 추가 된 하위 요소의 이벤트를 처리 할 수 ​​있다는 이점이 있습니다. 예를 들어, 테이블이 존재하지만 코드를 사용하여 행이 동적으로 추가되면 다음이 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5ad6ec00b70205934534ed66186e46766e431a7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Delegated events do not work for &lt;a href=&quot;http://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt; 에서는 위임 된 이벤트가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1396f709940aace150fc43d0022737a6382f4d9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prior to this&lt;/strong&gt;, the recommended approach was to use &lt;a href=&quot;http://api.jquery.com/live&quot;&gt;&lt;code&gt;live()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;이 전에&lt;/strong&gt; 권장되는 접근 방식은 &lt;a href=&quot;http://api.jquery.com/live&quot;&gt; &lt;code&gt;live()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="143ccabf09bfc2410ef1aef7440a4c4bf5b74242" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Single element:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;단일 요소 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e79b4193d9abf560434046dc211121399a27306" translate="yes" xml:space="preserve">
          <source>A delegated-events approach (the second code example) attaches an event handler to only one element, the &lt;code&gt;tbody&lt;/code&gt;, and the event only needs to bubble up one level (from the clicked &lt;code&gt;tr&lt;/code&gt; to &lt;code&gt;tbody&lt;/code&gt;).</source>
          <target state="translated">위임 된 이벤트 접근 방식 (두 번째 코드 예제)은 이벤트 핸들러를 하나의 요소 &lt;code&gt;tbody&lt;/code&gt; 에만 연결하며 이벤트는 클릭 한 &lt;code&gt;tr&lt;/code&gt; 에서 &lt;code&gt;tbody&lt;/code&gt; 로 한 레벨 만 버블 링해야합니다.</target>
        </trans-unit>
        <trans-unit id="bca51f7c9a8ef157c2eb1f3a0badc598bf24fbdc" translate="yes" xml:space="preserve">
          <source>Also as of version 1.9 &lt;code&gt;.live()&lt;/code&gt; method is removed.</source>
          <target state="translated">또한 버전 1.9부터 &lt;code&gt;.live()&lt;/code&gt; 메소드가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="520437ca88dd120a5b62eec01ddd5fb91366f135" translate="yes" xml:space="preserve">
          <source>Another flexible solution to create elements and bind events  (&lt;a href=&quot;https://stackoverflow.com/questions/10619445/the-preferred-way-of-creating-a-new-element-with-jquery&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">요소를 만들고 이벤트를 바인딩하는 또 다른 유연한 솔루션 ( &lt;a href=&quot;https://stackoverflow.com/questions/10619445/the-preferred-way-of-creating-a-new-element-with-jquery&quot;&gt;source&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9564d129a95bb8da226e634ff72c645d32f4388f" translate="yes" xml:space="preserve">
          <source>Another solution is to add the listener when creating the element. Instead of put the listener in the body, you put the listener in the element in the moment that you create it:</source>
          <target state="translated">다른 해결책은 요소를 만들 때 리스너를 추가하는 것입니다. 리스너를 본문에 넣는 대신 리스너를 생성하는 순간 요소에 리스너를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="43044a5260912f835cd862881dbcce424864025a" translate="yes" xml:space="preserve">
          <source>Any p&lt;strong&gt;arent that exists&lt;/strong&gt; at the time the event is bound and if your page was &lt;strong&gt;dynamically creating elements&lt;/strong&gt; with the class name &lt;strong&gt;button&lt;/strong&gt; you would bind the event to a parent which already exists</source>
          <target state="translated">이벤트가 바인딩 될 때 &lt;strong&gt;존재&lt;/strong&gt; 하는 페이지가없고 페이지가 클래스 이름 &lt;strong&gt;버튼&lt;/strong&gt; &lt;strong&gt;으로 요소&lt;/strong&gt; 를 &lt;strong&gt;동적으로 생성&lt;/strong&gt; 하는 경우 이미 존재하는 부모에 이벤트를 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="a28fbdb9a58de11fbc1879e841aecb020b6f3a51" translate="yes" xml:space="preserve">
          <source>Any parent that exists at the time the event is bound is fine. For example</source>
          <target state="translated">이벤트가 바인드 될 때 존재하는 모든 상위는 괜찮습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f970c18459a7c2d0b314f828c4413440bf8ad720" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;on()&lt;/a&gt; makes the trick to attach events, in order to create a fake unbind on those I came to:</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;on ()과&lt;/a&gt; 같이 이벤트를 첨부하는 트릭을 만들면 내가 온 사람들에게 가짜 바인딩을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e975b5a75355cd02b8540ca3f3913b901d617aa" translate="yes" xml:space="preserve">
          <source>As a workaround, you have to listen to all clicks and check the source element&amp;nbsp;:</source>
          <target state="translated">이 문제를 해결하려면 모든 클릭을 듣고 소스 요소를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="4001dba9ad59edc09c4afd8f7dea4e2524de2fde" translate="yes" xml:space="preserve">
          <source>Bind the event to a parent which already exists:</source>
          <target state="translated">이미 존재하는 부모에게 이벤트를 바인딩하십시오.</target>
        </trans-unit>
        <trans-unit id="23a669435afc0aec4042f83f8d933fab3832876c" translate="yes" xml:space="preserve">
          <source>Event binding on dynamically created elements</source>
          <target state="translated">동적으로 생성 된 요소에 대한 이벤트 바인딩</target>
        </trans-unit>
        <trans-unit id="bbae10adc7d50b259bc0e19531b06621889913be" translate="yes" xml:space="preserve">
          <source>Event handlers are bound only to the currently selected elements; they must exist on the page at the time your code makes the call to &lt;code&gt;.on()&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러는 현재 선택된 요소에만 바인드됩니다. 코드가 &lt;code&gt;.on()&lt;/code&gt; 호출 할 때 페이지에 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="09a4c4ab2bd8bc5a70d89eb8a77f473ea61d8c69" translate="yes" xml:space="preserve">
          <source>For example, if your page was dynamically creating elements with the class name &lt;code&gt;dosomething&lt;/code&gt; you would bind the event to &lt;strong&gt;a parent which already exists&lt;/strong&gt; (this is the nub of the problem here, you need something that exists to bind to, don't bind to the dynamic content), this can be (and the easiest option) is &lt;code&gt;document&lt;/code&gt;. Though bear in mind &lt;a href=&quot;https://stackoverflow.com/questions/12824549/should-all-jquery-events-be-bound-to-document&quot;&gt;&lt;code&gt;document&lt;/code&gt; may not be the most efficient option&lt;/a&gt;.</source>
          <target state="translated">예를 들어, 페이지에서 클래스 이름이 &lt;code&gt;dosomething&lt;/code&gt; 인 요소를 동적으로 생성 &lt;strong&gt;하는 경우 이미 존재하는 부모에&lt;/strong&gt; 이벤트를 바인딩 할 수 &lt;strong&gt;있습니다&lt;/strong&gt; (여기서는 문제의 핵심이므로 바인딩 할 내용이 필요합니다. 동적 내용)이 될 수 있으며 가장 쉬운 옵션은 &lt;code&gt;document&lt;/code&gt; 입니다. 마음에 곰 &lt;a href=&quot;https://stackoverflow.com/questions/12824549/should-all-jquery-events-be-bound-to-document&quot;&gt; &lt;code&gt;document&lt;/code&gt; 는 가장 효율적인 옵션이 아닐 수도 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74d1a19a05c414d5c3d9d18b75ee5e3108b41b64" translate="yes" xml:space="preserve">
          <source>Here is a sample code I have written, where you can see how the live() method binds chosen elements, even newly created ones, to events:</source>
          <target state="translated">다음은 내가 작성한 샘플 코드입니다. live () 메서드가 선택한 요소 (새로 만든 요소)를 이벤트에 바인딩하는 방법을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f010a4d150b400288dc5a4b619b03371e707377" translate="yes" xml:space="preserve">
          <source>Here is why dynamically created elements do not respond to clicks&amp;nbsp;:</source>
          <target state="translated">동적으로 생성 된 요소가 클릭에 응답하지 않는 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c81c0b216fd0f102fb2ba399de807bd3e0bee13" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;live()&lt;/code&gt; was deprecated in 1.7 in favour of &lt;code&gt;on()&lt;/code&gt;, and completely removed in 1.9. The &lt;code&gt;live()&lt;/code&gt; signature:</source>
          <target state="translated">그러나 &lt;code&gt;live()&lt;/code&gt; 는 &lt;code&gt;on()&lt;/code&gt; 을 위해 1.7에서 더 이상 사용되지 않으며 1.9에서 완전히 제거되었습니다. &lt;code&gt;live()&lt;/code&gt; 서명 :</target>
        </trans-unit>
        <trans-unit id="bea31d79a2f1fd37a468570dea30fb2473747abe" translate="yes" xml:space="preserve">
          <source>I have a bit of code where I am looping through all the select boxes on a page and binding a &lt;code&gt;.hover&lt;/code&gt; event to them to do a bit of twiddling with their width on &lt;code&gt;mouse on/off&lt;/code&gt;.</source>
          <target state="translated">페이지의 모든 선택 상자를 반복하고 &lt;code&gt;.hover&lt;/code&gt; 이벤트를 바인딩하여 &lt;code&gt;mouse on/off&lt;/code&gt; 의 너비를 사용하여 마우스를 켜거나 끄는 약간의 코드를 작성하는 코드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0166e850a3cacd1ad5c76193c5748e46bd35cbbc" translate="yes" xml:space="preserve">
          <source>I have found this plugin (&lt;a href=&quot;http://brandonaaron.net/docs/livequery/#getting-started&quot;&gt;jQuery Live Query Plugin&lt;/a&gt;), but before I add another 5k to my pages with a plugin, I want to see if anyone knows a way to do this, either with jQuery directly or by another option.</source>
          <target state="translated">이 플러그인 ( &lt;a href=&quot;http://brandonaaron.net/docs/livequery/#getting-started&quot;&gt;jQuery Live Query Plugin&lt;/a&gt; )을 찾았지만 플러그인을 사용하여 페이지에 다른 5k를 추가하기 전에 누군가 jQuery를 사용하거나 다른 옵션으로이를 수행하는 방법을 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="ccea30520e256f544ca7731ee1f90989cc557d6b" translate="yes" xml:space="preserve">
          <source>I have noticed that:</source>
          <target state="translated">나는 그것을 알아 차렸다 :</target>
        </trans-unit>
        <trans-unit id="a93ff81926a62d3a9f49d9c2a7c673b736a1ea74" translate="yes" xml:space="preserve">
          <source>I prefer to have event listeners deployed in a modular function fashion rather than scripting a &lt;code&gt;document&lt;/code&gt; level event listener. So, I do like below. &lt;em&gt;Note, you can't oversubscribe an element with the same event listener so don't worry about attaching a listener more than once - only one sticks.&lt;/em&gt;</source>
          <target state="translated">이벤트 레벨 리스너를 &lt;code&gt;document&lt;/code&gt; 레벨 이벤트 리스너를 스크립팅하는 대신 모듈 식 기능 방식으로 배치하는 것이 좋습니다. 그래서 나는 아래를 좋아한다. &lt;em&gt;동일한 이벤트 리스너로 요소를 초과 구독 할 수 없으므로 리스너를 두 번 이상 연결하는 것에 대해 걱정할 필요가 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba293bc4610d370b65094817ce4a70833808d6ac" translate="yes" xml:space="preserve">
          <source>I prefer using the selector and I apply it on the document.</source>
          <target state="translated">선택기를 사용하는 것을 선호하며 문서에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3f633aff3611d5b9a4ec0f1a72062fa2b919ca9d" translate="yes" xml:space="preserve">
          <source>I was looking a solution to get &lt;code&gt;$.bind&lt;/code&gt; and &lt;code&gt;$.unbind&lt;/code&gt; working without problems in dynamically added elements.</source>
          <target state="translated">동적으로 추가 된 요소에서 문제없이 &lt;code&gt;$.bind&lt;/code&gt; 및 &lt;code&gt;$.unbind&lt;/code&gt; 작동시키는 솔루션을 찾고있었습니다.</target>
        </trans-unit>
        <trans-unit id="121526c28eb4d17e924957f03145fd2a3bc2d327" translate="yes" xml:space="preserve">
          <source>If new HTML is being injected into the page, it is preferable to use delegated events to attach an event handler, as described next.</source>
          <target state="translated">새 HTML이 페이지에 삽입되는 경우 다음에 설명 된대로 위임 된 이벤트를 사용하여 이벤트 핸들러를 첨부하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e4ee1c304d91b4ba5db3b6662131800422aa2845" translate="yes" xml:space="preserve">
          <source>In addition to their ability to handle events on descendant elements which are not yet created, another advantage of delegated events is their potential for much lower overhead when many elements must be monitored. On a data table with 1,000 rows in its &lt;code&gt;tbody&lt;/code&gt;, the first code example attaches a handler to 1,000 elements.</source>
          <target state="translated">아직 생성되지 않은 하위 요소의 이벤트를 처리하는 기능 외에도 위임 된 이벤트의 또 다른 장점은 많은 요소를 모니터링해야 할 때 오버 헤드가 훨씬 낮아질 수 있다는 것입니다. &lt;code&gt;tbody&lt;/code&gt; 에 1,000 개의 행이있는 데이터 테이블에서 첫 번째 코드 예제는 1,000 개의 요소에 핸들러를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">한마디로 :</target>
        </trans-unit>
        <trans-unit id="55a55d75376d28ae5354a117f07c81ced1f380a0" translate="yes" xml:space="preserve">
          <source>In the above scenario, the MAIN object the jQuery will watch is &quot;container&quot;.</source>
          <target state="translated">위 시나리오에서 jQuery가 볼 MAIN 객체는 &quot;컨테이너&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="3ddf3717de1bf8871ba637caa0e3dbd804ec8fc6" translate="yes" xml:space="preserve">
          <source>It is not working any more, but it was working before. I have been using jQuery from Google &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN&lt;/a&gt;, but I don't know if they changed it.</source>
          <target state="translated">더 이상 작동하지 않지만 이전에는 작동했습니다. Google &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN&lt;/a&gt; 에서 jQuery를 사용하고 있지만 변경했는지는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="16d7fbf005872626c8808a92955de061d24efd73" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;This will create an event handler instance for each element&lt;/strong&gt; (may affect performance when used in loops)</source>
          <target state="translated">참고 : &lt;strong&gt;이렇게하면 각 요소에 대한 이벤트 핸들러 인스턴스가 작성&lt;/strong&gt; 됩니다 (루프에서 사용될 때 성능에 영향을 줄 수 있음)</target>
        </trans-unit>
        <trans-unit id="04147083b7d8a7196770879875a0ca9cf282f07f" translate="yes" xml:space="preserve">
          <source>Notice the added &lt;code&gt;*&lt;/code&gt;. An event will be triggered for all children of that element.</source>
          <target state="translated">추가 된 &lt;code&gt;*&lt;/code&gt; 를 확인하십시오 . 해당 요소의 모든 자식에 대해 이벤트가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="1a7e0e2bd50a0ef759671c87699bcc951dcac085" translate="yes" xml:space="preserve">
          <source>Take note of &quot;MAIN&quot; class the element is placed, for example,</source>
          <target state="translated">예를 들어, 요소가 배치 된 &quot;MAIN&quot;클래스에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="2a72daceef89d806147f11539b1d54a9c390a5ab" translate="yes" xml:space="preserve">
          <source>The problem I have is that any select boxes I add via Ajax or DOM after the initial loop won't have the event bound.</source>
          <target state="translated">내가 가진 문제는 초기 루프 후 Ajax 또는 DOM을 통해 추가 한 선택 상자에 이벤트가 바인딩되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="979b5ad8b60b8542eef0babcc9943887de13fd59" translate="yes" xml:space="preserve">
          <source>Then you will basically have elements names under container such as &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;li&lt;/code&gt;, and &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">그런 다음 기본적으로 컨테이너 아래에 &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;li&lt;/code&gt; 및 &lt;code&gt;select&lt;/code&gt; 와 같은 요소 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="59b38c9e93aa7726ab7323559170eed1fcbfe18b" translate="yes" xml:space="preserve">
          <source>There is a good explanation in the documentation of &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;&lt;code&gt;jQuery.fn.on&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/on/&quot;&gt; &lt;code&gt;jQuery.fn.on&lt;/code&gt; &lt;/a&gt; 문서에 좋은 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="393b62080db3f3cc932d8c6de03d8c4130e58885" translate="yes" xml:space="preserve">
          <source>This binds itself on the document and will be applicable to the elements that will be rendered after page load.</source>
          <target state="translated">이것은 문서에 바인딩되며 페이지로드 후 렌더링 될 요소에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a26f58f69215da3541ad28e6f186f321c1e4c5d7" translate="yes" xml:space="preserve">
          <source>This happens on page ready and works just fine.</source>
          <target state="translated">이것은 페이지 준비시 발생하며 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="03fccd37ed823050c43f5256a26856f5b806cdcd" translate="yes" xml:space="preserve">
          <source>This is a &lt;strong&gt;pure JavaScript&lt;/strong&gt; solution without any libraries or plugins:</source>
          <target state="translated">이것은 라이브러리 나 플러그인이없는 &lt;strong&gt;순수한 JavaScript&lt;/strong&gt; 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="ab54cbd9ffd4bba14eb8fbdb8033b05d53d35bd0" translate="yes" xml:space="preserve">
          <source>This is called &quot;Event Delegation&quot;. Good news, it's a builtin feature in jQuery :-)</source>
          <target state="translated">이것을 &quot;이벤트 위임&quot;이라고합니다. 좋은 소식은 jQuery의 내장 기능입니다 :-)</target>
        </trans-unit>
        <trans-unit id="46c820f1b2cb216120b87ff216b232a5acd72c52" translate="yes" xml:space="preserve">
          <source>Thus in the following example &lt;code&gt;#dataTable tbody tr&lt;/code&gt; must exist before the code is generated.</source>
          <target state="translated">따라서 다음 예제에서 &lt;code&gt;#dataTable tbody tr&lt;/code&gt; 은 코드가 생성되기 전에 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="91c7af6f3bf60017455d98ea1e4ea34dc694a936" translate="yes" xml:space="preserve">
          <source>Try like this way -</source>
          <target state="translated">이런 식으로 시도하십시오-</target>
        </trans-unit>
        <trans-unit id="10e8f62ba0b5574d62e1072ef78ab99ceb280730" translate="yes" xml:space="preserve">
          <source>Try to use &lt;code&gt;.live()&lt;/code&gt; instead of &lt;code&gt;.bind()&lt;/code&gt;; the &lt;code&gt;.live()&lt;/code&gt; will bind &lt;code&gt;.hover&lt;/code&gt; to your checkbox after the Ajax request executes.</source>
          <target state="translated">&lt;code&gt;.bind()&lt;/code&gt; 대신 .live ()를 사용하십시오 . &lt;code&gt;.hover&lt;/code&gt; &lt;code&gt;.live()&lt;/code&gt; 는 Ajax 요청이 실행 된 후 .hover 를 확인란에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="7b7ce60f27087cdb8816a25d6f46dc0cbcb1f006" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;.on()&lt;/code&gt; method of jQuery &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;http://api.jquery.com/on/&lt;/a&gt; to attach event handlers to live element.</source>
          <target state="translated">jQuery &lt;a href=&quot;http://api.jquery.com/on/&quot;&gt;http://api.jquery.com/on/&lt;/a&gt; 의 &lt;code&gt;.on()&lt;/code&gt; 메소드를 사용하여 이벤트 핸들러를 라이브 요소에 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="7428279e9da2bd5262728e5675af669aa9658310" translate="yes" xml:space="preserve">
          <source>Using more modern JS, &lt;code&gt;hasClass&lt;/code&gt; can be implemented as:</source>
          <target state="translated">보다 최신 JS를 사용하여 &lt;code&gt;hasClass&lt;/code&gt; 를 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32d3c9bfc640d88fdd5921bd366e94eb2506eb4b" translate="yes" xml:space="preserve">
          <source>You can add events to objects when you create them. If you are adding the same events to multiple objects at different times, creating a named function might be the way to go.</source>
          <target state="translated">객체를 만들 때 객체에 이벤트를 추가 할 수 있습니다. 다른 시간에 여러 객체에 동일한 이벤트를 추가하는 경우 명명 된 함수를 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5ecdaaefd58d99b1f8b90be889af14b3fc1cc97b" translate="yes" xml:space="preserve">
          <source>You can attach event to element when dynamically created using &lt;a href=&quot;https://api.jquery.com/jQuery/#jQuery-html-attributes&quot;&gt;&lt;code&gt;jQuery(html, attributes)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/jQuery/#jQuery-html-attributes&quot;&gt; &lt;code&gt;jQuery(html, attributes)&lt;/code&gt; &lt;/a&gt; 사용하여 동적으로 만들 때 요소에 이벤트를 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e058f96e8fbbf0d1d5e0eff215fc238e8278526c" translate="yes" xml:space="preserve">
          <source>You can use the live() method to bind elements (even newly created ones) to events and handlers, like the onclick event.</source>
          <target state="translated">live () 메소드를 사용하여 onclick 이벤트와 같은 요소 (새로 작성된 요소)를 이벤트 및 핸들러에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24e3cbdcb07a60f184ceb7d41c5a224d7c34d445" translate="yes" xml:space="preserve">
          <source>You could simply wrap your event binding call up into a function and then invoke it twice: once on document ready and once after your event that adds the new DOM elements. If you do that you'll want to avoid binding the same event twice on the existing elements so you'll need either unbind the existing events or (better) only bind to the DOM elements that are newly created. The code would look something like this:</source>
          <target state="translated">이벤트 바인딩 호출을 함수로 래핑 한 다음 문서에서 한 번 준비하고 새 DOM 요소를 추가하는 이벤트 후에 한 번만 두 번 호출 할 수 있습니다. 그렇게하면 기존 요소에서 동일한 이벤트를 두 번 바인딩하지 않으려면 기존 이벤트를 바인드 해제하거나 새로 작성된 DOM 요소에만 바인딩해야합니다. 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="5fe10e66f48323f79d7241340dee2b7b5afb7f57" translate="yes" xml:space="preserve">
          <source>see: &lt;a href=&quot;http://api.jquery.com/delegate/&quot;&gt;jQuery Delegate Event&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://api.jquery.com/delegate/&quot;&gt;jQuery 위임 이벤트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="268da60403559674a925e83b8f5019a089c41e7e" translate="yes" xml:space="preserve">
          <source>these two methods are equivalent but have a different order of parameters.</source>
          <target state="translated">이 두 방법은 동일하지만 매개 변수 순서가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f4a351527973325870be8cbbdc60883232cdbc1c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;hasClass&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;hasClass&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="e1aaaf53a6211629990be58cbd8bd15b9fc1d708" translate="yes" xml:space="preserve">
          <source>would apply to</source>
          <target state="translated">에 적용</target>
        </trans-unit>
        <trans-unit id="e65f2d7ea578436d8c5de9d0f81693c839400dd3" translate="yes" xml:space="preserve">
          <source>wrapper-class element can be anything ex. document, body or your wrapper. &lt;strong&gt;Wrapper should already exist&lt;/strong&gt;. However, &lt;code&gt;selector&lt;/code&gt; doesn't necessarily needs to be presented at page loading time. It may come later and the event will bind on &lt;code&gt;selector&lt;/code&gt;&lt;strong&gt;without fail&lt;/strong&gt;.</source>
          <target state="translated">래퍼 클래스 요소는 ex 일 수 있습니다. 문서, 본문 또는 포장지. &lt;strong&gt;랩퍼가 이미 존재해야합니다&lt;/strong&gt; . 그러나 페이지로드시 &lt;code&gt;selector&lt;/code&gt; 를 반드시 제공 할 필요는 없습니다. 나중에 올 수 있으며 이벤트는 &lt;code&gt;selector&lt;/code&gt; &lt;strong&gt;실패없이&lt;/strong&gt; 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="71dc20406e9920e5d8c00dc97939bb6e2c087e28" translate="yes" xml:space="preserve">
          <source>you could use</source>
          <target state="translated">당신은 사용할 수 있습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
