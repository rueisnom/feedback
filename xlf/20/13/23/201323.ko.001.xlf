<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/201323">
    <body>
      <group id="201323">
        <trans-unit id="b1b5a828768c114744b0e8c042dc66da113334ec" translate="yes" xml:space="preserve">
          <source>&quot;User Display Name user3@company.com&quot;</source>
          <target state="translated">&quot;사용자 표시 이름 user3@company.com&quot;</target>
        </trans-unit>
        <trans-unit id="26c2451374584a209014621e5558743bfa2ce56d" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com; user2@gmail.com&quot;</target>
        </trans-unit>
        <trans-unit id="28633028efd2c24861ac4a1740c2217f423b8453" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com; user3@company.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com; user2@gmail.com; user3@company.com&quot;</target>
        </trans-unit>
        <trans-unit id="0bc92ef1ed9e5d917df368b9389fccbdd11bbe8d" translate="yes" xml:space="preserve">
          <source>&quot;user4 @company.com&quot;</source>
          <target state="translated">&quot;user4 @ company.com&quot;</target>
        </trans-unit>
        <trans-unit id="32f8045af87affeff6f4333e80528d9f758f0dff" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt;)
If you're looking for something simpler but that will catch most valid email addresses try something like:</source>
          <target state="translated">( &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt; ) 더 간단한 것을 찾고 있지만 가장 유효한 이메일 주소를 찾으려면 다음과 같이 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="75f14c0b3eb6f2ddf1a7b788a9c63a1261d191e6" translate="yes" xml:space="preserve">
          <source>(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</source>
          <target state="translated">(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</target>
        </trans-unit>
        <trans-unit id="41c1c65773194544312b0d413e9568defa0fa5f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Cal Henderson&lt;/a&gt; (Flickr) wrote an article called &lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;Parsing Email Adresses in PHP&lt;/a&gt; and shows how to do proper RFC (2)822-compliant Email Address parsing.  You can also get the source code in &lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt;, python and ruby which is &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;cc licensed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Cal Henderson&lt;/a&gt; (Flickr)은 &lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;PHP로 Parsing Email Adresses&lt;/a&gt; 라는 기사를 작성했으며 올바른 RFC (2) 822 호환 이메일 주소 구문 분석을 수행하는 방법을 보여줍니다. &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;cc 라이센스&lt;/a&gt; 가있는 &lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt; , python 및 ruby에서 소스 코드를 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4215c60a61270d50ef11c83e3925ba93699fa35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt;&lt;em&gt;etc...&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt; &lt;em&gt;등 ...&lt;/em&gt; &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3654c41e6ade2da259eef5a7ae400fac5827b8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the best regular expression you have or have seen for validating emails?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이메일 확인에있어 가장 좋은 정규 표현은 무엇입니까?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83da26750665b7eec085cd165f43ccd6b0fe79c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &lt;code&gt;@&lt;/code&gt; character), too vague (after the &lt;code&gt;@&lt;/code&gt; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 요구 사항은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; 의 &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;고의적 인 위반&lt;/a&gt; 으로 동시에 너무 엄격한 ( &lt;code&gt;@&lt;/code&gt; 문자 이전), 너무 모호한 ( &lt;code&gt;@&lt;/code&gt; 문자 뒤) 및 너무 느슨한 (주석 허용, 공백 허용) 전자 메일 주소의 구문을 정의합니다. 문자, 및 대부분의 사용자에게 익숙하지 않은 방식으로 따옴표로 묶은 문자열)을 여기에서 실용적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="467b846662a13d15de5bbd34d57ea291cf420f2e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;valid e-mail address&lt;/strong&gt; is a string that matches the ABNF production [&amp;hellip;].</source>
          <target state="translated">&lt;strong&gt;유효한 이메일 주소&lt;/strong&gt; 는 ABNF 프로덕션 [&amp;hellip;]과 일치하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="aef7d848543c3d5b49c4b583603a1e7b9279f10b" translate="yes" xml:space="preserve">
          <source>A common use case is user input validation, for example on an html form. In that case it's usually reasonable to preclude address-literals and to require at least two labels in the hostname. Taking the improved RFC 5321 regex from the previous section as a basis, the resulting expression would be:</source>
          <target state="translated">일반적인 사용 사례는 사용자 입력 유효성 검사입니다 (예 : html 양식). 이 경우 일반적으로 주소 리터럴을 배제하고 호스트 이름에 두 개 이상의 레이블을 요구하는 것이 합리적입니다. 이전 섹션에서 개선 된 RFC 5321 정규식을 기본으로 사용하면 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f254b288b513a222b7ce9705affbccd53cd80d8" translate="yes" xml:space="preserve">
          <source>According to official standard &lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt; valid email regex is</source>
          <target state="translated">공식 표준 &lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt; 유효한 이메일 정규식에 따르면</target>
        </trans-unit>
        <trans-unit id="6d2f2f9c03ab4cdaf2b9f2364a0c2799a6329154" translate="yes" xml:space="preserve">
          <source>Addresses matched by this regex:</source>
          <target state="translated">이 정규식과 일치하는 주소 :</target>
        </trans-unit>
        <trans-unit id="b75e467be1d8b94588b3cc3f5aaec8acae067ee7" translate="yes" xml:space="preserve">
          <source>After all, the &lt;strong&gt;best&lt;/strong&gt; way to validate the email address is still to actually &lt;em&gt;send&lt;/em&gt; an email to the address in question to validate the address. If the email address is part of user authentication (register/login/etc), then you can perfectly combine it with the user activation system. I.e. send an email with a link with an unique activation key to the specified email address and only allow login when the user has activated the newly created account using the link in the email.</source>
          <target state="translated">결국, 전자 메일 주소를 확인하는 &lt;strong&gt;가장 좋은&lt;/strong&gt; 방법은 실제로 해당 주소로 전자 메일을 &lt;em&gt;보내&lt;/em&gt; 주소를 확인하는 것입니다. 이메일 주소가 사용자 인증 (등록 / 로그인 등)의 일부인 경우 사용자 활성화 시스템과 완벽하게 결합 할 수 있습니다. 즉, 고유 한 활성화 키가있는 링크가 포함 된 이메일을 지정된 이메일 주소로 보내고 사용자가 이메일의 링크를 사용하여 새로 만든 계정을 활성화 한 경우에만 로그인을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4747783011ffa130857e2027d5ff2eef5ab7e5ce" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part and domain name domain (requiring at least two domain name labels with the TLD limited to 2-6 alphabetic characters).</source>
          <target state="translated">도트 원자 로컬 부분 및 도메인 이름 도메인을 허용합니다 (TLD가 2-6 자의 알파벳 문자로 제한된 도메인 이름 레이블을 두 개 이상 필요).</target>
        </trans-unit>
        <trans-unit id="98f5ff42c06d45b9d6040c487efd8ddaae34384a" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, domain name domain, and (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain.</source>
          <target state="translated">도트 원자 로컬 부분, 따옴표로 묶은 문자열 로컬 부분, 도메인 이름 도메인 및 (IPv4, IPv6 및 IPv4 매핑 IPv6 주소) 도메인 리터럴 도메인을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1a501b9511aa2902571ab4411c2d68715c865f16" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, obsolete (mixed dot-atom and quoted-string) local-part, domain name domain, (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain, and (nested) CFWS.</source>
          <target state="translated">dot-atom local-part, quoted-string local-part, 쓸모없는 (dot-atom 및 인용 문자열 혼합) local-part, 도메인 이름 도메인 (IPv4, IPv6 및 IPv4 매핑 된 IPv6 주소) 도메인 리터럴 도메인을 허용합니다. 그리고 (중첩 된) CFWS.</target>
        </trans-unit>
        <trans-unit id="137a6c9662b514d8385afe47af02dd62a6fdb560" translate="yes" xml:space="preserve">
          <source>Another consideration, especially when using the regexes for input validation, is feedback to the user. If a user enters an incorrect address, it would be nice to give a little more feedback than a simple &quot;syntactically incorrect address&quot;. With &quot;vanilla&quot; regexes this is not possible.</source>
          <target state="translated">특히 입력 검증을 위해 정규식을 사용할 때 고려해야 할 또 다른 사항은 사용자에게 피드백입니다. 사용자가 잘못된 주소를 입력하면 간단한 &quot;구문 적으로 잘못된 주소&quot;보다 약간 더 많은 피드백을 제공하는 것이 좋습니다. &quot;vanilla&quot;정규식으로는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="7cf149b9d25d2489f954894be6028e467951029a" translate="yes" xml:space="preserve">
          <source>As stated in paragraph 3.1.4. of RFC 822 optional linear white space may be inserted between lexical tokens. Where applicable I've expanded the expressions to accommodate this rule and marked the result with &quot;opt-lwsp&quot;.</source>
          <target state="translated">단락 3.1.4에 명시된 바와 같이. RFC 822의 선택적 선형 공백은 어휘 토큰 사이에 삽입 될 수 있습니다. 해당되는 경우이 규칙을 수용하도록 표현식을 확장하고 결과를 &quot;opt-lwsp&quot;로 표시했습니다.</target>
        </trans-unit>
        <trans-unit id="023052f99d8ae0931ecbe27dc9dbfef6103d1f37" translate="yes" xml:space="preserve">
          <source>As you're writing in PHP I'd advice you to use the PHP build-in validation for emails.</source>
          <target state="translated">PHP로 작성하는 동안 이메일에 PHP 내장 유효성 검사를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="47bf4436a0ce6299cec6effd82a884e698974efd" translate="yes" xml:space="preserve">
          <source>Basic:</source>
          <target state="translated">Basic:</target>
        </trans-unit>
        <trans-unit id="0073f212804bc3306f849cfa8b512d52e55a727a" translate="yes" xml:space="preserve">
          <source>Confirmation tokens are the only way to know you got the address of the person entering it. This is why most mailing lists now use that mechanism to confirm sign-ups. After all, anybody can put down &lt;code&gt;president@whitehouse.gov&lt;/code&gt;, and that will even parse as legal, but it isn't likely to be the person at the other end.</source>
          <target state="translated">확인 토큰은 입력 한 사람의 주소를 알 수있는 유일한 방법입니다. 이것이 대부분의 메일 링리스트가 가입을 확인하기 위해이 메커니즘을 사용하는 이유입니다. 결국, 누구든지 &lt;code&gt;president@whitehouse.gov&lt;/code&gt; 를 내려 놓을 수 있으며, 이는 합법적 인 것으로 해석 될 수 있지만, 다른 쪽 사람은 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d15eaf92a267e0a03325e52d09f34bab6f23882" translate="yes" xml:space="preserve">
          <source>Context:</source>
          <target state="translated">Context:</target>
        </trans-unit>
        <trans-unit id="f828a4a98f03513a4667164d14af724f3d41a094" translate="yes" xml:space="preserve">
          <source>Correcting the &lt;code&gt;00&lt;/code&gt; bug in the IP pattern, we obtain a working and fairly fast regex.  (Scrape the rendered version, not the markdown, for actual code.)</source>
          <target state="translated">IP 패턴의 &lt;code&gt;00&lt;/code&gt; 버그를 수정하여 작업 속도가 빠르고 정규식을 얻습니다. (실제 코드의 경우 마크 다운이 아닌 렌더링 된 버전을 폐기합니다.)</target>
        </trans-unit>
        <trans-unit id="bf64925120bcbd811e65f1c72f59a3f04f836d22" translate="yes" xml:space="preserve">
          <source>Debuggex Demo</source>
          <target state="translated">Debuggex 데모</target>
        </trans-unit>
        <trans-unit id="61dca52965a9edf91b73613147e9ac7c10c8eeea" translate="yes" xml:space="preserve">
          <source>Different syntaxes should be used for different purposes. If you want to scan for email addresses in a (possibly very old) document it may be a good idea to use the syntax as defined in RFC 822. On the other hand, if you want to validate user input you may want to use the syntax as defined in RFC 5322, probably only accepting canonical representations. You should decide which syntax applies to your specific case.</source>
          <target state="translated">다른 목적으로 다른 구문을 사용해야합니다. 매우 오래된 문서에서 전자 메일 주소를 검색하려면 RFC 822에 정의 된 구문을 사용하는 것이 좋습니다. 반면에 사용자 입력의 유효성을 검사하려면 RFC 5322에 정의 된 구문으로, 정규 표현 만 허용합니다. 특정 사례에 적용 할 구문을 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc6873ddb69d463add1609634358323011bb0f08" translate="yes" xml:space="preserve">
          <source>Don't know about best, but &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;this one&lt;/a&gt; is at least correct, as long as the addresses have their comments stripped and replaced with whitespace.</source>
          <target state="translated">가장 잘 모르지만 주소에 주석이 제거되고 공백으로 대체되는 &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;한 이것은&lt;/a&gt; 정확합니다.</target>
        </trans-unit>
        <trans-unit id="850a13e5767f580f2031a50d8569b73c2488bbf5" translate="yes" xml:space="preserve">
          <source>EDIT:
From the link:</source>
          <target state="translated">편집 : 링크에서 :</target>
        </trans-unit>
        <trans-unit id="4986de5889e2f11c9bbdb9ef8b2a461042b1376a" translate="yes" xml:space="preserve">
          <source>Elaborate answer</source>
          <target state="translated">정교한 답변</target>
        </trans-unit>
        <trans-unit id="4d171fe5e95a2abcc5be91fb682415349c363bb7" translate="yes" xml:space="preserve">
          <source>For PHP, you should &lt;em&gt;not&lt;/em&gt; use the pattern given in &lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;Validate an E-Mail Address with PHP, the Right Way&lt;/a&gt; from which I quote:</source>
          <target state="translated">PHP의 경우 PHP &lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;로 전자 메일 주소 확인에&lt;/a&gt; 제공된 패턴을 사용해서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="388c8341169873cbf876d842d5c93f563b812762" translate="yes" xml:space="preserve">
          <source>For a vivid demonstration, the following monster is pretty good but still does not correctly recognize all syntactically valid email addresses: it recognizes nested comments up to four levels deep.</source>
          <target state="translated">생생한 데모를 위해 다음 몬스터는 훌륭하지만 구문 상 유효한 모든 이메일 주소를 올바르게 인식하지 못합니다. 중첩 된 주석은 최대 4 단계까지 인식합니다.</target>
        </trans-unit>
        <trans-unit id="844bb7409b2bf0d129a7300da9332ae49f500e9f" translate="yes" xml:space="preserve">
          <source>For the most comprehensive evaluation of the best regular expression for validating an email address please see this link; &quot;&lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;&quot;</source>
          <target state="translated">이메일 주소 확인을위한 최상의 정규식에 대한 가장 포괄적 인 평가는이 링크를 참조하십시오. &quot; &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;정규식 확인 이메일 주소 비교&lt;/a&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="810c3f2bf5a7cff75d30fdb21ab358a9d78d240a" translate="yes" xml:space="preserve">
          <source>For your regex of domain part, domain name cannot starts with '-' and cannot ends with '-'. Dash can only stays in between.</source>
          <target state="translated">정규식 도메인 부분의 경우 도메인 이름은 '-'로 시작할 수 없으며 '-'로 끝날 수 없습니다. 대시는 사이에만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="858f135b293e0d7506e7d37d2280ccbde6e7451a" translate="yes" xml:space="preserve">
          <source>Further considerations</source>
          <target state="translated">추가 고려 사항</target>
        </trans-unit>
        <trans-unit id="985180927b564d247d4e14d076eb593cde86c3fb" translate="yes" xml:space="preserve">
          <source>Further restrictions</source>
          <target state="translated">추가 제한 사항</target>
        </trans-unit>
        <trans-unit id="1c80cf144e810a9d98d32782de59c315753f43bf" translate="yes" xml:space="preserve">
          <source>Furthermore, an address having a dot at the end, like &lt;code&gt;user@company.&lt;/code&gt; is accepted by MailAddress as well.</source>
          <target state="translated">또한 &lt;code&gt;user@company.&lt;/code&gt; 와 같이 끝에 점이있는 주소 입니다. MailAddress에서도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="090fe8536ba48667df2f9156f2408f10a24285d6" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;diagram&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite state machine&lt;/a&gt; for above regexp which is more clear than regexp itself</source>
          <target state="translated">다음은 정규 표현식 자체보다 명확한 정규 표현식 위의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;유한 상태 머신&lt;/a&gt; &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;다이어그램&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a7827f413e7dc52ce89180fc06b75a173a00bb2" translate="yes" xml:space="preserve">
          <source>Here is the current top expression for reference purposes:</source>
          <target state="translated">다음은 참조 용으로 현재 최상위 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="f1b99749e961642af10fe964ad761b71345efbe1" translate="yes" xml:space="preserve">
          <source>Here's the PHP I use. I've choosen this solution in the spirit of &quot;false positives are better than false negatives&quot; as declared by another commenter here AND with regards to keeping your response time up and server load down ... there's really no need to waste server resources with a regular expression when this will weed out most simple user error. You can always follow this up by sending a test email if you want.</source>
          <target state="translated">내가 사용하는 PHP는 다음과 같습니다. 여기에 다른 주석 작성자가 선언 한 &quot;거짓 긍정이 거짓 긍정보다 낫다&quot;라는 정신 으로이 솔루션을 선택했으며 응답 시간을 늘리고 서버로드를 유지하는 것과 관련하여 서버 리소스를 낭비 할 필요가 없습니다. 이것이 가장 간단한 사용자 오류를 제거 할 때 정규 표현식. 원하는 경우 언제든지 테스트 이메일을 보내이 문제를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c555de7c7b1f7b703afcbb25f5d37921cd5a5f3c" translate="yes" xml:space="preserve">
          <source>Here's the derivation:</source>
          <target state="translated">파생은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40e3a2be8d888879a228175a976ea9a711b4df90" translate="yes" xml:space="preserve">
          <source>How to validate an email address using a regular expression</source>
          <target state="translated">정규식을 사용하여 이메일 주소를 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="b7c6fcdddbab0b180253335877c4f6f7061b17bc" translate="yes" xml:space="preserve">
          <source>I also do not recommend explicitly validating against a list of literal top-level domains or even imposing length-constraints (remember how &quot;.museum&quot; invalidated &lt;code&gt;[a-z]{2,4}&lt;/code&gt;), but if you must:</source>
          <target state="translated">또한 리터럴 최상위 도메인 목록에 대해 명시 적으로 유효성 검사를하거나 길이 제약 조건을 적용하는 것도 권장하지 않습니다 ( &quot;.museum&quot;이 &lt;code&gt;[a-z]{2,4}&lt;/code&gt; 무효화 한 방법 기억 &quot;).</target>
        </trans-unit>
        <trans-unit id="6106b21b52d6c2869f1edf73c29f89a75ca99ea7" translate="yes" xml:space="preserve">
          <source>I arrived at the following regular expression. I invite everyone to try and break it. If you find any false positives or false negatives, please post them in a comment and I'll try to fix the expression as soon as possible.</source>
          <target state="translated">나는 다음 정규식에 도착했다. 나는 모든 사람들이 그것을 시도하고 중단하도록 초대합니다. 오탐 또는 오탐을 발견하면 의견에 게시하고 가능한 빨리 식을 수정하도록 노력하겠습니다.</target>
        </trans-unit>
        <trans-unit id="de12597981cafac001a63547fcd2d56956471988" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 5322 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">나는 그것이 &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;정오표를&lt;/a&gt; 포함하여 RFC 5322를 완전히 준수한다고 생각합니다. 표준 형식의 전자 메일 주소 만 인식합니다. 공백을 인식 (접는)하는 정규식에 대해서는 아래 파생을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="89706fb75be6521376b620efafa6099e39529f6f" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 822 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">나는 그것이 &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;정오표를&lt;/a&gt; 포함하여 RFC 822를 완전히 준수한다고 생각합니다. 표준 형식의 전자 메일 주소 만 인식합니다. 공백을 인식 (접는)하는 정규식에 대해서는 아래 파생을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f512b55ca04846c10d5913e0fe2ed677435f773d" translate="yes" xml:space="preserve">
          <source>I collated test cases from Cal Henderson, Dave Child, Phil Haack, Doug Lovell, RFC5322 and RFC 3696. 275 test addresses in all. I ran all these tests against all the free validators I could find.</source>
          <target state="translated">Cal Henderson, Dave Child, Phil Haack, Doug Lovell, RFC5322 및 RFC 3696에서 테스트 사례를 수집했습니다. 내가 찾은 모든 무료 유효성 검사기에 대해 이러한 모든 테스트를 실행했습니다.</target>
        </trans-unit>
        <trans-unit id="8bc4518aeece4f1a66566191f1afe71e2bbca678" translate="yes" xml:space="preserve">
          <source>I discuss some issues in my &lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;answer to Is there a php library for email address validation?&lt;/a&gt;, it is discussed also in &lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;Regexp recognition of email address hard?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;이메일 주소 확인을위한 PHP 라이브러리가 있습니까?&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;전자 메일 주소의 정규식 인식에&lt;/a&gt; 대해서도 논의되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="a8865bf5a399677a2e921d40976a7e3002e86774" translate="yes" xml:space="preserve">
          <source>I do not recommend restricting the local part further, e.g. by precluding quoted strings, since we don't know what kind of mailbox names some hosts allow (like &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; or even &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; 또는 &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt; 과 같이 어떤 호스트가 어떤 사서함 이름을 허용하는지 알 수 없으므로 로컬 부분을 더 이상 제한하지 않는 것이 좋습니다 (예 : 따옴표로 묶은 문자열 제외) . 그물 ).</target>
        </trans-unit>
        <trans-unit id="b8e124659a2c24af661cc381668ac370a95c11e1" translate="yes" xml:space="preserve">
          <source>I ignored all the &quot;obs-&quot; rules from the RFC. This means that the regexes only match email addresses that are strictly RFC 5322 compliant. If you have to match &quot;old&quot; addresses (as the looser grammar including the &quot;obs-&quot; rules does), you can use one of the RFC 822 regexes from the previous paragraph.</source>
          <target state="translated">RFC의 모든 &quot;obs-&quot;규칙을 무시했습니다. 이는 정규 표현식이 엄격하게 RFC 5322를 준수하는 이메일 주소와 만 일치 함을 의미합니다. &quot;오래된&quot;주소와 일치해야하는 경우 ( &quot;obs-&quot;규칙을 포함한 느슨한 문법처럼) 이전 단락의 RFC 822 정규식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="062a5233c8de0b33af018e4eeae4a1ba0c95916d" translate="yes" xml:space="preserve">
          <source>I never bother creating with my own regular expression, because chances are that someone else has already come up with a better version.  I always use &lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib&lt;/a&gt; to find one to my liking.</source>
          <target state="translated">다른 사람이 이미 더 나은 버전을 만들었을 가능성이 있기 때문에 나는 내 자신의 정규 표현식으로 작성하는 것을 귀찮게하지 않습니다. 나는 항상 &lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib&lt;/a&gt; 를 사용하여 원하는 것을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="088e64f9ee7f255c4c5eac7974a7114e20492d11" translate="yes" xml:space="preserve">
          <source>I use</source>
          <target state="translated">나는 사용한다</target>
        </trans-unit>
        <trans-unit id="6795b75201299955c1b7995c570b13d659921b18" translate="yes" xml:space="preserve">
          <source>I use POSIX &quot;extended&quot; regular expressions in this answer, assuming an ASCII compatible character set.</source>
          <target state="translated">ASCII 호환 문자 집합을 가정하여 POSIX &quot;확장 된&quot;정규식을이 답변에 사용합니다.</target>
        </trans-unit>
        <trans-unit id="56d0d3ff30df9317fddde67f83205c8cb0ff3cec" translate="yes" xml:space="preserve">
          <source>I use it in several PHP programs, and it works most of the time.  However, from time to time I get contacted by someone that is having trouble with a site that uses it, and I end up having to make some adjustment (most recently I realized that I wasn't allowing 4-character TLDs).</source>
          <target state="translated">여러 PHP 프로그램에서 사용하며 대부분 작동합니다. 그러나 때때로 나는 그것을 사용하는 사이트에 문제가있는 누군가와 연락을 취하고 조정해야합니다 (가장 최근에는 4 자 TLD를 허용하지 않는다는 것을 깨달았습니다).</target>
        </trans-unit>
        <trans-unit id="034d131aacb2134a772bdf60fff06a86578e9c3f" translate="yes" xml:space="preserve">
          <source>I'll try to keep this page up-to-date as people enhance their validators. Thanks to Cal, Michael, Dave, Paul and Phil for their help and co-operation in compiling these tests and constructive criticism of &lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;my own validator&lt;/a&gt;.</source>
          <target state="translated">사람들이 유효성 검사기를 향상시킬 때이 페이지를 최신 상태로 유지하려고합니다. 이 테스트를 컴파일하고 &lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;내 검증&lt;/a&gt; 자의 건설적인 비판에 도움을 주신 Cal, Michael, Dave, Paul 및 Phil에게 감사의 말을 전합니다.</target>
        </trans-unit>
        <trans-unit id="8588212a8c9ffe41b9ef89fa0c2610e960516246" translate="yes" xml:space="preserve">
          <source>I've seen several solutions that use functions that use several shorter expressions, but I'd rather have one long complex expression in a simple function instead of several short expression in a more complex function.</source>
          <target state="translated">여러 개의 더 짧은 표현식을 사용하는 함수를 사용하는 여러 솔루션을 보았지만 더 복잡한 함수의 여러 짧은 표현식 대신 간단한 함수에서 하나의 긴 복잡한 표현식을 사용하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="725e5ed871d70812fff5a898374748169242406b" translate="yes" xml:space="preserve">
          <source>If the purpose of the regex is just to quickly inform the user in the UI that the specified email address doesn't look like in the right format, best is still to check if it matches basically the following regex:</source>
          <target state="translated">정규식의 목적이 UI에서 지정된 이메일 주소가 올바른 형식으로 보이지 않음을 사용자에게 신속하게 알리는 것이라면 기본적으로 다음 정규식과 일치하는지 확인하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="64cac7449f582a2dc109b435c4145c5f430d12f4" translate="yes" xml:space="preserve">
          <source>If you plan to use the &lt;code&gt;MailAddress&lt;/code&gt; to validate the e-mail address, be aware that this approach accepts the display name part of the e-mail address as well, and that may not be exactly what you want to achieve. For example, it accepts these strings as valid e-mail addresses:</source>
          <target state="translated">&lt;code&gt;MailAddress&lt;/code&gt; 를 사용하여 전자 메일 주소의 유효성을 검사하려는 경우이 방법을 사용하면 전자 메일 주소의 표시 이름 부분도 허용되므로 정확하게 달성하려는 것이 아닐 수도 있습니다. 예를 들어 다음 문자열을 유효한 전자 메일 주소로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="99811d1346d22a72366acd0b3ff9e1075ab2e9fc" translate="yes" xml:space="preserve">
          <source>If you really want to use a regex, &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;here it is&lt;/a&gt;:</source>
          <target state="translated">정규식을 실제로 사용하려면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44ce491ec374723f385ed8ad3f99125bd8e8fe92" translate="yes" xml:space="preserve">
          <source>If you used the PEAR library, check out their mail function (forgot the exact name/library).  You can validate email address by calling one function, and it validates the email address according to definition in RFC822.</source>
          <target state="translated">PEAR 라이브러리를 사용한 경우 메일 기능을 확인하십시오 (정확한 이름 / 라이브러리를 잊어 버렸습니다). 하나의 함수를 호출하여 이메일 주소를 검증 할 수 있으며 RFC822의 정의에 따라 이메일 주소를 검증합니다.</target>
        </trans-unit>
        <trans-unit id="89fdaa410759db94e2b5de2465bd333dc0953efc" translate="yes" xml:space="preserve">
          <source>If you want more information how this buid-in validation works, see here: &lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;Does PHP's filter_var FILTER_VALIDATE_EMAIL actually work?&lt;/a&gt;</source>
          <target state="translated">이 buid-in 유효성 검사의 작동 방식에 대한 자세한 내용은 다음을 참조하십시오. &lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;PHP의 filter_var FILTER_VALIDATE_EMAIL이 실제로 작동합니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c40d3684b422bc8ff6e3c9362de5de71480237e" translate="yes" xml:space="preserve">
          <source>If you want to get fancy and pedantic, &lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;implement a complete state engine&lt;/a&gt;. A regular expression can only act as a rudimentary filter. The problem with regular expressions is that telling someone that their perfectly valid e-mail address is invalid (a false positive) because your regular expression can't handle it is just rude and impolite from the user's perspective. A state engine for the purpose can both validate and even correct e-mail addresses that would otherwise be considered invalid as it disassembles the e-mail address according to each RFC. This allows for a potentially more pleasing experience, like</source>
          <target state="translated">화려하고 번거롭기를 원한다면 &lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;완전한 상태 엔진을 구현하십시오&lt;/a&gt; . 정규식은 기초 필터로만 작동 할 수 있습니다. 정규 표현식의 문제점은 정규 표현식이 처리 할 수 ​​없기 때문에 완벽하게 유효한 전자 메일 주소가 유효하지 않다고 잘못 판단한다는 것입니다 (사용자의 입장에서는 무례하고 무례합니다). 목적을위한 상태 엔진은 각 RFC에 따라 전자 우편 주소를 분해 할 때 유효하지 않은 전자 우편 주소를 검증하고 정정 할 수 있습니다. 이것은 잠재적으로 더 즐거운 경험을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="15c3b1fffdba1f0e987fbd41a9b09407c2fdc511" translate="yes" xml:space="preserve">
          <source>If you want to validate that an email is correct, you have no choice than to send an confirmation email and have the user reply to that. In many cases you will &lt;em&gt;have&lt;/em&gt; to send a confirmation mail anyway for security reasons or for ethical reasons (so you cannot e.g. sign someone up to a service against their will).</source>
          <target state="translated">이메일이 올바른지 확인하려면 확인 이메일을 보내서 사용자가 답장을 보내도록 선택할 수 있습니다. 대부분의 경우 보안상의 이유로 또는 윤리적 인 이유로 확인 메일을 보내야합니다 (따라서 자신의 의지에 반하여 서비스에 가입 할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="8f90c8045d52f4b058334a51ed4880471694677d" translate="yes" xml:space="preserve">
          <source>If you're running a php-version lower than 5.3.6 please be aware of this issue: &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https://bugs.php.net/bug.php?id=53091&lt;/a&gt;</source>
          <target state="translated">5.3.6보다 낮은 php 버전을 실행하는 경우이 문제에주의하십시오 : &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https://bugs.php.net/bug.php?id=53091&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bfe401233bd6300cf11a6837adc1067496b852ea" translate="yes" xml:space="preserve">
          <source>In short, don't expect a single, usable regex to do a proper job. And the best regex will validate the syntax, not the validity of an e-mail (jhohn@example.com is correct but it will probably bounce...).</source>
          <target state="translated">간단히 말해서, 사용 가능한 단일 정규 표현식이 올바른 작업을 수행 할 것으로 기대하지 마십시오. 그리고 최고의 정규 표현식은 전자 메일의 유효성이 아닌 구문의 유효성을 검사합니다 (jhohn@example.com은 정확하지만 반송 될 것입니다 ...).</target>
        </trans-unit>
        <trans-unit id="d64fa0e517911923332fac4e2f71d913ad55f9db" translate="yes" xml:space="preserve">
          <source>In some of these cases, only the last part of the strings is parsed as the address; the rest before that is the display name. To get a plain e-mail address without any display name, you can check the normalized address against your original string.</source>
          <target state="translated">이러한 경우 중 일부에서는 문자열의 마지막 부분 만 주소로 구문 분석됩니다. 그 전의 나머지는 표시 이름입니다. 표시 이름없이 일반 전자 메일 주소를 얻으려면 정규화 된 주소를 원래 문자열과 비교하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92b6aee3575856478de82d957aae0862c153d512" translate="yes" xml:space="preserve">
          <source>In this answer I&amp;rsquo;ll take &amp;ldquo;email address&amp;rdquo; to mean &lt;code&gt;addr-spec&lt;/code&gt; as defined in the RFCs (i.e. &lt;code&gt;jdoe@example.org&lt;/code&gt;, but not &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt;, nor &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt;).</source>
          <target state="translated">이 답변에서는 RFC에 정의 된대로 &lt;code&gt;addr-spec&lt;/code&gt; 을 의미하는&amp;ldquo;이메일 주소&amp;rdquo;를 사용합니다 (예 : &lt;code&gt;jdoe@example.org&lt;/code&gt; , &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29a575c86979b44c2fb0c43aa9e0d6c7884de728" translate="yes" xml:space="preserve">
          <source>Instead, use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt; class, like this:</source>
          <target state="translated">대신 다음과 같이 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt; 클래스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3cb298c6dabff17c93f08e57db5b7c214514b7" translate="yes" xml:space="preserve">
          <source>It all depends on how accurate you want to be.  For my purposes, where I'm just trying to keep out things like &lt;code&gt;bob @ aol.com&lt;/code&gt; (spaces in emails) or &lt;code&gt;steve&lt;/code&gt; (no domain at all) or &lt;code&gt;mary@aolcom&lt;/code&gt; (no period before .com), I use</source>
          <target state="translated">그것은 당신이 얼마나 정확한지에 달려 있습니다. 내 목적을 위해 &lt;code&gt;bob @ aol.com&lt;/code&gt; (이메일에 공백) 또는 &lt;code&gt;steve&lt;/code&gt; (도메인 없음) 또는 &lt;code&gt;mary@aolcom&lt;/code&gt; (.com 이전 기간 없음)과 같은 정보를 차단하려는 경우 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55c558aed4449d4838de9ba71870504efebc5f4d" translate="yes" xml:space="preserve">
          <source>It depends on what you mean by best:
If you're talking about catching every valid email address use the following:</source>
          <target state="translated">그것은 당신이 가장 의미하는 바에 달려 있습니다 : 유효한 모든 이메일 주소를 잡는 것에 대해 이야기하고 있다면 다음을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="634ea515e24f27b27c16f1ac8df53108713d9618" translate="yes" xml:space="preserve">
          <source>It does not prevent people from entering invalid or made-up email addresses, or entering someone else's address.</source>
          <target state="translated">사람들이 유효하지 않거나 구성한 전자 우편 주소를 입력하거나 다른 사람의 주소를 입력하는 것을 막지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef282074cd0ee12c9819b8667cca979a4d908a32" translate="yes" xml:space="preserve">
          <source>It should however be noted that if you want to find out if the address actually refers to an existing mailbox, there's no substitute for sending a message to the address. If you only want to check if an address is grammatically correct then you could use a regular expression, but note that &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; is a grammatically correct email address that certainly doesn't refer to an existing mailbox.</source>
          <target state="translated">그러나 주소가 실제로 기존 사서함을 참조하는지 확인하려면 해당 주소로 메시지를 보내는 대신 사용할 수 없습니다. 주소가 문법적으로 정확한지 확인하려면 정규식을 사용할 수 있지만 &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; 는 기존 사서함을 참조하지 않는 문법적으로 올바른 전자 메일 주소입니다.</target>
        </trans-unit>
        <trans-unit id="cc84b5c5472043636abf125126a167f8104cf798" translate="yes" xml:space="preserve">
          <source>It will not catch common typos.</source>
          <target state="translated">일반적인 오타는 잡을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="748495ccfc92d4a51e5e47b57ba34035d4c9f075" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy in Perl 5.10 or newer:</source>
          <target state="translated">Perl 5.10 이상에서는 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c36addb1f9a0630cf0fa05910cfe747100da3dcb" translate="yes" xml:space="preserve">
          <source>It's also important to understand that validating it per the RFC tells you absolutely nothing about whether that address actually exists at the supplied domain, or whether the person entering the address is its true owner. People sign others up to mailing lists this way all the time. Fixing that requires a fancier kind of validation that involves sending that address a message that includes a confirmation token meant to be entered on the same web page as was the address.</source>
          <target state="translated">또한 RFC에 따라 유효성을 검사하면 해당 주소가 제공된 도메인에 실제로 존재하는지 또는 주소를 입력 한 사람이 실제 소유자인지 여부를 전혀 알 수 없음을 이해하는 것이 중요합니다. 사람들은 항상 이런 방식으로 다른 사람들에게 메일 링리스트에 서명합니다. 주소와 동일한 웹 페이지에 입력되어야하는 확인 토큰을 포함하는 메시지를 해당 주소로 전송하는 것과 같은보다 우수한 종류의 유효성 검사가 필요한 수정.</target>
        </trans-unit>
        <trans-unit id="59fc40df1759e098dcd512bdd762d89c1c4815c1" translate="yes" xml:space="preserve">
          <source>Make sure to keep your regex up-to-date if you decide to go down the path of explicit top-level domain validation.</source>
          <target state="translated">명시적인 최상위 도메인 유효성 검사 경로를 내려 가기로 결정한 경우 정규식을 최신 상태로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="aa2ea3e7fb557b8b8b13fa28afb31c3928419cfd" translate="yes" xml:space="preserve">
          <source>None of the regexes in this answer are optimized for performance. If performance is an issue, you should see if (and how) the regex of your choice can be optimized.</source>
          <target state="translated">이 답변의 정규식 중 어느 것도 성능에 최적화되어 있지 않습니다. 성능이 문제인 경우 선택한 정규식을 최적화 할 수 있는지 (및 방법) 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a469b7426fdfa686180a96ef3fe9463e2cbdbd8" translate="yes" xml:space="preserve">
          <source>Not to mention that non-Latin (Chinese, Arabic, Greek, Hebrew, Cyrillic and so on) domain names are to be allowed in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;near future&lt;/a&gt;. Everyone has to change the email regex used, because those characters are surely not to be covered by &lt;code&gt;[a-z]/i&lt;/code&gt; nor &lt;code&gt;\w&lt;/code&gt;. They will all fail.</source>
          <target state="translated">비 라틴어 (중국어, 아랍어, 그리스어, 히브리어, 키릴 어 등) 도메인 이름은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;가까운 시일&lt;/a&gt; 내에 허용됩니다. 문자는 반드시 &lt;code&gt;[a-z]/i&lt;/code&gt; 또는 &lt;code&gt;\w&lt;/code&gt; 가 적용되지 않기 때문에 모든 사람이 사용한 이메일 정규식을 변경해야합니다. 그들은 모두 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ed883c2a93aaa8eff111b58e6939a3cdb4b3d6af" translate="yes" xml:space="preserve">
          <source>Note that depending on the use case you may not want to allow for a &quot;General-address-literal&quot; in your regex. Also note that I used a negative lookahead &lt;code&gt;(?!IPv6:)&lt;/code&gt; in the final regex to prevent the &quot;General-address-literal&quot; part to match malformed IPv6 addresses. Some regex processors don't support negative lookahead. Remove the substring &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; from the regex if you want to take the whole &quot;General-address-literal&quot; part out.</source>
          <target state="translated">유스 케이스에 따라 정규 표현식에서 &quot;일반 주소 리터럴&quot;을 허용하지 않을 수도 있습니다. 또한 최종 정규식에서 부정적인 예측 &lt;code&gt;(?!IPv6:)&lt;/code&gt; 을 사용하여 &quot;일반 주소 리터럴&quot;부분이 잘못된 IPv6 주소와 일치하지 않도록합니다. 일부 정규식 프로세서는 부정적 예측을 지원하지 않습니다. 전체 문자열을 &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; 에서 하위 문자열 | (?! IPv6 :) [0-9A-Za-z-] * [0-9A-Za-z] : [!-Z ^-~] +를 제거하십시오. &quot;일반 주소 리터럴&quot;부분.</target>
        </trans-unit>
        <trans-unit id="1603724f5f43f1edae560e9739defad7e033ecee" translate="yes" xml:space="preserve">
          <source>Note that some sources (notably &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt;) claim that RFC 5322 is too strict on the local part (i.e. the part before the @-sign). This is because &quot;..&quot;, &quot;a..b&quot; and &quot;a.&quot; are &lt;em&gt;not&lt;/em&gt; valid dot-atoms, while they may be used as mailbox names. The RFC, however, &lt;em&gt;does&lt;/em&gt; allow for local parts like these, except that they have to be quoted. So instead of &lt;code&gt;a..b@example.net&lt;/code&gt; you should write &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt;, which is semantically equivalent.</source>
          <target state="translated">일부 소스 (특히 &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt; )는 RFC 5322가 로컬 부분 (즉, @ 기호 앞 부분)에서 너무 엄격하다고 주장합니다. &quot;..&quot;, &quot;a..b&quot;및 &quot;a.&quot;때문입니다. 사서함 이름으로 사용될 수 있지만 유효한 점 원자는 &lt;em&gt;아닙니다&lt;/em&gt; . 그러나 RFC는 인용해야하는 것을 제외하고 이와 같은 로컬 부품을 허용합니다. 따라서 &lt;code&gt;a..b@example.net&lt;/code&gt; 대신 &quot;a..b&quot;@example.net 을 작성해야합니다. 이는 의미 적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a414e2438f7c9cf87c83b4983b266d69534ed05a" translate="yes" xml:space="preserve">
          <source>Note: This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &amp;ldquo;@&amp;rdquo; character), too vague (after the &amp;ldquo;@&amp;rdquo; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">참고 :이 요구 사항은 &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322를&lt;/a&gt; &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;고의적으로 위반&lt;/a&gt; 하는 것으로, 동시에 너무 엄격한 ( &quot;@&quot;문자 앞), 너무 모호한 ( &quot;@&quot;문자 뒤), 너무 느슨해 진 주석, 공백 문자 및 대부분의 사용자에게 친숙하지 않은 방식으로 인용 된 문자열을 여기에서 실제로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a60dff653e359c769e135e4c04c6e895ea0123b7" translate="yes" xml:space="preserve">
          <source>One RFC 5322 compliant regex can be found at the top of the page at &lt;a href=&quot;http://emailregex.com/&quot;&gt;http://emailregex.com/&lt;/a&gt; but uses the IP address pattern that is floating around the internet with a bug that allows &lt;code&gt;00&lt;/code&gt; for any of the unsigned byte decimal values in a dot-delimited address, which is illegal.  The rest of it appears to be consistent with the RFC 5322 grammar and passes several tests using &lt;code&gt;grep -Po&lt;/code&gt;, including cases domain names, IP addresses, bad ones, and account names with and without quotes.</source>
          <target state="translated">하나의 RFC 5322 호환 정규 표현식은 &lt;a href=&quot;http://emailregex.com/&quot;&gt;http://emailregex.com/&lt;/a&gt; 페이지 상단에서 찾을 수 있지만 부호없는 바이트 10 진수 값에 대해 &lt;code&gt;00&lt;/code&gt; 을 허용하는 버그로 인터넷 주위에 떠있는 IP 주소 패턴을 사용합니다. 점으로 구분 된 주소로, 불법입니다. 나머지는 RFC 5322 문법과 일치하는 것으로 보이며 도메인 이름, IP 주소, 잘못된 주소 및 계정 이름 (따옴표 포함)을 포함하거나 포함하지 않는 경우를 포함하여 &lt;code&gt;grep -Po&lt;/code&gt; 를 사용하여 여러 테스트를 통과했습니다.</target>
        </trans-unit>
        <trans-unit id="6849c03183bc687fc66af67fdc8fab74faf61cad" translate="yes" xml:space="preserve">
          <source>One simple regular expression which would at least not reject any valid email address would be checking for something, followed by an @ sign and then something followed by a period and at least 2 somethings. It won't reject anything, but after reviewing the spec I can't find any email that would be valid and rejected.</source>
          <target state="translated">유효한 전자 메일 주소를 적어도 거부하지 않는 간단한 정규 표현식은 무언가를 확인한 다음 @ 기호를 사용한 다음 마침표와 최소한 2 개의 무언가를 확인하는 것입니다. 아무것도 거부하지 않지만 사양을 검토 한 후 유효하고 거부되는 이메일을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eacf0af0cb780f7e0cc0c41e3539fd563e478436" translate="yes" xml:space="preserve">
          <source>Over the years I have slowly developed a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; that validates MOST email addresses correctly, assuming they don't use an IP address as the server part.</source>
          <target state="translated">지난 몇 년 동안 나는 IP 주소를 서버 부분으로 사용하지 않는다고 가정하면서 MOST 전자 메일 주소의 유효성을 올바르게 검사하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;정규식&lt;/a&gt; 을 천천히 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="4e44c1594bc79271466627aea4dc6d92f45efa87" translate="yes" xml:space="preserve">
          <source>People should be aware of the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;errata against RFC 3696&lt;/a&gt; in particular. Three of the canonical examples are in fact invalid addresses. And the maximum length of an address is 254 or 256 characters, &lt;strong&gt;not&lt;/strong&gt; 320.</source>
          <target state="translated">사람들은 특히 &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;RFC 3696&lt;/a&gt; 에 대한 정오표를 알고 있어야합니다. 정식 예제 중 3 개는 실제로 유효하지 않은 주소입니다. 주소의 최대 길이는 320이 &lt;strong&gt;아니라&lt;/strong&gt; 254 자 또는 256 자입니다.</target>
        </trans-unit>
        <trans-unit id="d39c523f1fb1d41ff6e8a68ec88d7d3a31a24cd0" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;the W3C HTML5 spec&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;W3C HTML5 사양에 따라&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="56c0dad2b0956cd6ae32504c979c840f02cf3573" translate="yes" xml:space="preserve">
          <source>Quick answer</source>
          <target state="translated">빠른 답변</target>
        </trans-unit>
        <trans-unit id="fa2251418aa68903f6488427bde3d8e415a9f16a" translate="yes" xml:space="preserve">
          <source>RFC 5321 basically leaves alone the &quot;local&quot; part (i.e. the part before the @-sign), but is stricter on the domain part (i.e. the part after the @-sign). It allows only host names in place of dot-atoms and address literals in place of domain literals.</source>
          <target state="translated">RFC 5321은 기본적으로 &quot;로컬&quot;부분 (예 : @ 기호 앞 부분) 만 남겨두고 도메인 부분 (예 : @ 기호 뒤에있는 부분)에서 더 엄격합니다. 도트 원자 대신 호스트 이름 만 허용하고 도메인 리터럴 대신 주소 리터럴을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="82af36243c542be2f1bd3a5fa7459b1dbce36d81" translate="yes" xml:space="preserve">
          <source>RFC 5321 standard:</source>
          <target state="translated">RFC 5321 표준 :</target>
        </trans-unit>
        <trans-unit id="17c58504badf8c1787c4ac4f95c466fc696f2e50" translate="yes" xml:space="preserve">
          <source>RFC 5322</source>
          <target state="translated">RFC 5322</target>
        </trans-unit>
        <trans-unit id="479d36b78205a178de44b9bbbe339cec9f59000b" translate="yes" xml:space="preserve">
          <source>RFC 5322 standard:</source>
          <target state="translated">RFC 5322 표준 :</target>
        </trans-unit>
        <trans-unit id="00af815762ae4e4ed879f00aa53f3fc9fc817b37" translate="yes" xml:space="preserve">
          <source>RFC 822</source>
          <target state="translated">RFC 822</target>
        </trans-unit>
        <trans-unit id="fd412bb5a3c2ad14d277d7a4b79b8f75df43ce9c" translate="yes" xml:space="preserve">
          <source>Regular expression built using Jeffrey Friedl's example in
  &lt;em&gt;Mastering Regular Expressions&lt;/em&gt; (&lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt;).</source>
          <target state="translated">정규 표현식 &lt;em&gt;마스터 링&lt;/em&gt; ( &lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt; )에서 Jeffrey Friedl의 예제를 사용하여 작성된 &lt;em&gt;정규 표현식&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4fa9d019350b110a4ff197daf305ce272d79f6ae" translate="yes" xml:space="preserve">
          <source>SMTP (as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321&lt;/a&gt;) further restricts the set of valid email addresses (or actually: mailbox names). It seems reasonable to impose this stricter grammar, so that the matched email address can actually be used to send an email.</source>
          <target state="translated">SMTP ( &lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321에&lt;/a&gt; 정의 된 대로 )는 유효한 이메일 주소 세트 (또는 실제로는 사서함 이름)를 제한합니다. 이 엄격한 문법을 ​​적용하는 것이 합리적이므로 일치하는 전자 메일 주소를 실제로 전자 메일을 보내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e509ea11bcd91c64419ceb313b8fded4cfb62a1" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;Validating Email Addresses&lt;/a&gt;, including the comments. Or &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;.</source>
          <target state="translated">주석을 포함하여 &lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;이메일 주소 확인&lt;/a&gt; 도 참조하십시오. 또는 &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;정규식 확인 이메일 주소 비교&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53a9c322bf8ce66569059aa3e1529b8bee955c35" translate="yes" xml:space="preserve">
          <source>Seriously. You should use an already written library for validating emails. The best way is probably to just send a verification e-mail to that address.</source>
          <target state="translated">진심으로. 이메일 유효성 검사를 위해 이미 작성된 라이브러리를 사용해야합니다. 가장 좋은 방법은 해당 주소로 확인 이메일을 보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a143d6225e75c2b766a2aee66d8dfbc3d273186e" translate="yes" xml:space="preserve">
          <source>Simple as that. Why on earth would you care about the characters used in the name and domain? It's the client's responsibility to enter a valid email address, not the server's. Even when the client enters a &lt;em&gt;syntactically&lt;/em&gt; valid email address like &lt;code&gt;aa@bb.cc&lt;/code&gt;, this does not guarantee that it's a legit email address. No one regex can cover that.</source>
          <target state="translated">그렇게 간단합니다. 왜 지구상에서 이름과 도메인에 사용 된 캐릭터에 관심이 있습니까? 서버가 아닌 유효한 이메일 주소를 입력하는 것은 고객의 책임입니다. 클라이언트가 &lt;code&gt;aa@bb.cc&lt;/code&gt; 와 같이 &lt;em&gt;구문 상&lt;/em&gt; 유효한 이메일 주소를 입력하더라도 이것이 올바른 이메일 주소 임을 보장하지는 않습니다. 아무도 정규식으로 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="056115c235bea2846acb135ffdbd27cd4ae8abc4" translate="yes" xml:space="preserve">
          <source>Strange that you &quot;cannot&quot; allow 4 characters TLDs.  You are banning people from &lt;em&gt;.info&lt;/em&gt; and &lt;em&gt;.name&lt;/em&gt;, and the length limitation stop &lt;em&gt;.travel&lt;/em&gt; and &lt;em&gt;.museum&lt;/em&gt;, but yes, they are less common than 2 characters TLDs and 3 characters TLDs.</source>
          <target state="translated">4 문자 TLD를 &quot;수용 할 수 없습니다&quot;. &lt;em&gt;.info&lt;/em&gt; 및 &lt;em&gt;.name&lt;/em&gt; 에서는 사람들을 금지하고 길이 제한은 &lt;em&gt;.travel&lt;/em&gt; 및 &lt;em&gt;.museum을&lt;/em&gt; 중지하지만 그렇습니다. 2 자 TLD 및 3 자 TLD보다 덜 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="6cbd3caa8bdfcbb5ef664dabf829fa863056ac8a" translate="yes" xml:space="preserve">
          <source>Sure, it will match things that aren't valid email addresses, but it's a matter of playing the 90/10 rule.</source>
          <target state="translated">물론, 유효하지 않은 이메일 주소와 일치하지만 90/10 규칙을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="af4c67c3df524d5adb915aacca975c4f92acf0be" translate="yes" xml:space="preserve">
          <source>That is no better than all the other non-RFC patterns. It isn&amp;rsquo;t even smart enough to handle even &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt;, let alone RFC 5322. &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;This one&lt;/a&gt;, however, is.</source>
          <target state="translated">그것은 다른 모든 비 RFC 패턴보다 낫지 않습니다. RFC 5322는 물론 &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt; 도 처리 할만큼 똑똑하지 못합니다. 그러나 &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;이것은 하나&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a8b13790b55067f7d02a02213bba322543be649" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;fully RFC 822 compliant regex&lt;/a&gt; is inefficient and obscure because of its length.  Fortunately, RFC 822 was superseded twice and the current specification for email addresses is &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt;.  RFC 5322 leads to a regex that can be understood if studied for a few minutes and is efficient enough for actual use.</source>
          <target state="translated">&lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;완전 RFC 822 준수 정규식&lt;/a&gt; 은 길이 때문에 비효율적이고 모호합니다. 다행히 RFC 822가 두 번 대체되었으며 현재 이메일 주소 사양은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt; 입니다. RFC 5322는 몇 분 동안 연구하면 이해할 수 있고 실제 사용하기에 충분히 효율적인 정규식으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="efef7583ce1f5955d8622631b97ef21d277e0c78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 spec suggests&lt;/a&gt; a simple regex for validating email addresses:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 사양은&lt;/a&gt; 이메일 주소를 확인하기위한 간단한 정규식을 제안 합니다.</target>
        </trans-unit>
        <trans-unit id="cc7666184f88738787a730cc2f788c93befa5c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MailAddress&lt;/code&gt; class uses a BNF parser to validate the address in full accordance with RFC822.</source>
          <target state="translated">&lt;code&gt;MailAddress&lt;/code&gt; 클래스는 BNF 구문 분석기를 사용하여 RFC822에 따라 주소의 전체 유효성을 검증합니다.</target>
        </trans-unit>
        <trans-unit id="08094c7e000914320983bbc93438575ec83bb464" translate="yes" xml:space="preserve">
          <source>The RFCs define syntaxes for email messages, not for email addresses as such. Addresses may appear in various header fields and this is where they are primarily defined. When they appear in header fields addresses may contain (between lexical tokens) whitespace, comments and even linebreaks. Semantically this has no significance however. By removing this whitespace, etc. from an address you get a semantically equivalent &lt;em&gt;canonical representation&lt;/em&gt;. Thus, the canonical representation of &lt;code&gt;first. last (comment) @   [3.5.7.9]&lt;/code&gt; is &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt;.</source>
          <target state="translated">RFC는 이메일 주소가 아닌 이메일 메시지의 구문을 정의합니다. 주소는 다양한 헤더 필드에 나타날 수 있으며 여기에서 주로 정의됩니다. 헤더 필드에 나타날 때 주소에는 어휘 토큰 사이에 공백, 주석 및 줄 바꿈이 포함될 수 있습니다. 그러나 의미 상 이것은 의미가 없습니다. 주소에서이 공백 등을 제거하면 의미 적으로 동등한 &lt;em&gt;표준 표현&lt;/em&gt; 을 얻을 수 있습니다. 따라서 &lt;code&gt;first. last (comment) @ [3.5.7.9]&lt;/code&gt; 표준 표현 . last (comment) @ [3.5.7.9] 는 &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03bb5d368df58fc938931912f1a46085762490a6" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. For rules that include semantically irrelevant (folding) whitespace, I give a separate regex marked &quot;(normalized)&quot; that doesn't accept this whitespace.</source>
          <target state="translated">파생은 내가 어떻게 표현에 도착했는지 보여줍니다. RFC의 모든 관련 문법 규칙을 표시된대로 정확하게 나열한 다음 해당 정규식을 나열합니다. 의미 상 관련이없는 (접기) 공백을 포함하는 규칙의 경우이 공백을 허용하지 않는 &quot;(정규화 된)&quot;으로 표시된 별도의 정규식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b143a24ff4d5dac8a1b58259e6ef61a5327993b2" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. Where an erratum has been published I give a separate expression for the corrected grammar rule (marked &quot;erratum&quot;) and use the updated version as a subexpression in subsequent regular expressions.</source>
          <target state="translated">파생은 내가 어떻게 표현에 도착했는지 보여줍니다. RFC의 모든 관련 문법 규칙을 표시된대로 정확하게 나열한 다음 해당 정규식을 나열합니다. 정오표가 게시 된 곳에서는 수정 된 문법 규칙 ( &quot;erratum&quot;으로 표시)에 대해 별도의 식을 제공하고 후속 정규식에서 업데이트 된 버전을 하위 식으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c988189fcad54702295e206fc75fe6d5f6101f50" translate="yes" xml:space="preserve">
          <source>The email addresses I want to validate are going to be used by an ASP.NET web application using the System.Net.Mail namespace to send emails to a list of people. So, rather than using some very complex regular expression, I just try to create a MailAddress instance from the address. The MailAddress construtor will throw an exception if the address is not formed properly. This way, I know I can at least get the email out of the door. Of course this is server-side validation but at a minimum you need that anyway.</source>
          <target state="translated">유효성을 검사하려는 전자 메일 주소는 System.Net.Mail 네임 스페이스를 사용하는 ASP.NET 웹 응용 프로그램에서 전자 메일을 사람 목록으로 보내는 데 사용됩니다. 따라서 매우 복잡한 정규식을 사용하는 대신 주소에서 MailAddress 인스턴스를 만들려고합니다. 주소가 올바르게 구성되지 않으면 MailAddress 구성자가 예외를 처리합니다. 이런 식으로, 나는 최소한 이메일을 문 밖으로 가져올 수 있다는 것을 알고 있습니다. 물론 이것은 서버 측 유효성 검사이지만 최소한 어쨌든 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2c42e1dbf8f30a22743d35f41dec49ad83dcbd78" translate="yes" xml:space="preserve">
          <source>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</source>
          <target state="translated">다음 JavaScript 및 Perl 호환 정규식은 위 정의를 구현 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="04b741d2a83f024156fc1aafe328ecd03eac2d01" translate="yes" xml:space="preserve">
          <source>The grammar presented in RFC 5321 is too lenient when it comes to both host names and IP addresses. I took the liberty of &quot;correcting&quot; the rules in question, using &lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;this draft&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034&lt;/a&gt; as guidelines. Here's the resulting regex.</source>
          <target state="translated">RFC 5321에 제시된 문법은 호스트 이름과 IP 주소 모두에있어 너무 관대합니다. &lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;이 초안&lt;/a&gt; 과 &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034&lt;/a&gt; 를 지침으로 사용하여 문제의 규칙을 &quot;수정&quot;할 자유를 얻었습니다. 결과 정규식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78bea17cadfee2e52d3b0ba653aeb8078d41c522" translate="yes" xml:space="preserve">
          <source>The more sophisticated patterns in Perl and PCRE (regex library used e.g. in PHP) can &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;correctly parse RFC 5322 without a hitch&lt;/a&gt;. Python and C# can do that too, but they use a different syntax from those first two. However, if you are forced to use one of the many less powerful pattern-matching languages, then it&amp;rsquo;s best to use a real parser.</source>
          <target state="translated">Perl 및 PCRE의보다 정교한 패턴 (예 : PHP에서 사용되는 정규식 라이브러리)은 &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;장애없이 RFC 5322를 올바르게 구문 분석&lt;/a&gt; 할 수 있습니다. 파이썬과 C #도 그렇게 할 수 있지만 처음 두 가지와 다른 구문을 사용합니다. 그러나 패턴이 일치하지 않는 많은 언어 중 하나를 사용해야하는 경우 실제 구문 분석기를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f44b7e654912775bb48deb334cbbfbb5d94ad3b7" translate="yes" xml:space="preserve">
          <source>The second constraint is a restriction on RFC 5321/5322.</source>
          <target state="translated">두 번째 제약은 RFC 5321/5322에 대한 제한입니다.</target>
        </trans-unit>
        <trans-unit id="ddc5dad053b60eb7739c3fbde8711a0b846a2faf" translate="yes" xml:space="preserve">
          <source>The specified e-mail address 'myemail@address,com' is invalid. Did you mean 'myemail@address.com'?</source>
          <target state="translated">지정된 이메일 주소 'myemail @ address, com'이 유효하지 않습니다. 'myemail@address.com'을 의미 했습니까?</target>
        </trans-unit>
        <trans-unit id="ba008b9092dbf02ae78dce33e0ba3f4f3680e270" translate="yes" xml:space="preserve">
          <source>The syntax of email addresses has been defined in various &lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFCs&lt;/a&gt;, most notably &lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;. RFC 822 should be seen as the &quot;original&quot; standard and RFC 5322 as the latest standard. The syntax defined in RFC 822 is the most lenient and subsequent standards have restricted the syntax further and further, where newer systems or services should recognize obsolete syntax, but never produce it.</source>
          <target state="translated">이메일 주소의 구문은 다양한 &lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFC&lt;/a&gt; , 특히 &lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; 및 &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; 에서 정의되었습니다. RFC 822는 &quot;원본&quot;표준으로, RFC 5322는 최신 표준으로 간주해야합니다. RFC 822에 정의 된 구문은 가장 관대하며 그 이후의 표준으로 인해 새로운 시스템이나 서비스가 더 이상 사용되지 않는 구문을 인식해야하지만 구문을 생성하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="694230a2ce267bc8d03a82385bbedc868ccb9017" translate="yes" xml:space="preserve">
          <source>The total length could also be limited to 254 characters, per &lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;RFC 3696  errata 1690&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;RFC 3696 에라타 1690에&lt;/a&gt; 따라 총 길이도 254 자로 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c409e37bc8b674795dc6985a2965f07b4a91bec" translate="yes" xml:space="preserve">
          <source>There are plenty examples of this out on the net (and I think even one that fully validates the RFC - but it's tens/hundreds of lines long if memory serves). People tend to get carried away validating this sort of thing. Why not just check it has an @ and at least one . and meets some simple minimum length. It's trivial to enter a fake email and still match any valid regex anyway. I would guess that false positives are better than false negatives.</source>
          <target state="translated">그물에 이것의 많은 예가 있습니다 (그리고 RFC를 완전히 검증하는 것조차 생각합니다-그러나 메모리가 제공된다면 수십 / 수백 줄입니다). 사람들은 이런 종류의 일을 확인하는 경향이 있습니다. 왜 @ 하나 이상이 있는지 확인하지 않는 것이 좋습니다. 간단한 최소 길이를 충족시킵니다. 가짜 이메일을 입력하고 여전히 유효한 정규식과 일치하는 것은 쉽지 않습니다. 나는 거짓 긍정이 거짓 부정보다 낫다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="e65ce1fdf25d40bc41ca80ae15e74e6206ea4278" translate="yes" xml:space="preserve">
          <source>There is not one which is really usable.</source>
          <target state="translated">실제로 사용할 수있는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb8823d7f714e02a82ffff0eff38f0b5686cb83b" translate="yes" xml:space="preserve">
          <source>There is some danger that common usage and widespread sloppy coding will establish a de facto standard for e-mail addresses that is more restrictive than the recorded formal standard.</source>
          <target state="translated">일반적인 사용법과 널리 사용되는 조잡한 코딩으로 인해 기록 된 공식 표준보다 전자 메일 주소에 대한 사실상의 표준이 확립 될 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab562daff5b311a461fd5743bafead8320f8ac4" translate="yes" xml:space="preserve">
          <source>There's one problem with translating the RFC syntaxes into regexes: the syntaxes are not regular! This is because they allow for optional comments in email addresses that can be infinitely nested, while infinite nesting can't be described by a regular expression. To scan for or validate addresses containing comments you need a parser or more powerful expressions. (Note that languages like Perl have constructs to describe context free grammars in a regex-like way.) In this answer I'll disregard comments and only consider proper regular expressions.</source>
          <target state="translated">RFC 구문을 정규식으로 변환하는 데에는 한 가지 문제점이 있습니다. 구문이 규칙적이지 않습니다! 무한 중첩은 정규식으로 설명 할 수 없지만 무한 중첩 될 수있는 이메일 주소에 선택적 주석을 허용하기 때문입니다. 주석이 포함 된 주소를 스캔하거나 확인하려면 구문 분석기 또는보다 강력한 표현식이 필요합니다. Perl과 같은 언어에는 컨텍스트 프리 문법을 정규식과 같은 방식으로 설명하는 구문이 있습니다.이 답변에서는 주석을 무시하고 적절한 정규식 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="604bc09674b2ed7a86a57667d281ad5d75b92f79" translate="yes" xml:space="preserve">
          <source>These two considerations could be addressed by parsing the address. The extra length constraint on host names could in some cases also be addressed by using an extra regex that checks it, and matching the address against both expressions.</source>
          <target state="translated">이 두 가지 고려 사항은 주소를 구문 분석하여 해결할 수 있습니다. 호스트 이름에 대한 추가 길이 제한은 경우에 따라이를 확인하는 추가 정규식을 사용하고 주소를 두 표현식과 일치 시켜서 해결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a6068ef4c671cc993159bd9f7876a710e880eee" translate="yes" xml:space="preserve">
          <source>This intentionally doesn't comply with &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;.</source>
          <target state="translated">이것은 의도적으로 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322를&lt;/a&gt; 준수하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e3c059245745fe56b963a2dd674dc3a620e4611" translate="yes" xml:space="preserve">
          <source>This is a job for a parser, but even if an address is syntactically valid, it still may not be deliverable. Sometimes you have to resort to the hillbilly method of &quot;Hey, y'all, watch ee-us!&quot;</source>
          <target state="translated">이것은 파서의 작업이지만 주소가 구문 적으로 유효한 경우에도 여전히 전달할 수 없습니다. 때때로 &quot;Hey, y'all, watch ee-us!&quot;의 구릉지 방법에 의지해야 할 때가 있습니다.</target>
        </trans-unit>
        <trans-unit id="40bd4785946bbfd84d54b271e863481fe650854b" translate="yes" xml:space="preserve">
          <source>This question is asked a lot, but I think you should step back and ask yourself &lt;em&gt;why&lt;/em&gt; you want to validate email adresses syntactically? What is the benefit really?</source>
          <target state="translated">이 질문은 많이 제기되지만 이메일 주소를 구문 적으로 검증하고 싶은 &lt;em&gt;이유는&lt;/em&gt; 무엇입니까? 실제로 이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5b58c52e10b145304d80e39ff92b63c4aaad7cba" translate="yes" xml:space="preserve">
          <source>This regex is from Perl's &lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email::Valid&lt;/a&gt; library. I believe it to be the most accurate, it matches all 822. And, it is based on the regular expression in the O'Reilly book:</source>
          <target state="translated">이 정규식은 Perl의 &lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email :: Valid&lt;/a&gt; 라이브러리에 있습니다. 나는 그것이 가장 정확하다고 생각합니다. 그것은 822 개와 모두 일치합니다. 그리고 그것은 O'Reilly 책의 정규식을 기반으로합니다 :</target>
        </trans-unit>
        <trans-unit id="ab37a40832b8b946cb58d45531219e00bca7eb3a" translate="yes" xml:space="preserve">
          <source>This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module).</source>
          <target state="translated">이 정규식은 주석이 제거되고 공백으로 대체 된 주소 만 확인합니다 (모듈에서 수행함).</target>
        </trans-unit>
        <trans-unit id="881eea75af81659120231f1a02a723701d920b5f" translate="yes" xml:space="preserve">
          <source>Use the following regex for input validation:</source>
          <target state="translated">입력 검증에 다음 정규식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a38e078061a3af58841a4b63d102b4842c3180b3" translate="yes" xml:space="preserve">
          <source>User input validation</source>
          <target state="translated">사용자 입력 검증</target>
        </trans-unit>
        <trans-unit id="417d6b6f39c552dae06a913e7670f440710547a0" translate="yes" xml:space="preserve">
          <source>Using a regular expression that recognizes email addresses could be useful in various situations: for example to scan for email addresses in a document, to validate user input, or as an integrity constraint on a data repository.</source>
          <target state="translated">전자 메일 주소를 인식하는 정규식을 사용하면 문서에서 전자 메일 주소를 검색하거나 사용자 입력을 확인하거나 데이터 저장소의 무결성 제약 조건과 같은 다양한 상황에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7404787d1040c9c25b80ed394962a1fd680b081b" translate="yes" xml:space="preserve">
          <source>When only accepting host names in the domain part (after the @-sign), the regexes above accept only labels with at most 63 characters, as they should. However, they don't enforce the fact that the entire host name must be at most 253 characters long (including the dots). Although this constraint is strictly speaking still regular, it's not feasible to make a regex that incorporates this rule.</source>
          <target state="translated">도메인 부분에서 호스트 이름 만 허용하는 경우 (@ 기호 뒤에) 위의 정규 표현식은 최대 63 자의 레이블 만 허용합니다. 그러나 전체 호스트 이름이 최대 253 자 (점 포함) 여야한다는 사실을 강요하지 않습니다. 이 제약 조건은 여전히 ​​규칙적으로 말하지만이 규칙을 포함하는 정규식을 만드는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="6adb4fb8492c6fd0b85a550dd4f05a8dfdfca38d" translate="yes" xml:space="preserve">
          <source>Which is the one used in ASP.NET by the RegularExpressionValidator.</source>
          <target state="translated">RegularExpressionValidator가 ASP.NET에서 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="39672ee698f325ca5854a5b725c41110c115c08f" translate="yes" xml:space="preserve">
          <source>While deciding which characters are allowed, please remember your apostrophed and hyphenated friends. I have no control over the fact that my company generates my email address using my name from the HR system. That includes the apostrophe in my last name. I can't tell you how many times I have been blocked from interacting with a website by the fact that my email address is &quot;invalid&quot;.</source>
          <target state="translated">허용되는 문자를 결정할 때 아포스트로피와 하이픈을 넣은 친구를 기억하십시오. 회사가 HR 시스템에서 내 이름을 사용하여 내 이메일 주소를 생성한다는 사실을 통제 할 수 없습니다. 내성에 아포스트로피가 포함되어 있습니다. 내 이메일 주소가 &quot;유효하지 않다&quot;는 사실에 의해 웹 사이트와의 상호 작용이 차단 된 횟수를 알려 드릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="040788551c90816319df84a15c3045438d8955bd" translate="yes" xml:space="preserve">
          <source>You could use the one employed by the jQuery Validation plugin:</source>
          <target state="translated">jQuery Validation 플러그인에서 사용하는 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0376b0b9474c79623a7bcdd162cc203cdab2051" translate="yes" xml:space="preserve">
          <source>You should allow uppercase alphabets too.  Email systems will normalize the local part and domain part.</source>
          <target state="translated">대문자 알파벳도 허용해야합니다. 이메일 시스템은 로컬 부분과 도메인 부분을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="50ecc3e11978eaebf7cdde3eb4723774140d8446" translate="yes" xml:space="preserve">
          <source>You should not use regular expressions to validate email addresses.</source>
          <target state="translated">이메일 주소의 유효성을 검사하기 위해 정규식을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="379c3a7e829422a79610cb5cbd113ec1b0e6fea0" translate="yes" xml:space="preserve">
          <source>[UPDATED] I've collated everything I know about email address validation here: &lt;a href=&quot;http://isemail.info&quot;&gt;http://isemail.info&lt;/a&gt;, which now not only validates but also diagnoses problems with email addresses. I agree with many of the comments here that validation is only part of the answer; see my essay at &lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/about&lt;/a&gt;.</source>
          <target state="translated">[업데이트 됨] 이메일 주소 확인에 대해 내가 아는 모든 것을 여기에 정리했습니다 : &lt;a href=&quot;http://isemail.info&quot;&gt;http://isemail.info&lt;/a&gt; , 이제 이메일 주소의 문제를 검증 할뿐만 아니라 진단합니다. 유효성 검사는 답변의 일부일 뿐이라는 많은 의견에 동의합니다. &lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/about&lt;/a&gt; 에서 내 에세이를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="782f584cb9f10bfd4e2d20721f3769a1a46ed1e5" translate="yes" xml:space="preserve">
          <source>email =~ &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt;</source>
          <target state="translated">이메일 = ~ &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb288e30ab07ffc44b2ae8e5468078c1c3d3cd58" translate="yes" xml:space="preserve">
          <source>have a domain part (i.e. the part after the @-sign) that is a host name with at least two labels, each of which is at most 63 characters long.</source>
          <target state="translated">최소한 두 개의 레이블이있는 호스트 이름 인 도메인 부분 (예 : @ 기호 뒤의 부분)이 있으며 각 레이블의 길이는 최대 63 자입니다.</target>
        </trans-unit>
        <trans-unit id="580c167d115747dac91f0ce065f1f0cea9534d8c" translate="yes" xml:space="preserve">
          <source>have a local part (i.e. the part before the @-sign) that is strictly compliant with RFC 5321/5322,</source>
          <target state="translated">RFC 5321/5322를 엄격히 준수하는 로컬 부분 (예 : @ 기호 앞 부분)이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d59803fdebe968a3fc4b59dba8d7638e6988094e" translate="yes" xml:space="preserve">
          <source>if you want to use it in Java its really very easy</source>
          <target state="translated">Java에서 사용하려면 정말 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="92fd5a496d47e663c9af65c455e24766e7ce98ef" translate="yes" xml:space="preserve">
          <source>is_email() remains, as far as I know, the only validator that will tell you definitively whether a given string is a valid email address or not. I've upload a new version at &lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/&lt;/a&gt;</source>
          <target state="translated">is_email ()은 내가 아는 한 주어진 문자열이 유효한 이메일 주소인지 아닌지를 확실하게 알려주는 유일한 유효성 검사기입니다. &lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/&lt;/a&gt; 에서 새 버전을 업로드했습니다.</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
