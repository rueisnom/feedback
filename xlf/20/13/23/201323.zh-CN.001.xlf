<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/201323">
    <body>
      <group id="201323">
        <trans-unit id="b1b5a828768c114744b0e8c042dc66da113334ec" translate="yes" xml:space="preserve">
          <source>&quot;User Display Name user3@company.com&quot;</source>
          <target state="translated">&quot;用户显示名称user3@company.com&quot;</target>
        </trans-unit>
        <trans-unit id="26c2451374584a209014621e5558743bfa2ce56d" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com;user2@gmail.com&quot;</target>
        </trans-unit>
        <trans-unit id="28633028efd2c24861ac4a1740c2217f423b8453" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com; user3@company.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com;user2@gmail.com;user3@company.com&quot;</target>
        </trans-unit>
        <trans-unit id="0bc92ef1ed9e5d917df368b9389fccbdd11bbe8d" translate="yes" xml:space="preserve">
          <source>&quot;user4 @company.com&quot;</source>
          <target state="translated">&quot;user4 @company.com&quot;</target>
        </trans-unit>
        <trans-unit id="32f8045af87affeff6f4333e80528d9f758f0dff" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt;)
If you're looking for something simpler but that will catch most valid email addresses try something like:</source>
          <target state="translated">（ &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt; ）如果您正在寻找更简单的方法，但是它将捕获大多数有效的电子邮件地址，请尝试以下方法：</target>
        </trans-unit>
        <trans-unit id="75f14c0b3eb6f2ddf1a7b788a9c63a1261d191e6" translate="yes" xml:space="preserve">
          <source>(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</source>
          <target state="translated">(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</target>
        </trans-unit>
        <trans-unit id="41c1c65773194544312b0d413e9568defa0fa5f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Cal Henderson&lt;/a&gt; (Flickr) wrote an article called &lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;Parsing Email Adresses in PHP&lt;/a&gt; and shows how to do proper RFC (2)822-compliant Email Address parsing.  You can also get the source code in &lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt;, python and ruby which is &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;cc licensed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Cal Henderson&lt;/a&gt; （Flickr） &lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;用PHP&lt;/a&gt;撰写了一篇名为&amp;ldquo; 解析电子邮件地址&amp;rdquo;的文章，并展示了如何进行符合RFC（2）822规范的电子邮件地址解析。 您还可以获取&lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;cc许可的&lt;/a&gt; &lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt; ，python和ruby中的源代码。</target>
        </trans-unit>
        <trans-unit id="e4215c60a61270d50ef11c83e3925ba93699fa35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt;&lt;em&gt;etc...&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt; &lt;em&gt;等...&lt;/em&gt; &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3654c41e6ade2da259eef5a7ae400fac5827b8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the best regular expression you have or have seen for validating emails?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;您已经或看到的用于验证电子邮件的最佳正则表达式是什么？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83da26750665b7eec085cd165f43ccd6b0fe79c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &lt;code&gt;@&lt;/code&gt; character), too vague (after the &lt;code&gt;@&lt;/code&gt; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此要求是对&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;的&lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;故意违反&lt;/a&gt; ， RFC 5322定义了同时太严格（ &lt;code&gt;@&lt;/code&gt; 字符之前），太模糊（ &lt;code&gt;@&lt;/code&gt; 字符之后）和太松散（允许注释，空格）的电子邮件地址语法。字符和带引号的字符串（大多数用户不熟悉的方式）在此处具有实际用途。</target>
        </trans-unit>
        <trans-unit id="467b846662a13d15de5bbd34d57ea291cf420f2e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;valid e-mail address&lt;/strong&gt; is a string that matches the ABNF production [&amp;hellip;].</source>
          <target state="translated">&lt;strong&gt;有效的电子邮件地址&lt;/strong&gt;是与ABNF产生[&amp;hellip;]相匹配的字符串。</target>
        </trans-unit>
        <trans-unit id="aef7d848543c3d5b49c4b583603a1e7b9279f10b" translate="yes" xml:space="preserve">
          <source>A common use case is user input validation, for example on an html form. In that case it's usually reasonable to preclude address-literals and to require at least two labels in the hostname. Taking the improved RFC 5321 regex from the previous section as a basis, the resulting expression would be:</source>
          <target state="translated">一个常见的使用案例是用户输入验证,例如在html表单中。在这种情况下,通常合理的做法是排除地址-字形,并要求主机名中至少有两个标签。以上一节中改进后的 RFC 5321 regex 为基础,结果的表达式是:</target>
        </trans-unit>
        <trans-unit id="7f254b288b513a222b7ce9705affbccd53cd80d8" translate="yes" xml:space="preserve">
          <source>According to official standard &lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt; valid email regex is</source>
          <target state="translated">根据官方标准&lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822，&lt;/a&gt;有效的电子邮件正则表达式为</target>
        </trans-unit>
        <trans-unit id="6d2f2f9c03ab4cdaf2b9f2364a0c2799a6329154" translate="yes" xml:space="preserve">
          <source>Addresses matched by this regex:</source>
          <target state="translated">由这一序列号匹配的地址。</target>
        </trans-unit>
        <trans-unit id="b75e467be1d8b94588b3cc3f5aaec8acae067ee7" translate="yes" xml:space="preserve">
          <source>After all, the &lt;strong&gt;best&lt;/strong&gt; way to validate the email address is still to actually &lt;em&gt;send&lt;/em&gt; an email to the address in question to validate the address. If the email address is part of user authentication (register/login/etc), then you can perfectly combine it with the user activation system. I.e. send an email with a link with an unique activation key to the specified email address and only allow login when the user has activated the newly created account using the link in the email.</source>
          <target state="translated">毕竟，验证电子邮件地址的&lt;strong&gt;最佳&lt;/strong&gt;方法仍然是&lt;em&gt;将&lt;/em&gt;电子邮件实际&lt;em&gt;发送&lt;/em&gt;到该地址以验证该地址。 如果电子邮件地址是用户身份验证的一部分（注册/登录/等），则可以将其与用户激活系统完美结合。 即，将带有唯一激活密钥链接的电子邮件发送到指定的电子邮件地址，并且仅当用户使用电子邮件中的链接激活了新创建的帐户时才允许登录。</target>
        </trans-unit>
        <trans-unit id="4747783011ffa130857e2027d5ff2eef5ab7e5ce" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part and domain name domain (requiring at least two domain name labels with the TLD limited to 2-6 alphabetic characters).</source>
          <target state="translated">允许点状原子局部部分和域名域名(要求至少两个域名标签,TLD限制在2-6个字母字符以内)。</target>
        </trans-unit>
        <trans-unit id="98f5ff42c06d45b9d6040c487efd8ddaae34384a" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, domain name domain, and (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain.</source>
          <target state="translated">允许点原子局部部分、引号字符串局部部分、域名域和(IPv4、IPv6和IPv4映射的IPv6地址)域字面域。</target>
        </trans-unit>
        <trans-unit id="1a501b9511aa2902571ab4411c2d68715c865f16" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, obsolete (mixed dot-atom and quoted-string) local-part, domain name domain, (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain, and (nested) CFWS.</source>
          <target state="translated">允许点原子本地部分、引用字符串本地部分、过时的(混合点原子和引用字符串)本地部分、域名域、(IPv4、IPv6和IPv4映射的IPv6地址)域字面域和(嵌套)CFWS。</target>
        </trans-unit>
        <trans-unit id="137a6c9662b514d8385afe47af02dd62a6fdb560" translate="yes" xml:space="preserve">
          <source>Another consideration, especially when using the regexes for input validation, is feedback to the user. If a user enters an incorrect address, it would be nice to give a little more feedback than a simple &quot;syntactically incorrect address&quot;. With &quot;vanilla&quot; regexes this is not possible.</source>
          <target state="translated">另一个要考虑的问题,尤其是在使用输入验证的时候,要考虑的是对用户的反馈问题。如果用户输入了一个不正确的地址,如果能给用户更多的反馈,比简单的 &quot;语法上不正确的地址 &quot;要好。而使用 &quot;vanilla &quot;重构符就不可能做到这一点。</target>
        </trans-unit>
        <trans-unit id="7cf149b9d25d2489f954894be6028e467951029a" translate="yes" xml:space="preserve">
          <source>As stated in paragraph 3.1.4. of RFC 822 optional linear white space may be inserted between lexical tokens. Where applicable I've expanded the expressions to accommodate this rule and marked the result with &quot;opt-lwsp&quot;.</source>
          <target state="translated">如RFC 822第3.1.4段所述,可在词法令牌之间插入可选的线性空白。在适用的地方,我扩展了表达式以适应这一规则,并将结果标为 &quot;opt-lwsp&quot;。</target>
        </trans-unit>
        <trans-unit id="023052f99d8ae0931ecbe27dc9dbfef6103d1f37" translate="yes" xml:space="preserve">
          <source>As you're writing in PHP I'd advice you to use the PHP build-in validation for emails.</source>
          <target state="translated">因为你是用PHP编写的,所以我建议你使用PHP内置的邮件验证。</target>
        </trans-unit>
        <trans-unit id="47bf4436a0ce6299cec6effd82a884e698974efd" translate="yes" xml:space="preserve">
          <source>Basic:</source>
          <target state="translated">Basic:</target>
        </trans-unit>
        <trans-unit id="0073f212804bc3306f849cfa8b512d52e55a727a" translate="yes" xml:space="preserve">
          <source>Confirmation tokens are the only way to know you got the address of the person entering it. This is why most mailing lists now use that mechanism to confirm sign-ups. After all, anybody can put down &lt;code&gt;president@whitehouse.gov&lt;/code&gt;, and that will even parse as legal, but it isn't likely to be the person at the other end.</source>
          <target state="translated">确认令牌是知道您获得输入者地址的唯一方法。 这就是为什么大多数邮件列表现在都使用该机制来确认注册的原因。 毕竟，任何人都可以放下 &lt;code&gt;president@whitehouse.gov&lt;/code&gt; ，甚至可以将其解析为合法的，但不太可能是对方。</target>
        </trans-unit>
        <trans-unit id="8d15eaf92a267e0a03325e52d09f34bab6f23882" translate="yes" xml:space="preserve">
          <source>Context:</source>
          <target state="translated">Context:</target>
        </trans-unit>
        <trans-unit id="f828a4a98f03513a4667164d14af724f3d41a094" translate="yes" xml:space="preserve">
          <source>Correcting the &lt;code&gt;00&lt;/code&gt; bug in the IP pattern, we obtain a working and fairly fast regex.  (Scrape the rendered version, not the markdown, for actual code.)</source>
          <target state="translated">纠正IP模式中的 &lt;code&gt;00&lt;/code&gt; 错误，我们获得了一个有效且相当快的正则表达式。 （对于实际代码，请删除渲染的版本，而不是降价版本。）</target>
        </trans-unit>
        <trans-unit id="bf64925120bcbd811e65f1c72f59a3f04f836d22" translate="yes" xml:space="preserve">
          <source>Debuggex Demo</source>
          <target state="translated">Debuggex演示</target>
        </trans-unit>
        <trans-unit id="61dca52965a9edf91b73613147e9ac7c10c8eeea" translate="yes" xml:space="preserve">
          <source>Different syntaxes should be used for different purposes. If you want to scan for email addresses in a (possibly very old) document it may be a good idea to use the syntax as defined in RFC 822. On the other hand, if you want to validate user input you may want to use the syntax as defined in RFC 5322, probably only accepting canonical representations. You should decide which syntax applies to your specific case.</source>
          <target state="translated">不同的语法应该用于不同的目的。如果你想在一个(可能是很旧的)文档中扫描电子邮件地址,使用RFC 822中定义的语法可能是个好主意。另一方面,如果你想验证用户的输入,你可能想使用RFC 5322中定义的语法,很可能只接受传统的表示方式。你应该决定哪种语法适用于你的特定情况。</target>
        </trans-unit>
        <trans-unit id="cc6873ddb69d463add1609634358323011bb0f08" translate="yes" xml:space="preserve">
          <source>Don't know about best, but &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;this one&lt;/a&gt; is at least correct, as long as the addresses have their comments stripped and replaced with whitespace.</source>
          <target state="translated">最好的情况一无所知，但这至少是正确的，只要地址中的注释被去除并用空格代替即可。</target>
        </trans-unit>
        <trans-unit id="850a13e5767f580f2031a50d8569b73c2488bbf5" translate="yes" xml:space="preserve">
          <source>EDIT:
From the link:</source>
          <target state="translated">EDIT:从链接上看。</target>
        </trans-unit>
        <trans-unit id="4986de5889e2f11c9bbdb9ef8b2a461042b1376a" translate="yes" xml:space="preserve">
          <source>Elaborate answer</source>
          <target state="translated">详述答案</target>
        </trans-unit>
        <trans-unit id="4d171fe5e95a2abcc5be91fb682415349c363bb7" translate="yes" xml:space="preserve">
          <source>For PHP, you should &lt;em&gt;not&lt;/em&gt; use the pattern given in &lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;Validate an E-Mail Address with PHP, the Right Way&lt;/a&gt; from which I quote:</source>
          <target state="translated">对于PHP，您不应使用&amp;ldquo; &lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;用PHP验证电子邮件地址&amp;rdquo;中给出的模式&lt;/a&gt; ，这是我引用的正确方法 ：</target>
        </trans-unit>
        <trans-unit id="388c8341169873cbf876d842d5c93f563b812762" translate="yes" xml:space="preserve">
          <source>For a vivid demonstration, the following monster is pretty good but still does not correctly recognize all syntactically valid email addresses: it recognizes nested comments up to four levels deep.</source>
          <target state="translated">对于一个生动的演示,下面这个怪物相当不错,但仍然不能正确识别所有语法上有效的电子邮件地址:它可以识别深达四层的嵌套注释。</target>
        </trans-unit>
        <trans-unit id="844bb7409b2bf0d129a7300da9332ae49f500e9f" translate="yes" xml:space="preserve">
          <source>For the most comprehensive evaluation of the best regular expression for validating an email address please see this link; &quot;&lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;&quot;</source>
          <target state="translated">有关验证电子邮件地址的最佳正则表达式的最全面评估，请参见此链接； &amp;ldquo; &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;比较验证正则表达式的电子邮件地址&lt;/a&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="810c3f2bf5a7cff75d30fdb21ab358a9d78d240a" translate="yes" xml:space="preserve">
          <source>For your regex of domain part, domain name cannot starts with '-' and cannot ends with '-'. Dash can only stays in between.</source>
          <target state="translated">对于你的域名部分的regex,域名不能以'-'开头,也不能以'-'结尾。破折号只能停留在两者之间。</target>
        </trans-unit>
        <trans-unit id="858f135b293e0d7506e7d37d2280ccbde6e7451a" translate="yes" xml:space="preserve">
          <source>Further considerations</source>
          <target state="translated">进一步的考虑</target>
        </trans-unit>
        <trans-unit id="985180927b564d247d4e14d076eb593cde86c3fb" translate="yes" xml:space="preserve">
          <source>Further restrictions</source>
          <target state="translated">进一步的限制</target>
        </trans-unit>
        <trans-unit id="1c80cf144e810a9d98d32782de59c315753f43bf" translate="yes" xml:space="preserve">
          <source>Furthermore, an address having a dot at the end, like &lt;code&gt;user@company.&lt;/code&gt; is accepted by MailAddress as well.</source>
          <target state="translated">此外，末尾带有点的地址，例如 &lt;code&gt;user@company.&lt;/code&gt; 也被MailAddress接受。</target>
        </trans-unit>
        <trans-unit id="090fe8536ba48667df2f9156f2408f10a24285d6" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;diagram&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite state machine&lt;/a&gt; for above regexp which is more clear than regexp itself</source>
          <target state="translated">这是上述regexp的&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;有限状态机&lt;/a&gt; &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;图&lt;/a&gt; ，比regexp本身更清晰</target>
        </trans-unit>
        <trans-unit id="2a7827f413e7dc52ce89180fc06b75a173a00bb2" translate="yes" xml:space="preserve">
          <source>Here is the current top expression for reference purposes:</source>
          <target state="translated">下面是目前的顶部表达,供参考。</target>
        </trans-unit>
        <trans-unit id="f1b99749e961642af10fe964ad761b71345efbe1" translate="yes" xml:space="preserve">
          <source>Here's the PHP I use. I've choosen this solution in the spirit of &quot;false positives are better than false negatives&quot; as declared by another commenter here AND with regards to keeping your response time up and server load down ... there's really no need to waste server resources with a regular expression when this will weed out most simple user error. You can always follow this up by sending a test email if you want.</source>
          <target state="translated">这是我使用的PHP。我选择这个解决方案是本着 &quot;假阳性比假阴性好 &quot;的精神,正如这里的另一位评论者所说的那样,而且为了保证你的响应时间和服务器负载的降低...........当这个方法可以排除大多数简单的用户错误时,真的没有必要用正则表达式来浪费服务器资源。如果你想的话,你可以随时发送一封测试邮件来跟进。</target>
        </trans-unit>
        <trans-unit id="c555de7c7b1f7b703afcbb25f5d37921cd5a5f3c" translate="yes" xml:space="preserve">
          <source>Here's the derivation:</source>
          <target state="translated">这里是引申出来的。</target>
        </trans-unit>
        <trans-unit id="40e3a2be8d888879a228175a976ea9a711b4df90" translate="yes" xml:space="preserve">
          <source>How to validate an email address using a regular expression</source>
          <target state="translated">如何使用正则表达式验证电子邮件地址?</target>
        </trans-unit>
        <trans-unit id="b7c6fcdddbab0b180253335877c4f6f7061b17bc" translate="yes" xml:space="preserve">
          <source>I also do not recommend explicitly validating against a list of literal top-level domains or even imposing length-constraints (remember how &quot;.museum&quot; invalidated &lt;code&gt;[a-z]{2,4}&lt;/code&gt;), but if you must:</source>
          <target state="translated">我也不建议针对文字顶级域列表进行显式验证，甚至不施加长度限制（请记住&amp;ldquo; .museum&amp;rdquo;如何使 &lt;code&gt;[a-z]{2,4}&lt;/code&gt; 无效），但是如果您必须执行以下操作：</target>
        </trans-unit>
        <trans-unit id="6106b21b52d6c2869f1edf73c29f89a75ca99ea7" translate="yes" xml:space="preserve">
          <source>I arrived at the following regular expression. I invite everyone to try and break it. If you find any false positives or false negatives, please post them in a comment and I'll try to fix the expression as soon as possible.</source>
          <target state="translated">我得出了以下的规律性表达。请大家尝试着去破解它。如果大家发现有假阳性或假阴性,请在评论中发表,我会尽快尝试修复这个表达式。</target>
        </trans-unit>
        <trans-unit id="de12597981cafac001a63547fcd2d56956471988" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 5322 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">我相信它完全符合包括&lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;勘误表&lt;/a&gt;在内的RFC 5322。 它仅识别规范形式的电子邮件地址。 有关可识别（折叠）空格的正则表达式，请参见下面的推导。</target>
        </trans-unit>
        <trans-unit id="89706fb75be6521376b620efafa6099e39529f6f" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 822 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">我认为它完全符合包括&lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;勘误表&lt;/a&gt;在内的RFC 822。 它仅识别规范形式的电子邮件地址。 有关可识别（折叠）空格的正则表达式，请参见下面的推导。</target>
        </trans-unit>
        <trans-unit id="f512b55ca04846c10d5913e0fe2ed677435f773d" translate="yes" xml:space="preserve">
          <source>I collated test cases from Cal Henderson, Dave Child, Phil Haack, Doug Lovell, RFC5322 and RFC 3696. 275 test addresses in all. I ran all these tests against all the free validators I could find.</source>
          <target state="translated">我整理了Cal Henderson、Dave Child、Phil Haack、Doug Lovell、RFC5322和RFC 3696的测试用例。总共275个测试地址。我把所有这些测试都在我能找到的免费验证器上进行了测试。</target>
        </trans-unit>
        <trans-unit id="8bc4518aeece4f1a66566191f1afe71e2bbca678" translate="yes" xml:space="preserve">
          <source>I discuss some issues in my &lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;answer to Is there a php library for email address validation?&lt;/a&gt;, it is discussed also in &lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;Regexp recognition of email address hard?&lt;/a&gt;</source>
          <target state="translated">我在&lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;回答&amp;ldquo;是否有用于验证电子邮件地址的php库&amp;rdquo;的答案中&lt;/a&gt;讨论了一些问题？ ，也&lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;很难&lt;/a&gt;在Regexp电子邮件地址识别中讨论吗？</target>
        </trans-unit>
        <trans-unit id="a8865bf5a399677a2e921d40976a7e3002e86774" translate="yes" xml:space="preserve">
          <source>I do not recommend restricting the local part further, e.g. by precluding quoted strings, since we don't know what kind of mailbox names some hosts allow (like &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; or even &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt;).</source>
          <target state="translated">我不建议进一步限制本地部分，例如通过排除带引号的字符串，因为我们不知道某些主机允许使用哪种邮箱名称（例如 &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; 甚至 &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b8e124659a2c24af661cc381668ac370a95c11e1" translate="yes" xml:space="preserve">
          <source>I ignored all the &quot;obs-&quot; rules from the RFC. This means that the regexes only match email addresses that are strictly RFC 5322 compliant. If you have to match &quot;old&quot; addresses (as the looser grammar including the &quot;obs-&quot; rules does), you can use one of the RFC 822 regexes from the previous paragraph.</source>
          <target state="translated">我忽略了RFC中的所有 &quot;obs-&quot;规则。这意味着,这些重构符只匹配严格符合RFC 5322的电子邮件地址。如果你必须匹配 &quot;旧的 &quot;地址(就像包括 &quot;obs-&quot;规则在内的较宽松的语法所做的那样),你可以使用上一段中的RFC 822 regexes之一。</target>
        </trans-unit>
        <trans-unit id="062a5233c8de0b33af018e4eeae4a1ba0c95916d" translate="yes" xml:space="preserve">
          <source>I never bother creating with my own regular expression, because chances are that someone else has already come up with a better version.  I always use &lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib&lt;/a&gt; to find one to my liking.</source>
          <target state="translated">我从不用自己的正则表达式进行创建，因为其他人可能已经提出了更好的版本。 我总是使用&lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib&lt;/a&gt;找到自己喜欢的一个。</target>
        </trans-unit>
        <trans-unit id="088e64f9ee7f255c4c5eac7974a7114e20492d11" translate="yes" xml:space="preserve">
          <source>I use</source>
          <target state="translated">我用的是</target>
        </trans-unit>
        <trans-unit id="6795b75201299955c1b7995c570b13d659921b18" translate="yes" xml:space="preserve">
          <source>I use POSIX &quot;extended&quot; regular expressions in this answer, assuming an ASCII compatible character set.</source>
          <target state="translated">我在这个答案中使用POSIX &quot;扩展 &quot;正则表达式,假设是ASCII兼容的字符集,我使用的是POSIX &quot;扩展 &quot;正则表达式。</target>
        </trans-unit>
        <trans-unit id="56d0d3ff30df9317fddde67f83205c8cb0ff3cec" translate="yes" xml:space="preserve">
          <source>I use it in several PHP programs, and it works most of the time.  However, from time to time I get contacted by someone that is having trouble with a site that uses it, and I end up having to make some adjustment (most recently I realized that I wasn't allowing 4-character TLDs).</source>
          <target state="translated">我在几个PHP程序中使用它,大部分时间都能正常工作。然而,时不时就会有人联系我,说我的网站使用它有问题,最后我不得不做一些调整(最近我发现我不允许4个字符的TLD)。</target>
        </trans-unit>
        <trans-unit id="034d131aacb2134a772bdf60fff06a86578e9c3f" translate="yes" xml:space="preserve">
          <source>I'll try to keep this page up-to-date as people enhance their validators. Thanks to Cal, Michael, Dave, Paul and Phil for their help and co-operation in compiling these tests and constructive criticism of &lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;my own validator&lt;/a&gt;.</source>
          <target state="translated">随着人们增强其验证器，我将尝试使此页面保持最新。 感谢Cal，Michael，Dave，Paul和Phil在汇编这些测试和对&lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;我自己的验证程序的&lt;/a&gt;建设性批评方面所提供的帮助和合作。</target>
        </trans-unit>
        <trans-unit id="8588212a8c9ffe41b9ef89fa0c2610e960516246" translate="yes" xml:space="preserve">
          <source>I've seen several solutions that use functions that use several shorter expressions, but I'd rather have one long complex expression in a simple function instead of several short expression in a more complex function.</source>
          <target state="translated">我见过几个使用几个短表达式的函数的解决方案,但我宁愿在一个简单的函数中使用一个长的复杂表达式,而不是在一个比较复杂的函数中使用几个短表达式。</target>
        </trans-unit>
        <trans-unit id="725e5ed871d70812fff5a898374748169242406b" translate="yes" xml:space="preserve">
          <source>If the purpose of the regex is just to quickly inform the user in the UI that the specified email address doesn't look like in the right format, best is still to check if it matches basically the following regex:</source>
          <target state="translated">如果regex的目的只是为了在UI中快速通知用户指定的邮件地址看起来不像是正确的格式,最好的办法还是检查它是否符合下面的regex。</target>
        </trans-unit>
        <trans-unit id="64cac7449f582a2dc109b435c4145c5f430d12f4" translate="yes" xml:space="preserve">
          <source>If you plan to use the &lt;code&gt;MailAddress&lt;/code&gt; to validate the e-mail address, be aware that this approach accepts the display name part of the e-mail address as well, and that may not be exactly what you want to achieve. For example, it accepts these strings as valid e-mail addresses:</source>
          <target state="translated">如果您打算使用 &lt;code&gt;MailAddress&lt;/code&gt; 来验证电子邮件地址，请注意，这种方法也接受电子邮件地址的显示名称部分，而这可能并不是您想要的。 例如，它接受以下字符串作为有效的电子邮件地址：</target>
        </trans-unit>
        <trans-unit id="99811d1346d22a72366acd0b3ff9e1075ab2e9fc" translate="yes" xml:space="preserve">
          <source>If you really want to use a regex, &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;here it is&lt;/a&gt;:</source>
          <target state="translated">如果您真的想使用正则表达式， &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;则为&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="44ce491ec374723f385ed8ad3f99125bd8e8fe92" translate="yes" xml:space="preserve">
          <source>If you used the PEAR library, check out their mail function (forgot the exact name/library).  You can validate email address by calling one function, and it validates the email address according to definition in RFC822.</source>
          <target state="translated">如果你用过PEAR库,可以看看他们的邮件函数(具体的名字库忘了)。你可以通过调用一个函数来验证邮件地址,它根据RFC822中的定义来验证邮件地址。</target>
        </trans-unit>
        <trans-unit id="89fdaa410759db94e2b5de2465bd333dc0953efc" translate="yes" xml:space="preserve">
          <source>If you want more information how this buid-in validation works, see here: &lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;Does PHP's filter_var FILTER_VALIDATE_EMAIL actually work?&lt;/a&gt;</source>
          <target state="translated">如果您想了解更多信息，请参见此处： &lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;PHP的filter_var FILTER_VALIDATE_EMAIL是否真正起作用？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c40d3684b422bc8ff6e3c9362de5de71480237e" translate="yes" xml:space="preserve">
          <source>If you want to get fancy and pedantic, &lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;implement a complete state engine&lt;/a&gt;. A regular expression can only act as a rudimentary filter. The problem with regular expressions is that telling someone that their perfectly valid e-mail address is invalid (a false positive) because your regular expression can't handle it is just rude and impolite from the user's perspective. A state engine for the purpose can both validate and even correct e-mail addresses that would otherwise be considered invalid as it disassembles the e-mail address according to each RFC. This allows for a potentially more pleasing experience, like</source>
          <target state="translated">如果您想花哨和学究，请&lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;实施一个完整的状态引擎&lt;/a&gt; 。 正则表达式只能充当基本过滤器。 正则表达式的问题在于，告诉某人其完全有效的电子邮件地址是无效的（误报），因为从用户的角度来看，您的正则表达式无法处理它只是不礼貌和不礼貌。 用于此目的的状态引擎既可以验证甚至更正电子邮件地址，否则它会被视为无效，因为它会根据每个RFC分解电子邮件地址。 这样可以带来更愉悦的体验，例如</target>
        </trans-unit>
        <trans-unit id="15c3b1fffdba1f0e987fbd41a9b09407c2fdc511" translate="yes" xml:space="preserve">
          <source>If you want to validate that an email is correct, you have no choice than to send an confirmation email and have the user reply to that. In many cases you will &lt;em&gt;have&lt;/em&gt; to send a confirmation mail anyway for security reasons or for ethical reasons (so you cannot e.g. sign someone up to a service against their will).</source>
          <target state="translated">如果要验证电子邮件正确，则别无选择，只能发送确认电子邮件并让用户回复。 在许多情况下，出于安全原因或出于道德原因，无论如何您都&lt;em&gt;必须&lt;/em&gt;发送确认邮件（因此，您不能例如违反某人的意愿而签署某项服务）。</target>
        </trans-unit>
        <trans-unit id="8f90c8045d52f4b058334a51ed4880471694677d" translate="yes" xml:space="preserve">
          <source>If you're running a php-version lower than 5.3.6 please be aware of this issue: &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https://bugs.php.net/bug.php?id=53091&lt;/a&gt;</source>
          <target state="translated">如果您运行的PHP版本低于5.3.6，请注意以下问题： &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https&lt;/a&gt; : //bugs.php.net/bug.php?id=53091</target>
        </trans-unit>
        <trans-unit id="bfe401233bd6300cf11a6837adc1067496b852ea" translate="yes" xml:space="preserve">
          <source>In short, don't expect a single, usable regex to do a proper job. And the best regex will validate the syntax, not the validity of an e-mail (jhohn@example.com is correct but it will probably bounce...).</source>
          <target state="translated">总而言之,不要指望一个单一的、可用的regex就能做得很好。而且最好的regex会验证语法,而不是验证邮件的有效性(jhohn@example.com 是正确的,但很可能会反弹..........)。</target>
        </trans-unit>
        <trans-unit id="d64fa0e517911923332fac4e2f71d913ad55f9db" translate="yes" xml:space="preserve">
          <source>In some of these cases, only the last part of the strings is parsed as the address; the rest before that is the display name. To get a plain e-mail address without any display name, you can check the normalized address against your original string.</source>
          <target state="translated">在某些情况下,只有字符串的最后一部分被解析为地址,其余的是显示名。要得到一个没有任何显示名称的纯邮件地址,你可以将归一化后的地址与你的原始字符串进行核对。</target>
        </trans-unit>
        <trans-unit id="92b6aee3575856478de82d957aae0862c153d512" translate="yes" xml:space="preserve">
          <source>In this answer I&amp;rsquo;ll take &amp;ldquo;email address&amp;rdquo; to mean &lt;code&gt;addr-spec&lt;/code&gt; as defined in the RFCs (i.e. &lt;code&gt;jdoe@example.org&lt;/code&gt;, but not &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt;, nor &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt;).</source>
          <target state="translated">在此答案中，我将使用&amp;ldquo;电子邮件地址&amp;rdquo;来表示RFC中定义的 &lt;code&gt;addr-spec&lt;/code&gt; （即 &lt;code&gt;jdoe@example.org&lt;/code&gt; ，而不是 &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt; 或 &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="29a575c86979b44c2fb0c43aa9e0d6c7884de728" translate="yes" xml:space="preserve">
          <source>Instead, use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt; class, like this:</source>
          <target state="translated">而是使用&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt;类，如下所示：</target>
        </trans-unit>
        <trans-unit id="bb3cb298c6dabff17c93f08e57db5b7c214514b7" translate="yes" xml:space="preserve">
          <source>It all depends on how accurate you want to be.  For my purposes, where I'm just trying to keep out things like &lt;code&gt;bob @ aol.com&lt;/code&gt; (spaces in emails) or &lt;code&gt;steve&lt;/code&gt; (no domain at all) or &lt;code&gt;mary@aolcom&lt;/code&gt; (no period before .com), I use</source>
          <target state="translated">这完全取决于您想要的精度。 就我的目的而言，我只是想避免出现诸如 &lt;code&gt;bob @ aol.com&lt;/code&gt; （电子邮件中的空格）或 &lt;code&gt;steve&lt;/code&gt; （根本没有域）或 &lt;code&gt;mary@aolcom&lt;/code&gt; （.com之前没有句号）之类的东西，</target>
        </trans-unit>
        <trans-unit id="55c558aed4449d4838de9ba71870504efebc5f4d" translate="yes" xml:space="preserve">
          <source>It depends on what you mean by best:
If you're talking about catching every valid email address use the following:</source>
          <target state="translated">这取决于你的意思是最好的。如果你是说要抓住每一个有效的电子邮件地址,请使用下面的方法。</target>
        </trans-unit>
        <trans-unit id="634ea515e24f27b27c16f1ac8df53108713d9618" translate="yes" xml:space="preserve">
          <source>It does not prevent people from entering invalid or made-up email addresses, or entering someone else's address.</source>
          <target state="translated">它并不阻止人们输入无效或伪造的电子邮件地址,或输入别人的地址。</target>
        </trans-unit>
        <trans-unit id="ef282074cd0ee12c9819b8667cca979a4d908a32" translate="yes" xml:space="preserve">
          <source>It should however be noted that if you want to find out if the address actually refers to an existing mailbox, there's no substitute for sending a message to the address. If you only want to check if an address is grammatically correct then you could use a regular expression, but note that &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; is a grammatically correct email address that certainly doesn't refer to an existing mailbox.</source>
          <target state="translated">但是，应注意，如果您要查找该地址是否实际指向现有邮箱，则没有替代方法可以向该地址发送消息。 如果只想检查地址在语法上是否正确，则可以使用正则表达式，但请注意， &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; 是在语法上正确的电子邮件地址，肯定没有引用现有的邮箱。</target>
        </trans-unit>
        <trans-unit id="cc84b5c5472043636abf125126a167f8104cf798" translate="yes" xml:space="preserve">
          <source>It will not catch common typos.</source>
          <target state="translated">它不会抓到常见的错别字。</target>
        </trans-unit>
        <trans-unit id="748495ccfc92d4a51e5e47b57ba34035d4c9f075" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy in Perl 5.10 or newer:</source>
          <target state="translated">在Perl 5.10或更高版本中很容易：</target>
        </trans-unit>
        <trans-unit id="c36addb1f9a0630cf0fa05910cfe747100da3dcb" translate="yes" xml:space="preserve">
          <source>It's also important to understand that validating it per the RFC tells you absolutely nothing about whether that address actually exists at the supplied domain, or whether the person entering the address is its true owner. People sign others up to mailing lists this way all the time. Fixing that requires a fancier kind of validation that involves sending that address a message that includes a confirmation token meant to be entered on the same web page as was the address.</source>
          <target state="translated">同样重要的是要明白,根据 RFC 验证它绝对不会告诉你这个地址是否真的存在于所提供的域中,或者输入地址的人是否是真正的所有者。人们总是用这种方式给别人注册邮件列表。要解决这个问题,需要一种更高级的验证方式,即向该地址发送一个包含确认令牌的消息,该消息将在同一个网页上输入一个确认令牌。</target>
        </trans-unit>
        <trans-unit id="59fc40df1759e098dcd512bdd762d89c1c4815c1" translate="yes" xml:space="preserve">
          <source>Make sure to keep your regex up-to-date if you decide to go down the path of explicit top-level domain validation.</source>
          <target state="translated">如果你决定走明确的顶级域验证之路,请确保你的regex是最新的。</target>
        </trans-unit>
        <trans-unit id="aa2ea3e7fb557b8b8b13fa28afb31c3928419cfd" translate="yes" xml:space="preserve">
          <source>None of the regexes in this answer are optimized for performance. If performance is an issue, you should see if (and how) the regex of your choice can be optimized.</source>
          <target state="translated">这个答案中没有一个是针对性能进行了优化的regex。如果性能是一个问题,你应该看看你选择的regex是否(以及如何)可以优化。</target>
        </trans-unit>
        <trans-unit id="2a469b7426fdfa686180a96ef3fe9463e2cbdbd8" translate="yes" xml:space="preserve">
          <source>Not to mention that non-Latin (Chinese, Arabic, Greek, Hebrew, Cyrillic and so on) domain names are to be allowed in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;near future&lt;/a&gt;. Everyone has to change the email regex used, because those characters are surely not to be covered by &lt;code&gt;[a-z]/i&lt;/code&gt; nor &lt;code&gt;\w&lt;/code&gt;. They will all fail.</source>
          <target state="translated">更不用说在&lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;不久的将来&lt;/a&gt;允许使用非拉丁（中文，阿拉伯文，希腊文，希伯来文，西里尔文等）域名。 每个人都必须更改所使用的电子邮件正则表达式，因为 &lt;code&gt;[a-z]/i&lt;/code&gt; 或 &lt;code&gt;\w&lt;/code&gt; 肯定不覆盖这些字符。 他们都会失败。</target>
        </trans-unit>
        <trans-unit id="ed883c2a93aaa8eff111b58e6939a3cdb4b3d6af" translate="yes" xml:space="preserve">
          <source>Note that depending on the use case you may not want to allow for a &quot;General-address-literal&quot; in your regex. Also note that I used a negative lookahead &lt;code&gt;(?!IPv6:)&lt;/code&gt; in the final regex to prevent the &quot;General-address-literal&quot; part to match malformed IPv6 addresses. Some regex processors don't support negative lookahead. Remove the substring &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; from the regex if you want to take the whole &quot;General-address-literal&quot; part out.</source>
          <target state="translated">请注意，根据使用情况，您可能不希望在正则表达式中使用&amp;ldquo;常规地址字面量&amp;rdquo;。 另请注意，在最后一个正则表达式中，我使用了否定的前行 &lt;code&gt;(?!IPv6:)&lt;/code&gt; ，以防止&amp;ldquo;常规地址字面量&amp;rdquo;部分匹配格式错误的IPv6地址。 某些正则表达式处理器不支持负前瞻。 如果要取整，请从正则表达式中删除子字符串 &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; &amp;ldquo;一般地址字面意义&amp;rdquo;部分退出。</target>
        </trans-unit>
        <trans-unit id="1603724f5f43f1edae560e9739defad7e033ecee" translate="yes" xml:space="preserve">
          <source>Note that some sources (notably &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt;) claim that RFC 5322 is too strict on the local part (i.e. the part before the @-sign). This is because &quot;..&quot;, &quot;a..b&quot; and &quot;a.&quot; are &lt;em&gt;not&lt;/em&gt; valid dot-atoms, while they may be used as mailbox names. The RFC, however, &lt;em&gt;does&lt;/em&gt; allow for local parts like these, except that they have to be quoted. So instead of &lt;code&gt;a..b@example.net&lt;/code&gt; you should write &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt;, which is semantically equivalent.</source>
          <target state="translated">请注意，某些来源（特别是&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt; ）声称RFC 5322对本地部分（即@符号前的部分）过于严格。 这是因为&amp;ldquo; ..&amp;rdquo;，&amp;ldquo; a..b&amp;rdquo;和&amp;ldquo; a。&amp;rdquo; &lt;em&gt;不是&lt;/em&gt;有效的点原子，但它们可以用作邮箱名称。 但是，RFC &lt;em&gt;确实&lt;/em&gt;允许像这样的本地部分，但必须将其引号。 因此，您应该写 &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; 而不是 &lt;code&gt;a..b@example.net&lt;/code&gt; ，这在语义上是等效的。</target>
        </trans-unit>
        <trans-unit id="a414e2438f7c9cf87c83b4983b266d69534ed05a" translate="yes" xml:space="preserve">
          <source>Note: This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &amp;ldquo;@&amp;rdquo; character), too vague (after the &amp;ldquo;@&amp;rdquo; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">注意：此要求是对&lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;的&lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;故意违反&lt;/a&gt; ， RFC 5322定义了电子邮件地址的语法，该语法同时太严格（在&amp;ldquo; @&amp;rdquo;字符之前），太模糊（在&amp;ldquo; @&amp;rdquo;字符之后）和太松散（允许注释，空格字符和大多数用户不熟悉的方式用引号引起来的字符串）在此处具有实际用途。</target>
        </trans-unit>
        <trans-unit id="a60dff653e359c769e135e4c04c6e895ea0123b7" translate="yes" xml:space="preserve">
          <source>One RFC 5322 compliant regex can be found at the top of the page at &lt;a href=&quot;http://emailregex.com/&quot;&gt;http://emailregex.com/&lt;/a&gt; but uses the IP address pattern that is floating around the internet with a bug that allows &lt;code&gt;00&lt;/code&gt; for any of the unsigned byte decimal values in a dot-delimited address, which is illegal.  The rest of it appears to be consistent with the RFC 5322 grammar and passes several tests using &lt;code&gt;grep -Po&lt;/code&gt;, including cases domain names, IP addresses, bad ones, and account names with and without quotes.</source>
          <target state="translated">可以在页面顶部的&lt;a href=&quot;http://emailregex.com/&quot;&gt;http://emailregex.com/&lt;/a&gt;上找到一个符合RFC 5322的正则表达式，但使用的IP地址模式在Internet上浮动，并且存在一个错误，该错误允许 &lt;code&gt;00&lt;/code&gt; 中的任何无符号字节十进制值以点分隔的地址，这是非法的。 它的其余部分似乎与RFC 5322语法一致，并通过了一些使用 &lt;code&gt;grep -Po&lt;/code&gt; 的测试，包括大小写域名，IP地址，错误的名称以及带或不带引号的帐户名称。</target>
        </trans-unit>
        <trans-unit id="6849c03183bc687fc66af67fdc8fab74faf61cad" translate="yes" xml:space="preserve">
          <source>One simple regular expression which would at least not reject any valid email address would be checking for something, followed by an @ sign and then something followed by a period and at least 2 somethings. It won't reject anything, but after reviewing the spec I can't find any email that would be valid and rejected.</source>
          <target state="translated">有一个简单的正则表达式至少不会拒绝任何有效的电子邮件地址,那就是检查东西,后面是@号,然后是句号和至少2个somethings。它不会拒绝任何东西,但在查看了规格之后,我找不到任何有效的邮件,也没有拒绝。</target>
        </trans-unit>
        <trans-unit id="eacf0af0cb780f7e0cc0c41e3539fd563e478436" translate="yes" xml:space="preserve">
          <source>Over the years I have slowly developed a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; that validates MOST email addresses correctly, assuming they don't use an IP address as the server part.</source>
          <target state="translated">多年来，我慢慢地开发了一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;正则表达式&lt;/a&gt; ，假设它们不使用IP地址作为服务器部件，则可以正确验证MOST电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="4e44c1594bc79271466627aea4dc6d92f45efa87" translate="yes" xml:space="preserve">
          <source>People should be aware of the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;errata against RFC 3696&lt;/a&gt; in particular. Three of the canonical examples are in fact invalid addresses. And the maximum length of an address is 254 or 256 characters, &lt;strong&gt;not&lt;/strong&gt; 320.</source>
          <target state="translated">人们应该特别注意&lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;针对RFC 3696&lt;/a&gt;的勘误表 。 实际上，其中三个规范示例是无效地址。 地址的最大长度为254或256个字符， &lt;strong&gt;而不是&lt;/strong&gt; 320个字符。</target>
        </trans-unit>
        <trans-unit id="d39c523f1fb1d41ff6e8a68ec88d7d3a31a24cd0" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;the W3C HTML5 spec&lt;/a&gt;:</source>
          <target state="translated">根据&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;W3C HTML5规范&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="56c0dad2b0956cd6ae32504c979c840f02cf3573" translate="yes" xml:space="preserve">
          <source>Quick answer</source>
          <target state="translated">快速回答</target>
        </trans-unit>
        <trans-unit id="fa2251418aa68903f6488427bde3d8e415a9f16a" translate="yes" xml:space="preserve">
          <source>RFC 5321 basically leaves alone the &quot;local&quot; part (i.e. the part before the @-sign), but is stricter on the domain part (i.e. the part after the @-sign). It allows only host names in place of dot-atoms and address literals in place of domain literals.</source>
          <target state="translated">RFC 5321 基本上只保留了 &quot;本地 &quot;部分(即 @-sign 之前的部分),但对域部分(即 @-sign 之后的部分)更为严格。它只允许用主机名代替点-原子,用地址字元代替域字元。</target>
        </trans-unit>
        <trans-unit id="82af36243c542be2f1bd3a5fa7459b1dbce36d81" translate="yes" xml:space="preserve">
          <source>RFC 5321 standard:</source>
          <target state="translated">RFC 5321标准。</target>
        </trans-unit>
        <trans-unit id="17c58504badf8c1787c4ac4f95c466fc696f2e50" translate="yes" xml:space="preserve">
          <source>RFC 5322</source>
          <target state="translated">RFC 5322</target>
        </trans-unit>
        <trans-unit id="479d36b78205a178de44b9bbbe339cec9f59000b" translate="yes" xml:space="preserve">
          <source>RFC 5322 standard:</source>
          <target state="translated">RFC 5322标准。</target>
        </trans-unit>
        <trans-unit id="00af815762ae4e4ed879f00aa53f3fc9fc817b37" translate="yes" xml:space="preserve">
          <source>RFC 822</source>
          <target state="translated">RFC 822</target>
        </trans-unit>
        <trans-unit id="fd412bb5a3c2ad14d277d7a4b79b8f75df43ce9c" translate="yes" xml:space="preserve">
          <source>Regular expression built using Jeffrey Friedl's example in
  &lt;em&gt;Mastering Regular Expressions&lt;/em&gt; (&lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt;).</source>
          <target state="translated">使用Jeffrey Friedl在&lt;em&gt;精通正则表达式&lt;/em&gt; （ &lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt; ）中的示例构建的&lt;em&gt;正则表达式&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fa9d019350b110a4ff197daf305ce272d79f6ae" translate="yes" xml:space="preserve">
          <source>SMTP (as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321&lt;/a&gt;) further restricts the set of valid email addresses (or actually: mailbox names). It seems reasonable to impose this stricter grammar, so that the matched email address can actually be used to send an email.</source>
          <target state="translated">SMTP（如&lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321&lt;/a&gt;所定义）进一步限制了有效电子邮件地址（或实际上：邮箱名称）的集合。 强加这种更严格的语法似乎是合理的，以便匹配的电子邮件地址实际上可以用于发送电子邮件。</target>
        </trans-unit>
        <trans-unit id="2e509ea11bcd91c64419ceb313b8fded4cfb62a1" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;Validating Email Addresses&lt;/a&gt;, including the comments. Or &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;验证电子邮件地址&lt;/a&gt; ，包括评论。 或&lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;比较验证正则表达式的电子邮件地址&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="53a9c322bf8ce66569059aa3e1529b8bee955c35" translate="yes" xml:space="preserve">
          <source>Seriously. You should use an already written library for validating emails. The best way is probably to just send a verification e-mail to that address.</source>
          <target state="translated">认真的说。你应该使用一个已经写好的库来验证邮件。最好的方法可能是直接向该地址发送一封验证邮件。</target>
        </trans-unit>
        <trans-unit id="a143d6225e75c2b766a2aee66d8dfbc3d273186e" translate="yes" xml:space="preserve">
          <source>Simple as that. Why on earth would you care about the characters used in the name and domain? It's the client's responsibility to enter a valid email address, not the server's. Even when the client enters a &lt;em&gt;syntactically&lt;/em&gt; valid email address like &lt;code&gt;aa@bb.cc&lt;/code&gt;, this does not guarantee that it's a legit email address. No one regex can cover that.</source>
          <target state="translated">就那么简单。 为什么您会关心名称和域中使用的字符？ 输入有效的电子邮件地址是客户的责任，而不是服务器的责任。 即使客户输入&lt;em&gt;语法上&lt;/em&gt;有效的电子邮件地址，例如 &lt;code&gt;aa@bb.cc&lt;/code&gt; ，也不能保证它是合法的电子邮件地址。 没有一个正则表达式可以解决这一问题。</target>
        </trans-unit>
        <trans-unit id="056115c235bea2846acb135ffdbd27cd4ae8abc4" translate="yes" xml:space="preserve">
          <source>Strange that you &quot;cannot&quot; allow 4 characters TLDs.  You are banning people from &lt;em&gt;.info&lt;/em&gt; and &lt;em&gt;.name&lt;/em&gt;, and the length limitation stop &lt;em&gt;.travel&lt;/em&gt; and &lt;em&gt;.museum&lt;/em&gt;, but yes, they are less common than 2 characters TLDs and 3 characters TLDs.</source>
          <target state="translated">奇怪的是，您&amp;ldquo;不能&amp;rdquo;允许4个字符的TLD。 您正在禁止人们使用&lt;em&gt;.info&lt;/em&gt;和&lt;em&gt;.name&lt;/em&gt; ，并且长度限制禁止&lt;em&gt;.travel&lt;/em&gt;和&lt;em&gt;.museum&lt;/em&gt; ，但是是的，它们不如2个字符的TLD和3个字符的TLD常见。</target>
        </trans-unit>
        <trans-unit id="6cbd3caa8bdfcbb5ef664dabf829fa863056ac8a" translate="yes" xml:space="preserve">
          <source>Sure, it will match things that aren't valid email addresses, but it's a matter of playing the 90/10 rule.</source>
          <target state="translated">当然,它会匹配一些不是有效的邮件地址的东西,但这是玩9010规则的问题。</target>
        </trans-unit>
        <trans-unit id="af4c67c3df524d5adb915aacca975c4f92acf0be" translate="yes" xml:space="preserve">
          <source>That is no better than all the other non-RFC patterns. It isn&amp;rsquo;t even smart enough to handle even &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt;, let alone RFC 5322. &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;This one&lt;/a&gt;, however, is.</source>
          <target state="translated">这并不比所有其他非RFC模式都好。 它甚至还不够智能，无法处理&lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt; ，更不用说RFC 5322了。</target>
        </trans-unit>
        <trans-unit id="8a8b13790b55067f7d02a02213bba322543be649" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;fully RFC 822 compliant regex&lt;/a&gt; is inefficient and obscure because of its length.  Fortunately, RFC 822 was superseded twice and the current specification for email addresses is &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt;.  RFC 5322 leads to a regex that can be understood if studied for a few minutes and is efficient enough for actual use.</source>
          <target state="translated">由于其长度， &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;完全符合RFC 822的正则表达式&lt;/a&gt;效率低下且晦涩难懂。 幸运的是，RFC 822被取代了两次，当前电子邮件地址规范为&lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt; 。 RFC 5322导致了一个正则表达式，如果研究几分钟，它可以被理解并且对于实际使用足够有效。</target>
        </trans-unit>
        <trans-unit id="efef7583ce1f5955d8622631b97ef21d277e0c78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 spec suggests&lt;/a&gt; a simple regex for validating email addresses:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5规范建议&lt;/a&gt;了一个用于验证电子邮件地址的简单正则表达式：</target>
        </trans-unit>
        <trans-unit id="cc7666184f88738787a730cc2f788c93befa5c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MailAddress&lt;/code&gt; class uses a BNF parser to validate the address in full accordance with RFC822.</source>
          <target state="translated">&lt;code&gt;MailAddress&lt;/code&gt; 类使用BNF解析器完全按照RFC822验证地址。</target>
        </trans-unit>
        <trans-unit id="08094c7e000914320983bbc93438575ec83bb464" translate="yes" xml:space="preserve">
          <source>The RFCs define syntaxes for email messages, not for email addresses as such. Addresses may appear in various header fields and this is where they are primarily defined. When they appear in header fields addresses may contain (between lexical tokens) whitespace, comments and even linebreaks. Semantically this has no significance however. By removing this whitespace, etc. from an address you get a semantically equivalent &lt;em&gt;canonical representation&lt;/em&gt;. Thus, the canonical representation of &lt;code&gt;first. last (comment) @   [3.5.7.9]&lt;/code&gt; is &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt;.</source>
          <target state="translated">RFC为电子邮件定义语法，而不是为电子邮件地址定义语法。 地址可能出现在各种标题字段中，这是它们的主要定义位置。 当它们出现在标题字段中时，地址可能包含（在词性标记之间）空格，注释甚至换行符。 但是在语义上这没有意义。 通过从地址中删除此空格等，您可以获得语义上等效的&lt;em&gt;规范表示&lt;/em&gt; 。 因此，第一个的规范表示 &lt;code&gt;first. last (comment) @ [3.5.7.9]&lt;/code&gt; last（评论）@ [3.5.7.9]是 &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03bb5d368df58fc938931912f1a46085762490a6" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. For rules that include semantically irrelevant (folding) whitespace, I give a separate regex marked &quot;(normalized)&quot; that doesn't accept this whitespace.</source>
          <target state="translated">这个推导说明了我是如何得出这个表达式的。我将RFC中所有相关的语法规则完全按照它们的样子列出,然后是相应的regex。对于包含语义上不相关的(折叠)空格的规则,我给出了一个单独的regex,标有&quot;(normalized)&quot;,不接受这个空格。</target>
        </trans-unit>
        <trans-unit id="b143a24ff4d5dac8a1b58259e6ef61a5327993b2" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. Where an erratum has been published I give a separate expression for the corrected grammar rule (marked &quot;erratum&quot;) and use the updated version as a subexpression in subsequent regular expressions.</source>
          <target state="translated">这个推导说明了我是如何得出这个表达式的。我将RFC中所有相关的语法规则按其出现的位置列出,然后是相应的regex。如果已经发布了一个错误的语法规则,我将为修正后的语法规则给出一个单独的表达式(标记为 &quot;错误&quot;),并在后面的正则表达式中使用更新的版本作为子表达式。</target>
        </trans-unit>
        <trans-unit id="c988189fcad54702295e206fc75fe6d5f6101f50" translate="yes" xml:space="preserve">
          <source>The email addresses I want to validate are going to be used by an ASP.NET web application using the System.Net.Mail namespace to send emails to a list of people. So, rather than using some very complex regular expression, I just try to create a MailAddress instance from the address. The MailAddress construtor will throw an exception if the address is not formed properly. This way, I know I can at least get the email out of the door. Of course this is server-side validation but at a minimum you need that anyway.</source>
          <target state="translated">我想验证的电子邮件地址将被一个ASP.NET Web应用程序使用System.Net.Mail命名空间来向一个列表中的人发送电子邮件。因此,我没有使用一些非常复杂的正则表达式,而是尝试从地址中创建一个MailAddress实例。MailAddress construtor会在地址没有正确形成时抛出一个异常。这样一来,我知道我至少可以把邮件送出去了。当然,这是服务器端验证,但至少你需要这样做。</target>
        </trans-unit>
        <trans-unit id="2c42e1dbf8f30a22743d35f41dec49ad83dcbd78" translate="yes" xml:space="preserve">
          <source>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</source>
          <target state="translated">下面这个兼容JavaScript和Perl的正则表达式就是上述定义的实现。</target>
        </trans-unit>
        <trans-unit id="04b741d2a83f024156fc1aafe328ecd03eac2d01" translate="yes" xml:space="preserve">
          <source>The grammar presented in RFC 5321 is too lenient when it comes to both host names and IP addresses. I took the liberty of &quot;correcting&quot; the rules in question, using &lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;this draft&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034&lt;/a&gt; as guidelines. Here's the resulting regex.</source>
          <target state="translated">当涉及到主机名和IP地址时，RFC 5321中提出的语法太宽容。 我以&lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;该草案&lt;/a&gt;和&lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034&lt;/a&gt;为准则自由地&amp;ldquo;纠正&amp;rdquo;了相关规则。 这是生成的正则表达式。</target>
        </trans-unit>
        <trans-unit id="78bea17cadfee2e52d3b0ba653aeb8078d41c522" translate="yes" xml:space="preserve">
          <source>The more sophisticated patterns in Perl and PCRE (regex library used e.g. in PHP) can &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;correctly parse RFC 5322 without a hitch&lt;/a&gt;. Python and C# can do that too, but they use a different syntax from those first two. However, if you are forced to use one of the many less powerful pattern-matching languages, then it&amp;rsquo;s best to use a real parser.</source>
          <target state="translated">Perl和PCRE（例如PHP中使用的正则表达式库）中更复杂的模式可以&lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;正确解析RFC 5322&lt;/a&gt; 。 Python和C＃也可以做到这一点，但是它们使用的语法与前两个语法不同。 但是，如果您不得不使用功能较弱的模式匹配语言之一，那么最好使用真正的解析器。</target>
        </trans-unit>
        <trans-unit id="f44b7e654912775bb48deb334cbbfbb5d94ad3b7" translate="yes" xml:space="preserve">
          <source>The second constraint is a restriction on RFC 5321/5322.</source>
          <target state="translated">第二个约束是对RFC 53215322的限制。</target>
        </trans-unit>
        <trans-unit id="ddc5dad053b60eb7739c3fbde8711a0b846a2faf" translate="yes" xml:space="preserve">
          <source>The specified e-mail address 'myemail@address,com' is invalid. Did you mean 'myemail@address.com'?</source>
          <target state="translated">指定的电子邮件地址 &quot;myemail@address,com &quot;无效。你是指'myemail@address.com'吗?</target>
        </trans-unit>
        <trans-unit id="ba008b9092dbf02ae78dce33e0ba3f4f3680e270" translate="yes" xml:space="preserve">
          <source>The syntax of email addresses has been defined in various &lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFCs&lt;/a&gt;, most notably &lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;. RFC 822 should be seen as the &quot;original&quot; standard and RFC 5322 as the latest standard. The syntax defined in RFC 822 is the most lenient and subsequent standards have restricted the syntax further and further, where newer systems or services should recognize obsolete syntax, but never produce it.</source>
          <target state="translated">电子邮件地址的语法已在各种&lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFC中&lt;/a&gt;定义，最著名的是&lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;和&lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; 。 RFC 822应该被视为&amp;ldquo;原始&amp;rdquo;标准，而RFC 5322应该被视为最新标准。 RFC 822中定义的语法是最宽松的，随后的标准越来越多地限制了语法，在这种情况下，较新的系统或服务应识别出过时的语法，但从不产生这种语法。</target>
        </trans-unit>
        <trans-unit id="694230a2ce267bc8d03a82385bbedc868ccb9017" translate="yes" xml:space="preserve">
          <source>The total length could also be limited to 254 characters, per &lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;RFC 3696  errata 1690&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;RFC 3696勘误表1690&lt;/a&gt; ，总长度也可以限制为254个字符。</target>
        </trans-unit>
        <trans-unit id="3c409e37bc8b674795dc6985a2965f07b4a91bec" translate="yes" xml:space="preserve">
          <source>There are plenty examples of this out on the net (and I think even one that fully validates the RFC - but it's tens/hundreds of lines long if memory serves). People tend to get carried away validating this sort of thing. Why not just check it has an @ and at least one . and meets some simple minimum length. It's trivial to enter a fake email and still match any valid regex anyway. I would guess that false positives are better than false negatives.</source>
          <target state="translated">在网上有很多这样的例子(我认为甚至有一个完全验证了RFC的例子----如果没记错的话,它有十几百行长)。人们在验证这种东西的时候往往会得意忘形。为什么不直接检查它有一个@和至少一个.,并满足一些简单的最小长度。输入一个假的电子邮件,无论如何都可以匹配任何有效的regex,这很简单。我想,假阳性比假阴性要好。</target>
        </trans-unit>
        <trans-unit id="e65ce1fdf25d40bc41ca80ae15e74e6206ea4278" translate="yes" xml:space="preserve">
          <source>There is not one which is really usable.</source>
          <target state="translated">没有一个是真正能用得上的。</target>
        </trans-unit>
        <trans-unit id="fb8823d7f714e02a82ffff0eff38f0b5686cb83b" translate="yes" xml:space="preserve">
          <source>There is some danger that common usage and widespread sloppy coding will establish a de facto standard for e-mail addresses that is more restrictive than the recorded formal standard.</source>
          <target state="translated">有一种危险,那就是普遍的使用和普遍的马虎编码将为电子邮件地址建立一个比正式记录的标准更严格的事实标准。</target>
        </trans-unit>
        <trans-unit id="eab562daff5b311a461fd5743bafead8320f8ac4" translate="yes" xml:space="preserve">
          <source>There's one problem with translating the RFC syntaxes into regexes: the syntaxes are not regular! This is because they allow for optional comments in email addresses that can be infinitely nested, while infinite nesting can't be described by a regular expression. To scan for or validate addresses containing comments you need a parser or more powerful expressions. (Note that languages like Perl have constructs to describe context free grammars in a regex-like way.) In this answer I'll disregard comments and only consider proper regular expressions.</source>
          <target state="translated">将RFC语法翻译成regexes有一个问题:这些语法不是正则表达式! 这是因为它们允许电子邮件地址中的可选注释可以无限嵌套,而无限嵌套不能用正则表达式来描述。要扫描或验证包含注释的地址,你需要一个解析器或更强大的表达式。(请注意,像Perl这样的语言有构造函数,可以用类似regex的方式来描述无上下文的语法)。在这个答案中,我将不考虑注释,只考虑正则表达式。</target>
        </trans-unit>
        <trans-unit id="604bc09674b2ed7a86a57667d281ad5d75b92f79" translate="yes" xml:space="preserve">
          <source>These two considerations could be addressed by parsing the address. The extra length constraint on host names could in some cases also be addressed by using an extra regex that checks it, and matching the address against both expressions.</source>
          <target state="translated">这两个方面的考虑可以通过解析地址来解决。在某些情况下,对主机名的额外长度限制也可以通过使用额外的regex来检查,并将地址与这两个表达式进行匹配来解决。</target>
        </trans-unit>
        <trans-unit id="6a6068ef4c671cc993159bd9f7876a710e880eee" translate="yes" xml:space="preserve">
          <source>This intentionally doesn't comply with &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;.</source>
          <target state="translated">这故意不符合&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e3c059245745fe56b963a2dd674dc3a620e4611" translate="yes" xml:space="preserve">
          <source>This is a job for a parser, but even if an address is syntactically valid, it still may not be deliverable. Sometimes you have to resort to the hillbilly method of &quot;Hey, y'all, watch ee-us!&quot;</source>
          <target state="translated">这是解析器的工作,但即使地址在语法上是有效的,也不一定能送达。有时候,你不得不采用 &quot;嘿,你们这些乡巴佬们,看好我们!&quot;</target>
        </trans-unit>
        <trans-unit id="40bd4785946bbfd84d54b271e863481fe650854b" translate="yes" xml:space="preserve">
          <source>This question is asked a lot, but I think you should step back and ask yourself &lt;em&gt;why&lt;/em&gt; you want to validate email adresses syntactically? What is the benefit really?</source>
          <target state="translated">这个问题被问了很多，但是我认为您应该退后一步，问自己&lt;em&gt;为什么&lt;/em&gt;要在语法上验证电子邮件地址？ 真正的好处是什么？</target>
        </trans-unit>
        <trans-unit id="5b58c52e10b145304d80e39ff92b63c4aaad7cba" translate="yes" xml:space="preserve">
          <source>This regex is from Perl's &lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email::Valid&lt;/a&gt; library. I believe it to be the most accurate, it matches all 822. And, it is based on the regular expression in the O'Reilly book:</source>
          <target state="translated">该正则表达式来自Perl的&lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email :: Valid&lt;/a&gt;库。 我认为它是最准确的，它可以匹配所有822。而且，它基于O'Reilly书中的正则表达式：</target>
        </trans-unit>
        <trans-unit id="ab37a40832b8b946cb58d45531219e00bca7eb3a" translate="yes" xml:space="preserve">
          <source>This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module).</source>
          <target state="translated">这个正则表达式将只验证那些被删除了任何注释并以空格代替的地址(这是由模块完成的)。</target>
        </trans-unit>
        <trans-unit id="881eea75af81659120231f1a02a723701d920b5f" translate="yes" xml:space="preserve">
          <source>Use the following regex for input validation:</source>
          <target state="translated">在输入验证中使用以下的regex。</target>
        </trans-unit>
        <trans-unit id="a38e078061a3af58841a4b63d102b4842c3180b3" translate="yes" xml:space="preserve">
          <source>User input validation</source>
          <target state="translated">用户输入验证</target>
        </trans-unit>
        <trans-unit id="417d6b6f39c552dae06a913e7670f440710547a0" translate="yes" xml:space="preserve">
          <source>Using a regular expression that recognizes email addresses could be useful in various situations: for example to scan for email addresses in a document, to validate user input, or as an integrity constraint on a data repository.</source>
          <target state="translated">使用能够识别电子邮件地址的正则表达式可以在各种情况下使用:例如扫描文档中的电子邮件地址,验证用户输入,或者作为数据存储库的完整性约束。</target>
        </trans-unit>
        <trans-unit id="7404787d1040c9c25b80ed394962a1fd680b081b" translate="yes" xml:space="preserve">
          <source>When only accepting host names in the domain part (after the @-sign), the regexes above accept only labels with at most 63 characters, as they should. However, they don't enforce the fact that the entire host name must be at most 253 characters long (including the dots). Although this constraint is strictly speaking still regular, it's not feasible to make a regex that incorporates this rule.</source>
          <target state="translated">当只接受域名部分(@-sign之后)的主机名时,上面的regexes只接受最多63个字符的标签。但是,它们并没有强制要求整个主机名最多只能有253个字符的长度(包括点)。虽然这个约束严格来说仍然是有规律的,但要做一个包含这个规则的regex是不可行的。</target>
        </trans-unit>
        <trans-unit id="6adb4fb8492c6fd0b85a550dd4f05a8dfdfca38d" translate="yes" xml:space="preserve">
          <source>Which is the one used in ASP.NET by the RegularExpressionValidator.</source>
          <target state="translated">也就是ASP.NET中使用的 RegularExpressionValidator。</target>
        </trans-unit>
        <trans-unit id="39672ee698f325ca5854a5b725c41110c115c08f" translate="yes" xml:space="preserve">
          <source>While deciding which characters are allowed, please remember your apostrophed and hyphenated friends. I have no control over the fact that my company generates my email address using my name from the HR system. That includes the apostrophe in my last name. I can't tell you how many times I have been blocked from interacting with a website by the fact that my email address is &quot;invalid&quot;.</source>
          <target state="translated">在决定允许使用哪些字符的同时,请记住你的远教和连字符的朋友。我无法控制我的公司用我的名字从人力资源系统中生成我的电子邮件地址。这其中包括我的姓氏中的撇号。我不知道有多少次因为我的邮箱地址 &quot;无效 &quot;而被阻止与网站互动。</target>
        </trans-unit>
        <trans-unit id="040788551c90816319df84a15c3045438d8955bd" translate="yes" xml:space="preserve">
          <source>You could use the one employed by the jQuery Validation plugin:</source>
          <target state="translated">你可以使用jQuery Validation插件所使用的那个。</target>
        </trans-unit>
        <trans-unit id="c0376b0b9474c79623a7bcdd162cc203cdab2051" translate="yes" xml:space="preserve">
          <source>You should allow uppercase alphabets too.  Email systems will normalize the local part and domain part.</source>
          <target state="translated">你也应该允许使用大写字母。电子邮件系统会将本地部分和域名部分正常化。</target>
        </trans-unit>
        <trans-unit id="50ecc3e11978eaebf7cdde3eb4723774140d8446" translate="yes" xml:space="preserve">
          <source>You should not use regular expressions to validate email addresses.</source>
          <target state="translated">您不应该使用正则表达式来验证电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="379c3a7e829422a79610cb5cbd113ec1b0e6fea0" translate="yes" xml:space="preserve">
          <source>[UPDATED] I've collated everything I know about email address validation here: &lt;a href=&quot;http://isemail.info&quot;&gt;http://isemail.info&lt;/a&gt;, which now not only validates but also diagnoses problems with email addresses. I agree with many of the comments here that validation is only part of the answer; see my essay at &lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/about&lt;/a&gt;.</source>
          <target state="translated">[更新]我已经在这里整理了有关电子邮件地址验证的所有信息： &lt;a href=&quot;http://isemail.info&quot;&gt;http&lt;/a&gt; : //isemail.info ，它现在不仅可以验证而且可以诊断电子邮件地址问题。 我同意这里的许多评论，即验证仅是答案的一部分。 请参阅&lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/about上的&lt;/a&gt;文章。</target>
        </trans-unit>
        <trans-unit id="782f584cb9f10bfd4e2d20721f3769a1a46ed1e5" translate="yes" xml:space="preserve">
          <source>email =~ &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt;</source>
          <target state="translated">电子邮件=〜 &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt; +\.[ ^@]{2,}$/</target>
        </trans-unit>
        <trans-unit id="fb288e30ab07ffc44b2ae8e5468078c1c3d3cd58" translate="yes" xml:space="preserve">
          <source>have a domain part (i.e. the part after the @-sign) that is a host name with at least two labels, each of which is at most 63 characters long.</source>
          <target state="translated">有一个域名部分(即@-符号后的部分),是一个至少有两个标签的主机名,每个标签最多只有63个字符长。</target>
        </trans-unit>
        <trans-unit id="580c167d115747dac91f0ce065f1f0cea9534d8c" translate="yes" xml:space="preserve">
          <source>have a local part (i.e. the part before the @-sign) that is strictly compliant with RFC 5321/5322,</source>
          <target state="translated">有一个严格符合RFC 53215322的本地部分(即@-符号前的部分)。</target>
        </trans-unit>
        <trans-unit id="d59803fdebe968a3fc4b59dba8d7638e6988094e" translate="yes" xml:space="preserve">
          <source>if you want to use it in Java its really very easy</source>
          <target state="translated">如果你想在Java中使用它,它真的很容易。</target>
        </trans-unit>
        <trans-unit id="92fd5a496d47e663c9af65c455e24766e7ce98ef" translate="yes" xml:space="preserve">
          <source>is_email() remains, as far as I know, the only validator that will tell you definitively whether a given string is a valid email address or not. I've upload a new version at &lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/&lt;/a&gt;</source>
          <target state="translated">据我所知，is_email（）仍然是唯一可以明确告诉您给定字符串是否为有效电子邮件地址的验证器。 我已经在&lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/&lt;/a&gt;上传了一个新版本。</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
