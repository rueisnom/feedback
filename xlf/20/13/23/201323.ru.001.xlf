<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/201323">
    <body>
      <group id="201323">
        <trans-unit id="b1b5a828768c114744b0e8c042dc66da113334ec" translate="yes" xml:space="preserve">
          <source>&quot;User Display Name user3@company.com&quot;</source>
          <target state="translated">&quot;Имя пользователя user3@company.com&quot;</target>
        </trans-unit>
        <trans-unit id="26c2451374584a209014621e5558743bfa2ce56d" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com;user2@gmail.com&quot;</target>
        </trans-unit>
        <trans-unit id="28633028efd2c24861ac4a1740c2217f423b8453" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com; user3@company.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com;user2@gmail.com;user3@company.com&quot;.</target>
        </trans-unit>
        <trans-unit id="0bc92ef1ed9e5d917df368b9389fccbdd11bbe8d" translate="yes" xml:space="preserve">
          <source>&quot;user4 @company.com&quot;</source>
          <target state="translated">&quot;user4 @company.com&quot;</target>
        </trans-unit>
        <trans-unit id="32f8045af87affeff6f4333e80528d9f758f0dff" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt;)
If you're looking for something simpler but that will catch most valid email addresses try something like:</source>
          <target state="translated">( &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt; ) Если вы ищете что-то более простое, но которое поймает большинство действительных адресов электронной почты, попробуйте что-то вроде:</target>
        </trans-unit>
        <trans-unit id="75f14c0b3eb6f2ddf1a7b788a9c63a1261d191e6" translate="yes" xml:space="preserve">
          <source>(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</source>
          <target state="translated">(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</target>
        </trans-unit>
        <trans-unit id="41c1c65773194544312b0d413e9568defa0fa5f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Cal Henderson&lt;/a&gt; (Flickr) wrote an article called &lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;Parsing Email Adresses in PHP&lt;/a&gt; and shows how to do proper RFC (2)822-compliant Email Address parsing.  You can also get the source code in &lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt;, python and ruby which is &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;cc licensed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Кэл Хендерсон&lt;/a&gt; (Flickr) написал статью под названием &amp;laquo; &lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;Парсинг адресов электронной почты в PHP&amp;raquo;&lt;/a&gt; и показывает, как правильно выполнять синтаксический анализ адресов электронной почты , соответствующих RFC (2) 822. Вы также можете получить исходный код в &lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt; , python и ruby, который &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;лицензирован cc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4215c60a61270d50ef11c83e3925ba93699fa35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt;&lt;em&gt;etc...&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt; &lt;em&gt;etc ...&lt;/em&gt; &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3654c41e6ade2da259eef5a7ae400fac5827b8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the best regular expression you have or have seen for validating emails?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Какое лучшее регулярное выражение вы видели или видели для проверки писем?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83da26750665b7eec085cd165f43ccd6b0fe79c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &lt;code&gt;@&lt;/code&gt; character), too vague (after the &lt;code&gt;@&lt;/code&gt; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Это требование является &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;преднамеренным нарушением&lt;/a&gt; &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; , который определяет синтаксис для адресов электронной почты, который является одновременно слишком строгим (до символа &lt;code&gt;@&lt;/code&gt; ), слишком расплывчатым (после символа &lt;code&gt;@&lt;/code&gt; ) и слишком слабым (допускает комментарии, пробелы). символы и строки в кавычках в манерах, незнакомых большинству пользователей) для практического использования здесь.</target>
        </trans-unit>
        <trans-unit id="467b846662a13d15de5bbd34d57ea291cf420f2e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;valid e-mail address&lt;/strong&gt; is a string that matches the ABNF production [&amp;hellip;].</source>
          <target state="translated">&lt;strong&gt;Действительный адрес электронной почты&lt;/strong&gt; - это строка, соответствующая продукции ABNF [&amp;hellip;].</target>
        </trans-unit>
        <trans-unit id="aef7d848543c3d5b49c4b583603a1e7b9279f10b" translate="yes" xml:space="preserve">
          <source>A common use case is user input validation, for example on an html form. In that case it's usually reasonable to preclude address-literals and to require at least two labels in the hostname. Taking the improved RFC 5321 regex from the previous section as a basis, the resulting expression would be:</source>
          <target state="translated">Обычным случаем использования является проверка пользовательского ввода,например,на html-форме.В этом случае,как правило,разумно исключить адрес-литералы и потребовать как минимум две метки в имени хоста.Если взять за основу улучшенный регекс RFC 5321 из предыдущего раздела,то получится выражение:</target>
        </trans-unit>
        <trans-unit id="7f254b288b513a222b7ce9705affbccd53cd80d8" translate="yes" xml:space="preserve">
          <source>According to official standard &lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt; valid email regex is</source>
          <target state="translated">Согласно официальному стандарту &lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt; действительное регулярное выражение электронной почты</target>
        </trans-unit>
        <trans-unit id="6d2f2f9c03ab4cdaf2b9f2364a0c2799a6329154" translate="yes" xml:space="preserve">
          <source>Addresses matched by this regex:</source>
          <target state="translated">Адреса,совпадающие с этим регексом:</target>
        </trans-unit>
        <trans-unit id="b75e467be1d8b94588b3cc3f5aaec8acae067ee7" translate="yes" xml:space="preserve">
          <source>After all, the &lt;strong&gt;best&lt;/strong&gt; way to validate the email address is still to actually &lt;em&gt;send&lt;/em&gt; an email to the address in question to validate the address. If the email address is part of user authentication (register/login/etc), then you can perfectly combine it with the user activation system. I.e. send an email with a link with an unique activation key to the specified email address and only allow login when the user has activated the newly created account using the link in the email.</source>
          <target state="translated">В конце концов, &lt;strong&gt;лучший&lt;/strong&gt; способ проверить адрес электронной почты по-прежнему состоит в том, чтобы фактически &lt;em&gt;отправить&lt;/em&gt; электронное письмо на указанный адрес для подтверждения адреса. Если адрес электронной почты является частью аутентификации пользователя (регистрация / логин / и т. Д.), То вы можете идеально сочетать его с системой активации пользователя. Т.е. отправьте электронное письмо со ссылкой с уникальным ключом активации на указанный адрес электронной почты и разрешите вход в систему только тогда, когда пользователь активировал вновь созданную учетную запись, используя ссылку в электронном письме.</target>
        </trans-unit>
        <trans-unit id="4747783011ffa130857e2027d5ff2eef5ab7e5ce" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part and domain name domain (requiring at least two domain name labels with the TLD limited to 2-6 alphabetic characters).</source>
          <target state="translated">Позволяет использовать локальную точечную часть и доменное имя (требуется не менее двух ярлыков доменного имени с ограничением ДВУ 2-6 алфавитными символами).</target>
        </trans-unit>
        <trans-unit id="98f5ff42c06d45b9d6040c487efd8ddaae34384a" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, domain name domain, and (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain.</source>
          <target state="translated">Позволяет точечную локальную часть,локальную часть с кавычками,доменное имя домена,и (IPv4,IPv6,и IPv4-mapped IPv6 адрес)домен буквально.</target>
        </trans-unit>
        <trans-unit id="1a501b9511aa2902571ab4411c2d68715c865f16" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, obsolete (mixed dot-atom and quoted-string) local-part, domain name domain, (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain, and (nested) CFWS.</source>
          <target state="translated">Позволяет локальную часть в виде точки-атома,локальную часть в виде кавычек,устаревшую (смешанную точку-атом и кавычки)локальную часть,доменное имя домена,(IPv4,IPv6 и IPv4-mapped IPv6 адрес)буквальный домен,и (вложенный)CFWS.</target>
        </trans-unit>
        <trans-unit id="137a6c9662b514d8385afe47af02dd62a6fdb560" translate="yes" xml:space="preserve">
          <source>Another consideration, especially when using the regexes for input validation, is feedback to the user. If a user enters an incorrect address, it would be nice to give a little more feedback than a simple &quot;syntactically incorrect address&quot;. With &quot;vanilla&quot; regexes this is not possible.</source>
          <target state="translated">Еще одним соображением,особенно при использовании регексов для проверки входных данных,является обратная связь с пользователем.Если пользователь вводит неправильный адрес,было бы неплохо дать немного больше обратной связи,чем просто &quot;синтаксически неправильный адрес&quot;.С &quot;ванильными&quot; регексами это невозможно.</target>
        </trans-unit>
        <trans-unit id="7cf149b9d25d2489f954894be6028e467951029a" translate="yes" xml:space="preserve">
          <source>As stated in paragraph 3.1.4. of RFC 822 optional linear white space may be inserted between lexical tokens. Where applicable I've expanded the expressions to accommodate this rule and marked the result with &quot;opt-lwsp&quot;.</source>
          <target state="translated">Как указано в пункте 3.1.4 RFC 822,между лексическими маркерами может быть вставлено дополнительное линейное белое пространство.Там,где это применимо,я расширил выражения,чтобы учесть это правило,и пометил результат &quot;opt-lwsp&quot;.</target>
        </trans-unit>
        <trans-unit id="023052f99d8ae0931ecbe27dc9dbfef6103d1f37" translate="yes" xml:space="preserve">
          <source>As you're writing in PHP I'd advice you to use the PHP build-in validation for emails.</source>
          <target state="translated">Поскольку вы пишете на PHP,я бы посоветовал вам использовать встроенную проверку PHP для электронной почты.</target>
        </trans-unit>
        <trans-unit id="47bf4436a0ce6299cec6effd82a884e698974efd" translate="yes" xml:space="preserve">
          <source>Basic:</source>
          <target state="translated">Basic:</target>
        </trans-unit>
        <trans-unit id="0073f212804bc3306f849cfa8b512d52e55a727a" translate="yes" xml:space="preserve">
          <source>Confirmation tokens are the only way to know you got the address of the person entering it. This is why most mailing lists now use that mechanism to confirm sign-ups. After all, anybody can put down &lt;code&gt;president@whitehouse.gov&lt;/code&gt;, and that will even parse as legal, but it isn't likely to be the person at the other end.</source>
          <target state="translated">Жетоны подтверждения - это единственный способ узнать, что вы получили адрес человека, который его вводит. Вот почему большинство списков рассылки теперь используют этот механизм для подтверждения регистрации. В конце концов, любой может отложить &lt;code&gt;president@whitehouse.gov&lt;/code&gt; , и это даже будет считаться законным, но вряд ли это будет человек на другом конце.</target>
        </trans-unit>
        <trans-unit id="8d15eaf92a267e0a03325e52d09f34bab6f23882" translate="yes" xml:space="preserve">
          <source>Context:</source>
          <target state="translated">Context:</target>
        </trans-unit>
        <trans-unit id="f828a4a98f03513a4667164d14af724f3d41a094" translate="yes" xml:space="preserve">
          <source>Correcting the &lt;code&gt;00&lt;/code&gt; bug in the IP pattern, we obtain a working and fairly fast regex.  (Scrape the rendered version, not the markdown, for actual code.)</source>
          <target state="translated">Исправляя ошибку &lt;code&gt;00&lt;/code&gt; в шаблоне IP, мы получаем работающее и довольно быстрое регулярное выражение. (Очистите отрендеренную версию, а не уценку, для реального кода.)</target>
        </trans-unit>
        <trans-unit id="bf64925120bcbd811e65f1c72f59a3f04f836d22" translate="yes" xml:space="preserve">
          <source>Debuggex Demo</source>
          <target state="translated">Демонстрация Debuggex</target>
        </trans-unit>
        <trans-unit id="61dca52965a9edf91b73613147e9ac7c10c8eeea" translate="yes" xml:space="preserve">
          <source>Different syntaxes should be used for different purposes. If you want to scan for email addresses in a (possibly very old) document it may be a good idea to use the syntax as defined in RFC 822. On the other hand, if you want to validate user input you may want to use the syntax as defined in RFC 5322, probably only accepting canonical representations. You should decide which syntax applies to your specific case.</source>
          <target state="translated">Для различных целей следует использовать разные синтаксисы.Если вы хотите отсканировать почтовые адреса в (возможно,очень старом)документе,возможно,будет хорошей идеей использовать синтаксис,как определено в RFC 822.С другой стороны,если вы хотите проверить вводимую пользователем информацию,вы можете использовать синтаксис,определенный в RFC 5322,вероятно,принимая только канонические представления.Вы должны решить,какой синтаксис применим в вашем конкретном случае.</target>
        </trans-unit>
        <trans-unit id="cc6873ddb69d463add1609634358323011bb0f08" translate="yes" xml:space="preserve">
          <source>Don't know about best, but &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;this one&lt;/a&gt; is at least correct, as long as the addresses have their comments stripped and replaced with whitespace.</source>
          <target state="translated">Не знаю, что лучше, но &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;этот,&lt;/a&gt; по крайней мере, правильный, если на адресах есть комментарии и они заменены пробелами.</target>
        </trans-unit>
        <trans-unit id="850a13e5767f580f2031a50d8569b73c2488bbf5" translate="yes" xml:space="preserve">
          <source>EDIT:
From the link:</source>
          <target state="translated">EDIT:По ссылке:</target>
        </trans-unit>
        <trans-unit id="4986de5889e2f11c9bbdb9ef8b2a461042b1376a" translate="yes" xml:space="preserve">
          <source>Elaborate answer</source>
          <target state="translated">Продуманный ответ</target>
        </trans-unit>
        <trans-unit id="4d171fe5e95a2abcc5be91fb682415349c363bb7" translate="yes" xml:space="preserve">
          <source>For PHP, you should &lt;em&gt;not&lt;/em&gt; use the pattern given in &lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;Validate an E-Mail Address with PHP, the Right Way&lt;/a&gt; from which I quote:</source>
          <target state="translated">Для PHP вы &lt;em&gt;не&lt;/em&gt; должны использовать шаблон, приведенный в разделе &lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;Проверка адреса электронной почты с PHP, правильный путь,&lt;/a&gt; из которого я цитирую:</target>
        </trans-unit>
        <trans-unit id="388c8341169873cbf876d842d5c93f563b812762" translate="yes" xml:space="preserve">
          <source>For a vivid demonstration, the following monster is pretty good but still does not correctly recognize all syntactically valid email addresses: it recognizes nested comments up to four levels deep.</source>
          <target state="translated">Для яркой демонстрации,следующий монстр довольно хорош,но все же не правильно распознает все синтаксически правильные адреса электронной почты:он распознает вложенные комментарии до четырех уровней глубины.</target>
        </trans-unit>
        <trans-unit id="844bb7409b2bf0d129a7300da9332ae49f500e9f" translate="yes" xml:space="preserve">
          <source>For the most comprehensive evaluation of the best regular expression for validating an email address please see this link; &quot;&lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;&quot;</source>
          <target state="translated">Для наиболее полной оценки лучшего регулярного выражения для проверки адреса электронной почты, пожалуйста, перейдите по этой ссылке; &amp;laquo; &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Сравнение адреса электронной почты, проверяющего регулярные выражения&lt;/a&gt; &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="810c3f2bf5a7cff75d30fdb21ab358a9d78d240a" translate="yes" xml:space="preserve">
          <source>For your regex of domain part, domain name cannot starts with '-' and cannot ends with '-'. Dash can only stays in between.</source>
          <target state="translated">Для вашего регекса части домена,доменное имя не может начинаться с '-' и не может заканчиваться на '-'.Тире может остаться только между ними.</target>
        </trans-unit>
        <trans-unit id="858f135b293e0d7506e7d37d2280ccbde6e7451a" translate="yes" xml:space="preserve">
          <source>Further considerations</source>
          <target state="translated">Дальнейшие соображения</target>
        </trans-unit>
        <trans-unit id="985180927b564d247d4e14d076eb593cde86c3fb" translate="yes" xml:space="preserve">
          <source>Further restrictions</source>
          <target state="translated">Дальнейшие ограничения</target>
        </trans-unit>
        <trans-unit id="1c80cf144e810a9d98d32782de59c315753f43bf" translate="yes" xml:space="preserve">
          <source>Furthermore, an address having a dot at the end, like &lt;code&gt;user@company.&lt;/code&gt; is accepted by MailAddress as well.</source>
          <target state="translated">Кроме того, адрес, имеющий точку в конце, например, &lt;code&gt;user@company.&lt;/code&gt; также принимается MailAddress.</target>
        </trans-unit>
        <trans-unit id="090fe8536ba48667df2f9156f2408f10a24285d6" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;diagram&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite state machine&lt;/a&gt; for above regexp which is more clear than regexp itself</source>
          <target state="translated">Вот &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;диаграмма&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;конечного автомата&lt;/a&gt; для приведенного выше регулярного выражения, которая более понятна, чем само регулярное выражение</target>
        </trans-unit>
        <trans-unit id="2a7827f413e7dc52ce89180fc06b75a173a00bb2" translate="yes" xml:space="preserve">
          <source>Here is the current top expression for reference purposes:</source>
          <target state="translated">Вот текущее верхнее выражение для справочных целей:</target>
        </trans-unit>
        <trans-unit id="f1b99749e961642af10fe964ad761b71345efbe1" translate="yes" xml:space="preserve">
          <source>Here's the PHP I use. I've choosen this solution in the spirit of &quot;false positives are better than false negatives&quot; as declared by another commenter here AND with regards to keeping your response time up and server load down ... there's really no need to waste server resources with a regular expression when this will weed out most simple user error. You can always follow this up by sending a test email if you want.</source>
          <target state="translated">Вот PHP,который я использую.Я выбрал это решение в духе &quot;ложные срабатывания лучше,чем ложные срабатывания&quot;,как заявил здесь другой комментатор И в том,что касается поддержания времени отклика и снижения нагрузки на сервер...на самом деле нет необходимости тратить ресурсы сервера с регулярным выражением,когда это устранит самую простую пользовательскую ошибку.Вы всегда можете проследить за этим,отправив тестовое электронное письмо,если хотите.</target>
        </trans-unit>
        <trans-unit id="c555de7c7b1f7b703afcbb25f5d37921cd5a5f3c" translate="yes" xml:space="preserve">
          <source>Here's the derivation:</source>
          <target state="translated">Вот деривация:</target>
        </trans-unit>
        <trans-unit id="40e3a2be8d888879a228175a976ea9a711b4df90" translate="yes" xml:space="preserve">
          <source>How to validate an email address using a regular expression</source>
          <target state="translated">Как проверить адрес электронной почты с помощью регулярного выражения</target>
        </trans-unit>
        <trans-unit id="b7c6fcdddbab0b180253335877c4f6f7061b17bc" translate="yes" xml:space="preserve">
          <source>I also do not recommend explicitly validating against a list of literal top-level domains or even imposing length-constraints (remember how &quot;.museum&quot; invalidated &lt;code&gt;[a-z]{2,4}&lt;/code&gt;), but if you must:</source>
          <target state="translated">Я также не рекомендую явно проверять список литеральных доменов верхнего уровня или даже накладывать ограничения длины (вспомните, как &amp;laquo;.museum&amp;raquo; аннулировал &lt;code&gt;[a-z]{2,4}&lt;/code&gt; ), но если вы должны:</target>
        </trans-unit>
        <trans-unit id="6106b21b52d6c2869f1edf73c29f89a75ca99ea7" translate="yes" xml:space="preserve">
          <source>I arrived at the following regular expression. I invite everyone to try and break it. If you find any false positives or false negatives, please post them in a comment and I'll try to fix the expression as soon as possible.</source>
          <target state="translated">Я пришел к следующему регулярному выражению.Я приглашаю всех попробовать сломать его.Если вы обнаружили ложные срабатывания или ложные срабатывания,пожалуйста,напишите об этом в комментарии,и я постараюсь исправить выражение как можно скорее.</target>
        </trans-unit>
        <trans-unit id="de12597981cafac001a63547fcd2d56956471988" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 5322 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">Я считаю, что он полностью соответствует RFC 5322, включая &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;ошибки&lt;/a&gt; . Он распознает только адреса электронной почты в их канонической форме. Для регулярного выражения, которое распознает (сворачивание) пробелы, смотрите вывод ниже.</target>
        </trans-unit>
        <trans-unit id="89706fb75be6521376b620efafa6099e39529f6f" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 822 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">Я считаю, что он полностью соответствует RFC 822, включая &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;ошибки&lt;/a&gt; . Он распознает только адреса электронной почты в их канонической форме. Для регулярного выражения, которое распознает (сворачивание) пробелы, смотрите вывод ниже.</target>
        </trans-unit>
        <trans-unit id="f512b55ca04846c10d5913e0fe2ed677435f773d" translate="yes" xml:space="preserve">
          <source>I collated test cases from Cal Henderson, Dave Child, Phil Haack, Doug Lovell, RFC5322 and RFC 3696. 275 test addresses in all. I ran all these tests against all the free validators I could find.</source>
          <target state="translated">Я собрал тестовые случаи от Кэла Хендерсона,Дэйва Чайлда,Фила Хаака,Дага Лавла,RFC5322 и RFC 3696.Всего 275 тестовых адресов.Я прогонял все эти тесты по всем бесплатным валидаторам,которые смог найти.</target>
        </trans-unit>
        <trans-unit id="8bc4518aeece4f1a66566191f1afe71e2bbca678" translate="yes" xml:space="preserve">
          <source>I discuss some issues in my &lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;answer to Is there a php library for email address validation?&lt;/a&gt;, it is discussed also in &lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;Regexp recognition of email address hard?&lt;/a&gt;</source>
          <target state="translated">Я обсуждаю некоторые вопросы в своем &lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;ответе на вопрос: есть ли библиотека php для проверки адреса электронной почты?&lt;/a&gt; , это также обсуждается в &lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;Regexp распознавание адреса электронной почты трудно?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8865bf5a399677a2e921d40976a7e3002e86774" translate="yes" xml:space="preserve">
          <source>I do not recommend restricting the local part further, e.g. by precluding quoted strings, since we don't know what kind of mailbox names some hosts allow (like &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; or even &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt;).</source>
          <target state="translated">Я не рекомендую ограничивать локальную часть, например, исключая строки в кавычках, поскольку мы не знаем, какие имена почтовых ящиков допускают некоторые хосты (например, &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; или даже &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b8e124659a2c24af661cc381668ac370a95c11e1" translate="yes" xml:space="preserve">
          <source>I ignored all the &quot;obs-&quot; rules from the RFC. This means that the regexes only match email addresses that are strictly RFC 5322 compliant. If you have to match &quot;old&quot; addresses (as the looser grammar including the &quot;obs-&quot; rules does), you can use one of the RFC 822 regexes from the previous paragraph.</source>
          <target state="translated">Я проигнорировал все &quot;обс-&quot; правила из RFC.Это означает,что регексы совпадают только с адресами электронной почты,которые строго соответствуют RFC 5322.Если вам нужно соответствовать &quot;старым&quot; адресам (как это делает более слабая грамматика,включая правила &quot;обс-&quot;),вы можете использовать один из регексов RFC 822 из предыдущего абзаца.</target>
        </trans-unit>
        <trans-unit id="062a5233c8de0b33af018e4eeae4a1ba0c95916d" translate="yes" xml:space="preserve">
          <source>I never bother creating with my own regular expression, because chances are that someone else has already come up with a better version.  I always use &lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib&lt;/a&gt; to find one to my liking.</source>
          <target state="translated">Я никогда не удосужился создавать свои собственные регулярные выражения, потому что есть вероятность, что кто-то другой уже придумал лучшую версию. Я всегда использую &lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib,&lt;/a&gt; чтобы найти тот, который мне по вкусу.</target>
        </trans-unit>
        <trans-unit id="088e64f9ee7f255c4c5eac7974a7114e20492d11" translate="yes" xml:space="preserve">
          <source>I use</source>
          <target state="translated">я использую</target>
        </trans-unit>
        <trans-unit id="6795b75201299955c1b7995c570b13d659921b18" translate="yes" xml:space="preserve">
          <source>I use POSIX &quot;extended&quot; regular expressions in this answer, assuming an ASCII compatible character set.</source>
          <target state="translated">В этом ответе я использую &quot;расширенные&quot; регулярные выражения POSIX,предполагая набор символов,совместимых с ASCII.</target>
        </trans-unit>
        <trans-unit id="56d0d3ff30df9317fddde67f83205c8cb0ff3cec" translate="yes" xml:space="preserve">
          <source>I use it in several PHP programs, and it works most of the time.  However, from time to time I get contacted by someone that is having trouble with a site that uses it, and I end up having to make some adjustment (most recently I realized that I wasn't allowing 4-character TLDs).</source>
          <target state="translated">Я использую его в нескольких PHP-программах,и он работает большую часть времени.Однако время от времени со мной связывается кто-то,у кого есть проблемы с сайтом,который его использует,и в конце концов мне приходится вносить некоторые коррективы (совсем недавно я понял,что не разрешаю 4-символьные TLD).</target>
        </trans-unit>
        <trans-unit id="034d131aacb2134a772bdf60fff06a86578e9c3f" translate="yes" xml:space="preserve">
          <source>I'll try to keep this page up-to-date as people enhance their validators. Thanks to Cal, Michael, Dave, Paul and Phil for their help and co-operation in compiling these tests and constructive criticism of &lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;my own validator&lt;/a&gt;.</source>
          <target state="translated">Я постараюсь обновлять эту страницу по мере того, как люди улучшат свои валидаторы. Спасибо Кэлу, Майклу, Дейву, Полу и Филу за помощь и сотрудничество в составлении этих тестов и конструктивную критику &lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;моего собственного валидатора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8588212a8c9ffe41b9ef89fa0c2610e960516246" translate="yes" xml:space="preserve">
          <source>I've seen several solutions that use functions that use several shorter expressions, but I'd rather have one long complex expression in a simple function instead of several short expression in a more complex function.</source>
          <target state="translated">Я видел несколько решений,использующих функции,которые используют несколько более коротких выражений,но я бы предпочел иметь одно длинное сложное выражение в простой функции,а не несколько коротких выражений в более сложной функции.</target>
        </trans-unit>
        <trans-unit id="725e5ed871d70812fff5a898374748169242406b" translate="yes" xml:space="preserve">
          <source>If the purpose of the regex is just to quickly inform the user in the UI that the specified email address doesn't look like in the right format, best is still to check if it matches basically the following regex:</source>
          <target state="translated">Если целью регекса является просто быстрое информирование пользователя в пользовательском интерфейсе о том,что указанный адрес электронной почты не выглядит в правильном формате,то лучше всего все же проверить,соответствует ли он в основном следующему регексуалу:</target>
        </trans-unit>
        <trans-unit id="64cac7449f582a2dc109b435c4145c5f430d12f4" translate="yes" xml:space="preserve">
          <source>If you plan to use the &lt;code&gt;MailAddress&lt;/code&gt; to validate the e-mail address, be aware that this approach accepts the display name part of the e-mail address as well, and that may not be exactly what you want to achieve. For example, it accepts these strings as valid e-mail addresses:</source>
          <target state="translated">Если вы планируете использовать &lt;code&gt;MailAddress&lt;/code&gt; для проверки адреса электронной почты, имейте в виду, что этот подход также принимает часть отображаемого имени адреса электронной почты, и это может быть не совсем тем, чего вы хотите достичь. Например, он принимает эти строки в качестве действительных адресов электронной почты:</target>
        </trans-unit>
        <trans-unit id="99811d1346d22a72366acd0b3ff9e1075ab2e9fc" translate="yes" xml:space="preserve">
          <source>If you really want to use a regex, &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;here it is&lt;/a&gt;:</source>
          <target state="translated">Если вы действительно хотите использовать регулярное выражение, &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;вот оно&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="44ce491ec374723f385ed8ad3f99125bd8e8fe92" translate="yes" xml:space="preserve">
          <source>If you used the PEAR library, check out their mail function (forgot the exact name/library).  You can validate email address by calling one function, and it validates the email address according to definition in RFC822.</source>
          <target state="translated">Если вы использовали библиотеку PEAR,проверьте их почтовую функцию (забыли точную библиотеку имен).Вы можете проверить адрес электронной почты,позвонив в одну из функций,и она проверит адрес электронной почты в соответствии с определением в RFC822.</target>
        </trans-unit>
        <trans-unit id="89fdaa410759db94e2b5de2465bd333dc0953efc" translate="yes" xml:space="preserve">
          <source>If you want more information how this buid-in validation works, see here: &lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;Does PHP's filter_var FILTER_VALIDATE_EMAIL actually work?&lt;/a&gt;</source>
          <target state="translated">Если вам нужна дополнительная информация о том, как работает эта встроенная проверка, см. Здесь: Работает &lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;ли PHP filter_var FILTER_VALIDATE_EMAIL на самом деле?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c40d3684b422bc8ff6e3c9362de5de71480237e" translate="yes" xml:space="preserve">
          <source>If you want to get fancy and pedantic, &lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;implement a complete state engine&lt;/a&gt;. A regular expression can only act as a rudimentary filter. The problem with regular expressions is that telling someone that their perfectly valid e-mail address is invalid (a false positive) because your regular expression can't handle it is just rude and impolite from the user's perspective. A state engine for the purpose can both validate and even correct e-mail addresses that would otherwise be considered invalid as it disassembles the e-mail address according to each RFC. This allows for a potentially more pleasing experience, like</source>
          <target state="translated">Если вы хотите стать модным и педантичным, &lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;внедрите полный двигатель состояния&lt;/a&gt; . Регулярное выражение может действовать только как элементарный фильтр. Проблема с регулярными выражениями заключается в том, что говорить кому-то, что их совершенно действительный адрес электронной почты недействителен (ложный положительный результат), потому что ваше регулярное выражение не может его обработать, просто грубо и невежливо с точки зрения пользователя. Механизм состояний для этой цели может как проверять, так и даже корректировать адреса электронной почты, которые в противном случае считались бы недействительными, поскольку он разбирает адрес электронной почты в соответствии с каждым RFC. Это позволяет получить потенциально более приятный опыт, как</target>
        </trans-unit>
        <trans-unit id="15c3b1fffdba1f0e987fbd41a9b09407c2fdc511" translate="yes" xml:space="preserve">
          <source>If you want to validate that an email is correct, you have no choice than to send an confirmation email and have the user reply to that. In many cases you will &lt;em&gt;have&lt;/em&gt; to send a confirmation mail anyway for security reasons or for ethical reasons (so you cannot e.g. sign someone up to a service against their will).</source>
          <target state="translated">Если вы хотите проверить правильность электронного письма, у вас нет другого выбора, кроме как отправить электронное письмо с подтверждением и получить ответ от пользователя. Во многих случаях вам все равно &lt;em&gt;придется&lt;/em&gt; отправлять письмо-подтверждение по соображениям безопасности или по этическим соображениям (например, вы не можете, например, зарегистрировать кого-либо в службе против его воли).</target>
        </trans-unit>
        <trans-unit id="8f90c8045d52f4b058334a51ed4880471694677d" translate="yes" xml:space="preserve">
          <source>If you're running a php-version lower than 5.3.6 please be aware of this issue: &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https://bugs.php.net/bug.php?id=53091&lt;/a&gt;</source>
          <target state="translated">Если у вас php-версия ниже 5.3.6, пожалуйста, учтите эту проблему: &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https://bugs.php.net/bug.php?id=53091&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bfe401233bd6300cf11a6837adc1067496b852ea" translate="yes" xml:space="preserve">
          <source>In short, don't expect a single, usable regex to do a proper job. And the best regex will validate the syntax, not the validity of an e-mail (jhohn@example.com is correct but it will probably bounce...).</source>
          <target state="translated">Короче говоря,не жди,что хоть один полезный регекс сделает правильную работу.И лучший регекс подтвердит синтаксис,а не действительность письма (jhohn@example.com правильный,но он,скорее всего,отскакивает...).</target>
        </trans-unit>
        <trans-unit id="d64fa0e517911923332fac4e2f71d913ad55f9db" translate="yes" xml:space="preserve">
          <source>In some of these cases, only the last part of the strings is parsed as the address; the rest before that is the display name. To get a plain e-mail address without any display name, you can check the normalized address against your original string.</source>
          <target state="translated">В некоторых случаях в качестве адреса обрабатывается только последняя часть строк,остальное перед этим-отображаемое имя.Чтобы получить обычный адрес электронной почты без отображаемого имени,можно проверить нормализованный адрес по сравнению с исходной строкой.</target>
        </trans-unit>
        <trans-unit id="92b6aee3575856478de82d957aae0862c153d512" translate="yes" xml:space="preserve">
          <source>In this answer I&amp;rsquo;ll take &amp;ldquo;email address&amp;rdquo; to mean &lt;code&gt;addr-spec&lt;/code&gt; as defined in the RFCs (i.e. &lt;code&gt;jdoe@example.org&lt;/code&gt;, but not &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt;, nor &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt;).</source>
          <target state="translated">В этом ответе я буду использовать &amp;laquo;адрес электронной почты&amp;raquo; для обозначения &lt;code&gt;addr-spec&lt;/code&gt; , как определено в RFC (т. &lt;code&gt;jdoe@example.org&lt;/code&gt; , но не &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt; или &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29a575c86979b44c2fb0c43aa9e0d6c7884de728" translate="yes" xml:space="preserve">
          <source>Instead, use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt; class, like this:</source>
          <target state="translated">Вместо этого используйте класс &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt; , например:</target>
        </trans-unit>
        <trans-unit id="bb3cb298c6dabff17c93f08e57db5b7c214514b7" translate="yes" xml:space="preserve">
          <source>It all depends on how accurate you want to be.  For my purposes, where I'm just trying to keep out things like &lt;code&gt;bob @ aol.com&lt;/code&gt; (spaces in emails) or &lt;code&gt;steve&lt;/code&gt; (no domain at all) or &lt;code&gt;mary@aolcom&lt;/code&gt; (no period before .com), I use</source>
          <target state="translated">Все зависит от того, насколько точно вы хотите быть. Для моих целей, где я просто пытаюсь не пускать такие вещи, как &lt;code&gt;bob @ aol.com&lt;/code&gt; (пробелы в электронных письмах) или &lt;code&gt;steve&lt;/code&gt; (вообще без домена) или &lt;code&gt;mary@aolcom&lt;/code&gt; (без периода до .com), я использую</target>
        </trans-unit>
        <trans-unit id="55c558aed4449d4838de9ba71870504efebc5f4d" translate="yes" xml:space="preserve">
          <source>It depends on what you mean by best:
If you're talking about catching every valid email address use the following:</source>
          <target state="translated">Это зависит от того,что ты подразумеваешь под лучшим:Если вы говорите о том,чтобы поймать каждый действительный адрес электронной почты,используйте следующее:</target>
        </trans-unit>
        <trans-unit id="634ea515e24f27b27c16f1ac8df53108713d9618" translate="yes" xml:space="preserve">
          <source>It does not prevent people from entering invalid or made-up email addresses, or entering someone else's address.</source>
          <target state="translated">Это не мешает людям вводить недействительные или выдуманные адреса электронной почты,или вводить чужой адрес.</target>
        </trans-unit>
        <trans-unit id="ef282074cd0ee12c9819b8667cca979a4d908a32" translate="yes" xml:space="preserve">
          <source>It should however be noted that if you want to find out if the address actually refers to an existing mailbox, there's no substitute for sending a message to the address. If you only want to check if an address is grammatically correct then you could use a regular expression, but note that &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; is a grammatically correct email address that certainly doesn't refer to an existing mailbox.</source>
          <target state="translated">Однако следует отметить, что если вы хотите выяснить, действительно ли адрес относится к существующему почтовому ящику, ничто не заменит отправку сообщения на этот адрес. Если вы хотите только проверить, является ли адрес грамматически правильным, то вы можете использовать регулярное выражение, но учтите, что &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; - это грамматически правильный адрес электронной почты, который, безусловно, не ссылается на существующий почтовый ящик.</target>
        </trans-unit>
        <trans-unit id="cc84b5c5472043636abf125126a167f8104cf798" translate="yes" xml:space="preserve">
          <source>It will not catch common typos.</source>
          <target state="translated">Он не будет ловить обычные опечатки.</target>
        </trans-unit>
        <trans-unit id="748495ccfc92d4a51e5e47b57ba34035d4c9f075" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy in Perl 5.10 or newer:</source>
          <target state="translated">Это легко в Perl 5.10 или новее:</target>
        </trans-unit>
        <trans-unit id="c36addb1f9a0630cf0fa05910cfe747100da3dcb" translate="yes" xml:space="preserve">
          <source>It's also important to understand that validating it per the RFC tells you absolutely nothing about whether that address actually exists at the supplied domain, or whether the person entering the address is its true owner. People sign others up to mailing lists this way all the time. Fixing that requires a fancier kind of validation that involves sending that address a message that includes a confirmation token meant to be entered on the same web page as was the address.</source>
          <target state="translated">Также важно понимать,что проверка его согласно RFC ничего не говорит вам о том,действительно ли этот адрес существует в поставляемом домене,или же человек,вводящий адрес,является его истинным владельцем.Люди постоянно подписывают других на списки рассылки таким образом.Исправление,требующее более причудливой проверки,которая включает отправку на этот адрес сообщения,содержащего маркер подтверждения,предназначенный для ввода на той же самой веб-странице,что и адрес.</target>
        </trans-unit>
        <trans-unit id="59fc40df1759e098dcd512bdd762d89c1c4815c1" translate="yes" xml:space="preserve">
          <source>Make sure to keep your regex up-to-date if you decide to go down the path of explicit top-level domain validation.</source>
          <target state="translated">Если вы решите пойти по пути эксплицитной проверки домена верхнего уровня,не забудьте обновить свой регекс.</target>
        </trans-unit>
        <trans-unit id="aa2ea3e7fb557b8b8b13fa28afb31c3928419cfd" translate="yes" xml:space="preserve">
          <source>None of the regexes in this answer are optimized for performance. If performance is an issue, you should see if (and how) the regex of your choice can be optimized.</source>
          <target state="translated">Ни один из регрессов в этом ответе не оптимизирован для производительности.Если производительность является проблемой,вы должны увидеть,если (и как)регресс по вашему выбору может быть оптимизирована.</target>
        </trans-unit>
        <trans-unit id="2a469b7426fdfa686180a96ef3fe9463e2cbdbd8" translate="yes" xml:space="preserve">
          <source>Not to mention that non-Latin (Chinese, Arabic, Greek, Hebrew, Cyrillic and so on) domain names are to be allowed in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;near future&lt;/a&gt;. Everyone has to change the email regex used, because those characters are surely not to be covered by &lt;code&gt;[a-z]/i&lt;/code&gt; nor &lt;code&gt;\w&lt;/code&gt;. They will all fail.</source>
          <target state="translated">Не говоря уже о том, что нелатинские (китайский, арабский, греческий, иврит, кириллица и т. Д.) Доменные имена должны быть разрешены в &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;ближайшем будущем&lt;/a&gt; . Каждый должен изменить используемое регулярное выражение электронной почты, потому что эти символы наверняка не будут охвачены ни &lt;code&gt;[a-z]/i&lt;/code&gt; ни &lt;code&gt;\w&lt;/code&gt; . Они все потерпят неудачу.</target>
        </trans-unit>
        <trans-unit id="ed883c2a93aaa8eff111b58e6939a3cdb4b3d6af" translate="yes" xml:space="preserve">
          <source>Note that depending on the use case you may not want to allow for a &quot;General-address-literal&quot; in your regex. Also note that I used a negative lookahead &lt;code&gt;(?!IPv6:)&lt;/code&gt; in the final regex to prevent the &quot;General-address-literal&quot; part to match malformed IPv6 addresses. Some regex processors don't support negative lookahead. Remove the substring &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; from the regex if you want to take the whole &quot;General-address-literal&quot; part out.</source>
          <target state="translated">Обратите внимание, что в зависимости от варианта использования вы можете не использовать &amp;laquo;General-address-literal&amp;raquo; в своем регулярном выражении. Также обратите внимание, что в последнем регулярном выражении я использовал отрицательный прогноз &lt;code&gt;(?!IPv6:)&lt;/code&gt; чтобы часть &amp;laquo;General-address-literal&amp;raquo; не соответствовала искаженным адресам IPv6. Некоторые процессоры регулярных выражений не поддерживают негативную перспективу. Удалите подстроку &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; из регулярного выражения, если вы хотите взять целое &amp;laquo;Общая адресно-буквальная&amp;raquo; часть вышла.</target>
        </trans-unit>
        <trans-unit id="1603724f5f43f1edae560e9739defad7e033ecee" translate="yes" xml:space="preserve">
          <source>Note that some sources (notably &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt;) claim that RFC 5322 is too strict on the local part (i.e. the part before the @-sign). This is because &quot;..&quot;, &quot;a..b&quot; and &quot;a.&quot; are &lt;em&gt;not&lt;/em&gt; valid dot-atoms, while they may be used as mailbox names. The RFC, however, &lt;em&gt;does&lt;/em&gt; allow for local parts like these, except that they have to be quoted. So instead of &lt;code&gt;a..b@example.net&lt;/code&gt; you should write &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt;, which is semantically equivalent.</source>
          <target state="translated">Обратите внимание, что некоторые источники (в частности, &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt; ) утверждают, что RFC 5322 является слишком строгим в локальной части (то есть в части, предшествующей знаку @). Это потому что &quot;..&quot;, &quot;a..b&quot; и &quot;a.&quot; &lt;em&gt;не&lt;/em&gt; являются действительными точечными атомами, в то время как они могут использоваться как имена почтовых ящиков. RFC, однако, допускает наличие таких мест, за исключением того, что они должны быть указаны. Поэтому вместо &lt;code&gt;a..b@example.net&lt;/code&gt; вы должны написать &quot; a..b&quot;@example.net , что семантически эквивалентно.</target>
        </trans-unit>
        <trans-unit id="a414e2438f7c9cf87c83b4983b266d69534ed05a" translate="yes" xml:space="preserve">
          <source>Note: This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &amp;ldquo;@&amp;rdquo; character), too vague (after the &amp;ldquo;@&amp;rdquo; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">Примечание. Это требование является &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;преднамеренным нарушением&lt;/a&gt; &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; , который определяет синтаксис для адресов электронной почты, который является одновременно слишком строгим (до символа &amp;laquo;@&amp;raquo;), слишком расплывчатым (после символа &amp;laquo;@&amp;raquo;) и слишком слабым ( здесь можно найти практическое применение комментариев, пробельных символов и строк в кавычках способами, незнакомыми большинству пользователей.</target>
        </trans-unit>
        <trans-unit id="a60dff653e359c769e135e4c04c6e895ea0123b7" translate="yes" xml:space="preserve">
          <source>One RFC 5322 compliant regex can be found at the top of the page at &lt;a href=&quot;http://emailregex.com/&quot;&gt;http://emailregex.com/&lt;/a&gt; but uses the IP address pattern that is floating around the internet with a bug that allows &lt;code&gt;00&lt;/code&gt; for any of the unsigned byte decimal values in a dot-delimited address, which is illegal.  The rest of it appears to be consistent with the RFC 5322 grammar and passes several tests using &lt;code&gt;grep -Po&lt;/code&gt;, including cases domain names, IP addresses, bad ones, and account names with and without quotes.</source>
          <target state="translated">Одно регулярное выражение, совместимое с RFC 5322, можно найти в верхней части страницы по адресу &lt;a href=&quot;http://emailregex.com/&quot;&gt;http://emailregex.com/,&lt;/a&gt; но в нем используется шаблон IP-адреса, распространяющийся по Интернету, с ошибкой, которая допускает &lt;code&gt;00&lt;/code&gt; для любого из десятичных значений байтов без знака в адрес с разделителями точками, что недопустимо. Остальное, похоже, соответствует грамматике RFC 5322 и проходит несколько тестов с использованием &lt;code&gt;grep -Po&lt;/code&gt; , включая доменные имена, IP-адреса, неверные и учетные записи с кавычками и без них.</target>
        </trans-unit>
        <trans-unit id="6849c03183bc687fc66af67fdc8fab74faf61cad" translate="yes" xml:space="preserve">
          <source>One simple regular expression which would at least not reject any valid email address would be checking for something, followed by an @ sign and then something followed by a period and at least 2 somethings. It won't reject anything, but after reviewing the spec I can't find any email that would be valid and rejected.</source>
          <target state="translated">Одним простым регулярным выражением,которое,по крайней мере,не отвергало бы действительный электронный адрес,была бы проверка на что-то,за которой следовал бы знак @,а затем что-то с периодом и,по крайней мере,2 вещи.Оно ничего не отвергает,но после просмотра спецификации я не могу найти никакого электронного письма,которое было бы действительным и отклонено.</target>
        </trans-unit>
        <trans-unit id="eacf0af0cb780f7e0cc0c41e3539fd563e478436" translate="yes" xml:space="preserve">
          <source>Over the years I have slowly developed a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; that validates MOST email addresses correctly, assuming they don't use an IP address as the server part.</source>
          <target state="translated">На протяжении многих лет я медленно разрабатывал &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;регулярное выражение,&lt;/a&gt; которое корректно проверяет адреса электронной почты MOST, предполагая, что они не используют IP-адрес в качестве серверной части.</target>
        </trans-unit>
        <trans-unit id="4e44c1594bc79271466627aea4dc6d92f45efa87" translate="yes" xml:space="preserve">
          <source>People should be aware of the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;errata against RFC 3696&lt;/a&gt; in particular. Three of the canonical examples are in fact invalid addresses. And the maximum length of an address is 254 or 256 characters, &lt;strong&gt;not&lt;/strong&gt; 320.</source>
          <target state="translated">Люди должны знать об &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;ошибках в RFC 3696&lt;/a&gt; в частности. Три из канонических примеров на самом деле являются недействительными адресами. И максимальная длина адреса составляет 254 или 256 символов, а &lt;strong&gt;не&lt;/strong&gt; 320.</target>
        </trans-unit>
        <trans-unit id="d39c523f1fb1d41ff6e8a68ec88d7d3a31a24cd0" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;the W3C HTML5 spec&lt;/a&gt;:</source>
          <target state="translated">Согласно &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;спецификации W3C HTML5&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="56c0dad2b0956cd6ae32504c979c840f02cf3573" translate="yes" xml:space="preserve">
          <source>Quick answer</source>
          <target state="translated">Быстрый ответ</target>
        </trans-unit>
        <trans-unit id="fa2251418aa68903f6488427bde3d8e415a9f16a" translate="yes" xml:space="preserve">
          <source>RFC 5321 basically leaves alone the &quot;local&quot; part (i.e. the part before the @-sign), but is stricter on the domain part (i.e. the part after the @-sign). It allows only host names in place of dot-atoms and address literals in place of domain literals.</source>
          <target state="translated">RFC 5321 в основном оставляет &quot;локальную&quot; часть (т.е.часть перед @-знаком),но более строгую в доменной части (т.е.часть после @-знака).Она допускает только имена хостов вместо точечных атомов и адресных литералов вместо доменных литералов.</target>
        </trans-unit>
        <trans-unit id="82af36243c542be2f1bd3a5fa7459b1dbce36d81" translate="yes" xml:space="preserve">
          <source>RFC 5321 standard:</source>
          <target state="translated">Стандарт RFC 5321:</target>
        </trans-unit>
        <trans-unit id="17c58504badf8c1787c4ac4f95c466fc696f2e50" translate="yes" xml:space="preserve">
          <source>RFC 5322</source>
          <target state="translated">RFC 5322</target>
        </trans-unit>
        <trans-unit id="479d36b78205a178de44b9bbbe339cec9f59000b" translate="yes" xml:space="preserve">
          <source>RFC 5322 standard:</source>
          <target state="translated">Стандарт RFC 5322:</target>
        </trans-unit>
        <trans-unit id="00af815762ae4e4ed879f00aa53f3fc9fc817b37" translate="yes" xml:space="preserve">
          <source>RFC 822</source>
          <target state="translated">RFC 822</target>
        </trans-unit>
        <trans-unit id="fd412bb5a3c2ad14d277d7a4b79b8f75df43ce9c" translate="yes" xml:space="preserve">
          <source>Regular expression built using Jeffrey Friedl's example in
  &lt;em&gt;Mastering Regular Expressions&lt;/em&gt; (&lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt;).</source>
          <target state="translated">Регулярное выражение построено с использованием примера Джеффри Фридла в статье &amp;laquo; &lt;em&gt;Освоение регулярных выражений&amp;raquo;&lt;/em&gt; ( &lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4fa9d019350b110a4ff197daf305ce272d79f6ae" translate="yes" xml:space="preserve">
          <source>SMTP (as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321&lt;/a&gt;) further restricts the set of valid email addresses (or actually: mailbox names). It seems reasonable to impose this stricter grammar, so that the matched email address can actually be used to send an email.</source>
          <target state="translated">SMTP (как определено в &lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321&lt;/a&gt; ) дополнительно ограничивает набор действительных адресов электронной почты (или фактически: имена почтовых ящиков). Представляется разумным навязать эту более строгую грамматику, чтобы сопоставленный адрес электронной почты мог фактически использоваться для отправки электронного письма.</target>
        </trans-unit>
        <trans-unit id="2e509ea11bcd91c64419ceb313b8fded4cfb62a1" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;Validating Email Addresses&lt;/a&gt;, including the comments. Or &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;.</source>
          <target state="translated">См. Также &lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;Проверка адресов электронной почты&lt;/a&gt; , включая комментарии. Или &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Сравнение адреса электронной почты, проверяющего регулярные выражения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53a9c322bf8ce66569059aa3e1529b8bee955c35" translate="yes" xml:space="preserve">
          <source>Seriously. You should use an already written library for validating emails. The best way is probably to just send a verification e-mail to that address.</source>
          <target state="translated">Серьёзно.Вы должны использовать уже написанную библиотеку для проверки электронной почты.Лучший способ,вероятно,просто отправить письмо с проверкой на этот адрес.</target>
        </trans-unit>
        <trans-unit id="a143d6225e75c2b766a2aee66d8dfbc3d273186e" translate="yes" xml:space="preserve">
          <source>Simple as that. Why on earth would you care about the characters used in the name and domain? It's the client's responsibility to enter a valid email address, not the server's. Even when the client enters a &lt;em&gt;syntactically&lt;/em&gt; valid email address like &lt;code&gt;aa@bb.cc&lt;/code&gt;, this does not guarantee that it's a legit email address. No one regex can cover that.</source>
          <target state="translated">Просто как тот. С какой стати вы заботитесь о символах, используемых в имени и домене? Ответственность за ввод действительного адреса электронной почты лежит на клиенте, а не на сервере. Даже если клиент вводит &lt;em&gt;синтаксически&lt;/em&gt; действительный адрес электронной почты, например &lt;code&gt;aa@bb.cc&lt;/code&gt; , это не гарантирует, что это допустимый адрес электронной почты. Никто из регулярных выражений не может это охватить.</target>
        </trans-unit>
        <trans-unit id="056115c235bea2846acb135ffdbd27cd4ae8abc4" translate="yes" xml:space="preserve">
          <source>Strange that you &quot;cannot&quot; allow 4 characters TLDs.  You are banning people from &lt;em&gt;.info&lt;/em&gt; and &lt;em&gt;.name&lt;/em&gt;, and the length limitation stop &lt;em&gt;.travel&lt;/em&gt; and &lt;em&gt;.museum&lt;/em&gt;, but yes, they are less common than 2 characters TLDs and 3 characters TLDs.</source>
          <target state="translated">Странно, что вы &amp;laquo;не можете&amp;raquo; разрешить 4-х символьные TLD. Вы запрещаете пользователям &lt;em&gt;доступ к&lt;/em&gt; &lt;em&gt;файлам&lt;/em&gt; &lt;em&gt;.info&lt;/em&gt; и &lt;em&gt;.name&lt;/em&gt; , и ограничение длины останавливается &lt;em&gt;.travel&lt;/em&gt; и &lt;em&gt;.museum&lt;/em&gt; , но да, они встречаются реже, чем 2-символьные TLD и 3-символьные TLD.</target>
        </trans-unit>
        <trans-unit id="6cbd3caa8bdfcbb5ef664dabf829fa863056ac8a" translate="yes" xml:space="preserve">
          <source>Sure, it will match things that aren't valid email addresses, but it's a matter of playing the 90/10 rule.</source>
          <target state="translated">Конечно,он будет соответствовать вещам,которые не являются действительными адресами электронной почты,но это вопрос проигрывания правила 9010.</target>
        </trans-unit>
        <trans-unit id="af4c67c3df524d5adb915aacca975c4f92acf0be" translate="yes" xml:space="preserve">
          <source>That is no better than all the other non-RFC patterns. It isn&amp;rsquo;t even smart enough to handle even &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt;, let alone RFC 5322. &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;This one&lt;/a&gt;, however, is.</source>
          <target state="translated">Это не лучше, чем все другие не RFC шаблоны. Он даже не настолько умен, чтобы справиться даже с &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt; , не говоря уже о RFC 5322. &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;Этот&lt;/a&gt; , однако, есть.</target>
        </trans-unit>
        <trans-unit id="8a8b13790b55067f7d02a02213bba322543be649" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;fully RFC 822 compliant regex&lt;/a&gt; is inefficient and obscure because of its length.  Fortunately, RFC 822 was superseded twice and the current specification for email addresses is &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt;.  RFC 5322 leads to a regex that can be understood if studied for a few minutes and is efficient enough for actual use.</source>
          <target state="translated">&lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;Регулярное выражение, полностью соответствующее RFC 822&lt;/a&gt; , неэффективно и неясно из-за его длины. К счастью, RFC 822 был заменен дважды, и текущая спецификация адресов электронной почты - &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt; . RFC 5322 приводит к регулярному выражению, которое можно понять, если изучить его в течение нескольких минут, и достаточно эффективно для реального использования.</target>
        </trans-unit>
        <trans-unit id="efef7583ce1f5955d8622631b97ef21d277e0c78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 spec suggests&lt;/a&gt; a simple regex for validating email addresses:</source>
          <target state="translated">Спецификация &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 предлагает&lt;/a&gt; простое регулярное выражение для проверки адресов электронной почты:</target>
        </trans-unit>
        <trans-unit id="cc7666184f88738787a730cc2f788c93befa5c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MailAddress&lt;/code&gt; class uses a BNF parser to validate the address in full accordance with RFC822.</source>
          <target state="translated">Класс &lt;code&gt;MailAddress&lt;/code&gt; использует анализатор BNF для проверки адреса в полном соответствии с RFC822.</target>
        </trans-unit>
        <trans-unit id="08094c7e000914320983bbc93438575ec83bb464" translate="yes" xml:space="preserve">
          <source>The RFCs define syntaxes for email messages, not for email addresses as such. Addresses may appear in various header fields and this is where they are primarily defined. When they appear in header fields addresses may contain (between lexical tokens) whitespace, comments and even linebreaks. Semantically this has no significance however. By removing this whitespace, etc. from an address you get a semantically equivalent &lt;em&gt;canonical representation&lt;/em&gt;. Thus, the canonical representation of &lt;code&gt;first. last (comment) @   [3.5.7.9]&lt;/code&gt; is &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt;.</source>
          <target state="translated">RFC определяют синтаксис для сообщений электронной почты, а не для адресов электронной почты как таковых. Адреса могут появляться в различных полях заголовка, и именно здесь они в основном определены. Когда они появляются в полях заголовка, адреса могут содержать (между лексическими токенами) пробелы, комментарии и даже разрывы строк. Семантически это не имеет значения, однако. Удаляя этот пробел и т. Д. Из адреса, вы получаете семантически эквивалентное &lt;em&gt;каноническое представление&lt;/em&gt; . Таким образом, каноническое представление &lt;code&gt;first. last (comment) @ [3.5.7.9]&lt;/code&gt; last (комментарий) @ [3.5.7.9] is &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03bb5d368df58fc938931912f1a46085762490a6" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. For rules that include semantically irrelevant (folding) whitespace, I give a separate regex marked &quot;(normalized)&quot; that doesn't accept this whitespace.</source>
          <target state="translated">Вывод показывает,как я пришел к этому выражению.Я перечисляю все соответствующие грамматические правила из КСФ в точности так,как они выглядят,с последующим соответствующим регексом.Для правил,которые включают в себя семантически не относящиеся (складывающиеся)пробельные символы,я даю отдельный регекс с пометкой &quot;(нормализованные)&quot;,который не принимает этот пробельный символ.</target>
        </trans-unit>
        <trans-unit id="b143a24ff4d5dac8a1b58259e6ef61a5327993b2" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. Where an erratum has been published I give a separate expression for the corrected grammar rule (marked &quot;erratum&quot;) and use the updated version as a subexpression in subsequent regular expressions.</source>
          <target state="translated">Вывод показывает,как я пришел к этому выражению.Я перечисляю все соответствующие грамматические правила из КСФ в точности так,как они выглядят,с последующим соответствующим регексом.В случае публикации ошибки даю отдельное выражение для исправленного правила грамматики (помеченное &quot;erratum&quot;)и использую обновленную версию как подвыражение в последующих регулярных выражениях.</target>
        </trans-unit>
        <trans-unit id="c988189fcad54702295e206fc75fe6d5f6101f50" translate="yes" xml:space="preserve">
          <source>The email addresses I want to validate are going to be used by an ASP.NET web application using the System.Net.Mail namespace to send emails to a list of people. So, rather than using some very complex regular expression, I just try to create a MailAddress instance from the address. The MailAddress construtor will throw an exception if the address is not formed properly. This way, I know I can at least get the email out of the door. Of course this is server-side validation but at a minimum you need that anyway.</source>
          <target state="translated">Адреса электронной почты,которые я хочу проверить,будут использоваться веб-приложением ASP.NET,использующим пространство имен System.Net.Mail для отправки писем в список людей.Поэтому,вместо того,чтобы использовать очень сложные регулярные выражения,я просто пытаюсь создать экземпляр MailAddress из этого адреса.Конструктор MailAddress бросит исключение,если адрес сформирован неправильно.Таким образом,я знаю,что могу,по крайней мере,вытащить письмо из двери.Конечно,это проверка на стороне сервера,но,как минимум,это все равно нужно.</target>
        </trans-unit>
        <trans-unit id="2c42e1dbf8f30a22743d35f41dec49ad83dcbd78" translate="yes" xml:space="preserve">
          <source>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</source>
          <target state="translated">Следующее JavaScript-и Perl-совместимое регулярное выражение является реализацией приведенного выше определения.</target>
        </trans-unit>
        <trans-unit id="04b741d2a83f024156fc1aafe328ecd03eac2d01" translate="yes" xml:space="preserve">
          <source>The grammar presented in RFC 5321 is too lenient when it comes to both host names and IP addresses. I took the liberty of &quot;correcting&quot; the rules in question, using &lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;this draft&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034&lt;/a&gt; as guidelines. Here's the resulting regex.</source>
          <target state="translated">Грамматика, представленная в RFC 5321, слишком мягкая, когда речь идет об именах хостов и IP-адресах. Я позволил себе &amp;laquo;исправить&amp;raquo; эти правила, используя &lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;этот проект&lt;/a&gt; и &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034 в&lt;/a&gt; качестве руководства. Вот результирующее регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="78bea17cadfee2e52d3b0ba653aeb8078d41c522" translate="yes" xml:space="preserve">
          <source>The more sophisticated patterns in Perl and PCRE (regex library used e.g. in PHP) can &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;correctly parse RFC 5322 without a hitch&lt;/a&gt;. Python and C# can do that too, but they use a different syntax from those first two. However, if you are forced to use one of the many less powerful pattern-matching languages, then it&amp;rsquo;s best to use a real parser.</source>
          <target state="translated">Более сложные шаблоны в Perl и PCRE (библиотека регулярных выражений, используемая, например, в PHP) могут &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;безошибочно анализировать RFC 5322&lt;/a&gt; . Python и C # тоже могут это делать, но они используют синтаксис, отличный от тех первых двух. Однако, если вы вынуждены использовать один из многих менее мощных языков сопоставления с образцом, то лучше использовать настоящий парсер.</target>
        </trans-unit>
        <trans-unit id="f44b7e654912775bb48deb334cbbfbb5d94ad3b7" translate="yes" xml:space="preserve">
          <source>The second constraint is a restriction on RFC 5321/5322.</source>
          <target state="translated">Вторым ограничением является ограничение RFC 53215322.</target>
        </trans-unit>
        <trans-unit id="ddc5dad053b60eb7739c3fbde8711a0b846a2faf" translate="yes" xml:space="preserve">
          <source>The specified e-mail address 'myemail@address,com' is invalid. Did you mean 'myemail@address.com'?</source>
          <target state="translated">Указанный адрес электронной почты 'myemail@address,com' недействителен.Вы имели в виду 'myemail@address.com'?</target>
        </trans-unit>
        <trans-unit id="ba008b9092dbf02ae78dce33e0ba3f4f3680e270" translate="yes" xml:space="preserve">
          <source>The syntax of email addresses has been defined in various &lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFCs&lt;/a&gt;, most notably &lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;. RFC 822 should be seen as the &quot;original&quot; standard and RFC 5322 as the latest standard. The syntax defined in RFC 822 is the most lenient and subsequent standards have restricted the syntax further and further, where newer systems or services should recognize obsolete syntax, but never produce it.</source>
          <target state="translated">Синтаксис адресов электронной почты был определен в различных &lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFC&lt;/a&gt; , особенно в &lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; и &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; . RFC 822 следует рассматривать как &amp;laquo;оригинальный&amp;raquo; стандарт, а RFC 5322 - как последний стандарт. Синтаксис, определенный в RFC 822, является наиболее мягким, и последующие стандарты ограничивают синтаксис все дальше и дальше, когда более новые системы или службы должны распознавать устаревший синтаксис, но никогда не создавать его.</target>
        </trans-unit>
        <trans-unit id="694230a2ce267bc8d03a82385bbedc868ccb9017" translate="yes" xml:space="preserve">
          <source>The total length could also be limited to 254 characters, per &lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;RFC 3696  errata 1690&lt;/a&gt;.</source>
          <target state="translated">Общая длина также может быть ограничена 254 символами, согласно &lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;RFC 3696 опечаток 1690&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c409e37bc8b674795dc6985a2965f07b4a91bec" translate="yes" xml:space="preserve">
          <source>There are plenty examples of this out on the net (and I think even one that fully validates the RFC - but it's tens/hundreds of lines long if memory serves). People tend to get carried away validating this sort of thing. Why not just check it has an @ and at least one . and meets some simple minimum length. It's trivial to enter a fake email and still match any valid regex anyway. I would guess that false positives are better than false negatives.</source>
          <target state="translated">Примеров этого в сети много (и я думаю,что даже тот,который полностью проверяет RFC-но это десятки сотен строк длиной,если память служит).Люди склонны увлекаться проверкой таких вещей.Почему бы просто не проверить,что она имеет @ и хотя бы одну.и соответствует некоторой простой минимальной длине.Тривиально ввести фальшивое письмо и все равно совпадает с любым действительным регексом.Я бы догадался,что ложные срабатывания лучше,чем ложные негативы.</target>
        </trans-unit>
        <trans-unit id="e65ce1fdf25d40bc41ca80ae15e74e6206ea4278" translate="yes" xml:space="preserve">
          <source>There is not one which is really usable.</source>
          <target state="translated">Нет такого,который был бы действительно полезен.</target>
        </trans-unit>
        <trans-unit id="fb8823d7f714e02a82ffff0eff38f0b5686cb83b" translate="yes" xml:space="preserve">
          <source>There is some danger that common usage and widespread sloppy coding will establish a de facto standard for e-mail addresses that is more restrictive than the recorded formal standard.</source>
          <target state="translated">Существует некоторая опасность того,что обычное использование и широко распространенное неаккуратное кодирование установят де-факто стандарт для адресов электронной почты,который является более ограничительным,чем записанный формальный стандарт.</target>
        </trans-unit>
        <trans-unit id="eab562daff5b311a461fd5743bafead8320f8ac4" translate="yes" xml:space="preserve">
          <source>There's one problem with translating the RFC syntaxes into regexes: the syntaxes are not regular! This is because they allow for optional comments in email addresses that can be infinitely nested, while infinite nesting can't be described by a regular expression. To scan for or validate addresses containing comments you need a parser or more powerful expressions. (Note that languages like Perl have constructs to describe context free grammars in a regex-like way.) In this answer I'll disregard comments and only consider proper regular expressions.</source>
          <target state="translated">Есть одна проблема с переводом синтаксиса RFC в регексы:синтаксис не регулярный! Это связано с тем,что они допускают необязательные комментарии в адресах электронной почты,которые могут быть бесконечно вложены,в то время как бесконечное вложение не может быть описано регулярным выражением.Для проверки или подтверждения адресов,содержащих комментарии,необходим синтаксический анализатор или более мощные выражения.(Обратите внимание,что в таких языках,как Perl,есть конструкции для описания контекстно-свободных грамматических выражений в регексоподобном виде).В этом ответе я пропущу комментарии и буду рассматривать только правильные регулярные выражения.</target>
        </trans-unit>
        <trans-unit id="604bc09674b2ed7a86a57667d281ad5d75b92f79" translate="yes" xml:space="preserve">
          <source>These two considerations could be addressed by parsing the address. The extra length constraint on host names could in some cases also be addressed by using an extra regex that checks it, and matching the address against both expressions.</source>
          <target state="translated">Эти два соображения могут быть решены путем разбора адреса.Ограничение на дополнительную длину для имен хостов может в некоторых случаях быть также устранено путем использования дополнительного регекса,который проверяет его,и сопоставления адреса с обоими выражениями.</target>
        </trans-unit>
        <trans-unit id="6a6068ef4c671cc993159bd9f7876a710e880eee" translate="yes" xml:space="preserve">
          <source>This intentionally doesn't comply with &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;.</source>
          <target state="translated">Это намеренно не соответствует &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e3c059245745fe56b963a2dd674dc3a620e4611" translate="yes" xml:space="preserve">
          <source>This is a job for a parser, but even if an address is syntactically valid, it still may not be deliverable. Sometimes you have to resort to the hillbilly method of &quot;Hey, y'all, watch ee-us!&quot;</source>
          <target state="translated">Это задание для парсера,но даже если адрес синтаксически корректен,он все равно может быть не доставлен.Иногда приходится прибегать к деревенскому методу &quot;Эй,вы все,смотрите ee-us!&quot;.</target>
        </trans-unit>
        <trans-unit id="40bd4785946bbfd84d54b271e863481fe650854b" translate="yes" xml:space="preserve">
          <source>This question is asked a lot, but I think you should step back and ask yourself &lt;em&gt;why&lt;/em&gt; you want to validate email adresses syntactically? What is the benefit really?</source>
          <target state="translated">Этот вопрос задают много, но я думаю, что вы должны отступить и спросить себя, &lt;em&gt;почему&lt;/em&gt; вы хотите проверять адреса электронной почты синтаксически? Какая выгода на самом деле?</target>
        </trans-unit>
        <trans-unit id="5b58c52e10b145304d80e39ff92b63c4aaad7cba" translate="yes" xml:space="preserve">
          <source>This regex is from Perl's &lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email::Valid&lt;/a&gt; library. I believe it to be the most accurate, it matches all 822. And, it is based on the regular expression in the O'Reilly book:</source>
          <target state="translated">Это регулярное выражение из библиотеки Perl's &lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email :: Valid&lt;/a&gt; . Я считаю, что он самый точный, он соответствует всем 822. И он основан на регулярном выражении в книге О'Рейли:</target>
        </trans-unit>
        <trans-unit id="ab37a40832b8b946cb58d45531219e00bca7eb3a" translate="yes" xml:space="preserve">
          <source>This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module).</source>
          <target state="translated">Это регулярное выражение будет проверять только те адреса,в которых комментарии были удалены и заменены пробелами (это делается модулем).</target>
        </trans-unit>
        <trans-unit id="881eea75af81659120231f1a02a723701d920b5f" translate="yes" xml:space="preserve">
          <source>Use the following regex for input validation:</source>
          <target state="translated">Для проверки ввода используйте следующий регекс:</target>
        </trans-unit>
        <trans-unit id="a38e078061a3af58841a4b63d102b4842c3180b3" translate="yes" xml:space="preserve">
          <source>User input validation</source>
          <target state="translated">Проверка пользовательского ввода</target>
        </trans-unit>
        <trans-unit id="417d6b6f39c552dae06a913e7670f440710547a0" translate="yes" xml:space="preserve">
          <source>Using a regular expression that recognizes email addresses could be useful in various situations: for example to scan for email addresses in a document, to validate user input, or as an integrity constraint on a data repository.</source>
          <target state="translated">Использование регулярного выражения,которое распознает адреса электронной почты,может быть полезно в различных ситуациях:например,для сканирования на наличие адресов электронной почты в документе,для проверки ввода данных пользователем или в качестве ограничения целостности хранилища данных.</target>
        </trans-unit>
        <trans-unit id="7404787d1040c9c25b80ed394962a1fd680b081b" translate="yes" xml:space="preserve">
          <source>When only accepting host names in the domain part (after the @-sign), the regexes above accept only labels with at most 63 characters, as they should. However, they don't enforce the fact that the entire host name must be at most 253 characters long (including the dots). Although this constraint is strictly speaking still regular, it's not feasible to make a regex that incorporates this rule.</source>
          <target state="translated">При приеме только имен хостов в части домена (после @-признака)вышеприведенные регезисы принимают только метки,содержащие не более 63 символов,как и должно быть.Однако они не обеспечивают соблюдение того факта,что все имя хоста должно состоять не более чем из 253 символов (включая точки).Хотя это ограничение,строго говоря,все еще является регулярным,невозможно сделать регекс,который бы включал это правило.</target>
        </trans-unit>
        <trans-unit id="6adb4fb8492c6fd0b85a550dd4f05a8dfdfca38d" translate="yes" xml:space="preserve">
          <source>Which is the one used in ASP.NET by the RegularExpressionValidator.</source>
          <target state="translated">Который используется в ASP.NET регулярным экспрессионным валидатором.</target>
        </trans-unit>
        <trans-unit id="39672ee698f325ca5854a5b725c41110c115c08f" translate="yes" xml:space="preserve">
          <source>While deciding which characters are allowed, please remember your apostrophed and hyphenated friends. I have no control over the fact that my company generates my email address using my name from the HR system. That includes the apostrophe in my last name. I can't tell you how many times I have been blocked from interacting with a website by the fact that my email address is &quot;invalid&quot;.</source>
          <target state="translated">При решении вопроса о том,какие персонажи разрешены,пожалуйста,помните о своих апострофных и дефисных друзьях.Я не могу контролировать тот факт,что моя компания генерирует мой электронный адрес,используя мое имя из системы HR.Это включает апостроф в мою фамилию.Я не могу сказать Вам,сколько раз я был заблокирован от взаимодействия с веб-сайтом тем фактом,что мой электронный адрес &quot;недействителен&quot;.</target>
        </trans-unit>
        <trans-unit id="040788551c90816319df84a15c3045438d8955bd" translate="yes" xml:space="preserve">
          <source>You could use the one employed by the jQuery Validation plugin:</source>
          <target state="translated">Вы можете использовать тот,который используется плагином jQuery Validation:</target>
        </trans-unit>
        <trans-unit id="c0376b0b9474c79623a7bcdd162cc203cdab2051" translate="yes" xml:space="preserve">
          <source>You should allow uppercase alphabets too.  Email systems will normalize the local part and domain part.</source>
          <target state="translated">Вы должны разрешить и заглавные алфавиты.Почтовые системы нормализуют локальную часть и доменную часть.</target>
        </trans-unit>
        <trans-unit id="50ecc3e11978eaebf7cdde3eb4723774140d8446" translate="yes" xml:space="preserve">
          <source>You should not use regular expressions to validate email addresses.</source>
          <target state="translated">Не следует использовать регулярные выражения для подтверждения адресов электронной почты.</target>
        </trans-unit>
        <trans-unit id="379c3a7e829422a79610cb5cbd113ec1b0e6fea0" translate="yes" xml:space="preserve">
          <source>[UPDATED] I've collated everything I know about email address validation here: &lt;a href=&quot;http://isemail.info&quot;&gt;http://isemail.info&lt;/a&gt;, which now not only validates but also diagnoses problems with email addresses. I agree with many of the comments here that validation is only part of the answer; see my essay at &lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/about&lt;/a&gt;.</source>
          <target state="translated">[ОБНОВЛЕНО] Я собрал все, что я знаю о проверке адреса электронной почты, здесь: &lt;a href=&quot;http://isemail.info&quot;&gt;http://isemail.info&lt;/a&gt; , который теперь не только проверяет, но и диагностирует проблемы с адресами электронной почты. Я согласен со многими комментариями здесь, что проверка является лишь частью ответа; см. мое эссе на &lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/about&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="782f584cb9f10bfd4e2d20721f3769a1a46ed1e5" translate="yes" xml:space="preserve">
          <source>email =~ &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt;</source>
          <target state="translated">электронная почта = ~ &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb288e30ab07ffc44b2ae8e5468078c1c3d3cd58" translate="yes" xml:space="preserve">
          <source>have a domain part (i.e. the part after the @-sign) that is a host name with at least two labels, each of which is at most 63 characters long.</source>
          <target state="translated">имеют часть домена (т.е.часть после @-знака),которая представляет собой имя хоста с как минимум двумя метками,каждая из которых имеет длину не более 63 символов.</target>
        </trans-unit>
        <trans-unit id="580c167d115747dac91f0ce065f1f0cea9534d8c" translate="yes" xml:space="preserve">
          <source>have a local part (i.e. the part before the @-sign) that is strictly compliant with RFC 5321/5322,</source>
          <target state="translated">имеют локальную часть (т.е.часть перед @-знаком),которая строго соответствует RFC 53215322,</target>
        </trans-unit>
        <trans-unit id="d59803fdebe968a3fc4b59dba8d7638e6988094e" translate="yes" xml:space="preserve">
          <source>if you want to use it in Java its really very easy</source>
          <target state="translated">если вы хотите использовать его на Java,то это очень просто.</target>
        </trans-unit>
        <trans-unit id="92fd5a496d47e663c9af65c455e24766e7ce98ef" translate="yes" xml:space="preserve">
          <source>is_email() remains, as far as I know, the only validator that will tell you definitively whether a given string is a valid email address or not. I've upload a new version at &lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/&lt;/a&gt;</source>
          <target state="translated">Насколько я знаю, is_email () остается единственным валидатором, который определенно скажет вам, является ли данная строка действительным адресом электронной почты или нет. Я загрузил новую версию на &lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
