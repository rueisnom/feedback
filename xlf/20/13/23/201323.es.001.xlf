<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/201323">
    <body>
      <group id="201323">
        <trans-unit id="b1b5a828768c114744b0e8c042dc66da113334ec" translate="yes" xml:space="preserve">
          <source>&quot;User Display Name user3@company.com&quot;</source>
          <target state="translated">&quot;Nombre de usuario user3@company.com&quot;</target>
        </trans-unit>
        <trans-unit id="26c2451374584a209014621e5558743bfa2ce56d" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com;user2@gmail.com&quot;</target>
        </trans-unit>
        <trans-unit id="28633028efd2c24861ac4a1740c2217f423b8453" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com; user3@company.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com;user2@gmail.com;user3@company.com&quot;</target>
        </trans-unit>
        <trans-unit id="0bc92ef1ed9e5d917df368b9389fccbdd11bbe8d" translate="yes" xml:space="preserve">
          <source>&quot;user4 @company.com&quot;</source>
          <target state="translated">&quot;user4 @company.com&quot;</target>
        </trans-unit>
        <trans-unit id="32f8045af87affeff6f4333e80528d9f758f0dff" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt;)
If you're looking for something simpler but that will catch most valid email addresses try something like:</source>
          <target state="translated">( &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt; ) Si est&amp;aacute; buscando algo m&amp;aacute;s simple pero que atrapar&amp;aacute; las direcciones de correo electr&amp;oacute;nico m&amp;aacute;s v&amp;aacute;lidas, intente algo como:</target>
        </trans-unit>
        <trans-unit id="75f14c0b3eb6f2ddf1a7b788a9c63a1261d191e6" translate="yes" xml:space="preserve">
          <source>(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</source>
          <target state="translated">(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</target>
        </trans-unit>
        <trans-unit id="41c1c65773194544312b0d413e9568defa0fa5f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Cal Henderson&lt;/a&gt; (Flickr) wrote an article called &lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;Parsing Email Adresses in PHP&lt;/a&gt; and shows how to do proper RFC (2)822-compliant Email Address parsing.  You can also get the source code in &lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt;, python and ruby which is &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;cc licensed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Cal Henderson&lt;/a&gt; (Flickr) escribi&amp;oacute; un art&amp;iacute;culo llamado &lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;Analizar direcciones de correo electr&amp;oacute;nico en PHP&lt;/a&gt; y muestra c&amp;oacute;mo hacer un an&amp;aacute;lisis de direcciones de correo electr&amp;oacute;nico que cumpla con RFC (2) 822. Tambi&amp;eacute;n puede obtener el c&amp;oacute;digo fuente en &lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt; , python y ruby ​​con &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;licencia cc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4215c60a61270d50ef11c83e3925ba93699fa35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt;&lt;em&gt;etc...&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt; &lt;em&gt;etc ...&lt;/em&gt; &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3654c41e6ade2da259eef5a7ae400fac5827b8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the best regular expression you have or have seen for validating emails?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest;Cu&amp;aacute;l es la mejor expresi&amp;oacute;n regular que tiene o ha visto para validar correos electr&amp;oacute;nicos?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83da26750665b7eec085cd165f43ccd6b0fe79c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &lt;code&gt;@&lt;/code&gt; character), too vague (after the &lt;code&gt;@&lt;/code&gt; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Este requisito es una &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;violaci&amp;oacute;n intencional&lt;/a&gt; de &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; , que define una sintaxis para las direcciones de correo electr&amp;oacute;nico que es simult&amp;aacute;neamente demasiado estricta (antes del car&amp;aacute;cter &lt;code&gt;@&lt;/code&gt; ), demasiado vaga (despu&amp;eacute;s del car&amp;aacute;cter &lt;code&gt;@&lt;/code&gt; ) y demasiado laxa (permitiendo comentarios, espacios en blanco caracteres, y cadenas citadas de maneras desconocidas para la mayor&amp;iacute;a de los usuarios) para que sean de uso pr&amp;aacute;ctico aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="467b846662a13d15de5bbd34d57ea291cf420f2e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;valid e-mail address&lt;/strong&gt; is a string that matches the ABNF production [&amp;hellip;].</source>
          <target state="translated">Una &lt;strong&gt;direcci&amp;oacute;n de correo electr&amp;oacute;nico v&amp;aacute;lida&lt;/strong&gt; es una cadena que coincide con la producci&amp;oacute;n ABNF [...].</target>
        </trans-unit>
        <trans-unit id="aef7d848543c3d5b49c4b583603a1e7b9279f10b" translate="yes" xml:space="preserve">
          <source>A common use case is user input validation, for example on an html form. In that case it's usually reasonable to preclude address-literals and to require at least two labels in the hostname. Taking the improved RFC 5321 regex from the previous section as a basis, the resulting expression would be:</source>
          <target state="translated">Un caso de uso común es la validación de entradas de usuarios,por ejemplo en un formulario html.En ese caso suele ser razonable excluir las letras de las direcciones y exigir al menos dos etiquetas en el nombre del host.Tomando como base el RFC 5321 regex mejorado de la sección anterior,la expresión resultante sería:</target>
        </trans-unit>
        <trans-unit id="7f254b288b513a222b7ce9705affbccd53cd80d8" translate="yes" xml:space="preserve">
          <source>According to official standard &lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt; valid email regex is</source>
          <target state="translated">De acuerdo con el est&amp;aacute;ndar oficial &lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822, la&lt;/a&gt; expresi&amp;oacute;n regular de correo electr&amp;oacute;nico v&amp;aacute;lida es</target>
        </trans-unit>
        <trans-unit id="6d2f2f9c03ab4cdaf2b9f2364a0c2799a6329154" translate="yes" xml:space="preserve">
          <source>Addresses matched by this regex:</source>
          <target state="translated">Direcciones que coinciden con esta regex:</target>
        </trans-unit>
        <trans-unit id="b75e467be1d8b94588b3cc3f5aaec8acae067ee7" translate="yes" xml:space="preserve">
          <source>After all, the &lt;strong&gt;best&lt;/strong&gt; way to validate the email address is still to actually &lt;em&gt;send&lt;/em&gt; an email to the address in question to validate the address. If the email address is part of user authentication (register/login/etc), then you can perfectly combine it with the user activation system. I.e. send an email with a link with an unique activation key to the specified email address and only allow login when the user has activated the newly created account using the link in the email.</source>
          <target state="translated">Despu&amp;eacute;s de todo, la &lt;strong&gt;mejor&lt;/strong&gt; manera de validar la direcci&amp;oacute;n de correo electr&amp;oacute;nico es &lt;em&gt;enviar&lt;/em&gt; un correo electr&amp;oacute;nico a la direcci&amp;oacute;n en cuesti&amp;oacute;n para validar la direcci&amp;oacute;n. Si la direcci&amp;oacute;n de correo electr&amp;oacute;nico es parte de la autenticaci&amp;oacute;n del usuario (registro / inicio de sesi&amp;oacute;n / etc.), puede combinarla perfectamente con el sistema de activaci&amp;oacute;n del usuario. Es decir, enviar un correo electr&amp;oacute;nico con un enlace con una clave de activaci&amp;oacute;n &amp;uacute;nica a la direcci&amp;oacute;n de correo electr&amp;oacute;nico especificada y solo permitir el inicio de sesi&amp;oacute;n cuando el usuario haya activado la cuenta reci&amp;eacute;n creada usando el enlace en el correo electr&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="4747783011ffa130857e2027d5ff2eef5ab7e5ce" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part and domain name domain (requiring at least two domain name labels with the TLD limited to 2-6 alphabetic characters).</source>
          <target state="translated">Permite la parte local punto-átomo y el dominio de nombre de dominio (requiere al menos dos etiquetas de nombre de dominio con el TLD limitado a 2-6 caracteres alfabéticos).</target>
        </trans-unit>
        <trans-unit id="98f5ff42c06d45b9d6040c487efd8ddaae34384a" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, domain name domain, and (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain.</source>
          <target state="translated">Permite el dominio literal del nombre de dominio (IPv4,IPv6 y dirección IPv4-mapped IPv6).</target>
        </trans-unit>
        <trans-unit id="1a501b9511aa2902571ab4411c2d68715c865f16" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, obsolete (mixed dot-atom and quoted-string) local-part, domain name domain, (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain, and (nested) CFWS.</source>
          <target state="translated">Permite la parte local de punto-átomo,la parte local de cadena cotizada,la parte local obsoleta (mezcla de punto-átomo y cadena cotizada),el dominio de nombre de dominio,el dominio literal de dominio (IPv4,IPv6,y la dirección IPv4-mapeada IPv6),y el CFWS (anidado).</target>
        </trans-unit>
        <trans-unit id="137a6c9662b514d8385afe47af02dd62a6fdb560" translate="yes" xml:space="preserve">
          <source>Another consideration, especially when using the regexes for input validation, is feedback to the user. If a user enters an incorrect address, it would be nice to give a little more feedback than a simple &quot;syntactically incorrect address&quot;. With &quot;vanilla&quot; regexes this is not possible.</source>
          <target state="translated">Otra consideración,especialmente cuando se utilizan las regex para la validación de entradas,es la retroalimentación al usuario.Si un usuario introduce una dirección incorrecta,sería bueno dar un poco más de retroalimentación que una simple &quot;dirección sintácticamente incorrecta&quot;.Con las regexes &quot;vainilla&quot; esto no es posible.</target>
        </trans-unit>
        <trans-unit id="7cf149b9d25d2489f954894be6028e467951029a" translate="yes" xml:space="preserve">
          <source>As stated in paragraph 3.1.4. of RFC 822 optional linear white space may be inserted between lexical tokens. Where applicable I've expanded the expressions to accommodate this rule and marked the result with &quot;opt-lwsp&quot;.</source>
          <target state="translated">Como se indica en el párrafo 3.1.4.de la RFC 822,puede insertarse un espacio blanco lineal opcional entre las fichas léxicas.Donde sea aplicable,he ampliado las expresiones para acomodar esta regla y he marcado el resultado con &quot;opt-lwsp&quot;.</target>
        </trans-unit>
        <trans-unit id="023052f99d8ae0931ecbe27dc9dbfef6103d1f37" translate="yes" xml:space="preserve">
          <source>As you're writing in PHP I'd advice you to use the PHP build-in validation for emails.</source>
          <target state="translated">Como estás escribiendo en PHP,te aconsejo que utilices la validación de la construcción de PHP para los correos electrónicos.</target>
        </trans-unit>
        <trans-unit id="47bf4436a0ce6299cec6effd82a884e698974efd" translate="yes" xml:space="preserve">
          <source>Basic:</source>
          <target state="translated">Basic:</target>
        </trans-unit>
        <trans-unit id="0073f212804bc3306f849cfa8b512d52e55a727a" translate="yes" xml:space="preserve">
          <source>Confirmation tokens are the only way to know you got the address of the person entering it. This is why most mailing lists now use that mechanism to confirm sign-ups. After all, anybody can put down &lt;code&gt;president@whitehouse.gov&lt;/code&gt;, and that will even parse as legal, but it isn't likely to be the person at the other end.</source>
          <target state="translated">Los tokens de confirmaci&amp;oacute;n son la &amp;uacute;nica forma de saber que recibi&amp;oacute; la direcci&amp;oacute;n de la persona que lo ingres&amp;oacute;. Es por eso que la mayor&amp;iacute;a de las listas de correo ahora usan ese mecanismo para confirmar las suscripciones. Despu&amp;eacute;s de todo, cualquiera puede anular &lt;code&gt;president@whitehouse.gov&lt;/code&gt; , y eso incluso se considerar&amp;aacute; legal, pero no es probable que sea la persona del otro lado.</target>
        </trans-unit>
        <trans-unit id="8d15eaf92a267e0a03325e52d09f34bab6f23882" translate="yes" xml:space="preserve">
          <source>Context:</source>
          <target state="translated">Context:</target>
        </trans-unit>
        <trans-unit id="f828a4a98f03513a4667164d14af724f3d41a094" translate="yes" xml:space="preserve">
          <source>Correcting the &lt;code&gt;00&lt;/code&gt; bug in the IP pattern, we obtain a working and fairly fast regex.  (Scrape the rendered version, not the markdown, for actual code.)</source>
          <target state="translated">Al corregir el error &lt;code&gt;00&lt;/code&gt; en el patr&amp;oacute;n de IP, obtenemos una expresi&amp;oacute;n regular que funciona y bastante r&amp;aacute;pido. (Raspe la versi&amp;oacute;n renderizada, no la rebaja, para el c&amp;oacute;digo real).</target>
        </trans-unit>
        <trans-unit id="bf64925120bcbd811e65f1c72f59a3f04f836d22" translate="yes" xml:space="preserve">
          <source>Debuggex Demo</source>
          <target state="translated">Demostración de Debuggex</target>
        </trans-unit>
        <trans-unit id="61dca52965a9edf91b73613147e9ac7c10c8eeea" translate="yes" xml:space="preserve">
          <source>Different syntaxes should be used for different purposes. If you want to scan for email addresses in a (possibly very old) document it may be a good idea to use the syntax as defined in RFC 822. On the other hand, if you want to validate user input you may want to use the syntax as defined in RFC 5322, probably only accepting canonical representations. You should decide which syntax applies to your specific case.</source>
          <target state="translated">Se deben utilizar diferentes sintaxis para diferentes propósitos.Si se quiere buscar direcciones de correo electrónico en un documento (posiblemente muy antiguo),puede ser una buena idea utilizar la sintaxis definida en el RFC 822.Por otro lado,si desea validar la entrada del usuario puede querer usar la sintaxis como se define en el RFC 5322,probablemente sólo aceptando representaciones canónicas.Usted debe decidir qué sintaxis se aplica a su caso específico.</target>
        </trans-unit>
        <trans-unit id="cc6873ddb69d463add1609634358323011bb0f08" translate="yes" xml:space="preserve">
          <source>Don't know about best, but &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;this one&lt;/a&gt; is at least correct, as long as the addresses have their comments stripped and replaced with whitespace.</source>
          <target state="translated">No s&amp;eacute; cu&amp;aacute;l es el mejor, pero &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;este&lt;/a&gt; es al menos correcto, siempre y cuando las direcciones tengan sus comentarios eliminados y reemplazados con espacios en blanco.</target>
        </trans-unit>
        <trans-unit id="850a13e5767f580f2031a50d8569b73c2488bbf5" translate="yes" xml:space="preserve">
          <source>EDIT:
From the link:</source>
          <target state="translated">EDITORIAL:Desde el enlace:</target>
        </trans-unit>
        <trans-unit id="4986de5889e2f11c9bbdb9ef8b2a461042b1376a" translate="yes" xml:space="preserve">
          <source>Elaborate answer</source>
          <target state="translated">Elaborar la respuesta</target>
        </trans-unit>
        <trans-unit id="4d171fe5e95a2abcc5be91fb682415349c363bb7" translate="yes" xml:space="preserve">
          <source>For PHP, you should &lt;em&gt;not&lt;/em&gt; use the pattern given in &lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;Validate an E-Mail Address with PHP, the Right Way&lt;/a&gt; from which I quote:</source>
          <target state="translated">Para PHP, no debe usar el patr&amp;oacute;n dado en &lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;Validar una direcci&amp;oacute;n de correo electr&amp;oacute;nico con PHP, la forma correcta&lt;/a&gt; de citar:</target>
        </trans-unit>
        <trans-unit id="388c8341169873cbf876d842d5c93f563b812762" translate="yes" xml:space="preserve">
          <source>For a vivid demonstration, the following monster is pretty good but still does not correctly recognize all syntactically valid email addresses: it recognizes nested comments up to four levels deep.</source>
          <target state="translated">Para una demostración vívida,el siguiente monstruo es bastante bueno pero todavía no reconoce correctamente todas las direcciones de correo electrónico sintácticamente válidas:reconoce comentarios anidados hasta cuatro niveles de profundidad.</target>
        </trans-unit>
        <trans-unit id="844bb7409b2bf0d129a7300da9332ae49f500e9f" translate="yes" xml:space="preserve">
          <source>For the most comprehensive evaluation of the best regular expression for validating an email address please see this link; &quot;&lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;&quot;</source>
          <target state="translated">Para la evaluaci&amp;oacute;n m&amp;aacute;s completa de la mejor expresi&amp;oacute;n regular para validar una direcci&amp;oacute;n de correo electr&amp;oacute;nico, consulte este enlace; &quot; &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparaci&amp;oacute;n de direcciones de correo electr&amp;oacute;nico que validan expresiones regulares&lt;/a&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="810c3f2bf5a7cff75d30fdb21ab358a9d78d240a" translate="yes" xml:space="preserve">
          <source>For your regex of domain part, domain name cannot starts with '-' and cannot ends with '-'. Dash can only stays in between.</source>
          <target state="translated">Para su regex de la parte del dominio,el nombre de dominio no puede comenzar con &quot;-&quot; y no puede terminar con &quot;-&quot;.Dash sólo puede permanecer en el medio.</target>
        </trans-unit>
        <trans-unit id="858f135b293e0d7506e7d37d2280ccbde6e7451a" translate="yes" xml:space="preserve">
          <source>Further considerations</source>
          <target state="translated">Otras consideraciones</target>
        </trans-unit>
        <trans-unit id="985180927b564d247d4e14d076eb593cde86c3fb" translate="yes" xml:space="preserve">
          <source>Further restrictions</source>
          <target state="translated">Otras restricciones</target>
        </trans-unit>
        <trans-unit id="1c80cf144e810a9d98d32782de59c315753f43bf" translate="yes" xml:space="preserve">
          <source>Furthermore, an address having a dot at the end, like &lt;code&gt;user@company.&lt;/code&gt; is accepted by MailAddress as well.</source>
          <target state="translated">Adem&amp;aacute;s, una direcci&amp;oacute;n que tiene un punto al final, como &lt;code&gt;user@company.&lt;/code&gt; es aceptado por MailAddress tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="090fe8536ba48667df2f9156f2408f10a24285d6" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;diagram&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite state machine&lt;/a&gt; for above regexp which is more clear than regexp itself</source>
          <target state="translated">Aqu&amp;iacute; hay un &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;diagrama&lt;/a&gt; de &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;la m&amp;aacute;quina de estados finitos&lt;/a&gt; para la expresi&amp;oacute;n regular anterior que es m&amp;aacute;s clara que la propia expresi&amp;oacute;n regular</target>
        </trans-unit>
        <trans-unit id="2a7827f413e7dc52ce89180fc06b75a173a00bb2" translate="yes" xml:space="preserve">
          <source>Here is the current top expression for reference purposes:</source>
          <target state="translated">Aquí está la máxima expresión actual para fines de referencia:</target>
        </trans-unit>
        <trans-unit id="f1b99749e961642af10fe964ad761b71345efbe1" translate="yes" xml:space="preserve">
          <source>Here's the PHP I use. I've choosen this solution in the spirit of &quot;false positives are better than false negatives&quot; as declared by another commenter here AND with regards to keeping your response time up and server load down ... there's really no need to waste server resources with a regular expression when this will weed out most simple user error. You can always follow this up by sending a test email if you want.</source>
          <target state="translated">Aquí está el PHP que uso.He elegido esta solución en el espíritu de &quot;los falsos positivos son mejores que los falsos negativos&quot; como lo declaró otro comentarista aquí Y con respecto a mantener su tiempo de respuesta arriba y la carga del servidor abajo...realmente no hay necesidad de desperdiciar recursos del servidor con una expresión regular cuando esto eliminará el más simple error de usuario.Siempre puedes hacer un seguimiento de esto enviando un correo electrónico de prueba si quieres.</target>
        </trans-unit>
        <trans-unit id="c555de7c7b1f7b703afcbb25f5d37921cd5a5f3c" translate="yes" xml:space="preserve">
          <source>Here's the derivation:</source>
          <target state="translated">Aquí está la derivación:</target>
        </trans-unit>
        <trans-unit id="40e3a2be8d888879a228175a976ea9a711b4df90" translate="yes" xml:space="preserve">
          <source>How to validate an email address using a regular expression</source>
          <target state="translated">Cómo validar una dirección de correo electrónico utilizando una expresión regular</target>
        </trans-unit>
        <trans-unit id="b7c6fcdddbab0b180253335877c4f6f7061b17bc" translate="yes" xml:space="preserve">
          <source>I also do not recommend explicitly validating against a list of literal top-level domains or even imposing length-constraints (remember how &quot;.museum&quot; invalidated &lt;code&gt;[a-z]{2,4}&lt;/code&gt;), but if you must:</source>
          <target state="translated">Tampoco recomiendo validar expl&amp;iacute;citamente contra una lista de dominios literales de nivel superior o incluso imponer restricciones de longitud (recuerde c&amp;oacute;mo &quot;.museum&quot; invalid&amp;oacute; &lt;code&gt;[a-z]{2,4}&lt;/code&gt; ), pero si debe:</target>
        </trans-unit>
        <trans-unit id="6106b21b52d6c2869f1edf73c29f89a75ca99ea7" translate="yes" xml:space="preserve">
          <source>I arrived at the following regular expression. I invite everyone to try and break it. If you find any false positives or false negatives, please post them in a comment and I'll try to fix the expression as soon as possible.</source>
          <target state="translated">Llegué a la siguiente expresión regular.Invito a todos a intentar romperla.Si encuentran algún falso positivo o falso negativo,por favor publíquelo en un comentario y trataré de arreglar la expresión lo antes posible.</target>
        </trans-unit>
        <trans-unit id="de12597981cafac001a63547fcd2d56956471988" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 5322 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">Creo que es totalmente compatible con RFC 5322, incluida la &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;errata&lt;/a&gt; . Solo reconoce las direcciones de correo electr&amp;oacute;nico en su forma can&amp;oacute;nica. Para una expresi&amp;oacute;n regular que reconoce espacios en blanco (plegables), consulte la derivaci&amp;oacute;n a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="89706fb75be6521376b620efafa6099e39529f6f" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 822 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">Creo que es totalmente compatible con RFC 822, incluida la &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;errata&lt;/a&gt; . Solo reconoce las direcciones de correo electr&amp;oacute;nico en su forma can&amp;oacute;nica. Para una expresi&amp;oacute;n regular que reconoce espacios en blanco (plegables), consulte la derivaci&amp;oacute;n a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f512b55ca04846c10d5913e0fe2ed677435f773d" translate="yes" xml:space="preserve">
          <source>I collated test cases from Cal Henderson, Dave Child, Phil Haack, Doug Lovell, RFC5322 and RFC 3696. 275 test addresses in all. I ran all these tests against all the free validators I could find.</source>
          <target state="translated">He cotejado los casos de prueba de Cal Henderson,Dave Child,Phil Haack,Doug Lovell,RFC5322 y RFC 3696.275 direcciones de prueba en total.Hice todas estas pruebas con todos los validadores gratuitos que pude encontrar.</target>
        </trans-unit>
        <trans-unit id="8bc4518aeece4f1a66566191f1afe71e2bbca678" translate="yes" xml:space="preserve">
          <source>I discuss some issues in my &lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;answer to Is there a php library for email address validation?&lt;/a&gt;, it is discussed also in &lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;Regexp recognition of email address hard?&lt;/a&gt;</source>
          <target state="translated">Discuto algunos problemas en mi &lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;respuesta a &amp;iquest;Hay una biblioteca php para la validaci&amp;oacute;n de la direcci&amp;oacute;n de correo electr&amp;oacute;nico?&lt;/a&gt; , se discute tambi&amp;eacute;n en &lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;Regexp reconocimiento de direcci&amp;oacute;n de correo electr&amp;oacute;nico duro?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8865bf5a399677a2e921d40976a7e3002e86774" translate="yes" xml:space="preserve">
          <source>I do not recommend restricting the local part further, e.g. by precluding quoted strings, since we don't know what kind of mailbox names some hosts allow (like &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; or even &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt;).</source>
          <target state="translated">No recomiendo restringir a&amp;uacute;n m&amp;aacute;s la parte local, por ejemplo, excluyendo cadenas entre comillas, ya que no sabemos qu&amp;eacute; tipo de nombres de buzones permiten algunos hosts (como &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; o incluso &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b8e124659a2c24af661cc381668ac370a95c11e1" translate="yes" xml:space="preserve">
          <source>I ignored all the &quot;obs-&quot; rules from the RFC. This means that the regexes only match email addresses that are strictly RFC 5322 compliant. If you have to match &quot;old&quot; addresses (as the looser grammar including the &quot;obs-&quot; rules does), you can use one of the RFC 822 regexes from the previous paragraph.</source>
          <target state="translated">Ignoré todas las reglas de &quot;obs...&quot; del RFC.Esto significa que los regexes sólo coinciden con las direcciones de correo electrónico que cumplen estrictamente con el RFC 5322.Si tienes que hacer coincidir direcciones &quot;antiguas&quot; (como lo hace la gramática más floja que incluye las reglas &quot;obs-&quot;),puedes usar una de las regexes RFC 822 del párrafo anterior.</target>
        </trans-unit>
        <trans-unit id="062a5233c8de0b33af018e4eeae4a1ba0c95916d" translate="yes" xml:space="preserve">
          <source>I never bother creating with my own regular expression, because chances are that someone else has already come up with a better version.  I always use &lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib&lt;/a&gt; to find one to my liking.</source>
          <target state="translated">Nunca me molesto en crear con mi propia expresi&amp;oacute;n regular, porque lo m&amp;aacute;s probable es que otra persona ya haya encontrado una versi&amp;oacute;n mejor. Siempre uso &lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib&lt;/a&gt; para encontrar uno de mi agrado.</target>
        </trans-unit>
        <trans-unit id="088e64f9ee7f255c4c5eac7974a7114e20492d11" translate="yes" xml:space="preserve">
          <source>I use</source>
          <target state="translated">Yo uso</target>
        </trans-unit>
        <trans-unit id="6795b75201299955c1b7995c570b13d659921b18" translate="yes" xml:space="preserve">
          <source>I use POSIX &quot;extended&quot; regular expressions in this answer, assuming an ASCII compatible character set.</source>
          <target state="translated">Utilizo expresiones regulares POSIX &quot;extendidas&quot; en esta respuesta,asumiendo un conjunto de caracteres compatibles con ASCII.</target>
        </trans-unit>
        <trans-unit id="56d0d3ff30df9317fddde67f83205c8cb0ff3cec" translate="yes" xml:space="preserve">
          <source>I use it in several PHP programs, and it works most of the time.  However, from time to time I get contacted by someone that is having trouble with a site that uses it, and I end up having to make some adjustment (most recently I realized that I wasn't allowing 4-character TLDs).</source>
          <target state="translated">Lo uso en varios programas PHP,y funciona la mayor parte del tiempo.Sin embargo,de vez en cuando me contacta alguien que tiene problemas con un sitio que lo usa,y termino teniendo que hacer algunos ajustes (más recientemente me di cuenta de que no permitía TLDs de 4 caracteres).</target>
        </trans-unit>
        <trans-unit id="034d131aacb2134a772bdf60fff06a86578e9c3f" translate="yes" xml:space="preserve">
          <source>I'll try to keep this page up-to-date as people enhance their validators. Thanks to Cal, Michael, Dave, Paul and Phil for their help and co-operation in compiling these tests and constructive criticism of &lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;my own validator&lt;/a&gt;.</source>
          <target state="translated">Intentar&amp;eacute; mantener esta p&amp;aacute;gina actualizada a medida que las personas mejoren sus validadores. Gracias a Cal, Michael, Dave, Paul y Phil por su ayuda y cooperaci&amp;oacute;n en la compilaci&amp;oacute;n de estas pruebas y cr&amp;iacute;ticas constructivas de &lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;mi propio validador&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8588212a8c9ffe41b9ef89fa0c2610e960516246" translate="yes" xml:space="preserve">
          <source>I've seen several solutions that use functions that use several shorter expressions, but I'd rather have one long complex expression in a simple function instead of several short expression in a more complex function.</source>
          <target state="translated">He visto varias soluciones que utilizan funciones que usan varias expresiones más cortas,pero prefiero una expresión larga y compleja en una función simple en lugar de varias expresiones cortas en una función más compleja.</target>
        </trans-unit>
        <trans-unit id="725e5ed871d70812fff5a898374748169242406b" translate="yes" xml:space="preserve">
          <source>If the purpose of the regex is just to quickly inform the user in the UI that the specified email address doesn't look like in the right format, best is still to check if it matches basically the following regex:</source>
          <target state="translated">Si el propósito de la regex es sólo informar rápidamente al usuario en la UI que la dirección de correo electrónico especificada no se ve en el formato correcto,lo mejor sigue siendo comprobar si coincide básicamente con la siguiente regex:</target>
        </trans-unit>
        <trans-unit id="64cac7449f582a2dc109b435c4145c5f430d12f4" translate="yes" xml:space="preserve">
          <source>If you plan to use the &lt;code&gt;MailAddress&lt;/code&gt; to validate the e-mail address, be aware that this approach accepts the display name part of the e-mail address as well, and that may not be exactly what you want to achieve. For example, it accepts these strings as valid e-mail addresses:</source>
          <target state="translated">Si planea usar &lt;code&gt;MailAddress&lt;/code&gt; para validar la direcci&amp;oacute;n de correo electr&amp;oacute;nico, tenga en cuenta que este enfoque tambi&amp;eacute;n acepta la parte del nombre para mostrar de la direcci&amp;oacute;n de correo electr&amp;oacute;nico, y que puede que no sea exactamente lo que desea lograr. Por ejemplo, acepta estas cadenas como direcciones de correo electr&amp;oacute;nico v&amp;aacute;lidas:</target>
        </trans-unit>
        <trans-unit id="99811d1346d22a72366acd0b3ff9e1075ab2e9fc" translate="yes" xml:space="preserve">
          <source>If you really want to use a regex, &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;here it is&lt;/a&gt;:</source>
          <target state="translated">Si realmente quieres usar una expresi&amp;oacute;n regular, &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;aqu&amp;iacute; est&amp;aacute;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="44ce491ec374723f385ed8ad3f99125bd8e8fe92" translate="yes" xml:space="preserve">
          <source>If you used the PEAR library, check out their mail function (forgot the exact name/library).  You can validate email address by calling one function, and it validates the email address according to definition in RFC822.</source>
          <target state="translated">Si usaste la biblioteca PEAR,revisa su función de correo (olvidaste el nombre exacto de la biblioteca).Puedes validar la dirección de correo electrónico llamando a una función,y ésta valida la dirección de correo electrónico según la definición en RFC822.</target>
        </trans-unit>
        <trans-unit id="89fdaa410759db94e2b5de2465bd333dc0953efc" translate="yes" xml:space="preserve">
          <source>If you want more information how this buid-in validation works, see here: &lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;Does PHP's filter_var FILTER_VALIDATE_EMAIL actually work?&lt;/a&gt;</source>
          <target state="translated">Si desea obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo funciona esta validaci&amp;oacute;n &lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;integrada&lt;/a&gt; , consulte aqu&amp;iacute;: &amp;iquest;Funciona realmente filter_var FILTER_VALIDATE_EMAIL de PHP?</target>
        </trans-unit>
        <trans-unit id="0c40d3684b422bc8ff6e3c9362de5de71480237e" translate="yes" xml:space="preserve">
          <source>If you want to get fancy and pedantic, &lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;implement a complete state engine&lt;/a&gt;. A regular expression can only act as a rudimentary filter. The problem with regular expressions is that telling someone that their perfectly valid e-mail address is invalid (a false positive) because your regular expression can't handle it is just rude and impolite from the user's perspective. A state engine for the purpose can both validate and even correct e-mail addresses that would otherwise be considered invalid as it disassembles the e-mail address according to each RFC. This allows for a potentially more pleasing experience, like</source>
          <target state="translated">Si desea ser elegante y pedante, &lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;implemente un motor de estado completo&lt;/a&gt; . Una expresi&amp;oacute;n regular solo puede actuar como un filtro rudimentario. El problema con las expresiones regulares es que decirle a alguien que su direcci&amp;oacute;n de correo electr&amp;oacute;nico perfectamente v&amp;aacute;lida no es v&amp;aacute;lida (un falso positivo) porque su expresi&amp;oacute;n regular no puede manejarlo es grosero y descort&amp;eacute;s desde la perspectiva del usuario. Un motor de estado para este prop&amp;oacute;sito puede validar e incluso corregir direcciones de correo electr&amp;oacute;nico que de otro modo se considerar&amp;iacute;an inv&amp;aacute;lidas, ya que desarma la direcci&amp;oacute;n de correo electr&amp;oacute;nico de acuerdo con cada RFC. Esto permite una experiencia potencialmente m&amp;aacute;s agradable, como</target>
        </trans-unit>
        <trans-unit id="15c3b1fffdba1f0e987fbd41a9b09407c2fdc511" translate="yes" xml:space="preserve">
          <source>If you want to validate that an email is correct, you have no choice than to send an confirmation email and have the user reply to that. In many cases you will &lt;em&gt;have&lt;/em&gt; to send a confirmation mail anyway for security reasons or for ethical reasons (so you cannot e.g. sign someone up to a service against their will).</source>
          <target state="translated">Si desea validar que un correo electr&amp;oacute;nico es correcto, no tiene m&amp;aacute;s remedio que enviar un correo electr&amp;oacute;nico de confirmaci&amp;oacute;n y que el usuario responda a eso. En muchos casos, deber&amp;aacute; enviar un correo de confirmaci&amp;oacute;n de todos modos por razones de seguridad o por razones &amp;eacute;ticas (por lo que no puede, por ejemplo, inscribir a alguien en un servicio contra su voluntad).</target>
        </trans-unit>
        <trans-unit id="8f90c8045d52f4b058334a51ed4880471694677d" translate="yes" xml:space="preserve">
          <source>If you're running a php-version lower than 5.3.6 please be aware of this issue: &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https://bugs.php.net/bug.php?id=53091&lt;/a&gt;</source>
          <target state="translated">Si est&amp;aacute; ejecutando una versi&amp;oacute;n php inferior a 5.3.6, tenga en cuenta este problema: &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https://bugs.php.net/bug.php?id=53091&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bfe401233bd6300cf11a6837adc1067496b852ea" translate="yes" xml:space="preserve">
          <source>In short, don't expect a single, usable regex to do a proper job. And the best regex will validate the syntax, not the validity of an e-mail (jhohn@example.com is correct but it will probably bounce...).</source>
          <target state="translated">En resumen,no esperes que un solo regex utilizable haga un buen trabajo.Y el mejor regex validará la sintaxis,no la validez de un e-mail (jhohn@example.com es correcto pero probablemente rebotará...).</target>
        </trans-unit>
        <trans-unit id="d64fa0e517911923332fac4e2f71d913ad55f9db" translate="yes" xml:space="preserve">
          <source>In some of these cases, only the last part of the strings is parsed as the address; the rest before that is the display name. To get a plain e-mail address without any display name, you can check the normalized address against your original string.</source>
          <target state="translated">En algunos de estos casos,sólo la última parte de las cuerdas se analiza como la dirección;el resto antes de eso es el nombre de la pantalla.Para obtener una dirección de correo electrónico simple sin ningún nombre para mostrar,se puede comparar la dirección normalizada con la cadena original.</target>
        </trans-unit>
        <trans-unit id="92b6aee3575856478de82d957aae0862c153d512" translate="yes" xml:space="preserve">
          <source>In this answer I&amp;rsquo;ll take &amp;ldquo;email address&amp;rdquo; to mean &lt;code&gt;addr-spec&lt;/code&gt; as defined in the RFCs (i.e. &lt;code&gt;jdoe@example.org&lt;/code&gt;, but not &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt;, nor &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt;).</source>
          <target state="translated">En esta respuesta, tomar&amp;eacute; &quot;direcci&amp;oacute;n de correo electr&amp;oacute;nico&quot; para &lt;code&gt;addr-spec&lt;/code&gt; a addr-spec como se define en los RFC (es decir, &lt;code&gt;jdoe@example.org&lt;/code&gt; , pero no &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt; , ni &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29a575c86979b44c2fb0c43aa9e0d6c7884de728" translate="yes" xml:space="preserve">
          <source>Instead, use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt; class, like this:</source>
          <target state="translated">En su lugar, use la clase &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="bb3cb298c6dabff17c93f08e57db5b7c214514b7" translate="yes" xml:space="preserve">
          <source>It all depends on how accurate you want to be.  For my purposes, where I'm just trying to keep out things like &lt;code&gt;bob @ aol.com&lt;/code&gt; (spaces in emails) or &lt;code&gt;steve&lt;/code&gt; (no domain at all) or &lt;code&gt;mary@aolcom&lt;/code&gt; (no period before .com), I use</source>
          <target state="translated">Todo depende de cu&amp;aacute;n preciso quieras ser. Para mis prop&amp;oacute;sitos, donde solo estoy tratando de evitar cosas como &lt;code&gt;bob @ aol.com&lt;/code&gt; (espacios en los correos electr&amp;oacute;nicos) o &lt;code&gt;steve&lt;/code&gt; (sin dominio) o &lt;code&gt;mary@aolcom&lt;/code&gt; (sin per&amp;iacute;odo anterior a .com), uso</target>
        </trans-unit>
        <trans-unit id="55c558aed4449d4838de9ba71870504efebc5f4d" translate="yes" xml:space="preserve">
          <source>It depends on what you mean by best:
If you're talking about catching every valid email address use the following:</source>
          <target state="translated">Depende de lo que quieras decir con mejor:Si estás hablando de atrapar todas las direcciones de correo electrónico válidas,usa las siguientes:</target>
        </trans-unit>
        <trans-unit id="634ea515e24f27b27c16f1ac8df53108713d9618" translate="yes" xml:space="preserve">
          <source>It does not prevent people from entering invalid or made-up email addresses, or entering someone else's address.</source>
          <target state="translated">No impide que las personas introduzcan direcciones de correo electrónico inválidas o inventadas,o que introduzcan la dirección de otra persona.</target>
        </trans-unit>
        <trans-unit id="ef282074cd0ee12c9819b8667cca979a4d908a32" translate="yes" xml:space="preserve">
          <source>It should however be noted that if you want to find out if the address actually refers to an existing mailbox, there's no substitute for sending a message to the address. If you only want to check if an address is grammatically correct then you could use a regular expression, but note that &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; is a grammatically correct email address that certainly doesn't refer to an existing mailbox.</source>
          <target state="translated">Sin embargo, debe tenerse en cuenta que si desea averiguar si la direcci&amp;oacute;n realmente se refiere a un buz&amp;oacute;n existente, no hay sustituto para enviar un mensaje a la direcci&amp;oacute;n. Si solo desea verificar si una direcci&amp;oacute;n es gramaticalmente correcta, entonces podr&amp;iacute;a usar una expresi&amp;oacute;n regular, pero tenga en cuenta que &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; es una direcci&amp;oacute;n de correo electr&amp;oacute;nico gramaticalmente correcta que ciertamente no se refiere a un buz&amp;oacute;n existente.</target>
        </trans-unit>
        <trans-unit id="cc84b5c5472043636abf125126a167f8104cf798" translate="yes" xml:space="preserve">
          <source>It will not catch common typos.</source>
          <target state="translated">No se contagiará de los errores tipográficos comunes.</target>
        </trans-unit>
        <trans-unit id="748495ccfc92d4a51e5e47b57ba34035d4c9f075" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy in Perl 5.10 or newer:</source>
          <target state="translated">Es f&amp;aacute;cil en Perl 5.10 o m&amp;aacute;s reciente:</target>
        </trans-unit>
        <trans-unit id="c36addb1f9a0630cf0fa05910cfe747100da3dcb" translate="yes" xml:space="preserve">
          <source>It's also important to understand that validating it per the RFC tells you absolutely nothing about whether that address actually exists at the supplied domain, or whether the person entering the address is its true owner. People sign others up to mailing lists this way all the time. Fixing that requires a fancier kind of validation that involves sending that address a message that includes a confirmation token meant to be entered on the same web page as was the address.</source>
          <target state="translated">También es importante entender que validarlo por el RFC no dice absolutamente nada sobre si esa dirección existe realmente en el dominio suministrado,o si la persona que introduce la dirección es su verdadero propietario.La gente inscribe a otros en listas de correo de esta manera todo el tiempo.La solución requiere un tipo de validación más elegante que implica enviar a esa dirección un mensaje que incluye un token de confirmación destinado a ser introducido en la misma página web que la dirección.</target>
        </trans-unit>
        <trans-unit id="59fc40df1759e098dcd512bdd762d89c1c4815c1" translate="yes" xml:space="preserve">
          <source>Make sure to keep your regex up-to-date if you decide to go down the path of explicit top-level domain validation.</source>
          <target state="translated">Asegúrate de mantener tu regex actualizado si decides seguir el camino de la validación explícita del dominio de nivel superior.</target>
        </trans-unit>
        <trans-unit id="aa2ea3e7fb557b8b8b13fa28afb31c3928419cfd" translate="yes" xml:space="preserve">
          <source>None of the regexes in this answer are optimized for performance. If performance is an issue, you should see if (and how) the regex of your choice can be optimized.</source>
          <target state="translated">Ninguno de los regexes de esta respuesta está optimizado para el rendimiento.Si el rendimiento es un problema,deberías ver si (y cómo)el regex de tu elección puede ser optimizado.</target>
        </trans-unit>
        <trans-unit id="2a469b7426fdfa686180a96ef3fe9463e2cbdbd8" translate="yes" xml:space="preserve">
          <source>Not to mention that non-Latin (Chinese, Arabic, Greek, Hebrew, Cyrillic and so on) domain names are to be allowed in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;near future&lt;/a&gt;. Everyone has to change the email regex used, because those characters are surely not to be covered by &lt;code&gt;[a-z]/i&lt;/code&gt; nor &lt;code&gt;\w&lt;/code&gt;. They will all fail.</source>
          <target state="translated">Sin mencionar que los nombres de dominio no latinos (chino, &amp;aacute;rabe, griego, hebreo, cir&amp;iacute;lico, etc.) se permitir&amp;aacute;n en &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;un futuro pr&amp;oacute;ximo&lt;/a&gt; . Todos tienen que cambiar la expresi&amp;oacute;n regular del correo electr&amp;oacute;nico utilizada, porque esos caracteres seguramente no ser&amp;aacute;n cubiertos por &lt;code&gt;[a-z]/i&lt;/code&gt; ni &lt;code&gt;\w&lt;/code&gt; . Todos fallar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="ed883c2a93aaa8eff111b58e6939a3cdb4b3d6af" translate="yes" xml:space="preserve">
          <source>Note that depending on the use case you may not want to allow for a &quot;General-address-literal&quot; in your regex. Also note that I used a negative lookahead &lt;code&gt;(?!IPv6:)&lt;/code&gt; in the final regex to prevent the &quot;General-address-literal&quot; part to match malformed IPv6 addresses. Some regex processors don't support negative lookahead. Remove the substring &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; from the regex if you want to take the whole &quot;General-address-literal&quot; part out.</source>
          <target state="translated">Tenga en cuenta que, seg&amp;uacute;n el caso de uso, es posible que no desee permitir un &quot;General-address-literal&quot; en su expresi&amp;oacute;n regular. Tambi&amp;eacute;n tenga en cuenta que utilic&amp;eacute; un lookahead negativo &lt;code&gt;(?!IPv6:)&lt;/code&gt; en la expresi&amp;oacute;n regular final para evitar que la parte &quot;General-address-literal&quot; coincida con direcciones IPv6 mal formadas. Algunos procesadores de expresiones regulares no son compatibles con la b&amp;uacute;squeda anticipada negativa. Elimine la subcadena &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; de la expresi&amp;oacute;n regular si desea tomar la totalidad &quot;General-address-literal&quot; parte.</target>
        </trans-unit>
        <trans-unit id="1603724f5f43f1edae560e9739defad7e033ecee" translate="yes" xml:space="preserve">
          <source>Note that some sources (notably &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt;) claim that RFC 5322 is too strict on the local part (i.e. the part before the @-sign). This is because &quot;..&quot;, &quot;a..b&quot; and &quot;a.&quot; are &lt;em&gt;not&lt;/em&gt; valid dot-atoms, while they may be used as mailbox names. The RFC, however, &lt;em&gt;does&lt;/em&gt; allow for local parts like these, except that they have to be quoted. So instead of &lt;code&gt;a..b@example.net&lt;/code&gt; you should write &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt;, which is semantically equivalent.</source>
          <target state="translated">Tenga en cuenta que algunas fuentes (especialmente &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt; ) afirman que RFC 5322 es demasiado estricto en la parte local (es decir, la parte anterior al signo @). Esto se debe a que &quot;..&quot;, &quot;a..b&quot; y &quot;a&quot;. &lt;em&gt;no&lt;/em&gt; son puntos-&amp;aacute;tomos v&amp;aacute;lidos, mientras que pueden usarse como nombres de buzones. El RFC, sin embargo, permite partes locales como estas, excepto que tienen que ser citadas. Entonces, en lugar de &lt;code&gt;a..b@example.net&lt;/code&gt; , debe escribir &quot; a..b&quot;@example.net , que es sem&amp;aacute;nticamente equivalente.</target>
        </trans-unit>
        <trans-unit id="a414e2438f7c9cf87c83b4983b266d69534ed05a" translate="yes" xml:space="preserve">
          <source>Note: This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &amp;ldquo;@&amp;rdquo; character), too vague (after the &amp;ldquo;@&amp;rdquo; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">Nota: Este requisito es una &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;violaci&amp;oacute;n intencional&lt;/a&gt; de &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; , que define una sintaxis para las direcciones de correo electr&amp;oacute;nico que es simult&amp;aacute;neamente demasiado estricta (antes del car&amp;aacute;cter &quot;@&quot;), demasiado vaga (despu&amp;eacute;s del car&amp;aacute;cter &quot;@&quot;) y demasiado laxa ( permitiendo que los comentarios, los caracteres de espacios en blanco y las cadenas citadas de maneras desconocidas para la mayor&amp;iacute;a de los usuarios) sean de utilidad pr&amp;aacute;ctica aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="a60dff653e359c769e135e4c04c6e895ea0123b7" translate="yes" xml:space="preserve">
          <source>One RFC 5322 compliant regex can be found at the top of the page at &lt;a href=&quot;http://emailregex.com/&quot;&gt;http://emailregex.com/&lt;/a&gt; but uses the IP address pattern that is floating around the internet with a bug that allows &lt;code&gt;00&lt;/code&gt; for any of the unsigned byte decimal values in a dot-delimited address, which is illegal.  The rest of it appears to be consistent with the RFC 5322 grammar and passes several tests using &lt;code&gt;grep -Po&lt;/code&gt;, including cases domain names, IP addresses, bad ones, and account names with and without quotes.</source>
          <target state="translated">Se puede encontrar una expresi&amp;oacute;n regular compatible con RFC 5322 en la parte superior de la p&amp;aacute;gina en &lt;a href=&quot;http://emailregex.com/&quot;&gt;http://emailregex.com/&lt;/a&gt; pero usa el patr&amp;oacute;n de direcci&amp;oacute;n IP que flota en Internet con un error que permite &lt;code&gt;00&lt;/code&gt; para cualquiera de los valores decimales de byte sin signo en una direcci&amp;oacute;n delimitada por puntos, que es ilegal. El resto parece ser coherente con la gram&amp;aacute;tica RFC 5322 y pasa varias pruebas usando &lt;code&gt;grep -Po&lt;/code&gt; , incluidos los casos nombres de dominio, direcciones IP, incorrectos y nombres de cuenta con y sin comillas.</target>
        </trans-unit>
        <trans-unit id="6849c03183bc687fc66af67fdc8fab74faf61cad" translate="yes" xml:space="preserve">
          <source>One simple regular expression which would at least not reject any valid email address would be checking for something, followed by an @ sign and then something followed by a period and at least 2 somethings. It won't reject anything, but after reviewing the spec I can't find any email that would be valid and rejected.</source>
          <target state="translated">Una simple expresión regular que al menos no rechazaría ninguna dirección de correo electrónico válida sería comprobar algo,seguido de un signo @ y luego algo seguido de un punto y al menos 2 cosas.No rechazará nada,pero después de revisar las especificaciones no puedo encontrar ningún correo electrónico que sea válido y rechazado.</target>
        </trans-unit>
        <trans-unit id="eacf0af0cb780f7e0cc0c41e3539fd563e478436" translate="yes" xml:space="preserve">
          <source>Over the years I have slowly developed a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; that validates MOST email addresses correctly, assuming they don't use an IP address as the server part.</source>
          <target state="translated">A lo largo de los a&amp;ntilde;os, he desarrollado lentamente una &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;expresi&amp;oacute;n regular&lt;/a&gt; que valida la mayor&amp;iacute;a de las direcciones de correo electr&amp;oacute;nico correctamente, asumiendo que no usan una direcci&amp;oacute;n IP como parte del servidor.</target>
        </trans-unit>
        <trans-unit id="4e44c1594bc79271466627aea4dc6d92f45efa87" translate="yes" xml:space="preserve">
          <source>People should be aware of the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;errata against RFC 3696&lt;/a&gt; in particular. Three of the canonical examples are in fact invalid addresses. And the maximum length of an address is 254 or 256 characters, &lt;strong&gt;not&lt;/strong&gt; 320.</source>
          <target state="translated">Las personas deben ser conscientes de la &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;errata contra RFC 3696&lt;/a&gt; en particular. Tres de los ejemplos can&amp;oacute;nicos son, de hecho, direcciones no v&amp;aacute;lidas. Y la longitud m&amp;aacute;xima de una direcci&amp;oacute;n es de 254 o 256 caracteres, &lt;strong&gt;no&lt;/strong&gt; 320.</target>
        </trans-unit>
        <trans-unit id="d39c523f1fb1d41ff6e8a68ec88d7d3a31a24cd0" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;the W3C HTML5 spec&lt;/a&gt;:</source>
          <target state="translated">Seg&amp;uacute;n &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;la especificaci&amp;oacute;n HTML5 W3C&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="56c0dad2b0956cd6ae32504c979c840f02cf3573" translate="yes" xml:space="preserve">
          <source>Quick answer</source>
          <target state="translated">Respuesta rápida</target>
        </trans-unit>
        <trans-unit id="fa2251418aa68903f6488427bde3d8e415a9f16a" translate="yes" xml:space="preserve">
          <source>RFC 5321 basically leaves alone the &quot;local&quot; part (i.e. the part before the @-sign), but is stricter on the domain part (i.e. the part after the @-sign). It allows only host names in place of dot-atoms and address literals in place of domain literals.</source>
          <target state="translated">El RFC 5321 básicamente deja en paz la parte &quot;local&quot; (es decir,la parte antes del signo @),pero es más estricto en la parte del dominio (es decir,la parte después del signo @).Sólo permite nombres de host en lugar de átomos de puntos y literales de dirección en lugar de literales de dominio.</target>
        </trans-unit>
        <trans-unit id="82af36243c542be2f1bd3a5fa7459b1dbce36d81" translate="yes" xml:space="preserve">
          <source>RFC 5321 standard:</source>
          <target state="translated">RFC 5321 estándar:</target>
        </trans-unit>
        <trans-unit id="17c58504badf8c1787c4ac4f95c466fc696f2e50" translate="yes" xml:space="preserve">
          <source>RFC 5322</source>
          <target state="translated">RFC 5322</target>
        </trans-unit>
        <trans-unit id="479d36b78205a178de44b9bbbe339cec9f59000b" translate="yes" xml:space="preserve">
          <source>RFC 5322 standard:</source>
          <target state="translated">RFC 5322 estándar:</target>
        </trans-unit>
        <trans-unit id="00af815762ae4e4ed879f00aa53f3fc9fc817b37" translate="yes" xml:space="preserve">
          <source>RFC 822</source>
          <target state="translated">RFC 822</target>
        </trans-unit>
        <trans-unit id="fd412bb5a3c2ad14d277d7a4b79b8f75df43ce9c" translate="yes" xml:space="preserve">
          <source>Regular expression built using Jeffrey Friedl's example in
  &lt;em&gt;Mastering Regular Expressions&lt;/em&gt; (&lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt;).</source>
          <target state="translated">Expresi&amp;oacute;n regular construida utilizando el ejemplo de Jeffrey Friedl en &lt;em&gt;Mastering Regular Expressions&lt;/em&gt; ( &lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4fa9d019350b110a4ff197daf305ce272d79f6ae" translate="yes" xml:space="preserve">
          <source>SMTP (as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321&lt;/a&gt;) further restricts the set of valid email addresses (or actually: mailbox names). It seems reasonable to impose this stricter grammar, so that the matched email address can actually be used to send an email.</source>
          <target state="translated">SMTP (como se define en &lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321&lt;/a&gt; ) restringe a&amp;uacute;n m&amp;aacute;s el conjunto de direcciones de correo electr&amp;oacute;nico v&amp;aacute;lidas (o en realidad: nombres de buzones). Parece razonable imponer esta gram&amp;aacute;tica m&amp;aacute;s estricta, de modo que la direcci&amp;oacute;n de correo electr&amp;oacute;nico coincidente pueda usarse para enviar un correo electr&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="2e509ea11bcd91c64419ceb313b8fded4cfb62a1" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;Validating Email Addresses&lt;/a&gt;, including the comments. Or &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;.</source>
          <target state="translated">Consulte tambi&amp;eacute;n &lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;Validar direcciones de correo electr&amp;oacute;nico&lt;/a&gt; , incluidos los comentarios. O &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;comparando la direcci&amp;oacute;n de correo electr&amp;oacute;nico validando expresiones regulares&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53a9c322bf8ce66569059aa3e1529b8bee955c35" translate="yes" xml:space="preserve">
          <source>Seriously. You should use an already written library for validating emails. The best way is probably to just send a verification e-mail to that address.</source>
          <target state="translated">En serio.Deberías usar una biblioteca ya escrita para validar los correos electrónicos.La mejor manera es probablemente enviar un e-mail de verificación a esa dirección.</target>
        </trans-unit>
        <trans-unit id="a143d6225e75c2b766a2aee66d8dfbc3d273186e" translate="yes" xml:space="preserve">
          <source>Simple as that. Why on earth would you care about the characters used in the name and domain? It's the client's responsibility to enter a valid email address, not the server's. Even when the client enters a &lt;em&gt;syntactically&lt;/em&gt; valid email address like &lt;code&gt;aa@bb.cc&lt;/code&gt;, this does not guarantee that it's a legit email address. No one regex can cover that.</source>
          <target state="translated">Simple como eso. &amp;iquest;Por qu&amp;eacute; te importar&amp;iacute;an los caracteres utilizados en el nombre y el dominio? Es responsabilidad del cliente ingresar una direcci&amp;oacute;n de correo electr&amp;oacute;nico v&amp;aacute;lida, no la del servidor. Incluso cuando el cliente ingresa una direcci&amp;oacute;n de correo electr&amp;oacute;nico &lt;em&gt;sint&amp;aacute;cticamente&lt;/em&gt; v&amp;aacute;lida como &lt;code&gt;aa@bb.cc&lt;/code&gt; , esto no garantiza que sea una direcci&amp;oacute;n de correo electr&amp;oacute;nico leg&amp;iacute;tima. Nadie regex puede cubrir eso.</target>
        </trans-unit>
        <trans-unit id="056115c235bea2846acb135ffdbd27cd4ae8abc4" translate="yes" xml:space="preserve">
          <source>Strange that you &quot;cannot&quot; allow 4 characters TLDs.  You are banning people from &lt;em&gt;.info&lt;/em&gt; and &lt;em&gt;.name&lt;/em&gt;, and the length limitation stop &lt;em&gt;.travel&lt;/em&gt; and &lt;em&gt;.museum&lt;/em&gt;, but yes, they are less common than 2 characters TLDs and 3 characters TLDs.</source>
          <target state="translated">Es extra&amp;ntilde;o que &quot;no pueda&quot; permitir TLD de 4 caracteres. Est&amp;aacute; prohibiendo a las personas &lt;em&gt;.info&lt;/em&gt; y &lt;em&gt;.name&lt;/em&gt; , y la limitaci&amp;oacute;n de longitud detiene &lt;em&gt;.travel&lt;/em&gt; y &lt;em&gt;.museum&lt;/em&gt; , pero s&amp;iacute;, son menos comunes que los TLD de 2 caracteres y los TLD de 3 caracteres.</target>
        </trans-unit>
        <trans-unit id="6cbd3caa8bdfcbb5ef664dabf829fa863056ac8a" translate="yes" xml:space="preserve">
          <source>Sure, it will match things that aren't valid email addresses, but it's a matter of playing the 90/10 rule.</source>
          <target state="translated">Claro,coincidirá con cosas que no son direcciones de correo electrónico válidas,pero es cuestión de jugar con la regla 9010.</target>
        </trans-unit>
        <trans-unit id="af4c67c3df524d5adb915aacca975c4f92acf0be" translate="yes" xml:space="preserve">
          <source>That is no better than all the other non-RFC patterns. It isn&amp;rsquo;t even smart enough to handle even &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt;, let alone RFC 5322. &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;This one&lt;/a&gt;, however, is.</source>
          <target state="translated">Eso no es mejor que todos los otros patrones no RFC. Ni siquiera es lo suficientemente inteligente como para manejar incluso &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt; , y mucho menos RFC 5322. &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;Sin&lt;/a&gt; embargo, este s&amp;iacute; lo es.</target>
        </trans-unit>
        <trans-unit id="8a8b13790b55067f7d02a02213bba322543be649" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;fully RFC 822 compliant regex&lt;/a&gt; is inefficient and obscure because of its length.  Fortunately, RFC 822 was superseded twice and the current specification for email addresses is &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt;.  RFC 5322 leads to a regex that can be understood if studied for a few minutes and is efficient enough for actual use.</source>
          <target state="translated">La &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;expresi&amp;oacute;n regular totalmente compatible con RFC 822&lt;/a&gt; es ineficiente y oscura debido a su longitud. Afortunadamente, RFC 822 fue reemplazado dos veces y la especificaci&amp;oacute;n actual para las direcciones de correo electr&amp;oacute;nico es &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt; . RFC 5322 conduce a una expresi&amp;oacute;n regular que se puede entender si se estudia durante unos minutos y es lo suficientemente eficiente para el uso real.</target>
        </trans-unit>
        <trans-unit id="efef7583ce1f5955d8622631b97ef21d277e0c78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 spec suggests&lt;/a&gt; a simple regex for validating email addresses:</source>
          <target state="translated">La &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;especificaci&amp;oacute;n HTML5 sugiere&lt;/a&gt; una expresi&amp;oacute;n regular simple para validar direcciones de correo electr&amp;oacute;nico:</target>
        </trans-unit>
        <trans-unit id="cc7666184f88738787a730cc2f788c93befa5c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MailAddress&lt;/code&gt; class uses a BNF parser to validate the address in full accordance with RFC822.</source>
          <target state="translated">La clase &lt;code&gt;MailAddress&lt;/code&gt; utiliza un analizador BNF para validar la direcci&amp;oacute;n de acuerdo con RFC822.</target>
        </trans-unit>
        <trans-unit id="08094c7e000914320983bbc93438575ec83bb464" translate="yes" xml:space="preserve">
          <source>The RFCs define syntaxes for email messages, not for email addresses as such. Addresses may appear in various header fields and this is where they are primarily defined. When they appear in header fields addresses may contain (between lexical tokens) whitespace, comments and even linebreaks. Semantically this has no significance however. By removing this whitespace, etc. from an address you get a semantically equivalent &lt;em&gt;canonical representation&lt;/em&gt;. Thus, the canonical representation of &lt;code&gt;first. last (comment) @   [3.5.7.9]&lt;/code&gt; is &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt;.</source>
          <target state="translated">Los RFC definen sintaxis para mensajes de correo electr&amp;oacute;nico, no para direcciones de correo electr&amp;oacute;nico como tales. Las direcciones pueden aparecer en varios campos de encabezado y aqu&amp;iacute; es donde se definen principalmente. Cuando aparecen en los campos de encabezado, las direcciones pueden contener (entre tokens l&amp;eacute;xicos) espacios en blanco, comentarios e incluso saltos de l&amp;iacute;nea. Sin embargo, sem&amp;aacute;nticamente esto no tiene importancia. Al eliminar este espacio en blanco, etc. de una direcci&amp;oacute;n, obtienes una &lt;em&gt;representaci&amp;oacute;n can&amp;oacute;nica&lt;/em&gt; sem&amp;aacute;nticamente equivalente. As&amp;iacute;, la representaci&amp;oacute;n can&amp;oacute;nica de la &lt;code&gt;first. last (comment) @ [3.5.7.9]&lt;/code&gt; last (comment) @ [3.5.7.9] es &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03bb5d368df58fc938931912f1a46085762490a6" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. For rules that include semantically irrelevant (folding) whitespace, I give a separate regex marked &quot;(normalized)&quot; that doesn't accept this whitespace.</source>
          <target state="translated">La derivación muestra cómo llegué a la expresión.Enumero todas las reglas gramaticales relevantes del RFC exactamente como aparecen,seguidas de la correspondiente regex.Para las reglas que incluyen espacios en blanco semánticamente irrelevantes (plegables),doy una regex separada marcada &quot;(normalizada)&quot; que no acepta este espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="b143a24ff4d5dac8a1b58259e6ef61a5327993b2" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. Where an erratum has been published I give a separate expression for the corrected grammar rule (marked &quot;erratum&quot;) and use the updated version as a subexpression in subsequent regular expressions.</source>
          <target state="translated">La derivación muestra cómo llegué a la expresión.Enumero todas las reglas gramaticales relevantes del RFC exactamente como aparecen,seguidas de la correspondiente regex.Cuando se ha publicado una fe de erratas doy una expresión separada para la regla gramatical corregida (marcada como &quot;fe de erratas&quot;)y utilizo la versión actualizada como una subexpresión en las expresiones regulares subsiguientes.</target>
        </trans-unit>
        <trans-unit id="c988189fcad54702295e206fc75fe6d5f6101f50" translate="yes" xml:space="preserve">
          <source>The email addresses I want to validate are going to be used by an ASP.NET web application using the System.Net.Mail namespace to send emails to a list of people. So, rather than using some very complex regular expression, I just try to create a MailAddress instance from the address. The MailAddress construtor will throw an exception if the address is not formed properly. This way, I know I can at least get the email out of the door. Of course this is server-side validation but at a minimum you need that anyway.</source>
          <target state="translated">Las direcciones de correo electrónico que quiero validar van a ser usadas por una aplicación web ASP.NET usando el espacio de nombres System.Net.Mail para enviar correos electrónicos a una lista de personas.Así que,en lugar de usar alguna expresión regular muy compleja,sólo intento crear una instancia de MailAddress a partir de la dirección.El constructor MailAddress lanzará una excepción si la dirección no está formada correctamente.De esta manera,sé que al menos puedo sacar el correo electrónico de la puerta.Por supuesto que esto es una validación del lado del servidor,pero como mínimo necesitas eso de todas formas.</target>
        </trans-unit>
        <trans-unit id="2c42e1dbf8f30a22743d35f41dec49ad83dcbd78" translate="yes" xml:space="preserve">
          <source>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</source>
          <target state="translated">La siguiente expresión regular compatible con JavaScript y Perl es una implementación de la definición anterior.</target>
        </trans-unit>
        <trans-unit id="04b741d2a83f024156fc1aafe328ecd03eac2d01" translate="yes" xml:space="preserve">
          <source>The grammar presented in RFC 5321 is too lenient when it comes to both host names and IP addresses. I took the liberty of &quot;correcting&quot; the rules in question, using &lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;this draft&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034&lt;/a&gt; as guidelines. Here's the resulting regex.</source>
          <target state="translated">La gram&amp;aacute;tica presentada en RFC 5321 es demasiado indulgente cuando se trata de nombres de host y direcciones IP. Me tom&amp;eacute; la libertad de &quot;corregir&quot; las reglas en cuesti&amp;oacute;n, utilizando &lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;este borrador&lt;/a&gt; y &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034&lt;/a&gt; como pautas. Aqu&amp;iacute; est&amp;aacute; la expresi&amp;oacute;n regular resultante.</target>
        </trans-unit>
        <trans-unit id="78bea17cadfee2e52d3b0ba653aeb8078d41c522" translate="yes" xml:space="preserve">
          <source>The more sophisticated patterns in Perl and PCRE (regex library used e.g. in PHP) can &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;correctly parse RFC 5322 without a hitch&lt;/a&gt;. Python and C# can do that too, but they use a different syntax from those first two. However, if you are forced to use one of the many less powerful pattern-matching languages, then it&amp;rsquo;s best to use a real parser.</source>
          <target state="translated">Los patrones m&amp;aacute;s sofisticados en Perl y PCRE (biblioteca de expresiones regulares usadas, por ejemplo, en PHP) pueden &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;analizar correctamente RFC 5322 sin problemas&lt;/a&gt; . Python y C # tambi&amp;eacute;n pueden hacer eso, pero usan una sintaxis diferente de las dos primeras. Sin embargo, si se ve obligado a usar uno de los muchos lenguajes de coincidencia de patrones menos potentes, entonces es mejor usar un analizador real.</target>
        </trans-unit>
        <trans-unit id="f44b7e654912775bb48deb334cbbfbb5d94ad3b7" translate="yes" xml:space="preserve">
          <source>The second constraint is a restriction on RFC 5321/5322.</source>
          <target state="translated">La segunda restricción es la del RFC 53215322.</target>
        </trans-unit>
        <trans-unit id="ddc5dad053b60eb7739c3fbde8711a0b846a2faf" translate="yes" xml:space="preserve">
          <source>The specified e-mail address 'myemail@address,com' is invalid. Did you mean 'myemail@address.com'?</source>
          <target state="translated">La dirección de correo electrónico especificada &quot;miemail@dirección,com&quot; es inválida.¿Quiso decir 'myemail@address.com'?</target>
        </trans-unit>
        <trans-unit id="ba008b9092dbf02ae78dce33e0ba3f4f3680e270" translate="yes" xml:space="preserve">
          <source>The syntax of email addresses has been defined in various &lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFCs&lt;/a&gt;, most notably &lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;. RFC 822 should be seen as the &quot;original&quot; standard and RFC 5322 as the latest standard. The syntax defined in RFC 822 is the most lenient and subsequent standards have restricted the syntax further and further, where newer systems or services should recognize obsolete syntax, but never produce it.</source>
          <target state="translated">La sintaxis de las direcciones de correo electr&amp;oacute;nico se ha definido en varios &lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFC&lt;/a&gt; , especialmente &lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; y &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; . RFC 822 debe verse como el est&amp;aacute;ndar &quot;original&quot; y RFC 5322 como el &amp;uacute;ltimo est&amp;aacute;ndar. La sintaxis definida en RFC 822 es la m&amp;aacute;s indulgente y los est&amp;aacute;ndares posteriores han restringido la sintaxis cada vez m&amp;aacute;s, donde los sistemas o servicios m&amp;aacute;s nuevos deber&amp;iacute;an reconocer la sintaxis obsoleta, pero nunca producirla.</target>
        </trans-unit>
        <trans-unit id="694230a2ce267bc8d03a82385bbedc868ccb9017" translate="yes" xml:space="preserve">
          <source>The total length could also be limited to 254 characters, per &lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;RFC 3696  errata 1690&lt;/a&gt;.</source>
          <target state="translated">La longitud total tambi&amp;eacute;n podr&amp;iacute;a limitarse a 254 caracteres, seg&amp;uacute;n la &lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;errata RFC 3696 1690&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c409e37bc8b674795dc6985a2965f07b4a91bec" translate="yes" xml:space="preserve">
          <source>There are plenty examples of this out on the net (and I think even one that fully validates the RFC - but it's tens/hundreds of lines long if memory serves). People tend to get carried away validating this sort of thing. Why not just check it has an @ and at least one . and meets some simple minimum length. It's trivial to enter a fake email and still match any valid regex anyway. I would guess that false positives are better than false negatives.</source>
          <target state="translated">Hay muchos ejemplos de esto en la red (y creo que incluso uno que valida completamente el RFC-pero es de diez cientos de líneas si la memoria sirve).La gente tiende a dejarse llevar validando este tipo de cosas.¿Por qué no comprueban que tiene una @ y al menos una...y que cumple con una simple longitud mínima.Es trivial introducir un email falso y aún así coincidir con cualquier regex válido de todos modos.Supongo que los falsos positivos son mejores que los falsos negativos.</target>
        </trans-unit>
        <trans-unit id="e65ce1fdf25d40bc41ca80ae15e74e6206ea4278" translate="yes" xml:space="preserve">
          <source>There is not one which is really usable.</source>
          <target state="translated">No hay ninguna que sea realmente utilizable.</target>
        </trans-unit>
        <trans-unit id="fb8823d7f714e02a82ffff0eff38f0b5686cb83b" translate="yes" xml:space="preserve">
          <source>There is some danger that common usage and widespread sloppy coding will establish a de facto standard for e-mail addresses that is more restrictive than the recorded formal standard.</source>
          <target state="translated">Existe cierto peligro de que el uso común y la codificación descuidada generalizada establezcan una norma de facto para las direcciones de correo electrónico que sea más restrictiva que la norma formal registrada.</target>
        </trans-unit>
        <trans-unit id="eab562daff5b311a461fd5743bafead8320f8ac4" translate="yes" xml:space="preserve">
          <source>There's one problem with translating the RFC syntaxes into regexes: the syntaxes are not regular! This is because they allow for optional comments in email addresses that can be infinitely nested, while infinite nesting can't be described by a regular expression. To scan for or validate addresses containing comments you need a parser or more powerful expressions. (Note that languages like Perl have constructs to describe context free grammars in a regex-like way.) In this answer I'll disregard comments and only consider proper regular expressions.</source>
          <target state="translated">Hay un problema con la traducción de las sintaxis RFC en regex:¡las sintaxis no son regulares! Esto se debe a que permiten comentarios opcionales en las direcciones de correo electrónico que pueden ser anidados infinitamente,mientras que el anidamiento infinito no puede ser descrito por una expresión regular.Para buscar o validar las direcciones que contienen comentarios se necesita un analizador o expresiones más potentes.(Nótese que los lenguajes como Perl tienen construcciones para describir gramáticas libres de contexto de una manera similar a regex).En esta respuesta haré caso omiso de los comentarios y sólo consideraré las expresiones regulares adecuadas.</target>
        </trans-unit>
        <trans-unit id="604bc09674b2ed7a86a57667d281ad5d75b92f79" translate="yes" xml:space="preserve">
          <source>These two considerations could be addressed by parsing the address. The extra length constraint on host names could in some cases also be addressed by using an extra regex that checks it, and matching the address against both expressions.</source>
          <target state="translated">Estas dos consideraciones podrían abordarse analizando la dirección.La limitación de longitud adicional de los nombres de host también podría abordarse en algunos casos utilizando un regex adicional que lo compruebe,y cotejando la dirección con ambas expresiones.</target>
        </trans-unit>
        <trans-unit id="6a6068ef4c671cc993159bd9f7876a710e880eee" translate="yes" xml:space="preserve">
          <source>This intentionally doesn't comply with &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;.</source>
          <target state="translated">Esto intencionalmente no cumple con &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e3c059245745fe56b963a2dd674dc3a620e4611" translate="yes" xml:space="preserve">
          <source>This is a job for a parser, but even if an address is syntactically valid, it still may not be deliverable. Sometimes you have to resort to the hillbilly method of &quot;Hey, y'all, watch ee-us!&quot;</source>
          <target state="translated">Este es un trabajo para un analizador,pero incluso si una dirección es sintácticamente válida,puede que no se pueda entregar.A veces hay que recurrir al método de los paletos de &quot;¡Eh,vosotros,miradnos!&quot;</target>
        </trans-unit>
        <trans-unit id="40bd4785946bbfd84d54b271e863481fe650854b" translate="yes" xml:space="preserve">
          <source>This question is asked a lot, but I think you should step back and ask yourself &lt;em&gt;why&lt;/em&gt; you want to validate email adresses syntactically? What is the benefit really?</source>
          <target state="translated">Esta pregunta se hace mucho, pero creo que deber&amp;iacute;as dar un paso atr&amp;aacute;s y preguntarte &lt;em&gt;por&lt;/em&gt; qu&amp;eacute; quieres validar sint&amp;aacute;cticamente las direcciones de correo electr&amp;oacute;nico. &amp;iquest;Cu&amp;aacute;l es el beneficio realmente?</target>
        </trans-unit>
        <trans-unit id="5b58c52e10b145304d80e39ff92b63c4aaad7cba" translate="yes" xml:space="preserve">
          <source>This regex is from Perl's &lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email::Valid&lt;/a&gt; library. I believe it to be the most accurate, it matches all 822. And, it is based on the regular expression in the O'Reilly book:</source>
          <target state="translated">Esta expresi&amp;oacute;n regular es de la biblioteca &lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email :: Valid&lt;/a&gt; de Perl. Creo que es el m&amp;aacute;s preciso, coincide con los 822. Y se basa en la expresi&amp;oacute;n regular en el libro de O'Reilly:</target>
        </trans-unit>
        <trans-unit id="ab37a40832b8b946cb58d45531219e00bca7eb3a" translate="yes" xml:space="preserve">
          <source>This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module).</source>
          <target state="translated">Esta expresión regular sólo validará las direcciones a las que se les haya quitado algún comentario y se hayan sustituido por espacios en blanco (esto lo hace el módulo).</target>
        </trans-unit>
        <trans-unit id="881eea75af81659120231f1a02a723701d920b5f" translate="yes" xml:space="preserve">
          <source>Use the following regex for input validation:</source>
          <target state="translated">Utilice el siguiente regex para la validación de la entrada:</target>
        </trans-unit>
        <trans-unit id="a38e078061a3af58841a4b63d102b4842c3180b3" translate="yes" xml:space="preserve">
          <source>User input validation</source>
          <target state="translated">Validación de la entrada del usuario</target>
        </trans-unit>
        <trans-unit id="417d6b6f39c552dae06a913e7670f440710547a0" translate="yes" xml:space="preserve">
          <source>Using a regular expression that recognizes email addresses could be useful in various situations: for example to scan for email addresses in a document, to validate user input, or as an integrity constraint on a data repository.</source>
          <target state="translated">El uso de una expresión regular que reconozca las direcciones de correo electrónico podría ser útil en diversas situaciones:por ejemplo,para escanear las direcciones de correo electrónico de un documento,para validar los datos introducidos por el usuario o como una limitación de integridad en un depósito de datos.</target>
        </trans-unit>
        <trans-unit id="7404787d1040c9c25b80ed394962a1fd680b081b" translate="yes" xml:space="preserve">
          <source>When only accepting host names in the domain part (after the @-sign), the regexes above accept only labels with at most 63 characters, as they should. However, they don't enforce the fact that the entire host name must be at most 253 characters long (including the dots). Although this constraint is strictly speaking still regular, it's not feasible to make a regex that incorporates this rule.</source>
          <target state="translated">Cuando sólo se aceptan nombres de host en la parte del dominio (después del signo @),las regexes de arriba sólo aceptan etiquetas con un máximo de 63 caracteres,como deberían.Sin embargo,no imponen el hecho de que el nombre de host completo debe tener como máximo 253 caracteres (incluidos los puntos).Aunque esta limitación sigue siendo,en sentido estricto,regular,no es factible hacer una regex que incorpore esta regla.</target>
        </trans-unit>
        <trans-unit id="6adb4fb8492c6fd0b85a550dd4f05a8dfdfca38d" translate="yes" xml:space="preserve">
          <source>Which is the one used in ASP.NET by the RegularExpressionValidator.</source>
          <target state="translated">Que es el utilizado en ASP.NET por el RegularExpressionValidator.</target>
        </trans-unit>
        <trans-unit id="39672ee698f325ca5854a5b725c41110c115c08f" translate="yes" xml:space="preserve">
          <source>While deciding which characters are allowed, please remember your apostrophed and hyphenated friends. I have no control over the fact that my company generates my email address using my name from the HR system. That includes the apostrophe in my last name. I can't tell you how many times I have been blocked from interacting with a website by the fact that my email address is &quot;invalid&quot;.</source>
          <target state="translated">Mientras deciden qué personajes se permiten,por favor recuerden sus amigos apóstrofes y guiones.No tengo control sobre el hecho de que mi compañía genere mi dirección de correo electrónico usando mi nombre del sistema de recursos humanos.Eso incluye el apóstrofe de mi apellido.No puedo decirle cuántas veces me han bloqueado la interacción con un sitio web por el hecho de que mi dirección de correo electrónico es &quot;inválida&quot;.</target>
        </trans-unit>
        <trans-unit id="040788551c90816319df84a15c3045438d8955bd" translate="yes" xml:space="preserve">
          <source>You could use the one employed by the jQuery Validation plugin:</source>
          <target state="translated">Podrías usar el empleado por el plugin de validación de jQuery:</target>
        </trans-unit>
        <trans-unit id="c0376b0b9474c79623a7bcdd162cc203cdab2051" translate="yes" xml:space="preserve">
          <source>You should allow uppercase alphabets too.  Email systems will normalize the local part and domain part.</source>
          <target state="translated">También deberías permitir los alfabetos en mayúsculas.Los sistemas de correo electrónico normalizarán la parte local y la parte del dominio.</target>
        </trans-unit>
        <trans-unit id="50ecc3e11978eaebf7cdde3eb4723774140d8446" translate="yes" xml:space="preserve">
          <source>You should not use regular expressions to validate email addresses.</source>
          <target state="translated">No debe utilizar expresiones regulares para validar las direcciones de correo electrónico.</target>
        </trans-unit>
        <trans-unit id="379c3a7e829422a79610cb5cbd113ec1b0e6fea0" translate="yes" xml:space="preserve">
          <source>[UPDATED] I've collated everything I know about email address validation here: &lt;a href=&quot;http://isemail.info&quot;&gt;http://isemail.info&lt;/a&gt;, which now not only validates but also diagnoses problems with email addresses. I agree with many of the comments here that validation is only part of the answer; see my essay at &lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/about&lt;/a&gt;.</source>
          <target state="translated">[ACTUALIZADO] He recopilado todo lo que s&amp;eacute; sobre la validaci&amp;oacute;n de direcciones de correo electr&amp;oacute;nico aqu&amp;iacute;: &lt;a href=&quot;http://isemail.info&quot;&gt;http://isemail.info&lt;/a&gt; , que ahora no solo valida sino que tambi&amp;eacute;n diagnostica problemas con las direcciones de correo electr&amp;oacute;nico. Estoy de acuerdo con muchos de los comentarios aqu&amp;iacute; que la validaci&amp;oacute;n es solo una parte de la respuesta; vea mi ensayo en &lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/about&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="782f584cb9f10bfd4e2d20721f3769a1a46ed1e5" translate="yes" xml:space="preserve">
          <source>email =~ &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt;</source>
          <target state="translated">correo electr&amp;oacute;nico = ~ &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb288e30ab07ffc44b2ae8e5468078c1c3d3cd58" translate="yes" xml:space="preserve">
          <source>have a domain part (i.e. the part after the @-sign) that is a host name with at least two labels, each of which is at most 63 characters long.</source>
          <target state="translated">tienen una parte de dominio (es decir,la parte que sigue al signo @)que es un nombre de host con al menos dos etiquetas,cada una de las cuales tiene como máximo 63 caracteres de longitud.</target>
        </trans-unit>
        <trans-unit id="580c167d115747dac91f0ce065f1f0cea9534d8c" translate="yes" xml:space="preserve">
          <source>have a local part (i.e. the part before the @-sign) that is strictly compliant with RFC 5321/5322,</source>
          <target state="translated">tienen una parte local (es decir,la parte anterior al signo @)que cumple estrictamente con el RFC 53215322,</target>
        </trans-unit>
        <trans-unit id="d59803fdebe968a3fc4b59dba8d7638e6988094e" translate="yes" xml:space="preserve">
          <source>if you want to use it in Java its really very easy</source>
          <target state="translated">si quieres usarlo en Java es realmente muy fácil</target>
        </trans-unit>
        <trans-unit id="92fd5a496d47e663c9af65c455e24766e7ce98ef" translate="yes" xml:space="preserve">
          <source>is_email() remains, as far as I know, the only validator that will tell you definitively whether a given string is a valid email address or not. I've upload a new version at &lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/&lt;/a&gt;</source>
          <target state="translated">is_email () sigue siendo, hasta donde yo s&amp;eacute;, el &amp;uacute;nico validador que le dir&amp;aacute; definitivamente si una cadena dada es una direcci&amp;oacute;n de correo electr&amp;oacute;nico v&amp;aacute;lida o no. Sub&amp;iacute; una nueva versi&amp;oacute;n en &lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
