<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/201323">
    <body>
      <group id="201323">
        <trans-unit id="b1b5a828768c114744b0e8c042dc66da113334ec" translate="yes" xml:space="preserve">
          <source>&quot;User Display Name user3@company.com&quot;</source>
          <target state="translated">&quot;ユーザー表示名 user3@company.com</target>
        </trans-unit>
        <trans-unit id="26c2451374584a209014621e5558743bfa2ce56d" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com;user2@gmail.com&quot;</target>
        </trans-unit>
        <trans-unit id="28633028efd2c24861ac4a1740c2217f423b8453" translate="yes" xml:space="preserve">
          <source>&quot;user1@hotmail.com; user2@gmail.com; user3@company.com&quot;</source>
          <target state="translated">&quot;user1@hotmail.com;user2@gmail.com;user3@company.com&quot;</target>
        </trans-unit>
        <trans-unit id="0bc92ef1ed9e5d917df368b9389fccbdd11bbe8d" translate="yes" xml:space="preserve">
          <source>&quot;user4 @company.com&quot;</source>
          <target state="translated">&quot;user4 @company.com&quot;</target>
        </trans-unit>
        <trans-unit id="32f8045af87affeff6f4333e80528d9f758f0dff" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt;)
If you're looking for something simpler but that will catch most valid email addresses try something like:</source>
          <target state="translated">（ &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&lt;/a&gt; ）より簡単なものを探しているのに、ほとんどの有効なメールアドレスをキャッチできる場合は、次のようにしてください。</target>
        </trans-unit>
        <trans-unit id="75f14c0b3eb6f2ddf1a7b788a9c63a1261d191e6" translate="yes" xml:space="preserve">
          <source>(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</source>
          <target state="translated">(?:[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</target>
        </trans-unit>
        <trans-unit id="41c1c65773194544312b0d413e9568defa0fa5f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Cal Henderson&lt;/a&gt; (Flickr) wrote an article called &lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;Parsing Email Adresses in PHP&lt;/a&gt; and shows how to do proper RFC (2)822-compliant Email Address parsing.  You can also get the source code in &lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt;, python and ruby which is &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;cc licensed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.iamcal.com/&quot;&gt;Cal Henderson&lt;/a&gt; （Flickr）が&lt;a href=&quot;http://www.iamcal.com/publish/articles/php/parsing_email/&quot;&gt;PHPでParsing Email Adresses&lt;/a&gt;と呼ばれる記事を書き、適切なRFC（2）822準拠のEメールアドレス解析を行う方法を示しています。 &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.5/&quot;&gt;ccライセンスさ&lt;/a&gt;れている&lt;a href=&quot;http://code.iamcal.com/php/rfc822/&quot;&gt;php&lt;/a&gt; 、python、rubyのソースコードを取得することもできます。</target>
        </trans-unit>
        <trans-unit id="e4215c60a61270d50ef11c83e3925ba93699fa35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt;&lt;em&gt;etc...&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|&quot;([]!#-[^-~ \t]|(\\[\t -~]))+&quot;)@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|&lt;/code&gt; &lt;em&gt;etc ...&lt;/em&gt; &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3654c41e6ade2da259eef5a7ae400fac5827b8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the best regular expression you have or have seen for validating emails?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;メールを検証するために、あなたが見た、または見た中で最も良い正規表現は何ですか？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83da26750665b7eec085cd165f43ccd6b0fe79c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &lt;code&gt;@&lt;/code&gt; character), too vague (after the &lt;code&gt;@&lt;/code&gt; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この要件は、 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322の&lt;/a&gt; &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;意図的な違反&lt;/a&gt;です。RFC5322は 、電子メールアドレスの構文が厳密すぎ（ &lt;code&gt;@&lt;/code&gt; 文字の前）、曖昧すぎ（ &lt;code&gt;@&lt;/code&gt; 文字の後ろ）、緩い（コメント、空白を許可）の構文を定義しています。文字、および引用符で囲まれた文字列（ほとんどのユーザーにとってなじみのない方法で））。</target>
        </trans-unit>
        <trans-unit id="467b846662a13d15de5bbd34d57ea291cf420f2e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;valid e-mail address&lt;/strong&gt; is a string that matches the ABNF production [&amp;hellip;].</source>
          <target state="translated">&lt;strong&gt;有効な電子メールアドレス&lt;/strong&gt;は、ABNFプロダクション[&amp;hellip;]に一致する文字列です。</target>
        </trans-unit>
        <trans-unit id="aef7d848543c3d5b49c4b583603a1e7b9279f10b" translate="yes" xml:space="preserve">
          <source>A common use case is user input validation, for example on an html form. In that case it's usually reasonable to preclude address-literals and to require at least two labels in the hostname. Taking the improved RFC 5321 regex from the previous section as a basis, the resulting expression would be:</source>
          <target state="translated">一般的な使用例としては、例えばhtmlフォームでのユーザ入力の検証があります。この場合、アドレスリテラルを除外し、ホスト名に少なくとも2つのラベルを要求するのが通常は合理的です。前のセクションの改良されたRFC 5321の正規表現を基にすると、結果として得られる式は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7f254b288b513a222b7ce9705affbccd53cd80d8" translate="yes" xml:space="preserve">
          <source>According to official standard &lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822&lt;/a&gt; valid email regex is</source>
          <target state="translated">公式の標準&lt;a href=&quot;http://tools.ietf.org/html/rfc2822#section-3.4.1&quot;&gt;RFC 2822に&lt;/a&gt;よれば、有効なメールの正規表現は</target>
        </trans-unit>
        <trans-unit id="6d2f2f9c03ab4cdaf2b9f2364a0c2799a6329154" translate="yes" xml:space="preserve">
          <source>Addresses matched by this regex:</source>
          <target state="translated">この正規表現にマッチするアドレス。</target>
        </trans-unit>
        <trans-unit id="b75e467be1d8b94588b3cc3f5aaec8acae067ee7" translate="yes" xml:space="preserve">
          <source>After all, the &lt;strong&gt;best&lt;/strong&gt; way to validate the email address is still to actually &lt;em&gt;send&lt;/em&gt; an email to the address in question to validate the address. If the email address is part of user authentication (register/login/etc), then you can perfectly combine it with the user activation system. I.e. send an email with a link with an unique activation key to the specified email address and only allow login when the user has activated the newly created account using the link in the email.</source>
          <target state="translated">結局のところ、電子メールアドレスを検証する&lt;strong&gt;最良の&lt;/strong&gt;方法は、実際に問題のアドレスに電子メールを送信してアドレスを検証することです。 メールアドレスがユーザー認証の一部である場合（登録/ログイン/など）、ユーザーアクティベーションシステムと完全に組み合わせることができます。 つまり、固有のアクティベーションキーのリンクを含むメールを指定のメールアドレスに送信し、ユーザーがメールのリンクを使用して新しく作成したアカウントをアクティベートした場合にのみログインを許可します。</target>
        </trans-unit>
        <trans-unit id="4747783011ffa130857e2027d5ff2eef5ab7e5ce" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part and domain name domain (requiring at least two domain name labels with the TLD limited to 2-6 alphabetic characters).</source>
          <target state="translated">ドットアトムローカルパートとドメイン名ドメインを許可します(TLDがアルファベット2~6文字に制限されているドメイン名ラベルを2つ以上必要とします)。</target>
        </trans-unit>
        <trans-unit id="98f5ff42c06d45b9d6040c487efd8ddaae34384a" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, domain name domain, and (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain.</source>
          <target state="translated">ドットアトムローカルパート、引用符付き文字列ローカルパート、ドメイン名ドメイン、および (IPv4、IPv6、および IPv4 マップ IPv6 アドレス)ドメインリテラルドメインを許可します。</target>
        </trans-unit>
        <trans-unit id="1a501b9511aa2902571ab4411c2d68715c865f16" translate="yes" xml:space="preserve">
          <source>Allows dot-atom local-part, quoted-string local-part, obsolete (mixed dot-atom and quoted-string) local-part, domain name domain, (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain, and (nested) CFWS.</source>
          <target state="translated">dot-atom ローカルパート、quoted-string ローカルパート、廃止された (dot-atom と quoted-string が混在した)ローカルパート、ドメイン名ドメイン、 (IPv4、IPv6、IPv4-mapped IPv6 アドレス)ドメインリテラルドメイン、および (入れ子になった)CFWS を許可します。</target>
        </trans-unit>
        <trans-unit id="137a6c9662b514d8385afe47af02dd62a6fdb560" translate="yes" xml:space="preserve">
          <source>Another consideration, especially when using the regexes for input validation, is feedback to the user. If a user enters an incorrect address, it would be nice to give a little more feedback than a simple &quot;syntactically incorrect address&quot;. With &quot;vanilla&quot; regexes this is not possible.</source>
          <target state="translated">もう一つの考慮点は、特に入力の検証に正規表現を使用する場合、ユーザーへのフィードバックです。ユーザーが誤ったアドレスを入力した場合、単純な「構文的に正しくないアドレス」というフィードバックよりも、もう少し多くのフィードバックを与えることができれば良いでしょう。バニラ」の正規表現ではこれはできません。</target>
        </trans-unit>
        <trans-unit id="7cf149b9d25d2489f954894be6028e467951029a" translate="yes" xml:space="preserve">
          <source>As stated in paragraph 3.1.4. of RFC 822 optional linear white space may be inserted between lexical tokens. Where applicable I've expanded the expressions to accommodate this rule and marked the result with &quot;opt-lwsp&quot;.</source>
          <target state="translated">RFC 822のパラグラフ3.1.4.で述べられているように、任意の線形の空白を字句トークンの間に挿入してもよい。該当する場合は、このルールに対応するために式を拡張し、結果に「opt-lwsp」とマークを付けました。</target>
        </trans-unit>
        <trans-unit id="023052f99d8ae0931ecbe27dc9dbfef6103d1f37" translate="yes" xml:space="preserve">
          <source>As you're writing in PHP I'd advice you to use the PHP build-in validation for emails.</source>
          <target state="translated">PHPで書いているように、PHPのビルドインバリデーションをメールに使うことをアドバイスします。</target>
        </trans-unit>
        <trans-unit id="47bf4436a0ce6299cec6effd82a884e698974efd" translate="yes" xml:space="preserve">
          <source>Basic:</source>
          <target state="translated">Basic:</target>
        </trans-unit>
        <trans-unit id="0073f212804bc3306f849cfa8b512d52e55a727a" translate="yes" xml:space="preserve">
          <source>Confirmation tokens are the only way to know you got the address of the person entering it. This is why most mailing lists now use that mechanism to confirm sign-ups. After all, anybody can put down &lt;code&gt;president@whitehouse.gov&lt;/code&gt;, and that will even parse as legal, but it isn't likely to be the person at the other end.</source>
          <target state="translated">確認トークンは、トークンを入力する人のアドレスを取得したことを確認する唯一の方法です。 これが、現在ほとんどのメーリングリストがそのメカニズムを使用してサインアップを確認する理由です。 結局のところ、誰もがPresident@whitehouse.govを置くことができ、それは合法的にさえ解析されますが、それは反対側の人である可能性は低いです。</target>
        </trans-unit>
        <trans-unit id="8d15eaf92a267e0a03325e52d09f34bab6f23882" translate="yes" xml:space="preserve">
          <source>Context:</source>
          <target state="translated">Context:</target>
        </trans-unit>
        <trans-unit id="f828a4a98f03513a4667164d14af724f3d41a094" translate="yes" xml:space="preserve">
          <source>Correcting the &lt;code&gt;00&lt;/code&gt; bug in the IP pattern, we obtain a working and fairly fast regex.  (Scrape the rendered version, not the markdown, for actual code.)</source>
          <target state="translated">IPパターンの &lt;code&gt;00&lt;/code&gt; バグを修正すると、正常に機能するかなり高速な正規表現を取得できます。 （実際のコードでは、マークダウンではなく、レンダリングされたバージョンをスクレイピングします。）</target>
        </trans-unit>
        <trans-unit id="bf64925120bcbd811e65f1c72f59a3f04f836d22" translate="yes" xml:space="preserve">
          <source>Debuggex Demo</source>
          <target state="translated">Debuggexデモ</target>
        </trans-unit>
        <trans-unit id="61dca52965a9edf91b73613147e9ac7c10c8eeea" translate="yes" xml:space="preserve">
          <source>Different syntaxes should be used for different purposes. If you want to scan for email addresses in a (possibly very old) document it may be a good idea to use the syntax as defined in RFC 822. On the other hand, if you want to validate user input you may want to use the syntax as defined in RFC 5322, probably only accepting canonical representations. You should decide which syntax applies to your specific case.</source>
          <target state="translated">目的に応じて異なる構文を使用する必要があります。もし、(非常に古い可能性のある)文書の中のメールアドレスをスキャンしたいのであれば、RFC 822で定義されている構文を使うのが良いでしょう。一方、ユーザの入力を検証したい場合は、RFC5322で定義されている構文を使用した方が良いでしょう。どの構文が自分の特定のケースに当てはまるかを決めるべきです。</target>
        </trans-unit>
        <trans-unit id="cc6873ddb69d463add1609634358323011bb0f08" translate="yes" xml:space="preserve">
          <source>Don't know about best, but &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;this one&lt;/a&gt; is at least correct, as long as the addresses have their comments stripped and replaced with whitespace.</source>
          <target state="translated">最善の方法はわかりませんが、アドレスのコメントが削除されて空白で置き換えられている限り、 &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;これ&lt;/a&gt;は少なくとも正しいものです。</target>
        </trans-unit>
        <trans-unit id="850a13e5767f580f2031a50d8569b73c2488bbf5" translate="yes" xml:space="preserve">
          <source>EDIT:
From the link:</source>
          <target state="translated">EDIT:リンク先から。</target>
        </trans-unit>
        <trans-unit id="4986de5889e2f11c9bbdb9ef8b2a461042b1376a" translate="yes" xml:space="preserve">
          <source>Elaborate answer</source>
          <target state="translated">精巧な回答</target>
        </trans-unit>
        <trans-unit id="4d171fe5e95a2abcc5be91fb682415349c363bb7" translate="yes" xml:space="preserve">
          <source>For PHP, you should &lt;em&gt;not&lt;/em&gt; use the pattern given in &lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;Validate an E-Mail Address with PHP, the Right Way&lt;/a&gt; from which I quote:</source>
          <target state="translated">PHPの場合、「PHPで&lt;a href=&quot;http://www.linuxjournal.com/article/9585&quot;&gt;電子メールアドレスを検証&lt;/a&gt;する」で説明したパターンを使用し&lt;em&gt;ない&lt;/em&gt;でください。</target>
        </trans-unit>
        <trans-unit id="388c8341169873cbf876d842d5c93f563b812762" translate="yes" xml:space="preserve">
          <source>For a vivid demonstration, the following monster is pretty good but still does not correctly recognize all syntactically valid email addresses: it recognizes nested comments up to four levels deep.</source>
          <target state="translated">鮮やかなデモンストレーションのために、以下のモンスターはかなり良いですが、まだ構文的に有効なすべてのメールアドレスを正しく認識しません:それは4レベルの深さまで入れ子にされたコメントを認識します。</target>
        </trans-unit>
        <trans-unit id="844bb7409b2bf0d129a7300da9332ae49f500e9f" translate="yes" xml:space="preserve">
          <source>For the most comprehensive evaluation of the best regular expression for validating an email address please see this link; &quot;&lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;&quot;</source>
          <target state="translated">電子メールアドレスを検証するための最適な正規表現の最も包括的な評価については、このリンクを参照してください。 「 &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;正規表現を検証する電子メールアドレスの比較&lt;/a&gt; 」</target>
        </trans-unit>
        <trans-unit id="810c3f2bf5a7cff75d30fdb21ab358a9d78d240a" translate="yes" xml:space="preserve">
          <source>For your regex of domain part, domain name cannot starts with '-' and cannot ends with '-'. Dash can only stays in between.</source>
          <target state="translated">ドメイン部分の正規表現では、ドメイン名は'-'で始まり'-'で終わることはできません。ダッシュは間にしか入れられません。</target>
        </trans-unit>
        <trans-unit id="858f135b293e0d7506e7d37d2280ccbde6e7451a" translate="yes" xml:space="preserve">
          <source>Further considerations</source>
          <target state="translated">さらなる検討事項</target>
        </trans-unit>
        <trans-unit id="985180927b564d247d4e14d076eb593cde86c3fb" translate="yes" xml:space="preserve">
          <source>Further restrictions</source>
          <target state="translated">更なる制限</target>
        </trans-unit>
        <trans-unit id="1c80cf144e810a9d98d32782de59c315753f43bf" translate="yes" xml:space="preserve">
          <source>Furthermore, an address having a dot at the end, like &lt;code&gt;user@company.&lt;/code&gt; is accepted by MailAddress as well.</source>
          <target state="translated">さらに、 &lt;code&gt;user@company.&lt;/code&gt; ように、ドットが最後に付いたアドレス。 MailAddressでも受け入れられます。</target>
        </trans-unit>
        <trans-unit id="090fe8536ba48667df2f9156f2408f10a24285d6" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;diagram&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite state machine&lt;/a&gt; for above regexp which is more clear than regexp itself</source>
          <target state="translated">これは、正規表現自体よりも明確な、上記の正規表現の&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;有限状態機械の&lt;/a&gt; &lt;a href=&quot;https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26'*%2B%2F%3D%3F%5E_%60%7B%7C%7D~-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)&quot;&gt;図&lt;/a&gt;です</target>
        </trans-unit>
        <trans-unit id="2a7827f413e7dc52ce89180fc06b75a173a00bb2" translate="yes" xml:space="preserve">
          <source>Here is the current top expression for reference purposes:</source>
          <target state="translated">参考までに現在のトップの表現を紹介します。</target>
        </trans-unit>
        <trans-unit id="f1b99749e961642af10fe964ad761b71345efbe1" translate="yes" xml:space="preserve">
          <source>Here's the PHP I use. I've choosen this solution in the spirit of &quot;false positives are better than false negatives&quot; as declared by another commenter here AND with regards to keeping your response time up and server load down ... there's really no need to waste server resources with a regular expression when this will weed out most simple user error. You can always follow this up by sending a test email if you want.</source>
          <target state="translated">これが私が使用しているPHPです。ここで別のコメンターが宣言しているように、「偽陽性は偽陰性よりも良い」という精神でこの解決策を選択しました。必要であれば、テストメールを送ることでいつでもフォローアップすることができます。</target>
        </trans-unit>
        <trans-unit id="c555de7c7b1f7b703afcbb25f5d37921cd5a5f3c" translate="yes" xml:space="preserve">
          <source>Here's the derivation:</source>
          <target state="translated">これが派生です。</target>
        </trans-unit>
        <trans-unit id="40e3a2be8d888879a228175a976ea9a711b4df90" translate="yes" xml:space="preserve">
          <source>How to validate an email address using a regular expression</source>
          <target state="translated">正規表現を使ってメールアドレスを検証する方法</target>
        </trans-unit>
        <trans-unit id="b7c6fcdddbab0b180253335877c4f6f7061b17bc" translate="yes" xml:space="preserve">
          <source>I also do not recommend explicitly validating against a list of literal top-level domains or even imposing length-constraints (remember how &quot;.museum&quot; invalidated &lt;code&gt;[a-z]{2,4}&lt;/code&gt;), but if you must:</source>
          <target state="translated">また、リテラルトップレベルドメインのリストに対して明示的に検証したり、長さの制約を課したりすることもお勧めしません（ &quot;.museum&quot;が &lt;code&gt;[a-z]{2,4}&lt;/code&gt; 無効化したことを思い出してください）。</target>
        </trans-unit>
        <trans-unit id="6106b21b52d6c2869f1edf73c29f89a75ca99ea7" translate="yes" xml:space="preserve">
          <source>I arrived at the following regular expression. I invite everyone to try and break it. If you find any false positives or false negatives, please post them in a comment and I'll try to fix the expression as soon as possible.</source>
          <target state="translated">次の正規表現にたどり着きました。皆さんもぜひ試しに壊してみてください。誤検出や誤陰性を見つけたらコメントで投稿していただければ、早急に式を修正してみます。</target>
        </trans-unit>
        <trans-unit id="de12597981cafac001a63547fcd2d56956471988" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 5322 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">&lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5322&quot;&gt;エラータ&lt;/a&gt;を含むRFC 5322に完全に準拠していると思います。 正規形式のメールアドレスのみを認識します。 空白を認識する（折りたたむ）正規表現については、以下の派生を参照してください。</target>
        </trans-unit>
        <trans-unit id="89706fb75be6521376b620efafa6099e39529f6f" translate="yes" xml:space="preserve">
          <source>I believe it's fully complient with RFC 822 including the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;errata&lt;/a&gt;. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</source>
          <target state="translated">&lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=822&quot;&gt;エラータ&lt;/a&gt;を含むRFC 822に完全に準拠していると思います。 正規形式のメールアドレスのみを認識します。 空白を認識する（折りたたむ）正規表現については、以下の派生を参照してください。</target>
        </trans-unit>
        <trans-unit id="f512b55ca04846c10d5913e0fe2ed677435f773d" translate="yes" xml:space="preserve">
          <source>I collated test cases from Cal Henderson, Dave Child, Phil Haack, Doug Lovell, RFC5322 and RFC 3696. 275 test addresses in all. I ran all these tests against all the free validators I could find.</source>
          <target state="translated">Cal Henderson、Dave Child、Phil Haack、Doug Lovell、RFC5322、RFC3696のテストケースを照合しました。275個のテストアドレスを集めました。これらのテストはすべて、私が見つけたすべてのフリーのバリデータと照合しました。</target>
        </trans-unit>
        <trans-unit id="8bc4518aeece4f1a66566191f1afe71e2bbca678" translate="yes" xml:space="preserve">
          <source>I discuss some issues in my &lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;answer to Is there a php library for email address validation?&lt;/a&gt;, it is discussed also in &lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;Regexp recognition of email address hard?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582&quot;&gt;メールアドレス検証用のPHPライブラリはありますか？&lt;/a&gt; 、それはまた、 &lt;a href=&quot;https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard&quot;&gt;メールアドレスのRegexp認識で&lt;/a&gt;も難しい議論されていますか？</target>
        </trans-unit>
        <trans-unit id="a8865bf5a399677a2e921d40976a7e3002e86774" translate="yes" xml:space="preserve">
          <source>I do not recommend restricting the local part further, e.g. by precluding quoted strings, since we don't know what kind of mailbox names some hosts allow (like &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; or even &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt;).</source>
          <target state="translated">一部のホストで許可されているメールボックス名の種類（ &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt; や &lt;code&gt;&quot;a b&quot;@example.net&lt;/code&gt; わからないため、ローカル部分をさらに制限することはお勧めしません。たとえば、引用文字列を除外します。ネット ）。</target>
        </trans-unit>
        <trans-unit id="b8e124659a2c24af661cc381668ac370a95c11e1" translate="yes" xml:space="preserve">
          <source>I ignored all the &quot;obs-&quot; rules from the RFC. This means that the regexes only match email addresses that are strictly RFC 5322 compliant. If you have to match &quot;old&quot; addresses (as the looser grammar including the &quot;obs-&quot; rules does), you can use one of the RFC 822 regexes from the previous paragraph.</source>
          <target state="translated">私はRFCの &quot;obs-&quot;ルールをすべて無視しました。つまり、正規表現は厳密にはRFC 5322に準拠したメールアドレスにしかマッチしないということです。もし「古い」アドレスにマッチさせなければならない場合は(「obs-」ルールを含む緩い文法がそうであるように)、前の段落にあったRFC 822の正規表現のいずれかを使うことができます。</target>
        </trans-unit>
        <trans-unit id="062a5233c8de0b33af018e4eeae4a1ba0c95916d" translate="yes" xml:space="preserve">
          <source>I never bother creating with my own regular expression, because chances are that someone else has already come up with a better version.  I always use &lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib&lt;/a&gt; to find one to my liking.</source>
          <target state="translated">私は自分の正規表現を使って作成することはありません。誰か他の人がすでにより良いバージョンを考えている可能性があるからです。 私はいつも&lt;a href=&quot;http://regexlib.com/Search.aspx&quot;&gt;regexlib&lt;/a&gt;を使って自分の好みに合ったものを見つけています。</target>
        </trans-unit>
        <trans-unit id="088e64f9ee7f255c4c5eac7974a7114e20492d11" translate="yes" xml:space="preserve">
          <source>I use</source>
          <target state="translated">私は</target>
        </trans-unit>
        <trans-unit id="6795b75201299955c1b7995c570b13d659921b18" translate="yes" xml:space="preserve">
          <source>I use POSIX &quot;extended&quot; regular expressions in this answer, assuming an ASCII compatible character set.</source>
          <target state="translated">この回答では、ASCII互換の文字セットを想定して、POSIX「拡張」正規表現を使用しています。</target>
        </trans-unit>
        <trans-unit id="56d0d3ff30df9317fddde67f83205c8cb0ff3cec" translate="yes" xml:space="preserve">
          <source>I use it in several PHP programs, and it works most of the time.  However, from time to time I get contacted by someone that is having trouble with a site that uses it, and I end up having to make some adjustment (most recently I realized that I wasn't allowing 4-character TLDs).</source>
          <target state="translated">私はいくつかの PHP プログラムでそれを使用しており、ほとんどの時間で動作します。しかし、時々、それを使用しているサイトで問題を抱えている人から連絡があり、私はいくつかの調整をしなければならないことになってしまいます(最近では、私は4文字のTLDを許可していないことに気付きました)。</target>
        </trans-unit>
        <trans-unit id="034d131aacb2134a772bdf60fff06a86578e9c3f" translate="yes" xml:space="preserve">
          <source>I'll try to keep this page up-to-date as people enhance their validators. Thanks to Cal, Michael, Dave, Paul and Phil for their help and co-operation in compiling these tests and constructive criticism of &lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;my own validator&lt;/a&gt;.</source>
          <target state="translated">人々がバリデーターを強化している間、私はこのページを最新の状態に保つよう努めます。 Cal、Michael、Dave、Paul、Philは、これらのテストのコンパイルと&lt;a href=&quot;http://code.google.com/p/isemail&quot;&gt;私の検証者の&lt;/a&gt;建設的な批判に対する協力と協力に感謝します。</target>
        </trans-unit>
        <trans-unit id="8588212a8c9ffe41b9ef89fa0c2610e960516246" translate="yes" xml:space="preserve">
          <source>I've seen several solutions that use functions that use several shorter expressions, but I'd rather have one long complex expression in a simple function instead of several short expression in a more complex function.</source>
          <target state="translated">短い式をいくつか使う関数を使う解決策はいくつか見たことがありますが、もっと複雑な関数で短い式をいくつか使うよりも、単純な関数で長い複雑な式を1つ使った方がいいですね。</target>
        </trans-unit>
        <trans-unit id="725e5ed871d70812fff5a898374748169242406b" translate="yes" xml:space="preserve">
          <source>If the purpose of the regex is just to quickly inform the user in the UI that the specified email address doesn't look like in the right format, best is still to check if it matches basically the following regex:</source>
          <target state="translated">正規表現の目的が、指定したメールアドレスが正しい形式に見えないことをUIでユーザーに素早く知らせることだけであれば、基本的には以下の正規表現と一致するかどうかを確認するのがベストです。</target>
        </trans-unit>
        <trans-unit id="64cac7449f582a2dc109b435c4145c5f430d12f4" translate="yes" xml:space="preserve">
          <source>If you plan to use the &lt;code&gt;MailAddress&lt;/code&gt; to validate the e-mail address, be aware that this approach accepts the display name part of the e-mail address as well, and that may not be exactly what you want to achieve. For example, it accepts these strings as valid e-mail addresses:</source>
          <target state="translated">&lt;code&gt;MailAddress&lt;/code&gt; を使用して電子メールアドレスを検証する場合は、この方法が電子メールアドレスの表示名部分も受け入れることに注意してください。これは、 意図したとおりではない場合があることに注意してください。 たとえば、次の文字列を有効な電子メールアドレスとして受け入れます。</target>
        </trans-unit>
        <trans-unit id="99811d1346d22a72366acd0b3ff9e1075ab2e9fc" translate="yes" xml:space="preserve">
          <source>If you really want to use a regex, &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;here it is&lt;/a&gt;:</source>
          <target state="translated">あなたが本当に正規表現を使いたいなら、 &lt;a href=&quot;http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;ここにあり&lt;/a&gt;ます：</target>
        </trans-unit>
        <trans-unit id="44ce491ec374723f385ed8ad3f99125bd8e8fe92" translate="yes" xml:space="preserve">
          <source>If you used the PEAR library, check out their mail function (forgot the exact name/library).  You can validate email address by calling one function, and it validates the email address according to definition in RFC822.</source>
          <target state="translated">PEAR ライブラリを使っている場合は、その mail 関数 (正確な名前は忘れました)を調べてみてください。1つの関数を呼び出すことでメールアドレスの検証を行うことができ、RFC822で定義されているメールアドレスの検証を行ってくれます。</target>
        </trans-unit>
        <trans-unit id="89fdaa410759db94e2b5de2465bd333dc0953efc" translate="yes" xml:space="preserve">
          <source>If you want more information how this buid-in validation works, see here: &lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;Does PHP's filter_var FILTER_VALIDATE_EMAIL actually work?&lt;/a&gt;</source>
          <target state="translated">この組み込み検証がどのように機能するかについて詳しく知りたい場合は、こちらを参照してください&lt;a href=&quot;https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work&quot;&gt;。PHPのfilter_var FILTER_VALIDATE_EMAILは実際に機能しますか？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c40d3684b422bc8ff6e3c9362de5de71480237e" translate="yes" xml:space="preserve">
          <source>If you want to get fancy and pedantic, &lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;implement a complete state engine&lt;/a&gt;. A regular expression can only act as a rudimentary filter. The problem with regular expressions is that telling someone that their perfectly valid e-mail address is invalid (a false positive) because your regular expression can't handle it is just rude and impolite from the user's perspective. A state engine for the purpose can both validate and even correct e-mail addresses that would otherwise be considered invalid as it disassembles the e-mail address according to each RFC. This allows for a potentially more pleasing experience, like</source>
          <target state="translated">凝ったものにしたい場合は&lt;a href=&quot;http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html&quot;&gt;、完全な状態エンジンを実装してください&lt;/a&gt; 。 正規表現は、基本的なフィルターとしてのみ機能します。 正規表現の問題は、正規表現で処理できないため、完全に有効な電子メールアドレスが無効（誤検知）であることを誰かに伝えることは、ユーザーの観点から見ると失礼で失礼です。 目的のための状態エンジンは、各RFCに従って電子メールアドレスを逆アセンブルするために無効と見なされる電子メールアドレスを検証し、修正することもできます。 これにより、次のような潜在的により楽しい体験が可能になります</target>
        </trans-unit>
        <trans-unit id="15c3b1fffdba1f0e987fbd41a9b09407c2fdc511" translate="yes" xml:space="preserve">
          <source>If you want to validate that an email is correct, you have no choice than to send an confirmation email and have the user reply to that. In many cases you will &lt;em&gt;have&lt;/em&gt; to send a confirmation mail anyway for security reasons or for ethical reasons (so you cannot e.g. sign someone up to a service against their will).</source>
          <target state="translated">メールが正しいことを検証したい場合は、確認メールを送信してユーザーに返信する以外に選択肢はありません。 多くの場合、セキュリティ上の理由や倫理上の理由で確認メールを送信する必要があります（そのため、たとえば意志に反してサービスにサインアップすることはできません）。</target>
        </trans-unit>
        <trans-unit id="8f90c8045d52f4b058334a51ed4880471694677d" translate="yes" xml:space="preserve">
          <source>If you're running a php-version lower than 5.3.6 please be aware of this issue: &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https://bugs.php.net/bug.php?id=53091&lt;/a&gt;</source>
          <target state="translated">5.3.6より前のphp-versionを実行している場合は、この問題に注意してください： &lt;a href=&quot;https://bugs.php.net/bug.php?id=53091&quot;&gt;https&lt;/a&gt; : //bugs.php.net/bug.php?id=53091</target>
        </trans-unit>
        <trans-unit id="bfe401233bd6300cf11a6837adc1067496b852ea" translate="yes" xml:space="preserve">
          <source>In short, don't expect a single, usable regex to do a proper job. And the best regex will validate the syntax, not the validity of an e-mail (jhohn@example.com is correct but it will probably bounce...).</source>
          <target state="translated">要するに、単一の使える正規表現が適切な仕事をしてくれると期待してはいけないということです。そして、最良の正規表現は、電子メールの有効性ではなく、構文を検証するものです (jhohn@example.com は正しいですが、おそらくバウンスされます...)。</target>
        </trans-unit>
        <trans-unit id="d64fa0e517911923332fac4e2f71d913ad55f9db" translate="yes" xml:space="preserve">
          <source>In some of these cases, only the last part of the strings is parsed as the address; the rest before that is the display name. To get a plain e-mail address without any display name, you can check the normalized address against your original string.</source>
          <target state="translated">これらのケースの中には、文字列の最後の部分だけがアドレスとして解析され、その前の残りの部分が表示名となります。表示名のないプレーンなメールアドレスを取得するには、正規化されたアドレスを元の文字列と照合することができます。</target>
        </trans-unit>
        <trans-unit id="92b6aee3575856478de82d957aae0862c153d512" translate="yes" xml:space="preserve">
          <source>In this answer I&amp;rsquo;ll take &amp;ldquo;email address&amp;rdquo; to mean &lt;code&gt;addr-spec&lt;/code&gt; as defined in the RFCs (i.e. &lt;code&gt;jdoe@example.org&lt;/code&gt;, but not &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt;, nor &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt;).</source>
          <target state="translated">この回答では、RFCで定義されている &lt;code&gt;addr-spec&lt;/code&gt; （つまり、 &lt;code&gt;some-group:jdoe@example.org,mrx@exampel.org;&lt;/code&gt; &lt;code&gt;&quot;John Doe&quot;&amp;lt;jdoe@example.org&amp;gt;&lt;/code&gt; を意味しますが、 「John Doe」&amp;lt;jdoe@example.org&amp;gt;やsome-group：jdoe @は意味しません）を「メールアドレス」と解釈します。 example.org、mrx @ exampel.org; ）。</target>
        </trans-unit>
        <trans-unit id="29a575c86979b44c2fb0c43aa9e0d6c7884de728" translate="yes" xml:space="preserve">
          <source>Instead, use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt; class, like this:</source>
          <target state="translated">代わりに、次のように&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx&quot;&gt;MailAddress&lt;/a&gt;クラスを使用します。</target>
        </trans-unit>
        <trans-unit id="bb3cb298c6dabff17c93f08e57db5b7c214514b7" translate="yes" xml:space="preserve">
          <source>It all depends on how accurate you want to be.  For my purposes, where I'm just trying to keep out things like &lt;code&gt;bob @ aol.com&lt;/code&gt; (spaces in emails) or &lt;code&gt;steve&lt;/code&gt; (no domain at all) or &lt;code&gt;mary@aolcom&lt;/code&gt; (no period before .com), I use</source>
          <target state="translated">それはすべて、あなたがなりたい精度に依存します。 私の目的のために、私は &lt;code&gt;bob @ aol.com&lt;/code&gt; （電子メール内のスペース）または &lt;code&gt;steve&lt;/code&gt; （ドメインなし）または &lt;code&gt;mary@aolcom&lt;/code&gt; （.comの前のピリオドなし）などのことを避けようとしているだけで、</target>
        </trans-unit>
        <trans-unit id="55c558aed4449d4838de9ba71870504efebc5f4d" translate="yes" xml:space="preserve">
          <source>It depends on what you mean by best:
If you're talking about catching every valid email address use the following:</source>
          <target state="translated">何がベストかは、あなたが何を意味するかによります。すべての有効なメールアドレスをキャッチすることについて話しているのであれば、以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="634ea515e24f27b27c16f1ac8df53108713d9618" translate="yes" xml:space="preserve">
          <source>It does not prevent people from entering invalid or made-up email addresses, or entering someone else's address.</source>
          <target state="translated">無効なメールアドレスやでっち上げのメールアドレスを入力したり、他人のアドレスを入力したりすることを防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="ef282074cd0ee12c9819b8667cca979a4d908a32" translate="yes" xml:space="preserve">
          <source>It should however be noted that if you want to find out if the address actually refers to an existing mailbox, there's no substitute for sending a message to the address. If you only want to check if an address is grammatically correct then you could use a regular expression, but note that &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; is a grammatically correct email address that certainly doesn't refer to an existing mailbox.</source>
          <target state="translated">ただし、アドレスが実際に既存のメールボックスを参照しているかどうかを確認する場合は、そのアドレスにメッセージを送信する以外の方法はありません。 アドレスが文法的に正しいかどうかのみを確認したい場合は、正規表現を使用できますが、 &lt;code&gt;&quot;&quot;@[]&lt;/code&gt; は文法的に正しいメールアドレスであり、既存のメールボックスを参照しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="cc84b5c5472043636abf125126a167f8104cf798" translate="yes" xml:space="preserve">
          <source>It will not catch common typos.</source>
          <target state="translated">よくある誤字脱字をキャッチすることはできません。</target>
        </trans-unit>
        <trans-unit id="748495ccfc92d4a51e5e47b57ba34035d4c9f075" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy in Perl 5.10 or newer:</source>
          <target state="translated">Perl 5.10以降では簡単です。</target>
        </trans-unit>
        <trans-unit id="c36addb1f9a0630cf0fa05910cfe747100da3dcb" translate="yes" xml:space="preserve">
          <source>It's also important to understand that validating it per the RFC tells you absolutely nothing about whether that address actually exists at the supplied domain, or whether the person entering the address is its true owner. People sign others up to mailing lists this way all the time. Fixing that requires a fancier kind of validation that involves sending that address a message that includes a confirmation token meant to be entered on the same web page as was the address.</source>
          <target state="translated">また、RFC に基づいて検証しても、そのアドレスが提供されたドメインに実際に存在するかどうかや、 アドレスを入力した人がそのアドレスの真の所有者であるかどうかについては何もわからないということを理解しておくことも重要です。人々はいつもこの方法で他人をメーリングリストに登録しています。これを修正するには、そのアドレスと同じウェブページで入力された確認用のトークンを含むメッセージをそのアドレスに送信するという、より高度な検証が必要になります。</target>
        </trans-unit>
        <trans-unit id="59fc40df1759e098dcd512bdd762d89c1c4815c1" translate="yes" xml:space="preserve">
          <source>Make sure to keep your regex up-to-date if you decide to go down the path of explicit top-level domain validation.</source>
          <target state="translated">明示的なトップレベルドメインの検証を行う場合は、正規表現を最新の状態に保つようにしてください。</target>
        </trans-unit>
        <trans-unit id="aa2ea3e7fb557b8b8b13fa28afb31c3928419cfd" translate="yes" xml:space="preserve">
          <source>None of the regexes in this answer are optimized for performance. If performance is an issue, you should see if (and how) the regex of your choice can be optimized.</source>
          <target state="translated">この回答にある正規表現は、どれもパフォーマンスが最適化されていません。パフォーマンスが問題になる場合は、選択した正規表現が最適化されるかどうか(そしてどのようにして)確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="2a469b7426fdfa686180a96ef3fe9463e2cbdbd8" translate="yes" xml:space="preserve">
          <source>Not to mention that non-Latin (Chinese, Arabic, Greek, Hebrew, Cyrillic and so on) domain names are to be allowed in the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;near future&lt;/a&gt;. Everyone has to change the email regex used, because those characters are surely not to be covered by &lt;code&gt;[a-z]/i&lt;/code&gt; nor &lt;code&gt;\w&lt;/code&gt;. They will all fail.</source>
          <target state="translated">ラテン語以外のドメイン名（中国語、アラビア語、ギリシャ語、ヘブライ語、キリル文字など）が&lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;近い将来に&lt;/a&gt;許可されることは言うまでもありません。 これらの文字は確かに &lt;code&gt;[a-z]/i&lt;/code&gt; や &lt;code&gt;\w&lt;/code&gt; 対象ではないため、使用するメールの正規表現を変更する必要があります。 それらはすべて失敗します。</target>
        </trans-unit>
        <trans-unit id="ed883c2a93aaa8eff111b58e6939a3cdb4b3d6af" translate="yes" xml:space="preserve">
          <source>Note that depending on the use case you may not want to allow for a &quot;General-address-literal&quot; in your regex. Also note that I used a negative lookahead &lt;code&gt;(?!IPv6:)&lt;/code&gt; in the final regex to prevent the &quot;General-address-literal&quot; part to match malformed IPv6 addresses. Some regex processors don't support negative lookahead. Remove the substring &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; from the regex if you want to take the whole &quot;General-address-literal&quot; part out.</source>
          <target state="translated">ユースケースによっては、正規表現で「General-address-literal」を許可したくない場合があることに注意してください。 また、最終的な正規表現で否定先読み &lt;code&gt;(?!IPv6:)&lt;/code&gt; を使用して、「General-address-literal」の部分が不正な形式のIPv6アドレスと一致しないようにしたことにも注意してください。 一部の正規表現プロセッサは、否定先読みをサポートしていません。 全体を取得する場合は、部分文字列 &lt;code&gt;|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+&lt;/code&gt; を正規表現から削除します「一般住所リテラル」の一部が除外されました。</target>
        </trans-unit>
        <trans-unit id="1603724f5f43f1edae560e9739defad7e033ecee" translate="yes" xml:space="preserve">
          <source>Note that some sources (notably &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt;) claim that RFC 5322 is too strict on the local part (i.e. the part before the @-sign). This is because &quot;..&quot;, &quot;a..b&quot; and &quot;a.&quot; are &lt;em&gt;not&lt;/em&gt; valid dot-atoms, while they may be used as mailbox names. The RFC, however, &lt;em&gt;does&lt;/em&gt; allow for local parts like these, except that they have to be quoted. So instead of &lt;code&gt;a..b@example.net&lt;/code&gt; you should write &lt;code&gt;&quot;a..b&quot;@example.net&lt;/code&gt;, which is semantically equivalent.</source>
          <target state="translated">一部のソース（特に&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;w3c&lt;/a&gt; ）は、RFC 5322がローカル部分（つまり、@記号の前の部分）に対して厳格すぎると主張していることに注意してください。 これは、「..」、「a..b」、「a。」のためです。 有効なドットアトムではあり&lt;em&gt;ません&lt;/em&gt;が、メールボックス名として使用される場合があります。 ただし、RFCは、引用符で囲む必要があることを除いて、これらのようなローカル部分を許可します。 したがって、 &lt;code&gt;a..b@example.net&lt;/code&gt; 代わりに、「 a..b」@ example.netと記述する必要があります 。これは、意味的に同等です。</target>
        </trans-unit>
        <trans-unit id="a414e2438f7c9cf87c83b4983b266d69534ed05a" translate="yes" xml:space="preserve">
          <source>Note: This requirement is a &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;willful violation&lt;/a&gt; of &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &amp;ldquo;@&amp;rdquo; character), too vague (after the &amp;ldquo;@&amp;rdquo; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</source>
          <target state="translated">注：この要件は、 &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322の&lt;/a&gt; &lt;a href=&quot;http://www.w3.org/TR/html5/introduction.html#willful-violation&quot;&gt;意図的な違反&lt;/a&gt;です。RFC5322は 、電子メールアドレスの構文が厳密すぎ（「@」文字の前）、曖昧すぎ（「@」文字の後）、緩い（ここでは、コメント、空白文字、引用符付き文字列をほとんどのユーザーに馴染みのない方法で使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="a60dff653e359c769e135e4c04c6e895ea0123b7" translate="yes" xml:space="preserve">
          <source>One RFC 5322 compliant regex can be found at the top of the page at &lt;a href=&quot;http://emailregex.com/&quot;&gt;http://emailregex.com/&lt;/a&gt; but uses the IP address pattern that is floating around the internet with a bug that allows &lt;code&gt;00&lt;/code&gt; for any of the unsigned byte decimal values in a dot-delimited address, which is illegal.  The rest of it appears to be consistent with the RFC 5322 grammar and passes several tests using &lt;code&gt;grep -Po&lt;/code&gt;, including cases domain names, IP addresses, bad ones, and account names with and without quotes.</source>
          <target state="translated">1つのRFC 5322準拠の正規表現は、 &lt;a href=&quot;http://emailregex.com/&quot;&gt;http：//emailregex.com/&lt;/a&gt;のページの上部にありますが、インターネット上をフロートするIPアドレスパターンを使用します。不正なドット区切りアドレス。 残りの部分はRFC 5322の文法と一致しているように &lt;code&gt;grep -Po&lt;/code&gt; 、 grep -Poを使用して、ドメイン名、IPアドレス、不正なもの、引用符付きまたは引用符なしのアカウント名など、いくつかのテストに合格しています。</target>
        </trans-unit>
        <trans-unit id="6849c03183bc687fc66af67fdc8fab74faf61cad" translate="yes" xml:space="preserve">
          <source>One simple regular expression which would at least not reject any valid email address would be checking for something, followed by an @ sign and then something followed by a period and at least 2 somethings. It won't reject anything, but after reviewing the spec I can't find any email that would be valid and rejected.</source>
          <target state="translated">少なくとも有効なメールアドレスを拒否しない単純な正規表現は、何かをチェックして、@記号の後に何か、ピリオドの後に何か、そして最低でも2つの何かをチェックします。これでは何も拒否されませんが、仕様書を確認したところ、有効で拒否されるメールが見つかりません。</target>
        </trans-unit>
        <trans-unit id="eacf0af0cb780f7e0cc0c41e3539fd563e478436" translate="yes" xml:space="preserve">
          <source>Over the years I have slowly developed a &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; that validates MOST email addresses correctly, assuming they don't use an IP address as the server part.</source>
          <target state="translated">長年にわたり、サーバーの一部としてIPアドレスを使用しないことを前提として、MOSTメールアドレスを正しく検証する&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;正規表現&lt;/a&gt;を徐々に開発してきました。</target>
        </trans-unit>
        <trans-unit id="4e44c1594bc79271466627aea4dc6d92f45efa87" translate="yes" xml:space="preserve">
          <source>People should be aware of the &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;errata against RFC 3696&lt;/a&gt; in particular. Three of the canonical examples are in fact invalid addresses. And the maximum length of an address is 254 or 256 characters, &lt;strong&gt;not&lt;/strong&gt; 320.</source>
          <target state="translated">特に&lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=3696&quot;&gt;RFC 3696に対するエラッタに&lt;/a&gt;注意する必要があります。 正規の3つの例は、実際には無効なアドレスです。 また、アドレスの最大長は、320では&lt;strong&gt;なく&lt;/strong&gt; 、254または256文字です。</target>
        </trans-unit>
        <trans-unit id="d39c523f1fb1d41ff6e8a68ec88d7d3a31a24cd0" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;the W3C HTML5 spec&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;W3C HTML5仕様に従って&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="56c0dad2b0956cd6ae32504c979c840f02cf3573" translate="yes" xml:space="preserve">
          <source>Quick answer</source>
          <target state="translated">クイックアンサー</target>
        </trans-unit>
        <trans-unit id="fa2251418aa68903f6488427bde3d8e415a9f16a" translate="yes" xml:space="preserve">
          <source>RFC 5321 basically leaves alone the &quot;local&quot; part (i.e. the part before the @-sign), but is stricter on the domain part (i.e. the part after the @-sign). It allows only host names in place of dot-atoms and address literals in place of domain literals.</source>
          <target state="translated">RFC 5321は基本的には「ローカル」の部分(すなわち@記号の前の部分)だけを残すが、 ドメインの部分(すなわち@記号の後の部分)についてはより厳格である。これは、ドットアトムの代わりにホスト名のみを許可し、ドメインリテラルの代わりにアドレスリテラルを許可しています。</target>
        </trans-unit>
        <trans-unit id="82af36243c542be2f1bd3a5fa7459b1dbce36d81" translate="yes" xml:space="preserve">
          <source>RFC 5321 standard:</source>
          <target state="translated">RFC 5321規格に準拠しています。</target>
        </trans-unit>
        <trans-unit id="17c58504badf8c1787c4ac4f95c466fc696f2e50" translate="yes" xml:space="preserve">
          <source>RFC 5322</source>
          <target state="translated">RFC53222</target>
        </trans-unit>
        <trans-unit id="479d36b78205a178de44b9bbbe339cec9f59000b" translate="yes" xml:space="preserve">
          <source>RFC 5322 standard:</source>
          <target state="translated">RFC 5322規格。</target>
        </trans-unit>
        <trans-unit id="00af815762ae4e4ed879f00aa53f3fc9fc817b37" translate="yes" xml:space="preserve">
          <source>RFC 822</source>
          <target state="translated">RFC八百二十二</target>
        </trans-unit>
        <trans-unit id="fd412bb5a3c2ad14d277d7a4b79b8f75df43ce9c" translate="yes" xml:space="preserve">
          <source>Regular expression built using Jeffrey Friedl's example in
  &lt;em&gt;Mastering Regular Expressions&lt;/em&gt; (&lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt;).</source>
          <target state="translated">正規表現の&lt;em&gt;習得&lt;/em&gt; （ &lt;a href=&quot;http://www.ora.com/catalog/regexp/&quot;&gt;http://www.ora.com/catalog/regexp/&lt;/a&gt; ）のJeffrey Friedlの例を使用して構築された正規表現。</target>
        </trans-unit>
        <trans-unit id="4fa9d019350b110a4ff197daf305ce272d79f6ae" translate="yes" xml:space="preserve">
          <source>SMTP (as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321&lt;/a&gt;) further restricts the set of valid email addresses (or actually: mailbox names). It seems reasonable to impose this stricter grammar, so that the matched email address can actually be used to send an email.</source>
          <target state="translated">SMTP（ &lt;a href=&quot;http://tools.ietf.org/html/rfc5321&quot;&gt;RFC 5321で&lt;/a&gt;定義）は、有効な電子メールアドレス（または実際にはメールボックス名）のセットをさらに制限します。 この厳密な文法を課すことは合理的であるように思われます。そのため、一致した電子メールアドレスを実際に使用して電子メールを送信できます。</target>
        </trans-unit>
        <trans-unit id="2e509ea11bcd91c64419ceb313b8fded4cfb62a1" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;Validating Email Addresses&lt;/a&gt;, including the comments. Or &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;Comparing E-mail Address Validating Regular Expressions&lt;/a&gt;.</source>
          <target state="translated">コメントを含む&lt;a href=&quot;http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx&quot;&gt;電子メールアドレスの検証&lt;/a&gt;も参照してください。 または、 &lt;a href=&quot;http://fightingforalostcause.net/misc/2006/compare-email-regex.php&quot;&gt;正規表現を検証する電子メールアドレスを比較し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="53a9c322bf8ce66569059aa3e1529b8bee955c35" translate="yes" xml:space="preserve">
          <source>Seriously. You should use an already written library for validating emails. The best way is probably to just send a verification e-mail to that address.</source>
          <target state="translated">真面目な話。メールの検証には、すでに書かれているライブラリを使うべきです。一番いいのは、そのアドレスに検証用のメールを送るだけでいいのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="a143d6225e75c2b766a2aee66d8dfbc3d273186e" translate="yes" xml:space="preserve">
          <source>Simple as that. Why on earth would you care about the characters used in the name and domain? It's the client's responsibility to enter a valid email address, not the server's. Even when the client enters a &lt;em&gt;syntactically&lt;/em&gt; valid email address like &lt;code&gt;aa@bb.cc&lt;/code&gt;, this does not guarantee that it's a legit email address. No one regex can cover that.</source>
          <target state="translated">そのような単純な。 名前とドメインで使用されている文字をどうして気にするのですか？ サーバーではなく、有効な電子メールアドレスを入力するのはクライアントの責任です。 クライアントが &lt;code&gt;aa@bb.cc&lt;/code&gt; のような&lt;em&gt;構文的に&lt;/em&gt;有効なメールアドレスを入力した場合でも、これが正当なメールアドレスであることを保証するものではありません。 正規表現でそれをカバーすることはできません。</target>
        </trans-unit>
        <trans-unit id="056115c235bea2846acb135ffdbd27cd4ae8abc4" translate="yes" xml:space="preserve">
          <source>Strange that you &quot;cannot&quot; allow 4 characters TLDs.  You are banning people from &lt;em&gt;.info&lt;/em&gt; and &lt;em&gt;.name&lt;/em&gt;, and the length limitation stop &lt;em&gt;.travel&lt;/em&gt; and &lt;em&gt;.museum&lt;/em&gt;, but yes, they are less common than 2 characters TLDs and 3 characters TLDs.</source>
          <target state="translated">奇妙なことに、4文字のTLDを許可することはできません。 あなたは&lt;em&gt;.info&lt;/em&gt;と&lt;em&gt;.name&lt;/em&gt;からの人々を禁止し、長さ制限は&lt;em&gt;.travel&lt;/em&gt;と&lt;em&gt;.museumを&lt;/em&gt;停止し&lt;em&gt;ます&lt;/em&gt;が、そうです、それらは2文字のTLDと3文字のTLDより一般的ではありません。</target>
        </trans-unit>
        <trans-unit id="6cbd3caa8bdfcbb5ef664dabf829fa863056ac8a" translate="yes" xml:space="preserve">
          <source>Sure, it will match things that aren't valid email addresses, but it's a matter of playing the 90/10 rule.</source>
          <target state="translated">確かに、有効なメールアドレスではないものにはマッチしますが、9010ルールで勝負することになります。</target>
        </trans-unit>
        <trans-unit id="af4c67c3df524d5adb915aacca975c4f92acf0be" translate="yes" xml:space="preserve">
          <source>That is no better than all the other non-RFC patterns. It isn&amp;rsquo;t even smart enough to handle even &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt;, let alone RFC 5322. &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;This one&lt;/a&gt;, however, is.</source>
          <target state="translated">これは、他のすべての非RFCパターンと同じです。 RFC 5322は言うまでもなく、 &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC 822&lt;/a&gt;を処理するのにも十分スマートではありません。しかし、 &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;これ&lt;/a&gt;はそうです。</target>
        </trans-unit>
        <trans-unit id="8a8b13790b55067f7d02a02213bba322543be649" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;fully RFC 822 compliant regex&lt;/a&gt; is inefficient and obscure because of its length.  Fortunately, RFC 822 was superseded twice and the current specification for email addresses is &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt;.  RFC 5322 leads to a regex that can be understood if studied for a few minutes and is efficient enough for actual use.</source>
          <target state="translated">&lt;a href=&quot;http://ex-parrot.com/~pdw/Mail-RFC822-Address.html&quot;&gt;RFC 822に完全に準拠した正規表現&lt;/a&gt;は、その長さのために非効率であいまいです。 さいわい、RFC 822は2回置き換えられ、電子メールアドレスの現在の仕様は&lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;RFC 5322&lt;/a&gt;です。 RFC 5322は正規表現につながります。これは、数分間調べれば理解でき、実際の使用には十分効率的です。</target>
        </trans-unit>
        <trans-unit id="efef7583ce1f5955d8622631b97ef21d277e0c78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5 spec suggests&lt;/a&gt; a simple regex for validating email addresses:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/html5/forms.html#valid-e-mail-address&quot;&gt;HTML5仕様では&lt;/a&gt; 、メールアドレスを検証するための簡単な正規表現を提案しています。</target>
        </trans-unit>
        <trans-unit id="cc7666184f88738787a730cc2f788c93befa5c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MailAddress&lt;/code&gt; class uses a BNF parser to validate the address in full accordance with RFC822.</source>
          <target state="translated">&lt;code&gt;MailAddress&lt;/code&gt; クラスは、BNFパーサーを使用して、RFC822に完全に準拠したアドレスを検証します。</target>
        </trans-unit>
        <trans-unit id="08094c7e000914320983bbc93438575ec83bb464" translate="yes" xml:space="preserve">
          <source>The RFCs define syntaxes for email messages, not for email addresses as such. Addresses may appear in various header fields and this is where they are primarily defined. When they appear in header fields addresses may contain (between lexical tokens) whitespace, comments and even linebreaks. Semantically this has no significance however. By removing this whitespace, etc. from an address you get a semantically equivalent &lt;em&gt;canonical representation&lt;/em&gt;. Thus, the canonical representation of &lt;code&gt;first. last (comment) @   [3.5.7.9]&lt;/code&gt; is &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt;.</source>
          <target state="translated">RFCは、電子メールアドレス自体ではなく、電子メールメッセージの構文を定義します。 アドレスはさまざまなヘッダーフィールドに表示される可能性があり、ここで主に定義されます。 それらがヘッダーフィールドに表示されるとき、アドレスには（字句トークン間で）空白、コメント、さらには改行が含まれる場合があります。 しかし、意味的にこれは重要ではありません。 この空白などをアドレスから削除すると、意味的に同等の&lt;em&gt;正規表現&lt;/em&gt;が得られます。 したがって、 &lt;code&gt;first. last (comment) @ [3.5.7.9]&lt;/code&gt; の正規表現。 last（コメント）@ [3.5.7.9] is &lt;code&gt;first.last@[3.5.7.9]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03bb5d368df58fc938931912f1a46085762490a6" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. For rules that include semantically irrelevant (folding) whitespace, I give a separate regex marked &quot;(normalized)&quot; that doesn't accept this whitespace.</source>
          <target state="translated">派生は、私がどのようにしてこの式にたどり着いたかを示しています。RFCの関連するすべての文法規則を正確に表示されている通りにリストアップし、それに対応する正規表現を続けています。意味的に無関係な(折りたたみの)空白を含む規則については、この空白を受け入れない「(正規化された)」とマークされた別の正規表現を与えています。</target>
        </trans-unit>
        <trans-unit id="b143a24ff4d5dac8a1b58259e6ef61a5327993b2" translate="yes" xml:space="preserve">
          <source>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. Where an erratum has been published I give a separate expression for the corrected grammar rule (marked &quot;erratum&quot;) and use the updated version as a subexpression in subsequent regular expressions.</source>
          <target state="translated">派生は、私がどのようにしてこの式にたどり着いたかを示しています。私はRFCからの関連するすべての文法規則を正確に表示されている通りにリストアップし、それに対応する正規表現を続けています。正誤表が公開されている場合は、修正された文法規則(&quot;erratum &quot;とマークされている)のために別の表現を与え、更新されたバージョンを後続の正規表現のサブ式として使用します。</target>
        </trans-unit>
        <trans-unit id="c988189fcad54702295e206fc75fe6d5f6101f50" translate="yes" xml:space="preserve">
          <source>The email addresses I want to validate are going to be used by an ASP.NET web application using the System.Net.Mail namespace to send emails to a list of people. So, rather than using some very complex regular expression, I just try to create a MailAddress instance from the address. The MailAddress construtor will throw an exception if the address is not formed properly. This way, I know I can at least get the email out of the door. Of course this is server-side validation but at a minimum you need that anyway.</source>
          <target state="translated">検証したいメールアドレスは、System.Net.Mailネームスペースを使用したASP.NETウェブアプリケーションで使用され、人々のリストに電子メールを送信するために使用されます。そこで、非常に複雑な正規表現を使うのではなく、アドレスから MailAddress のインスタンスを作成してみます。MailAddress construtor は、アドレスが正しく形成されていない場合に例外をスローします。こうすることで、少なくともメールが届くようになることがわかっています。もちろんこれはサーバー側の検証ですが、最低限必要なのはいずれにしてもこれです。</target>
        </trans-unit>
        <trans-unit id="2c42e1dbf8f30a22743d35f41dec49ad83dcbd78" translate="yes" xml:space="preserve">
          <source>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</source>
          <target state="translated">以下のJavaScriptおよびPerl互換の正規表現は、上記の定義を実装したものです。</target>
        </trans-unit>
        <trans-unit id="04b741d2a83f024156fc1aafe328ecd03eac2d01" translate="yes" xml:space="preserve">
          <source>The grammar presented in RFC 5321 is too lenient when it comes to both host names and IP addresses. I took the liberty of &quot;correcting&quot; the rules in question, using &lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;this draft&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034&lt;/a&gt; as guidelines. Here's the resulting regex.</source>
          <target state="translated">RFC 5321で提示されている文法は、ホスト名とIPアドレスの両方に関しては寛大すぎます。 &lt;a href=&quot;https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt&quot;&gt;このドラフト&lt;/a&gt;と&lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;RFC 1034&lt;/a&gt;をガイドラインとして使用して、問題のルールを自由に「修正」しました。 これが結果の正規表現です。</target>
        </trans-unit>
        <trans-unit id="78bea17cadfee2e52d3b0ba653aeb8078d41c522" translate="yes" xml:space="preserve">
          <source>The more sophisticated patterns in Perl and PCRE (regex library used e.g. in PHP) can &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;correctly parse RFC 5322 without a hitch&lt;/a&gt;. Python and C# can do that too, but they use a different syntax from those first two. However, if you are forced to use one of the many less powerful pattern-matching languages, then it&amp;rsquo;s best to use a real parser.</source>
          <target state="translated">PerlおよびPCRE（例えばPHPで使用される正規表現ライブラリ）のより洗練されたパターンは、 &lt;a href=&quot;https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982&quot;&gt;RFC 5322を問題なく解析&lt;/a&gt;できます 。 PythonとC＃でも同じことができますが、最初の2つとは異なる構文を使用します。 ただし、あまり強力でないパターンマッチング言語の1つを使用せざるを得ない場合は、実際のパーサーを使用するのが最善です。</target>
        </trans-unit>
        <trans-unit id="f44b7e654912775bb48deb334cbbfbb5d94ad3b7" translate="yes" xml:space="preserve">
          <source>The second constraint is a restriction on RFC 5321/5322.</source>
          <target state="translated">2つ目の制約は、RFC 53215322の制約です。</target>
        </trans-unit>
        <trans-unit id="ddc5dad053b60eb7739c3fbde8711a0b846a2faf" translate="yes" xml:space="preserve">
          <source>The specified e-mail address 'myemail@address,com' is invalid. Did you mean 'myemail@address.com'?</source>
          <target state="translated">指定されたメールアドレス'myemail@address,com'は無効です。myemail@address.com」という意味だったのでしょうか?</target>
        </trans-unit>
        <trans-unit id="ba008b9092dbf02ae78dce33e0ba3f4f3680e270" translate="yes" xml:space="preserve">
          <source>The syntax of email addresses has been defined in various &lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFCs&lt;/a&gt;, most notably &lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;. RFC 822 should be seen as the &quot;original&quot; standard and RFC 5322 as the latest standard. The syntax defined in RFC 822 is the most lenient and subsequent standards have restricted the syntax further and further, where newer systems or services should recognize obsolete syntax, but never produce it.</source>
          <target state="translated">電子メールアドレスの構文は、さまざまな&lt;a href=&quot;http://en.wikipedia.org/wiki/Request_for_Comments&quot;&gt;RFC&lt;/a&gt; 、特に&lt;a href=&quot;http://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;および&lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322で&lt;/a&gt;定義されています 。 RFC 822は「元の」標準と見なされ、RFC 5322は最新の標準と見なされます。 RFC 822で定義された構文は最も寛容であり、後続の標準によって構文がますます制限されています。新しいシステムまたはサービスは廃止された構文を認識しますが、生成することはありません。</target>
        </trans-unit>
        <trans-unit id="694230a2ce267bc8d03a82385bbedc868ccb9017" translate="yes" xml:space="preserve">
          <source>The total length could also be limited to 254 characters, per &lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;RFC 3696  errata 1690&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;amp;eid=1690&quot;&gt;RFC 3696エラッタ1690&lt;/a&gt;に従って、全長は254文字に制限することもできます。</target>
        </trans-unit>
        <trans-unit id="3c409e37bc8b674795dc6985a2965f07b4a91bec" translate="yes" xml:space="preserve">
          <source>There are plenty examples of this out on the net (and I think even one that fully validates the RFC - but it's tens/hundreds of lines long if memory serves). People tend to get carried away validating this sort of thing. Why not just check it has an @ and at least one . and meets some simple minimum length. It's trivial to enter a fake email and still match any valid regex anyway. I would guess that false positives are better than false negatives.</source>
          <target state="translated">このような例はネット上にたくさんあります(RFCを完全に検証しているものもあると思いますが、記憶が正しければ何十行もあります)。人々はこの種のことを検証することに夢中になりがちです。なぜ、@と少なくとも1つの .がついていて、簡単な最小行数を満たしていることを確認しないのでしょうか。偽のメールを入力しても、有効な正規表現と一致するのは簡単なことです。誤検知の方が誤検知よりはマシだと思います。</target>
        </trans-unit>
        <trans-unit id="e65ce1fdf25d40bc41ca80ae15e74e6206ea4278" translate="yes" xml:space="preserve">
          <source>There is not one which is really usable.</source>
          <target state="translated">本当に使えるものは一つもありません。</target>
        </trans-unit>
        <trans-unit id="fb8823d7f714e02a82ffff0eff38f0b5686cb83b" translate="yes" xml:space="preserve">
          <source>There is some danger that common usage and widespread sloppy coding will establish a de facto standard for e-mail addresses that is more restrictive than the recorded formal standard.</source>
          <target state="translated">一般的な使用法と広範囲に及ぶずさんなコーディングによって、記録された正式な標準よりも制限的な電子メールアドレスのデファクトスタンダードが確立される危険性があります。</target>
        </trans-unit>
        <trans-unit id="eab562daff5b311a461fd5743bafead8320f8ac4" translate="yes" xml:space="preserve">
          <source>There's one problem with translating the RFC syntaxes into regexes: the syntaxes are not regular! This is because they allow for optional comments in email addresses that can be infinitely nested, while infinite nesting can't be described by a regular expression. To scan for or validate addresses containing comments you need a parser or more powerful expressions. (Note that languages like Perl have constructs to describe context free grammars in a regex-like way.) In this answer I'll disregard comments and only consider proper regular expressions.</source>
          <target state="translated">RFCの構文を正規表現に変換する際には一つ問題があります。これは、電子メールのアドレスには、無限に入れ子にできるオプションのコメントが含まれているからです。コメントを含むアドレスをスキャンしたり検証したりするには、パーサかより強力な式が必要です。(Perlのような言語には、文脈自由文法を正規表現のような方法で記述するための構文があることに注意してください)。この回答ではコメントは無視して、適切な正規表現のみを考慮します。</target>
        </trans-unit>
        <trans-unit id="604bc09674b2ed7a86a57667d281ad5d75b92f79" translate="yes" xml:space="preserve">
          <source>These two considerations could be addressed by parsing the address. The extra length constraint on host names could in some cases also be addressed by using an extra regex that checks it, and matching the address against both expressions.</source>
          <target state="translated">これら二つの考慮事項は、アドレスを解析することで対処できます。ホスト名に対する余分な長さの制約は、場合によっては、それをチェックする余分な正規表現を使用して、両方の式に対してアドレスをマッチングさせることでも対処できます。</target>
        </trans-unit>
        <trans-unit id="6a6068ef4c671cc993159bd9f7876a710e880eee" translate="yes" xml:space="preserve">
          <source>This intentionally doesn't comply with &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;.</source>
          <target state="translated">これは意図的に&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322に&lt;/a&gt;準拠していません。</target>
        </trans-unit>
        <trans-unit id="9e3c059245745fe56b963a2dd674dc3a620e4611" translate="yes" xml:space="preserve">
          <source>This is a job for a parser, but even if an address is syntactically valid, it still may not be deliverable. Sometimes you have to resort to the hillbilly method of &quot;Hey, y'all, watch ee-us!&quot;</source>
          <target state="translated">これはパーサーの仕事ですが、アドレスが構文的に有効であっても、配信できないことがあります。時には、&quot;Hey,y'all,watch ee-us!&quot;という山賊のような方法に頼らなければならないこともあります。</target>
        </trans-unit>
        <trans-unit id="40bd4785946bbfd84d54b271e863481fe650854b" translate="yes" xml:space="preserve">
          <source>This question is asked a lot, but I think you should step back and ask yourself &lt;em&gt;why&lt;/em&gt; you want to validate email adresses syntactically? What is the benefit really?</source>
          <target state="translated">この質問は頻繁に寄せられますが、メールアドレスを構文的に検証する&lt;em&gt;理由&lt;/em&gt;を一歩踏み込んで考えるべきでしょうか。 本当にメリットは何ですか？</target>
        </trans-unit>
        <trans-unit id="5b58c52e10b145304d80e39ff92b63c4aaad7cba" translate="yes" xml:space="preserve">
          <source>This regex is from Perl's &lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email::Valid&lt;/a&gt; library. I believe it to be the most accurate, it matches all 822. And, it is based on the regular expression in the O'Reilly book:</source>
          <target state="translated">この正規表現は、Perlの&lt;a href=&quot;https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm&quot;&gt;Email :: Valid&lt;/a&gt;ライブラリからのものです。 私はそれが最も正確であると信じています、それはすべての822に一致します。そして、それはO'Reillyの本の正規表現に基づいています：</target>
        </trans-unit>
        <trans-unit id="ab37a40832b8b946cb58d45531219e00bca7eb3a" translate="yes" xml:space="preserve">
          <source>This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module).</source>
          <target state="translated">この正規表現は、コメントが取り除かれて空白で置き換えられたアドレスのみを検証します (これはモジュールによって行われます)。</target>
        </trans-unit>
        <trans-unit id="881eea75af81659120231f1a02a723701d920b5f" translate="yes" xml:space="preserve">
          <source>Use the following regex for input validation:</source>
          <target state="translated">入力の検証には以下の正規表現を使用します。</target>
        </trans-unit>
        <trans-unit id="a38e078061a3af58841a4b63d102b4842c3180b3" translate="yes" xml:space="preserve">
          <source>User input validation</source>
          <target state="translated">ユーザー入力の検証</target>
        </trans-unit>
        <trans-unit id="417d6b6f39c552dae06a913e7670f440710547a0" translate="yes" xml:space="preserve">
          <source>Using a regular expression that recognizes email addresses could be useful in various situations: for example to scan for email addresses in a document, to validate user input, or as an integrity constraint on a data repository.</source>
          <target state="translated">メールアドレスを認識する正規表現を使用することは、様々な状況で役立ちます。例えば、文書内のメールアドレスをスキャンしたり、ユーザーの入力を検証したり、データリポジトリの整合性制約として使用することができます。</target>
        </trans-unit>
        <trans-unit id="7404787d1040c9c25b80ed394962a1fd680b081b" translate="yes" xml:space="preserve">
          <source>When only accepting host names in the domain part (after the @-sign), the regexes above accept only labels with at most 63 characters, as they should. However, they don't enforce the fact that the entire host name must be at most 253 characters long (including the dots). Although this constraint is strictly speaking still regular, it's not feasible to make a regex that incorporates this rule.</source>
          <target state="translated">ドメイン部分のホスト名のみを受け入れる場合 (@ 記号の後)、上記の正規表現は、そうすべきであるように、最大でも 63 文字のラベルのみを受け入れます。しかし、ホスト名全体の長さが(ドットを含めて)最大253文字でなければならないという事実を強制するものではありません。この制約は厳密に言えばまだ正規表現ですが、この規則を組み込んだ正規表現を作ることは不可能です。</target>
        </trans-unit>
        <trans-unit id="6adb4fb8492c6fd0b85a550dd4f05a8dfdfca38d" translate="yes" xml:space="preserve">
          <source>Which is the one used in ASP.NET by the RegularExpressionValidator.</source>
          <target state="translated">ASP.NETでRegularExpressionValidatorが使用しているものです。</target>
        </trans-unit>
        <trans-unit id="39672ee698f325ca5854a5b725c41110c115c08f" translate="yes" xml:space="preserve">
          <source>While deciding which characters are allowed, please remember your apostrophed and hyphenated friends. I have no control over the fact that my company generates my email address using my name from the HR system. That includes the apostrophe in my last name. I can't tell you how many times I have been blocked from interacting with a website by the fact that my email address is &quot;invalid&quot;.</source>
          <target state="translated">許可される文字を決めている間、アポストロフィーやハイフンを使った友人のことを思い出してください。私の会社が人事システムから私の名前を使用して私のメールアドレスを生成しているという事実は、私にはコントロールできません。それは私の苗字のアポストロフィも含まれています。私のメールアドレスが「無効」であるという事実によって、ウェブサイトとのやりとりがブロックされたことが何度あったか、私には言い尽くせません。</target>
        </trans-unit>
        <trans-unit id="040788551c90816319df84a15c3045438d8955bd" translate="yes" xml:space="preserve">
          <source>You could use the one employed by the jQuery Validation plugin:</source>
          <target state="translated">jQuery Validationプラグインで採用されているものを使用することができます。</target>
        </trans-unit>
        <trans-unit id="c0376b0b9474c79623a7bcdd162cc203cdab2051" translate="yes" xml:space="preserve">
          <source>You should allow uppercase alphabets too.  Email systems will normalize the local part and domain part.</source>
          <target state="translated">大文字のアルファベットも許可する必要があります。メールシステムはローカル部分とドメイン部分を正規化します。</target>
        </trans-unit>
        <trans-unit id="50ecc3e11978eaebf7cdde3eb4723774140d8446" translate="yes" xml:space="preserve">
          <source>You should not use regular expressions to validate email addresses.</source>
          <target state="translated">メールアドレスの検証に正規表現を使用してはいけません。</target>
        </trans-unit>
        <trans-unit id="379c3a7e829422a79610cb5cbd113ec1b0e6fea0" translate="yes" xml:space="preserve">
          <source>[UPDATED] I've collated everything I know about email address validation here: &lt;a href=&quot;http://isemail.info&quot;&gt;http://isemail.info&lt;/a&gt;, which now not only validates but also diagnoses problems with email addresses. I agree with many of the comments here that validation is only part of the answer; see my essay at &lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/about&lt;/a&gt;.</source>
          <target state="translated">[更新]私はここで電子メールアドレスの検証について知っているすべてを照合しました： &lt;a href=&quot;http://isemail.info&quot;&gt;http&lt;/a&gt; : //isemail.infoは 、電子メールアドレスの検証だけでなく、診断も行います。 検証は答えの一部にすぎないという、ここでのコメントの多くに同意します。 &lt;a href=&quot;http://isemail.info/about&quot;&gt;http://isemail.info/aboutで&lt;/a&gt;私のエッセイを参照してください。</target>
        </trans-unit>
        <trans-unit id="782f584cb9f10bfd4e2d20721f3769a1a46ed1e5" translate="yes" xml:space="preserve">
          <source>email =~ &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt;</source>
          <target state="translated">メール=〜 &lt;code&gt;/.+@[^@]+\.[^@]{2,}$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb288e30ab07ffc44b2ae8e5468078c1c3d3cd58" translate="yes" xml:space="preserve">
          <source>have a domain part (i.e. the part after the @-sign) that is a host name with at least two labels, each of which is at most 63 characters long.</source>
          <target state="translated">ドメイン部分(すなわち@記号の後の部分)を持つホスト名で、少なくとも2つのラベルを持ち、それぞれが最大で63文字の長さを持つ。</target>
        </trans-unit>
        <trans-unit id="580c167d115747dac91f0ce065f1f0cea9534d8c" translate="yes" xml:space="preserve">
          <source>have a local part (i.e. the part before the @-sign) that is strictly compliant with RFC 5321/5322,</source>
          <target state="translated">には、RFC 53215322 に厳密に準拠したローカル部分 (すなわち @ 記号の前の部分)があります。</target>
        </trans-unit>
        <trans-unit id="d59803fdebe968a3fc4b59dba8d7638e6988094e" translate="yes" xml:space="preserve">
          <source>if you want to use it in Java its really very easy</source>
          <target state="translated">Javaで使用したい場合は、非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="92fd5a496d47e663c9af65c455e24766e7ce98ef" translate="yes" xml:space="preserve">
          <source>is_email() remains, as far as I know, the only validator that will tell you definitively whether a given string is a valid email address or not. I've upload a new version at &lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/&lt;/a&gt;</source>
          <target state="translated">is_email（）は、私が知る限り、指定された文字列が有効な電子メールアドレスであるかどうかを明確に通知する唯一のバリデーターです。 &lt;a href=&quot;http://isemail.info/&quot;&gt;http://isemail.info/で&lt;/a&gt;新しいバージョンをアップロードしました</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
