<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/20940979">
    <body>
      <group id="20940979">
        <trans-unit id="90157ae76a08af0a3a22d7b35660a60c0952288c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GetString()&lt;/code&gt; will throw &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; because you're dataset has only two columns but you're trying to get a value from 3rd one (indices are &lt;em&gt;always&lt;/em&gt; 0-based).</source>
          <target state="translated">데이터 집합에 열이 두 개 뿐이지 만 세 번째 열에서 값을 가져 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 하기 때문에 &lt;code&gt;GetString()&lt;/code&gt; 은 IndexOutOfRangeException을 발생 시킵니다 (표시는 &lt;em&gt;항상&lt;/em&gt; 0 기반).</target>
        </trans-unit>
        <trans-unit id="6e82abbf74c093ad6a49b85e4604cb669c37d2d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IndexOutOfRangeException&lt;/code&gt; is generally different in that it in most cases it is pretty trivial to check for at the point where the exception is being raised.  Generally this kind of exception get thrown by some code that could very easily deal with the issue at the place it is occurring - just by checking the actual length of the array.  You don't want to 'fix' this by handling this exception higher up - but instead by ensuring its not thrown in the first instance - which in most cases is easy to do by checking the array length.</source>
          <target state="translated">&lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 은 일반적으로 예외가 발생하는 시점에서 확인하기가 쉽지 않기 때문에 일반적으로 다릅니다. 일반적으로 이러한 종류의 예외는 발생하는 장소에서 문제를 매우 쉽게 처리 할 수있는 일부 코드에 의해 발생합니다. 배열의 실제 길이를 확인하면됩니다. 이 예외를 더 높게 처리하여이를 '수정'하고 싶지는 않지만 대신 첫 번째 인스턴스에서 발생하지 않도록함으로써 대부분의 경우 배열 길이를 확인하여 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e384b1ac38528cf2b153179ee64c5c07891a0262" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;First item in arrays has always index 0&lt;/em&gt;. This is not always true because you can create an array with a custom lower bound:</source>
          <target state="translated">&lt;em&gt;배열의 첫 번째 항목은 항상 색인 0&lt;/em&gt; 입니다. 사용자 지정 하한을 사용하여 배열을 만들 수 있기 때문에 항상 그렇지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="02fe3c2ec3752f01939a625bda6b22efdd43fc7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Just think one train is there its compartments are D1,D2,D3.
One passenger came to enter the train and he have the ticket for D4.
now what will happen. the passenger want to enter a compartment that does not exist so obviously problem will arise.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;한 열차에 구획이 D1, D2, D3이라고 생각하십시오.&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;한 승객이 기차에 들어 와서 D4 티켓을 받았습니다.&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;이제 어떻게 될까요.&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;승객이 존재하지 않는 구획에 들어가기를 원하므로 분명히 문제가 발생합니다.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc2e9df144a904ca7e654e3151e719003968083d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Special&lt;/em&gt; Arrays With Custom Lower Bound&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;커스텀 로우 바운드가있는 &lt;em&gt;특수&lt;/em&gt; 어레이&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="585a20b3a1b5efe5d8ac80cc5fb5c37c9fe438f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array Length&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;배열 길이&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="219b82a1e751af97e51e37c164a80c71e6ab177e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays Do Not Grow&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;배열이 성장하지 않음&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6a5525b746c8370f4e56003defd53c493ddeb6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check Object State&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;객체 상태 확인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c45556dd62755f58a0dbbe669c6bbe02448a2daf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How it applies to &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx&quot;&gt;&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것이 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx&quot;&gt; &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 어떻게 적용됩니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68f01d14d713169ff7c034d4ab53d72b3d416586" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IDataReader and Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IDataReader 및 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="830bf9eb4cb1898d0ede130953d19e72968029bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Others&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Others&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b840c57c128f4bfe2ea512de26ab75218adb38a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unexpected Results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예기치 않은 결과&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="354119c5be040a4156893c8c1927c10b93fd64db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Upper Bound Is Not Inclusive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;상한은 포함되지 않습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69073d14195994c9068b40b723887a0ff4c2e715" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Validate Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;파라미터 검증&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5a3215f12d670c927c04e4f1ae816dec54af5a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Validate Return Values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;반환 값 확인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98c7e1be1d82ea36b991a9791f2b7fb7af4ce1ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wrong Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;잘못된 인수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a8b1f21ee4f3d1496817ff5cf7d9a607a0aeb2e6" translate="yes" xml:space="preserve">
          <source>A good start point is to always use assertions and to validate inputs. You may even want to use code contracts. When something went wrong and you can't figure out what happens with a quick look at your code then you have to resort to an old friend: &lt;strong&gt;debugger&lt;/strong&gt;. Just run your application in debug inside Visual Studio (or your favorite IDE), you'll see exactly which line throws this exception, which array is involved and which index you're trying to use. Really, 99% of the times you'll solve it by yourself in a few minutes.</source>
          <target state="translated">좋은 시작점은 항상 어설 션을 사용하고 입력을 확인하는 것입니다. 코드 계약을 사용할 수도 있습니다. 문제가 발생하여 코드를 빠르게 살펴보면 어떤 일이 발생하는지 파악할 수없는 경우 오랜 친구 인 &lt;strong&gt;debugger&lt;/strong&gt; 를 사용해야합니다. Visual Studio (또는 선호하는 IDE) 내에서 디버그로 응용 프로그램을 실행하면이 예외를 발생시키는 행, 관련된 배열 및 사용하려는 색인을 정확하게 볼 수 있습니다. 실제로 99 %의 시간으로 몇 분 안에 직접 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918d55df9a652e86c4424371b8022ca5c74d8fd7" translate="yes" xml:space="preserve">
          <source>A side from the very long complete accepted answer there is an important point to make about &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; compared with many other exception types, and that is:</source>
          <target state="translated">매우 오랫동안 받아 들여진 대답의 한 측면에서 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 을 다른 많은 예외 유형과 비교할 때 중요한 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="590ef1689a35dd4e7ed120fafde303e4f853d31a" translate="yes" xml:space="preserve">
          <source>An array is fast. Very fast in linear search compared to every other collection. It is because items are contiguous in memory so memory address can be calculated (and increment is just an addition). No need to follow a node list, simple math! You pay this with a limitation: they can't grow, if you need more elements you need to reallocate that array (this may take a relatively long time if old items must be copied to a new block). You resize them with &lt;code&gt;Array.Resize&amp;lt;T&amp;gt;()&lt;/code&gt;, this example adds a new entry to an existing array:</source>
          <target state="translated">배열이 빠릅니다. 다른 모든 컬렉션에 비해 선형 검색에서 매우 빠릅니다. 메모리에 항목이 연속되어 있기 때문에 메모리 주소를 계산할 수 있습니다 (증분은 단지 추가 일 뿐임). 노드 목록을 따를 필요없이 간단한 수학! 더 많은 요소가 필요한 경우 해당 배열을 재 할당해야합니다 (오래된 항목을 새 블록에 복사해야하는 경우 비교적 오랜 시간이 걸릴 수 있음). &lt;code&gt;Array.Resize&amp;lt;T&amp;gt;()&lt;/code&gt; 크기를 조정하면이 예제는 기존 배열에 새 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0b202a6b93b0ad3a0b8b0e09acb9d27754d6a75e" translate="yes" xml:space="preserve">
          <source>An exception of type 'System.ArgumentOutOfRangeException' occurred in mscorlib.dll but was not handled in user code Additional information: Index was out of range. Must be non-negative and less than the size of the collection.</source>
          <target state="translated">mscorlib.dll에서 'System.ArgumentOutOfRangeException'유형의 예외가 발생했지만 사용자 코드에서 처리되지 않았습니다. 추가 정보 : 색인이 범위를 벗어났습니다. 음수가 아니어야하며 컬렉션 크기보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="fd779c4366caa60dd63adc01044809905187b95d" translate="yes" xml:space="preserve">
          <source>Another way of putting this is that other exceptions can arise due to genuine lack of control over input or program state BUT &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; more often than not is simply just pilot (programmer) error.</source>
          <target state="translated">이것을 넣는 또 다른 방법은 입력 또는 프로그램 상태에 대한 진정한 통제력 부족으로 인해 다른 예외가 발생할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="51e4f40de8bfab70e2225354db35d9faafa79f94" translate="yes" xml:space="preserve">
          <source>Array index may not come directly from a parameter. It may be part of object state. In general is always a good practice to validate object state (by itself and with function parameters, if needed). You can use &lt;code&gt;Debug.Assert()&lt;/code&gt;, throw a proper exception (more descriptive about the problem) or handle that like in this example:</source>
          <target state="translated">배열 색인이 매개 변수에서 직접 제공되지 않을 수 있습니다. 객체 상태의 일부일 수 있습니다. 일반적으로 객체 상태를 자체적으로 (필요한 경우 함수 매개 변수를 사용하여) 확인하는 것이 좋습니다. &lt;code&gt;Debug.Assert()&lt;/code&gt; 사용하거나 적절한 예외를 발생 시키거나 (문제에 대해 더 설명적인) 다음 예제와 같이 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b9f2099dfa78e0a0cb9a9cacf32f191610f4e09d" translate="yes" xml:space="preserve">
          <source>Common case is to populate list with indexing (similar to &lt;code&gt;Dictionary&amp;lt;int, T&amp;gt;&lt;/code&gt;) will cause exception:</source>
          <target state="translated">일반적인 경우는 색인을 사용하여 목록을 채우는 것입니다 ( &lt;code&gt;Dictionary&amp;lt;int, T&amp;gt;&lt;/code&gt; 와 유사).</target>
        </trans-unit>
        <trans-unit id="25bb3e5e2d21ab7475b6402126c502ae27235124" translate="yes" xml:space="preserve">
          <source>Depending on classes used it can also be &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt;</source>
          <target state="translated">사용 된 클래스에 따라 &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b23b0799bcc8b2ce81bdf52bb9e099981c0d4d4" translate="yes" xml:space="preserve">
          <source>Don't forget that valid indices are from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;Length - 1&lt;/code&gt;. If you simply try to assign an item at &lt;code&gt;Length&lt;/code&gt; you'll get &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; (this behavior may confuse you if you think they may increase with a syntax similar to &lt;code&gt;Insert&lt;/code&gt; method of other collections).</source>
          <target state="translated">유효한 인덱스는 &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;Length - 1&lt;/code&gt; 입니다. &lt;code&gt;Length&lt;/code&gt; 에 항목을 할당하려고하면 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 이 발생합니다 (다른 컬렉션의 &lt;code&gt;Insert&lt;/code&gt; 메소드와 비슷한 구문으로 항목이 증가 할 경우 혼동 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="9b27fd7fe4b50df7d96174836b344cc4290d5689" translate="yes" xml:space="preserve">
          <source>Everything that we have said in the C# answer is valid for VB.NET with the obvious syntax differences but there is an important point to consider when you deal with VB.NET arrays.</source>
          <target state="translated">C # 답변에서 우리가 말한 모든 것은 명백한 구문 차이로 VB.NET에 유효하지만 VB.NET 배열을 다룰 때 고려해야 할 중요한 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b0d70e741d1af30dcaad5c3bd9539dbb820958c" translate="yes" xml:space="preserve">
          <source>Given an array declared as:</source>
          <target state="translated">다음과 같이 선언 된 배열이 주어집니다.</target>
        </trans-unit>
        <trans-unit id="634c81757628431baf46510d0fe88d9be1baed40" translate="yes" xml:space="preserve">
          <source>How to Avoid</source>
          <target state="translated">피하는 방법</target>
        </trans-unit>
        <trans-unit id="5b89063333bb026e82eef2450102f0542fe56b68" translate="yes" xml:space="preserve">
          <source>How to Debug</source>
          <target state="translated">디버깅하는 방법</target>
        </trans-unit>
        <trans-unit id="9054b410bcbb93070af4dc6c3c5cb26cb599c747" translate="yes" xml:space="preserve">
          <source>I have some code and when it executes, it throws a &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;, saying,</source>
          <target state="translated">코드가 있고 실행될 때 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="b7e20f4df8a1a037e7ebf260c1409ec6d68d3f62" translate="yes" xml:space="preserve">
          <source>If function is private you may simply replace &lt;code&gt;if&lt;/code&gt; logic with &lt;code&gt;Debug.Assert()&lt;/code&gt;:</source>
          <target state="translated">함수가 전용 인 &lt;code&gt;if&lt;/code&gt; 단순히 로직을 &lt;code&gt;Debug.Assert()&lt;/code&gt; 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35c8969ec9cb494058d0a4f6bd3ead6a41ac90ee" translate="yes" xml:space="preserve">
          <source>If index comes from a parameter you should always validate them (throwing appropriate &lt;code&gt;ArgumentException&lt;/code&gt; or &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt;). In the next example, wrong parameters may cause &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;, users of this function may expect this because they're passing an array but it's not always so obvious. I'd suggest to always validate parameters for public functions:</source>
          <target state="translated">인덱스가 매개 변수에서 나온 경우 항상 적절한 &lt;code&gt;ArgumentException&lt;/code&gt; 또는 &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; 을 발생 시켜 유효성을 검사해야합니다. 다음 예제에서 잘못된 매개 변수로 인해 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 이 발생할 수 있습니다.이 함수의 사용자는 배열을 전달하기 때문에이를 기대할 수 있지만 항상 그렇게 명확하지는 않습니다. 공개 함수의 매개 변수를 항상 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41c04df0b1cc86ae38c46937975285a88af8013e" translate="yes" xml:space="preserve">
          <source>If this happens in production then you'd better to add assertions in incriminated code, probably we won't see in your code what you can't see by yourself (but you can always bet).</source>
          <target state="translated">이것이 프로덕션 환경에서 발생하는 경우 위반 코드에 어설 션을 추가하는 것이 좋습니다. 아마도 우리는 자신이 볼 수없는 것을 코드에서 볼 수는 없지만 항상 내기를 할 수는 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b987be037398d3c129254a55d4e390c131f0e51" translate="yes" xml:space="preserve">
          <source>If you access an array using unvalidated arguments (from user input or from function user) you may get this error:</source>
          <target state="translated">검증되지 않은 인수 (사용자 입력 또는 함수 사용자)를 사용하여 배열에 액세스하면이 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9227b461684c699e8e65d0bf1176a729c1a582df" translate="yes" xml:space="preserve">
          <source>Imagine you're trying to read data from a database with this code:</source>
          <target state="translated">이 코드로 데이터베이스에서 데이터를 읽으려고한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="cc7a9efc85a264d77dd9f0d9027c47e5cf9aa6ef" translate="yes" xml:space="preserve">
          <source>In C#, usually, arrays are 0-based. It means that first element has index 0 and last element has index &lt;code&gt;Length - 1&lt;/code&gt; (where &lt;code&gt;Length&lt;/code&gt; is total number of items in the array) so this code doesn't work:</source>
          <target state="translated">C #에서 일반적으로 배열은 0을 기준으로합니다. 첫 번째 요소에는 색인 0이 있고 마지막 요소에는 색인 &lt;code&gt;Length - 1&lt;/code&gt; (여기서 &lt;code&gt;Length&lt;/code&gt; 는 배열의 총 항목 수)이 있으므로이 코드가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd6bbf267ba207b6ab0dbf6146519797f071cf4c" translate="yes" xml:space="preserve">
          <source>In VB.NET, arrays are declared setting the maximum valid index value for the array. It is not the count of the elements that we want to store in the array.</source>
          <target state="translated">VB.NET에서 배열은 배열의 최대 유효한 인덱스 값을 설정하여 선언됩니다. 배열에 저장하려는 요소의 개수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="dfcd9df83ee30d7d807a5c86bffb1eab90e4c481" translate="yes" xml:space="preserve">
          <source>In another scenario you may get &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; for this code (for example if you're using &lt;code&gt;GetPixel&lt;/code&gt; method on a &lt;code&gt;Bitmap&lt;/code&gt; class).</source>
          <target state="translated">다른 시나리오에서는이 코드에 대해 &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; 이 발생할 수 있습니다 (예 : &lt;code&gt;Bitmap&lt;/code&gt; 클래스에서 &lt;code&gt;GetPixel&lt;/code&gt; 메서드를 사용하는 경우).</target>
        </trans-unit>
        <trans-unit id="a096121cdf696e4cc12035da5ed6a1a2d6a4cfea" translate="yes" xml:space="preserve">
          <source>In my opinion, most of the questions, here on SO, about this error can be simply avoided. The time you spend to write a proper question (with a small working example and a small explanation) could easily much more than the time you'll need to debug your code. First of all, read this Eric Lippert's blog post about &lt;a href=&quot;http://ericlippert.com/2014/03/05/how-to-debug-small-programs/&quot;&gt;debugging of small programs&lt;/a&gt;, I won't repeat his words here but it's absolutely a &lt;em&gt;must read&lt;/em&gt;.</source>
          <target state="translated">내 의견으로는,이 오류에 대한 대부분의 질문은 간단하게 피할 수 있습니다. 적절한 질문을 작성하는 데 소요되는 시간 (작은 실례와 작은 설명으로)은 코드를 디버깅하는 데 필요한 시간보다 훨씬 더 많을 수 있습니다. 우선, &lt;a href=&quot;http://ericlippert.com/2014/03/05/how-to-debug-small-programs/&quot;&gt;작은 프로그램의 디버깅에&lt;/a&gt; 관한 Eric Lippert의 블로그 게시물을 &lt;em&gt;읽으십시오&lt;/em&gt; . 여기서 그의 말을 반복하지는 않지만 &lt;em&gt;반드시 읽어야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="edd9c3162520ffa6a25317a3046678c7840a5043" translate="yes" xml:space="preserve">
          <source>In one of previous examples we directly used &lt;code&gt;Array.IndexOf()&lt;/code&gt; return value. If we know it may fail then it's better to handle that case:</source>
          <target state="translated">이전 예제 중 하나에서 &lt;code&gt;Array.IndexOf()&lt;/code&gt; 반환 값을 직접 사용 했습니다 . 우리가 실패 할 수 있다는 것을 안다면, 그 사건을 처리하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0eaaf0f408d82787f7dce03834f5280173facd24" translate="yes" xml:space="preserve">
          <source>In that example, array indices are valid from 1 to 4. Of course, upper bound cannot be changed.</source>
          <target state="translated">이 예제에서 배열 인덱스는 1에서 4까지 유효합니다. 물론 상한은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="530b06e2da2492e2c8bc73420f839699bc382ee8" translate="yes" xml:space="preserve">
          <source>In the following example we create a raw bidimensional array of &lt;code&gt;Color&lt;/code&gt;. Each item represents a pixel, indices are from &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(imageWidth - 1, imageHeight - 1)&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;Color&lt;/code&gt; 의 원시 2 차원 배열을 만듭니다. 각 항목은 픽셀을 나타내며 인덱스는 &lt;code&gt;(0, 0)&lt;/code&gt; 에서 &lt;code&gt;(imageWidth - 1, imageHeight - 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32a51fdd8deaa7d4b87e2ddb0c98c68d696f01dc" translate="yes" xml:space="preserve">
          <source>In this example, let me assume, for simplicity, that arrays are always monodimensional and 0-based. If you want to be strict (or you're developing a library), you may need to replace &lt;code&gt;0&lt;/code&gt; with &lt;code&gt;GetLowerBound(0)&lt;/code&gt; and &lt;code&gt;.Length&lt;/code&gt; with &lt;code&gt;GetUpperBound(0)&lt;/code&gt; (of course if you have parameters of type &lt;code&gt;System.Arra&lt;/code&gt;y, it doesn't apply for &lt;code&gt;T[]&lt;/code&gt;). Please note that in this case, upper bound is inclusive then this code:</source>
          <target state="translated">이 예제에서는 간단히하기 위해 배열이 항상 1 차원이고 0 기반이라고 가정합니다. 엄격하게 (또는 라이브러리를 개발하려는 경우) &lt;code&gt;0&lt;/code&gt; 을 &lt;code&gt;GetLowerBound(0)&lt;/code&gt; 로 &lt;code&gt;.Length&lt;/code&gt; 를 &lt;code&gt;GetUpperBound(0)&lt;/code&gt; 바꾸어야 할 수도 있습니다 ( 물론 &lt;code&gt;System.Arra&lt;/code&gt; y 유형의 매개 변수가있는 경우 &lt;code&gt;T[]&lt;/code&gt; 에는 적용되지 않습니다. 이 경우 상한은 다음 코드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="40272c70580d7c109cb89e34d31411747867424c" translate="yes" xml:space="preserve">
          <source>Index was outside the bounds of the array.</source>
          <target state="translated">인덱스 배열의 범위를 벗어난 것입니다.</target>
        </trans-unit>
        <trans-unit id="f4bb569161e53103307661e8b53e45107af3a570" translate="yes" xml:space="preserve">
          <source>Moreover please note that if you have a multidimensional array then you can't use &lt;code&gt;Array.Length&lt;/code&gt; for both dimension, you have to use &lt;code&gt;Array.GetLength()&lt;/code&gt;:</source>
          <target state="translated">또한 다차원 배열이있는 경우 두 차원 모두에 &lt;code&gt;Array.Length&lt;/code&gt; 를 사용할 수 없으므로 &lt;code&gt;Array.GetLength()&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="570a52861d8c447060bebaa3d7e734fd46e5d33b" translate="yes" xml:space="preserve">
          <source>Next example is a naive example to calculate occurrences of a given set of numbers (knowing maximum number and returning an array where item at index 0 represents number 0, items at index 1 represents number 1 and so on):</source>
          <target state="translated">다음 예제는 주어진 숫자 세트의 발생을 계산하는 순진한 예제입니다 (최대 숫자를 알고 인덱스 0의 항목이 숫자 0을 나타내고 배열 1의 항목이 숫자 1 등을 나타내는 배열을 리턴 함).</target>
        </trans-unit>
        <trans-unit id="d557f009913713cad73735b6dbf5343e1e1dfbca" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; throws &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; for the same cases where arrays use &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;.</source>
          <target state="translated">배열이 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 을 사용하는 것과 동일한 경우 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bd651f30e77cb8c08ebc4ef5e06e931ce221c6fe" translate="yes" xml:space="preserve">
          <source>Of course, it's a pretty terrible implementation but what I want to show is that it'll fail for negative numbers and numbers above &lt;code&gt;maximum&lt;/code&gt;.</source>
          <target state="translated">물론, 그것은 끔찍한 구현이지만 내가 보여주고 싶은 것은 음수와 &lt;code&gt;maximum&lt;/code&gt; 값을 초과하면 실패한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ef9f43dc4d8385dc0e33e58565ca9eb5b222e6b" translate="yes" xml:space="preserve">
          <source>Often there is complex program state that maybe difficult to have control over at a particular point in code e.g a DB connection goes down so data for an input cannot be retrieved etc... This kind of issue often results in an Exception of some kind that has to bubble up to a higher level because where it occurs has no way of dealing with it at that point.</source>
          <target state="translated">종종 코드의 특정 지점에서 제어하기 어려운 복잡한 프로그램 상태가 있습니다. 예를 들어 DB 연결이 끊어 지므로 입력 데이터를 검색 할 수 없습니다. 이런 종류의 문제는 종종 예외가 발생합니다. 그것이 발생하는 곳은 그 시점에서 그것을 다루는 방법이 없기 때문에 더 높은 수준으로 버블 링해야합니다.</target>
        </trans-unit>
        <trans-unit id="27f8fcfb9ecd8c53b26dd0b2f91e65142b39621f" translate="yes" xml:space="preserve">
          <source>Please note that this behavior is shared with most &lt;code&gt;IDataReader&lt;/code&gt; implementations (&lt;code&gt;SqlDataReader&lt;/code&gt;, &lt;code&gt;OleDbDataReader&lt;/code&gt; and so on).</source>
          <target state="translated">이 동작은 대부분의 &lt;code&gt;IDataReader&lt;/code&gt; 구현 ( &lt;code&gt;SqlDataReader&lt;/code&gt; , &lt;code&gt;OleDbDataReader&lt;/code&gt; 등)과 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="b97b5a8efe8a2722837e5c57560477b5040d0b1f" translate="yes" xml:space="preserve">
          <source>Please note that this is not allowed (it'll throw &lt;code&gt;InvalidCastException&lt;/code&gt;), that's why if your parameters are &lt;code&gt;T[]&lt;/code&gt; you're safe about custom lower bound arrays:</source>
          <target state="translated">이것은 허용되지 않습니다 ( &lt;code&gt;InvalidCastException&lt;/code&gt; 을 던질 것입니다). 따라서 매개 변수가 &lt;code&gt;T[]&lt;/code&gt; 경우 사용자 정의 하한 배열에 대해 안전합니다.</target>
        </trans-unit>
        <trans-unit id="96f3e922a9aef7a1879f91f29f818e5ff62931fb" translate="yes" xml:space="preserve">
          <source>Result will be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fabd2b4a718bdee98a8cc1784519325b35b0832c" translate="yes" xml:space="preserve">
          <source>Same cases as array - range of valid indexes - 0 (&lt;code&gt;List&lt;/code&gt;'s indexes always start with 0) to &lt;code&gt;list.Count&lt;/code&gt; - accessing elements outside of this range will cause the exception.</source>
          <target state="translated">배열-유효한 인덱스 범위-0 ( &lt;code&gt;List&lt;/code&gt; 의 인덱스는 항상 0으로 시작)과 같은 경우 나열- &lt;code&gt;list.Count&lt;/code&gt; -이 범위 밖의 요소에 액세스하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4caee130f7f88696a123daa568884e0a7a6c235c" translate="yes" xml:space="preserve">
          <source>Same scenario: whenever we try to access an array list, etc. we can only access the existing indexes in the array. &lt;code&gt;array[0]&lt;/code&gt; and &lt;code&gt;array[1]&lt;/code&gt; are existing. If we try to access &lt;code&gt;array[3]&lt;/code&gt;, it's not there actually, so an index out of bound exception will arise.</source>
          <target state="translated">같은 시나리오 : 배열 목록 등에 액세스하려고 할 때마다 배열의 기존 인덱스에만 액세스 할 수 있습니다. &lt;code&gt;array[0]&lt;/code&gt; 및 &lt;code&gt;array[1]&lt;/code&gt; 이 존재합니다. &lt;code&gt;array[3]&lt;/code&gt; 에 액세스하려고하면 실제로 존재하지 않으므로 인덱스를 벗어난 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7d7463e8ea002eaac163acc85628793b0ec0e69f" translate="yes" xml:space="preserve">
          <source>Should be rewritten like this:</source>
          <target state="translated">다음과 같이 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="be76153017b0c155c35e835c740ed8b45e1ac779" translate="yes" xml:space="preserve">
          <source>Simple explanation about what a Index out of bound exception is:</source>
          <target state="translated">인덱스를 벗어난 예외가 무엇인지에 대한 간단한 설명 :</target>
        </trans-unit>
        <trans-unit id="2d047b4d2d0dcbe67d0f58d382579d548af0a6ba" translate="yes" xml:space="preserve">
          <source>Size of array is 3 (indices 0, 1 and 2), but the for-loop loops 4 times (0, 1, 2 and 3).</source>
          <target state="translated">배열의 크기는 3 (0, 1 및 2 표시)이지만 for-loop는 4 번 (0, 1, 2 및 3) 루프됩니다.</target>
        </trans-unit>
        <trans-unit id="b2fd41760f100eb04b3fbf11f90eaf5e88b79a94" translate="yes" xml:space="preserve">
          <source>So this loop will fill the array with 5 integers without causing any &lt;strong&gt;IndexOutOfRangeException&lt;/strong&gt;</source>
          <target state="translated">따라서이 루프는 &lt;strong&gt;IndexOutOfRangeException&lt;/strong&gt; 을 발생시키지 않고 5 개의 정수로 배열을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="2eceeacdc6960cb32b48adcd985da317ecc2c1d5" translate="yes" xml:space="preserve">
          <source>So when it tries to access outside the bounds with (3) it throws the exception.</source>
          <target state="translated">따라서 (3)으로 경계 외부에 액세스하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eef2eb7f26ac3a52b33b36028193756338fc756d" translate="yes" xml:space="preserve">
          <source>Suppose for example that you have retrieved a column named &lt;em&gt;Column1&lt;/em&gt; but then you try to retrieve the value of that field with</source>
          <target state="translated">예를 들어, &lt;em&gt;Column1&lt;/em&gt; 이라는 &lt;em&gt;열&lt;/em&gt; 을 검색했지만 다음을 사용하여 해당 필드의 값을 검색하려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="5d5442589685d9f06310c6030d60b943cbbc03f6" translate="yes" xml:space="preserve">
          <source>The VB.NET rule</source>
          <target state="translated">VB.NET 규칙</target>
        </trans-unit>
        <trans-unit id="29a34df4c3a8b6265655372cf0b7ca0c4c58177b" translate="yes" xml:space="preserve">
          <source>The VB.NET side of the story</source>
          <target state="translated">이야기의 VB.NET 측</target>
        </trans-unit>
        <trans-unit id="107a9888b94abfe0f0842709b6d53a8d5a2cad39" translate="yes" xml:space="preserve">
          <source>There is another (documented) case when this exception is thrown: if, in &lt;code&gt;DataView&lt;/code&gt;, data column name being supplied to the &lt;code&gt;DataViewSort&lt;/code&gt; property is not valid.</source>
          <target state="translated">이 예외가 발생하는 경우 (문서화 된) 또 다른 경우가 있습니다. &lt;code&gt;DataViewSort&lt;/code&gt; 에서 DataViewSort 특성에 제공되는 데이터 열 이름이 유효하지 않은 경우입니다.</target>
        </trans-unit>
        <trans-unit id="2feb23c1a9eaeb80736074afbcae4a7353c3d269" translate="yes" xml:space="preserve">
          <source>This code will then fail because array is 0-based and last (bottom-right) pixel in the image is &lt;code&gt;pixels[imageWidth - 1, imageHeight - 1]&lt;/code&gt;:</source>
          <target state="translated">이 코드는 배열이 0 기반이고 이미지의 마지막 (오른쪽 아래) 픽셀이 &lt;code&gt;pixels[imageWidth - 1, imageHeight - 1]&lt;/code&gt; 이기 때문에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7b0ef8f0aa42bf47870a059eee92fc5398d3ebb4" translate="yes" xml:space="preserve">
          <source>This exception may be thrown for another reason too: by convention, many &lt;em&gt;search functions&lt;/em&gt; will return -1 (nullables has been introduced with .NET 2.0 and anyway it's also a well-known convention in use from many years) if they didn't find anything. Let's imagine you have an array of objects comparable with a string. You may think to write this code:</source>
          <target state="translated">이 예외는 다른 이유로도 발생할 수 있습니다. 규칙에 따라 많은 &lt;em&gt;검색 함수&lt;/em&gt; 는 -1을 반환합니다 (.NET 2.0에서 nullables가 도입되었으며 어쨌든 잘 알려진 규칙 임에도 불구하고). 아무것도. 문자열과 비슷한 객체 배열이 있다고 가정 해 봅시다. 이 코드를 작성한다고 생각할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2fcd2cd1cb1036644f107b16a8890283d860e72" translate="yes" xml:space="preserve">
          <source>This exception means that you're trying to access a collection item by index, using an invalid index. An index is invalid when it's lower than the collection's lower bound or greater than &lt;del&gt;equal to the number of elements it contains.&lt;/del&gt; the maximum allowed index defined in the array declaration</source>
          <target state="translated">이 예외는 잘못된 인덱스를 사용하여 인덱스로 컬렉션 항목에 액세스하려고 함을 의미합니다. 컬렉션의 하한보다 작거나보다 큰 인덱스는 유효하지 않습니다. &lt;del&gt; 포함하는 요소 수와 같습니다. &lt;/del&gt; 배열 선언에 정의 된 최대 허용 인덱스</target>
        </trans-unit>
        <trans-unit id="e7dec47f74c256ee0220fc295a632aecdf0b27a6" translate="yes" xml:space="preserve">
          <source>This exception means that you're trying to access a collection item by index, using an invalid index. An index is invalid when it's lower than the collection's lower bound or greater than or equal to the number of elements it contains.</source>
          <target state="translated">이 예외는 잘못된 인덱스를 사용하여 인덱스로 컬렉션 항목에 액세스하려고 함을 의미합니다. 컬렉션의 하한보다 작거나 포함 된 요소 수보다 크거나 같은 인덱스는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e01fe07c21102f88931eb8da4f078ace2acf044" translate="yes" xml:space="preserve">
          <source>This happens because the indexer operator is implemented trying to retrieve the index of a &lt;em&gt;Colum1&lt;/em&gt; field that doesn't exist. The GetOrdinal method will throw this exception when its internal helper code returns a -1 as the index of &quot;Colum1&quot;.</source>
          <target state="translated">이는 존재하지 않는 &lt;em&gt;Colum1&lt;/em&gt; 필드의 색인을 검색하려고 인덱서 연산자가 구현 되었기 때문에 발생합니다. 내부 도우미 코드가 &quot;Colum1&quot;의 인덱스로 -1을 반환하면 GetOrdinal 메서드에서이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e8ae00193f164544dc369987db61ee45ff297184" translate="yes" xml:space="preserve">
          <source>This will fail if no items in &lt;code&gt;myArray&lt;/code&gt; will satisfy search condition because &lt;code&gt;Array.IndexOf()&lt;/code&gt; will return -1 and then array access will throw.</source>
          <target state="translated">&lt;code&gt;Array.IndexOf()&lt;/code&gt; 가 -1을 반환하고 배열 액세스가 발생하기 때문에 &lt;code&gt;myArray&lt;/code&gt; 의 항목이 검색 조건을 만족하지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1448888ed15547b9b90d018b51d2e99215c5719e" translate="yes" xml:space="preserve">
          <source>To easily understand the problem, imagine we wrote this code:</source>
          <target state="translated">문제를 쉽게 이해하기 위해 다음 코드를 작성했다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="d75990cb468491d4aee74eb65a49267c49a02831" translate="yes" xml:space="preserve">
          <source>Unlike arrays, &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; starts empty - so trying to access items of just created list lead to this exception.</source>
          <target state="translated">배열과 달리 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 는 비어 있으므로 시작된 목록의 항목에 액세스하려고하면이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85b71ece91202721794d3f3aa2f8575d83d210c3" translate="yes" xml:space="preserve">
          <source>What Is It?</source>
          <target state="translated">무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d038b6b88960ddb547851582deb4aa9178a9143a" translate="yes" xml:space="preserve">
          <source>What does this mean, and what can I do about it?</source>
          <target state="translated">이것은 무엇을 의미하며 이에 대해 무엇을 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="db3e9dce32f32c752d89721d4714009559cf8ea7" translate="yes" xml:space="preserve">
          <source>What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it</source>
          <target state="translated">IndexOutOfRangeException / ArgumentOutOfRangeException은 무엇이며 어떻게 해결합니까?</target>
        </trans-unit>
        <trans-unit id="64d2ca343b2d11209d8e98e83bbc370189858b2f" translate="yes" xml:space="preserve">
          <source>When It Is Thrown</source>
          <target state="translated">던져 질 때</target>
        </trans-unit>
        <trans-unit id="b6cd6c3e3375f53769e3f51014aa013895a17062" translate="yes" xml:space="preserve">
          <source>You can access this array from 0 to 3, values outside this range will cause &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; to be thrown. Remember this when you create and access an array.</source>
          <target state="translated">이 배열에 0에서 3까지 액세스 할 수 있습니다.이 범위를 벗어난 값으로 인해 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 이 발생합니다. 어레이를 생성하고 액세스 할 때이 점을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="a435dd41b664b49681c0f5d1ce876301860c479a" translate="yes" xml:space="preserve">
          <source>You can get the same exception also if you use the IDataReader overload of the indexer operator that takes a column name and pass an invalid column name.</source>
          <target state="translated">열 이름을 사용하고 유효하지 않은 열 이름을 전달하는 인덱서 연산자의 IDataReader 오버로드를 사용하는 경우에도 동일한 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc1e14f5925304435bda2fd3d2ff334f6898cf6b" translate="yes" xml:space="preserve">
          <source>You found your error, check how &lt;code&gt;index&lt;/code&gt; increases. Is it right? Check how array is allocated, is coherent with how &lt;code&gt;index&lt;/code&gt; increases? Is it right according to your specifications? If you answer &lt;em&gt;yes&lt;/em&gt; to all these questions, then you'll find good help here on StackOverflow but please first check for that by yourself. You'll save your own time!</source>
          <target state="translated">오류를 발견하고 &lt;code&gt;index&lt;/code&gt; 이 어떻게 증가하는지 확인하십시오. 맞아? 배열이 어떻게 할당되는지 확인하고 &lt;code&gt;index&lt;/code&gt; 가 어떻게 증가하는지 일관성이 있습니까? 사양에 따라 맞습니까? 이 모든 질문에 &lt;em&gt;예라고&lt;/em&gt; 대답하면 StackOverflow에 대한 유용한 도움말을 찾을 수 있지만 먼저 직접 확인하십시오. 당신은 당신의 자신의 시간을 절약 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="250a56e82d76e86df3aa532f5df265e03cc75d27" translate="yes" xml:space="preserve">
          <source>You have source code, you have exception message with a stack trace. Go there, pick right line number and you'll see:</source>
          <target state="translated">소스 코드가 있고 스택 추적이 포함 된 예외 메시지가 있습니다. 거기에 가서 올바른 줄 번호를 선택하면 다음을 볼 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
