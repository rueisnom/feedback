<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/20940979">
    <body>
      <group id="20940979">
        <trans-unit id="90157ae76a08af0a3a22d7b35660a60c0952288c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GetString()&lt;/code&gt; will throw &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; because you're dataset has only two columns but you're trying to get a value from 3rd one (indices are &lt;em&gt;always&lt;/em&gt; 0-based).</source>
          <target state="translated">データセットには2つの列しかないが、3番目の列から値を取得しようとしているため（インデックスは&lt;em&gt;常に&lt;/em&gt; 0ベースです &lt;code&gt;GetString()&lt;/code&gt; は &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="6e82abbf74c093ad6a49b85e4604cb669c37d2d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IndexOutOfRangeException&lt;/code&gt; is generally different in that it in most cases it is pretty trivial to check for at the point where the exception is being raised.  Generally this kind of exception get thrown by some code that could very easily deal with the issue at the place it is occurring - just by checking the actual length of the array.  You don't want to 'fix' this by handling this exception higher up - but instead by ensuring its not thrown in the first instance - which in most cases is easy to do by checking the array length.</source>
          <target state="translated">&lt;code&gt;IndexOutOfRangeException&lt;/code&gt; は、ほとんどの場合、例外が発生しているポイントで確認するのは簡単なことです。 一般に、この種の例外は、配列の実際の長さを確認するだけで、問題が発生している場所で問題に非常に簡単に対処できるコードによってスローされます。 この例外を上位に処理することでこれを「修正」したくない-代わりに、最初のインスタンスで例外がスローされないようにする-これは、ほとんどの場合、配列の長さをチェックすることで簡単に実行できます。</target>
        </trans-unit>
        <trans-unit id="e384b1ac38528cf2b153179ee64c5c07891a0262" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;First item in arrays has always index 0&lt;/em&gt;. This is not always true because you can create an array with a custom lower bound:</source>
          <target state="translated">&lt;em&gt;配列の最初の項目のインデックスは常に0&lt;/em&gt;です。 カスタムの下限で配列を作成できるため、これは常に当てはまるわけではありません。</target>
        </trans-unit>
        <trans-unit id="02fe3c2ec3752f01939a625bda6b22efdd43fc7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Just think one train is there its compartments are D1,D2,D3.
One passenger came to enter the train and he have the ticket for D4.
now what will happen. the passenger want to enter a compartment that does not exist so obviously problem will arise.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;1つの列車のコンパートメントがD1、D2、D3であると考えてください。&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;一人の乗客が電車に入るようになり、彼はD4のチケットを持っています。&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;今何が起こるか。&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;乗客は存在しないコンパートメントに入ろうとするため、明らかに問題が発生します。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc2e9df144a904ca7e654e3151e719003968083d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Special&lt;/em&gt; Arrays With Custom Lower Bound&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;カスタムの下限を持つ&lt;em&gt;特別な&lt;/em&gt;配列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="585a20b3a1b5efe5d8ac80cc5fb5c37c9fe438f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array Length&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アレイの長さ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="219b82a1e751af97e51e37c164a80c71e6ab177e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays Do Not Grow&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;配列が大きくならない&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6a5525b746c8370f4e56003defd53c493ddeb6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check Object State&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;オブジェクトの状態を確認する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c45556dd62755f58a0dbbe669c6bbe02448a2daf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How it applies to &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx&quot;&gt;&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx&quot;&gt; &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;どのように適用されますか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68f01d14d713169ff7c034d4ab53d72b3d416586" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IDataReader and Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IDataReaderと列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="830bf9eb4cb1898d0ede130953d19e72968029bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Others&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Others&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b840c57c128f4bfe2ea512de26ab75218adb38a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unexpected Results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;予期しない結果&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="354119c5be040a4156893c8c1927c10b93fd64db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Upper Bound Is Not Inclusive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;上限は含まれていません&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69073d14195994c9068b40b723887a0ff4c2e715" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Validate Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;パラメータを検証&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5a3215f12d670c927c04e4f1ae816dec54af5a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Validate Return Values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;戻り値を検証する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98c7e1be1d82ea36b991a9791f2b7fb7af4ce1ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wrong Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;間違った引数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a8b1f21ee4f3d1496817ff5cf7d9a607a0aeb2e6" translate="yes" xml:space="preserve">
          <source>A good start point is to always use assertions and to validate inputs. You may even want to use code contracts. When something went wrong and you can't figure out what happens with a quick look at your code then you have to resort to an old friend: &lt;strong&gt;debugger&lt;/strong&gt;. Just run your application in debug inside Visual Studio (or your favorite IDE), you'll see exactly which line throws this exception, which array is involved and which index you're trying to use. Really, 99% of the times you'll solve it by yourself in a few minutes.</source>
          <target state="translated">良い出発点は、常にアサーションを使用し、入力を検証することです。 コードコントラクトを使用することもできます。 何かがうまくいかず、コードをざっと見ても何が起こるかわからない場合は、昔の友達である&lt;strong&gt;デバッガ&lt;/strong&gt;に頼る必要があり&lt;strong&gt;ます&lt;/strong&gt; 。 Visual Studio（またはお気に入りのIDE）内のデバッグでアプリケーションを実行するだけで、どの行がこの例外をスローし、どの配列が関係し、どのインデックスを使用しようとしているのかが正確にわかります。 実際には、99％の時間で、数分で自分で解決できます。</target>
        </trans-unit>
        <trans-unit id="918d55df9a652e86c4424371b8022ca5c74d8fd7" translate="yes" xml:space="preserve">
          <source>A side from the very long complete accepted answer there is an important point to make about &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; compared with many other exception types, and that is:</source>
          <target state="translated">非常に長い完全に受け入れられた回答とは &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 、他の多くの例外タイプと比較してIndexOutOfRangeExceptionについて重要なポイントがあります。それは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="590ef1689a35dd4e7ed120fafde303e4f853d31a" translate="yes" xml:space="preserve">
          <source>An array is fast. Very fast in linear search compared to every other collection. It is because items are contiguous in memory so memory address can be calculated (and increment is just an addition). No need to follow a node list, simple math! You pay this with a limitation: they can't grow, if you need more elements you need to reallocate that array (this may take a relatively long time if old items must be copied to a new block). You resize them with &lt;code&gt;Array.Resize&amp;lt;T&amp;gt;()&lt;/code&gt;, this example adds a new entry to an existing array:</source>
          <target state="translated">配列は高速です。 他のすべてのコレクションと比較して、線形検索は非常に高速です。 これは、メモリ内でアイテムが隣接しているため、メモリアドレスを計算できるためです（インクリメントは単なる追加です）。 ノードリストをたどる必要はありません、簡単な数学！ 制限付きでこれを支払います。要素を増やす必要がある場合は、配列を再割り当てする必要があります（古いアイテムを新しいブロックにコピーする必要がある場合、これには比較的長い時間がかかる可能性があります）。 &lt;code&gt;Array.Resize&amp;lt;T&amp;gt;()&lt;/code&gt; を使用してサイズを変更します。この例では、既存の配列に新しいエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="0b202a6b93b0ad3a0b8b0e09acb9d27754d6a75e" translate="yes" xml:space="preserve">
          <source>An exception of type 'System.ArgumentOutOfRangeException' occurred in mscorlib.dll but was not handled in user code Additional information: Index was out of range. Must be non-negative and less than the size of the collection.</source>
          <target state="translated">mscorlib.dll で System.ArgumentOutOfRangeException というタイプの例外が発生しましたが、ユーザーコードでは処理されませんでした。インデックスが範囲外でした。負ではなく、コレクションのサイズ以下でなければなりません。</target>
        </trans-unit>
        <trans-unit id="fd779c4366caa60dd63adc01044809905187b95d" translate="yes" xml:space="preserve">
          <source>Another way of putting this is that other exceptions can arise due to genuine lack of control over input or program state BUT &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; more often than not is simply just pilot (programmer) error.</source>
          <target state="translated">これを置くもう1つの方法は、入力またはプログラムの状態を制御できないために他の例外が発生する可能性があることです。ただし、 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; は単なるパイロット（プログラマー）エラーである場合がほとんどです。</target>
        </trans-unit>
        <trans-unit id="51e4f40de8bfab70e2225354db35d9faafa79f94" translate="yes" xml:space="preserve">
          <source>Array index may not come directly from a parameter. It may be part of object state. In general is always a good practice to validate object state (by itself and with function parameters, if needed). You can use &lt;code&gt;Debug.Assert()&lt;/code&gt;, throw a proper exception (more descriptive about the problem) or handle that like in this example:</source>
          <target state="translated">配列のインデックスは、パラメータから直接取得することはできません。 オブジェクトの状態の一部である可能性があります。 一般に、オブジェクトの状態を検証するためには常に（それ自体、および必要に応じて関数パラメーターを使用して）常に良い方法です。 &lt;code&gt;Debug.Assert()&lt;/code&gt; を使用したり 、適切な例外をスローしたり（問題についてより詳しく説明したり）、次の例のように処理したりできます。</target>
        </trans-unit>
        <trans-unit id="b9f2099dfa78e0a0cb9a9cacf32f191610f4e09d" translate="yes" xml:space="preserve">
          <source>Common case is to populate list with indexing (similar to &lt;code&gt;Dictionary&amp;lt;int, T&amp;gt;&lt;/code&gt;) will cause exception:</source>
          <target state="translated">一般的なケースは、リストにインデックスを設定することです（ &lt;code&gt;Dictionary&amp;lt;int, T&amp;gt;&lt;/code&gt; と同様）で例外が発生します。</target>
        </trans-unit>
        <trans-unit id="25bb3e5e2d21ab7475b6402126c502ae27235124" translate="yes" xml:space="preserve">
          <source>Depending on classes used it can also be &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt;</source>
          <target state="translated">使用するクラスによっては、 &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; になることもあります。</target>
        </trans-unit>
        <trans-unit id="4b23b0799bcc8b2ce81bdf52bb9e099981c0d4d4" translate="yes" xml:space="preserve">
          <source>Don't forget that valid indices are from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;Length - 1&lt;/code&gt;. If you simply try to assign an item at &lt;code&gt;Length&lt;/code&gt; you'll get &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; (this behavior may confuse you if you think they may increase with a syntax similar to &lt;code&gt;Insert&lt;/code&gt; method of other collections).</source>
          <target state="translated">有効なインデックスは &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;Length - 1&lt;/code&gt; までであることを忘れないでください。 &lt;code&gt;Length&lt;/code&gt; 項目を割り当てようとすると、 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; が発生します（他のコレクションの &lt;code&gt;Insert&lt;/code&gt; メソッドと同様の構文で増加すると思われる場合、この動作により混乱する可能性があります）。</target>
        </trans-unit>
        <trans-unit id="9b27fd7fe4b50df7d96174836b344cc4290d5689" translate="yes" xml:space="preserve">
          <source>Everything that we have said in the C# answer is valid for VB.NET with the obvious syntax differences but there is an important point to consider when you deal with VB.NET arrays.</source>
          <target state="translated">C#の回答で述べたことはすべて、明らかな構文の違いを持つVB.NETで有効ですが、VB.NETの配列を扱う際に考慮すべき重要なポイントがあります。</target>
        </trans-unit>
        <trans-unit id="9b0d70e741d1af30dcaad5c3bd9539dbb820958c" translate="yes" xml:space="preserve">
          <source>Given an array declared as:</source>
          <target state="translated">として宣言された配列が与えられます。</target>
        </trans-unit>
        <trans-unit id="634c81757628431baf46510d0fe88d9be1baed40" translate="yes" xml:space="preserve">
          <source>How to Avoid</source>
          <target state="translated">避ける方法</target>
        </trans-unit>
        <trans-unit id="5b89063333bb026e82eef2450102f0542fe56b68" translate="yes" xml:space="preserve">
          <source>How to Debug</source>
          <target state="translated">デバッグ方法</target>
        </trans-unit>
        <trans-unit id="9054b410bcbb93070af4dc6c3c5cb26cb599c747" translate="yes" xml:space="preserve">
          <source>I have some code and when it executes, it throws a &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;, saying,</source>
          <target state="translated">私はいくつかのコードを持っていますが、実行すると &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; がスローされ 、</target>
        </trans-unit>
        <trans-unit id="b7e20f4df8a1a037e7ebf260c1409ec6d68d3f62" translate="yes" xml:space="preserve">
          <source>If function is private you may simply replace &lt;code&gt;if&lt;/code&gt; logic with &lt;code&gt;Debug.Assert()&lt;/code&gt;:</source>
          <target state="translated">関数がプライベートの場合、 &lt;code&gt;if&lt;/code&gt; ロジックを &lt;code&gt;Debug.Assert()&lt;/code&gt; に置き換えるだけです。</target>
        </trans-unit>
        <trans-unit id="35c8969ec9cb494058d0a4f6bd3ead6a41ac90ee" translate="yes" xml:space="preserve">
          <source>If index comes from a parameter you should always validate them (throwing appropriate &lt;code&gt;ArgumentException&lt;/code&gt; or &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt;). In the next example, wrong parameters may cause &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;, users of this function may expect this because they're passing an array but it's not always so obvious. I'd suggest to always validate parameters for public functions:</source>
          <target state="translated">インデックスがパラメーターからのものである場合、常にそれらを検証する必要があります（適切な &lt;code&gt;ArgumentException&lt;/code&gt; または &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; をスローします）。 次の例では、間違ったパラメーターが &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; を引き起こす可能性があります。この関数のユーザーは、配列を渡すため、これを予期するかもしれませんが、必ずしもそれほど明白ではありません。 常にパブリック関数のパラメーターを検証することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="41c04df0b1cc86ae38c46937975285a88af8013e" translate="yes" xml:space="preserve">
          <source>If this happens in production then you'd better to add assertions in incriminated code, probably we won't see in your code what you can't see by yourself (but you can always bet).</source>
          <target state="translated">このようなことが本番で起こるのであれば、罪に問われたコードにアサーションを追加した方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="2b987be037398d3c129254a55d4e390c131f0e51" translate="yes" xml:space="preserve">
          <source>If you access an array using unvalidated arguments (from user input or from function user) you may get this error:</source>
          <target state="translated">(ユーザの入力や関数のユーザからの)有効でない引数を使用して配列にアクセスした場合、このエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9227b461684c699e8e65d0bf1176a729c1a582df" translate="yes" xml:space="preserve">
          <source>Imagine you're trying to read data from a database with this code:</source>
          <target state="translated">このコードを使ってデータベースからデータを読み込もうとしていると想像してみてください。</target>
        </trans-unit>
        <trans-unit id="cc7a9efc85a264d77dd9f0d9027c47e5cf9aa6ef" translate="yes" xml:space="preserve">
          <source>In C#, usually, arrays are 0-based. It means that first element has index 0 and last element has index &lt;code&gt;Length - 1&lt;/code&gt; (where &lt;code&gt;Length&lt;/code&gt; is total number of items in the array) so this code doesn't work:</source>
          <target state="translated">C＃では、通常、配列は0ベースです。 つまり、最初の要素のインデックスは0で、最後の要素のインデックスは &lt;code&gt;Length - 1&lt;/code&gt; （ &lt;code&gt;Length&lt;/code&gt; は配列内のアイテムの総数）であるため、次のコードは機能しません。</target>
        </trans-unit>
        <trans-unit id="fd6bbf267ba207b6ab0dbf6146519797f071cf4c" translate="yes" xml:space="preserve">
          <source>In VB.NET, arrays are declared setting the maximum valid index value for the array. It is not the count of the elements that we want to store in the array.</source>
          <target state="translated">VB.NETでは、配列は配列の有効な最大インデックス値を設定して宣言されます。配列に格納したい要素の数ではありません。</target>
        </trans-unit>
        <trans-unit id="dfcd9df83ee30d7d807a5c86bffb1eab90e4c481" translate="yes" xml:space="preserve">
          <source>In another scenario you may get &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; for this code (for example if you're using &lt;code&gt;GetPixel&lt;/code&gt; method on a &lt;code&gt;Bitmap&lt;/code&gt; class).</source>
          <target state="translated">別のシナリオでは、このコードに対して &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; を取得する場合があります（たとえば、 &lt;code&gt;Bitmap&lt;/code&gt; クラスで &lt;code&gt;GetPixel&lt;/code&gt; メソッドを使用している場合）。</target>
        </trans-unit>
        <trans-unit id="a096121cdf696e4cc12035da5ed6a1a2d6a4cfea" translate="yes" xml:space="preserve">
          <source>In my opinion, most of the questions, here on SO, about this error can be simply avoided. The time you spend to write a proper question (with a small working example and a small explanation) could easily much more than the time you'll need to debug your code. First of all, read this Eric Lippert's blog post about &lt;a href=&quot;http://ericlippert.com/2014/03/05/how-to-debug-small-programs/&quot;&gt;debugging of small programs&lt;/a&gt;, I won't repeat his words here but it's absolutely a &lt;em&gt;must read&lt;/em&gt;.</source>
          <target state="translated">私の意見では、このエラーに関するほとんどの質問（ここではSO）は単純に回避できます。 適切な質問を書くために費やす時間（小さな作業例と小さな説明を含む）は、コードのデバッグに必要な時間よりもはるかに多くなる可能性があります。 まず、 &lt;a href=&quot;http://ericlippert.com/2014/03/05/how-to-debug-small-programs/&quot;&gt;小さなプログラムのデバッグ&lt;/a&gt;に関するこのEric Lippertのブログ投稿を&lt;em&gt;読んでください&lt;/em&gt; 。ここで彼の言葉を繰り返すことはしませんが、 &lt;em&gt;必ず読む必要があります&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="edd9c3162520ffa6a25317a3046678c7840a5043" translate="yes" xml:space="preserve">
          <source>In one of previous examples we directly used &lt;code&gt;Array.IndexOf()&lt;/code&gt; return value. If we know it may fail then it's better to handle that case:</source>
          <target state="translated">前の例の1 &lt;code&gt;Array.IndexOf()&lt;/code&gt; 戻り値を直接使用しました 。 失敗する可能性があることがわかっている場合は、そのケースを処理することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0eaaf0f408d82787f7dce03834f5280173facd24" translate="yes" xml:space="preserve">
          <source>In that example, array indices are valid from 1 to 4. Of course, upper bound cannot be changed.</source>
          <target state="translated">その例では、配列のインデックスは1から4まで有効です。もちろん上限は変更できません。</target>
        </trans-unit>
        <trans-unit id="530b06e2da2492e2c8bc73420f839699bc382ee8" translate="yes" xml:space="preserve">
          <source>In the following example we create a raw bidimensional array of &lt;code&gt;Color&lt;/code&gt;. Each item represents a pixel, indices are from &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(imageWidth - 1, imageHeight - 1)&lt;/code&gt;.</source>
          <target state="translated">次の例では、 &lt;code&gt;Color&lt;/code&gt; の生の2次元配列を作成します。 各アイテムはピクセルを表し、インデックスは &lt;code&gt;(0, 0)&lt;/code&gt; から &lt;code&gt;(imageWidth - 1, imageHeight - 1)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="32a51fdd8deaa7d4b87e2ddb0c98c68d696f01dc" translate="yes" xml:space="preserve">
          <source>In this example, let me assume, for simplicity, that arrays are always monodimensional and 0-based. If you want to be strict (or you're developing a library), you may need to replace &lt;code&gt;0&lt;/code&gt; with &lt;code&gt;GetLowerBound(0)&lt;/code&gt; and &lt;code&gt;.Length&lt;/code&gt; with &lt;code&gt;GetUpperBound(0)&lt;/code&gt; (of course if you have parameters of type &lt;code&gt;System.Arra&lt;/code&gt;y, it doesn't apply for &lt;code&gt;T[]&lt;/code&gt;). Please note that in this case, upper bound is inclusive then this code:</source>
          <target state="translated">この例では、簡単にするために、配列は常に1次元で0ベースであると仮定します。 厳密にしたい場合（またはライブラリを開発している場合）、 &lt;code&gt;0&lt;/code&gt; を &lt;code&gt;GetLowerBound(0)&lt;/code&gt; に 、 &lt;code&gt;.Length&lt;/code&gt; を &lt;code&gt;GetUpperBound(0)&lt;/code&gt; に置き換える必要があります（もちろん、 &lt;code&gt;System.Arra&lt;/code&gt; y型のパラメーターがある場合は、 &lt;code&gt;T[]&lt;/code&gt; は適用されません）。 この場合、上限はこのコードを含むことに注意してください：</target>
        </trans-unit>
        <trans-unit id="40272c70580d7c109cb89e34d31411747867424c" translate="yes" xml:space="preserve">
          <source>Index was outside the bounds of the array.</source>
          <target state="translated">インデックスが配列の範囲外にありました。</target>
        </trans-unit>
        <trans-unit id="f4bb569161e53103307661e8b53e45107af3a570" translate="yes" xml:space="preserve">
          <source>Moreover please note that if you have a multidimensional array then you can't use &lt;code&gt;Array.Length&lt;/code&gt; for both dimension, you have to use &lt;code&gt;Array.GetLength()&lt;/code&gt;:</source>
          <target state="translated">さらに、多次元配列がある場合、両方の次元に &lt;code&gt;Array.Length&lt;/code&gt; を使用できないため、 &lt;code&gt;Array.GetLength()&lt;/code&gt; を使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="570a52861d8c447060bebaa3d7e734fd46e5d33b" translate="yes" xml:space="preserve">
          <source>Next example is a naive example to calculate occurrences of a given set of numbers (knowing maximum number and returning an array where item at index 0 represents number 0, items at index 1 represents number 1 and so on):</source>
          <target state="translated">次の例は、与えられた数の集合の出現率を計算するためのナイーブな例です(最大数を知り、インデックス0の項目が数0を表し、インデックス1の項目が数1を表す配列を返します)。</target>
        </trans-unit>
        <trans-unit id="d557f009913713cad73735b6dbf5343e1e1dfbca" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; throws &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; for the same cases where arrays use &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; は、配列が &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; を使用するのと同じ場合に &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; をスローすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bd651f30e77cb8c08ebc4ef5e06e931ce221c6fe" translate="yes" xml:space="preserve">
          <source>Of course, it's a pretty terrible implementation but what I want to show is that it'll fail for negative numbers and numbers above &lt;code&gt;maximum&lt;/code&gt;.</source>
          <target state="translated">もちろん、それはかなりひどい実装ですが、私が示したいのは、負の数と &lt;code&gt;maximum&lt;/code&gt; 超える数では失敗するということです。</target>
        </trans-unit>
        <trans-unit id="9ef9f43dc4d8385dc0e33e58565ca9eb5b222e6b" translate="yes" xml:space="preserve">
          <source>Often there is complex program state that maybe difficult to have control over at a particular point in code e.g a DB connection goes down so data for an input cannot be retrieved etc... This kind of issue often results in an Exception of some kind that has to bubble up to a higher level because where it occurs has no way of dealing with it at that point.</source>
          <target state="translated">DB 接続がダウンして入力のデータが取得できないなど、コードの特定の時点で制御することが難しい複雑なプログラム状態が発生することがよくあります。このような問題が発生すると、その時点では対処のしようがないため、より高いレベルに浮上しなければならない、ある種の例外が発生することがよくあります。</target>
        </trans-unit>
        <trans-unit id="27f8fcfb9ecd8c53b26dd0b2f91e65142b39621f" translate="yes" xml:space="preserve">
          <source>Please note that this behavior is shared with most &lt;code&gt;IDataReader&lt;/code&gt; implementations (&lt;code&gt;SqlDataReader&lt;/code&gt;, &lt;code&gt;OleDbDataReader&lt;/code&gt; and so on).</source>
          <target state="translated">この動作は、ほとんどの &lt;code&gt;IDataReader&lt;/code&gt; 実装（ &lt;code&gt;SqlDataReader&lt;/code&gt; 、 &lt;code&gt;OleDbDataReader&lt;/code&gt; など）と共有されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b97b5a8efe8a2722837e5c57560477b5040d0b1f" translate="yes" xml:space="preserve">
          <source>Please note that this is not allowed (it'll throw &lt;code&gt;InvalidCastException&lt;/code&gt;), that's why if your parameters are &lt;code&gt;T[]&lt;/code&gt; you're safe about custom lower bound arrays:</source>
          <target state="translated">これは許可されていないことに注意してください（ &lt;code&gt;InvalidCastException&lt;/code&gt; がスローされます）。そのため、パラメーターが &lt;code&gt;T[]&lt;/code&gt; 場合、カスタムの下限配列について安全です。</target>
        </trans-unit>
        <trans-unit id="96f3e922a9aef7a1879f91f29f818e5ff62931fb" translate="yes" xml:space="preserve">
          <source>Result will be:</source>
          <target state="translated">結果はこうなります。</target>
        </trans-unit>
        <trans-unit id="fabd2b4a718bdee98a8cc1784519325b35b0832c" translate="yes" xml:space="preserve">
          <source>Same cases as array - range of valid indexes - 0 (&lt;code&gt;List&lt;/code&gt;'s indexes always start with 0) to &lt;code&gt;list.Count&lt;/code&gt; - accessing elements outside of this range will cause the exception.</source>
          <target state="translated">配列と同じ場合-有効なインデックスの範囲-0（ &lt;code&gt;List&lt;/code&gt; のインデックスは常に0から &lt;code&gt;list.Count&lt;/code&gt; ます）からlist.Count-この範囲外の要素にアクセスすると例外が発生します。</target>
        </trans-unit>
        <trans-unit id="4caee130f7f88696a123daa568884e0a7a6c235c" translate="yes" xml:space="preserve">
          <source>Same scenario: whenever we try to access an array list, etc. we can only access the existing indexes in the array. &lt;code&gt;array[0]&lt;/code&gt; and &lt;code&gt;array[1]&lt;/code&gt; are existing. If we try to access &lt;code&gt;array[3]&lt;/code&gt;, it's not there actually, so an index out of bound exception will arise.</source>
          <target state="translated">同じシナリオ：配列リストなどにアクセスしようとするときはいつでも、配列内の既存のインデックスにしかアクセスできません。 &lt;code&gt;array[0]&lt;/code&gt; と &lt;code&gt;array[1]&lt;/code&gt; が存在します。 &lt;code&gt;array[3]&lt;/code&gt; にアクセスしようとすると、実際には存在しないため、範囲外のインデックスの例外が発生します。</target>
        </trans-unit>
        <trans-unit id="7d7463e8ea002eaac163acc85628793b0ec0e69f" translate="yes" xml:space="preserve">
          <source>Should be rewritten like this:</source>
          <target state="translated">このように書き換えるべきです。</target>
        </trans-unit>
        <trans-unit id="be76153017b0c155c35e835c740ed8b45e1ac779" translate="yes" xml:space="preserve">
          <source>Simple explanation about what a Index out of bound exception is:</source>
          <target state="translated">Index out of bound例外とは何かを簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="2d047b4d2d0dcbe67d0f58d382579d548af0a6ba" translate="yes" xml:space="preserve">
          <source>Size of array is 3 (indices 0, 1 and 2), but the for-loop loops 4 times (0, 1, 2 and 3).</source>
          <target state="translated">配列のサイズは3(インデックス0,1,2)ですが、フォーループは4回(0,1,2,3)ループします。</target>
        </trans-unit>
        <trans-unit id="b2fd41760f100eb04b3fbf11f90eaf5e88b79a94" translate="yes" xml:space="preserve">
          <source>So this loop will fill the array with 5 integers without causing any &lt;strong&gt;IndexOutOfRangeException&lt;/strong&gt;</source>
          <target state="translated">したがって、このループは、 &lt;strong&gt;IndexOutOfRangeException&lt;/strong&gt;を発生させることなく、配列を5つの整数で埋めます。</target>
        </trans-unit>
        <trans-unit id="2eceeacdc6960cb32b48adcd985da317ecc2c1d5" translate="yes" xml:space="preserve">
          <source>So when it tries to access outside the bounds with (3) it throws the exception.</source>
          <target state="translated">そのため、(3)で境界外にアクセスしようとすると例外が発生します。</target>
        </trans-unit>
        <trans-unit id="eef2eb7f26ac3a52b33b36028193756338fc756d" translate="yes" xml:space="preserve">
          <source>Suppose for example that you have retrieved a column named &lt;em&gt;Column1&lt;/em&gt; but then you try to retrieve the value of that field with</source>
          <target state="translated">たとえば、 &lt;em&gt;Column1&lt;/em&gt;という名前の列を取得したが、そのフィールドの値を取得しようとしたとします。</target>
        </trans-unit>
        <trans-unit id="5d5442589685d9f06310c6030d60b943cbbc03f6" translate="yes" xml:space="preserve">
          <source>The VB.NET rule</source>
          <target state="translated">VB.NETルール</target>
        </trans-unit>
        <trans-unit id="29a34df4c3a8b6265655372cf0b7ca0c4c58177b" translate="yes" xml:space="preserve">
          <source>The VB.NET side of the story</source>
          <target state="translated">VB.NET側の話</target>
        </trans-unit>
        <trans-unit id="107a9888b94abfe0f0842709b6d53a8d5a2cad39" translate="yes" xml:space="preserve">
          <source>There is another (documented) case when this exception is thrown: if, in &lt;code&gt;DataView&lt;/code&gt;, data column name being supplied to the &lt;code&gt;DataViewSort&lt;/code&gt; property is not valid.</source>
          <target state="translated">この例外がスローされる別の（文書化された）ケースがあり &lt;code&gt;DataView&lt;/code&gt; で、 &lt;code&gt;DataViewSort&lt;/code&gt; プロパティに提供されているデータ列名が無効な場合です。</target>
        </trans-unit>
        <trans-unit id="2feb23c1a9eaeb80736074afbcae4a7353c3d269" translate="yes" xml:space="preserve">
          <source>This code will then fail because array is 0-based and last (bottom-right) pixel in the image is &lt;code&gt;pixels[imageWidth - 1, imageHeight - 1]&lt;/code&gt;:</source>
          <target state="translated">配列は0ベースであり、画像の最後（右下）のピクセルは &lt;code&gt;pixels[imageWidth - 1, imageHeight - 1]&lt;/code&gt; ため、このコードは失敗します 。</target>
        </trans-unit>
        <trans-unit id="7b0ef8f0aa42bf47870a059eee92fc5398d3ebb4" translate="yes" xml:space="preserve">
          <source>This exception may be thrown for another reason too: by convention, many &lt;em&gt;search functions&lt;/em&gt; will return -1 (nullables has been introduced with .NET 2.0 and anyway it's also a well-known convention in use from many years) if they didn't find anything. Let's imagine you have an array of objects comparable with a string. You may think to write this code:</source>
          <target state="translated">この例外は別の理由でもスローされる可能性があります。慣例により、多くの&lt;em&gt;検索関数&lt;/em&gt;は-1を返します（nullableは.NET 2.0で導入され、とにかく長年使用されているよく知られた慣例でもあります）。何でも。 文字列に匹敵するオブジェクトの配列があるとしましょう。 あなたはこのコードを書くことを考えるかもしれません：</target>
        </trans-unit>
        <trans-unit id="a2fcd2cd1cb1036644f107b16a8890283d860e72" translate="yes" xml:space="preserve">
          <source>This exception means that you're trying to access a collection item by index, using an invalid index. An index is invalid when it's lower than the collection's lower bound or greater than &lt;del&gt;equal to the number of elements it contains.&lt;/del&gt; the maximum allowed index defined in the array declaration</source>
          <target state="translated">この例外は、無効なインデックスを使用して、インデックスでコレクションアイテムにアクセスしようとしていることを意味します。 インデックスがコレクションの下限よりも小さいか、またはより大きい場合、インデックスは無効です &lt;del&gt; それが含む要素の数に等しい。 &lt;/del&gt; 配列宣言で定義された最大許容インデックス</target>
        </trans-unit>
        <trans-unit id="e7dec47f74c256ee0220fc295a632aecdf0b27a6" translate="yes" xml:space="preserve">
          <source>This exception means that you're trying to access a collection item by index, using an invalid index. An index is invalid when it's lower than the collection's lower bound or greater than or equal to the number of elements it contains.</source>
          <target state="translated">この例外は、無効なインデックスを使用して、コレクション項目にインデックスでアクセスしようとしていることを意味します。インデックスがコレクションの下限よりも低い場合、または含まれる要素の数以上の場合は無効です。</target>
        </trans-unit>
        <trans-unit id="9e01fe07c21102f88931eb8da4f078ace2acf044" translate="yes" xml:space="preserve">
          <source>This happens because the indexer operator is implemented trying to retrieve the index of a &lt;em&gt;Colum1&lt;/em&gt; field that doesn't exist. The GetOrdinal method will throw this exception when its internal helper code returns a -1 as the index of &quot;Colum1&quot;.</source>
          <target state="translated">これは、存在しない&lt;em&gt;Colum1&lt;/em&gt;フィールドのインデックスを取得しようとしてインデクサーオペレーターが実装されているために発生します。 GetOrdinalメソッドは、その内部ヘルパーコードが「Colum1」のインデックスとして-1を返すと、この例外をスローします。</target>
        </trans-unit>
        <trans-unit id="e8ae00193f164544dc369987db61ee45ff297184" translate="yes" xml:space="preserve">
          <source>This will fail if no items in &lt;code&gt;myArray&lt;/code&gt; will satisfy search condition because &lt;code&gt;Array.IndexOf()&lt;/code&gt; will return -1 and then array access will throw.</source>
          <target state="translated">&lt;code&gt;Array.IndexOf()&lt;/code&gt; が-1を返し、配列アクセスがスローされるため、 &lt;code&gt;myArray&lt;/code&gt; のどの項目も検索条件を満たす場合、これは失敗します。</target>
        </trans-unit>
        <trans-unit id="1448888ed15547b9b90d018b51d2e99215c5719e" translate="yes" xml:space="preserve">
          <source>To easily understand the problem, imagine we wrote this code:</source>
          <target state="translated">問題を簡単に理解するには、次のようなコードを書いたと想像してみてください。</target>
        </trans-unit>
        <trans-unit id="d75990cb468491d4aee74eb65a49267c49a02831" translate="yes" xml:space="preserve">
          <source>Unlike arrays, &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; starts empty - so trying to access items of just created list lead to this exception.</source>
          <target state="translated">配列とは異なり、 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; は空から始まります。そのため、作成されたばかりのリストのアイテムにアクセスしようとすると、この例外が発生します。</target>
        </trans-unit>
        <trans-unit id="85b71ece91202721794d3f3aa2f8575d83d210c3" translate="yes" xml:space="preserve">
          <source>What Is It?</source>
          <target state="translated">それは何ですか?</target>
        </trans-unit>
        <trans-unit id="d038b6b88960ddb547851582deb4aa9178a9143a" translate="yes" xml:space="preserve">
          <source>What does this mean, and what can I do about it?</source>
          <target state="translated">これはどういうことなのか、どうすればいいのか。</target>
        </trans-unit>
        <trans-unit id="db3e9dce32f32c752d89721d4714009559cf8ea7" translate="yes" xml:space="preserve">
          <source>What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it</source>
          <target state="translated">IndexOutOfOfRangeException ArgumentOutOfRangeException とは?</target>
        </trans-unit>
        <trans-unit id="64d2ca343b2d11209d8e98e83bbc370189858b2f" translate="yes" xml:space="preserve">
          <source>When It Is Thrown</source>
          <target state="translated">投げられたとき</target>
        </trans-unit>
        <trans-unit id="b6cd6c3e3375f53769e3f51014aa013895a17062" translate="yes" xml:space="preserve">
          <source>You can access this array from 0 to 3, values outside this range will cause &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; to be thrown. Remember this when you create and access an array.</source>
          <target state="translated">この配列には0〜3の範囲でアクセスできます。この範囲外の値を指定すると、 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; がスローされます。 アレイを作成してアクセスするときは、このことを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="a435dd41b664b49681c0f5d1ce876301860c479a" translate="yes" xml:space="preserve">
          <source>You can get the same exception also if you use the IDataReader overload of the indexer operator that takes a column name and pass an invalid column name.</source>
          <target state="translated">カラム名を受け取り、無効なカラム名を渡すインデクサ演算子のIDataReaderオーバーロードを使用しても、同じ例外が発生します。</target>
        </trans-unit>
        <trans-unit id="fc1e14f5925304435bda2fd3d2ff334f6898cf6b" translate="yes" xml:space="preserve">
          <source>You found your error, check how &lt;code&gt;index&lt;/code&gt; increases. Is it right? Check how array is allocated, is coherent with how &lt;code&gt;index&lt;/code&gt; increases? Is it right according to your specifications? If you answer &lt;em&gt;yes&lt;/em&gt; to all these questions, then you'll find good help here on StackOverflow but please first check for that by yourself. You'll save your own time!</source>
          <target state="translated">エラーが見つかりました。 &lt;code&gt;index&lt;/code&gt; 増加方法を確認してください。 正しいですか？ 配列の割り当て方法を確認してください。 &lt;code&gt;index&lt;/code&gt; 増加方法と一致していますか？ 仕様通りですか？ これらすべての質問に&lt;em&gt;「はい」&lt;/em&gt;と答えると、StackOverflowで役立つヘルプが見つかりますが、まず自分で確認してください。 自分の時間を節約できます！</target>
        </trans-unit>
        <trans-unit id="250a56e82d76e86df3aa532f5df265e03cc75d27" translate="yes" xml:space="preserve">
          <source>You have source code, you have exception message with a stack trace. Go there, pick right line number and you'll see:</source>
          <target state="translated">ソースコードとスタックトレースの例外メッセージがあります。そこに行って、右の行番号を選んでください。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
