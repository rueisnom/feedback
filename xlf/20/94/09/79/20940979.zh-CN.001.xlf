<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/20940979">
    <body>
      <group id="20940979">
        <trans-unit id="90157ae76a08af0a3a22d7b35660a60c0952288c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GetString()&lt;/code&gt; will throw &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; because you're dataset has only two columns but you're trying to get a value from 3rd one (indices are &lt;em&gt;always&lt;/em&gt; 0-based).</source>
          <target state="translated">&lt;code&gt;GetString()&lt;/code&gt; 将抛出 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; ,因为您的数据集只有两列，但是您试图从第3个列中获取一个值（索引&lt;em&gt;始终&lt;/em&gt;基于0）。</target>
        </trans-unit>
        <trans-unit id="6e82abbf74c093ad6a49b85e4604cb669c37d2d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IndexOutOfRangeException&lt;/code&gt; is generally different in that it in most cases it is pretty trivial to check for at the point where the exception is being raised.  Generally this kind of exception get thrown by some code that could very easily deal with the issue at the place it is occurring - just by checking the actual length of the array.  You don't want to 'fix' this by handling this exception higher up - but instead by ensuring its not thrown in the first instance - which in most cases is easy to do by checking the array length.</source>
          <target state="translated">&lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 通常有所不同，因为在大多数情况下，在引发异常的位置进行检查非常简单。 通常，这种异常会被某些代码抛出，这些代码可以很容易地在发生问题的地方进行处理-只需检查数组的实际长度即可。 您不想通过更高级别处理此异常来&amp;ldquo;解决&amp;rdquo;此问题，而是通过确保不在第一实例中抛出该异常来解决此问题，在大多数情况下，通过检查数组长度即可轻松做到这一点。</target>
        </trans-unit>
        <trans-unit id="e384b1ac38528cf2b153179ee64c5c07891a0262" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;First item in arrays has always index 0&lt;/em&gt;. This is not always true because you can create an array with a custom lower bound:</source>
          <target state="translated">&lt;em&gt;数组中的第一项始终具有索引0&lt;/em&gt; 。 这并不总是正确的，因为您可以创建具有自定义下限的数组：</target>
        </trans-unit>
        <trans-unit id="02fe3c2ec3752f01939a625bda6b22efdd43fc7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Just think one train is there its compartments are D1,D2,D3.
One passenger came to enter the train and he have the ticket for D4.
now what will happen. the passenger want to enter a compartment that does not exist so obviously problem will arise.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;试想一下，有一列火车的车厢是D1，D2，D3。&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;一位乘客进入火车，他有D4的票。&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;现在会发生什么。&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;乘客想要进入一个不存在的车厢，因此显然会出现问题。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc2e9df144a904ca7e654e3151e719003968083d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Special&lt;/em&gt; Arrays With Custom Lower Bound&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;具有自定义下界的&lt;em&gt;特殊&lt;/em&gt;数组&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="585a20b3a1b5efe5d8ac80cc5fb5c37c9fe438f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array Length&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;阵列长度&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="219b82a1e751af97e51e37c164a80c71e6ab177e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays Do Not Grow&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;数组不增长&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6a5525b746c8370f4e56003defd53c493ddeb6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check Object State&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;检查对象状态&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c45556dd62755f58a0dbbe669c6bbe02448a2daf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How it applies to &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx&quot;&gt;&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;它如何应用于&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx&quot;&gt; &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; ？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68f01d14d713169ff7c034d4ab53d72b3d416586" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IDataReader and Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IDataReader和列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="830bf9eb4cb1898d0ede130953d19e72968029bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Others&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Others&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b840c57c128f4bfe2ea512de26ab75218adb38a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unexpected Results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;意外的结果&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="354119c5be040a4156893c8c1927c10b93fd64db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Upper Bound Is Not Inclusive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;上限不包括在内&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69073d14195994c9068b40b723887a0ff4c2e715" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Validate Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;验证参数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5a3215f12d670c927c04e4f1ae816dec54af5a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Validate Return Values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;验证返回值&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98c7e1be1d82ea36b991a9791f2b7fb7af4ce1ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wrong Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;错误的论点&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a8b1f21ee4f3d1496817ff5cf7d9a607a0aeb2e6" translate="yes" xml:space="preserve">
          <source>A good start point is to always use assertions and to validate inputs. You may even want to use code contracts. When something went wrong and you can't figure out what happens with a quick look at your code then you have to resort to an old friend: &lt;strong&gt;debugger&lt;/strong&gt;. Just run your application in debug inside Visual Studio (or your favorite IDE), you'll see exactly which line throws this exception, which array is involved and which index you're trying to use. Really, 99% of the times you'll solve it by yourself in a few minutes.</source>
          <target state="translated">一个好的起点是始终使用断言并验证输入。 您甚至可能想要使用代码合同。 当出现问题时，您无法通过快速查看代码来判断会发生什么，那么您必须求助于老朋友： &lt;strong&gt;debugger&lt;/strong&gt; 。 只需在Visual Studio（或您最喜欢的IDE）中的调试中运行您的应用程序，您就会确切地看到哪一行引发此异常，涉及哪个数组以及您要使用哪个索引。 确实，您有99％的时间会在几分钟内自行解决。</target>
        </trans-unit>
        <trans-unit id="918d55df9a652e86c4424371b8022ca5c74d8fd7" translate="yes" xml:space="preserve">
          <source>A side from the very long complete accepted answer there is an important point to make about &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; compared with many other exception types, and that is:</source>
          <target state="translated">与一个很长的完整接受的答案相比，与许多其他异常类型相比， &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 有一个重要的意义，那就是：</target>
        </trans-unit>
        <trans-unit id="590ef1689a35dd4e7ed120fafde303e4f853d31a" translate="yes" xml:space="preserve">
          <source>An array is fast. Very fast in linear search compared to every other collection. It is because items are contiguous in memory so memory address can be calculated (and increment is just an addition). No need to follow a node list, simple math! You pay this with a limitation: they can't grow, if you need more elements you need to reallocate that array (this may take a relatively long time if old items must be copied to a new block). You resize them with &lt;code&gt;Array.Resize&amp;lt;T&amp;gt;()&lt;/code&gt;, this example adds a new entry to an existing array:</source>
          <target state="translated">数组很快。 与所有其他集合相比，线性搜索非常快。 这是因为项目在内存中是连续的，所以可以计算内存地址（增量只是一个加法）。 无需遵循节点列表，简单的数学运算！ 您为此付出了一定的限制：它们无法增长，如果您需要更多的元素，则需要重新分配该数组（如果必须将旧项目复制到新块中，则可能会花费较长的时间）。 使用 &lt;code&gt;Array.Resize&amp;lt;T&amp;gt;()&lt;/code&gt; 调整它们的大小，此示例将一个新条目添加到现有数组：</target>
        </trans-unit>
        <trans-unit id="0b202a6b93b0ad3a0b8b0e09acb9d27754d6a75e" translate="yes" xml:space="preserve">
          <source>An exception of type 'System.ArgumentOutOfRangeException' occurred in mscorlib.dll but was not handled in user code Additional information: Index was out of range. Must be non-negative and less than the size of the collection.</source>
          <target state="translated">mscorlib.dll中发生了'System.ArgumentOutOfRangeException'类型的异常,但在用户代码中没有处理。索引超出了范围。必须为非负值且小于集合的大小。</target>
        </trans-unit>
        <trans-unit id="fd779c4366caa60dd63adc01044809905187b95d" translate="yes" xml:space="preserve">
          <source>Another way of putting this is that other exceptions can arise due to genuine lack of control over input or program state BUT &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; more often than not is simply just pilot (programmer) error.</source>
          <target state="translated">另一种表达方式是，由于对输入或程序状态的真正缺乏控制而可能会导致其他异常，但BUT &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 通常不仅仅是飞行员（程序员）错误。</target>
        </trans-unit>
        <trans-unit id="51e4f40de8bfab70e2225354db35d9faafa79f94" translate="yes" xml:space="preserve">
          <source>Array index may not come directly from a parameter. It may be part of object state. In general is always a good practice to validate object state (by itself and with function parameters, if needed). You can use &lt;code&gt;Debug.Assert()&lt;/code&gt;, throw a proper exception (more descriptive about the problem) or handle that like in this example:</source>
          <target state="translated">数组索引可能不直接来自参数。 它可能是对象状态的一部分。 通常，验证对象状态（根据需要以及使用功能参数）始终是一种良好的做法。 您可以使用 &lt;code&gt;Debug.Assert()&lt;/code&gt; ，抛出适当的异常（对问题的描述性更高）或像下面的示例一样处理该异常：</target>
        </trans-unit>
        <trans-unit id="b9f2099dfa78e0a0cb9a9cacf32f191610f4e09d" translate="yes" xml:space="preserve">
          <source>Common case is to populate list with indexing (similar to &lt;code&gt;Dictionary&amp;lt;int, T&amp;gt;&lt;/code&gt;) will cause exception:</source>
          <target state="translated">常见情况是用索引填充列表（类似于 &lt;code&gt;Dictionary&amp;lt;int, T&amp;gt;&lt;/code&gt; ）将导致异常：</target>
        </trans-unit>
        <trans-unit id="25bb3e5e2d21ab7475b6402126c502ae27235124" translate="yes" xml:space="preserve">
          <source>Depending on classes used it can also be &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt;</source>
          <target state="translated">根据使用的类，它也可以是 &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b23b0799bcc8b2ce81bdf52bb9e099981c0d4d4" translate="yes" xml:space="preserve">
          <source>Don't forget that valid indices are from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;Length - 1&lt;/code&gt;. If you simply try to assign an item at &lt;code&gt;Length&lt;/code&gt; you'll get &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; (this behavior may confuse you if you think they may increase with a syntax similar to &lt;code&gt;Insert&lt;/code&gt; method of other collections).</source>
          <target state="translated">别忘了有效索引的范围是 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;Length - 1&lt;/code&gt; 。 如果您只是简单地尝试将一个项目分配为 &lt;code&gt;Length&lt;/code&gt; ，则会得到 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; （如果您认为它们的使用类似于其他集合的 &lt;code&gt;Insert&lt;/code&gt; 方法的语法会增加，则此行为可能会使您感到困惑）。</target>
        </trans-unit>
        <trans-unit id="9b27fd7fe4b50df7d96174836b344cc4290d5689" translate="yes" xml:space="preserve">
          <source>Everything that we have said in the C# answer is valid for VB.NET with the obvious syntax differences but there is an important point to consider when you deal with VB.NET arrays.</source>
          <target state="translated">我们在C#答案中所说的所有内容,在VB.NET中都是有效的,有明显的语法差异,但在处理VB.NET数组时,有一个重要的点需要考虑。</target>
        </trans-unit>
        <trans-unit id="9b0d70e741d1af30dcaad5c3bd9539dbb820958c" translate="yes" xml:space="preserve">
          <source>Given an array declared as:</source>
          <target state="translated">给出一个数组,声明为:</target>
        </trans-unit>
        <trans-unit id="634c81757628431baf46510d0fe88d9be1baed40" translate="yes" xml:space="preserve">
          <source>How to Avoid</source>
          <target state="translated">如何避免</target>
        </trans-unit>
        <trans-unit id="5b89063333bb026e82eef2450102f0542fe56b68" translate="yes" xml:space="preserve">
          <source>How to Debug</source>
          <target state="translated">如何调试</target>
        </trans-unit>
        <trans-unit id="9054b410bcbb93070af4dc6c3c5cb26cb599c747" translate="yes" xml:space="preserve">
          <source>I have some code and when it executes, it throws a &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;, saying,</source>
          <target state="translated">我有一些代码，执行时会抛出 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; ，说，</target>
        </trans-unit>
        <trans-unit id="b7e20f4df8a1a037e7ebf260c1409ec6d68d3f62" translate="yes" xml:space="preserve">
          <source>If function is private you may simply replace &lt;code&gt;if&lt;/code&gt; logic with &lt;code&gt;Debug.Assert()&lt;/code&gt;:</source>
          <target state="translated">如果函数是私有的，则可以用 &lt;code&gt;Debug.Assert()&lt;/code&gt; 替换 &lt;code&gt;if&lt;/code&gt; 逻辑：</target>
        </trans-unit>
        <trans-unit id="35c8969ec9cb494058d0a4f6bd3ead6a41ac90ee" translate="yes" xml:space="preserve">
          <source>If index comes from a parameter you should always validate them (throwing appropriate &lt;code&gt;ArgumentException&lt;/code&gt; or &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt;). In the next example, wrong parameters may cause &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;, users of this function may expect this because they're passing an array but it's not always so obvious. I'd suggest to always validate parameters for public functions:</source>
          <target state="translated">如果索引来自某个参数，则应始终对其进行验证（抛出适当的 &lt;code&gt;ArgumentException&lt;/code&gt; 或 &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; ）。 在下一个示例中，错误的参数可能会导致 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; ，此函数的用户可能会期望这样做，因为他们正在传递数组，但并不总是那么明显。 我建议始终验证公共功能的参数：</target>
        </trans-unit>
        <trans-unit id="41c04df0b1cc86ae38c46937975285a88af8013e" translate="yes" xml:space="preserve">
          <source>If this happens in production then you'd better to add assertions in incriminated code, probably we won't see in your code what you can't see by yourself (but you can always bet).</source>
          <target state="translated">如果这种情况发生在生产中,那么你最好在被污染的代码中添加断言,可能我们不会在你的代码中看到你自己看不到的东西(但你可以随时打赌)。</target>
        </trans-unit>
        <trans-unit id="2b987be037398d3c129254a55d4e390c131f0e51" translate="yes" xml:space="preserve">
          <source>If you access an array using unvalidated arguments (from user input or from function user) you may get this error:</source>
          <target state="translated">如果你使用未验证的参数(来自用户输入或函数用户)访问数组,你可能会得到这个错误。</target>
        </trans-unit>
        <trans-unit id="9227b461684c699e8e65d0bf1176a729c1a582df" translate="yes" xml:space="preserve">
          <source>Imagine you're trying to read data from a database with this code:</source>
          <target state="translated">想象一下,你正试图用这段代码从数据库中读取数据。</target>
        </trans-unit>
        <trans-unit id="cc7a9efc85a264d77dd9f0d9027c47e5cf9aa6ef" translate="yes" xml:space="preserve">
          <source>In C#, usually, arrays are 0-based. It means that first element has index 0 and last element has index &lt;code&gt;Length - 1&lt;/code&gt; (where &lt;code&gt;Length&lt;/code&gt; is total number of items in the array) so this code doesn't work:</source>
          <target state="translated">通常，在C＃中，数组基于0。 这意味着第一个元素的索引为0，最后一个元素的索引为 &lt;code&gt;Length - 1&lt;/code&gt; （其中 &lt;code&gt;Length&lt;/code&gt; 是数组中项目的总数），因此此代码不起作用：</target>
        </trans-unit>
        <trans-unit id="fd6bbf267ba207b6ab0dbf6146519797f071cf4c" translate="yes" xml:space="preserve">
          <source>In VB.NET, arrays are declared setting the maximum valid index value for the array. It is not the count of the elements that we want to store in the array.</source>
          <target state="translated">在VB.NET中,数组的声明是为数组设置最大有效索引值。它不是我们要存储在数组中的元素的计数。</target>
        </trans-unit>
        <trans-unit id="dfcd9df83ee30d7d807a5c86bffb1eab90e4c481" translate="yes" xml:space="preserve">
          <source>In another scenario you may get &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; for this code (for example if you're using &lt;code&gt;GetPixel&lt;/code&gt; method on a &lt;code&gt;Bitmap&lt;/code&gt; class).</source>
          <target state="translated">在另一种情况下，您可能会为此代码获取 &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; （例如，如果您在 &lt;code&gt;Bitmap&lt;/code&gt; 类上使用 &lt;code&gt;GetPixel&lt;/code&gt; 方法）。</target>
        </trans-unit>
        <trans-unit id="a096121cdf696e4cc12035da5ed6a1a2d6a4cfea" translate="yes" xml:space="preserve">
          <source>In my opinion, most of the questions, here on SO, about this error can be simply avoided. The time you spend to write a proper question (with a small working example and a small explanation) could easily much more than the time you'll need to debug your code. First of all, read this Eric Lippert's blog post about &lt;a href=&quot;http://ericlippert.com/2014/03/05/how-to-debug-small-programs/&quot;&gt;debugging of small programs&lt;/a&gt;, I won't repeat his words here but it's absolutely a &lt;em&gt;must read&lt;/em&gt;.</source>
          <target state="translated">我认为，SO上有关此错误的大多数问题都可以简单地避免。 您花费在编写适当的问题上的时间（带有一个简单的示例和一个简短的解释）所花的时间可能比调试代码所花费的时间要容易得多。 首先，请阅读Eric Lippert的有关&lt;a href=&quot;http://ericlippert.com/2014/03/05/how-to-debug-small-programs/&quot;&gt;调试小程序&lt;/a&gt;的博客文章，在这里我不会重复他的话，但这绝对是一本&lt;em&gt;必读的书&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="edd9c3162520ffa6a25317a3046678c7840a5043" translate="yes" xml:space="preserve">
          <source>In one of previous examples we directly used &lt;code&gt;Array.IndexOf()&lt;/code&gt; return value. If we know it may fail then it's better to handle that case:</source>
          <target state="translated">在前面的示例中，我们直接使用 &lt;code&gt;Array.IndexOf()&lt;/code&gt; 返回值。 如果我们知道它可能会失败，那么最好处理这种情况：</target>
        </trans-unit>
        <trans-unit id="0eaaf0f408d82787f7dce03834f5280173facd24" translate="yes" xml:space="preserve">
          <source>In that example, array indices are valid from 1 to 4. Of course, upper bound cannot be changed.</source>
          <target state="translated">在这个例子中,数组索引从1到4都是有效的。当然,上界不能改变。</target>
        </trans-unit>
        <trans-unit id="530b06e2da2492e2c8bc73420f839699bc382ee8" translate="yes" xml:space="preserve">
          <source>In the following example we create a raw bidimensional array of &lt;code&gt;Color&lt;/code&gt;. Each item represents a pixel, indices are from &lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(imageWidth - 1, imageHeight - 1)&lt;/code&gt;.</source>
          <target state="translated">在下面的示例中，我们创建 &lt;code&gt;Color&lt;/code&gt; 的原始二维数组。 每个项目代表一个像素，索引从 &lt;code&gt;(0, 0)&lt;/code&gt; 到 &lt;code&gt;(imageWidth - 1, imageHeight - 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32a51fdd8deaa7d4b87e2ddb0c98c68d696f01dc" translate="yes" xml:space="preserve">
          <source>In this example, let me assume, for simplicity, that arrays are always monodimensional and 0-based. If you want to be strict (or you're developing a library), you may need to replace &lt;code&gt;0&lt;/code&gt; with &lt;code&gt;GetLowerBound(0)&lt;/code&gt; and &lt;code&gt;.Length&lt;/code&gt; with &lt;code&gt;GetUpperBound(0)&lt;/code&gt; (of course if you have parameters of type &lt;code&gt;System.Arra&lt;/code&gt;y, it doesn't apply for &lt;code&gt;T[]&lt;/code&gt;). Please note that in this case, upper bound is inclusive then this code:</source>
          <target state="translated">在此示例中，为简单起见，让我假设数组始终是一维的并且基于0。 如果要严格（或者正在开发库），则可能需要用 &lt;code&gt;GetLowerBound(0)&lt;/code&gt; 替换 &lt;code&gt;0&lt;/code&gt; 并用GetUpperBound（0）替换.Length（当然，如果您有 &lt;code&gt;System.Arra&lt;/code&gt; y类型的参数，不适用于 &lt;code&gt;T[]&lt;/code&gt; ）。 请注意，在这种情况下，上限包含以下代码：</target>
        </trans-unit>
        <trans-unit id="40272c70580d7c109cb89e34d31411747867424c" translate="yes" xml:space="preserve">
          <source>Index was outside the bounds of the array.</source>
          <target state="translated">索引是在数组的范围之外。</target>
        </trans-unit>
        <trans-unit id="f4bb569161e53103307661e8b53e45107af3a570" translate="yes" xml:space="preserve">
          <source>Moreover please note that if you have a multidimensional array then you can't use &lt;code&gt;Array.Length&lt;/code&gt; for both dimension, you have to use &lt;code&gt;Array.GetLength()&lt;/code&gt;:</source>
          <target state="translated">此外请注意，如果您有多维数组，则不能对两个维度都使用 &lt;code&gt;Array.GetLength()&lt;/code&gt; ，而必须使用Array.GetLength（） ：</target>
        </trans-unit>
        <trans-unit id="570a52861d8c447060bebaa3d7e734fd46e5d33b" translate="yes" xml:space="preserve">
          <source>Next example is a naive example to calculate occurrences of a given set of numbers (knowing maximum number and returning an array where item at index 0 represents number 0, items at index 1 represents number 1 and so on):</source>
          <target state="translated">下一个例子是一个天真的例子,用来计算一组数字的出现次数(知道最大的数字并返回一个数组,其中索引0的项代表数字0,索引1的项代表数字1,以此类推)。</target>
        </trans-unit>
        <trans-unit id="d557f009913713cad73735b6dbf5343e1e1dfbca" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; throws &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; for the same cases where arrays use &lt;code&gt;IndexOutOfRangeException&lt;/code&gt;.</source>
          <target state="translated">请注意，对于数组使用 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 的情况， &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 会引发 &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd651f30e77cb8c08ebc4ef5e06e931ce221c6fe" translate="yes" xml:space="preserve">
          <source>Of course, it's a pretty terrible implementation but what I want to show is that it'll fail for negative numbers and numbers above &lt;code&gt;maximum&lt;/code&gt;.</source>
          <target state="translated">当然，这是一个非常糟糕的实现，但是我想展示的是它会因为负数和大于max的数而失败。</target>
        </trans-unit>
        <trans-unit id="9ef9f43dc4d8385dc0e33e58565ca9eb5b222e6b" translate="yes" xml:space="preserve">
          <source>Often there is complex program state that maybe difficult to have control over at a particular point in code e.g a DB connection goes down so data for an input cannot be retrieved etc... This kind of issue often results in an Exception of some kind that has to bubble up to a higher level because where it occurs has no way of dealing with it at that point.</source>
          <target state="translated">经常会有一些复杂的程序状态,可能在代码中的某一点上很难控制,例如DB连接中断,无法检索到输入的数据等等。这类问题通常会导致某种类型的异常(Exception)的出现,而这些异常必须上升到更高的级别,因为在这一点上没有办法处理。</target>
        </trans-unit>
        <trans-unit id="27f8fcfb9ecd8c53b26dd0b2f91e65142b39621f" translate="yes" xml:space="preserve">
          <source>Please note that this behavior is shared with most &lt;code&gt;IDataReader&lt;/code&gt; implementations (&lt;code&gt;SqlDataReader&lt;/code&gt;, &lt;code&gt;OleDbDataReader&lt;/code&gt; and so on).</source>
          <target state="translated">请注意，此行为与大多数 &lt;code&gt;IDataReader&lt;/code&gt; 实现（ &lt;code&gt;SqlDataReader&lt;/code&gt; ， &lt;code&gt;OleDbDataReader&lt;/code&gt; 等）共享。</target>
        </trans-unit>
        <trans-unit id="b97b5a8efe8a2722837e5c57560477b5040d0b1f" translate="yes" xml:space="preserve">
          <source>Please note that this is not allowed (it'll throw &lt;code&gt;InvalidCastException&lt;/code&gt;), that's why if your parameters are &lt;code&gt;T[]&lt;/code&gt; you're safe about custom lower bound arrays:</source>
          <target state="translated">请注意，这是不允许的（它会引发 &lt;code&gt;InvalidCastException&lt;/code&gt; ），这就是为什么如果您的参数是 &lt;code&gt;T[]&lt;/code&gt; 那么对于自定义下限数组是安全的：</target>
        </trans-unit>
        <trans-unit id="96f3e922a9aef7a1879f91f29f818e5ff62931fb" translate="yes" xml:space="preserve">
          <source>Result will be:</source>
          <target state="translated">结果将是:</target>
        </trans-unit>
        <trans-unit id="fabd2b4a718bdee98a8cc1784519325b35b0832c" translate="yes" xml:space="preserve">
          <source>Same cases as array - range of valid indexes - 0 (&lt;code&gt;List&lt;/code&gt;'s indexes always start with 0) to &lt;code&gt;list.Count&lt;/code&gt; - accessing elements outside of this range will cause the exception.</source>
          <target state="translated">与数组相同-有效索引范围-0（ &lt;code&gt;List&lt;/code&gt; 的索引始终以0开头）到 &lt;code&gt;list.Count&lt;/code&gt; 访问此范围之外的元素将导致异常。</target>
        </trans-unit>
        <trans-unit id="4caee130f7f88696a123daa568884e0a7a6c235c" translate="yes" xml:space="preserve">
          <source>Same scenario: whenever we try to access an array list, etc. we can only access the existing indexes in the array. &lt;code&gt;array[0]&lt;/code&gt; and &lt;code&gt;array[1]&lt;/code&gt; are existing. If we try to access &lt;code&gt;array[3]&lt;/code&gt;, it's not there actually, so an index out of bound exception will arise.</source>
          <target state="translated">同样的情况：每当我们尝试访问数组列表等时，我们只能访问数组中的现有索引。 &lt;code&gt;array[0]&lt;/code&gt; 和 &lt;code&gt;array[1]&lt;/code&gt; 存在。 如果我们尝试访问 &lt;code&gt;array[3]&lt;/code&gt; ，那么它实际上并不存在，因此将出现索引超出范围的异常。</target>
        </trans-unit>
        <trans-unit id="7d7463e8ea002eaac163acc85628793b0ec0e69f" translate="yes" xml:space="preserve">
          <source>Should be rewritten like this:</source>
          <target state="translated">应该是这样改写的。</target>
        </trans-unit>
        <trans-unit id="be76153017b0c155c35e835c740ed8b45e1ac779" translate="yes" xml:space="preserve">
          <source>Simple explanation about what a Index out of bound exception is:</source>
          <target state="translated">简单解释一下什么是Index out of bound异常。</target>
        </trans-unit>
        <trans-unit id="2d047b4d2d0dcbe67d0f58d382579d548af0a6ba" translate="yes" xml:space="preserve">
          <source>Size of array is 3 (indices 0, 1 and 2), but the for-loop loops 4 times (0, 1, 2 and 3).</source>
          <target state="translated">阵列的大小为3(索引0、1和2),但for-loop循环4次(0、1、2和3)。</target>
        </trans-unit>
        <trans-unit id="b2fd41760f100eb04b3fbf11f90eaf5e88b79a94" translate="yes" xml:space="preserve">
          <source>So this loop will fill the array with 5 integers without causing any &lt;strong&gt;IndexOutOfRangeException&lt;/strong&gt;</source>
          <target state="translated">因此，此循环将使用5个整数填充数组，而不会引起任何&lt;strong&gt;IndexOutOfRangeException&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2eceeacdc6960cb32b48adcd985da317ecc2c1d5" translate="yes" xml:space="preserve">
          <source>So when it tries to access outside the bounds with (3) it throws the exception.</source>
          <target state="translated">所以当它试图用(3)访问界外时,会抛出异常。</target>
        </trans-unit>
        <trans-unit id="eef2eb7f26ac3a52b33b36028193756338fc756d" translate="yes" xml:space="preserve">
          <source>Suppose for example that you have retrieved a column named &lt;em&gt;Column1&lt;/em&gt; but then you try to retrieve the value of that field with</source>
          <target state="translated">例如，假设您检索了一个名为&lt;em&gt;Column1&lt;/em&gt;的列，然后尝试使用以下方法检索该字段的值</target>
        </trans-unit>
        <trans-unit id="5d5442589685d9f06310c6030d60b943cbbc03f6" translate="yes" xml:space="preserve">
          <source>The VB.NET rule</source>
          <target state="translated">VB.NET规则</target>
        </trans-unit>
        <trans-unit id="29a34df4c3a8b6265655372cf0b7ca0c4c58177b" translate="yes" xml:space="preserve">
          <source>The VB.NET side of the story</source>
          <target state="translated">VB.NET方面的故事</target>
        </trans-unit>
        <trans-unit id="107a9888b94abfe0f0842709b6d53a8d5a2cad39" translate="yes" xml:space="preserve">
          <source>There is another (documented) case when this exception is thrown: if, in &lt;code&gt;DataView&lt;/code&gt;, data column name being supplied to the &lt;code&gt;DataViewSort&lt;/code&gt; property is not valid.</source>
          <target state="translated">引发此异常时，还有另一种（记录在案）的情况：如果在 &lt;code&gt;DataView&lt;/code&gt; 中提供给 &lt;code&gt;DataViewSort&lt;/code&gt; 属性的数据列名称无效。</target>
        </trans-unit>
        <trans-unit id="2feb23c1a9eaeb80736074afbcae4a7353c3d269" translate="yes" xml:space="preserve">
          <source>This code will then fail because array is 0-based and last (bottom-right) pixel in the image is &lt;code&gt;pixels[imageWidth - 1, imageHeight - 1]&lt;/code&gt;:</source>
          <target state="translated">然后，此代码将失败，因为数组是基于0的，并且图像中的最后一个（右下）像素为 &lt;code&gt;pixels[imageWidth - 1, imageHeight - 1]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7b0ef8f0aa42bf47870a059eee92fc5398d3ebb4" translate="yes" xml:space="preserve">
          <source>This exception may be thrown for another reason too: by convention, many &lt;em&gt;search functions&lt;/em&gt; will return -1 (nullables has been introduced with .NET 2.0 and anyway it's also a well-known convention in use from many years) if they didn't find anything. Let's imagine you have an array of objects comparable with a string. You may think to write this code:</source>
          <target state="translated">也可能由于另一个原因引发此异常：按照惯例，如果没有找到，许多&lt;em&gt;搜索函数&lt;/em&gt;将返回-1（.net 2.0中引入了nullable，无论如何它也是多年以来使用的众所周知的约定）任何东西。 假设您有一个与字符串可比的对象数组。 您可能会考虑编写以下代码：</target>
        </trans-unit>
        <trans-unit id="a2fcd2cd1cb1036644f107b16a8890283d860e72" translate="yes" xml:space="preserve">
          <source>This exception means that you're trying to access a collection item by index, using an invalid index. An index is invalid when it's lower than the collection's lower bound or greater than &lt;del&gt;equal to the number of elements it contains.&lt;/del&gt; the maximum allowed index defined in the array declaration</source>
          <target state="translated">此异常表示您正在尝试使用无效索引按索引访问收集项。 当索引小于集合的下限或大于集合的下限时，索引无效 &lt;del&gt; 等于它包含的元素数量。 &lt;/del&gt; 数组声明中定义的最大允许索引</target>
        </trans-unit>
        <trans-unit id="e7dec47f74c256ee0220fc295a632aecdf0b27a6" translate="yes" xml:space="preserve">
          <source>This exception means that you're trying to access a collection item by index, using an invalid index. An index is invalid when it's lower than the collection's lower bound or greater than or equal to the number of elements it contains.</source>
          <target state="translated">这个异常意味着你试图通过索引访问一个集合项,使用的是无效索引。当一个索引低于集合的下限或大于或等于它所包含的元素数时,这个索引是无效的。</target>
        </trans-unit>
        <trans-unit id="9e01fe07c21102f88931eb8da4f078ace2acf044" translate="yes" xml:space="preserve">
          <source>This happens because the indexer operator is implemented trying to retrieve the index of a &lt;em&gt;Colum1&lt;/em&gt; field that doesn't exist. The GetOrdinal method will throw this exception when its internal helper code returns a -1 as the index of &quot;Colum1&quot;.</source>
          <target state="translated">发生这种情况是因为实现了索引器运算符，试图检索不存在的&lt;em&gt;Colum1&lt;/em&gt;字段的索引。 当其内部帮助程序代码返回-1作为&amp;ldquo; Colum1&amp;rdquo;的索引时，GetOrdinal方法将引发此异常。</target>
        </trans-unit>
        <trans-unit id="e8ae00193f164544dc369987db61ee45ff297184" translate="yes" xml:space="preserve">
          <source>This will fail if no items in &lt;code&gt;myArray&lt;/code&gt; will satisfy search condition because &lt;code&gt;Array.IndexOf()&lt;/code&gt; will return -1 and then array access will throw.</source>
          <target state="translated">如果 &lt;code&gt;myArray&lt;/code&gt; 中没有任何项目满足搜索条件，则此操作将失败，因为 &lt;code&gt;Array.IndexOf()&lt;/code&gt; 将返回-1，然后将引发对数组的访问。</target>
        </trans-unit>
        <trans-unit id="1448888ed15547b9b90d018b51d2e99215c5719e" translate="yes" xml:space="preserve">
          <source>To easily understand the problem, imagine we wrote this code:</source>
          <target state="translated">为了容易理解这个问题,想象一下我们写了这样的代码。</target>
        </trans-unit>
        <trans-unit id="d75990cb468491d4aee74eb65a49267c49a02831" translate="yes" xml:space="preserve">
          <source>Unlike arrays, &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; starts empty - so trying to access items of just created list lead to this exception.</source>
          <target state="translated">与数组不同， &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 开始为空-因此，尝试访问刚刚创建的列表的项目会导致此异常。</target>
        </trans-unit>
        <trans-unit id="85b71ece91202721794d3f3aa2f8575d83d210c3" translate="yes" xml:space="preserve">
          <source>What Is It?</source>
          <target state="translated">它是什么?</target>
        </trans-unit>
        <trans-unit id="d038b6b88960ddb547851582deb4aa9178a9143a" translate="yes" xml:space="preserve">
          <source>What does this mean, and what can I do about it?</source>
          <target state="translated">这意味着什么,我又能做些什么呢?</target>
        </trans-unit>
        <trans-unit id="db3e9dce32f32c752d89721d4714009559cf8ea7" translate="yes" xml:space="preserve">
          <source>What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it</source>
          <target state="translated">什么是 IndexOutOfRangeException ArgumentOutOfRangeException,如何修复?</target>
        </trans-unit>
        <trans-unit id="64d2ca343b2d11209d8e98e83bbc370189858b2f" translate="yes" xml:space="preserve">
          <source>When It Is Thrown</source>
          <target state="translated">当它被抛出时</target>
        </trans-unit>
        <trans-unit id="b6cd6c3e3375f53769e3f51014aa013895a17062" translate="yes" xml:space="preserve">
          <source>You can access this array from 0 to 3, values outside this range will cause &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; to be thrown. Remember this when you create and access an array.</source>
          <target state="translated">您可以从0到3访问此数组，超出此范围的值将导致抛出 &lt;code&gt;IndexOutOfRangeException&lt;/code&gt; 。 创建和访问数组时，请记住这一点。</target>
        </trans-unit>
        <trans-unit id="a435dd41b664b49681c0f5d1ce876301860c479a" translate="yes" xml:space="preserve">
          <source>You can get the same exception also if you use the IDataReader overload of the indexer operator that takes a column name and pass an invalid column name.</source>
          <target state="translated">如果你使用索引器操作符的IDataReader重载,如果你使用索引器操作符的IDataReader重载,并传递一个无效的列名,你也会得到同样的异常。</target>
        </trans-unit>
        <trans-unit id="fc1e14f5925304435bda2fd3d2ff334f6898cf6b" translate="yes" xml:space="preserve">
          <source>You found your error, check how &lt;code&gt;index&lt;/code&gt; increases. Is it right? Check how array is allocated, is coherent with how &lt;code&gt;index&lt;/code&gt; increases? Is it right according to your specifications? If you answer &lt;em&gt;yes&lt;/em&gt; to all these questions, then you'll find good help here on StackOverflow but please first check for that by yourself. You'll save your own time!</source>
          <target state="translated">您发现了错误，请检查 &lt;code&gt;index&lt;/code&gt; 如何增加。 这样对吗？ 检查数组如何分配，与 &lt;code&gt;index&lt;/code&gt; 如何增加一致？ 根据您的要求正确吗？ 如果您对所有这些问题的回答都是&amp;ldquo; &lt;em&gt;是&amp;rdquo;&lt;/em&gt; ，那么您将在StackOverflow上找到很好的帮助，但请先自己检查一下。 您将节省自己的时间！</target>
        </trans-unit>
        <trans-unit id="250a56e82d76e86df3aa532f5df265e03cc75d27" translate="yes" xml:space="preserve">
          <source>You have source code, you have exception message with a stack trace. Go there, pick right line number and you'll see:</source>
          <target state="translated">你有源码,你有异常消息和堆栈跟踪。去那里,选右边的行号,你会看到。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
