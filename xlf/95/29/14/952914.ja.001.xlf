<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/952914">
    <body>
      <group id="952914">
        <trans-unit id="c7212e4ddbfbd11031c6226c57bdfe67288fb392" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Itertools&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Itertools&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="c38e822746feba1c5a49dc07f0faa24c4c4931b8" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Matplotlib&lt;/strong&gt;</source>
          <target state="translated">...&lt;strong&gt;Matplotlib&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9613459c01cb7031c63f21aeb1fc59b70025f78" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Pandas&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Pandas&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="77820f7ceaf27b513827583c0595b5674e49df57" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Setuptools&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Setuptools&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="96580150ba876eb18a7f55a60d0871b389dcdfb9" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Unipath&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Unipath&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b988115e6086e3dfbfef73ed6a51772ebb57d0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_iterable&lt;/code&gt; is pretty fast! But it's no comparison to reduce with &lt;code&gt;concat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;from_iterable&lt;/code&gt; はかなり高速です！ しかし、それは &lt;code&gt;concat&lt;/code&gt; で削減するための比較ではありません。</target>
        </trans-unit>
        <trans-unit id="22e0147f3766b1297fd754cae27ffd20940d80d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matplotlib.cbook.flatten()&lt;/code&gt; will work for nested lists even if they nest more deeply than the example.</source>
          <target state="translated">&lt;code&gt;matplotlib.cbook.flatten()&lt;/code&gt; は、例よりもネストが深い場合でも、ネストされたリストで機能します。</target>
        </trans-unit>
        <trans-unit id="f05a79f3c1b6d531b3afef5719fd794bc8e796c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Notes&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Notes&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a79903480a5608a4282c3838d1bbe7ef700e434b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Demo&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Demo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="630494acded75e86cdf6b39a97d60ee31ec53223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Error message&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;エラーメッセージ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5cca58a8ac381d444b393a0c564994acbbba4985" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I take my statement back. sum is not the winner. Although it is faster when the list is small. But the performance degrades significantly with larger lists.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;私は私の声明を取り戻します。&lt;/strong&gt; &lt;strong&gt;合計は勝者ではありません。&lt;/strong&gt; &lt;strong&gt;リストが小さいほど高速ですが。&lt;/strong&gt; &lt;strong&gt;ただし、リストが大きくなると、パフォーマンスは大幅に低下します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cb834ff6376acff7370669f5a5e4c75c94f3e3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note from the author&lt;/strong&gt;: This is inefficient. But fun, because &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science&quot;&gt;monoids&lt;/a&gt; are awesome. It's not appropriate for production Python code.</source>
          <target state="translated">&lt;strong&gt;著者からの注記&lt;/strong&gt; ：これは非効率的です。 しかし、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science&quot;&gt;モノイド&lt;/a&gt;は素晴らしいので、楽しいです。 これは本番Pythonコードには適していません。</target>
        </trans-unit>
        <trans-unit id="ed88dbceadb4943205fcb5801aa28bda02f9d380" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Below applies to Python 3.3+ because it uses &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html&quot;&gt;&lt;code&gt;yield_from&lt;/code&gt;&lt;/a&gt;.  &lt;code&gt;six&lt;/code&gt; is also a third-party package, though it is stable.  Alternately, you could use &lt;code&gt;sys.version&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt; ：以下は、yield_fromを使用するため、Python 3.3以降に適用されます。 &lt;code&gt;six&lt;/code&gt; も安定していますが、サードパーティのパッケージです。 または、 &lt;code&gt;sys.version&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="c2a6eb120ac5d954b7aa47baca4f35f487d47fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd4fbdf13dfb7b34fb1cfad02cbbdb2cd557e3bb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 Disclaimer: I'm the author of that library&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1免責事項：私はそのライブラリの作成者です&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fd92c55b0dc16e777e3a8b2fef34d2eb8a6d0d79" translate="yes" xml:space="preserve">
          <source>A faster way to do the &lt;code&gt;reduce&lt;/code&gt; version would be</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; バージョンを実行するより速い方法は、</target>
        </trans-unit>
        <trans-unit id="644e0cd0e37d239b0db451be1ed40f528a62e4aa" translate="yes" xml:space="preserve">
          <source>Accepted answer that did &lt;em&gt;not&lt;/em&gt; work:</source>
          <target state="translated">うまくいか&lt;em&gt;なかった&lt;/em&gt;受け入れられた答え：</target>
        </trans-unit>
        <trans-unit id="92d8769801fabd6702c5789616d5242fc7543178" translate="yes" xml:space="preserve">
          <source>Aha, you get back a list.</source>
          <target state="translated">嗚呼、リストが返ってくる。</target>
        </trans-unit>
        <trans-unit id="4967535c662745c7a48ab240736eb2afb1b8188c" translate="yes" xml:space="preserve">
          <source>Although I am not sure at this time about the efficiency.</source>
          <target state="translated">効率については今のところわかりませんが。</target>
        </trans-unit>
        <trans-unit id="33c231558a50c479e065510258c34b8fabc3215b" translate="yes" xml:space="preserve">
          <source>An bad feature of Anil's function above is that it requires the user to always manually specify the second argument to be an empty list &lt;code&gt;[]&lt;/code&gt;. This should instead be a default. Due to the way Python objects work, these should be set inside the function, not in the arguments.</source>
          <target state="translated">上記のAnilの関数の悪い特徴は、ユーザーが2番目の引数を常に手動で空のリスト &lt;code&gt;[]&lt;/code&gt; に指定する必要があることです。 代わりに、これがデフォルトになります。 Pythonオブジェクトの動作方法により、これらは引数ではなく関数内で設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fe8d80125b2f737fe3af135678ddabde16aa4257" translate="yes" xml:space="preserve">
          <source>As evidence, you can use the &lt;code&gt;timeit&lt;/code&gt; module in the standard library:</source>
          <target state="translated">証拠として、標準ライブラリの &lt;code&gt;timeit&lt;/code&gt; モジュールを使用できます。</target>
        </trans-unit>
        <trans-unit id="78f39cdb91c380ac04df841707c9330ce5e0f8b6" translate="yes" xml:space="preserve">
          <source>As of version 2.4, you can flatten more complicated, nested iterables with &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse&quot;&gt;&lt;code&gt;more_itertools.collapse&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse&quot;&gt;source&lt;/a&gt;, contributed by  abarnet).</source>
          <target state="translated">バージョン2.4以降では、 &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse&quot;&gt; &lt;code&gt;more_itertools.collapse&lt;/code&gt; &lt;/a&gt; （ &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse&quot;&gt;source&lt;/a&gt; 、abarnet提供）を使用して 、より複雑でネストされたイテラブルをフラット化できます。</target>
        </trans-unit>
        <trans-unit id="53e4fb8ef7602d42af84e5483a79fac166b0b7ab" translate="yes" xml:space="preserve">
          <source>Because you are summing nested lists, you actually get &lt;code&gt;[1,3]+[2,4]&lt;/code&gt; as a result of &lt;code&gt;sum([[1,3],[2,4]],[])&lt;/code&gt;, which is equal to &lt;code&gt;[1,3,2,4]&lt;/code&gt;.</source>
          <target state="translated">ネストされたリストを合計しているため、実際には &lt;code&gt;sum([[1,3],[2,4]],[])&lt;/code&gt; 結果として &lt;code&gt;[1,3]+[2,4]&lt;/code&gt; を取得します。これは &lt;code&gt;[1,3,2,4]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7695cefcf2d60f8c75926b4ba0826457404530c6" translate="yes" xml:space="preserve">
          <source>Code to reproduce the plot:</source>
          <target state="translated">プロットを再現するためのコード。</target>
        </trans-unit>
        <trans-unit id="a616585bfa18713708d4a3a2bc94f44cc9664c38" translate="yes" xml:space="preserve">
          <source>Consider installing the &lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt; &lt;code&gt;more_itertools&lt;/code&gt; &lt;/a&gt;パッケージのインストールを検討してください 。</target>
        </trans-unit>
        <trans-unit id="ba07a235a25c22c3ececc91a67add93d936aada4" translate="yes" xml:space="preserve">
          <source>Don't reinvent the wheel if you use &lt;strong&gt;Django&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Django&lt;/strong&gt;を使用する場合は、ホイールを再発明しないでください。</target>
        </trans-unit>
        <trans-unit id="5ca515ce5ebb9fbc9ca9e3d43452c4f363e26fd5" translate="yes" xml:space="preserve">
          <source>Done! You can of course turn it back into a list by executing list(l)</source>
          <target state="translated">これで完了です。もちろん、list(l)を実行することでリストに戻すことができます。</target>
        </trans-unit>
        <trans-unit id="2ac185dfc986222e4ecce9e1d5b072f8e68479ca" translate="yes" xml:space="preserve">
          <source>Edit 11/02/2016: Only works when sublists have identical dimensions.</source>
          <target state="translated">11022016を編集しました。サブリストが同一寸法の場合にのみ動作します。</target>
        </trans-unit>
        <trans-unit id="39c3e010a815528bd9b4496919045b2af64aec1c" translate="yes" xml:space="preserve">
          <source>Explanation: the shortcuts based on &lt;code&gt;+&lt;/code&gt; (including the implied use in &lt;code&gt;sum&lt;/code&gt;) are, of necessity, &lt;code&gt;O(L**2)&lt;/code&gt; when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of I items each: the first I items are copied back and forth L-1 times, the second I items L-2 times, and so on; total number of copies is I times the sum of x for x from 1 to L excluded, i.e., &lt;code&gt;I * (L**2)/2&lt;/code&gt;.</source>
          <target state="translated">説明： &lt;code&gt;+&lt;/code&gt; に基づくショートカット（ &lt;code&gt;sum&lt;/code&gt; の暗黙の使用を含む）は、Lサブリストがある場合、必要に応じて &lt;code&gt;O(L**2)&lt;/code&gt; -中間結果リストが長くなり続けるため、各ステップで新しい中間結果リストオブジェクトが割り当てられ、前の中間結果のすべてのアイテム（および最後に追加されたいくつかの新しいアイテム）をコピーする必要があります。 したがって、単純化のために、一般性を実際に失うことなく、それぞれIアイテムのLサブリストがあるとします。最初のIアイテムはL-1回、2番目のIアイテムはL-2回、というようにコピーされます。 コピーの総数は、xの1からLを除いたxの合計のI倍、つまり &lt;code&gt;I * (L**2)/2&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="55df575d9380e8cbd705dfa5f7d604bb01331885" translate="yes" xml:space="preserve">
          <source>Fastest solution I have found (for large list anyway):</source>
          <target state="translated">私が見つけた最速のソリューション(とにかく大きなリストのために)。</target>
        </trans-unit>
        <trans-unit id="830686325b823bed7b23d54cb0487a311cd10a29" translate="yes" xml:space="preserve">
          <source>Following seem simplest to me:</source>
          <target state="translated">以下が一番シンプルな気がします。</target>
        </trans-unit>
        <trans-unit id="81386a63f543dc89fc6a29418e00a411645173eb" translate="yes" xml:space="preserve">
          <source>For medium lists:</source>
          <target state="translated">中程度のリストの場合。</target>
        </trans-unit>
        <trans-unit id="de8d08f3dc9af8f5773bf1fec37d4c6b20244b54" translate="yes" xml:space="preserve">
          <source>Found an earlier &lt;a href=&quot;https://stackoverflow.com/a/2158532/4531270&quot;&gt;SO post&lt;/a&gt;, possibly the original demonstration.</source>
          <target state="translated">以前の&lt;a href=&quot;https://stackoverflow.com/a/2158532/4531270&quot;&gt;SO投稿&lt;/a&gt; 、おそらくオリジナルのデモが見つかりました。</target>
        </trans-unit>
        <trans-unit id="a296481527c15a34f5cdbc79f43470f0a233779e" translate="yes" xml:space="preserve">
          <source>Given a list of lists &lt;code&gt;l&lt;/code&gt;,</source>
          <target state="translated">リスト &lt;code&gt;l&lt;/code&gt; のリストを考えると、</target>
        </trans-unit>
        <trans-unit id="cfb0572cc3b39652a46f7d9b229a8f0c97c6a0e8" translate="yes" xml:space="preserve">
          <source>Here is a general approach that applies to &lt;strong&gt;numbers&lt;/strong&gt;, &lt;strong&gt;strings&lt;/strong&gt;, &lt;strong&gt;nested&lt;/strong&gt; lists and &lt;strong&gt;mixed&lt;/strong&gt; containers.</source>
          <target state="translated">以下は、 &lt;strong&gt;数値&lt;/strong&gt; 、 &lt;strong&gt;文字列&lt;/strong&gt; 、 &lt;strong&gt;ネストされた&lt;/strong&gt;リスト、 &lt;strong&gt;混合&lt;/strong&gt;コンテナに適用される一般的なアプローチです。</target>
        </trans-unit>
        <trans-unit id="90277c92aa2ef531d4bb81d661f56bc4a3bae36b" translate="yes" xml:space="preserve">
          <source>Here is the corresponding function:</source>
          <target state="translated">ここに対応する関数があります。</target>
        </trans-unit>
        <trans-unit id="65dbecec5681faac4b7b7628e864c5f2b770a52e" translate="yes" xml:space="preserve">
          <source>Here's a working function:</source>
          <target state="translated">ここでは、働く機能を紹介します。</target>
        </trans-unit>
        <trans-unit id="b599b1f61b5e7a90940ef61c51226edfdd3dc1c2" translate="yes" xml:space="preserve">
          <source>Here, you check that the sub-element (1) is iterable with &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;, an ABC from &lt;code&gt;itertools&lt;/code&gt;, but also want to ensure that (2) the element is &lt;em&gt;not&lt;/em&gt; &quot;string-like.&quot;</source>
          <target state="translated">ここでは、サブ要素（1）が&lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;のABCであるIterableで反復可能であることを確認しますが、（2）要素が「文字列のような」ものでは&lt;em&gt;ない&lt;/em&gt;ことも確認します。</target>
        </trans-unit>
        <trans-unit id="47f8c1be878ff256bd61a349c03652d7ed848da2" translate="yes" xml:space="preserve">
          <source>How about performance::</source>
          <target state="translated">パフォーマンスはどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="6202fef82862d98b07042e913d0ce2707782c6ba" translate="yes" xml:space="preserve">
          <source>How to make a flat list out of list of lists</source>
          <target state="translated">リストのリストからフラットリストを作る方法</target>
        </trans-unit>
        <trans-unit id="99f29d6ec76cfea7c1780d30f2c4f113f892e19c" translate="yes" xml:space="preserve">
          <source>However, consider this slightly more complex case:</source>
          <target state="translated">しかし、この少し複雑なケースを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="5933bc989310515ebc4ee439fbe83965e3f8a5a6" translate="yes" xml:space="preserve">
          <source>I can do that in a &lt;code&gt;for&lt;/code&gt; loop, but maybe there is some cool &quot;one-liner&quot;? I tried it with &lt;code&gt;reduce()&lt;/code&gt;, but I get an error.</source>
          <target state="translated">私は &lt;code&gt;for&lt;/code&gt; ループでそれを行うことができますが、いくつかのクールな「ワンライナー」があるのでしょうか？ &lt;code&gt;reduce()&lt;/code&gt; で試しましたが、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="ba03edc363764ebb3a6d3e7b811a5812532edcac" translate="yes" xml:space="preserve">
          <source>I tested most suggested solutions with &lt;a href=&quot;https://github.com/nschloe/perfplot&quot;&gt;perfplot&lt;/a&gt; (a pet project of mine, essentially a wrapper around &lt;code&gt;timeit&lt;/code&gt;), and found</source>
          <target state="translated">私はほとんどの提案されたソリューションを&lt;a href=&quot;https://github.com/nschloe/perfplot&quot;&gt;perfplot&lt;/a&gt; （私のペットプロジェクト、本質的には &lt;code&gt;timeit&lt;/code&gt; のラッパー）でテストし 、</target>
        </trans-unit>
        <trans-unit id="876cae1b1c230f0b41d5bbd93d68960bc959b80c" translate="yes" xml:space="preserve">
          <source>I wonder whether there is a shortcut to make a simple list out of list of lists in Python.</source>
          <target state="translated">Pythonでリストのリストから簡単なリストを作るショートカットはないのかな。</target>
        </trans-unit>
        <trans-unit id="61fc8760cdaa2f2e5362a195c732748258b70b96" translate="yes" xml:space="preserve">
          <source>If you are willing to give up a tiny amount of speed for a cleaner look, then you could use &lt;code&gt;numpy.concatenate().tolist()&lt;/code&gt; or &lt;code&gt;numpy.concatenate().ravel().tolist()&lt;/code&gt;:</source>
          <target state="translated">見栄えをよくするために &lt;code&gt;numpy.concatenate().tolist()&lt;/code&gt; 速度をあきらめたい場合は、 numpy.concatenate（）。tolist（）または &lt;code&gt;numpy.concatenate().ravel().tolist()&lt;/code&gt; ravel（）。tolist（）を使用できます。</target>
        </trans-unit>
        <trans-unit id="f2612465f4102edf2a5792b74f40ea0d29bfb7d8" translate="yes" xml:space="preserve">
          <source>If you want to flatten a data-structure where you don't know how deep it's nested you could use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt;&lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt;&lt;/a&gt;&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">ネストの深さがわからないデータ構造をフラット化する場合は、 &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt; &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; &lt;/a&gt; &lt;sup&gt;1を&lt;/sup&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="32fee52bb03074fffdc25bdcabef4136af14249f" translate="yes" xml:space="preserve">
          <source>If you're thinking functional, it is as easy as this::</source>
          <target state="translated">機能的なことを考えているのであれば、以下のように簡単です。</target>
        </trans-unit>
        <trans-unit id="d2fa2014fa3a734a25a87e6c0fcd1d6156afb5bd" translate="yes" xml:space="preserve">
          <source>In Python 3, &lt;code&gt;yield from flatten(x)&lt;/code&gt; can replace &lt;code&gt;for sub_x in flatten(x): yield sub_x&lt;/code&gt;</source>
          <target state="translated">Python 3では &lt;code&gt;yield from flatten(x)&lt;/code&gt; &lt;code&gt;for sub_x in flatten(x): yield sub_x&lt;/code&gt; 置き換えることができます：yield sub_x</target>
        </trans-unit>
        <trans-unit id="514f6225a66010f2d4c19d4f65146ac3f7d801d1" translate="yes" xml:space="preserve">
          <source>In Python 3.8, &lt;a href=&quot;https://docs.python.org/3/library/collections.abc.html#module-collections.abc&quot;&gt;abstract base classes&lt;/a&gt; are &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.7.html#id3&quot;&gt;moved&lt;/a&gt; from &lt;code&gt;collection.abc&lt;/code&gt; to the &lt;code&gt;typing&lt;/code&gt; module.</source>
          <target state="translated">Python 3.8では、 &lt;a href=&quot;https://docs.python.org/3/library/collections.abc.html#module-collections.abc&quot;&gt;抽象基本クラス&lt;/a&gt;が &lt;code&gt;collection.abc&lt;/code&gt; から &lt;code&gt;typing&lt;/code&gt; モジュールに&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.7.html#id3&quot;&gt;移動さ&lt;/a&gt;れました。</target>
        </trans-unit>
        <trans-unit id="7121c3061e262fdfa84e5a233d466f5601743942" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;obj = [[1, 2,], [3, 4], [5, 6]]&lt;/code&gt;, all of the solutions here are good, including list comprehension and &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj = [[1, 2,], [3, 4], [5, 6]]&lt;/code&gt; 場合、リスト内包法や &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; を含め、ここでのすべての解決策は適切です。</target>
        </trans-unit>
        <trans-unit id="ae463b2138420d7f869146a1a9a4624956753f55" translate="yes" xml:space="preserve">
          <source>It ships with an implementation for &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten&quot;&gt;source&lt;/a&gt;, from the &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools recipes&lt;/a&gt;):</source>
          <target state="translated">これには、 &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten&quot;&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;/a&gt; （ &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten&quot;&gt;source&lt;/a&gt; 、 &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertoolsレシピ&lt;/a&gt;から）の実装が同梱されています 。</target>
        </trans-unit>
        <trans-unit id="81faee37aa250627b621e8f54d471969e6c42fdf" translate="yes" xml:space="preserve">
          <source>It solves all flatten problems (none list item or complex nesting)</source>
          <target state="translated">すべての平坦化問題(リスト項目や複雑な入れ子がない)を解決します。</target>
        </trans-unit>
        <trans-unit id="6f4274e4e265456695c37cb98096f65cdb50b393" translate="yes" xml:space="preserve">
          <source>It's a generator so you need to cast the result to a &lt;code&gt;list&lt;/code&gt; or explicitly iterate over it.</source>
          <target state="translated">これはジェネレータなので、結果を &lt;code&gt;list&lt;/code&gt; にキャストするか、明示的に反復する必要があります。</target>
        </trans-unit>
        <trans-unit id="bab3f440e0cb9b6ef1870545dce67cee5b69549a" translate="yes" xml:space="preserve">
          <source>It's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better.</source>
          <target state="translated">広がる膨大な値の範囲に対応するために対数プロットしたものです。質的推論のために 低い方が良い。</target>
        </trans-unit>
        <trans-unit id="c4d4f86224ef28956be32e434d9873c524962e30" translate="yes" xml:space="preserve">
          <source>Just to add some timings (based on Nico Schl&amp;ouml;mer answer that didn't include the function presented in this answer):</source>
          <target state="translated">いくつかのタイミングを追加するだけです（この回答で提示された関数を含まないNicoSchl&amp;ouml;merの回答に基づく）：</target>
        </trans-unit>
        <trans-unit id="3be2f60b7d85235e979e45d49f68feac671b94c1" translate="yes" xml:space="preserve">
          <source>New proposed solution that &lt;em&gt;did&lt;/em&gt; work for me:</source>
          <target state="translated">私のために働いた新しい提案された解決策：</target>
        </trans-unit>
        <trans-unit id="0ffedc979da9fc4c310ebb5e966b9183d9fbaafe" translate="yes" xml:space="preserve">
          <source>Note that only works on lists of lists. For lists of lists of lists, you'll need another solution.</source>
          <target state="translated">これはリストのリストに対してのみ動作することに注意してください。リストのリストに対しては、別の解決策が必要になります。</target>
        </trans-unit>
        <trans-unit id="da5cc2418e5a4bd3106e3f3ce95f6320daee1110" translate="yes" xml:space="preserve">
          <source>Note: extend is more efficient than + on lists.</source>
          <target state="translated">注意:extendはリスト上では+よりも効率的です。</target>
        </trans-unit>
        <trans-unit id="c47684635a9abd882bb07dd1af45494e951b55aa" translate="yes" xml:space="preserve">
          <source>One can also use NumPy's &lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html&quot;&gt;flat&lt;/a&gt;:</source>
          <target state="translated">NumPyの&lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html&quot;&gt;フラットを&lt;/a&gt;使用することもできます。</target>
        </trans-unit>
        <trans-unit id="87936a8087e52b4dc48ce96d0bf6a057c81e8ab2" translate="yes" xml:space="preserve">
          <source>One element, &lt;code&gt;'abc'&lt;/code&gt;, &lt;em&gt;is&lt;/em&gt; technically iterable (all &lt;code&gt;str&lt;/code&gt;s are).  However, reading between the lines a bit, you don't want to treat it as such--you want to treat it as a single element.</source>
          <target state="translated">1つの要素 &lt;code&gt;'abc'&lt;/code&gt; &lt;em&gt;は&lt;/em&gt;技術的に反復可能です（すべての &lt;code&gt;str&lt;/code&gt; はそうです）。 ただし、行間を少し読むと、そのように扱いたくない-単一の要素として扱いたい場合。</target>
        </trans-unit>
        <trans-unit id="2906f0e61b652b524e54b5ed7699d5db97c2adeb" translate="yes" xml:space="preserve">
          <source>One element, &lt;code&gt;6&lt;/code&gt;, is just a scalar; it's not iterable, so the above routes will fail here.</source>
          <target state="translated">1つの要素 &lt;code&gt;6&lt;/code&gt; は単なるスカラーです。 反復可能ではないため、上記のルートはここで失敗します。</target>
        </trans-unit>
        <trans-unit id="314acacc9569152fc4da86dd9d5208c370dc9afc" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt;&lt;code&gt;itertools.chain.from_iterable()&lt;/code&gt;&lt;/a&gt; which doesn't require unpacking the list with the &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#tut-unpacking-arguments&quot;&gt;&lt;code&gt;*&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">または、 &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#tut-unpacking-arguments&quot;&gt; &lt;code&gt;*&lt;/code&gt; 演算子を使用&lt;/a&gt;してリストをアンパックする必要のない&lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt; &lt;code&gt;itertools.chain.from_iterable()&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="96b676519adbe95ecb795d350dfb60971f7271dc" translate="yes" xml:space="preserve">
          <source>Recursive version</source>
          <target state="translated">再帰的バージョン</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="24c3fe6c6fdc963c62e2db5221e26b4d3823916f" translate="yes" xml:space="preserve">
          <source>Simple code for &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt;&lt;code&gt;underscore.py&lt;/code&gt;&lt;/a&gt; package fan</source>
          <target state="translated">&lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt; &lt;code&gt;underscore.py&lt;/code&gt; &lt;/a&gt;パッケージファンの単純なコード</target>
        </trans-unit>
        <trans-unit id="38d4e1b388c4c9a2760e19d334c82a73510265e8" translate="yes" xml:space="preserve">
          <source>Testing:</source>
          <target state="translated">Testing:</target>
        </trans-unit>
        <trans-unit id="8eb26a47b520c5dbbccaf00c5378c80eb2b2e50e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extend()&lt;/code&gt; method in your example modifies &lt;code&gt;x&lt;/code&gt; instead of returning a useful value (which &lt;code&gt;reduce()&lt;/code&gt; expects).</source>
          <target state="translated">この例の &lt;code&gt;extend()&lt;/code&gt; メソッドは、（ &lt;code&gt;reduce()&lt;/code&gt; が期待する）有用な値を返す代わりに &lt;code&gt;x&lt;/code&gt; を変更します。</target>
        </trans-unit>
        <trans-unit id="df9a56352fe0182aa9b3497490b49100923fa99c" translate="yes" xml:space="preserve">
          <source>The above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl &lt;code&gt;flist&lt;/code&gt;, like below.</source>
          <target state="translated">上記のものは、いくつかのローカルリストを作成し、それらを返します。これらは親のリストを拡張するために使用されます。 これを回避する方法は、以下のようなgloabl &lt;code&gt;flist&lt;/code&gt; を作成することだと思います。</target>
        </trans-unit>
        <trans-unit id="386171513d5c24a58e7ed773e77f34df403522e7" translate="yes" xml:space="preserve">
          <source>The accepted answer did not work for me when dealing with text-based lists of variable lengths. Here is an alternate approach that did work for me.</source>
          <target state="translated">可変長のテキストベースのリストを扱う際に、受け入れられた回答は私には機能しませんでした。ここでは、私のために動作した別のアプローチを紹介します。</target>
        </trans-unit>
        <trans-unit id="32b0e7cb6d27e016711c8a613c0443164f3ad516" translate="yes" xml:space="preserve">
          <source>The advantage of this solution over most others here is that if you have a list like:</source>
          <target state="translated">ここでの他のほとんどの人よりもこのソリューションの利点は、あなたがリストのようなものを持っている場合、ということです。</target>
        </trans-unit>
        <trans-unit id="6f6eb68ec0de9e7966a150472808fb0be4be2be4" translate="yes" xml:space="preserve">
          <source>The final element, &lt;code&gt;[8, [9, 10]]&lt;/code&gt; is itself a nested iterable.  Basic list comprehension and &lt;code&gt;chain.from_iterable&lt;/code&gt; only extract &quot;1 level down.&quot;</source>
          <target state="translated">最後の要素 &lt;code&gt;[8, [9, 10]]&lt;/code&gt; は、それ自体がネストされた反復可能です。 基本的なリスト内包と &lt;code&gt;chain.from_iterable&lt;/code&gt; は、「1レベル下」のみを抽出します。</target>
        </trans-unit>
        <trans-unit id="2f8cc82ebeb3c2efcac05855ec9c0cb5bccc63bd" translate="yes" xml:space="preserve">
          <source>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</source>
          <target state="translated">リスト理解は、1つのリストを1回だけ生成し、各項目を(元の居住地から結果リストへ)正確に1回だけコピーします。</target>
        </trans-unit>
        <trans-unit id="c55395401359835a6e3f32b3f23a39a7f4f78ecc" translate="yes" xml:space="preserve">
          <source>The output is</source>
          <target state="translated">を出力しています。</target>
        </trans-unit>
        <trans-unit id="e7e78b54dc635e3743925801712ceba59b3f69ff" translate="yes" xml:space="preserve">
          <source>The output is again</source>
          <target state="translated">出力はまたしても</target>
        </trans-unit>
        <trans-unit id="a57f5af7d243e25c69e05bf8c07fdb2268f7e527" translate="yes" xml:space="preserve">
          <source>The reason your function didn't work is because the &lt;em&gt;extend&lt;/em&gt; extends an array in-place and doesn't return it. You can still return x from lambda, using something like this:</source>
          <target state="translated">関数が機能しなかった理由は、 &lt;em&gt;extend&lt;/em&gt;が配列をインプレースで拡張し、それを返さないためです。 次のようなものを使用して、ラムダからxを返すことができます。</target>
        </trans-unit>
        <trans-unit id="fcc503c0e349fbcd95911ec7361823eee8d6907c" translate="yes" xml:space="preserve">
          <source>The results show that if the iterable contains only a few inner iterables then &lt;code&gt;sum&lt;/code&gt; will be fastest, however for long iterables only the &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;, &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; or the nested comprehension have reasonable performance with &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; being the fastest (as already noticed by Nico Schl&amp;ouml;mer).</source>
          <target state="translated">結果は、 &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; に少数の内部イテラブルしか含まれていない場合、 &lt;code&gt;sum&lt;/code&gt; が最も速くなることを示していますが、長いイテラブルの場合、 itertools.chain.from_iterable 、 &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; 、またはネストされた内包 &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; が、最も高速なitertools.chain.from_iterableで妥当なパフォーマンスを発揮します。 （すでにニコ・シュレーマーが気づいたように）。</target>
        </trans-unit>
        <trans-unit id="7175c5e62cfcd939bbd4213e3f7c7e95a96b69db" translate="yes" xml:space="preserve">
          <source>The sum version is still running for more than a minute and it hasn't done processing yet!</source>
          <target state="translated">sum版はまだ1分以上動いていて、処理が終わっていません!</target>
        </trans-unit>
        <trans-unit id="a4a70ba48ec34522605cf566e94a4806b211eeb3" translate="yes" xml:space="preserve">
          <source>There are several problems here:</source>
          <target state="translated">ここにはいくつかの問題があります。</target>
        </trans-unit>
        <trans-unit id="3c67e5d7f089a9f9e7857e3acedcc581dc0f9c42" translate="yes" xml:space="preserve">
          <source>There seems to be a confusion with &lt;code&gt;operator.add&lt;/code&gt;! When you add two lists together, the correct term for that is &lt;code&gt;concat&lt;/code&gt;, not add. &lt;code&gt;operator.concat&lt;/code&gt; is what you need to use.</source>
          <target state="translated">&lt;code&gt;operator.add&lt;/code&gt; と混同しているようです！ 2つのリストを一緒に追加する場合、その正しい用語は追加ではなく &lt;code&gt;concat&lt;/code&gt; です。 &lt;code&gt;operator.concat&lt;/code&gt; は、使用する必要があるものです。</target>
        </trans-unit>
        <trans-unit id="af9f85228d363e1396dd2478ab29159bb2918911" translate="yes" xml:space="preserve">
          <source>This Code also works fine as it just extend the list all the way. Although it is much similar but only have one for loop. So It have less complexity than adding 2 for loops.</source>
          <target state="translated">このコードもリストをずっと拡張しているだけなので問題なく動作します。似ていますが、forループが1つしかありません。そのため、2つのループを追加するよりも複雑さが少なくて済みます。</target>
        </trans-unit>
        <trans-unit id="e08b5f038b08a8c96efa1f08522f5e66a998d327" translate="yes" xml:space="preserve">
          <source>This is 18x faster than underscore._.flatten:</source>
          <target state="translated">underscore._.flattenの18倍の速さです。</target>
        </trans-unit>
        <trans-unit id="64c743f00d333be28bff13f8652e1a11252b868f" translate="yes" xml:space="preserve">
          <source>This just sums the elements of iterable passed in the first argument, treating second argument as the initial value of the sum (if not given, &lt;code&gt;0&lt;/code&gt; is used instead and this case will give you an error).</source>
          <target state="translated">これは、最初の引数で渡されたイテラブルの要素を合計し、2番目の引数を合計の初期値として扱います（指定されていない場合は、代わりに &lt;code&gt;0&lt;/code&gt; が使用され、この場合はエラーが発生します）。</target>
        </trans-unit>
        <trans-unit id="22c2c19b3bac52f4b2cf95eeea7c5da16b692799" translate="yes" xml:space="preserve">
          <source>This may not be the most efficient way but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python3.5) and recursion.</source>
          <target state="translated">一番効率的ではないかもしれませんが、ワンライナー(実際はツーライナー)を入れてみようと思いました。どちらのバージョンも任意の階層ネストされたリストで動作し、言語機能(Python3.5)と再帰性を悪用しています。</target>
        </trans-unit>
        <trans-unit id="ab7d5f153551afca8f6c602e4de5f5383356ed3b" translate="yes" xml:space="preserve">
          <source>This should work fine.</source>
          <target state="translated">これはうまくいくはずです。</target>
        </trans-unit>
        <trans-unit id="c8771b06b3b88dac30f258456688e4372fdb7213" translate="yes" xml:space="preserve">
          <source>This solution is modified from a recipe in &lt;em&gt;Beazley, D. and B. Jones.  Recipe 4.14, Python Cookbook 3rd Ed., O'Reilly Media Inc. Sebastopol, CA: 2013.&lt;/em&gt;</source>
          <target state="translated">このソリューションは、 &lt;em&gt;Beazley、D。、およびB. Jonesの&lt;/em&gt;レシピから変更されてい&lt;em&gt;ます。&lt;/em&gt; &lt;em&gt;レシピ4.14、Pythonクックブック第3版、O'Reilly Media Inc.セバストポル、カリフォルニア：2013。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9bcd7287917139a6af150a5761753b741a5dfa5f" translate="yes" xml:space="preserve">
          <source>This works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable &lt;code&gt;flist&lt;/code&gt; and then rolls back it to the parent. Whenever &lt;code&gt;flist&lt;/code&gt; is returned, it is extended to the parent's &lt;code&gt;flist&lt;/code&gt; in the list comprehension. Therefore, at the root, a flat list is returned.</source>
          <target state="translated">これは、深さ優先で機能します。 再帰は、リスト以外の要素が見つかるまで停止し、ローカル変数 &lt;code&gt;flist&lt;/code&gt; を拡張して、親にロールバックします。 &lt;code&gt;flist&lt;/code&gt; が返されるときは常に、リスト内包 &lt;code&gt;flist&lt;/code&gt; の親のflistに拡張されます。 したがって、ルートではフラットリストが返されます。</target>
        </trans-unit>
        <trans-unit id="59ed80852db6ea428cf54dd89710beabb15d36d1" translate="yes" xml:space="preserve">
          <source>To flatten only one level and if each of the items is itself iterable you can also use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html&quot;&gt;&lt;code&gt;iteration_utilities.flatten&lt;/code&gt;&lt;/a&gt; which itself is just a thin wrapper around &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt;&lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">1つのレベルのみをフラット化し、各アイテム自体が反復可能である場合、それ自体が&lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt; &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; の&lt;/a&gt;薄いラッパーである&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html&quot;&gt; &lt;code&gt;iteration_utilities.flatten&lt;/code&gt; &lt;/a&gt;を使用することもできます 。</target>
        </trans-unit>
        <trans-unit id="d85e040c6b2316333bbc8b6ece8ebd109dcad5c6" translate="yes" xml:space="preserve">
          <source>Using small lists and timeit: number=1000000</source>
          <target state="translated">スモールリストとtimeitの使用:number=1000000</target>
        </trans-unit>
        <trans-unit id="8b777156d7db14dbefaad623bb79535a459684ae" translate="yes" xml:space="preserve">
          <source>Why do you use extend?</source>
          <target state="translated">なぜextendを使うのか?</target>
        </trans-unit>
        <trans-unit id="026239782349d9cccf8cae513c88ec70bc6f77a6" translate="yes" xml:space="preserve">
          <source>You can find out more here in the docs &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html&quot;&gt;numpy.concatenate&lt;/a&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html&quot;&gt;numpy.ravel&lt;/a&gt;</source>
          <target state="translated">詳しくは、ドキュメント&lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html&quot;&gt;numpy.concatenate&lt;/a&gt;および&lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html&quot;&gt;numpy.ravelをご覧ください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98f00c4375c36821b12502ea83723a702fb0edfd" translate="yes" xml:space="preserve">
          <source>You can install &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt;&lt;code&gt;underscore.py&lt;/code&gt;&lt;/a&gt; with pip</source>
          <target state="translated">あなたはpipで&lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt; &lt;code&gt;underscore.py&lt;/code&gt; &lt;/a&gt;をインストールできます</target>
        </trans-unit>
        <trans-unit id="4e3f2e4eb4b0b94b2d85fa9b562339a3ec7bc93b" translate="yes" xml:space="preserve">
          <source>You can remedy this as follows:</source>
          <target state="translated">これは以下のように是正することができます。</target>
        </trans-unit>
        <trans-unit id="b69cc7e24723fc0ad7c514ca643eccd680bfbd54" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain&quot;&gt;&lt;code&gt;itertools.chain()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain&quot;&gt; &lt;code&gt;itertools.chain()&lt;/code&gt; &lt;/a&gt;を使用できます：</target>
        </trans-unit>
        <trans-unit id="ae1549c83cb4c81622f3b6d9fed8b362916b2245" translate="yes" xml:space="preserve">
          <source>You can use numpy :</source>
          <target state="translated">numpy を使うことができます。</target>
        </trans-unit>
        <trans-unit id="ac9b642dd33f13b33118da8230b6f694c73801a1" translate="yes" xml:space="preserve">
          <source>You see reduce respects the sequence type, so when you supply a tuple, you get back a tuple. Let's try with a list::</source>
          <target state="translated">reduce はシーケンス型を尊重するので、タプルを指定するとタプルが返ってきます。リスト:.</target>
        </trans-unit>
        <trans-unit id="2fae8325874681cc6b334b37cba1a121bd8cfad9" translate="yes" xml:space="preserve">
          <source>another fun way to do this:</source>
          <target state="translated">もう一つの楽しみ方</target>
        </trans-unit>
        <trans-unit id="9909ec7f3a3afabe82abee395540624cbdaad7c1" translate="yes" xml:space="preserve">
          <source>is faster than the shortcuts posted so far. (&lt;code&gt;l&lt;/code&gt; is the list to flatten.)</source>
          <target state="translated">これまでに投稿されたショートカットよりも高速です。 （ &lt;code&gt;l&lt;/code&gt; はフラット化するリストです。）</target>
        </trans-unit>
        <trans-unit id="abfaa5b8f36540158b4c83a8c2ff8def85ec64e0" translate="yes" xml:space="preserve">
          <source>to be the fastest solution. (&lt;code&gt;operator.iadd&lt;/code&gt; is equally fast.)</source>
          <target state="translated">最速のソリューションになる。 （ &lt;code&gt;operator.iadd&lt;/code&gt; も同様に高速です。）</target>
        </trans-unit>
        <trans-unit id="3d6b372a9c60b40127154403945e3da65b17a4cf" translate="yes" xml:space="preserve">
          <source>which means:</source>
          <target state="translated">という意味です。</target>
        </trans-unit>
        <trans-unit id="8a81fcda00582e8515550fb41988323475038a58" translate="yes" xml:space="preserve">
          <source>while most other solutions throw an error this solution handles them.</source>
          <target state="translated">他のほとんどのソリューションではエラーが発生しますが、このソリューションではそれを処理します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
