<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/952914">
    <body>
      <group id="952914">
        <trans-unit id="c7212e4ddbfbd11031c6226c57bdfe67288fb392" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Itertools&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Itertools&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="c38e822746feba1c5a49dc07f0faa24c4c4931b8" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Matplotlib&lt;/strong&gt;</source>
          <target state="translated">...&lt;strong&gt;Matplotlib&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9613459c01cb7031c63f21aeb1fc59b70025f78" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Pandas&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Pandas&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="77820f7ceaf27b513827583c0595b5674e49df57" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Setuptools&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Setuptools&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="96580150ba876eb18a7f55a60d0871b389dcdfb9" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Unipath&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Unipath&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b988115e6086e3dfbfef73ed6a51772ebb57d0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_iterable&lt;/code&gt; is pretty fast! But it's no comparison to reduce with &lt;code&gt;concat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;from_iterable&lt;/code&gt; 은 꽤 빠릅니다! 그러나 &lt;code&gt;concat&lt;/code&gt; 을 사용하여 비교하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="22e0147f3766b1297fd754cae27ffd20940d80d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matplotlib.cbook.flatten()&lt;/code&gt; will work for nested lists even if they nest more deeply than the example.</source>
          <target state="translated">&lt;code&gt;matplotlib.cbook.flatten()&lt;/code&gt; 은 예제보다 더 깊이 중첩 된 경우에도 중첩 목록에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f05a79f3c1b6d531b3afef5719fd794bc8e796c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Notes&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Notes&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a79903480a5608a4282c3838d1bbe7ef700e434b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Demo&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Demo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="630494acded75e86cdf6b39a97d60ee31ec53223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Error message&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;에러 메시지&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5cca58a8ac381d444b393a0c564994acbbba4985" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I take my statement back. sum is not the winner. Although it is faster when the list is small. But the performance degrades significantly with larger lists.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;진술서를 다시 가져옵니다.&lt;/strong&gt; &lt;strong&gt;합계는 승자가 아닙니다.&lt;/strong&gt; &lt;strong&gt;목록이 작을 때 더 빠르지 만.&lt;/strong&gt; &lt;strong&gt;그러나 목록이 클수록 성능이 크게 저하됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cb834ff6376acff7370669f5a5e4c75c94f3e3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note from the author&lt;/strong&gt;: This is inefficient. But fun, because &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science&quot;&gt;monoids&lt;/a&gt; are awesome. It's not appropriate for production Python code.</source>
          <target state="translated">&lt;strong&gt;저자의 메모&lt;/strong&gt; : 이것은 비효율적입니다. 그러나 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science&quot;&gt;monoid&lt;/a&gt; 가 굉장하기 때문에 재미 있습니다. 프로덕션 Python 코드에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed88dbceadb4943205fcb5801aa28bda02f9d380" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Below applies to Python 3.3+ because it uses &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html&quot;&gt;&lt;code&gt;yield_from&lt;/code&gt;&lt;/a&gt;.  &lt;code&gt;six&lt;/code&gt; is also a third-party package, though it is stable.  Alternately, you could use &lt;code&gt;sys.version&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 아래는 &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html&quot;&gt; &lt;code&gt;yield_from&lt;/code&gt; &lt;/a&gt; 을 사용하기 때문에 Python 3.3 이상에 적용됩니다. &lt;code&gt;six&lt;/code&gt; 는 타사 패키지이지만 안정적입니다. 또는 &lt;code&gt;sys.version&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a6eb120ac5d954b7aa47baca4f35f487d47fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd4fbdf13dfb7b34fb1cfad02cbbdb2cd557e3bb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 Disclaimer: I'm the author of that library&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1 면책 조항 : 나는 그 도서관의 저자입니다&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fd92c55b0dc16e777e3a8b2fef34d2eb8a6d0d79" translate="yes" xml:space="preserve">
          <source>A faster way to do the &lt;code&gt;reduce&lt;/code&gt; version would be</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; 버전을 수행하는 가장 빠른 방법은</target>
        </trans-unit>
        <trans-unit id="644e0cd0e37d239b0db451be1ed40f528a62e4aa" translate="yes" xml:space="preserve">
          <source>Accepted answer that did &lt;em&gt;not&lt;/em&gt; work:</source>
          <target state="translated">작동하지 &lt;em&gt;않는&lt;/em&gt; 수락 된 답변 :</target>
        </trans-unit>
        <trans-unit id="92d8769801fabd6702c5789616d5242fc7543178" translate="yes" xml:space="preserve">
          <source>Aha, you get back a list.</source>
          <target state="translated">아하, 당신은 목록을 다시 얻는다.</target>
        </trans-unit>
        <trans-unit id="4967535c662745c7a48ab240736eb2afb1b8188c" translate="yes" xml:space="preserve">
          <source>Although I am not sure at this time about the efficiency.</source>
          <target state="translated">지금은 효율성에 대해 잘 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="33c231558a50c479e065510258c34b8fabc3215b" translate="yes" xml:space="preserve">
          <source>An bad feature of Anil's function above is that it requires the user to always manually specify the second argument to be an empty list &lt;code&gt;[]&lt;/code&gt;. This should instead be a default. Due to the way Python objects work, these should be set inside the function, not in the arguments.</source>
          <target state="translated">위의 Anil 함수의 나쁜 기능은 사용자가 항상 수동으로 두 번째 인수를 빈 목록 &lt;code&gt;[]&lt;/code&gt; 으로 지정해야한다는 것입니다. 대신 기본값이어야합니다. 파이썬 객체는 작동하는 방식 때문에 인수가 아닌 함수 내부에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe8d80125b2f737fe3af135678ddabde16aa4257" translate="yes" xml:space="preserve">
          <source>As evidence, you can use the &lt;code&gt;timeit&lt;/code&gt; module in the standard library:</source>
          <target state="translated">증거로 표준 라이브러리에서 &lt;code&gt;timeit&lt;/code&gt; 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78f39cdb91c380ac04df841707c9330ce5e0f8b6" translate="yes" xml:space="preserve">
          <source>As of version 2.4, you can flatten more complicated, nested iterables with &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse&quot;&gt;&lt;code&gt;more_itertools.collapse&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse&quot;&gt;source&lt;/a&gt;, contributed by  abarnet).</source>
          <target state="translated">버전 2.4 &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse&quot;&gt; &lt;code&gt;more_itertools.collapse&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse&quot;&gt;source&lt;/a&gt; , abarnet 제공)를 사용하여 더 복잡하고 중첩 된 반복 가능 항목을 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e4fb8ef7602d42af84e5483a79fac166b0b7ab" translate="yes" xml:space="preserve">
          <source>Because you are summing nested lists, you actually get &lt;code&gt;[1,3]+[2,4]&lt;/code&gt; as a result of &lt;code&gt;sum([[1,3],[2,4]],[])&lt;/code&gt;, which is equal to &lt;code&gt;[1,3,2,4]&lt;/code&gt;.</source>
          <target state="translated">중첩 목록을 합산하기 때문에 실제로 &lt;code&gt;sum([[1,3],[2,4]],[])&lt;/code&gt; 의 결과로 &lt;code&gt;[1,3]+[2,4]&lt;/code&gt; 를 얻습니다 &lt;code&gt;[1,3,2,4]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7695cefcf2d60f8c75926b4ba0826457404530c6" translate="yes" xml:space="preserve">
          <source>Code to reproduce the plot:</source>
          <target state="translated">줄거리를 재현하는 코드 :</target>
        </trans-unit>
        <trans-unit id="a616585bfa18713708d4a3a2bc94f44cc9664c38" translate="yes" xml:space="preserve">
          <source>Consider installing the &lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt; &lt;code&gt;more_itertools&lt;/code&gt; &lt;/a&gt; 패키지 설치를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ba07a235a25c22c3ececc91a67add93d936aada4" translate="yes" xml:space="preserve">
          <source>Don't reinvent the wheel if you use &lt;strong&gt;Django&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Django&lt;/strong&gt; 를 사용하는 경우 바퀴를 다시 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5ca515ce5ebb9fbc9ca9e3d43452c4f363e26fd5" translate="yes" xml:space="preserve">
          <source>Done! You can of course turn it back into a list by executing list(l)</source>
          <target state="translated">끝난! 물론 list (l)을 실행하여 목록으로 다시 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac185dfc986222e4ecce9e1d5b072f8e68479ca" translate="yes" xml:space="preserve">
          <source>Edit 11/02/2016: Only works when sublists have identical dimensions.</source>
          <target state="translated">2016 년 11 월 2 일 수정 : 하위 목록의 차원이 동일한 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="39c3e010a815528bd9b4496919045b2af64aec1c" translate="yes" xml:space="preserve">
          <source>Explanation: the shortcuts based on &lt;code&gt;+&lt;/code&gt; (including the implied use in &lt;code&gt;sum&lt;/code&gt;) are, of necessity, &lt;code&gt;O(L**2)&lt;/code&gt; when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of I items each: the first I items are copied back and forth L-1 times, the second I items L-2 times, and so on; total number of copies is I times the sum of x for x from 1 to L excluded, i.e., &lt;code&gt;I * (L**2)/2&lt;/code&gt;.</source>
          <target state="translated">설명 : &lt;code&gt;+&lt;/code&gt; 를 기반으로하는 바로 가기 (암시 적 사용을 포함하여 포함 &lt;code&gt;O(L**2)&lt;/code&gt; 는 L 하위 목록이있을 때 O (L ** 2) 가 필요합니다. 중간 결과 목록이 계속 길어질수록 각 단계에서 새로운 중간 결과 list 객체가 할당되고 이전 중간 결과의 모든 항목을 복사해야합니다 (마지막에 추가 된 몇 가지 새로운 항목). 따라서 단순성과 실제 일반성을 잃지 않고 I 항목의 L 하위 목록이 각각 있다고 가정하십시오. 첫 번째 I 항목은 L-1 번 앞뒤로 복사되고 두 번째 I 항목은 L-2 번 등으로 복사됩니다. 총 사본 수는 1에서 L까지의 x에 대한 x의 합의 I 곱하기, 즉 &lt;code&gt;I * (L**2)/2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="55df575d9380e8cbd705dfa5f7d604bb01331885" translate="yes" xml:space="preserve">
          <source>Fastest solution I have found (for large list anyway):</source>
          <target state="translated">내가 찾은 가장 빠른 솔루션 (어쨌든 큰 목록) :</target>
        </trans-unit>
        <trans-unit id="830686325b823bed7b23d54cb0487a311cd10a29" translate="yes" xml:space="preserve">
          <source>Following seem simplest to me:</source>
          <target state="translated">다음은 가장 단순 해 보입니다.</target>
        </trans-unit>
        <trans-unit id="81386a63f543dc89fc6a29418e00a411645173eb" translate="yes" xml:space="preserve">
          <source>For medium lists:</source>
          <target state="translated">중간 목록의 경우 :</target>
        </trans-unit>
        <trans-unit id="de8d08f3dc9af8f5773bf1fec37d4c6b20244b54" translate="yes" xml:space="preserve">
          <source>Found an earlier &lt;a href=&quot;https://stackoverflow.com/a/2158532/4531270&quot;&gt;SO post&lt;/a&gt;, possibly the original demonstration.</source>
          <target state="translated">이전 &lt;a href=&quot;https://stackoverflow.com/a/2158532/4531270&quot;&gt;SO post&lt;/a&gt; , 아마도 원래 데모를 찾았 습니다 .</target>
        </trans-unit>
        <trans-unit id="a296481527c15a34f5cdbc79f43470f0a233779e" translate="yes" xml:space="preserve">
          <source>Given a list of lists &lt;code&gt;l&lt;/code&gt;,</source>
          <target state="translated">목록의 목록이 주어지면 &lt;code&gt;l&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="cfb0572cc3b39652a46f7d9b229a8f0c97c6a0e8" translate="yes" xml:space="preserve">
          <source>Here is a general approach that applies to &lt;strong&gt;numbers&lt;/strong&gt;, &lt;strong&gt;strings&lt;/strong&gt;, &lt;strong&gt;nested&lt;/strong&gt; lists and &lt;strong&gt;mixed&lt;/strong&gt; containers.</source>
          <target state="translated">다음은 &lt;strong&gt;숫자&lt;/strong&gt; , &lt;strong&gt;문자열&lt;/strong&gt; , &lt;strong&gt;중첩&lt;/strong&gt; 목록 및 &lt;strong&gt;혼합&lt;/strong&gt; 컨테이너에 적용되는 일반적인 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="90277c92aa2ef531d4bb81d661f56bc4a3bae36b" translate="yes" xml:space="preserve">
          <source>Here is the corresponding function:</source>
          <target state="translated">해당 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65dbecec5681faac4b7b7628e864c5f2b770a52e" translate="yes" xml:space="preserve">
          <source>Here's a working function:</source>
          <target state="translated">작동하는 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b599b1f61b5e7a90940ef61c51226edfdd3dc1c2" translate="yes" xml:space="preserve">
          <source>Here, you check that the sub-element (1) is iterable with &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;, an ABC from &lt;code&gt;itertools&lt;/code&gt;, but also want to ensure that (2) the element is &lt;em&gt;not&lt;/em&gt; &quot;string-like.&quot;</source>
          <target state="translated">여기서는 하위 요소 (1)이 &lt;code&gt;itertools&lt;/code&gt; 의 ABC &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt; 로 반복 가능한지 확인하지만 (2) 요소가 &quot;문자열 모양&quot;이 &lt;em&gt;아닌지&lt;/em&gt; 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="47f8c1be878ff256bd61a349c03652d7ed848da2" translate="yes" xml:space="preserve">
          <source>How about performance::</source>
          <target state="translated">성능은 어떻습니까 ::</target>
        </trans-unit>
        <trans-unit id="6202fef82862d98b07042e913d0ce2707782c6ba" translate="yes" xml:space="preserve">
          <source>How to make a flat list out of list of lists</source>
          <target state="translated">목록 목록에서 단순 목록을 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="99f29d6ec76cfea7c1780d30f2c4f113f892e19c" translate="yes" xml:space="preserve">
          <source>However, consider this slightly more complex case:</source>
          <target state="translated">그러나 약간 더 복잡한 경우를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5933bc989310515ebc4ee439fbe83965e3f8a5a6" translate="yes" xml:space="preserve">
          <source>I can do that in a &lt;code&gt;for&lt;/code&gt; loop, but maybe there is some cool &quot;one-liner&quot;? I tried it with &lt;code&gt;reduce()&lt;/code&gt;, but I get an error.</source>
          <target state="translated">나는 &lt;code&gt;for&lt;/code&gt; 루프에서 그렇게 할 수 있지만 멋진 &quot;한 줄짜리&quot;가 있을까요? &lt;code&gt;reduce()&lt;/code&gt; 하여 시도했지만 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ba03edc363764ebb3a6d3e7b811a5812532edcac" translate="yes" xml:space="preserve">
          <source>I tested most suggested solutions with &lt;a href=&quot;https://github.com/nschloe/perfplot&quot;&gt;perfplot&lt;/a&gt; (a pet project of mine, essentially a wrapper around &lt;code&gt;timeit&lt;/code&gt;), and found</source>
          <target state="translated">&lt;a href=&quot;https://github.com/nschloe/perfplot&quot;&gt;perfplot&lt;/a&gt; (내 애완 동물 프로젝트, 본질적으로 &lt;code&gt;timeit&lt;/code&gt; 주위 래퍼)으로 가장 많이 제안 된 솔루션을 테스트 했으며</target>
        </trans-unit>
        <trans-unit id="876cae1b1c230f0b41d5bbd93d68960bc959b80c" translate="yes" xml:space="preserve">
          <source>I wonder whether there is a shortcut to make a simple list out of list of lists in Python.</source>
          <target state="translated">파이썬의 목록 목록에서 간단한 목록을 만드는 지름길이 있는지 궁금합니다.</target>
        </trans-unit>
        <trans-unit id="61fc8760cdaa2f2e5362a195c732748258b70b96" translate="yes" xml:space="preserve">
          <source>If you are willing to give up a tiny amount of speed for a cleaner look, then you could use &lt;code&gt;numpy.concatenate().tolist()&lt;/code&gt; or &lt;code&gt;numpy.concatenate().ravel().tolist()&lt;/code&gt;:</source>
          <target state="translated">깔끔한 외관을 위해 약간의 속도를 포기하고 &lt;code&gt;numpy.concatenate().tolist()&lt;/code&gt; 또는 &lt;code&gt;numpy.concatenate().ravel().tolist()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2612465f4102edf2a5792b74f40ea0d29bfb7d8" translate="yes" xml:space="preserve">
          <source>If you want to flatten a data-structure where you don't know how deep it's nested you could use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt;&lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt;&lt;/a&gt;&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">얼마나 깊이 중첩되어 있는지 모르는 데이터 구조를 평탄화하려면 &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt; &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; &lt;/a&gt; &lt;sup&gt;1을&lt;/sup&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32fee52bb03074fffdc25bdcabef4136af14249f" translate="yes" xml:space="preserve">
          <source>If you're thinking functional, it is as easy as this::</source>
          <target state="translated">기능적이라고 생각하면 다음과 같이 쉽습니다. :</target>
        </trans-unit>
        <trans-unit id="d2fa2014fa3a734a25a87e6c0fcd1d6156afb5bd" translate="yes" xml:space="preserve">
          <source>In Python 3, &lt;code&gt;yield from flatten(x)&lt;/code&gt; can replace &lt;code&gt;for sub_x in flatten(x): yield sub_x&lt;/code&gt;</source>
          <target state="translated">Python 3 &lt;code&gt;yield from flatten(x)&lt;/code&gt; &lt;code&gt;for sub_x in flatten(x): yield sub_x&lt;/code&gt; 대체 할 수 있습니다 . yield sub_x</target>
        </trans-unit>
        <trans-unit id="514f6225a66010f2d4c19d4f65146ac3f7d801d1" translate="yes" xml:space="preserve">
          <source>In Python 3.8, &lt;a href=&quot;https://docs.python.org/3/library/collections.abc.html#module-collections.abc&quot;&gt;abstract base classes&lt;/a&gt; are &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.7.html#id3&quot;&gt;moved&lt;/a&gt; from &lt;code&gt;collection.abc&lt;/code&gt; to the &lt;code&gt;typing&lt;/code&gt; module.</source>
          <target state="translated">Python 3.8에서는 &lt;a href=&quot;https://docs.python.org/3/library/collections.abc.html#module-collections.abc&quot;&gt;추상 기본 클래스&lt;/a&gt; 가 &lt;code&gt;collection.abc&lt;/code&gt; 에서 &lt;code&gt;typing&lt;/code&gt; 모듈 &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.7.html#id3&quot;&gt;로 이동&lt;/a&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="7121c3061e262fdfa84e5a233d466f5601743942" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;obj = [[1, 2,], [3, 4], [5, 6]]&lt;/code&gt;, all of the solutions here are good, including list comprehension and &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj = [[1, 2,], [3, 4], [5, 6]]&lt;/code&gt; 의 경우 목록 이해 및 &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; 을 포함하여 여기의 모든 솔루션이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ae463b2138420d7f869146a1a9a4624956753f55" translate="yes" xml:space="preserve">
          <source>It ships with an implementation for &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten&quot;&gt;source&lt;/a&gt;, from the &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools recipes&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten&quot;&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten&quot;&gt;source&lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools recipes&lt;/a&gt; ) 구현이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="81faee37aa250627b621e8f54d471969e6c42fdf" translate="yes" xml:space="preserve">
          <source>It solves all flatten problems (none list item or complex nesting)</source>
          <target state="translated">모든 평탄화 문제를 해결합니다 (목록 항목이 없거나 복잡한 중첩).</target>
        </trans-unit>
        <trans-unit id="6f4274e4e265456695c37cb98096f65cdb50b393" translate="yes" xml:space="preserve">
          <source>It's a generator so you need to cast the result to a &lt;code&gt;list&lt;/code&gt; or explicitly iterate over it.</source>
          <target state="translated">생성기이므로 결과를 &lt;code&gt;list&lt;/code&gt; 으로 캐스트하거나 명시 적으로 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="bab3f440e0cb9b6ef1870545dce67cee5b69549a" translate="yes" xml:space="preserve">
          <source>It's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better.</source>
          <target state="translated">광범위한 범위의 값을 수용하기위한 로그-로그 플롯입니다. 질적 추론 : 낮을수록 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c4d4f86224ef28956be32e434d9873c524962e30" translate="yes" xml:space="preserve">
          <source>Just to add some timings (based on Nico Schl&amp;ouml;mer answer that didn't include the function presented in this answer):</source>
          <target state="translated">타이밍을 추가하기 만하면 (이 답변에 제시된 기능을 포함하지 않은 Nico Schl&amp;ouml;mer 답변을 기반으로 함) :</target>
        </trans-unit>
        <trans-unit id="3be2f60b7d85235e979e45d49f68feac671b94c1" translate="yes" xml:space="preserve">
          <source>New proposed solution that &lt;em&gt;did&lt;/em&gt; work for me:</source>
          <target state="translated">나를 위해 일한 새로운 제안 된 솔루션 :</target>
        </trans-unit>
        <trans-unit id="0ffedc979da9fc4c310ebb5e966b9183d9fbaafe" translate="yes" xml:space="preserve">
          <source>Note that only works on lists of lists. For lists of lists of lists, you'll need another solution.</source>
          <target state="translated">목록 목록에서만 작동합니다. 목록 목록의 경우 다른 솔루션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="da5cc2418e5a4bd3106e3f3ce95f6320daee1110" translate="yes" xml:space="preserve">
          <source>Note: extend is more efficient than + on lists.</source>
          <target state="translated">참고 : 확장은 목록에서 +보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="c47684635a9abd882bb07dd1af45494e951b55aa" translate="yes" xml:space="preserve">
          <source>One can also use NumPy's &lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html&quot;&gt;flat&lt;/a&gt;:</source>
          <target state="translated">NumPy의 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html&quot;&gt;flat을&lt;/a&gt; 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="87936a8087e52b4dc48ce96d0bf6a057c81e8ab2" translate="yes" xml:space="preserve">
          <source>One element, &lt;code&gt;'abc'&lt;/code&gt;, &lt;em&gt;is&lt;/em&gt; technically iterable (all &lt;code&gt;str&lt;/code&gt;s are).  However, reading between the lines a bit, you don't want to treat it as such--you want to treat it as a single element.</source>
          <target state="translated">하나의 요소 &lt;code&gt;'abc'&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; 기술적으로 반복 가능합니다 (모든 &lt;code&gt;str&lt;/code&gt; 이 있습니다). 그러나 줄 사이를 조금만 읽으면 해당 줄을 단일 요소로 취급하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2906f0e61b652b524e54b5ed7699d5db97c2adeb" translate="yes" xml:space="preserve">
          <source>One element, &lt;code&gt;6&lt;/code&gt;, is just a scalar; it's not iterable, so the above routes will fail here.</source>
          <target state="translated">하나의 요소 &lt;code&gt;6&lt;/code&gt; 은 스칼라 일뿐입니다. 반복 할 수 없으므로 위의 경로는 여기서 실패합니다.</target>
        </trans-unit>
        <trans-unit id="314acacc9569152fc4da86dd9d5208c370dc9afc" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt;&lt;code&gt;itertools.chain.from_iterable()&lt;/code&gt;&lt;/a&gt; which doesn't require unpacking the list with the &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#tut-unpacking-arguments&quot;&gt;&lt;code&gt;*&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt; &lt;code&gt;itertools.chain.from_iterable()&lt;/code&gt; &lt;/a&gt; 을 사용하면 &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#tut-unpacking-arguments&quot;&gt; &lt;code&gt;*&lt;/code&gt; 연산자로&lt;/a&gt; 목록의 압축을 풀 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="96b676519adbe95ecb795d350dfb60971f7271dc" translate="yes" xml:space="preserve">
          <source>Recursive version</source>
          <target state="translated">재귀 버전</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="24c3fe6c6fdc963c62e2db5221e26b4d3823916f" translate="yes" xml:space="preserve">
          <source>Simple code for &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt;&lt;code&gt;underscore.py&lt;/code&gt;&lt;/a&gt; package fan</source>
          <target state="translated">&lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt; &lt;code&gt;underscore.py&lt;/code&gt; &lt;/a&gt; 패키지 팬을위한 간단한 코드</target>
        </trans-unit>
        <trans-unit id="38d4e1b388c4c9a2760e19d334c82a73510265e8" translate="yes" xml:space="preserve">
          <source>Testing:</source>
          <target state="translated">Testing:</target>
        </trans-unit>
        <trans-unit id="8eb26a47b520c5dbbccaf00c5378c80eb2b2e50e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extend()&lt;/code&gt; method in your example modifies &lt;code&gt;x&lt;/code&gt; instead of returning a useful value (which &lt;code&gt;reduce()&lt;/code&gt; expects).</source>
          <target state="translated">예제의 &lt;code&gt;extend()&lt;/code&gt; 메소드는 유용한 값 ( &lt;code&gt;reduce()&lt;/code&gt; 기대하는)을 반환하는 대신 &lt;code&gt;x&lt;/code&gt; 를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="df9a56352fe0182aa9b3497490b49100923fa99c" translate="yes" xml:space="preserve">
          <source>The above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl &lt;code&gt;flist&lt;/code&gt;, like below.</source>
          <target state="translated">위의 목록은 여러 로컬 목록을 만들어 부모 목록을 확장하는 데 사용되는 목록을 반환합니다. 이 문제를 해결하는 방법은 아래와 같이 gloabl &lt;code&gt;flist&lt;/code&gt; 를 만드는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="386171513d5c24a58e7ed773e77f34df403522e7" translate="yes" xml:space="preserve">
          <source>The accepted answer did not work for me when dealing with text-based lists of variable lengths. Here is an alternate approach that did work for me.</source>
          <target state="translated">가변 길이의 텍스트 기반 목록을 처리 할 때 허용되는 답변이 작동하지 않았습니다. 나를 위해 일한 다른 접근법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32b0e7cb6d27e016711c8a613c0443164f3ad516" translate="yes" xml:space="preserve">
          <source>The advantage of this solution over most others here is that if you have a list like:</source>
          <target state="translated">여기에서 대부분의 다른 솔루션보다이 솔루션의 장점은 다음과 같은 목록이있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="6f6eb68ec0de9e7966a150472808fb0be4be2be4" translate="yes" xml:space="preserve">
          <source>The final element, &lt;code&gt;[8, [9, 10]]&lt;/code&gt; is itself a nested iterable.  Basic list comprehension and &lt;code&gt;chain.from_iterable&lt;/code&gt; only extract &quot;1 level down.&quot;</source>
          <target state="translated">마지막 요소 &lt;code&gt;[8, [9, 10]]&lt;/code&gt; 자체는 중첩 된 반복 가능 요소입니다. 기본 목록 이해 및 &lt;code&gt;chain.from_iterable&lt;/code&gt; 은 &quot;1 레벨 다운&quot;만 추출합니다.</target>
        </trans-unit>
        <trans-unit id="2f8cc82ebeb3c2efcac05855ec9c0cb5bccc63bd" translate="yes" xml:space="preserve">
          <source>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</source>
          <target state="translated">목록 이해는 하나의 목록을 한 번만 생성하고 각 항목을 원래 위치에서 결과 목록으로 정확히 한 번 복사합니다.</target>
        </trans-unit>
        <trans-unit id="c55395401359835a6e3f32b3f23a39a7f4f78ecc" translate="yes" xml:space="preserve">
          <source>The output is</source>
          <target state="translated">출력은</target>
        </trans-unit>
        <trans-unit id="e7e78b54dc635e3743925801712ceba59b3f69ff" translate="yes" xml:space="preserve">
          <source>The output is again</source>
          <target state="translated">다시 출력</target>
        </trans-unit>
        <trans-unit id="a57f5af7d243e25c69e05bf8c07fdb2268f7e527" translate="yes" xml:space="preserve">
          <source>The reason your function didn't work is because the &lt;em&gt;extend&lt;/em&gt; extends an array in-place and doesn't return it. You can still return x from lambda, using something like this:</source>
          <target state="translated">함수가 작동하지 않는 이유는 &lt;em&gt;확장&lt;/em&gt; 이 배열을 제자리로 확장하고 반환하지 않기 때문입니다. 다음과 같이 람다에서 x를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcc503c0e349fbcd95911ec7361823eee8d6907c" translate="yes" xml:space="preserve">
          <source>The results show that if the iterable contains only a few inner iterables then &lt;code&gt;sum&lt;/code&gt; will be fastest, however for long iterables only the &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;, &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; or the nested comprehension have reasonable performance with &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; being the fastest (as already noticed by Nico Schl&amp;ouml;mer).</source>
          <target state="translated">결과에 따르면 iterable에 내부 iterable이 몇 개만 포함되어 있으면 &lt;code&gt;sum&lt;/code&gt; 이 가장 빠르지 만 &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; , &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; 또는 중첩 이해 만 &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; 이 가장 빠릅니다. (니코 Schl&amp;ouml;mer에 의해 이미 알려진 바와 같이).</target>
        </trans-unit>
        <trans-unit id="7175c5e62cfcd939bbd4213e3f7c7e95a96b69db" translate="yes" xml:space="preserve">
          <source>The sum version is still running for more than a minute and it hasn't done processing yet!</source>
          <target state="translated">합계 버전이 여전히 1 분 이상 실행 중이며 아직 처리되지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="a4a70ba48ec34522605cf566e94a4806b211eeb3" translate="yes" xml:space="preserve">
          <source>There are several problems here:</source>
          <target state="translated">여기 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c67e5d7f089a9f9e7857e3acedcc581dc0f9c42" translate="yes" xml:space="preserve">
          <source>There seems to be a confusion with &lt;code&gt;operator.add&lt;/code&gt;! When you add two lists together, the correct term for that is &lt;code&gt;concat&lt;/code&gt;, not add. &lt;code&gt;operator.concat&lt;/code&gt; is what you need to use.</source>
          <target state="translated">&lt;code&gt;operator.add&lt;/code&gt; 와 혼동이있는 것 같습니다! 두 개의 목록을 함께 추가하면 해당 용어에 대한 올바른 용어는 추가되지 않습니다. &lt;code&gt;operator.concat&lt;/code&gt; 은 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="af9f85228d363e1396dd2478ab29159bb2918911" translate="yes" xml:space="preserve">
          <source>This Code also works fine as it just extend the list all the way. Although it is much similar but only have one for loop. So It have less complexity than adding 2 for loops.</source>
          <target state="translated">이 코드는 목록을 끝까지 확장하므로 잘 작동합니다. 그것은 매우 비슷하지만 하나의 for 루프 만 있습니다. 따라서 2 개의 for 루프를 추가하는 것보다 덜 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="e08b5f038b08a8c96efa1f08522f5e66a998d327" translate="yes" xml:space="preserve">
          <source>This is 18x faster than underscore._.flatten:</source>
          <target state="translated">이것은 밑줄보다 평평한 속도보다 18 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="64c743f00d333be28bff13f8652e1a11252b868f" translate="yes" xml:space="preserve">
          <source>This just sums the elements of iterable passed in the first argument, treating second argument as the initial value of the sum (if not given, &lt;code&gt;0&lt;/code&gt; is used instead and this case will give you an error).</source>
          <target state="translated">이것은 첫 번째 인수에 전달 된 iterable의 요소를 합하여 두 번째 인수를 합계의 초기 값으로 취급합니다 (제공되지 않으면 &lt;code&gt;0&lt;/code&gt; 이 대신 사용 되며이 경우 오류가 발생합니다).</target>
        </trans-unit>
        <trans-unit id="22c2c19b3bac52f4b2cf95eeea7c5da16b692799" translate="yes" xml:space="preserve">
          <source>This may not be the most efficient way but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python3.5) and recursion.</source>
          <target state="translated">이것은 가장 효율적인 방법은 아니지만 하나의 라이너 (실제로 두 개의 라이너)를 넣는 것으로 생각했습니다. 두 버전 모두 임의의 계층 구조 중첩 목록에서 작동하며 언어 기능 (Python3.5) 및 재귀를 이용합니다.</target>
        </trans-unit>
        <trans-unit id="ab7d5f153551afca8f6c602e4de5f5383356ed3b" translate="yes" xml:space="preserve">
          <source>This should work fine.</source>
          <target state="translated">이것은 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c8771b06b3b88dac30f258456688e4372fdb7213" translate="yes" xml:space="preserve">
          <source>This solution is modified from a recipe in &lt;em&gt;Beazley, D. and B. Jones.  Recipe 4.14, Python Cookbook 3rd Ed., O'Reilly Media Inc. Sebastopol, CA: 2013.&lt;/em&gt;</source>
          <target state="translated">이 솔루션은 &lt;em&gt;Beazley, D. 및 B. Jones&lt;/em&gt; 의 레시피에서 수정되었습니다 &lt;em&gt;.&lt;/em&gt; &lt;em&gt;레시피 4.14, Python Cookbook 3rd Ed., O'Reilly Media Inc. Sebastopol, CA : 2013.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9bcd7287917139a6af150a5761753b741a5dfa5f" translate="yes" xml:space="preserve">
          <source>This works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable &lt;code&gt;flist&lt;/code&gt; and then rolls back it to the parent. Whenever &lt;code&gt;flist&lt;/code&gt; is returned, it is extended to the parent's &lt;code&gt;flist&lt;/code&gt; in the list comprehension. Therefore, at the root, a flat list is returned.</source>
          <target state="translated">이것은 깊이 우선 방식으로 작동합니다. 재귀는 목록에없는 요소를 찾을 때까지 내려간 다음 지역 변수 &lt;code&gt;flist&lt;/code&gt; 를 확장 한 다음이를 부모에게 롤백합니다. &lt;code&gt;flist&lt;/code&gt; 가 리턴 될 때마다 목록 이해에서 상위의 &lt;code&gt;flist&lt;/code&gt; 로 확장됩니다. 따라서 루트에서 플랫 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="59ed80852db6ea428cf54dd89710beabb15d36d1" translate="yes" xml:space="preserve">
          <source>To flatten only one level and if each of the items is itself iterable you can also use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html&quot;&gt;&lt;code&gt;iteration_utilities.flatten&lt;/code&gt;&lt;/a&gt; which itself is just a thin wrapper around &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt;&lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">하나의 레벨 만 평탄화하고 각 항목 자체가 반복 가능한 경우 &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html&quot;&gt; &lt;code&gt;iteration_utilities.flatten&lt;/code&gt; &lt;/a&gt; 주위의 얇은 래퍼 인 iteration_utilities.flatten 을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d85e040c6b2316333bbc8b6ece8ebd109dcad5c6" translate="yes" xml:space="preserve">
          <source>Using small lists and timeit: number=1000000</source>
          <target state="translated">작은 목록과 timeit 사용 : number = 1000000</target>
        </trans-unit>
        <trans-unit id="8b777156d7db14dbefaad623bb79535a459684ae" translate="yes" xml:space="preserve">
          <source>Why do you use extend?</source>
          <target state="translated">왜 extend를 사용합니까?</target>
        </trans-unit>
        <trans-unit id="026239782349d9cccf8cae513c88ec70bc6f77a6" translate="yes" xml:space="preserve">
          <source>You can find out more here in the docs &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html&quot;&gt;numpy.concatenate&lt;/a&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html&quot;&gt;numpy.ravel&lt;/a&gt;</source>
          <target state="translated">문서 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html&quot;&gt;numpy.concatenate&lt;/a&gt; 및 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html&quot;&gt;numpy.ravel&lt;/a&gt; 에서 자세한 내용을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98f00c4375c36821b12502ea83723a702fb0edfd" translate="yes" xml:space="preserve">
          <source>You can install &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt;&lt;code&gt;underscore.py&lt;/code&gt;&lt;/a&gt; with pip</source>
          <target state="translated">pip로 &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt; &lt;code&gt;underscore.py&lt;/code&gt; &lt;/a&gt; 를 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4e3f2e4eb4b0b94b2d85fa9b562339a3ec7bc93b" translate="yes" xml:space="preserve">
          <source>You can remedy this as follows:</source>
          <target state="translated">다음과 같이이를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b69cc7e24723fc0ad7c514ca643eccd680bfbd54" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain&quot;&gt;&lt;code&gt;itertools.chain()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain&quot;&gt; &lt;code&gt;itertools.chain()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ae1549c83cb4c81622f3b6d9fed8b362916b2245" translate="yes" xml:space="preserve">
          <source>You can use numpy :</source>
          <target state="translated">numpy 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ac9b642dd33f13b33118da8230b6f694c73801a1" translate="yes" xml:space="preserve">
          <source>You see reduce respects the sequence type, so when you supply a tuple, you get back a tuple. Let's try with a list::</source>
          <target state="translated">시퀀스 유형이 축소되는 것을 알 수 있으므로 튜플을 공급하면 튜플이 다시 나타납니다. 목록으로 시도해 봅시다 ::</target>
        </trans-unit>
        <trans-unit id="2fae8325874681cc6b334b37cba1a121bd8cfad9" translate="yes" xml:space="preserve">
          <source>another fun way to do this:</source>
          <target state="translated">이것을하는 또 다른 재미있는 방법 :</target>
        </trans-unit>
        <trans-unit id="9909ec7f3a3afabe82abee395540624cbdaad7c1" translate="yes" xml:space="preserve">
          <source>is faster than the shortcuts posted so far. (&lt;code&gt;l&lt;/code&gt; is the list to flatten.)</source>
          <target state="translated">지금까지 게시 된 바로 가기보다 빠릅니다. ( &lt;code&gt;l&lt;/code&gt; 은 병합 할 목록입니다.)</target>
        </trans-unit>
        <trans-unit id="abfaa5b8f36540158b4c83a8c2ff8def85ec64e0" translate="yes" xml:space="preserve">
          <source>to be the fastest solution. (&lt;code&gt;operator.iadd&lt;/code&gt; is equally fast.)</source>
          <target state="translated">가장 빠른 솔루션입니다. ( &lt;code&gt;operator.iadd&lt;/code&gt; 도 똑같이 빠릅니다.)</target>
        </trans-unit>
        <trans-unit id="3d6b372a9c60b40127154403945e3da65b17a4cf" translate="yes" xml:space="preserve">
          <source>which means:</source>
          <target state="translated">이는 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a81fcda00582e8515550fb41988323475038a58" translate="yes" xml:space="preserve">
          <source>while most other solutions throw an error this solution handles them.</source>
          <target state="translated">대부분의 다른 솔루션에서 오류가 발생하지만이 솔루션에서 처리합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
