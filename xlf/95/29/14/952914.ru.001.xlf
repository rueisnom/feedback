<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/952914">
    <body>
      <group id="952914">
        <trans-unit id="c7212e4ddbfbd11031c6226c57bdfe67288fb392" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Itertools&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Itertools&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="c38e822746feba1c5a49dc07f0faa24c4c4931b8" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Matplotlib&lt;/strong&gt;</source>
          <target state="translated">...&lt;strong&gt;Matplotlib&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9613459c01cb7031c63f21aeb1fc59b70025f78" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Pandas&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Pandas&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="77820f7ceaf27b513827583c0595b5674e49df57" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Setuptools&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Setuptools&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="96580150ba876eb18a7f55a60d0871b389dcdfb9" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Unipath&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Unipath&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b988115e6086e3dfbfef73ed6a51772ebb57d0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_iterable&lt;/code&gt; is pretty fast! But it's no comparison to reduce with &lt;code&gt;concat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;from_iterable&lt;/code&gt; довольно быстрый! Но это не сравнить, чтобы уменьшить с &lt;code&gt;concat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22e0147f3766b1297fd754cae27ffd20940d80d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matplotlib.cbook.flatten()&lt;/code&gt; will work for nested lists even if they nest more deeply than the example.</source>
          <target state="translated">&lt;code&gt;matplotlib.cbook.flatten()&lt;/code&gt; будет работать для вложенных списков, даже если они вложены глубже, чем в примере.</target>
        </trans-unit>
        <trans-unit id="f05a79f3c1b6d531b3afef5719fd794bc8e796c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Notes&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Notes&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a79903480a5608a4282c3838d1bbe7ef700e434b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Demo&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Demo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="630494acded75e86cdf6b39a97d60ee31ec53223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Error message&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сообщение об ошибке&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5cca58a8ac381d444b393a0c564994acbbba4985" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I take my statement back. sum is not the winner. Although it is faster when the list is small. But the performance degrades significantly with larger lists.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Я забираю свое заявление обратно.&lt;/strong&gt; &lt;strong&gt;сумма не победитель.&lt;/strong&gt; &lt;strong&gt;Хотя это быстрее, когда список невелик.&lt;/strong&gt; &lt;strong&gt;Но производительность значительно ухудшается с большими списками.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cb834ff6376acff7370669f5a5e4c75c94f3e3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note from the author&lt;/strong&gt;: This is inefficient. But fun, because &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science&quot;&gt;monoids&lt;/a&gt; are awesome. It's not appropriate for production Python code.</source>
          <target state="translated">&lt;strong&gt;Примечание автора&lt;/strong&gt; : это неэффективно. Но весело, потому что &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science&quot;&gt;моноиды&lt;/a&gt; потрясающие. Это не подходит для производственного кода Python.</target>
        </trans-unit>
        <trans-unit id="ed88dbceadb4943205fcb5801aa28bda02f9d380" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Below applies to Python 3.3+ because it uses &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html&quot;&gt;&lt;code&gt;yield_from&lt;/code&gt;&lt;/a&gt;.  &lt;code&gt;six&lt;/code&gt; is also a third-party package, though it is stable.  Alternately, you could use &lt;code&gt;sys.version&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : ниже применяется к Python 3.3+, потому что он использует &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html&quot;&gt; &lt;code&gt;yield_from&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;six&lt;/code&gt; тоже сторонний пакет, хотя и стабильный. В качестве альтернативы вы можете использовать &lt;code&gt;sys.version&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2a6eb120ac5d954b7aa47baca4f35f487d47fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd4fbdf13dfb7b34fb1cfad02cbbdb2cd557e3bb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 Disclaimer: I'm the author of that library&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1 Отказ от ответственности: я автор этой библиотеки&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fd92c55b0dc16e777e3a8b2fef34d2eb8a6d0d79" translate="yes" xml:space="preserve">
          <source>A faster way to do the &lt;code&gt;reduce&lt;/code&gt; version would be</source>
          <target state="translated">Более быстрый способ сделать &lt;code&gt;reduce&lt;/code&gt; версию будет</target>
        </trans-unit>
        <trans-unit id="644e0cd0e37d239b0db451be1ed40f528a62e4aa" translate="yes" xml:space="preserve">
          <source>Accepted answer that did &lt;em&gt;not&lt;/em&gt; work:</source>
          <target state="translated">Принимается ответ, который &lt;em&gt;не&lt;/em&gt; сработал:</target>
        </trans-unit>
        <trans-unit id="92d8769801fabd6702c5789616d5242fc7543178" translate="yes" xml:space="preserve">
          <source>Aha, you get back a list.</source>
          <target state="translated">Ага,ты получишь список.</target>
        </trans-unit>
        <trans-unit id="4967535c662745c7a48ab240736eb2afb1b8188c" translate="yes" xml:space="preserve">
          <source>Although I am not sure at this time about the efficiency.</source>
          <target state="translated">Хотя в данный момент я не уверен в эффективности.</target>
        </trans-unit>
        <trans-unit id="33c231558a50c479e065510258c34b8fabc3215b" translate="yes" xml:space="preserve">
          <source>An bad feature of Anil's function above is that it requires the user to always manually specify the second argument to be an empty list &lt;code&gt;[]&lt;/code&gt;. This should instead be a default. Due to the way Python objects work, these should be set inside the function, not in the arguments.</source>
          <target state="translated">Плохая особенность функции Anil, описанной выше, состоит в том, что она требует, чтобы пользователь всегда вручную указывал второй аргумент, чтобы он был пустым списком &lt;code&gt;[]&lt;/code&gt; . Вместо этого это должно быть по умолчанию. Из-за того, как работают объекты Python, их следует устанавливать внутри функции, а не в аргументах.</target>
        </trans-unit>
        <trans-unit id="fe8d80125b2f737fe3af135678ddabde16aa4257" translate="yes" xml:space="preserve">
          <source>As evidence, you can use the &lt;code&gt;timeit&lt;/code&gt; module in the standard library:</source>
          <target state="translated">В качестве доказательства вы можете использовать модуль &lt;code&gt;timeit&lt;/code&gt; в стандартной библиотеке:</target>
        </trans-unit>
        <trans-unit id="78f39cdb91c380ac04df841707c9330ce5e0f8b6" translate="yes" xml:space="preserve">
          <source>As of version 2.4, you can flatten more complicated, nested iterables with &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse&quot;&gt;&lt;code&gt;more_itertools.collapse&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse&quot;&gt;source&lt;/a&gt;, contributed by  abarnet).</source>
          <target state="translated">Начиная с версии 2.4, вы можете сгладить более сложные вложенные итерации с помощью &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse&quot;&gt; &lt;code&gt;more_itertools.collapse&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse&quot;&gt;источник&lt;/a&gt; , предоставленный abarnet).</target>
        </trans-unit>
        <trans-unit id="53e4fb8ef7602d42af84e5483a79fac166b0b7ab" translate="yes" xml:space="preserve">
          <source>Because you are summing nested lists, you actually get &lt;code&gt;[1,3]+[2,4]&lt;/code&gt; as a result of &lt;code&gt;sum([[1,3],[2,4]],[])&lt;/code&gt;, which is equal to &lt;code&gt;[1,3,2,4]&lt;/code&gt;.</source>
          <target state="translated">Поскольку вы суммируете вложенные списки, вы фактически получаете &lt;code&gt;[1,3]+[2,4]&lt;/code&gt; в результате &lt;code&gt;sum([[1,3],[2,4]],[])&lt;/code&gt; , которое равно &lt;code&gt;[1,3,2,4]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7695cefcf2d60f8c75926b4ba0826457404530c6" translate="yes" xml:space="preserve">
          <source>Code to reproduce the plot:</source>
          <target state="translated">Код для воспроизведения сюжета:</target>
        </trans-unit>
        <trans-unit id="a616585bfa18713708d4a3a2bc94f44cc9664c38" translate="yes" xml:space="preserve">
          <source>Consider installing the &lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">Рассмотрите возможность установки пакета &lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt; &lt;code&gt;more_itertools&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba07a235a25c22c3ececc91a67add93d936aada4" translate="yes" xml:space="preserve">
          <source>Don't reinvent the wheel if you use &lt;strong&gt;Django&lt;/strong&gt;:</source>
          <target state="translated">Не изобретайте велосипед, если вы используете &lt;strong&gt;Django&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="5ca515ce5ebb9fbc9ca9e3d43452c4f363e26fd5" translate="yes" xml:space="preserve">
          <source>Done! You can of course turn it back into a list by executing list(l)</source>
          <target state="translated">Готово! Вы,конечно,можете превратить его обратно в список,выполнив list(l).</target>
        </trans-unit>
        <trans-unit id="2ac185dfc986222e4ecce9e1d5b072f8e68479ca" translate="yes" xml:space="preserve">
          <source>Edit 11/02/2016: Only works when sublists have identical dimensions.</source>
          <target state="translated">Редакция 11022016:Работает только тогда,когда подлисты имеют одинаковые размеры.</target>
        </trans-unit>
        <trans-unit id="39c3e010a815528bd9b4496919045b2af64aec1c" translate="yes" xml:space="preserve">
          <source>Explanation: the shortcuts based on &lt;code&gt;+&lt;/code&gt; (including the implied use in &lt;code&gt;sum&lt;/code&gt;) are, of necessity, &lt;code&gt;O(L**2)&lt;/code&gt; when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of I items each: the first I items are copied back and forth L-1 times, the second I items L-2 times, and so on; total number of copies is I times the sum of x for x from 1 to L excluded, i.e., &lt;code&gt;I * (L**2)/2&lt;/code&gt;.</source>
          <target state="translated">Объяснение: ярлыки, основанные на &lt;code&gt;+&lt;/code&gt; (включая подразумеваемое использование в &lt;code&gt;sum&lt;/code&gt; ), по необходимости, &lt;code&gt;O(L**2)&lt;/code&gt; когда есть L подсписки - поскольку список промежуточных результатов продолжает увеличиваться, на каждом шаге новый промежуточный результат Объект списка распределяется, и все элементы предыдущего промежуточного результата должны быть скопированы (а также добавлено несколько новых в конце). Итак, для простоты и без фактической потери общности, скажем, у вас есть L подсписков из I элементов каждый: первые I элементы копируются назад и вперед L-1 раз, вторые I элементы L-2 раза и т. Д .; общее количество копий равно I, умноженной на сумму x для x от 1 до L, т.е. &lt;code&gt;I * (L**2)/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55df575d9380e8cbd705dfa5f7d604bb01331885" translate="yes" xml:space="preserve">
          <source>Fastest solution I have found (for large list anyway):</source>
          <target state="translated">Самое быстрое решение,которое я нашел (для большого списка в любом случае):</target>
        </trans-unit>
        <trans-unit id="830686325b823bed7b23d54cb0487a311cd10a29" translate="yes" xml:space="preserve">
          <source>Following seem simplest to me:</source>
          <target state="translated">Следование кажется мне простым:</target>
        </trans-unit>
        <trans-unit id="81386a63f543dc89fc6a29418e00a411645173eb" translate="yes" xml:space="preserve">
          <source>For medium lists:</source>
          <target state="translated">Для средних списков:</target>
        </trans-unit>
        <trans-unit id="de8d08f3dc9af8f5773bf1fec37d4c6b20244b54" translate="yes" xml:space="preserve">
          <source>Found an earlier &lt;a href=&quot;https://stackoverflow.com/a/2158532/4531270&quot;&gt;SO post&lt;/a&gt;, possibly the original demonstration.</source>
          <target state="translated">Нашел более ранний &lt;a href=&quot;https://stackoverflow.com/a/2158532/4531270&quot;&gt;пост SO&lt;/a&gt; , возможно оригинальную демонстрацию.</target>
        </trans-unit>
        <trans-unit id="a296481527c15a34f5cdbc79f43470f0a233779e" translate="yes" xml:space="preserve">
          <source>Given a list of lists &lt;code&gt;l&lt;/code&gt;,</source>
          <target state="translated">Учитывая список списков &lt;code&gt;l&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="cfb0572cc3b39652a46f7d9b229a8f0c97c6a0e8" translate="yes" xml:space="preserve">
          <source>Here is a general approach that applies to &lt;strong&gt;numbers&lt;/strong&gt;, &lt;strong&gt;strings&lt;/strong&gt;, &lt;strong&gt;nested&lt;/strong&gt; lists and &lt;strong&gt;mixed&lt;/strong&gt; containers.</source>
          <target state="translated">Вот общий подход, который применяется к &lt;strong&gt;числам&lt;/strong&gt; , &lt;strong&gt;строкам&lt;/strong&gt; , &lt;strong&gt;вложенным&lt;/strong&gt; спискам и &lt;strong&gt;смешанным&lt;/strong&gt; контейнерам.</target>
        </trans-unit>
        <trans-unit id="90277c92aa2ef531d4bb81d661f56bc4a3bae36b" translate="yes" xml:space="preserve">
          <source>Here is the corresponding function:</source>
          <target state="translated">Вот соответствующая функция:</target>
        </trans-unit>
        <trans-unit id="65dbecec5681faac4b7b7628e864c5f2b770a52e" translate="yes" xml:space="preserve">
          <source>Here's a working function:</source>
          <target state="translated">Вот рабочая функция:</target>
        </trans-unit>
        <trans-unit id="b599b1f61b5e7a90940ef61c51226edfdd3dc1c2" translate="yes" xml:space="preserve">
          <source>Here, you check that the sub-element (1) is iterable with &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;, an ABC from &lt;code&gt;itertools&lt;/code&gt;, but also want to ensure that (2) the element is &lt;em&gt;not&lt;/em&gt; &quot;string-like.&quot;</source>
          <target state="translated">Здесь вы проверяете, что подэлемент (1) является итеративным с &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt; , ABC от &lt;code&gt;itertools&lt;/code&gt; , но также хотите убедиться, что (2) элемент &lt;em&gt;не&lt;/em&gt; является &amp;laquo;строковым&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="47f8c1be878ff256bd61a349c03652d7ed848da2" translate="yes" xml:space="preserve">
          <source>How about performance::</source>
          <target state="translated">Как насчет производительности:..:</target>
        </trans-unit>
        <trans-unit id="6202fef82862d98b07042e913d0ce2707782c6ba" translate="yes" xml:space="preserve">
          <source>How to make a flat list out of list of lists</source>
          <target state="translated">Как сделать плоский список из списка списков</target>
        </trans-unit>
        <trans-unit id="99f29d6ec76cfea7c1780d30f2c4f113f892e19c" translate="yes" xml:space="preserve">
          <source>However, consider this slightly more complex case:</source>
          <target state="translated">Однако,рассмотрим этот немного более сложный случай:</target>
        </trans-unit>
        <trans-unit id="5933bc989310515ebc4ee439fbe83965e3f8a5a6" translate="yes" xml:space="preserve">
          <source>I can do that in a &lt;code&gt;for&lt;/code&gt; loop, but maybe there is some cool &quot;one-liner&quot;? I tried it with &lt;code&gt;reduce()&lt;/code&gt;, but I get an error.</source>
          <target state="translated">Я могу сделать это в цикле &lt;code&gt;for&lt;/code&gt; , но, может быть, есть какой-нибудь крутой &amp;laquo;однострочный&amp;raquo;? Я пробовал с помощью &lt;code&gt;reduce()&lt;/code&gt; , но я получаю сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="ba03edc363764ebb3a6d3e7b811a5812532edcac" translate="yes" xml:space="preserve">
          <source>I tested most suggested solutions with &lt;a href=&quot;https://github.com/nschloe/perfplot&quot;&gt;perfplot&lt;/a&gt; (a pet project of mine, essentially a wrapper around &lt;code&gt;timeit&lt;/code&gt;), and found</source>
          <target state="translated">Я протестировал большинство предлагаемых решений с помощью &lt;a href=&quot;https://github.com/nschloe/perfplot&quot;&gt;perfplot&lt;/a&gt; ( мой любимый проект, по сути, обертка вокруг &lt;code&gt;timeit&lt;/code&gt; ), и нашел</target>
        </trans-unit>
        <trans-unit id="876cae1b1c230f0b41d5bbd93d68960bc959b80c" translate="yes" xml:space="preserve">
          <source>I wonder whether there is a shortcut to make a simple list out of list of lists in Python.</source>
          <target state="translated">Интересно,есть ли на Python ярлык для создания простого списка из списков.</target>
        </trans-unit>
        <trans-unit id="61fc8760cdaa2f2e5362a195c732748258b70b96" translate="yes" xml:space="preserve">
          <source>If you are willing to give up a tiny amount of speed for a cleaner look, then you could use &lt;code&gt;numpy.concatenate().tolist()&lt;/code&gt; or &lt;code&gt;numpy.concatenate().ravel().tolist()&lt;/code&gt;:</source>
          <target state="translated">Если вы готовы отдать &lt;code&gt;numpy.concatenate().tolist()&lt;/code&gt; скорости для более чистого вида, то вы можете использовать numpy.concatenate (). Tolist () или &lt;code&gt;numpy.concatenate().ravel().tolist()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f2612465f4102edf2a5792b74f40ea0d29bfb7d8" translate="yes" xml:space="preserve">
          <source>If you want to flatten a data-structure where you don't know how deep it's nested you could use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt;&lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt;&lt;/a&gt;&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">Если вы хотите сгладить структуру данных, в которой вы не знаете, как глубоко она вложена, вы можете использовать &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt; &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; &lt;/a&gt; &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32fee52bb03074fffdc25bdcabef4136af14249f" translate="yes" xml:space="preserve">
          <source>If you're thinking functional, it is as easy as this::</source>
          <target state="translated">Если ты думаешь о функциональности,то это так же просто:..:</target>
        </trans-unit>
        <trans-unit id="d2fa2014fa3a734a25a87e6c0fcd1d6156afb5bd" translate="yes" xml:space="preserve">
          <source>In Python 3, &lt;code&gt;yield from flatten(x)&lt;/code&gt; can replace &lt;code&gt;for sub_x in flatten(x): yield sub_x&lt;/code&gt;</source>
          <target state="translated">В Python 3 &lt;code&gt;yield from flatten(x)&lt;/code&gt; можно заменить &lt;code&gt;for sub_x in flatten(x): yield sub_x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="514f6225a66010f2d4c19d4f65146ac3f7d801d1" translate="yes" xml:space="preserve">
          <source>In Python 3.8, &lt;a href=&quot;https://docs.python.org/3/library/collections.abc.html#module-collections.abc&quot;&gt;abstract base classes&lt;/a&gt; are &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.7.html#id3&quot;&gt;moved&lt;/a&gt; from &lt;code&gt;collection.abc&lt;/code&gt; to the &lt;code&gt;typing&lt;/code&gt; module.</source>
          <target state="translated">В Python 3.8 &lt;a href=&quot;https://docs.python.org/3/library/collections.abc.html#module-collections.abc&quot;&gt;абстрактные базовые классы&lt;/a&gt; &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.7.html#id3&quot;&gt;перемещаются&lt;/a&gt; из &lt;code&gt;collection.abc&lt;/code&gt; в модуль &lt;code&gt;typing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7121c3061e262fdfa84e5a233d466f5601743942" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;obj = [[1, 2,], [3, 4], [5, 6]]&lt;/code&gt;, all of the solutions here are good, including list comprehension and &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;.</source>
          <target state="translated">В случае &lt;code&gt;obj = [[1, 2,], [3, 4], [5, 6]]&lt;/code&gt; все решения здесь хороши, включая понимание списка и &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae463b2138420d7f869146a1a9a4624956753f55" translate="yes" xml:space="preserve">
          <source>It ships with an implementation for &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten&quot;&gt;source&lt;/a&gt;, from the &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools recipes&lt;/a&gt;):</source>
          <target state="translated">Он поставляется с реализацией для &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten&quot;&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten&quot;&gt;источник&lt;/a&gt; по &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;рецептам itertools&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="81faee37aa250627b621e8f54d471969e6c42fdf" translate="yes" xml:space="preserve">
          <source>It solves all flatten problems (none list item or complex nesting)</source>
          <target state="translated">Решает все плоские задачи (ни одного пункта перечня или сложного гнездования).</target>
        </trans-unit>
        <trans-unit id="6f4274e4e265456695c37cb98096f65cdb50b393" translate="yes" xml:space="preserve">
          <source>It's a generator so you need to cast the result to a &lt;code&gt;list&lt;/code&gt; or explicitly iterate over it.</source>
          <target state="translated">Это генератор, поэтому вам нужно привести результат в &lt;code&gt;list&lt;/code&gt; или явно перебрать его.</target>
        </trans-unit>
        <trans-unit id="bab3f440e0cb9b6ef1870545dce67cee5b69549a" translate="yes" xml:space="preserve">
          <source>It's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better.</source>
          <target state="translated">Это участок лога для размещения огромного диапазона значений.Для качественного обоснования:Нижнее лучше.</target>
        </trans-unit>
        <trans-unit id="c4d4f86224ef28956be32e434d9873c524962e30" translate="yes" xml:space="preserve">
          <source>Just to add some timings (based on Nico Schl&amp;ouml;mer answer that didn't include the function presented in this answer):</source>
          <target state="translated">Просто добавим немного времени (на основе ответа Нико Шлёмера, который не включает функцию, представленную в этом ответе):</target>
        </trans-unit>
        <trans-unit id="3be2f60b7d85235e979e45d49f68feac671b94c1" translate="yes" xml:space="preserve">
          <source>New proposed solution that &lt;em&gt;did&lt;/em&gt; work for me:</source>
          <target state="translated">Новое предлагаемое решение, которое сработало для меня:</target>
        </trans-unit>
        <trans-unit id="0ffedc979da9fc4c310ebb5e966b9183d9fbaafe" translate="yes" xml:space="preserve">
          <source>Note that only works on lists of lists. For lists of lists of lists, you'll need another solution.</source>
          <target state="translated">Обратите внимание,что это работает только в списках.Для списков списков вам понадобится другое решение.</target>
        </trans-unit>
        <trans-unit id="da5cc2418e5a4bd3106e3f3ce95f6320daee1110" translate="yes" xml:space="preserve">
          <source>Note: extend is more efficient than + on lists.</source>
          <target state="translated">Примечание:расширение более эффективно,чем+в списках.</target>
        </trans-unit>
        <trans-unit id="c47684635a9abd882bb07dd1af45494e951b55aa" translate="yes" xml:space="preserve">
          <source>One can also use NumPy's &lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html&quot;&gt;flat&lt;/a&gt;:</source>
          <target state="translated">Можно также использовать &lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html&quot;&gt;квартиру&lt;/a&gt; NumPy:</target>
        </trans-unit>
        <trans-unit id="87936a8087e52b4dc48ce96d0bf6a057c81e8ab2" translate="yes" xml:space="preserve">
          <source>One element, &lt;code&gt;'abc'&lt;/code&gt;, &lt;em&gt;is&lt;/em&gt; technically iterable (all &lt;code&gt;str&lt;/code&gt;s are).  However, reading between the lines a bit, you don't want to treat it as such--you want to treat it as a single element.</source>
          <target state="translated">Один элемент, &lt;code&gt;'abc'&lt;/code&gt; , технически повторяем (все строки). Однако, читая немного между строк, вы не хотите рассматривать это как таковой - вы хотите рассматривать это как отдельный элемент.</target>
        </trans-unit>
        <trans-unit id="2906f0e61b652b524e54b5ed7699d5db97c2adeb" translate="yes" xml:space="preserve">
          <source>One element, &lt;code&gt;6&lt;/code&gt;, is just a scalar; it's not iterable, so the above routes will fail here.</source>
          <target state="translated">Один элемент, &lt;code&gt;6&lt;/code&gt; , это просто скаляр; это не повторяется, поэтому приведенные выше маршруты потерпят неудачу.</target>
        </trans-unit>
        <trans-unit id="314acacc9569152fc4da86dd9d5208c370dc9afc" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt;&lt;code&gt;itertools.chain.from_iterable()&lt;/code&gt;&lt;/a&gt; which doesn't require unpacking the list with the &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#tut-unpacking-arguments&quot;&gt;&lt;code&gt;*&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">Или вы можете использовать &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt; &lt;code&gt;itertools.chain.from_iterable()&lt;/code&gt; &lt;/a&gt; который не требует распаковки списка с помощью &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#tut-unpacking-arguments&quot;&gt;оператора &lt;code&gt;*&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="96b676519adbe95ecb795d350dfb60971f7271dc" translate="yes" xml:space="preserve">
          <source>Recursive version</source>
          <target state="translated">Рекурсивная версия</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="24c3fe6c6fdc963c62e2db5221e26b4d3823916f" translate="yes" xml:space="preserve">
          <source>Simple code for &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt;&lt;code&gt;underscore.py&lt;/code&gt;&lt;/a&gt; package fan</source>
          <target state="translated">Простой код для поклонника пакета &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt; &lt;code&gt;underscore.py&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38d4e1b388c4c9a2760e19d334c82a73510265e8" translate="yes" xml:space="preserve">
          <source>Testing:</source>
          <target state="translated">Testing:</target>
        </trans-unit>
        <trans-unit id="8eb26a47b520c5dbbccaf00c5378c80eb2b2e50e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extend()&lt;/code&gt; method in your example modifies &lt;code&gt;x&lt;/code&gt; instead of returning a useful value (which &lt;code&gt;reduce()&lt;/code&gt; expects).</source>
          <target state="translated">Метод &lt;code&gt;extend()&lt;/code&gt; в вашем примере изменяет &lt;code&gt;x&lt;/code&gt; вместо возврата полезного значения (которое ожидает &lt;code&gt;reduce()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="df9a56352fe0182aa9b3497490b49100923fa99c" translate="yes" xml:space="preserve">
          <source>The above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl &lt;code&gt;flist&lt;/code&gt;, like below.</source>
          <target state="translated">Вышеупомянутый создает несколько локальных списков и возвращает их, которые используются для расширения списка родителей. Я думаю, что выходом из этого может быть создание &lt;code&gt;flist&lt;/code&gt; , как показано ниже.</target>
        </trans-unit>
        <trans-unit id="386171513d5c24a58e7ed773e77f34df403522e7" translate="yes" xml:space="preserve">
          <source>The accepted answer did not work for me when dealing with text-based lists of variable lengths. Here is an alternate approach that did work for me.</source>
          <target state="translated">Принятый ответ не сработал для меня при работе с текстовыми списками переменной длины.Вот альтернативный подход,который сработал для меня.</target>
        </trans-unit>
        <trans-unit id="32b0e7cb6d27e016711c8a613c0443164f3ad516" translate="yes" xml:space="preserve">
          <source>The advantage of this solution over most others here is that if you have a list like:</source>
          <target state="translated">Преимущество этого решения перед большинством других здесь заключается в том,что если у вас есть такой список:</target>
        </trans-unit>
        <trans-unit id="6f6eb68ec0de9e7966a150472808fb0be4be2be4" translate="yes" xml:space="preserve">
          <source>The final element, &lt;code&gt;[8, [9, 10]]&lt;/code&gt; is itself a nested iterable.  Basic list comprehension and &lt;code&gt;chain.from_iterable&lt;/code&gt; only extract &quot;1 level down.&quot;</source>
          <target state="translated">Последний элемент, &lt;code&gt;[8, [9, 10]]&lt;/code&gt; сам по себе является вложенным итерируемым. Базовое понимание списка и &lt;code&gt;chain.from_iterable&lt;/code&gt; только извлекают &amp;laquo;1 уровень вниз&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2f8cc82ebeb3c2efcac05855ec9c0cb5bccc63bd" translate="yes" xml:space="preserve">
          <source>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</source>
          <target state="translated">Осмысление списка всего лишь генерирует один список,один раз,и копирует каждый пункт поверх (от его первоначального места жительства до списка результатов)также ровно один раз.</target>
        </trans-unit>
        <trans-unit id="c55395401359835a6e3f32b3f23a39a7f4f78ecc" translate="yes" xml:space="preserve">
          <source>The output is</source>
          <target state="translated">На выходе</target>
        </trans-unit>
        <trans-unit id="e7e78b54dc635e3743925801712ceba59b3f69ff" translate="yes" xml:space="preserve">
          <source>The output is again</source>
          <target state="translated">Выход снова</target>
        </trans-unit>
        <trans-unit id="a57f5af7d243e25c69e05bf8c07fdb2268f7e527" translate="yes" xml:space="preserve">
          <source>The reason your function didn't work is because the &lt;em&gt;extend&lt;/em&gt; extends an array in-place and doesn't return it. You can still return x from lambda, using something like this:</source>
          <target state="translated">Причина, по которой ваша функция не сработала, заключается в том, что &lt;em&gt;расширение&lt;/em&gt; расширяет массив на месте и не возвращает его. Вы все еще можете вернуть x из лямбды, используя что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="fcc503c0e349fbcd95911ec7361823eee8d6907c" translate="yes" xml:space="preserve">
          <source>The results show that if the iterable contains only a few inner iterables then &lt;code&gt;sum&lt;/code&gt; will be fastest, however for long iterables only the &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;, &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; or the nested comprehension have reasonable performance with &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; being the fastest (as already noticed by Nico Schl&amp;ouml;mer).</source>
          <target state="translated">Результаты показывают, что если итерируемое содержит только несколько внутренних итераций, то &lt;code&gt;sum&lt;/code&gt; будет самой быстрой, однако для длинных итераций только &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; , &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; или вложенное понимание имеют разумную производительность, так как &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; является самым быстрым (как уже заметил Нико Шлёмер).</target>
        </trans-unit>
        <trans-unit id="7175c5e62cfcd939bbd4213e3f7c7e95a96b69db" translate="yes" xml:space="preserve">
          <source>The sum version is still running for more than a minute and it hasn't done processing yet!</source>
          <target state="translated">Суммарная версия все еще работает более минуты и еще не закончила обработку!</target>
        </trans-unit>
        <trans-unit id="a4a70ba48ec34522605cf566e94a4806b211eeb3" translate="yes" xml:space="preserve">
          <source>There are several problems here:</source>
          <target state="translated">Здесь есть несколько проблем:</target>
        </trans-unit>
        <trans-unit id="3c67e5d7f089a9f9e7857e3acedcc581dc0f9c42" translate="yes" xml:space="preserve">
          <source>There seems to be a confusion with &lt;code&gt;operator.add&lt;/code&gt;! When you add two lists together, the correct term for that is &lt;code&gt;concat&lt;/code&gt;, not add. &lt;code&gt;operator.concat&lt;/code&gt; is what you need to use.</source>
          <target state="translated">Там, кажется, путаница с &lt;code&gt;operator.add&lt;/code&gt; ! Когда вы добавляете два списка вместе, правильный термин для этого - &lt;code&gt;concat&lt;/code&gt; , а не add. &lt;code&gt;operator.concat&lt;/code&gt; - это то, что вам нужно использовать.</target>
        </trans-unit>
        <trans-unit id="af9f85228d363e1396dd2478ab29159bb2918911" translate="yes" xml:space="preserve">
          <source>This Code also works fine as it just extend the list all the way. Although it is much similar but only have one for loop. So It have less complexity than adding 2 for loops.</source>
          <target state="translated">Этот код также отлично работает,так как он просто расширяет список до конца.Хотя он очень похож,но имеет только один для цикла.Таким образом,он менее сложен,чем добавление 2 для циклов.</target>
        </trans-unit>
        <trans-unit id="e08b5f038b08a8c96efa1f08522f5e66a998d327" translate="yes" xml:space="preserve">
          <source>This is 18x faster than underscore._.flatten:</source>
          <target state="translated">Это в 18 раз быстрее,чем подчеркивание._...сплюснуто:</target>
        </trans-unit>
        <trans-unit id="64c743f00d333be28bff13f8652e1a11252b868f" translate="yes" xml:space="preserve">
          <source>This just sums the elements of iterable passed in the first argument, treating second argument as the initial value of the sum (if not given, &lt;code&gt;0&lt;/code&gt; is used instead and this case will give you an error).</source>
          <target state="translated">Это просто суммирует элементы итерируемого, переданные в первом аргументе, обрабатывая второй аргумент как начальное значение суммы (если не задано, вместо этого используется &lt;code&gt;0&lt;/code&gt; , и в этом случае вы получите ошибку).</target>
        </trans-unit>
        <trans-unit id="22c2c19b3bac52f4b2cf95eeea7c5da16b692799" translate="yes" xml:space="preserve">
          <source>This may not be the most efficient way but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python3.5) and recursion.</source>
          <target state="translated">Возможно,это не самый эффективный способ,но я подумал о том,чтобы поставить однолинейный (на самом деле,двухлинейный).Обе версии будут работать с произвольными вложенными списками иерархий,а также используют возможности языка (Python3.5)и рекурсии.</target>
        </trans-unit>
        <trans-unit id="ab7d5f153551afca8f6c602e4de5f5383356ed3b" translate="yes" xml:space="preserve">
          <source>This should work fine.</source>
          <target state="translated">Это должно сработать.</target>
        </trans-unit>
        <trans-unit id="c8771b06b3b88dac30f258456688e4372fdb7213" translate="yes" xml:space="preserve">
          <source>This solution is modified from a recipe in &lt;em&gt;Beazley, D. and B. Jones.  Recipe 4.14, Python Cookbook 3rd Ed., O'Reilly Media Inc. Sebastopol, CA: 2013.&lt;/em&gt;</source>
          <target state="translated">Это решение модифицировано по рецепту &lt;em&gt;Бизли, Д. и Б. Джонса.&lt;/em&gt; &lt;em&gt;Рецепт 4.14, поваренная книга Python, 3-е издание, O'Reilly Media Inc., Севастополь, Калифорния: 2013.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9bcd7287917139a6af150a5761753b741a5dfa5f" translate="yes" xml:space="preserve">
          <source>This works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable &lt;code&gt;flist&lt;/code&gt; and then rolls back it to the parent. Whenever &lt;code&gt;flist&lt;/code&gt; is returned, it is extended to the parent's &lt;code&gt;flist&lt;/code&gt; in the list comprehension. Therefore, at the root, a flat list is returned.</source>
          <target state="translated">Это работает в глубине в первую очередь. Рекурсия снижается до тех пор, пока не находит элемент не из списка, затем расширяет локальную переменную &lt;code&gt;flist&lt;/code&gt; и затем откатывает его до родителя. Всякий раз, когда возвращается &lt;code&gt;flist&lt;/code&gt; , он распространяется на &lt;code&gt;flist&lt;/code&gt; родителя в понимании списка. Поэтому в корне возвращается плоский список.</target>
        </trans-unit>
        <trans-unit id="59ed80852db6ea428cf54dd89710beabb15d36d1" translate="yes" xml:space="preserve">
          <source>To flatten only one level and if each of the items is itself iterable you can also use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html&quot;&gt;&lt;code&gt;iteration_utilities.flatten&lt;/code&gt;&lt;/a&gt; which itself is just a thin wrapper around &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt;&lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы сгладить только один уровень, и если каждый из элементов сам по себе является итеративным, вы также можете использовать &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html&quot;&gt; &lt;code&gt;iteration_utilities.flatten&lt;/code&gt; ,&lt;/a&gt; который сам по себе является просто тонкой оболочкой для &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt; &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d85e040c6b2316333bbc8b6ece8ebd109dcad5c6" translate="yes" xml:space="preserve">
          <source>Using small lists and timeit: number=1000000</source>
          <target state="translated">Использование небольших списков и времени:номер=1000000</target>
        </trans-unit>
        <trans-unit id="8b777156d7db14dbefaad623bb79535a459684ae" translate="yes" xml:space="preserve">
          <source>Why do you use extend?</source>
          <target state="translated">Почему ты пользуешься продлением?</target>
        </trans-unit>
        <trans-unit id="026239782349d9cccf8cae513c88ec70bc6f77a6" translate="yes" xml:space="preserve">
          <source>You can find out more here in the docs &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html&quot;&gt;numpy.concatenate&lt;/a&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html&quot;&gt;numpy.ravel&lt;/a&gt;</source>
          <target state="translated">Вы можете узнать больше здесь в документах &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html&quot;&gt;numpy.concatenate&lt;/a&gt; и &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html&quot;&gt;numpy.ravel&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98f00c4375c36821b12502ea83723a702fb0edfd" translate="yes" xml:space="preserve">
          <source>You can install &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt;&lt;code&gt;underscore.py&lt;/code&gt;&lt;/a&gt; with pip</source>
          <target state="translated">Вы можете установить &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt; &lt;code&gt;underscore.py&lt;/code&gt; &lt;/a&gt; с помощью pip</target>
        </trans-unit>
        <trans-unit id="4e3f2e4eb4b0b94b2d85fa9b562339a3ec7bc93b" translate="yes" xml:space="preserve">
          <source>You can remedy this as follows:</source>
          <target state="translated">Вы можете исправить это следующим образом:</target>
        </trans-unit>
        <trans-unit id="b69cc7e24723fc0ad7c514ca643eccd680bfbd54" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain&quot;&gt;&lt;code&gt;itertools.chain()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain&quot;&gt; &lt;code&gt;itertools.chain()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ae1549c83cb4c81622f3b6d9fed8b362916b2245" translate="yes" xml:space="preserve">
          <source>You can use numpy :</source>
          <target state="translated">Вы можете использовать онемелый :</target>
        </trans-unit>
        <trans-unit id="ac9b642dd33f13b33118da8230b6f694c73801a1" translate="yes" xml:space="preserve">
          <source>You see reduce respects the sequence type, so when you supply a tuple, you get back a tuple. Let's try with a list::</source>
          <target state="translated">Вы видите уменьшение уважения к типу последовательности,поэтому,когда вы поставляете кортеж,вы получаете кортеж обратно.Давайте попробуем со списком::</target>
        </trans-unit>
        <trans-unit id="2fae8325874681cc6b334b37cba1a121bd8cfad9" translate="yes" xml:space="preserve">
          <source>another fun way to do this:</source>
          <target state="translated">еще один забавный способ сделать это:</target>
        </trans-unit>
        <trans-unit id="9909ec7f3a3afabe82abee395540624cbdaad7c1" translate="yes" xml:space="preserve">
          <source>is faster than the shortcuts posted so far. (&lt;code&gt;l&lt;/code&gt; is the list to flatten.)</source>
          <target state="translated">быстрее, чем ярлыки, опубликованные до сих пор. ( &lt;code&gt;l&lt;/code&gt; - список, чтобы сгладить.)</target>
        </trans-unit>
        <trans-unit id="abfaa5b8f36540158b4c83a8c2ff8def85ec64e0" translate="yes" xml:space="preserve">
          <source>to be the fastest solution. (&lt;code&gt;operator.iadd&lt;/code&gt; is equally fast.)</source>
          <target state="translated">быть самым быстрым решением. ( &lt;code&gt;operator.iadd&lt;/code&gt; одинаково быстр.)</target>
        </trans-unit>
        <trans-unit id="3d6b372a9c60b40127154403945e3da65b17a4cf" translate="yes" xml:space="preserve">
          <source>which means:</source>
          <target state="translated">а это значит:</target>
        </trans-unit>
        <trans-unit id="8a81fcda00582e8515550fb41988323475038a58" translate="yes" xml:space="preserve">
          <source>while most other solutions throw an error this solution handles them.</source>
          <target state="translated">в то время как большинство других решений бросают ошибку,с которой это решение справляется.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
