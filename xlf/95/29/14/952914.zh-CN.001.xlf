<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/952914">
    <body>
      <group id="952914">
        <trans-unit id="c7212e4ddbfbd11031c6226c57bdfe67288fb392" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Itertools&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Itertools&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="c38e822746feba1c5a49dc07f0faa24c4c4931b8" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Matplotlib&lt;/strong&gt;</source>
          <target state="translated">...&lt;strong&gt;Matplotlib&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9613459c01cb7031c63f21aeb1fc59b70025f78" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Pandas&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Pandas&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="77820f7ceaf27b513827583c0595b5674e49df57" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Setuptools&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Setuptools&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="96580150ba876eb18a7f55a60d0871b389dcdfb9" translate="yes" xml:space="preserve">
          <source>...&lt;strong&gt;Unipath&lt;/strong&gt;:</source>
          <target state="translated">...&lt;strong&gt;Unipath&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b988115e6086e3dfbfef73ed6a51772ebb57d0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_iterable&lt;/code&gt; is pretty fast! But it's no comparison to reduce with &lt;code&gt;concat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;from_iterable&lt;/code&gt; 非常快！ 但这并不能与 &lt;code&gt;concat&lt;/code&gt; 相提并论 。</target>
        </trans-unit>
        <trans-unit id="22e0147f3766b1297fd754cae27ffd20940d80d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matplotlib.cbook.flatten()&lt;/code&gt; will work for nested lists even if they nest more deeply than the example.</source>
          <target state="translated">&lt;code&gt;matplotlib.cbook.flatten()&lt;/code&gt; 将适用于嵌套列表，即使它们嵌套得比示例更深。</target>
        </trans-unit>
        <trans-unit id="f05a79f3c1b6d531b3afef5719fd794bc8e796c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Notes&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Notes&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a79903480a5608a4282c3838d1bbe7ef700e434b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Demo&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Demo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="630494acded75e86cdf6b39a97d60ee31ec53223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Error message&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;错误信息&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5cca58a8ac381d444b393a0c564994acbbba4985" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I take my statement back. sum is not the winner. Although it is faster when the list is small. But the performance degrades significantly with larger lists.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我收回我的声明。&lt;/strong&gt; &lt;strong&gt;总和不是赢家。&lt;/strong&gt; &lt;strong&gt;尽管列表较小时速度更快。&lt;/strong&gt; &lt;strong&gt;但是，列表较大时，性能会大大降低。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cb834ff6376acff7370669f5a5e4c75c94f3e3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note from the author&lt;/strong&gt;: This is inefficient. But fun, because &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science&quot;&gt;monoids&lt;/a&gt; are awesome. It's not appropriate for production Python code.</source>
          <target state="translated">&lt;strong&gt;作者注&lt;/strong&gt; ：这是低效的。 但是很有趣，因为类&lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science&quot;&gt;人猿&lt;/a&gt;很棒。 它不适用于生产Python代码。</target>
        </trans-unit>
        <trans-unit id="ed88dbceadb4943205fcb5801aa28bda02f9d380" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Below applies to Python 3.3+ because it uses &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html&quot;&gt;&lt;code&gt;yield_from&lt;/code&gt;&lt;/a&gt;.  &lt;code&gt;six&lt;/code&gt; is also a third-party package, though it is stable.  Alternately, you could use &lt;code&gt;sys.version&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：以下内容适用于Python 3.3+，因为它使用&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html&quot;&gt; &lt;code&gt;yield_from&lt;/code&gt; &lt;/a&gt; 。 &lt;code&gt;six&lt;/code&gt; 也是第三方软件包，尽管它很稳定。 或者，您可以使用 &lt;code&gt;sys.version&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2a6eb120ac5d954b7aa47baca4f35f487d47fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd4fbdf13dfb7b34fb1cfad02cbbdb2cd557e3bb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 Disclaimer: I'm the author of that library&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1免责声明：我是该图书馆的作者&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fd92c55b0dc16e777e3a8b2fef34d2eb8a6d0d79" translate="yes" xml:space="preserve">
          <source>A faster way to do the &lt;code&gt;reduce&lt;/code&gt; version would be</source>
          <target state="translated">做 &lt;code&gt;reduce&lt;/code&gt; 版本的更快方法是</target>
        </trans-unit>
        <trans-unit id="644e0cd0e37d239b0db451be1ed40f528a62e4aa" translate="yes" xml:space="preserve">
          <source>Accepted answer that did &lt;em&gt;not&lt;/em&gt; work:</source>
          <target state="translated">接受的答案&lt;em&gt;无效&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="92d8769801fabd6702c5789616d5242fc7543178" translate="yes" xml:space="preserve">
          <source>Aha, you get back a list.</source>
          <target state="translated">啊哈,你拿回一张名单。</target>
        </trans-unit>
        <trans-unit id="4967535c662745c7a48ab240736eb2afb1b8188c" translate="yes" xml:space="preserve">
          <source>Although I am not sure at this time about the efficiency.</source>
          <target state="translated">虽然我现在还不确定效率如何。</target>
        </trans-unit>
        <trans-unit id="33c231558a50c479e065510258c34b8fabc3215b" translate="yes" xml:space="preserve">
          <source>An bad feature of Anil's function above is that it requires the user to always manually specify the second argument to be an empty list &lt;code&gt;[]&lt;/code&gt;. This should instead be a default. Due to the way Python objects work, these should be set inside the function, not in the arguments.</source>
          <target state="translated">上面的Anil函数的一个坏功能是，它要求用户始终手动将第二个参数指定为空列表 &lt;code&gt;[]&lt;/code&gt; 。 相反，这应该是默认设置。 由于Python对象的工作方式，应在函数内部而不是参数中设置这些对象。</target>
        </trans-unit>
        <trans-unit id="fe8d80125b2f737fe3af135678ddabde16aa4257" translate="yes" xml:space="preserve">
          <source>As evidence, you can use the &lt;code&gt;timeit&lt;/code&gt; module in the standard library:</source>
          <target state="translated">作为证明，您可以使用标准库中的 &lt;code&gt;timeit&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="78f39cdb91c380ac04df841707c9330ce5e0f8b6" translate="yes" xml:space="preserve">
          <source>As of version 2.4, you can flatten more complicated, nested iterables with &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse&quot;&gt;&lt;code&gt;more_itertools.collapse&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse&quot;&gt;source&lt;/a&gt;, contributed by  abarnet).</source>
          <target state="translated">从2.4版开始，您可以使用&lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse&quot;&gt; &lt;code&gt;more_itertools.collapse&lt;/code&gt; &lt;/a&gt; （ &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse&quot;&gt;源代码&lt;/a&gt; ，由abarnet提供）来展平更复杂，嵌套的可迭代对象。</target>
        </trans-unit>
        <trans-unit id="53e4fb8ef7602d42af84e5483a79fac166b0b7ab" translate="yes" xml:space="preserve">
          <source>Because you are summing nested lists, you actually get &lt;code&gt;[1,3]+[2,4]&lt;/code&gt; as a result of &lt;code&gt;sum([[1,3],[2,4]],[])&lt;/code&gt;, which is equal to &lt;code&gt;[1,3,2,4]&lt;/code&gt;.</source>
          <target state="translated">因为您正在对嵌套列表求和，所以实际上，由于 &lt;code&gt;sum([[1,3],[2,4]],[])&lt;/code&gt; 等于[[]，因此得到 &lt;code&gt;[1,3]+[2,4]&lt;/code&gt; &lt;code&gt;[1,3,2,4]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7695cefcf2d60f8c75926b4ba0826457404530c6" translate="yes" xml:space="preserve">
          <source>Code to reproduce the plot:</source>
          <target state="translated">重现情节的代码。</target>
        </trans-unit>
        <trans-unit id="a616585bfa18713708d4a3a2bc94f44cc9664c38" translate="yes" xml:space="preserve">
          <source>Consider installing the &lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">考虑安装&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt; &lt;code&gt;more_itertools&lt;/code&gt; &lt;/a&gt;软件包。</target>
        </trans-unit>
        <trans-unit id="ba07a235a25c22c3ececc91a67add93d936aada4" translate="yes" xml:space="preserve">
          <source>Don't reinvent the wheel if you use &lt;strong&gt;Django&lt;/strong&gt;:</source>
          <target state="translated">如果您使用&lt;strong&gt;Django，请&lt;/strong&gt;不要重新发明轮子：</target>
        </trans-unit>
        <trans-unit id="5ca515ce5ebb9fbc9ca9e3d43452c4f363e26fd5" translate="yes" xml:space="preserve">
          <source>Done! You can of course turn it back into a list by executing list(l)</source>
          <target state="translated">完成了! 当然,你可以通过执行list(l)把它转回列表,把它变成一个列表</target>
        </trans-unit>
        <trans-unit id="2ac185dfc986222e4ecce9e1d5b072f8e68479ca" translate="yes" xml:space="preserve">
          <source>Edit 11/02/2016: Only works when sublists have identical dimensions.</source>
          <target state="translated">编辑11022016。只有当子列表的维度相同时才有效。</target>
        </trans-unit>
        <trans-unit id="39c3e010a815528bd9b4496919045b2af64aec1c" translate="yes" xml:space="preserve">
          <source>Explanation: the shortcuts based on &lt;code&gt;+&lt;/code&gt; (including the implied use in &lt;code&gt;sum&lt;/code&gt;) are, of necessity, &lt;code&gt;O(L**2)&lt;/code&gt; when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of I items each: the first I items are copied back and forth L-1 times, the second I items L-2 times, and so on; total number of copies is I times the sum of x for x from 1 to L excluded, i.e., &lt;code&gt;I * (L**2)/2&lt;/code&gt;.</source>
          <target state="translated">说明：当存在L个子列表时，基于 &lt;code&gt;+&lt;/code&gt; 的快捷方式（包括 &lt;code&gt;sum&lt;/code&gt; 的隐含使用）必然为 &lt;code&gt;O(L**2)&lt;/code&gt; －由于中间结果列表越来越长，因此每一步都有一个新的中间结果将分配list对象，并且必须复制上一个中间结果中的所有项目（以及最后添加的一些新项目）。 因此，为简单起见，并且不失去一般性，请说您每个都有I个项目的L个子列表：第一个I项目来回复制L-1次，第二个I项目L-2次，依此类推；等等。 总拷贝数是I乘以x的x的总和（从1到L），即 &lt;code&gt;I * (L**2)/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55df575d9380e8cbd705dfa5f7d604bb01331885" translate="yes" xml:space="preserve">
          <source>Fastest solution I have found (for large list anyway):</source>
          <target state="translated">我所找到的最快速的解决方案(反正是针对大名单)。</target>
        </trans-unit>
        <trans-unit id="830686325b823bed7b23d54cb0487a311cd10a29" translate="yes" xml:space="preserve">
          <source>Following seem simplest to me:</source>
          <target state="translated">在我看来最简单的是:</target>
        </trans-unit>
        <trans-unit id="81386a63f543dc89fc6a29418e00a411645173eb" translate="yes" xml:space="preserve">
          <source>For medium lists:</source>
          <target state="translated">对于中单:</target>
        </trans-unit>
        <trans-unit id="de8d08f3dc9af8f5773bf1fec37d4c6b20244b54" translate="yes" xml:space="preserve">
          <source>Found an earlier &lt;a href=&quot;https://stackoverflow.com/a/2158532/4531270&quot;&gt;SO post&lt;/a&gt;, possibly the original demonstration.</source>
          <target state="translated">找到了较早的&lt;a href=&quot;https://stackoverflow.com/a/2158532/4531270&quot;&gt;SO帖子&lt;/a&gt; ，可能是原始的演示。</target>
        </trans-unit>
        <trans-unit id="a296481527c15a34f5cdbc79f43470f0a233779e" translate="yes" xml:space="preserve">
          <source>Given a list of lists &lt;code&gt;l&lt;/code&gt;,</source>
          <target state="translated">给定一个列表 &lt;code&gt;l&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="cfb0572cc3b39652a46f7d9b229a8f0c97c6a0e8" translate="yes" xml:space="preserve">
          <source>Here is a general approach that applies to &lt;strong&gt;numbers&lt;/strong&gt;, &lt;strong&gt;strings&lt;/strong&gt;, &lt;strong&gt;nested&lt;/strong&gt; lists and &lt;strong&gt;mixed&lt;/strong&gt; containers.</source>
          <target state="translated">这是适用于&lt;strong&gt;数字&lt;/strong&gt; ， &lt;strong&gt;字符串&lt;/strong&gt; ， &lt;strong&gt;嵌套&lt;/strong&gt;列表和&lt;strong&gt;混合&lt;/strong&gt;容器的通用方法。</target>
        </trans-unit>
        <trans-unit id="90277c92aa2ef531d4bb81d661f56bc4a3bae36b" translate="yes" xml:space="preserve">
          <source>Here is the corresponding function:</source>
          <target state="translated">下面是相应的功能。</target>
        </trans-unit>
        <trans-unit id="65dbecec5681faac4b7b7628e864c5f2b770a52e" translate="yes" xml:space="preserve">
          <source>Here's a working function:</source>
          <target state="translated">这里有一个工作功能。</target>
        </trans-unit>
        <trans-unit id="b599b1f61b5e7a90940ef61c51226edfdd3dc1c2" translate="yes" xml:space="preserve">
          <source>Here, you check that the sub-element (1) is iterable with &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;, an ABC from &lt;code&gt;itertools&lt;/code&gt;, but also want to ensure that (2) the element is &lt;em&gt;not&lt;/em&gt; &quot;string-like.&quot;</source>
          <target state="translated">在这里，您要检查子元素（1）是否可以使用&lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;的ABC Iterable进行迭代，但还要确保（2）元素&lt;em&gt;不是&lt;/em&gt; &amp;ldquo;字符串状&amp;rdquo;的。</target>
        </trans-unit>
        <trans-unit id="47f8c1be878ff256bd61a349c03652d7ed848da2" translate="yes" xml:space="preserve">
          <source>How about performance::</source>
          <target state="translated">性能如何:。</target>
        </trans-unit>
        <trans-unit id="6202fef82862d98b07042e913d0ce2707782c6ba" translate="yes" xml:space="preserve">
          <source>How to make a flat list out of list of lists</source>
          <target state="translated">如何将清单中的清单制作成平面清单</target>
        </trans-unit>
        <trans-unit id="99f29d6ec76cfea7c1780d30f2c4f113f892e19c" translate="yes" xml:space="preserve">
          <source>However, consider this slightly more complex case:</source>
          <target state="translated">然而,考虑这个略显复杂的案例。</target>
        </trans-unit>
        <trans-unit id="5933bc989310515ebc4ee439fbe83965e3f8a5a6" translate="yes" xml:space="preserve">
          <source>I can do that in a &lt;code&gt;for&lt;/code&gt; loop, but maybe there is some cool &quot;one-liner&quot;? I tried it with &lt;code&gt;reduce()&lt;/code&gt;, but I get an error.</source>
          <target state="translated">我可以在 &lt;code&gt;for&lt;/code&gt; 循环中执行此操作，但也许有一些很酷的&amp;ldquo;单行代码&amp;rdquo;？ 我尝试用 &lt;code&gt;reduce()&lt;/code&gt; ，但是出现错误。</target>
        </trans-unit>
        <trans-unit id="ba03edc363764ebb3a6d3e7b811a5812532edcac" translate="yes" xml:space="preserve">
          <source>I tested most suggested solutions with &lt;a href=&quot;https://github.com/nschloe/perfplot&quot;&gt;perfplot&lt;/a&gt; (a pet project of mine, essentially a wrapper around &lt;code&gt;timeit&lt;/code&gt;), and found</source>
          <target state="translated">我用&lt;a href=&quot;https://github.com/nschloe/perfplot&quot;&gt;perfplot&lt;/a&gt; （我的一个宠物项目，本质上是 &lt;code&gt;timeit&lt;/code&gt; 的包装器）测试了大多数建议的解决方案，然后发现</target>
        </trans-unit>
        <trans-unit id="876cae1b1c230f0b41d5bbd93d68960bc959b80c" translate="yes" xml:space="preserve">
          <source>I wonder whether there is a shortcut to make a simple list out of list of lists in Python.</source>
          <target state="translated">不知道有没有一个捷径,可以用Python中的列表制作出一个简单的列表。</target>
        </trans-unit>
        <trans-unit id="61fc8760cdaa2f2e5362a195c732748258b70b96" translate="yes" xml:space="preserve">
          <source>If you are willing to give up a tiny amount of speed for a cleaner look, then you could use &lt;code&gt;numpy.concatenate().tolist()&lt;/code&gt; or &lt;code&gt;numpy.concatenate().ravel().tolist()&lt;/code&gt;:</source>
          <target state="translated">如果您愿意放弃一点速度以获得更干净的外观，则可以使用 &lt;code&gt;numpy.concatenate().tolist()&lt;/code&gt; 或 &lt;code&gt;numpy.concatenate().ravel().tolist()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f2612465f4102edf2a5792b74f40ea0d29bfb7d8" translate="yes" xml:space="preserve">
          <source>If you want to flatten a data-structure where you don't know how deep it's nested you could use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt;&lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt;&lt;/a&gt;&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">如果要在不知道嵌套深度的情况下展平数据结构，则可以使用&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt; &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; &lt;/a&gt; &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32fee52bb03074fffdc25bdcabef4136af14249f" translate="yes" xml:space="preserve">
          <source>If you're thinking functional, it is as easy as this::</source>
          <target state="translated">如果你想的是功能性的,就像这样简单:。</target>
        </trans-unit>
        <trans-unit id="d2fa2014fa3a734a25a87e6c0fcd1d6156afb5bd" translate="yes" xml:space="preserve">
          <source>In Python 3, &lt;code&gt;yield from flatten(x)&lt;/code&gt; can replace &lt;code&gt;for sub_x in flatten(x): yield sub_x&lt;/code&gt;</source>
          <target state="translated">在Python 3中， &lt;code&gt;yield from flatten(x)&lt;/code&gt; 可以替换 &lt;code&gt;for sub_x in flatten(x): yield sub_x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="514f6225a66010f2d4c19d4f65146ac3f7d801d1" translate="yes" xml:space="preserve">
          <source>In Python 3.8, &lt;a href=&quot;https://docs.python.org/3/library/collections.abc.html#module-collections.abc&quot;&gt;abstract base classes&lt;/a&gt; are &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.7.html#id3&quot;&gt;moved&lt;/a&gt; from &lt;code&gt;collection.abc&lt;/code&gt; to the &lt;code&gt;typing&lt;/code&gt; module.</source>
          <target state="translated">在Python 3.8中， &lt;a href=&quot;https://docs.python.org/3/library/collections.abc.html#module-collections.abc&quot;&gt;抽象基类&lt;/a&gt;从 &lt;code&gt;collection.abc&lt;/code&gt; 移至 &lt;code&gt;typing&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="7121c3061e262fdfa84e5a233d466f5601743942" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;obj = [[1, 2,], [3, 4], [5, 6]]&lt;/code&gt;, all of the solutions here are good, including list comprehension and &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;obj = [[1, 2,], [3, 4], [5, 6]]&lt;/code&gt; ，这里的所有解决方案都是好的，包括列表理解和 &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae463b2138420d7f869146a1a9a4624956753f55" translate="yes" xml:space="preserve">
          <source>It ships with an implementation for &lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten&quot;&gt;source&lt;/a&gt;, from the &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools recipes&lt;/a&gt;):</source>
          <target state="translated">它附带一个用于&lt;a href=&quot;https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten&quot;&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;/a&gt;的实现（ &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten&quot;&gt;source&lt;/a&gt; ，来自&lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools-recipes&quot;&gt;itertools配方&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="81faee37aa250627b621e8f54d471969e6c42fdf" translate="yes" xml:space="preserve">
          <source>It solves all flatten problems (none list item or complex nesting)</source>
          <target state="translated">它解决了所有扁平化问题(无列表项或复杂嵌套)。</target>
        </trans-unit>
        <trans-unit id="6f4274e4e265456695c37cb98096f65cdb50b393" translate="yes" xml:space="preserve">
          <source>It's a generator so you need to cast the result to a &lt;code&gt;list&lt;/code&gt; or explicitly iterate over it.</source>
          <target state="translated">它是一个生成器，因此您需要将结果强制转换为 &lt;code&gt;list&lt;/code&gt; 或对其进行显式迭代。</target>
        </trans-unit>
        <trans-unit id="bab3f440e0cb9b6ef1870545dce67cee5b69549a" translate="yes" xml:space="preserve">
          <source>It's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better.</source>
          <target state="translated">这是一个对数-log图,以适应跨度巨大的数值范围。对于定性推理来说。越低越好。</target>
        </trans-unit>
        <trans-unit id="c4d4f86224ef28956be32e434d9873c524962e30" translate="yes" xml:space="preserve">
          <source>Just to add some timings (based on Nico Schl&amp;ouml;mer answer that didn't include the function presented in this answer):</source>
          <target state="translated">只是添加一些时间（基于NicoSchl&amp;ouml;mer的答案，其中不包括此答案中提供的功能）：</target>
        </trans-unit>
        <trans-unit id="3be2f60b7d85235e979e45d49f68feac671b94c1" translate="yes" xml:space="preserve">
          <source>New proposed solution that &lt;em&gt;did&lt;/em&gt; work for me:</source>
          <target state="translated">对我&lt;em&gt;有用的&lt;/em&gt;新提议解决方案：</target>
        </trans-unit>
        <trans-unit id="0ffedc979da9fc4c310ebb5e966b9183d9fbaafe" translate="yes" xml:space="preserve">
          <source>Note that only works on lists of lists. For lists of lists of lists, you'll need another solution.</source>
          <target state="translated">注意,这只适用于列表的列表。对于列表列表的列表,你需要另外的解决方案。</target>
        </trans-unit>
        <trans-unit id="da5cc2418e5a4bd3106e3f3ce95f6320daee1110" translate="yes" xml:space="preserve">
          <source>Note: extend is more efficient than + on lists.</source>
          <target state="translated">注:扩展比列表上的+更有效。</target>
        </trans-unit>
        <trans-unit id="c47684635a9abd882bb07dd1af45494e951b55aa" translate="yes" xml:space="preserve">
          <source>One can also use NumPy's &lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html&quot;&gt;flat&lt;/a&gt;:</source>
          <target state="translated">也可以使用NumPy的&lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html&quot;&gt;flat&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="87936a8087e52b4dc48ce96d0bf6a057c81e8ab2" translate="yes" xml:space="preserve">
          <source>One element, &lt;code&gt;'abc'&lt;/code&gt;, &lt;em&gt;is&lt;/em&gt; technically iterable (all &lt;code&gt;str&lt;/code&gt;s are).  However, reading between the lines a bit, you don't want to treat it as such--you want to treat it as a single element.</source>
          <target state="translated">一个元素 &lt;code&gt;'abc'&lt;/code&gt; &lt;em&gt;在&lt;/em&gt;技术上&lt;em&gt;是&lt;/em&gt;可迭代的（所有 &lt;code&gt;str&lt;/code&gt; 都是）。 但是，在行与行之间进行一点阅读时，您并不想这样处理-您希望将其视为单个元素。</target>
        </trans-unit>
        <trans-unit id="2906f0e61b652b524e54b5ed7699d5db97c2adeb" translate="yes" xml:space="preserve">
          <source>One element, &lt;code&gt;6&lt;/code&gt;, is just a scalar; it's not iterable, so the above routes will fail here.</source>
          <target state="translated">一个元素 &lt;code&gt;6&lt;/code&gt; 只是一个标量； 它是不可迭代的，因此上述路由将在此处失败。</target>
        </trans-unit>
        <trans-unit id="314acacc9569152fc4da86dd9d5208c370dc9afc" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt;&lt;code&gt;itertools.chain.from_iterable()&lt;/code&gt;&lt;/a&gt; which doesn't require unpacking the list with the &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#tut-unpacking-arguments&quot;&gt;&lt;code&gt;*&lt;/code&gt; operator&lt;/a&gt;:</source>
          <target state="translated">或者，您可以使用&lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt; &lt;code&gt;itertools.chain.from_iterable()&lt;/code&gt; &lt;/a&gt; ，而无需使用&lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#tut-unpacking-arguments&quot;&gt; &lt;code&gt;*&lt;/code&gt; 运算符&lt;/a&gt;将列表拆包：</target>
        </trans-unit>
        <trans-unit id="96b676519adbe95ecb795d350dfb60971f7271dc" translate="yes" xml:space="preserve">
          <source>Recursive version</source>
          <target state="translated">递归版本</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="24c3fe6c6fdc963c62e2db5221e26b4d3823916f" translate="yes" xml:space="preserve">
          <source>Simple code for &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt;&lt;code&gt;underscore.py&lt;/code&gt;&lt;/a&gt; package fan</source>
          <target state="translated">&lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt; &lt;code&gt;underscore.py&lt;/code&gt; &lt;/a&gt;包迷的简单代码</target>
        </trans-unit>
        <trans-unit id="38d4e1b388c4c9a2760e19d334c82a73510265e8" translate="yes" xml:space="preserve">
          <source>Testing:</source>
          <target state="translated">Testing:</target>
        </trans-unit>
        <trans-unit id="8eb26a47b520c5dbbccaf00c5378c80eb2b2e50e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extend()&lt;/code&gt; method in your example modifies &lt;code&gt;x&lt;/code&gt; instead of returning a useful value (which &lt;code&gt;reduce()&lt;/code&gt; expects).</source>
          <target state="translated">您的示例中的 &lt;code&gt;extend()&lt;/code&gt; 方法修改 &lt;code&gt;x&lt;/code&gt; 而不是返回有用的值（ &lt;code&gt;reduce()&lt;/code&gt; 期望）。</target>
        </trans-unit>
        <trans-unit id="df9a56352fe0182aa9b3497490b49100923fa99c" translate="yes" xml:space="preserve">
          <source>The above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl &lt;code&gt;flist&lt;/code&gt;, like below.</source>
          <target state="translated">上面的代码创建了几个本地列表并返回它们，这些列表用于扩展父级列表。 我认为解决此问题的方法可能是创建一个全球性的列表，如下所示。</target>
        </trans-unit>
        <trans-unit id="386171513d5c24a58e7ed773e77f34df403522e7" translate="yes" xml:space="preserve">
          <source>The accepted answer did not work for me when dealing with text-based lists of variable lengths. Here is an alternate approach that did work for me.</source>
          <target state="translated">在处理基于文本的可变长度的列表时,接受的答案对我来说不起作用。下面是另一种对我来说确实有效的方法。</target>
        </trans-unit>
        <trans-unit id="32b0e7cb6d27e016711c8a613c0443164f3ad516" translate="yes" xml:space="preserve">
          <source>The advantage of this solution over most others here is that if you have a list like:</source>
          <target state="translated">与这里的大多数其他方案相比,这个方案的优势在于,如果你有一个类似的名单。</target>
        </trans-unit>
        <trans-unit id="6f6eb68ec0de9e7966a150472808fb0be4be2be4" translate="yes" xml:space="preserve">
          <source>The final element, &lt;code&gt;[8, [9, 10]]&lt;/code&gt; is itself a nested iterable.  Basic list comprehension and &lt;code&gt;chain.from_iterable&lt;/code&gt; only extract &quot;1 level down.&quot;</source>
          <target state="translated">最后一个元素 &lt;code&gt;[8, [9, 10]]&lt;/code&gt; 本身是嵌套的可迭代对象。 基本列表理解和 &lt;code&gt;chain.from_iterable&lt;/code&gt; 仅提取&amp;ldquo;下一级&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2f8cc82ebeb3c2efcac05855ec9c0cb5bccc63bd" translate="yes" xml:space="preserve">
          <source>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</source>
          <target state="translated">列表理解只生成一个列表,一次,并将每个项目复制过来(从原来的居住地复制到结果列表中)。</target>
        </trans-unit>
        <trans-unit id="c55395401359835a6e3f32b3f23a39a7f4f78ecc" translate="yes" xml:space="preserve">
          <source>The output is</source>
          <target state="translated">输出是</target>
        </trans-unit>
        <trans-unit id="e7e78b54dc635e3743925801712ceba59b3f69ff" translate="yes" xml:space="preserve">
          <source>The output is again</source>
          <target state="translated">输出又是</target>
        </trans-unit>
        <trans-unit id="a57f5af7d243e25c69e05bf8c07fdb2268f7e527" translate="yes" xml:space="preserve">
          <source>The reason your function didn't work is because the &lt;em&gt;extend&lt;/em&gt; extends an array in-place and doesn't return it. You can still return x from lambda, using something like this:</source>
          <target state="translated">您的函数不起作用的原因是因为&lt;em&gt;扩展名&lt;/em&gt;扩展了数组就位并且不返回它。 您仍然可以使用以下方法从lambda返回x：</target>
        </trans-unit>
        <trans-unit id="fcc503c0e349fbcd95911ec7361823eee8d6907c" translate="yes" xml:space="preserve">
          <source>The results show that if the iterable contains only a few inner iterables then &lt;code&gt;sum&lt;/code&gt; will be fastest, however for long iterables only the &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;, &lt;code&gt;iteration_utilities.deepflatten&lt;/code&gt; or the nested comprehension have reasonable performance with &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; being the fastest (as already noticed by Nico Schl&amp;ouml;mer).</source>
          <target state="translated">结果表明，如果可迭代对象仅包含几个内部可迭代对象，则 &lt;code&gt;sum&lt;/code&gt; 最快，但是对于长的可迭代对象，只有 &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; ， eration_utilities.deepflatten或嵌套的理解具有最快的 &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; 性能。 （正如NicoSchl&amp;ouml;mer所注意到的那样）。</target>
        </trans-unit>
        <trans-unit id="7175c5e62cfcd939bbd4213e3f7c7e95a96b69db" translate="yes" xml:space="preserve">
          <source>The sum version is still running for more than a minute and it hasn't done processing yet!</source>
          <target state="translated">和值版还在运行1分多钟,还没做处理呢!</target>
        </trans-unit>
        <trans-unit id="a4a70ba48ec34522605cf566e94a4806b211eeb3" translate="yes" xml:space="preserve">
          <source>There are several problems here:</source>
          <target state="translated">这里有几个问题。</target>
        </trans-unit>
        <trans-unit id="3c67e5d7f089a9f9e7857e3acedcc581dc0f9c42" translate="yes" xml:space="preserve">
          <source>There seems to be a confusion with &lt;code&gt;operator.add&lt;/code&gt;! When you add two lists together, the correct term for that is &lt;code&gt;concat&lt;/code&gt;, not add. &lt;code&gt;operator.concat&lt;/code&gt; is what you need to use.</source>
          <target state="translated">似乎与 &lt;code&gt;operator.add&lt;/code&gt; 混淆了！ 将两个列表加在一起时，正确的术语是 &lt;code&gt;concat&lt;/code&gt; ，而不是add。 &lt;code&gt;operator.concat&lt;/code&gt; 是您需要使用的。</target>
        </trans-unit>
        <trans-unit id="af9f85228d363e1396dd2478ab29159bb2918911" translate="yes" xml:space="preserve">
          <source>This Code also works fine as it just extend the list all the way. Although it is much similar but only have one for loop. So It have less complexity than adding 2 for loops.</source>
          <target state="translated">这个代码也很好用,因为它只是将列表全部扩展。虽然它很相似,但只有一个for循环。所以它的复杂性比添加2个for循环要低。</target>
        </trans-unit>
        <trans-unit id="e08b5f038b08a8c96efa1f08522f5e66a998d327" translate="yes" xml:space="preserve">
          <source>This is 18x faster than underscore._.flatten:</source>
          <target state="translated">这比下划线快18倍,_.扁平化。</target>
        </trans-unit>
        <trans-unit id="64c743f00d333be28bff13f8652e1a11252b868f" translate="yes" xml:space="preserve">
          <source>This just sums the elements of iterable passed in the first argument, treating second argument as the initial value of the sum (if not given, &lt;code&gt;0&lt;/code&gt; is used instead and this case will give you an error).</source>
          <target state="translated">这只是对第一个参数中传递的iterable元素求和，将第二个参数视为和的初始值（如果未给出，则使用 &lt;code&gt;0&lt;/code&gt; 代替，这种情况下会给您带来错误）。</target>
        </trans-unit>
        <trans-unit id="22c2c19b3bac52f4b2cf95eeea7c5da16b692799" translate="yes" xml:space="preserve">
          <source>This may not be the most efficient way but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python3.5) and recursion.</source>
          <target state="translated">这可能不是最有效的方法,但我想到了放一个单行本(其实是双行本)。这两个版本都可以在任意层次嵌套的列表上工作,并且利用了语言特性(Python3.5)和递归的特点。</target>
        </trans-unit>
        <trans-unit id="ab7d5f153551afca8f6c602e4de5f5383356ed3b" translate="yes" xml:space="preserve">
          <source>This should work fine.</source>
          <target state="translated">这个应该很好用。</target>
        </trans-unit>
        <trans-unit id="c8771b06b3b88dac30f258456688e4372fdb7213" translate="yes" xml:space="preserve">
          <source>This solution is modified from a recipe in &lt;em&gt;Beazley, D. and B. Jones.  Recipe 4.14, Python Cookbook 3rd Ed., O'Reilly Media Inc. Sebastopol, CA: 2013.&lt;/em&gt;</source>
          <target state="translated">此解决方案是根据&lt;em&gt;Beazley，D.和B. Jones&lt;/em&gt;的食谱修改的&lt;em&gt;。&lt;/em&gt; &lt;em&gt;食谱4.14，Python Cookbook第三版，O'Reilly Media Inc.，塞巴斯托波尔，加利福尼亚：2013年。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9bcd7287917139a6af150a5761753b741a5dfa5f" translate="yes" xml:space="preserve">
          <source>This works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable &lt;code&gt;flist&lt;/code&gt; and then rolls back it to the parent. Whenever &lt;code&gt;flist&lt;/code&gt; is returned, it is extended to the parent's &lt;code&gt;flist&lt;/code&gt; in the list comprehension. Therefore, at the root, a flat list is returned.</source>
          <target state="translated">这以深度优先的方式工作。 递归向下进行，直到找到一个非列表元素，然后扩展局部变量 &lt;code&gt;flist&lt;/code&gt; 并将其回滚到父级。 每当返回 &lt;code&gt;flist&lt;/code&gt; 时 ，它就会在列表 &lt;code&gt;flist&lt;/code&gt; 中扩展到父级的flist 。 因此，从根本上返回一个平面列表。</target>
        </trans-unit>
        <trans-unit id="59ed80852db6ea428cf54dd89710beabb15d36d1" translate="yes" xml:space="preserve">
          <source>To flatten only one level and if each of the items is itself iterable you can also use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html&quot;&gt;&lt;code&gt;iteration_utilities.flatten&lt;/code&gt;&lt;/a&gt; which itself is just a thin wrapper around &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt;&lt;code&gt;itertools.chain.from_iterable&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要仅展平一个级别，并且如果每个项目本身都是可迭代的，那么您还可以使用&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html&quot;&gt; &lt;code&gt;iteration_utilities.flatten&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain.from_iterable&quot;&gt; &lt;code&gt;itertools.chain.from_iterable&lt;/code&gt; &lt;/a&gt; ，它本身只是itertools.chain.from_iterable的薄包装：</target>
        </trans-unit>
        <trans-unit id="d85e040c6b2316333bbc8b6ece8ebd109dcad5c6" translate="yes" xml:space="preserve">
          <source>Using small lists and timeit: number=1000000</source>
          <target state="translated">使用小的列表和timeit:number=1000000</target>
        </trans-unit>
        <trans-unit id="8b777156d7db14dbefaad623bb79535a459684ae" translate="yes" xml:space="preserve">
          <source>Why do you use extend?</source>
          <target state="translated">为什么要用延长线?</target>
        </trans-unit>
        <trans-unit id="026239782349d9cccf8cae513c88ec70bc6f77a6" translate="yes" xml:space="preserve">
          <source>You can find out more here in the docs &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html&quot;&gt;numpy.concatenate&lt;/a&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html&quot;&gt;numpy.ravel&lt;/a&gt;</source>
          <target state="translated">您可以在docs &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html&quot;&gt;numpy.concatenate&lt;/a&gt;和&lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html&quot;&gt;numpy.ravel中&lt;/a&gt;找到更多信息</target>
        </trans-unit>
        <trans-unit id="98f00c4375c36821b12502ea83723a702fb0edfd" translate="yes" xml:space="preserve">
          <source>You can install &lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt;&lt;code&gt;underscore.py&lt;/code&gt;&lt;/a&gt; with pip</source>
          <target state="translated">您可以使用pip安装&lt;a href=&quot;https://github.com/serkanyersen/underscore.py&quot;&gt; &lt;code&gt;underscore.py&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e3f2e4eb4b0b94b2d85fa9b562339a3ec7bc93b" translate="yes" xml:space="preserve">
          <source>You can remedy this as follows:</source>
          <target state="translated">你可以通过以下方法来补救。</target>
        </trans-unit>
        <trans-unit id="b69cc7e24723fc0ad7c514ca643eccd680bfbd54" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain&quot;&gt;&lt;code&gt;itertools.chain()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://docs.python.org/library/itertools.html#itertools.chain&quot;&gt; &lt;code&gt;itertools.chain()&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="ae1549c83cb4c81622f3b6d9fed8b362916b2245" translate="yes" xml:space="preserve">
          <source>You can use numpy :</source>
          <target state="translated">你可以使用numpy :</target>
        </trans-unit>
        <trans-unit id="ac9b642dd33f13b33118da8230b6f694c73801a1" translate="yes" xml:space="preserve">
          <source>You see reduce respects the sequence type, so when you supply a tuple, you get back a tuple. Let's try with a list::</source>
          <target state="translated">你看 reduce 尊重序列类型,所以当你提供一个 tuple 时,你会得到一个 tuple。我们用一个列表来试试:。</target>
        </trans-unit>
        <trans-unit id="2fae8325874681cc6b334b37cba1a121bd8cfad9" translate="yes" xml:space="preserve">
          <source>another fun way to do this:</source>
          <target state="translated">另一个有趣的方式来做这个。</target>
        </trans-unit>
        <trans-unit id="9909ec7f3a3afabe82abee395540624cbdaad7c1" translate="yes" xml:space="preserve">
          <source>is faster than the shortcuts posted so far. (&lt;code&gt;l&lt;/code&gt; is the list to flatten.)</source>
          <target state="translated">比到目前为止发布的快捷方式快。 （ &lt;code&gt;l&lt;/code&gt; 是要扁平化的列表。）</target>
        </trans-unit>
        <trans-unit id="abfaa5b8f36540158b4c83a8c2ff8def85ec64e0" translate="yes" xml:space="preserve">
          <source>to be the fastest solution. (&lt;code&gt;operator.iadd&lt;/code&gt; is equally fast.)</source>
          <target state="translated">成为最快的解决方案。 （ &lt;code&gt;operator.iadd&lt;/code&gt; 同样快。）</target>
        </trans-unit>
        <trans-unit id="3d6b372a9c60b40127154403945e3da65b17a4cf" translate="yes" xml:space="preserve">
          <source>which means:</source>
          <target state="translated">这意味着:</target>
        </trans-unit>
        <trans-unit id="8a81fcda00582e8515550fb41988323475038a58" translate="yes" xml:space="preserve">
          <source>while most other solutions throw an error this solution handles them.</source>
          <target state="translated">而大多数其他的解决方案都会出错,而这个解决方案可以处理它们。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
