<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/950087">
    <body>
      <group id="950087">
        <trans-unit id="206ab3d9bec48efae73640429f4d8678f64506e9" translate="yes" xml:space="preserve">
          <source>(This answer is in response to e-satis' comment).</source>
          <target state="translated">(この回答はe-satisさんのコメントに対するものです)。</target>
        </trans-unit>
        <trans-unit id="c2f82e6af2dc551c77d47d4e59e40a67261ca803" translate="yes" xml:space="preserve">
          <source>. And it works! Confusing...</source>
          <target state="translated">.うまくいった!紛らわしい...</target>
        </trans-unit>
        <trans-unit id="6eae3a5b062c6d0d79f070c26e6d62486b40cb46" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>
        </trans-unit>
        <trans-unit id="56462b98ec98df96345ec73222abd51331f6a57f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://37signals.com/svn/posts/1587-introducing-sprockets-javascript-dependency-management-and-concatenation&quot;&gt;Introducing Sprockets: JavaScript dependency management and concatenation&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://37signals.com/svn/posts/1587-introducing-sprockets-javascript-dependency-management-and-concatenation&quot;&gt;Sprocketsの紹介：JavaScriptの依存関係の管理と連結&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c32de899cfb6ec06e8cc06f8e5e9f40a37e92d7c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://calculist.org/blog/2012/06/29/static-module-resolution/&quot;&gt;Static module resolution&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://calculist.org/blog/2012/06/29/static-module-resolution/&quot;&gt;静的モジュールの解決&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2762c6431432dd5a70cecfb315f7619966f378a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders&quot;&gt;Module loaders&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders&quot;&gt;モジュールローダー&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="788fd7a0f4e090824b273e7120114e5c5cbd91d5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;build/main.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;build/main.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6f6bff257cd31d0764b92815c9b9d17e8f561e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;src/Form/Input/Tel.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;src/Form/Input/Tel.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca9ca5e0a3691e6d44f125996c50847fbf836c5c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;src/main.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;src/main.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6a16d8f75b54b1f1f0b21d8ce61fc11b0bba33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CommonJS&lt;/strong&gt; (used in NodeJS)</source>
          <target state="translated">&lt;strong&gt;CommonJS&lt;/strong&gt; （NodeJSで使用）</target>
        </trans-unit>
        <trans-unit id="7290c866af5b8bcecf5045b72e9fd6779df65827" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Modules&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6モジュール&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bebe38df96c7eb3f3282665cee82c64c21884191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what to do about it ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;それでそれについて何をすべきか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fcc0aa2abc91d9c0d481b93b0bba6fbd9423c59b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: Mixture is &lt;a href=&quot;http://mixture.io/blog/free/&quot;&gt;now free&lt;/a&gt; (offline).</source>
          <target state="translated">&lt;strong&gt;更新&lt;/strong&gt; ：Mixtureは&lt;a href=&quot;http://mixture.io/blog/free/&quot;&gt;無料&lt;/a&gt; （オフライン）になりました。</target>
        </trans-unit>
        <trans-unit id="53d014567827ce6d8ba81376d4cbf9262511230d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: Mixture is now discontinued. &lt;a href=&quot;https://github.com/teammixture/mixture.io/issues/6&quot;&gt;Old mixture releases&lt;/a&gt; are still available</source>
          <target state="translated">&lt;strong&gt;更新&lt;/strong&gt; ：Mixtureは廃止されました。 &lt;a href=&quot;https://github.com/teammixture/mixture.io/issues/6&quot;&gt;古い混合リリース&lt;/a&gt;はまだ利用可能です</target>
        </trans-unit>
        <trans-unit id="f8d6e8d151ca82b2e0671602d8c89392168b089a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;implementation.js&lt;/strong&gt; is your &quot;main&quot; JavaScript file that depends on &lt;strong&gt;some-dependency.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;implementation.js&lt;/strong&gt;は、 &lt;strong&gt;some-dependency.jsに依存&lt;/strong&gt;する「メイン」のJavaScriptファイルです</target>
        </trans-unit>
        <trans-unit id="e090dd13b65625719872427d2c45c23e507646c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;some-dependency.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;some-dependency.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00d49aecf61eefacf881c76b0da44cb61b90c3b6" translate="yes" xml:space="preserve">
          <source>AJAX Loading</source>
          <target state="translated">AJAXの読み込み</target>
        </trans-unit>
        <trans-unit id="a858f45b0cd86a8d053c47aed5612e8df1b50a0b" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;https://stackoverflow.com/a/10939737/1676444&quot;&gt;as the second highest voted answer to your question highlights&lt;/a&gt;, &lt;a href=&quot;http://www.requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; can also handle including scripts inside a Web Worker (likely calling &lt;code&gt;importScripts&lt;/code&gt; itself, but with a few other useful features).</source>
          <target state="translated">または、 &lt;a href=&quot;https://stackoverflow.com/a/10939737/1676444&quot;&gt;質問に対する2番目に投票数の多い回答がハイライトされているため&lt;/a&gt; 、 &lt;a href=&quot;http://www.requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;はWebワーカー内にスクリプトを含めることも処理できます （ &lt;code&gt;importScripts&lt;/code&gt; 自体を呼び出す可能性がありますが、他のいくつかの便利な機能があります）。</target>
        </trans-unit>
        <trans-unit id="104bb6fccb3dd88007fd041a6caf1caa570d887e" translate="yes" xml:space="preserve">
          <source>Although these answers are great, there is a simple &quot;solution&quot; that has been around since script loading existed, and it will cover 99.999% of most people's use cases. Just include the script you need before the script that requires it. For most projects it does not take long to determine which scripts are needed and in what order.</source>
          <target state="translated">これらの回答は素晴らしいものですが、スクリプトの読み込みが存在していた頃からあるシンプルな「解決策」があり、ほとんどの人のユースケースの99.999%をカバーします。必要なスクリプトを必要とするスクリプトの前に、必要なスクリプトを含めるだけです。ほとんどのプロジェクトでは、どのスクリプトが必要か、どの順番で必要かを判断するのに時間はかかりません。</target>
        </trans-unit>
        <trans-unit id="b50f51a682a21ea87eb5831332387ee8e672513c" translate="yes" xml:space="preserve">
          <source>And be able to call a function from the required script in the next line:</source>
          <target state="translated">そして、次の行で必要なスクリプトから関数を呼び出せるようにすること。</target>
        </trans-unit>
        <trans-unit id="883eb03a9cdc193322e4ba0c284e4929b617cd9b" translate="yes" xml:space="preserve">
          <source>And get the combined file</source>
          <target state="translated">そして、結合されたファイルを取得します。</target>
        </trans-unit>
        <trans-unit id="26312a853a8a0fed6d13295ff03f0dca11974071" translate="yes" xml:space="preserve">
          <source>And right after including &lt;code&gt;included.js&lt;/code&gt;, the &lt;code&gt;hello()&lt;/code&gt; function is called, and you get the alert.</source>
          <target state="translated">また、 &lt;code&gt;included.js&lt;/code&gt; をインクルードした直後に &lt;code&gt;hello()&lt;/code&gt; 関数が呼び出され、アラートが表示されます。</target>
        </trans-unit>
        <trans-unit id="f13e6a18a32be72735a2f247839504b514c2563c" translate="yes" xml:space="preserve">
          <source>Another way, that in my opinion is much cleaner, is to make a synchronous Ajax request instead of using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. Which is also how &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; handles includes.</source>
          <target state="translated">もう1つの方法は、私の意見ではよりクリーンで、 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを使用する代わりに同期Ajaxリクエストを作成することです。 これは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.jsによる&lt;/a&gt;インクルードの処理方法でもあります。</target>
        </trans-unit>
        <trans-unit id="f421ce52a3901e83133ea470faef7ae69fc93013" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this answer, many developers use build/transpilation tool(s) like Parcel, Webpack, or Babel in their projects, allowing them to use upcoming JavaScript syntax, provide backward compatibility for older browsers, combine files, minify, perform code splitting etc.</source>
          <target state="translated">この回答のトップで述べたように、多くの開発者はプロジェクトでParcel、Webpack、またはBabelのようなbuildtranspilationツールを使用しており、今後のJavaScriptの構文を使用したり、古いブラウザの下位互換性を提供したり、ファイルを結合したり、ミニ化したり、コード分割を実行したりすることができます。</target>
        </trans-unit>
        <trans-unit id="949b1e33e3a590719f723351553af804e4929438" translate="yes" xml:space="preserve">
          <source>As you saw, I had use a variable in one JavaScript file in another JavaScript file, but I didn't need to include one in another. I just needed to ensure that the first JavaScript file loaded before the second JavaScript file, and, the first JavaScript file's variables are accessible in the second JavaScript file, automatically.</source>
          <target state="translated">ご覧のように、ある JavaScript ファイルの変数を別の JavaScript ファイルで使用していましたが、別の JavaScript ファイルに変数を含める必要はありませんでした。最初の JavaScript ファイルが 2 番目の JavaScript ファイルよりも先に読み込まれ、最初の JavaScript ファイルの変数が 2 番目の JavaScript ファイルで自動的にアクセスできるようにする必要があっただけです。</target>
        </trans-unit>
        <trans-unit id="277120e489ec4b95e6dd7c32060d43032d9152c8" translate="yes" xml:space="preserve">
          <source>As you see, it's easier than Require.js and as convenient as jQuery's &lt;code&gt;$.getScript&lt;/code&gt; method. It also has some advanced features, like conditional loading, feature detection and &lt;a href=&quot;http://headjs.com/site/api/v1.00.html&quot;&gt;much more&lt;/a&gt;.</source>
          <target state="translated">ご覧のとおり、これはRequire.jsよりも簡単で、jQueryの &lt;code&gt;$.getScript&lt;/code&gt; メソッドと同じくらい便利です。 また、条件付き読み込み、機能検出などの高度な機能も備えて&lt;a href=&quot;http://headjs.com/site/api/v1.00.html&quot;&gt;います&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="198f9d81f71210a4fe6ffba57567675fdb5e650b" translate="yes" xml:space="preserve">
          <source>BUT:</source>
          <target state="translated">BUT:</target>
        </trans-unit>
        <trans-unit id="2314410b2adc404dde335bb42725bcc7fd26563a" translate="yes" xml:space="preserve">
          <source>Before calling &lt;code&gt;document.writeln&lt;/code&gt;, it checks to make sure the script has not already been loading by evaluating all the script elements.</source>
          <target state="translated">&lt;code&gt;document.writeln&lt;/code&gt; を呼び出す前に、すべてのスクリプト要素を評価して、スクリプトがまだ読み込まれていないことを確認します。</target>
        </trans-unit>
        <trans-unit id="2816ea2652eecdb35254f7a8a62138f40ae37f28" translate="yes" xml:space="preserve">
          <source>Both of these solutions are discussed and illustrated in &lt;a href=&quot;http://unixpapa.com/js/dyna.html&quot;&gt;JavaScript Madness: Dynamic Script Loading&lt;/a&gt;.</source>
          <target state="translated">これらのソリューションの両方については、「 &lt;a href=&quot;http://unixpapa.com/js/dyna.html&quot;&gt;JavaScriptマッドネス：動的スクリプト読み込み」で&lt;/a&gt;説明されています 。</target>
        </trans-unit>
        <trans-unit id="caabcacc0f9cf84e44c7d32424a5dc4629a4c721" translate="yes" xml:space="preserve">
          <source>Browsers do not support this moduling system yet so in order for you to use this syntax you must use a bundler like webpack. Using a bundler is better anyway because this can combine all of your different files into a single (or couple related) files. This will serve the files from the server to the client faster because each HTTP request has some associated overhead accompanied with it. Thus by reducing the overal HTTP request we improve the performance. Here is an example of ES6 modules:</source>
          <target state="translated">ブラウザはまだこのモジュリングシステムをサポートしていないので、この構文を使うためには webpack のようなバンドルラーを使わなければなりません。バンドルラーを使う方が良いでしょう。それぞれの HTTP リクエストはそれに付随していくつかの関連するオーバーヘッドを持っているので、これはサーバからクライアントへのファイルの配信をより速くします。このように、HTTPリクエストのオーバーヘッドを減らすことで、パフォーマンスを向上させることができます。ここにES6モジュールの例を示します。</target>
        </trans-unit>
        <trans-unit id="b337cd4902acd58b0de99a8784fe0ca89f41d186" translate="yes" xml:space="preserve">
          <source>Browsers have had support for loading ECMAScript modules directly (no tools like Webpack required) &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;since&lt;/a&gt; Safari 10.1, Chrome 61, Firefox 60, and Edge 16. Check the current support at &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;caniuse&lt;/a&gt;. There is no need to use Node.js' &lt;code&gt;.mjs&lt;/code&gt; extension; browsers completely ignore file extensions on modules/scripts.</source>
          <target state="translated">ブラウザは&lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;、&lt;/a&gt; Safari 10.1、Chrome 61、Firefox 60、およびEdge 16 以降、 ECMAScriptモジュールの直接ロードをサポートしています（Webpackなどのツールは不要） &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;。caniuseで&lt;/a&gt;現在のサポートを確認してください。 Node.jsの &lt;code&gt;.mjs&lt;/code&gt; 拡張子を使用する必要はありません。 ブラウザはモジュール/スクリプトのファイル拡張子を完全に無視します。</target>
        </trans-unit>
        <trans-unit id="522ce0fcef4ca6aef8ba20db065f82588818d7ac" translate="yes" xml:space="preserve">
          <source>But if that is not a problem for you, then this method should work.</source>
          <target state="translated">しかし、それが問題にならないのであれば、この方法はうまくいくはずです。</target>
        </trans-unit>
        <trans-unit id="1bbb812967de17c1fec9aa4b70a28049b6474a4a" translate="yes" xml:space="preserve">
          <source>But since 2015 (ES6), JavaScript has had the &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES6 modules&lt;/a&gt; standard to import modules in Node.js, which is also supported by &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;most modern browsers&lt;/a&gt;.</source>
          <target state="translated">しかし、2015年（ES6）以降、JavaScriptにはNode.jsにモジュールをインポートする&lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES6モジュール&lt;/a&gt;標準があり、 &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;ほとんどの最新のブラウザーで&lt;/a&gt;もサポートされています 。</target>
        </trans-unit>
        <trans-unit id="5df356af95c22125fad799a05f636daf7b8b6f4f" translate="yes" xml:space="preserve">
          <source>Define dependencies as modules:</source>
          <target state="translated">依存関係をモジュールとして定義します。</target>
        </trans-unit>
        <trans-unit id="efb211ea4156611a7cf5952316e1ba2fb95ae811" translate="yes" xml:space="preserve">
          <source>Detecting when the script has been executed</source>
          <target state="translated">スクリプトが実行されたときの検出</target>
        </trans-unit>
        <trans-unit id="e8e7c59c81ba090cb40a7e03782de9db506696ec" translate="yes" xml:space="preserve">
          <source>Dynamic Script Loading</source>
          <target state="translated">動的スクリプトの読み込み</target>
        </trans-unit>
        <trans-unit id="386cf3c6e6b0464ad5cbc22efde8538c6548eced" translate="yes" xml:space="preserve">
          <source>Dynamic imports in browsers</source>
          <target state="translated">ブラウザでの動的インポート</target>
        </trans-unit>
        <trans-unit id="d9d3d46b339478880eb52f7f9c0e16f1cb5a0500" translate="yes" xml:space="preserve">
          <source>Dynamic imports let the script load other scripts as needed:</source>
          <target state="translated">動的インポートにより、必要に応じて他のスクリプトをロードすることができます。</target>
        </trans-unit>
        <trans-unit id="d388c8604db3813ddb87de2fb1c3f60be9f8222a" translate="yes" xml:space="preserve">
          <source>ECMAScript (ES6) modules have been &lt;a href=&quot;https://nodejs.org/api/esm.html&quot;&gt;supported in Node.js&lt;/a&gt; since v8.5, with the &lt;code&gt;--experimental-modules&lt;/code&gt; flag, and since at least Node.js v13.8.0 without the flag. To enable &quot;ESM&quot; (vs. Node.js's previous CommonJS-style module system [&quot;CJS&quot;]) you either use &lt;code&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt; in &lt;code&gt;package.json&lt;/code&gt; or give the files the extension &lt;code&gt;.mjs&lt;/code&gt;. (Similarly, modules written with Node.js's previous CJS module can be named &lt;code&gt;.cjs&lt;/code&gt; if your default is ESM.)</source>
          <target state="translated">ECMAScript（ES6）モジュールは、v.8.5以降、 &lt;code&gt;--experimental-modules&lt;/code&gt; フラグを使用して、および少なくともNode.js v13.8.0以降、フラグなし&lt;a href=&quot;https://nodejs.org/api/esm.html&quot;&gt;でNode.jsでサポートされ&lt;/a&gt;ています 。 &quot;ESM&quot;（vs. Node.jsの以前のCommonJSスタイルのモジュールシステム[&quot;CJS&quot;]）を有効にするには、 &lt;code&gt;package.json&lt;/code&gt; で &lt;code&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt; を使用するか、ファイルに拡張子 &lt;code&gt;.mjs&lt;/code&gt; を付けます。 （同様に、Node.jsの以前のCJSモジュールで作成されたモジュールは、デフォルトがESMの場合、 &lt;code&gt;.cjs&lt;/code&gt; という名前にすることができます。）</target>
        </trans-unit>
        <trans-unit id="1ec6cc0d49bcb01cd50cba9ddb3ed7b2944cb238" translate="yes" xml:space="preserve">
          <source>ECMAScript modules in browsers</source>
          <target state="translated">ブラウザのECMAScriptモジュール</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6モジュール</target>
        </trans-unit>
        <trans-unit id="78859e0aa530ac3119a27bb18cf0fc2aeb91ad89" translate="yes" xml:space="preserve">
          <source>Even though all of the plugins get dropped into the head tag the way they ought to, they don't always get run by the browser when you click into the page or refresh.</source>
          <target state="translated">すべてのプラグインがヘッドタグに落とし込まれても、ページをクリックしたり更新したりしたときにブラウザに実行されるとは限りません。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="b4136dcf903eb3c76fe317c65ef053453e8cdc32" translate="yes" xml:space="preserve">
          <source>Excerpt from the &lt;a href=&quot;https://github.com/jrburke/requirejs&quot;&gt;GitHub&lt;/a&gt; README:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/jrburke/requirejs&quot;&gt;GitHub&lt;/a&gt; READMEからの抜粋：</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="b5cbd3434bd596109a8781b509798ab1da4452a6" translate="yes" xml:space="preserve">
          <source>F5</source>
          <target state="translated">F5</target>
        </trans-unit>
        <trans-unit id="94716db44426788000dfcbae9cba45638f7cc496" translate="yes" xml:space="preserve">
          <source>Fetch Loading</source>
          <target state="translated">フェッチ読み込み</target>
        </trans-unit>
        <trans-unit id="52af92858e80319c3e320b7210c45af2d1252260" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;main.js.php&lt;/code&gt;:</source>
          <target state="translated">ファイル &lt;code&gt;main.js.php&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="97e1664caa79aa71082bd60226618665682535d9" translate="yes" xml:space="preserve">
          <source>File1:</source>
          <target state="translated">File1:</target>
        </trans-unit>
        <trans-unit id="730fd0522d514826c9aaf7d211a195d36c9b867d" translate="yes" xml:space="preserve">
          <source>File2:</source>
          <target state="translated">File2:</target>
        </trans-unit>
        <trans-unit id="2e8382e08c9bb01c7e1654bd24c7e7f77f55dbf0" translate="yes" xml:space="preserve">
          <source>File3:</source>
          <target state="translated">File3:</target>
        </trans-unit>
        <trans-unit id="775ecf6ee49f69f0ed328c8af1660730b48d6a2e" translate="yes" xml:space="preserve">
          <source>File: main.js</source>
          <target state="translated">ファイル:main.js</target>
        </trans-unit>
        <trans-unit id="fed8f02dc3fd97daef37a09c9513fac304867fe6" translate="yes" xml:space="preserve">
          <source>File: myvariables.js</source>
          <target state="translated">ファイル:myvariables.js</target>
        </trans-unit>
        <trans-unit id="f973768795a937dcadac26fc7473d3746b5da826" translate="yes" xml:space="preserve">
          <source>For compatibility with older browsers, build tools like &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; and/or transpilation tools like &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; can be used.</source>
          <target state="translated">古いブラウザとの互換性のために、 &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;や&lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt;などのビルドツールや&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;などのトランスパイレーションツールを使用できます。</target>
        </trans-unit>
        <trans-unit id="1f2147bfcc0f0f7c3cef6200f4753cf79500f046" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;my_lovely_script.js&lt;/code&gt; contains &lt;code&gt;MySuperObject&lt;/code&gt;:</source>
          <target state="translated">たとえば、 &lt;code&gt;my_lovely_script.js&lt;/code&gt; にはMySuperObjectが含まれてい &lt;code&gt;MySuperObject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="759d7f8d0ebbe76c3a7b37e810db7f723123b25b" translate="yes" xml:space="preserve">
          <source>For this I did as below:</source>
          <target state="translated">そのためには以下のようにしました。</target>
        </trans-unit>
        <trans-unit id="34a3ad15283216601c4c7025cdfabd88fdbb3275" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries&quot;&gt;Web Workers have their own &lt;code&gt;importScripts&lt;/code&gt; function&lt;/a&gt; which is a global function in the scope of the Web Worker, native to the browser itself as it &lt;a href=&quot;https://html.spec.whatwg.org/multipage/workers.html#importing-scripts-and-libraries&quot;&gt;is part of the specification&lt;/a&gt;.</source>
          <target state="translated">さいわい、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries&quot;&gt;Webワーカーには独自の &lt;code&gt;importScripts&lt;/code&gt; 関数&lt;/a&gt;があり、これはWebワーカーのスコープ内のグローバル関数で&lt;a href=&quot;https://html.spec.whatwg.org/multipage/workers.html#importing-scripts-and-libraries&quot;&gt;あり、仕様の一部である&lt;/a&gt;ため、ブラウザー自体にネイティブです。</target>
        </trans-unit>
        <trans-unit id="67960c2c77f8b866584719b8e48c2e8eda27e92f" translate="yes" xml:space="preserve">
          <source>From the Mixture documentation on &lt;code&gt;.mix&lt;/code&gt; files:</source>
          <target state="translated">&lt;code&gt;.mix&lt;/code&gt; ファイルに関するMixtureドキュメントから：</target>
        </trans-unit>
        <trans-unit id="43906746944eafb56d9523b37e70f7bd285ad8e4" translate="yes" xml:space="preserve">
          <source>Gist: &lt;a href=&quot;http://gist.github.com/284442&quot;&gt;http://gist.github.com/284442&lt;/a&gt;.</source>
          <target state="translated">要旨： &lt;a href=&quot;http://gist.github.com/284442&quot;&gt;http&lt;/a&gt; : //gist.github.com/284442 。</target>
        </trans-unit>
        <trans-unit id="c973140512dda715ec8b98cd19e4abc17e64227e" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;synchronous&lt;/strong&gt; version &lt;strong&gt;without jQuery&lt;/strong&gt;:</source>
          <target state="translated">ここに&lt;strong&gt;jQueryなしの&lt;/strong&gt; &lt;strong&gt;同期&lt;/strong&gt;バージョンがあります：</target>
        </trans-unit>
        <trans-unit id="24b79cca1f32a4977bb54091e81e918ad5543042" translate="yes" xml:space="preserve">
          <source>Here is an example of how this could work:</source>
          <target state="translated">これがどのように機能するかの一例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="c836ed859d15dd35abf3de4024c47570ffc40a21" translate="yes" xml:space="preserve">
          <source>Here's an example &lt;code&gt;.mix&lt;/code&gt; file that combines multiple &lt;code&gt;.js&lt;/code&gt; files into one:</source>
          <target state="translated">複数の &lt;code&gt;.js&lt;/code&gt; ファイルを1つに &lt;code&gt;.mix&lt;/code&gt; ファイルの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="a0a735f6041355a8e31634a70ac885a99ea8fc46" translate="yes" xml:space="preserve">
          <source>Here's an example using jQuery:</source>
          <target state="translated">jQueryを使った例です。</target>
        </trans-unit>
        <trans-unit id="3d4d50089b78caa8accdb20b9de1e3e36a7c71dd" translate="yes" xml:space="preserve">
          <source>Here's an explanation of how the code works for those that are curious: essentially, it creates a new script tag (after the first one) of the URL. It sets it to asynchronous mode so it doesn't block the rest of the code, but calls a callback when the readyState (the state of the content to be loaded) changes to 'loaded'.</source>
          <target state="translated">興味のある方のために、このコードがどのように動作するかを説明します:基本的には、URLの新しいscriptタグ(最初のタグの後)を作成します。非同期モードに設定しているので、残りのコードはブロックされませんが、READYState (読み込まれるコンテンツの状態)が 'LOADED' に変化したときにコールバックを呼び出します。</target>
        </trans-unit>
        <trans-unit id="687874dfffbfcb582922598a2058fbf71cfb4713" translate="yes" xml:space="preserve">
          <source>Here's the generalized version of how Facebook does it for their ubiquitous Like button:</source>
          <target state="translated">これは、Facebookがユビキタスな「いいね!」ボタンのためにどのようにそれを行うかの一般化されたバージョンです。</target>
        </trans-unit>
        <trans-unit id="512061e76228d02949b902d49c6ed3f12388bcca" translate="yes" xml:space="preserve">
          <source>How do I include a JavaScript file in another JavaScript file</source>
          <target state="translated">JavaScriptファイルを別のJavaScriptファイルにインクルードするには?</target>
        </trans-unit>
        <trans-unit id="f534ee42b1b1417c1c4328067f9e323c71e4cd19" translate="yes" xml:space="preserve">
          <source>However, this method also has a problem: if an error happens in the imported JavaScript file, &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; (and also Firefox Error Console and &lt;a href=&quot;https://developers.google.com/chrome-developer-tools/&quot;&gt;Chrome Developer Tools&lt;/a&gt; as well) will report its place incorrectly, which is a big problem if you use Firebug to track JavaScript errors down a lot (I do). Firebug simply doesn't know about the newly loaded file for some reason, so if an error occurs in that file, it reports that it occurred in your main &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; file, and you will have trouble finding out the real reason for the error.</source>
          <target state="translated">ただし、この方法には問題もあります。インポートされたJavaScriptファイルでエラーが発生した場合、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; （およびFirefox Error Consoleと&lt;a href=&quot;https://developers.google.com/chrome-developer-tools/&quot;&gt;Chromeデベロッパーツール&lt;/a&gt;も）がその場所を誤って報告します。これは、Firebugを使用して追跡する場合は大きな問題ですJavaScriptはかなりダウンします（私はそうします）。 Firebugは、何らかの理由で新しくロードされたファイルを単に認識しないため、そのファイルでエラーが発生すると、メインの&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;ファイルで発生したことが報告され、エラーの実際の理由を見つけるのが困難になります。</target>
        </trans-unit>
        <trans-unit id="96ce64ab269dff867b5298523efe17ef57bf386e" translate="yes" xml:space="preserve">
          <source>I also made a simple test for this at &lt;a href=&quot;http://www.kipras.com/dev/import_js_test/&quot;&gt;Example&lt;/a&gt;.</source>
          <target state="translated">例でも簡単なテストを行いました。</target>
        </trans-unit>
        <trans-unit id="052345c2ec801d63db4bca3da6cc49e6666d2a55" translate="yes" xml:space="preserve">
          <source>I assume that a script is not fully executed until its &lt;code&gt;document.ready&lt;/code&gt; event has been executed. (I know using &lt;code&gt;document.ready&lt;/code&gt; is not required, but many people use it, and handling this is a safeguard.)</source>
          <target state="translated">&lt;code&gt;document.ready&lt;/code&gt; イベントが実行されるまで、スクリプトは完全には実行されないと思います。 （私は &lt;code&gt;document.ready&lt;/code&gt; を使用する必要がないことを知っていますが、多くの人がそれを使用しており、これを処理することは安全策です。）</target>
        </trans-unit>
        <trans-unit id="bcf92d81ab2e9f8567b02bf77422af88d42f8420" translate="yes" xml:space="preserve">
          <source>I came to this question because I was looking for a simple way to maintain a collection of useful JavaScript plugins. After seeing some of the solutions here, I came up with this:</source>
          <target state="translated">この質問に来たのは、JavaScriptの便利なプラグイン集を簡単にメンテナンスできる方法を探していたからです。ここでいくつかの解決策を見た後、私はこれにたどり着きました。</target>
        </trans-unit>
        <trans-unit id="76ea63d97f56a6085f1fd0905c71733444f736e3" translate="yes" xml:space="preserve">
          <source>I decided to go backwards instead of forwards. Thank you &lt;code&gt;document.writeln&lt;/code&gt;. I know it's taboo, but as long as it is used correctly this works well. You end up with code that can be debugged easily, shows in the DOM correctly and can ensure the order the dependencies are loaded correctly.</source>
          <target state="translated">前進ではなく後退することにしました。 &lt;code&gt;document.writeln&lt;/code&gt; に感謝します。 私はそれがタブーであることを知っていますが、それが正しく使用されている限り、これはうまく機能します。 簡単にデバッグできるコードができ、DOMに正しく表示され、依存関係が正しく読み込まれる順序を確認できます。</target>
        </trans-unit>
        <trans-unit id="e71ee8ddaf9dbce0706f9609b8c87eec82c91b6d" translate="yes" xml:space="preserve">
          <source>I had a simple issue, but I was baffled by responses to this question.</source>
          <target state="translated">簡単な問題なのですが、この問題に対する回答に困惑してしまいました。</target>
        </trans-unit>
        <trans-unit id="e90313ba30b8afab25bd3404bda1adf05507004e" translate="yes" xml:space="preserve">
          <source>I had to use a variable (myVar1) defined in one JavaScript file (myvariables.js) in another JavaScript file (main.js).</source>
          <target state="translated">あるJavaScriptファイル(myvariables.js)で定義された変数(myVar1)を別のJavaScriptファイル(main.js)で使用しなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="e78b6aa2c0deda3aa7dbaba4a6e64774f7b7faa0" translate="yes" xml:space="preserve">
          <source>I have actually written a jQuery plugin called &lt;em&gt;$.import_js()&lt;/em&gt; which uses this method:</source>
          <target state="translated">私は実際に、このメソッドを使用する&lt;em&gt;$ .import_js（）&lt;/em&gt;というjQueryプラグインを作成しました。</target>
        </trans-unit>
        <trans-unit id="4a561d066341fa04c3643f7a3595cf6b9722249e" translate="yes" xml:space="preserve">
          <source>I just wrote this JavaScript code (using &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt; for &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; manipulation):</source>
          <target state="translated">私はこのJavaScriptコードを記述しました（ &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;操作に&lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt;を使用）。</target>
        </trans-unit>
        <trans-unit id="8964113a372044579ef717f6641fb9d359e68a92" translate="yes" xml:space="preserve">
          <source>I liked the idea of extending jQuery, but obviously you don't need to.</source>
          <target state="translated">jQueryを拡張するというアイデアは好きでしたが、明らかにその必要はありません。</target>
        </trans-unit>
        <trans-unit id="48b6e1e53bcee394381ab4d7bb07cd633f263a4a" translate="yes" xml:space="preserve">
          <source>I use &lt;a href=&quot;https://github.com/sstephenson/sprockets&quot;&gt;Sprockets&lt;/a&gt; (I don't know if there are others). You build your JavaScript code in separate files and include comments that are processed by the Sprockets engine as includes. For development you can include files sequentially, then for production to merge them...</source>
          <target state="translated">私は&lt;a href=&quot;https://github.com/sstephenson/sprockets&quot;&gt;スプロケット&lt;/a&gt;を使用しています（他にあるかどうかはわかりません）。 JavaScriptコードを個別のファイルで作成し、Sprocketsエンジンで処理されるコメントをインクルードとして含めます。 開発の場合、ファイルを順番にインクルードし、本番の場合はマージすることができます...</target>
        </trans-unit>
        <trans-unit id="182b551075d667e89774a12930481224b9f18f97" translate="yes" xml:space="preserve">
          <source>I wrote a simple module that automates the job of importing/including module scripts in JavaScript. For detailed explanation of the code, refer to the blog post &lt;em&gt;&lt;a href=&quot;http://stamat.wordpress.com/2013/04/12/javascript-require-import-include-modules/&quot;&gt;JavaScript require / import / include modules&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">JavaScriptでモジュールスクリプトをインポート/インクルードする作業を自動化する簡単なモジュールを書きました。 コードの詳細な説明については、ブログ投稿&lt;em&gt;&lt;a href=&quot;http://stamat.wordpress.com/2013/04/12/javascript-require-import-include-modules/&quot;&gt;JavaScript require / import / includeモジュールを&lt;/a&gt;&lt;/em&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8b95b09b19967e0602d178894a47c43cfd08dc83" translate="yes" xml:space="preserve">
          <source>I've found it's more reliable to just write the script tags in a PHP include. You only have to write it once and that's just as much work as calling the plugin using JavaScript.</source>
          <target state="translated">PHPのインクルードでスクリプトタグを書くだけの方が信頼性が高いことがわかりました。一度だけ書く必要がありますし、JavaScriptを使ってプラグインを呼び出すのと同じくらいの作業です。</target>
        </trans-unit>
        <trans-unit id="50692954f36df35776c3a5384707e2028295c3dc" translate="yes" xml:space="preserve">
          <source>If anyone is looking for something more advanced, try out &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;. You'll get added benefits such as dependency management, better concurrency, and avoid duplication (that is, retrieving a script more than once).</source>
          <target state="translated">誰かがより高度なものを探している場合は、 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJSを&lt;/a&gt;試してください 。 依存関係の管理、同時実行性の向上、重複の回避（スクリプトの複数回の取得）などの追加のメリットが得られます。</target>
        </trans-unit>
        <trans-unit id="09c49c729196296537941a7491dbe605bca62236" translate="yes" xml:space="preserve">
          <source>If it works for Facebook, it will work for you.</source>
          <target state="translated">Facebookで効果があれば、あなたにも効果があるでしょう。</target>
        </trans-unit>
        <trans-unit id="e0e6f46db11f475cee8f6fa8e7e1cdd71fa87a80" translate="yes" xml:space="preserve">
          <source>If script2 requires script1, this really is the absolute easiest way to do something like this. I'm very surprised no-one has brought this up, as it's the most obvious and simplest answer that will apply in nearly every single case.</source>
          <target state="translated">script2 が script1 を必要とする場合、このようなことを行うには本当に最も簡単な方法です。これは、ほとんどすべての場合に適用される最も明白で最も単純な答えなので、誰もこれを持ち出さなかったことに非常に驚いています。</target>
        </trans-unit>
        <trans-unit id="08d0f5c8d3d6ff132321aa6d959d367e737ba43f" translate="yes" xml:space="preserve">
          <source>If you use the jQuery library, you can use the &lt;code&gt;$.getScript&lt;/code&gt; method.</source>
          <target state="translated">jQueryライブラリを使用する場合は、 &lt;code&gt;$.getScript&lt;/code&gt; 。 getScriptメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="2d3524e0e4d4cd1e4cf3277f0741ff66c1dc55d6" translate="yes" xml:space="preserve">
          <source>If you want in pure JavaScript, you can use &lt;code&gt;document.write&lt;/code&gt;.</source>
          <target state="translated">純粋なJavaScriptが必要な場合は、 &lt;code&gt;document.write&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="ad91c62be5e861663504e4455fee22384fc00bcf" translate="yes" xml:space="preserve">
          <source>If your intention to load the JavaScript file is &lt;strong&gt;using the functions from the imported/included file&lt;/strong&gt;, you can also define a global object and set the functions as object items. For instance:</source>
          <target state="translated">JavaScriptファイルをロードする意図が&lt;strong&gt;インポート/インクルードファイルの関数を使用している&lt;/strong&gt;場合は、グローバルオブジェクトを定義し、関数をオブジェクトアイテムとして設定することもできます。 例えば：</target>
        </trans-unit>
        <trans-unit id="87d10a4bf452ed2df2e36493992bb6eac702495c" translate="yes" xml:space="preserve">
          <source>In case you are using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage&quot;&gt;Web Workers&lt;/a&gt; and want to include additional scripts in the scope of the worker, the other answers provided about adding scripts to the &lt;code&gt;head&lt;/code&gt; tag, etc. will not work for you.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage&quot;&gt;Webワーカー&lt;/a&gt;を使用していて、ワーカーのスコープに追加のスクリプトを含めたい場合、ヘッドタグへのスクリプトの追加などについて提供されている他の回答は機能しません。</target>
        </trans-unit>
        <trans-unit id="c372dfb440124c48faeedb667ad1686636faba8f" translate="yes" xml:space="preserve">
          <source>In modern language with the check if script has already been loaded it would be:</source>
          <target state="translated">スクリプトがすでに読み込まれているかどうかをチェックする現代の言語ではそうなります。</target>
        </trans-unit>
        <trans-unit id="89e569c5aabe9fbbde286f6fa71cb13e5d555b8c" translate="yes" xml:space="preserve">
          <source>Instead of this approach you could attempt to modify the jQuery &lt;code&gt;readyList&lt;/code&gt;, but this seemed like a worse solution.</source>
          <target state="translated">このアプローチの代わりに、jQuery &lt;code&gt;readyList&lt;/code&gt; を変更することもできますが、これはより悪い解決策のように見えました。</target>
        </trans-unit>
        <trans-unit id="5198a78bb0d30cc8cf91f499bbb47db39eac32c1" translate="yes" xml:space="preserve">
          <source>Is there something in JavaScript similar to &lt;code&gt;@import&lt;/code&gt; in CSS that allows you to include a JavaScript file inside another JavaScript file?</source>
          <target state="translated">JavaScriptに、CSSの &lt;code&gt;@import&lt;/code&gt; のようなもので、JavaScriptファイルを別のJavaScriptファイル内に含めることができるものはありますか？</target>
        </trans-unit>
        <trans-unit id="a0c170f044d1b6605820b898a6064dddbee3d16e" translate="yes" xml:space="preserve">
          <source>It includes a &lt;code&gt;main.js&lt;/code&gt; file in the main HTML and then the script in &lt;code&gt;main.js&lt;/code&gt; uses &lt;code&gt;$.import_js()&lt;/code&gt; to import an additional file called &lt;code&gt;included.js&lt;/code&gt;, which defines this function:</source>
          <target state="translated">メインHTMLに &lt;code&gt;main.js&lt;/code&gt; ファイルが含まれていて、 main.jsのスクリプトは &lt;code&gt;$.import_js()&lt;/code&gt; を使用し &lt;code&gt;included.js&lt;/code&gt; 、この関数を定義するincluded.jsという追加のファイルをインポートします。</target>
        </trans-unit>
        <trans-unit id="cc1c709a99169050e868f3572e201e60f18ff0c4" translate="yes" xml:space="preserve">
          <source>It is possible to dynamically generate a JavaScript tag and append it to HTML document from inside other JavaScript code. This will load targeted JavaScript file.</source>
          <target state="translated">他のJavaScriptコードの中から動的にJavaScriptタグを生成してHTML文書に追加することが可能です。これにより、対象となるJavaScriptファイルが読み込まれます。</target>
        </trans-unit>
        <trans-unit id="299027586058c2f57df63257e78428635d35de48" translate="yes" xml:space="preserve">
          <source>It means that if you use these tricks directly, &lt;em&gt;you won't be able to use your newly loaded code the next line after you asked it to be loaded&lt;/em&gt;, because it will be still loading.</source>
          <target state="translated">つまり、これらのトリックを直接&lt;em&gt;使用する場合、ロードを要求した後、次の行で新しくロードされたコードを使用することはできません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="b01ba72d4fd35a9d4c4c9996b99e2fd452fde924" translate="yes" xml:space="preserve">
          <source>It works great and uses no page-reloads for me. I've tried the AJAX method (one of the other answers) but it doesn't seem to work as nicely for me.</source>
          <target state="translated">それは素晴らしい作品で、私のためにページのリロードを使用していません。私はAJAXメソッド(他の回答の1つ)を試してみましたが、それは私のためにうまく動作するようには見えません。</target>
        </trans-unit>
        <trans-unit id="e5daad8292815a8f471b32cc8d290ff531ccef25" translate="yes" xml:space="preserve">
          <source>Like Dynamic Imports you can load one or many scripts with a &lt;code&gt;fetch&lt;/code&gt; call using promises to control order of execution for script dependencies using the &lt;a href=&quot;https://git.habd.as/jhabdas/fetch-inject&quot;&gt;Fetch Inject&lt;/a&gt; library:</source>
          <target state="translated">動的インポートと同様に、 &lt;a href=&quot;https://git.habd.as/jhabdas/fetch-inject&quot;&gt;Fetch Inject&lt;/a&gt;ライブラリを使用してスクリプトの依存関係の実行順序を制御するプロミスを使用して、 &lt;code&gt;fetch&lt;/code&gt; 呼び出しで1つ以上のスクリプトをロードできます。</target>
        </trans-unit>
        <trans-unit id="8fcc19aee2e562ac4b64c23515ff5bb055bba5e1" translate="yes" xml:space="preserve">
          <source>Loaded the JavaScript code in the HTML file, in the correct order, myvariables.js first, then main.js:</source>
          <target state="translated">HTMLファイル内のJavaScriptコードを正しい順序でロードし、最初にmyvariables.js、次にmain.jsの順でロードしました。</target>
        </trans-unit>
        <trans-unit id="7475b8cb4b8b4b0ea0bd2e2735262e923671b358" translate="yes" xml:space="preserve">
          <source>Manually call just the one file in your head:</source>
          <target state="translated">頭の中にある1つのファイルだけを手動で呼び出します。</target>
        </trans-unit>
        <trans-unit id="c0955483993644c2d345d5478838388a3821a9ea" translate="yes" xml:space="preserve">
          <source>Maybe you can use this function that I found on this page &lt;em&gt;&lt;a href=&quot;http://forums.digitalpoint.com/showthread.php?t=146094&quot;&gt;How do I include a JavaScript file in a JavaScript file?&lt;/a&gt;&lt;/em&gt;:</source>
          <target state="translated">このページで見つけたこの関数を使用できるかもしれません&lt;em&gt;&lt;a href=&quot;http://forums.digitalpoint.com/showthread.php?t=146094&quot;&gt;。JavaScriptファイルにJavaScriptファイルを含めるにはどうすればよいですか？&lt;/a&gt;&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="e8d91a207629cab68b84bde0bfdf97bd5b2fd884" translate="yes" xml:space="preserve">
          <source>Mix files are simply .js or .css files with .mix. in the file name. A
  mix file simply     extends the functionality of a normal style or
  script file and allows you to import and combine.</source>
          <target state="translated">ミックスファイルとは、ファイル名に.mix.を持つ.jsや.cssファイルのことです。ミックスファイルは、通常のスタイルファイルやスクリプトファイルの機能を単純に拡張したもので、インポートしたり組み合わせたりすることができます。</target>
        </trans-unit>
        <trans-unit id="481ac87a7bba22c45887cc5c7ea78c63b449b061" translate="yes" xml:space="preserve">
          <source>Mixture outputs this as &lt;code&gt;scripts-global.js&lt;/code&gt; and also as a minified version (&lt;code&gt;scripts-global.min.js&lt;/code&gt;).</source>
          <target state="translated">Mixtureは、これを &lt;code&gt;scripts-global.js&lt;/code&gt; および縮小バージョン（ &lt;code&gt;scripts-global.min.js&lt;/code&gt; ）として出力します。</target>
        </trans-unit>
        <trans-unit id="3a067d11c89c1bd83a9bd5ce416dd2e152f89832" translate="yes" xml:space="preserve">
          <source>Most of solutions shown here imply dynamical loading. I was searching instead for a compiler which assemble all the depended files into a single output file. The same as &lt;a href=&quot;http://en.wikipedia.org/wiki/Less_%28stylesheet_language%29&quot;&gt;Less&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass&lt;/a&gt; preprocessors deal with the CSS &lt;code&gt;@import&lt;/code&gt; at-rule. Since I didn't find anything decent of this sort, I wrote a simple tool solving the issue.</source>
          <target state="translated">ここに示されているソリューションのほとんどは、動的な負荷を意味しています。 代わりに、依存するすべてのファイルを1つの出力ファイルにアセンブルするコンパイラを探していました。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Less_%28stylesheet_language%29&quot;&gt;Less&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass&lt;/a&gt;プリプロセッサがCSS &lt;code&gt;@import&lt;/code&gt; at-ruleを処理するのと同じです。 私はこの種のまともなものを見つけられなかったので、問題を解決する簡単なツールを書きました。</target>
        </trans-unit>
        <trans-unit id="80d75005f71e84434c0fa44621569283aced2efa" translate="yes" xml:space="preserve">
          <source>My usual method is:</source>
          <target state="translated">私のいつもの方法は</target>
        </trans-unit>
        <trans-unit id="cd04c41011b8c6a90b8d3d406e8973f00f118915" translate="yes" xml:space="preserve">
          <source>NOTE: You must use this only while the page is loading, otherwise you get a blank screen. In other words, &lt;strong&gt;always place this before / outside of document.ready&lt;/strong&gt;. I have not tested using this after the page is loaded in a click event or anything like that, but I am pretty sure it'll fail.</source>
          <target state="translated">注：これは、ページの読み込み中にのみ使用する必要があります。そうしないと、空白の画面が表示されます。 つまり、 &lt;strong&gt;常にdocument.readyの前/外に配置します&lt;/strong&gt; 。 ページがクリックイベントなどで読み込まれた後、これを使用したテストはしていませんが、失敗することはほぼ間違いありません。</target>
        </trans-unit>
        <trans-unit id="0ce496c371b0e9f99e92db6d770461268fed0859" translate="yes" xml:space="preserve">
          <source>Node.js require</source>
          <target state="translated">Node.js require</target>
        </trans-unit>
        <trans-unit id="70393d4cd6440f7071aab91842a254a103787886" translate="yes" xml:space="preserve">
          <source>Note that the script may execute after the DOM has loaded, or before, depending on the browser and whether you included the line &lt;code&gt;script.async = false;&lt;/code&gt;. There's a &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/script-loading/&quot;&gt;great article on Javascript loading in general&lt;/a&gt; which discusses this.</source>
          <target state="translated">DOMがロードされた後、またはその前に、ブラウザと、 &lt;code&gt;script.async = false;&lt;/code&gt; 行を含めたかどうかによって、スクリプトが実行される場合があることに注意してください。 。 これを説明&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/script-loading/&quot;&gt;する一般的なJavaScriptの読み込みに関する優れた記事&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="ff2891b93715f3f936e6b7d24ad6fad0a5319c90" translate="yes" xml:space="preserve">
          <source>Note that to get this working cross-domain, the server will need to set &lt;code&gt;allow-origin&lt;/code&gt; header in its response.</source>
          <target state="translated">この動作するクロスドメインを取得するには、サーバーが応答に &lt;code&gt;allow-origin&lt;/code&gt; ヘッダーを設定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f5f3eb8c4ce200ec467cdef1208486ed2b2ad0c8" translate="yes" xml:space="preserve">
          <source>Note: I'm not in any way affiliated with Mixture, other than using it as a front-end development tool. I came across this question upon seeing a &lt;code&gt;.mix&lt;/code&gt; JavaScript file in action (in one of the Mixture boilerplates) and being a bit confused by it (&quot;you can do this?&quot; I thought to myself). Then I realized that it was an application-specific file type (somewhat disappointing, agreed). Nevertheless, figured the knowledge might be helpful for others.</source>
          <target state="translated">注：フロントエンド開発ツールとして使用する以外は、私はMixtureとは一切関係ありません。 &lt;code&gt;.mix&lt;/code&gt; JavaScriptファイルが（Mixtureボイラープレートの1つで）動作しているのを見て、少し混乱している（「これは可能ですか？」と私は思った）ときにこの質問に出くわしました。 それから、それはアプリケーション固有のファイルタイプであることに気付きました（やや残念、同意しました）。 それにもかかわらず、知識は他の人に役立つかもしれないと考えました。</target>
        </trans-unit>
        <trans-unit id="d5361b0d202b75a326b27f5abc5966b30b92c5ab" translate="yes" xml:space="preserve">
          <source>Now we can run the compiler:</source>
          <target state="translated">これでコンパイラを実行できるようになりました。</target>
        </trans-unit>
        <trans-unit id="be1e395612e56b219495a2511f226e4a6bbad566" translate="yes" xml:space="preserve">
          <source>Now, there is a big issue you must know about. Doing that implies that &lt;em&gt;you remotely load the code&lt;/em&gt;. Modern web browsers will load the file and keep executing your current script because they load everything asynchronously to improve performance. (This applies to both the jQuery method and the manual dynamic script loading method.)</source>
          <target state="translated">今、あなたが知っておくべき大きな問題があります。 これは&lt;em&gt;、リモートでコードをロード&lt;/em&gt;することを意味し&lt;em&gt;ます&lt;/em&gt; 。 最新のWebブラウザーはすべてを非同期でロードしてパフォーマンスを向上させるため、ファイルをロードして現在のスクリプトを実行し続けます。 （これは、jQueryメソッドと手動の動的スクリプトロードメソッドの両方に適用されます。）</target>
        </trans-unit>
        <trans-unit id="f6aec98cb390ce572d475ac294a8779bcdd59d39" translate="yes" xml:space="preserve">
          <source>On the jQuery master branch, they simply concatenate atomic source files into a single one starting with &lt;code&gt;intro.js&lt;/code&gt; and ending with &lt;code&gt;outtro.js&lt;/code&gt;. That doesn't suits me as it provides no flexibility on the source code design. Check out how it works with jsic:</source>
          <target state="translated">jQueryマスターブランチでは、アトミックソースファイルを &lt;code&gt;intro.js&lt;/code&gt; で始まりoutout.jsで終わる単一のソースファイルに単純に連結します。 ソースコードの設計に柔軟性がないため、これは私には適していません。 jsicでどのように機能するかを確認してください。</target>
        </trans-unit>
        <trans-unit id="35244510a0932d71a1e33c185ed4d3632c86c351" translate="yes" xml:space="preserve">
          <source>Or rather than including at run time, use a script to concatenate prior to upload.</source>
          <target state="translated">あるいは、実行時にインクルードするのではなく、アップロード前にスクリプトを使用して連結します。</target>
        </trans-unit>
        <trans-unit id="ae55d21513645c5d75d2af23ca6c677b65dcc82d" translate="yes" xml:space="preserve">
          <source>Read more at &lt;a href=&quot;https://developers.google.com/web/updates/2017/11/dynamic-import&quot;&gt;https://developers.google.com/web/updates/2017/11/dynamic-import&lt;/a&gt;</source>
          <target state="translated">詳しくは&lt;a href=&quot;https://developers.google.com/web/updates/2017/11/dynamic-import&quot;&gt;https://developers.google.com/web/updates/2017/11/dynamic-importをご覧ください&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0fdf3837508857a07cdb1bf94cb244b7d21a5aae" translate="yes" xml:space="preserve">
          <source>Read more at &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;https://jakearchibald.com/2017/es-modules-in-browsers/&lt;/a&gt;</source>
          <target state="translated">詳しくは&lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;https://jakearchibald.com/2017/es-modules-in-browsers/をご覧ください&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a2968690e7c23123fd7efc2f7e364afd5a86919" translate="yes" xml:space="preserve">
          <source>Refer to:</source>
          <target state="translated">を参照してください。</target>
        </trans-unit>
        <trans-unit id="5ad4ccb4e6c788c5d5198e149aa1d4af7b483a35" translate="yes" xml:space="preserve">
          <source>RequireJS loads plain JavaScript files as well as more defined
  modules. It is optimized for in-browser use, including in a Web
  Worker, but it can be used in other JavaScript environments, like
  Rhino and Node. It implements the Asynchronous Module API.</source>
          <target state="translated">RequireJSは、より定義されたモジュールと同様に、プレーンなJavaScriptファイルをロードします。これはWeb Workerを含むブラウザ内での使用に最適化されていますが、RhinoやNodeのような他のJavaScript環境でも使用することができます。これは非同期モジュールAPIを実装しています。</target>
        </trans-unit>
        <trans-unit id="efbb4b5102cbae7f42e744b6a9286fbaccd8f904" translate="yes" xml:space="preserve">
          <source>RequireJS uses plain script tags to load modules/files, so it should
  allow for easy debugging. It can be used simply to load existing
  JavaScript files, so &lt;strong&gt;you can add it to your existing project without
  having to re-write your JavaScript files.&lt;/strong&gt;</source>
          <target state="translated">RequireJSは、プレーンスクリプトタグを使用してモジュール/ファイルをロードするため、簡単にデバッグできるはずです。 これは単に既存のJavaScriptファイルをロードするため&lt;strong&gt;に使用できるため、JavaScriptファイルを書き直すことなく、既存のプロジェクトに追加できます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="71dc617a43ade90c11908db4d0f8e0e5ad86ab36" translate="yes" xml:space="preserve">
          <source>Set up a file called &quot;plugins.js&quot; (or extensions.js or whatever you want). Keep your plugin files together with that one master file.</source>
          <target state="translated">plugins.js」というファイルを設定します(拡張子.jsでも何でも構いません)。プラグインファイルはこのマスターファイルにまとめておきましょう。</target>
        </trans-unit>
        <trans-unit id="cb63b27c44e32458c090132cc30786386502db2f" translate="yes" xml:space="preserve">
          <source>So all you would need to do to import JavaScript is:</source>
          <target state="translated">なので、JavaScriptをインポートするために必要なのは</target>
        </trans-unit>
        <trans-unit id="50c7c7e6fbef7aa987cd88ab0ebe41cc1d7dfd86" translate="yes" xml:space="preserve">
          <source>So here is the compiler, &lt;a href=&quot;https://github.com/dsheiko/jsic&quot;&gt;https://github.com/dsheiko/jsic&lt;/a&gt;, which replaces &lt;code&gt;$import(&quot;file-path&quot;)&lt;/code&gt; with the requested file content securely. Here is the corresponding &lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; plugin: &lt;a href=&quot;https://github.com/dsheiko/grunt-jsic&quot;&gt;https://github.com/dsheiko/grunt-jsic&lt;/a&gt;.</source>
          <target state="translated">したがって、ここにコンパイラ&lt;a href=&quot;https://github.com/dsheiko/jsic&quot;&gt;https://github.com/dsheiko/jsicがあり&lt;/a&gt; 、これは &lt;code&gt;$import(&quot;file-path&quot;)&lt;/code&gt; を要求されたファイルコンテンツに安全に置き換えます。 対応する&lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt;プラグインは次のとおりです： &lt;a href=&quot;https://github.com/dsheiko/grunt-jsic&quot;&gt;https&lt;/a&gt; : //github.com/dsheiko/grunt-jsic 。</target>
        </trans-unit>
        <trans-unit id="207e16cd95f6cd938f21d26d90e229e30bc7c63b" translate="yes" xml:space="preserve">
          <source>So you don't have to rely upon any JavaScript framework nor do you have to explicitly make &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;Ajax&lt;/a&gt; calls.</source>
          <target state="translated">したがって、JavaScriptフレームワークに依存する必要も、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;Ajax&lt;/a&gt;呼び出しを明示的に行う必要もありません。</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="db6dad97ca62ef5d7f44d822ae7ada54d51ed9bf" translate="yes" xml:space="preserve">
          <source>Source Code Merge/Preprocessing</source>
          <target state="translated">ソース コード MergePreprocessing</target>
        </trans-unit>
        <trans-unit id="60c6c4d6b31992a793c66bd837c9c7497f32017e" translate="yes" xml:space="preserve">
          <source>Statement &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; is in ECMAScript 6.</source>
          <target state="translated">ステートメントの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;はECMAScript 6にあります。</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="8b1b78f01302f9f5124b19ec9053902f483cc415" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; library provides loading functionality &lt;a href=&quot;http://api.jquery.com/jQuery.getScript/&quot;&gt;in one line&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;ライブラリは&lt;a href=&quot;http://api.jquery.com/jQuery.getScript/&quot;&gt;、1行で&lt;/a&gt;読み込み機能を提供します。</target>
        </trans-unit>
        <trans-unit id="365cfa5fd770b6dc0769934f9dacef667879a63d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@import&lt;/code&gt; syntax for achieving CSS-like JavaScript importing is possible using a tool such as Mixture via their special &lt;code&gt;.mix&lt;/code&gt; file type (see &lt;a href=&quot;http://docs.mixture.io/preprocessors#mix&quot;&gt;here&lt;/a&gt;). I imagine the application simply uses one of the aforementioned methods interally, though I don't know.</source>
          <target state="translated">CSSのようなJavaScriptインポートを実現するための &lt;code&gt;@import&lt;/code&gt; 構文は、特別な &lt;code&gt;.mix&lt;/code&gt; ファイルタイプを介してMixtureなどのツールを使用して可能です（ &lt;a href=&quot;http://docs.mixture.io/preprocessors#mix&quot;&gt;ここを&lt;/a&gt;参照）。 私は知りませんが、アプリケーションは前述の方法の1つを内部的に使用するだけだと思います。</target>
        </trans-unit>
        <trans-unit id="c5e847bed7fd8f4657d461e7ff8a88bffa6bd775" translate="yes" xml:space="preserve">
          <source>The old versions of JavaScript had no import, include, or require, so many different approaches to this problem have been developed.</source>
          <target state="translated">古いバージョンのJavaScriptにはインポートもインクルードも要求もなかったため、この問題に対するさまざまなアプローチが開発されてきました。</target>
        </trans-unit>
        <trans-unit id="332a07b88f0fcf415b8555e25a5eeedebfe4cb0d" translate="yes" xml:space="preserve">
          <source>The older CJS module style, still widely used in Node.js, is the &lt;a href=&quot;https://nodejs.org/api/modules.html&quot;&gt;&lt;code&gt;module.exports&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; system.</source>
          <target state="translated">Node.jsでまだ広く使用されている古いCJSモジュールスタイルは、 &lt;a href=&quot;https://nodejs.org/api/modules.html&quot;&gt; &lt;code&gt;module.exports&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; systemです。</target>
        </trans-unit>
        <trans-unit id="3c64a3691275e516da071b56c9173a3a5745a171" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;$.getScript&lt;/code&gt; and really any other solution that requires a callback when loading is complete is that if you have multiple files that use it and depend on each other you no longer have a way to know when all scripts have been loaded (once they are nested in multiple files).</source>
          <target state="translated">&lt;code&gt;$.getScript&lt;/code&gt; の問題、およびロードの完了時にコールバックが必要な他のすべてのソリューションの問題は、それを使用し、相互に依存する複数のファイルがある場合、すべてのスクリプトがロードされたときを知る方法がなくなったことです（一度、それらは複数のファイルにネストされています）。</target>
        </trans-unit>
        <trans-unit id="e3df137a5e529bd9e98b8d075cf6b8ec8e6991ff" translate="yes" xml:space="preserve">
          <source>The reason why we look for the first &lt;code&gt;script&lt;/code&gt; element instead of &lt;code&gt;head&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; is because some browsers don't create one if missing, but we're guaranteed to have a &lt;code&gt;script&lt;/code&gt; element - this one. Read more at &lt;a href=&quot;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&quot;&gt;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;head&lt;/code&gt; や &lt;code&gt;body&lt;/code&gt; 代わりに最初の &lt;code&gt;script&lt;/code&gt; 要素を探すのは、一部のブラウザーでは欠落しても &lt;code&gt;script&lt;/code&gt; 要素が作成されないためですが、 スクリプト要素（この要素）があることが保証されています 。 詳細については、 &lt;a href=&quot;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&quot;&gt;http：//www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/をご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="82cf60f97f6c09707b8f19fab54ef5c1a0cb6287" translate="yes" xml:space="preserve">
          <source>The script can even reside on a different server. Furthermore, the browser evaluates the code. The &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag can be injected into either the web page &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;, or inserted just before the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">スクリプトは別のサーバーに置くこともできます。 さらに、ブラウザはコードを評価します。 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグは、Webページ &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; に挿入するか、終了 &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; タグの直前に挿入できます。</target>
        </trans-unit>
        <trans-unit id="cbf546d79de34ac91357b0003cf697e434471972" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;main.js&lt;/code&gt;:</source>
          <target state="translated">次に &lt;code&gt;main.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1a3dc8d9fecff4598af5823bdb8309740acf1198" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;main.mjs&lt;/code&gt;:</source>
          <target state="translated">次に &lt;code&gt;main.mjs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7cb5f212cd2a13edf49d3b9684dcfad659ee20ea" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;module.js&lt;/code&gt;:</source>
          <target state="translated">次に &lt;code&gt;module.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fea8eb87370a87b1e4d189a8d9e83a44e5c1f2cf" translate="yes" xml:space="preserve">
          <source>Then you reload the page hitting</source>
          <target state="translated">その後、ページをリロードして</target>
        </trans-unit>
        <trans-unit id="0672e4bde170e584fa2b6dc719a249509055bb38" translate="yes" xml:space="preserve">
          <source>Then you run all that:</source>
          <target state="translated">それから、すべてを実行してください。</target>
        </trans-unit>
        <trans-unit id="3b84e4c1da86765df25fe1104617e23cd6a3172e" translate="yes" xml:space="preserve">
          <source>Then you write the code you want to use AFTER the script is loaded in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda function&lt;/a&gt;:</source>
          <target state="translated">次に、スクリプトが&lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;ラムダ関数に&lt;/a&gt;読み込まれた後で、使用するコードを記述します。</target>
        </trans-unit>
        <trans-unit id="38c5068306243c5f0677ed35094b305a3aebfa48" translate="yes" xml:space="preserve">
          <source>There actually &lt;em&gt;is&lt;/em&gt; a way to load a JavaScript file &lt;em&gt;not&lt;/em&gt; asynchronously, so you could use the functions included in your newly loaded file right after loading it, and I think it works in all browsers.</source>
          <target state="translated">実際に&lt;em&gt;は&lt;/em&gt; 、JavaScriptファイル&lt;em&gt;を&lt;/em&gt;非同期で&lt;em&gt;はなく&lt;/em&gt;読み込む方法&lt;em&gt;が&lt;/em&gt;あるので、新しく読み込んだファイルに含まれている関数を、読み込んだ直後に使用でき、すべてのブラウザーで機能すると思います。</target>
        </trans-unit>
        <trans-unit id="d358c9da7c21739b51ad491587d2a2e4bbea8403" translate="yes" xml:space="preserve">
          <source>There are a lot of potential answers for this question. My answer is obviously based on a number of them. This is what I ended up with after reading through all the answers.</source>
          <target state="translated">この質問には多くの可能性のある答えがあります。私の答えは明らかにそれらのいくつかに基づいています。すべての答えを読んだ結果、私はこうなりました。</target>
        </trans-unit>
        <trans-unit id="44afba8e9b45daeb202787b573cfab4ecc933b89" translate="yes" xml:space="preserve">
          <source>There are other ways for JavaScript to include external JavaScript contents in browsers that do not require preprocessing.</source>
          <target state="translated">他にも、前処理を必要としないJavaScriptの外部コンテンツをブラウザに含める方法があります。</target>
        </trans-unit>
        <trans-unit id="775a00f31987b24b0b74ff2c37a582e1e13b8885" translate="yes" xml:space="preserve">
          <source>There are several ways to implement modules in Javascript, Here are the 2 most popular ones:</source>
          <target state="translated">Javascriptでモジュールを実装する方法はいくつかありますが、ここでは最も人気のある2つの方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="a509c35ddc3ed0ce500ef2c3f3e54fe40074c6be" translate="yes" xml:space="preserve">
          <source>There is a good news for you. Very soon you will be able to load JavaScript code easily. It will become a standard way of importing modules of JavaScript code and will be part of core JavaScript itself.</source>
          <target state="translated">あなたに良いニュースがあります。まもなく、JavaScriptのコードを簡単に読み込むことができるようになります。これは、JavaScriptコードのモジュールをインポートするための標準的な方法になり、コアJavaScript自体の一部になるでしょう。</target>
        </trans-unit>
        <trans-unit id="03917ccdd96f3286351548a9349f54699c873ece" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://headjs.com/&quot;&gt;Head.js&lt;/a&gt;. It is very easy to deal with:</source>
          <target state="translated">&lt;a href=&quot;http://headjs.com/&quot;&gt;Head.js&lt;/a&gt;もあります。 対処は非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="282a95668b3d184d0221e75ea9a0b317f15912d1" translate="yes" xml:space="preserve">
          <source>This function will add a new &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to the end of the head section of the page, where the &lt;code&gt;src&lt;/code&gt; attribute is set to the URL which is given to the function as the first parameter.</source>
          <target state="translated">この関数は、新しい &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグをページのヘッドセクションの最後に追加します &lt;code&gt;src&lt;/code&gt; 属性は、最初のパラメーターとして関数に指定されたURLに設定されます。</target>
        </trans-unit>
        <trans-unit id="aec69cae0df189fe5f15918931a93fbb19af37a4" translate="yes" xml:space="preserve">
          <source>This moduling system is used in NodeJS. You basically add your exports to an object which is called &lt;code&gt;module.exports&lt;/code&gt;. You then can access this object via a &lt;code&gt;require('modulePath')&lt;/code&gt;. Important here is to realize that these modules are being cached, so if you &lt;code&gt;require()&lt;/code&gt; a certain module twice it will return the already created module.</source>
          <target state="translated">この変調システムはNodeJSで使用されます。 基本的には、 &lt;code&gt;module.exports&lt;/code&gt; と呼ばれるオブジェクトにエクスポートを追加します。 その後、 &lt;code&gt;require('modulePath')&lt;/code&gt; を介してこのオブジェクトにアクセスできます。 ここで重要なのは、これらのモジュールがキャッシュされていることを理解することです。そのため、特定のモジュールを2回 &lt;code&gt;require()&lt;/code&gt; すると、作成済みのモジュールが返されます。</target>
        </trans-unit>
        <trans-unit id="8d141c73c6e84930879c36e1f775b68c2e49892c" translate="yes" xml:space="preserve">
          <source>This saved my day. I hope this helps.</source>
          <target state="translated">これは私の日を救ってくれた これが役に立つことを願っています。</target>
        </trans-unit>
        <trans-unit id="5fbb1a0423bef2cdcefbfb4471fd65f7883a8a93" translate="yes" xml:space="preserve">
          <source>This script will add a JavaScript file to the top of any other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">このスクリプトは、JavaScriptファイルを他の &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグの先頭に追加します。</target>
        </trans-unit>
        <trans-unit id="677f26183a09ed669f4cb588a041e322090571ba" translate="yes" xml:space="preserve">
          <source>This should do:</source>
          <target state="translated">これでいいんじゃないかな。</target>
        </trans-unit>
        <trans-unit id="1766b2907ae68f8084c4976da09f1789f75a93ee" translate="yes" xml:space="preserve">
          <source>Usage (Promise):</source>
          <target state="translated">使い方(プロミス)。</target>
        </trans-unit>
        <trans-unit id="eeba7483417f4c19d85bdb39a309d8abb9362c2d" translate="yes" xml:space="preserve">
          <source>Usage (async/await):</source>
          <target state="translated">使用法(asyncawait)。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="b2f9ce47657e324cce2b6d80e0c2f7518a08067a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.mjs&lt;/code&gt;, you'd have &lt;code&gt;module.mjs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.mjs&lt;/code&gt; を使用すると、 module.mjsができます。</target>
        </trans-unit>
        <trans-unit id="c3c8d0e74dd9558a24f0302ee206a7608218058e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; の使用：</target>
        </trans-unit>
        <trans-unit id="25836b321091437346e2f5dbe6de27871ab3c287" translate="yes" xml:space="preserve">
          <source>Well, you can use the hack the author suggests in the link I gave you. In summary, for people in a hurry, he uses an event to run a callback function when the script is loaded. So you can put all the code using the remote library in the callback function. For example:</source>
          <target state="translated">まあ、私があげたリンク先で著者が提案しているハックを使えばいいんですけどね。要約すると、急いでいる人のために、スクリプトが読み込まれたときにイベントを使ってコールバック関数を実行するというものです。なので、コールバック関数の中にリモートライブラリを使ったコードを全て入れればいいのです。例えば、以下のように。</target>
        </trans-unit>
        <trans-unit id="6bd3ad67628e2ce42d0075e4006bcb283c8372d6" translate="yes" xml:space="preserve">
          <source>When the additional files are loaded the &lt;code&gt;document.ready&lt;/code&gt; callbacks will get executed in the wrong order. To address this when a script is actually loaded, the script that imported it is re-imported itself and execution halted. This causes the originating file to now have its &lt;code&gt;document.ready&lt;/code&gt; callback executed after any from any scripts that it imports.</source>
          <target state="translated">追加のファイルがロードされると、 &lt;code&gt;document.ready&lt;/code&gt; コールバックが間違った順序で実行されます。 スクリプトが実際にロードされたときにこれに対処するために、スクリプトをインポートしたスクリプト自体が再インポートされ、実行が停止します。 これにより、元のファイルは、それがインポートするスクリプトから実行された後に &lt;code&gt;document.ready&lt;/code&gt; コールバックが実行されるようになります。</target>
        </trans-unit>
        <trans-unit id="9eea4e801ae6abd35d58a38d0d55c894879bbd27" translate="yes" xml:space="preserve">
          <source>You are right when you say that you could specify Ajax to run synchronously or use &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt;, but the current trend appears to be to deprecate synchronous requests, so you may not get full browser support now or in the future.</source>
          <target state="translated">Ajaxを同期的に実行するか&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequestを&lt;/a&gt;使用するように指定できると言ったのはあなたの言うとおりですが、現在の傾向は同期リクエストを非推奨にする傾向があるため、現在または将来、完全なブラウザーサポートが得られない可能性があります。</target>
        </trans-unit>
        <trans-unit id="41b688ca3fa05f1b8bf2b2c1390acf30888a6c1a" translate="yes" xml:space="preserve">
          <source>You can also assemble your scripts using &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;を使用してスクリプトをアセンブルすることもできます。</target>
        </trans-unit>
        <trans-unit id="b67289039b993bbae286ee78e5a38a9d7984d26f" translate="yes" xml:space="preserve">
          <source>You can of course use $ (&quot;body&quot;).append(), but then you can no longer debug correctly any more.</source>
          <target state="translated">もちろん $ (&quot;body&quot;).append()を使うこともできますが、そうするともう正しくデバッグできなくなってしまいます。</target>
        </trans-unit>
        <trans-unit id="261f53110fde11b3c98c44fc320c61440f8caf48" translate="yes" xml:space="preserve">
          <source>You can then use it in your code as you'd usually use an include:</source>
          <target state="translated">そして、通常インクルードを使用するようにコードの中でそれを使用することができます。</target>
        </trans-unit>
        <trans-unit id="763d2233f3f407809871ccf36da8867041eafddf" translate="yes" xml:space="preserve">
          <source>You can write your JavaScript files in &quot;modules&quot; and then reference them as dependencies in other scripts. Or you can use RequireJS as a simple &quot;go get this script&quot; solution.</source>
          <target state="translated">JavaScriptファイルを「モジュール」に書き、他のスクリプトの依存関係として参照することができます。あるいは、単純な「このスクリプトを取りに行く」ソリューションとして RequireJS を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="43fc4e4d3a473a2cd0549a65efd79e36b5e2afb7" translate="yes" xml:space="preserve">
          <source>You could add a script tag with the script URL into the HTML. To avoid the overhead of jQuery, this is an ideal solution.</source>
          <target state="translated">HTMLの中にスクリプトのURLが記載されたscriptタグを追加すればいいのです。jQueryのオーバーヘッドを避けるためには、これが理想的な解決策です。</target>
        </trans-unit>
        <trans-unit id="677229282757dc7a7d42af0f461340f88668361d" translate="yes" xml:space="preserve">
          <source>You could load an additional script with an AJAX call and then use &lt;code&gt;eval&lt;/code&gt; to run it. This is the most straightforward way, but it is limited to your domain because of the JavaScript sandbox security model. Using &lt;code&gt;eval&lt;/code&gt; also opens the door to bugs, hacks and security issues.</source>
          <target state="translated">AJAX呼び出しで追加のスクリプトをロードし、 &lt;code&gt;eval&lt;/code&gt; を使用してそれを実行できます。 これは最も簡単な方法ですが、JavaScriptサンドボックスセキュリティモデルのため、ドメインに限定されます。 &lt;code&gt;eval&lt;/code&gt; を使用すると、バグ、ハッキング、セキュリティの問題への扉も開きます。</target>
        </trans-unit>
        <trans-unit id="740e8e133fe6283f4bf17af1eb127c00965480b1" translate="yes" xml:space="preserve">
          <source>You could try to use &lt;code&gt;$.when&lt;/code&gt; to check an array of deferred objects, but now you are doing this in every file and file2 will be considered loaded as soon as the &lt;code&gt;$.when&lt;/code&gt; is executed not when the callback is executed, so file1 still continues execution before file3 is loaded. This really still has the same problem.</source>
          <target state="translated">&lt;code&gt;$.when&lt;/code&gt; を使用して据え置きオブジェクトの配列をチェックすることもできますが、これをすべてのファイルで実行すると、コールバックが実行されたときではなく、 &lt;code&gt;$.when&lt;/code&gt; が実行されるとすぐにfile2がロードされたと見なされるため、file1はまだfile3がロードされる前に実行を継続します。 これにはまだ同じ問題があります。</target>
        </trans-unit>
        <trans-unit id="ac49dc35cec96359223a55198aee1ea6a7723105" translate="yes" xml:space="preserve">
          <source>You just need to be careful when you are including scripts in an HTML file. The order should be as in below:</source>
          <target state="translated">ただ、HTMLファイルの中にスクリプトを含める場合は注意が必要です。順番は以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="44f152a3a2ff3ec5b145516a70206e4b37c0738c" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;jQuery.append()&lt;/code&gt; on the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; element of your page, that is:</source>
          <target state="translated">ページの &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 要素で &lt;code&gt;jQuery.append()&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4ad6f53621aa3d1faf240c9a38a76a34ecb3ac9f" translate="yes" xml:space="preserve">
          <source>You simply have to write &lt;code&gt;import cond from 'cond.js';&lt;/code&gt; to load a macro named &lt;code&gt;cond&lt;/code&gt; from a file &lt;code&gt;cond.js&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import cond from 'cond.js';&lt;/code&gt; を記述するだけです。 &lt;code&gt;cond&lt;/code&gt; という名前のマクロをファイル &lt;code&gt;cond.js&lt;/code&gt; からロードします。</target>
        </trans-unit>
        <trans-unit id="d9c029655932b5efd739f546d5b2cb4eaadd323a" translate="yes" xml:space="preserve">
          <source>file1.js</source>
          <target state="translated">file1.js</target>
        </trans-unit>
        <trans-unit id="a2bf4c98312f67688bf14bf9ed30d02aa9d4ca8d" translate="yes" xml:space="preserve">
          <source>file1.js:</source>
          <target state="translated">file1.js:</target>
        </trans-unit>
        <trans-unit id="d14c0cdfc2b81349332a20275d4e5388ced355bc" translate="yes" xml:space="preserve">
          <source>file2.js</source>
          <target state="translated">file2.js</target>
        </trans-unit>
        <trans-unit id="03a0f7a91e0893577595163e3fac51c418880f93" translate="yes" xml:space="preserve">
          <source>file2.js:</source>
          <target state="translated">file2.js:</target>
        </trans-unit>
        <trans-unit id="9eb542476d35d6e35c8f124ac5e963ed9e1f9a2e" translate="yes" xml:space="preserve">
          <source>file3.js</source>
          <target state="translated">file3.js</target>
        </trans-unit>
        <trans-unit id="a7eac0c8dd40160a0c46c08bdfaf13d11b629316" translate="yes" xml:space="preserve">
          <source>global.js</source>
          <target state="translated">global.js</target>
        </trans-unit>
        <trans-unit id="0f4ed54c5010ce0a22e2398e6e747b8624d5114e" translate="yes" xml:space="preserve">
          <source>jQuery Loading</source>
          <target state="translated">jQueryの読み込み</target>
        </trans-unit>
        <trans-unit id="c4a4248f7568c9e41265502c39b0daeb8b635431" translate="yes" xml:space="preserve">
          <source>main.js</source>
          <target state="translated">main.js</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="e8775485c8f1802e0ec89012c9e0a431dd135b78" translate="yes" xml:space="preserve">
          <source>plugins.js will have an array called &lt;code&gt;pluginNames[]&lt;/code&gt; that we will iterate over &lt;code&gt;each()&lt;/code&gt;,
then append a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to the head for each plugin</source>
          <target state="translated">plugins.jsには、 &lt;code&gt;pluginNames[]&lt;/code&gt; と呼ばれる配列があり、 &lt;code&gt;each()&lt;/code&gt; を反復処理してから、各プラグインのヘッドに &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを追加します</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
