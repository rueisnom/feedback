<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/950087">
    <body>
      <group id="950087">
        <trans-unit id="206ab3d9bec48efae73640429f4d8678f64506e9" translate="yes" xml:space="preserve">
          <source>(This answer is in response to e-satis' comment).</source>
          <target state="translated">(此回答是对e-satis' 的评论的回应)。</target>
        </trans-unit>
        <trans-unit id="c2f82e6af2dc551c77d47d4e59e40a67261ca803" translate="yes" xml:space="preserve">
          <source>. And it works! Confusing...</source>
          <target state="translated">.而且它还能用!令人困惑.....</target>
        </trans-unit>
        <trans-unit id="6eae3a5b062c6d0d79f070c26e6d62486b40cb46" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>
        </trans-unit>
        <trans-unit id="56462b98ec98df96345ec73222abd51331f6a57f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://37signals.com/svn/posts/1587-introducing-sprockets-javascript-dependency-management-and-concatenation&quot;&gt;Introducing Sprockets: JavaScript dependency management and concatenation&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://37signals.com/svn/posts/1587-introducing-sprockets-javascript-dependency-management-and-concatenation&quot;&gt;Sprockets简介：JavaScript依赖关系管理和串联&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c32de899cfb6ec06e8cc06f8e5e9f40a37e92d7c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://calculist.org/blog/2012/06/29/static-module-resolution/&quot;&gt;Static module resolution&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://calculist.org/blog/2012/06/29/static-module-resolution/&quot;&gt;静态模块分辨率&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2762c6431432dd5a70cecfb315f7619966f378a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders&quot;&gt;Module loaders&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders&quot;&gt;模块装载机&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="788fd7a0f4e090824b273e7120114e5c5cbd91d5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;build/main.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;build/main.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6f6bff257cd31d0764b92815c9b9d17e8f561e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;src/Form/Input/Tel.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;src/Form/Input/Tel.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca9ca5e0a3691e6d44f125996c50847fbf836c5c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;src/main.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;src/main.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6a16d8f75b54b1f1f0b21d8ce61fc11b0bba33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CommonJS&lt;/strong&gt; (used in NodeJS)</source>
          <target state="translated">&lt;strong&gt;CommonJS&lt;/strong&gt; （在NodeJS中使用）</target>
        </trans-unit>
        <trans-unit id="7290c866af5b8bcecf5045b72e9fd6779df65827" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Modules&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6模块&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bebe38df96c7eb3f3282665cee82c64c21884191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what to do about it ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;那么该怎么办呢？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fcc0aa2abc91d9c0d481b93b0bba6fbd9423c59b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: Mixture is &lt;a href=&quot;http://mixture.io/blog/free/&quot;&gt;now free&lt;/a&gt; (offline).</source>
          <target state="translated">&lt;strong&gt;更新&lt;/strong&gt; ：混合物&lt;a href=&quot;http://mixture.io/blog/free/&quot;&gt;现在免费&lt;/a&gt; （脱机）。</target>
        </trans-unit>
        <trans-unit id="53d014567827ce6d8ba81376d4cbf9262511230d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: Mixture is now discontinued. &lt;a href=&quot;https://github.com/teammixture/mixture.io/issues/6&quot;&gt;Old mixture releases&lt;/a&gt; are still available</source>
          <target state="translated">&lt;strong&gt;更新&lt;/strong&gt; ：混合物现已停产。 &lt;a href=&quot;https://github.com/teammixture/mixture.io/issues/6&quot;&gt;旧的混合物版本&lt;/a&gt;仍然可用</target>
        </trans-unit>
        <trans-unit id="f8d6e8d151ca82b2e0671602d8c89392168b089a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;implementation.js&lt;/strong&gt; is your &quot;main&quot; JavaScript file that depends on &lt;strong&gt;some-dependency.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Implementation.js&lt;/strong&gt;是您的&amp;ldquo;主要&amp;rdquo; JavaScript文件，它取决于&lt;strong&gt;some-dependency.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e090dd13b65625719872427d2c45c23e507646c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;some-dependency.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;some-dependency.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00d49aecf61eefacf881c76b0da44cb61b90c3b6" translate="yes" xml:space="preserve">
          <source>AJAX Loading</source>
          <target state="translated">AJAX加载</target>
        </trans-unit>
        <trans-unit id="a858f45b0cd86a8d053c47aed5612e8df1b50a0b" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;https://stackoverflow.com/a/10939737/1676444&quot;&gt;as the second highest voted answer to your question highlights&lt;/a&gt;, &lt;a href=&quot;http://www.requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; can also handle including scripts inside a Web Worker (likely calling &lt;code&gt;importScripts&lt;/code&gt; itself, but with a few other useful features).</source>
          <target state="translated">或者， &lt;a href=&quot;https://stackoverflow.com/a/10939737/1676444&quot;&gt;作为对您的问题的第二高投票答案&lt;/a&gt; ， &lt;a href=&quot;http://www.requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;还可以处理Web Worker中包含的脚本（可能调用 &lt;code&gt;importScripts&lt;/code&gt; 本身，但还具有其他一些有用的功能）。</target>
        </trans-unit>
        <trans-unit id="104bb6fccb3dd88007fd041a6caf1caa570d887e" translate="yes" xml:space="preserve">
          <source>Although these answers are great, there is a simple &quot;solution&quot; that has been around since script loading existed, and it will cover 99.999% of most people's use cases. Just include the script you need before the script that requires it. For most projects it does not take long to determine which scripts are needed and in what order.</source>
          <target state="translated">虽然这些答案都很好,但有一个简单的 &quot;解决方案&quot;,从脚本加载存在的时候就已经出现了,它可以覆盖大部分人的用例的99.999%。只需要在需要的脚本之前包含你需要的脚本就可以了。对于大多数项目来说,不需要花很长时间就能确定哪些脚本是需要的,按照什么顺序来做。</target>
        </trans-unit>
        <trans-unit id="b50f51a682a21ea87eb5831332387ee8e672513c" translate="yes" xml:space="preserve">
          <source>And be able to call a function from the required script in the next line:</source>
          <target state="translated">并能够在下一行中调用所需的脚本中的函数。</target>
        </trans-unit>
        <trans-unit id="883eb03a9cdc193322e4ba0c284e4929b617cd9b" translate="yes" xml:space="preserve">
          <source>And get the combined file</source>
          <target state="translated">并获得合并后的文件</target>
        </trans-unit>
        <trans-unit id="26312a853a8a0fed6d13295ff03f0dca11974071" translate="yes" xml:space="preserve">
          <source>And right after including &lt;code&gt;included.js&lt;/code&gt;, the &lt;code&gt;hello()&lt;/code&gt; function is called, and you get the alert.</source>
          <target state="translated">在包含 &lt;code&gt;included.js&lt;/code&gt; 之后 ，立即调用 &lt;code&gt;hello()&lt;/code&gt; 函数，您将收到警报。</target>
        </trans-unit>
        <trans-unit id="f13e6a18a32be72735a2f247839504b514c2563c" translate="yes" xml:space="preserve">
          <source>Another way, that in my opinion is much cleaner, is to make a synchronous Ajax request instead of using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. Which is also how &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; handles includes.</source>
          <target state="translated">在我看来，更简洁的另一种方法是发出同步Ajax请求，而不使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt;处理的内容也包括在内。</target>
        </trans-unit>
        <trans-unit id="f421ce52a3901e83133ea470faef7ae69fc93013" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this answer, many developers use build/transpilation tool(s) like Parcel, Webpack, or Babel in their projects, allowing them to use upcoming JavaScript syntax, provide backward compatibility for older browsers, combine files, minify, perform code splitting etc.</source>
          <target state="translated">正如本答案顶部提到的,许多开发者在他们的项目中使用了像Parcel、Webpack或Babel这样的buildtranspilation工具,允许他们使用即将到来的JavaScript语法,为旧的浏览器提供向后兼容,合并文件,最小化,执行代码拆分等。</target>
        </trans-unit>
        <trans-unit id="949b1e33e3a590719f723351553af804e4929438" translate="yes" xml:space="preserve">
          <source>As you saw, I had use a variable in one JavaScript file in another JavaScript file, but I didn't need to include one in another. I just needed to ensure that the first JavaScript file loaded before the second JavaScript file, and, the first JavaScript file's variables are accessible in the second JavaScript file, automatically.</source>
          <target state="translated">正如你所看到的,我在另一个JavaScript文件中使用了一个JavaScript文件中的变量,但我不需要在另一个JavaScript文件中包含一个变量。我只需要确保第一个JavaScript文件在第二个JavaScript文件之前加载,并且,第一个JavaScript文件的变量可以在第二个JavaScript文件中自动访问。</target>
        </trans-unit>
        <trans-unit id="277120e489ec4b95e6dd7c32060d43032d9152c8" translate="yes" xml:space="preserve">
          <source>As you see, it's easier than Require.js and as convenient as jQuery's &lt;code&gt;$.getScript&lt;/code&gt; method. It also has some advanced features, like conditional loading, feature detection and &lt;a href=&quot;http://headjs.com/site/api/v1.00.html&quot;&gt;much more&lt;/a&gt;.</source>
          <target state="translated">如您所见，它比Require.js更容易，并且与jQuery的 &lt;code&gt;$.getScript&lt;/code&gt; 方法一样方便。 它还具有一些高级功能，例如条件加载，功能检测等。</target>
        </trans-unit>
        <trans-unit id="198f9d81f71210a4fe6ffba57567675fdb5e650b" translate="yes" xml:space="preserve">
          <source>BUT:</source>
          <target state="translated">BUT:</target>
        </trans-unit>
        <trans-unit id="2314410b2adc404dde335bb42725bcc7fd26563a" translate="yes" xml:space="preserve">
          <source>Before calling &lt;code&gt;document.writeln&lt;/code&gt;, it checks to make sure the script has not already been loading by evaluating all the script elements.</source>
          <target state="translated">在调用 &lt;code&gt;document.writeln&lt;/code&gt; 之前，它将通过评估所有脚本元素来检查以确保尚未加载脚本。</target>
        </trans-unit>
        <trans-unit id="2816ea2652eecdb35254f7a8a62138f40ae37f28" translate="yes" xml:space="preserve">
          <source>Both of these solutions are discussed and illustrated in &lt;a href=&quot;http://unixpapa.com/js/dyna.html&quot;&gt;JavaScript Madness: Dynamic Script Loading&lt;/a&gt;.</source>
          <target state="translated">《 &lt;a href=&quot;http://unixpapa.com/js/dyna.html&quot;&gt;JavaScript Madness：动态脚本加载》&lt;/a&gt;中讨论和说明了这两种解决方案。</target>
        </trans-unit>
        <trans-unit id="caabcacc0f9cf84e44c7d32424a5dc4629a4c721" translate="yes" xml:space="preserve">
          <source>Browsers do not support this moduling system yet so in order for you to use this syntax you must use a bundler like webpack. Using a bundler is better anyway because this can combine all of your different files into a single (or couple related) files. This will serve the files from the server to the client faster because each HTTP request has some associated overhead accompanied with it. Thus by reducing the overal HTTP request we improve the performance. Here is an example of ES6 modules:</source>
          <target state="translated">浏览器还不支持这个修改系统,所以为了让你使用这个语法,你必须使用像webpack这样的捆绑器。无论如何,使用捆绑器会更好,因为它可以将所有不同的文件组合成一个(或几个相关的)文件。这样可以更快地将文件从服务器上服务到客户端,因为每个HTTP请求都有一些相关的开销。因此,通过减少HTTP请求的开销,我们可以提高性能。下面是一个ES6模块的例子。</target>
        </trans-unit>
        <trans-unit id="b337cd4902acd58b0de99a8784fe0ca89f41d186" translate="yes" xml:space="preserve">
          <source>Browsers have had support for loading ECMAScript modules directly (no tools like Webpack required) &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;since&lt;/a&gt; Safari 10.1, Chrome 61, Firefox 60, and Edge 16. Check the current support at &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;caniuse&lt;/a&gt;. There is no need to use Node.js' &lt;code&gt;.mjs&lt;/code&gt; extension; browsers completely ignore file extensions on modules/scripts.</source>
          <target state="translated">&lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;自&lt;/a&gt; Safari 10.1，Chrome 61，Firefox 60和Edge 16开始，浏览器已经支持直接加载ECMAScript模块（不需要像Webpack这样的工具）。请在&lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;caniuse上&lt;/a&gt;查看当前支持。 无需使用Node.js的 &lt;code&gt;.mjs&lt;/code&gt; 扩展名； 浏览器完全忽略模块/脚本上的文件扩展名。</target>
        </trans-unit>
        <trans-unit id="522ce0fcef4ca6aef8ba20db065f82588818d7ac" translate="yes" xml:space="preserve">
          <source>But if that is not a problem for you, then this method should work.</source>
          <target state="translated">但如果这对你来说不是问题,那么这个方法应该是可行的。</target>
        </trans-unit>
        <trans-unit id="1bbb812967de17c1fec9aa4b70a28049b6474a4a" translate="yes" xml:space="preserve">
          <source>But since 2015 (ES6), JavaScript has had the &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES6 modules&lt;/a&gt; standard to import modules in Node.js, which is also supported by &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;most modern browsers&lt;/a&gt;.</source>
          <target state="translated">但是自2015年（ES6）起，JavaScript有了&lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES6模块&lt;/a&gt;标准即可在Node.js中导入模块， &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;大多数现代浏览器&lt;/a&gt;也支持该模块。</target>
        </trans-unit>
        <trans-unit id="5df356af95c22125fad799a05f636daf7b8b6f4f" translate="yes" xml:space="preserve">
          <source>Define dependencies as modules:</source>
          <target state="translated">将依赖项定义为模块。</target>
        </trans-unit>
        <trans-unit id="efb211ea4156611a7cf5952316e1ba2fb95ae811" translate="yes" xml:space="preserve">
          <source>Detecting when the script has been executed</source>
          <target state="translated">检测脚本何时被执行</target>
        </trans-unit>
        <trans-unit id="e8e7c59c81ba090cb40a7e03782de9db506696ec" translate="yes" xml:space="preserve">
          <source>Dynamic Script Loading</source>
          <target state="translated">动态脚本加载</target>
        </trans-unit>
        <trans-unit id="386cf3c6e6b0464ad5cbc22efde8538c6548eced" translate="yes" xml:space="preserve">
          <source>Dynamic imports in browsers</source>
          <target state="translated">浏览器中的动态导入</target>
        </trans-unit>
        <trans-unit id="d9d3d46b339478880eb52f7f9c0e16f1cb5a0500" translate="yes" xml:space="preserve">
          <source>Dynamic imports let the script load other scripts as needed:</source>
          <target state="translated">动态导入,让脚本根据需要加载其他脚本。</target>
        </trans-unit>
        <trans-unit id="d388c8604db3813ddb87de2fb1c3f60be9f8222a" translate="yes" xml:space="preserve">
          <source>ECMAScript (ES6) modules have been &lt;a href=&quot;https://nodejs.org/api/esm.html&quot;&gt;supported in Node.js&lt;/a&gt; since v8.5, with the &lt;code&gt;--experimental-modules&lt;/code&gt; flag, and since at least Node.js v13.8.0 without the flag. To enable &quot;ESM&quot; (vs. Node.js's previous CommonJS-style module system [&quot;CJS&quot;]) you either use &lt;code&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt; in &lt;code&gt;package.json&lt;/code&gt; or give the files the extension &lt;code&gt;.mjs&lt;/code&gt;. (Similarly, modules written with Node.js's previous CJS module can be named &lt;code&gt;.cjs&lt;/code&gt; if your default is ESM.)</source>
          <target state="translated">从v8.5开始，带有 &lt;code&gt;--experimental-modules&lt;/code&gt; 标志的&lt;a href=&quot;https://nodejs.org/api/esm.html&quot;&gt;Node.js支持&lt;/a&gt; ECMAScript（ES6）模块，并且至少从不带有标志的Node.js v13.8.0开始支持 ECMAScript（ES6）模块。 要启用&amp;ldquo; ESM&amp;rdquo;（相对于Node.js先前的CommonJS样式的模块系统[&amp;ldquo; CJS&amp;rdquo;]），您可以在 &lt;code&gt;package.json&lt;/code&gt; 中使用 &lt;code&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt; 或给文件扩展名 &lt;code&gt;.mjs&lt;/code&gt; 。 （类似地，如果您的默认值为ESM，则用Node.js先前的CJS模块编写的模块可以命名为 &lt;code&gt;.cjs&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="1ec6cc0d49bcb01cd50cba9ddb3ed7b2944cb238" translate="yes" xml:space="preserve">
          <source>ECMAScript modules in browsers</source>
          <target state="translated">浏览器中的ECMAScript模块</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6模块</target>
        </trans-unit>
        <trans-unit id="78859e0aa530ac3119a27bb18cf0fc2aeb91ad89" translate="yes" xml:space="preserve">
          <source>Even though all of the plugins get dropped into the head tag the way they ought to, they don't always get run by the browser when you click into the page or refresh.</source>
          <target state="translated">尽管所有的插件都会按照它们应该的方式被放到头部标签中,但当你点击进入页面或刷新时,它们并不总是被浏览器运行。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="b4136dcf903eb3c76fe317c65ef053453e8cdc32" translate="yes" xml:space="preserve">
          <source>Excerpt from the &lt;a href=&quot;https://github.com/jrburke/requirejs&quot;&gt;GitHub&lt;/a&gt; README:</source>
          <target state="translated">摘自&lt;a href=&quot;https://github.com/jrburke/requirejs&quot;&gt;GitHub&lt;/a&gt;自述文件：</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="b5cbd3434bd596109a8781b509798ab1da4452a6" translate="yes" xml:space="preserve">
          <source>F5</source>
          <target state="translated">F5</target>
        </trans-unit>
        <trans-unit id="94716db44426788000dfcbae9cba45638f7cc496" translate="yes" xml:space="preserve">
          <source>Fetch Loading</source>
          <target state="translated">获取加载</target>
        </trans-unit>
        <trans-unit id="52af92858e80319c3e320b7210c45af2d1252260" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;main.js.php&lt;/code&gt;:</source>
          <target state="translated">文件 &lt;code&gt;main.js.php&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="97e1664caa79aa71082bd60226618665682535d9" translate="yes" xml:space="preserve">
          <source>File1:</source>
          <target state="translated">File1:</target>
        </trans-unit>
        <trans-unit id="730fd0522d514826c9aaf7d211a195d36c9b867d" translate="yes" xml:space="preserve">
          <source>File2:</source>
          <target state="translated">File2:</target>
        </trans-unit>
        <trans-unit id="2e8382e08c9bb01c7e1654bd24c7e7f77f55dbf0" translate="yes" xml:space="preserve">
          <source>File3:</source>
          <target state="translated">File3:</target>
        </trans-unit>
        <trans-unit id="775ecf6ee49f69f0ed328c8af1660730b48d6a2e" translate="yes" xml:space="preserve">
          <source>File: main.js</source>
          <target state="translated">文件:main.js</target>
        </trans-unit>
        <trans-unit id="fed8f02dc3fd97daef37a09c9513fac304867fe6" translate="yes" xml:space="preserve">
          <source>File: myvariables.js</source>
          <target state="translated">文件:myvariables.js</target>
        </trans-unit>
        <trans-unit id="f973768795a937dcadac26fc7473d3746b5da826" translate="yes" xml:space="preserve">
          <source>For compatibility with older browsers, build tools like &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; and/or transpilation tools like &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; can be used.</source>
          <target state="translated">为了与旧版浏览器兼容，可以使用&lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;和&lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt;等构建工具和/或Babel等编译工具。</target>
        </trans-unit>
        <trans-unit id="1f2147bfcc0f0f7c3cef6200f4753cf79500f046" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;my_lovely_script.js&lt;/code&gt; contains &lt;code&gt;MySuperObject&lt;/code&gt;:</source>
          <target state="translated">例如： &lt;code&gt;my_lovely_script.js&lt;/code&gt; 包含 &lt;code&gt;MySuperObject&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="759d7f8d0ebbe76c3a7b37e810db7f723123b25b" translate="yes" xml:space="preserve">
          <source>For this I did as below:</source>
          <target state="translated">对此,我的做法如下。</target>
        </trans-unit>
        <trans-unit id="34a3ad15283216601c4c7025cdfabd88fdbb3275" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries&quot;&gt;Web Workers have their own &lt;code&gt;importScripts&lt;/code&gt; function&lt;/a&gt; which is a global function in the scope of the Web Worker, native to the browser itself as it &lt;a href=&quot;https://html.spec.whatwg.org/multipage/workers.html#importing-scripts-and-libraries&quot;&gt;is part of the specification&lt;/a&gt;.</source>
          <target state="translated">幸运的是， &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries&quot;&gt;Web Workers拥有自己的 &lt;code&gt;importScripts&lt;/code&gt; 函数&lt;/a&gt; ，该函数是Web Workers范围内的全局函数，它&lt;a href=&quot;https://html.spec.whatwg.org/multipage/workers.html#importing-scripts-and-libraries&quot;&gt;是&lt;/a&gt;浏览器本身的固有特性，因为它是规范的一部分 。</target>
        </trans-unit>
        <trans-unit id="67960c2c77f8b866584719b8e48c2e8eda27e92f" translate="yes" xml:space="preserve">
          <source>From the Mixture documentation on &lt;code&gt;.mix&lt;/code&gt; files:</source>
          <target state="translated">从 &lt;code&gt;.mix&lt;/code&gt; 文件的Mixture文档中：</target>
        </trans-unit>
        <trans-unit id="43906746944eafb56d9523b37e70f7bd285ad8e4" translate="yes" xml:space="preserve">
          <source>Gist: &lt;a href=&quot;http://gist.github.com/284442&quot;&gt;http://gist.github.com/284442&lt;/a&gt;.</source>
          <target state="translated">要点： &lt;a href=&quot;http://gist.github.com/284442&quot;&gt;http&lt;/a&gt; : //gist.github.com/284442 。</target>
        </trans-unit>
        <trans-unit id="c973140512dda715ec8b98cd19e4abc17e64227e" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;synchronous&lt;/strong&gt; version &lt;strong&gt;without jQuery&lt;/strong&gt;:</source>
          <target state="translated">这是&lt;strong&gt;没有jQuery&lt;/strong&gt;的&lt;strong&gt;同步&lt;/strong&gt;版本：</target>
        </trans-unit>
        <trans-unit id="24b79cca1f32a4977bb54091e81e918ad5543042" translate="yes" xml:space="preserve">
          <source>Here is an example of how this could work:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="c836ed859d15dd35abf3de4024c47570ffc40a21" translate="yes" xml:space="preserve">
          <source>Here's an example &lt;code&gt;.mix&lt;/code&gt; file that combines multiple &lt;code&gt;.js&lt;/code&gt; files into one:</source>
          <target state="translated">这是一个示例 &lt;code&gt;.mix&lt;/code&gt; 文件，它将多个 &lt;code&gt;.js&lt;/code&gt; 文件合并为一个：</target>
        </trans-unit>
        <trans-unit id="a0a735f6041355a8e31634a70ac885a99ea8fc46" translate="yes" xml:space="preserve">
          <source>Here's an example using jQuery:</source>
          <target state="translated">下面是一个使用jQuery的例子。</target>
        </trans-unit>
        <trans-unit id="3d4d50089b78caa8accdb20b9de1e3e36a7c71dd" translate="yes" xml:space="preserve">
          <source>Here's an explanation of how the code works for those that are curious: essentially, it creates a new script tag (after the first one) of the URL. It sets it to asynchronous mode so it doesn't block the rest of the code, but calls a callback when the readyState (the state of the content to be loaded) changes to 'loaded'.</source>
          <target state="translated">下面是对这段代码的工作原理的解释,对于那些好奇的人来说:本质上,它创建了一个新的脚本标签(在第一个标签之后)的URL。它将其设置为异步模式,所以它不会阻止其余的代码,但当readyState(要加载的内容的状态)变为 &quot;load &quot;时,会调用一个回调。</target>
        </trans-unit>
        <trans-unit id="687874dfffbfcb582922598a2058fbf71cfb4713" translate="yes" xml:space="preserve">
          <source>Here's the generalized version of how Facebook does it for their ubiquitous Like button:</source>
          <target state="translated">以下是Facebook对其无处不在的Like按钮的通用版本。</target>
        </trans-unit>
        <trans-unit id="512061e76228d02949b902d49c6ed3f12388bcca" translate="yes" xml:space="preserve">
          <source>How do I include a JavaScript file in another JavaScript file</source>
          <target state="translated">我如何在另一个JavaScript文件中包含一个JavaScript文件?</target>
        </trans-unit>
        <trans-unit id="f534ee42b1b1417c1c4328067f9e323c71e4cd19" translate="yes" xml:space="preserve">
          <source>However, this method also has a problem: if an error happens in the imported JavaScript file, &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; (and also Firefox Error Console and &lt;a href=&quot;https://developers.google.com/chrome-developer-tools/&quot;&gt;Chrome Developer Tools&lt;/a&gt; as well) will report its place incorrectly, which is a big problem if you use Firebug to track JavaScript errors down a lot (I do). Firebug simply doesn't know about the newly loaded file for some reason, so if an error occurs in that file, it reports that it occurred in your main &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; file, and you will have trouble finding out the real reason for the error.</source>
          <target state="translated">但是，此方法也有一个问题：如果在导入的JavaScript文件中发生错误，则&lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; （以及Firefox错误控制台和&lt;a href=&quot;https://developers.google.com/chrome-developer-tools/&quot;&gt;Chrome开发者工具&lt;/a&gt; ）也会错误地报告其位置，如果您使用Firebug进行跟踪，这将是一个大问题JavaScript错误很多（我愿意）。 Firebug出于某种原因根本不了解新加载的文件，因此，如果该文件中发生错误，它将报告该错误是在您的主&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;文件中发生的，您将很难找出错误的真正原因。</target>
        </trans-unit>
        <trans-unit id="96ce64ab269dff867b5298523efe17ef57bf386e" translate="yes" xml:space="preserve">
          <source>I also made a simple test for this at &lt;a href=&quot;http://www.kipras.com/dev/import_js_test/&quot;&gt;Example&lt;/a&gt;.</source>
          <target state="translated">我还在&lt;a href=&quot;http://www.kipras.com/dev/import_js_test/&quot;&gt;Example上&lt;/a&gt;对此进行了简单测试。</target>
        </trans-unit>
        <trans-unit id="052345c2ec801d63db4bca3da6cc49e6666d2a55" translate="yes" xml:space="preserve">
          <source>I assume that a script is not fully executed until its &lt;code&gt;document.ready&lt;/code&gt; event has been executed. (I know using &lt;code&gt;document.ready&lt;/code&gt; is not required, but many people use it, and handling this is a safeguard.)</source>
          <target state="translated">我假设脚本只有在执行 &lt;code&gt;document.ready&lt;/code&gt; 事件后才能完全执行。 （我知道不需要使用 &lt;code&gt;document.ready&lt;/code&gt; ，但是许多人都使用它，并且处理此问题是一种保护措施。）</target>
        </trans-unit>
        <trans-unit id="bcf92d81ab2e9f8567b02bf77422af88d42f8420" translate="yes" xml:space="preserve">
          <source>I came to this question because I was looking for a simple way to maintain a collection of useful JavaScript plugins. After seeing some of the solutions here, I came up with this:</source>
          <target state="translated">我来到这个问题,是因为我在寻找一个简单的方法来维护一个有用的JavaScript插件集合。在看到这里的一些解决方案后,我想出了这个办法。</target>
        </trans-unit>
        <trans-unit id="76ea63d97f56a6085f1fd0905c71733444f736e3" translate="yes" xml:space="preserve">
          <source>I decided to go backwards instead of forwards. Thank you &lt;code&gt;document.writeln&lt;/code&gt;. I know it's taboo, but as long as it is used correctly this works well. You end up with code that can be debugged easily, shows in the DOM correctly and can ensure the order the dependencies are loaded correctly.</source>
          <target state="translated">我决定后退而不是前进。 谢谢 &lt;code&gt;document.writeln&lt;/code&gt; 。 我知道这是忌讳的，但是只要正确使用它就可以了。 您最终得到的代码可以轻松调试，可以在DOM中正确显示，并且可以确保正确加载依赖项的顺序。</target>
        </trans-unit>
        <trans-unit id="e71ee8ddaf9dbce0706f9609b8c87eec82c91b6d" translate="yes" xml:space="preserve">
          <source>I had a simple issue, but I was baffled by responses to this question.</source>
          <target state="translated">我有一个很简单的问题,但对这个问题的回答让我百思不得其解。</target>
        </trans-unit>
        <trans-unit id="e90313ba30b8afab25bd3404bda1adf05507004e" translate="yes" xml:space="preserve">
          <source>I had to use a variable (myVar1) defined in one JavaScript file (myvariables.js) in another JavaScript file (main.js).</source>
          <target state="translated">我不得不在另一个JavaScript文件(main.js)中使用一个JavaScript文件(myvariables.js)中定义的变量(myVar1)。</target>
        </trans-unit>
        <trans-unit id="e78b6aa2c0deda3aa7dbaba4a6e64774f7b7faa0" translate="yes" xml:space="preserve">
          <source>I have actually written a jQuery plugin called &lt;em&gt;$.import_js()&lt;/em&gt; which uses this method:</source>
          <target state="translated">我实际上已经编写了一个名为&lt;em&gt;$ .import_js（）&lt;/em&gt;的jQuery插件，它使用此方法：</target>
        </trans-unit>
        <trans-unit id="4a561d066341fa04c3643f7a3595cf6b9722249e" translate="yes" xml:space="preserve">
          <source>I just wrote this JavaScript code (using &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt; for &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; manipulation):</source>
          <target state="translated">我刚刚编写了以下JavaScript代码（使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt;进行&lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;操作）：</target>
        </trans-unit>
        <trans-unit id="8964113a372044579ef717f6641fb9d359e68a92" translate="yes" xml:space="preserve">
          <source>I liked the idea of extending jQuery, but obviously you don't need to.</source>
          <target state="translated">我喜欢扩展jQuery的想法,但显然你不需要这样做。</target>
        </trans-unit>
        <trans-unit id="48b6e1e53bcee394381ab4d7bb07cd633f263a4a" translate="yes" xml:space="preserve">
          <source>I use &lt;a href=&quot;https://github.com/sstephenson/sprockets&quot;&gt;Sprockets&lt;/a&gt; (I don't know if there are others). You build your JavaScript code in separate files and include comments that are processed by the Sprockets engine as includes. For development you can include files sequentially, then for production to merge them...</source>
          <target state="translated">我使用&lt;a href=&quot;https://github.com/sstephenson/sprockets&quot;&gt;链轮&lt;/a&gt; （我不知道是否还有其他链轮 ）。 您将JavaScript代码构建在单独的文件中，并包含由Sprockets引擎处理的注释（包括）。 对于开发，您可以依次包含文件，然后在生产中将它们合并...</target>
        </trans-unit>
        <trans-unit id="182b551075d667e89774a12930481224b9f18f97" translate="yes" xml:space="preserve">
          <source>I wrote a simple module that automates the job of importing/including module scripts in JavaScript. For detailed explanation of the code, refer to the blog post &lt;em&gt;&lt;a href=&quot;http://stamat.wordpress.com/2013/04/12/javascript-require-import-include-modules/&quot;&gt;JavaScript require / import / include modules&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">我编写了一个简单的模块，该模块可以自动执行导入/包含JavaScript中的模块脚本的工作。 有关代码的详细说明，请参阅博客文章&lt;em&gt;&lt;a href=&quot;http://stamat.wordpress.com/2013/04/12/javascript-require-import-include-modules/&quot;&gt;JavaScript require / import / include modules&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b95b09b19967e0602d178894a47c43cfd08dc83" translate="yes" xml:space="preserve">
          <source>I've found it's more reliable to just write the script tags in a PHP include. You only have to write it once and that's just as much work as calling the plugin using JavaScript.</source>
          <target state="translated">我发现直接在PHP include中写脚本标记更可靠。你只需要写一次就可以了,这和用JavaScript调用插件一样多。</target>
        </trans-unit>
        <trans-unit id="50692954f36df35776c3a5384707e2028295c3dc" translate="yes" xml:space="preserve">
          <source>If anyone is looking for something more advanced, try out &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;. You'll get added benefits such as dependency management, better concurrency, and avoid duplication (that is, retrieving a script more than once).</source>
          <target state="translated">如果有人在寻找更高级的东西，请尝试&lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; 。 您将获得诸如依赖管理，更好的并发性和避免重复（即，多次检索脚本）之类的好处。</target>
        </trans-unit>
        <trans-unit id="09c49c729196296537941a7491dbe605bca62236" translate="yes" xml:space="preserve">
          <source>If it works for Facebook, it will work for you.</source>
          <target state="translated">如果它对Facebook有效,那么它也会对你有效。</target>
        </trans-unit>
        <trans-unit id="e0e6f46db11f475cee8f6fa8e7e1cdd71fa87a80" translate="yes" xml:space="preserve">
          <source>If script2 requires script1, this really is the absolute easiest way to do something like this. I'm very surprised no-one has brought this up, as it's the most obvious and simplest answer that will apply in nearly every single case.</source>
          <target state="translated">如果script2需要script1,这真的是最简单的方法。我很惊讶没有人提出这个问题,因为这是最明显、最简单的答案,几乎适用于每一种情况。</target>
        </trans-unit>
        <trans-unit id="08d0f5c8d3d6ff132321aa6d959d367e737ba43f" translate="yes" xml:space="preserve">
          <source>If you use the jQuery library, you can use the &lt;code&gt;$.getScript&lt;/code&gt; method.</source>
          <target state="translated">如果使用jQuery库，则可以使用 &lt;code&gt;$.getScript&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="2d3524e0e4d4cd1e4cf3277f0741ff66c1dc55d6" translate="yes" xml:space="preserve">
          <source>If you want in pure JavaScript, you can use &lt;code&gt;document.write&lt;/code&gt;.</source>
          <target state="translated">如果要使用纯JavaScript，则可以使用 &lt;code&gt;document.write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad91c62be5e861663504e4455fee22384fc00bcf" translate="yes" xml:space="preserve">
          <source>If your intention to load the JavaScript file is &lt;strong&gt;using the functions from the imported/included file&lt;/strong&gt;, you can also define a global object and set the functions as object items. For instance:</source>
          <target state="translated">如果要加载JavaScript文件的目的是&lt;strong&gt;使用导入/包含的文件中的函数&lt;/strong&gt; ，则还可以定义一个全局对象并将这些函数设置为对象项。 例如：</target>
        </trans-unit>
        <trans-unit id="87d10a4bf452ed2df2e36493992bb6eac702495c" translate="yes" xml:space="preserve">
          <source>In case you are using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage&quot;&gt;Web Workers&lt;/a&gt; and want to include additional scripts in the scope of the worker, the other answers provided about adding scripts to the &lt;code&gt;head&lt;/code&gt; tag, etc. will not work for you.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage&quot;&gt;Web&lt;/a&gt; Worker，并且希望在worker范围内包括其他脚本，则其他有关将脚本添加到 &lt;code&gt;head&lt;/code&gt; 标签等的答案将对您不起作用。</target>
        </trans-unit>
        <trans-unit id="c372dfb440124c48faeedb667ad1686636faba8f" translate="yes" xml:space="preserve">
          <source>In modern language with the check if script has already been loaded it would be:</source>
          <target state="translated">在现代语言中,如果脚本已经加载了,那么在检查脚本是否已被加载的情况下,它将是。</target>
        </trans-unit>
        <trans-unit id="89e569c5aabe9fbbde286f6fa71cb13e5d555b8c" translate="yes" xml:space="preserve">
          <source>Instead of this approach you could attempt to modify the jQuery &lt;code&gt;readyList&lt;/code&gt;, but this seemed like a worse solution.</source>
          <target state="translated">代替这种方法，您可以尝试修改jQuery &lt;code&gt;readyList&lt;/code&gt; ，但这似乎是一个较差的解决方案。</target>
        </trans-unit>
        <trans-unit id="5198a78bb0d30cc8cf91f499bbb47db39eac32c1" translate="yes" xml:space="preserve">
          <source>Is there something in JavaScript similar to &lt;code&gt;@import&lt;/code&gt; in CSS that allows you to include a JavaScript file inside another JavaScript file?</source>
          <target state="translated">JavaScript中是否有类似于CSS中 &lt;code&gt;@import&lt;/code&gt; 的内容，可让您在另一个JavaScript文件中包含一个JavaScript文件？</target>
        </trans-unit>
        <trans-unit id="a0c170f044d1b6605820b898a6064dddbee3d16e" translate="yes" xml:space="preserve">
          <source>It includes a &lt;code&gt;main.js&lt;/code&gt; file in the main HTML and then the script in &lt;code&gt;main.js&lt;/code&gt; uses &lt;code&gt;$.import_js()&lt;/code&gt; to import an additional file called &lt;code&gt;included.js&lt;/code&gt;, which defines this function:</source>
          <target state="translated">它在主HTML中包含一个 &lt;code&gt;main.js&lt;/code&gt; 文件，然后 &lt;code&gt;main.js&lt;/code&gt; 中的脚本使用 &lt;code&gt;$.import_js()&lt;/code&gt; 导入一个名为include.js的附加文件，该文件定义了此功能：</target>
        </trans-unit>
        <trans-unit id="cc1c709a99169050e868f3572e201e60f18ff0c4" translate="yes" xml:space="preserve">
          <source>It is possible to dynamically generate a JavaScript tag and append it to HTML document from inside other JavaScript code. This will load targeted JavaScript file.</source>
          <target state="translated">可以动态生成一个JavaScript标签,并将其附加到HTML文档中。这将加载有针对性的JavaScript文件。</target>
        </trans-unit>
        <trans-unit id="299027586058c2f57df63257e78428635d35de48" translate="yes" xml:space="preserve">
          <source>It means that if you use these tricks directly, &lt;em&gt;you won't be able to use your newly loaded code the next line after you asked it to be loaded&lt;/em&gt;, because it will be still loading.</source>
          <target state="translated">这意味着，如果您直接使用这些技巧， &lt;em&gt;那么在您要求加载新代码后&lt;/em&gt; ， &lt;em&gt;将无法在下一行使用新加载的代码&lt;/em&gt; ，因为它仍将加载。</target>
        </trans-unit>
        <trans-unit id="b01ba72d4fd35a9d4c4c9996b99e2fd452fde924" translate="yes" xml:space="preserve">
          <source>It works great and uses no page-reloads for me. I've tried the AJAX method (one of the other answers) but it doesn't seem to work as nicely for me.</source>
          <target state="translated">它的效果很好,对我来说不需要重新加载页面。我试过AJAX方法(其他答案之一),但它似乎对我来说并没有那么好用。</target>
        </trans-unit>
        <trans-unit id="e5daad8292815a8f471b32cc8d290ff531ccef25" translate="yes" xml:space="preserve">
          <source>Like Dynamic Imports you can load one or many scripts with a &lt;code&gt;fetch&lt;/code&gt; call using promises to control order of execution for script dependencies using the &lt;a href=&quot;https://git.habd.as/jhabdas/fetch-inject&quot;&gt;Fetch Inject&lt;/a&gt; library:</source>
          <target state="translated">像动态导入一样，您可以使用承诺通过&lt;a href=&quot;https://git.habd.as/jhabdas/fetch-inject&quot;&gt;Fetch Inject&lt;/a&gt;库控制使用脚本来控制脚本依赖项的执行顺序，从而通过 &lt;code&gt;fetch&lt;/code&gt; 调用加载一个或多个脚本：</target>
        </trans-unit>
        <trans-unit id="8fcc19aee2e562ac4b64c23515ff5bb055bba5e1" translate="yes" xml:space="preserve">
          <source>Loaded the JavaScript code in the HTML file, in the correct order, myvariables.js first, then main.js:</source>
          <target state="translated">在HTML文件中加载了JavaScript代码,按照正确的顺序,先是myvariables.js,然后是main.js。</target>
        </trans-unit>
        <trans-unit id="7475b8cb4b8b4b0ea0bd2e2735262e923671b358" translate="yes" xml:space="preserve">
          <source>Manually call just the one file in your head:</source>
          <target state="translated">手动调用你脑海中的一个文件就可以了。</target>
        </trans-unit>
        <trans-unit id="c0955483993644c2d345d5478838388a3821a9ea" translate="yes" xml:space="preserve">
          <source>Maybe you can use this function that I found on this page &lt;em&gt;&lt;a href=&quot;http://forums.digitalpoint.com/showthread.php?t=146094&quot;&gt;How do I include a JavaScript file in a JavaScript file?&lt;/a&gt;&lt;/em&gt;:</source>
          <target state="translated">也许您可以使用在此页面上找到的此功能， &lt;em&gt;&lt;a href=&quot;http://forums.digitalpoint.com/showthread.php?t=146094&quot;&gt;如何在JavaScript文件中包含JavaScript文件？&lt;/a&gt;&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="e8d91a207629cab68b84bde0bfdf97bd5b2fd884" translate="yes" xml:space="preserve">
          <source>Mix files are simply .js or .css files with .mix. in the file name. A
  mix file simply     extends the functionality of a normal style or
  script file and allows you to import and combine.</source>
          <target state="translated">混合文件就是文件名中带.js或.css的文件。混合文件只是扩展了普通样式或脚本文件的功能,允许你导入和组合。</target>
        </trans-unit>
        <trans-unit id="481ac87a7bba22c45887cc5c7ea78c63b449b061" translate="yes" xml:space="preserve">
          <source>Mixture outputs this as &lt;code&gt;scripts-global.js&lt;/code&gt; and also as a minified version (&lt;code&gt;scripts-global.min.js&lt;/code&gt;).</source>
          <target state="translated">Mixture将其输出为 &lt;code&gt;scripts-global.js&lt;/code&gt; 和缩小版本（ &lt;code&gt;scripts-global.min.js&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3a067d11c89c1bd83a9bd5ce416dd2e152f89832" translate="yes" xml:space="preserve">
          <source>Most of solutions shown here imply dynamical loading. I was searching instead for a compiler which assemble all the depended files into a single output file. The same as &lt;a href=&quot;http://en.wikipedia.org/wiki/Less_%28stylesheet_language%29&quot;&gt;Less&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass&lt;/a&gt; preprocessors deal with the CSS &lt;code&gt;@import&lt;/code&gt; at-rule. Since I didn't find anything decent of this sort, I wrote a simple tool solving the issue.</source>
          <target state="translated">此处显示的大多数解决方案都暗含动态载荷。 我正在搜索的是一个将所有依赖文件组装成一个输出文件的编译器。 与&lt;a href=&quot;http://en.wikipedia.org/wiki/Less_%28stylesheet_language%29&quot;&gt;Less&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass&lt;/a&gt;预处理程序处理CSS &lt;code&gt;@import&lt;/code&gt; 规则相同。 由于我没有找到任何像样的东西，因此我编写了一个简单的工具来解决该问题。</target>
        </trans-unit>
        <trans-unit id="80d75005f71e84434c0fa44621569283aced2efa" translate="yes" xml:space="preserve">
          <source>My usual method is:</source>
          <target state="translated">我常用的方法是:</target>
        </trans-unit>
        <trans-unit id="cd04c41011b8c6a90b8d3d406e8973f00f118915" translate="yes" xml:space="preserve">
          <source>NOTE: You must use this only while the page is loading, otherwise you get a blank screen. In other words, &lt;strong&gt;always place this before / outside of document.ready&lt;/strong&gt;. I have not tested using this after the page is loaded in a click event or anything like that, but I am pretty sure it'll fail.</source>
          <target state="translated">注意：您只能在页面加载时使用此功能，否则会出现空白屏幕。 换句话说，请&lt;strong&gt;始终将其放在document.ready之前/之外&lt;/strong&gt; 。 在将页面加载到click事件或类似事件之后，我还没有使用此工具进行过测试，但是我敢肯定它会失败。</target>
        </trans-unit>
        <trans-unit id="0ce496c371b0e9f99e92db6d770461268fed0859" translate="yes" xml:space="preserve">
          <source>Node.js require</source>
          <target state="translated">Node.js要求</target>
        </trans-unit>
        <trans-unit id="70393d4cd6440f7071aab91842a254a103787886" translate="yes" xml:space="preserve">
          <source>Note that the script may execute after the DOM has loaded, or before, depending on the browser and whether you included the line &lt;code&gt;script.async = false;&lt;/code&gt;. There's a &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/script-loading/&quot;&gt;great article on Javascript loading in general&lt;/a&gt; which discusses this.</source>
          <target state="translated">请注意，脚本可能在加载DOM之后或之前执行，具体取决于浏览器以及是否包含行脚本 &lt;code&gt;script.async = false;&lt;/code&gt; 。 &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/script-loading/&quot;&gt;总的来说&lt;/a&gt; ，有一篇很棒的关于Javascript加载的文章对此进行了讨论。</target>
        </trans-unit>
        <trans-unit id="ff2891b93715f3f936e6b7d24ad6fad0a5319c90" translate="yes" xml:space="preserve">
          <source>Note that to get this working cross-domain, the server will need to set &lt;code&gt;allow-origin&lt;/code&gt; header in its response.</source>
          <target state="translated">请注意，要获得此工作的跨域，服务器将需要在其响应中设置 &lt;code&gt;allow-origin&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="f5f3eb8c4ce200ec467cdef1208486ed2b2ad0c8" translate="yes" xml:space="preserve">
          <source>Note: I'm not in any way affiliated with Mixture, other than using it as a front-end development tool. I came across this question upon seeing a &lt;code&gt;.mix&lt;/code&gt; JavaScript file in action (in one of the Mixture boilerplates) and being a bit confused by it (&quot;you can do this?&quot; I thought to myself). Then I realized that it was an application-specific file type (somewhat disappointing, agreed). Nevertheless, figured the knowledge might be helpful for others.</source>
          <target state="translated">注意：除了将它用作前端开发工具之外，我与Mixture无关。 我看到一个正在运行的 &lt;code&gt;.mix&lt;/code&gt; JavaScript文件（在Mixture样板中）时遇到了这个问题，并对此感到有些困惑（&amp;ldquo;我能做到吗？&amp;rdquo;）。 然后我意识到这是一种特定于应用程序的文件类型（有些令人失望，同意）。 但是，认为这些知识可能对其他人有所帮助。</target>
        </trans-unit>
        <trans-unit id="d5361b0d202b75a326b27f5abc5966b30b92c5ab" translate="yes" xml:space="preserve">
          <source>Now we can run the compiler:</source>
          <target state="translated">现在我们可以运行编译器了。</target>
        </trans-unit>
        <trans-unit id="be1e395612e56b219495a2511f226e4a6bbad566" translate="yes" xml:space="preserve">
          <source>Now, there is a big issue you must know about. Doing that implies that &lt;em&gt;you remotely load the code&lt;/em&gt;. Modern web browsers will load the file and keep executing your current script because they load everything asynchronously to improve performance. (This applies to both the jQuery method and the manual dynamic script loading method.)</source>
          <target state="translated">现在，您必须知道一个大问题。 这样做意味着&lt;em&gt;您需要远程加载代码&lt;/em&gt; 。 现代的Web浏览器将加载文件并继续执行当前脚本，因为它们异步加载所有内容以提高性能。 （这适用于jQuery方法和手动动态脚本加载方法。）</target>
        </trans-unit>
        <trans-unit id="f6aec98cb390ce572d475ac294a8779bcdd59d39" translate="yes" xml:space="preserve">
          <source>On the jQuery master branch, they simply concatenate atomic source files into a single one starting with &lt;code&gt;intro.js&lt;/code&gt; and ending with &lt;code&gt;outtro.js&lt;/code&gt;. That doesn't suits me as it provides no flexibility on the source code design. Check out how it works with jsic:</source>
          <target state="translated">在jQuery master分支上，它们仅将原子源文件连接到一个以 &lt;code&gt;intro.js&lt;/code&gt; 开头并以 &lt;code&gt;outtro.js&lt;/code&gt; 结尾的文件中 。 那不适合我，因为它在源代码设计上没有灵活性。 查看jsic的工作方式：</target>
        </trans-unit>
        <trans-unit id="35244510a0932d71a1e33c185ed4d3632c86c351" translate="yes" xml:space="preserve">
          <source>Or rather than including at run time, use a script to concatenate prior to upload.</source>
          <target state="translated">或者,与其在运行时包含,不如在上传前使用脚本来串联。</target>
        </trans-unit>
        <trans-unit id="ae55d21513645c5d75d2af23ca6c677b65dcc82d" translate="yes" xml:space="preserve">
          <source>Read more at &lt;a href=&quot;https://developers.google.com/web/updates/2017/11/dynamic-import&quot;&gt;https://developers.google.com/web/updates/2017/11/dynamic-import&lt;/a&gt;</source>
          <target state="translated">请访问&lt;a href=&quot;https://developers.google.com/web/updates/2017/11/dynamic-import&quot;&gt;https://developers.google.com/web/updates/2017/11/dynamic-import&lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="0fdf3837508857a07cdb1bf94cb244b7d21a5aae" translate="yes" xml:space="preserve">
          <source>Read more at &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;https://jakearchibald.com/2017/es-modules-in-browsers/&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;https://jakearchibald.com/2017/es-modules-in-browsers/&lt;/a&gt;了解更多</target>
        </trans-unit>
        <trans-unit id="7a2968690e7c23123fd7efc2f7e364afd5a86919" translate="yes" xml:space="preserve">
          <source>Refer to:</source>
          <target state="translated">参看:</target>
        </trans-unit>
        <trans-unit id="5ad4ccb4e6c788c5d5198e149aa1d4af7b483a35" translate="yes" xml:space="preserve">
          <source>RequireJS loads plain JavaScript files as well as more defined
  modules. It is optimized for in-browser use, including in a Web
  Worker, but it can be used in other JavaScript environments, like
  Rhino and Node. It implements the Asynchronous Module API.</source>
          <target state="translated">RequireJS可以加载普通的JavaScript文件以及更多定义的模块。它针对浏览器内使用进行了优化,包括在Web Worker中,但也可以在其他JavaScript环境中使用,如Rhino和Node。它实现了Asynchronous Module API。</target>
        </trans-unit>
        <trans-unit id="efbb4b5102cbae7f42e744b6a9286fbaccd8f904" translate="yes" xml:space="preserve">
          <source>RequireJS uses plain script tags to load modules/files, so it should
  allow for easy debugging. It can be used simply to load existing
  JavaScript files, so &lt;strong&gt;you can add it to your existing project without
  having to re-write your JavaScript files.&lt;/strong&gt;</source>
          <target state="translated">RequireJS使用简单的脚本标签来加载模块/文件，因此应便于调试。 它可以简单地用于加载现有的JavaScript文件，因此&lt;strong&gt;您可以将其添加到现有项目中，而无需重新编写JavaScript文件。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">也见。</target>
        </trans-unit>
        <trans-unit id="71dc617a43ade90c11908db4d0f8e0e5ad86ab36" translate="yes" xml:space="preserve">
          <source>Set up a file called &quot;plugins.js&quot; (or extensions.js or whatever you want). Keep your plugin files together with that one master file.</source>
          <target state="translated">设置一个名为 &quot;plugins.js &quot;的文件(或extensions.js或任何你想要的东西)。将你的插件文件和这个主文件一起保存。</target>
        </trans-unit>
        <trans-unit id="cb63b27c44e32458c090132cc30786386502db2f" translate="yes" xml:space="preserve">
          <source>So all you would need to do to import JavaScript is:</source>
          <target state="translated">所以,你需要做的就是导入JavaScript。</target>
        </trans-unit>
        <trans-unit id="50c7c7e6fbef7aa987cd88ab0ebe41cc1d7dfd86" translate="yes" xml:space="preserve">
          <source>So here is the compiler, &lt;a href=&quot;https://github.com/dsheiko/jsic&quot;&gt;https://github.com/dsheiko/jsic&lt;/a&gt;, which replaces &lt;code&gt;$import(&quot;file-path&quot;)&lt;/code&gt; with the requested file content securely. Here is the corresponding &lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; plugin: &lt;a href=&quot;https://github.com/dsheiko/grunt-jsic&quot;&gt;https://github.com/dsheiko/grunt-jsic&lt;/a&gt;.</source>
          <target state="translated">因此，这里是编译器&lt;a href=&quot;https://github.com/dsheiko/jsic&quot;&gt;https://github.com/dsheiko/jsic&lt;/a&gt; ，它将安全地将 &lt;code&gt;$import(&quot;file-path&quot;)&lt;/code&gt; 替换为所请求的文件内容。 这是对应的&lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt;插件： &lt;a href=&quot;https://github.com/dsheiko/grunt-jsic&quot;&gt;https&lt;/a&gt; : //github.com/dsheiko/grunt-jsic 。</target>
        </trans-unit>
        <trans-unit id="207e16cd95f6cd938f21d26d90e229e30bc7c63b" translate="yes" xml:space="preserve">
          <source>So you don't have to rely upon any JavaScript framework nor do you have to explicitly make &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;Ajax&lt;/a&gt; calls.</source>
          <target state="translated">因此，您不必依赖任何JavaScript框架，也不必显式进行&lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;Ajax&lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="db6dad97ca62ef5d7f44d822ae7ada54d51ed9bf" translate="yes" xml:space="preserve">
          <source>Source Code Merge/Preprocessing</source>
          <target state="translated">源代码 MergePreprocessing</target>
        </trans-unit>
        <trans-unit id="60c6c4d6b31992a793c66bd837c9c7497f32017e" translate="yes" xml:space="preserve">
          <source>Statement &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; is in ECMAScript 6.</source>
          <target state="translated">语句&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;在ECMAScript 6中。</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="8b1b78f01302f9f5124b19ec9053902f483cc415" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; library provides loading functionality &lt;a href=&quot;http://api.jquery.com/jQuery.getScript/&quot;&gt;in one line&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;库&lt;a href=&quot;http://api.jquery.com/jQuery.getScript/&quot;&gt;在一行中&lt;/a&gt;提供了加载功能：</target>
        </trans-unit>
        <trans-unit id="365cfa5fd770b6dc0769934f9dacef667879a63d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@import&lt;/code&gt; syntax for achieving CSS-like JavaScript importing is possible using a tool such as Mixture via their special &lt;code&gt;.mix&lt;/code&gt; file type (see &lt;a href=&quot;http://docs.mixture.io/preprocessors#mix&quot;&gt;here&lt;/a&gt;). I imagine the application simply uses one of the aforementioned methods interally, though I don't know.</source>
          <target state="translated">使用诸如Mixture之类的工具通过其特殊的 &lt;code&gt;.mix&lt;/code&gt; 文件类型，可以使用 &lt;code&gt;@import&lt;/code&gt; 语法来实现类似CSS的JavaScript导入（请参见&lt;a href=&quot;http://docs.mixture.io/preprocessors#mix&quot;&gt;此处&lt;/a&gt; ）。 我想该应用程序只是内部使用一种上述方法，尽管我不知道。</target>
        </trans-unit>
        <trans-unit id="c5e847bed7fd8f4657d461e7ff8a88bffa6bd775" translate="yes" xml:space="preserve">
          <source>The old versions of JavaScript had no import, include, or require, so many different approaches to this problem have been developed.</source>
          <target state="translated">旧版本的JavaScript没有导入、包含或要求,所以针对这个问题开发了很多不同的方法。</target>
        </trans-unit>
        <trans-unit id="332a07b88f0fcf415b8555e25a5eeedebfe4cb0d" translate="yes" xml:space="preserve">
          <source>The older CJS module style, still widely used in Node.js, is the &lt;a href=&quot;https://nodejs.org/api/modules.html&quot;&gt;&lt;code&gt;module.exports&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; system.</source>
          <target state="translated">仍在Node.js中广泛使用的较旧的CJS模块样式是&lt;a href=&quot;https://nodejs.org/api/modules.html&quot;&gt; &lt;code&gt;module.exports&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;系统。</target>
        </trans-unit>
        <trans-unit id="3c64a3691275e516da071b56c9173a3a5745a171" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;$.getScript&lt;/code&gt; and really any other solution that requires a callback when loading is complete is that if you have multiple files that use it and depend on each other you no longer have a way to know when all scripts have been loaded (once they are nested in multiple files).</source>
          <target state="translated">&lt;code&gt;$.getScript&lt;/code&gt; 以及实际上在完成加载后需要回调的任何其他解决方案的问题是，如果您有多个使用它的文件并且彼此依赖，则您不再有办法知道何时加载所有脚本（一次它们嵌套在多个文件中）。</target>
        </trans-unit>
        <trans-unit id="e3df137a5e529bd9e98b8d075cf6b8ec8e6991ff" translate="yes" xml:space="preserve">
          <source>The reason why we look for the first &lt;code&gt;script&lt;/code&gt; element instead of &lt;code&gt;head&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; is because some browsers don't create one if missing, but we're guaranteed to have a &lt;code&gt;script&lt;/code&gt; element - this one. Read more at &lt;a href=&quot;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&quot;&gt;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&lt;/a&gt;.</source>
          <target state="translated">我们寻找第一个 &lt;code&gt;script&lt;/code&gt; 元素而不是 &lt;code&gt;head&lt;/code&gt; 或 &lt;code&gt;body&lt;/code&gt; 的原因是因为某些浏览器如果丢失则不会创建一个 &lt;code&gt;script&lt;/code&gt; 元素，但是我们保证有一个script元素-这个。 请访问&lt;a href=&quot;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&quot;&gt;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&lt;/a&gt;了解更多信息 。</target>
        </trans-unit>
        <trans-unit id="82cf60f97f6c09707b8f19fab54ef5c1a0cb6287" translate="yes" xml:space="preserve">
          <source>The script can even reside on a different server. Furthermore, the browser evaluates the code. The &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag can be injected into either the web page &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;, or inserted just before the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">该脚本甚至可以驻留在其他服务器上。 此外，浏览器会评估代码。 可以将 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记插入网页 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 中 ，也可以将其插入在结束 &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; 标记之前。</target>
        </trans-unit>
        <trans-unit id="cbf546d79de34ac91357b0003cf697e434471972" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;main.js&lt;/code&gt;:</source>
          <target state="translated">然后 &lt;code&gt;main.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1a3dc8d9fecff4598af5823bdb8309740acf1198" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;main.mjs&lt;/code&gt;:</source>
          <target state="translated">然后 &lt;code&gt;main.mjs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7cb5f212cd2a13edf49d3b9684dcfad659ee20ea" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;module.js&lt;/code&gt;:</source>
          <target state="translated">然后 &lt;code&gt;module.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fea8eb87370a87b1e4d189a8d9e83a44e5c1f2cf" translate="yes" xml:space="preserve">
          <source>Then you reload the page hitting</source>
          <target state="translated">然后重新加载页面,点击</target>
        </trans-unit>
        <trans-unit id="0672e4bde170e584fa2b6dc719a249509055bb38" translate="yes" xml:space="preserve">
          <source>Then you run all that:</source>
          <target state="translated">那你就把这些都跑了。</target>
        </trans-unit>
        <trans-unit id="3b84e4c1da86765df25fe1104617e23cd6a3172e" translate="yes" xml:space="preserve">
          <source>Then you write the code you want to use AFTER the script is loaded in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda function&lt;/a&gt;:</source>
          <target state="translated">然后，在脚本加载到&lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda函数中&lt;/a&gt;之后，编写要使用的代码：</target>
        </trans-unit>
        <trans-unit id="38c5068306243c5f0677ed35094b305a3aebfa48" translate="yes" xml:space="preserve">
          <source>There actually &lt;em&gt;is&lt;/em&gt; a way to load a JavaScript file &lt;em&gt;not&lt;/em&gt; asynchronously, so you could use the functions included in your newly loaded file right after loading it, and I think it works in all browsers.</source>
          <target state="translated">实际上， &lt;em&gt;有&lt;/em&gt;一种方法可以&lt;em&gt;不&lt;/em&gt;异步加载JavaScript文件，因此您可以在加载后立即使用新加载的文件中包含的功能，并且我认为它可以在所有浏览器中使用。</target>
        </trans-unit>
        <trans-unit id="d358c9da7c21739b51ad491587d2a2e4bbea8403" translate="yes" xml:space="preserve">
          <source>There are a lot of potential answers for this question. My answer is obviously based on a number of them. This is what I ended up with after reading through all the answers.</source>
          <target state="translated">对于这个问题,有很多可能的答案。我的答案显然是基于其中的一些答案。这是我看完所有的答案后得出的结果。</target>
        </trans-unit>
        <trans-unit id="44afba8e9b45daeb202787b573cfab4ecc933b89" translate="yes" xml:space="preserve">
          <source>There are other ways for JavaScript to include external JavaScript contents in browsers that do not require preprocessing.</source>
          <target state="translated">在浏览器中,JavaScript还有其他不需要预处理的方式来包含外部JavaScript内容。</target>
        </trans-unit>
        <trans-unit id="775a00f31987b24b0b74ff2c37a582e1e13b8885" translate="yes" xml:space="preserve">
          <source>There are several ways to implement modules in Javascript, Here are the 2 most popular ones:</source>
          <target state="translated">有几种在Javascript中实现模块的方法,下面是2种最流行的方法。</target>
        </trans-unit>
        <trans-unit id="a509c35ddc3ed0ce500ef2c3f3e54fe40074c6be" translate="yes" xml:space="preserve">
          <source>There is a good news for you. Very soon you will be able to load JavaScript code easily. It will become a standard way of importing modules of JavaScript code and will be part of core JavaScript itself.</source>
          <target state="translated">有一个好消息要告诉你。很快,你将能够轻松加载JavaScript代码。它将成为导入JavaScript代码模块的标准方式,并将成为核心JavaScript本身的一部分。</target>
        </trans-unit>
        <trans-unit id="03917ccdd96f3286351548a9349f54699c873ece" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://headjs.com/&quot;&gt;Head.js&lt;/a&gt;. It is very easy to deal with:</source>
          <target state="translated">还有&lt;a href=&quot;http://headjs.com/&quot;&gt;Head.js。&lt;/a&gt; 这很容易处理：</target>
        </trans-unit>
        <trans-unit id="282a95668b3d184d0221e75ea9a0b317f15912d1" translate="yes" xml:space="preserve">
          <source>This function will add a new &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to the end of the head section of the page, where the &lt;code&gt;src&lt;/code&gt; attribute is set to the URL which is given to the function as the first parameter.</source>
          <target state="translated">此函数将在页面头部的末尾添加一个新的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记，其中 &lt;code&gt;src&lt;/code&gt; 属性设置为该函数作为第一个参数给出的URL。</target>
        </trans-unit>
        <trans-unit id="aec69cae0df189fe5f15918931a93fbb19af37a4" translate="yes" xml:space="preserve">
          <source>This moduling system is used in NodeJS. You basically add your exports to an object which is called &lt;code&gt;module.exports&lt;/code&gt;. You then can access this object via a &lt;code&gt;require('modulePath')&lt;/code&gt;. Important here is to realize that these modules are being cached, so if you &lt;code&gt;require()&lt;/code&gt; a certain module twice it will return the already created module.</source>
          <target state="translated">该调制系统用于NodeJS。 基本上，您将导出添加到名为 &lt;code&gt;module.exports&lt;/code&gt; 的对象中。 然后，您可以通过 &lt;code&gt;require('modulePath')&lt;/code&gt; 访问该对象。 在这里重要的是要意识到这些模块已被缓存，因此，如果对 &lt;code&gt;require()&lt;/code&gt; 两次调用某个模块，它将返回已创建的模块。</target>
        </trans-unit>
        <trans-unit id="8d141c73c6e84930879c36e1f775b68c2e49892c" translate="yes" xml:space="preserve">
          <source>This saved my day. I hope this helps.</source>
          <target state="translated">这救了我一天。我希望这能帮到你</target>
        </trans-unit>
        <trans-unit id="5fbb1a0423bef2cdcefbfb4471fd65f7883a8a93" translate="yes" xml:space="preserve">
          <source>This script will add a JavaScript file to the top of any other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">此脚本会将JavaScript文件添加到任何其他 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记的顶部：</target>
        </trans-unit>
        <trans-unit id="677f26183a09ed669f4cb588a041e322090571ba" translate="yes" xml:space="preserve">
          <source>This should do:</source>
          <target state="translated">这个应该可以了。</target>
        </trans-unit>
        <trans-unit id="1766b2907ae68f8084c4976da09f1789f75a93ee" translate="yes" xml:space="preserve">
          <source>Usage (Promise):</source>
          <target state="translated">用法(承诺)。</target>
        </trans-unit>
        <trans-unit id="eeba7483417f4c19d85bdb39a309d8abb9362c2d" translate="yes" xml:space="preserve">
          <source>Usage (async/await):</source>
          <target state="translated">用法(Asyncawait)。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="b2f9ce47657e324cce2b6d80e0c2f7518a08067a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.mjs&lt;/code&gt;, you'd have &lt;code&gt;module.mjs&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;.mjs&lt;/code&gt; ，您将拥有 &lt;code&gt;module.mjs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c3c8d0e74dd9558a24f0302ee206a7608218058e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;package.json&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="25836b321091437346e2f5dbe6de27871ab3c287" translate="yes" xml:space="preserve">
          <source>Well, you can use the hack the author suggests in the link I gave you. In summary, for people in a hurry, he uses an event to run a callback function when the script is loaded. So you can put all the code using the remote library in the callback function. For example:</source>
          <target state="translated">那么,你可以使用笔者给你的链接中的作者建议的黑客方法。综上所述,对于赶时间的人来说,他用一个事件来运行脚本加载时的回调函数。所以你可以把所有使用远程库的代码都放在回调函数中。举个例子。</target>
        </trans-unit>
        <trans-unit id="6bd3ad67628e2ce42d0075e4006bcb283c8372d6" translate="yes" xml:space="preserve">
          <source>When the additional files are loaded the &lt;code&gt;document.ready&lt;/code&gt; callbacks will get executed in the wrong order. To address this when a script is actually loaded, the script that imported it is re-imported itself and execution halted. This causes the originating file to now have its &lt;code&gt;document.ready&lt;/code&gt; callback executed after any from any scripts that it imports.</source>
          <target state="translated">加载其他文件时， &lt;code&gt;document.ready&lt;/code&gt; 回调将以错误的顺序执行。 为了在实际加载脚本时解决此问题，请重新导入导入脚本的脚本，并暂停执行。 这将导致原始文件现在从其导入的任何脚本中执行了 &lt;code&gt;document.ready&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="9eea4e801ae6abd35d58a38d0d55c894879bbd27" translate="yes" xml:space="preserve">
          <source>You are right when you say that you could specify Ajax to run synchronously or use &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt;, but the current trend appears to be to deprecate synchronous requests, so you may not get full browser support now or in the future.</source>
          <target state="translated">说对了，您可以指定Ajax同步运行或使用&lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; ，这是对的，但是当前的趋势似乎是弃用同步请求，因此您现在或将来可能无法获得完整的浏览器支持。</target>
        </trans-unit>
        <trans-unit id="41b688ca3fa05f1b8bf2b2c1390acf30888a6c1a" translate="yes" xml:space="preserve">
          <source>You can also assemble your scripts using &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;:</source>
          <target state="translated">您也可以使用&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;汇编脚本：</target>
        </trans-unit>
        <trans-unit id="b67289039b993bbae286ee78e5a38a9d7984d26f" translate="yes" xml:space="preserve">
          <source>You can of course use $ (&quot;body&quot;).append(), but then you can no longer debug correctly any more.</source>
          <target state="translated">当然你可以使用$(&quot;body&quot;).append(),但这样一来,你就不能再正确地调试了。</target>
        </trans-unit>
        <trans-unit id="261f53110fde11b3c98c44fc320c61440f8caf48" translate="yes" xml:space="preserve">
          <source>You can then use it in your code as you'd usually use an include:</source>
          <target state="translated">然后你可以在你的代码中使用它,因为你通常会使用一个include。</target>
        </trans-unit>
        <trans-unit id="763d2233f3f407809871ccf36da8867041eafddf" translate="yes" xml:space="preserve">
          <source>You can write your JavaScript files in &quot;modules&quot; and then reference them as dependencies in other scripts. Or you can use RequireJS as a simple &quot;go get this script&quot; solution.</source>
          <target state="translated">你可以把你的JavaScript文件写成 &quot;modules&quot;,然后在其他脚本中作为依赖关系引用。或者你可以使用 RequireJS 作为一个简单的 &quot;去获取这个脚本 &quot;的解决方案。</target>
        </trans-unit>
        <trans-unit id="43fc4e4d3a473a2cd0549a65efd79e36b5e2afb7" translate="yes" xml:space="preserve">
          <source>You could add a script tag with the script URL into the HTML. To avoid the overhead of jQuery, this is an ideal solution.</source>
          <target state="translated">你可以在HTML中添加一个带有脚本URL的脚本标签。为了避免jQuery的开销,这是一个理想的解决方案。</target>
        </trans-unit>
        <trans-unit id="677229282757dc7a7d42af0f461340f88668361d" translate="yes" xml:space="preserve">
          <source>You could load an additional script with an AJAX call and then use &lt;code&gt;eval&lt;/code&gt; to run it. This is the most straightforward way, but it is limited to your domain because of the JavaScript sandbox security model. Using &lt;code&gt;eval&lt;/code&gt; also opens the door to bugs, hacks and security issues.</source>
          <target state="translated">您可以使用AJAX调用加载其他脚本，然后使用 &lt;code&gt;eval&lt;/code&gt; 运行它。 这是最直接的方法，但是由于JavaScript沙箱安全模型，它仅限于您的域。 使用 &lt;code&gt;eval&lt;/code&gt; 还打开了漏洞，黑客和安全问题的大门。</target>
        </trans-unit>
        <trans-unit id="740e8e133fe6283f4bf17af1eb127c00965480b1" translate="yes" xml:space="preserve">
          <source>You could try to use &lt;code&gt;$.when&lt;/code&gt; to check an array of deferred objects, but now you are doing this in every file and file2 will be considered loaded as soon as the &lt;code&gt;$.when&lt;/code&gt; is executed not when the callback is executed, so file1 still continues execution before file3 is loaded. This really still has the same problem.</source>
          <target state="translated">您可以尝试使用 &lt;code&gt;$.when&lt;/code&gt; 检查延迟对象的数组，但是现在您正在每个文件中执行此操作，并且 &lt;code&gt;$.when&lt;/code&gt; 在执行时（而不是在执行回调时）将被视为立即加载file2 。在加载file3之前继续执行。 这确实仍然存在相同的问题。</target>
        </trans-unit>
        <trans-unit id="ac49dc35cec96359223a55198aee1ea6a7723105" translate="yes" xml:space="preserve">
          <source>You just need to be careful when you are including scripts in an HTML file. The order should be as in below:</source>
          <target state="translated">你只需要在HTML文件中包含脚本的时候要注意。顺序应该如下图所示。</target>
        </trans-unit>
        <trans-unit id="44f152a3a2ff3ec5b145516a70206e4b37c0738c" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;jQuery.append()&lt;/code&gt; on the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; element of your page, that is:</source>
          <target state="translated">您需要在页面的 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 元素上使用 &lt;code&gt;jQuery.append()&lt;/code&gt; ，即：</target>
        </trans-unit>
        <trans-unit id="4ad6f53621aa3d1faf240c9a38a76a34ecb3ac9f" translate="yes" xml:space="preserve">
          <source>You simply have to write &lt;code&gt;import cond from 'cond.js';&lt;/code&gt; to load a macro named &lt;code&gt;cond&lt;/code&gt; from a file &lt;code&gt;cond.js&lt;/code&gt;.</source>
          <target state="translated">您只需 &lt;code&gt;import cond from 'cond.js';&lt;/code&gt; 编写import cond； 从文件 &lt;code&gt;cond.js&lt;/code&gt; 加载名为 &lt;code&gt;cond&lt;/code&gt; 的宏。</target>
        </trans-unit>
        <trans-unit id="d9c029655932b5efd739f546d5b2cb4eaadd323a" translate="yes" xml:space="preserve">
          <source>file1.js</source>
          <target state="translated">file1.js</target>
        </trans-unit>
        <trans-unit id="a2bf4c98312f67688bf14bf9ed30d02aa9d4ca8d" translate="yes" xml:space="preserve">
          <source>file1.js:</source>
          <target state="translated">file1.js:</target>
        </trans-unit>
        <trans-unit id="d14c0cdfc2b81349332a20275d4e5388ced355bc" translate="yes" xml:space="preserve">
          <source>file2.js</source>
          <target state="translated">file2.js</target>
        </trans-unit>
        <trans-unit id="03a0f7a91e0893577595163e3fac51c418880f93" translate="yes" xml:space="preserve">
          <source>file2.js:</source>
          <target state="translated">file2.js:</target>
        </trans-unit>
        <trans-unit id="9eb542476d35d6e35c8f124ac5e963ed9e1f9a2e" translate="yes" xml:space="preserve">
          <source>file3.js</source>
          <target state="translated">file3.js</target>
        </trans-unit>
        <trans-unit id="a7eac0c8dd40160a0c46c08bdfaf13d11b629316" translate="yes" xml:space="preserve">
          <source>global.js</source>
          <target state="translated">global.js</target>
        </trans-unit>
        <trans-unit id="0f4ed54c5010ce0a22e2398e6e747b8624d5114e" translate="yes" xml:space="preserve">
          <source>jQuery Loading</source>
          <target state="translated">jQuery加载</target>
        </trans-unit>
        <trans-unit id="c4a4248f7568c9e41265502c39b0daeb8b635431" translate="yes" xml:space="preserve">
          <source>main.js</source>
          <target state="translated">main.js</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="e8775485c8f1802e0ec89012c9e0a431dd135b78" translate="yes" xml:space="preserve">
          <source>plugins.js will have an array called &lt;code&gt;pluginNames[]&lt;/code&gt; that we will iterate over &lt;code&gt;each()&lt;/code&gt;,
then append a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to the head for each plugin</source>
          <target state="translated">plugins.js将具有一个名为 &lt;code&gt;pluginNames[]&lt;/code&gt; 的数组，我们将在 &lt;code&gt;each()&lt;/code&gt; 上进行迭代，然后在每个插件的头部添加 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
