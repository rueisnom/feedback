<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/950087">
    <body>
      <group id="950087">
        <trans-unit id="206ab3d9bec48efae73640429f4d8678f64506e9" translate="yes" xml:space="preserve">
          <source>(This answer is in response to e-satis' comment).</source>
          <target state="translated">(이 답변은 e-satis의 의견에 대한 답변입니다).</target>
        </trans-unit>
        <trans-unit id="c2f82e6af2dc551c77d47d4e59e40a67261ca803" translate="yes" xml:space="preserve">
          <source>. And it works! Confusing...</source>
          <target state="translated">. 그리고 작동합니다! 혼란스러운 ...</target>
        </trans-unit>
        <trans-unit id="6eae3a5b062c6d0d79f070c26e6d62486b40cb46" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>
        </trans-unit>
        <trans-unit id="56462b98ec98df96345ec73222abd51331f6a57f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://37signals.com/svn/posts/1587-introducing-sprockets-javascript-dependency-management-and-concatenation&quot;&gt;Introducing Sprockets: JavaScript dependency management and concatenation&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://37signals.com/svn/posts/1587-introducing-sprockets-javascript-dependency-management-and-concatenation&quot;&gt;스프로킷 소개 : JavaScript 의존성 관리 및 연결&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c32de899cfb6ec06e8cc06f8e5e9f40a37e92d7c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://calculist.org/blog/2012/06/29/static-module-resolution/&quot;&gt;Static module resolution&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://calculist.org/blog/2012/06/29/static-module-resolution/&quot;&gt;정적 모듈 해상도&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2762c6431432dd5a70cecfb315f7619966f378a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders&quot;&gt;Module loaders&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders&quot;&gt;모듈 로더&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="788fd7a0f4e090824b273e7120114e5c5cbd91d5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;build/main.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;build/main.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6f6bff257cd31d0764b92815c9b9d17e8f561e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;src/Form/Input/Tel.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;src/Form/Input/Tel.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca9ca5e0a3691e6d44f125996c50847fbf836c5c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;src/main.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;src/main.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6a16d8f75b54b1f1f0b21d8ce61fc11b0bba33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CommonJS&lt;/strong&gt; (used in NodeJS)</source>
          <target state="translated">&lt;strong&gt;CommonJS&lt;/strong&gt; (NodeJS에서 사용)</target>
        </trans-unit>
        <trans-unit id="7290c866af5b8bcecf5045b72e9fd6779df65827" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Modules&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 모듈&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bebe38df96c7eb3f3282665cee82c64c21884191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what to do about it ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그래서 어떻게해야합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fcc0aa2abc91d9c0d481b93b0bba6fbd9423c59b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: Mixture is &lt;a href=&quot;http://mixture.io/blog/free/&quot;&gt;now free&lt;/a&gt; (offline).</source>
          <target state="translated">&lt;strong&gt;업데이트&lt;/strong&gt; : 혼합물은 &lt;a href=&quot;http://mixture.io/blog/free/&quot;&gt;이제 무료입니다&lt;/a&gt; (오프라인).</target>
        </trans-unit>
        <trans-unit id="53d014567827ce6d8ba81376d4cbf9262511230d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: Mixture is now discontinued. &lt;a href=&quot;https://github.com/teammixture/mixture.io/issues/6&quot;&gt;Old mixture releases&lt;/a&gt; are still available</source>
          <target state="translated">&lt;strong&gt;업데이트&lt;/strong&gt; : 혼합물이 중단되었습니다. &lt;a href=&quot;https://github.com/teammixture/mixture.io/issues/6&quot;&gt;오래된 혼합물 출시&lt;/a&gt; 는 여전히 가능합니다</target>
        </trans-unit>
        <trans-unit id="f8d6e8d151ca82b2e0671602d8c89392168b089a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;implementation.js&lt;/strong&gt; is your &quot;main&quot; JavaScript file that depends on &lt;strong&gt;some-dependency.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;implementation.js&lt;/strong&gt; 는 &lt;strong&gt;some-dependency.js에 의존&lt;/strong&gt; 하는 &quot;기본&quot;JavaScript 파일입니다.</target>
        </trans-unit>
        <trans-unit id="e090dd13b65625719872427d2c45c23e507646c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;some-dependency.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;some-dependency.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00d49aecf61eefacf881c76b0da44cb61b90c3b6" translate="yes" xml:space="preserve">
          <source>AJAX Loading</source>
          <target state="translated">AJAX 로딩</target>
        </trans-unit>
        <trans-unit id="a858f45b0cd86a8d053c47aed5612e8df1b50a0b" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;https://stackoverflow.com/a/10939737/1676444&quot;&gt;as the second highest voted answer to your question highlights&lt;/a&gt;, &lt;a href=&quot;http://www.requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; can also handle including scripts inside a Web Worker (likely calling &lt;code&gt;importScripts&lt;/code&gt; itself, but with a few other useful features).</source>
          <target state="translated">또는 &lt;a href=&quot;https://stackoverflow.com/a/10939737/1676444&quot;&gt;귀하의 질문에 대한 두 번째로 높은 투표 답변으로&lt;/a&gt; &lt;a href=&quot;http://www.requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; 는 웹 작업자 내부의 스크립트 포함을 가져올 수도 있습니다 ( &lt;code&gt;importScripts&lt;/code&gt; 자체를 호출하지만 다른 유용한 기능이 있음).</target>
        </trans-unit>
        <trans-unit id="104bb6fccb3dd88007fd041a6caf1caa570d887e" translate="yes" xml:space="preserve">
          <source>Although these answers are great, there is a simple &quot;solution&quot; that has been around since script loading existed, and it will cover 99.999% of most people's use cases. Just include the script you need before the script that requires it. For most projects it does not take long to determine which scripts are needed and in what order.</source>
          <target state="translated">이 답변은 훌륭하지만 스크립트로드가 존재 한 이후로 존재하는 간단한 &quot;솔루션&quot;이 있으며 대부분의 사람들이 사용하는 사례의 99.999 %를 차지합니다. 필요한 스크립트 앞에 필요한 스크립트를 포함시키기 만하면됩니다. 대부분의 프로젝트에서 필요한 스크립트와 순서를 결정하는 데 시간이 오래 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b50f51a682a21ea87eb5831332387ee8e672513c" translate="yes" xml:space="preserve">
          <source>And be able to call a function from the required script in the next line:</source>
          <target state="translated">다음 줄에서 필요한 스크립트에서 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="883eb03a9cdc193322e4ba0c284e4929b617cd9b" translate="yes" xml:space="preserve">
          <source>And get the combined file</source>
          <target state="translated">그리고 결합 된 파일을 얻으십시오</target>
        </trans-unit>
        <trans-unit id="26312a853a8a0fed6d13295ff03f0dca11974071" translate="yes" xml:space="preserve">
          <source>And right after including &lt;code&gt;included.js&lt;/code&gt;, the &lt;code&gt;hello()&lt;/code&gt; function is called, and you get the alert.</source>
          <target state="translated">그리고 &lt;code&gt;included.js&lt;/code&gt; 를 포함 하면 &lt;code&gt;hello()&lt;/code&gt; 함수가 호출되고 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f13e6a18a32be72735a2f247839504b514c2563c" translate="yes" xml:space="preserve">
          <source>Another way, that in my opinion is much cleaner, is to make a synchronous Ajax request instead of using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. Which is also how &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; handles includes.</source>
          <target state="translated">내 의견으로는 훨씬 깨끗하다는 또 다른 방법은 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 사용하는 대신 동기 Ajax 요청을하는 것입니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; 가 include를 처리하는 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f421ce52a3901e83133ea470faef7ae69fc93013" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this answer, many developers use build/transpilation tool(s) like Parcel, Webpack, or Babel in their projects, allowing them to use upcoming JavaScript syntax, provide backward compatibility for older browsers, combine files, minify, perform code splitting etc.</source>
          <target state="translated">이 답변의 맨 위에 언급했듯이 많은 개발자는 프로젝트에서 Parcel, Webpack 또는 Babel과 같은 빌드 / 번역 도구를 사용하여 향후 JavaScript 구문을 사용하고, 이전 브라우저에 대한 하위 호환성을 제공하고, 파일을 결합하고, 축소하고, 코드 분할 등을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="949b1e33e3a590719f723351553af804e4929438" translate="yes" xml:space="preserve">
          <source>As you saw, I had use a variable in one JavaScript file in another JavaScript file, but I didn't need to include one in another. I just needed to ensure that the first JavaScript file loaded before the second JavaScript file, and, the first JavaScript file's variables are accessible in the second JavaScript file, automatically.</source>
          <target state="translated">보시다시피, 한 JavaScript 파일의 변수를 다른 JavaScript 파일의 변수를 사용했지만 다른 변수를 포함 할 필요는 없었습니다. 방금 첫 번째 JavaScript 파일이 두 번째 JavaScript 파일보다 먼저로드되고 첫 번째 JavaScript 파일의 변수에 두 번째 JavaScript 파일에서 자동으로 액세스 할 수 있는지 확인해야했습니다.</target>
        </trans-unit>
        <trans-unit id="277120e489ec4b95e6dd7c32060d43032d9152c8" translate="yes" xml:space="preserve">
          <source>As you see, it's easier than Require.js and as convenient as jQuery's &lt;code&gt;$.getScript&lt;/code&gt; method. It also has some advanced features, like conditional loading, feature detection and &lt;a href=&quot;http://headjs.com/site/api/v1.00.html&quot;&gt;much more&lt;/a&gt;.</source>
          <target state="translated">보시다시피 Require.js보다 쉽고 jQuery의 &lt;code&gt;$.getScript&lt;/code&gt; 메소드만큼 편리합니다. 또한 조건부로드, 기능 감지 등과 같은 고급 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="198f9d81f71210a4fe6ffba57567675fdb5e650b" translate="yes" xml:space="preserve">
          <source>BUT:</source>
          <target state="translated">BUT:</target>
        </trans-unit>
        <trans-unit id="2314410b2adc404dde335bb42725bcc7fd26563a" translate="yes" xml:space="preserve">
          <source>Before calling &lt;code&gt;document.writeln&lt;/code&gt;, it checks to make sure the script has not already been loading by evaluating all the script elements.</source>
          <target state="translated">&lt;code&gt;document.writeln&lt;/code&gt; 을 호출하기 전에 모든 스크립트 요소를 평가하여 스크립트가 이미로드되지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2816ea2652eecdb35254f7a8a62138f40ae37f28" translate="yes" xml:space="preserve">
          <source>Both of these solutions are discussed and illustrated in &lt;a href=&quot;http://unixpapa.com/js/dyna.html&quot;&gt;JavaScript Madness: Dynamic Script Loading&lt;/a&gt;.</source>
          <target state="translated">이러한 솔루션은 모두 &lt;a href=&quot;http://unixpapa.com/js/dyna.html&quot;&gt;JavaScript Madness : Dynamic Script Loading에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="caabcacc0f9cf84e44c7d32424a5dc4629a4c721" translate="yes" xml:space="preserve">
          <source>Browsers do not support this moduling system yet so in order for you to use this syntax you must use a bundler like webpack. Using a bundler is better anyway because this can combine all of your different files into a single (or couple related) files. This will serve the files from the server to the client faster because each HTTP request has some associated overhead accompanied with it. Thus by reducing the overal HTTP request we improve the performance. Here is an example of ES6 modules:</source>
          <target state="translated">브라우저는 아직이 변조 시스템을 지원하지 않으므로이 구문을 사용하려면 webpack과 같은 번 들러를 사용해야합니다. 번 들러를 사용하면 다른 모든 파일을 단일 (또는 커플 관련) 파일로 결합 할 수 있으므로 더 좋습니다. 각 HTTP 요청에는 이와 관련된 일부 오버 헤드가 있으므로 서버에서 클라이언트로 파일을 더 빨리 제공합니다. 따라서 전체 HTTP 요청을 줄임으로써 성능을 향상시킵니다. ES6 모듈의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b337cd4902acd58b0de99a8784fe0ca89f41d186" translate="yes" xml:space="preserve">
          <source>Browsers have had support for loading ECMAScript modules directly (no tools like Webpack required) &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;since&lt;/a&gt; Safari 10.1, Chrome 61, Firefox 60, and Edge 16. Check the current support at &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;caniuse&lt;/a&gt;. There is no need to use Node.js' &lt;code&gt;.mjs&lt;/code&gt; extension; browsers completely ignore file extensions on modules/scripts.</source>
          <target state="translated">브라우저는 Safari 10.1, Chrome 61, Firefox 60 및 Edge 16 &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;이후&lt;/a&gt; ECMAScript 모듈을 직접로드 할 수 있습니다 (웹팩과 같은 도구는 필요하지 않음). &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;caniuse&lt;/a&gt; 에서 현재 지원을 확인하십시오. Node.js의 &lt;code&gt;.mjs&lt;/code&gt; 확장자를 사용할 필요는 없습니다. 브라우저는 모듈 / 스크립트의 파일 확장자를 완전히 무시합니다.</target>
        </trans-unit>
        <trans-unit id="522ce0fcef4ca6aef8ba20db065f82588818d7ac" translate="yes" xml:space="preserve">
          <source>But if that is not a problem for you, then this method should work.</source>
          <target state="translated">그러나 이것이 문제가되지 않으면이 방법이 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="1bbb812967de17c1fec9aa4b70a28049b6474a4a" translate="yes" xml:space="preserve">
          <source>But since 2015 (ES6), JavaScript has had the &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES6 modules&lt;/a&gt; standard to import modules in Node.js, which is also supported by &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;most modern browsers&lt;/a&gt;.</source>
          <target state="translated">그러나 2015 년 (ES6) 이후 JavaScript는 Node.js에서 모듈을 가져 오기위한 &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES6 모듈&lt;/a&gt; 표준을 가지고 있으며 이는 &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;대부분의 최신 브라우저&lt;/a&gt; 에서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5df356af95c22125fad799a05f636daf7b8b6f4f" translate="yes" xml:space="preserve">
          <source>Define dependencies as modules:</source>
          <target state="translated">종속성을 모듈로 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="efb211ea4156611a7cf5952316e1ba2fb95ae811" translate="yes" xml:space="preserve">
          <source>Detecting when the script has been executed</source>
          <target state="translated">스크립트가 언제 실행되었는지 감지</target>
        </trans-unit>
        <trans-unit id="e8e7c59c81ba090cb40a7e03782de9db506696ec" translate="yes" xml:space="preserve">
          <source>Dynamic Script Loading</source>
          <target state="translated">동적 스크립트 로딩</target>
        </trans-unit>
        <trans-unit id="386cf3c6e6b0464ad5cbc22efde8538c6548eced" translate="yes" xml:space="preserve">
          <source>Dynamic imports in browsers</source>
          <target state="translated">브라우저에서 동적 가져 오기</target>
        </trans-unit>
        <trans-unit id="d9d3d46b339478880eb52f7f9c0e16f1cb5a0500" translate="yes" xml:space="preserve">
          <source>Dynamic imports let the script load other scripts as needed:</source>
          <target state="translated">동적 가져 오기를 통해 스크립트가 필요에 따라 다른 스크립트를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d388c8604db3813ddb87de2fb1c3f60be9f8222a" translate="yes" xml:space="preserve">
          <source>ECMAScript (ES6) modules have been &lt;a href=&quot;https://nodejs.org/api/esm.html&quot;&gt;supported in Node.js&lt;/a&gt; since v8.5, with the &lt;code&gt;--experimental-modules&lt;/code&gt; flag, and since at least Node.js v13.8.0 without the flag. To enable &quot;ESM&quot; (vs. Node.js's previous CommonJS-style module system [&quot;CJS&quot;]) you either use &lt;code&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt; in &lt;code&gt;package.json&lt;/code&gt; or give the files the extension &lt;code&gt;.mjs&lt;/code&gt;. (Similarly, modules written with Node.js's previous CJS module can be named &lt;code&gt;.cjs&lt;/code&gt; if your default is ESM.)</source>
          <target state="translated">ECMAScript (ES6) 모듈은 &lt;code&gt;--experimental-modules&lt;/code&gt; 플래그가있는 v8.5 이후 및 플래그가없는 Node.js v13.8.0 이상부터 &lt;a href=&quot;https://nodejs.org/api/esm.html&quot;&gt;Node.js&lt;/a&gt; 에서 지원 되었습니다. &quot;ESM&quot;(vs. Node.js의 이전 CommonJS 스타일 모듈 시스템 [ &quot;CJS&quot;])을 사용하려면 &lt;code&gt;package.json&lt;/code&gt; 에서 &lt;code&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt; 을 사용하거나 파일 확장자를 &lt;code&gt;.mjs&lt;/code&gt; 로 지정하십시오 . 비슷하게 Node.js의 이전 CJS 모듈로 작성된 모듈의 이름은 기본값이 ESM 인 경우 &lt;code&gt;.cjs&lt;/code&gt; 로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec6cc0d49bcb01cd50cba9ddb3ed7b2944cb238" translate="yes" xml:space="preserve">
          <source>ECMAScript modules in browsers</source>
          <target state="translated">브라우저의 ECMAScript 모듈</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6 모듈</target>
        </trans-unit>
        <trans-unit id="78859e0aa530ac3119a27bb18cf0fc2aeb91ad89" translate="yes" xml:space="preserve">
          <source>Even though all of the plugins get dropped into the head tag the way they ought to, they don't always get run by the browser when you click into the page or refresh.</source>
          <target state="translated">모든 플러그인이 원하는 방식으로 헤드 태그에 들어가더라도 페이지를 클릭하거나 새로 고칠 때 브라우저에서 항상 실행되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="b4136dcf903eb3c76fe317c65ef053453e8cdc32" translate="yes" xml:space="preserve">
          <source>Excerpt from the &lt;a href=&quot;https://github.com/jrburke/requirejs&quot;&gt;GitHub&lt;/a&gt; README:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/jrburke/requirejs&quot;&gt;GitHub&lt;/a&gt; 읽어보기에서 발췌 :</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="b5cbd3434bd596109a8781b509798ab1da4452a6" translate="yes" xml:space="preserve">
          <source>F5</source>
          <target state="translated">F5</target>
        </trans-unit>
        <trans-unit id="94716db44426788000dfcbae9cba45638f7cc496" translate="yes" xml:space="preserve">
          <source>Fetch Loading</source>
          <target state="translated">페치 로딩</target>
        </trans-unit>
        <trans-unit id="52af92858e80319c3e320b7210c45af2d1252260" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;main.js.php&lt;/code&gt;:</source>
          <target state="translated">파일 &lt;code&gt;main.js.php&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="97e1664caa79aa71082bd60226618665682535d9" translate="yes" xml:space="preserve">
          <source>File1:</source>
          <target state="translated">File1:</target>
        </trans-unit>
        <trans-unit id="730fd0522d514826c9aaf7d211a195d36c9b867d" translate="yes" xml:space="preserve">
          <source>File2:</source>
          <target state="translated">File2:</target>
        </trans-unit>
        <trans-unit id="2e8382e08c9bb01c7e1654bd24c7e7f77f55dbf0" translate="yes" xml:space="preserve">
          <source>File3:</source>
          <target state="translated">File3:</target>
        </trans-unit>
        <trans-unit id="775ecf6ee49f69f0ed328c8af1660730b48d6a2e" translate="yes" xml:space="preserve">
          <source>File: main.js</source>
          <target state="translated">파일 : main.js</target>
        </trans-unit>
        <trans-unit id="fed8f02dc3fd97daef37a09c9513fac304867fe6" translate="yes" xml:space="preserve">
          <source>File: myvariables.js</source>
          <target state="translated">파일 : myvariables.js</target>
        </trans-unit>
        <trans-unit id="f973768795a937dcadac26fc7473d3746b5da826" translate="yes" xml:space="preserve">
          <source>For compatibility with older browsers, build tools like &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; and/or transpilation tools like &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; can be used.</source>
          <target state="translated">구형 브라우저와의 호환성을 위해 &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; 및 &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; 과 같은 빌드 도구 및 / 또는 &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 과 같은 변환 툴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2147bfcc0f0f7c3cef6200f4753cf79500f046" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;my_lovely_script.js&lt;/code&gt; contains &lt;code&gt;MySuperObject&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;my_lovely_script.js&lt;/code&gt; 는 &lt;code&gt;MySuperObject&lt;/code&gt; 를 포함 합니다 .</target>
        </trans-unit>
        <trans-unit id="759d7f8d0ebbe76c3a7b37e810db7f723123b25b" translate="yes" xml:space="preserve">
          <source>For this I did as below:</source>
          <target state="translated">이를 위해 다음과 같이했습니다.</target>
        </trans-unit>
        <trans-unit id="34a3ad15283216601c4c7025cdfabd88fdbb3275" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries&quot;&gt;Web Workers have their own &lt;code&gt;importScripts&lt;/code&gt; function&lt;/a&gt; which is a global function in the scope of the Web Worker, native to the browser itself as it &lt;a href=&quot;https://html.spec.whatwg.org/multipage/workers.html#importing-scripts-and-libraries&quot;&gt;is part of the specification&lt;/a&gt;.</source>
          <target state="translated">다행스럽게도 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries&quot;&gt;웹 워커는 자신의 &lt;code&gt;importScripts&lt;/code&gt; 기능을&lt;/a&gt; 가지고 있는데, &lt;a href=&quot;https://html.spec.whatwg.org/multipage/workers.html#importing-scripts-and-libraries&quot;&gt;이는 스펙의 일부인&lt;/a&gt; 브라우저 자체에 고유 한 웹 워커 범위의 글로벌 함수입니다.</target>
        </trans-unit>
        <trans-unit id="67960c2c77f8b866584719b8e48c2e8eda27e92f" translate="yes" xml:space="preserve">
          <source>From the Mixture documentation on &lt;code&gt;.mix&lt;/code&gt; files:</source>
          <target state="translated">&lt;code&gt;.mix&lt;/code&gt; 파일의 혼합물 설명서에서 :</target>
        </trans-unit>
        <trans-unit id="43906746944eafb56d9523b37e70f7bd285ad8e4" translate="yes" xml:space="preserve">
          <source>Gist: &lt;a href=&quot;http://gist.github.com/284442&quot;&gt;http://gist.github.com/284442&lt;/a&gt;.</source>
          <target state="translated">요점 : &lt;a href=&quot;http://gist.github.com/284442&quot;&gt;http://gist.github.com/284442&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c973140512dda715ec8b98cd19e4abc17e64227e" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;synchronous&lt;/strong&gt; version &lt;strong&gt;without jQuery&lt;/strong&gt;:</source>
          <target state="translated">다음은 &lt;strong&gt;jQuery&lt;/strong&gt; 가없는 &lt;strong&gt;동기&lt;/strong&gt; 버전입니다.</target>
        </trans-unit>
        <trans-unit id="24b79cca1f32a4977bb54091e81e918ad5543042" translate="yes" xml:space="preserve">
          <source>Here is an example of how this could work:</source>
          <target state="translated">이것이 어떻게 작동하는지에 대한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c836ed859d15dd35abf3de4024c47570ffc40a21" translate="yes" xml:space="preserve">
          <source>Here's an example &lt;code&gt;.mix&lt;/code&gt; file that combines multiple &lt;code&gt;.js&lt;/code&gt; files into one:</source>
          <target state="translated">다음은 여러 &lt;code&gt;.js&lt;/code&gt; 파일을 하나로 결합하는 예제 &lt;code&gt;.mix&lt;/code&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="a0a735f6041355a8e31634a70ac885a99ea8fc46" translate="yes" xml:space="preserve">
          <source>Here's an example using jQuery:</source>
          <target state="translated">다음은 jQuery를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="3d4d50089b78caa8accdb20b9de1e3e36a7c71dd" translate="yes" xml:space="preserve">
          <source>Here's an explanation of how the code works for those that are curious: essentially, it creates a new script tag (after the first one) of the URL. It sets it to asynchronous mode so it doesn't block the rest of the code, but calls a callback when the readyState (the state of the content to be loaded) changes to 'loaded'.</source>
          <target state="translated">호기심이 많은 사람들의 코드 작동 방식에 대한 설명은 다음과 같습니다. 기본적으로 URL의 첫 스크립트 태그 뒤에 새 스크립트 태그를 만듭니다. 비동기 코드로 설정하여 나머지 코드를 차단하지 않지만 readyState (로드 할 내용의 상태)가 'loaded'로 변경되면 콜백을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="687874dfffbfcb582922598a2058fbf71cfb4713" translate="yes" xml:space="preserve">
          <source>Here's the generalized version of how Facebook does it for their ubiquitous Like button:</source>
          <target state="translated">다음은 Facebook의 유비쿼터스 좋아요 버튼에 대해 Facebook이 수행하는 방식의 일반화 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="512061e76228d02949b902d49c6ed3f12388bcca" translate="yes" xml:space="preserve">
          <source>How do I include a JavaScript file in another JavaScript file</source>
          <target state="translated">다른 JavaScript 파일에 JavaScript 파일을 포함시키는 방법</target>
        </trans-unit>
        <trans-unit id="f534ee42b1b1417c1c4328067f9e323c71e4cd19" translate="yes" xml:space="preserve">
          <source>However, this method also has a problem: if an error happens in the imported JavaScript file, &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; (and also Firefox Error Console and &lt;a href=&quot;https://developers.google.com/chrome-developer-tools/&quot;&gt;Chrome Developer Tools&lt;/a&gt; as well) will report its place incorrectly, which is a big problem if you use Firebug to track JavaScript errors down a lot (I do). Firebug simply doesn't know about the newly loaded file for some reason, so if an error occurs in that file, it reports that it occurred in your main &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; file, and you will have trouble finding out the real reason for the error.</source>
          <target state="translated">그러나이 방법에도 문제가 있습니다. 가져온 JavaScript 파일에서 오류가 발생하면 &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; (및 Firefox 오류 콘솔 및 &lt;a href=&quot;https://developers.google.com/chrome-developer-tools/&quot;&gt;Chrome 개발자 도구&lt;/a&gt; )도 잘못된 위치를보고하므로 Firebug를 사용하여 추적하는 경우 큰 문제입니다 JavaScript 오류가 많이 발생합니다 (그렇습니다). Firebug는 어떤 이유로 든 새로로드 된 파일에 대해 단순히 알지 못하므로 해당 파일에서 오류가 발생하면 기본 &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; 파일에서 발생한 것으로보고하여 오류의 실제 원인을 찾는 데 어려움을 겪습니다.</target>
        </trans-unit>
        <trans-unit id="96ce64ab269dff867b5298523efe17ef57bf386e" translate="yes" xml:space="preserve">
          <source>I also made a simple test for this at &lt;a href=&quot;http://www.kipras.com/dev/import_js_test/&quot;&gt;Example&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;http://www.kipras.com/dev/import_js_test/&quot;&gt;Example&lt;/a&gt; 에서 간단한 테스트를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="052345c2ec801d63db4bca3da6cc49e6666d2a55" translate="yes" xml:space="preserve">
          <source>I assume that a script is not fully executed until its &lt;code&gt;document.ready&lt;/code&gt; event has been executed. (I know using &lt;code&gt;document.ready&lt;/code&gt; is not required, but many people use it, and handling this is a safeguard.)</source>
          <target state="translated">나는 &lt;code&gt;document.ready&lt;/code&gt; 이벤트가 실행될 때까지 스크립트가 완전히 실행되지 않았다고 가정합니다. (나는 &lt;code&gt;document.ready&lt;/code&gt; 를 사용할 필요는 없지만 많은 사람들이 그것을 사용한다는 것을 알고 있으며 이것을 처리하는 것이 안전합니다.)</target>
        </trans-unit>
        <trans-unit id="bcf92d81ab2e9f8567b02bf77422af88d42f8420" translate="yes" xml:space="preserve">
          <source>I came to this question because I was looking for a simple way to maintain a collection of useful JavaScript plugins. After seeing some of the solutions here, I came up with this:</source>
          <target state="translated">유용한 JavaScript 플러그인 모음을 유지 관리하는 간단한 방법을 찾고 있었기 때문에이 질문에 왔습니다. 여기에 몇 가지 해결책을 본 후에 나는 이것을 생각해 냈습니다.</target>
        </trans-unit>
        <trans-unit id="76ea63d97f56a6085f1fd0905c71733444f736e3" translate="yes" xml:space="preserve">
          <source>I decided to go backwards instead of forwards. Thank you &lt;code&gt;document.writeln&lt;/code&gt;. I know it's taboo, but as long as it is used correctly this works well. You end up with code that can be debugged easily, shows in the DOM correctly and can ensure the order the dependencies are loaded correctly.</source>
          <target state="translated">나는 앞으로가 아니라 뒤로 가기로 결정했습니다. &lt;code&gt;document.writeln&lt;/code&gt; 감사합니다. 나는 그것이 금기임을 알고 있지만 올바르게 사용되는 한 잘 작동합니다. 결국 쉽게 디버깅 할 수 있고 DOM에 올바르게 표시되고 종속성이 올바르게로드되는 순서를 보장 할 수있는 코드로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="e71ee8ddaf9dbce0706f9609b8c87eec82c91b6d" translate="yes" xml:space="preserve">
          <source>I had a simple issue, but I was baffled by responses to this question.</source>
          <target state="translated">나는 간단한 문제가 있었지만이 질문에 대한 답변으로 당황했다.</target>
        </trans-unit>
        <trans-unit id="e90313ba30b8afab25bd3404bda1adf05507004e" translate="yes" xml:space="preserve">
          <source>I had to use a variable (myVar1) defined in one JavaScript file (myvariables.js) in another JavaScript file (main.js).</source>
          <target state="translated">한 JavaScript 파일 (myvariables.js)에 정의 된 변수 (myVar1)를 다른 JavaScript 파일 (main.js)을 사용해야했습니다.</target>
        </trans-unit>
        <trans-unit id="e78b6aa2c0deda3aa7dbaba4a6e64774f7b7faa0" translate="yes" xml:space="preserve">
          <source>I have actually written a jQuery plugin called &lt;em&gt;$.import_js()&lt;/em&gt; which uses this method:</source>
          <target state="translated">실제로이 방법을 사용하는 &lt;em&gt;$ .import_js ()&lt;/em&gt; 라는 jQuery 플러그인을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="4a561d066341fa04c3643f7a3595cf6b9722249e" translate="yes" xml:space="preserve">
          <source>I just wrote this JavaScript code (using &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt; for &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; manipulation):</source>
          <target state="translated">방금이 JavaScript 코드를 작성했습니다 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; 조작에 &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;프로토 타입&lt;/a&gt; 사용).</target>
        </trans-unit>
        <trans-unit id="8964113a372044579ef717f6641fb9d359e68a92" translate="yes" xml:space="preserve">
          <source>I liked the idea of extending jQuery, but obviously you don't need to.</source>
          <target state="translated">jQuery를 확장한다는 아이디어가 마음에 들었지만 반드시 그럴 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="48b6e1e53bcee394381ab4d7bb07cd633f263a4a" translate="yes" xml:space="preserve">
          <source>I use &lt;a href=&quot;https://github.com/sstephenson/sprockets&quot;&gt;Sprockets&lt;/a&gt; (I don't know if there are others). You build your JavaScript code in separate files and include comments that are processed by the Sprockets engine as includes. For development you can include files sequentially, then for production to merge them...</source>
          <target state="translated">나는 &lt;a href=&quot;https://github.com/sstephenson/sprockets&quot;&gt;스프로킷을&lt;/a&gt; 사용합니다 (다른 것이 있는지 모르겠습니다). 별도의 파일로 JavaScript 코드를 작성하고 Sprockets 엔진에서 처리 한 주석을 포함으로 포함합니다. 개발을 위해 파일을 순차적으로 포함시킨 다음 프로덕션 환경에서 파일을 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="182b551075d667e89774a12930481224b9f18f97" translate="yes" xml:space="preserve">
          <source>I wrote a simple module that automates the job of importing/including module scripts in JavaScript. For detailed explanation of the code, refer to the blog post &lt;em&gt;&lt;a href=&quot;http://stamat.wordpress.com/2013/04/12/javascript-require-import-include-modules/&quot;&gt;JavaScript require / import / include modules&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">JavaScript로 모듈 스크립트 가져 오기 / 포함 작업을 자동화하는 간단한 모듈을 작성했습니다. 코드에 대한 자세한 설명은 블로그 게시물 &lt;em&gt;&lt;a href=&quot;http://stamat.wordpress.com/2013/04/12/javascript-require-import-include-modules/&quot;&gt;JavaScript require / import / include 모듈을&lt;/a&gt;&lt;/em&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b95b09b19967e0602d178894a47c43cfd08dc83" translate="yes" xml:space="preserve">
          <source>I've found it's more reliable to just write the script tags in a PHP include. You only have to write it once and that's just as much work as calling the plugin using JavaScript.</source>
          <target state="translated">PHP include에 스크립트 태그를 작성하는 것이 더 안정적이라는 것을 알았습니다. 한 번만 작성하면 JavaScript를 사용하여 플러그인을 호출하는 것만큼이나 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="50692954f36df35776c3a5384707e2028295c3dc" translate="yes" xml:space="preserve">
          <source>If anyone is looking for something more advanced, try out &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;. You'll get added benefits such as dependency management, better concurrency, and avoid duplication (that is, retrieving a script more than once).</source>
          <target state="translated">더 진보 된 것을 찾는 사람이라면 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS를&lt;/a&gt; 사용해보십시오. 종속성 관리, 동시성 향상 및 복제 방지 (스크립트를 두 번 이상 검색)와 같은 추가 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09c49c729196296537941a7491dbe605bca62236" translate="yes" xml:space="preserve">
          <source>If it works for Facebook, it will work for you.</source>
          <target state="translated">Facebook에서 작동하면 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0e6f46db11f475cee8f6fa8e7e1cdd71fa87a80" translate="yes" xml:space="preserve">
          <source>If script2 requires script1, this really is the absolute easiest way to do something like this. I'm very surprised no-one has brought this up, as it's the most obvious and simplest answer that will apply in nearly every single case.</source>
          <target state="translated">script2에 script1이 필요한 경우 실제로 이와 같은 작업을 수행하는 가장 쉬운 방법입니다. 거의 모든 경우에 적용되는 가장 분명하고 간단한 답변이기 때문에 아무도 이것을 제기하지 않은 것에 매우 놀랐습니다.</target>
        </trans-unit>
        <trans-unit id="08d0f5c8d3d6ff132321aa6d959d367e737ba43f" translate="yes" xml:space="preserve">
          <source>If you use the jQuery library, you can use the &lt;code&gt;$.getScript&lt;/code&gt; method.</source>
          <target state="translated">jQuery 라이브러리를 사용하는 경우 &lt;code&gt;$.getScript&lt;/code&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d3524e0e4d4cd1e4cf3277f0741ff66c1dc55d6" translate="yes" xml:space="preserve">
          <source>If you want in pure JavaScript, you can use &lt;code&gt;document.write&lt;/code&gt;.</source>
          <target state="translated">순수한 JavaScript로 원한다면 &lt;code&gt;document.write&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad91c62be5e861663504e4455fee22384fc00bcf" translate="yes" xml:space="preserve">
          <source>If your intention to load the JavaScript file is &lt;strong&gt;using the functions from the imported/included file&lt;/strong&gt;, you can also define a global object and set the functions as object items. For instance:</source>
          <target state="translated">JavaScript 파일을로드하려는 의도가 가져 오기 &lt;strong&gt;/ 포함 파일의 함수를 사용하는&lt;/strong&gt; 경우 전역 오브젝트를 정의하고 함수를 오브젝트 항목으로 설정할 수도 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="87d10a4bf452ed2df2e36493992bb6eac702495c" translate="yes" xml:space="preserve">
          <source>In case you are using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage&quot;&gt;Web Workers&lt;/a&gt; and want to include additional scripts in the scope of the worker, the other answers provided about adding scripts to the &lt;code&gt;head&lt;/code&gt; tag, etc. will not work for you.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage&quot;&gt;웹 워커를&lt;/a&gt; 사용 중이고 워커 범위에 추가 스크립트를 포함하려는 경우 &lt;code&gt;head&lt;/code&gt; 태그에 스크립트를 추가하는 등의 다른 답변은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c372dfb440124c48faeedb667ad1686636faba8f" translate="yes" xml:space="preserve">
          <source>In modern language with the check if script has already been loaded it would be:</source>
          <target state="translated">스크립트가 이미로드되어 있는지 확인하는 현대 언어에서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89e569c5aabe9fbbde286f6fa71cb13e5d555b8c" translate="yes" xml:space="preserve">
          <source>Instead of this approach you could attempt to modify the jQuery &lt;code&gt;readyList&lt;/code&gt;, but this seemed like a worse solution.</source>
          <target state="translated">이 접근법 대신 jQuery &lt;code&gt;readyList&lt;/code&gt; 를 수정하려고 시도 할 수는 있지만 더 나쁜 해결책 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="5198a78bb0d30cc8cf91f499bbb47db39eac32c1" translate="yes" xml:space="preserve">
          <source>Is there something in JavaScript similar to &lt;code&gt;@import&lt;/code&gt; in CSS that allows you to include a JavaScript file inside another JavaScript file?</source>
          <target state="translated">JavaScript의 &lt;code&gt;@import&lt;/code&gt; 와 비슷한 JavaScript에 다른 JavaScript 파일 내에 JavaScript 파일을 포함시킬 수있는 것이 있습니까?</target>
        </trans-unit>
        <trans-unit id="a0c170f044d1b6605820b898a6064dddbee3d16e" translate="yes" xml:space="preserve">
          <source>It includes a &lt;code&gt;main.js&lt;/code&gt; file in the main HTML and then the script in &lt;code&gt;main.js&lt;/code&gt; uses &lt;code&gt;$.import_js()&lt;/code&gt; to import an additional file called &lt;code&gt;included.js&lt;/code&gt;, which defines this function:</source>
          <target state="translated">기본 HTML에 &lt;code&gt;main.js&lt;/code&gt; 파일이 포함 된 다음 &lt;code&gt;main.js&lt;/code&gt; 의 스크립트는 &lt;code&gt;$.import_js()&lt;/code&gt; 를 사용하여 다음 함수를 정의하는 &lt;code&gt;included.js&lt;/code&gt; 라는 추가 파일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cc1c709a99169050e868f3572e201e60f18ff0c4" translate="yes" xml:space="preserve">
          <source>It is possible to dynamically generate a JavaScript tag and append it to HTML document from inside other JavaScript code. This will load targeted JavaScript file.</source>
          <target state="translated">JavaScript 태그를 동적으로 생성하여 다른 JavaScript 코드 내에서 HTML 문서에 추가 할 수 있습니다. 대상 JavaScript 파일이로드됩니다.</target>
        </trans-unit>
        <trans-unit id="299027586058c2f57df63257e78428635d35de48" translate="yes" xml:space="preserve">
          <source>It means that if you use these tricks directly, &lt;em&gt;you won't be able to use your newly loaded code the next line after you asked it to be loaded&lt;/em&gt;, because it will be still loading.</source>
          <target state="translated">즉, 이러한 트릭을 직접 사용하는 경우 &lt;em&gt;새로로드 된 코드를로드 요청 후 다음 줄에서 사용할 수 없습니다&lt;/em&gt; .로드가 계속 진행 중이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b01ba72d4fd35a9d4c4c9996b99e2fd452fde924" translate="yes" xml:space="preserve">
          <source>It works great and uses no page-reloads for me. I've tried the AJAX method (one of the other answers) but it doesn't seem to work as nicely for me.</source>
          <target state="translated">그것은 훌륭하게 작동하며 페이지 다시로드를 사용하지 않습니다. AJAX 방법 (다른 답변 중 하나)을 시도했지만 나에게 잘 작동하지 않는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5daad8292815a8f471b32cc8d290ff531ccef25" translate="yes" xml:space="preserve">
          <source>Like Dynamic Imports you can load one or many scripts with a &lt;code&gt;fetch&lt;/code&gt; call using promises to control order of execution for script dependencies using the &lt;a href=&quot;https://git.habd.as/jhabdas/fetch-inject&quot;&gt;Fetch Inject&lt;/a&gt; library:</source>
          <target state="translated">동적 가져 오기와 마찬가지로 &lt;a href=&quot;https://git.habd.as/jhabdas/fetch-inject&quot;&gt;Fetch Inject&lt;/a&gt; 라이브러리를 사용하여 스크립트 종속성에 대한 실행 순서를 제어하는 ​​약속을 사용하여 &lt;code&gt;fetch&lt;/code&gt; 호출로 하나 이상의 스크립트를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fcc19aee2e562ac4b64c23515ff5bb055bba5e1" translate="yes" xml:space="preserve">
          <source>Loaded the JavaScript code in the HTML file, in the correct order, myvariables.js first, then main.js:</source>
          <target state="translated">JavaScript 파일을 HTML 파일에 올바른 순서로 myvariables.js를 먼저 입력 한 다음 main.js로로드했습니다.</target>
        </trans-unit>
        <trans-unit id="7475b8cb4b8b4b0ea0bd2e2735262e923671b358" translate="yes" xml:space="preserve">
          <source>Manually call just the one file in your head:</source>
          <target state="translated">머리에있는 파일 하나만 수동으로 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c0955483993644c2d345d5478838388a3821a9ea" translate="yes" xml:space="preserve">
          <source>Maybe you can use this function that I found on this page &lt;em&gt;&lt;a href=&quot;http://forums.digitalpoint.com/showthread.php?t=146094&quot;&gt;How do I include a JavaScript file in a JavaScript file?&lt;/a&gt;&lt;/em&gt;:</source>
          <target state="translated">이 페이지에서 찾은이 기능을 사용할 수 있습니다 &lt;em&gt;&lt;a href=&quot;http://forums.digitalpoint.com/showthread.php?t=146094&quot;&gt;. JavaScript 파일에 JavaScript 파일을 어떻게 포함 시키나요?&lt;/a&gt;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="e8d91a207629cab68b84bde0bfdf97bd5b2fd884" translate="yes" xml:space="preserve">
          <source>Mix files are simply .js or .css files with .mix. in the file name. A
  mix file simply     extends the functionality of a normal style or
  script file and allows you to import and combine.</source>
          <target state="translated">믹스 파일은 .mix가 포함 된 .js 또는 .css 파일입니다. 파일 이름에. 믹스 파일은 단순히 일반 스타일 또는 스크립트 파일의 기능을 확장하여 가져오고 결합 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="481ac87a7bba22c45887cc5c7ea78c63b449b061" translate="yes" xml:space="preserve">
          <source>Mixture outputs this as &lt;code&gt;scripts-global.js&lt;/code&gt; and also as a minified version (&lt;code&gt;scripts-global.min.js&lt;/code&gt;).</source>
          <target state="translated">Mixture는이를 &lt;code&gt;scripts-global.js&lt;/code&gt; 및 축소 버전 ( &lt;code&gt;scripts-global.min.js&lt;/code&gt; )으로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="3a067d11c89c1bd83a9bd5ce416dd2e152f89832" translate="yes" xml:space="preserve">
          <source>Most of solutions shown here imply dynamical loading. I was searching instead for a compiler which assemble all the depended files into a single output file. The same as &lt;a href=&quot;http://en.wikipedia.org/wiki/Less_%28stylesheet_language%29&quot;&gt;Less&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass&lt;/a&gt; preprocessors deal with the CSS &lt;code&gt;@import&lt;/code&gt; at-rule. Since I didn't find anything decent of this sort, I wrote a simple tool solving the issue.</source>
          <target state="translated">여기에 표시된 대부분의 솔루션은 동적 로딩을 의미합니다. 대신 모든 종속 파일을 단일 출력 파일로 어셈블하는 컴파일러를 찾고있었습니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Less_%28stylesheet_language%29&quot;&gt;Less&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass&lt;/a&gt; 전처리 기와 동일하게 CSS &lt;code&gt;@import&lt;/code&gt; at-rule을 처리합니다. 이런 종류의 점을 찾지 못했기 때문에 문제를 해결하는 간단한 도구를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="80d75005f71e84434c0fa44621569283aced2efa" translate="yes" xml:space="preserve">
          <source>My usual method is:</source>
          <target state="translated">내 일반적인 방법은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="cd04c41011b8c6a90b8d3d406e8973f00f118915" translate="yes" xml:space="preserve">
          <source>NOTE: You must use this only while the page is loading, otherwise you get a blank screen. In other words, &lt;strong&gt;always place this before / outside of document.ready&lt;/strong&gt;. I have not tested using this after the page is loaded in a click event or anything like that, but I am pretty sure it'll fail.</source>
          <target state="translated">참고 : 페이지를로드하는 동안에 만 사용해야하며, 그렇지 않으면 빈 화면이 나타납니다. 즉, &lt;strong&gt;항상 document.ready 앞 / 뒤에 배치하십시오&lt;/strong&gt; . 페이지가 클릭 이벤트 또는 이와 유사한 것으로로드 된 후에 이것을 사용하여 테스트하지는 않았지만 실패 할 것이라고 확신합니다.</target>
        </trans-unit>
        <trans-unit id="0ce496c371b0e9f99e92db6d770461268fed0859" translate="yes" xml:space="preserve">
          <source>Node.js require</source>
          <target state="translated">Node.js가 필요합니다</target>
        </trans-unit>
        <trans-unit id="70393d4cd6440f7071aab91842a254a103787886" translate="yes" xml:space="preserve">
          <source>Note that the script may execute after the DOM has loaded, or before, depending on the browser and whether you included the line &lt;code&gt;script.async = false;&lt;/code&gt;. There's a &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/script-loading/&quot;&gt;great article on Javascript loading in general&lt;/a&gt; which discusses this.</source>
          <target state="translated">스크립트는 브라우저에 따라 DOM이로드 된 후 또는 이전에 실행될 수 있으며 스크립트를 포함했는지 여부에 따라 스크립트가 실행될 수 있습니다 &lt;code&gt;script.async = false;&lt;/code&gt; . &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/script-loading/&quot;&gt;Javascript 로딩에&lt;/a&gt; 대한 훌륭한 기사 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff2891b93715f3f936e6b7d24ad6fad0a5319c90" translate="yes" xml:space="preserve">
          <source>Note that to get this working cross-domain, the server will need to set &lt;code&gt;allow-origin&lt;/code&gt; header in its response.</source>
          <target state="translated">이 작동하는 도메인 간을 가져 오려면 서버가 응답에서 &lt;code&gt;allow-origin&lt;/code&gt; 헤더를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5f3eb8c4ce200ec467cdef1208486ed2b2ad0c8" translate="yes" xml:space="preserve">
          <source>Note: I'm not in any way affiliated with Mixture, other than using it as a front-end development tool. I came across this question upon seeing a &lt;code&gt;.mix&lt;/code&gt; JavaScript file in action (in one of the Mixture boilerplates) and being a bit confused by it (&quot;you can do this?&quot; I thought to myself). Then I realized that it was an application-specific file type (somewhat disappointing, agreed). Nevertheless, figured the knowledge might be helpful for others.</source>
          <target state="translated">참고 : 저는 Mixture를 프론트 엔드 개발 도구로 사용하는 것 외에는 어떤 방식으로도 Mixture와 제휴하지 않습니다. 나는 &lt;code&gt;.mix&lt;/code&gt; JavaScript 파일이 (Mixture 상용구 중 하나에서) 작동하고 약간 혼란스러워 보이는 것을 보았을 때이 질문에 부딪쳤다 . 그런 다음 그것이 응용 프로그램 특정 파일 형식이라는 것을 깨달았습니다 (약간 실망스럽고 동의했습니다). 그럼에도 불구하고 지식이 다른 사람들에게 도움이 될 것이라고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="d5361b0d202b75a326b27f5abc5966b30b92c5ab" translate="yes" xml:space="preserve">
          <source>Now we can run the compiler:</source>
          <target state="translated">이제 컴파일러를 실행할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="be1e395612e56b219495a2511f226e4a6bbad566" translate="yes" xml:space="preserve">
          <source>Now, there is a big issue you must know about. Doing that implies that &lt;em&gt;you remotely load the code&lt;/em&gt;. Modern web browsers will load the file and keep executing your current script because they load everything asynchronously to improve performance. (This applies to both the jQuery method and the manual dynamic script loading method.)</source>
          <target state="translated">이제 알아야 할 큰 문제가 있습니다. 그렇게하면 &lt;em&gt;원격으로 코드를로드 할 수 있습니다&lt;/em&gt; . 최신 웹 브라우저는 파일을로드하고 성능을 향상시키기 위해 모든 것을 비동기식으로로드하기 때문에 현재 스크립트를 계속 실행합니다. (이는 jQuery 메소드와 수동 동적 스크립트로드 메소드 모두에 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="f6aec98cb390ce572d475ac294a8779bcdd59d39" translate="yes" xml:space="preserve">
          <source>On the jQuery master branch, they simply concatenate atomic source files into a single one starting with &lt;code&gt;intro.js&lt;/code&gt; and ending with &lt;code&gt;outtro.js&lt;/code&gt;. That doesn't suits me as it provides no flexibility on the source code design. Check out how it works with jsic:</source>
          <target state="translated">jQuery 마스터 브랜치에서는 원자 소스 파일을 &lt;code&gt;intro.js&lt;/code&gt; 로 시작하고 outtro.js 로 끝나는 단일 소스 파일로 간단히 연결합니다. 소스 코드 디자인에 유연성이 없기 때문에 나에게 적합하지 않습니다. jsic과의 작동 방식을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="35244510a0932d71a1e33c185ed4d3632c86c351" translate="yes" xml:space="preserve">
          <source>Or rather than including at run time, use a script to concatenate prior to upload.</source>
          <target state="translated">또는 런타임에 포함하는 대신 스크립트를 사용하여 업로드하기 전에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="ae55d21513645c5d75d2af23ca6c677b65dcc82d" translate="yes" xml:space="preserve">
          <source>Read more at &lt;a href=&quot;https://developers.google.com/web/updates/2017/11/dynamic-import&quot;&gt;https://developers.google.com/web/updates/2017/11/dynamic-import&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developers.google.com/web/updates/2017/11/dynamic-import&quot;&gt;https://developers.google.com/web/updates/2017/11/dynamic-import&lt;/a&gt; 에서 자세히 알아 보십시오.</target>
        </trans-unit>
        <trans-unit id="0fdf3837508857a07cdb1bf94cb244b7d21a5aae" translate="yes" xml:space="preserve">
          <source>Read more at &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;https://jakearchibald.com/2017/es-modules-in-browsers/&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;https://jakearchibald.com/2017/es-modules-in-browsers/&lt;/a&gt; 에서 자세한 내용을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7a2968690e7c23123fd7efc2f7e364afd5a86919" translate="yes" xml:space="preserve">
          <source>Refer to:</source>
          <target state="translated">인용하다:</target>
        </trans-unit>
        <trans-unit id="5ad4ccb4e6c788c5d5198e149aa1d4af7b483a35" translate="yes" xml:space="preserve">
          <source>RequireJS loads plain JavaScript files as well as more defined
  modules. It is optimized for in-browser use, including in a Web
  Worker, but it can be used in other JavaScript environments, like
  Rhino and Node. It implements the Asynchronous Module API.</source>
          <target state="translated">RequireJS는 일반 JavaScript 파일과 더 정의 된 모듈을로드합니다. 웹 워커를 포함하여 브라우저 내 사용에 최적화되어 있지만 Rhino 및 Node와 같은 다른 JavaScript 환경에서 사용할 수 있습니다. 비동기 모듈 API를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="efbb4b5102cbae7f42e744b6a9286fbaccd8f904" translate="yes" xml:space="preserve">
          <source>RequireJS uses plain script tags to load modules/files, so it should
  allow for easy debugging. It can be used simply to load existing
  JavaScript files, so &lt;strong&gt;you can add it to your existing project without
  having to re-write your JavaScript files.&lt;/strong&gt;</source>
          <target state="translated">RequireJS는 일반 스크립트 태그를 사용하여 모듈 / 파일을로드하므로 쉽게 디버깅 할 수 있습니다. 기존 JavaScript 파일을로드하는 데 간단히 사용할 수 있으므로 JavaScript 파일 &lt;strong&gt;을 다시 쓰지 않고도 기존 프로젝트에&lt;/strong&gt; 파일 &lt;strong&gt;을 추가 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="71dc617a43ade90c11908db4d0f8e0e5ad86ab36" translate="yes" xml:space="preserve">
          <source>Set up a file called &quot;plugins.js&quot; (or extensions.js or whatever you want). Keep your plugin files together with that one master file.</source>
          <target state="translated">&quot;plugins.js&quot;(또는 extensions.js 또는 원하는 파일)라는 파일을 설정하십시오. 하나의 마스터 파일과 함께 플러그인 파일을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="cb63b27c44e32458c090132cc30786386502db2f" translate="yes" xml:space="preserve">
          <source>So all you would need to do to import JavaScript is:</source>
          <target state="translated">따라서 JavaScript를 가져 오려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="50c7c7e6fbef7aa987cd88ab0ebe41cc1d7dfd86" translate="yes" xml:space="preserve">
          <source>So here is the compiler, &lt;a href=&quot;https://github.com/dsheiko/jsic&quot;&gt;https://github.com/dsheiko/jsic&lt;/a&gt;, which replaces &lt;code&gt;$import(&quot;file-path&quot;)&lt;/code&gt; with the requested file content securely. Here is the corresponding &lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; plugin: &lt;a href=&quot;https://github.com/dsheiko/grunt-jsic&quot;&gt;https://github.com/dsheiko/grunt-jsic&lt;/a&gt;.</source>
          <target state="translated">여기에 &lt;a href=&quot;https://github.com/dsheiko/jsic&quot;&gt;https://github.com/dsheiko/jsic&lt;/a&gt; 컴파일러가 있는데, 이것은 &lt;code&gt;$import(&quot;file-path&quot;)&lt;/code&gt; 를 요청 된 파일 내용으로 안전하게 대체합니다. 해당 &lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; 플러그인은 다음과 같습니다. &lt;a href=&quot;https://github.com/dsheiko/grunt-jsic&quot;&gt;https://github.com/dsheiko/grunt-jsic&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="207e16cd95f6cd938f21d26d90e229e30bc7c63b" translate="yes" xml:space="preserve">
          <source>So you don't have to rely upon any JavaScript framework nor do you have to explicitly make &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;Ajax&lt;/a&gt; calls.</source>
          <target state="translated">따라서 JavaScript 프레임 워크에 의존하거나 &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;Ajax&lt;/a&gt; 호출을 명시 적으로 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="db6dad97ca62ef5d7f44d822ae7ada54d51ed9bf" translate="yes" xml:space="preserve">
          <source>Source Code Merge/Preprocessing</source>
          <target state="translated">소스 코드 병합 / 전처리</target>
        </trans-unit>
        <trans-unit id="60c6c4d6b31992a793c66bd837c9c7497f32017e" translate="yes" xml:space="preserve">
          <source>Statement &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; is in ECMAScript 6.</source>
          <target state="translated">명령문 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 는 ECMAScript 6에 있습니다.</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="8b1b78f01302f9f5124b19ec9053902f483cc415" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; library provides loading functionality &lt;a href=&quot;http://api.jquery.com/jQuery.getScript/&quot;&gt;in one line&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 라이브러리는 &lt;a href=&quot;http://api.jquery.com/jQuery.getScript/&quot;&gt;한 줄에&lt;/a&gt; 로딩 기능 을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="365cfa5fd770b6dc0769934f9dacef667879a63d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@import&lt;/code&gt; syntax for achieving CSS-like JavaScript importing is possible using a tool such as Mixture via their special &lt;code&gt;.mix&lt;/code&gt; file type (see &lt;a href=&quot;http://docs.mixture.io/preprocessors#mix&quot;&gt;here&lt;/a&gt;). I imagine the application simply uses one of the aforementioned methods interally, though I don't know.</source>
          <target state="translated">CSS와 같은 JavaScript 가져 오기를 달성하기위한 &lt;code&gt;@import&lt;/code&gt; 구문은 특수한 &lt;code&gt;.mix&lt;/code&gt; 파일 유형 ( &lt;a href=&quot;http://docs.mixture.io/preprocessors#mix&quot;&gt;여기&lt;/a&gt; 참조)을 통해 Mixture와 같은 도구를 사용하여 가능합니다. 나는 응용 프로그램이 단순히 위에서 언급 한 방법 중 하나를 내부적으로 사용한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="c5e847bed7fd8f4657d461e7ff8a88bffa6bd775" translate="yes" xml:space="preserve">
          <source>The old versions of JavaScript had no import, include, or require, so many different approaches to this problem have been developed.</source>
          <target state="translated">이전 버전의 JavaScript에는 가져 오기, 포함 또는 필요가 없었으므로이 문제에 대한 다양한 접근 방식이 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="332a07b88f0fcf415b8555e25a5eeedebfe4cb0d" translate="yes" xml:space="preserve">
          <source>The older CJS module style, still widely used in Node.js, is the &lt;a href=&quot;https://nodejs.org/api/modules.html&quot;&gt;&lt;code&gt;module.exports&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; system.</source>
          <target state="translated">Node.js에서 여전히 널리 사용되는 이전 CJS 모듈 스타일은 &lt;a href=&quot;https://nodejs.org/api/modules.html&quot;&gt; &lt;code&gt;module.exports&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="3c64a3691275e516da071b56c9173a3a5745a171" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;$.getScript&lt;/code&gt; and really any other solution that requires a callback when loading is complete is that if you have multiple files that use it and depend on each other you no longer have a way to know when all scripts have been loaded (once they are nested in multiple files).</source>
          <target state="translated">&lt;code&gt;$.getScript&lt;/code&gt; 와로드가 완료 될 때 콜백이 필요한 다른 솔루션의 문제는 파일을 사용하고 서로 의존하는 여러 파일이 있으면 더 이상 모든 스크립트가로드 된 시점을 알 수있는 방법이 없다는 것입니다 여러 파일에 중첩되어 있습니다).</target>
        </trans-unit>
        <trans-unit id="e3df137a5e529bd9e98b8d075cf6b8ec8e6991ff" translate="yes" xml:space="preserve">
          <source>The reason why we look for the first &lt;code&gt;script&lt;/code&gt; element instead of &lt;code&gt;head&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; is because some browsers don't create one if missing, but we're guaranteed to have a &lt;code&gt;script&lt;/code&gt; element - this one. Read more at &lt;a href=&quot;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&quot;&gt;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;head&lt;/code&gt; 또는 &lt;code&gt;body&lt;/code&gt; 대신 첫 번째 &lt;code&gt;script&lt;/code&gt; 요소를 찾는 이유는 일부 브라우저가없는 경우 브라우저를 만들지 않지만 &lt;code&gt;script&lt;/code&gt; 요소가 있다는 것입니다. &lt;a href=&quot;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&quot;&gt;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&lt;/a&gt; 에서 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="82cf60f97f6c09707b8f19fab54ef5c1a0cb6287" translate="yes" xml:space="preserve">
          <source>The script can even reside on a different server. Furthermore, the browser evaluates the code. The &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag can be injected into either the web page &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;, or inserted just before the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">스크립트는 다른 서버에 상주 할 수도 있습니다. 또한 브라우저는 코드를 평가합니다. &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그는 웹 페이지 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 에 삽입하거나 닫는 &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; 태그 바로 앞에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf546d79de34ac91357b0003cf697e434471972" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;main.js&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;main.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a3dc8d9fecff4598af5823bdb8309740acf1198" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;main.mjs&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;main.mjs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7cb5f212cd2a13edf49d3b9684dcfad659ee20ea" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;module.js&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;module.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fea8eb87370a87b1e4d189a8d9e83a44e5c1f2cf" translate="yes" xml:space="preserve">
          <source>Then you reload the page hitting</source>
          <target state="translated">그런 다음 페이지 히트를 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="0672e4bde170e584fa2b6dc719a249509055bb38" translate="yes" xml:space="preserve">
          <source>Then you run all that:</source>
          <target state="translated">그런 다음 모든 것을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3b84e4c1da86765df25fe1104617e23cd6a3172e" translate="yes" xml:space="preserve">
          <source>Then you write the code you want to use AFTER the script is loaded in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda function&lt;/a&gt;:</source>
          <target state="translated">그런 다음 스크립트가 &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;람다 함수에&lt;/a&gt; 로드 된 후 사용하려는 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="38c5068306243c5f0677ed35094b305a3aebfa48" translate="yes" xml:space="preserve">
          <source>There actually &lt;em&gt;is&lt;/em&gt; a way to load a JavaScript file &lt;em&gt;not&lt;/em&gt; asynchronously, so you could use the functions included in your newly loaded file right after loading it, and I think it works in all browsers.</source>
          <target state="translated">실제로 JavaScript 파일 &lt;em&gt;을&lt;/em&gt; 비동기식으로로드 &lt;em&gt;하지 않는&lt;/em&gt; 방법이 있으므로 새로로드 한 파일을로드 한 직후에 포함 된 기능을 사용할 수 있으며 모든 브라우저에서 작동한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="d358c9da7c21739b51ad491587d2a2e4bbea8403" translate="yes" xml:space="preserve">
          <source>There are a lot of potential answers for this question. My answer is obviously based on a number of them. This is what I ended up with after reading through all the answers.</source>
          <target state="translated">이 질문에 대한 많은 잠재적 인 답변이 있습니다. 내 대답은 분명히 여러 가지를 기반으로합니다. 이것이 모든 답변을 읽은 후에 끝내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="44afba8e9b45daeb202787b573cfab4ecc933b89" translate="yes" xml:space="preserve">
          <source>There are other ways for JavaScript to include external JavaScript contents in browsers that do not require preprocessing.</source>
          <target state="translated">JavaScript가 전처리가 필요없는 브라우저에 외부 JavaScript 컨텐츠를 포함시키는 다른 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="775a00f31987b24b0b74ff2c37a582e1e13b8885" translate="yes" xml:space="preserve">
          <source>There are several ways to implement modules in Javascript, Here are the 2 most popular ones:</source>
          <target state="translated">Javascript에서 모듈을 구현하는 방법에는 여러 가지가 있습니다. 가장 인기있는 두 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a509c35ddc3ed0ce500ef2c3f3e54fe40074c6be" translate="yes" xml:space="preserve">
          <source>There is a good news for you. Very soon you will be able to load JavaScript code easily. It will become a standard way of importing modules of JavaScript code and will be part of core JavaScript itself.</source>
          <target state="translated">좋은 소식이 있습니다. 곧 JavaScript 코드를 쉽게로드 할 수 있습니다. JavaScript 코드 모듈을 가져 오는 표준 방법이되고 핵심 JavaScript 자체의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="03917ccdd96f3286351548a9349f54699c873ece" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://headjs.com/&quot;&gt;Head.js&lt;/a&gt;. It is very easy to deal with:</source>
          <target state="translated">&lt;a href=&quot;http://headjs.com/&quot;&gt;Head.js&lt;/a&gt; 도 있습니다 . 다루기가 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="282a95668b3d184d0221e75ea9a0b317f15912d1" translate="yes" xml:space="preserve">
          <source>This function will add a new &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to the end of the head section of the page, where the &lt;code&gt;src&lt;/code&gt; attribute is set to the URL which is given to the function as the first parameter.</source>
          <target state="translated">이 함수는 페이지의 head 섹션 끝에 새로운 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 추가합니다. 여기서 &lt;code&gt;src&lt;/code&gt; 속성은 함수에 첫 번째 매개 변수로 제공되는 URL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aec69cae0df189fe5f15918931a93fbb19af37a4" translate="yes" xml:space="preserve">
          <source>This moduling system is used in NodeJS. You basically add your exports to an object which is called &lt;code&gt;module.exports&lt;/code&gt;. You then can access this object via a &lt;code&gt;require('modulePath')&lt;/code&gt;. Important here is to realize that these modules are being cached, so if you &lt;code&gt;require()&lt;/code&gt; a certain module twice it will return the already created module.</source>
          <target state="translated">이 변조 시스템은 NodeJS에서 사용됩니다. 기본적으로 &lt;code&gt;module.exports&lt;/code&gt; 라는 객체에 내보내기를 추가합니다. 그런 다음 &lt;code&gt;require('modulePath')&lt;/code&gt; 를 통해이 객체에 액세스 할 수 있습니다. 여기서 중요한 것은 이러한 모듈이 캐시되고 있다는 것을 인식하는 것이므로 특정 모듈을 두 번 필요로하면 이미 작성된 모듈을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d141c73c6e84930879c36e1f775b68c2e49892c" translate="yes" xml:space="preserve">
          <source>This saved my day. I hope this helps.</source>
          <target state="translated">이것은 나의 하루를 구했다. 이게 도움이 되길 바란다.</target>
        </trans-unit>
        <trans-unit id="5fbb1a0423bef2cdcefbfb4471fd65f7883a8a93" translate="yes" xml:space="preserve">
          <source>This script will add a JavaScript file to the top of any other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">이 스크립트는 다른 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그의 맨 위에 JavaScript 파일을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="677f26183a09ed669f4cb588a041e322090571ba" translate="yes" xml:space="preserve">
          <source>This should do:</source>
          <target state="translated">이것은해야합니다 :</target>
        </trans-unit>
        <trans-unit id="1766b2907ae68f8084c4976da09f1789f75a93ee" translate="yes" xml:space="preserve">
          <source>Usage (Promise):</source>
          <target state="translated">사용법 (약속) :</target>
        </trans-unit>
        <trans-unit id="eeba7483417f4c19d85bdb39a309d8abb9362c2d" translate="yes" xml:space="preserve">
          <source>Usage (async/await):</source>
          <target state="translated">사용법 (비동기 / 대기) :</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="b2f9ce47657e324cce2b6d80e0c2f7518a08067a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.mjs&lt;/code&gt;, you'd have &lt;code&gt;module.mjs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.mjs&lt;/code&gt; 사용하면 &lt;code&gt;module.mjs&lt;/code&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3c8d0e74dd9558a24f0302ee206a7608218058e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="25836b321091437346e2f5dbe6de27871ab3c287" translate="yes" xml:space="preserve">
          <source>Well, you can use the hack the author suggests in the link I gave you. In summary, for people in a hurry, he uses an event to run a callback function when the script is loaded. So you can put all the code using the remote library in the callback function. For example:</source>
          <target state="translated">글쎄, 내가 준 링크에서 저자가 제안한 해킹을 사용할 수 있습니다. 요약하자면, 급한 사람들을 위해, 그는 스크립트가로드 될 때 이벤트를 사용하여 콜백 함수를 실행합니다. 따라서 콜백 함수에서 원격 라이브러리를 사용하여 모든 코드를 넣을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bd3ad67628e2ce42d0075e4006bcb283c8372d6" translate="yes" xml:space="preserve">
          <source>When the additional files are loaded the &lt;code&gt;document.ready&lt;/code&gt; callbacks will get executed in the wrong order. To address this when a script is actually loaded, the script that imported it is re-imported itself and execution halted. This causes the originating file to now have its &lt;code&gt;document.ready&lt;/code&gt; callback executed after any from any scripts that it imports.</source>
          <target state="translated">추가 파일이로드되면 &lt;code&gt;document.ready&lt;/code&gt; 콜백이 잘못된 순서로 실행됩니다. 스크립트가 실제로로드 될 때이 문제를 해결하기 위해 스크립트를 가져온 스크립트를 다시 가져 와서 실행을 중지합니다. 이로 인해 원래 파일이 가져 오는 스크립트에서 &lt;code&gt;document.ready&lt;/code&gt; 콜백을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9eea4e801ae6abd35d58a38d0d55c894879bbd27" translate="yes" xml:space="preserve">
          <source>You are right when you say that you could specify Ajax to run synchronously or use &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt;, but the current trend appears to be to deprecate synchronous requests, so you may not get full browser support now or in the future.</source>
          <target state="translated">Ajax를 지정하여 동기식으로 실행하거나 &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest를&lt;/a&gt; 사용할 수 있다고 말하면 맞지만 현재 추세는 동기식 요청을 더 이상 사용하지 않는 것으로 보이므로 현재 또는 미래에 전체 브라우저를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41b688ca3fa05f1b8bf2b2c1390acf30888a6c1a" translate="yes" xml:space="preserve">
          <source>You can also assemble your scripts using &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; 를 사용하여 스크립트를 어셈블 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67289039b993bbae286ee78e5a38a9d7984d26f" translate="yes" xml:space="preserve">
          <source>You can of course use $ (&quot;body&quot;).append(), but then you can no longer debug correctly any more.</source>
          <target state="translated">물론 $ ( &quot;body&quot;). append ()를 사용할 수 있지만 더 이상 더 이상 올바르게 디버깅 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="261f53110fde11b3c98c44fc320c61440f8caf48" translate="yes" xml:space="preserve">
          <source>You can then use it in your code as you'd usually use an include:</source>
          <target state="translated">그런 다음 일반적으로 include를 사용할 때 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="763d2233f3f407809871ccf36da8867041eafddf" translate="yes" xml:space="preserve">
          <source>You can write your JavaScript files in &quot;modules&quot; and then reference them as dependencies in other scripts. Or you can use RequireJS as a simple &quot;go get this script&quot; solution.</source>
          <target state="translated">JavaScript 파일을 &quot;모듈&quot;로 작성한 다음 다른 스크립트에서 종속성으로 참조 할 수 있습니다. 또는 RequireJS를 간단한 &quot;이 스크립트 가져 오기&quot;솔루션으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43fc4e4d3a473a2cd0549a65efd79e36b5e2afb7" translate="yes" xml:space="preserve">
          <source>You could add a script tag with the script URL into the HTML. To avoid the overhead of jQuery, this is an ideal solution.</source>
          <target state="translated">스크립트 URL이있는 스크립트 태그를 HTML에 추가 할 수 있습니다. jQuery의 오버 헤드를 피하기 위해 이상적인 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="677229282757dc7a7d42af0f461340f88668361d" translate="yes" xml:space="preserve">
          <source>You could load an additional script with an AJAX call and then use &lt;code&gt;eval&lt;/code&gt; to run it. This is the most straightforward way, but it is limited to your domain because of the JavaScript sandbox security model. Using &lt;code&gt;eval&lt;/code&gt; also opens the door to bugs, hacks and security issues.</source>
          <target state="translated">AJAX 호출로 추가 스크립트를로드 한 다음 &lt;code&gt;eval&lt;/code&gt; 을 사용하여 실행할 수 있습니다. 이는 가장 간단한 방법이지만 JavaScript 샌드 박스 보안 모델로 인해 도메인으로 제한됩니다. &lt;code&gt;eval&lt;/code&gt; 을 사용하면 버그, 해킹 및 보안 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="740e8e133fe6283f4bf17af1eb127c00965480b1" translate="yes" xml:space="preserve">
          <source>You could try to use &lt;code&gt;$.when&lt;/code&gt; to check an array of deferred objects, but now you are doing this in every file and file2 will be considered loaded as soon as the &lt;code&gt;$.when&lt;/code&gt; is executed not when the callback is executed, so file1 still continues execution before file3 is loaded. This really still has the same problem.</source>
          <target state="translated">지연된 객체의 배열을 확인하기 위해 &lt;code&gt;$.when&lt;/code&gt; 을 사용하려고 시도 할 수 있지만 이제는 모든 파일 에서이 작업을 수행하고 콜백이 실행될 때가 아니라 &lt;code&gt;$.when&lt;/code&gt; 이 실행되는 즉시 file2 가로 드 된 것으로 간주되므로 file1은 여전히 file3이로드되기 전에 실행을 계속합니다. 이것은 여전히 ​​똑같은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac49dc35cec96359223a55198aee1ea6a7723105" translate="yes" xml:space="preserve">
          <source>You just need to be careful when you are including scripts in an HTML file. The order should be as in below:</source>
          <target state="translated">HTML 파일에 스크립트를 포함시킬 때주의해야합니다. 순서는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="44f152a3a2ff3ec5b145516a70206e4b37c0738c" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;jQuery.append()&lt;/code&gt; on the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; element of your page, that is:</source>
          <target state="translated">페이지의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 요소에서 &lt;code&gt;jQuery.append()&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ad6f53621aa3d1faf240c9a38a76a34ecb3ac9f" translate="yes" xml:space="preserve">
          <source>You simply have to write &lt;code&gt;import cond from 'cond.js';&lt;/code&gt; to load a macro named &lt;code&gt;cond&lt;/code&gt; from a file &lt;code&gt;cond.js&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import cond from 'cond.js';&lt;/code&gt; 를 작성하면됩니다 . &lt;code&gt;cond.js&lt;/code&gt; 파일에서 &lt;code&gt;cond&lt;/code&gt; 라는 매크로를로드합니다.</target>
        </trans-unit>
        <trans-unit id="d9c029655932b5efd739f546d5b2cb4eaadd323a" translate="yes" xml:space="preserve">
          <source>file1.js</source>
          <target state="translated">file1.js</target>
        </trans-unit>
        <trans-unit id="a2bf4c98312f67688bf14bf9ed30d02aa9d4ca8d" translate="yes" xml:space="preserve">
          <source>file1.js:</source>
          <target state="translated">file1.js:</target>
        </trans-unit>
        <trans-unit id="d14c0cdfc2b81349332a20275d4e5388ced355bc" translate="yes" xml:space="preserve">
          <source>file2.js</source>
          <target state="translated">file2.js</target>
        </trans-unit>
        <trans-unit id="03a0f7a91e0893577595163e3fac51c418880f93" translate="yes" xml:space="preserve">
          <source>file2.js:</source>
          <target state="translated">file2.js:</target>
        </trans-unit>
        <trans-unit id="9eb542476d35d6e35c8f124ac5e963ed9e1f9a2e" translate="yes" xml:space="preserve">
          <source>file3.js</source>
          <target state="translated">file3.js</target>
        </trans-unit>
        <trans-unit id="a7eac0c8dd40160a0c46c08bdfaf13d11b629316" translate="yes" xml:space="preserve">
          <source>global.js</source>
          <target state="translated">global.js</target>
        </trans-unit>
        <trans-unit id="0f4ed54c5010ce0a22e2398e6e747b8624d5114e" translate="yes" xml:space="preserve">
          <source>jQuery Loading</source>
          <target state="translated">jQuery 로딩</target>
        </trans-unit>
        <trans-unit id="c4a4248f7568c9e41265502c39b0daeb8b635431" translate="yes" xml:space="preserve">
          <source>main.js</source>
          <target state="translated">main.js</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="e8775485c8f1802e0ec89012c9e0a431dd135b78" translate="yes" xml:space="preserve">
          <source>plugins.js will have an array called &lt;code&gt;pluginNames[]&lt;/code&gt; that we will iterate over &lt;code&gt;each()&lt;/code&gt;,
then append a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to the head for each plugin</source>
          <target state="translated">plugins.js는 &lt;code&gt;pluginNames[]&lt;/code&gt; 라는 배열을 가지게되는데 우리는 &lt;code&gt;each()&lt;/code&gt; 반복하고 각 플러그인의 헤드에 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 추가합니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
