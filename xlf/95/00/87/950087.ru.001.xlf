<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/950087">
    <body>
      <group id="950087">
        <trans-unit id="206ab3d9bec48efae73640429f4d8678f64506e9" translate="yes" xml:space="preserve">
          <source>(This answer is in response to e-satis' comment).</source>
          <target state="translated">(Этот ответ является ответом на комментарий esatis).</target>
        </trans-unit>
        <trans-unit id="c2f82e6af2dc551c77d47d4e59e40a67261ca803" translate="yes" xml:space="preserve">
          <source>. And it works! Confusing...</source>
          <target state="translated">.И это работает! Сбивает с толку...</target>
        </trans-unit>
        <trans-unit id="6eae3a5b062c6d0d79f070c26e6d62486b40cb46" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>
        </trans-unit>
        <trans-unit id="56462b98ec98df96345ec73222abd51331f6a57f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://37signals.com/svn/posts/1587-introducing-sprockets-javascript-dependency-management-and-concatenation&quot;&gt;Introducing Sprockets: JavaScript dependency management and concatenation&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://37signals.com/svn/posts/1587-introducing-sprockets-javascript-dependency-management-and-concatenation&quot;&gt;Представляем Sprockets: управление зависимостями JavaScript и конкатенация&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c32de899cfb6ec06e8cc06f8e5e9f40a37e92d7c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://calculist.org/blog/2012/06/29/static-module-resolution/&quot;&gt;Static module resolution&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://calculist.org/blog/2012/06/29/static-module-resolution/&quot;&gt;Разрешение статического модуля&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2762c6431432dd5a70cecfb315f7619966f378a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders&quot;&gt;Module loaders&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders&quot;&gt;Модульные погрузчики&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="788fd7a0f4e090824b273e7120114e5c5cbd91d5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;build/main.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;build/main.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6f6bff257cd31d0764b92815c9b9d17e8f561e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;src/Form/Input/Tel.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;src/Form/Input/Tel.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca9ca5e0a3691e6d44f125996c50847fbf836c5c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;src/main.js&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;src/main.js&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6a16d8f75b54b1f1f0b21d8ce61fc11b0bba33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CommonJS&lt;/strong&gt; (used in NodeJS)</source>
          <target state="translated">&lt;strong&gt;CommonJS&lt;/strong&gt; (используется в NodeJS)</target>
        </trans-unit>
        <trans-unit id="7290c866af5b8bcecf5045b72e9fd6779df65827" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Modules&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Модули&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bebe38df96c7eb3f3282665cee82c64c21884191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what to do about it ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Так что с этим делать?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fcc0aa2abc91d9c0d481b93b0bba6fbd9423c59b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: Mixture is &lt;a href=&quot;http://mixture.io/blog/free/&quot;&gt;now free&lt;/a&gt; (offline).</source>
          <target state="translated">&lt;strong&gt;ОБНОВЛЕНИЕ&lt;/strong&gt; : Mixture &lt;a href=&quot;http://mixture.io/blog/free/&quot;&gt;теперь бесплатна&lt;/a&gt; (не в сети).</target>
        </trans-unit>
        <trans-unit id="53d014567827ce6d8ba81376d4cbf9262511230d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: Mixture is now discontinued. &lt;a href=&quot;https://github.com/teammixture/mixture.io/issues/6&quot;&gt;Old mixture releases&lt;/a&gt; are still available</source>
          <target state="translated">&lt;strong&gt;ОБНОВЛЕНИЕ&lt;/strong&gt; : Смесь теперь прекращена. &lt;a href=&quot;https://github.com/teammixture/mixture.io/issues/6&quot;&gt;Старые релизы смеси&lt;/a&gt; все еще доступны</target>
        </trans-unit>
        <trans-unit id="f8d6e8d151ca82b2e0671602d8c89392168b089a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;implementation.js&lt;/strong&gt; is your &quot;main&quot; JavaScript file that depends on &lt;strong&gt;some-dependency.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;creation.js&lt;/strong&gt; - это ваш &amp;laquo;основной&amp;raquo; файл JavaScript, который зависит от &lt;strong&gt;some-dependency.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e090dd13b65625719872427d2c45c23e507646c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;some-dependency.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;some-dependency.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00d49aecf61eefacf881c76b0da44cb61b90c3b6" translate="yes" xml:space="preserve">
          <source>AJAX Loading</source>
          <target state="translated">AJAX погрузка</target>
        </trans-unit>
        <trans-unit id="a858f45b0cd86a8d053c47aed5612e8df1b50a0b" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;https://stackoverflow.com/a/10939737/1676444&quot;&gt;as the second highest voted answer to your question highlights&lt;/a&gt;, &lt;a href=&quot;http://www.requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; can also handle including scripts inside a Web Worker (likely calling &lt;code&gt;importScripts&lt;/code&gt; itself, but with a few other useful features).</source>
          <target state="translated">Кроме того, &lt;a href=&quot;https://stackoverflow.com/a/10939737/1676444&quot;&gt;в качестве второго наиболее высоко&lt;/a&gt; &lt;a href=&quot;http://www.requirejs.org/&quot;&gt;оцененного&lt;/a&gt; ответа на ваш вопрос , RequireJS может также обрабатывать включение сценариев внутри Web Worker (вероятно, вызывающего сам &lt;code&gt;importScripts&lt;/code&gt; , но с несколькими другими полезными функциями).</target>
        </trans-unit>
        <trans-unit id="104bb6fccb3dd88007fd041a6caf1caa570d887e" translate="yes" xml:space="preserve">
          <source>Although these answers are great, there is a simple &quot;solution&quot; that has been around since script loading existed, and it will cover 99.999% of most people's use cases. Just include the script you need before the script that requires it. For most projects it does not take long to determine which scripts are needed and in what order.</source>
          <target state="translated">Хотя эти ответы отличные,есть простое &quot;решение&quot;,которое было вокруг с момента загрузки скриптов существовали,и оно будет охватывать 99,999% случаев использования большинства людей.Просто включите скрипт,который вам нужен перед сценарием,который требует этого.Для большинства проектов это не займет много времени,чтобы определить,какие скрипты необходимы и в каком порядке.</target>
        </trans-unit>
        <trans-unit id="b50f51a682a21ea87eb5831332387ee8e672513c" translate="yes" xml:space="preserve">
          <source>And be able to call a function from the required script in the next line:</source>
          <target state="translated">И иметь возможность вызвать функцию из требуемого скрипта в следующей строке:</target>
        </trans-unit>
        <trans-unit id="883eb03a9cdc193322e4ba0c284e4929b617cd9b" translate="yes" xml:space="preserve">
          <source>And get the combined file</source>
          <target state="translated">И получите комбинированный файл</target>
        </trans-unit>
        <trans-unit id="26312a853a8a0fed6d13295ff03f0dca11974071" translate="yes" xml:space="preserve">
          <source>And right after including &lt;code&gt;included.js&lt;/code&gt;, the &lt;code&gt;hello()&lt;/code&gt; function is called, and you get the alert.</source>
          <target state="translated">И сразу после включения &lt;code&gt;hello()&lt;/code&gt; вызывается функция hello () , и вы получаете предупреждение.</target>
        </trans-unit>
        <trans-unit id="f13e6a18a32be72735a2f247839504b514c2563c" translate="yes" xml:space="preserve">
          <source>Another way, that in my opinion is much cleaner, is to make a synchronous Ajax request instead of using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. Which is also how &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; handles includes.</source>
          <target state="translated">Другой способ, который, на мой взгляд, намного чище, - это сделать синхронный Ajax-запрос вместо использования &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; . К тому же, как обрабатывает &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f421ce52a3901e83133ea470faef7ae69fc93013" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this answer, many developers use build/transpilation tool(s) like Parcel, Webpack, or Babel in their projects, allowing them to use upcoming JavaScript syntax, provide backward compatibility for older browsers, combine files, minify, perform code splitting etc.</source>
          <target state="translated">Как упоминалось в верхней части этого ответа,многие разработчики используют в своих проектах такие инструменты buildtranspilation,как Parcel,Webpack или Babel,что позволяет им использовать предстоящий синтаксис JavaScript,обеспечивать обратную совместимость для старых браузеров,объединять файлы,минимизировать,выполнять разбиение кода и т.д.</target>
        </trans-unit>
        <trans-unit id="949b1e33e3a590719f723351553af804e4929438" translate="yes" xml:space="preserve">
          <source>As you saw, I had use a variable in one JavaScript file in another JavaScript file, but I didn't need to include one in another. I just needed to ensure that the first JavaScript file loaded before the second JavaScript file, and, the first JavaScript file's variables are accessible in the second JavaScript file, automatically.</source>
          <target state="translated">Как вы видели,я использовал переменную в одном файле JavaScript в другом файле JavaScript,но мне не нужно было включать одну переменную в другой.Мне просто нужно было убедиться,что первый файл JavaScript загружается перед вторым файлом JavaScript,и переменные первого файла JavaScript автоматически становятся доступными во втором файле JavaScript.</target>
        </trans-unit>
        <trans-unit id="277120e489ec4b95e6dd7c32060d43032d9152c8" translate="yes" xml:space="preserve">
          <source>As you see, it's easier than Require.js and as convenient as jQuery's &lt;code&gt;$.getScript&lt;/code&gt; method. It also has some advanced features, like conditional loading, feature detection and &lt;a href=&quot;http://headjs.com/site/api/v1.00.html&quot;&gt;much more&lt;/a&gt;.</source>
          <target state="translated">Как видите, это проще, чем Require.js, и так же удобно, как метод &lt;code&gt;$.getScript&lt;/code&gt; jQuery. Он также имеет некоторые расширенные функции, такие как условная загрузка, обнаружение функций и &lt;a href=&quot;http://headjs.com/site/api/v1.00.html&quot;&gt;многое другое&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="198f9d81f71210a4fe6ffba57567675fdb5e650b" translate="yes" xml:space="preserve">
          <source>BUT:</source>
          <target state="translated">BUT:</target>
        </trans-unit>
        <trans-unit id="2314410b2adc404dde335bb42725bcc7fd26563a" translate="yes" xml:space="preserve">
          <source>Before calling &lt;code&gt;document.writeln&lt;/code&gt;, it checks to make sure the script has not already been loading by evaluating all the script elements.</source>
          <target state="translated">Перед вызовом &lt;code&gt;document.writeln&lt;/code&gt; он проверяет, что скрипт еще не загружался, оценивая все элементы скрипта.</target>
        </trans-unit>
        <trans-unit id="2816ea2652eecdb35254f7a8a62138f40ae37f28" translate="yes" xml:space="preserve">
          <source>Both of these solutions are discussed and illustrated in &lt;a href=&quot;http://unixpapa.com/js/dyna.html&quot;&gt;JavaScript Madness: Dynamic Script Loading&lt;/a&gt;.</source>
          <target state="translated">Оба эти решения обсуждаются и иллюстрируются в &lt;a href=&quot;http://unixpapa.com/js/dyna.html&quot;&gt;JavaScript Madness: динамическая загрузка скриптов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caabcacc0f9cf84e44c7d32424a5dc4629a4c721" translate="yes" xml:space="preserve">
          <source>Browsers do not support this moduling system yet so in order for you to use this syntax you must use a bundler like webpack. Using a bundler is better anyway because this can combine all of your different files into a single (or couple related) files. This will serve the files from the server to the client faster because each HTTP request has some associated overhead accompanied with it. Thus by reducing the overal HTTP request we improve the performance. Here is an example of ES6 modules:</source>
          <target state="translated">Браузеры пока не поддерживают эту систему моделирования,поэтому для того,чтобы вы могли использовать этот синтаксис,вы должны использовать бундлер типа webpack.Использование связки лучше в любом случае,потому что это может объединить все ваши различные файлы в один (или пару связанных)файлы.Это позволит быстрее обслуживать файлы от сервера к клиенту,потому что каждый HTTP-запрос имеет некоторые связанные с ним накладные расходы.Таким образом,уменьшая комбинезон HTTP запрос мы улучшаем производительность.Вот пример модулей ES6:</target>
        </trans-unit>
        <trans-unit id="b337cd4902acd58b0de99a8784fe0ca89f41d186" translate="yes" xml:space="preserve">
          <source>Browsers have had support for loading ECMAScript modules directly (no tools like Webpack required) &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;since&lt;/a&gt; Safari 10.1, Chrome 61, Firefox 60, and Edge 16. Check the current support at &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;caniuse&lt;/a&gt;. There is no need to use Node.js' &lt;code&gt;.mjs&lt;/code&gt; extension; browsers completely ignore file extensions on modules/scripts.</source>
          <target state="translated">Браузеры поддерживают загрузку модулей ECMAScript напрямую (не требуются такие инструменты, как Webpack), &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;начиная с&lt;/a&gt; Safari 10.1, Chrome 61, Firefox 60 и Edge 16. Проверьте текущую поддержку в &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;caniuse&lt;/a&gt; . Нет необходимости использовать расширение Node.js &lt;code&gt;.mjs&lt;/code&gt; ; браузеры полностью игнорируют расширения файлов в модулях / скриптах.</target>
        </trans-unit>
        <trans-unit id="522ce0fcef4ca6aef8ba20db065f82588818d7ac" translate="yes" xml:space="preserve">
          <source>But if that is not a problem for you, then this method should work.</source>
          <target state="translated">Но если для вас это не проблема,то этот метод должен сработать.</target>
        </trans-unit>
        <trans-unit id="1bbb812967de17c1fec9aa4b70a28049b6474a4a" translate="yes" xml:space="preserve">
          <source>But since 2015 (ES6), JavaScript has had the &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES6 modules&lt;/a&gt; standard to import modules in Node.js, which is also supported by &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;most modern browsers&lt;/a&gt;.</source>
          <target state="translated">Но с 2015 года (ES6) в JavaScript появился &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;стандарт модулей ES6&lt;/a&gt; для импорта модулей в Node.js, который также поддерживается &lt;a href=&quot;https://caniuse.com/#feat=es6-module&quot;&gt;большинством современных браузеров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5df356af95c22125fad799a05f636daf7b8b6f4f" translate="yes" xml:space="preserve">
          <source>Define dependencies as modules:</source>
          <target state="translated">Определите зависимости как модули:</target>
        </trans-unit>
        <trans-unit id="efb211ea4156611a7cf5952316e1ba2fb95ae811" translate="yes" xml:space="preserve">
          <source>Detecting when the script has been executed</source>
          <target state="translated">Обнаружение того,когда скрипт был выполнен</target>
        </trans-unit>
        <trans-unit id="e8e7c59c81ba090cb40a7e03782de9db506696ec" translate="yes" xml:space="preserve">
          <source>Dynamic Script Loading</source>
          <target state="translated">Динамическая загрузка сценария</target>
        </trans-unit>
        <trans-unit id="386cf3c6e6b0464ad5cbc22efde8538c6548eced" translate="yes" xml:space="preserve">
          <source>Dynamic imports in browsers</source>
          <target state="translated">Динамический импорт в браузерах</target>
        </trans-unit>
        <trans-unit id="d9d3d46b339478880eb52f7f9c0e16f1cb5a0500" translate="yes" xml:space="preserve">
          <source>Dynamic imports let the script load other scripts as needed:</source>
          <target state="translated">Динамический импорт позволяет скрипту загружать другие скрипты по мере необходимости:</target>
        </trans-unit>
        <trans-unit id="d388c8604db3813ddb87de2fb1c3f60be9f8222a" translate="yes" xml:space="preserve">
          <source>ECMAScript (ES6) modules have been &lt;a href=&quot;https://nodejs.org/api/esm.html&quot;&gt;supported in Node.js&lt;/a&gt; since v8.5, with the &lt;code&gt;--experimental-modules&lt;/code&gt; flag, and since at least Node.js v13.8.0 without the flag. To enable &quot;ESM&quot; (vs. Node.js's previous CommonJS-style module system [&quot;CJS&quot;]) you either use &lt;code&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt; in &lt;code&gt;package.json&lt;/code&gt; or give the files the extension &lt;code&gt;.mjs&lt;/code&gt;. (Similarly, modules written with Node.js's previous CJS module can be named &lt;code&gt;.cjs&lt;/code&gt; if your default is ESM.)</source>
          <target state="translated">Модули ECMAScript (ES6) &lt;a href=&quot;https://nodejs.org/api/esm.html&quot;&gt;поддерживаются в Node.js&lt;/a&gt; начиная с v8.5, с &lt;code&gt;--experimental-modules&lt;/code&gt; и, как минимум, с Node.js v13.8.0 без флага. Чтобы включить &amp;laquo;ESM&amp;raquo; (по сравнению с предыдущей системой модулей CommonJS в стиле Node.js [&amp;laquo;CJS&amp;raquo;]), вы либо используете &lt;code&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt; в &lt;code&gt;package.json&lt;/code&gt; , либо даете файлам расширение &lt;code&gt;.mjs&lt;/code&gt; . (Аналогично, модули, написанные с помощью предыдущего модуля CJS Node.js, могут называться &lt;code&gt;.cjs&lt;/code&gt; , если по умолчанию используется ESM.)</target>
        </trans-unit>
        <trans-unit id="1ec6cc0d49bcb01cd50cba9ddb3ed7b2944cb238" translate="yes" xml:space="preserve">
          <source>ECMAScript modules in browsers</source>
          <target state="translated">ECMAScript-модули в браузерах</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6 Модули</target>
        </trans-unit>
        <trans-unit id="78859e0aa530ac3119a27bb18cf0fc2aeb91ad89" translate="yes" xml:space="preserve">
          <source>Even though all of the plugins get dropped into the head tag the way they ought to, they don't always get run by the browser when you click into the page or refresh.</source>
          <target state="translated">Несмотря на то,что все плагины попадают в тэг головы так,как и должны,они не всегда запускаются браузером при нажатии на страницу или при обновлении.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="b4136dcf903eb3c76fe317c65ef053453e8cdc32" translate="yes" xml:space="preserve">
          <source>Excerpt from the &lt;a href=&quot;https://github.com/jrburke/requirejs&quot;&gt;GitHub&lt;/a&gt; README:</source>
          <target state="translated">Выдержка из &lt;a href=&quot;https://github.com/jrburke/requirejs&quot;&gt;GitHub&lt;/a&gt; README:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="b5cbd3434bd596109a8781b509798ab1da4452a6" translate="yes" xml:space="preserve">
          <source>F5</source>
          <target state="translated">F5</target>
        </trans-unit>
        <trans-unit id="94716db44426788000dfcbae9cba45638f7cc496" translate="yes" xml:space="preserve">
          <source>Fetch Loading</source>
          <target state="translated">Загрузка комплектующих</target>
        </trans-unit>
        <trans-unit id="52af92858e80319c3e320b7210c45af2d1252260" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;main.js.php&lt;/code&gt;:</source>
          <target state="translated">Файл &lt;code&gt;main.js.php&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="97e1664caa79aa71082bd60226618665682535d9" translate="yes" xml:space="preserve">
          <source>File1:</source>
          <target state="translated">File1:</target>
        </trans-unit>
        <trans-unit id="730fd0522d514826c9aaf7d211a195d36c9b867d" translate="yes" xml:space="preserve">
          <source>File2:</source>
          <target state="translated">File2:</target>
        </trans-unit>
        <trans-unit id="2e8382e08c9bb01c7e1654bd24c7e7f77f55dbf0" translate="yes" xml:space="preserve">
          <source>File3:</source>
          <target state="translated">File3:</target>
        </trans-unit>
        <trans-unit id="775ecf6ee49f69f0ed328c8af1660730b48d6a2e" translate="yes" xml:space="preserve">
          <source>File: main.js</source>
          <target state="translated">Файл:main.js</target>
        </trans-unit>
        <trans-unit id="fed8f02dc3fd97daef37a09c9513fac304867fe6" translate="yes" xml:space="preserve">
          <source>File: myvariables.js</source>
          <target state="translated">Файл:myvariables.js</target>
        </trans-unit>
        <trans-unit id="f973768795a937dcadac26fc7473d3746b5da826" translate="yes" xml:space="preserve">
          <source>For compatibility with older browsers, build tools like &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; and/or transpilation tools like &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; can be used.</source>
          <target state="translated">Для совместимости со старыми браузерами можно использовать инструменты сборки, такие как &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; и &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup,&lt;/a&gt; и / или инструменты переноса, такие как &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f2147bfcc0f0f7c3cef6200f4753cf79500f046" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;my_lovely_script.js&lt;/code&gt; contains &lt;code&gt;MySuperObject&lt;/code&gt;:</source>
          <target state="translated">Например: &lt;code&gt;my_lovely_script.js&lt;/code&gt; содержит &lt;code&gt;MySuperObject&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="759d7f8d0ebbe76c3a7b37e810db7f723123b25b" translate="yes" xml:space="preserve">
          <source>For this I did as below:</source>
          <target state="translated">За это я сделала то,что написано ниже:</target>
        </trans-unit>
        <trans-unit id="34a3ad15283216601c4c7025cdfabd88fdbb3275" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries&quot;&gt;Web Workers have their own &lt;code&gt;importScripts&lt;/code&gt; function&lt;/a&gt; which is a global function in the scope of the Web Worker, native to the browser itself as it &lt;a href=&quot;https://html.spec.whatwg.org/multipage/workers.html#importing-scripts-and-libraries&quot;&gt;is part of the specification&lt;/a&gt;.</source>
          <target state="translated">К счастью, у &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries&quot;&gt;Web Workers есть своя собственная функция &lt;code&gt;importScripts&lt;/code&gt; ,&lt;/a&gt; которая является глобальной функцией в области Web Worker, встроенной в сам браузер, поскольку &lt;a href=&quot;https://html.spec.whatwg.org/multipage/workers.html#importing-scripts-and-libraries&quot;&gt;является частью спецификации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67960c2c77f8b866584719b8e48c2e8eda27e92f" translate="yes" xml:space="preserve">
          <source>From the Mixture documentation on &lt;code&gt;.mix&lt;/code&gt; files:</source>
          <target state="translated">Из документации Mixture по файлам &lt;code&gt;.mix&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="43906746944eafb56d9523b37e70f7bd285ad8e4" translate="yes" xml:space="preserve">
          <source>Gist: &lt;a href=&quot;http://gist.github.com/284442&quot;&gt;http://gist.github.com/284442&lt;/a&gt;.</source>
          <target state="translated">Суть: &lt;a href=&quot;http://gist.github.com/284442&quot;&gt;http://gist.github.com/284442&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c973140512dda715ec8b98cd19e4abc17e64227e" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;synchronous&lt;/strong&gt; version &lt;strong&gt;without jQuery&lt;/strong&gt;:</source>
          <target state="translated">Вот &lt;strong&gt;синхронная&lt;/strong&gt; версия &lt;strong&gt;без jQuery&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="24b79cca1f32a4977bb54091e81e918ad5543042" translate="yes" xml:space="preserve">
          <source>Here is an example of how this could work:</source>
          <target state="translated">Вот пример того,как это может сработать:</target>
        </trans-unit>
        <trans-unit id="c836ed859d15dd35abf3de4024c47570ffc40a21" translate="yes" xml:space="preserve">
          <source>Here's an example &lt;code&gt;.mix&lt;/code&gt; file that combines multiple &lt;code&gt;.js&lt;/code&gt; files into one:</source>
          <target state="translated">Вот пример файла &lt;code&gt;.mix&lt;/code&gt; , который объединяет несколько файлов &lt;code&gt;.js&lt;/code&gt; в один:</target>
        </trans-unit>
        <trans-unit id="a0a735f6041355a8e31634a70ac885a99ea8fc46" translate="yes" xml:space="preserve">
          <source>Here's an example using jQuery:</source>
          <target state="translated">Вот пример использования jQuery:</target>
        </trans-unit>
        <trans-unit id="3d4d50089b78caa8accdb20b9de1e3e36a7c71dd" translate="yes" xml:space="preserve">
          <source>Here's an explanation of how the code works for those that are curious: essentially, it creates a new script tag (after the first one) of the URL. It sets it to asynchronous mode so it doesn't block the rest of the code, but calls a callback when the readyState (the state of the content to be loaded) changes to 'loaded'.</source>
          <target state="translated">Вот объяснение того,как работает код для тех,кому интересно:по сути,он создает новый тег скрипта (после первого)URL.Он переводит его в асинхронный режим,чтобы не блокировать остальную часть кода,а вызывает обратный вызов,когда состояние готовности (состояние загружаемого содержимого)меняется на &quot;загруженный&quot;.</target>
        </trans-unit>
        <trans-unit id="687874dfffbfcb582922598a2058fbf71cfb4713" translate="yes" xml:space="preserve">
          <source>Here's the generalized version of how Facebook does it for their ubiquitous Like button:</source>
          <target state="translated">Вот обобщенная версия того,как Facebook делает это для своей вездесущей кнопки &quot;Like&quot;:</target>
        </trans-unit>
        <trans-unit id="512061e76228d02949b902d49c6ed3f12388bcca" translate="yes" xml:space="preserve">
          <source>How do I include a JavaScript file in another JavaScript file</source>
          <target state="translated">Как включить файл JavaScript в другой файл JavaScript?</target>
        </trans-unit>
        <trans-unit id="f534ee42b1b1417c1c4328067f9e323c71e4cd19" translate="yes" xml:space="preserve">
          <source>However, this method also has a problem: if an error happens in the imported JavaScript file, &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; (and also Firefox Error Console and &lt;a href=&quot;https://developers.google.com/chrome-developer-tools/&quot;&gt;Chrome Developer Tools&lt;/a&gt; as well) will report its place incorrectly, which is a big problem if you use Firebug to track JavaScript errors down a lot (I do). Firebug simply doesn't know about the newly loaded file for some reason, so if an error occurs in that file, it reports that it occurred in your main &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; file, and you will have trouble finding out the real reason for the error.</source>
          <target state="translated">Однако этот метод также имеет проблему: если в импортированном файле JavaScript возникает ошибка, &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; (а также Firefox Error Console и &lt;a href=&quot;https://developers.google.com/chrome-developer-tools/&quot;&gt;Chrome Developer Tools&lt;/a&gt; также сообщат о своем месте неверно, что является большой проблемой, если вы используете Firebug для отслеживания Ошибки JavaScript много (я делаю). Firebug по какой-то причине просто не знает о недавно загруженном файле, поэтому, если в этом файле происходит ошибка, он сообщает, что она произошла в вашем основном &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML-&lt;/a&gt; файле, и у вас будут проблемы с поиском истинной причины ошибки.</target>
        </trans-unit>
        <trans-unit id="96ce64ab269dff867b5298523efe17ef57bf386e" translate="yes" xml:space="preserve">
          <source>I also made a simple test for this at &lt;a href=&quot;http://www.kipras.com/dev/import_js_test/&quot;&gt;Example&lt;/a&gt;.</source>
          <target state="translated">Я также сделал простой тест для этого в &lt;a href=&quot;http://www.kipras.com/dev/import_js_test/&quot;&gt;Примере&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="052345c2ec801d63db4bca3da6cc49e6666d2a55" translate="yes" xml:space="preserve">
          <source>I assume that a script is not fully executed until its &lt;code&gt;document.ready&lt;/code&gt; event has been executed. (I know using &lt;code&gt;document.ready&lt;/code&gt; is not required, but many people use it, and handling this is a safeguard.)</source>
          <target state="translated">Я предполагаю, что скрипт не выполняется полностью до тех пор, пока не будет выполнено событие &lt;code&gt;document.ready&lt;/code&gt; . (Я знаю, что использование &lt;code&gt;document.ready&lt;/code&gt; не требуется, но многие люди используют его, и обработка этого является гарантией.)</target>
        </trans-unit>
        <trans-unit id="bcf92d81ab2e9f8567b02bf77422af88d42f8420" translate="yes" xml:space="preserve">
          <source>I came to this question because I was looking for a simple way to maintain a collection of useful JavaScript plugins. After seeing some of the solutions here, I came up with this:</source>
          <target state="translated">Я пришел к этому вопросу,потому что искал простой способ поддерживать коллекцию полезных JavaScript-плагинов.После того,как я увидел здесь некоторые решения,я пришел к этому:</target>
        </trans-unit>
        <trans-unit id="76ea63d97f56a6085f1fd0905c71733444f736e3" translate="yes" xml:space="preserve">
          <source>I decided to go backwards instead of forwards. Thank you &lt;code&gt;document.writeln&lt;/code&gt;. I know it's taboo, but as long as it is used correctly this works well. You end up with code that can be debugged easily, shows in the DOM correctly and can ensure the order the dependencies are loaded correctly.</source>
          <target state="translated">Я решил идти назад, а не вперед. Спасибо &lt;code&gt;document.writeln&lt;/code&gt; . Я знаю, что это табу, но при правильном использовании это работает хорошо. Вы получите код, который можно легко отладить, правильно отобразить в DOM и убедиться, что зависимости загружены правильно.</target>
        </trans-unit>
        <trans-unit id="e71ee8ddaf9dbce0706f9609b8c87eec82c91b6d" translate="yes" xml:space="preserve">
          <source>I had a simple issue, but I was baffled by responses to this question.</source>
          <target state="translated">У меня был простой вопрос,но я был озадачен ответами на этот вопрос.</target>
        </trans-unit>
        <trans-unit id="e90313ba30b8afab25bd3404bda1adf05507004e" translate="yes" xml:space="preserve">
          <source>I had to use a variable (myVar1) defined in one JavaScript file (myvariables.js) in another JavaScript file (main.js).</source>
          <target state="translated">Я должен был использовать переменную (myVar1),определенную в одном файле JavaScript (myvariables.js)в другом файле JavaScript (main.js).</target>
        </trans-unit>
        <trans-unit id="e78b6aa2c0deda3aa7dbaba4a6e64774f7b7faa0" translate="yes" xml:space="preserve">
          <source>I have actually written a jQuery plugin called &lt;em&gt;$.import_js()&lt;/em&gt; which uses this method:</source>
          <target state="translated">На самом деле я написал плагин jQuery с именем &lt;em&gt;$ .import_js (),&lt;/em&gt; который использует этот метод:</target>
        </trans-unit>
        <trans-unit id="4a561d066341fa04c3643f7a3595cf6b9722249e" translate="yes" xml:space="preserve">
          <source>I just wrote this JavaScript code (using &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt; for &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; manipulation):</source>
          <target state="translated">Я только что написал этот код JavaScript (используя &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt; для манипулирования &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="8964113a372044579ef717f6641fb9d359e68a92" translate="yes" xml:space="preserve">
          <source>I liked the idea of extending jQuery, but obviously you don't need to.</source>
          <target state="translated">Мне понравилась идея расширить JQuery,но,очевидно,в этом нет необходимости.</target>
        </trans-unit>
        <trans-unit id="48b6e1e53bcee394381ab4d7bb07cd633f263a4a" translate="yes" xml:space="preserve">
          <source>I use &lt;a href=&quot;https://github.com/sstephenson/sprockets&quot;&gt;Sprockets&lt;/a&gt; (I don't know if there are others). You build your JavaScript code in separate files and include comments that are processed by the Sprockets engine as includes. For development you can include files sequentially, then for production to merge them...</source>
          <target state="translated">Я использую &lt;a href=&quot;https://github.com/sstephenson/sprockets&quot;&gt;Звездочки&lt;/a&gt; (я не знаю, есть ли другие). Вы строите свой код JavaScript в отдельных файлах и включаете комментарии, которые обрабатываются механизмом Sprockets, как и включенные. Для разработки вы можете включить файлы последовательно, а затем для производства, чтобы объединить их ...</target>
        </trans-unit>
        <trans-unit id="182b551075d667e89774a12930481224b9f18f97" translate="yes" xml:space="preserve">
          <source>I wrote a simple module that automates the job of importing/including module scripts in JavaScript. For detailed explanation of the code, refer to the blog post &lt;em&gt;&lt;a href=&quot;http://stamat.wordpress.com/2013/04/12/javascript-require-import-include-modules/&quot;&gt;JavaScript require / import / include modules&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Я написал простой модуль, который автоматизирует работу по импорту / включению скриптов модуля в JavaScript. Для подробного объяснения кода, обратитесь к сообщению блога &lt;em&gt;&lt;a href=&quot;http://stamat.wordpress.com/2013/04/12/javascript-require-import-include-modules/&quot;&gt;JavaScript require / import / include modules&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8b95b09b19967e0602d178894a47c43cfd08dc83" translate="yes" xml:space="preserve">
          <source>I've found it's more reliable to just write the script tags in a PHP include. You only have to write it once and that's just as much work as calling the plugin using JavaScript.</source>
          <target state="translated">Я нашел более надежным просто написать теги скрипта в PHP include.Вы должны написать его только один раз,и это такая же работа,как вызов плагина с помощью JavaScript.</target>
        </trans-unit>
        <trans-unit id="50692954f36df35776c3a5384707e2028295c3dc" translate="yes" xml:space="preserve">
          <source>If anyone is looking for something more advanced, try out &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;. You'll get added benefits such as dependency management, better concurrency, and avoid duplication (that is, retrieving a script more than once).</source>
          <target state="translated">Если кто-то ищет что-то более продвинутое, попробуйте &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; . Вы получите дополнительные преимущества, такие как управление зависимостями, улучшенный параллелизм и избежание дублирования (то есть получение сценария более одного раза).</target>
        </trans-unit>
        <trans-unit id="09c49c729196296537941a7491dbe605bca62236" translate="yes" xml:space="preserve">
          <source>If it works for Facebook, it will work for you.</source>
          <target state="translated">Если это сработает на Facebook,то сработает и на вас.</target>
        </trans-unit>
        <trans-unit id="e0e6f46db11f475cee8f6fa8e7e1cdd71fa87a80" translate="yes" xml:space="preserve">
          <source>If script2 requires script1, this really is the absolute easiest way to do something like this. I'm very surprised no-one has brought this up, as it's the most obvious and simplest answer that will apply in nearly every single case.</source>
          <target state="translated">Если script2 требует script1,то это действительно самый простой способ сделать что-то подобное.Я очень удивлен,что никто не поднимал эту тему,так как это самый очевидный и простой ответ,который будет применяться почти в каждом отдельном случае.</target>
        </trans-unit>
        <trans-unit id="08d0f5c8d3d6ff132321aa6d959d367e737ba43f" translate="yes" xml:space="preserve">
          <source>If you use the jQuery library, you can use the &lt;code&gt;$.getScript&lt;/code&gt; method.</source>
          <target state="translated">Если вы используете библиотеку jQuery, вы можете использовать метод &lt;code&gt;$.getScript&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d3524e0e4d4cd1e4cf3277f0741ff66c1dc55d6" translate="yes" xml:space="preserve">
          <source>If you want in pure JavaScript, you can use &lt;code&gt;document.write&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите в чистом JavaScript, вы можете использовать &lt;code&gt;document.write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad91c62be5e861663504e4455fee22384fc00bcf" translate="yes" xml:space="preserve">
          <source>If your intention to load the JavaScript file is &lt;strong&gt;using the functions from the imported/included file&lt;/strong&gt;, you can also define a global object and set the functions as object items. For instance:</source>
          <target state="translated">Если ваше намерение загрузить файл JavaScript &lt;strong&gt;использует функции из импортированного / включенного файла&lt;/strong&gt; , вы также можете определить глобальный объект и установить функции в качестве элементов объекта. Например:</target>
        </trans-unit>
        <trans-unit id="87d10a4bf452ed2df2e36493992bb6eac702495c" translate="yes" xml:space="preserve">
          <source>In case you are using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage&quot;&gt;Web Workers&lt;/a&gt; and want to include additional scripts in the scope of the worker, the other answers provided about adding scripts to the &lt;code&gt;head&lt;/code&gt; tag, etc. will not work for you.</source>
          <target state="translated">Если вы используете &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage&quot;&gt;Web Workers&lt;/a&gt; и хотите включить в область работника дополнительные сценарии, другие ответы о добавлении сценариев в тег &lt;code&gt;head&lt;/code&gt; и т. Д. Не будут работать для вас.</target>
        </trans-unit>
        <trans-unit id="c372dfb440124c48faeedb667ad1686636faba8f" translate="yes" xml:space="preserve">
          <source>In modern language with the check if script has already been loaded it would be:</source>
          <target state="translated">В современном языке с проверкой,загружен ли уже скрипт,это было бы:</target>
        </trans-unit>
        <trans-unit id="89e569c5aabe9fbbde286f6fa71cb13e5d555b8c" translate="yes" xml:space="preserve">
          <source>Instead of this approach you could attempt to modify the jQuery &lt;code&gt;readyList&lt;/code&gt;, but this seemed like a worse solution.</source>
          <target state="translated">Вместо этого вы можете попытаться изменить &lt;code&gt;readyList&lt;/code&gt; список jQuery, но это выглядит как худшее решение.</target>
        </trans-unit>
        <trans-unit id="5198a78bb0d30cc8cf91f499bbb47db39eac32c1" translate="yes" xml:space="preserve">
          <source>Is there something in JavaScript similar to &lt;code&gt;@import&lt;/code&gt; in CSS that allows you to include a JavaScript file inside another JavaScript file?</source>
          <target state="translated">Есть ли в JavaScript что-то похожее на &lt;code&gt;@import&lt;/code&gt; в CSS, что позволяет включать файл JavaScript в другой файл JavaScript?</target>
        </trans-unit>
        <trans-unit id="a0c170f044d1b6605820b898a6064dddbee3d16e" translate="yes" xml:space="preserve">
          <source>It includes a &lt;code&gt;main.js&lt;/code&gt; file in the main HTML and then the script in &lt;code&gt;main.js&lt;/code&gt; uses &lt;code&gt;$.import_js()&lt;/code&gt; to import an additional file called &lt;code&gt;included.js&lt;/code&gt;, which defines this function:</source>
          <target state="translated">Он включает файл &lt;code&gt;main.js&lt;/code&gt; в основной HTML, а затем сценарий в &lt;code&gt;main.js&lt;/code&gt; использует &lt;code&gt;$.import_js()&lt;/code&gt; для импорта дополнительного файла с именем includes.js , который определяет эту функцию:</target>
        </trans-unit>
        <trans-unit id="cc1c709a99169050e868f3572e201e60f18ff0c4" translate="yes" xml:space="preserve">
          <source>It is possible to dynamically generate a JavaScript tag and append it to HTML document from inside other JavaScript code. This will load targeted JavaScript file.</source>
          <target state="translated">Можно динамически генерировать тег JavaScript и добавлять его в HTML-документ изнутри другого JavaScript-кода.Это позволит загрузить целевой JavaScript-файл.</target>
        </trans-unit>
        <trans-unit id="299027586058c2f57df63257e78428635d35de48" translate="yes" xml:space="preserve">
          <source>It means that if you use these tricks directly, &lt;em&gt;you won't be able to use your newly loaded code the next line after you asked it to be loaded&lt;/em&gt;, because it will be still loading.</source>
          <target state="translated">Это означает, что если вы будете использовать эти приемы напрямую, &lt;em&gt;вы не сможете использовать свой недавно загруженный код на следующей строке после того, как вы попросили его загрузить&lt;/em&gt; , потому что он все еще будет загружаться.</target>
        </trans-unit>
        <trans-unit id="b01ba72d4fd35a9d4c4c9996b99e2fd452fde924" translate="yes" xml:space="preserve">
          <source>It works great and uses no page-reloads for me. I've tried the AJAX method (one of the other answers) but it doesn't seem to work as nicely for me.</source>
          <target state="translated">Он отлично работает и не перезагружает страницы для меня.Я пробовал метод AJAX (один из других ответов),но,похоже,он работает не так хорошо для меня.</target>
        </trans-unit>
        <trans-unit id="e5daad8292815a8f471b32cc8d290ff531ccef25" translate="yes" xml:space="preserve">
          <source>Like Dynamic Imports you can load one or many scripts with a &lt;code&gt;fetch&lt;/code&gt; call using promises to control order of execution for script dependencies using the &lt;a href=&quot;https://git.habd.as/jhabdas/fetch-inject&quot;&gt;Fetch Inject&lt;/a&gt; library:</source>
          <target state="translated">Как и Dynamic Imports, вы можете загружать один или несколько сценариев с помощью вызова &lt;code&gt;fetch&lt;/code&gt; используя обещания для управления порядком выполнения зависимостей сценариев с помощью библиотеки &lt;a href=&quot;https://git.habd.as/jhabdas/fetch-inject&quot;&gt;Fetch Inject&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8fcc19aee2e562ac4b64c23515ff5bb055bba5e1" translate="yes" xml:space="preserve">
          <source>Loaded the JavaScript code in the HTML file, in the correct order, myvariables.js first, then main.js:</source>
          <target state="translated">Загрузил JavaScript-код в HTML-файл,в правильном порядке,сначала myvariables.js,затем main.js:</target>
        </trans-unit>
        <trans-unit id="7475b8cb4b8b4b0ea0bd2e2735262e923671b358" translate="yes" xml:space="preserve">
          <source>Manually call just the one file in your head:</source>
          <target state="translated">Вручную вызовите только один файл в вашей голове:</target>
        </trans-unit>
        <trans-unit id="c0955483993644c2d345d5478838388a3821a9ea" translate="yes" xml:space="preserve">
          <source>Maybe you can use this function that I found on this page &lt;em&gt;&lt;a href=&quot;http://forums.digitalpoint.com/showthread.php?t=146094&quot;&gt;How do I include a JavaScript file in a JavaScript file?&lt;/a&gt;&lt;/em&gt;:</source>
          <target state="translated">Может быть, вы можете использовать эту функцию, которую я нашел на этой странице &lt;em&gt;&lt;a href=&quot;http://forums.digitalpoint.com/showthread.php?t=146094&quot;&gt;Как мне включить файл JavaScript в файл JavaScript?&lt;/a&gt;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="e8d91a207629cab68b84bde0bfdf97bd5b2fd884" translate="yes" xml:space="preserve">
          <source>Mix files are simply .js or .css files with .mix. in the file name. A
  mix file simply     extends the functionality of a normal style or
  script file and allows you to import and combine.</source>
          <target state="translated">Смешанные файлы-это просто .js или .css файлы с .mix.в имени файла.Смешанный файл просто расширяет функциональность обычного стиля или файла сценария и позволяет импортировать и комбинировать.</target>
        </trans-unit>
        <trans-unit id="481ac87a7bba22c45887cc5c7ea78c63b449b061" translate="yes" xml:space="preserve">
          <source>Mixture outputs this as &lt;code&gt;scripts-global.js&lt;/code&gt; and also as a minified version (&lt;code&gt;scripts-global.min.js&lt;/code&gt;).</source>
          <target state="translated">Mixture выводит это как &lt;code&gt;scripts-global.js&lt;/code&gt; , а также как уменьшенную версию ( &lt;code&gt;scripts-global.min.js&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3a067d11c89c1bd83a9bd5ce416dd2e152f89832" translate="yes" xml:space="preserve">
          <source>Most of solutions shown here imply dynamical loading. I was searching instead for a compiler which assemble all the depended files into a single output file. The same as &lt;a href=&quot;http://en.wikipedia.org/wiki/Less_%28stylesheet_language%29&quot;&gt;Less&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass&lt;/a&gt; preprocessors deal with the CSS &lt;code&gt;@import&lt;/code&gt; at-rule. Since I didn't find anything decent of this sort, I wrote a simple tool solving the issue.</source>
          <target state="translated">Большинство представленных здесь решений предполагают динамическую загрузку. Вместо этого я искал компилятор, который собирает все зависимые файлы в один выходной файл. Так же, как препроцессоры &lt;a href=&quot;http://en.wikipedia.org/wiki/Less_%28stylesheet_language%29&quot;&gt;Less&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/Sass_%28stylesheet_language%29&quot;&gt;Sass&lt;/a&gt; &lt;code&gt;@import&lt;/code&gt; с правилом CSS @import . Поскольку я не нашел ничего приличного в этом роде, я написал простой инструмент для решения проблемы.</target>
        </trans-unit>
        <trans-unit id="80d75005f71e84434c0fa44621569283aced2efa" translate="yes" xml:space="preserve">
          <source>My usual method is:</source>
          <target state="translated">Мой обычный метод:</target>
        </trans-unit>
        <trans-unit id="cd04c41011b8c6a90b8d3d406e8973f00f118915" translate="yes" xml:space="preserve">
          <source>NOTE: You must use this only while the page is loading, otherwise you get a blank screen. In other words, &lt;strong&gt;always place this before / outside of document.ready&lt;/strong&gt;. I have not tested using this after the page is loaded in a click event or anything like that, but I am pretty sure it'll fail.</source>
          <target state="translated">ПРИМЕЧАНИЕ. Вы должны использовать это только во время загрузки страницы, иначе вы получите пустой экран. Другими словами, &lt;strong&gt;всегда размещайте это перед / за пределами document.ready&lt;/strong&gt; . Я не проверял использование этого после загрузки страницы в событии щелчка или чем-то подобном, но я почти уверен, что это потерпит неудачу.</target>
        </trans-unit>
        <trans-unit id="0ce496c371b0e9f99e92db6d770461268fed0859" translate="yes" xml:space="preserve">
          <source>Node.js require</source>
          <target state="translated">Node.js требуют</target>
        </trans-unit>
        <trans-unit id="70393d4cd6440f7071aab91842a254a103787886" translate="yes" xml:space="preserve">
          <source>Note that the script may execute after the DOM has loaded, or before, depending on the browser and whether you included the line &lt;code&gt;script.async = false;&lt;/code&gt;. There's a &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/script-loading/&quot;&gt;great article on Javascript loading in general&lt;/a&gt; which discusses this.</source>
          <target state="translated">Обратите внимание, что сценарий может выполняться после загрузки DOM или раньше, в зависимости от браузера и от того, включена ли строка &lt;code&gt;script.async = false;&lt;/code&gt; , В &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/script-loading/&quot;&gt;общем&lt;/a&gt; , есть отличная статья о загрузке Javascript, которая обсуждает это.</target>
        </trans-unit>
        <trans-unit id="ff2891b93715f3f936e6b7d24ad6fad0a5319c90" translate="yes" xml:space="preserve">
          <source>Note that to get this working cross-domain, the server will need to set &lt;code&gt;allow-origin&lt;/code&gt; header in its response.</source>
          <target state="translated">Обратите внимание, что для получения этого рабочего междомена сервер должен будет установить заголовок &lt;code&gt;allow-origin&lt;/code&gt; в своем ответе.</target>
        </trans-unit>
        <trans-unit id="f5f3eb8c4ce200ec467cdef1208486ed2b2ad0c8" translate="yes" xml:space="preserve">
          <source>Note: I'm not in any way affiliated with Mixture, other than using it as a front-end development tool. I came across this question upon seeing a &lt;code&gt;.mix&lt;/code&gt; JavaScript file in action (in one of the Mixture boilerplates) and being a bit confused by it (&quot;you can do this?&quot; I thought to myself). Then I realized that it was an application-specific file type (somewhat disappointing, agreed). Nevertheless, figured the knowledge might be helpful for others.</source>
          <target state="translated">Примечание: я никоим образом не связан с Mixture, кроме того, что использую его как интерфейсный инструмент разработки. Я столкнулся с этим вопросом, увидев &lt;code&gt;.mix&lt;/code&gt; JavaScript .mix в действии (в одном из шаблонов Mixture) и будучи немного смущенным этим (&amp;laquo;Вы можете сделать это?&amp;raquo; - подумал я про себя). Затем я понял, что это был тип файла приложения (несколько разочаровывающий, согласился). Тем не менее, полагал, что знания могут быть полезны для других.</target>
        </trans-unit>
        <trans-unit id="d5361b0d202b75a326b27f5abc5966b30b92c5ab" translate="yes" xml:space="preserve">
          <source>Now we can run the compiler:</source>
          <target state="translated">Теперь мы можем запустить компилятор:</target>
        </trans-unit>
        <trans-unit id="be1e395612e56b219495a2511f226e4a6bbad566" translate="yes" xml:space="preserve">
          <source>Now, there is a big issue you must know about. Doing that implies that &lt;em&gt;you remotely load the code&lt;/em&gt;. Modern web browsers will load the file and keep executing your current script because they load everything asynchronously to improve performance. (This applies to both the jQuery method and the manual dynamic script loading method.)</source>
          <target state="translated">Теперь есть большая проблема, о которой вы должны знать. Это подразумевает, что &lt;em&gt;вы загружаете код удаленно&lt;/em&gt; . Современные веб-браузеры загружают файл и продолжают выполнять ваш текущий скрипт, потому что они загружают все асинхронно для повышения производительности. (Это относится как к методу jQuery, так и к методу ручной динамической загрузки скрипта.)</target>
        </trans-unit>
        <trans-unit id="f6aec98cb390ce572d475ac294a8779bcdd59d39" translate="yes" xml:space="preserve">
          <source>On the jQuery master branch, they simply concatenate atomic source files into a single one starting with &lt;code&gt;intro.js&lt;/code&gt; and ending with &lt;code&gt;outtro.js&lt;/code&gt;. That doesn't suits me as it provides no flexibility on the source code design. Check out how it works with jsic:</source>
          <target state="translated">В основной ветке jQuery они просто объединяют атомарные исходные файлы в один, начиная с &lt;code&gt;intro.js&lt;/code&gt; и заканчивая &lt;code&gt;outtro.js&lt;/code&gt; . Это меня не устраивает, так как не обеспечивает гибкости при разработке исходного кода. Проверьте, как это работает с JSIC:</target>
        </trans-unit>
        <trans-unit id="35244510a0932d71a1e33c185ed4d3632c86c351" translate="yes" xml:space="preserve">
          <source>Or rather than including at run time, use a script to concatenate prior to upload.</source>
          <target state="translated">Или вместо того,чтобы включать во время выполнения,используйте скрипт для конкатенирования перед загрузкой.</target>
        </trans-unit>
        <trans-unit id="ae55d21513645c5d75d2af23ca6c677b65dcc82d" translate="yes" xml:space="preserve">
          <source>Read more at &lt;a href=&quot;https://developers.google.com/web/updates/2017/11/dynamic-import&quot;&gt;https://developers.google.com/web/updates/2017/11/dynamic-import&lt;/a&gt;</source>
          <target state="translated">Подробнее &lt;a href=&quot;https://developers.google.com/web/updates/2017/11/dynamic-import&quot;&gt;читайте&lt;/a&gt; на странице https://developers.google.com/web/updates/2017/11/dynamic-import.</target>
        </trans-unit>
        <trans-unit id="0fdf3837508857a07cdb1bf94cb244b7d21a5aae" translate="yes" xml:space="preserve">
          <source>Read more at &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;https://jakearchibald.com/2017/es-modules-in-browsers/&lt;/a&gt;</source>
          <target state="translated">Узнайте больше на &lt;a href=&quot;https://jakearchibald.com/2017/es-modules-in-browsers/&quot;&gt;https://jakearchibald.com/2017/es-modules-in-browsers/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a2968690e7c23123fd7efc2f7e364afd5a86919" translate="yes" xml:space="preserve">
          <source>Refer to:</source>
          <target state="translated">Смотри:</target>
        </trans-unit>
        <trans-unit id="5ad4ccb4e6c788c5d5198e149aa1d4af7b483a35" translate="yes" xml:space="preserve">
          <source>RequireJS loads plain JavaScript files as well as more defined
  modules. It is optimized for in-browser use, including in a Web
  Worker, but it can be used in other JavaScript environments, like
  Rhino and Node. It implements the Asynchronous Module API.</source>
          <target state="translated">RequireJS загружает как простые JavaScript-файлы,так и более определенные модули.Он оптимизирован для использования в браузере,в том числе и в Web Worker,но может быть использован и в других JavaScript-средах,таких как Rhino и Node.Реализован API модуля Asynchronous.</target>
        </trans-unit>
        <trans-unit id="efbb4b5102cbae7f42e744b6a9286fbaccd8f904" translate="yes" xml:space="preserve">
          <source>RequireJS uses plain script tags to load modules/files, so it should
  allow for easy debugging. It can be used simply to load existing
  JavaScript files, so &lt;strong&gt;you can add it to your existing project without
  having to re-write your JavaScript files.&lt;/strong&gt;</source>
          <target state="translated">RequireJS использует простые теги сценариев для загрузки модулей / файлов, поэтому он должен обеспечивать легкую отладку. Его можно использовать просто для загрузки существующих файлов JavaScript, поэтому &lt;strong&gt;вы можете добавить его в существующий проект без необходимости переписывать файлы JavaScript.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">См.также:</target>
        </trans-unit>
        <trans-unit id="71dc617a43ade90c11908db4d0f8e0e5ad86ab36" translate="yes" xml:space="preserve">
          <source>Set up a file called &quot;plugins.js&quot; (or extensions.js or whatever you want). Keep your plugin files together with that one master file.</source>
          <target state="translated">Установите файл под названием &quot;plugins.js&quot; (или extensions.js,или что угодно).Сохраняйте ваши файлы плагинов вместе с этим одним основным файлом.</target>
        </trans-unit>
        <trans-unit id="cb63b27c44e32458c090132cc30786386502db2f" translate="yes" xml:space="preserve">
          <source>So all you would need to do to import JavaScript is:</source>
          <target state="translated">Итак,для импорта JavaScript все,что вам нужно сделать:</target>
        </trans-unit>
        <trans-unit id="50c7c7e6fbef7aa987cd88ab0ebe41cc1d7dfd86" translate="yes" xml:space="preserve">
          <source>So here is the compiler, &lt;a href=&quot;https://github.com/dsheiko/jsic&quot;&gt;https://github.com/dsheiko/jsic&lt;/a&gt;, which replaces &lt;code&gt;$import(&quot;file-path&quot;)&lt;/code&gt; with the requested file content securely. Here is the corresponding &lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; plugin: &lt;a href=&quot;https://github.com/dsheiko/grunt-jsic&quot;&gt;https://github.com/dsheiko/grunt-jsic&lt;/a&gt;.</source>
          <target state="translated">Итак, вот компилятор &lt;a href=&quot;https://github.com/dsheiko/jsic&quot;&gt;https://github.com/dsheiko/jsic&lt;/a&gt; , который надежно заменяет &lt;code&gt;$import(&quot;file-path&quot;)&lt;/code&gt; запрашиваемым содержимым файла. Вот соответствующий плагин &lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; : &lt;a href=&quot;https://github.com/dsheiko/grunt-jsic&quot;&gt;https://github.com/dsheiko/grunt-jsic&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="207e16cd95f6cd938f21d26d90e229e30bc7c63b" translate="yes" xml:space="preserve">
          <source>So you don't have to rely upon any JavaScript framework nor do you have to explicitly make &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;Ajax&lt;/a&gt; calls.</source>
          <target state="translated">Таким образом, вам не нужно полагаться на какую-либо инфраструктуру JavaScript и не нужно явно делать вызовы &lt;a href=&quot;http://en.wikipedia.org/wiki/Ajax_%28programming%29&quot;&gt;Ajax&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="db6dad97ca62ef5d7f44d822ae7ada54d51ed9bf" translate="yes" xml:space="preserve">
          <source>Source Code Merge/Preprocessing</source>
          <target state="translated">Обработка исходного кода MergePreproprocessing</target>
        </trans-unit>
        <trans-unit id="60c6c4d6b31992a793c66bd837c9c7497f32017e" translate="yes" xml:space="preserve">
          <source>Statement &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; is in ECMAScript 6.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; операторов в ECMAScript 6.</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="8b1b78f01302f9f5124b19ec9053902f483cc415" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; library provides loading functionality &lt;a href=&quot;http://api.jquery.com/jQuery.getScript/&quot;&gt;in one line&lt;/a&gt;:</source>
          <target state="translated">Библиотека &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; обеспечивает загрузку &lt;a href=&quot;http://api.jquery.com/jQuery.getScript/&quot;&gt;в одну строку&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="365cfa5fd770b6dc0769934f9dacef667879a63d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@import&lt;/code&gt; syntax for achieving CSS-like JavaScript importing is possible using a tool such as Mixture via their special &lt;code&gt;.mix&lt;/code&gt; file type (see &lt;a href=&quot;http://docs.mixture.io/preprocessors#mix&quot;&gt;here&lt;/a&gt;). I imagine the application simply uses one of the aforementioned methods interally, though I don't know.</source>
          <target state="translated">Синтаксис &lt;code&gt;@import&lt;/code&gt; для импорта CSS-подобного JavaScript возможен с помощью такого инструмента, как Mixture, через специальный &lt;code&gt;.mix&lt;/code&gt; файла .mix (см. &lt;a href=&quot;http://docs.mixture.io/preprocessors#mix&quot;&gt;Здесь&lt;/a&gt; ). Я предполагаю, что приложение просто использует один из вышеупомянутых методов, хотя я не знаю.</target>
        </trans-unit>
        <trans-unit id="c5e847bed7fd8f4657d461e7ff8a88bffa6bd775" translate="yes" xml:space="preserve">
          <source>The old versions of JavaScript had no import, include, or require, so many different approaches to this problem have been developed.</source>
          <target state="translated">Старые версии JavaScript не импортировали,не включали и не требовали,поэтому было разработано множество различных подходов к этой проблеме.</target>
        </trans-unit>
        <trans-unit id="332a07b88f0fcf415b8555e25a5eeedebfe4cb0d" translate="yes" xml:space="preserve">
          <source>The older CJS module style, still widely used in Node.js, is the &lt;a href=&quot;https://nodejs.org/api/modules.html&quot;&gt;&lt;code&gt;module.exports&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; system.</source>
          <target state="translated">Более старый стиль модуля CJS, все еще широко используемый в Node.js, это система &lt;a href=&quot;https://nodejs.org/api/modules.html&quot;&gt; &lt;code&gt;module.exports&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c64a3691275e516da071b56c9173a3a5745a171" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;$.getScript&lt;/code&gt; and really any other solution that requires a callback when loading is complete is that if you have multiple files that use it and depend on each other you no longer have a way to know when all scripts have been loaded (once they are nested in multiple files).</source>
          <target state="translated">Проблема с &lt;code&gt;$.getScript&lt;/code&gt; и действительно любым другим решением, которое требует обратного вызова при завершении загрузки, состоит в том, что если у вас есть несколько файлов, которые используют его и зависят друг от друга, у вас больше не будет способа узнать, когда все сценарии были загружены (один раз они вложены в несколько файлов).</target>
        </trans-unit>
        <trans-unit id="e3df137a5e529bd9e98b8d075cf6b8ec8e6991ff" translate="yes" xml:space="preserve">
          <source>The reason why we look for the first &lt;code&gt;script&lt;/code&gt; element instead of &lt;code&gt;head&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; is because some browsers don't create one if missing, but we're guaranteed to have a &lt;code&gt;script&lt;/code&gt; element - this one. Read more at &lt;a href=&quot;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&quot;&gt;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&lt;/a&gt;.</source>
          <target state="translated">Причина, по которой мы ищем первый элемент &lt;code&gt;script&lt;/code&gt; вместо &lt;code&gt;head&lt;/code&gt; или &lt;code&gt;body&lt;/code&gt; заключается в том, что некоторые браузеры не создают его в случае его отсутствия, но мы обязательно имеем элемент &lt;code&gt;script&lt;/code&gt; - этот. Узнайте больше на &lt;a href=&quot;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&quot;&gt;http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82cf60f97f6c09707b8f19fab54ef5c1a0cb6287" translate="yes" xml:space="preserve">
          <source>The script can even reside on a different server. Furthermore, the browser evaluates the code. The &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag can be injected into either the web page &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;, or inserted just before the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">Скрипт может даже находиться на другом сервере. Кроме того, браузер оценивает код. Тег &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; может быть вставлен в веб-страницу &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; или вставлен непосредственно перед закрывающим &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbf546d79de34ac91357b0003cf697e434471972" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;main.js&lt;/code&gt;:</source>
          <target state="translated">Тогда &lt;code&gt;main.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a3dc8d9fecff4598af5823bdb8309740acf1198" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;main.mjs&lt;/code&gt;:</source>
          <target state="translated">Тогда &lt;code&gt;main.mjs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7cb5f212cd2a13edf49d3b9684dcfad659ee20ea" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;module.js&lt;/code&gt;:</source>
          <target state="translated">Тогда &lt;code&gt;module.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fea8eb87370a87b1e4d189a8d9e83a44e5c1f2cf" translate="yes" xml:space="preserve">
          <source>Then you reload the page hitting</source>
          <target state="translated">Затем вы перезагружаете страницу,нажав</target>
        </trans-unit>
        <trans-unit id="0672e4bde170e584fa2b6dc719a249509055bb38" translate="yes" xml:space="preserve">
          <source>Then you run all that:</source>
          <target state="translated">Тогда ты будешь управлять всем этим:</target>
        </trans-unit>
        <trans-unit id="3b84e4c1da86765df25fe1104617e23cd6a3172e" translate="yes" xml:space="preserve">
          <source>Then you write the code you want to use AFTER the script is loaded in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda function&lt;/a&gt;:</source>
          <target state="translated">Затем вы пишете код, который хотите использовать ПОСЛЕ того, как скрипт загружается в &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;лямбда-функцию&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="38c5068306243c5f0677ed35094b305a3aebfa48" translate="yes" xml:space="preserve">
          <source>There actually &lt;em&gt;is&lt;/em&gt; a way to load a JavaScript file &lt;em&gt;not&lt;/em&gt; asynchronously, so you could use the functions included in your newly loaded file right after loading it, and I think it works in all browsers.</source>
          <target state="translated">На самом деле &lt;em&gt;есть&lt;/em&gt; способ загрузить файл JavaScript &lt;em&gt;не&lt;/em&gt; асинхронно, так что вы можете использовать функции, включенные в ваш недавно загруженный файл, сразу после загрузки, и я думаю, что он работает во всех браузерах.</target>
        </trans-unit>
        <trans-unit id="d358c9da7c21739b51ad491587d2a2e4bbea8403" translate="yes" xml:space="preserve">
          <source>There are a lot of potential answers for this question. My answer is obviously based on a number of them. This is what I ended up with after reading through all the answers.</source>
          <target state="translated">На этот вопрос есть много потенциальных ответов.Очевидно,что мой ответ основывается на ряде из них.Это то,чем я закончил после прочтения всех ответов.</target>
        </trans-unit>
        <trans-unit id="44afba8e9b45daeb202787b573cfab4ecc933b89" translate="yes" xml:space="preserve">
          <source>There are other ways for JavaScript to include external JavaScript contents in browsers that do not require preprocessing.</source>
          <target state="translated">Существуют и другие способы включения внешнего JavaScript-контента в браузеры,не требующие препроцессирования.</target>
        </trans-unit>
        <trans-unit id="775a00f31987b24b0b74ff2c37a582e1e13b8885" translate="yes" xml:space="preserve">
          <source>There are several ways to implement modules in Javascript, Here are the 2 most popular ones:</source>
          <target state="translated">Существует несколько способов реализации модулей на Javascript,вот 2 самых популярных:</target>
        </trans-unit>
        <trans-unit id="a509c35ddc3ed0ce500ef2c3f3e54fe40074c6be" translate="yes" xml:space="preserve">
          <source>There is a good news for you. Very soon you will be able to load JavaScript code easily. It will become a standard way of importing modules of JavaScript code and will be part of core JavaScript itself.</source>
          <target state="translated">Есть хорошие новости для тебя.Очень скоро вы сможете легко загрузить JavaScript-код.Это станет стандартным способом импорта модулей JavaScript-кода и станет частью самого ядра JavaScript.</target>
        </trans-unit>
        <trans-unit id="03917ccdd96f3286351548a9349f54699c873ece" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://headjs.com/&quot;&gt;Head.js&lt;/a&gt;. It is very easy to deal with:</source>
          <target state="translated">Также есть &lt;a href=&quot;http://headjs.com/&quot;&gt;Head.js.&lt;/a&gt; Это очень легко иметь дело с:</target>
        </trans-unit>
        <trans-unit id="282a95668b3d184d0221e75ea9a0b317f15912d1" translate="yes" xml:space="preserve">
          <source>This function will add a new &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to the end of the head section of the page, where the &lt;code&gt;src&lt;/code&gt; attribute is set to the URL which is given to the function as the first parameter.</source>
          <target state="translated">Эта функция добавит новый &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; в конец раздела head страницы, где для атрибута &lt;code&gt;src&lt;/code&gt; задан URL-адрес, который передается функции в качестве первого параметра.</target>
        </trans-unit>
        <trans-unit id="aec69cae0df189fe5f15918931a93fbb19af37a4" translate="yes" xml:space="preserve">
          <source>This moduling system is used in NodeJS. You basically add your exports to an object which is called &lt;code&gt;module.exports&lt;/code&gt;. You then can access this object via a &lt;code&gt;require('modulePath')&lt;/code&gt;. Important here is to realize that these modules are being cached, so if you &lt;code&gt;require()&lt;/code&gt; a certain module twice it will return the already created module.</source>
          <target state="translated">Эта система модуляции используется в NodeJS. Вы в основном добавляете свои экспорты к объекту, который называется &lt;code&gt;module.exports&lt;/code&gt; . Затем вы можете получить доступ к этому объекту через &lt;code&gt;require('modulePath')&lt;/code&gt; . Важно понимать, что эти модули кэшируются, поэтому, если вам &lt;code&gt;require()&lt;/code&gt; определенный модуль дважды, он вернет уже созданный модуль.</target>
        </trans-unit>
        <trans-unit id="8d141c73c6e84930879c36e1f775b68c2e49892c" translate="yes" xml:space="preserve">
          <source>This saved my day. I hope this helps.</source>
          <target state="translated">Это спасло мой день.Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="5fbb1a0423bef2cdcefbfb4471fd65f7883a8a93" translate="yes" xml:space="preserve">
          <source>This script will add a JavaScript file to the top of any other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">Этот скрипт добавит файл JavaScript в начало любого другого &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="677f26183a09ed669f4cb588a041e322090571ba" translate="yes" xml:space="preserve">
          <source>This should do:</source>
          <target state="translated">Это должно сработать:</target>
        </trans-unit>
        <trans-unit id="1766b2907ae68f8084c4976da09f1789f75a93ee" translate="yes" xml:space="preserve">
          <source>Usage (Promise):</source>
          <target state="translated">Использование (Обещание):</target>
        </trans-unit>
        <trans-unit id="eeba7483417f4c19d85bdb39a309d8abb9362c2d" translate="yes" xml:space="preserve">
          <source>Usage (async/await):</source>
          <target state="translated">Использование (асинкаваит):</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="b2f9ce47657e324cce2b6d80e0c2f7518a08067a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.mjs&lt;/code&gt;, you'd have &lt;code&gt;module.mjs&lt;/code&gt;:</source>
          <target state="translated">Используя &lt;code&gt;.mjs&lt;/code&gt; , вы получите &lt;code&gt;module.mjs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c3c8d0e74dd9558a24f0302ee206a7608218058e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">Используя &lt;code&gt;package.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="25836b321091437346e2f5dbe6de27871ab3c287" translate="yes" xml:space="preserve">
          <source>Well, you can use the hack the author suggests in the link I gave you. In summary, for people in a hurry, he uses an event to run a callback function when the script is loaded. So you can put all the code using the remote library in the callback function. For example:</source>
          <target state="translated">Ну,ты можешь воспользоваться взломом,который автор предлагает в ссылке,которую я тебе дал.В общем,для людей,которые спешат,он использует событие для запуска функции обратного вызова при загрузке скрипта.Таким образом,вы можете поместить весь код,используя удаленную библиотеку,в функцию обратного вызова.Например:</target>
        </trans-unit>
        <trans-unit id="6bd3ad67628e2ce42d0075e4006bcb283c8372d6" translate="yes" xml:space="preserve">
          <source>When the additional files are loaded the &lt;code&gt;document.ready&lt;/code&gt; callbacks will get executed in the wrong order. To address this when a script is actually loaded, the script that imported it is re-imported itself and execution halted. This causes the originating file to now have its &lt;code&gt;document.ready&lt;/code&gt; callback executed after any from any scripts that it imports.</source>
          <target state="translated">Когда дополнительные файлы загружены, обратные вызовы &lt;code&gt;document.ready&lt;/code&gt; будут выполняться в неправильном порядке. Чтобы решить эту проблему, когда скрипт действительно загружен, импортированный скрипт сам реимпортируется и выполнение останавливается. Это приводит к тому, что для исходного файла теперь выполняется обратный вызов &lt;code&gt;document.ready&lt;/code&gt; после любого из любых сценариев, которые он импортирует.</target>
        </trans-unit>
        <trans-unit id="9eea4e801ae6abd35d58a38d0d55c894879bbd27" translate="yes" xml:space="preserve">
          <source>You are right when you say that you could specify Ajax to run synchronously or use &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt;, but the current trend appears to be to deprecate synchronous requests, so you may not get full browser support now or in the future.</source>
          <target state="translated">Вы правы, когда говорите, что можете указать, что Ajax будет работать синхронно или использовать &lt;a href=&quot;http://en.wikipedia.org/wiki/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; , но в настоящее время наблюдается тенденция отклонять синхронные запросы, поэтому вы можете не получить полную поддержку браузера сейчас или в будущем.</target>
        </trans-unit>
        <trans-unit id="41b688ca3fa05f1b8bf2b2c1390acf30888a6c1a" translate="yes" xml:space="preserve">
          <source>You can also assemble your scripts using &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;:</source>
          <target state="translated">Вы также можете собрать свои скрипты, используя &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b67289039b993bbae286ee78e5a38a9d7984d26f" translate="yes" xml:space="preserve">
          <source>You can of course use $ (&quot;body&quot;).append(), but then you can no longer debug correctly any more.</source>
          <target state="translated">Вы,конечно,можете использовать $ (&quot;body&quot;).append(),но тогда вы больше не сможете корректно отлаживать.</target>
        </trans-unit>
        <trans-unit id="261f53110fde11b3c98c44fc320c61440f8caf48" translate="yes" xml:space="preserve">
          <source>You can then use it in your code as you'd usually use an include:</source>
          <target state="translated">Затем вы можете использовать его в своем коде,как вы обычно используете включенную версию:</target>
        </trans-unit>
        <trans-unit id="763d2233f3f407809871ccf36da8867041eafddf" translate="yes" xml:space="preserve">
          <source>You can write your JavaScript files in &quot;modules&quot; and then reference them as dependencies in other scripts. Or you can use RequireJS as a simple &quot;go get this script&quot; solution.</source>
          <target state="translated">Вы можете записывать свои JavaScript-файлы в &quot;модули&quot;,а затем ссылаться на них как на зависимости в других скриптах.Или вы можете использовать RequireJS в качестве простого решения &quot;go get this script&quot;.</target>
        </trans-unit>
        <trans-unit id="43fc4e4d3a473a2cd0549a65efd79e36b5e2afb7" translate="yes" xml:space="preserve">
          <source>You could add a script tag with the script URL into the HTML. To avoid the overhead of jQuery, this is an ideal solution.</source>
          <target state="translated">Вы можете добавить тег скрипта с URL скрипта в HTML.Чтобы избежать накладных расходов jQuery,это идеальное решение.</target>
        </trans-unit>
        <trans-unit id="677229282757dc7a7d42af0f461340f88668361d" translate="yes" xml:space="preserve">
          <source>You could load an additional script with an AJAX call and then use &lt;code&gt;eval&lt;/code&gt; to run it. This is the most straightforward way, but it is limited to your domain because of the JavaScript sandbox security model. Using &lt;code&gt;eval&lt;/code&gt; also opens the door to bugs, hacks and security issues.</source>
          <target state="translated">Вы можете загрузить дополнительный скрипт с помощью вызова AJAX, а затем использовать &lt;code&gt;eval&lt;/code&gt; для его запуска. Это самый простой способ, но он ограничен вашим доменом из-за модели безопасности песочницы JavaScript. Использование &lt;code&gt;eval&lt;/code&gt; также открывает путь к ошибкам, взломам и проблемам безопасности.</target>
        </trans-unit>
        <trans-unit id="740e8e133fe6283f4bf17af1eb127c00965480b1" translate="yes" xml:space="preserve">
          <source>You could try to use &lt;code&gt;$.when&lt;/code&gt; to check an array of deferred objects, but now you are doing this in every file and file2 will be considered loaded as soon as the &lt;code&gt;$.when&lt;/code&gt; is executed not when the callback is executed, so file1 still continues execution before file3 is loaded. This really still has the same problem.</source>
          <target state="translated">Вы можете попытаться использовать &lt;code&gt;$.when&lt;/code&gt; для проверки массива отложенных объектов, но теперь вы делаете это в каждом файле, и file2 будет считаться загруженным, как только &lt;code&gt;$.when&lt;/code&gt; будет выполнен, а не при выполнении обратного вызова, поэтому file1 по-прежнему продолжает выполнение до загрузки file3. Это действительно до сих пор та же проблема.</target>
        </trans-unit>
        <trans-unit id="ac49dc35cec96359223a55198aee1ea6a7723105" translate="yes" xml:space="preserve">
          <source>You just need to be careful when you are including scripts in an HTML file. The order should be as in below:</source>
          <target state="translated">Вам просто нужно быть осторожным,когда вы включаете скрипты в HTML-файл.Порядок должен быть таким,как указано ниже:</target>
        </trans-unit>
        <trans-unit id="44f152a3a2ff3ec5b145516a70206e4b37c0738c" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;jQuery.append()&lt;/code&gt; on the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; element of your page, that is:</source>
          <target state="translated">Вам необходимо использовать &lt;code&gt;jQuery.append()&lt;/code&gt; в элементе &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; вашей страницы, то есть:</target>
        </trans-unit>
        <trans-unit id="4ad6f53621aa3d1faf240c9a38a76a34ecb3ac9f" translate="yes" xml:space="preserve">
          <source>You simply have to write &lt;code&gt;import cond from 'cond.js';&lt;/code&gt; to load a macro named &lt;code&gt;cond&lt;/code&gt; from a file &lt;code&gt;cond.js&lt;/code&gt;.</source>
          <target state="translated">Вы просто должны написать &lt;code&gt;import cond from 'cond.js';&lt;/code&gt; загрузить макрос с именем &lt;code&gt;cond&lt;/code&gt; из файла &lt;code&gt;cond.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9c029655932b5efd739f546d5b2cb4eaadd323a" translate="yes" xml:space="preserve">
          <source>file1.js</source>
          <target state="translated">file1.js</target>
        </trans-unit>
        <trans-unit id="a2bf4c98312f67688bf14bf9ed30d02aa9d4ca8d" translate="yes" xml:space="preserve">
          <source>file1.js:</source>
          <target state="translated">file1.js:</target>
        </trans-unit>
        <trans-unit id="d14c0cdfc2b81349332a20275d4e5388ced355bc" translate="yes" xml:space="preserve">
          <source>file2.js</source>
          <target state="translated">file2.js</target>
        </trans-unit>
        <trans-unit id="03a0f7a91e0893577595163e3fac51c418880f93" translate="yes" xml:space="preserve">
          <source>file2.js:</source>
          <target state="translated">file2.js:</target>
        </trans-unit>
        <trans-unit id="9eb542476d35d6e35c8f124ac5e963ed9e1f9a2e" translate="yes" xml:space="preserve">
          <source>file3.js</source>
          <target state="translated">file3.js</target>
        </trans-unit>
        <trans-unit id="a7eac0c8dd40160a0c46c08bdfaf13d11b629316" translate="yes" xml:space="preserve">
          <source>global.js</source>
          <target state="translated">global.js</target>
        </trans-unit>
        <trans-unit id="0f4ed54c5010ce0a22e2398e6e747b8624d5114e" translate="yes" xml:space="preserve">
          <source>jQuery Loading</source>
          <target state="translated">запрос Загрузка</target>
        </trans-unit>
        <trans-unit id="c4a4248f7568c9e41265502c39b0daeb8b635431" translate="yes" xml:space="preserve">
          <source>main.js</source>
          <target state="translated">main.js</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="e8775485c8f1802e0ec89012c9e0a431dd135b78" translate="yes" xml:space="preserve">
          <source>plugins.js will have an array called &lt;code&gt;pluginNames[]&lt;/code&gt; that we will iterate over &lt;code&gt;each()&lt;/code&gt;,
then append a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to the head for each plugin</source>
          <target state="translated">У plugins.js будет массив с именем &lt;code&gt;pluginNames[]&lt;/code&gt; который мы будем повторять для &lt;code&gt;each()&lt;/code&gt; , а затем добавляем &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; к заголовку для каждого плагина.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
