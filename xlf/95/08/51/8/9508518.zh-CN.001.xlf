<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/9508518">
    <body>
      <group id="9508518">
        <trans-unit id="f4fa0ad2dbf00e7377bb9024e10bd7c46a4b8c93" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.com&lt;/a&gt; compares floating point arithmetic across programming languages</source>
          <target state="translated">&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.com&lt;/a&gt;比较各种编程语言中的浮点算法</target>
        </trans-unit>
        <trans-unit id="24c9907757c274c7f252cc607997262c334e6d0a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;The R Inferno by Patrick Burns&lt;/a&gt; devotes the first &quot;Circle&quot; to this problem (starting on page 9)</source>
          <target state="translated">&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;帕特里克&amp;middot;伯恩斯（Patrick Burns）&lt;/a&gt;创作的R Inferno致力于解决这个问题的第一个&amp;ldquo;圆圈&amp;rdquo;（从第9页开始）</target>
        </trans-unit>
        <trans-unit id="930823bc4ba954f44f4ecf582ca21a88c9a5d230" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;Canonical duplicate for &quot;floating point is inaccurate&quot;&lt;/a&gt; (a meta discussion about a canonical answer for this issue)</source>
          <target state="translated">&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;&amp;ldquo;浮点数不正确&amp;rdquo;的规范重复&lt;/a&gt; （有关此问题的规范答案的元讨论）</target>
        </trans-unit>
        <trans-unit id="1baf96f8d4e4ecd837aee183191fa1077bb3b202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does not give the &quot;expected&quot; result and &lt;code&gt;all.equal&lt;/code&gt; does not perform element-wise</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 不会给出&amp;ldquo;预期&amp;rdquo;结果，并且 &lt;code&gt;all.equal&lt;/code&gt; 不会按元素执行</target>
        </trans-unit>
        <trans-unit id="98f6b45786d2b2aedf5ec1132df549cebc8df3fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dplyr::near()&lt;/code&gt; is an option for testing if two vectors of floating point numbers are equal. This is the example from the &lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;dplyr::near()&lt;/code&gt; 是用于测试两个浮点数向量是否相等的选项。 这是&lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;docs中&lt;/a&gt;的示例：</target>
        </trans-unit>
        <trans-unit id="a0e2b1d9886d3fae1cc44fa5d134212926dac59f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;gt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;比较a&amp;gt; = b：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccea69290856a10c89ac66255fbe959b1d843e33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;lt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;比较&amp;lt;= b：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1aeaadf527cff400e53c622865a7ced4c552aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a = b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;比较a = b：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae3dd5ba710442f2a39cd59cf354c80a5495d632" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Per Joshua's warning here is the updated code (Thanks Joshua):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Per Joshua的警告是更新的代码（谢谢Joshua）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051f8044a78b9bb0a5e9b49aec7a714c76917ab2" translate="yes" xml:space="preserve">
          <source>@ I found this work around solution about unequal cut intervals.  @ I
  used the round function in R. By setting the option to 2 digits, did
  not solved the problem.</source>
          <target state="translated">@ 我找到了这个关于不相等的切割间隔的解决方案。我在R中使用了round函数,将选项设置为2位数,并没有解决这个问题。</target>
        </trans-unit>
        <trans-unit id="2aeffb9b120bf727e331fbd80cf3370e6f6add08" translate="yes" xml:space="preserve">
          <source>Adding to Brian's comment (which is the reason) you can over come this by using &lt;code&gt;all.equal&lt;/code&gt; instead:</source>
          <target state="translated">在Brian的评论中添加（这就是原因），您可以使用 &lt;code&gt;all.equal&lt;/code&gt; 代替：</target>
        </trans-unit>
        <trans-unit id="c3e13ababf0fa6f39113926ca83f1024d4b04f23" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of wrapping &lt;code&gt;all.equal&lt;/code&gt; in even more function calls, you can just replicate the relevant internals of &lt;code&gt;all.equal.numeric&lt;/code&gt; and use implicit vectorization:</source>
          <target state="translated">另外，也可以将 &lt;code&gt;all.equal.numeric&lt;/code&gt; 的相关内部复制并使用隐式矢量化，而不是将 &lt;code&gt;all.equal&lt;/code&gt; 包装在更多函数调用中：</target>
        </trans-unit>
        <trans-unit id="e1cc3319b6d4e9c6df888fe5f49dbccf0d9c60c3" translate="yes" xml:space="preserve">
          <source>Comparing scalars</source>
          <target state="translated">比较标量</target>
        </trans-unit>
        <trans-unit id="e5078ee6bca5437eb55e908d75d2142a6eb1887f" translate="yes" xml:space="preserve">
          <source>Comparing vectors</source>
          <target state="translated">向量比较</target>
        </trans-unit>
        <trans-unit id="9141c1bcc7393f0a51a930e3e61068beb111c324" translate="yes" xml:space="preserve">
          <source>David Goldberg, &quot;What Every Computer Scientist Should Know About Floating-point Arithmetic,&quot; &lt;em&gt;ACM Computing Surveys&lt;/em&gt;&lt;strong&gt;23&lt;/strong&gt;, 1 (1991-03), 5-48 &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;doi&amp;gt;10.1145/103162.103163&lt;/a&gt; (&lt;a href=&quot;http://www.validlab.com/goldberg/paper.pdf&quot;&gt;revision also available&lt;/a&gt;)</source>
          <target state="translated">大卫&amp;middot;戈德堡（David Goldberg），&amp;ldquo;每位计算机科学家都应了解的浮点算法&amp;rdquo;， &lt;em&gt;ACM计算调查&lt;/em&gt; &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;23，1&lt;/a&gt; （1991-03），5-48 doi&amp;gt; 10.1145 / 103162.103163 （ &lt;a href=&quot;http://www.validlab.com/goldberg/paper.pdf&quot;&gt;也提供修订版&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="61a132a84dfc3fde6af76f27012b8611354d6aa7" translate="yes" xml:space="preserve">
          <source>General (language agnostic) reason</source>
          <target state="translated">一般(语言不可知论)理由</target>
        </trans-unit>
        <trans-unit id="d9da8d2236553ed39bb853de9dbc03947b4af565" translate="yes" xml:space="preserve">
          <source>Generalized comparisons (&quot;&amp;lt;=&quot;, &quot;&amp;gt;=&quot;, &quot;=&quot;) in double precion arithmetic:</source>
          <target state="translated">双精度算法中的广义比较（&amp;ldquo; &amp;lt;=&amp;rdquo;，&amp;ldquo;&amp;gt; =&amp;rdquo;，&amp;ldquo; =&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="ca21d0110f4cb3b258d5ecd4dbf4725bfab29709" translate="yes" xml:space="preserve">
          <source>I had a similar problem. I used the following solution.</source>
          <target state="translated">我也遇到了类似的问题。我使用了以下的解决方案。</target>
        </trans-unit>
        <trans-unit id="6821df2a778db375130c453d3832adf6ecca124e" translate="yes" xml:space="preserve">
          <source>If a functional version of this is desired, it can be written</source>
          <target state="translated">如果需要一个功能版本,可以写成</target>
        </trans-unit>
        <trans-unit id="a326f79ad38f19b61a34a0eda13066d9d3971374" translate="yes" xml:space="preserve">
          <source>Is floating point math broken?</source>
          <target state="translated">浮点数学是不是坏了?</target>
        </trans-unit>
        <trans-unit id="4aae375ec7ffb4038e977be2e7bfd35ef0e328eb" translate="yes" xml:space="preserve">
          <source>Rather, a version which loops over the two vectors must be used</source>
          <target state="translated">相反,必须使用一个在两个向量上循环的版本。</target>
        </trans-unit>
        <trans-unit id="1a049a837169173e32b09640587b10f6554d0375" translate="yes" xml:space="preserve">
          <source>Several Stack Overflow questions including</source>
          <target state="translated">几个堆栈溢出的问题,包括</target>
        </trans-unit>
        <trans-unit id="23417499b5d7a1a4236bdd6daa17778bf5030ace" translate="yes" xml:space="preserve">
          <source>Since not all numbers can be represented exactly in &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE floating point arithmetic&lt;/a&gt; (the standard that almost all computers use to represent decimal numbers and do math with them), you will not always get what you expected. This is especially true because some values which are simple, finite decimals (such as 0.1 and 0.05) are not represented exactly in the computer and so the results of arithmetic on them may not give a result that is identical to a direct representation of the &quot;known&quot; answer.</source>
          <target state="translated">由于并非所有数字都可以用&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE浮点算术&lt;/a&gt; （几乎所有计算机都用来表示十进制数字并对其进行数学运算的标准）来精确表示，因此您将无法始终获得期望的结果。 尤其如此，因为某些简单的有限十进制值（例如0.1和0.05）无法在计算机中准确表示，因此对它们的算术结果可能不会得出与&amp;ldquo;&amp;rdquo;的直接表示相同的结果。已知&amp;rdquo;的答案。</target>
        </trans-unit>
        <trans-unit id="78a5407867ec4b20b146cd40dcedc7268687c9ca" translate="yes" xml:space="preserve">
          <source>So the all.equal function is actually checking that the difference between the numbers is the square root of the smallest difference between two mantissas.</source>
          <target state="translated">所以all.equal函数实际上是在检查两个数之间的差值是否是两个数之间的最小差值的平方根。</target>
        </trans-unit>
        <trans-unit id="782df692af05d6a97e8bc9b7ec27212915fb412b" translate="yes" xml:space="preserve">
          <source>Some more detail, directly copied from an &lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;answer to a similar question&lt;/a&gt;:</source>
          <target state="translated">直接从&lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;类似问题&lt;/a&gt;的答案中复制的更多细节：</target>
        </trans-unit>
        <trans-unit id="9802b4584fbee2462fc07f889fb2472820006245" translate="yes" xml:space="preserve">
          <source>Some more examples of using &lt;code&gt;all.equal&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (the last example is supposed to show that this will correctly show differences).</source>
          <target state="translated">还有更多使用 &lt;code&gt;all.equal&lt;/code&gt; 代替 &lt;code&gt;==&lt;/code&gt; 的示例（最后一个示例应该表明这将正确显示差异）。</target>
        </trans-unit>
        <trans-unit id="5584632278ce8887d8f51c213098aaaebc556bb5" translate="yes" xml:space="preserve">
          <source>The Floating-Point Guide - What Every Programmer Should Know About Floating-Point Arithmetic</source>
          <target state="translated">浮点数指南-每个程序员都应该知道的浮点数算术知识</target>
        </trans-unit>
        <trans-unit id="0a0152c5594eda13240b4bf87e58f512efcfe2a8" translate="yes" xml:space="preserve">
          <source>The R FAQ has question devoted to it: &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</source>
          <target state="translated">R FAQ有一个专门的问题： &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ca718a45aece9e7f3c849274bc1c2ead790fe38" translate="yes" xml:space="preserve">
          <source>The above discussion assumed a comparison of two single values. In R, there are no scalars, just vectors and implicit vectorization is a strength of the language. For comparing the value of vectors element-wise, the previous principles hold, but the implementation is slightly different. &lt;code&gt;==&lt;/code&gt; is vectorized (does an element-wise comparison) while &lt;code&gt;all.equal&lt;/code&gt; compares the whole vectors as a single entity.</source>
          <target state="translated">上面的讨论假定了两个单个值的比较。 在R中，没有标量，只有向量，隐式向量化是该语言的强项。 对于逐元素比较向量的值，以前的原理适用，但是实现方式略有不同。 &lt;code&gt;==&lt;/code&gt; 被向量化（进行逐元素比较），而 &lt;code&gt;all.equal&lt;/code&gt; 将整个向量作为单个实体进行比较。</target>
        </trans-unit>
        <trans-unit id="286083fedeb68706da5ddee7fc584595eecda87b" translate="yes" xml:space="preserve">
          <source>The following code is obviously wrong.  What's the problem?</source>
          <target state="translated">下面的代码明显有问题。问题出在哪里?</target>
        </trans-unit>
        <trans-unit id="65307256c0769098ea92d6613e2547e6bd639c7c" translate="yes" xml:space="preserve">
          <source>The function has a built in tolerance parameter: &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; that can be adjusted. The default parameter is the same as the default for &lt;code&gt;all.equal()&lt;/code&gt;.</source>
          <target state="translated">该函数具有内置的公差参数： &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; ，可以调整。 默认参数与 &lt;code&gt;all.equal()&lt;/code&gt; 的默认参数相同。</target>
        </trans-unit>
        <trans-unit id="272b58680ab72335d1e4703a07ebfbb0f28c4676" translate="yes" xml:space="preserve">
          <source>The problem you have encountered is that floating point cannot represent decimal fractions  exactly in most cases, which means you will frequently find that exact matches fail.</source>
          <target state="translated">你遇到的问题是,浮点在大多数情况下不能准确地表示小数分数,这意味着你会经常发现精确匹配失败。</target>
        </trans-unit>
        <trans-unit id="070a79f751feafcce9f08da9832c4e0815567968" translate="yes" xml:space="preserve">
          <source>The standard solution to this in &lt;code&gt;R&lt;/code&gt; is not to use &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, but rather the &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt;&lt;code&gt;all.equal&lt;/code&gt;&lt;/a&gt; function. Or rather, since &lt;code&gt;all.equal&lt;/code&gt; gives lots of detail about the differences if there are any, &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 中对此的标准解决方案不是使用&lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; ，而是使用&lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt; &lt;code&gt;all.equal&lt;/code&gt; &lt;/a&gt;函数。 或者更确切地说，因为 &lt;code&gt;all.equal&lt;/code&gt; 提供了许多有关差异的详细信息（如果存在）， &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="968758f117ff62e2e51c64f8ae3295633b6964fb" translate="yes" xml:space="preserve">
          <source>This algorithm goes a bit funny near extremely small numbers called denormals, but you don't need to worry about that.</source>
          <target state="translated">这个算法在极小的数字附近,叫做二元函数,这个算法有点搞笑,但你不需要担心这个问题。</target>
        </trans-unit>
        <trans-unit id="fbe24a5ff071badc1bdfee449e6e147729102bc5" translate="yes" xml:space="preserve">
          <source>This is a safe way of comparing if two vectors of floating point numbers are (pairwise) equal. This is safer than using &lt;code&gt;==&lt;/code&gt;, because it has a built in tolerance</source>
          <target state="translated">比较两个浮点数向量（成对）是否相等是一种安全的方法。 这比使用 &lt;code&gt;==&lt;/code&gt; 更安全，因为它具有内置公差</target>
        </trans-unit>
        <trans-unit id="91e3f8389d6dff87fc6a424c5b6b4ddea1948923" translate="yes" xml:space="preserve">
          <source>This is a well known limitation of computer arithmetic and is discussed in several places:</source>
          <target state="translated">这是众所周知的计算机算术的局限性,在很多地方都有讨论。</target>
        </trans-unit>
        <trans-unit id="6dcb0fcdf79e4046df658313cba49c1768ab3a2b" translate="yes" xml:space="preserve">
          <source>This is hackish, but quick:</source>
          <target state="translated">这很黑,但很快。</target>
        </trans-unit>
        <trans-unit id="ed935a9b3c7b1cf31f413305e15558985737c468" translate="yes" xml:space="preserve">
          <source>This is the approach taken by &lt;code&gt;dplyr::near&lt;/code&gt;, which documents itself as</source>
          <target state="translated">这是 &lt;code&gt;dplyr::near&lt;/code&gt; 采取的方法，该方法将自身记录为</target>
        </trans-unit>
        <trans-unit id="b3cb562ee661de7f62ca0b20fc9e2098fe890aaa" translate="yes" xml:space="preserve">
          <source>Using the previous examples</source>
          <target state="translated">使用前面的例子</target>
        </trans-unit>
        <trans-unit id="83c1ba1426882f3dbdb8afe93eecb9ffe8f2b8b6" translate="yes" xml:space="preserve">
          <source>We can find out for any given computer what this smallest representable number is by looking in R's &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;machine&lt;/a&gt; field:</source>
          <target state="translated">通过查看R的&lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;机器&lt;/a&gt;字段，我们可以找到任何给定的计算机，这个最小的可表示数字是什么：</target>
        </trans-unit>
        <trans-unit id="7f7977854e0609a7430f9215b9e0dd9b56ddf4fa" translate="yes" xml:space="preserve">
          <source>Why are floating point numbers inaccurate?</source>
          <target state="translated">为什么浮点数字不准确?</target>
        </trans-unit>
        <trans-unit id="35070ef523d704a541ea75421f4ab2990c3a7c10" translate="yes" xml:space="preserve">
          <source>Why are these numbers not equal</source>
          <target state="translated">为什么这些数字不相等</target>
        </trans-unit>
        <trans-unit id="d158ff5b250d0962183aec94aa27b2b25dfd3b68" translate="yes" xml:space="preserve">
          <source>Why can't decimal numbers be represented exactly in binary?</source>
          <target state="translated">为什么十进制数不能完全用二进制来表示?</target>
        </trans-unit>
        <trans-unit id="c00c805fd92e2f74ab3c3034d65224c75d82b28c" translate="yes" xml:space="preserve">
          <source>You can find out what it really thinks in decimal:</source>
          <target state="translated">你可以了解一下它的真实想法,用小数来表示。</target>
        </trans-unit>
        <trans-unit id="4e1abdfe596c9332ffa901f6c46aabba4fde63ec" translate="yes" xml:space="preserve">
          <source>You can see that they differ by &lt;code&gt;2^-53&lt;/code&gt;, which is important because this number is the smallest representable difference between two numbers whose value is close to 1, as this is.</source>
          <target state="translated">您可以看到它们相差 &lt;code&gt;2^-53&lt;/code&gt; ，这很重要，因为此数字是值接近1的两个数字之间最小的可表示差异。</target>
        </trans-unit>
        <trans-unit id="ec9ee50875afbcc40532438f10cd7f14a78aa98d" translate="yes" xml:space="preserve">
          <source>You can see these numbers are different, but the representation is a bit unwieldy.  If we look at them in binary (well, hex, which is equivalent) we get a clearer picture:</source>
          <target state="translated">你可以看到这些数字是不同的,但表示方式有点不方便。如果我们用二进制(好吧,十六进制,也就是等价的)来表示,我们就会有更清晰的画面。</target>
        </trans-unit>
        <trans-unit id="979f0181b91248a84779be2c1dc7ecc648c38964" translate="yes" xml:space="preserve">
          <source>You can use this fact to create a 'nearly equals' function which checks that the difference is close to the smallest representable number in floating point.  In fact this already exists: &lt;code&gt;all.equal&lt;/code&gt;.</source>
          <target state="translated">您可以使用这个事实来创建一个&amp;ldquo;几乎等于&amp;rdquo;函数，该函数检查差值是否接近浮点数中最小的可表示数字。 实际上，这已经存在： &lt;code&gt;all.equal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5422db08900cb5c0098c2ebe8e48aab223199ed" translate="yes" xml:space="preserve">
          <source>output of equal cut intervals based on round function:</source>
          <target state="translated">基于圆周函数的等切区间输出。</target>
        </trans-unit>
        <trans-unit id="e34633607427b57df33468be95a58b1f2c765d53" translate="yes" xml:space="preserve">
          <source>output of unequal cut intervals based on options(digits = 2):</source>
          <target state="translated">基于options(digits=2)的不等式切割区间的输出。</target>
        </trans-unit>
        <trans-unit id="8fb6e7eec5312db10e2781b45c210b071f1567b8" translate="yes" xml:space="preserve">
          <source>which can be called as just</source>
          <target state="translated">可谓是</target>
        </trans-unit>
        <trans-unit id="cb8114adda95adf801cfaf3c990dedd22ec24f9a" translate="yes" xml:space="preserve">
          <source>while R lies slightly when you say:</source>
          <target state="translated">而R在说的时候略微说谎。</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
