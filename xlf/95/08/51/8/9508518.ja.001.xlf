<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/9508518">
    <body>
      <group id="9508518">
        <trans-unit id="f4fa0ad2dbf00e7377bb9024e10bd7c46a4b8c93" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.com&lt;/a&gt; compares floating point arithmetic across programming languages</source>
          <target state="translated">&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.comは、&lt;/a&gt;プログラミング言語間で浮動小数点演算を比較します</target>
        </trans-unit>
        <trans-unit id="24c9907757c274c7f252cc607997262c334e6d0a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;The R Inferno by Patrick Burns&lt;/a&gt; devotes the first &quot;Circle&quot; to this problem (starting on page 9)</source>
          <target state="translated">&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;Patrick BurnsのR Infernoは、&lt;/a&gt;この問題に最初の「Circle」を当てています（9ページから始まる）。</target>
        </trans-unit>
        <trans-unit id="930823bc4ba954f44f4ecf582ca21a88c9a5d230" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;Canonical duplicate for &quot;floating point is inaccurate&quot;&lt;/a&gt; (a meta discussion about a canonical answer for this issue)</source>
          <target state="translated">&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;「浮動小数点は不正確」の正規の複製&lt;/a&gt; （この問題の正規の回答に関するメタディスカッション）</target>
        </trans-unit>
        <trans-unit id="1baf96f8d4e4ecd837aee183191fa1077bb3b202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does not give the &quot;expected&quot; result and &lt;code&gt;all.equal&lt;/code&gt; does not perform element-wise</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; は「期待される」結果を &lt;code&gt;all.equal&lt;/code&gt; ず、 all.equalは要素ごとに実行しません</target>
        </trans-unit>
        <trans-unit id="98f6b45786d2b2aedf5ec1132df549cebc8df3fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dplyr::near()&lt;/code&gt; is an option for testing if two vectors of floating point numbers are equal. This is the example from the &lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;dplyr::near()&lt;/code&gt; は、浮動小数点数の2つのベクトルが等しいかどうかをテストするためのオプションです。 これは&lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;ドキュメント&lt;/a&gt;の例です：</target>
        </trans-unit>
        <trans-unit id="a0e2b1d9886d3fae1cc44fa5d134212926dac59f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;gt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;a&amp;gt; = bの比較：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccea69290856a10c89ac66255fbe959b1d843e33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;lt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;a &amp;lt;= bの比較：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1aeaadf527cff400e53c622865a7ced4c552aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a = b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;a = bの比較：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae3dd5ba710442f2a39cd59cf354c80a5495d632" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Per Joshua's warning here is the updated code (Thanks Joshua):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ここでのジョシュアの警告は、更新されたコードです（ありがとうジョシュア）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051f8044a78b9bb0a5e9b49aec7a714c76917ab2" translate="yes" xml:space="preserve">
          <source>@ I found this work around solution about unequal cut intervals.  @ I
  used the round function in R. By setting the option to 2 digits, did
  not solved the problem.</source>
          <target state="translated">不等間隔カットについて、この回避策を見つけました。Rでラウンド関数を使ってみましたが、オプションを2桁にしても問題は解決しませんでした。</target>
        </trans-unit>
        <trans-unit id="2aeffb9b120bf727e331fbd80cf3370e6f6add08" translate="yes" xml:space="preserve">
          <source>Adding to Brian's comment (which is the reason) you can over come this by using &lt;code&gt;all.equal&lt;/code&gt; instead:</source>
          <target state="translated">ブライアンのコメントに追加する（これが理由です）代わりに、 &lt;code&gt;all.equal&lt;/code&gt; を使用してこれに対処できます。</target>
        </trans-unit>
        <trans-unit id="c3e13ababf0fa6f39113926ca83f1024d4b04f23" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of wrapping &lt;code&gt;all.equal&lt;/code&gt; in even more function calls, you can just replicate the relevant internals of &lt;code&gt;all.equal.numeric&lt;/code&gt; and use implicit vectorization:</source>
          <target state="translated">または、 &lt;code&gt;all.equal&lt;/code&gt; をさらに多くの関数呼び出しでラップする代わりに、 all.equal.numericの関連する内部を複製し、暗黙的なベクトル化を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="e1cc3319b6d4e9c6df888fe5f49dbccf0d9c60c3" translate="yes" xml:space="preserve">
          <source>Comparing scalars</source>
          <target state="translated">スカラーの比較</target>
        </trans-unit>
        <trans-unit id="e5078ee6bca5437eb55e908d75d2142a6eb1887f" translate="yes" xml:space="preserve">
          <source>Comparing vectors</source>
          <target state="translated">ベクトルの比較</target>
        </trans-unit>
        <trans-unit id="9141c1bcc7393f0a51a930e3e61068beb111c324" translate="yes" xml:space="preserve">
          <source>David Goldberg, &quot;What Every Computer Scientist Should Know About Floating-point Arithmetic,&quot; &lt;em&gt;ACM Computing Surveys&lt;/em&gt;&lt;strong&gt;23&lt;/strong&gt;, 1 (1991-03), 5-48 &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;doi&amp;gt;10.1145/103162.103163&lt;/a&gt; (&lt;a href=&quot;http://www.validlab.com/goldberg/paper.pdf&quot;&gt;revision also available&lt;/a&gt;)</source>
          <target state="translated">David Goldberg、「すべてのコンピューター科学者が浮動小数点演算について知っておくべきこと」、 &lt;em&gt;ACM Computing Surveys&lt;/em&gt; &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;23、1&lt;/a&gt; （1991-03）、5-48 doi&amp;gt; 10.1145 / 103162.103163 （ &lt;a href=&quot;http://www.validlab.com/goldberg/paper.pdf&quot;&gt;改訂版も入手可能&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="61a132a84dfc3fde6af76f27012b8611354d6aa7" translate="yes" xml:space="preserve">
          <source>General (language agnostic) reason</source>
          <target state="translated">一般的な(言語不可知論的な)理由</target>
        </trans-unit>
        <trans-unit id="d9da8d2236553ed39bb853de9dbc03947b4af565" translate="yes" xml:space="preserve">
          <source>Generalized comparisons (&quot;&amp;lt;=&quot;, &quot;&amp;gt;=&quot;, &quot;=&quot;) in double precion arithmetic:</source>
          <target state="translated">倍精度演算での一般化比較（ &quot;&amp;lt;=&quot;、 &quot;&amp;gt; =&quot;、 &quot;=&quot;）：</target>
        </trans-unit>
        <trans-unit id="ca21d0110f4cb3b258d5ecd4dbf4725bfab29709" translate="yes" xml:space="preserve">
          <source>I had a similar problem. I used the following solution.</source>
          <target state="translated">私も同じような問題を抱えていました。私は以下の解決策を使いました。</target>
        </trans-unit>
        <trans-unit id="6821df2a778db375130c453d3832adf6ecca124e" translate="yes" xml:space="preserve">
          <source>If a functional version of this is desired, it can be written</source>
          <target state="translated">これの機能的なバージョンが必要な場合は、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="a326f79ad38f19b61a34a0eda13066d9d3971374" translate="yes" xml:space="preserve">
          <source>Is floating point math broken?</source>
          <target state="translated">浮動小数点演算は壊れている?</target>
        </trans-unit>
        <trans-unit id="4aae375ec7ffb4038e977be2e7bfd35ef0e328eb" translate="yes" xml:space="preserve">
          <source>Rather, a version which loops over the two vectors must be used</source>
          <target state="translated">むしろ、2つのベクトルの上をループするバージョンを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="1a049a837169173e32b09640587b10f6554d0375" translate="yes" xml:space="preserve">
          <source>Several Stack Overflow questions including</source>
          <target state="translated">以下のようなStack Overflowの質問がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="23417499b5d7a1a4236bdd6daa17778bf5030ace" translate="yes" xml:space="preserve">
          <source>Since not all numbers can be represented exactly in &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE floating point arithmetic&lt;/a&gt; (the standard that almost all computers use to represent decimal numbers and do math with them), you will not always get what you expected. This is especially true because some values which are simple, finite decimals (such as 0.1 and 0.05) are not represented exactly in the computer and so the results of arithmetic on them may not give a result that is identical to a direct representation of the &quot;known&quot; answer.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE浮動小数点演算&lt;/a&gt; （ほとんどすべてのコンピューターが10進数を表し、それらを使って計算するために使用する標準）ですべての数値を正確に表現できるわけではないため、必ずしも期待どおりの結果が得られるとは限りません。 これは特に当てはまります。これは、単純な有限の小数（0.1や0.05など）である一部の値がコンピューターで正確に表されないため、これらの値の演算結果が「」の直接表現と同じ結果にならない場合があるためです。既知の」答え。</target>
        </trans-unit>
        <trans-unit id="78a5407867ec4b20b146cd40dcedc7268687c9ca" translate="yes" xml:space="preserve">
          <source>So the all.equal function is actually checking that the difference between the numbers is the square root of the smallest difference between two mantissas.</source>
          <target state="translated">つまり、all.equal関数は、実際には数字の差が2つのマンティサの最小の差の平方根であることを確認しているのです。</target>
        </trans-unit>
        <trans-unit id="782df692af05d6a97e8bc9b7ec27212915fb412b" translate="yes" xml:space="preserve">
          <source>Some more detail, directly copied from an &lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;answer to a similar question&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;同様の質問へ&lt;/a&gt;の回答から直接コピーされた、もう少し詳細：</target>
        </trans-unit>
        <trans-unit id="9802b4584fbee2462fc07f889fb2472820006245" translate="yes" xml:space="preserve">
          <source>Some more examples of using &lt;code&gt;all.equal&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (the last example is supposed to show that this will correctly show differences).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; の代わりに &lt;code&gt;all.equal&lt;/code&gt; を使用するいくつかの例（最後の例は、これが違いを正しく表示することを示しています）。</target>
        </trans-unit>
        <trans-unit id="5584632278ce8887d8f51c213098aaaebc556bb5" translate="yes" xml:space="preserve">
          <source>The Floating-Point Guide - What Every Programmer Should Know About Floating-Point Arithmetic</source>
          <target state="translated">浮動小数点ガイド-浮動小数点演算についてプログラマが知っておくべきこと</target>
        </trans-unit>
        <trans-unit id="0a0152c5594eda13240b4bf87e58f512efcfe2a8" translate="yes" xml:space="preserve">
          <source>The R FAQ has question devoted to it: &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</source>
          <target state="translated">R FAQはそれに専念した質問があります： &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ca718a45aece9e7f3c849274bc1c2ead790fe38" translate="yes" xml:space="preserve">
          <source>The above discussion assumed a comparison of two single values. In R, there are no scalars, just vectors and implicit vectorization is a strength of the language. For comparing the value of vectors element-wise, the previous principles hold, but the implementation is slightly different. &lt;code&gt;==&lt;/code&gt; is vectorized (does an element-wise comparison) while &lt;code&gt;all.equal&lt;/code&gt; compares the whole vectors as a single entity.</source>
          <target state="translated">上記の説明では、2つの単一値の比較を想定しています。 Rでは、スカラーはなく、ベクトルのみであり、暗黙的なベクトル化が言語の強みです。 ベクトルの値を要素ごとに比較するために、前の原則が成り立ちますが、実装は少し異なります。 &lt;code&gt;==&lt;/code&gt; はベクトル化されます（要素ごとの比較を行います）が、 &lt;code&gt;all.equal&lt;/code&gt; はベクトル全体を単一のエンティティとして比較します。</target>
        </trans-unit>
        <trans-unit id="286083fedeb68706da5ddee7fc584595eecda87b" translate="yes" xml:space="preserve">
          <source>The following code is obviously wrong.  What's the problem?</source>
          <target state="translated">以下のコードは明らかに間違っています。何が問題なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="65307256c0769098ea92d6613e2547e6bd639c7c" translate="yes" xml:space="preserve">
          <source>The function has a built in tolerance parameter: &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; that can be adjusted. The default parameter is the same as the default for &lt;code&gt;all.equal()&lt;/code&gt;.</source>
          <target state="translated">この関数には、許容誤差パラメーターが組み込まれています。調整可能な &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; です。 デフォルトのパラメータは、 &lt;code&gt;all.equal()&lt;/code&gt; のデフォルトと同じです。</target>
        </trans-unit>
        <trans-unit id="272b58680ab72335d1e4703a07ebfbb0f28c4676" translate="yes" xml:space="preserve">
          <source>The problem you have encountered is that floating point cannot represent decimal fractions  exactly in most cases, which means you will frequently find that exact matches fail.</source>
          <target state="translated">あなたが遭遇した問題は、浮動小数点がほとんどの場合、小数点以下の分数を正確に表すことができないということです。</target>
        </trans-unit>
        <trans-unit id="070a79f751feafcce9f08da9832c4e0815567968" translate="yes" xml:space="preserve">
          <source>The standard solution to this in &lt;code&gt;R&lt;/code&gt; is not to use &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, but rather the &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt;&lt;code&gt;all.equal&lt;/code&gt;&lt;/a&gt; function. Or rather, since &lt;code&gt;all.equal&lt;/code&gt; gives lots of detail about the differences if there are any, &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; でのこれに対する標準的な解決策は、 &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;ではなく、 &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt; &lt;code&gt;all.equal&lt;/code&gt; &lt;/a&gt;関数を使用することです。 むしろ、 &lt;code&gt;all.equal&lt;/code&gt; は違いがある場合、違いについて多くの詳細を提供するため、 &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="968758f117ff62e2e51c64f8ae3295633b6964fb" translate="yes" xml:space="preserve">
          <source>This algorithm goes a bit funny near extremely small numbers called denormals, but you don't need to worry about that.</source>
          <target state="translated">このアルゴリズムは、デノマルと呼ばれる極端に小さな数値の近くでは少しおかしくなりますが、その点は気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="fbe24a5ff071badc1bdfee449e6e147729102bc5" translate="yes" xml:space="preserve">
          <source>This is a safe way of comparing if two vectors of floating point numbers are (pairwise) equal. This is safer than using &lt;code&gt;==&lt;/code&gt;, because it has a built in tolerance</source>
          <target state="translated">これは、浮動小数点数の2つのベクトルが（ペアワイズで）等しいかどうかを比較する安全な方法です。 許容値が組み込まれているため、 &lt;code&gt;==&lt;/code&gt; を使用するよりも安全です。</target>
        </trans-unit>
        <trans-unit id="91e3f8389d6dff87fc6a424c5b6b4ddea1948923" translate="yes" xml:space="preserve">
          <source>This is a well known limitation of computer arithmetic and is discussed in several places:</source>
          <target state="translated">これはよく知られたコンピュータ算術の制限であり、いくつかの場所で議論されています。</target>
        </trans-unit>
        <trans-unit id="6dcb0fcdf79e4046df658313cba49c1768ab3a2b" translate="yes" xml:space="preserve">
          <source>This is hackish, but quick:</source>
          <target state="translated">これはハックっぽいけど、早いですね。</target>
        </trans-unit>
        <trans-unit id="ed935a9b3c7b1cf31f413305e15558985737c468" translate="yes" xml:space="preserve">
          <source>This is the approach taken by &lt;code&gt;dplyr::near&lt;/code&gt;, which documents itself as</source>
          <target state="translated">これは、 &lt;code&gt;dplyr::near&lt;/code&gt; が採用するアプローチであり 、自身を次のように文書化します。</target>
        </trans-unit>
        <trans-unit id="b3cb562ee661de7f62ca0b20fc9e2098fe890aaa" translate="yes" xml:space="preserve">
          <source>Using the previous examples</source>
          <target state="translated">これまでの例を使って</target>
        </trans-unit>
        <trans-unit id="83c1ba1426882f3dbdb8afe93eecb9ffe8f2b8b6" translate="yes" xml:space="preserve">
          <source>We can find out for any given computer what this smallest representable number is by looking in R's &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;machine&lt;/a&gt; field:</source>
          <target state="translated">Rの&lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;マシン&lt;/a&gt;フィールドを調べることにより、この最小の表現可能な数がどのコンピューターであるかを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="7f7977854e0609a7430f9215b9e0dd9b56ddf4fa" translate="yes" xml:space="preserve">
          <source>Why are floating point numbers inaccurate?</source>
          <target state="translated">なぜ浮動小数点数は不正確なのか?</target>
        </trans-unit>
        <trans-unit id="35070ef523d704a541ea75421f4ab2990c3a7c10" translate="yes" xml:space="preserve">
          <source>Why are these numbers not equal</source>
          <target state="translated">なぜこれらの数字が等しくないのか</target>
        </trans-unit>
        <trans-unit id="d158ff5b250d0962183aec94aa27b2b25dfd3b68" translate="yes" xml:space="preserve">
          <source>Why can't decimal numbers be represented exactly in binary?</source>
          <target state="translated">なぜ10進数は2進数で正確に表現できないのか?</target>
        </trans-unit>
        <trans-unit id="c00c805fd92e2f74ab3c3034d65224c75d82b28c" translate="yes" xml:space="preserve">
          <source>You can find out what it really thinks in decimal:</source>
          <target state="translated">10進数で本音がわかる。</target>
        </trans-unit>
        <trans-unit id="4e1abdfe596c9332ffa901f6c46aabba4fde63ec" translate="yes" xml:space="preserve">
          <source>You can see that they differ by &lt;code&gt;2^-53&lt;/code&gt;, which is important because this number is the smallest representable difference between two numbers whose value is close to 1, as this is.</source>
          <target state="translated">&lt;code&gt;2^-53&lt;/code&gt; が異なることがわかります。これは、値が1に近い2つの数値間の最小の表現可能な違いであるため、これは重要です。</target>
        </trans-unit>
        <trans-unit id="ec9ee50875afbcc40532438f10cd7f14a78aa98d" translate="yes" xml:space="preserve">
          <source>You can see these numbers are different, but the representation is a bit unwieldy.  If we look at them in binary (well, hex, which is equivalent) we get a clearer picture:</source>
          <target state="translated">これらの数値が異なることがわかりますが、表現が少し扱いにくいです。2進数(まあ、16進数がそれに相当します)で見ると、より明確なイメージを得ることができます。</target>
        </trans-unit>
        <trans-unit id="979f0181b91248a84779be2c1dc7ecc648c38964" translate="yes" xml:space="preserve">
          <source>You can use this fact to create a 'nearly equals' function which checks that the difference is close to the smallest representable number in floating point.  In fact this already exists: &lt;code&gt;all.equal&lt;/code&gt;.</source>
          <target state="translated">この事実を使用して、差が浮動小数点で表現可能な最小数に近いことを確認する「ほぼ等しい」関数を作成できます。 実際、これはすでに存在しています： &lt;code&gt;all.equal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5422db08900cb5c0098c2ebe8e48aab223199ed" translate="yes" xml:space="preserve">
          <source>output of equal cut intervals based on round function:</source>
          <target state="translated">ラウンド関数に基づく等間隔カットの出力</target>
        </trans-unit>
        <trans-unit id="e34633607427b57df33468be95a58b1f2c765d53" translate="yes" xml:space="preserve">
          <source>output of unequal cut intervals based on options(digits = 2):</source>
          <target state="translated">オプション(桁数=2)に基づく不等切符間隔の出力。</target>
        </trans-unit>
        <trans-unit id="8fb6e7eec5312db10e2781b45c210b071f1567b8" translate="yes" xml:space="preserve">
          <source>which can be called as just</source>
          <target state="translated">とも言える</target>
        </trans-unit>
        <trans-unit id="cb8114adda95adf801cfaf3c990dedd22ec24f9a" translate="yes" xml:space="preserve">
          <source>while R lies slightly when you say:</source>
          <target state="translated">と言われてもRはわずかに嘘をつく。</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
