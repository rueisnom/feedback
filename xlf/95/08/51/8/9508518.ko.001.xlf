<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/9508518">
    <body>
      <group id="9508518">
        <trans-unit id="f4fa0ad2dbf00e7377bb9024e10bd7c46a4b8c93" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.com&lt;/a&gt; compares floating point arithmetic across programming languages</source>
          <target state="translated">&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.com&lt;/a&gt; 은 프로그래밍 언어에서 부동 소수점 산술 비교</target>
        </trans-unit>
        <trans-unit id="24c9907757c274c7f252cc607997262c334e6d0a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;The R Inferno by Patrick Burns&lt;/a&gt; devotes the first &quot;Circle&quot; to this problem (starting on page 9)</source>
          <target state="translated">&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;Patrick Burns의 R Inferno는&lt;/a&gt; 이 문제에 첫 번째 &quot;원&quot;을 바칩니다 (9 페이지부터 시작)</target>
        </trans-unit>
        <trans-unit id="930823bc4ba954f44f4ecf582ca21a88c9a5d230" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;Canonical duplicate for &quot;floating point is inaccurate&quot;&lt;/a&gt; (a meta discussion about a canonical answer for this issue)</source>
          <target state="translated">&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;&quot;부동 소수점이 정확하지&lt;/a&gt; 않음 &quot;에 대한 정식 복제본 (이 문제에 대한 정식 답변에 대한 메타 토론)</target>
        </trans-unit>
        <trans-unit id="1baf96f8d4e4ecd837aee183191fa1077bb3b202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does not give the &quot;expected&quot; result and &lt;code&gt;all.equal&lt;/code&gt; does not perform element-wise</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 는 &quot;예상 된&quot;결과를 제공하지 않으며 &lt;code&gt;all.equal&lt;/code&gt; 은 요소별로 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98f6b45786d2b2aedf5ec1132df549cebc8df3fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dplyr::near()&lt;/code&gt; is an option for testing if two vectors of floating point numbers are equal. This is the example from the &lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;dplyr::near()&lt;/code&gt; 는 부동 소수점 숫자의 두 벡터가 같은지 테스트하는 옵션입니다. 이것은 &lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;문서&lt;/a&gt; 의 예입니다.</target>
        </trans-unit>
        <trans-unit id="a0e2b1d9886d3fae1cc44fa5d134212926dac59f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;gt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;a&amp;gt; = b 비교 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccea69290856a10c89ac66255fbe959b1d843e33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;lt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;a &amp;lt;= b 비교 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1aeaadf527cff400e53c622865a7ced4c552aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a = b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;a = b 비교 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae3dd5ba710442f2a39cd59cf354c80a5495d632" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Per Joshua's warning here is the updated code (Thanks Joshua):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;여기에 Joshua의 경고는 업데이트 된 코드입니다 (Joshua에게 감사합니다).&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051f8044a78b9bb0a5e9b49aec7a714c76917ab2" translate="yes" xml:space="preserve">
          <source>@ I found this work around solution about unequal cut intervals.  @ I
  used the round function in R. By setting the option to 2 digits, did
  not solved the problem.</source>
          <target state="translated">@ 불균일 한 컷 간격에 대한 해결책을 찾았습니다. @ R에서 반올림 기능을 사용했습니다. 옵션을 2 자리로 설정해도 문제가 해결되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2aeffb9b120bf727e331fbd80cf3370e6f6add08" translate="yes" xml:space="preserve">
          <source>Adding to Brian's comment (which is the reason) you can over come this by using &lt;code&gt;all.equal&lt;/code&gt; instead:</source>
          <target state="translated">Brian의 의견에 추가하면 (이유가 있습니다) 대신 &lt;code&gt;all.equal&lt;/code&gt; 을 사용하여이 문제를 극복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e13ababf0fa6f39113926ca83f1024d4b04f23" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of wrapping &lt;code&gt;all.equal&lt;/code&gt; in even more function calls, you can just replicate the relevant internals of &lt;code&gt;all.equal.numeric&lt;/code&gt; and use implicit vectorization:</source>
          <target state="translated">또는 더 많은 함수 호출에서 &lt;code&gt;all.equal&lt;/code&gt; 을 줄 바꿈하는 대신 all.equal.numeric 의 관련 내부를 복제하고 암시 적 벡터화를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1cc3319b6d4e9c6df888fe5f49dbccf0d9c60c3" translate="yes" xml:space="preserve">
          <source>Comparing scalars</source>
          <target state="translated">스칼라 비교</target>
        </trans-unit>
        <trans-unit id="e5078ee6bca5437eb55e908d75d2142a6eb1887f" translate="yes" xml:space="preserve">
          <source>Comparing vectors</source>
          <target state="translated">벡터 비교</target>
        </trans-unit>
        <trans-unit id="9141c1bcc7393f0a51a930e3e61068beb111c324" translate="yes" xml:space="preserve">
          <source>David Goldberg, &quot;What Every Computer Scientist Should Know About Floating-point Arithmetic,&quot; &lt;em&gt;ACM Computing Surveys&lt;/em&gt;&lt;strong&gt;23&lt;/strong&gt;, 1 (1991-03), 5-48 &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;doi&amp;gt;10.1145/103162.103163&lt;/a&gt; (&lt;a href=&quot;http://www.validlab.com/goldberg/paper.pdf&quot;&gt;revision also available&lt;/a&gt;)</source>
          <target state="translated">David Goldberg, &quot;모든 컴퓨터 과학자가 부동 소수점 산술에 대해 알아야 할 사항&quot; &lt;em&gt;ACM 컴퓨팅 설문 조사&lt;/em&gt; &lt;strong&gt;23&lt;/strong&gt; , 1 (1991-03), 5-48 &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;doi&amp;gt; 10.1145 / 103162.103163&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61a132a84dfc3fde6af76f27012b8611354d6aa7" translate="yes" xml:space="preserve">
          <source>General (language agnostic) reason</source>
          <target state="translated">일반적인 (언어에 구애받지 않는) 이유</target>
        </trans-unit>
        <trans-unit id="d9da8d2236553ed39bb853de9dbc03947b4af565" translate="yes" xml:space="preserve">
          <source>Generalized comparisons (&quot;&amp;lt;=&quot;, &quot;&amp;gt;=&quot;, &quot;=&quot;) in double precion arithmetic:</source>
          <target state="translated">이중 전치 산술의 일반화 된 비교 ( &quot;&amp;lt;=&quot;, &quot;&amp;gt; =&quot;, &quot;=&quot;) :</target>
        </trans-unit>
        <trans-unit id="ca21d0110f4cb3b258d5ecd4dbf4725bfab29709" translate="yes" xml:space="preserve">
          <source>I had a similar problem. I used the following solution.</source>
          <target state="translated">나는 비슷한 문제가 있었다. 나는 다음 해결책을 사용했다.</target>
        </trans-unit>
        <trans-unit id="6821df2a778db375130c453d3832adf6ecca124e" translate="yes" xml:space="preserve">
          <source>If a functional version of this is desired, it can be written</source>
          <target state="translated">이 기능 버전이 필요한 경우 작성할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a326f79ad38f19b61a34a0eda13066d9d3971374" translate="yes" xml:space="preserve">
          <source>Is floating point math broken?</source>
          <target state="translated">부동 소수점 수학이 깨졌습니까?</target>
        </trans-unit>
        <trans-unit id="4aae375ec7ffb4038e977be2e7bfd35ef0e328eb" translate="yes" xml:space="preserve">
          <source>Rather, a version which loops over the two vectors must be used</source>
          <target state="translated">오히려 두 벡터를 반복하는 버전을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="1a049a837169173e32b09640587b10f6554d0375" translate="yes" xml:space="preserve">
          <source>Several Stack Overflow questions including</source>
          <target state="translated">다음을 포함한 몇 가지 스택 오버플로 질문</target>
        </trans-unit>
        <trans-unit id="23417499b5d7a1a4236bdd6daa17778bf5030ace" translate="yes" xml:space="preserve">
          <source>Since not all numbers can be represented exactly in &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE floating point arithmetic&lt;/a&gt; (the standard that almost all computers use to represent decimal numbers and do math with them), you will not always get what you expected. This is especially true because some values which are simple, finite decimals (such as 0.1 and 0.05) are not represented exactly in the computer and so the results of arithmetic on them may not give a result that is identical to a direct representation of the &quot;known&quot; answer.</source>
          <target state="translated">모든 숫자를 &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE 부동 소수점 산술&lt;/a&gt; (거의 모든 컴퓨터가 10 진수를 나타내고 수학으로 사용하는 표준)으로 정확하게 표현할 수있는 것은 아니므로 항상 예상 한 값을 얻지는 못할 수 있습니다. 이것은 단순하고 유한 한 소수 (예 : 0.1 및 0.05) 인 일부 값이 컴퓨터에 정확하게 표시되지 않으므로 이에 대한 산술 결과가 &quot; 알려진 &quot;답변입니다.</target>
        </trans-unit>
        <trans-unit id="78a5407867ec4b20b146cd40dcedc7268687c9ca" translate="yes" xml:space="preserve">
          <source>So the all.equal function is actually checking that the difference between the numbers is the square root of the smallest difference between two mantissas.</source>
          <target state="translated">따라서 all.equal 함수는 실제로 숫자 사이의 차이가 두 가수 사이의 가장 작은 차이의 제곱근인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="782df692af05d6a97e8bc9b7ec27212915fb412b" translate="yes" xml:space="preserve">
          <source>Some more detail, directly copied from an &lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;answer to a similar question&lt;/a&gt;:</source>
          <target state="translated">더 자세한 내용 &lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;은 비슷한 질문에&lt;/a&gt; 대한 답변 에서 직접 복사되었습니다.</target>
        </trans-unit>
        <trans-unit id="9802b4584fbee2462fc07f889fb2472820006245" translate="yes" xml:space="preserve">
          <source>Some more examples of using &lt;code&gt;all.equal&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (the last example is supposed to show that this will correctly show differences).</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 대신 &lt;code&gt;all.equal&lt;/code&gt; 을 사용하는 몇 가지 예가 더 있습니다 (마지막 예는 이것이 올바르게 차이점을 보여줄 것입니다).</target>
        </trans-unit>
        <trans-unit id="5584632278ce8887d8f51c213098aaaebc556bb5" translate="yes" xml:space="preserve">
          <source>The Floating-Point Guide - What Every Programmer Should Know About Floating-Point Arithmetic</source>
          <target state="translated">부동 소수점 안내서-모든 프로그래머가 부동 소수점 산술에 대해 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="0a0152c5594eda13240b4bf87e58f512efcfe2a8" translate="yes" xml:space="preserve">
          <source>The R FAQ has question devoted to it: &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</source>
          <target state="translated">R FAQ에 관한 질문이 있습니다 : &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ca718a45aece9e7f3c849274bc1c2ead790fe38" translate="yes" xml:space="preserve">
          <source>The above discussion assumed a comparison of two single values. In R, there are no scalars, just vectors and implicit vectorization is a strength of the language. For comparing the value of vectors element-wise, the previous principles hold, but the implementation is slightly different. &lt;code&gt;==&lt;/code&gt; is vectorized (does an element-wise comparison) while &lt;code&gt;all.equal&lt;/code&gt; compares the whole vectors as a single entity.</source>
          <target state="translated">위의 논의는 두 개의 단일 값의 비교를 가정했습니다. R에는 스칼라가 없으며 벡터 만 있으며 암시 적 벡터화는 언어의 강점입니다. 벡터의 값을 요소별로 비교하기 위해 이전 원칙이 적용되지만 구현 방식이 약간 다릅니다. &lt;code&gt;==&lt;/code&gt; 는 벡터화되고 (요소 별 비교) &lt;code&gt;all.equal&lt;/code&gt; 은 전체 벡터를 단일 엔티티로 비교합니다.</target>
        </trans-unit>
        <trans-unit id="286083fedeb68706da5ddee7fc584595eecda87b" translate="yes" xml:space="preserve">
          <source>The following code is obviously wrong.  What's the problem?</source>
          <target state="translated">다음 코드는 분명히 잘못되었습니다. 뭐가 문제 야?</target>
        </trans-unit>
        <trans-unit id="65307256c0769098ea92d6613e2547e6bd639c7c" translate="yes" xml:space="preserve">
          <source>The function has a built in tolerance parameter: &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; that can be adjusted. The default parameter is the same as the default for &lt;code&gt;all.equal()&lt;/code&gt;.</source>
          <target state="translated">이 기능에는 공차 매개 변수가 내장되어 있습니다. &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; . 조정할 수 있습니다. 기본 매개 변수는 &lt;code&gt;all.equal()&lt;/code&gt; 의 기본값과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="272b58680ab72335d1e4703a07ebfbb0f28c4676" translate="yes" xml:space="preserve">
          <source>The problem you have encountered is that floating point cannot represent decimal fractions  exactly in most cases, which means you will frequently find that exact matches fail.</source>
          <target state="translated">발생하는 문제는 대부분의 경우 부동 소수점이 소수를 정확하게 표현할 수 없다는 것입니다. 즉, 정확한 일치가 실패하는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="070a79f751feafcce9f08da9832c4e0815567968" translate="yes" xml:space="preserve">
          <source>The standard solution to this in &lt;code&gt;R&lt;/code&gt; is not to use &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, but rather the &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt;&lt;code&gt;all.equal&lt;/code&gt;&lt;/a&gt; function. Or rather, since &lt;code&gt;all.equal&lt;/code&gt; gives lots of detail about the differences if there are any, &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 에서 이것에 대한 표준 솔루션은 &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 아니라 &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt; &lt;code&gt;all.equal&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것입니다. 또는 &lt;code&gt;all.equal&lt;/code&gt; 은 차이가있는 경우 &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt; 대한 자세한 정보를 제공하므로</target>
        </trans-unit>
        <trans-unit id="968758f117ff62e2e51c64f8ae3295633b6964fb" translate="yes" xml:space="preserve">
          <source>This algorithm goes a bit funny near extremely small numbers called denormals, but you don't need to worry about that.</source>
          <target state="translated">이 알고리즘은 denormals라고하는 극소수 근처에서는 약간 재미 있지만 걱정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fbe24a5ff071badc1bdfee449e6e147729102bc5" translate="yes" xml:space="preserve">
          <source>This is a safe way of comparing if two vectors of floating point numbers are (pairwise) equal. This is safer than using &lt;code&gt;==&lt;/code&gt;, because it has a built in tolerance</source>
          <target state="translated">부동 소수점 숫자의 두 벡터가 (쌍별) 동일한 지 비교하는 안전한 방법입니다. 공차가 내장되어 있기 때문에 &lt;code&gt;==&lt;/code&gt; 를 사용하는 것보다 안전합니다.</target>
        </trans-unit>
        <trans-unit id="91e3f8389d6dff87fc6a424c5b6b4ddea1948923" translate="yes" xml:space="preserve">
          <source>This is a well known limitation of computer arithmetic and is discussed in several places:</source>
          <target state="translated">이것은 컴퓨터 산술의 잘 알려진 제한 사항이며 여러 곳에서 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="6dcb0fcdf79e4046df658313cba49c1768ab3a2b" translate="yes" xml:space="preserve">
          <source>This is hackish, but quick:</source>
          <target state="translated">이것은 hackish이지만 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ed935a9b3c7b1cf31f413305e15558985737c468" translate="yes" xml:space="preserve">
          <source>This is the approach taken by &lt;code&gt;dplyr::near&lt;/code&gt;, which documents itself as</source>
          <target state="translated">이것은 &lt;code&gt;dplyr::near&lt;/code&gt; 취한 접근 방식으로, 자체를 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="b3cb562ee661de7f62ca0b20fc9e2098fe890aaa" translate="yes" xml:space="preserve">
          <source>Using the previous examples</source>
          <target state="translated">이전 예제 사용</target>
        </trans-unit>
        <trans-unit id="83c1ba1426882f3dbdb8afe93eecb9ffe8f2b8b6" translate="yes" xml:space="preserve">
          <source>We can find out for any given computer what this smallest representable number is by looking in R's &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;machine&lt;/a&gt; field:</source>
          <target state="translated">우리는 주어진 컴퓨터에서 R의 &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;machine&lt;/a&gt; field에서이 가장 작은 숫자가 무엇인지 알아낼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7f7977854e0609a7430f9215b9e0dd9b56ddf4fa" translate="yes" xml:space="preserve">
          <source>Why are floating point numbers inaccurate?</source>
          <target state="translated">부동 소수점 숫자가 왜 정확하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="35070ef523d704a541ea75421f4ab2990c3a7c10" translate="yes" xml:space="preserve">
          <source>Why are these numbers not equal</source>
          <target state="translated">이 숫자가 왜 다른가요?</target>
        </trans-unit>
        <trans-unit id="d158ff5b250d0962183aec94aa27b2b25dfd3b68" translate="yes" xml:space="preserve">
          <source>Why can't decimal numbers be represented exactly in binary?</source>
          <target state="translated">왜 십진수를 이진수로 정확하게 표현할 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="c00c805fd92e2f74ab3c3034d65224c75d82b28c" translate="yes" xml:space="preserve">
          <source>You can find out what it really thinks in decimal:</source>
          <target state="translated">실제로 어떻게 생각하는지 십진수로 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1abdfe596c9332ffa901f6c46aabba4fde63ec" translate="yes" xml:space="preserve">
          <source>You can see that they differ by &lt;code&gt;2^-53&lt;/code&gt;, which is important because this number is the smallest representable difference between two numbers whose value is close to 1, as this is.</source>
          <target state="translated">&lt;code&gt;2^-53&lt;/code&gt; 차이가 있음을 알 수 있습니다.이 숫자는 값이 1에 가까운 두 숫자 사이의 가장 작은 차이이기 때문에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ec9ee50875afbcc40532438f10cd7f14a78aa98d" translate="yes" xml:space="preserve">
          <source>You can see these numbers are different, but the representation is a bit unwieldy.  If we look at them in binary (well, hex, which is equivalent) we get a clearer picture:</source>
          <target state="translated">이 숫자가 다르다는 것을 알 수 있지만 표현은 다루기 힘듭니다. 우리가 그것들을 이진으로 보면 (음, 16 진, 이에 상응하는) 더 명확한 그림을 얻게됩니다 :</target>
        </trans-unit>
        <trans-unit id="979f0181b91248a84779be2c1dc7ecc648c38964" translate="yes" xml:space="preserve">
          <source>You can use this fact to create a 'nearly equals' function which checks that the difference is close to the smallest representable number in floating point.  In fact this already exists: &lt;code&gt;all.equal&lt;/code&gt;.</source>
          <target state="translated">이 사실을 사용하여 차이가 부동 소수점에서 가장 작은 표현 가능한 숫자에 가까운 지 확인하는 '거의 같음'함수를 만들 수 있습니다. 실제로 이것은 이미 존재합니다 : &lt;code&gt;all.equal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5422db08900cb5c0098c2ebe8e48aab223199ed" translate="yes" xml:space="preserve">
          <source>output of equal cut intervals based on round function:</source>
          <target state="translated">라운드 기능을 기준으로 동일한 컷 간격의 출력 :</target>
        </trans-unit>
        <trans-unit id="e34633607427b57df33468be95a58b1f2c765d53" translate="yes" xml:space="preserve">
          <source>output of unequal cut intervals based on options(digits = 2):</source>
          <target state="translated">옵션 (숫자 = 2)에 따른 불균등 한 절단 간격 출력 :</target>
        </trans-unit>
        <trans-unit id="8fb6e7eec5312db10e2781b45c210b071f1567b8" translate="yes" xml:space="preserve">
          <source>which can be called as just</source>
          <target state="translated">그냥 호출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cb8114adda95adf801cfaf3c990dedd22ec24f9a" translate="yes" xml:space="preserve">
          <source>while R lies slightly when you say:</source>
          <target state="translated">당신이 말할 때 R은 약간 있습니다 :</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
