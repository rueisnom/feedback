<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/9508518">
    <body>
      <group id="9508518">
        <trans-unit id="f4fa0ad2dbf00e7377bb9024e10bd7c46a4b8c93" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.com&lt;/a&gt; compares floating point arithmetic across programming languages</source>
          <target state="translated">&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.com&lt;/a&gt; сравнивает арифметику с плавающей запятой для разных языков программирования</target>
        </trans-unit>
        <trans-unit id="24c9907757c274c7f252cc607997262c334e6d0a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;The R Inferno by Patrick Burns&lt;/a&gt; devotes the first &quot;Circle&quot; to this problem (starting on page 9)</source>
          <target state="translated">&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;The R Inferno Патрика Бернса&lt;/a&gt; посвящает первый &amp;laquo;Круг&amp;raquo; этой проблеме (начиная со страницы 9)</target>
        </trans-unit>
        <trans-unit id="930823bc4ba954f44f4ecf582ca21a88c9a5d230" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;Canonical duplicate for &quot;floating point is inaccurate&quot;&lt;/a&gt; (a meta discussion about a canonical answer for this issue)</source>
          <target state="translated">&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;Канонический дубликат для &amp;laquo;с плавающей точкой неточен&amp;raquo;&lt;/a&gt; (мета-обсуждение канонического ответа на этот вопрос)</target>
        </trans-unit>
        <trans-unit id="1baf96f8d4e4ecd837aee183191fa1077bb3b202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does not give the &quot;expected&quot; result and &lt;code&gt;all.equal&lt;/code&gt; does not perform element-wise</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; не дает &quot;ожидаемого&quot; результата и &lt;code&gt;all.equal&lt;/code&gt; не выполняется поэлементно</target>
        </trans-unit>
        <trans-unit id="98f6b45786d2b2aedf5ec1132df549cebc8df3fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dplyr::near()&lt;/code&gt; is an option for testing if two vectors of floating point numbers are equal. This is the example from the &lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;dplyr::near()&lt;/code&gt; - это опция для тестирования, если два вектора чисел с плавающей точкой равны. Это пример из &lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;документов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a0e2b1d9886d3fae1cc44fa5d134212926dac59f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;gt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сравнивая a&amp;gt; = b:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccea69290856a10c89ac66255fbe959b1d843e33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;lt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сравнивая &amp;lt;= b:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1aeaadf527cff400e53c622865a7ced4c552aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a = b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сравнивая а = б:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae3dd5ba710442f2a39cd59cf354c80a5495d632" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Per Joshua's warning here is the updated code (Thanks Joshua):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;За предупреждением Джошуа вот обновленный код (спасибо Джошуа):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051f8044a78b9bb0a5e9b49aec7a714c76917ab2" translate="yes" xml:space="preserve">
          <source>@ I found this work around solution about unequal cut intervals.  @ I
  used the round function in R. By setting the option to 2 digits, did
  not solved the problem.</source>
          <target state="translated">@ Я нашел эту работу вокруг решения проблемы неравных интервалов резания.@ Я использовал круглую функцию в R.Установив опцию на 2 цифры,не решил проблему.</target>
        </trans-unit>
        <trans-unit id="2aeffb9b120bf727e331fbd80cf3370e6f6add08" translate="yes" xml:space="preserve">
          <source>Adding to Brian's comment (which is the reason) you can over come this by using &lt;code&gt;all.equal&lt;/code&gt; instead:</source>
          <target state="translated">Добавив комментарий Брайана (что является причиной), вы можете сделать это, используя вместо этого &lt;code&gt;all.equal&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c3e13ababf0fa6f39113926ca83f1024d4b04f23" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of wrapping &lt;code&gt;all.equal&lt;/code&gt; in even more function calls, you can just replicate the relevant internals of &lt;code&gt;all.equal.numeric&lt;/code&gt; and use implicit vectorization:</source>
          <target state="translated">В качестве альтернативы, вместо того, чтобы &lt;code&gt;all.equal&lt;/code&gt; в еще большее количество вызовов функций, вы можете просто скопировать соответствующие внутренние &lt;code&gt;all.equal.numeric&lt;/code&gt; и использовать неявную векторизацию:</target>
        </trans-unit>
        <trans-unit id="e1cc3319b6d4e9c6df888fe5f49dbccf0d9c60c3" translate="yes" xml:space="preserve">
          <source>Comparing scalars</source>
          <target state="translated">Сравнительные скаляры</target>
        </trans-unit>
        <trans-unit id="e5078ee6bca5437eb55e908d75d2142a6eb1887f" translate="yes" xml:space="preserve">
          <source>Comparing vectors</source>
          <target state="translated">Сравнение векторов</target>
        </trans-unit>
        <trans-unit id="9141c1bcc7393f0a51a930e3e61068beb111c324" translate="yes" xml:space="preserve">
          <source>David Goldberg, &quot;What Every Computer Scientist Should Know About Floating-point Arithmetic,&quot; &lt;em&gt;ACM Computing Surveys&lt;/em&gt;&lt;strong&gt;23&lt;/strong&gt;, 1 (1991-03), 5-48 &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;doi&amp;gt;10.1145/103162.103163&lt;/a&gt; (&lt;a href=&quot;http://www.validlab.com/goldberg/paper.pdf&quot;&gt;revision also available&lt;/a&gt;)</source>
          <target state="translated">Дэвид Голдберг, &amp;laquo;Что должен знать каждый компьютерщик об арифметике с плавающей точкой&amp;raquo;, &lt;em&gt;ACM Computing Surveys&lt;/em&gt; &lt;strong&gt;23&lt;/strong&gt; , 1 (1991-03), 5-48 &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;doi&amp;gt; 10.1145 / 103162.103163&lt;/a&gt; ( &lt;a href=&quot;http://www.validlab.com/goldberg/paper.pdf&quot;&gt;также доступна редакция&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="61a132a84dfc3fde6af76f27012b8611354d6aa7" translate="yes" xml:space="preserve">
          <source>General (language agnostic) reason</source>
          <target state="translated">Общая (языковая агностическая)причина</target>
        </trans-unit>
        <trans-unit id="d9da8d2236553ed39bb853de9dbc03947b4af565" translate="yes" xml:space="preserve">
          <source>Generalized comparisons (&quot;&amp;lt;=&quot;, &quot;&amp;gt;=&quot;, &quot;=&quot;) in double precion arithmetic:</source>
          <target state="translated">Обобщенные сравнения (&quot;&amp;lt;=&quot;, &quot;&amp;gt; =&quot;, &quot;=&quot;) в двойной арифметике</target>
        </trans-unit>
        <trans-unit id="ca21d0110f4cb3b258d5ecd4dbf4725bfab29709" translate="yes" xml:space="preserve">
          <source>I had a similar problem. I used the following solution.</source>
          <target state="translated">У меня была похожая проблема.Я использовал следующее решение.</target>
        </trans-unit>
        <trans-unit id="6821df2a778db375130c453d3832adf6ecca124e" translate="yes" xml:space="preserve">
          <source>If a functional version of this is desired, it can be written</source>
          <target state="translated">Если желательна функциональная версия,то она может быть написана</target>
        </trans-unit>
        <trans-unit id="a326f79ad38f19b61a34a0eda13066d9d3971374" translate="yes" xml:space="preserve">
          <source>Is floating point math broken?</source>
          <target state="translated">Математика с плавающей точкой сломана?</target>
        </trans-unit>
        <trans-unit id="4aae375ec7ffb4038e977be2e7bfd35ef0e328eb" translate="yes" xml:space="preserve">
          <source>Rather, a version which loops over the two vectors must be used</source>
          <target state="translated">Вместо этого необходимо использовать версию,в которой циклы поверх двух векторов должны использоваться</target>
        </trans-unit>
        <trans-unit id="1a049a837169173e32b09640587b10f6554d0375" translate="yes" xml:space="preserve">
          <source>Several Stack Overflow questions including</source>
          <target state="translated">Несколько вопросов о переполнении стека,включая</target>
        </trans-unit>
        <trans-unit id="23417499b5d7a1a4236bdd6daa17778bf5030ace" translate="yes" xml:space="preserve">
          <source>Since not all numbers can be represented exactly in &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE floating point arithmetic&lt;/a&gt; (the standard that almost all computers use to represent decimal numbers and do math with them), you will not always get what you expected. This is especially true because some values which are simple, finite decimals (such as 0.1 and 0.05) are not represented exactly in the computer and so the results of arithmetic on them may not give a result that is identical to a direct representation of the &quot;known&quot; answer.</source>
          <target state="translated">Поскольку не все числа могут быть представлены точно в &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;арифметике IEEE с плавающей запятой&lt;/a&gt; (стандарт, который почти все компьютеры используют для представления десятичных чисел и выполнения с ними математических операций ), вы не всегда получите то, что ожидали. Это особенно верно, потому что некоторые значения, которые являются простыми конечными десятичными знаками (такими как 0,1 и 0,05), не представлены точно в компьютере, и поэтому результаты арифметики на них могут не дать результат, который идентичен прямому представлению &quot; известный &quot;ответ.</target>
        </trans-unit>
        <trans-unit id="78a5407867ec4b20b146cd40dcedc7268687c9ca" translate="yes" xml:space="preserve">
          <source>So the all.equal function is actually checking that the difference between the numbers is the square root of the smallest difference between two mantissas.</source>
          <target state="translated">Таким образом,функция all.equal на самом деле проверяет,что разница между числами является квадратным корнем наименьшего различия между двумя мантиссами.</target>
        </trans-unit>
        <trans-unit id="782df692af05d6a97e8bc9b7ec27212915fb412b" translate="yes" xml:space="preserve">
          <source>Some more detail, directly copied from an &lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;answer to a similar question&lt;/a&gt;:</source>
          <target state="translated">Немного подробнее, прямо скопировано из &lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;ответа на аналогичный вопрос&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9802b4584fbee2462fc07f889fb2472820006245" translate="yes" xml:space="preserve">
          <source>Some more examples of using &lt;code&gt;all.equal&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (the last example is supposed to show that this will correctly show differences).</source>
          <target state="translated">Еще несколько примеров использования &lt;code&gt;all.equal&lt;/code&gt; вместо &lt;code&gt;==&lt;/code&gt; (последний пример должен показать, что это правильно покажет различия).</target>
        </trans-unit>
        <trans-unit id="5584632278ce8887d8f51c213098aaaebc556bb5" translate="yes" xml:space="preserve">
          <source>The Floating-Point Guide - What Every Programmer Should Know About Floating-Point Arithmetic</source>
          <target state="translated">Руководство по арифметике с плавающей точкой-что каждый программист должен знать об арифметике с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="0a0152c5594eda13240b4bf87e58f512efcfe2a8" translate="yes" xml:space="preserve">
          <source>The R FAQ has question devoted to it: &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</source>
          <target state="translated">R FAQ имеет вопрос, посвященный этому: &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ca718a45aece9e7f3c849274bc1c2ead790fe38" translate="yes" xml:space="preserve">
          <source>The above discussion assumed a comparison of two single values. In R, there are no scalars, just vectors and implicit vectorization is a strength of the language. For comparing the value of vectors element-wise, the previous principles hold, but the implementation is slightly different. &lt;code&gt;==&lt;/code&gt; is vectorized (does an element-wise comparison) while &lt;code&gt;all.equal&lt;/code&gt; compares the whole vectors as a single entity.</source>
          <target state="translated">Приведенное выше обсуждение предполагает сравнение двух отдельных значений. В R нет скаляров, только векторы, и неявная векторизация является сильной стороной языка. Для сравнения значений векторов поэлементно, предыдущие принципы верны, но реализация немного отличается. &lt;code&gt;==&lt;/code&gt; векторизован (выполняет поэлементное сравнение), а &lt;code&gt;all.equal&lt;/code&gt; сравнивает целые векторы как одну сущность.</target>
        </trans-unit>
        <trans-unit id="286083fedeb68706da5ddee7fc584595eecda87b" translate="yes" xml:space="preserve">
          <source>The following code is obviously wrong.  What's the problem?</source>
          <target state="translated">Следующий код,очевидно,ошибочен.В чем проблема?</target>
        </trans-unit>
        <trans-unit id="65307256c0769098ea92d6613e2547e6bd639c7c" translate="yes" xml:space="preserve">
          <source>The function has a built in tolerance parameter: &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; that can be adjusted. The default parameter is the same as the default for &lt;code&gt;all.equal()&lt;/code&gt;.</source>
          <target state="translated">Функция имеет встроенный параметр допуска: &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; который можно настроить. Параметр по умолчанию такой же, как по умолчанию для &lt;code&gt;all.equal()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="272b58680ab72335d1e4703a07ebfbb0f28c4676" translate="yes" xml:space="preserve">
          <source>The problem you have encountered is that floating point cannot represent decimal fractions  exactly in most cases, which means you will frequently find that exact matches fail.</source>
          <target state="translated">Проблема,с которой вы столкнулись,заключается в том,что в большинстве случаев плавающая запятая не может точно представлять десятичные дроби,а значит,вы часто обнаружите,что точное совпадение не удается.</target>
        </trans-unit>
        <trans-unit id="070a79f751feafcce9f08da9832c4e0815567968" translate="yes" xml:space="preserve">
          <source>The standard solution to this in &lt;code&gt;R&lt;/code&gt; is not to use &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, but rather the &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt;&lt;code&gt;all.equal&lt;/code&gt;&lt;/a&gt; function. Or rather, since &lt;code&gt;all.equal&lt;/code&gt; gives lots of detail about the differences if there are any, &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt;.</source>
          <target state="translated">Стандартным решением этой проблемы в &lt;code&gt;R&lt;/code&gt; является не использование &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; , а функция &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt; &lt;code&gt;all.equal&lt;/code&gt; &lt;/a&gt; . Вернее, поскольку &lt;code&gt;all.equal&lt;/code&gt; подробно описывает различия, если они есть, &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="968758f117ff62e2e51c64f8ae3295633b6964fb" translate="yes" xml:space="preserve">
          <source>This algorithm goes a bit funny near extremely small numbers called denormals, but you don't need to worry about that.</source>
          <target state="translated">Этот алгоритм идет немного забавно рядом с очень маленькими числами,называемыми денормалами,но вам не нужно беспокоиться об этом.</target>
        </trans-unit>
        <trans-unit id="fbe24a5ff071badc1bdfee449e6e147729102bc5" translate="yes" xml:space="preserve">
          <source>This is a safe way of comparing if two vectors of floating point numbers are (pairwise) equal. This is safer than using &lt;code&gt;==&lt;/code&gt;, because it has a built in tolerance</source>
          <target state="translated">Это безопасный способ сравнения, если два вектора чисел с плавающей запятой (попарно) равны. Это безопаснее, чем использовать &lt;code&gt;==&lt;/code&gt; , потому что он имеет встроенный допуск</target>
        </trans-unit>
        <trans-unit id="91e3f8389d6dff87fc6a424c5b6b4ddea1948923" translate="yes" xml:space="preserve">
          <source>This is a well known limitation of computer arithmetic and is discussed in several places:</source>
          <target state="translated">Это хорошо известное ограничение компьютерной арифметики и обсуждается в нескольких местах:</target>
        </trans-unit>
        <trans-unit id="6dcb0fcdf79e4046df658313cba49c1768ab3a2b" translate="yes" xml:space="preserve">
          <source>This is hackish, but quick:</source>
          <target state="translated">Это хакерство,но быстро:</target>
        </trans-unit>
        <trans-unit id="ed935a9b3c7b1cf31f413305e15558985737c468" translate="yes" xml:space="preserve">
          <source>This is the approach taken by &lt;code&gt;dplyr::near&lt;/code&gt;, which documents itself as</source>
          <target state="translated">Это подход, принятый &lt;code&gt;dplyr::near&lt;/code&gt; , который документирует себя как</target>
        </trans-unit>
        <trans-unit id="b3cb562ee661de7f62ca0b20fc9e2098fe890aaa" translate="yes" xml:space="preserve">
          <source>Using the previous examples</source>
          <target state="translated">Используя предыдущие примеры</target>
        </trans-unit>
        <trans-unit id="83c1ba1426882f3dbdb8afe93eecb9ffe8f2b8b6" translate="yes" xml:space="preserve">
          <source>We can find out for any given computer what this smallest representable number is by looking in R's &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;machine&lt;/a&gt; field:</source>
          <target state="translated">Мы можем узнать для любого данного компьютера, что это наименьшее представимое число, посмотрев в поле &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;машины&lt;/a&gt; R:</target>
        </trans-unit>
        <trans-unit id="7f7977854e0609a7430f9215b9e0dd9b56ddf4fa" translate="yes" xml:space="preserve">
          <source>Why are floating point numbers inaccurate?</source>
          <target state="translated">Почему числа с плавающей точкой неточны?</target>
        </trans-unit>
        <trans-unit id="35070ef523d704a541ea75421f4ab2990c3a7c10" translate="yes" xml:space="preserve">
          <source>Why are these numbers not equal</source>
          <target state="translated">Почему эти числа не равны</target>
        </trans-unit>
        <trans-unit id="d158ff5b250d0962183aec94aa27b2b25dfd3b68" translate="yes" xml:space="preserve">
          <source>Why can't decimal numbers be represented exactly in binary?</source>
          <target state="translated">Почему десятичные числа не могут быть точно представлены в двоичном виде?</target>
        </trans-unit>
        <trans-unit id="c00c805fd92e2f74ab3c3034d65224c75d82b28c" translate="yes" xml:space="preserve">
          <source>You can find out what it really thinks in decimal:</source>
          <target state="translated">Ты можешь узнать,что он на самом деле думает в десятичной дроби:</target>
        </trans-unit>
        <trans-unit id="4e1abdfe596c9332ffa901f6c46aabba4fde63ec" translate="yes" xml:space="preserve">
          <source>You can see that they differ by &lt;code&gt;2^-53&lt;/code&gt;, which is important because this number is the smallest representable difference between two numbers whose value is close to 1, as this is.</source>
          <target state="translated">Вы можете видеть, что они отличаются на &lt;code&gt;2^-53&lt;/code&gt; , что важно, потому что это число является наименьшей представимой разницей между двумя числами, значение которых близко к 1, как это.</target>
        </trans-unit>
        <trans-unit id="ec9ee50875afbcc40532438f10cd7f14a78aa98d" translate="yes" xml:space="preserve">
          <source>You can see these numbers are different, but the representation is a bit unwieldy.  If we look at them in binary (well, hex, which is equivalent) we get a clearer picture:</source>
          <target state="translated">Вы можете видеть,что эти числа разные,но представление немного громоздкое.Если мы посмотрим на них в двоичном виде (ну,гекс,что эквивалентно),то получим более ясную картину:</target>
        </trans-unit>
        <trans-unit id="979f0181b91248a84779be2c1dc7ecc648c38964" translate="yes" xml:space="preserve">
          <source>You can use this fact to create a 'nearly equals' function which checks that the difference is close to the smallest representable number in floating point.  In fact this already exists: &lt;code&gt;all.equal&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать этот факт для создания функции &amp;laquo;почти равно&amp;raquo;, которая проверяет, что разница близка к наименьшему представимому числу в плавающей точке. На самом деле это уже существует: &lt;code&gt;all.equal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5422db08900cb5c0098c2ebe8e48aab223199ed" translate="yes" xml:space="preserve">
          <source>output of equal cut intervals based on round function:</source>
          <target state="translated">вывод равномерных интервалов резки в зависимости от круглой функции:</target>
        </trans-unit>
        <trans-unit id="e34633607427b57df33468be95a58b1f2c765d53" translate="yes" xml:space="preserve">
          <source>output of unequal cut intervals based on options(digits = 2):</source>
          <target state="translated">вывод неравномерных интервалов резки на основе опций (цифры=2):</target>
        </trans-unit>
        <trans-unit id="8fb6e7eec5312db10e2781b45c210b071f1567b8" translate="yes" xml:space="preserve">
          <source>which can be called as just</source>
          <target state="translated">который можно назвать справедливым</target>
        </trans-unit>
        <trans-unit id="cb8114adda95adf801cfaf3c990dedd22ec24f9a" translate="yes" xml:space="preserve">
          <source>while R lies slightly when you say:</source>
          <target state="translated">в то время как Р немного лжет,когда ты говоришь:</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
