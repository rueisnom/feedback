<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/9508518">
    <body>
      <group id="9508518">
        <trans-unit id="f4fa0ad2dbf00e7377bb9024e10bd7c46a4b8c93" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.com&lt;/a&gt; compares floating point arithmetic across programming languages</source>
          <target state="translated">&lt;a href=&quot;http://0.30000000000000004.com&quot;&gt;0.30000000000000004.com&lt;/a&gt; compara la aritm&amp;eacute;tica de coma flotante en los lenguajes de programaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="24c9907757c274c7f252cc607997262c334e6d0a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;The R Inferno by Patrick Burns&lt;/a&gt; devotes the first &quot;Circle&quot; to this problem (starting on page 9)</source>
          <target state="translated">&lt;a href=&quot;http://www.burns-stat.com/pages/Tutor/R_inferno.pdf&quot;&gt;El Infierno R de Patrick Burns&lt;/a&gt; dedica el primer &quot;C&amp;iacute;rculo&quot; a este problema (comenzando en la p&amp;aacute;gina 9)</target>
        </trans-unit>
        <trans-unit id="930823bc4ba954f44f4ecf582ca21a88c9a5d230" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;Canonical duplicate for &quot;floating point is inaccurate&quot;&lt;/a&gt; (a meta discussion about a canonical answer for this issue)</source>
          <target state="translated">&lt;a href=&quot;https://meta.stackoverflow.com/q/260130/892313&quot;&gt;Duplicado can&amp;oacute;nico para &quot;coma flotante es inexacto&quot;&lt;/a&gt; (una meta discusi&amp;oacute;n sobre una respuesta can&amp;oacute;nica para este problema)</target>
        </trans-unit>
        <trans-unit id="1baf96f8d4e4ecd837aee183191fa1077bb3b202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does not give the &quot;expected&quot; result and &lt;code&gt;all.equal&lt;/code&gt; does not perform element-wise</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; no da el resultado &quot;esperado&quot; y &lt;code&gt;all.equal&lt;/code&gt; no realiza elementos sabios</target>
        </trans-unit>
        <trans-unit id="98f6b45786d2b2aedf5ec1132df549cebc8df3fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dplyr::near()&lt;/code&gt; is an option for testing if two vectors of floating point numbers are equal. This is the example from the &lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;dplyr::near()&lt;/code&gt; es una opci&amp;oacute;n para probar si dos vectores de n&amp;uacute;meros de coma flotante son iguales. Este es el ejemplo de los &lt;a href=&quot;https://dplyr.tidyverse.org/reference/near.html&quot;&gt;documentos&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a0e2b1d9886d3fae1cc44fa5d134212926dac59f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;gt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Comparando a&amp;gt; = b:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccea69290856a10c89ac66255fbe959b1d843e33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a &amp;lt;= b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Comparando a &amp;lt;= b:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1aeaadf527cff400e53c622865a7ced4c552aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comparing a = b:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Comparando a = b:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae3dd5ba710442f2a39cd59cf354c80a5495d632" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Per Joshua's warning here is the updated code (Thanks Joshua):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La advertencia de Joshua aqu&amp;iacute; es el c&amp;oacute;digo actualizado (Gracias Joshua):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051f8044a78b9bb0a5e9b49aec7a714c76917ab2" translate="yes" xml:space="preserve">
          <source>@ I found this work around solution about unequal cut intervals.  @ I
  used the round function in R. By setting the option to 2 digits, did
  not solved the problem.</source>
          <target state="translated">Encontré este trabajo sobre la solución de los intervalos de corte desiguales.Utilicé la función de redondeo en R.Al poner la opción de 2 dígitos,no resolví el problema.</target>
        </trans-unit>
        <trans-unit id="2aeffb9b120bf727e331fbd80cf3370e6f6add08" translate="yes" xml:space="preserve">
          <source>Adding to Brian's comment (which is the reason) you can over come this by using &lt;code&gt;all.equal&lt;/code&gt; instead:</source>
          <target state="translated">Agregando al comentario de Brian (que es la raz&amp;oacute;n) puedes superar esto usando &lt;code&gt;all.equal&lt;/code&gt; en su lugar:</target>
        </trans-unit>
        <trans-unit id="c3e13ababf0fa6f39113926ca83f1024d4b04f23" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of wrapping &lt;code&gt;all.equal&lt;/code&gt; in even more function calls, you can just replicate the relevant internals of &lt;code&gt;all.equal.numeric&lt;/code&gt; and use implicit vectorization:</source>
          <target state="translated">Alternativamente, en lugar de envolver &lt;code&gt;all.equal&lt;/code&gt; en a&amp;uacute;n m&amp;aacute;s llamadas a funciones, puede simplemente replicar las &lt;code&gt;all.equal.numeric&lt;/code&gt; internas relevantes de all.equal.numeric y usar la vectorizaci&amp;oacute;n impl&amp;iacute;cita:</target>
        </trans-unit>
        <trans-unit id="e1cc3319b6d4e9c6df888fe5f49dbccf0d9c60c3" translate="yes" xml:space="preserve">
          <source>Comparing scalars</source>
          <target state="translated">Comparando los escalares</target>
        </trans-unit>
        <trans-unit id="e5078ee6bca5437eb55e908d75d2142a6eb1887f" translate="yes" xml:space="preserve">
          <source>Comparing vectors</source>
          <target state="translated">Comparando vectores</target>
        </trans-unit>
        <trans-unit id="9141c1bcc7393f0a51a930e3e61068beb111c324" translate="yes" xml:space="preserve">
          <source>David Goldberg, &quot;What Every Computer Scientist Should Know About Floating-point Arithmetic,&quot; &lt;em&gt;ACM Computing Surveys&lt;/em&gt;&lt;strong&gt;23&lt;/strong&gt;, 1 (1991-03), 5-48 &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;doi&amp;gt;10.1145/103162.103163&lt;/a&gt; (&lt;a href=&quot;http://www.validlab.com/goldberg/paper.pdf&quot;&gt;revision also available&lt;/a&gt;)</source>
          <target state="translated">David Goldberg, &quot;Lo que todo inform&amp;aacute;tico debe saber sobre la aritm&amp;eacute;tica de punto flotante&quot;, &lt;em&gt;ACM Computing Surveys&lt;/em&gt; &lt;strong&gt;23&lt;/strong&gt; , 1 (1991-03), 5-48 &lt;a href=&quot;http://dx.doi.org/10.1145/103162.103163&quot;&gt;doi&amp;gt; 10.1145 / 103162.103163&lt;/a&gt; ( &lt;a href=&quot;http://www.validlab.com/goldberg/paper.pdf&quot;&gt;revisi&amp;oacute;n tambi&amp;eacute;n disponible&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="61a132a84dfc3fde6af76f27012b8611354d6aa7" translate="yes" xml:space="preserve">
          <source>General (language agnostic) reason</source>
          <target state="translated">Razón general (lenguaje agnóstico)</target>
        </trans-unit>
        <trans-unit id="d9da8d2236553ed39bb853de9dbc03947b4af565" translate="yes" xml:space="preserve">
          <source>Generalized comparisons (&quot;&amp;lt;=&quot;, &quot;&amp;gt;=&quot;, &quot;=&quot;) in double precion arithmetic:</source>
          <target state="translated">Comparaciones generalizadas (&quot;&amp;lt;=&quot;, &quot;&amp;gt; =&quot;, &quot;=&quot;) en aritm&amp;eacute;tica de doble preci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="ca21d0110f4cb3b258d5ecd4dbf4725bfab29709" translate="yes" xml:space="preserve">
          <source>I had a similar problem. I used the following solution.</source>
          <target state="translated">Yo tenía un problema similar.Utilicé la siguiente solución.</target>
        </trans-unit>
        <trans-unit id="6821df2a778db375130c453d3832adf6ecca124e" translate="yes" xml:space="preserve">
          <source>If a functional version of this is desired, it can be written</source>
          <target state="translated">Si se desea una versión funcional de esto,se puede escribir</target>
        </trans-unit>
        <trans-unit id="a326f79ad38f19b61a34a0eda13066d9d3971374" translate="yes" xml:space="preserve">
          <source>Is floating point math broken?</source>
          <target state="translated">¿Están rotas las matemáticas de punto flotante?</target>
        </trans-unit>
        <trans-unit id="4aae375ec7ffb4038e977be2e7bfd35ef0e328eb" translate="yes" xml:space="preserve">
          <source>Rather, a version which loops over the two vectors must be used</source>
          <target state="translated">Más bien,se debe utilizar una versión que haga un bucle sobre los dos vectores</target>
        </trans-unit>
        <trans-unit id="1a049a837169173e32b09640587b10f6554d0375" translate="yes" xml:space="preserve">
          <source>Several Stack Overflow questions including</source>
          <target state="translated">Varias preguntas sobre el desbordamiento de la pila,incluyendo</target>
        </trans-unit>
        <trans-unit id="23417499b5d7a1a4236bdd6daa17778bf5030ace" translate="yes" xml:space="preserve">
          <source>Since not all numbers can be represented exactly in &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE floating point arithmetic&lt;/a&gt; (the standard that almost all computers use to represent decimal numbers and do math with them), you will not always get what you expected. This is especially true because some values which are simple, finite decimals (such as 0.1 and 0.05) are not represented exactly in the computer and so the results of arithmetic on them may not give a result that is identical to a direct representation of the &quot;known&quot; answer.</source>
          <target state="translated">Como no todos los n&amp;uacute;meros se pueden representar exactamente en &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;aritm&amp;eacute;tica de coma flotante IEEE&lt;/a&gt; (el est&amp;aacute;ndar que casi todas las computadoras usan para representar n&amp;uacute;meros decimales y hacer c&amp;aacute;lculos matem&amp;aacute;ticos con ellos), no siempre obtendr&amp;aacute; lo que esperaba. Esto es especialmente cierto porque algunos valores que son decimales finitos simples (como 0.1 y 0.05) no est&amp;aacute;n representados exactamente en la computadora y, por lo tanto, los resultados de la aritm&amp;eacute;tica en ellos pueden no dar un resultado que sea id&amp;eacute;ntico a una representaci&amp;oacute;n directa de &quot; conocida &quot;respuesta.</target>
        </trans-unit>
        <trans-unit id="78a5407867ec4b20b146cd40dcedc7268687c9ca" translate="yes" xml:space="preserve">
          <source>So the all.equal function is actually checking that the difference between the numbers is the square root of the smallest difference between two mantissas.</source>
          <target state="translated">Así que la función all.equal está comprobando que la diferencia entre los números es la raíz cuadrada de la menor diferencia entre dos mantisas.</target>
        </trans-unit>
        <trans-unit id="782df692af05d6a97e8bc9b7ec27212915fb412b" translate="yes" xml:space="preserve">
          <source>Some more detail, directly copied from an &lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;answer to a similar question&lt;/a&gt;:</source>
          <target state="translated">Algunos detalles m&amp;aacute;s, copiados directamente de una &lt;a href=&quot;https://stackoverflow.com/a/2228139/892313&quot;&gt;respuesta a una pregunta similar&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9802b4584fbee2462fc07f889fb2472820006245" translate="yes" xml:space="preserve">
          <source>Some more examples of using &lt;code&gt;all.equal&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (the last example is supposed to show that this will correctly show differences).</source>
          <target state="translated">Algunos ejemplos m&amp;aacute;s del uso de &lt;code&gt;all.equal&lt;/code&gt; en lugar de &lt;code&gt;==&lt;/code&gt; (se supone que el &amp;uacute;ltimo ejemplo muestra que esto mostrar&amp;aacute; correctamente las diferencias).</target>
        </trans-unit>
        <trans-unit id="5584632278ce8887d8f51c213098aaaebc556bb5" translate="yes" xml:space="preserve">
          <source>The Floating-Point Guide - What Every Programmer Should Know About Floating-Point Arithmetic</source>
          <target state="translated">The Floating-Point Guide-Lo que todo programador debería saber sobre la aritmética de los puntos flotantes</target>
        </trans-unit>
        <trans-unit id="0a0152c5594eda13240b4bf87e58f512efcfe2a8" translate="yes" xml:space="preserve">
          <source>The R FAQ has question devoted to it: &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</source>
          <target state="translated">La R FAQ tiene una pregunta dedicada: &lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f&quot;&gt;R FAQ 7.31&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ca718a45aece9e7f3c849274bc1c2ead790fe38" translate="yes" xml:space="preserve">
          <source>The above discussion assumed a comparison of two single values. In R, there are no scalars, just vectors and implicit vectorization is a strength of the language. For comparing the value of vectors element-wise, the previous principles hold, but the implementation is slightly different. &lt;code&gt;==&lt;/code&gt; is vectorized (does an element-wise comparison) while &lt;code&gt;all.equal&lt;/code&gt; compares the whole vectors as a single entity.</source>
          <target state="translated">La discusi&amp;oacute;n anterior supuso una comparaci&amp;oacute;n de dos valores individuales. En R, no hay escalares, solo vectores y la vectorizaci&amp;oacute;n impl&amp;iacute;cita es una fortaleza del lenguaje. Para comparar el valor de los vectores por elementos, se mantienen los principios anteriores, pero la implementaci&amp;oacute;n es ligeramente diferente. &lt;code&gt;==&lt;/code&gt; est&amp;aacute; vectorizado (hace una comparaci&amp;oacute;n entre elementos) mientras &lt;code&gt;all.equal&lt;/code&gt; compara los vectores completos como una sola entidad.</target>
        </trans-unit>
        <trans-unit id="286083fedeb68706da5ddee7fc584595eecda87b" translate="yes" xml:space="preserve">
          <source>The following code is obviously wrong.  What's the problem?</source>
          <target state="translated">El siguiente código está obviamente equivocado.¿Cuál es el problema?</target>
        </trans-unit>
        <trans-unit id="65307256c0769098ea92d6613e2547e6bd639c7c" translate="yes" xml:space="preserve">
          <source>The function has a built in tolerance parameter: &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; that can be adjusted. The default parameter is the same as the default for &lt;code&gt;all.equal()&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n tiene un par&amp;aacute;metro de tolerancia incorporado: &lt;code&gt;tol = .Machine$double.eps^0.5&lt;/code&gt; que se puede ajustar. El par&amp;aacute;metro predeterminado es el mismo que el predeterminado para &lt;code&gt;all.equal()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="272b58680ab72335d1e4703a07ebfbb0f28c4676" translate="yes" xml:space="preserve">
          <source>The problem you have encountered is that floating point cannot represent decimal fractions  exactly in most cases, which means you will frequently find that exact matches fail.</source>
          <target state="translated">El problema que ha encontrado es que la coma flotante no puede representar fracciones decimales exactamente en la mayoría de los casos,lo que significa que con frecuencia encontrará que las coincidencias exactas fallan.</target>
        </trans-unit>
        <trans-unit id="070a79f751feafcce9f08da9832c4e0815567968" translate="yes" xml:space="preserve">
          <source>The standard solution to this in &lt;code&gt;R&lt;/code&gt; is not to use &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, but rather the &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt;&lt;code&gt;all.equal&lt;/code&gt;&lt;/a&gt; function. Or rather, since &lt;code&gt;all.equal&lt;/code&gt; gives lots of detail about the differences if there are any, &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt;.</source>
          <target state="translated">La soluci&amp;oacute;n est&amp;aacute;ndar para esto en &lt;code&gt;R&lt;/code&gt; no es usar &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/Comparison&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; , sino la funci&amp;oacute;n &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/all.equal&quot;&gt; &lt;code&gt;all.equal&lt;/code&gt; &lt;/a&gt; . O m&amp;aacute;s bien, dado que &lt;code&gt;all.equal&lt;/code&gt; brinda muchos detalles sobre las diferencias, si las hay, es &lt;code&gt;isTRUE(all.equal(...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="968758f117ff62e2e51c64f8ae3295633b6964fb" translate="yes" xml:space="preserve">
          <source>This algorithm goes a bit funny near extremely small numbers called denormals, but you don't need to worry about that.</source>
          <target state="translated">Este algoritmo es un poco raro cerca de los números extremadamente pequeños llamados denormales,pero no tienes que preocuparte por eso.</target>
        </trans-unit>
        <trans-unit id="fbe24a5ff071badc1bdfee449e6e147729102bc5" translate="yes" xml:space="preserve">
          <source>This is a safe way of comparing if two vectors of floating point numbers are (pairwise) equal. This is safer than using &lt;code&gt;==&lt;/code&gt;, because it has a built in tolerance</source>
          <target state="translated">Esta es una forma segura de comparar si dos vectores de n&amp;uacute;meros de coma flotante son (por pares) iguales. Esto es m&amp;aacute;s seguro que usar &lt;code&gt;==&lt;/code&gt; , porque tiene una tolerancia incorporada</target>
        </trans-unit>
        <trans-unit id="91e3f8389d6dff87fc6a424c5b6b4ddea1948923" translate="yes" xml:space="preserve">
          <source>This is a well known limitation of computer arithmetic and is discussed in several places:</source>
          <target state="translated">Esta es una limitación bien conocida de la aritmética computacional y se discute en varios lugares:</target>
        </trans-unit>
        <trans-unit id="6dcb0fcdf79e4046df658313cba49c1768ab3a2b" translate="yes" xml:space="preserve">
          <source>This is hackish, but quick:</source>
          <target state="translated">Esto es un hacker,pero rápido:</target>
        </trans-unit>
        <trans-unit id="ed935a9b3c7b1cf31f413305e15558985737c468" translate="yes" xml:space="preserve">
          <source>This is the approach taken by &lt;code&gt;dplyr::near&lt;/code&gt;, which documents itself as</source>
          <target state="translated">Este es el enfoque adoptado por &lt;code&gt;dplyr::near&lt;/code&gt; , que se documenta como</target>
        </trans-unit>
        <trans-unit id="b3cb562ee661de7f62ca0b20fc9e2098fe890aaa" translate="yes" xml:space="preserve">
          <source>Using the previous examples</source>
          <target state="translated">Utilizando los ejemplos anteriores</target>
        </trans-unit>
        <trans-unit id="83c1ba1426882f3dbdb8afe93eecb9ffe8f2b8b6" translate="yes" xml:space="preserve">
          <source>We can find out for any given computer what this smallest representable number is by looking in R's &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;machine&lt;/a&gt; field:</source>
          <target state="translated">Podemos averiguar en cualquier computadora cu&amp;aacute;l es este n&amp;uacute;mero representable m&amp;aacute;s peque&amp;ntilde;o mirando el campo de &lt;a href=&quot;https://www.rdocumentation.org/packages/base/topics/.Machine&quot;&gt;m&amp;aacute;quina&lt;/a&gt; de R:</target>
        </trans-unit>
        <trans-unit id="7f7977854e0609a7430f9215b9e0dd9b56ddf4fa" translate="yes" xml:space="preserve">
          <source>Why are floating point numbers inaccurate?</source>
          <target state="translated">¿Por qué los números en coma flotante son inexactos?</target>
        </trans-unit>
        <trans-unit id="35070ef523d704a541ea75421f4ab2990c3a7c10" translate="yes" xml:space="preserve">
          <source>Why are these numbers not equal</source>
          <target state="translated">¿Por qué estos números no son iguales</target>
        </trans-unit>
        <trans-unit id="d158ff5b250d0962183aec94aa27b2b25dfd3b68" translate="yes" xml:space="preserve">
          <source>Why can't decimal numbers be represented exactly in binary?</source>
          <target state="translated">¿Por qué los números decimales no pueden ser representados exactamente en binario?</target>
        </trans-unit>
        <trans-unit id="c00c805fd92e2f74ab3c3034d65224c75d82b28c" translate="yes" xml:space="preserve">
          <source>You can find out what it really thinks in decimal:</source>
          <target state="translated">Puedes averiguar lo que realmente piensa en decimal:</target>
        </trans-unit>
        <trans-unit id="4e1abdfe596c9332ffa901f6c46aabba4fde63ec" translate="yes" xml:space="preserve">
          <source>You can see that they differ by &lt;code&gt;2^-53&lt;/code&gt;, which is important because this number is the smallest representable difference between two numbers whose value is close to 1, as this is.</source>
          <target state="translated">Puede ver que difieren en &lt;code&gt;2^-53&lt;/code&gt; , lo cual es importante porque este n&amp;uacute;mero es la diferencia representable m&amp;aacute;s peque&amp;ntilde;a entre dos n&amp;uacute;meros cuyo valor es cercano a 1, como lo es.</target>
        </trans-unit>
        <trans-unit id="ec9ee50875afbcc40532438f10cd7f14a78aa98d" translate="yes" xml:space="preserve">
          <source>You can see these numbers are different, but the representation is a bit unwieldy.  If we look at them in binary (well, hex, which is equivalent) we get a clearer picture:</source>
          <target state="translated">Puedes ver que estos números son diferentes,pero la representación es un poco difícil de manejar.Si los miramos en binario (bueno,en hexágono,que es equivalente)obtenemos una imagen más clara:</target>
        </trans-unit>
        <trans-unit id="979f0181b91248a84779be2c1dc7ecc648c38964" translate="yes" xml:space="preserve">
          <source>You can use this fact to create a 'nearly equals' function which checks that the difference is close to the smallest representable number in floating point.  In fact this already exists: &lt;code&gt;all.equal&lt;/code&gt;.</source>
          <target state="translated">Puede usar este hecho para crear una funci&amp;oacute;n 'casi igual' que verifique que la diferencia est&amp;eacute; cerca del n&amp;uacute;mero representable m&amp;aacute;s peque&amp;ntilde;o en coma flotante. De hecho, esto ya existe: &lt;code&gt;all.equal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5422db08900cb5c0098c2ebe8e48aab223199ed" translate="yes" xml:space="preserve">
          <source>output of equal cut intervals based on round function:</source>
          <target state="translated">salida de intervalos de corte iguales basados en la función redonda:</target>
        </trans-unit>
        <trans-unit id="e34633607427b57df33468be95a58b1f2c765d53" translate="yes" xml:space="preserve">
          <source>output of unequal cut intervals based on options(digits = 2):</source>
          <target state="translated">salida de intervalos de corte desiguales basados en opciones (dígitos=2):</target>
        </trans-unit>
        <trans-unit id="8fb6e7eec5312db10e2781b45c210b071f1567b8" translate="yes" xml:space="preserve">
          <source>which can be called as just</source>
          <target state="translated">que puede ser llamado como sólo</target>
        </trans-unit>
        <trans-unit id="cb8114adda95adf801cfaf3c990dedd22ec24f9a" translate="yes" xml:space="preserve">
          <source>while R lies slightly when you say:</source>
          <target state="translated">mientras que R miente ligeramente cuando dices:</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
