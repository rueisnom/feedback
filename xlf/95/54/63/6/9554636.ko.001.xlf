<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/9554636">
    <body>
      <group id="9554636">
        <trans-unit id="855f9e933886a93d32ebf837609b340fe090e632" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/internalframe.html&quot;&gt;&lt;code&gt;JInternalFrame&lt;/code&gt;/&lt;code&gt;JDesktopPane&lt;/code&gt;&lt;/a&gt; typically used for an &lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_document_interface&quot;&gt;MDI&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/internalframe.html&quot;&gt; &lt;code&gt;JInternalFrame&lt;/code&gt; / &lt;code&gt;JDesktopPane&lt;/code&gt; 은&lt;/a&gt; 일반적으로 &lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_document_interface&quot;&gt;MDI에&lt;/a&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a46d13b700a93249f6afe7fb6bfe1e263e5530b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/layeredpane.html&quot;&gt;&lt;code&gt;JLayeredPane&lt;/code&gt;&lt;/a&gt; far many well ..layered components.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/layeredpane.html&quot;&gt; &lt;code&gt;JLayeredPane&lt;/code&gt; &lt;/a&gt; 훨씬 많은 ..layered 구성 요소.</target>
        </trans-unit>
        <trans-unit id="fa15a30d2ea44e1bae88344bfaba468ce12217dd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/splitpane.html&quot;&gt;&lt;code&gt;JSplitPane&lt;/code&gt;&lt;/a&gt; A way to display two components of which the importance between one or the other (the size) varies according to what the user is doing.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/splitpane.html&quot;&gt; &lt;code&gt;JSplitPane&lt;/code&gt; &lt;/a&gt; 두 구성 요소를 표시하는 방법 중 하나는 다른 요소 사이의 중요성 (크기)이 사용자의 작업에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="109151339ec6f5994c59939e3d44bde37775fe57" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tabbedpane.html&quot;&gt;&lt;code&gt;JTabbedPane&lt;/code&gt;&lt;/a&gt; for groups of components.</source>
          <target state="translated">컴포넌트 그룹 용 &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tabbedpane.html&quot;&gt; &lt;code&gt;JTabbedPane&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d1c280dafddc96fddfd673c95475f20a70bbd27" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/toolbar.html&quot;&gt;&lt;code&gt;JToolBar&lt;/code&gt;&lt;/a&gt; typically contains groups of actions or controls.  Can be dragged around the GUI, or off it entirely according to user need.  As mentioned above, will minimize/restore according to the parent doing so.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/toolbar.html&quot;&gt; &lt;code&gt;JToolBar&lt;/code&gt; 는&lt;/a&gt; 일반적으로 액션 또는 컨트롤 그룹을 포함합니다. GUI 주위를 드래그하거나 사용자 요구에 따라 완전히 끌 수 있습니다. 위에서 언급했듯이 부모에 따라 최소화 / 복원합니다.</target>
        </trans-unit>
        <trans-unit id="763086f93c3af994a0218d3c81cbcc6c22c71525" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/card.html&quot;&gt;&lt;code&gt;CardLayout&lt;/code&gt;&lt;/a&gt; (short &lt;a href=&quot;https://stackoverflow.com/a/5786005/418556&quot;&gt;demo.&lt;/a&gt;). Good for:</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/card.html&quot;&gt; &lt;code&gt;CardLayout&lt;/code&gt; &lt;/a&gt; (짧은 &lt;a href=&quot;https://stackoverflow.com/a/5786005/418556&quot;&gt;데모.&lt;/a&gt; ). 좋은:</target>
        </trans-unit>
        <trans-unit id="550f5f00bb5b95d41520ea13e97393e21fb1dc71" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/5630271/418556&quot;&gt;Nested layouts&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/5630271/418556&quot;&gt;중첩 레이아웃&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e69a34a769e8e98953e94688ba466fa5ffa332bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's easy to use JInternalFrame&lt;/strong&gt; This is kind of retorical, now it's way easier and other people smarter ( or with more spare time) than us have already think through the Desktop and JInternalFrame pattern, so I would recommend to use it.</source>
          <target state="translated">&lt;strong&gt;JInternalFrame을 사용하기 쉽습니다.&lt;/strong&gt; 이것은 일종의 레토릭이며, 이제 우리가 이미 Desktop 및 JInternalFrame 패턴을 통해 생각했던 것보다 훨씬 쉽고 더 똑똑한 (또는 여가 시간이 더) 길기 때문에 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6505550594a36da49202f35678c36a219cd1bc64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's more expensive:&lt;/strong&gt; you will have to allocate way more resources to draw a JFrame that other kind of window container, such as Dialog or JInternalFrame.</source>
          <target state="translated">&lt;strong&gt;더 비쌉니다.&lt;/strong&gt; Dialog 또는 JInternalFrame과 같은 다른 종류의 창 컨테이너와 같은 JFrame을 그리려면 더 많은 리소스를 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="64a9e72acd1aeb2087f34209c0fdded738377ff3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Makes it easy for end-users to reference outside material&lt;/strong&gt; - Once, I had this situation: My app had a &quot;data viewer,&quot; from which you could click &quot;Add New&quot; and it would open a data entry screen. Initially, both were &lt;code&gt;JFrame&lt;/code&gt;s. However, I wanted the data entry screen to be a &lt;code&gt;JDialog&lt;/code&gt; whose parent was the data viewer. I made the change, and immediately I received a call from an end-user who relied heavily on the fact that he could minimize or close the &lt;strong&gt;viewer&lt;/strong&gt; and keep the &lt;strong&gt;editor&lt;/strong&gt; open while he referenced another part of the program (or a website, I don't remember). He's &lt;strong&gt;not&lt;/strong&gt; on a multi-monitor, so he needed the entry dialog to be first and &lt;em&gt;something else&lt;/em&gt; to be second, with the data viewer completely hidden. This was impossible with a &lt;code&gt;JDialog&lt;/code&gt; and certainly would've been impossible with a &lt;code&gt;JInternalFrame&lt;/code&gt; as well. I begrudgingly changed it back to being separate &lt;code&gt;JFrames&lt;/code&gt; for his sanity, but it taught me an important lesson.</source>
          <target state="translated">&lt;strong&gt;최종 사용자가 외부 자료를 쉽게 참조 할 수 있도록합니다&lt;/strong&gt; .-일단 다음 상황이 발생했습니다. 내 앱에 &quot;데이터 뷰어&quot;가있어 &quot;새로 추가&quot;를 클릭하면 데이터 입력 화면이 열립니다. 처음에는 둘 다 &lt;code&gt;JFrame&lt;/code&gt; 입니다. 그러나 데이터 입력 화면이 부모가 데이터 뷰어 인 &lt;code&gt;JDialog&lt;/code&gt; 가되기를 원했습니다. 변경 한 후 즉시 최종 사용자로부터 &lt;strong&gt;뷰어를&lt;/strong&gt; 최소화하거나 닫을 수 있고 프로그램의 다른 부분 (또는 웹 사이트, 기억하지 마십시오). 그는 다중 모니터를 사용 &lt;strong&gt;하지 않기&lt;/strong&gt; 때문에 데이터 뷰어가 완전히 숨겨져 있기 때문에 입력 대화 상자가 첫 번째이고 &lt;em&gt;다른&lt;/em&gt; 것이 두 번째이어야했습니다. 이것은 &lt;code&gt;JDialog&lt;/code&gt; 로는 불가능했으며 &lt;code&gt;JInternalFrame&lt;/code&gt; 에서도 불가능했을 것입니다. 나는 그의 건강을 위해 별도의 &lt;code&gt;JFrames&lt;/code&gt; 로 다시 바꿨지 만 중요한 교훈을 가르쳐주었습니다.</target>
        </trans-unit>
        <trans-unit id="c350bf5b7874fb5157fa5b4d297e3baedf5daf04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Myth/Unproven: Resource Heavy&lt;/strong&gt; - I'd like to see some facts behind this speculative statement. Although, perhaps, you could say a &lt;code&gt;JFrame&lt;/code&gt; needs more space than a &lt;code&gt;JInternalFrame&lt;/code&gt;, even if you open up 100 &lt;code&gt;JFrame&lt;/code&gt;s, how many more resources would you really be consuming? If your concern is memory leaks because of resources: calling &lt;code&gt;dispose()&lt;/code&gt; frees all resources used by the frame for garbage collection (and, again I say, a &lt;code&gt;JInternalFrame&lt;/code&gt; should invoke exactly the same concern).</source>
          <target state="translated">&lt;strong&gt;오해 / 증명되지 않은 : 리소스가 많이 소모 됨&lt;/strong&gt; -이 추측에 대한 몇 가지 사실을 알고 싶습니다. 아마도 &lt;code&gt;JFrame&lt;/code&gt; 이 &lt;code&gt;JInternalFrame&lt;/code&gt; 보다 더 많은 공간이 필요하다고 말할 수 있지만 100 개의 &lt;code&gt;JFrame&lt;/code&gt; 을 열더라도 실제로 더 많은 리소스를 소비하고 있습니까? 리소스 때문에 메모리 누수가 우려되는 경우 : &lt;code&gt;dispose()&lt;/code&gt; 호출하면 가비지 수집을 위해 프레임에서 사용하는 모든 리소스가 해제됩니다 (다시 말해 &lt;code&gt;JInternalFrame&lt;/code&gt; 은 정확히 동일한 우려를 호출해야 함).</target>
        </trans-unit>
        <trans-unit id="efb2fd64572b99552839bf2317681d6459eacddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Myth: Hard to code&lt;/strong&gt; - This is not true in my experience. I don't see why it would be any easier to create a &lt;code&gt;JInternalFrame&lt;/code&gt; than a &lt;code&gt;JFrame&lt;/code&gt;. In fact, in my experience, &lt;code&gt;JInternalFrames&lt;/code&gt; offer much less flexibility. I have developed a systematic way of handling the opening &amp;amp; closing of &lt;code&gt;JFrame&lt;/code&gt;s in my apps that really works well. I control the frame almost completely from within the frame's code itself; the creation of the new frame, &lt;code&gt;SwingWorker&lt;/code&gt;s that control the retrieval of data on background threads and the GUI code on EDT, restoring/bringing to front the frame if the user tries to open it twice, etc. All you need to open my &lt;code&gt;JFrame&lt;/code&gt;s is call a public static method &lt;code&gt;open()&lt;/code&gt; and the open method, combined with a &lt;code&gt;windowClosing()&lt;/code&gt; event handles the rest (is the frame already open? is it not open, but loading? etc.) I made this approach a template so it's not difficult to implement for each frame.</source>
          <target state="translated">&lt;strong&gt;오해 : 코딩하기&lt;/strong&gt; 어려움-이것은 내 경험에 해당되지 않습니다. &lt;code&gt;JFrame&lt;/code&gt; 보다 &lt;code&gt;JInternalFrame&lt;/code&gt; 을 만드는 것이 더 쉬운 이유는 모르겠습니다. 실제로 &lt;code&gt;JInternalFrames&lt;/code&gt; 는 경험상 훨씬 적은 유연성을 제공합니다. 실제로 잘 작동하는 앱에서 &lt;code&gt;JFrame&lt;/code&gt; 열기 및 닫기를 처리하는 체계적인 방법을 개발했습니다. 프레임 코드 자체에서 프레임을 거의 완벽하게 제어합니다. 백그라운드 스레드에서 데이터 검색과 EDT에서 GUI 코드 검색을 제어하는 ​​새로운 프레임, &lt;code&gt;SwingWorker&lt;/code&gt; 생성, 사용자가 프레임을 두 번 열려고하면 프레임을 앞당기거나 가져 오기 등. &lt;code&gt;JFrame&lt;/code&gt; 을 열면 됩니다. s는 공개 정적 메소드 &lt;code&gt;open()&lt;/code&gt; 및 open 메소드이며 &lt;code&gt;windowClosing()&lt;/code&gt; 이벤트와 결합하여 나머지를 처리합니다 (프레임이 이미 열려 있습니까? 열려 있지는 않지만로드 중입니까?).이 접근법을 템플릿으로 만들었습니다. 각 프레임마다 구현하기 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b720d278aac00ca850d3c60052ad4c0ee45a6be7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Not user friendly:&lt;/strong&gt; It is not easy to navigate into a bunch of JFrame stuck together, it will look like your application is a set of applications inconsistent and poorly design.</source>
          <target state="translated">&lt;strong&gt;사용자 친화적이지 않음 :&lt;/strong&gt; 여러 JFrame을 함께 탐색하기가 쉽지 않습니다. 애플리케이션이 일관성이없고 디자인이 잘못된 애플리케이션 세트 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="e47badd23c6e53dbd9b63a1f01bbb996aa64fedf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ultimate flexibility in layout&lt;/strong&gt; - By allowing separate &lt;code&gt;JFrame&lt;/code&gt;s, you give your end-user the ability to spread out and control what's on his/her screen. The concept feels &quot;open&quot; and non-constricting. You lose this when you go towards one big &lt;code&gt;JFrame&lt;/code&gt; and a bunch of &lt;code&gt;JInternalFrame&lt;/code&gt;s.</source>
          <target state="translated">뛰어난 &lt;strong&gt;레이아웃 유연성&lt;/strong&gt; -별도의 &lt;code&gt;JFrame&lt;/code&gt; 을 허용함으로써 최종 사용자가 자신의 화면에있는 내용을 분산시키고 제어 할 수 있습니다. 이 개념은 &quot;개방적&quot;이고 비 제한적입니다. 하나의 큰 &lt;code&gt;JFrame&lt;/code&gt; 과 많은 &lt;code&gt;JInternalFrame&lt;/code&gt; 으로 갈 때 이것을 잃습니다.</target>
        </trans-unit>
        <trans-unit id="84a7ad212cb5de26f474e362ca7b87eca229fa40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Works well for very modularized applications&lt;/strong&gt; - In my case, most of my applications have 3 - 5 big &quot;modules&quot; that really have nothing to do with each other whatsoever. For instance, one module might be a sales dashboard and one might be an accounting dashboard. They don't talk to each other or anything. However, the executive might want to open both and them being separate frames on the taskbar makes his life easier.</source>
          <target state="translated">&lt;strong&gt;매우 모듈화 된 응용 프로그램에 적합&lt;/strong&gt; -제 경우에는 대부분의 응용 프로그램이 서로간에 전혀 관련이없는 3-5 개의 큰 &quot;모듈&quot;을 가지고 있습니다. 예를 들어 하나의 모듈은 영업 대시 보드이고 다른 하나는 회계 대시 보드 일 수 있습니다. 그들은 서로 또는 아무 말도하지 않습니다. 그러나 경영자는 두 가지를 모두 열어야 할 수도 있고 작업 표시 줄의 별도 프레임으로 인해 삶을 더 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c09531f11456b32284ff4e2a43762199b6770665" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/modality.html&quot;&gt;modal dialog&lt;/a&gt; offers the easy opportunity to focus attention on the content of that dialog - choose/fix/cancel this, &lt;strong&gt;then&lt;/strong&gt; proceed.  Multiple frames do not.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/modality.html&quot;&gt;모달 대화 상자&lt;/a&gt; 는 해당 대화 상자의 내용에 집중할 수있는 쉬운 기회를 제공합니다.이를 선택 / 수정 / 취소 &lt;strong&gt;한 다음&lt;/strong&gt; 진행하십시오. 여러 프레임은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77810e31cc11f1c6c67cebac737ee31a02924ebe" translate="yes" xml:space="preserve">
          <source>A dialog (or floating tool-bar) with a parent will come to front when the parent is clicked on - you'd have to implement that in frames if that was the desired behavior.</source>
          <target state="translated">부모를 클릭하면 부모가있는 대화 상자 (또는 플로팅 도구 모음)가 맨 앞에 나타납니다. 원하는 동작 인 경우 프레임으로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="52189483e5b90097f0c12c725e7468b27890f539" translate="yes" xml:space="preserve">
          <source>A few months ago we started getting requests from our customers to make these report viewer windows modeless, so that they could have multiple reports open at the same time.</source>
          <target state="translated">몇 달 전에 고객의 요청에 따라 이러한 보고서 뷰어 창을 모달리스로 만들었으므로 동시에 여러 보고서를 열 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="668c86d396f1672863ae5b4773825a8d5d39ac9b" translate="yes" xml:space="preserve">
          <source>A great example of multiple frames/single document per frame (&lt;a href=&quot;http://en.wikipedia.org/wiki/Single_document_interface&quot;&gt;SDI&lt;/a&gt;) vs single frame/multiple documents per frame (&lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_document_interface&quot;&gt;MDI&lt;/a&gt;) is Microsoft Excel. Some of MDI benefits:</source>
          <target state="translated">다중 프레임 / &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_document_interface&quot;&gt;SDI&lt;/a&gt; 당 단일 문서 ( SDI ) 대 단일 프레임 / 프레임 당 다중 문서 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_document_interface&quot;&gt;MDI&lt;/a&gt; )의 좋은 예는 Microsoft Excel입니다. 일부 MDI 혜택 :</target>
        </trans-unit>
        <trans-unit id="481be78e172b7c4c1ccc2711164c06866ca4de84" translate="yes" xml:space="preserve">
          <source>A nightmare to code and maintain:</source>
          <target state="translated">코딩하고 유지해야하는 악몽 :</target>
        </trans-unit>
        <trans-unit id="81e29999fc6773f2d1b64774d9f19aac3a5acde1" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;JLabel&lt;/code&gt; (centered in a scroll pane) to display whichever image the user is interested in at that moment.  As seen in &lt;a href=&quot;https://stackoverflow.com/a/13463684/418556&quot;&gt;&lt;code&gt;ImageViewer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 &lt;code&gt;JLabel&lt;/code&gt; (스크롤 창 중앙에 있음)은 사용자가 그 시점에 관심있는 이미지를 표시합니다. &lt;a href=&quot;https://stackoverflow.com/a/13463684/418556&quot;&gt; &lt;code&gt;ImageViewer&lt;/code&gt; &lt;/a&gt; 에서 볼 수 있듯이.</target>
        </trans-unit>
        <trans-unit id="bbb2bffa61ffc5da7a6aa465611d7a0863e77051" translate="yes" xml:space="preserve">
          <source>A single row &lt;code&gt;JList&lt;/code&gt;. As seen in &lt;a href=&quot;https://stackoverflow.com/a/9544652/418556&quot;&gt;this answer&lt;/a&gt;.  The 'single row' part of that only works if they are all the same dimensions.  Alternately, if you are prepared to scale the images on the fly, and they are all the same aspect ratio (e.g. 4:3 or 16:9).</source>
          <target state="translated">단일 행 &lt;code&gt;JList&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/9544652/418556&quot;&gt;이 답변&lt;/a&gt; 에서 볼 수 있듯이. 그 '단일 행'부분은 모두 같은 치수 인 경우에만 작동합니다. 또는 이미지를 즉석에서 스케일링 할 준비가되어 있고 모두 동일한 종횡비 (예 : 4 : 3 또는 16 : 9) 인 경우.</target>
        </trans-unit>
        <trans-unit id="dc55daa7dd0a9587b2c55b293fa2cc08de97b8cf" translate="yes" xml:space="preserve">
          <source>Also we can switch between this &lt;code&gt;JPanel&lt;/code&gt;s. So it gives us freedom to display more than on thing in the &lt;code&gt;JFrame&lt;/code&gt;.</source>
          <target state="translated">또한이 &lt;code&gt;JPanel&lt;/code&gt; 사이를 전환 할 수 있습니다. 따라서 &lt;code&gt;JFrame&lt;/code&gt; 에있는 것보다 더 많은 것을 자유롭게 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="235a62d33b197f5e505ad2f49140e11726f388af" translate="yes" xml:space="preserve">
          <source>As items in a &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/list.html&quot;&gt;&lt;code&gt;JList&lt;/code&gt;&lt;/a&gt; (simple example below).</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/list.html&quot;&gt; &lt;code&gt;JList&lt;/code&gt; 의&lt;/a&gt; 항목으로 (아래 간단한 예).</target>
        </trans-unit>
        <trans-unit id="b88696386beb9499cee8e8d14cb2dbe189e4727c" translate="yes" xml:space="preserve">
          <source>As nodes in a &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;&lt;code&gt;JTree&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt; &lt;code&gt;JTree&lt;/code&gt; &lt;/a&gt; 내의 노드로서.</target>
        </trans-unit>
        <trans-unit id="fa88a229b782b18f180bc35ea575c9856c05f12d" translate="yes" xml:space="preserve">
          <source>Bad (bad, bad) practice.</source>
          <target state="translated">나쁜 (나쁜, 나쁜) 연습.</target>
        </trans-unit>
        <trans-unit id="2d4d395e63075e1d369f76a05fc7ad4309ce2242" translate="yes" xml:space="preserve">
          <source>Bad practice definitely. One reason is that it is not very 'user-friendly' for the fact that every &lt;code&gt;JFrame&lt;/code&gt; shows a new taskbar icon. Controlling multiple &lt;code&gt;JFrame&lt;/code&gt;s will have you ripping your hair out.</source>
          <target state="translated">확실히 나쁜 연습. 한 가지 이유는 모든 &lt;code&gt;JFrame&lt;/code&gt; 에 새 작업 표시 줄 아이콘이 표시되기 때문에 사용자에게 친숙하지 않기 때문입니다. 여러 개의 &lt;code&gt;JFrame&lt;/code&gt; 을 제어하면 머리카락을 찢을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b7e32b0d0b98dfd1849893ada1230a6994eabe" translate="yes" xml:space="preserve">
          <source>But if those strategies do not work for a particular use-case, try the following.  Establish a single main &lt;code&gt;JFrame&lt;/code&gt;, then have &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/dialog.html&quot;&gt;&lt;code&gt;JDialog&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/dialog.html#features&quot;&gt;&lt;code&gt;JOptionPane&lt;/code&gt;&lt;/a&gt; instances appear for the rest of the free-floating elements, using the frame as the parent for the dialogs.</source>
          <target state="translated">그러나 이러한 전략이 특정 사용 사례에서 작동하지 않으면 다음을 시도하십시오. 단일 기본 &lt;code&gt;JFrame&lt;/code&gt; 을 설정 한 다음 프레임을 대화 상자의 부모로 사용하여 나머지 자유 부동 요소에 대해 &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/dialog.html&quot;&gt; &lt;code&gt;JDialog&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/dialog.html#features&quot;&gt; &lt;code&gt;JOptionPane&lt;/code&gt; &lt;/a&gt; 인스턴스가 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="372547561d143dc46d276e8a37f9d3e37875665f" translate="yes" xml:space="preserve">
          <source>But its better to change one &lt;code&gt;JFrame&lt;/code&gt; for our different needs rather than having multiple &lt;code&gt;JFrame&lt;/code&gt;s.</source>
          <target state="translated">그러나 여러 &lt;code&gt;JFrame&lt;/code&gt; 을 사용하는 것보다 다른 요구에 따라 하나의 &lt;code&gt;JFrame&lt;/code&gt; 을 변경하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8b7b9110186106fbc6770f355b804553c6609a8c" translate="yes" xml:space="preserve">
          <source>Displaying list, tree etc. selections for items that have an associated component.</source>
          <target state="translated">연관된 컴포넌트가있는 항목에 대한 목록, 트리 등 선택 사항 표시</target>
        </trans-unit>
        <trans-unit id="f20aa55ef6fcf5d4c20d52e4186907ac6e4f6540" translate="yes" xml:space="preserve">
          <source>Flipping between no component and visible component.</source>
          <target state="translated">구성 요소가없는 것과 보이는 구성 요소 사이를 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="e964c3e4f6b23a66ecbd023460578f171f5d331e" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;JPanel&lt;/code&gt; we can design different things and all this &lt;code&gt;JPanel&lt;/code&gt; can be displayed on the single &lt;code&gt;JFrame&lt;/code&gt;one at a time.</source>
          <target state="translated">각 &lt;code&gt;JPanel&lt;/code&gt; 마다 서로 다른 것을 디자인 할 수 있으며이 JPanel 을 한 번에 하나씩 단일 &lt;code&gt;JFrame&lt;/code&gt; 에 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38348ede1c8912649e35d338068ca9b9b1ed3244" translate="yes" xml:space="preserve">
          <source>For modeless dialogs, pass a null parent to the constructor, but locate them relative to their 'parent' window.</source>
          <target state="translated">모덜리스 대화 상자의 경우 null 부모를 생성자에 전달하지만 '부모'창을 기준으로 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c62455a2a5cd91e7727a1d98153de9e332b98738" translate="yes" xml:space="preserve">
          <source>For some time I resisted this request as I did not think this was a good solution. However, my mind was changed when I found out how the users were getting around this 'deficiency' of our system.</source>
          <target state="translated">나는 이것이 좋은 해결책이라고 생각하지 않았기 때문에이 요청에 저항했습니다. 그러나 사용자가 시스템의 '결함'을 어떻게 극복하고 있는지 알게되면서 마음이 바뀌 었습니다.</target>
        </trans-unit>
        <trans-unit id="c191869b8a33edda7cdd405128b0e40442840200" translate="yes" xml:space="preserve">
          <source>I think using multiple &lt;code&gt;Jframe&lt;/code&gt;s is not a good idea.</source>
          <target state="translated">여러 &lt;code&gt;Jframe&lt;/code&gt; 을 사용하는 것은 좋은 생각이 아니라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="47beb323263604d1b1e5e6f6e5c6d3e720f4a9d6" translate="yes" xml:space="preserve">
          <source>I'd like to counter the &quot;not user friendly&quot; argument with an example that I have just been involved with.</source>
          <target state="translated">방금 관련된 예제와 함께 &quot;사용자 친화적이지 않은&quot;논증에 반대하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="1af47f037ee6de340a78c3f8c81dbe89cae14102" translate="yes" xml:space="preserve">
          <source>I'm developing an application which displays images, and plays sounds from a database. I'm trying to decide whether or not to use a separate JFrame to add images to the database from the GUI.</source>
          <target state="translated">이미지를 표시하고 데이터베이스에서 소리를 재생하는 응용 프로그램을 개발 중입니다. GUI에서 데이터베이스에 이미지를 추가하기 위해 별도의 JFrame을 사용할지 여부를 결정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e4ec08d035a2860eaee2641f5d1b48e4d2025766" translate="yes" xml:space="preserve">
          <source>I'm just wondering whether it is good practice to use multiple JFrame windows?</source>
          <target state="translated">여러 JFrame 창을 사용하는 것이 좋은지 궁금합니다.</target>
        </trans-unit>
        <trans-unit id="6166fff8262f4671ea4124eb1c4dce25116ab7c4" translate="yes" xml:space="preserve">
          <source>I'm just wondering whether it is good practice to use multiple JFrames?</source>
          <target state="translated">여러 JFrame을 사용하는 것이 좋은 방법인지 궁금합니다.</target>
        </trans-unit>
        <trans-unit id="70109a724c8dab00d6202da1795974ff980336d6" translate="yes" xml:space="preserve">
          <source>I've written a lot and I feel like I could write more. Anyways, I hope I don't get down-voted simply because it's an unpopular opinion. The question is clearly a valuable one and I hope I've provided a valuable answer, even if it isn't the common opinion.</source>
          <target state="translated">많이 썼는데 더 쓸 수있을 것 같아요. 어쨌든, 나는 그것이 인기가없는 의견이기 때문에 단순히 투표를받지 않기를 바랍니다. 질문은 분명히 귀중한 것이며 일반적인 의견이 아닌 경우에도 귀중한 답변을 제공했으면합니다.</target>
        </trans-unit>
        <trans-unit id="c11d1eae3222d1ad420eabf6693a1a8a14bc6ddf" translate="yes" xml:space="preserve">
          <source>If the frames are going to be the same size, why not create the frame and pass the frame then as a reference to it instead.</source>
          <target state="translated">프레임의 크기가 같으면 프레임을 만들고 프레임을 참조로 전달하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d8eca14de00affb5abab3c716277e3216fff2b85" translate="yes" xml:space="preserve">
          <source>In our application we have a main window where the users run various 'programs' as separate tabs. As much as possible we have tried to keep our application to this single window.</source>
          <target state="translated">우리의 응용 프로그램에는 사용자가 다양한 '프로그램'을 별도의 탭으로 실행하는 기본 창이 있습니다. 우리는 가능한 한이 응용 프로그램을이 단일 창에 유지하려고 노력했습니다.</target>
        </trans-unit>
        <trans-unit id="70c20b9a9bc2f25260461351498ba9aef81d17b2" translate="yes" xml:space="preserve">
          <source>In this case where the multiple elements are images, it would be better to use either of the following instead:</source>
          <target state="translated">여러 요소가 이미지 인 경우 대신 다음 중 하나를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ede8b7972234cfca52cc35fd271479bfd7c63d76" translate="yes" xml:space="preserve">
          <source>Instead we can use &lt;code&gt;JPanel&lt;/code&gt;s more than one or more &lt;code&gt;JPanel&lt;/code&gt; in the same &lt;code&gt;JFrame&lt;/code&gt;.</source>
          <target state="translated">대신 같은 &lt;code&gt;JFrame&lt;/code&gt; 에서 &lt;code&gt;JPanel&lt;/code&gt; 을 하나 이상의 JPanel 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f41475e79339890879ae861045ad68c3e7bd735" translate="yes" xml:space="preserve">
          <source>It is not a good practice but even though you wish to use it you can use the singleton pattern as its good. I have used the singleton patterns in most of my project its good.</source>
          <target state="translated">좋은 방법은 아니지만 사용하려는 경우에도 싱글 톤 패턴을 좋은 것으로 사용할 수 있습니다. 나는 대부분의 프로젝트에서 싱글 톤 패턴을 사용했다.</target>
        </trans-unit>
        <trans-unit id="80e6f7ce8bf052de169f73af25b368215b3c8388" translate="yes" xml:space="preserve">
          <source>It seems to be best practice to use JDialog's for these modeless windows</source>
          <target state="translated">이 모덜리스 창에 JDialog를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="298c9c67ea16ba4bc93f201fc45211b386669a87" translate="yes" xml:space="preserve">
          <source>It's been a while since the last time i touch swing but in general is a bad practice to do this. Some of the main disadvantages that comes to mind:</source>
          <target state="translated">내가 스윙을 만지는 마지막 시간이 지났지 만 일반적 으로이 작업을 수행하는 것은 나쁜 습관입니다. 염두에 두어야 할 주요 단점 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7df5571c3f2bc8c6d0d8d7e5164858995ac3c72" translate="yes" xml:space="preserve">
          <source>MDI (Multiple-Document Interface, i.e., every window can have multiple documents):</source>
          <target state="translated">MDI (여러 문서 인터페이스, 즉 모든 창에 여러 문서가있을 수 있음) :</target>
        </trans-unit>
        <trans-unit id="c041fbc6f6d5e8180164af2e81ff649862ed2f1c" translate="yes" xml:space="preserve">
          <source>Make an jInternalFrame into main frame and make it invisible. Then you can use it for further events.</source>
          <target state="translated">jInternalFrame을 메인 프레임으로 만들어 보이지 않게하십시오. 그런 다음 추가 이벤트에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19799c5d85ff59ea7febea012652a9f4974c293e" translate="yes" xml:space="preserve">
          <source>Many images</source>
          <target state="translated">많은 이미지</target>
        </trans-unit>
        <trans-unit id="abe5bc4e611a570041b7ddf07077ea1fc14ea933" translate="yes" xml:space="preserve">
          <source>More than one &lt;code&gt;JFrame&lt;/code&gt; is not a good practice, but there is nothing wrong if we want more than one &lt;code&gt;JFrame&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 &lt;code&gt;JFrame&lt;/code&gt; 이 좋은 방법은 아니지만 하나 이상의 &lt;code&gt;JFrame&lt;/code&gt; 을 원한다면 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c6983f6b6fab768e218346da2e077d79ea85ffb" translate="yes" xml:space="preserve">
          <source>Multiple JFrame objects = Pain, trouble, and problems.</source>
          <target state="translated">여러 JFrame 객체 = 통증, 문제 및 문제</target>
        </trans-unit>
        <trans-unit id="aa24bb0d2031831f6d23f49b9461a627edcfa34d" translate="yes" xml:space="preserve">
          <source>One of the 'programs' they run presents a list of reports that have been generated by the system, and the user can click on an icon on each line to pop open a report viewer dialog. This viewer is showing the equivalent of the portrait/landscape A4 page(s) of the report, so the users like this window to be quite big, almost filling their screens.</source>
          <target state="translated">그들이 실행하는 '프로그램'중 하나는 시스템에 의해 생성 된 보고서 목록을 제공하며, 사용자는 각 라인에서 아이콘을 클릭하여 보고서 뷰어 대화 상자를 열 수 있습니다. 이 뷰어는 보고서의 세로 / 가로 A4 페이지와 동일하게 표시되므로이 창을 좋아하는 사용자는 화면을 거의 채우면서 상당히 커집니다.</target>
        </trans-unit>
        <trans-unit id="455bf84971f11c9b9b4e73032d41fc1c9c19bc5c" translate="yes" xml:space="preserve">
          <source>Personally, I would use ONE &lt;code&gt;JFrame&lt;/code&gt; for your kind of application. Methods of displaying multiple things is up to you, there are many. &lt;code&gt;Canvas&lt;/code&gt;es, &lt;code&gt;JInternalFrame&lt;/code&gt;, &lt;code&gt;CardLayout&lt;/code&gt;, even &lt;code&gt;JPanel&lt;/code&gt;s possibly.</source>
          <target state="translated">개인적으로, 나는 당신의 응용 프로그램에 ONE &lt;code&gt;JFrame&lt;/code&gt; 을 사용합니다. 여러 가지를 표시하는 방법은 당신에게 달려 있습니다. &lt;code&gt;Canvas&lt;/code&gt; es, &lt;code&gt;JInternalFrame&lt;/code&gt; , &lt;code&gt;CardLayout&lt;/code&gt; , 심지어 &lt;code&gt;JPanel&lt;/code&gt; 도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a02280d6357b0974accd403fc8e774f7f619fe2c" translate="yes" xml:space="preserve">
          <source>SDI (Single-Document Interface, i.e., every window can only have a single document):</source>
          <target state="translated">SDI (단일 문서 인터페이스, 즉 모든 창에는 단일 문서 만있을 수 있음) :</target>
        </trans-unit>
        <trans-unit id="21804c77671ee36486bcf0c9bf85e5d1f9e47d65" translate="yes" xml:space="preserve">
          <source>SOME NOTES:</source>
          <target state="translated">몇 가지 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="c99545794d629ad61770e4f2281ea9d1b95b7c1b" translate="yes" xml:space="preserve">
          <source>Showing wizard like dialogs.</source>
          <target state="translated">대화 상자와 같은 마법사 표시</target>
        </trans-unit>
        <trans-unit id="0bf5dabc7cb7282680a7e0e93e293d6b01de6405" translate="yes" xml:space="preserve">
          <source>So I relented and made the viewer modeless. This means that each viewer has a task-bar icon.</source>
          <target state="translated">그래서 나는 시청자를 무모하게 만들었습니다. 이는 각 뷰어에 작업 표시 줄 아이콘이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9969b7a30e587dc86c6ccd9bc10943865a3888d2" translate="yes" xml:space="preserve">
          <source>So you go ahead and tell your users that what they want is bad, but ultimately it won't do you any favours.</source>
          <target state="translated">따라서 사용자가 원하는 것이 나쁘다는 것을 사용자에게 알리지 만 궁극적으로는 그다지 좋아하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da7bec0bb8499c9086a991e52be889b85f7197bc" translate="yes" xml:space="preserve">
          <source>So, I'm going to explain the benefits of the multiple &lt;code&gt;JFrame&lt;/code&gt; approach, as well as myth-bust some of the cons that others have presented.</source>
          <target state="translated">그래서 다중 &lt;code&gt;JFrame&lt;/code&gt; 접근 방식의 장점과 다른 사람들이 제시 한 단점을 신화 적으로 설명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="9555a28c03ec4e74732765af9fd7a7315e2519fd" translate="yes" xml:space="preserve">
          <source>The Use of Multiple JFrames: Good or Bad Practice</source>
          <target state="translated">여러 JFrame 사용 : 좋은 습관 또는 나쁜 습관</target>
        </trans-unit>
        <trans-unit id="ceb502ac410c531592f1d728b268dd2b741ea8a0" translate="yes" xml:space="preserve">
          <source>The multiple &lt;code&gt;JFrame&lt;/code&gt; approach has been something I've implemented since I began programming Swing apps. For the most part, I did it in the beginning because I didn't know any better. &lt;strong&gt;However&lt;/strong&gt;, as I matured in my experience and knowledge as a developer and as began to read and absorb the opinions of so many more experienced Java devs online, I made an attempt to &lt;strong&gt;shift away&lt;/strong&gt; from the multiple &lt;code&gt;JFrame&lt;/code&gt; approach (both in current projects and future projects) only to be met with... get this... &lt;em&gt;resistance from my clients!&lt;/em&gt; As I began implementing modal dialogs to control &quot;child&quot; windows and &lt;code&gt;JInternalFrame&lt;/code&gt;s for separate components, &lt;strong&gt;my clients began to complain!&lt;/strong&gt; I was quite surprised, as I was doing what I thought was best-practice! But, as they say, &quot;A happy wife is a happy life.&quot; Same goes for your clients. Of course, I am a contractor so my end-users have direct access to me, the developer, which is obviously not a common scenario.</source>
          <target state="translated">다중 &lt;code&gt;JFrame&lt;/code&gt; 접근 방식은 Swing 앱 프로그래밍을 시작한 이래 구현 한 것입니다. 대부분, 나는 더 잘 몰랐기 때문에 처음에 해냈습니다. &lt;strong&gt;그러나&lt;/strong&gt; 개발자로서의 경험과 지식을 발전시키고 더 많은 Java 개발자의 의견을 온라인에서 읽고 흡수하기 시작하면서 여러 &lt;code&gt;JFrame&lt;/code&gt; 접근 방식에서 &lt;strong&gt;벗어나기&lt;/strong&gt; 위해 노력했습니다 (현재 프로젝트와 미래 모두에서) 프로젝트) 만 충족 ...이 얻을 ... &lt;em&gt;내 고객의 저항!&lt;/em&gt; 별도의 구성 요소에 대한 &quot;자식&quot;창과 &lt;code&gt;JInternalFrame&lt;/code&gt; 을 제어하기 위해 모달 대화 상자를 구현 &lt;strong&gt;하기 시작하면서 고객이 불만을 제기하기 시작했습니다!&lt;/strong&gt; 내가 최선의 방법이라고 생각한 것을하고 있었기 때문에 나는 매우 놀랐다! 그러나 그들이 말하는 것처럼 &quot;행복한 아내는 행복한 삶입니다.&quot; 고객도 마찬가지입니다. 물론, 계약자이므로 최종 사용자가 개발자 인 본인에게 직접 액세스 할 수 있습니다. 이는 일반적인 시나리오가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cc0f517ed38d5dc4aee1525800cb76944363c44a" translate="yes" xml:space="preserve">
          <source>There are any number of ways of displaying many elements in one GUI, e.g.:</source>
          <target state="translated">하나의 GUI에 많은 요소를 표시하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="876809a0777c1f327a13c68dfb31e3a3b557deed" translate="yes" xml:space="preserve">
          <source>They were opening a viewer, using the 'Save As' facility to save the report as a PDF to a specific directory, using Acrobat Reader to open the PDF file, and then they would do the same with the next report. They would have multiple Acrobat Readers running with the various report outputs that they wanted to look at.</source>
          <target state="translated">'다른 이름으로 저장'기능을 사용하여 보고서를 특정 디렉토리에 PDF로 저장하고 Acrobat Reader를 사용하여 PDF 파일을 연 다음 뷰어와 동일한 방식으로 뷰어를 열었습니다. 보고자하는 다양한 보고서 출력으로 여러 개의 Acrobat Reader를 실행하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="07adcf3f02b71244d6c5593ea0fb0de89ed0f816" translate="yes" xml:space="preserve">
          <source>To switch between this &lt;code&gt;JPanel&lt;/code&gt;s use &lt;code&gt;JMenuBar&lt;/code&gt; with &lt;code&gt;JMenuItems&lt;/code&gt; for each &lt;code&gt;JPanel&lt;/code&gt;or 'JButton&lt;code&gt;for each&lt;/code&gt;JPanel`.</source>
          <target state="translated">이 &lt;code&gt;JPanel&lt;/code&gt; 사이를 전환하려면 각 &lt;code&gt;JPanel&lt;/code&gt; 에 &lt;code&gt;JMenuItems&lt;/code&gt; 가있는 &lt;code&gt;JMenuBar&lt;/code&gt; 를 사용하거나 각 JPanel &lt;code&gt;for each&lt;/code&gt; JButton 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="1ef67bd016d5084cd1dc89a3544f7b7deae7f76c" translate="yes" xml:space="preserve">
          <source>Use the constructors that use the new &lt;code&gt;ModalityType&lt;/code&gt; rather than the boolean &lt;code&gt;modal&lt;/code&gt; argument. This is what gives these dialogs the task-bar icon.</source>
          <target state="translated">부울 &lt;code&gt;modal&lt;/code&gt; 인수 대신 새 &lt;code&gt;ModalityType&lt;/code&gt; 을 사용하는 생성자를 사용하십시오. 이 대화 상자에 작업 표시 줄 아이콘이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="37df70d866bcd3bb36a8422c910e346f9cb84c7b" translate="yes" xml:space="preserve">
          <source>User unfriendly: The user sees multiple icons in their task bar when expecting to see only one.  Plus the side effects of the coding problems..</source>
          <target state="translated">사용자에게 친숙하지 않음 : 사용자에게는 하나만 표시 될 때 작업 표시 줄에 여러 개의 아이콘이 표시됩니다. 또한 코딩 문제의 부작용 ..</target>
        </trans-unit>
        <trans-unit id="ba1a9fa2fb40926910838f2b5d2d0d17281ee5e1" translate="yes" xml:space="preserve">
          <source>Version 6 of Java on Windows has a &lt;a href=&quot;http://bugs.sun.com/view_bug.do?bug_id=6829546&quot;&gt;bug&lt;/a&gt; which means that your main window can become 'always on top' without you telling it. Upgrade to version 7 to fix this</source>
          <target state="translated">Windows의 Java 버전 6에는 &lt;a href=&quot;http://bugs.sun.com/view_bug.do?bug_id=6829546&quot;&gt;버그&lt;/a&gt; 가 있으므로 기본 창을 알리지 않고 '항상 맨 위에'있을 수 있습니다. 이 문제를 해결하려면 버전 7로 업그레이드</target>
        </trans-unit>
        <trans-unit id="5727d35c6ceab167cf86a91daab09b3830139fa4" translate="yes" xml:space="preserve">
          <source>When the latest version was released to them last week, the overwhelming response from them is that they LOVE it. It's been one of our most popular recent enhancements to the system.</source>
          <target state="translated">지난 주에 최신 버전이 출시되었을 때, 그들로부터 압도적 인 반응은 그들이 그것을 좋아한다는 것입니다. 최근 가장 많이 개선 된 시스템 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="bfe52204fef7c1c1111b24e5c4b045c5b10d5af6" translate="yes" xml:space="preserve">
          <source>When you have passed the frame you can then decide how to populate it. It would be like having a method for calculating the average of a set of figures. Would you create the method over and over again?</source>
          <target state="translated">프레임을 통과하면 프레임을 채우는 방법을 결정할 수 있습니다. 그림 집합의 평균을 계산하는 방법을 갖는 것과 같습니다. 메소드를 반복해서 작성 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="9e6d5433c3d8befdb496a1390c3d98c9e607a226" translate="yes" xml:space="preserve">
          <source>it is possible to have a few windows in non rectangular shape - so they don't hide desktop or other window from another process (e.g. web browser)</source>
          <target state="translated">직사각형이 아닌 몇 개의 창을 가질 수 있으므로 다른 프로세스 (예 : 웹 브라우저)에서 데스크탑 또는 다른 창을 숨기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63c50400e1490c23c20ab019c4988e31ae00c26c" translate="yes" xml:space="preserve">
          <source>it is possible to have different documents on different screens, which is especially useful when screens do not have the same resolution</source>
          <target state="translated">화면마다 다른 문서를 가질 수 있으며, 화면의 해상도가 같지 않을 때 특히 유용합니다</target>
        </trans-unit>
        <trans-unit id="d0f48a7c2e4973a385323f0ad23b27b44b967cb3" translate="yes" xml:space="preserve">
          <source>it is possible to open a window from another process over one Excel window while writing in second Excel window - with MDI, trying to write in one of internal windows will give focus to the entire Excel window, hence hiding window from another process</source>
          <target state="translated">두 번째 Excel 창에서 쓰는 동안 하나의 Excel 창에서 다른 프로세스의 창을 열 수 있습니다. MDI를 사용하면 내부 창 중 하나에 쓰려고하면 전체 Excel 창에 초점이 표시되므로 다른 프로세스에서 창을 숨길 수 있습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
