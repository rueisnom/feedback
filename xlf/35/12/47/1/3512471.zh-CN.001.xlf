<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3512471">
    <body>
      <group id="3512471">
        <trans-unit id="bcf0d126ecf0118f14796b2398997a40ae04dbcd" translate="yes" xml:space="preserve">
          <source>... I would get the following result:</source>
          <target state="translated">...我将得到以下结果:</target>
        </trans-unit>
        <trans-unit id="e676d3c3446448a15304f4211ad1b20f882e04f5" translate="yes" xml:space="preserve">
          <source>... over it, we are trying to use the first group, add an underscore, use the third group, then the second group, add another underscore, and then the fourth group. The resulting string would be like the one below.</source>
          <target state="translated">....在它上面,我们试图使用第一组,加一个下划线,使用第三组,然后是第二组,再加一个下划线,然后是第四组。这样得到的字符串就像下面的字符串一样。</target>
        </trans-unit>
        <trans-unit id="8d7b22b0b137294fd5060dc96e83c2e36087c17e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;([A-Z][A-Z0-9]*)\b[^&amp;gt;]*&amp;gt;.*?&amp;lt;/\1&amp;gt;&lt;/code&gt;  [ Finds an xml tag (without ns support) ]</source>
          <target state="translated">&lt;code&gt;&amp;lt;([A-Z][A-Z0-9]*)\b[^&amp;gt;]*&amp;gt;.*?&amp;lt;/\1&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; [查找xml标记（不支持ns）]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d6e0fe4cd1a0261b6f7dffe18465ce0c6bd73555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(,)&lt;/code&gt;--&amp;gt; Captured Group 2</source>
          <target state="translated">&lt;code&gt;(,)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&amp;gt;捕获的组2&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b87d78ba8679f96c2130a3dbc6e88950fee8228" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?:=)&lt;/code&gt;--&amp;gt; Non-Captured Group 2</source>
          <target state="translated">&lt;code&gt;(?:=)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&amp;gt;非捕获组2&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f413d73a52a778e7fb5b3df9208b4ab712159ac3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(?:animal)&lt;/code&gt; --&amp;gt; Non-Captured Group 1</source>
          <target state="translated">&lt;code&gt;(?:animal)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&amp;gt;未捕获的组1&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0b7963c035deb8fbc21e44b7caa16b852993ff4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;([A-Z][A-Z0-9]*)&lt;/code&gt; is a capturing group (in this case it is the tagname)</source>
          <target state="translated">&lt;code&gt;([A-Z][A-Z0-9]*)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个捕获组（在这种情况下，它是标记名）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b68561957d734503999badcc4801abfc5e772b12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(\w+)&lt;/code&gt;--&amp;gt; Captured Group 1</source>
          <target state="translated">&lt;code&gt;(\w+)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&amp;gt;捕获的组1&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d61c24f1edc0bdca1ad0588eda1164c670624b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?:&lt;/code&gt; is used when you want to group an expression, but you do not want to save it as a matched/captured portion of the string.</source>
          <target state="translated">&lt;code&gt;?:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用于将表达式分组，但又不想将其另存为字符串的匹配/捕获部分时使用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9754acdd6f94185fe697370370027059e969e2d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\1&lt;/code&gt; --&amp;gt; result of captured group 1 i.e In Line 1 is cat, In Line 2 is cat, In Line 3 is dog.</source>
          <target state="translated">&lt;code&gt;\1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;gt;捕获的组1的结果，即第1行是cat，在第2行是cat，在第3行是dog。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="627a7a83cc0fc15be9e5f95c9c58a8fc0bb38fc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\2&lt;/code&gt; --&amp;gt; result of captured group 2 i.e comma (,)</source>
          <target state="translated">&lt;code&gt;\2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;gt;捕获的组2的结果，即逗号（，）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="772db0e3b9f2b34f24b763cded895c8fddc1e5b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hope this explains the use of non capturing group.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;希望这解释了非捕获组的使用。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f71ecb148d8f60d740e36bab1c15ed940f0c5d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let me try this with an example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;让我用一个例子尝试一下：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75885fa7b4b4d05f5599fa72d28b180a52274c86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Search String:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;搜索字符串：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e74407f6e0ab790de8a950e7d4735f204a851f27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, the output will be as below:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，输出将如下所示：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8036b5b4c918d300090aa8d7a6011feed1eb6ef3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr&lt;/strong&gt; non-capturing groups, as the name suggests are the parts of the regex that you do not want to be included in the match and &lt;code&gt;?:&lt;/code&gt; is a way to define a group as being non-capturing.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tl; dr&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非捕获组，顾名思义是不希望包含在匹配中的正则表达式部分，而&lt;/font&gt;&lt;/font&gt; &lt;code&gt;?:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是将组定义为非捕获组的一种方式。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b862ccef0aa65d103454beb2c0a3b6164a052d1e" translate="yes" xml:space="preserve">
          <source>An example would be something to match an IP address:</source>
          <target state="translated">一个例子是匹配IP地址的东西。</target>
        </trans-unit>
        <trans-unit id="c7b878320593df0bcf3070cb1d7927cca232be0b" translate="yes" xml:space="preserve">
          <source>As per the order of code &lt;code&gt;(?:animal)&lt;/code&gt; should be group 1 and &lt;code&gt;(?:=)&lt;/code&gt; should be group 2 and continues..</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;按照代码的顺序&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:animal)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该是组1，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:=)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该是2组并继续。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a92a14f93428452b73ba027e5dca4c177ffbb9b8" translate="yes" xml:space="preserve">
          <source>As requested, let me try to explain groups too.</source>
          <target state="translated">按照要求,让我也试着给大家解释一下。</target>
        </trans-unit>
        <trans-unit id="b609a4cf5e3a806bf6ea63e5189d426110b52753" translate="yes" xml:space="preserve">
          <source>But I don't care about the protocol -- I just want the host and path of the URL. So, I change the regex to include the non-capturing group &lt;code&gt;(?:)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是我不在乎协议-我只想要URL的主机和路径。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，我将正则表达式更改为包括非捕获组&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd1c31df99c682d3fcad72a5e0aa95676b0bee1f" translate="yes" xml:space="preserve">
          <source>Consider a scenario where you want to match &lt;code&gt;cat is animal&lt;/code&gt;
when you would like match cat and animal and both should have a &lt;code&gt;is&lt;/code&gt; in between them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑要匹配的情景&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cat is animal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ，当你想匹配的猫和动物两者都应该有一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;is&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在他们之间。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5b1e5874ffbd61df419bd16b3496a99760914305" translate="yes" xml:space="preserve">
          <source>Consider the expressions &lt;code&gt;(a|b)c&lt;/code&gt; and &lt;code&gt;a|bc&lt;/code&gt;, due to priority of concatenation over &lt;code&gt;|&lt;/code&gt;, these expressions represent two different languages (&lt;code&gt;{ac, bc}&lt;/code&gt; and &lt;code&gt;{a, bc}&lt;/code&gt; respectively).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;串联&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a|b)c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a|bc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优先级&lt;/font&gt;&lt;/font&gt; &lt;code&gt;|&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这些表达式代表两种不同的语言（分别为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;{ac, bc}&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;{a, bc}&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="264905281596046843b12de293d71e42b7e7688d" translate="yes" xml:space="preserve">
          <source>Consider the following text:</source>
          <target state="translated">请考虑以下案文:</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="bf23515c405d573441877e64b3bcc3048bf11b42" translate="yes" xml:space="preserve">
          <source>Example of using later on in the regex (backreference):</source>
          <target state="translated">在后面的regex(backreference)中使用的例子。</target>
        </trans-unit>
        <trans-unit id="4d143a48e760953f2206a56df2a4440e50f1f46f" translate="yes" xml:space="preserve">
          <source>Groups that &lt;strong&gt;capture&lt;/strong&gt; you can use later on in the regex to match &lt;strong&gt;OR&lt;/strong&gt; you can use them in the replacement part of the regex.  Making a &lt;strong&gt;non-capturing&lt;/strong&gt; group simply exempts that group from being used for either of these reasons.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这组&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;拍摄&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，你可以稍后在使用正则表达式匹配&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或者&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;你可以在正则表达式的替换零件使用它们。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;建立一个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非捕获&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组只是出于以下两个原因之一而免除了该组的使用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1b6cc0dc3dd4dd8335f0eae667eaa49d2144ff7" translate="yes" xml:space="preserve">
          <source>HISTORICAL MOTIVATION:</source>
          <target state="translated">历史动机。</target>
        </trans-unit>
        <trans-unit id="213aee9e28e115d3ca4ebcad92457d21b2b7d23c" translate="yes" xml:space="preserve">
          <source>How are non-capturing groups, i.e. &lt;code&gt;(?:)&lt;/code&gt;, used in regular expressions and what are they good for?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非捕获组（即&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）如何在正则表达式中使用，它们有什么用？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="224d7bd00a2a5cf12a7b471ed8d149017cff7c49" translate="yes" xml:space="preserve">
          <source>However, the parenthesis are also used as a matching group (as explained by the other answers...).</source>
          <target state="translated">不过,括号也是作为搭配组(由其他答案解释...)。</target>
        </trans-unit>
        <trans-unit id="3ab0fc4bdf1f3f852c478c53fe809cbcf1b57a77" translate="yes" xml:space="preserve">
          <source>I cannot comment on the top answers to say this: I would like to add an explicit point which is only implied in the top answers:</source>
          <target state="translated">我无法对上面的答案进行评论,只能这样说。我想补充一点,这一点只在上面的答案中隐含着。</target>
        </trans-unit>
        <trans-unit id="278b25ea15e8f1a2876947ecd7cf6f00824ee9c6" translate="yes" xml:space="preserve">
          <source>I think I would give you the answer. Don't use capture variables without checking that the match succeeded.</source>
          <target state="translated">我想我会给你答案。在没有检查是否匹配成功之前,不要使用捕获变量。</target>
        </trans-unit>
        <trans-unit id="7c72585f7f59b0950dbe2ce10550a24b61487618" translate="yes" xml:space="preserve">
          <source>I thought if the first group &lt;code&gt;(?:([A-Za-z]+):)&lt;/code&gt; is a non-capturing group then why it is returning &lt;code&gt;http&lt;/code&gt; string in the output array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我以为如果第一组&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:([A-Za-z]+):)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个非捕获组，那么为什么它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在输出数组中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回&lt;/font&gt;&lt;/font&gt; &lt;code&gt;http&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符串。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e7e9bcc060a5f0ae1d16003068494f777d48d5e" translate="yes" xml:space="preserve">
          <source>If the pattern is matched , then &lt;code&gt;$1&lt;/code&gt; is captured as next grouped pattern.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果模式匹配，则&lt;/font&gt;&lt;/font&gt; &lt;code&gt;$1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被捕获为下一个分组模式。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a74cff867e72f6b90bcf3a4fed1c8ad63142468e" translate="yes" xml:space="preserve">
          <source>In complex regular expressions you may have the situation arise where you wish to use a large number of groups some of which are there for repetition matching and some of which are there to provide back references. By default the text matching each group is loaded into the backreference array. Where we have lots of groups and only need to be able to reference some of them from the backreference array we can override this default behaviour to tell the regular expression that certain groups are there only for repetition handling and do not need to be captured and stored in the backreference array.</source>
          <target state="translated">在复杂的正则表达式中,你可能会遇到这样的情况,即你希望使用大量的组,其中一些组是为了重复匹配,另一些组是为了提供反向引用。默认情况下,每个组匹配的文本会被加载到backreference数组中。如果我们有很多组,并且只需要从backreference数组中引用其中的一些组,我们可以覆盖这个默认的行为,告诉正则表达式,某些组只是为了重复处理而存在,不需要被捕获并存储在backreference数组中。</target>
        </trans-unit>
        <trans-unit id="9daca7626ec573ded51fa04dac04f67eb08735f4" translate="yes" xml:space="preserve">
          <source>In the above example, to avoid capturing bronto in &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;(?:)&lt;/code&gt; is used.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在上面的示例中，为避免捕获&lt;/font&gt;&lt;/font&gt; &lt;code&gt;$1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bronto &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="369d761cfe07f98f24131cbd8cb9afa94cec6de3" translate="yes" xml:space="preserve">
          <source>Input url string:</source>
          <target state="translated">输入URL字符串。</target>
        </trans-unit>
        <trans-unit id="ecf8bc5cb8774a51996a3b1d64ef1449713980c6" translate="yes" xml:space="preserve">
          <source>It is Useful if you don't want the matches to be saved.</source>
          <target state="translated">如果你不希望火柴被保存,它很有用。</target>
        </trans-unit>
        <trans-unit id="819f9a951ddc20cbf71662734141f8ed11468fd1" translate="yes" xml:space="preserve">
          <source>It makes the group non-capturing, which means that the substring matched by that group will not be included in the list of captures. An example in ruby to illustrate the difference:</source>
          <target state="translated">它使组不被捕获,这意味着该组匹配的子串不会被包含在捕获列表中。用Ruby中的一个例子来说明这个区别。</target>
        </trans-unit>
        <trans-unit id="1f7fbb7891b3402052270ff4133b332e8ed65674" translate="yes" xml:space="preserve">
          <source>Its as simple as that.</source>
          <target state="translated">就这么简单。</target>
        </trans-unit>
        <trans-unit id="04eecf74cbc06fc131595c71a1e320387b05f571" translate="yes" xml:space="preserve">
          <source>Its extremely simple, We can understand with simple date example, suppose if the date is mentioned as 1st January 2019 or 2nd May 2019 or any other date and we simply want to convert it to &lt;strong&gt;dd/mm/yyyy&lt;/strong&gt; format we would not need the month's name which is January or February for that matter, so in order to capture the numeric part, but not the (optional) suffix you can use a non-capturing group.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它非常简单，我们可以通过简单的日期示例来理解，假设如果日期被提到为2019年1月1日或2019年5月2日或任何其他日期，我们只想将其转换为&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;dd / mm / yyyy&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;格式，则不需要月份的名称是一月或二月，因此为了捕获数字部分，而不是（可选）后缀，可以使用非捕获组。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9976df8cd06470bec3bcac27c19305b473d398a3" translate="yes" xml:space="preserve">
          <source>Later on in the regex is &lt;code&gt;\1&lt;/code&gt; which means it will only match the same text that was in the first group (the &lt;code&gt;([A-Z][A-Z0-9]*)&lt;/code&gt; group) (in this case it is matching the end tag).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以后在正则表达式中是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;\1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这意味着它将仅与第一组&lt;/font&gt;&lt;/font&gt; &lt;code&gt;([A-Z][A-Z0-9]*)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的相同文本匹配&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（在这种情况下，它与结束标记匹配） ）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="43adfd1cdfc25034d3502f087497ed3ea98160ef" translate="yes" xml:space="preserve">
          <source>Let me try to explain this with an example.</source>
          <target state="translated">让我试着用一个例子来解释一下。</target>
        </trans-unit>
        <trans-unit id="f3283cce490022a6d472f45cdb3f88d5b2aec05f" translate="yes" xml:space="preserve">
          <source>Let's say you have an email address &lt;code&gt;example@example.com&lt;/code&gt;. The following regex will create two &lt;strong&gt;groups&lt;/strong&gt;, the id part and @example.com part. &lt;code&gt;(\p{Alpha}*[a-z])(@example.com)&lt;/code&gt;. For simplicity's sake, we are extracting the whole domain name including the &lt;code&gt;@&lt;/code&gt; character.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设您有一个电子邮件地址&lt;/font&gt;&lt;/font&gt; &lt;code&gt;example@example.com&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下正则表达式将创建两个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，即id部分和@ example.com部分。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(\p{Alpha}*[a-z])(@example.com)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了简单起见，我们提取包括&lt;/font&gt;&lt;/font&gt; &lt;code&gt;@&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在内的整个域名&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f885c63824e77156466ae1912e924f5afcb9e053" translate="yes" xml:space="preserve">
          <source>Let's try some substitutions now. Consider the following text:</source>
          <target state="translated">现在让我们来尝试一些替换的方法。考虑一下下面的文字:</target>
        </trans-unit>
        <trans-unit id="f8209e598b57132f617e3bbea18d61afb1923684" translate="yes" xml:space="preserve">
          <source>Line 1 - &lt;code&gt;animal=cat,dog,cat,tiger,dog&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第1行- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;animal=cat,dog,cat,tiger,dog&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed24d8e3e1c0c95d9b4755a92be4a9f54e6fb231" translate="yes" xml:space="preserve">
          <source>Line 2 - &lt;code&gt;animal=cat,cat,dog,dog,tiger&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第2行- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;animal=cat,cat,dog,dog,tiger&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98fc7b56a6846f9710703ab5eae4f0a03fe308a1" translate="yes" xml:space="preserve">
          <source>Line 3 - &lt;code&gt;animal=dog,dog,cat,cat,tiger&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第3行- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;animal=dog,dog,cat,cat,tiger&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="928f909cd25d5693fce4bc6308324fad51c64621" translate="yes" xml:space="preserve">
          <source>Non-capturing groups are great if you are trying to capture many different things and there are some groups you don't want to capture.</source>
          <target state="translated">如果你想抓拍很多不同的东西,而有些群体是你不想抓拍的,那么非抓拍群体就很好。</target>
        </trans-unit>
        <trans-unit id="0dec0b6d33a858c36135ae23afa7bbe2e863c0c0" translate="yes" xml:space="preserve">
          <source>Note that I don't care about saving the first 3 octets, but the &lt;code&gt;(?:...)&lt;/code&gt; grouping allows me to shorten the regex without incurring the overhead of capturing and storing a match.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，我不在乎保存前3个八位位组，但是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:...)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分组使我可以缩短正则表达式，而不会产生捕获和存储匹配项的开销。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9d7295831f17a416ec0423a517b61f8dedbbc67" translate="yes" xml:space="preserve">
          <source>Now let's say, you only need the id part of the address. What you want to do is to grab the first group of the match result, surrounded by &lt;code&gt;()&lt;/code&gt; in the regex and the way to do this is to use the non-capturing group syntax, i.e. &lt;code&gt;?:&lt;/code&gt;. So the regex &lt;code&gt;(\p{Alpha}*[a-z])(?:@example.com)&lt;/code&gt; will return just the id part of the email.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在说，您只需要地址的id部分。您想要做的就是获取匹配结果的第一组，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在正则表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包围，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而这样做的方法是使用非捕获组语法，即&lt;/font&gt;&lt;/font&gt; &lt;code&gt;?:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。因此，正则表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(\p{Alpha}*[a-z])(?:@example.com)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将仅返回电子邮件的id部分。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d2c52f7e270ca5e6bb3a810803588ff5f551b65" translate="yes" xml:space="preserve">
          <source>Now, if I apply the regex below over it...</source>
          <target state="translated">现在,如果我在它上面应用下面的regex.....</target>
        </trans-unit>
        <trans-unit id="36f361b61189aff42b7eebd5607b8d7f76a4b27b" translate="yes" xml:space="preserve">
          <source>Now, let's use this dumb regex over it:</source>
          <target state="translated">现在,让我们用这个哑巴的regex来代替它。</target>
        </trans-unit>
        <trans-unit id="a79bbab80e5f51a1ba97e8d1a5a565646de7af3e" translate="yes" xml:space="preserve">
          <source>Now, my result looks like this:</source>
          <target state="translated">现在,我的结果是这样的</target>
        </trans-unit>
        <trans-unit id="1f274cd072a23fa7cccb71fc8297c70751c9a459" translate="yes" xml:space="preserve">
          <source>Ok, imagine you have some kind of XML or HTML (be aware that &lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags&quot;&gt;regex may not be the best tool for the job&lt;/a&gt;, but it is nice as an example). You want to parse the tags, so you could do something like this (I have added spaces to make it easier to understand):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好的，假设您有某种XML或HTML（请注意，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正则表达式可能不是完成这项工作的最佳工具&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但它很好地举例说明了这一点）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您想解析标签，因此可以执行以下操作（我添加了空格以使其更易于理解）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d884c7d7d1bf713f8c2c281bc9fe3cd4f545114" translate="yes" xml:space="preserve">
          <source>One interesting thing that I came across is the fact that you can have a capturing group inside a non-capturing group. Have a look at below regex for matching web urls:</source>
          <target state="translated">我遇到的一个有趣的事情是,你可以在一个非捕获组内有一个捕获组。请看下面的匹配网络URL的regex。</target>
        </trans-unit>
        <trans-unit id="f1c9dcb4cd92829730ac3cc2143bc86b38c1daa8" translate="yes" xml:space="preserve">
          <source>Open your Google Chrome devTools and then Console tab: and type this:</source>
          <target state="translated">打开你的谷歌浏览器devTools,然后打开Console选项卡:并键入这个。</target>
        </trans-unit>
        <trans-unit id="5b59a89b13d60aab47b70580d466c5ce41419ec3" translate="yes" xml:space="preserve">
          <source>Regex Code: &lt;code&gt;(?:animal)(?:=)(\w+)(,)\1\2&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正则表达式代码：（？：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:animal)(?:=)(\w+)(,)\1\2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a76abf14694f69d61d1bb18343ad634bb670d59a" translate="yes" xml:space="preserve">
          <source>Run it and you will see:</source>
          <target state="translated">运行它,你就知道了。</target>
        </trans-unit>
        <trans-unit id="3642e9d0e043b335858ccab6c89ee4552a574fd9" translate="yes" xml:space="preserve">
          <source>Say you want to match numeric text, but some numbers could be written as 1st, 2nd, 3rd, 4th,...  If you want to capture the numeric part, but not the (optional) suffix you can use a non-capturing group.</source>
          <target state="translated">假设你想匹配数字文本,但有些数字可以写成1号、2号、3号、4号.....。如果你想抓取数字部分,但不需要(可选)后缀,你可以使用非抓取组。</target>
        </trans-unit>
        <trans-unit id="662b07a2d3845512550aba285e519dc9184a801a" translate="yes" xml:space="preserve">
          <source>See? The first group has not been captured. The parser uses it to match the text, but ignores it later, in the final result.</source>
          <target state="translated">看到了吗?第一组没有被捕捉到。解析器使用它来匹配文本,但在最后的结果中却忽略了它,在最后的结果中。</target>
        </trans-unit>
        <trans-unit id="a755f44d8210aa9fb1addd2d290074c17bf1ba87" translate="yes" xml:space="preserve">
          <source>So if you notice that there is a nested group &lt;code&gt;([A-Za-z]+)&lt;/code&gt; inside the non-capturing group. That nested group &lt;code&gt;([A-Za-z]+)&lt;/code&gt; is a capturing group (not having &lt;code&gt;?:&lt;/code&gt; at the beginning) in itself inside a non-capturing group &lt;code&gt;(?:([A-Za-z]+):)&lt;/code&gt;. That's why the text &lt;code&gt;http&lt;/code&gt; still gets captured but the colon &lt;code&gt;:&lt;/code&gt; character which is inside the non-capturing group but outside the capturing group doesn't get reported in the output array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，如果您注意到&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在非捕获组内&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有一个嵌套组&lt;/font&gt;&lt;/font&gt; &lt;code&gt;([A-Za-z]+)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该嵌套组&lt;/font&gt;&lt;/font&gt; &lt;code&gt;([A-Za-z]+)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个捕获组（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在开始时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;?:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;(?:([A-Za-z]+):)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本身在一个非捕获组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（？：（[A-Za-z] +）:)中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这就是为什么&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仍然捕获&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文本&lt;/font&gt;&lt;/font&gt; &lt;code&gt;http&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非捕获组内部但在捕获组外部的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;冒号&lt;/font&gt;&lt;/font&gt; &lt;code&gt;:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符未在输出数组中报告的原因。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="19e7e3ad72117c5317984ec5b1edb5657293488f" translate="yes" xml:space="preserve">
          <source>So in this code by giving &lt;code&gt;\1&lt;/code&gt; and &lt;code&gt;\2&lt;/code&gt; we recall or repeat the result of captured group 1 and 2 respectively later in the code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，在此代码中，通过给出&lt;/font&gt;&lt;/font&gt; &lt;code&gt;\1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;\2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们分别在代码的后面分别调用或重复捕获的组1和2的结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="357367b5957f0c6f83afcc57e98869313f465e4c" translate="yes" xml:space="preserve">
          <source>So, if we apply the substitution string:</source>
          <target state="translated">所以,如果我们应用替换字符串。</target>
        </trans-unit>
        <trans-unit id="4fa2a8f807d64fdaff79b5a7ca7af29c6812c71c" translate="yes" xml:space="preserve">
          <source>That will match numbers in the form 1, 2, 3... or in the form 1st, 2nd, 3rd,... but it will only capture the numeric part.</source>
          <target state="translated">这将匹配1,2,3.....或1,2,3....或1,2,3....的形式的数字,但它只能捕获数字部分。</target>
        </trans-unit>
        <trans-unit id="73f6c8798d99899797302d167e109c75e80214a3" translate="yes" xml:space="preserve">
          <source>Thats pretty much the reason they exist.  While you are learning about groups, learn about &lt;a href=&quot;http://www.regular-expressions.info/atomic.html&quot;&gt;Atomic Groups&lt;/a&gt;, they do a lot!  There is also lookaround groups but they are a little more complex and not used so much.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那几乎就是它们存在的原因。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您学习组时，请学习&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.regular-expressions.info/atomic.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子组&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它们可以发挥很多作用！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也有环视组，但它们稍微复杂一些，使用量不大。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14a69e4759845310875b34b062b2002490ab9bcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JavaScript&lt;/code&gt; RegExp engine capture three groups, the items with indexes 1,2,3. Now  use non-capturing mark to see the result.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;JavaScript&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正则表达式引擎捕获三组，指标1,2,3项。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在使用非捕获标记来查看结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13d974c0959db61c745376ce8ffaca83f53ce956" translate="yes" xml:space="preserve">
          <source>The capture variables, &lt;code&gt;$1&lt;/code&gt;, etc, are not valid unless the match succeeded, and they're not cleared, either.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;捕获变量&lt;/font&gt;&lt;/font&gt; &lt;code&gt;$1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等无效，除非匹配成功，并且也不会清除它们。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0c26a1ed699881851d0465a73258cd4e904856c5" translate="yes" xml:space="preserve">
          <source>The existence of non-capturing groups can be explained with the use of parenthesis.</source>
          <target state="translated">非捕捉组的存在,可以用括号来解释。</target>
        </trans-unit>
        <trans-unit id="c70a8b4f8a2ad825460fd6179f0c38d96e7d7f06" translate="yes" xml:space="preserve">
          <source>The first group in my regex &lt;code&gt;(?:([A-Za-z]+):)&lt;/code&gt; is a non-capturing group which matches the protocol scheme and colon &lt;code&gt;:&lt;/code&gt; character i.e. &lt;code&gt;http:&lt;/code&gt; but when I was running below code, I was seeing the 1st index of the returned array was containing the string &lt;code&gt;http&lt;/code&gt; when I was thinking that &lt;code&gt;http&lt;/code&gt; and colon &lt;code&gt;:&lt;/code&gt; both will not get reported as they are inside a non-capturing group.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的正则表达式中的第一组&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:([A-Za-z]+):)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个非捕获组，它与协议方案和冒号&lt;/font&gt;&lt;/font&gt; &lt;code&gt;:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符即&lt;/font&gt;&lt;/font&gt; &lt;code&gt;http:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相匹配，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是当我在下面的代码下运行时，我看到了返回数组的第一个指数是包含字符串&lt;/font&gt;&lt;/font&gt; &lt;code&gt;http&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时，我在想，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;http&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和结肠&lt;/font&gt;&lt;/font&gt; &lt;code&gt;:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;既不会得到报告，因为他们是一个非捕获组内。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="933f274efc29a60ddcbc9dd53e5bc757b24ff8f8" translate="yes" xml:space="preserve">
          <source>The first regex has a named group (TAG), while the second one uses a common group. Both regexes do the same thing: they use the value from the first group (the name of the tag) to match the closing tag. The difference is that the first one uses the name to match the value, and the second one uses the group index (which starts at 1).</source>
          <target state="translated">第一个gex有一个命名的组(TAG),而第二个gex使用一个通用组。这两个regex的作用都是一样的:它们使用第一个组中的值(tag的名称)来匹配关闭的tag。不同的是,第一种使用名称来匹配值,而第二种使用组索引(从1开始)。</target>
        </trans-unit>
        <trans-unit id="ae54010f75119dee887bb47e46927d86541df658" translate="yes" xml:space="preserve">
          <source>The non-capturing group &lt;code&gt;(?...)&lt;/code&gt; 
does &lt;strong&gt;not remove&lt;/strong&gt; any characters from the original full match, &lt;strong&gt;it only&lt;/strong&gt; reorganises the regex visually to the programmer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非捕获组&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?...)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 不会&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从原始完全匹配项中&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;删除&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何字符，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它只会&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以可视化方式将正则表达式重新组织给程序员。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">其结果是:</target>
        </trans-unit>
        <trans-unit id="318ceae08ec25fde53661e4228851bc15eebe840" translate="yes" xml:space="preserve">
          <source>This is obvious what is non capturing group.</source>
          <target state="translated">这就是明显的非捕捉组。</target>
        </trans-unit>
        <trans-unit id="b66439f3881a02902ca6010d6d2bd92a7434e78a" translate="yes" xml:space="preserve">
          <source>This regex matches words with at least 3 characters, and uses groups to separate the first three letters. The result is this:</source>
          <target state="translated">这个regex匹配至少有3个字符的单词,并使用组来分隔前三个字母。结果是这样的。</target>
        </trans-unit>
        <trans-unit id="a07a319e45b5785cb254dadda8ec13bc616e6c15" translate="yes" xml:space="preserve">
          <source>To access a specific part of the regex without defined extraneous characters you would always need to use &lt;code&gt;.group(&amp;lt;index&amp;gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要访问正则表达式的特定部分而没有定义多余字符，则始终需要使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;.group(&amp;lt;index&amp;gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84b6e00b2a2f4b65773933ec5844cb70ef7e26f8" translate="yes" xml:space="preserve">
          <source>To play around with regexes, I recommend &lt;a href=&quot;http://regex101.com/&quot;&gt;http://regex101.com/&lt;/a&gt;, which offers a good amount of details on how the regex works; it also offers a few regex engines to choose from.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要使用正则表达式，建议使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://regex101.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://regex101.com/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它提供了大量有关正则表达式工作原理的详细信息。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它还提供了一些正则表达式引擎供您选择。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b243fe5772ab0c1a785f69808ef43d49a3b3e9d5" translate="yes" xml:space="preserve">
          <source>Well I am a JavaScript developer and will try to explain its significance pertaining to JavaScript.</source>
          <target state="translated">好吧,我是一个JavaScript开发者,我将尝试解释一下它与JavaScript相关的意义。</target>
        </trans-unit>
        <trans-unit id="53d569ad77d1085fc503c918599e5104238c6aff" translate="yes" xml:space="preserve">
          <source>Well, groups serve many purposes. They can help you to extract exact information from a bigger match (which can also be named), they let you rematch a previous matched group, and can be used for substitutions. Let's try some examples, shall we?</source>
          <target state="translated">那么,组的作用有很多。它们可以帮助你从一个更大的匹配中提取精确的信息(也可以命名),它们可以让你重新匹配之前的匹配组,还可以用于替换。让我们试着举几个例子,好吗?</target>
        </trans-unit>
        <trans-unit id="f734eb4f0ab2949982e36e9579f7d8ba1c487224" translate="yes" xml:space="preserve">
          <source>What is a non-capturing group in regular expressions</source>
          <target state="translated">什么是正则表达式中的非捕获组?</target>
        </trans-unit>
        <trans-unit id="70142d01328081ebf39c9733293e91db29341e97" translate="yes" xml:space="preserve">
          <source>When you want to have parenthesis but not capture the sub-expression you use NON-CAPTURING GROUPS. In the example, &lt;code&gt;(?:a|b)c&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您想使用括号而不捕获子表达式时，可以使用NON-CAPTURING GROUPS。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在示例中，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:a|b)c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a4477b8c9f4bec5e436c46e7090f42132a3ba00" translate="yes" xml:space="preserve">
          <source>You can use capturing groups to organize and parse an expression.  A non-capturing group has the first benefit, but doesn't have the overhead of the second.  You can still say a non-capturing group is optional, for example.</source>
          <target state="translated">你可以使用捕获组来组织和解析一个表达式。非捕获组有第一个好处,但没有第二个好处。你仍然可以说非捕获组是可选的,例如。</target>
        </trans-unit>
        <trans-unit id="3e558ad69a8ba496c74b18d311adf75066f0d177" translate="yes" xml:space="preserve">
          <source>You can use named groups for substitutions too, using &lt;code&gt;${name}&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您也可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;${name}&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来使用命名组进行替换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="329f9f97cceaba3b659f997963c599aa962deb8a" translate="yes" xml:space="preserve">
          <source>but by giving the &lt;code&gt;?:&lt;/code&gt; we make the match-group non captured (which do not count off in matched group, so the grouping number starts from the first captured group and not the non captured), so that the repetition of the result of match-group &lt;code&gt;(?:animal)&lt;/code&gt; can't be called later in code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是给定&lt;/font&gt;&lt;/font&gt; &lt;code&gt;?:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们使匹配组未被捕获（在匹配组中不计数），因此分组号从捕获的第一个组开始，而不是未被捕获的组，以便重复匹配结果-group &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(?:animal)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;稍后无法在代码中调用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cda3502beefadf8b98a36ab2b6b179e5765a5f31" translate="yes" xml:space="preserve">
          <source>so the regular expression would be,</source>
          <target state="translated">所以正则表达式为:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
