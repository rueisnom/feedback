<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/352098">
    <body>
      <group id="352098">
        <trans-unit id="c2b21c5dca0f8a3a5e3a8913a7c60d9e43912c15" translate="yes" xml:space="preserve">
          <source>(example: &lt;code&gt;curl localhost:5000/blocks | jq&lt;/code&gt;)</source>
          <target state="translated">（例如： &lt;code&gt;curl localhost:5000/blocks | jq&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="eff15212915025452a077b7d193862752aff0748" translate="yes" xml:space="preserve">
          <source>... into something like this:</source>
          <target state="translated">...变成这样的东西。</target>
        </trans-unit>
        <trans-unit id="ccf47cdeb293f0ccc497d23213931545afc5ac72" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsonlint.com/&quot;&gt;JSONLint&lt;/a&gt; has an &lt;a href=&quot;https://github.com/zaach/jsonlint&quot;&gt;open-source implementation on GitHub&lt;/a&gt; that can be used on the command line or included in a Node.js project.</source>
          <target state="translated">&lt;a href=&quot;http://jsonlint.com/&quot;&gt;JSONLint&lt;/a&gt; &lt;a href=&quot;https://github.com/zaach/jsonlint&quot;&gt;在GitHub上&lt;/a&gt;具有开源实现 ，可在命令行上使用或包含在Node.js项目中。</target>
        </trans-unit>
        <trans-unit id="65ffdca0ef159c53c6bccffc11b0aa9494ecdeab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/jmhodges/jsonpp&quot;&gt;jsonpp&lt;/a&gt; is a very nice command line JSON pretty printer.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/jmhodges/jsonpp&quot;&gt;jsonpp&lt;/a&gt;是一个非常不错的命令行JSON漂亮打印机。</target>
        </trans-unit>
        <trans-unit id="5d01ad35b562f7f9080fc17394d697b4762ba688" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/sharkdp/bat&quot;&gt;&lt;code&gt;bat&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;cat&lt;/code&gt; clone with syntax highlighting:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/sharkdp/bat&quot;&gt; &lt;code&gt;bat&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;cat&lt;/code&gt; 克隆，语法高亮显示：</target>
        </trans-unit>
        <trans-unit id="11ec9a9b9955f5569a0be3167d367d46f7339d7c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tidwall/jj&quot;&gt;jj&lt;/a&gt; is super-fast, can handle ginormous JSON documents economically, does not mess with valid JSON numbers, and is easy to use, e.g.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tidwall/jj&quot;&gt;jj&lt;/a&gt;超快，可以经济地处理大量的JSON文档，不会与有效的JSON数字混淆，并且易于使用，例如</target>
        </trans-unit>
        <trans-unit id="9fc0e3abbbceabb9d15486ba1cee7465326fa952" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-p&lt;/code&gt; will output without headers, and &lt;code&gt;-l&lt;/code&gt; will explicitly specify the language.</source>
          <target state="translated">&lt;code&gt;-p&lt;/code&gt; 将输出不包含标题的信息， &lt;code&gt;-l&lt;/code&gt; 将显式指定语言。</target>
        </trans-unit>
        <trans-unit id="1a8afa7777815b16c1d872e70a45dba35c28654f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt; I'm using &lt;code&gt;jq&lt;/code&gt; now as suggested in another answer. It's extremely powerful at filtering JSON, but, at its most basic, also an awesome way to pretty print JSON for viewing.</source>
          <target state="translated">&lt;strong&gt;更新&lt;/strong&gt;我正在使用 &lt;code&gt;jq&lt;/code&gt; ,如另一个答案中所建议。 它在过滤JSON方面非常强大，但是，从最基本的角度来看，它也是一种漂亮地打印JSON以供查看的绝妙方法。</target>
        </trans-unit>
        <trans-unit id="558d01555dcc98ed3d3c6d8549b4af8d358becac" translate="yes" xml:space="preserve">
          <source>And then pipe any JSON content to &lt;code&gt;pjson&lt;/code&gt;.</source>
          <target state="translated">然后将所有JSON内容通过管道传递给 &lt;code&gt;pjson&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2deac98f0979bc538865ceca91376bded4586346" translate="yes" xml:space="preserve">
          <source>And to retrieve select data (in this case, &quot;test&quot;'s value):</source>
          <target state="translated">并检索选择数据(在本例中,&quot;test &quot;的值)。</target>
        </trans-unit>
        <trans-unit id="a8877b9cd466e709cb219df12e612288bd73695a" translate="yes" xml:space="preserve">
          <source>Basically, I want it to transform the following:</source>
          <target state="translated">基本上,我希望它能转化为以下内容。</target>
        </trans-unit>
        <trans-unit id="e526d0b82dfd82b5b92416610771e8b48e737efe" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://github.com/mconigliaro/jazor&quot;&gt;Jazor&lt;/a&gt;. It's a simple command line JSON parser written in Ruby.</source>
          <target state="translated">查看&lt;a href=&quot;https://github.com/mconigliaro/jazor&quot;&gt;Jazor&lt;/a&gt; 。 这是用Ruby编写的简单命令行JSON解析器。</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2a7e2ee750b232b776d1e0f6bba195affff6bbd4" translate="yes" xml:space="preserve">
          <source>For convenience in all of these cases you can make an alias:</source>
          <target state="translated">为了方便在所有这些情况下,你可以做一个别名。</target>
        </trans-unit>
        <trans-unit id="8bded8109814c9b0dc25f326bc700c50e4e0db85" translate="yes" xml:space="preserve">
          <source>For even more convenience with a bit more typing to get it ready:</source>
          <target state="translated">为了更多的方便,多打点字就可以了。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="a265f88f8efe1b02478906424759d729b930ae30" translate="yes" xml:space="preserve">
          <source>From the README:</source>
          <target state="translated">从README中。</target>
        </trans-unit>
        <trans-unit id="9399153ff98e7cbe217ca05a05415e027818b1b6" translate="yes" xml:space="preserve">
          <source>From the Unix command-line with Node.js, specifying JSON on the command line:</source>
          <target state="translated">从Unix命令行中使用Node.js,在命令行中指定JSON。</target>
        </trans-unit>
        <trans-unit id="ab14fffdbdc684c4e6464af946966b06426d55b0" translate="yes" xml:space="preserve">
          <source>From the Unix command-line with Node.js, specifying a filename that contains JSON, and using an indent of four spaces:</source>
          <target state="translated">从Unix命令行用Node.js,指定一个包含JSON的文件名,并使用四个空格缩进。</target>
        </trans-unit>
        <trans-unit id="6df6c42a5832b66a784567af76f261dd90b20e3c" translate="yes" xml:space="preserve">
          <source>Here is a live demo:</source>
          <target state="translated">这里有一个现场演示。</target>
        </trans-unit>
        <trans-unit id="638071c88b16c8f77a19ace5c6837cf529e7f268" translate="yes" xml:space="preserve">
          <source>How can I pretty-print JSON in a shell script</source>
          <target state="translated">如何在一个shell脚本中漂亮地打印JSON?</target>
        </trans-unit>
        <trans-unit id="870e84646da256de256a8e67a8ee08dfa3b8edbb" translate="yes" xml:space="preserve">
          <source>I combine Python's json.tool with pygmentize:</source>
          <target state="translated">我把Python的json.tool和pygmentize结合在一起。</target>
        </trans-unit>
        <trans-unit id="fa550568eb173ef55f0f2e58ff95516042a7fda1" translate="yes" xml:space="preserve">
          <source>I may be a bit biased, but it's an awesome tool for printing and manipulating JSON data from the command-line. It's super-friendly to use and has extensive command-line help/documentation. It's a Swiss Army knife that I use for 1001 different small tasks that would be surprisingly annoying to do any other way.</source>
          <target state="translated">我可能有点偏颇,但它是一个很棒的工具,可以从命令行打印和处理JSON数据。它使用起来超级友好,并且有丰富的命令行帮助文档。它是一把瑞士军刀,我用它来完成1001个不同的小任务,如果用其他方式来完成这些小任务,会让人觉得很烦。</target>
        </trans-unit>
        <trans-unit id="606a0c4bd6be5bc2c19edf5aa9dfed70ee856514" translate="yes" xml:space="preserve">
          <source>I recommend using the json_xs command line utility which is included in the JSON::XS perl module. JSON::XS is a Perl module for serializing/deserializing JSON, on a Debian or Ubuntu machine you can install it like this:</source>
          <target state="translated">我推荐使用JSON_XS命令行工具,它包含在JSON::XS perl模块中。JSON:::XS是一个用于序列化JSON的Perl模块,在Debian或Ubuntu机器上,你可以这样安装。</target>
        </trans-unit>
        <trans-unit id="a31d2fb698bfa23a0bb003098c02af5ec5790eab" translate="yes" xml:space="preserve">
          <source>I use &lt;a href=&quot;http://kmkeen.com/jshon/&quot;&gt;jshon&lt;/a&gt; to do exactly what you're describing. Just run:</source>
          <target state="translated">我使用&lt;a href=&quot;http://kmkeen.com/jshon/&quot;&gt;jshon&lt;/a&gt;来完全按照您的描述进行操作。 赶紧跑：</target>
        </trans-unit>
        <trans-unit id="5f71a5242fca6ebf28b369924ab84a5d40d8bfb6" translate="yes" xml:space="preserve">
          <source>I use the &quot;space&quot; argument of &lt;a href=&quot;http://es5.github.io/#x15.12.3&quot;&gt;&lt;code&gt;JSON.stringify&lt;/code&gt;&lt;/a&gt; to pretty-print JSON in JavaScript.</source>
          <target state="translated">我使用&lt;a href=&quot;http://es5.github.io/#x15.12.3&quot;&gt; &lt;code&gt;JSON.stringify&lt;/code&gt; &lt;/a&gt;的&amp;ldquo; space&amp;rdquo;参数在JavaScript中漂亮地打印JSON。</target>
        </trans-unit>
        <trans-unit id="82a06354b6938a34330cac58ea4b5cb6e7137340" translate="yes" xml:space="preserve">
          <source>I usually just do:</source>
          <target state="translated">我通常只是做。</target>
        </trans-unit>
        <trans-unit id="7f1f7c39fe55184fcf4428f66ed3cdcd924fafd4" translate="yes" xml:space="preserve">
          <source>I wrote a tool that has one of the best &quot;smart whitespace&quot; formatters available. It produces more readable and less verbose output than most of the other options here.</source>
          <target state="translated">我写了一个工具,它有一个最好的 &quot;smart whitespace &quot;格式化器。它比这里的大多数其他选项产生的输出更可读,更少的字数。</target>
        </trans-unit>
        <trans-unit id="bf4b73e090df4af8ca69d20b237a46ac646babb1" translate="yes" xml:space="preserve">
          <source>If the JSON data is in a file:</source>
          <target state="translated">如果JSON数据是在一个文件中。</target>
        </trans-unit>
        <trans-unit id="b125c7ff6503ee2e6e42e63180f50dd876244ee6" translate="yes" xml:space="preserve">
          <source>If the remainder of your pipeline will gracefully handle unicode and you'd like your JSON to also be human-friendly, simply &lt;a href=&quot;https://docs.python.org/2/library/json.html&quot;&gt;use&lt;/a&gt;&lt;code&gt;ensure_ascii=False&lt;/code&gt;</source>
          <target state="translated">如果管道的其余部分将正常处理unicode，并且您希望JSON也对人类友好，则只需&lt;a href=&quot;https://docs.python.org/2/library/json.html&quot;&gt;使用&lt;/a&gt; &lt;code&gt;ensure_ascii=False&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5174c4b3fc22706a455ee505125ef4a49cf154eb" translate="yes" xml:space="preserve">
          <source>If you don't have &lt;code&gt;json_xs&lt;/code&gt;, try &lt;code&gt;json_pp&lt;/code&gt; . &quot;pp&quot; is for &quot;pure perl&quot; &amp;ndash; the tool is implemented in Perl only, without a binding to an external C library (which is what XS stands for, Perl's &quot;Extension System&quot;).</source>
          <target state="translated">如果您没有 &lt;code&gt;json_xs&lt;/code&gt; ，请尝试 &lt;code&gt;json_pp&lt;/code&gt; 。 &amp;ldquo; pp&amp;rdquo;表示&amp;ldquo;纯perl&amp;rdquo; &amp;ndash;该工具仅在Perl中实现，没有绑定到外部C库（XS代表Perl的&amp;ldquo;扩展系统&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="89f8c3ae28bbaf3b056d461bae9d9283fbf143fb" translate="yes" xml:space="preserve">
          <source>If you use npm and Node.js, you can do &lt;code&gt;npm install -g json&lt;/code&gt; and then pipe the command through &lt;code&gt;json&lt;/code&gt;.  Do &lt;code&gt;json -h&lt;/code&gt; to get all the options. It can also pull out specific fields and colorize the output with &lt;code&gt;-i&lt;/code&gt;.</source>
          <target state="translated">如果使用npm和Node.js，则可以执行 &lt;code&gt;npm install -g json&lt;/code&gt; ，然后通过 &lt;code&gt;json&lt;/code&gt; 传递命令。 执行 &lt;code&gt;json -h&lt;/code&gt; 以获取所有选项。 它还可以提取特定字段，并使用 &lt;code&gt;-i&lt;/code&gt; 为输出着色。</target>
        </trans-unit>
        <trans-unit id="5ac9e9fb4727ee8563034227abbd5e41b4dd9ada" translate="yes" xml:space="preserve">
          <source>If you want to do it all in one go with &lt;code&gt;curl&lt;/code&gt; on the command line using an authentication token:</source>
          <target state="translated">如果您想使用身份验证令牌在命令行中 &lt;code&gt;curl&lt;/code&gt; 地完成所有操作：</target>
        </trans-unit>
        <trans-unit id="0cdd645852f8484e24950b690e025af50241844b" translate="yes" xml:space="preserve">
          <source>If you're on Mac OS X, you can &lt;code&gt;brew install jsonpp&lt;/code&gt;. If not, you can simply copy the binary to somewhere in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">如果您使用的是Mac OS X，则可以 &lt;code&gt;brew install jsonpp&lt;/code&gt; 。 如果没有，您可以简单地将二进制文件复制到 &lt;code&gt;$PATH&lt;/code&gt; 某个位置。</target>
        </trans-unit>
        <trans-unit id="1b24d311a42dcbec1e7dfe04f8b94a7c69f1df1a" translate="yes" xml:space="preserve">
          <source>Install it with &lt;code&gt;pip&lt;/code&gt;:</source>
          <target state="translated">用 &lt;code&gt;pip&lt;/code&gt; 安装它：</target>
        </trans-unit>
        <trans-unit id="a102c20a34e15bf9150429aa671f99e79dd225d9" translate="yes" xml:space="preserve">
          <source>Install yajl-tools with the command below:</source>
          <target state="translated">用下面的命令安装yajl-tools。</target>
        </trans-unit>
        <trans-unit id="dd5c7a96e4392f1fd17e1cf640379bcd73a90892" translate="yes" xml:space="preserve">
          <source>Is there a (Unix) shell script to format JSON in human-readable form?</source>
          <target state="translated">是否有一个(Unix)shell脚本来将JSON格式化为人类可读的形式?</target>
        </trans-unit>
        <trans-unit id="919abba41f1da02f9fb484f1c3f528e466269bfb" translate="yes" xml:space="preserve">
          <source>It has colouring and formatting for JSON and does &lt;em&gt;not&lt;/em&gt; have the problems noted in this comment: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/352098/how-can-i-pretty-print-json-in-a-unix-shell-script#comment52647558_15231463&quot;&gt;How can I pretty-print JSON in a shell script?&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">它具有JSON的颜色和格式，并且没有此注释中指出的问题： &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/352098/how-can-i-pretty-print-json-in-a-unix-shell-script#comment52647558_15231463&quot;&gt;如何在Shell脚本中漂亮地打印JSON？&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96f130b38b043342182e4e0595a0a71c31b35a14" translate="yes" xml:space="preserve">
          <source>It is (2018) still quite new so maybe it won&amp;rsquo;t handle invalid JSON the way you expect, but it is easy to install on major platforms.</source>
          <target state="translated">它（2018）仍然很新，因此也许它不会按照您期望的方式处理无效的JSON，但它很容易在主要平台上安装。</target>
        </trans-unit>
        <trans-unit id="183aff2d9559be018a3d12f2a43857228968028b" translate="yes" xml:space="preserve">
          <source>It is not too simple with a native way with &lt;a href=&quot;https://stedolan.github.io/jq/tutorial/&quot;&gt;the jq tools&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://stedolan.github.io/jq/tutorial/&quot;&gt;jq工具&lt;/a&gt;的本机方法并不是太简单。</target>
        </trans-unit>
        <trans-unit id="669752a463c782025aefa037d1597e7487795a1c" translate="yes" xml:space="preserve">
          <source>It is obviously also available on &lt;a href=&quot;http://search.cpan.org/~mlehmann/JSON-XS-2.3/bin/json_xs&quot;&gt;CPAN&lt;/a&gt;.</source>
          <target state="translated">它显然也可以在&lt;a href=&quot;http://search.cpan.org/~mlehmann/JSON-XS-2.3/bin/json_xs&quot;&gt;CPAN上使用&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="62671dd06c1d921cee833c0aae59219b3f828d7f" translate="yes" xml:space="preserve">
          <source>It shortens the code and gets the job done.</source>
          <target state="translated">它缩短了代码,完成了工作。</target>
        </trans-unit>
        <trans-unit id="bb041fd5d5bd7096c7957ecffe2bdffd416a5a42" translate="yes" xml:space="preserve">
          <source>It's very simple to use and it works great! It can handle very large JSON structures, including streams.  You can find
their tutorials &lt;a href=&quot;http://stedolan.github.com/jq/tutorial&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">使用非常简单，效果很好！ 它可以处理非常大的JSON结构，包括流。 您可以&lt;a href=&quot;http://stedolan.github.com/jq/tutorial&quot;&gt;在这里&lt;/a&gt;找到他们的教程。</target>
        </trans-unit>
        <trans-unit id="4fd641f387c5ea84ff81db159616c2bd1891ed03" translate="yes" xml:space="preserve">
          <source>It's worth mentioning that &lt;code&gt;json_pp&lt;/code&gt; comes pre-installed with Ubuntu 12.04 (at least) and Debian in &lt;code&gt;/usr/bin/json_pp&lt;/code&gt;</source>
          <target state="translated">值得一提的是 &lt;code&gt;json_pp&lt;/code&gt; 至少预装了Ubuntu 12.04和Debian，位于 &lt;code&gt;/usr/bin/json_pp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea595b3a7a53b8ed236a88cd0c1447a9218f30f1" translate="yes" xml:space="preserve">
          <source>Latest use-case: Chrome, Dev console, Network tab, export all as HAR file, &quot;cat site.har | underscore select '.url' --outfmt text | grep mydomain&quot;; now I have a chronologically ordered list of all URL fetches made during the loading of my company's site.</source>
          <target state="translated">underscore select '.url' --outfmt text Chrome,开发控制台,网络选项卡,导出全部为HAR文件,&quot;cat site.har&quot;。</target>
        </trans-unit>
        <trans-unit id="8cf745c7c9e86d5f300e9c6f3b16d0a129b8707b" translate="yes" xml:space="preserve">
          <source>NOTE: It is not &lt;em&gt;the&lt;/em&gt; way to do it.</source>
          <target state="translated">注意：这不是这样做&lt;em&gt;的&lt;/em&gt;方法。</target>
        </trans-unit>
        <trans-unit id="f8b86fdcfd8118e25e920f87856a7489f9d7dc83" translate="yes" xml:space="preserve">
          <source>Note 2:
If you run</source>
          <target state="translated">注2:如果你运行</target>
        </trans-unit>
        <trans-unit id="6e345a98f5b8c10ee284ef69054e5d03b8abd169" translate="yes" xml:space="preserve">
          <source>On *nix, reading from stdin and writing to stdout works better:</source>
          <target state="translated">在*nix平台上,从stdin读取并写到stdout效果更好。</target>
        </trans-unit>
        <trans-unit id="5a2a0ce7c6fbc34f2428caf2278f2aec9e8753f6" translate="yes" xml:space="preserve">
          <source>Or, with Ruby:</source>
          <target state="translated">或者说,与鲁比。</target>
        </trans-unit>
        <trans-unit id="6e30534c73dcc2557e0027d0bfc2c4d52c17fa41" translate="yes" xml:space="preserve">
          <source>Prettify the JSON file &lt;code&gt;src.json&lt;/code&gt; to &lt;code&gt;pretty.json&lt;/code&gt;:</source>
          <target state="translated">将JSON文件 &lt;code&gt;src.json&lt;/code&gt; 美化为 &lt;code&gt;pretty.json&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1576dced00150e68a3d308f019f2518c2c04e68c" translate="yes" xml:space="preserve">
          <source>Pretty print web service responses like so:</source>
          <target state="translated">漂亮的打印网服务的回复是这样的。</target>
        </trans-unit>
        <trans-unit id="94838a1d7ea443cd6e12978b50b56c00d3b34814" translate="yes" xml:space="preserve">
          <source>Pretty printing is easy:</source>
          <target state="translated">漂亮的印刷是很容易的。</target>
        </trans-unit>
        <trans-unit id="2c6e03977c1fc2f8de7bddd1d80c1dde9b1962cf" translate="yes" xml:space="preserve">
          <source>Put this in a file (I named mine &quot;prettyJSON&quot; after &lt;a href=&quot;https://stackoverflow.com/users/83069/anc&quot;&gt;AnC&lt;/a&gt;'s answer) in your PATH and &lt;code&gt;chmod +x&lt;/code&gt; it, and you're good to go.</source>
          <target state="translated">将此文件放入PATH中的文件中（我在&lt;a href=&quot;https://stackoverflow.com/users/83069/anc&quot;&gt;AnC&lt;/a&gt;的答案后命名为mine&amp;ldquo; prettyJSON&amp;rdquo;），然后对其进行 &lt;code&gt;chmod +x&lt;/code&gt; 调试 ，您就可以了。</target>
        </trans-unit>
        <trans-unit id="82581fe7ead045ef094219c4927c4169cba5987a" translate="yes" xml:space="preserve">
          <source>Pygmentize</source>
          <target state="translated">Pygmentize</target>
        </trans-unit>
        <trans-unit id="7749fcf802c472b6c2f5bd0556805e456ffd5674" translate="yes" xml:space="preserve">
          <source>Returns:</source>
          <target state="translated">Returns:</target>
        </trans-unit>
        <trans-unit id="1a75f81e5c26149ff705d63f33281d5a91ad18c7" translate="yes" xml:space="preserve">
          <source>Same thing, more explicit:</source>
          <target state="translated">同样的事情,更明确。</target>
        </trans-unit>
        <trans-unit id="a6abba0d984f928e92f1e863f9d70ad8dd483d41" translate="yes" xml:space="preserve">
          <source>Same thing:</source>
          <target state="translated">同样的事情。</target>
        </trans-unit>
        <trans-unit id="a8956667d88a5fb46037c3e79908b80f8e29035b" translate="yes" xml:space="preserve">
          <source>Script download:  &lt;a href=&quot;http://gist.github.com/3738968&quot;&gt;gist.github.com/3738968&lt;/a&gt;</source>
          <target state="translated">脚本下载： &lt;a href=&quot;http://gist.github.com/3738968&quot;&gt;gist.github.com/3738968&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="729a296e7900dba4208987915dbeaf65ad9bc8d9" translate="yes" xml:space="preserve">
          <source>Simply pipe the output to &lt;code&gt;jq .&lt;/code&gt;.</source>
          <target state="translated">只需将输出传递给 &lt;code&gt;jq .&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="feac1334ead53a83e0b00894813666d44adf3bd8" translate="yes" xml:space="preserve">
          <source>Thanks to J.F. Sebastian's very helpful pointers, here's a slightly enhanced script I've come up with:</source>
          <target state="translated">感谢J.F.Sebastian的指点,这里是我稍微加强了一点的剧本。</target>
        </trans-unit>
        <trans-unit id="d090fb0191553a01102bf35dec2221f80926b5a2" translate="yes" xml:space="preserve">
          <source>That's how I do it:</source>
          <target state="translated">我就是这样做的。</target>
        </trans-unit>
        <trans-unit id="c0701a55bb5fb5c51ebd73983d75ac7febe02399" translate="yes" xml:space="preserve">
          <source>The . is the identity filter.</source>
          <target state="translated">.是身份过滤器。</target>
        </trans-unit>
        <trans-unit id="0a82b0bb0d0b24eb60b94e64563aa0f6ff8badb3" translate="yes" xml:space="preserve">
          <source>The JSON Ruby Gem is bundled with a shell script to prettify JSON:</source>
          <target state="translated">JSON Ruby Gem 捆绑了一个shell脚本来美化JSON。</target>
        </trans-unit>
        <trans-unit id="c338e795f5e9dd037ed1c6b0374a48ff43b46a40" translate="yes" xml:space="preserve">
          <source>The huge advantage of jq is that it can do A LOT more if you'd like to parse and process the json.</source>
          <target state="translated">jq的巨大优势在于,如果你想解析和处理json,它可以做更多的事情。</target>
        </trans-unit>
        <trans-unit id="8f694fd51a4ec64caf357a104c04383ebcdb6c01" translate="yes" xml:space="preserve">
          <source>The same in Perl:</source>
          <target state="translated">Perl中也是如此。</target>
        </trans-unit>
        <trans-unit id="c166baa37013b76a1334eb446e80719360839f32" translate="yes" xml:space="preserve">
          <source>There are some alternatives to pygmentize which are listed in &lt;a href=&quot;https://stackoverflow.com/a/27501509/2670370&quot;&gt;my this answer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/27501509/2670370&quot;&gt;我的答案&lt;/a&gt;中列出了一些pygmentize的替代方法。</target>
        </trans-unit>
        <trans-unit id="5786a9adadbc2d45da3b07ead6c63e3b25751f95" translate="yes" xml:space="preserve">
          <source>This is what &quot;smart whitespace&quot; looks like:</source>
          <target state="translated">这就是 &quot;智能白板 &quot;的样子。</target>
        </trans-unit>
        <trans-unit id="c6bc3a011eb91a433b41f2b4f9592439c73ed55e" translate="yes" xml:space="preserve">
          <source>This tool is my current passion project, so if you have any feature requests, there is a good chance I'll address them.</source>
          <target state="translated">这个工具是我目前的激情项目,所以如果你有什么功能需求,我很有可能会解决。</target>
        </trans-unit>
        <trans-unit id="e4658089a251010d46235c8bb8a8f672d58a978a" translate="yes" xml:space="preserve">
          <source>To reformat as &lt;a href=&quot;http://en.wikipedia.org/wiki/YAML&quot;&gt;YAML&lt;/a&gt;, which some people consider to be more humanly-readable than JSON:</source>
          <target state="translated">要将其重新格式化为&lt;a href=&quot;http://en.wikipedia.org/wiki/YAML&quot;&gt;YAML&lt;/a&gt; ，有些人认为它比JSON更易读：</target>
        </trans-unit>
        <trans-unit id="41c68f28a7448336b39defcb1a52da8afe6cb9b6" translate="yes" xml:space="preserve">
          <source>To use it to format JSON obtained from a URL you can use curl or wget like this:</source>
          <target state="translated">要使用它来格式化从URL中获得的JSON,你可以使用curl或wget来格式化,就像这样。</target>
        </trans-unit>
        <trans-unit id="a7e52111d6dc833ddc7851e988849881bccb3953" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;https://github.com/igorgue/pjson&quot;&gt;&lt;code&gt;pjson&lt;/code&gt;&lt;/a&gt;. It has colors!</source>
          <target state="translated">尝试&lt;a href=&quot;https://github.com/igorgue/pjson&quot;&gt; &lt;code&gt;pjson&lt;/code&gt; &lt;/a&gt; 。 它有颜色！</target>
        </trans-unit>
        <trans-unit id="173610cb31251b28e80fadc258036215d99d7128" translate="yes" xml:space="preserve">
          <source>Usage examples:</source>
          <target state="translated">用例:</target>
        </trans-unit>
        <trans-unit id="8e9acd221cd54d14e27951022535d847c4b6a552" translate="yes" xml:space="preserve">
          <source>Using a pipe:</source>
          <target state="translated">用管子。</target>
        </trans-unit>
        <trans-unit id="6057ff470ba577346db3c6189754426752d17bb9" translate="yes" xml:space="preserve">
          <source>Validate:</source>
          <target state="translated">Validate:</target>
        </trans-unit>
        <trans-unit id="04b71b57ef11300f92c8a294e6b7871aac01ae89" translate="yes" xml:space="preserve">
          <source>With Perl, if you install &lt;a href=&quot;http://search.cpan.org/dist/JSON-PP/&quot;&gt;JSON::PP&lt;/a&gt; from CPAN you'll get the &lt;a href=&quot;http://search.cpan.org/perldoc?json_pp&quot;&gt;json_pp&lt;/a&gt; command.  Stealing the &lt;a href=&quot;https://stackoverflow.com/questions/352098/how-to-pretty-print-json-script/1920585#1920585&quot;&gt;example&lt;/a&gt; from &lt;a href=&quot;https://stackoverflow.com/users/233648/b-bycroft&quot;&gt;B Bycroft&lt;/a&gt; you get:</source>
          <target state="translated">使用Perl，如果从CPAN安装&lt;a href=&quot;http://search.cpan.org/dist/JSON-PP/&quot;&gt;JSON :: PP&lt;/a&gt; ，则将获得&lt;a href=&quot;http://search.cpan.org/perldoc?json_pp&quot;&gt;json_pp&lt;/a&gt;命令。 从&lt;a href=&quot;https://stackoverflow.com/users/233648/b-bycroft&quot;&gt;B Bycroft&lt;/a&gt;窃取&lt;a href=&quot;https://stackoverflow.com/questions/352098/how-to-pretty-print-json-script/1920585#1920585&quot;&gt;示例&lt;/a&gt; ，您将获得：</target>
        </trans-unit>
        <trans-unit id="bbe2430795ada5c918ef4fd2a921eb0efe2b1951" translate="yes" xml:space="preserve">
          <source>With Perl, use the CPAN module &lt;code&gt;JSON::XS&lt;/code&gt;. It installs a command line tool &lt;code&gt;json_xs&lt;/code&gt;.</source>
          <target state="translated">对于Perl，请使用CPAN模块 &lt;code&gt;JSON::XS&lt;/code&gt; 。 它安装了命令行工具 &lt;code&gt;json_xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2721ddefc8ec55875c238236341b3372ea2e2f7" translate="yes" xml:space="preserve">
          <source>With Python 2.6+ you can just do:</source>
          <target state="translated">有了Python 2.6+,你可以直接做。</target>
        </trans-unit>
        <trans-unit id="ec9137815fae6a13f9735eb057129ad18e846b9b" translate="yes" xml:space="preserve">
          <source>You can also pass arguments to transform the JSON data.</source>
          <target state="translated">你也可以通过参数来转换JSON数据。</target>
        </trans-unit>
        <trans-unit id="beb665e3f43fdb8a841c16b9a74b56f776eab6ca" translate="yes" xml:space="preserve">
          <source>You can simply use standard tools like jq or json_pp.</source>
          <target state="translated">你可以简单地使用标准工具,如jq或json_pp。</target>
        </trans-unit>
        <trans-unit id="0cc843a8c1d597487a53a62cee69c07c3225f171" translate="yes" xml:space="preserve">
          <source>You can use this simple command to achieve the result:</source>
          <target state="translated">你可以用这个简单的命令来达到效果。</target>
        </trans-unit>
        <trans-unit id="4e5211fa9265ba94dd3dc2bccc58cc8910690278" translate="yes" xml:space="preserve">
          <source>You can use: &lt;a href=&quot;http://stedolan.github.com/jq&quot;&gt;&lt;code&gt;jq&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">您可以使用： &lt;a href=&quot;http://stedolan.github.com/jq&quot;&gt; &lt;code&gt;jq&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac3a6f60f4e628dfc19fae2fcb3577ad9823944b" translate="yes" xml:space="preserve">
          <source>a simple bash script for pretty json printing</source>
          <target state="translated">一个简单的bash脚本,用于漂亮的json打印的简单脚本</target>
        </trans-unit>
        <trans-unit id="5165f8a7a89fa6bd8f69b86aab76723eb9357154" translate="yes" xml:space="preserve">
          <source>and make beautiful the files running around on your disk:</source>
          <target state="translated">并使文件在你的磁盘上运行的美丽。</target>
        </trans-unit>
        <trans-unit id="a357a0b3b6bb01e41a042b584904f6b12375f3f1" translate="yes" xml:space="preserve">
          <source>and then</source>
          <target state="translated">而后</target>
        </trans-unit>
        <trans-unit id="5c556c0d2fa45fada329a718dc69afa88a6f16b0" translate="yes" xml:space="preserve">
          <source>and to format JSON contained in a file you can do this:</source>
          <target state="translated">而要格式化一个文件中包含的JSON,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="3698853e42e2afb632488aae6e31da627858b112" translate="yes" xml:space="preserve">
          <source>and you'll get:</source>
          <target state="translated">而你会得到。</target>
        </trans-unit>
        <trans-unit id="5592a069ea3f28056a831dda2ff26b71f5219950" translate="yes" xml:space="preserve">
          <source>for all the above cases. You can put this in &lt;code&gt;.bashrc&lt;/code&gt; and it will be available every time in shell. Invoke it like &lt;code&gt;prettyjson_s '{&quot;foo&quot;: &quot;lorem&quot;, &quot;bar&quot;: &quot;ipsum&quot;}'&lt;/code&gt;.</source>
          <target state="translated">以上所有情况。 您可以将其放在 &lt;code&gt;.bashrc&lt;/code&gt; 中,并且每次在Shell中都可用。 像 &lt;code&gt;prettyjson_s '{&quot;foo&quot;: &quot;lorem&quot;, &quot;bar&quot;: &quot;ipsum&quot;}'&lt;/code&gt; 一样调用它。</target>
        </trans-unit>
        <trans-unit id="3f04c30758d01c486aa292d322c2466007d62485" translate="yes" xml:space="preserve">
          <source>if the JSON is from an internet source such as an API, you can use</source>
          <target state="translated">如果JSON是来自互联网源,如API,你可以使用</target>
        </trans-unit>
        <trans-unit id="8822d1e4cffc1581f1ed5e458592fbcc45490d29" translate="yes" xml:space="preserve">
          <source>json_pretty.sh</source>
          <target state="translated">json_pretty.sh</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">或者是这样的。</target>
        </trans-unit>
        <trans-unit id="6683a028e6a0bbf2249b22f1af28b21b00ca5102" translate="yes" xml:space="preserve">
          <source>or, if the JSON is in a file, you can do:</source>
          <target state="translated">或者,如果JSON在一个文件中,你可以做。</target>
        </trans-unit>
        <trans-unit id="6459833e2bfc11d16a93a3cda57d211c8299f9d1" translate="yes" xml:space="preserve">
          <source>the nicely readable word becomes \u encoded</source>
          <target state="translated">可读性好的词变成了编码的词</target>
        </trans-unit>
        <trans-unit id="b804662fb4789f2726c6b0cdc6bffed73b78c7ab" translate="yes" xml:space="preserve">
          <source>then,</source>
          <target state="translated">then,</target>
        </trans-unit>
        <trans-unit id="6e3b1a45b1d3a64ccddfbe8df1daea6fe135ec81" translate="yes" xml:space="preserve">
          <source>underscore-cli</source>
          <target state="translated">underscore-cli</target>
        </trans-unit>
        <trans-unit id="7dc5c767306ee3075238aa6c43cbe928b97113e5" translate="yes" xml:space="preserve">
          <source>will both prettify output like the following (jq even more colorful):</source>
          <target state="translated">都会像下面这样对输出进行预处理(jq更加丰富多彩)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
