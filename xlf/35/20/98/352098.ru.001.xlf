<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/352098">
    <body>
      <group id="352098">
        <trans-unit id="c2b21c5dca0f8a3a5e3a8913a7c60d9e43912c15" translate="yes" xml:space="preserve">
          <source>(example: &lt;code&gt;curl localhost:5000/blocks | jq&lt;/code&gt;)</source>
          <target state="translated">(пример: &lt;code&gt;curl localhost:5000/blocks | jq&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="eff15212915025452a077b7d193862752aff0748" translate="yes" xml:space="preserve">
          <source>... into something like this:</source>
          <target state="translated">...во что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="ccf47cdeb293f0ccc497d23213931545afc5ac72" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsonlint.com/&quot;&gt;JSONLint&lt;/a&gt; has an &lt;a href=&quot;https://github.com/zaach/jsonlint&quot;&gt;open-source implementation on GitHub&lt;/a&gt; that can be used on the command line or included in a Node.js project.</source>
          <target state="translated">&lt;a href=&quot;http://jsonlint.com/&quot;&gt;JSONLint&lt;/a&gt; имеет реализацию с &lt;a href=&quot;https://github.com/zaach/jsonlint&quot;&gt;открытым исходным кодом на GitHub,&lt;/a&gt; которую можно использовать в командной строке или включить в проект Node.js.</target>
        </trans-unit>
        <trans-unit id="65ffdca0ef159c53c6bccffc11b0aa9494ecdeab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/jmhodges/jsonpp&quot;&gt;jsonpp&lt;/a&gt; is a very nice command line JSON pretty printer.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/jmhodges/jsonpp&quot;&gt;jsonpp&lt;/a&gt; - очень приятный принтер для командной строки.</target>
        </trans-unit>
        <trans-unit id="5d01ad35b562f7f9080fc17394d697b4762ba688" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/sharkdp/bat&quot;&gt;&lt;code&gt;bat&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;cat&lt;/code&gt; clone with syntax highlighting:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/sharkdp/bat&quot;&gt; &lt;code&gt;bat&lt;/code&gt; &lt;/a&gt; - клон &lt;code&gt;cat&lt;/code&gt; с подсветкой синтаксиса:</target>
        </trans-unit>
        <trans-unit id="11ec9a9b9955f5569a0be3167d367d46f7339d7c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tidwall/jj&quot;&gt;jj&lt;/a&gt; is super-fast, can handle ginormous JSON documents economically, does not mess with valid JSON numbers, and is easy to use, e.g.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tidwall/jj&quot;&gt;jj&lt;/a&gt; работает очень быстро, может экономно обрабатывать огромные JSON-документы, не работает с действительными числами JSON и прост в использовании, например:</target>
        </trans-unit>
        <trans-unit id="9fc0e3abbbceabb9d15486ba1cee7465326fa952" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-p&lt;/code&gt; will output without headers, and &lt;code&gt;-l&lt;/code&gt; will explicitly specify the language.</source>
          <target state="translated">&lt;code&gt;-p&lt;/code&gt; выведет без заголовков, а &lt;code&gt;-l&lt;/code&gt; явно укажет язык.</target>
        </trans-unit>
        <trans-unit id="1a8afa7777815b16c1d872e70a45dba35c28654f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt; I'm using &lt;code&gt;jq&lt;/code&gt; now as suggested in another answer. It's extremely powerful at filtering JSON, but, at its most basic, also an awesome way to pretty print JSON for viewing.</source>
          <target state="translated">&lt;strong&gt;ОБНОВЛЕНИЕ&lt;/strong&gt; Я использую &lt;code&gt;jq&lt;/code&gt; сейчас, как это предлагается в другом ответе. Он чрезвычайно эффективен при фильтрации JSON, но, по своей сути, также является отличным способом печати JSON для просмотра.</target>
        </trans-unit>
        <trans-unit id="558d01555dcc98ed3d3c6d8549b4af8d358becac" translate="yes" xml:space="preserve">
          <source>And then pipe any JSON content to &lt;code&gt;pjson&lt;/code&gt;.</source>
          <target state="translated">А затем &lt;code&gt;pjson&lt;/code&gt; любой контент JSON в pjson .</target>
        </trans-unit>
        <trans-unit id="2deac98f0979bc538865ceca91376bded4586346" translate="yes" xml:space="preserve">
          <source>And to retrieve select data (in this case, &quot;test&quot;'s value):</source>
          <target state="translated">И извлечь выбранные данные (в данном случае-&quot;тестовое&quot; значение):</target>
        </trans-unit>
        <trans-unit id="a8877b9cd466e709cb219df12e612288bd73695a" translate="yes" xml:space="preserve">
          <source>Basically, I want it to transform the following:</source>
          <target state="translated">По сути,я хочу,чтобы это трансформировало следующее:</target>
        </trans-unit>
        <trans-unit id="e526d0b82dfd82b5b92416610771e8b48e737efe" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://github.com/mconigliaro/jazor&quot;&gt;Jazor&lt;/a&gt;. It's a simple command line JSON parser written in Ruby.</source>
          <target state="translated">Проверьте &lt;a href=&quot;https://github.com/mconigliaro/jazor&quot;&gt;Jazor&lt;/a&gt; . Это простой JSON-анализатор командной строки, написанный на Ruby.</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2a7e2ee750b232b776d1e0f6bba195affff6bbd4" translate="yes" xml:space="preserve">
          <source>For convenience in all of these cases you can make an alias:</source>
          <target state="translated">Для удобства во всех этих случаях можно сделать псевдоним:</target>
        </trans-unit>
        <trans-unit id="8bded8109814c9b0dc25f326bc700c50e4e0db85" translate="yes" xml:space="preserve">
          <source>For even more convenience with a bit more typing to get it ready:</source>
          <target state="translated">Для еще большего удобства с немного больше набора текста,чтобы подготовить его:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="a265f88f8efe1b02478906424759d729b930ae30" translate="yes" xml:space="preserve">
          <source>From the README:</source>
          <target state="translated">Из &quot;README&quot;:</target>
        </trans-unit>
        <trans-unit id="9399153ff98e7cbe217ca05a05415e027818b1b6" translate="yes" xml:space="preserve">
          <source>From the Unix command-line with Node.js, specifying JSON on the command line:</source>
          <target state="translated">Из командной строки Unix с помощью Node.js,указав JSON в командной строке:</target>
        </trans-unit>
        <trans-unit id="ab14fffdbdc684c4e6464af946966b06426d55b0" translate="yes" xml:space="preserve">
          <source>From the Unix command-line with Node.js, specifying a filename that contains JSON, and using an indent of four spaces:</source>
          <target state="translated">Из командной строки Unix с помощью Node.js,указывающей имя файла,содержащего JSON,и использующей отступ с четырьмя пробелами:</target>
        </trans-unit>
        <trans-unit id="6df6c42a5832b66a784567af76f261dd90b20e3c" translate="yes" xml:space="preserve">
          <source>Here is a live demo:</source>
          <target state="translated">Вот живая демонстрация:</target>
        </trans-unit>
        <trans-unit id="638071c88b16c8f77a19ace5c6837cf529e7f268" translate="yes" xml:space="preserve">
          <source>How can I pretty-print JSON in a shell script</source>
          <target state="translated">Как я могу распечатать JSON в скрипте оболочки.</target>
        </trans-unit>
        <trans-unit id="870e84646da256de256a8e67a8ee08dfa3b8edbb" translate="yes" xml:space="preserve">
          <source>I combine Python's json.tool with pygmentize:</source>
          <target state="translated">Я совмещаю инструмент Пайтона с пигментизом:</target>
        </trans-unit>
        <trans-unit id="fa550568eb173ef55f0f2e58ff95516042a7fda1" translate="yes" xml:space="preserve">
          <source>I may be a bit biased, but it's an awesome tool for printing and manipulating JSON data from the command-line. It's super-friendly to use and has extensive command-line help/documentation. It's a Swiss Army knife that I use for 1001 different small tasks that would be surprisingly annoying to do any other way.</source>
          <target state="translated">Может быть,я и немного предвзят,но это потрясающий инструмент для печати и манипулирования JSON-данными из командной строки.Он очень удобен в использовании и имеет обширную справочную документацию из командной строки.Это швейцарский армейский нож,который я использую для 1001 различных небольших задач,что было бы удивительно раздражающе делать любым другим способом.</target>
        </trans-unit>
        <trans-unit id="606a0c4bd6be5bc2c19edf5aa9dfed70ee856514" translate="yes" xml:space="preserve">
          <source>I recommend using the json_xs command line utility which is included in the JSON::XS perl module. JSON::XS is a Perl module for serializing/deserializing JSON, on a Debian or Ubuntu machine you can install it like this:</source>
          <target state="translated">Я рекомендую использовать утилиту командной строки json_xs,которая входит в состав модуля JSON::XS perl.JSON::XS-это Perl-модуль для сериализации JSON,на машину Debian или Ubuntu вы можете установить его так:</target>
        </trans-unit>
        <trans-unit id="a31d2fb698bfa23a0bb003098c02af5ec5790eab" translate="yes" xml:space="preserve">
          <source>I use &lt;a href=&quot;http://kmkeen.com/jshon/&quot;&gt;jshon&lt;/a&gt; to do exactly what you're describing. Just run:</source>
          <target state="translated">Я использую &lt;a href=&quot;http://kmkeen.com/jshon/&quot;&gt;jshon,&lt;/a&gt; чтобы делать именно то, что вы описываете. Просто беги:</target>
        </trans-unit>
        <trans-unit id="5f71a5242fca6ebf28b369924ab84a5d40d8bfb6" translate="yes" xml:space="preserve">
          <source>I use the &quot;space&quot; argument of &lt;a href=&quot;http://es5.github.io/#x15.12.3&quot;&gt;&lt;code&gt;JSON.stringify&lt;/code&gt;&lt;/a&gt; to pretty-print JSON in JavaScript.</source>
          <target state="translated">Я использую аргумент &amp;laquo;пробел&amp;raquo; &lt;a href=&quot;http://es5.github.io/#x15.12.3&quot;&gt; &lt;code&gt;JSON.stringify&lt;/code&gt; ,&lt;/a&gt; чтобы красиво печатать JSON в JavaScript.</target>
        </trans-unit>
        <trans-unit id="82a06354b6938a34330cac58ea4b5cb6e7137340" translate="yes" xml:space="preserve">
          <source>I usually just do:</source>
          <target state="translated">Обычно я так и делаю:</target>
        </trans-unit>
        <trans-unit id="7f1f7c39fe55184fcf4428f66ed3cdcd924fafd4" translate="yes" xml:space="preserve">
          <source>I wrote a tool that has one of the best &quot;smart whitespace&quot; formatters available. It produces more readable and less verbose output than most of the other options here.</source>
          <target state="translated">Я написал инструмент,который имеет один из лучших доступных форматов &quot;умных пробельных символов&quot;.Он производит более читабельный и менее подробный вывод,чем большинство других вариантов здесь.</target>
        </trans-unit>
        <trans-unit id="bf4b73e090df4af8ca69d20b237a46ac646babb1" translate="yes" xml:space="preserve">
          <source>If the JSON data is in a file:</source>
          <target state="translated">Если данные JSON находятся в файле:</target>
        </trans-unit>
        <trans-unit id="b125c7ff6503ee2e6e42e63180f50dd876244ee6" translate="yes" xml:space="preserve">
          <source>If the remainder of your pipeline will gracefully handle unicode and you'd like your JSON to also be human-friendly, simply &lt;a href=&quot;https://docs.python.org/2/library/json.html&quot;&gt;use&lt;/a&gt;&lt;code&gt;ensure_ascii=False&lt;/code&gt;</source>
          <target state="translated">Если остальная часть вашего конвейера будет корректно обрабатывать Unicode, и вы хотите, чтобы ваш JSON также был дружественным к человеку, просто &lt;a href=&quot;https://docs.python.org/2/library/json.html&quot;&gt;используйте&lt;/a&gt; &lt;code&gt;ensure_ascii=False&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5174c4b3fc22706a455ee505125ef4a49cf154eb" translate="yes" xml:space="preserve">
          <source>If you don't have &lt;code&gt;json_xs&lt;/code&gt;, try &lt;code&gt;json_pp&lt;/code&gt; . &quot;pp&quot; is for &quot;pure perl&quot; &amp;ndash; the tool is implemented in Perl only, without a binding to an external C library (which is what XS stands for, Perl's &quot;Extension System&quot;).</source>
          <target state="translated">Если у вас нет &lt;code&gt;json_xs&lt;/code&gt; , попробуйте &lt;code&gt;json_pp&lt;/code&gt; . &amp;laquo;pp&amp;raquo; для &amp;laquo;чистого perl&amp;raquo; - инструмент реализован только на Perl, без привязки к внешней библиотеке C (что и обозначает XS, Perl &amp;laquo;Extension System&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="89f8c3ae28bbaf3b056d461bae9d9283fbf143fb" translate="yes" xml:space="preserve">
          <source>If you use npm and Node.js, you can do &lt;code&gt;npm install -g json&lt;/code&gt; and then pipe the command through &lt;code&gt;json&lt;/code&gt;.  Do &lt;code&gt;json -h&lt;/code&gt; to get all the options. It can also pull out specific fields and colorize the output with &lt;code&gt;-i&lt;/code&gt;.</source>
          <target state="translated">Если вы используете npm и Node.js, вы можете выполнить &lt;code&gt;npm install -g json&lt;/code&gt; и затем передать команду через &lt;code&gt;json&lt;/code&gt; . Сделайте &lt;code&gt;json -h&lt;/code&gt; чтобы получить все варианты. Он также может извлекать определенные поля и раскрашивать вывод с помощью &lt;code&gt;-i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ac9e9fb4727ee8563034227abbd5e41b4dd9ada" translate="yes" xml:space="preserve">
          <source>If you want to do it all in one go with &lt;code&gt;curl&lt;/code&gt; on the command line using an authentication token:</source>
          <target state="translated">Если вы хотите сделать все это за один раз, &lt;code&gt;curl&lt;/code&gt; в командной строке, используя маркер аутентификации:</target>
        </trans-unit>
        <trans-unit id="0cdd645852f8484e24950b690e025af50241844b" translate="yes" xml:space="preserve">
          <source>If you're on Mac OS X, you can &lt;code&gt;brew install jsonpp&lt;/code&gt;. If not, you can simply copy the binary to somewhere in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">Если вы работаете в Mac OS X, вы можете &lt;code&gt;brew install jsonpp&lt;/code&gt; . Если нет, вы можете просто скопировать двоичный файл куда-нибудь в &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b24d311a42dcbec1e7dfe04f8b94a7c69f1df1a" translate="yes" xml:space="preserve">
          <source>Install it with &lt;code&gt;pip&lt;/code&gt;:</source>
          <target state="translated">Установите его с помощью &lt;code&gt;pip&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a102c20a34e15bf9150429aa671f99e79dd225d9" translate="yes" xml:space="preserve">
          <source>Install yajl-tools with the command below:</source>
          <target state="translated">Установите яйл-инструменты с помощью команды ниже:</target>
        </trans-unit>
        <trans-unit id="dd5c7a96e4392f1fd17e1cf640379bcd73a90892" translate="yes" xml:space="preserve">
          <source>Is there a (Unix) shell script to format JSON in human-readable form?</source>
          <target state="translated">Существует ли (Unix)скрипт оболочки для форматирования JSON в читаемом человеком виде?</target>
        </trans-unit>
        <trans-unit id="919abba41f1da02f9fb484f1c3f528e466269bfb" translate="yes" xml:space="preserve">
          <source>It has colouring and formatting for JSON and does &lt;em&gt;not&lt;/em&gt; have the problems noted in this comment: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/352098/how-can-i-pretty-print-json-in-a-unix-shell-script#comment52647558_15231463&quot;&gt;How can I pretty-print JSON in a shell script?&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Он имеет раскраску и форматирование для JSON и &lt;em&gt;не&lt;/em&gt; имеет проблем, отмеченных в этом комментарии: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/352098/how-can-i-pretty-print-json-in-a-unix-shell-script#comment52647558_15231463&quot;&gt;Как я могу красиво напечатать JSON в сценарии оболочки?&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96f130b38b043342182e4e0595a0a71c31b35a14" translate="yes" xml:space="preserve">
          <source>It is (2018) still quite new so maybe it won&amp;rsquo;t handle invalid JSON the way you expect, but it is easy to install on major platforms.</source>
          <target state="translated">Он (2018) все еще довольно новый, поэтому, возможно, он не будет обрабатывать недействительный JSON, как вы ожидаете, но его легко установить на основные платформы.</target>
        </trans-unit>
        <trans-unit id="183aff2d9559be018a3d12f2a43857228968028b" translate="yes" xml:space="preserve">
          <source>It is not too simple with a native way with &lt;a href=&quot;https://stedolan.github.io/jq/tutorial/&quot;&gt;the jq tools&lt;/a&gt;.</source>
          <target state="translated">Это не слишком просто с нативным способом с &lt;a href=&quot;https://stedolan.github.io/jq/tutorial/&quot;&gt;помощью инструментов jq&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="669752a463c782025aefa037d1597e7487795a1c" translate="yes" xml:space="preserve">
          <source>It is obviously also available on &lt;a href=&quot;http://search.cpan.org/~mlehmann/JSON-XS-2.3/bin/json_xs&quot;&gt;CPAN&lt;/a&gt;.</source>
          <target state="translated">Это очевидно также доступно на &lt;a href=&quot;http://search.cpan.org/~mlehmann/JSON-XS-2.3/bin/json_xs&quot;&gt;CPAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62671dd06c1d921cee833c0aae59219b3f828d7f" translate="yes" xml:space="preserve">
          <source>It shortens the code and gets the job done.</source>
          <target state="translated">Он сокращает код и выполняет работу.</target>
        </trans-unit>
        <trans-unit id="bb041fd5d5bd7096c7957ecffe2bdffd416a5a42" translate="yes" xml:space="preserve">
          <source>It's very simple to use and it works great! It can handle very large JSON structures, including streams.  You can find
their tutorials &lt;a href=&quot;http://stedolan.github.com/jq/tutorial&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Он очень прост в использовании и отлично работает! Он может обрабатывать очень большие структуры JSON, включая потоки. Вы можете найти их уроки &lt;a href=&quot;http://stedolan.github.com/jq/tutorial&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fd641f387c5ea84ff81db159616c2bd1891ed03" translate="yes" xml:space="preserve">
          <source>It's worth mentioning that &lt;code&gt;json_pp&lt;/code&gt; comes pre-installed with Ubuntu 12.04 (at least) and Debian in &lt;code&gt;/usr/bin/json_pp&lt;/code&gt;</source>
          <target state="translated">Стоит отметить, что &lt;code&gt;json_pp&lt;/code&gt; предустановлен с Ubuntu 12.04 (по крайней мере) и Debian в &lt;code&gt;/usr/bin/json_pp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea595b3a7a53b8ed236a88cd0c1447a9218f30f1" translate="yes" xml:space="preserve">
          <source>Latest use-case: Chrome, Dev console, Network tab, export all as HAR file, &quot;cat site.har | underscore select '.url' --outfmt text | grep mydomain&quot;; now I have a chronologically ordered list of all URL fetches made during the loading of my company's site.</source>
          <target state="translated">underscore select '.url' --outfmt text Chrome,консоль Dev,вкладка Network,экспортировать все как HAR-файл,&quot;cat site.har&quot;.</target>
        </trans-unit>
        <trans-unit id="8cf745c7c9e86d5f300e9c6f3b16d0a129b8707b" translate="yes" xml:space="preserve">
          <source>NOTE: It is not &lt;em&gt;the&lt;/em&gt; way to do it.</source>
          <target state="translated">ПРИМЕЧАНИЕ: это не способ сделать это.</target>
        </trans-unit>
        <trans-unit id="f8b86fdcfd8118e25e920f87856a7489f9d7dc83" translate="yes" xml:space="preserve">
          <source>Note 2:
If you run</source>
          <target state="translated">Примечание 2:Если вы бежите</target>
        </trans-unit>
        <trans-unit id="6e345a98f5b8c10ee284ef69054e5d03b8abd169" translate="yes" xml:space="preserve">
          <source>On *nix, reading from stdin and writing to stdout works better:</source>
          <target state="translated">На *никс,чтение от stdin и письмо к stdout работает лучше:</target>
        </trans-unit>
        <trans-unit id="5a2a0ce7c6fbc34f2428caf2278f2aec9e8753f6" translate="yes" xml:space="preserve">
          <source>Or, with Ruby:</source>
          <target state="translated">Или,с Руби:</target>
        </trans-unit>
        <trans-unit id="6e30534c73dcc2557e0027d0bfc2c4d52c17fa41" translate="yes" xml:space="preserve">
          <source>Prettify the JSON file &lt;code&gt;src.json&lt;/code&gt; to &lt;code&gt;pretty.json&lt;/code&gt;:</source>
          <target state="translated">Откорректируйте файл JSON &lt;code&gt;src.json&lt;/code&gt; до &lt;code&gt;pretty.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1576dced00150e68a3d308f019f2518c2c04e68c" translate="yes" xml:space="preserve">
          <source>Pretty print web service responses like so:</source>
          <target state="translated">Симпатичные ответы веб-службы печати:</target>
        </trans-unit>
        <trans-unit id="94838a1d7ea443cd6e12978b50b56c00d3b34814" translate="yes" xml:space="preserve">
          <source>Pretty printing is easy:</source>
          <target state="translated">Симпатичная печать-это легко:</target>
        </trans-unit>
        <trans-unit id="2c6e03977c1fc2f8de7bddd1d80c1dde9b1962cf" translate="yes" xml:space="preserve">
          <source>Put this in a file (I named mine &quot;prettyJSON&quot; after &lt;a href=&quot;https://stackoverflow.com/users/83069/anc&quot;&gt;AnC&lt;/a&gt;'s answer) in your PATH and &lt;code&gt;chmod +x&lt;/code&gt; it, and you're good to go.</source>
          <target state="translated">Поместите это в файл (я назвал мой &quot;prettyJSON&quot; после &lt;a href=&quot;https://stackoverflow.com/users/83069/anc&quot;&gt;ответа AnC&lt;/a&gt; ) в вашем PATH и &lt;code&gt;chmod +x&lt;/code&gt; it, и все готово .</target>
        </trans-unit>
        <trans-unit id="82581fe7ead045ef094219c4927c4169cba5987a" translate="yes" xml:space="preserve">
          <source>Pygmentize</source>
          <target state="translated">Pygmentize</target>
        </trans-unit>
        <trans-unit id="7749fcf802c472b6c2f5bd0556805e456ffd5674" translate="yes" xml:space="preserve">
          <source>Returns:</source>
          <target state="translated">Returns:</target>
        </trans-unit>
        <trans-unit id="1a75f81e5c26149ff705d63f33281d5a91ad18c7" translate="yes" xml:space="preserve">
          <source>Same thing, more explicit:</source>
          <target state="translated">То же самое,более откровенно:</target>
        </trans-unit>
        <trans-unit id="a6abba0d984f928e92f1e863f9d70ad8dd483d41" translate="yes" xml:space="preserve">
          <source>Same thing:</source>
          <target state="translated">То же самое:</target>
        </trans-unit>
        <trans-unit id="a8956667d88a5fb46037c3e79908b80f8e29035b" translate="yes" xml:space="preserve">
          <source>Script download:  &lt;a href=&quot;http://gist.github.com/3738968&quot;&gt;gist.github.com/3738968&lt;/a&gt;</source>
          <target state="translated">Скрипт загрузки: &lt;a href=&quot;http://gist.github.com/3738968&quot;&gt;gist.github.com/3738968&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="729a296e7900dba4208987915dbeaf65ad9bc8d9" translate="yes" xml:space="preserve">
          <source>Simply pipe the output to &lt;code&gt;jq .&lt;/code&gt;.</source>
          <target state="translated">Просто &lt;code&gt;jq .&lt;/code&gt; вывод в JQ. ,</target>
        </trans-unit>
        <trans-unit id="feac1334ead53a83e0b00894813666d44adf3bd8" translate="yes" xml:space="preserve">
          <source>Thanks to J.F. Sebastian's very helpful pointers, here's a slightly enhanced script I've come up with:</source>
          <target state="translated">Благодаря очень полезным указателям Дж.Ф.Себастьяна,вот немного улучшенный сценарий,который я придумал:</target>
        </trans-unit>
        <trans-unit id="d090fb0191553a01102bf35dec2221f80926b5a2" translate="yes" xml:space="preserve">
          <source>That's how I do it:</source>
          <target state="translated">Вот как я это делаю:</target>
        </trans-unit>
        <trans-unit id="c0701a55bb5fb5c51ebd73983d75ac7febe02399" translate="yes" xml:space="preserve">
          <source>The . is the identity filter.</source>
          <target state="translated">Это...фильтр идентификации.</target>
        </trans-unit>
        <trans-unit id="0a82b0bb0d0b24eb60b94e64563aa0f6ff8badb3" translate="yes" xml:space="preserve">
          <source>The JSON Ruby Gem is bundled with a shell script to prettify JSON:</source>
          <target state="translated">JSON Ruby Gem поставляется в комплекте со скриптом оболочки для притворства JSON:</target>
        </trans-unit>
        <trans-unit id="c338e795f5e9dd037ed1c6b0374a48ff43b46a40" translate="yes" xml:space="preserve">
          <source>The huge advantage of jq is that it can do A LOT more if you'd like to parse and process the json.</source>
          <target state="translated">Огромным преимуществом jq является то,что он может сделать A LOT больше,если вы хотите разобрать и обработать json.</target>
        </trans-unit>
        <trans-unit id="8f694fd51a4ec64caf357a104c04383ebcdb6c01" translate="yes" xml:space="preserve">
          <source>The same in Perl:</source>
          <target state="translated">То же самое в Перле:</target>
        </trans-unit>
        <trans-unit id="c166baa37013b76a1334eb446e80719360839f32" translate="yes" xml:space="preserve">
          <source>There are some alternatives to pygmentize which are listed in &lt;a href=&quot;https://stackoverflow.com/a/27501509/2670370&quot;&gt;my this answer&lt;/a&gt;.</source>
          <target state="translated">Есть несколько альтернатив пигментированию, которые перечислены в &lt;a href=&quot;https://stackoverflow.com/a/27501509/2670370&quot;&gt;моем ответе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5786a9adadbc2d45da3b07ead6c63e3b25751f95" translate="yes" xml:space="preserve">
          <source>This is what &quot;smart whitespace&quot; looks like:</source>
          <target state="translated">Вот как выглядит &quot;умный белый пробел&quot;:</target>
        </trans-unit>
        <trans-unit id="c6bc3a011eb91a433b41f2b4f9592439c73ed55e" translate="yes" xml:space="preserve">
          <source>This tool is my current passion project, so if you have any feature requests, there is a good chance I'll address them.</source>
          <target state="translated">Этот инструмент является моим текущим страстным проектом,так что если у вас есть какие-то пожелания к функциям,есть большая вероятность,что я обращусь к ним.</target>
        </trans-unit>
        <trans-unit id="e4658089a251010d46235c8bb8a8f672d58a978a" translate="yes" xml:space="preserve">
          <source>To reformat as &lt;a href=&quot;http://en.wikipedia.org/wiki/YAML&quot;&gt;YAML&lt;/a&gt;, which some people consider to be more humanly-readable than JSON:</source>
          <target state="translated">Чтобы переформатировать как &lt;a href=&quot;http://en.wikipedia.org/wiki/YAML&quot;&gt;YAML&lt;/a&gt; , который некоторые люди считают более понятным для человека, чем JSON:</target>
        </trans-unit>
        <trans-unit id="41c68f28a7448336b39defcb1a52da8afe6cb9b6" translate="yes" xml:space="preserve">
          <source>To use it to format JSON obtained from a URL you can use curl or wget like this:</source>
          <target state="translated">Чтобы использовать его для форматирования JSON,полученного по URL,можно использовать curl или wget:</target>
        </trans-unit>
        <trans-unit id="a7e52111d6dc833ddc7851e988849881bccb3953" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;https://github.com/igorgue/pjson&quot;&gt;&lt;code&gt;pjson&lt;/code&gt;&lt;/a&gt;. It has colors!</source>
          <target state="translated">Попробуй &lt;a href=&quot;https://github.com/igorgue/pjson&quot;&gt; &lt;code&gt;pjson&lt;/code&gt; &lt;/a&gt; . У него есть цвета!</target>
        </trans-unit>
        <trans-unit id="173610cb31251b28e80fadc258036215d99d7128" translate="yes" xml:space="preserve">
          <source>Usage examples:</source>
          <target state="translated">Примеры использования:</target>
        </trans-unit>
        <trans-unit id="8e9acd221cd54d14e27951022535d847c4b6a552" translate="yes" xml:space="preserve">
          <source>Using a pipe:</source>
          <target state="translated">Используя трубу:</target>
        </trans-unit>
        <trans-unit id="6057ff470ba577346db3c6189754426752d17bb9" translate="yes" xml:space="preserve">
          <source>Validate:</source>
          <target state="translated">Validate:</target>
        </trans-unit>
        <trans-unit id="04b71b57ef11300f92c8a294e6b7871aac01ae89" translate="yes" xml:space="preserve">
          <source>With Perl, if you install &lt;a href=&quot;http://search.cpan.org/dist/JSON-PP/&quot;&gt;JSON::PP&lt;/a&gt; from CPAN you'll get the &lt;a href=&quot;http://search.cpan.org/perldoc?json_pp&quot;&gt;json_pp&lt;/a&gt; command.  Stealing the &lt;a href=&quot;https://stackoverflow.com/questions/352098/how-to-pretty-print-json-script/1920585#1920585&quot;&gt;example&lt;/a&gt; from &lt;a href=&quot;https://stackoverflow.com/users/233648/b-bycroft&quot;&gt;B Bycroft&lt;/a&gt; you get:</source>
          <target state="translated">В Perl, если вы установите &lt;a href=&quot;http://search.cpan.org/dist/JSON-PP/&quot;&gt;JSON :: PP&lt;/a&gt; из CPAN, вы получите команду &lt;a href=&quot;http://search.cpan.org/perldoc?json_pp&quot;&gt;json_pp&lt;/a&gt; . Кража &lt;a href=&quot;https://stackoverflow.com/questions/352098/how-to-pretty-print-json-script/1920585#1920585&quot;&gt;примера&lt;/a&gt; из &lt;a href=&quot;https://stackoverflow.com/users/233648/b-bycroft&quot;&gt;B Bycroft&lt;/a&gt; вы получите:</target>
        </trans-unit>
        <trans-unit id="bbe2430795ada5c918ef4fd2a921eb0efe2b1951" translate="yes" xml:space="preserve">
          <source>With Perl, use the CPAN module &lt;code&gt;JSON::XS&lt;/code&gt;. It installs a command line tool &lt;code&gt;json_xs&lt;/code&gt;.</source>
          <target state="translated">В Perl используйте модуль CPAN &lt;code&gt;JSON::XS&lt;/code&gt; . Он устанавливает инструмент командной строки &lt;code&gt;json_xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2721ddefc8ec55875c238236341b3372ea2e2f7" translate="yes" xml:space="preserve">
          <source>With Python 2.6+ you can just do:</source>
          <target state="translated">С Python 2.6+вы можете просто сделать:</target>
        </trans-unit>
        <trans-unit id="ec9137815fae6a13f9735eb057129ad18e846b9b" translate="yes" xml:space="preserve">
          <source>You can also pass arguments to transform the JSON data.</source>
          <target state="translated">Вы также можете передавать аргументы для преобразования данных JSON.</target>
        </trans-unit>
        <trans-unit id="beb665e3f43fdb8a841c16b9a74b56f776eab6ca" translate="yes" xml:space="preserve">
          <source>You can simply use standard tools like jq or json_pp.</source>
          <target state="translated">Вы можете просто использовать стандартные инструменты,такие как jq или json_pp.</target>
        </trans-unit>
        <trans-unit id="0cc843a8c1d597487a53a62cee69c07c3225f171" translate="yes" xml:space="preserve">
          <source>You can use this simple command to achieve the result:</source>
          <target state="translated">Вы можете использовать эту простую команду для достижения результата:</target>
        </trans-unit>
        <trans-unit id="4e5211fa9265ba94dd3dc2bccc58cc8910690278" translate="yes" xml:space="preserve">
          <source>You can use: &lt;a href=&quot;http://stedolan.github.com/jq&quot;&gt;&lt;code&gt;jq&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Вы можете использовать: &lt;a href=&quot;http://stedolan.github.com/jq&quot;&gt; &lt;code&gt;jq&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac3a6f60f4e628dfc19fae2fcb3577ad9823944b" translate="yes" xml:space="preserve">
          <source>a simple bash script for pretty json printing</source>
          <target state="translated">простой бэш-скрипт для красивой печати Джсона.</target>
        </trans-unit>
        <trans-unit id="5165f8a7a89fa6bd8f69b86aab76723eb9357154" translate="yes" xml:space="preserve">
          <source>and make beautiful the files running around on your disk:</source>
          <target state="translated">и сделать красивые файлы,запущенные на вашем диске:</target>
        </trans-unit>
        <trans-unit id="a357a0b3b6bb01e41a042b584904f6b12375f3f1" translate="yes" xml:space="preserve">
          <source>and then</source>
          <target state="translated">а потом</target>
        </trans-unit>
        <trans-unit id="5c556c0d2fa45fada329a718dc69afa88a6f16b0" translate="yes" xml:space="preserve">
          <source>and to format JSON contained in a file you can do this:</source>
          <target state="translated">и отформатировать JSON,содержащийся в файле,можно:</target>
        </trans-unit>
        <trans-unit id="3698853e42e2afb632488aae6e31da627858b112" translate="yes" xml:space="preserve">
          <source>and you'll get:</source>
          <target state="translated">и ты получишь:</target>
        </trans-unit>
        <trans-unit id="5592a069ea3f28056a831dda2ff26b71f5219950" translate="yes" xml:space="preserve">
          <source>for all the above cases. You can put this in &lt;code&gt;.bashrc&lt;/code&gt; and it will be available every time in shell. Invoke it like &lt;code&gt;prettyjson_s '{&quot;foo&quot;: &quot;lorem&quot;, &quot;bar&quot;: &quot;ipsum&quot;}'&lt;/code&gt;.</source>
          <target state="translated">для всех вышеперечисленных случаев. Вы можете поместить это в &lt;code&gt;.bashrc&lt;/code&gt; , и он будет доступен каждый раз в оболочке. &lt;code&gt;prettyjson_s '{&quot;foo&quot;: &quot;lorem&quot;, &quot;bar&quot;: &quot;ipsum&quot;}'&lt;/code&gt; это как prettyjson_s '{&quot;foo&quot;: &quot;lorem&quot;, &quot;bar&quot;: &quot;ipsum&quot;}' .</target>
        </trans-unit>
        <trans-unit id="3f04c30758d01c486aa292d322c2466007d62485" translate="yes" xml:space="preserve">
          <source>if the JSON is from an internet source such as an API, you can use</source>
          <target state="translated">если JSON исходит из интернет-источника,такого как API,вы можете использовать</target>
        </trans-unit>
        <trans-unit id="8822d1e4cffc1581f1ed5e458592fbcc45490d29" translate="yes" xml:space="preserve">
          <source>json_pretty.sh</source>
          <target state="translated">json_pretty.sh</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">или это:</target>
        </trans-unit>
        <trans-unit id="6683a028e6a0bbf2249b22f1af28b21b00ca5102" translate="yes" xml:space="preserve">
          <source>or, if the JSON is in a file, you can do:</source>
          <target state="translated">или,если JSON в файле,вы можете это сделать:</target>
        </trans-unit>
        <trans-unit id="6459833e2bfc11d16a93a3cda57d211c8299f9d1" translate="yes" xml:space="preserve">
          <source>the nicely readable word becomes \u encoded</source>
          <target state="translated">красиво читаемое слово становится \u закодированным.</target>
        </trans-unit>
        <trans-unit id="b804662fb4789f2726c6b0cdc6bffed73b78c7ab" translate="yes" xml:space="preserve">
          <source>then,</source>
          <target state="translated">then,</target>
        </trans-unit>
        <trans-unit id="6e3b1a45b1d3a64ccddfbe8df1daea6fe135ec81" translate="yes" xml:space="preserve">
          <source>underscore-cli</source>
          <target state="translated">underscore-cli</target>
        </trans-unit>
        <trans-unit id="7dc5c767306ee3075238aa6c43cbe928b97113e5" translate="yes" xml:space="preserve">
          <source>will both prettify output like the following (jq even more colorful):</source>
          <target state="translated">оба притворяются,что выходные данные выглядят следующим образом (jq еще более красочными):</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
