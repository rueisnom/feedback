<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/35553500">
    <body>
      <group id="35553500">
        <trans-unit id="c5fdbed70e669b038bcfb2cab90deeaf62877bee" translate="yes" xml:space="preserve">
          <source>&quot;Get&quot; request with appending headers transform to &quot;Options&quot; request. So Cors policy problems occur. You have to implement &quot;Options&quot; request to your server.</source>
          <target state="translated">헤더를 추가 한 &quot;Get&quot;요청은 &quot;Options&quot;요청으로 변환됩니다. 따라서 Cors 정책 문제가 발생합니다. 서버에 &quot;옵션&quot;요청을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="f69aaadff17bc308b050f9fadf2f5785686ce694" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but the browser has no way of knowing if either of the above are true, so trust is not automatic and the SOP is applied. Permission has to be granted explicitly before the browser will give the data it was given to a different website.</source>
          <target state="translated">&amp;hellip; 그러나 브라우저는 위의 내용 중 하나에 해당하는지 알 수 없으므로 신뢰가 자동이 아니며 SOP가 적용됩니다. 브라우저가 다른 웹 사이트에 제공 한 데이터를 제공하기 전에 권한이 명시 적으로 부여되어야합니다.</target>
        </trans-unit>
        <trans-unit id="aa3428b119285e7b20310e804868ca099ac810ab" translate="yes" xml:space="preserve">
          <source>&amp;hellip; in the response headers to permit any website to read the data.</source>
          <target state="translated">&amp;hellip; 응답 헤더에서 모든 웹 사이트가 데이터를 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="0666e400461e2ce9ecc28ecb83674c30b2511723" translate="yes" xml:space="preserve">
          <source>&amp;hellip; would allow only a specific site to access it, and Bob can dynamically generate that based on the &lt;code&gt;Origin&lt;/code&gt;&lt;em&gt;request&lt;/em&gt; header to permit multiple, but not all, sites to access it.</source>
          <target state="translated">&amp;hellip; 특정 사이트 만 액세스 할 수 있으며 Bob은 &lt;code&gt;Origin&lt;/code&gt; &lt;em&gt;요청&lt;/em&gt; 헤더를 기반으로 해당 사이트를 동적으로 생성하여 모든 사이트가 아닌 여러 사이트에서 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="3083c68c35322c957b6383c55bcd22231a4d4652" translate="yes" xml:space="preserve">
          <source>(Weirdly, it also applies to CSS fonts, but that is because found foundries insisted on DRM and not for the security issues that the Same Origin Policy usually covers).</source>
          <target state="translated">일반적으로 CSS 글꼴에도 적용되지만 파운드리가 DRM을 주장하기 때문에 동일한 출처 정책에서 일반적으로 다루는 보안 문제가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c721f376efe00285946ac6d7bf010b66ff393846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; Browser extensions do need to be written carefully to avoid cross-origin issues. &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/extension-content-script-fetches&quot;&gt;See the Chrome documentation for example&lt;/a&gt;.</source>
          <target state="translated">교차 출처 문제를 피하려면 브라우저 확장 프로그램을 신중하게 작성해야합니다. &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/extension-content-script-fetches&quot;&gt;예를 들어 Chrome 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccf579f23dfb488978fdf26171abc0e7c4458b84" translate="yes" xml:space="preserve">
          <source>A Proxy</source>
          <target state="translated">프록시</target>
        </trans-unit>
        <trans-unit id="12bdfbed461b262c6a3ff537a120d9b8a0e256c7" translate="yes" xml:space="preserve">
          <source>A basic implementation would just include:</source>
          <target state="translated">기본 구현에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="79adb0593bc6b4bf0a194d641b36d1310630c1a5" translate="yes" xml:space="preserve">
          <source>About the Same Origin Policy</source>
          <target state="translated">동일한 원산지 정책 정보</target>
        </trans-unit>
        <trans-unit id="cedda5083aa15826802650527c14fd360bd167bc" translate="yes" xml:space="preserve">
          <source>Access to fetch at '&lt;code&gt;https://example.com/&lt;/code&gt;' from origin '&lt;code&gt;https://example.net&lt;/code&gt;' has been blocked by CORS policy: No '&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.</source>
          <target state="translated">CORS 정책에 의해 ' &lt;code&gt;https://example.net&lt;/code&gt; '출처에서 가져 오기 ' &lt;code&gt;https://example.com/&lt;/code&gt; '에 대한 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 가 CORS 정책에 의해 차단되었습니다. 요청 된 자원에 ' Access-Control-Allow-Origin '헤더가 없습니다. 불투명 한 응답이 사용자의 요구에 부응하는 경우 CORS가 비활성화 된 상태에서 리소스를 가져 오려면 요청 모드를 'no-cors'로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7b7974bfa3fba0e3975c4d056b6b9ca1197d455e" translate="yes" xml:space="preserve">
          <source>Alice is a person with a web browser</source>
          <target state="translated">앨리스는 웹 브라우저를 가진 사람입니다</target>
        </trans-unit>
        <trans-unit id="080d446b3afc60112cc22d7278d349fef3fd6d9e" translate="yes" xml:space="preserve">
          <source>Alice is logged into Bob's site and has some confidential data there. Perhaps it is a company intranet (accessible only to browsers on the LAN), or her online banking (accessible only with a cookie you get after entering a username and password).</source>
          <target state="translated">Alice는 Bob의 사이트에 로그인하여 기밀 데이터를 가지고 있습니다. 회사 인트라넷 (LAN의 브라우저에서만 액세스 가능) 또는 온라인 뱅킹 (사용자 이름 및 비밀번호를 입력 한 후 쿠키로만 액세스 가능) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f9059ae8633c85b7699e923ebb41ea7becd668e" translate="yes" xml:space="preserve">
          <source>Alice visits Mallory's website which has some JavaScript that causes Alice's browser to make an HTTP request to Bob's website (from her IP address with her cookies, etc). This could be as simple as using &lt;code&gt;XMLHttpRequest&lt;/code&gt; and reading the &lt;code&gt;responseText&lt;/code&gt;.</source>
          <target state="translated">Alice는 Mallory의 웹 사이트를 방문합니다. 여기에는 Alice의 브라우저가 쿠키를 사용하여 IP 주소에서 Bob의 웹 사이트로 HTTP 요청을하는 JavaScript가 포함되어 있습니다. &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 사용하고 &lt;code&gt;responseText&lt;/code&gt; 를 읽는 것만 큼 간단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bdc163ef94b8775f3c2206de222d5cdbb730053" translate="yes" xml:space="preserve">
          <source>Alice, Bob and Mallory are the same person.</source>
          <target state="translated">앨리스, 밥, 말로리는 같은 사람입니다.</target>
        </trans-unit>
        <trans-unit id="e356eab4f83b3e77df9f9a8c73c681fa3b5ef7cc" translate="yes" xml:space="preserve">
          <source>Alternatives to CORS</source>
          <target state="translated">CORS의 대안</target>
        </trans-unit>
        <trans-unit id="3f9bf680f2d7e601b6b53dc367493c6e9226daf2" translate="yes" xml:space="preserve">
          <source>As noted in the section &quot;Why the Same Origin Policy only applies to JavaScript in a web page&quot;, you can avoid the SOP by not writing JavaScript in a webpage.</source>
          <target state="translated">&quot;동일한 원본 정책이 웹 페이지의 JavaScript에만 적용되는 이유&quot;섹션에서 언급 한 것처럼 웹 페이지에서 JavaScript를 작성하지 않으면 SOP를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d506fbbc5a8bc383106b8326dc9ab129456f337c" translate="yes" xml:space="preserve">
          <source>As this isn't mentioned in the accepted answer.</source>
          <target state="translated">이것은 받아 들여진 대답에 언급되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b05e4adacdafe56d47f3926c61aa1bd3e81b8aa" translate="yes" xml:space="preserve">
          <source>Bob could also provide the data using a hack like &lt;a href=&quot;https://stackoverflow.com/questions/2067472/what-is-jsonp-all-about&quot;&gt;JSONP&lt;/a&gt; which is how people did cross-origin Ajax before CORS came along.</source>
          <target state="translated">Bob은 &lt;a href=&quot;https://stackoverflow.com/questions/2067472/what-is-jsonp-all-about&quot;&gt;JSONP&lt;/a&gt; 와 같은 핵을 사용하여 데이터를 제공 할 수 있는데, 이는 CORS가 등장하기 전에 사람들이 Ajax를 교차 출처로 사용한 방식입니다.</target>
        </trans-unit>
        <trans-unit id="1ea8ca767428c6dc82740ebab1a317eb537dfc17" translate="yes" xml:space="preserve">
          <source>Bob is providing entirely public information</source>
          <target state="translated">밥은 전적으로 공개 정보를 제공하고 있습니다</target>
        </trans-unit>
        <trans-unit id="4ad9e5a181ccf4d48e00fa324c6d3fa0e330762e" translate="yes" xml:space="preserve">
          <source>Bob runs a website (&lt;code&gt;https://www.[website].com/&lt;/code&gt; in your example)</source>
          <target state="translated">Bob은 웹 사이트를 실행합니다 (예 &lt;code&gt;https://www.[website].com/&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ddc4f8c91108ac2bf18e262a30c2fd7398d649f7" translate="yes" xml:space="preserve">
          <source>Bob wouldn't need to grant any permissions for that to happen.</source>
          <target state="translated">Bob은이를 위해 권한을 부여 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a7792b7795b50e8301b591ad82091d0598c147a" translate="yes" xml:space="preserve">
          <source>Browser extensions</source>
          <target state="translated">브라우저 확장</target>
        </trans-unit>
        <trans-unit id="52a3e647edc456ec783b6d63aa3dd4cf5795f836" translate="yes" xml:space="preserve">
          <source>Browser extensions&lt;code&gt;*&lt;/code&gt;, the Network tab in browser developer tools and applications like Postman are installed software. They aren't passing data from one website to the JavaScript belonging to a different website &lt;em&gt;just because you visited that different website&lt;/em&gt;. Installing software usually takes a more conscious choice.</source>
          <target state="translated">브라우저 확장 프로그램 &lt;code&gt;*&lt;/code&gt; , 브라우저 개발자 도구의 네트워크 탭 및 Postman과 같은 응용 프로그램이 소프트웨어로 설치됩니다. 그들은 다른 웹 사이트 &lt;em&gt;를 방문했기 때문에 한&lt;/em&gt; 웹 사이트에서 다른 웹 사이트에 속하는 JavaScript로 데이터를 전달하지 않습니다. 소프트웨어를 설치하려면 일반적으로보다 의식적인 선택이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="02de3c6a5d36416398534d79472aff7a9ccfbc69" translate="yes" xml:space="preserve">
          <source>But I'm not Bob!</source>
          <target state="translated">그러나 나는 밥이 아니다!</target>
        </trans-unit>
        <trans-unit id="2139aadec237bbecb581e62932f94bc3bce7a704" translate="yes" xml:space="preserve">
          <source>CORS</source>
          <target state="translated">CORS</target>
        </trans-unit>
        <trans-unit id="72a7bba2b6e46912da58c628abb44b1d77e213c9" translate="yes" xml:space="preserve">
          <source>Common mistakes that trigger this include:</source>
          <target state="translated">이를 유발하는 일반적인 실수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b6794110b358bc83a6cd7c420d7cd48e8a0d272" translate="yes" xml:space="preserve">
          <source>Consequently, Mallory can only use this technique to read &lt;em&gt;public&lt;/em&gt; data.</source>
          <target state="translated">결과적으로 Mallory는이 기술을 사용하여 &lt;em&gt;공개&lt;/em&gt; 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22709a8723fb233b31baf16067c518f10a970801" translate="yes" xml:space="preserve">
          <source>Couldn't be generated with a regular HTML form (e.g. has custom headers or a Content-Type that you couldn't use in a form's &lt;code&gt;enctype&lt;/code&gt;).</source>
          <target state="translated">일반 HTML 양식으로 생성 할 수 없습니다 (예 : 사용자 정의 헤더 또는 양식의 &lt;code&gt;enctype&lt;/code&gt; 에서 사용할 수없는 Content-Type이 있음).</target>
        </trans-unit>
        <trans-unit id="9f7023ae6c0c7bb388366399240a29d8f70d9716" translate="yes" xml:space="preserve">
          <source>Error messages which mention &quot;Response for preflight&quot;</source>
          <target state="translated">&quot;프리 플라이트에 대한 응답&quot;이라는 오류 메시지</target>
        </trans-unit>
        <trans-unit id="de11082858543756881cde0b6cf3f0aabed14671" translate="yes" xml:space="preserve">
          <source>For any given URL it is possible that the SOP is not needed. A couple of common scenarios where this is the case are:</source>
          <target state="translated">주어진 URL에 대해 SOP가 필요하지 않을 수 있습니다. 이 경우에 일반적인 몇 가지 시나리오는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="360422379e164038fc5a13abf8702a9a03c5924c" translate="yes" xml:space="preserve">
          <source>Having a proper development environment with a local development &lt;em&gt;server&lt;/em&gt; 
is usually a better approach.</source>
          <target state="translated">로컬 개발 &lt;em&gt;서버&lt;/em&gt; 와 함께 적절한 개발 환경을 갖는 것이 일반적으로 더 나은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8c77c3320c21e1da3d952fdceed8b3d5a9040f1b" translate="yes" xml:space="preserve">
          <source>How to do it is explained by the Chrome error message given when you make a request using &lt;code&gt;fetch&lt;/code&gt; and don't get permission to view the response with CORS:</source>
          <target state="translated">이를 수행하는 방법은 &lt;code&gt;fetch&lt;/code&gt; 사용하여 요청하고 CORS로 응답을 볼 수있는 권한이없는 경우 제공되는 Chrome 오류 메시지로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a2e8f7365ba0b05a0e386702f943744a084420" translate="yes" xml:space="preserve">
          <source>How to get a cross-origin resource sharing (CORS) post request working</source>
          <target state="translated">CORS (Cross-Origin Resource Sharing) 사후 요청 작업 방법</target>
        </trans-unit>
        <trans-unit id="4544234b52783d9ce6c7523afb3788d72f490ed8" translate="yes" xml:space="preserve">
          <source>I got the same error in Chrome console.</source>
          <target state="translated">Chrome 콘솔에서 동일한 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="191fa4c21ffb0259f46e3158d042758a40108e3b" translate="yes" xml:space="preserve">
          <source>I have a Grunt process which initiates an instance of express.js server. This was working absolutely fine up until just now when it started serving a blank page with the following appearing in the error log in the developer's console in Chrome (latest version):</source>
          <target state="translated">express.js 서버의 인스턴스를 시작하는 Grunt 프로세스가 있습니다. Chrome의 개발자 콘솔 (최신 버전)에서 오류 로그에 다음과 같이 빈 페이지가 게재되기 시작한 지금까지는 제대로 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="696b9bf9d526b3f1a17737731ae9d27d92d1474e" translate="yes" xml:space="preserve">
          <source>I'm having this issue currently under different reason.
My front end is returning 'Access-Control-Allow-Origin' header error as well.</source>
          <target state="translated">현재 다른 이유로이 문제가 있습니다. 내 프론트 엔드도 'Access-Control-Allow-Origin'헤더 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abe02bb96c36c6f655503931ed03c194f5f3b1cd" translate="yes" xml:space="preserve">
          <source>If Bob is running a public API then there might be a mechanism to turn on CORS (perhaps by formatting the request in a certain way, or a config option after logging into a Developer Portal site for Bob's site). This will have to be a mechanism implemented by Bob though. Mallory could read the documentation on Bob's site to see if something is available, or she could talk to Bob and ask him to implement CORS.</source>
          <target state="translated">Bob이 공개 API를 실행중인 경우 CORS를 설정하는 메커니즘이있을 수 있습니다 (아마도 특정 방식으로 요청을 형식화하거나 Bob의 사이트에 대한 개발자 포털 사이트에 로그인 한 후 구성 옵션을 사용하여). 이것은 Bob이 구현 한 메커니즘이어야합니다. Mallory는 Bob의 사이트에있는 설명서를 읽고 사용 가능한 것이 있는지 확인하거나 Bob과 대화하여 CORS를 구현하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92ad6fa7497aadeaf8ff53a9f87b47f0a06f7043" translate="yes" xml:space="preserve">
          <source>If it is a public service:</source>
          <target state="translated">공공 서비스 인 경우 :</target>
        </trans-unit>
        <trans-unit id="b43202b21aa22f1dcb0dbdd04e2b92e038006f59" translate="yes" xml:space="preserve">
          <source>If none of the above apply: Get the browser to talk to &lt;em&gt;your&lt;/em&gt; server instead, and then have your server fetch the data from the other server and pass it on. (There are also third-party hosted services which attach CORS headers to publically accessible resources that you could use).</source>
          <target state="translated">위의 어느 것도 해당되지 않는 경우 : 브라우저가 대신 서버와 통신하도록 한 &lt;em&gt;다음&lt;/em&gt; 서버가 다른 서버에서 데이터를 가져 와서 전달하도록하십시오. CORS 헤더를 공개적으로 액세스 할 수있는 리소스에 연결하는 타사 호스팅 서비스도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e48fd7463af9f02e701f5f698b5fff66bca17c7f" translate="yes" xml:space="preserve">
          <source>If the HTML document the JS runs in and the URL being requested are on the same origin (sharing the same scheme, hostname, and port) then they Same Origin Policy grants permission by default. CORS is not needed.</source>
          <target state="translated">JS가 실행되는 HTML 문서와 요청중인 URL이 동일한 출처 (같은 체계, 호스트 이름 및 포트를 공유)에있는 경우, 동일한 출처 정책은 기본적으로 권한을 부여합니다. CORS는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08cc9d28f22949cc5fa0a94d72751f3fa207f841" translate="yes" xml:space="preserve">
          <source>If you are correctly doing something that needs a preflight</source>
          <target state="translated">프리 플라이트가 필요한 작업을 올바르게 수행하는 경우</target>
        </trans-unit>
        <trans-unit id="ba22853626484508756ed5c98d033ee48a650bbd" translate="yes" xml:space="preserve">
          <source>If you are friendly with the person who controls it: Get them to add CORS permissions to it.</source>
          <target state="translated">제어하는 사람과 친숙한 경우 : CORS 권한을 추가하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="853008022034caee905ec37fc3d3b78af426efd3" translate="yes" xml:space="preserve">
          <source>If you are triggering a preflight by mistake</source>
          <target state="translated">실수로 프리 플라이트를 트리거하는 경우</target>
        </trans-unit>
        <trans-unit id="e26a716bf9b75b23f6454ffbb214b653934425a4" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch&quot;&gt;the &lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; (rather than &lt;code&gt;XMLHttpRequest&lt;/code&gt;), then you can configure it to not try to use CORS.</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 대신 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch&quot;&gt; &lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; 를 사용하는 경우 CORS를 사용하지 않도록 API 를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70d17978875ee658715b4db351d2df97b4823527" translate="yes" xml:space="preserve">
          <source>If you control the server the request is being made to: Add CORS permissions to it.</source>
          <target state="translated">서버를 제어하는 ​​경우 요청이 수행됩니다. CORS 권한을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c3d6c76ecd5f6ccde50eec6284baa0a0a9f6e8f0" translate="yes" xml:space="preserve">
          <source>If your client code does not explicit set affected Headers (e.g. &quot;Accept&quot;) with a fix value in the request it &lt;em&gt;might&lt;/em&gt; occur that some clients do set these Headers automatically with some &quot;non-standard&quot; values causing the server to not accept it as Simple Request - which will give you a CORS error.</source>
          <target state="translated">클라이언트 코드가 요청에서 수정 된 값으로 영향을받는 헤더 (예 : &quot;수락&quot;)를 명시 적으로 설정하지 않은 경우 일부 클라이언트는 &quot;비표준&quot;값으로 이러한 헤더를 자동으로 설정하여 서버가이를 수락하지 않을 수 있습니다. 간단한 요청-CORS 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7eaa077646e8880c93a7bd47f607df23835f175" translate="yes" xml:space="preserve">
          <source>In either of these cases, removing the extra request header will often be enough to avoid the need for a preflight (which will solve the problem when communicating with APIs that support simple requests but not preflighted requests).</source>
          <target state="translated">두 경우 모두 추가 요청 헤더를 제거하면 프리 플라이트가 필요하지 않을 수 있습니다 (단순 요청은 지원하지만 프리 플라이트 요청은 지원하지 않는 API와 통신 할 때 문제가 해결됨).</target>
        </trans-unit>
        <trans-unit id="5729a2bfc145c982ccb21e1853b5da3159d0e027" translate="yes" xml:space="preserve">
          <source>In order to perform a 'Simple Requests' the request needs to meet several conditions. E.g. only allowing &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt; method, as well as only allowing some given Headers (you can find all conditions &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">'간단한 요청'을 수행하려면 요청이 여러 조건을 충족해야합니다. 예를 들어 &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;GET&lt;/code&gt; 및 &lt;code&gt;HEAD&lt;/code&gt; 메소드 만 허용하고 일부 지정된 헤더 만 허용합니다 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&quot;&gt;여기에서&lt;/a&gt; 모든 조건을 찾을 수 있음).</target>
        </trans-unit>
        <trans-unit id="7cc076a9ba30ebdfbaf2900c4da047938ac0695e" translate="yes" xml:space="preserve">
          <source>In these cases then &lt;strong&gt;the rest of this answer still applies&lt;/strong&gt; but you also need to make sure that the server can listen for the preflight request (which will be &lt;code&gt;OPTIONS&lt;/code&gt; (and not &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt; or whatever you were trying to send) and respond to it with the right &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header but also &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; and &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; to allow your specific HTTP methods or headers.</source>
          <target state="translated">이 경우 &lt;strong&gt;에도이 답변의 나머지 부분이 여전히 적용&lt;/strong&gt; 되지만 서버가 프리 플라이트 요청 ( &lt;code&gt;OPTIONS&lt;/code&gt; (및 &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; 또는 보내려는 것이 아닌))을 수신하고 응답 할 수 있는지 확인해야합니다. 올바른 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더와 함께 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 및 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 를 사용하여 특정 HTTP 메소드 또는 헤더를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="d26715ff3c8058144a5e6781d18e2ccc51089bd3" translate="yes" xml:space="preserve">
          <source>Includes credentials like cookies</source>
          <target state="translated">쿠키와 같은 자격 증명 포함</target>
        </trans-unit>
        <trans-unit id="62f77bfbffd7a258cc0b8ce904a719ce6a3ee3ed" translate="yes" xml:space="preserve">
          <source>It is possible for a browser extension to inject the CORS headers in the response before the Same Origin Policy is applied.</source>
          <target state="translated">동일한 오리진 정책이 적용되기 전에 브라우저 확장이 응답에 CORS 헤더를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="524d541343869ab2cfcaedba8cffa363f4e4da8d" translate="yes" xml:space="preserve">
          <source>It requires that Mallory trust Bob not to provide malicious code.</source>
          <target state="translated">Mallory가 Bob에게 악성 코드를 제공하지 않도록 신뢰해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0d49ced5af1ce4f42b72853fa8477beb628ad66" translate="yes" xml:space="preserve">
          <source>It will either:</source>
          <target state="translated">다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="45aea3ca1172a010ceadbf9eb618c7f4dd492ee6" translate="yes" xml:space="preserve">
          <source>It will let you make a simple request, not see the response, and not fill the Developer Console with error messages.</source>
          <target state="translated">간단한 요청을하고 응답을 보지 않으며 개발자 콘솔에 오류 메시지를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97e9368be80f4c0b36d760f04834a058af9cb0eb" translate="yes" xml:space="preserve">
          <source>It works by presenting the data in the form of a JavaScript program which injects the data into Mallory's page.</source>
          <target state="translated">Mallory의 페이지에 데이터를 주입하는 JavaScript 프로그램 형식으로 데이터를 표시하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="42c6036ddd5d662bc456c530699d3704be7c5087" translate="yes" xml:space="preserve">
          <source>JSONP</source>
          <target state="translated">JSONP</target>
        </trans-unit>
        <trans-unit id="d91c94a14abe9d71f04f1aaf68eb2c1b48685144" translate="yes" xml:space="preserve">
          <source>Just that I've pointed the wrong URL so this header wasn't reflected properly (in which i kept presume it did). localhost (front end) -&amp;gt; call to non secured http (supposed to be https), make sure the API end point from front end is pointing to the correct protocol.</source>
          <target state="translated">내가 잘못된 URL을 지적했기 때문에이 헤더가 제대로 반영되지 않았습니다 (내가 계속 추측했습니다). localhost (프론트 엔드)-&amp;gt; 보안되지 않은 http에 대한 호출 (https 인 경우), 프론트 엔드의 API 엔드 포인트가 올바른 프로토콜을 가리키는 지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5948c6b1360bb812feb00f5faadc9ae4a212ff35" translate="yes" xml:space="preserve">
          <source>Make sure you aren't triggering a preflight request you don't need. The API might grant permission for simple requests but not preflighted requests.</source>
          <target state="translated">필요없는 프리 플라이트 요청을 트리거하지 않아야합니다. API는 간단한 요청에 대한 권한을 부여하지만 사전 비행 요청은 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c47e0f7a3e4ddaa6dbc100fabee7e2aec1ca459" translate="yes" xml:space="preserve">
          <source>Mallory &lt;em&gt;could&lt;/em&gt; use server-side code to fetch the data (which she could then pass from her server to Alice's browser through HTTP as usual).</source>
          <target state="translated">Mallory &lt;em&gt;는&lt;/em&gt; 서버 측 코드를 사용하여 데이터를 가져올 수 있습니다 (그런 다음 평소와 같이 HTTP를 통해 서버에서 Alice의 브라우저로 전달할 수 있음).</target>
        </trans-unit>
        <trans-unit id="564e68efef90eb6ff94dbc5e63c04d09f8c8e32a" translate="yes" xml:space="preserve">
          <source>Mallory runs a website (&lt;code&gt;http://localhost:4300&lt;/code&gt; in your example)</source>
          <target state="translated">Mallory는 웹 사이트를 실행합니다 (예 &lt;code&gt;http://localhost:4300&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f2e3a0d4f23dada9bbe46ba7d15363f3d33d0fc0" translate="yes" xml:space="preserve">
          <source>Mallory was trusted</source>
          <target state="translated">말로리는 신뢰했다</target>
        </trans-unit>
        <trans-unit id="5741aafa13c097ce47a2ce4d5a8a24a6ed295abc" translate="yes" xml:space="preserve">
          <source>Move the two resources to a single Origin</source>
          <target state="translated">두 자원을 단일 원점으로 이동</target>
        </trans-unit>
        <trans-unit id="179f34374a10f83759fcee462cc56f0119a97fff" translate="yes" xml:space="preserve">
          <source>My problem was, I was trying to go to the site using &lt;code&gt;http://&lt;/code&gt; instead of &lt;code&gt;https://&lt;/code&gt;. So there was nothing to fix, just had to go to the same site using &lt;code&gt;https&lt;/code&gt;.</source>
          <target state="translated">내 문제는 &lt;code&gt;https://&lt;/code&gt; 대신 &lt;code&gt;http://&lt;/code&gt; 를 사용하여 사이트로 이동하려고했습니다. 그래서 고칠 것이 없었습니다. &lt;code&gt;https&lt;/code&gt; 를 사용하여 같은 사이트로 가야했습니다.</target>
        </trans-unit>
        <trans-unit id="da7899ad8069372c74d86a8d03eec992d656f441" translate="yes" xml:space="preserve">
          <source>NB: Some requests are complex and send a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests&quot;&gt;preflight&lt;/a&gt; OPTIONS request that the server will have to respond to before the browser will send the GET/POST/PUT/Whatever request that the JS wants to make. Implementations of CORS that only add &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; to specific URLs often get tripped up by this.</source>
          <target state="translated">NB : 일부 요청은 복잡하며 브라우저가 JS가 원하는 GET / POST / PUT / 무엇을 보내기 전에 서버가 응답해야하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests&quot;&gt;프리 플라이트&lt;/a&gt; OPTIONS 요청을 보냅니다. 특정 URL에 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 만 추가하는 CORS 구현은 종종 이것에 의해 트립됩니다.</target>
        </trans-unit>
        <trans-unit id="6627ccdfafd9a906f6fccd9cc62f31a063fd4bcc" translate="yes" xml:space="preserve">
          <source>Note that SOP / CORS do not mitigate &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;CSRF&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injection&lt;/a&gt; attacks which need to be handled independently.</source>
          <target state="translated">SOP / CORS는 독립적으로 처리해야하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;CSRF&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL 주입&lt;/a&gt; 공격을 완화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc579f199a3101a7f44833570e63a56fb1cb5e4" translate="yes" xml:space="preserve">
          <source>Note that this won't let you do anything that you require CORS to do. You will not be able to read the response. You will not be able to make a request that requires a preflight.</source>
          <target state="translated">이렇게하면 CORS에 필요한 작업을 수행 할 수 없습니다. 응답을 읽을 수 없습니다. 프리 플라이트가 필요한 요청을 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4d6128232048cd6c6d7f3d7b647ed7fff7f8026" translate="yes" xml:space="preserve">
          <source>Note the common theme: The site providing the data has to tell the browser that it is OK for a third party site to access the data it is sending to the browser.</source>
          <target state="translated">공통 주제를 참고하십시오. 데이터를 제공하는 사이트는 브라우저가 타사 사이트가 브라우저로 보내는 데이터에 액세스하는 것이 좋다고 브라우저에 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="2aebca51e57e08fa958991342bd12a4146e354ff" translate="yes" xml:space="preserve">
          <source>Obviously granting permission via CORS is something Bob would only do only if either:</source>
          <target state="translated">분명히 CORS를 통해 권한을 부여하는 것은 Bob이 다음 중 하나의 경우에만 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="52c0ea51241c014c452b8334a0a0cdf2931af1be" translate="yes" xml:space="preserve">
          <source>Opaque responses</source>
          <target state="translated">불투명 한 반응</target>
        </trans-unit>
        <trans-unit id="f4c0bf26e722637eaa84e1385d4bed8c7c900340" translate="yes" xml:space="preserve">
          <source>Other security risks</source>
          <target state="translated">다른 보안 위험</target>
        </trans-unit>
        <trans-unit id="3a9e8860a792c71b56b7e9a1d5af8455957c17a7" translate="yes" xml:space="preserve">
          <source>Read More about it here: &lt;a href=&quot;https://stackoverflow.com/questions/25923796/cors-error-with-jquery&quot;&gt;CORS error with jquery&lt;/a&gt;</source>
          <target state="translated">여기에 대해 더 읽어보십시오 : &lt;a href=&quot;https://stackoverflow.com/questions/25923796/cors-error-with-jquery&quot;&gt;jquery의 CORS 오류&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36d37ad0ea64198287e8b037dac57678ca1b9809" translate="yes" xml:space="preserve">
          <source>Read their API documentation to see what they say about accessing it with client-side JavaScript:</source>
          <target state="translated">API 문서를 읽고 클라이언트 측 JavaScript로 액세스하는 것에 대한 의견을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3cfa06457874ce9969c8b51f9984b1636c423b3c" translate="yes" xml:space="preserve">
          <source>Since JSONP works by appending a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element to load the data in the form of a JavaScript program which calls a function already in the page, attempting to use the JSONP technique on a URL which returns JSON will fail &amp;mdash; typically with a CORB error &amp;mdash; because JSON is not JavaScript.</source>
          <target state="translated">JSONP는 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 요소를 추가하여 페이지에 이미있는 함수를 호출하는 JavaScript 프로그램 형식으로 데이터를로드하는 방식으로 작동하므로 JSON을 반환하는 URL에서 JSONP 기술을 사용하려고 시도하면 일반적으로 CORB 오류가 발생합니다. &amp;mdash; JSON은 JavaScript가 아니기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1861df057de67ba04d2b5992466bb39553c4cf29" translate="yes" xml:space="preserve">
          <source>Some cross origin requests are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests&quot;&gt;preflighted&lt;/a&gt;.</source>
          <target state="translated">일부 교차 출발 요청은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests&quot;&gt;프리 플라이트&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="fdf3b7775d3b635980a416d0d4279a7d7d042752" translate="yes" xml:space="preserve">
          <source>Sometimes people make mistakes when trying to construct Ajax requests, and sometimes these trigger the need for a preflight. If the API is designed to allow cross-origin requests, but doesn't require anything that would need a preflight, then this can break access.</source>
          <target state="translated">때때로 사람들은 Ajax 요청을 구성하려고 할 때 실수를 저지르고 때로는 프리 플라이트가 필요합니다. API가 교차 출처 요청을 허용하도록 설계되었지만 프리 플라이트가 필요한 항목이 필요하지 않으면 액세스가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0b549858f2443774149a23a83091eb427dedd6b" translate="yes" xml:space="preserve">
          <source>Sometimes you need to make an HTTP request, but you don't need to read the response. e.g. if you are posting a log message to the server for recording.</source>
          <target state="translated">때로는 HTTP 요청을해야하지만 응답을 읽을 필요는 없습니다. 예를 들어 기록을 위해 로그 메시지를 서버에 게시하는 경우.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="3bfcdfe6eb4d2132f9b02f748b3b12d32af0e673" translate="yes" xml:space="preserve">
          <source>Target server must allowed cross-origin request. In order to allow it through express, simply handle http options request :</source>
          <target state="translated">대상 서버는 출처 간 요청을 허용해야합니다. Express를 통해 허용하려면 간단히 http 옵션 요청을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="03272e3fa289c41f7c3f5d68e234a4e328f368c9" translate="yes" xml:space="preserve">
          <source>That doesn't mean you can't continue to use JavaScript and HTML, but you could distribute it using some other mechanism, such as Node-WebKit or PhoneGap.</source>
          <target state="translated">그렇다고 JavaScript와 HTML을 계속 사용할 수는 없지만 Node-WebKit 또는 PhoneGap과 같은 다른 메커니즘을 사용하여 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a037477ee252bfd6e5d800d4a6268d25aa2f8c53" translate="yes" xml:space="preserve">
          <source>That server-side code could be written &amp;amp; hosted by a third party (such as CORS Anywhere). Note the privacy implications of this: The third party can monitor who proxies what across their servers.</source>
          <target state="translated">해당 서버 측 코드는 CORS Anywhere와 같은 타사에서 작성하고 호스팅 할 수 있습니다. 개인 정보 보호에 미치는 영향에 유의하십시오. 타사는 서버에서 무엇을 프록시하는지 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0de50f88e2b3d052aad5c90272075ba1a3d3802" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; HTTP &lt;strong&gt;response&lt;/strong&gt; header referred to in the error message is part of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;CORS&lt;/a&gt; standard which allows Bob to explicitly grant permission to Mallory's site to access the data via Alice's browser.</source>
          <target state="translated">오류 메시지에 언급 된 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; HTTP &lt;strong&gt;응답&lt;/strong&gt; 헤더는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;CORS&lt;/a&gt; 표준의 일부로 Bob이 Mallory의 사이트에 Alice의 브라우저를 통해 데이터에 액세스 할 수있는 권한을 명시 적으로 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1dbef57f9bfebd76c45b9a48c018f05b8a8a202" translate="yes" xml:space="preserve">
          <source>The browser's Same Origin Policy prevents that JavaScript from reading the data returned by Bob's website (which Bob and Alice don't want Mallory to access). (Note that you can, for example, display an image using an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element across origins because the content of the image is not exposed to JavaScript (or Mallory) &amp;hellip; unless you throw canvas into the mix in which case you &lt;em&gt;will&lt;/em&gt; generate a same-origin violation error).</source>
          <target state="translated">브라우저의 동일한 출처 정책은 JavaScript가 Bob의 웹 사이트 (Bob 및 Alice가 Mallory에 액세스하기를 원하지 않음)에서 반환 한 데이터를 읽지 못하게합니다. (예를 들어 이미지의 내용이 JavaScript (또는 Mallory)에 노출되지 않기 때문에 원점에서 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 요소를 사용하여 이미지를 표시 할 수 있습니다. 동일 출처 위반 오류).</target>
        </trans-unit>
        <trans-unit id="79ef50211c8179fcab85dd49da5f3fbabd650658" translate="yes" xml:space="preserve">
          <source>The data was not private &lt;em&gt;or&lt;/em&gt;</source>
          <target state="translated">개인 정보가 아니 &lt;em&gt;거나&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d9762ae08f6f7dad91721e27217991f8a11ff9f" translate="yes" xml:space="preserve">
          <source>The specifics of how Bob sets that response header depend on Bob's HTTP server and/or server-side programming language. There is &lt;a href=&quot;https://enable-cors.org/server.html&quot;&gt;a collection of guides for various common configurations&lt;/a&gt; that might help.</source>
          <target state="translated">Bob이 응답 헤더를 설정하는 방법에 대한 구체적인 내용은 Bob의 HTTP 서버 및 / 또는 서버 측 프로그래밍 언어에 따라 다릅니다. 도움이 될 수있는 &lt;a href=&quot;https://enable-cors.org/server.html&quot;&gt;다양한 공통 구성에 대한 안내서 모음&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6604893b096b6ba328e55fd565fa6955767da643" translate="yes" xml:space="preserve">
          <source>The standard scenario that demonstrates the need for the SOP can be demonstrated with &lt;a href=&quot;https://en.wikipedia.org/wiki/Alice_and_Bob&quot;&gt;three characters&lt;/a&gt;:</source>
          <target state="translated">SOP의 필요성을 보여주는 표준 시나리오는 다음 &lt;a href=&quot;https://en.wikipedia.org/wiki/Alice_and_Bob&quot;&gt;세 문자&lt;/a&gt; 로 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d044b9d63caf8c196634124ce4c9ba4ca176213" translate="yes" xml:space="preserve">
          <source>There are a number of circumstances where Mallory's site can cause a browser to fetch data from a third party and display it (e.g. by adding an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element to display an image). It isn't possible for Mallory's JavaScript to read the data in that resource though, only Alice's browser and Bob's server can do that, so it is still secure.</source>
          <target state="translated">Mallory의 사이트에서 브라우저가 제 3 자로부터 데이터를 가져 와서 표시하도록하는 여러 가지 상황이 있습니다 (예 : &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 요소를 추가하여 이미지 표시). Mallory의 JavaScript가 해당 리소스의 데이터를 읽을 수는 없지만 Alice의 브라우저와 Bob의 서버만이 그렇게 할 수 있으므로 여전히 안전합니다.</target>
        </trans-unit>
        <trans-unit id="6127874d9aef1420ff154b79562f50afaf6347c1" translate="yes" xml:space="preserve">
          <source>There is no standard mechanism for &lt;em&gt;Mallory&lt;/em&gt; to add this header because it has to come from Bob's website, which she does not control.</source>
          <target state="translated">&lt;em&gt;Mallory&lt;/em&gt; 가이 헤더를 추가하는 표준 메커니즘은 Bob의 웹 사이트에서 가져와야하므로 제어하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b79496a457c196bc566172f51692296fa4b04a80" translate="yes" xml:space="preserve">
          <source>There is nothing you can do in &lt;em&gt;your&lt;/em&gt; client-side code that will enable CORS access to someone &lt;em&gt;else's&lt;/em&gt; server.</source>
          <target state="translated">CORS가 다른 &lt;em&gt;사람의&lt;/em&gt; 서버에 액세스 할 수 있도록 클라이언트 측 코드에서 수행 할 수있는 작업은 없습니다.</target>
        </trans-unit>
        <trans-unit id="beaef9fcd0c6d1171c964ef462dc2b90796057d4" translate="yes" xml:space="preserve">
          <source>There isn't a third party (Mallory) who is considered a risk.</source>
          <target state="translated">위험으로 간주되는 제 3 자 (Mallory)는 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd9bc05dc8287dee0908fc2de2446be79f55333c" translate="yes" xml:space="preserve">
          <source>These can be useful for development, but are not practical for a production site (asking every user of your site to install a browser extension that disables a security feature of their browser is unreasonable).</source>
          <target state="translated">이것들은 개발에 유용하지만 프로덕션 사이트에는 실용적이지 않습니다 (사이트의 모든 사용자에게 브라우저의 보안 기능을 비활성화하는 브라우저 확장 프로그램을 설치하도록 요구하는 것은 합리적이지 않습니다).</target>
        </trans-unit>
        <trans-unit id="2f870286e388f3bb6b87e9c1b23cb67398f0476e" translate="yes" xml:space="preserve">
          <source>These links may help</source>
          <target state="translated">이 링크는 도움이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3c5b93c7e9e12c292b3d57a2e8033fcb4066808f" translate="yes" xml:space="preserve">
          <source>They also tend to work only with simple requests (failing when handling preflight OPTIONS requests).</source>
          <target state="translated">또한 간단한 요청으로 만 작동하는 경향이 있습니다 (사전 비행 옵션 요청을 처리 할 때 실패).</target>
        </trans-unit>
        <trans-unit id="966f60079bca7fe60d16c9b028cbe378ce505cbe" translate="yes" xml:space="preserve">
          <source>They might not support cross-origin access from client-side code at all (this might be a deliberate decision on security grounds, especially if you have to pass a personalised API Key in each request).</source>
          <target state="translated">클라이언트 측 코드에서 교차 출처 액세스를 전혀 지원하지 않을 수 있습니다 (특히 각 요청에서 개인화 된 API 키를 전달해야하는 경우 보안상의 이유로 결정될 수 있음).</target>
        </trans-unit>
        <trans-unit id="4035c1092fef5f4b1d5300a30ca72bc19b830f2c" translate="yes" xml:space="preserve">
          <source>They might support JSONP</source>
          <target state="translated">JSONP를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4070327462efd6341c1d8af061f6ae9a155f4f00" translate="yes" xml:space="preserve">
          <source>They might tell you to use specific URLs</source>
          <target state="translated">특정 URL을 사용하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e6affe855b69f1d8bd485bd50cbf74902446c9" translate="yes" xml:space="preserve">
          <source>This CORS issue wasn't further elaborated (for other causes).</source>
          <target state="translated">이 CORS 문제는 더 이상 설명되지 않았습니다 (다른 원인).</target>
        </trans-unit>
        <trans-unit id="da5b27da2c10e147b1be9056b8f6e0b70cc76a30" translate="yes" xml:space="preserve">
          <source>This happens when (roughly speaking) you try to make a cross-origin request that:</source>
          <target state="translated">이것은 (대략 말하면) 다음과 같은 출처 간 요청을하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa7d3a1a783441f8156a995c4e747515c5eed7e1" translate="yes" xml:space="preserve">
          <source>This is happening because of the CORS error. CORS stands for Cross Origin Resource Sharing. In simple words, this error occurs when we try to access a domain/resource from another domain.</source>
          <target state="translated">이것은 CORS 오류로 인해 발생합니다. CORS는 Cross Origin Resource Sharing의 약자입니다. 간단히 말해이 오류는 다른 도메인에서 도메인 / 리소스에 액세스하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9445c44ac33eafce8dbcfa7beb12d85c9a2a027a" translate="yes" xml:space="preserve">
          <source>This is not the case for this exact question, but might help others that search for that problem</source>
          <target state="translated">이 정확한 질문의 경우는 아니지만 해당 문제를 찾는 다른 사람들을 도울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a4478d9435b61f5fc0f10a853aef5dc4b7c054" translate="yes" xml:space="preserve">
          <source>This is something you can do in your client-code to prevent CORS errors in &lt;em&gt;some cases&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;일부 경우&lt;/em&gt; CORS 오류를 방지하기 위해 클라이언트 코드에서 수행 할 수있는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="dd387cc7c0ddfa81e8a73fd3ad8eec157d2b5a85" translate="yes" xml:space="preserve">
          <source>This is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;Same Origin Policy&lt;/a&gt;. It is a security feature implemented by browsers.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일한 원산지 정책&lt;/a&gt; 입니다. 브라우저에 의해 구현 된 보안 기능입니다.</target>
        </trans-unit>
        <trans-unit id="f228285fd4ea1c4455057da91df16018363da6ef" translate="yes" xml:space="preserve">
          <source>This would be fine since that is just between Mallory and Bob. There is no way for Bob to think that Mallory is Alice and to provide Mallory with data that should be kept confidential between Alice and Bob.</source>
          <target state="translated">Mallory와 Bob 사이에 있기 때문에 이것은 좋을 것입니다. Bob은 Mallory가 Alice라고 생각하고 Alice와 Bob간에 기밀로 유지해야하는 데이터를 Mallory에 제공 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="2e622d7f6639260890f80f2a6685c393b5403a2f" translate="yes" xml:space="preserve">
          <source>To fix this, if you have access to the other domain, you will have to allow Access-Control-Allow-Origin in the server. This can be added in the headers. You can enable this for all the requests/domains or a specific domain.</source>
          <target state="translated">이 문제를 해결하려면 다른 도메인에 액세스 할 수있는 경우 서버에서 Access-Control-Allow-Origin을 허용해야합니다. 헤더에 추가 할 수 있습니다. 모든 요청 / 도메인 또는 특정 도메인에 대해이를 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f655decc8eac3fe6c8bc774d35ee8140515efbb" translate="yes" xml:space="preserve">
          <source>What is stopping me from accessing the page?</source>
          <target state="translated">페이지 액세스를 방해하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c222285e4f0dfcb26c7d734bf432abc2efc0b6a4" translate="yes" xml:space="preserve">
          <source>Why the Same Origin Policy applies when you don't think it should</source>
          <target state="translated">생각하지 않을 때 동일한 출처 정책이 적용되는 이유</target>
        </trans-unit>
        <trans-unit id="68b8e4a4bfccfe90f892af4970ab015d6f70ef95" translate="yes" xml:space="preserve">
          <source>Why the Same Origin Policy only applies to JavaScript in a web page</source>
          <target state="translated">동일한 출처 정책이 웹 페이지의 JavaScript에만 적용되는 이유</target>
        </trans-unit>
        <trans-unit id="abbe2bbe571390ca47e7527f04f9f823e204410f" translate="yes" xml:space="preserve">
          <source>Why you can display data in the page without reading it with JS</source>
          <target state="translated">JS로 읽지 않고 페이지에 데이터를 표시 할 수있는 이유</target>
        </trans-unit>
        <trans-unit id="383dc6735c76bbfea9b61fc8d3bbc5bbdaf87eee" translate="yes" xml:space="preserve">
          <source>Writing something other than a web app</source>
          <target state="translated">웹앱 이외의 것을 작성</target>
        </trans-unit>
        <trans-unit id="71bad54d58acd5cde3dc0f122a888a11d325d05a" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest cannot load &lt;a href=&quot;https://www.example.com/&quot;&gt;https://www.example.com/&lt;/a&gt;
      No 'Access-Control-Allow-Origin' header is present on the requested 
      resource. Origin '&lt;a href=&quot;http://localhost:4300&quot;&gt;http://localhost:4300&lt;/a&gt;' is therefore not allowed access.</source>
          <target state="translated">XMLHttpRequest가 &lt;a href=&quot;https://www.example.com/&quot;&gt;https://www.example.com/을 (를)&lt;/a&gt; 로드 할 수 없습니다. 요청 된 리소스에 'Access-Control-Allow-Origin'헤더가 없습니다. 따라서 원본 ' &lt;a href=&quot;http://localhost:4300&quot;&gt;http : // localhost : 4300&lt;/a&gt; '은 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d4c0874dabc4851005a3af251a7dd41b17c2b76" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header</source>
          <target state="translated">XMLHttpRequest가 XXX 아니요 'Access-Control-Allow-Origin'헤더를로드 할 수 없음</target>
        </trans-unit>
        <trans-unit id="84032e9155256a63c2c317d1a432e1392ae2ffde" translate="yes" xml:space="preserve">
          <source>You can make use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&quot;&gt;Simple Requests&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&quot;&gt;간단한 요청&lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="565919979d1b220118880d7347d1698f1fb11c07" translate="yes" xml:space="preserve">
          <source>You should enable CORS to get it working.</source>
          <target state="translated">CORS가 작동하도록 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="39ab42da37e2b09b25f5e11e8fbf631b5baa0ed2" translate="yes" xml:space="preserve">
          <source>Your particular case is showing how it is implemented for XMLHttpRequest (and you'll get identical results if you were to use fetch), but it also applies to other things (such as images loaded onto a &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; or documents loaded into an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;), just with slightly different implementations.</source>
          <target state="translated">특정 사례는 XMLHttpRequest에 대해 구현 방법을 보여 주지만 (fetch를 사용하는 경우 동일한 결과를 얻음) 다른 것들 (예 : &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; 에 로드 된 이미지 또는 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 약간 다른 구현으로 iframe&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="9b958ab959f694798d92a468527ac46f2f64cf4b" translate="yes" xml:space="preserve">
          <source>add CORS headers</source>
          <target state="translated">CORS 헤더 추가</target>
        </trans-unit>
        <trans-unit id="fbbf1bdb4343897dcae9384602598bf7e27d95fa" translate="yes" xml:space="preserve">
          <source>convert the response to JSONP</source>
          <target state="translated">응답을 JSONP로 변환</target>
        </trans-unit>
        <trans-unit id="4d45714443791a616cc27fecf90f9f0854b14322" translate="yes" xml:space="preserve">
          <source>exist on the same origin as the HTML document</source>
          <target state="translated">HTML 문서와 동일한 출처에 존재</target>
        </trans-unit>
        <trans-unit id="64979ef625f468550475be52a9f9eba4cb697b50" translate="yes" xml:space="preserve">
          <source>tl;dr &amp;mdash;&amp;nbsp;There's a summary at the end and headings in the answer to make it easier to find the relevant parts. Reading everything is recommended though as it provides useful background for understanding the &lt;strong&gt;why&lt;/strong&gt; that makes seeing how the &lt;strong&gt;how&lt;/strong&gt; applies in different circumstances easier.</source>
          <target state="translated">tl; dr &amp;mdash; 관련 부분을보다 쉽게 ​​찾을 수 있도록 답변 끝에 제목과 제목이 요약되어 있습니다. 다른 상황에서 &lt;strong&gt;어떻게&lt;/strong&gt; 적용 &lt;strong&gt;되는지&lt;/strong&gt; 쉽게 &lt;strong&gt;알&lt;/strong&gt; 수있는 &lt;strong&gt;이유&lt;/strong&gt; 를 이해하는 데 유용한 배경을 제공하므로 모든 것을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="798d6f2be2e1e1f95e0abe2c366b9282b7d0b9fc" translate="yes" xml:space="preserve">
          <source>tl;dr; About the Same Origin Policy</source>
          <target state="translated">tl; dr; 동일한 원산지 정책 정보</target>
        </trans-unit>
        <trans-unit id="e4288b0b274bc0ac97897c68b14dc2b0d1554ea7" translate="yes" xml:space="preserve">
          <source>trying to put &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; and other CORS response headers on the request. These don't belong on the request, don't do anything helpful (what would be the point of a permissions system where you could grant yourself permission?), and must appear only on the response.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 및 기타 CORS 응답 헤더를 요청에 넣습니다. 이것들은 요청에 속하지 않으며, 도움이되는 어떤 것도하지 않습니다 (허가를받을 수있는 권한 시스템의 요점은 무엇입니까?). 응답에만 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="1fa6839e05c6436308f1e8f17d2a6574bb48bf8d" translate="yes" xml:space="preserve">
          <source>trying to put a &lt;code&gt;Content-Type: application/json&lt;/code&gt; header on a GET request that has no request body to describe the content of (typically when the author confuses &lt;code&gt;Content-Type&lt;/code&gt; and &lt;code&gt;Accept&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Content-Type: application/json&lt;/code&gt; 를 설명 할 요청 본문이없는 GET 요청에 Content-Type : application / json 헤더를 넣으려고합니다 (일반적으로 작성자가 &lt;code&gt;Content-Type&lt;/code&gt; 과 &lt;code&gt;Accept&lt;/code&gt; 를 혼동 할 때).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
