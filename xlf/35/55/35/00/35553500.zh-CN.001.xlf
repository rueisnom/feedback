<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/35553500">
    <body>
      <group id="35553500">
        <trans-unit id="c5fdbed70e669b038bcfb2cab90deeaf62877bee" translate="yes" xml:space="preserve">
          <source>&quot;Get&quot; request with appending headers transform to &quot;Options&quot; request. So Cors policy problems occur. You have to implement &quot;Options&quot; request to your server.</source>
          <target state="translated">&quot;Get &quot;请求与附加头的 &quot;获取 &quot;请求转化为 &quot;选项 &quot;请求。所以Cors策略的问题就出现了。你必须在你的服务器上实现 &quot;Options &quot;请求。</target>
        </trans-unit>
        <trans-unit id="f69aaadff17bc308b050f9fadf2f5785686ce694" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but the browser has no way of knowing if either of the above are true, so trust is not automatic and the SOP is applied. Permission has to be granted explicitly before the browser will give the data it was given to a different website.</source>
          <target state="translated">&amp;hellip;但是浏览器无法知道以上两个条件是否成立，因此信任不是自动的，因此会应用SOP。 在浏览器将数据提供给其他网站之前，必须明确授予权限。</target>
        </trans-unit>
        <trans-unit id="aa3428b119285e7b20310e804868ca099ac810ab" translate="yes" xml:space="preserve">
          <source>&amp;hellip; in the response headers to permit any website to read the data.</source>
          <target state="translated">&amp;hellip;在响应标题中，以允许任何网站读取数据。</target>
        </trans-unit>
        <trans-unit id="0666e400461e2ce9ecc28ecb83674c30b2511723" translate="yes" xml:space="preserve">
          <source>&amp;hellip; would allow only a specific site to access it, and Bob can dynamically generate that based on the &lt;code&gt;Origin&lt;/code&gt;&lt;em&gt;request&lt;/em&gt; header to permit multiple, but not all, sites to access it.</source>
          <target state="translated">&amp;hellip;将仅允许特定站点访问它，而Bob可以基于 &lt;code&gt;Origin&lt;/code&gt; &lt;em&gt;请求&lt;/em&gt;标头动态生成该&lt;em&gt;消息，&lt;/em&gt;以允许多个但不是全部站点访问它。</target>
        </trans-unit>
        <trans-unit id="3083c68c35322c957b6383c55bcd22231a4d4652" translate="yes" xml:space="preserve">
          <source>(Weirdly, it also applies to CSS fonts, but that is because found foundries insisted on DRM and not for the security issues that the Same Origin Policy usually covers).</source>
          <target state="translated">奇怪的是,这也适用于CSS字体,但这是因为代工厂商坚持使用DRM,而不是因为同源政策通常涵盖的安全问题)。</target>
        </trans-unit>
        <trans-unit id="c721f376efe00285946ac6d7bf010b66ff393846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; Browser extensions do need to be written carefully to avoid cross-origin issues. &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/extension-content-script-fetches&quot;&gt;See the Chrome documentation for example&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 浏览器扩展确实需要仔细编写，以避免跨域问题。 &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/extension-content-script-fetches&quot;&gt;例如，请参阅Chrome文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccf579f23dfb488978fdf26171abc0e7c4458b84" translate="yes" xml:space="preserve">
          <source>A Proxy</source>
          <target state="translated">代理人</target>
        </trans-unit>
        <trans-unit id="12bdfbed461b262c6a3ff537a120d9b8a0e256c7" translate="yes" xml:space="preserve">
          <source>A basic implementation would just include:</source>
          <target state="translated">一个基本的实施方案只需包括:</target>
        </trans-unit>
        <trans-unit id="79adb0593bc6b4bf0a194d641b36d1310630c1a5" translate="yes" xml:space="preserve">
          <source>About the Same Origin Policy</source>
          <target state="translated">关于同源政策</target>
        </trans-unit>
        <trans-unit id="cedda5083aa15826802650527c14fd360bd167bc" translate="yes" xml:space="preserve">
          <source>Access to fetch at '&lt;code&gt;https://example.com/&lt;/code&gt;' from origin '&lt;code&gt;https://example.net&lt;/code&gt;' has been blocked by CORS policy: No '&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.</source>
          <target state="translated">从源&amp;ldquo; &lt;code&gt;https://example.net&lt;/code&gt; &amp;rdquo;访问&amp;ldquo; &lt;code&gt;https://example.com/&lt;/code&gt; &amp;rdquo;处的访存已被CORS策略阻止：请求的资源上不存在&amp;ldquo; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &amp;rdquo;标头。 如果不透明的响应满足您的需求，请将请求的模式设置为&amp;ldquo; no-cors&amp;rdquo;，以在禁用CORS的情况下获取资源。</target>
        </trans-unit>
        <trans-unit id="7b7974bfa3fba0e3975c4d056b6b9ca1197d455e" translate="yes" xml:space="preserve">
          <source>Alice is a person with a web browser</source>
          <target state="translated">爱丽丝是一个拥有网络浏览器的人</target>
        </trans-unit>
        <trans-unit id="080d446b3afc60112cc22d7278d349fef3fd6d9e" translate="yes" xml:space="preserve">
          <source>Alice is logged into Bob's site and has some confidential data there. Perhaps it is a company intranet (accessible only to browsers on the LAN), or her online banking (accessible only with a cookie you get after entering a username and password).</source>
          <target state="translated">Alice登录了Bob的网站,在那里有一些机密数据。也许是公司内部网(只有局域网上的浏览器才能访问),或者是她的网上银行(只有在输入用户名和密码后,才能通过cookie访问)。</target>
        </trans-unit>
        <trans-unit id="2f9059ae8633c85b7699e923ebb41ea7becd668e" translate="yes" xml:space="preserve">
          <source>Alice visits Mallory's website which has some JavaScript that causes Alice's browser to make an HTTP request to Bob's website (from her IP address with her cookies, etc). This could be as simple as using &lt;code&gt;XMLHttpRequest&lt;/code&gt; and reading the &lt;code&gt;responseText&lt;/code&gt;.</source>
          <target state="translated">爱丽丝访问Mallory的网站，该网站具有一些JavaScript，这些JavaScript导致爱丽丝的浏览器向鲍勃的网站发出HTTP请求（从她的IP地址，她的cookie等）。 这可以像使用 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 并读取 &lt;code&gt;responseText&lt;/code&gt; 一样简单。</target>
        </trans-unit>
        <trans-unit id="5bdc163ef94b8775f3c2206de222d5cdbb730053" translate="yes" xml:space="preserve">
          <source>Alice, Bob and Mallory are the same person.</source>
          <target state="translated">爱丽丝、鲍勃和马洛里是同一个人。</target>
        </trans-unit>
        <trans-unit id="e356eab4f83b3e77df9f9a8c73c681fa3b5ef7cc" translate="yes" xml:space="preserve">
          <source>Alternatives to CORS</source>
          <target state="translated">CORS的替代品</target>
        </trans-unit>
        <trans-unit id="3f9bf680f2d7e601b6b53dc367493c6e9226daf2" translate="yes" xml:space="preserve">
          <source>As noted in the section &quot;Why the Same Origin Policy only applies to JavaScript in a web page&quot;, you can avoid the SOP by not writing JavaScript in a webpage.</source>
          <target state="translated">正如在 &quot;为什么同源政策只适用于网页中的JavaScript &quot;一节中提到的,你可以通过不在网页中编写JavaScript来避免SOP。</target>
        </trans-unit>
        <trans-unit id="d506fbbc5a8bc383106b8326dc9ab129456f337c" translate="yes" xml:space="preserve">
          <source>As this isn't mentioned in the accepted answer.</source>
          <target state="translated">由于这一点在接受的答案中没有提到。</target>
        </trans-unit>
        <trans-unit id="3b05e4adacdafe56d47f3926c61aa1bd3e81b8aa" translate="yes" xml:space="preserve">
          <source>Bob could also provide the data using a hack like &lt;a href=&quot;https://stackoverflow.com/questions/2067472/what-is-jsonp-all-about&quot;&gt;JSONP&lt;/a&gt; which is how people did cross-origin Ajax before CORS came along.</source>
          <target state="translated">鲍勃还可以使用&lt;a href=&quot;https://stackoverflow.com/questions/2067472/what-is-jsonp-all-about&quot;&gt;JSONP之&lt;/a&gt;类的黑客提供数据，这是人们在CORS出现之前对Ajax进行跨源编程的方式。</target>
        </trans-unit>
        <trans-unit id="1ea8ca767428c6dc82740ebab1a317eb537dfc17" translate="yes" xml:space="preserve">
          <source>Bob is providing entirely public information</source>
          <target state="translated">鲍勃提供的完全是公共信息</target>
        </trans-unit>
        <trans-unit id="4ad9e5a181ccf4d48e00fa324c6d3fa0e330762e" translate="yes" xml:space="preserve">
          <source>Bob runs a website (&lt;code&gt;https://www.[website].com/&lt;/code&gt; in your example)</source>
          <target state="translated">鲍勃经营一个网站（在您的示例中为 &lt;code&gt;https://www.[website].com/&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ddc4f8c91108ac2bf18e262a30c2fd7398d649f7" translate="yes" xml:space="preserve">
          <source>Bob wouldn't need to grant any permissions for that to happen.</source>
          <target state="translated">鲍勃不需要授予任何权限就能做到这一点。</target>
        </trans-unit>
        <trans-unit id="0a7792b7795b50e8301b591ad82091d0598c147a" translate="yes" xml:space="preserve">
          <source>Browser extensions</source>
          <target state="translated">浏览器扩展</target>
        </trans-unit>
        <trans-unit id="52a3e647edc456ec783b6d63aa3dd4cf5795f836" translate="yes" xml:space="preserve">
          <source>Browser extensions&lt;code&gt;*&lt;/code&gt;, the Network tab in browser developer tools and applications like Postman are installed software. They aren't passing data from one website to the JavaScript belonging to a different website &lt;em&gt;just because you visited that different website&lt;/em&gt;. Installing software usually takes a more conscious choice.</source>
          <target state="translated">浏览器扩展程序 &lt;code&gt;*&lt;/code&gt; ，浏览器开发人员工具和Postman等应用程序中的网络选项卡是已安装的软件。 他们不会&lt;em&gt;因为您访问另一个网站&lt;/em&gt;而将数据从一个网站传递到属于不同网站的JavaScript中。 安装软件通常需要更明智的选择。</target>
        </trans-unit>
        <trans-unit id="02de3c6a5d36416398534d79472aff7a9ccfbc69" translate="yes" xml:space="preserve">
          <source>But I'm not Bob!</source>
          <target state="translated">但我不是鲍勃!</target>
        </trans-unit>
        <trans-unit id="2139aadec237bbecb581e62932f94bc3bce7a704" translate="yes" xml:space="preserve">
          <source>CORS</source>
          <target state="translated">CORS</target>
        </trans-unit>
        <trans-unit id="72a7bba2b6e46912da58c628abb44b1d77e213c9" translate="yes" xml:space="preserve">
          <source>Common mistakes that trigger this include:</source>
          <target state="translated">触发这种情况的常见错误包括:</target>
        </trans-unit>
        <trans-unit id="7b6794110b358bc83a6cd7c420d7cd48e8a0d272" translate="yes" xml:space="preserve">
          <source>Consequently, Mallory can only use this technique to read &lt;em&gt;public&lt;/em&gt; data.</source>
          <target state="translated">因此，Mallory只能使用此技术读取&lt;em&gt;公共&lt;/em&gt;数据。</target>
        </trans-unit>
        <trans-unit id="22709a8723fb233b31baf16067c518f10a970801" translate="yes" xml:space="preserve">
          <source>Couldn't be generated with a regular HTML form (e.g. has custom headers or a Content-Type that you couldn't use in a form's &lt;code&gt;enctype&lt;/code&gt;).</source>
          <target state="translated">无法使用常规HTML表单生成（例如，具有自定义标头或无法在表单的 &lt;code&gt;enctype&lt;/code&gt; 中使用的Content-Type）。</target>
        </trans-unit>
        <trans-unit id="9f7023ae6c0c7bb388366399240a29d8f70d9716" translate="yes" xml:space="preserve">
          <source>Error messages which mention &quot;Response for preflight&quot;</source>
          <target state="translated">提到 &quot;飞行前反应 &quot;的错误信息</target>
        </trans-unit>
        <trans-unit id="de11082858543756881cde0b6cf3f0aabed14671" translate="yes" xml:space="preserve">
          <source>For any given URL it is possible that the SOP is not needed. A couple of common scenarios where this is the case are:</source>
          <target state="translated">对于任何给定的URL,有可能不需要SOP。在这种情况下,常见的几种情况是:。</target>
        </trans-unit>
        <trans-unit id="360422379e164038fc5a13abf8702a9a03c5924c" translate="yes" xml:space="preserve">
          <source>Having a proper development environment with a local development &lt;em&gt;server&lt;/em&gt; 
is usually a better approach.</source>
          <target state="translated">通常，使用本地开发&lt;em&gt;服务器&lt;/em&gt;使用适当的开发环境是一种更好的方法。</target>
        </trans-unit>
        <trans-unit id="8c77c3320c21e1da3d952fdceed8b3d5a9040f1b" translate="yes" xml:space="preserve">
          <source>How to do it is explained by the Chrome error message given when you make a request using &lt;code&gt;fetch&lt;/code&gt; and don't get permission to view the response with CORS:</source>
          <target state="translated">当您使用 &lt;code&gt;fetch&lt;/code&gt; 进行请求且没有获得使用CORS查看响应的权限时，Chrome给出了Chrome错误消息，说明了操作方法：</target>
        </trans-unit>
        <trans-unit id="b5a2e8f7365ba0b05a0e386702f943744a084420" translate="yes" xml:space="preserve">
          <source>How to get a cross-origin resource sharing (CORS) post request working</source>
          <target state="translated">如何实现跨源资源共享(CORS)岗位请求的工作方式</target>
        </trans-unit>
        <trans-unit id="4544234b52783d9ce6c7523afb3788d72f490ed8" translate="yes" xml:space="preserve">
          <source>I got the same error in Chrome console.</source>
          <target state="translated">我在Chrome游戏机中也出现了同样的错误。</target>
        </trans-unit>
        <trans-unit id="191fa4c21ffb0259f46e3158d042758a40108e3b" translate="yes" xml:space="preserve">
          <source>I have a Grunt process which initiates an instance of express.js server. This was working absolutely fine up until just now when it started serving a blank page with the following appearing in the error log in the developer's console in Chrome (latest version):</source>
          <target state="translated">我有一个 Grunt 进程,它启动了一个 express.js 服务器的实例。直到刚才,它的工作非常顺利,但在Chrome浏览器(最新版本)的开发者控制台中,它开始为一个空白页面提供服务,并在错误日志中出现以下内容。</target>
        </trans-unit>
        <trans-unit id="696b9bf9d526b3f1a17737731ae9d27d92d1474e" translate="yes" xml:space="preserve">
          <source>I'm having this issue currently under different reason.
My front end is returning 'Access-Control-Allow-Origin' header error as well.</source>
          <target state="translated">我目前在不同的原因下遇到了这个问题。我的前端也返回'Access-Control-Allow-Origin'的标题错误。</target>
        </trans-unit>
        <trans-unit id="abe02bb96c36c6f655503931ed03c194f5f3b1cd" translate="yes" xml:space="preserve">
          <source>If Bob is running a public API then there might be a mechanism to turn on CORS (perhaps by formatting the request in a certain way, or a config option after logging into a Developer Portal site for Bob's site). This will have to be a mechanism implemented by Bob though. Mallory could read the documentation on Bob's site to see if something is available, or she could talk to Bob and ask him to implement CORS.</source>
          <target state="translated">如果Bob正在运行一个公共API,那么可能会有一个机制来打开CORS(也许是通过特定的方式格式化请求,或者在登录到Bob的网站的开发者门户站点后的配置选项)。但这必须由Bob实现的机制。Mallory可以阅读Bob的网站上的文档,看看是否有可用的东西,或者她可以和Bob谈谈,请他实现CORS。</target>
        </trans-unit>
        <trans-unit id="92ad6fa7497aadeaf8ff53a9f87b47f0a06f7043" translate="yes" xml:space="preserve">
          <source>If it is a public service:</source>
          <target state="translated">如果是公共服务的话。</target>
        </trans-unit>
        <trans-unit id="b43202b21aa22f1dcb0dbdd04e2b92e038006f59" translate="yes" xml:space="preserve">
          <source>If none of the above apply: Get the browser to talk to &lt;em&gt;your&lt;/em&gt; server instead, and then have your server fetch the data from the other server and pass it on. (There are also third-party hosted services which attach CORS headers to publically accessible resources that you could use).</source>
          <target state="translated">如果上述方法均不适用：请让浏览器与&lt;em&gt;您的&lt;/em&gt;服务器通信，然后让您的服务器从另一台服务器获取数据并继续传递。 （还有一些第三方托管服务，它们将CORS标头附加到您可以使用的可公开访问的资源上）。</target>
        </trans-unit>
        <trans-unit id="e48fd7463af9f02e701f5f698b5fff66bca17c7f" translate="yes" xml:space="preserve">
          <source>If the HTML document the JS runs in and the URL being requested are on the same origin (sharing the same scheme, hostname, and port) then they Same Origin Policy grants permission by default. CORS is not needed.</source>
          <target state="translated">如果JS运行的HTML文档和被请求的URL是在同一个原点上(共享相同的方案、主机名和端口),那么它们的同一原点策略默认授予权限。CORS是不需要的。</target>
        </trans-unit>
        <trans-unit id="08cc9d28f22949cc5fa0a94d72751f3fa207f841" translate="yes" xml:space="preserve">
          <source>If you are correctly doing something that needs a preflight</source>
          <target state="translated">如果你所做的事情是正确的,需要进行飞行前的检查</target>
        </trans-unit>
        <trans-unit id="ba22853626484508756ed5c98d033ee48a650bbd" translate="yes" xml:space="preserve">
          <source>If you are friendly with the person who controls it: Get them to add CORS permissions to it.</source>
          <target state="translated">如果你和控制它的人很友好。让他们给它添加CORS权限。</target>
        </trans-unit>
        <trans-unit id="853008022034caee905ec37fc3d3b78af426efd3" translate="yes" xml:space="preserve">
          <source>If you are triggering a preflight by mistake</source>
          <target state="translated">如果你错误地触发了预飞行</target>
        </trans-unit>
        <trans-unit id="e26a716bf9b75b23f6454ffbb214b653934425a4" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch&quot;&gt;the &lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; (rather than &lt;code&gt;XMLHttpRequest&lt;/code&gt;), then you can configure it to not try to use CORS.</source>
          <target state="translated">如果使用的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch&quot;&gt;是 &lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; （而不是 &lt;code&gt;XMLHttpRequest&lt;/code&gt; ），则可以将其配置为不尝试使用CORS。</target>
        </trans-unit>
        <trans-unit id="70d17978875ee658715b4db351d2df97b4823527" translate="yes" xml:space="preserve">
          <source>If you control the server the request is being made to: Add CORS permissions to it.</source>
          <target state="translated">如果你控制了请求的服务器。给它添加CORS权限。</target>
        </trans-unit>
        <trans-unit id="c3d6c76ecd5f6ccde50eec6284baa0a0a9f6e8f0" translate="yes" xml:space="preserve">
          <source>If your client code does not explicit set affected Headers (e.g. &quot;Accept&quot;) with a fix value in the request it &lt;em&gt;might&lt;/em&gt; occur that some clients do set these Headers automatically with some &quot;non-standard&quot; values causing the server to not accept it as Simple Request - which will give you a CORS error.</source>
          <target state="translated">如果您的客户端代码未在请求中使用固定值显式设置受影响的标头（例如&amp;ldquo; Accept&amp;rdquo;），则&lt;em&gt;可能会&lt;/em&gt;发生某些客户端确实使用某些&amp;ldquo;非标准&amp;rdquo;值自动设置这些标头，导致服务器不接受该标头的情况。简单请求-这会给您一个CORS错误。</target>
        </trans-unit>
        <trans-unit id="a7eaa077646e8880c93a7bd47f607df23835f175" translate="yes" xml:space="preserve">
          <source>In either of these cases, removing the extra request header will often be enough to avoid the need for a preflight (which will solve the problem when communicating with APIs that support simple requests but not preflighted requests).</source>
          <target state="translated">在上述任何一种情况下,删除额外的请求头通常就可以避免预检(当与支持简单请求但不支持预检请求的API进行通信时,这将解决这个问题)。</target>
        </trans-unit>
        <trans-unit id="5729a2bfc145c982ccb21e1853b5da3159d0e027" translate="yes" xml:space="preserve">
          <source>In order to perform a 'Simple Requests' the request needs to meet several conditions. E.g. only allowing &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt; method, as well as only allowing some given Headers (you can find all conditions &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">为了执行&amp;ldquo;简单请求&amp;rdquo;，请求需要满足几个条件。 例如，仅允许 &lt;code&gt;POST&lt;/code&gt; ， &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;HEAD&lt;/code&gt; 方法，以及仅允许某些给定的Header（您可以&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&quot;&gt;在此处&lt;/a&gt;找到所有条件）。</target>
        </trans-unit>
        <trans-unit id="7cc076a9ba30ebdfbaf2900c4da047938ac0695e" translate="yes" xml:space="preserve">
          <source>In these cases then &lt;strong&gt;the rest of this answer still applies&lt;/strong&gt; but you also need to make sure that the server can listen for the preflight request (which will be &lt;code&gt;OPTIONS&lt;/code&gt; (and not &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt; or whatever you were trying to send) and respond to it with the right &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header but also &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; and &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; to allow your specific HTTP methods or headers.</source>
          <target state="translated">在这种情况下&lt;strong&gt;，此答案的其余部分仍然适用，&lt;/strong&gt;但是您还需要确保服务器可以侦听预检请求（将是 &lt;code&gt;OPTIONS&lt;/code&gt; （而不是 &lt;code&gt;GET&lt;/code&gt; ， &lt;code&gt;POST&lt;/code&gt; 或您尝试发送的任何内容）并对其进行响应使用正确的 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头，以及 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 和 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 以允许您的特定HTTP方法或标头。</target>
        </trans-unit>
        <trans-unit id="d26715ff3c8058144a5e6781d18e2ccc51089bd3" translate="yes" xml:space="preserve">
          <source>Includes credentials like cookies</source>
          <target state="translated">包括cookies等凭证</target>
        </trans-unit>
        <trans-unit id="62f77bfbffd7a258cc0b8ce904a719ce6a3ee3ed" translate="yes" xml:space="preserve">
          <source>It is possible for a browser extension to inject the CORS headers in the response before the Same Origin Policy is applied.</source>
          <target state="translated">在应用同一来源策略之前,浏览器扩展可以在响应中注入CORS标题。</target>
        </trans-unit>
        <trans-unit id="524d541343869ab2cfcaedba8cffa363f4e4da8d" translate="yes" xml:space="preserve">
          <source>It requires that Mallory trust Bob not to provide malicious code.</source>
          <target state="translated">它要求Mallory信任Bob不提供恶意代码。</target>
        </trans-unit>
        <trans-unit id="a0d49ced5af1ce4f42b72853fa8477beb628ad66" translate="yes" xml:space="preserve">
          <source>It will either:</source>
          <target state="translated">它要么会。</target>
        </trans-unit>
        <trans-unit id="45aea3ca1172a010ceadbf9eb618c7f4dd492ee6" translate="yes" xml:space="preserve">
          <source>It will let you make a simple request, not see the response, and not fill the Developer Console with error messages.</source>
          <target state="translated">它可以让你做一个简单的请求,看不到响应,也不会让开发者控制台中充满错误信息。</target>
        </trans-unit>
        <trans-unit id="97e9368be80f4c0b36d760f04834a058af9cb0eb" translate="yes" xml:space="preserve">
          <source>It works by presenting the data in the form of a JavaScript program which injects the data into Mallory's page.</source>
          <target state="translated">它的工作原理是将数据以JavaScript程序的形式呈现,并将数据注入到Mallory的页面中。</target>
        </trans-unit>
        <trans-unit id="42c6036ddd5d662bc456c530699d3704be7c5087" translate="yes" xml:space="preserve">
          <source>JSONP</source>
          <target state="translated">JSONP</target>
        </trans-unit>
        <trans-unit id="d91c94a14abe9d71f04f1aaf68eb2c1b48685144" translate="yes" xml:space="preserve">
          <source>Just that I've pointed the wrong URL so this header wasn't reflected properly (in which i kept presume it did). localhost (front end) -&amp;gt; call to non secured http (supposed to be https), make sure the API end point from front end is pointing to the correct protocol.</source>
          <target state="translated">只是我指出了错误的URL，所以未正确反映此标头（我一直认为其中确实如此）。 本地主机（前端）-&amp;gt;调用非安全的http（假定为https），请确保前端的API端点指向正确的协议。</target>
        </trans-unit>
        <trans-unit id="5948c6b1360bb812feb00f5faadc9ae4a212ff35" translate="yes" xml:space="preserve">
          <source>Make sure you aren't triggering a preflight request you don't need. The API might grant permission for simple requests but not preflighted requests.</source>
          <target state="translated">确保你没有触发一个你不需要的预检请求。API可能会对简单的请求授予权限,但不是预亮请求。</target>
        </trans-unit>
        <trans-unit id="1c47e0f7a3e4ddaa6dbc100fabee7e2aec1ca459" translate="yes" xml:space="preserve">
          <source>Mallory &lt;em&gt;could&lt;/em&gt; use server-side code to fetch the data (which she could then pass from her server to Alice's browser through HTTP as usual).</source>
          <target state="translated">Mallory &lt;em&gt;可以&lt;/em&gt;使用服务器端代码来获取数据（然后可以照常通过HTTP将其从服务器传递到Alice的浏览器）。</target>
        </trans-unit>
        <trans-unit id="564e68efef90eb6ff94dbc5e63c04d09f8c8e32a" translate="yes" xml:space="preserve">
          <source>Mallory runs a website (&lt;code&gt;http://localhost:4300&lt;/code&gt; in your example)</source>
          <target state="translated">Mallory运行一个网站（在您的示例中为 &lt;code&gt;http://localhost:4300&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f2e3a0d4f23dada9bbe46ba7d15363f3d33d0fc0" translate="yes" xml:space="preserve">
          <source>Mallory was trusted</source>
          <target state="translated">马洛里是值得信赖的</target>
        </trans-unit>
        <trans-unit id="5741aafa13c097ce47a2ce4d5a8a24a6ed295abc" translate="yes" xml:space="preserve">
          <source>Move the two resources to a single Origin</source>
          <target state="translated">将两个资源转移到一个单一的Origin</target>
        </trans-unit>
        <trans-unit id="179f34374a10f83759fcee462cc56f0119a97fff" translate="yes" xml:space="preserve">
          <source>My problem was, I was trying to go to the site using &lt;code&gt;http://&lt;/code&gt; instead of &lt;code&gt;https://&lt;/code&gt;. So there was nothing to fix, just had to go to the same site using &lt;code&gt;https&lt;/code&gt;.</source>
          <target state="translated">我的问题是，我试图使用 &lt;code&gt;http://&lt;/code&gt; 而不是 &lt;code&gt;https://&lt;/code&gt; 转到该站点。 因此，没有什么可修复的，只需要使用 &lt;code&gt;https&lt;/code&gt; 转到同一站点即可。</target>
        </trans-unit>
        <trans-unit id="da7899ad8069372c74d86a8d03eec992d656f441" translate="yes" xml:space="preserve">
          <source>NB: Some requests are complex and send a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests&quot;&gt;preflight&lt;/a&gt; OPTIONS request that the server will have to respond to before the browser will send the GET/POST/PUT/Whatever request that the JS wants to make. Implementations of CORS that only add &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; to specific URLs often get tripped up by this.</source>
          <target state="translated">注意：有些请求很复杂，并且会发送一个服务器必须响应的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests&quot;&gt;预检&lt;/a&gt; OPTIONS请求，然后浏览器才发送JS想要发出的GET / POST / PUT /任何请求。 仅将 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 添加到特定URL的CORS实现经常会因此而被绊倒。</target>
        </trans-unit>
        <trans-unit id="6627ccdfafd9a906f6fccd9cc62f31a063fd4bcc" translate="yes" xml:space="preserve">
          <source>Note that SOP / CORS do not mitigate &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;CSRF&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injection&lt;/a&gt; attacks which need to be handled independently.</source>
          <target state="translated">请注意，SOP / CORS不会缓解需要独立处理的&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS&lt;/a&gt; ， &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;CSRF&lt;/a&gt;或&lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL注入&lt;/a&gt;攻击。</target>
        </trans-unit>
        <trans-unit id="9bc579f199a3101a7f44833570e63a56fb1cb5e4" translate="yes" xml:space="preserve">
          <source>Note that this won't let you do anything that you require CORS to do. You will not be able to read the response. You will not be able to make a request that requires a preflight.</source>
          <target state="translated">注意,这不会让你做任何你要求CORS做的事情。您将无法读取响应。您将无法提出需要预检的请求。</target>
        </trans-unit>
        <trans-unit id="f4d6128232048cd6c6d7f3d7b647ed7fff7f8026" translate="yes" xml:space="preserve">
          <source>Note the common theme: The site providing the data has to tell the browser that it is OK for a third party site to access the data it is sending to the browser.</source>
          <target state="translated">注意共同的主题。提供数据的网站必须告诉浏览器,第三方网站可以访问它向浏览器发送的数据。</target>
        </trans-unit>
        <trans-unit id="2aebca51e57e08fa958991342bd12a4146e354ff" translate="yes" xml:space="preserve">
          <source>Obviously granting permission via CORS is something Bob would only do only if either:</source>
          <target state="translated">显然,通过CORS授予许可是鲍勃只有在以下两种情况下才会做的事情。</target>
        </trans-unit>
        <trans-unit id="52c0ea51241c014c452b8334a0a0cdf2931af1be" translate="yes" xml:space="preserve">
          <source>Opaque responses</source>
          <target state="translated">不透明的反应</target>
        </trans-unit>
        <trans-unit id="f4c0bf26e722637eaa84e1385d4bed8c7c900340" translate="yes" xml:space="preserve">
          <source>Other security risks</source>
          <target state="translated">其他安全风险</target>
        </trans-unit>
        <trans-unit id="3a9e8860a792c71b56b7e9a1d5af8455957c17a7" translate="yes" xml:space="preserve">
          <source>Read More about it here: &lt;a href=&quot;https://stackoverflow.com/questions/25923796/cors-error-with-jquery&quot;&gt;CORS error with jquery&lt;/a&gt;</source>
          <target state="translated">在这里阅读有关它的更多信息： &lt;a href=&quot;https://stackoverflow.com/questions/25923796/cors-error-with-jquery&quot;&gt;jQuery的CORS错误&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36d37ad0ea64198287e8b037dac57678ca1b9809" translate="yes" xml:space="preserve">
          <source>Read their API documentation to see what they say about accessing it with client-side JavaScript:</source>
          <target state="translated">阅读他们的API文档,看看他们是怎么说用客户端JavaScript访问的。</target>
        </trans-unit>
        <trans-unit id="3cfa06457874ce9969c8b51f9984b1636c423b3c" translate="yes" xml:space="preserve">
          <source>Since JSONP works by appending a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element to load the data in the form of a JavaScript program which calls a function already in the page, attempting to use the JSONP technique on a URL which returns JSON will fail &amp;mdash; typically with a CORB error &amp;mdash; because JSON is not JavaScript.</source>
          <target state="translated">由于JSONP通过添加 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素以JavaScript程序的形式加载数据而工作，该JavaScript程序调用了页面中已存在的函数，因此尝试在返回JSON的URL上使用JSONP技术将失败&amp;mdash;通常会出现CORB错误&amp;mdash;因为JSON不是JavaScript。</target>
        </trans-unit>
        <trans-unit id="1861df057de67ba04d2b5992466bb39553c4cf29" translate="yes" xml:space="preserve">
          <source>Some cross origin requests are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests&quot;&gt;preflighted&lt;/a&gt;.</source>
          <target state="translated">一些跨源请求已经&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests&quot;&gt;过时&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdf3b7775d3b635980a416d0d4279a7d7d042752" translate="yes" xml:space="preserve">
          <source>Sometimes people make mistakes when trying to construct Ajax requests, and sometimes these trigger the need for a preflight. If the API is designed to allow cross-origin requests, but doesn't require anything that would need a preflight, then this can break access.</source>
          <target state="translated">有时,人们在尝试构造Ajax请求时,会犯一些错误,有时这些错误会触发需要预检。如果API被设计成允许跨源请求,但不需要任何需要预检的东西,那么这可能会破坏访问。</target>
        </trans-unit>
        <trans-unit id="f0b549858f2443774149a23a83091eb427dedd6b" translate="yes" xml:space="preserve">
          <source>Sometimes you need to make an HTTP request, but you don't need to read the response. e.g. if you are posting a log message to the server for recording.</source>
          <target state="translated">有时你需要做一个HTTP请求,但你不需要读取响应,例如,如果你要发布日志消息到服务器上进行记录。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="3bfcdfe6eb4d2132f9b02f748b3b12d32af0e673" translate="yes" xml:space="preserve">
          <source>Target server must allowed cross-origin request. In order to allow it through express, simply handle http options request :</source>
          <target state="translated">目标服务器必须允许跨源请求。为了允许通过expert,只需处理http选项请求。</target>
        </trans-unit>
        <trans-unit id="03272e3fa289c41f7c3f5d68e234a4e328f368c9" translate="yes" xml:space="preserve">
          <source>That doesn't mean you can't continue to use JavaScript and HTML, but you could distribute it using some other mechanism, such as Node-WebKit or PhoneGap.</source>
          <target state="translated">这并不意味着你不能继续使用JavaScript和HTML,但你可以使用其他一些机制来发布,比如Node-WebKit或PhoneGap。</target>
        </trans-unit>
        <trans-unit id="a037477ee252bfd6e5d800d4a6268d25aa2f8c53" translate="yes" xml:space="preserve">
          <source>That server-side code could be written &amp;amp; hosted by a third party (such as CORS Anywhere). Note the privacy implications of this: The third party can monitor who proxies what across their servers.</source>
          <target state="translated">该服务器端代码可以由第三方（例如CORS Anywhere）编写和托管。 请注意以下方面的隐私含义：第三方可以监视谁代理其服务器上的内容。</target>
        </trans-unit>
        <trans-unit id="a0de50f88e2b3d052aad5c90272075ba1a3d3802" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; HTTP &lt;strong&gt;response&lt;/strong&gt; header referred to in the error message is part of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;CORS&lt;/a&gt; standard which allows Bob to explicitly grant permission to Mallory's site to access the data via Alice's browser.</source>
          <target state="translated">错误消息中引用的 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; HTTP &lt;strong&gt;响应&lt;/strong&gt;标头是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;CORS&lt;/a&gt;标准的一部分，该标准允许Bob明确授予Mallory站点访问权限，以通过Alice的浏览器访问数据。</target>
        </trans-unit>
        <trans-unit id="f1dbef57f9bfebd76c45b9a48c018f05b8a8a202" translate="yes" xml:space="preserve">
          <source>The browser's Same Origin Policy prevents that JavaScript from reading the data returned by Bob's website (which Bob and Alice don't want Mallory to access). (Note that you can, for example, display an image using an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element across origins because the content of the image is not exposed to JavaScript (or Mallory) &amp;hellip; unless you throw canvas into the mix in which case you &lt;em&gt;will&lt;/em&gt; generate a same-origin violation error).</source>
          <target state="translated">浏览器的同源策略禁止JavaScript读取Bob网站返回的数据（Bob和Alice不想让Mallory访问）。 （请注意，例如，您可以使用 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 元素在各个原点之间显示图像，因为图像的内容不会暴露在JavaScript（或Mallory）中&amp;hellip;&amp;hellip;除非您将画布放入混合中，否则&lt;em&gt;会&lt;/em&gt;生成一个同源冲突错误）。</target>
        </trans-unit>
        <trans-unit id="79ef50211c8179fcab85dd49da5f3fbabd650658" translate="yes" xml:space="preserve">
          <source>The data was not private &lt;em&gt;or&lt;/em&gt;</source>
          <target state="translated">数据不是私人的&lt;em&gt;或&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d9762ae08f6f7dad91721e27217991f8a11ff9f" translate="yes" xml:space="preserve">
          <source>The specifics of how Bob sets that response header depend on Bob's HTTP server and/or server-side programming language. There is &lt;a href=&quot;https://enable-cors.org/server.html&quot;&gt;a collection of guides for various common configurations&lt;/a&gt; that might help.</source>
          <target state="translated">Bob如何设置响应头的具体细节取决于Bob的HTTP服务器和/或服务器端编程语言。 提供&lt;a href=&quot;https://enable-cors.org/server.html&quot;&gt;了&lt;/a&gt;一些可能有用的各种常见配置的指南 。</target>
        </trans-unit>
        <trans-unit id="6604893b096b6ba328e55fd565fa6955767da643" translate="yes" xml:space="preserve">
          <source>The standard scenario that demonstrates the need for the SOP can be demonstrated with &lt;a href=&quot;https://en.wikipedia.org/wiki/Alice_and_Bob&quot;&gt;three characters&lt;/a&gt;:</source>
          <target state="translated">证明需要SOP的标准方案可以用&lt;a href=&quot;https://en.wikipedia.org/wiki/Alice_and_Bob&quot;&gt;三个字符&lt;/a&gt;来证明：</target>
        </trans-unit>
        <trans-unit id="7d044b9d63caf8c196634124ce4c9ba4ca176213" translate="yes" xml:space="preserve">
          <source>There are a number of circumstances where Mallory's site can cause a browser to fetch data from a third party and display it (e.g. by adding an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element to display an image). It isn't possible for Mallory's JavaScript to read the data in that resource though, only Alice's browser and Bob's server can do that, so it is still secure.</source>
          <target state="translated">在许多情况下，Mallory的网站可能会导致浏览器从第三方获取数据并显示（例如，通过添加 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 元素以显示图像）。 不过，Mallory的JavaScript不可能读取该资源中的数据，只有Alice的浏览器和Bob的服务器可以做到这一点，因此它仍然是安全的。</target>
        </trans-unit>
        <trans-unit id="6127874d9aef1420ff154b79562f50afaf6347c1" translate="yes" xml:space="preserve">
          <source>There is no standard mechanism for &lt;em&gt;Mallory&lt;/em&gt; to add this header because it has to come from Bob's website, which she does not control.</source>
          <target state="translated">&lt;em&gt;Mallory&lt;/em&gt;没有添加此标头的标准机制，因为它必须来自Bob不能控制的Bob的网站。</target>
        </trans-unit>
        <trans-unit id="b79496a457c196bc566172f51692296fa4b04a80" translate="yes" xml:space="preserve">
          <source>There is nothing you can do in &lt;em&gt;your&lt;/em&gt; client-side code that will enable CORS access to someone &lt;em&gt;else's&lt;/em&gt; server.</source>
          <target state="translated">您无法在客户端代码中执行任何操作来使CORS访问其他&lt;em&gt;人的&lt;/em&gt;服务器。</target>
        </trans-unit>
        <trans-unit id="beaef9fcd0c6d1171c964ef462dc2b90796057d4" translate="yes" xml:space="preserve">
          <source>There isn't a third party (Mallory) who is considered a risk.</source>
          <target state="translated">没有一个第三方(Mallory)被认为是有风险的。</target>
        </trans-unit>
        <trans-unit id="dd9bc05dc8287dee0908fc2de2446be79f55333c" translate="yes" xml:space="preserve">
          <source>These can be useful for development, but are not practical for a production site (asking every user of your site to install a browser extension that disables a security feature of their browser is unreasonable).</source>
          <target state="translated">这些对开发来说可能很有用,但对生产型网站来说并不实用(要求你的网站的每个用户安装一个浏览器扩展,禁用浏览器的安全功能是不合理的)。</target>
        </trans-unit>
        <trans-unit id="2f870286e388f3bb6b87e9c1b23cb67398f0476e" translate="yes" xml:space="preserve">
          <source>These links may help</source>
          <target state="translated">这些链接可能有帮助</target>
        </trans-unit>
        <trans-unit id="3c5b93c7e9e12c292b3d57a2e8033fcb4066808f" translate="yes" xml:space="preserve">
          <source>They also tend to work only with simple requests (failing when handling preflight OPTIONS requests).</source>
          <target state="translated">它们也往往只对简单的请求起作用(在处理OPTIONS请求时失败)。</target>
        </trans-unit>
        <trans-unit id="966f60079bca7fe60d16c9b028cbe378ce505cbe" translate="yes" xml:space="preserve">
          <source>They might not support cross-origin access from client-side code at all (this might be a deliberate decision on security grounds, especially if you have to pass a personalised API Key in each request).</source>
          <target state="translated">他们可能根本不支持客户端代码的跨源访问(这可能是出于安全考虑,特别是当你在每次请求中都要传递一个个性化的API Key时,这可能是一个故意的决定)。</target>
        </trans-unit>
        <trans-unit id="4035c1092fef5f4b1d5300a30ca72bc19b830f2c" translate="yes" xml:space="preserve">
          <source>They might support JSONP</source>
          <target state="translated">他们可能支持JSONP</target>
        </trans-unit>
        <trans-unit id="4070327462efd6341c1d8af061f6ae9a155f4f00" translate="yes" xml:space="preserve">
          <source>They might tell you to use specific URLs</source>
          <target state="translated">他们可能会告诉你使用特定的URLs</target>
        </trans-unit>
        <trans-unit id="86e6affe855b69f1d8bd485bd50cbf74902446c9" translate="yes" xml:space="preserve">
          <source>This CORS issue wasn't further elaborated (for other causes).</source>
          <target state="translated">这个CORS问题没有进一步阐述(因为其他原因)。</target>
        </trans-unit>
        <trans-unit id="da5b27da2c10e147b1be9056b8f6e0b70cc76a30" translate="yes" xml:space="preserve">
          <source>This happens when (roughly speaking) you try to make a cross-origin request that:</source>
          <target state="translated">当(粗略地讲)你试图提出一个跨产地的要求时,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="aa7d3a1a783441f8156a995c4e747515c5eed7e1" translate="yes" xml:space="preserve">
          <source>This is happening because of the CORS error. CORS stands for Cross Origin Resource Sharing. In simple words, this error occurs when we try to access a domain/resource from another domain.</source>
          <target state="translated">出现这种情况是因为CORS错误。CORS是Cross Origin Resource Sharing的缩写。简单来说,当我们尝试从另一个域访问域资源时,就会出现这个错误。</target>
        </trans-unit>
        <trans-unit id="9445c44ac33eafce8dbcfa7beb12d85c9a2a027a" translate="yes" xml:space="preserve">
          <source>This is not the case for this exact question, but might help others that search for that problem</source>
          <target state="translated">这不是这个确切的问题,但可能会帮助其他寻找这个问题的人。</target>
        </trans-unit>
        <trans-unit id="20a4478d9435b61f5fc0f10a853aef5dc4b7c054" translate="yes" xml:space="preserve">
          <source>This is something you can do in your client-code to prevent CORS errors in &lt;em&gt;some cases&lt;/em&gt;.</source>
          <target state="translated">您可以在客户端代码中执行此操作，以在&lt;em&gt;某些情况下&lt;/em&gt;防止CORS错误。</target>
        </trans-unit>
        <trans-unit id="dd387cc7c0ddfa81e8a73fd3ad8eec157d2b5a85" translate="yes" xml:space="preserve">
          <source>This is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;Same Origin Policy&lt;/a&gt;. It is a security feature implemented by browsers.</source>
          <target state="translated">这是&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;同源政策&amp;rdquo;&lt;/a&gt; 。 它是浏览器实现的安全功能。</target>
        </trans-unit>
        <trans-unit id="f228285fd4ea1c4455057da91df16018363da6ef" translate="yes" xml:space="preserve">
          <source>This would be fine since that is just between Mallory and Bob. There is no way for Bob to think that Mallory is Alice and to provide Mallory with data that should be kept confidential between Alice and Bob.</source>
          <target state="translated">这样就可以了,因为那只是马洛里和鲍勃之间的事。鲍勃不可能认为马洛里是爱丽丝,也不可能认为马洛里是爱丽丝,也不可能给马洛里提供应该在爱丽丝和鲍勃之间保密的数据。</target>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="2e622d7f6639260890f80f2a6685c393b5403a2f" translate="yes" xml:space="preserve">
          <source>To fix this, if you have access to the other domain, you will have to allow Access-Control-Allow-Origin in the server. This can be added in the headers. You can enable this for all the requests/domains or a specific domain.</source>
          <target state="translated">为了解决这个问题,如果你有访问其他域的权限,你必须在服务器中允许Access-Control-Allow-Origin。这可以在头文件中添加。你可以为所有请求域或特定域启用这个功能。</target>
        </trans-unit>
        <trans-unit id="6f655decc8eac3fe6c8bc774d35ee8140515efbb" translate="yes" xml:space="preserve">
          <source>What is stopping me from accessing the page?</source>
          <target state="translated">是什么阻碍了我访问该页面?</target>
        </trans-unit>
        <trans-unit id="c222285e4f0dfcb26c7d734bf432abc2efc0b6a4" translate="yes" xml:space="preserve">
          <source>Why the Same Origin Policy applies when you don't think it should</source>
          <target state="translated">为什么在你认为不应该适用同源政策的情况下,却适用同源政策?</target>
        </trans-unit>
        <trans-unit id="68b8e4a4bfccfe90f892af4970ab015d6f70ef95" translate="yes" xml:space="preserve">
          <source>Why the Same Origin Policy only applies to JavaScript in a web page</source>
          <target state="translated">为什么同源政策只适用于网页中的JavaScript?</target>
        </trans-unit>
        <trans-unit id="abbe2bbe571390ca47e7527f04f9f823e204410f" translate="yes" xml:space="preserve">
          <source>Why you can display data in the page without reading it with JS</source>
          <target state="translated">为什么用JS可以在页面中显示数据而不需要读取数据</target>
        </trans-unit>
        <trans-unit id="383dc6735c76bbfea9b61fc8d3bbc5bbdaf87eee" translate="yes" xml:space="preserve">
          <source>Writing something other than a web app</source>
          <target state="translated">编写非网络应用以外的东西</target>
        </trans-unit>
        <trans-unit id="71bad54d58acd5cde3dc0f122a888a11d325d05a" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest cannot load &lt;a href=&quot;https://www.example.com/&quot;&gt;https://www.example.com/&lt;/a&gt;
      No 'Access-Control-Allow-Origin' header is present on the requested 
      resource. Origin '&lt;a href=&quot;http://localhost:4300&quot;&gt;http://localhost:4300&lt;/a&gt;' is therefore not allowed access.</source>
          <target state="translated">XMLHttpRequest无法加载&lt;a href=&quot;https://www.example.com/&quot;&gt;https://www.example.com/&lt;/a&gt;所请求的资源上没有'Access-Control-Allow-Origin'标头。 因此，不允许访问源' &lt;a href=&quot;http://localhost:4300&quot;&gt;http：// localhost：4300&lt;/a&gt; '。</target>
        </trans-unit>
        <trans-unit id="7d4c0874dabc4851005a3af251a7dd41b17c2b76" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header</source>
          <target state="translated">XMLHttpRequest无法加载XXX 没有'Access-Control-Allow-Origin'头。</target>
        </trans-unit>
        <trans-unit id="84032e9155256a63c2c317d1a432e1392ae2ffde" translate="yes" xml:space="preserve">
          <source>You can make use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&quot;&gt;Simple Requests&lt;/a&gt;.</source>
          <target state="translated">您可以使用&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&quot;&gt;简单请求&amp;rdquo;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="565919979d1b220118880d7347d1698f1fb11c07" translate="yes" xml:space="preserve">
          <source>You should enable CORS to get it working.</source>
          <target state="translated">你应该启用CORS来让它工作。</target>
        </trans-unit>
        <trans-unit id="39ab42da37e2b09b25f5e11e8fbf631b5baa0ed2" translate="yes" xml:space="preserve">
          <source>Your particular case is showing how it is implemented for XMLHttpRequest (and you'll get identical results if you were to use fetch), but it also applies to other things (such as images loaded onto a &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; or documents loaded into an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;), just with slightly different implementations.</source>
          <target state="translated">您的特殊情况显示了如何为XMLHttpRequest实现它（如果使用fetch，您将获得相同的结果），但是它也适用于其他情况（例如，将图像加载到 &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; 或文档加载到 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; ），只是实现方式略有不同。</target>
        </trans-unit>
        <trans-unit id="9b958ab959f694798d92a468527ac46f2f64cf4b" translate="yes" xml:space="preserve">
          <source>add CORS headers</source>
          <target state="translated">加CORS头</target>
        </trans-unit>
        <trans-unit id="fbbf1bdb4343897dcae9384602598bf7e27d95fa" translate="yes" xml:space="preserve">
          <source>convert the response to JSONP</source>
          <target state="translated">转换为JSONP</target>
        </trans-unit>
        <trans-unit id="4d45714443791a616cc27fecf90f9f0854b14322" translate="yes" xml:space="preserve">
          <source>exist on the same origin as the HTML document</source>
          <target state="translated">与HTML文档同源</target>
        </trans-unit>
        <trans-unit id="64979ef625f468550475be52a9f9eba4cb697b50" translate="yes" xml:space="preserve">
          <source>tl;dr &amp;mdash;&amp;nbsp;There's a summary at the end and headings in the answer to make it easier to find the relevant parts. Reading everything is recommended though as it provides useful background for understanding the &lt;strong&gt;why&lt;/strong&gt; that makes seeing how the &lt;strong&gt;how&lt;/strong&gt; applies in different circumstances easier.</source>
          <target state="translated">tl; dr &amp;mdash;答案的末尾有一个摘要，以便于查找相关部分。 建议您阅读所有内容，因为它提供了有用的背景知识，可帮助您理解&lt;strong&gt;为什么&lt;/strong&gt;这样做的&lt;strong&gt;原因&lt;/strong&gt; ，从而使您更容易&lt;strong&gt;了解如何&lt;/strong&gt;在不同情况下应用。</target>
        </trans-unit>
        <trans-unit id="798d6f2be2e1e1f95e0abe2c366b9282b7d0b9fc" translate="yes" xml:space="preserve">
          <source>tl;dr; About the Same Origin Policy</source>
          <target state="translated">Tl;dr;关于同源政策</target>
        </trans-unit>
        <trans-unit id="e4288b0b274bc0ac97897c68b14dc2b0d1554ea7" translate="yes" xml:space="preserve">
          <source>trying to put &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; and other CORS response headers on the request. These don't belong on the request, don't do anything helpful (what would be the point of a permissions system where you could grant yourself permission?), and must appear only on the response.</source>
          <target state="translated">尝试将 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 和其他CORS响应标头放在请求上。 这些不属于请求，对您没有任何帮助（在权限系统中您可以授予自己权限的意义是什么？），并且必须仅出现在响应中。</target>
        </trans-unit>
        <trans-unit id="1fa6839e05c6436308f1e8f17d2a6574bb48bf8d" translate="yes" xml:space="preserve">
          <source>trying to put a &lt;code&gt;Content-Type: application/json&lt;/code&gt; header on a GET request that has no request body to describe the content of (typically when the author confuses &lt;code&gt;Content-Type&lt;/code&gt; and &lt;code&gt;Accept&lt;/code&gt;).</source>
          <target state="translated">尝试在没有请求正文的GET请求上放置 &lt;code&gt;Content-Type: application/json&lt;/code&gt; 标头（通常在作者混淆 &lt;code&gt;Content-Type&lt;/code&gt; 和 &lt;code&gt;Accept&lt;/code&gt; 时 ）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
