<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/359494">
    <body>
      <group id="359494">
        <trans-unit id="130bf5785915eb04e8a94d3a41ec118bd8e8f0d8" translate="yes" xml:space="preserve">
          <source>&quot;Use three equals unless you fully understand the conversions that take
  place for two-equals.&quot;</source>
          <target state="translated">&quot;두 같음에 대해 발생하는 전환을 완전히 이해하지 않는 한 세 가지 같음을 사용하십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="54f697a1ff421e46f37022813a88d0937a82090c" translate="yes" xml:space="preserve">
          <source>&amp;amp;</source>
          <target state="translated">&amp;amp;</target>
        </trans-unit>
        <trans-unit id="dea7f7f48b6202dbcdd6e2f0b470c1320197a1b3" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;1. If Type(x) is different from Type(y), return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">1. Type (x)가 Type (y)와 다른 경우 &lt;strong&gt;false를&lt;/strong&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="128316503370069a1f99b4764d5a503e65225aa7" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;10. Return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">10. &lt;strong&gt;false를&lt;/strong&gt; 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9f94476563997f8d2da2e6fdfb6b36c68ec81051" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;11. If Type(x) is String, then return &lt;strong&gt;true&lt;/strong&gt; if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">11. Type (x)가 String이면 x와 y가 정확히 동일한 문자 시퀀스 (해당 위치의 동일한 길이와 동일한 문자) &lt;strong&gt;이면 true&lt;/strong&gt; 를 반환 &lt;strong&gt;합니다&lt;/strong&gt; . 그렇지 않으면 &lt;strong&gt;false를&lt;/strong&gt; 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="4c30077433d472cb40022cd05bbb7b0fce6d9add" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;12. If Type(x) is Boolean, return &lt;strong&gt;true&lt;/strong&gt; if x and y are both &lt;strong&gt;true&lt;/strong&gt; or both &lt;strong&gt;false&lt;/strong&gt;; otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">12. Type (x)가 부울 인 경우 x와 y가 모두 &lt;strong&gt;true&lt;/strong&gt; 이거나 모두 &lt;strong&gt;false&lt;/strong&gt; &lt;strong&gt;이면 true를&lt;/strong&gt; 반환 &lt;strong&gt;합니다&lt;/strong&gt; . 그렇지 않으면 &lt;strong&gt;false를&lt;/strong&gt; 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="25f36acdf60e7d6a4df37ffedc98b9f14faf995c" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;13. Return &lt;strong&gt;true&lt;/strong&gt; if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">13. x와 y가 같은 객체를 참조하거나 서로 연결된 객체를 참조하면 &lt;strong&gt;true를&lt;/strong&gt; 반환 &lt;strong&gt;합니다&lt;/strong&gt; (13.1.2 참조). 그렇지 않으면 &lt;strong&gt;false를&lt;/strong&gt; 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="6754f28eced479b11eb44690f5d4fa3822beda44" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;2. If Type(x) is Undefined, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">2. Type (x)가 Undefined &lt;strong&gt;이면 true를&lt;/strong&gt; 반환 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a41404dc0e9e4b2139c7b55b00ba4f197ed1db" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;3. If Type(x) is Null, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">3. Type (x)가 Null &lt;strong&gt;이면 true를&lt;/strong&gt; 반환 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="86e81311d208ba00e8a82f89a4b6f670518af9c9" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;4. If Type(x) is not Number, go to step 11.</source>
          <target state="translated">4. Type (x)가 숫자가 아니면 11 단계로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="1d11aa4bb7dc1bb6eb30029e881efcb0c773c688" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;5. If x is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">5. x가 &lt;strong&gt;NaN&lt;/strong&gt; 인 경우 &lt;strong&gt;false를&lt;/strong&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6feedc887138d0c4493e0285c20861d70ce82b0" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;6. If y is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">y가 &lt;strong&gt;NaN&lt;/strong&gt; 인 경우 &lt;strong&gt;false를&lt;/strong&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b305a8dce9f7df97f238519197a73606b9ab87f2" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;7. If x is the same number value as y, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">7. x가 y와 같은 숫자 값 &lt;strong&gt;이면 true를&lt;/strong&gt; 반환 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b42c345a414ab1fe5a4c613c47711966027975a5" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;8. If x is +0 and y is &amp;minus;0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">8. x가 +0이고 y가 &amp;minus;0 &lt;strong&gt;이면 true를&lt;/strong&gt; 반환 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e941ba4b0fdf4fcc001e64d6bd9bd26d6a81fd02" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;9. If x is &amp;minus;0 and y is +0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">9. x가 -0이고 y가 +0 &lt;strong&gt;이면 true를&lt;/strong&gt; 반환 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="03520e1e34120f6fae6bbeb3d5eb895994c709d3" translate="yes" xml:space="preserve">
          <source>** STRANGE: note that any two values on the first column are not equal in that sense.**</source>
          <target state="translated">** STRANGE : 첫 번째 열의 두 값은 그런 의미에서 동일하지 않습니다. **</target>
        </trans-unit>
        <trans-unit id="bfadb6bfe229d17ab6eb814049a1af7e1c35942f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality and type comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;평등 및 유형 비교 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4311a70549d246e170e5a8f1b527e5c5a19379f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;평등 비교 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1ab346462c9fcef1a02b67c403e451e31987880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does a &lt;strong&gt;&lt;em&gt;whole bunch of other stuff&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; &lt;strong&gt;&lt;em&gt;다른 많은 것들을 수행&lt;/em&gt;&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1b338ff3f560901a0f7f2338cb21ec9ed418bce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;with&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 는 &lt;code&gt;type conversion&lt;/code&gt; 사용 &lt;strong&gt;하는&lt;/strong&gt; 피연산자 간의 &lt;strong&gt;비교&lt;/strong&gt; 를 의미합니다</target>
        </trans-unit>
        <trans-unit id="e9d647aeb173e83a0130624d9b11d9a6aca4c3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; operator just checks the value of the variables for equality.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 연산자는 변수의 값이 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="86a40c35943be312d26be58ed590bcd3dd325425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; Returns &lt;code&gt;true&lt;/code&gt; if the operands are strictly equal (see above)
  with no type conversion.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 피연산자가 형식 변환없이 엄격하게 같으면 (위 참조) &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="9d0976f976a35ebb6ebe62b08679b2e138576dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;without&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; &lt;code&gt;type conversion&lt;/code&gt; &lt;strong&gt;없이&lt;/strong&gt; 피연산자 간의 &lt;strong&gt;비교&lt;/strong&gt; 를 의미</target>
        </trans-unit>
        <trans-unit id="54e23978f1caf3d9c1511fb347612a2b3442e552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator  checks the values as well as the types of the variables for equality.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 연산자는 변수의 유형뿐만 아니라 값이 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0784b02b5003c7729e030d9b7d490e95bab806f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator in javascript &lt;strong&gt;checks value as well as type&lt;/strong&gt; where as &lt;code&gt;==&lt;/code&gt; operator just checks &lt;strong&gt;the value (does type conversion if required)&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 자바 스크립트의 연산자 &lt;strong&gt;는 값뿐만 아니라 형식도&lt;/strong&gt; 검사 &lt;strong&gt;합니다.&lt;/strong&gt; &lt;code&gt;==&lt;/code&gt; 연산자 &lt;strong&gt;는 값을&lt;/strong&gt; 확인 &lt;strong&gt;합니다 (필요한 경우 형식 변환 수행)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e191a0a45be586c4c0bba711c1f56571fe4d8f4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both strings and contain the exact same characters</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 모두 문자열이고 정확히 동일한 문자를 포함하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c03f97f96e2f5f2837a1f086b8eb03c59b00a165" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same value and are of the same type</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; 값이 같고 유형이 같은 경우 a === b 는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b9afde54d1a9e309f7f55b08fcee09754103a72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reference the exact same object</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 정확히 같은 객체를 참조하면 true를 반환</target>
        </trans-unit>
        <trans-unit id="a569658b84c50eebdb4a105bf59c6e932a3a246e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;The equal comparison operator == is confusing and should be avoided.&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;등호 비교 연산자 ==는 혼동되므로 피해야합니다.&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e7e53458508d6e51aeb7d6a48cf2891cadddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.2.2 The new Operator&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;11.2.2 새로운 연산자&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="7998aff2909b6b4706d92805f6351ca4f05e7bf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.9.6 The Strict Equality Comparison Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;11.9.6 엄격한 평등 비교 알고리즘&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6991c2660c1bca00359ab71ad6adcfdf32c7a356" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For reference types:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;참조 유형 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b281c590fb85b87b5d11f1a04a3b17b4b081d21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For strings:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;문자열의 경우 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a449c178aebbeb356e9012aeb4b469de6ac6e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For value types (numbers):&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;값 유형 (숫자)의 경우 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f73c5c4818316a7e7ba83421501c2687aba89eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;If in doubt, read the &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;specification&lt;/a&gt;!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;확실하지 않은 경우 &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;사양을&lt;/a&gt; 읽으십시오!&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b1bf8ddd0de3be690c43c624391f8937688d9e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Moral of the story:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;이야기의 교훈:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83c7151c0c6f7fb762f855eb85e50c829ea14a0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Use &lt;code&gt;===&lt;/code&gt; unless you fully understand the
  conversions that take place with &lt;code&gt;==&lt;/code&gt;.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;==&lt;/code&gt; 로 발생하는 변환을 완전히 이해하지 않으면 &lt;code&gt;===&lt;/code&gt; 를 사용하십시오.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef127aa6ac9121f82176c29f76864dbb36fe4c2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;==&lt;/code&gt; for JavaScript equality testing, some
  funky conversions take place.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;JavaScript 동등성 테스트에 &lt;code&gt;==&lt;/code&gt; 를 사용하면 몇 가지 펑키 변환이 발생합니다.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77298b36a9fcbaf746d98e1bc74886ea8bbddcff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;===&lt;/code&gt; for JavaScript equality testing, everything is as is. Nothing gets converted before being evaluated.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;JavaScript 동등성 테스트에 &lt;code&gt;===&lt;/code&gt; 를 사용하면 모든 것이 그대로입니다.&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;평가하기 전에 아무것도 변환되지 않습니다.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5583d977f70290bf3ad57016e11eed7fe1b944f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of doubt, learn by heart the following truth table:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;의심이가는 경우 다음 진리표를 가슴에 새기십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4e32406ca5087fb220aee87a9159a70a2cf49c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In summary&lt;/strong&gt;; using the &lt;strong&gt;==&lt;/strong&gt; operator might evaluate to true in situations where you do not want it to so using the &lt;strong&gt;===&lt;/strong&gt; operator would be safer.</source>
          <target state="translated">&lt;strong&gt;요약하면&lt;/strong&gt; ; 원하지 않는 상황에서 &lt;strong&gt;==&lt;/strong&gt; 연산자를 사용하면 true로 평가되므로 &lt;strong&gt;===&lt;/strong&gt; 연산자를 사용하는 것이 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0fc148d6649bd47fe8e2b7cf2467f19d0bf69fd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not transitive: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(b == c)&lt;/em&gt; does not lead to &lt;em&gt;(a == c)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전 이적이지 않습니다 : &lt;em&gt;(a == b)&lt;/em&gt; 및 &lt;em&gt;(b == c)&lt;/em&gt; 는 &lt;em&gt;(a == c)&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b0a31f565c1a8710eee82d40a2198e9e2ade2a15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's mutually exclusive to its negation: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(a != b)&lt;/em&gt; always hold opposite Boolean values, with all a and b.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;(a == b)&lt;/em&gt; 및 &lt;em&gt;(a! = b)는&lt;/em&gt; 항상 a와 b를 사용하여 반대 부울 값을 보유합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2a6eb120ac5d954b7aa47baca4f35f487d47fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e15c6bff6033a446fc6a95bbcaedcb5920c62e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So the moral of the story is...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이야기의 교훈은 ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f68664c3d5e1f0872cc0f7095d28293c50692b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what does this mean?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것이 무엇을 의미합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcffb768a62952b163df247d1df132d1d92ba1ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source: &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http://dorey.github.io/JavaScript-Equality-Table/&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;출처 : &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http://dorey.github.io/JavaScript-Equality-Table/&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3572e23516a3bbfc97277c54e9df478818214273" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Then weirder with strings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그런 다음 줄이 이상해&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4799deaf7c2bdd75e811e68dfa65cd85a9318390" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Things get really weird with arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;배열은 정말 이상합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c6910a7c92878ee22dbd03dfb0a4072532d90db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When is equal not equal?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;언제 같지 않습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8eb43dbcbcd365843d41af200d644bb6817377de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why &lt;code&gt;==&lt;/code&gt; is so unpredictable?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;왜 &lt;code&gt;==&lt;/code&gt; 를 예측할 수 없습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="158e452fe7b5ed683ae60f76da327fa38cec4251" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why does this happen?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;왜 이런 일이 발생합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3471db61bc9f6d45c5cdde69581a956986a6defd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes!&lt;/strong&gt; It does matter.</source>
          <target state="translated">&lt;strong&gt;예!&lt;/strong&gt; 그것은 문제가된다.</target>
        </trans-unit>
        <trans-unit id="72675d0e476a995d0975566582a364150fca52f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;new&lt;/strong&gt; always returns an Object, even for &lt;strong&gt;String&lt;/strong&gt; constructors, too. And alas! The value semantics for strings (see step 11) is lost.</source>
          <target state="translated">&lt;strong&gt;new는&lt;/strong&gt; 항상 &lt;strong&gt;String&lt;/strong&gt; 생성자에 대해서도 Object를 반환합니다. 그리고 아아! 문자열의 값 의미 (11 단계 참조)가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="b7f0cbff18eeec5852f5ea8c1be766cd8cf6a45d" translate="yes" xml:space="preserve">
          <source>A good point was brought up by &lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt; in the comments and in &lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;@Phillipe Laybaert's&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/957602/1288&quot;&gt;answer&lt;/a&gt; concerning reference types.  For reference types &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; act consistently with one another (except in a special case).</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt; 는 주석과 참조 유형에 관한 &lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;@Phillipe Laybaert의&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/957602/1288&quot;&gt;답변&lt;/a&gt; 에서 @Casebash 가 제기했습니다. 참조 유형의 경우 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;===&lt;/code&gt; 서로 일관되게 작동합니다 (특별한 경우 제외).</target>
        </trans-unit>
        <trans-unit id="8b54302e5ddc3ab8451d73b4e6fbcce29f1fb9c2" translate="yes" xml:space="preserve">
          <source>A simple example is</source>
          <target state="translated">간단한 예는</target>
        </trans-unit>
        <trans-unit id="4e666e628adc9d3ae32638bd884bee95473bd54e" translate="yes" xml:space="preserve">
          <source>Aidiakapi wrote this in a comment below:</source>
          <target state="translated">Aidiakapi는 아래의 주석에서 이것을 썼습니다 :</target>
        </trans-unit>
        <trans-unit id="a54a3ffda19eea85fbc25119ad4dce8fb1e843e4" translate="yes" xml:space="preserve">
          <source>All returns true and you may not want this. Let's suppose you have a function that can return the 0th index of an array or false on failure. If you check with &quot;==&quot; false, you can get a confusing result.</source>
          <target state="translated">모두 true를 반환하며이를 원하지 않을 수 있습니다. 배열의 0 번째 인덱스를 반환하거나 실패시 false를 반환 할 수있는 함수가 있다고 가정합니다. &quot;==&quot;false로 확인하면 혼란스러운 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8742264e60f01ff6e597018b6c9b30ad6c84fa0b" translate="yes" xml:space="preserve">
          <source>An interesting pictorial representation of the equality comparison between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 과 &lt;code&gt;===&lt;/code&gt; 의 등가 비교에 대한 흥미로운 그림 표현.</target>
        </trans-unit>
        <trans-unit id="8c1a994f0cb44644f821ea4b44798e564cbb1e78" translate="yes" xml:space="preserve">
          <source>And it doesn't end there, here's another one:</source>
          <target state="translated">그리고 거기서 끝나지 않습니다. 여기 또 다른 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcab40bf0cf2cc434eb0ce086ee4dfadcbc91121" translate="yes" xml:space="preserve">
          <source>And this finally means: &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">그리고 이것은 마지막으로 다음을 의미합니다 : &lt;strong&gt;new String ( &quot;a&quot;)! == &quot;a&quot;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c997d053fe7d55a1f5eb3f9358b3b7760fec29e8" translate="yes" xml:space="preserve">
          <source>And this is just the crazy stuff you get with primitives.</source>
          <target state="translated">그리고 이것은 당신이 프리미티브로 얻는 미친 것들입니다.</target>
        </trans-unit>
        <trans-unit id="9353a89820dfa87107beffc7a1a273e498311936" translate="yes" xml:space="preserve">
          <source>Another common example:</source>
          <target state="translated">또 다른 일반적인 예 :</target>
        </trans-unit>
        <trans-unit id="bb0313b7b5d894d38b25b3429130ff71d7450726" translate="yes" xml:space="preserve">
          <source>Any performance improvement would be welcomed as many comparison operators exist.</source>
          <target state="translated">많은 비교 연산자가 존재하므로 성능 향상을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="ebdf4e9004e5ae311bc10c04cc1657d844cc2b1e" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, I would generally use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (and &lt;code&gt;!==&lt;/code&gt; instead of &lt;code&gt;!=&lt;/code&gt;).</source>
          <target state="translated">경험상, 나는 일반적으로 &lt;code&gt;!==&lt;/code&gt; 대신 &lt;code&gt;==&lt;/code&gt; = (및 ! = 대신 ! == )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="13b3f53e194e780033d076d6dfdef27478b25e97" translate="yes" xml:space="preserve">
          <source>As the conclusion states:</source>
          <target state="translated">결론은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c8f8302c2c50753cc3fc038d29edd38e7d27241" translate="yes" xml:space="preserve">
          <source>At this point your probably wondering...</source>
          <target state="translated">이 시점에서 아마도 궁금 할 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="78a365d1c42cbfa956f22145534e940bf6aa204f" translate="yes" xml:space="preserve">
          <source>Because it's complicated it's hard to know what's going to happen when you use it.</source>
          <target state="translated">복잡하기 때문에 사용할 때 어떤 일이 일어날 지 알기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="6d67a31310a8174d28abedb216692a809603aaa3" translate="yes" xml:space="preserve">
          <source>But how about this?:</source>
          <target state="translated">그러나 이것은 어떻습니까? :</target>
        </trans-unit>
        <trans-unit id="c0360df7ca51ade50469aaf2a05a01615c88e9dd" translate="yes" xml:space="preserve">
          <source>But personally I would do what JSLint suggests. This recommendation is there not because of performance issues, but because type coercion means &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; is true.</source>
          <target state="translated">그러나 개인적으로 JSLint가 제안한대로 할 것입니다. 이 권장 사항은 성능 문제 때문이 아니라 강제 변환 유형 &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; 이 참이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fbdab286eda606977bf3a9c58a18c188200a37c4" translate="yes" xml:space="preserve">
          <source>Common example:</source>
          <target state="translated">일반적인 예 :</target>
        </trans-unit>
        <trans-unit id="f64d819276a8e60d2cf4282031ed91641ea77411" translate="yes" xml:space="preserve">
          <source>ECMA-262 is the specification for a scripting language of which JavaScript is a dialect. Of course in practice it matters more how the most important browsers behave than an esoteric definition of how something is supposed to be handled. But it is helpful to understand why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">ECMA-262는 JavaScript가 방언 인 스크립팅 언어의 사양입니다. 물론 실제로 가장 중요한 브라우저가 어떻게 처리되어야하는지에 대한 난해한 정의보다 더 중요합니다. 그러나 &lt;strong&gt;new String ( &quot;a&quot;)! == &quot;a&quot;인&lt;/strong&gt; 이유를 이해하면 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dd5ffe9d4172fd93e2644ec55bff755f2376bde5" translate="yes" xml:space="preserve">
          <source>EQUAL OPERATOR TRUTH TABLE IN JAVASCRIPT</source>
          <target state="translated">JAVASCRIPT의 등가 조작자 트러스트 테이블</target>
        </trans-unit>
        <trans-unit id="c0cc6f9b7554c74df1b7cae7c6ef1f64783063e0" translate="yes" xml:space="preserve">
          <source>Each row in the table is a set of 3 mutually &quot;equal&quot; values, meaning that any 2 values among them are equal using the equal == sign*</source>
          <target state="translated">표의 각 행은 서로 &quot;동일한&quot;3 개의 값 집합으로, 그 중 2 개의 값은 등호 == 부호 *를 사용하여 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58b2ed100a4c02f3e223f19e77f4fc970f37bc3e" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&quot;a == b&quot;&lt;/strong&gt; to evaluate to true a and b need to be the &lt;strong&gt;same value&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&quot;a == b&quot;의&lt;/strong&gt; 경우 true로 평가하려면 a와 b는 &lt;strong&gt;동일한 값&lt;/strong&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="38827ea4d22912a8579010ad9d43caaae3a33e79" translate="yes" xml:space="preserve">
          <source>For example jQuery 1.9.1 uses this pattern 43 times, and  the &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;JSHint syntax checker&lt;/a&gt; even provides the &lt;code&gt;eqnull&lt;/code&gt; relaxing option for this reason.</source>
          <target state="translated">예를 들어 jQuery 1.9.1은이 패턴을 43 번 사용하고 &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;JSHint 구문 검사기&lt;/a&gt; 는 이러한 이유로 &lt;code&gt;eqnull&lt;/code&gt; 이완 옵션도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="3b5af0e25b6d033fced42a264a3e0862e363a6cc" translate="yes" xml:space="preserve">
          <source>For example, if you have:</source>
          <target state="translated">예를 들어 다음과 같은 경우</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93d53aae8f4cbac1a7160cd657ddf2e114550792" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;jQuery style guide&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;jQuery 스타일 가이드에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="519a4ac6eaa68eb2f5a55813ad6c7b39e2e3c9a5" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;core javascript reference&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;핵심 자바 스크립트 참조에서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33d6d15bce91547d5c6e839acec0e386194d3e54" translate="yes" xml:space="preserve">
          <source>From the specification</source>
          <target state="translated">사양에서</target>
        </trans-unit>
        <trans-unit id="078ecfcf86b689086aece409c4dd9d3597272bc8" translate="yes" xml:space="preserve">
          <source>Google for implicit conversions in C++ and &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; to get some of the arguments against it...</source>
          <target state="translated">C ++ 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; 에서 암시 적 변환을위한 Google은 이에 대한 몇 가지 주장을 얻었습니다 ...</target>
        </trans-unit>
        <trans-unit id="5532825dcc419a2c608b4660ff4df27ee7b64e3b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; do not have values. Whereas, 0, false and '' are all values. One thing common beween all these are that they are all falsy values, which means they all &lt;strong&gt;satisfy&lt;/strong&gt; falsy conditions.</source>
          <target state="translated">여기서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 에는 값이 없습니다. 반면에 0, false 및 ''는 모두 값입니다. 이 모든 것 사이에서 공통적 인 한 가지는 값이 모두 잘못된 값이라는 것입니다. 즉, 모두 잘못된 조건을 &lt;strong&gt;만족&lt;/strong&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4f47052c940a268ebe245314f782cc99b18f0d6e" translate="yes" xml:space="preserve">
          <source>Here is a handy comparison table that shows the conversions that happen and the differences between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">다음은 발생하는 변환과 &lt;code&gt;==&lt;/code&gt; 과 &lt;code&gt;===&lt;/code&gt; 의 차이점을 보여주는 편리한 비교표입니다.</target>
        </trans-unit>
        <trans-unit id="2e780233b6b8ef08d4cfd3eb493ce561f782434f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;==&lt;/code&gt; operator is checking the values of the two objects and returning &lt;code&gt;true&lt;/code&gt;, but the &lt;code&gt;===&lt;/code&gt; is seeing that they're not the same type and returning &lt;code&gt;false&lt;/code&gt;.  Which one is correct?  That really depends on what you're trying to compare.  My advice is to bypass the question entirely and just don't use the &lt;code&gt;String&lt;/code&gt; constructor to create string objects.</source>
          <target state="translated">여기서 &lt;code&gt;==&lt;/code&gt; 연산자는 두 객체의 값을 확인하고 &lt;code&gt;true&lt;/code&gt; 를 반환하지만 &lt;code&gt;===&lt;/code&gt; 는 동일한 유형이 아니며 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. 어느 것이 맞습니까? 그것은 실제로 비교하려는 것에 달려 있습니다. 내 조언은 질문을 완전히 무시하고 &lt;code&gt;String&lt;/code&gt; 생성자를 사용하여 문자열 객체를 만드는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7108ec5478e370309fc5357c0e971bd4f05bbf90" translate="yes" xml:space="preserve">
          <source>However there is &lt;strong&gt;one single exception&lt;/strong&gt;:
&lt;code&gt;== null&lt;/code&gt; is an efficient way to check for 'is null or undefined':</source>
          <target state="translated">그러나 &lt;strong&gt;하나의 예외가 있습니다&lt;/strong&gt; : &lt;code&gt;== null&lt;/code&gt; 은 'is null or undefined'를 확인하는 효율적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f0d30f93bb4df391284d009844ff1535f26f2082" translate="yes" xml:space="preserve">
          <source>I tested this in Firefox with &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; using code like this:</source>
          <target state="translated">다음과 같은 코드를 사용하여 Firefox에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug로&lt;/a&gt; 이것을 테스트했습니다.</target>
        </trans-unit>
        <trans-unit id="7b1c18acfb2da322223032a6ca65bcb729f0ddd1" translate="yes" xml:space="preserve">
          <source>I thought strings behave like value types? Well, it depends who you ask... In this case a and b are not the same type. &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;Object&lt;/code&gt;, while &lt;code&gt;b&lt;/code&gt; is of type &lt;code&gt;string&lt;/code&gt;. Just remember that creating a string object using the &lt;code&gt;String&lt;/code&gt; constructor creates something of type &lt;code&gt;Object&lt;/code&gt; that behaves as a string &lt;em&gt;most of the time&lt;/em&gt;.</source>
          <target state="translated">문자열이 값 유형처럼 동작한다고 생각 했습니까? 글쎄, 그것은 당신이 묻는 사람에 달려 있습니다 ...이 경우 a와 b는 같은 유형이 아닙니다. &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;Object&lt;/code&gt; 유형이고 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;string&lt;/code&gt; 유형입니다. &lt;code&gt;String&lt;/code&gt; 생성자를 사용하여 문자열 객체를 만들면 &lt;em&gt;대부분&lt;/em&gt; 문자열처럼 동작하는 &lt;code&gt;Object&lt;/code&gt; 유형의 무언가가 생성 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6724c10b1c4dd89e994b59c7b65ce998cb53f9b0" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;JSLint&lt;/a&gt; to go through JavaScript, and it's returning many suggestions to replace &lt;code&gt;==&lt;/code&gt; (two equals signs) with &lt;code&gt;===&lt;/code&gt; (three equals signs) when doing things like comparing &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; inside of an &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;JSLint&lt;/a&gt; 를 사용하여 JavaScript를 사용하고 있으며 &lt;code&gt;if&lt;/code&gt; 내부에서 &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; 비교와 같은 작업을 수행 할 때 &lt;code&gt;==&lt;/code&gt; (두 등호)를 &lt;code&gt;===&lt;/code&gt; (세 등호)로 대체하는 많은 제안을 반환 합니다. 성명서.</target>
        </trans-unit>
        <trans-unit id="699383a3720b89c508893f13174fcc345a333a00" translate="yes" xml:space="preserve">
          <source>If Type(constructor) is not Object, throw a TypeError exception.</source>
          <target state="translated">Type (constructor)이 Object가 아닌 경우 TypeError 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="7c1b47bf6a1abbf554dbd0ee2168db0b303f1c1f" translate="yes" xml:space="preserve">
          <source>If both operands of == are objects, then they are compared to see if they are the same object. If both operands point to the same object, then the equal operator returns true. Otherwise,
the two are not equal.</source>
          <target state="translated">==의 두 피연산자가 모두 객체이면 동일한 객체인지 확인하기 위해 비교됩니다. 두 피연산자가 모두 동일한 객체를 가리키는 경우 등호 연산자는 true를 반환합니다. 그렇지 않으면 둘이 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbb1a99493847058458e46837af0fc9a5702b63e" translate="yes" xml:space="preserve">
          <source>If no type conversion takes place, would there be a performance gain over &lt;code&gt;==&lt;/code&gt;?</source>
          <target state="translated">유형 변환이 수행되지 않으면 &lt;code&gt;==&lt;/code&gt; 보다 성능이 향상됩니까?</target>
        </trans-unit>
        <trans-unit id="e27332524b113dae22c09288bee3e0f34778ca3c" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;HAVE TO&lt;/strong&gt; live with it, then remember the following 3 things:</source>
          <target state="translated">함께 살아야한다면 다음 3 가지를 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="ba83b649d7ac77ee88b91662e9dc19d8d2569046" translate="yes" xml:space="preserve">
          <source>If you wonder why &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; does not return a string, how about some exercise reading a specification? Have fun!</source>
          <target state="translated">&lt;strong&gt;new String ( &quot;a&quot;)&lt;/strong&gt; 이 문자열을 반환하지 않는 이유가 궁금하다면, 사양을 읽는 연습은 어떻습니까? 즐기세요!</target>
        </trans-unit>
        <trans-unit id="318588db3ab6c1c4c50c1ae4dd7cb47bf8189bab" translate="yes" xml:space="preserve">
          <source>In JavaScript it means of the same value and type.</source>
          <target state="translated">JavaScript에서는 동일한 값과 유형을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4bbc85798100e8a6c2b8173b4c4cc5ff26f86121" translate="yes" xml:space="preserve">
          <source>In PHP and JavaScript, it is a strict equality operator. Which means, it will compare both type and values.</source>
          <target state="translated">PHP와 JavaScript에서 엄격한 항등 연산자입니다. 즉, 유형과 값을 모두 비교합니다.</target>
        </trans-unit>
        <trans-unit id="0fd01d3c121d1dd02e0aad7a9a25393961f9968a" translate="yes" xml:space="preserve">
          <source>In a typical script there will be no performance difference. More important may be the fact that thousand &quot;===&quot; is 1&amp;nbsp;KB heavier than thousand &quot;==&quot; :) &lt;a href=&quot;https://stackoverflow.com/questions/tagged/javascript+performance&quot;&gt;JavaScript profilers&lt;/a&gt; can tell you if there is a performance difference in your case.</source>
          <target state="translated">일반적인 스크립트에서는 성능 차이가 없습니다. 더 중요한 것은 천 &quot;===&quot;이 천 &quot;&quot;보다 1KB 무겁다는 것입니다. &quot;==&quot;:) &lt;a href=&quot;https://stackoverflow.com/questions/tagged/javascript+performance&quot;&gt;JavaScript 프로파일 러&lt;/a&gt; 는 귀하의 경우에 성능 차이가 있는지 알려줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e42d567a09b4ba932e88964ee9b8587449c04d9" translate="yes" xml:space="preserve">
          <source>In fact, if you tried to write a function that does what &lt;code&gt;==&lt;/code&gt; does it would look something like this:</source>
          <target state="translated">실제로, &lt;code&gt;==&lt;/code&gt; 기능을 수행하는 함수를 작성하려고하면 다음과 같이 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="48c572d57b17fbc593b6830a7381e7378807a00f" translate="yes" xml:space="preserve">
          <source>In the 90% usage scenario it won't matter which one you use, but it is handy to know the difference when you get some unexpected behaviour one day.</source>
          <target state="translated">90 % 사용 시나리오에서는 어떤 것을 사용하든 관계가 없지만 언젠가 예기치 않은 동작이 발생할 때의 차이점을 아는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="ec01264fb9d51cfefd427a17d74eb33ac1be156e" translate="yes" xml:space="preserve">
          <source>In the answers here, I didn't read anything about what &lt;strong&gt;equal&lt;/strong&gt; means. Some will say that &lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;equal and of the same type&lt;/strong&gt;, but that's not really true. It actually means that &lt;strong&gt;both operands reference the same object&lt;/strong&gt;, or in case of &lt;strong&gt;value types, have the same value&lt;/strong&gt;.</source>
          <target state="translated">여기의 답변에서 나는 &lt;strong&gt;동등한&lt;/strong&gt; 의미가 무엇인지 전혀 읽지 못했습니다. 어떤 사람들은 &lt;code&gt;===&lt;/code&gt; 이 &lt;strong&gt;같고 같은 유형을&lt;/strong&gt; 의미한다고 말하지만 실제로는 그렇지 않습니다. 실제로 &lt;strong&gt;두 피연산자가 동일한 객체를 참조&lt;/strong&gt; 하거나 &lt;strong&gt;값 유형의&lt;/strong&gt; 경우 &lt;strong&gt;동일한 값을 가짐을 의미&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ca385d21427dba165889d58d33e6fa5704fb46b2" translate="yes" xml:space="preserve">
          <source>In the case of &lt;strong&gt;&quot;a === b&quot;&lt;/strong&gt; a and b must be the &lt;strong&gt;same value&lt;/strong&gt; and also the &lt;strong&gt;same type&lt;/strong&gt; for it to evaluate to true.</source>
          <target state="translated">&lt;strong&gt;&quot;a === b&quot;의 경우&lt;/strong&gt; a와 b는 &lt;strong&gt;동일한 값&lt;/strong&gt; 이어야하며 &lt;strong&gt;동일한 유형&lt;/strong&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="251bebdd324bcccca7535068065ec28cc534eae3" translate="yes" xml:space="preserve">
          <source>In the code above, both == and === get false because a and b are not the same objects.</source>
          <target state="translated">위의 코드에서 a와 b는 같은 객체가 아니기 때문에 ==와 === 모두 false가됩니다.</target>
        </trans-unit>
        <trans-unit id="a4cd7b099967df429e07f68f296c07052c7aba52" translate="yes" xml:space="preserve">
          <source>Interesting is step 11. Yes, strings are treated as value types. But this does not explain why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;. Do we have a browser not conforming to ECMA-262?</source>
          <target state="translated">흥미로운 단계는 11 단계입니다. 예, 문자열은 값 유형으로 처리됩니다. 그러나 이것은 왜 &lt;strong&gt;새로운 String ( &quot;a&quot;)! == &quot;a&quot;&lt;/strong&gt; 인지 설명하지 않습니다. ECMA-262를 준수하지 않는 브라우저가 있습니까?</target>
        </trans-unit>
        <trans-unit id="cd2c230db52d16c62fde2c29f3b5aa18ff6b95af" translate="yes" xml:space="preserve">
          <source>Is there a performance benefit to replacing &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;===&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 를 &lt;code&gt;===&lt;/code&gt; 로 바꾸면 성능상의 이점이 있습니까?</target>
        </trans-unit>
        <trans-unit id="6208d5e465527e22f406b99578ad5d55c45f7cb9" translate="yes" xml:space="preserve">
          <source>It checks if same sides are equal in &lt;strong&gt;type&lt;/strong&gt; as well as &lt;strong&gt;value&lt;/strong&gt;.</source>
          <target state="translated">같은 변의 &lt;strong&gt;유형&lt;/strong&gt; 과 &lt;strong&gt;값&lt;/strong&gt; 이 같은지 확인 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3b33800c6e21e7706b86e94308ae2b6ade92ea2c" translate="yes" xml:space="preserve">
          <source>It get's pretty wacky.</source>
          <target state="translated">꽤 별나다.</target>
        </trans-unit>
        <trans-unit id="0c3489421f48aca78ca26cbeacff41a88d0a2485" translate="yes" xml:space="preserve">
          <source>It get's worse:</source>
          <target state="translated">더 나 빠진다 :</target>
        </trans-unit>
        <trans-unit id="2461a72119f69288570a91dd4886cf1946921ace" translate="yes" xml:space="preserve">
          <source>It has special handling for functions, special handling for nulls, undefined, strings, you name it.</source>
          <target state="translated">함수에 대한 특수 처리, 널에 대한 특수 처리, 정의되지 않은 문자열이 있으며 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e7800c4331282e121e342d6b81303384bd272938" translate="yes" xml:space="preserve">
          <source>It is faster only when the types are not the same, in which case it does not try to convert types but directly returns a false.</source>
          <target state="translated">유형이 동일하지 않은 경우에만 더 빠르며,이 경우 유형 변환을 시도하지 않고 직접 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="faa77444bfb36c5ba995cd19f29530d0943b04a1" translate="yes" xml:space="preserve">
          <source>It means &lt;code&gt;==&lt;/code&gt; is complicated.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 가 복잡 하다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="a65b5bfaad127fd93d57e6ab192d490bc11ac353" translate="yes" xml:space="preserve">
          <source>It means &lt;strong&gt;equality without type coercion&lt;/strong&gt;
type coercion means JavaScript do not automatically convert any other data types to string data types</source>
          <target state="translated">그것은 &lt;strong&gt;강제 변환&lt;/strong&gt; 유형이 &lt;strong&gt;없는 평등을&lt;/strong&gt; 의미 &lt;strong&gt;합니다. 강제 변환&lt;/strong&gt; 유형은 JavaScript가 다른 데이터 유형을 문자열 데이터 유형으로 자동 변환하지 않음을 의미합니다</target>
        </trans-unit>
        <trans-unit id="4cc792e792c928abedc18234163e220b2c90215c" translate="yes" xml:space="preserve">
          <source>It's a good thing especially if you're checking between 0 and false and null.</source>
          <target state="translated">0과 false와 null 사이를 검사하는 경우 특히 좋습니다.</target>
        </trans-unit>
        <trans-unit id="76814442e2351cc8045391978fecf4190730bd23" translate="yes" xml:space="preserve">
          <source>It's a strict check test.</source>
          <target state="translated">엄격한 검사 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="c194b6748d81866560cca42c3ec80275ce25b0fa" translate="yes" xml:space="preserve">
          <source>It's a whole new level of crazy when you use &lt;code&gt;==&lt;/code&gt; with objects.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 를 객체와 함께 사용하면 완전히 새로운 수준의 미친 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e5685be28423b6fa9a147ecdfab572abc4a40a1" translate="yes" xml:space="preserve">
          <source>JSLint sometimes gives you unrealistic reasons to modify stuff. &lt;code&gt;===&lt;/code&gt; has exactly the same performance as &lt;code&gt;==&lt;/code&gt; if the types are already the same.</source>
          <target state="translated">JSLint는 때때로 비현실적인 이유를 제공합니다. 유형이 이미 동일한 경우 &lt;code&gt;===&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; 와 정확히 동일한 성능을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6f75f5a9d4e62f008ab83040158a6ea4c2ffb8de" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;===&lt;/code&gt;&lt;strong&gt;vs&lt;/strong&gt;&lt;code&gt;==&lt;/code&gt; .</source>
          <target state="translated">JavaScript &lt;code&gt;===&lt;/code&gt; &lt;strong&gt;vs&lt;/strong&gt; &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f50ece919837ed27b6fe25229b9c0edd82a3a80" translate="yes" xml:space="preserve">
          <source>JavaScript has two sets of equality operators: &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;, and their evil twins &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.  The good ones work the way you would expect.  If the two operands are of the same type and have the same value, then &lt;code&gt;===&lt;/code&gt; produces &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt; produces &lt;code&gt;false&lt;/code&gt;.  The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values.  the rules by which they do that are complicated and unmemorable.  These are some of the interesting cases:</source>
          <target state="translated">JavaScript에는 &lt;code&gt;===&lt;/code&gt; 및 &lt;code&gt;!==&lt;/code&gt; 의 두 등식 연산자 세트와 사악한 쌍둥이 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 있습니다. 좋은 것은 당신이 기대하는 방식으로 작동합니다. 두 피연산자가 동일한 유형이고 동일한 값을 갖는 경우 &lt;code&gt;===&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 생성하고 &lt;code&gt;!==&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 생성합니다. 피연산자가 같은 유형일 때 사악한 쌍둥이가 옳은 일을하지만 다른 유형일 경우 값을 강요하려고합니다. 그들이하는 규칙은 복잡하고 기억에 남습니다. 흥미로운 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ddcc47139dece09713aae28867a0635754940c72" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for non strict equality / comparison '=='</source>
          <target state="translated">비 균등 평등 / 비교를위한 자바 스크립트 실행 흐름도 '=='</target>
        </trans-unit>
        <trans-unit id="c489836ec904339790b4e755108af00367792205" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for strict equality / Comparison '==='</source>
          <target state="translated">엄격한 평등을위한 자바 스크립트 실행 흐름도 / 비교 '==='</target>
        </trans-unit>
        <trans-unit id="8a105feba0ec261aeed869b80ed97fd71c7d981b" translate="yes" xml:space="preserve">
          <source>Let me add this counsel:</source>
          <target state="translated">이 권고를 추가하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="b78f589e89c4bf85c5acdcf503fa3ce05322739a" translate="yes" xml:space="preserve">
          <source>Let me say that again:</source>
          <target state="translated">다시 말씀 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="7dc48ae18a400d363e4e831b1bc3f62fa17e236b" translate="yes" xml:space="preserve">
          <source>Let's check the types of the operands. Try it out for yourself by wrapping them in &lt;strong&gt;typeof()&lt;/strong&gt;. I find that &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; is an object, and step 1 is used: return &lt;strong&gt;false&lt;/strong&gt; if the types are different.</source>
          <target state="translated">피연산자의 유형을 확인합시다. &lt;strong&gt;typeof ()&lt;/strong&gt; 로 감싸서 직접 사용해보십시오. &lt;strong&gt;new String ( &quot;a&quot;)&lt;/strong&gt; 은 객체이며 1 단계가 사용됩니다. 유형이 다르면 &lt;strong&gt;false를&lt;/strong&gt; 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="b61e7aec3e99c633efdc11e39208fc2dff1d3e2c" translate="yes" xml:space="preserve">
          <source>Lets take 2 vars a and b.</source>
          <target state="translated">2 가지 a와 b를 취하겠습니다.</target>
        </trans-unit>
        <trans-unit id="cfd185a2bd37b57a50c809cfa0d84c8e0b4f3ff4" translate="yes" xml:space="preserve">
          <source>Make your life less complicated.</source>
          <target state="translated">인생을 덜 복잡하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="63b41e8cde051766ea25feb26773d03ab2db614d" translate="yes" xml:space="preserve">
          <source>Meaning, there is no reason to change &lt;code&gt;==&lt;/code&gt; to &lt;code&gt;===&lt;/code&gt; in a check like &lt;code&gt;if (a == 'test')&lt;/code&gt; when you know it for a fact that a can only be a String.</source>
          <target state="translated">즉, 문자열 만 될 수 있다는 사실을 알면 &lt;code&gt;if (a == 'test')&lt;/code&gt; 와 같은 검사에서 &lt;code&gt;==&lt;/code&gt; 에서 &lt;code&gt;===&lt;/code&gt; 로 변경할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0938c27e70c1f172175d9d18522b01f7447aea0e" translate="yes" xml:space="preserve">
          <source>Modifying a lot of code that way wastes developers' and reviewers' time and achieves nothing.</source>
          <target state="translated">많은 코드를 수정하면 개발자와 검토 자의 시간을 낭비하고 아무것도 달성하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="f4cefe7cd2cd184bb73ed4c344cfc83710bb0d62" translate="yes" xml:space="preserve">
          <source>My results (tested five times each and averaged):</source>
          <target state="translated">내 결과 (각 5 회 테스트 및 평균) :</target>
        </trans-unit>
        <trans-unit id="f0da046224ce2dc3106a3b60cd5d194e6ba42983" translate="yes" xml:space="preserve">
          <source>Not so fast!</source>
          <target state="translated">그렇게 빠르지 않습니다!</target>
        </trans-unit>
        <trans-unit id="d5b784c68e01c822fc3215d8b23457f17bc7b95f" translate="yes" xml:space="preserve">
          <source>Now it becomes interesting:</source>
          <target state="translated">이제 흥미로워집니다.</target>
        </trans-unit>
        <trans-unit id="26cf870c221ea623ca6c9613122347141c9e0338" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;strong&gt;identity operator &lt;code&gt;===&lt;/code&gt; does not do type coercion&lt;/strong&gt;, and thus does not convert the values when comparing, and is therefore faster (as according to &lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;This JS benchmark&lt;/a&gt; test) as it skips one step.</source>
          <target state="translated">한편, &lt;strong&gt;항등 연산자 &lt;code&gt;===&lt;/code&gt; 는 유형 강제 변환을 수행&lt;/strong&gt; 하지 않으므로 비교할 때 값을 변환하지 않으므로 ( &lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;이 JS 벤치 마크&lt;/a&gt; 테스트에 따라) 한 단계를 건너 뛰므로 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="bb6871c5d84a4419ab95dc8eece8700504fdd6d6" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;==&lt;/code&gt;</source>
          <target state="translated">연산자 &lt;code&gt;==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f06b526b15c78330ed724b58112444a30169da4d" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">연산자 &lt;code&gt;===&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7a3d854bfa0266e9c4a954b8a4122785d12b7cc" translate="yes" xml:space="preserve">
          <source>Or even:</source>
          <target state="translated">또는:</target>
        </trans-unit>
        <trans-unit id="596eba5f701a564c8f484f75e8abdc3dd9152672" translate="yes" xml:space="preserve">
          <source>Please let me explain how to read the specification to clarify this question. I see that in this very old topic nobody had an answer for the very strange effect. So, if you can read a specification, this will help you in your profession tremendously. It is an acquired skill. So, let's continue.</source>
          <target state="translated">이 질문을 명확히하기 위해 사양을 읽는 방법을 설명하겠습니다. 나는이 아주 오래된 주제에서 아무도 그 이상한 효과에 대한 답을 얻지 못했다는 것을 알았습니다. 따라서 사양을 읽을 수 있다면 이것은 직업에 큰 도움이 될 것입니다. 습득 한 기술입니다. 계속하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2a07e2d0f6f8e8b2cf427f387c24f9c27a381095" translate="yes" xml:space="preserve">
          <source>Reasons are explained in in the answers above and also Douglas Crockford is pretty clear about it (&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;).</source>
          <target state="translated">이유는 위의 답변에 설명되어 있으며 Douglas Crockford는 이에 대해 분명합니다 ( &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript : The Good Parts&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d15ebe82de3e2a210aaf6dba6213d7558919e153" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;Javascript Tutorial: Comparison Operators&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;Javascript 학습서 : 비교 연산자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ea0f0fa0757bccc8812f547b6f8ef97346e64a" translate="yes" xml:space="preserve">
          <source>Returns true if both operands are equal and of the same type. It's generally 
better and safer if you compare this way, because there's no behind-the-scenes type conversions.</source>
          <target state="translated">두 피연산자가 같고 같은 유형 인 경우 true를 리턴합니다. 비하인드 유형 변환이 없기 때문에이 방법을 비교하면 일반적으로 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="957512be3223fc2dc3834f75c1dd58acecceff86" translate="yes" xml:space="preserve">
          <source>Returns true, when both operands are equal. The operands are converted to the same type before being compared.</source>
          <target state="translated">두 피연산자가 같으면 true를 리턴합니다. 피연산자는 비교하기 전에 동일한 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="38ce9002bb36040cd6c2edf6d1d18fcb9a616b7a" translate="yes" xml:space="preserve">
          <source>Searching the PDF file for === brings me to page 56 of the specification: &lt;strong&gt;11.9.4. The Strict Equals Operator ( === )&lt;/strong&gt;, and after wading through the specificationalese I find:</source>
          <target state="translated">===에 대한 PDF 파일을 검색하면 사양의 56 페이지로 이동합니다 : &lt;strong&gt;11.9.4.&lt;/strong&gt; &lt;strong&gt;Strict Equals Operator (===)&lt;/strong&gt; 및 specalesales를 넘어 가면 다음을 발견합니다.</target>
        </trans-unit>
        <trans-unit id="91af0d8b760b9aafb600d14166c0c131354b13a6" translate="yes" xml:space="preserve">
          <source>Simply</source>
          <target state="translated">Simply</target>
        </trans-unit>
        <trans-unit id="64c21976a1564e95206be932a9271ff8e6100731" translate="yes" xml:space="preserve">
          <source>So I'd say that the miniscule difference (this is over 100000 iterations, remember) is negligible. Performance &lt;strong&gt;&lt;em&gt;isn't&lt;/em&gt;&lt;/strong&gt; a reason to do &lt;code&gt;===&lt;/code&gt;. Type safety (well, as safe as you're going to get in JavaScript), and code quality is.</source>
          <target state="translated">따라서 작은 차이 (100000 회 이상 반복됨)는 무시할 만하다고 말하고 싶습니다. 성능 &lt;strong&gt;&lt;em&gt;이&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;===&lt;/code&gt; 할 이유 &lt;strong&gt;&lt;em&gt;가 아닙니다&lt;/em&gt;&lt;/strong&gt; . 타입 안전 (자바 스크립트에서 얻을 수있는만큼 안전)과 코드 품질입니다.</target>
        </trans-unit>
        <trans-unit id="ae0f3a56366851cea007b0cc3ec71cfe6236267c" translate="yes" xml:space="preserve">
          <source>So with the same thing as above, but a strict test:</source>
          <target state="translated">위와 동일하지만 엄격한 테스트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c48ceb341b7974b0c35d68232de996773594700" translate="yes" xml:space="preserve">
          <source>So, &lt;em&gt;IMHO,&lt;/em&gt; JSLint maybe used to write new code, but useless over-optimizing should be avoided at all costs.</source>
          <target state="translated">따라서 &lt;em&gt;IMHO,&lt;/em&gt; JSLint는 새 코드를 작성하는 데 사용될 수 있지만 모든 비용으로 쓸모없는 과도한 최적화를 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5331af50eaf804f03f6a6159c25f1bb07cd7a40" translate="yes" xml:space="preserve">
          <source>So, let's take the following code:</source>
          <target state="translated">다음 코드를 보자.</target>
        </trans-unit>
        <trans-unit id="93b72b7d5b6694715afdca6d3fa8931c4d1db958" translate="yes" xml:space="preserve">
          <source>So, the 0, false and '' together form a sub-group. And on other hand, null &amp;amp; undefined form the second sub-group. Check the comparisons in the below image. null and undefined would equal. The other three would equal to each other. But, they all are treated as falsy conditions in JavaScript.</source>
          <target state="translated">따라서 0, false 및 ''은 함께 하위 그룹을 형성합니다. 반면에 null &amp;amp; undefined는 두 번째 하위 그룹을 형성합니다. 아래 이미지에서 비교를 확인하십시오. null과 undefined는 같습니다. 다른 세 사람은 서로 같습니다. 그러나 이들은 모두 JavaScript에서 잘못된 조건으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="1a279fa74ab72ad3bcba6d6c656bd5ebc3d0eab4" translate="yes" xml:space="preserve">
          <source>Strict equality checks (===) should be used in favor of ==. The only
  exception is when checking for undefined and null by way of null.</source>
          <target state="translated">엄격한 평등 검사 (===)는 ==에 유리하게 사용해야합니다. null을 통해 undefined 및 null을 검사 할 때는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="1d6d9051f3abc1e1858ebeb652dd4b2cace2ad46" translate="yes" xml:space="preserve">
          <source>Strings are not value types, but in Javascript they behave like value types, so they will be &quot;equal&quot; when the characters in the string are the same and when they are of the same length (as explained in the third rule)</source>
          <target state="translated">문자열은 값 유형이 아니지만 Javascript에서는 값 유형처럼 동작하므로 문자열의 문자가 동일하고 길이가 같은 경우 (제 3 규칙에 설명 된대로) &quot;동일&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="2fc95a3daa32ef795b3db44197ca06a9161c6605" translate="yes" xml:space="preserve">
          <source>Strings: the special case...</source>
          <target state="translated">문자열 : 특별한 경우 ...</target>
        </trans-unit>
        <trans-unit id="0a10f80e947919598b83985df0a922cea18c825f" translate="yes" xml:space="preserve">
          <source>Take the following example</source>
          <target state="translated">다음 예제를 보자</target>
        </trans-unit>
        <trans-unit id="34d15b0c36f8c3a873f0aa9868dd4a2ce99ed153" translate="yes" xml:space="preserve">
          <source>That's to say: if both operands of == are objects, == behaves same as ===, which also means identity. The essential difference of this two operators is about type conversion. == has conversion before it checks equality, but === does not.</source>
          <target state="translated">즉, ==의 두 피연산자가 모두 객체 인 경우 ==는 ===와 동일하게 동작하며 이는 또한 동일성을 의미합니다. 이 두 연산자의 근본적인 차이점은 형식 변환에 관한 것입니다. == 동일성을 검사하기 전에 변환이 있지만 ===는 변환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b194ffbdff61cd41449b27896d0388ad11bc6102" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator will compare for equality &lt;em&gt;after doing any necessary type conversions&lt;/em&gt;.  The &lt;code&gt;===&lt;/code&gt; operator will &lt;strong&gt;not&lt;/strong&gt; do the conversion, so if two values are not the same type &lt;code&gt;===&lt;/code&gt; will simply return &lt;code&gt;false&lt;/code&gt;. Both are equally quick.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 연산자는 &lt;em&gt;필요한 형식 변환을 수행 한 후&lt;/em&gt; 동등성 &lt;em&gt;을&lt;/em&gt; 비교합니다. &lt;code&gt;===&lt;/code&gt; 연산자는 변환을 수행하지 않으므로 두 값이 같지 않으면 &lt;code&gt;===&lt;/code&gt; 유형은 단순히 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. 둘 다 똑같이 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="94d61a1bd3d74a41d42873da5dad1d59e17caf82" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;===&lt;/strong&gt; operator is called a strict comparison operator, it &lt;strong&gt;does&lt;/strong&gt; differ from the &lt;strong&gt;==&lt;/strong&gt; operator.</source>
          <target state="translated">&lt;strong&gt;===&lt;/strong&gt; 연산자를 엄격한 비교 연산자라고하며 &lt;strong&gt;==&lt;/strong&gt; 연산자와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6b4a3a20e019eab11a43250c848486e6d49f5365" translate="yes" xml:space="preserve">
          <source>The End.</source>
          <target state="translated">끝.</target>
        </trans-unit>
        <trans-unit id="afa8919ed4dc94f9cf1c114da989f410b6e7be00" translate="yes" xml:space="preserve">
          <source>The comparison x === y, where x and y are values, produces &lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;. Such a comparison is performed as follows:</source>
          <target state="translated">x와 y가 값인 x === y 비교는 &lt;strong&gt;true&lt;/strong&gt; 또는 &lt;strong&gt;false를&lt;/strong&gt; 생성 &lt;strong&gt;합니다&lt;/strong&gt; . 이러한 비교는 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1b98b3145565493d8ec7750f669d527714ecc29b" translate="yes" xml:space="preserve">
          <source>The identity (&lt;code&gt;===&lt;/code&gt;) operator behaves identically to the equality (&lt;code&gt;==&lt;/code&gt;) operator except no type conversion is done, and the types must be the same to be considered equal.</source>
          <target state="translated">항등 ( &lt;code&gt;===&lt;/code&gt; ) 연산자는 유형 변환이 수행되지 않은 것을 제외하고 항등 ( &lt;code&gt;==&lt;/code&gt; ) 연산자와 동일하게 작동하며 유형이 동일하다고 간주되도록 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="412caf725ac873e21c2342891582c7eb72241e50" translate="yes" xml:space="preserve">
          <source>The lack of transitivity is alarming.  My advice is to never use the evil twins.  Instead, always use &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;.  All of the comparisons just shown produce &lt;code&gt;false&lt;/code&gt; with the &lt;code&gt;===&lt;/code&gt; operator.</source>
          <target state="translated">전이성의 결여가 놀랍습니다. 내 충고는 사악한 쌍둥이를 절대로 사용하지 않는 것입니다. 대신 항상 &lt;code&gt;===&lt;/code&gt; 및 &lt;code&gt;!==&lt;/code&gt; . 방금 표시된 모든 비교는 &lt;code&gt;===&lt;/code&gt; 연산자로 &lt;code&gt;false&lt;/code&gt; 를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e2ca5becda5d8c525a92af853383dd2f554be5e6" translate="yes" xml:space="preserve">
          <source>The problem is that you might easily get into trouble since JavaScript have a lot of implicit conversions meaning...</source>
          <target state="translated">문제는 JavaScript에 많은 암시 적 변환이 있기 때문에 쉽게 문제가 발생할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c5cdbf6f285cc357902c21867d22dceaabbfb07" translate="yes" xml:space="preserve">
          <source>The rule is:</source>
          <target state="translated">규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34e5356fba8841d2e384644ac7191e706b9b383b" translate="yes" xml:space="preserve">
          <source>The same here:</source>
          <target state="translated">여기 동일합니다 :</target>
        </trans-unit>
        <trans-unit id="ac6a25542b0ec2ff99281bcf844b6b748cb989bf" translate="yes" xml:space="preserve">
          <source>The special case is when you compare a literal with an object that evaluates to the same literal, due to its &lt;code&gt;toString&lt;/code&gt; or &lt;code&gt;valueOf&lt;/code&gt; method. For example, consider the comparison of a string literal with a string object created by the &lt;code&gt;String&lt;/code&gt; constructor.</source>
          <target state="translated">특별한 경우는 &lt;code&gt;toString&lt;/code&gt; 또는 &lt;code&gt;valueOf&lt;/code&gt; 메소드로 인해 리터럴을 동일한 리터럴로 평가되는 객체와 리터럴을 비교하는 경우입니다. 예를 들어 문자열 리터럴과 &lt;code&gt;String&lt;/code&gt; 생성자가 만든 문자열 객체를 비교해보십시오.</target>
        </trans-unit>
        <trans-unit id="deec20d89955518508df750a0325916894b132b6" translate="yes" xml:space="preserve">
          <source>The top 2 answers both mentioned == means equality and === means identity. Unfortunately, this statement is incorrect.</source>
          <target state="translated">언급 된 ==는 평등을 의미하고 ===는 동일성을 의미하는 상위 2 개의 답변 불행히도이 문장은 틀렸다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="7e6e25d889bccff4888c16c5091398046e021bd5" translate="yes" xml:space="preserve">
          <source>There is unlikely to be any performance difference between the two operations in your usage. There is no type-conversion to be done because both parameters are already the same type. Both operations will have a type comparison followed by a value comparison.</source>
          <target state="translated">사용 중 두 작업간에 성능 차이가 없을 것입니다. 두 매개 변수가 이미 동일한 유형이므로 유형 변환이 수행되지 않습니다. 두 작업 모두 유형 비교와 값 비교가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0addef10584dbb6993cff27164cee0b6c70c9f9" translate="yes" xml:space="preserve">
          <source>This behavior is not always obvious. There's more to the story than being equal and being of the same type.</source>
          <target state="translated">이 동작이 항상 명백한 것은 아닙니다. 평등하고 같은 유형의 것보다 더 많은 이야기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="10b32091fa5a9c7a5536dd0b8d0dbc5d56df3f1a" translate="yes" xml:space="preserve">
          <source>This is because the &lt;strong&gt;equality operator &lt;code&gt;==&lt;/code&gt; does type coercion&lt;/strong&gt;, meaning that the interpreter implicitly tries to convert the values before comparing.</source>
          <target state="translated">&lt;strong&gt;항등 연산자 &lt;code&gt;==&lt;/code&gt; 는 coercion 유형을 수행&lt;/strong&gt; 하기 때문에 인터프리터가 암시 적으로 값을 변환하기 전에 값을 변환하려고 시도하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e099919ae099449d50619707a595101be1938525" translate="yes" xml:space="preserve">
          <source>This is same as any object (like {}, arrays, etc.), non-empty string &amp;amp; Boolean true are all truthy conditions. But, they are all not equal.</source>
          <target state="translated">이것은 {}, 배열 등과 같은 모든 객체와 동일하며, 비어 있지 않은 문자열 및 부울 true는 모두 진실한 조건입니다. 그러나 그들은 모두 평등하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c01421dd6e3a97aa7a750d67645c9ce033722624" translate="yes" xml:space="preserve">
          <source>To quote Douglas Crockford's excellent &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;,</source>
          <target state="translated">Douglas Crockford의 뛰어난 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript&lt;/a&gt; 를 인용하면 : The Good Parts ,</target>
        </trans-unit>
        <trans-unit id="1b6611f5af4feb0209552e588441f461e4827c57" translate="yes" xml:space="preserve">
          <source>Type conversion in javaScript means javaScript automatically convert any other data types to string data types.</source>
          <target state="translated">javaScript에서 유형 변환은 javaScript가 다른 데이터 유형을 문자열 데이터 유형으로 자동 변환 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="2dd151cc35444f22efefaf2a4c9200a524eabcbb" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 대신 &lt;code&gt;===&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c453d7e21f4c791a03dcc4a981e5605615b7d07" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;==&lt;/code&gt; operator (&lt;em&gt;Equality&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 연산자 사용 ( &lt;em&gt;Equality&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="513b5a2751665a1919f797ca492150f5a95e5dbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;===&lt;/code&gt; operator (&lt;em&gt;Identity&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 연산자 ( &lt;em&gt;Identity&lt;/em&gt; ) 사용</target>
        </trans-unit>
        <trans-unit id="49fae091b162654343089eb4ba3ab8ccdfc467f0" translate="yes" xml:space="preserve">
          <source>Well it's because unlike &quot;triple equals&quot; (&lt;code&gt;===&lt;/code&gt;) which just checks if two values are the same.</source>
          <target state="translated">&quot;triple equals&quot;( &lt;code&gt;===&lt;/code&gt; )와 달리 두 값이 같은지 확인하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fbbea6dde2ab91a36ff23b57623dc1796e371116" translate="yes" xml:space="preserve">
          <source>What do you get when you compare an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; with the number zero &lt;code&gt;0&lt;/code&gt;?</source>
          <target state="translated">빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 을 숫자 0 &lt;code&gt;0&lt;/code&gt; 과 비교하면 무엇을 얻습니까?</target>
        </trans-unit>
        <trans-unit id="67709d0522046140afbdae10c9f80a805117bee6" translate="yes" xml:space="preserve">
          <source>Which equals operator (== vs ===) should be used in JavaScript comparisons</source>
          <target state="translated">JavaScript 비교에는 연산자 (== vs ===)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="697e4e154c1261a7e33818edccc744a4d570a31e" translate="yes" xml:space="preserve">
          <source>Which means you could end up with bugs.</source>
          <target state="translated">이는 버그로 끝날 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d141d97a7a3ac22b01fd1cd75711d31e277f0a28" translate="yes" xml:space="preserve">
          <source>Which obviously during runtime does &lt;em&gt;very&lt;/em&gt; undefined things...</source>
          <target state="translated">분명히 런타임 중에 &lt;em&gt;매우&lt;/em&gt; 정의되지 않은 일을하는 것은 ...</target>
        </trans-unit>
        <trans-unit id="36933ceea4f2db404d028c82e6364a36ace968a0" translate="yes" xml:space="preserve">
          <source>Which pretty soon becomes a problem. The best sample of why implicit conversion is &quot;evil&quot; can be taken from this code in &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C++ which actually will compile due to an implicit conversion from CString to HANDLE which is a pointer typedef type...</source>
          <target state="translated">곧 문제가 될 것입니다. 암시 적 변환이 &quot;악&quot;인 이유에 대한 가장 좋은 샘플은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C ++의이 코드에서 가져올 수 있는데, 이는 포인터 typedef 유형 인 CString에서 HANDLE 로의 암시 적 변환으로 인해 실제로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="9fcac86aac0009e66019e4c27ea46100eaf900a2" translate="yes" xml:space="preserve">
          <source>With other words, if String wouldn't be of type Object it couldn't be used with the new operator.</source>
          <target state="translated">즉, String이 Object 유형이 아니면 new 연산자와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="45903fac0ea3c75afe550d2440dc48b77fd3f572" translate="yes" xml:space="preserve">
          <source>Yep, that's right according to &lt;code&gt;==&lt;/code&gt; an empty string and the number zero are the same time.</source>
          <target state="translated">그렇습니다. &lt;code&gt;==&lt;/code&gt; 빈 문자열에 따르면 맞고 숫자 0은 같은 시간입니다.</target>
        </trans-unit>
        <trans-unit id="eabbe6442a6f27defee150f80d6147176f73513a" translate="yes" xml:space="preserve">
          <source>You can easily test it. Paste following code in an HTML file and open it in browser</source>
          <target state="translated">쉽게 테스트 할 수 있습니다. HTML 파일에 다음 코드를 붙여 넣고 브라우저에서 엽니 다</target>
        </trans-unit>
        <trans-unit id="5da640618827894fedb5feef195dd55437e5bda8" translate="yes" xml:space="preserve">
          <source>You will get '&lt;strong&gt;false&lt;/strong&gt;' in alert. Now modify the &lt;code&gt;onPageLoad()&lt;/code&gt; method to &lt;code&gt;alert(x == 5);&lt;/code&gt; you will get &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">경고 메시지에 ' &lt;strong&gt;거짓&lt;/strong&gt; '이 표시됩니다. 이제 &lt;code&gt;onPageLoad()&lt;/code&gt; 메소드를 &lt;code&gt;alert(x == 5);&lt;/code&gt; 수정하십시오 . 당신은 &lt;strong&gt;사실&lt;/strong&gt; 을 얻을 &lt;strong&gt;것&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="786e97b3ee9fc4b292d5852c2c5943153c4ce91a" translate="yes" xml:space="preserve">
          <source>but</source>
          <target state="translated">but</target>
        </trans-unit>
        <trans-unit id="550f8bc02aebdb930e2ff4b54cf6677ee045437c" translate="yes" xml:space="preserve">
          <source>null and undefined are nothingness, that is,</source>
          <target state="translated">null과 undefined는 무의미하다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
