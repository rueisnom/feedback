<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/359494">
    <body>
      <group id="359494">
        <trans-unit id="130bf5785915eb04e8a94d3a41ec118bd8e8f0d8" translate="yes" xml:space="preserve">
          <source>&quot;Use three equals unless you fully understand the conversions that take
  place for two-equals.&quot;</source>
          <target state="translated">&quot;2等分の変換を完全に理解しない限り 3等分を使え&quot;</target>
        </trans-unit>
        <trans-unit id="54f697a1ff421e46f37022813a88d0937a82090c" translate="yes" xml:space="preserve">
          <source>&amp;amp;</source>
          <target state="translated">&amp;amp;</target>
        </trans-unit>
        <trans-unit id="dea7f7f48b6202dbcdd6e2f0b470c1320197a1b3" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;1. If Type(x) is different from Type(y), return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">1. Type（x）がType（y）と異なる場合は、 &lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="128316503370069a1f99b4764d5a503e65225aa7" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;10. Return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">10. &lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f94476563997f8d2da2e6fdfb6b36c68ec81051" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;11. If Type(x) is String, then return &lt;strong&gt;true&lt;/strong&gt; if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">11. Type（x）が文字列の場合、xとyがまったく同じ文字シーケンス（同じ長さで対応する位置に同じ文字）であれば&lt;strong&gt;true&lt;/strong&gt;を返し&lt;strong&gt;ます&lt;/strong&gt; 。 それ以外の場合は、 &lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c30077433d472cb40022cd05bbb7b0fce6d9add" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;12. If Type(x) is Boolean, return &lt;strong&gt;true&lt;/strong&gt; if x and y are both &lt;strong&gt;true&lt;/strong&gt; or both &lt;strong&gt;false&lt;/strong&gt;; otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">12. Type（x）がブール値の場合、xとyが両方とも&lt;strong&gt;true&lt;/strong&gt;または両方とも&lt;strong&gt;falseで&lt;/strong&gt;あれば&lt;strong&gt;trueを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。 それ以外の場合は、 &lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="25f36acdf60e7d6a4df37ffedc98b9f14faf995c" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;13. Return &lt;strong&gt;true&lt;/strong&gt; if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">13. xとyが同じオブジェクトを参照する場合、または互いに結合されたオブジェクトを参照する場合は、 &lt;strong&gt;trueを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; （13.1.2を参照）。 それ以外の場合は、 &lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6754f28eced479b11eb44690f5d4fa3822beda44" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;2. If Type(x) is Undefined, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">2. Type（x）が未定義の場合、 &lt;strong&gt;trueを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8a41404dc0e9e4b2139c7b55b00ba4f197ed1db" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;3. If Type(x) is Null, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">3. Type（x）がNullの場合、 &lt;strong&gt;trueを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="86e81311d208ba00e8a82f89a4b6f670518af9c9" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;4. If Type(x) is not Number, go to step 11.</source>
          <target state="translated">4. Type（x）がNumberでない場合は、手順11に進みます。</target>
        </trans-unit>
        <trans-unit id="1d11aa4bb7dc1bb6eb30029e881efcb0c773c688" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;5. If x is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">5. xが&lt;strong&gt;NaNの&lt;/strong&gt;場合、 &lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6feedc887138d0c4493e0285c20861d70ce82b0" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;6. If y is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">6. yが&lt;strong&gt;NaNの&lt;/strong&gt;場合、 &lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b305a8dce9f7df97f238519197a73606b9ab87f2" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;7. If x is the same number value as y, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">7. xがyと同じ数値の場合、 &lt;strong&gt;trueを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b42c345a414ab1fe5a4c613c47711966027975a5" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;8. If x is +0 and y is &amp;minus;0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">8. xが+0でyが-0の場合、 &lt;strong&gt;trueを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e941ba4b0fdf4fcc001e64d6bd9bd26d6a81fd02" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;9. If x is &amp;minus;0 and y is +0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">9. xが-0でyが+0の場合、 &lt;strong&gt;trueを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="03520e1e34120f6fae6bbeb3d5eb895994c709d3" translate="yes" xml:space="preserve">
          <source>** STRANGE: note that any two values on the first column are not equal in that sense.**</source>
          <target state="translated">**奇妙なことに、最初の列にある2つの値は、その意味では等しくないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="bfadb6bfe229d17ab6eb814049a1af7e1c35942f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality and type comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;等価性と型の比較：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4311a70549d246e170e5a8f1b527e5c5a19379f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;同等性の比較：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1ab346462c9fcef1a02b67c403e451e31987880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does a &lt;strong&gt;&lt;em&gt;whole bunch of other stuff&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; &lt;strong&gt;&lt;em&gt;たくさんの他のことをし&lt;/em&gt;&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1b338ff3f560901a0f7f2338cb21ec9ed418bce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;with&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; は&lt;strong&gt;、&lt;/strong&gt; &lt;code&gt;type conversion&lt;/code&gt; オペランド間の&lt;strong&gt;比較&lt;/strong&gt;を意味します</target>
        </trans-unit>
        <trans-unit id="e9d647aeb173e83a0130624d9b11d9a6aca4c3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; operator just checks the value of the variables for equality.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 演算子は、変数の値が等しいかどうかをチェックするだけです。</target>
        </trans-unit>
        <trans-unit id="86a40c35943be312d26be58ed590bcd3dd325425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; Returns &lt;code&gt;true&lt;/code&gt; if the operands are strictly equal (see above)
  with no type conversion.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; オペランドが型変換なしで厳密に等しい場合（上記を参照）、 &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9d0976f976a35ebb6ebe62b08679b2e138576dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;without&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; は、 &lt;code&gt;type conversion&lt;/code&gt; &lt;strong&gt;なしの&lt;/strong&gt;オペランド間の&lt;strong&gt;比較&lt;/strong&gt;を意味します</target>
        </trans-unit>
        <trans-unit id="54e23978f1caf3d9c1511fb347612a2b3442e552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator  checks the values as well as the types of the variables for equality.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 演算子は、値と変数の型が等しいかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="0784b02b5003c7729e030d9b7d490e95bab806f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator in javascript &lt;strong&gt;checks value as well as type&lt;/strong&gt; where as &lt;code&gt;==&lt;/code&gt; operator just checks &lt;strong&gt;the value (does type conversion if required)&lt;/strong&gt;.</source>
          <target state="translated">JavaScriptの &lt;code&gt;===&lt;/code&gt; 演算子は&lt;strong&gt;値と型をチェックします。&lt;/strong&gt;ここで、as &lt;code&gt;==&lt;/code&gt; 演算子&lt;strong&gt;は値を&lt;/strong&gt;チェック&lt;strong&gt;する&lt;/strong&gt;だけ&lt;strong&gt;です（必要に応じて型変換を行います）&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e191a0a45be586c4c0bba711c1f56571fe4d8f4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both strings and contain the exact same characters</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; は、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; が両方とも文字列で、まったく同じ文字を含む場合にtrueを返します</target>
        </trans-unit>
        <trans-unit id="c03f97f96e2f5f2837a1f086b8eb03c59b00a165" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same value and are of the same type</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; は、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; が同じ値で、同じ型である場合にtrueを返します</target>
        </trans-unit>
        <trans-unit id="0b9afde54d1a9e309f7f55b08fcee09754103a72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reference the exact same object</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; は、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; がまったく同じオブジェクトを参照している場合にtrueを返します</target>
        </trans-unit>
        <trans-unit id="a569658b84c50eebdb4a105bf59c6e932a3a246e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;The equal comparison operator == is confusing and should be avoided.&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;等価比較演算子==は混乱を招くため、回避する必要があります。&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e7e53458508d6e51aeb7d6a48cf2891cadddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.2.2 The new Operator&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;11.2.2新しいオペレーター&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="7998aff2909b6b4706d92805f6351ca4f05e7bf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.9.6 The Strict Equality Comparison Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;11.9.6厳格な平等比較アルゴリズム&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6991c2660c1bca00359ab71ad6adcfdf32c7a356" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For reference types:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;参照タイプの場合：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b281c590fb85b87b5d11f1a04a3b17b4b081d21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For strings:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;文字列の場合：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a449c178aebbeb356e9012aeb4b469de6ac6e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For value types (numbers):&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;値タイプ（数値）の場合：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f73c5c4818316a7e7ba83421501c2687aba89eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;If in doubt, read the &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;specification&lt;/a&gt;!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;疑問がある場合は、 &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;仕様を&lt;/a&gt;読んでください！&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b1bf8ddd0de3be690c43c624391f8937688d9e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Moral of the story:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;この話の教訓：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83c7151c0c6f7fb762f855eb85e50c829ea14a0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Use &lt;code&gt;===&lt;/code&gt; unless you fully understand the
  conversions that take place with &lt;code&gt;==&lt;/code&gt;.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;==&lt;/code&gt; を使用して行われる変換を完全に理解していない限り、 &lt;code&gt;===&lt;/code&gt; を使用してください。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef127aa6ac9121f82176c29f76864dbb36fe4c2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;==&lt;/code&gt; for JavaScript equality testing, some
  funky conversions take place.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;JavaScriptの等価性テストに &lt;code&gt;==&lt;/code&gt; を使用すると、いくつかのファンキーな変換が行われます。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77298b36a9fcbaf746d98e1bc74886ea8bbddcff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;===&lt;/code&gt; for JavaScript equality testing, everything is as is. Nothing gets converted before being evaluated.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;JavaScriptの等価性テストに &lt;code&gt;===&lt;/code&gt; を使用する場合、すべてがそのままです。&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;評価される前に何も変換されません。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5583d977f70290bf3ad57016e11eed7fe1b944f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of doubt, learn by heart the following truth table:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;疑問がある場合は、次の真理値表を暗記してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4e32406ca5087fb220aee87a9159a70a2cf49c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In summary&lt;/strong&gt;; using the &lt;strong&gt;==&lt;/strong&gt; operator might evaluate to true in situations where you do not want it to so using the &lt;strong&gt;===&lt;/strong&gt; operator would be safer.</source>
          <target state="translated">&lt;strong&gt;要約すると&lt;/strong&gt; 、 &lt;strong&gt;==&lt;/strong&gt;演算子を使用したくない場合は、 &lt;strong&gt;==&lt;/strong&gt;演算子をtrueに評価するため、 &lt;strong&gt;===&lt;/strong&gt;演算子を使用した方が安全です。</target>
        </trans-unit>
        <trans-unit id="0fc148d6649bd47fe8e2b7cf2467f19d0bf69fd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not transitive: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(b == c)&lt;/em&gt; does not lead to &lt;em&gt;(a == c)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;推移的ではありません： &lt;em&gt;（a == b）&lt;/em&gt;および&lt;em&gt;（b == c）&lt;/em&gt;は&lt;em&gt;（a == c）に&lt;/em&gt;つながりません&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b0a31f565c1a8710eee82d40a2198e9e2ade2a15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's mutually exclusive to its negation: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(a != b)&lt;/em&gt; always hold opposite Boolean values, with all a and b.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;（a == b）&lt;/em&gt;と&lt;em&gt;（a！= b）は&lt;/em&gt;常に反対のブール値を保持し、すべてのaとbを否定します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2a6eb120ac5d954b7aa47baca4f35f487d47fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e15c6bff6033a446fc6a95bbcaedcb5920c62e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So the moral of the story is...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;だから、物語の教訓は...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f68664c3d5e1f0872cc0f7095d28293c50692b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what does this mean?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これはどういう意味ですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcffb768a62952b163df247d1df132d1d92ba1ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source: &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http://dorey.github.io/JavaScript-Equality-Table/&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ソース： &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http&lt;/a&gt; : //dorey.github.io/JavaScript-Equality-Table/&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3572e23516a3bbfc97277c54e9df478818214273" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Then weirder with strings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;次に、文字列で奇妙な&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4799deaf7c2bdd75e811e68dfa65cd85a9318390" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Things get really weird with arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;配列では物事が本当に奇妙になります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c6910a7c92878ee22dbd03dfb0a4072532d90db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When is equal not equal?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;いつ等しくないか&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8eb43dbcbcd365843d41af200d644bb6817377de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why &lt;code&gt;==&lt;/code&gt; is so unpredictable?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;なぜ &lt;code&gt;==&lt;/code&gt; がそれほど予測できないのですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="158e452fe7b5ed683ae60f76da327fa38cec4251" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why does this happen?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;なぜこれが起こるのですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3471db61bc9f6d45c5cdde69581a956986a6defd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes!&lt;/strong&gt; It does matter.</source>
          <target state="translated">&lt;strong&gt;はい！&lt;/strong&gt; それは問題である。</target>
        </trans-unit>
        <trans-unit id="72675d0e476a995d0975566582a364150fca52f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;new&lt;/strong&gt; always returns an Object, even for &lt;strong&gt;String&lt;/strong&gt; constructors, too. And alas! The value semantics for strings (see step 11) is lost.</source>
          <target state="translated">&lt;strong&gt;new&lt;/strong&gt;は、 &lt;strong&gt;String&lt;/strong&gt;コンストラクタの場合でも、常にObjectを返します。 そして悲しいかな！ 文字列の値のセマンティクス（手順11を参照）は失われます。</target>
        </trans-unit>
        <trans-unit id="b7f0cbff18eeec5852f5ea8c1be766cd8cf6a45d" translate="yes" xml:space="preserve">
          <source>A good point was brought up by &lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt; in the comments and in &lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;@Phillipe Laybaert's&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/957602/1288&quot;&gt;answer&lt;/a&gt; concerning reference types.  For reference types &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; act consistently with one another (except in a special case).</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt;のコメントと参照型に関する&lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;@Phillipe Laybaertの&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/957602/1288&quot;&gt;回答で&lt;/a&gt;良い点が取り上げられました。 参照タイプ &lt;code&gt;==&lt;/code&gt; および &lt;code&gt;===&lt;/code&gt; の場合、互いに一貫して動作します（特別な場合を除く）。</target>
        </trans-unit>
        <trans-unit id="8b54302e5ddc3ab8451d73b4e6fbcce29f1fb9c2" translate="yes" xml:space="preserve">
          <source>A simple example is</source>
          <target state="translated">簡単な例としては</target>
        </trans-unit>
        <trans-unit id="4e666e628adc9d3ae32638bd884bee95473bd54e" translate="yes" xml:space="preserve">
          <source>Aidiakapi wrote this in a comment below:</source>
          <target state="translated">アイディアカピさんが下のコメントで書いていました。</target>
        </trans-unit>
        <trans-unit id="a54a3ffda19eea85fbc25119ad4dce8fb1e843e4" translate="yes" xml:space="preserve">
          <source>All returns true and you may not want this. Let's suppose you have a function that can return the 0th index of an array or false on failure. If you check with &quot;==&quot; false, you can get a confusing result.</source>
          <target state="translated">すべてが真を返すので、これは望まないかもしれません。配列の0番目のインデックスを返すか、失敗した場合にfalseを返す関数があるとしましょう。&quot;==&quot; falseでチェックしてしまうと、混乱を招く結果になってしまいます。</target>
        </trans-unit>
        <trans-unit id="8742264e60f01ff6e597018b6c9b30ad6c84fa0b" translate="yes" xml:space="preserve">
          <source>An interesting pictorial representation of the equality comparison between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; と &lt;code&gt;===&lt;/code&gt; の間の等価比較の興味深い絵の表現。</target>
        </trans-unit>
        <trans-unit id="8c1a994f0cb44644f821ea4b44798e564cbb1e78" translate="yes" xml:space="preserve">
          <source>And it doesn't end there, here's another one:</source>
          <target state="translated">それだけでは終わらない、別のものがあります。</target>
        </trans-unit>
        <trans-unit id="fcab40bf0cf2cc434eb0ce086ee4dfadcbc91121" translate="yes" xml:space="preserve">
          <source>And this finally means: &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">そして、これは最後に次を意味します： &lt;strong&gt;new String（ &quot;a&quot;）！== &quot;a&quot;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c997d053fe7d55a1f5eb3f9358b3b7760fec29e8" translate="yes" xml:space="preserve">
          <source>And this is just the crazy stuff you get with primitives.</source>
          <target state="translated">そしてこれはプリミティブを使っているからこそのキチガイっぷりですね。</target>
        </trans-unit>
        <trans-unit id="9353a89820dfa87107beffc7a1a273e498311936" translate="yes" xml:space="preserve">
          <source>Another common example:</source>
          <target state="translated">他にもよくある例。</target>
        </trans-unit>
        <trans-unit id="bb0313b7b5d894d38b25b3429130ff71d7450726" translate="yes" xml:space="preserve">
          <source>Any performance improvement would be welcomed as many comparison operators exist.</source>
          <target state="translated">多くの比較演算子が存在するため、パフォーマンスの向上は歓迎されます。</target>
        </trans-unit>
        <trans-unit id="ebdf4e9004e5ae311bc10c04cc1657d844cc2b1e" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, I would generally use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (and &lt;code&gt;!==&lt;/code&gt; instead of &lt;code&gt;!=&lt;/code&gt;).</source>
          <target state="translated">経験則として、私は一般的に &lt;code&gt;==&lt;/code&gt; の代わりに &lt;code&gt;===&lt;/code&gt; を使用します（そして &lt;code&gt;!=&lt;/code&gt; の代わりに！ &lt;code&gt;!==&lt;/code&gt; 使用します ）。</target>
        </trans-unit>
        <trans-unit id="13b3f53e194e780033d076d6dfdef27478b25e97" translate="yes" xml:space="preserve">
          <source>As the conclusion states:</source>
          <target state="translated">結論から言うと</target>
        </trans-unit>
        <trans-unit id="2c8f8302c2c50753cc3fc038d29edd38e7d27241" translate="yes" xml:space="preserve">
          <source>At this point your probably wondering...</source>
          <target state="translated">この時点であなたはおそらく疑問に思っている...</target>
        </trans-unit>
        <trans-unit id="78a365d1c42cbfa956f22145534e940bf6aa204f" translate="yes" xml:space="preserve">
          <source>Because it's complicated it's hard to know what's going to happen when you use it.</source>
          <target state="translated">ややこしいから、使ってみたらどうなるかわからない。</target>
        </trans-unit>
        <trans-unit id="6d67a31310a8174d28abedb216692a809603aaa3" translate="yes" xml:space="preserve">
          <source>But how about this?:</source>
          <target state="translated">でも、これはどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="c0360df7ca51ade50469aaf2a05a01615c88e9dd" translate="yes" xml:space="preserve">
          <source>But personally I would do what JSLint suggests. This recommendation is there not because of performance issues, but because type coercion means &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; is true.</source>
          <target state="translated">しかし、個人的にはJSLintが提案することを行います。 この推奨事項は、パフォーマンスの問題のためではなく、型の強制が &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; であることを意味するためです。</target>
        </trans-unit>
        <trans-unit id="fbdab286eda606977bf3a9c58a18c188200a37c4" translate="yes" xml:space="preserve">
          <source>Common example:</source>
          <target state="translated">一般的な例です。</target>
        </trans-unit>
        <trans-unit id="f64d819276a8e60d2cf4282031ed91641ea77411" translate="yes" xml:space="preserve">
          <source>ECMA-262 is the specification for a scripting language of which JavaScript is a dialect. Of course in practice it matters more how the most important browsers behave than an esoteric definition of how something is supposed to be handled. But it is helpful to understand why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">ECMA-262は、JavaScriptが方言であるスクリプト言語の仕様です。 もちろん実際には、最も重要なブラウザがどのように動作するかという難解な定義よりも、ブラウザがどのように動作するかが重要です。 しかし、なぜ&lt;strong&gt;新しいString（ &quot;a&quot;）！== &quot;a&quot;なの&lt;/strong&gt;かを理解しておくと役に立ちます。</target>
        </trans-unit>
        <trans-unit id="dd5ffe9d4172fd93e2644ec55bff755f2376bde5" translate="yes" xml:space="preserve">
          <source>EQUAL OPERATOR TRUTH TABLE IN JAVASCRIPT</source>
          <target state="translated">javascriptでの等演算子真理値表</target>
        </trans-unit>
        <trans-unit id="c0cc6f9b7554c74df1b7cae7c6ef1f64783063e0" translate="yes" xml:space="preserve">
          <source>Each row in the table is a set of 3 mutually &quot;equal&quot; values, meaning that any 2 values among them are equal using the equal == sign*</source>
          <target state="translated">表の各行は、3つの相互に「等しい」値の集合であり、その中のどの2つの値も、等しい==記号*を使って等しいことを意味します。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58b2ed100a4c02f3e223f19e77f4fc970f37bc3e" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&quot;a == b&quot;&lt;/strong&gt; to evaluate to true a and b need to be the &lt;strong&gt;same value&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;「a == b」&lt;/strong&gt;が真と評価されるためには、aとbが&lt;strong&gt;同じ値である&lt;/strong&gt;必要があり&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="38827ea4d22912a8579010ad9d43caaae3a33e79" translate="yes" xml:space="preserve">
          <source>For example jQuery 1.9.1 uses this pattern 43 times, and  the &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;JSHint syntax checker&lt;/a&gt; even provides the &lt;code&gt;eqnull&lt;/code&gt; relaxing option for this reason.</source>
          <target state="translated">たとえば、jQuery 1.9.1はこのパターンを43回使用し、 &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;JSHint構文チェッカー&lt;/a&gt;はこの理由で &lt;code&gt;eqnull&lt;/code&gt; 緩和オプションさえ提供します。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="3b5af0e25b6d033fced42a264a3e0862e363a6cc" translate="yes" xml:space="preserve">
          <source>For example, if you have:</source>
          <target state="translated">例えば、あなたが持っている場合。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="93d53aae8f4cbac1a7160cd657ddf2e114550792" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;jQuery style guide&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;jQueryスタイルガイドから&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="519a4ac6eaa68eb2f5a55813ad6c7b39e2e3c9a5" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;core javascript reference&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;コアJavaScriptリファレンスから&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33d6d15bce91547d5c6e839acec0e386194d3e54" translate="yes" xml:space="preserve">
          <source>From the specification</source>
          <target state="translated">仕様書より</target>
        </trans-unit>
        <trans-unit id="078ecfcf86b689086aece409c4dd9d3597272bc8" translate="yes" xml:space="preserve">
          <source>Google for implicit conversions in C++ and &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; to get some of the arguments against it...</source>
          <target state="translated">GoogleはC ++および&lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt;で暗黙の変換を行い、それに対するいくつかの引数を取得します...</target>
        </trans-unit>
        <trans-unit id="5532825dcc419a2c608b4660ff4df27ee7b64e3b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; do not have values. Whereas, 0, false and '' are all values. One thing common beween all these are that they are all falsy values, which means they all &lt;strong&gt;satisfy&lt;/strong&gt; falsy conditions.</source>
          <target state="translated">ここ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; とbには値がありません。 一方、0、false、 ''はすべて値です。 これらすべての共通点は、すべて偽の値であること、つまりすべて&lt;strong&gt;が&lt;/strong&gt;偽の条件を満たすことです。</target>
        </trans-unit>
        <trans-unit id="4f47052c940a268ebe245314f782cc99b18f0d6e" translate="yes" xml:space="preserve">
          <source>Here is a handy comparison table that shows the conversions that happen and the differences between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">以下は、発生する変換と &lt;code&gt;==&lt;/code&gt; と &lt;code&gt;===&lt;/code&gt; の違いを示す便利な比較表です。</target>
        </trans-unit>
        <trans-unit id="2e780233b6b8ef08d4cfd3eb493ce561f782434f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;==&lt;/code&gt; operator is checking the values of the two objects and returning &lt;code&gt;true&lt;/code&gt;, but the &lt;code&gt;===&lt;/code&gt; is seeing that they're not the same type and returning &lt;code&gt;false&lt;/code&gt;.  Which one is correct?  That really depends on what you're trying to compare.  My advice is to bypass the question entirely and just don't use the &lt;code&gt;String&lt;/code&gt; constructor to create string objects.</source>
          <target state="translated">ここで &lt;code&gt;==&lt;/code&gt; 演算子は2つのオブジェクトの値をチェックして &lt;code&gt;true&lt;/code&gt; を返していますが、 &lt;code&gt;===&lt;/code&gt; はそれらが同じ型ではなく、 &lt;code&gt;false&lt;/code&gt; を返しています 。 どちらが正しいですか？ それは本当にあなたが比較しようとしているものに依存します。 私のアドバイスは、質問を完全にバイパスし、 &lt;code&gt;String&lt;/code&gt; コンストラクターを使用して文字列オブジェクトを作成しないことです。</target>
        </trans-unit>
        <trans-unit id="7108ec5478e370309fc5357c0e971bd4f05bbf90" translate="yes" xml:space="preserve">
          <source>However there is &lt;strong&gt;one single exception&lt;/strong&gt;:
&lt;code&gt;== null&lt;/code&gt; is an efficient way to check for 'is null or undefined':</source>
          <target state="translated">ただし、 &lt;strong&gt;1つの例外があります&lt;/strong&gt; 。 &lt;code&gt;== null&lt;/code&gt; は、「is nullまたはundefined」かどうかを確認する効率的な方法です。</target>
        </trans-unit>
        <trans-unit id="f0d30f93bb4df391284d009844ff1535f26f2082" translate="yes" xml:space="preserve">
          <source>I tested this in Firefox with &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; using code like this:</source>
          <target state="translated">私は次のようなコードを使用して、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt;を搭載したFirefoxでこれをテストしました。</target>
        </trans-unit>
        <trans-unit id="7b1c18acfb2da322223032a6ca65bcb729f0ddd1" translate="yes" xml:space="preserve">
          <source>I thought strings behave like value types? Well, it depends who you ask... In this case a and b are not the same type. &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;Object&lt;/code&gt;, while &lt;code&gt;b&lt;/code&gt; is of type &lt;code&gt;string&lt;/code&gt;. Just remember that creating a string object using the &lt;code&gt;String&lt;/code&gt; constructor creates something of type &lt;code&gt;Object&lt;/code&gt; that behaves as a string &lt;em&gt;most of the time&lt;/em&gt;.</source>
          <target state="translated">文字列は値型のように動作すると思いましたか？ まあ、それはあなたが誰に尋ねるかによります...この場合、aとbは同じ型ではありません。 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;Object&lt;/code&gt; 型で、 &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;string&lt;/code&gt; 型です。 &lt;code&gt;String&lt;/code&gt; コンストラクタを使用して文字列オブジェクトを作成すると、 &lt;em&gt;ほとんどの場合&lt;/em&gt;文字列として動作する &lt;code&gt;Object&lt;/code&gt; 型のオブジェクトが作成されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6724c10b1c4dd89e994b59c7b65ce998cb53f9b0" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;JSLint&lt;/a&gt; to go through JavaScript, and it's returning many suggestions to replace &lt;code&gt;==&lt;/code&gt; (two equals signs) with &lt;code&gt;===&lt;/code&gt; (three equals signs) when doing things like comparing &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; inside of an &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">JavaScriptを&lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;通過&lt;/a&gt;するためにJSLintを使用していて、 &lt;code&gt;if&lt;/code&gt; の内部で &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; 比較するようなものを実行すると、 &lt;code&gt;==&lt;/code&gt; （2つの等号）を &lt;code&gt;===&lt;/code&gt; （3つの等号）に置き換える多くの提案が返されますステートメント。</target>
        </trans-unit>
        <trans-unit id="699383a3720b89c508893f13174fcc345a333a00" translate="yes" xml:space="preserve">
          <source>If Type(constructor) is not Object, throw a TypeError exception.</source>
          <target state="translated">Type(コンストラクタ)がObjectでない場合は、TypeError例外をスローします。</target>
        </trans-unit>
        <trans-unit id="7c1b47bf6a1abbf554dbd0ee2168db0b303f1c1f" translate="yes" xml:space="preserve">
          <source>If both operands of == are objects, then they are compared to see if they are the same object. If both operands point to the same object, then the equal operator returns true. Otherwise,
the two are not equal.</source>
          <target state="translated">の両方のオペランドがオブジェクトである場合、それらが同じオブジェクトであるかどうかを比較します。両方のオペランドが同じオブジェクトを指している場合、イコール演算子は真を返します。そうでない場合は、2つは等しくありません。</target>
        </trans-unit>
        <trans-unit id="cbb1a99493847058458e46837af0fc9a5702b63e" translate="yes" xml:space="preserve">
          <source>If no type conversion takes place, would there be a performance gain over &lt;code&gt;==&lt;/code&gt;?</source>
          <target state="translated">タイプ変換が行われない場合、 &lt;code&gt;==&lt;/code&gt; よりもパフォーマンスが向上しますか？</target>
        </trans-unit>
        <trans-unit id="e27332524b113dae22c09288bee3e0f34778ca3c" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;HAVE TO&lt;/strong&gt; live with it, then remember the following 3 things:</source>
          <target state="translated">一緒に暮らす必要がある場合は、次の3つの点に注意してください。</target>
        </trans-unit>
        <trans-unit id="ba83b649d7ac77ee88b91662e9dc19d8d2569046" translate="yes" xml:space="preserve">
          <source>If you wonder why &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; does not return a string, how about some exercise reading a specification? Have fun!</source>
          <target state="translated">&lt;strong&gt;new String（ &quot;a&quot;）&lt;/strong&gt;が文字列を返さない理由がわからない場合は、仕様を読んでみてはいかがですか。 楽しんで！</target>
        </trans-unit>
        <trans-unit id="318588db3ab6c1c4c50c1ae4dd7cb47bf8189bab" translate="yes" xml:space="preserve">
          <source>In JavaScript it means of the same value and type.</source>
          <target state="translated">JavaScriptでは、同じ値と型を意味します。</target>
        </trans-unit>
        <trans-unit id="4bbc85798100e8a6c2b8173b4c4cc5ff26f86121" translate="yes" xml:space="preserve">
          <source>In PHP and JavaScript, it is a strict equality operator. Which means, it will compare both type and values.</source>
          <target state="translated">PHPやJavaScriptでは、これは厳密な平等演算子です。つまり、型と値の両方を比較します。</target>
        </trans-unit>
        <trans-unit id="0fd01d3c121d1dd02e0aad7a9a25393961f9968a" translate="yes" xml:space="preserve">
          <source>In a typical script there will be no performance difference. More important may be the fact that thousand &quot;===&quot; is 1&amp;nbsp;KB heavier than thousand &quot;==&quot; :) &lt;a href=&quot;https://stackoverflow.com/questions/tagged/javascript+performance&quot;&gt;JavaScript profilers&lt;/a&gt; can tell you if there is a performance difference in your case.</source>
          <target state="translated">典型的なスクリプトでは、パフォーマンスの違いはありません。 さらに重要なのは、1,000の「===が1000の「==」より1 KB重い」という事実かもしれません。</target>
        </trans-unit>
        <trans-unit id="0e42d567a09b4ba932e88964ee9b8587449c04d9" translate="yes" xml:space="preserve">
          <source>In fact, if you tried to write a function that does what &lt;code&gt;==&lt;/code&gt; does it would look something like this:</source>
          <target state="translated">実際、 &lt;code&gt;==&lt;/code&gt; の機能を実行する関数を記述しようとすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="48c572d57b17fbc593b6830a7381e7378807a00f" translate="yes" xml:space="preserve">
          <source>In the 90% usage scenario it won't matter which one you use, but it is handy to know the difference when you get some unexpected behaviour one day.</source>
          <target state="translated">90%の利用シーンではどちらでも構わないのですが、ある日突然予期せぬ行動に出た時にその違いを知ることができるのは便利です。</target>
        </trans-unit>
        <trans-unit id="ec01264fb9d51cfefd427a17d74eb33ac1be156e" translate="yes" xml:space="preserve">
          <source>In the answers here, I didn't read anything about what &lt;strong&gt;equal&lt;/strong&gt; means. Some will say that &lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;equal and of the same type&lt;/strong&gt;, but that's not really true. It actually means that &lt;strong&gt;both operands reference the same object&lt;/strong&gt;, or in case of &lt;strong&gt;value types, have the same value&lt;/strong&gt;.</source>
          <target state="translated">ここでの答えでは、 &lt;strong&gt;平等の&lt;/strong&gt;意味については何も読みませんでした。 &lt;code&gt;===&lt;/code&gt; は&lt;strong&gt;同じ型&lt;/strong&gt;で&lt;strong&gt;同じ型を&lt;/strong&gt;意味すると言う人もいますが、それは本当ではありません。 実際には、 &lt;strong&gt;両方のオペランドが同じオブジェクトを参照する&lt;/strong&gt;か、 &lt;strong&gt;値型の&lt;/strong&gt;場合は&lt;strong&gt;同じ値を持つ&lt;/strong&gt;ことを意味し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca385d21427dba165889d58d33e6fa5704fb46b2" translate="yes" xml:space="preserve">
          <source>In the case of &lt;strong&gt;&quot;a === b&quot;&lt;/strong&gt; a and b must be the &lt;strong&gt;same value&lt;/strong&gt; and also the &lt;strong&gt;same type&lt;/strong&gt; for it to evaluate to true.</source>
          <target state="translated">&lt;strong&gt;「a === b」&lt;/strong&gt;の場合、trueと評価するには、aとbは&lt;strong&gt;同じ値&lt;/strong&gt;であり、 &lt;strong&gt;同じ型&lt;/strong&gt;でなければなりません。</target>
        </trans-unit>
        <trans-unit id="251bebdd324bcccca7535068065ec28cc534eae3" translate="yes" xml:space="preserve">
          <source>In the code above, both == and === get false because a and b are not the same objects.</source>
          <target state="translated">上のコードでは、aとbは同じオブジェクトではないので、==と==の両方がfalseになります。</target>
        </trans-unit>
        <trans-unit id="a4cd7b099967df429e07f68f296c07052c7aba52" translate="yes" xml:space="preserve">
          <source>Interesting is step 11. Yes, strings are treated as value types. But this does not explain why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;. Do we have a browser not conforming to ECMA-262?</source>
          <target state="translated">興味深いのは、ステップ11です。はい、文字列は値の型として扱われます。 しかし、これは&lt;strong&gt;new String（ &quot;a&quot;）！== &quot;a&quot;である&lt;/strong&gt;理由を説明していません。 ECMA-262に準拠していないブラウザはありますか？</target>
        </trans-unit>
        <trans-unit id="cd2c230db52d16c62fde2c29f3b5aa18ff6b95af" translate="yes" xml:space="preserve">
          <source>Is there a performance benefit to replacing &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;===&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; を &lt;code&gt;===&lt;/code&gt; に置き換えることでパフォーマンス上の利点はありますか？</target>
        </trans-unit>
        <trans-unit id="6208d5e465527e22f406b99578ad5d55c45f7cb9" translate="yes" xml:space="preserve">
          <source>It checks if same sides are equal in &lt;strong&gt;type&lt;/strong&gt; as well as &lt;strong&gt;value&lt;/strong&gt;.</source>
          <target state="translated">同じ辺の&lt;strong&gt;タイプ&lt;/strong&gt;と&lt;strong&gt;値&lt;/strong&gt;が等しいかどうかをチェックし&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b33800c6e21e7706b86e94308ae2b6ade92ea2c" translate="yes" xml:space="preserve">
          <source>It get's pretty wacky.</source>
          <target state="translated">それはかなり奇妙なことだ</target>
        </trans-unit>
        <trans-unit id="0c3489421f48aca78ca26cbeacff41a88d0a2485" translate="yes" xml:space="preserve">
          <source>It get's worse:</source>
          <target state="translated">悪化する</target>
        </trans-unit>
        <trans-unit id="2461a72119f69288570a91dd4886cf1946921ace" translate="yes" xml:space="preserve">
          <source>It has special handling for functions, special handling for nulls, undefined, strings, you name it.</source>
          <target state="translated">これは、関数のための特別な処理、ヌル、未定義、文字列などのための特別な処理を持っています。</target>
        </trans-unit>
        <trans-unit id="e7800c4331282e121e342d6b81303384bd272938" translate="yes" xml:space="preserve">
          <source>It is faster only when the types are not the same, in which case it does not try to convert types but directly returns a false.</source>
          <target state="translated">これは型が同じではない場合にのみ高速になりますが、その場合は型の変換を試みずに直接 false を返します。</target>
        </trans-unit>
        <trans-unit id="faa77444bfb36c5ba995cd19f29530d0943b04a1" translate="yes" xml:space="preserve">
          <source>It means &lt;code&gt;==&lt;/code&gt; is complicated.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; が複雑であることを意味します。</target>
        </trans-unit>
        <trans-unit id="a65b5bfaad127fd93d57e6ab192d490bc11ac353" translate="yes" xml:space="preserve">
          <source>It means &lt;strong&gt;equality without type coercion&lt;/strong&gt;
type coercion means JavaScript do not automatically convert any other data types to string data types</source>
          <target state="translated">&lt;strong&gt;型強制なしの等価性&lt;/strong&gt;型強制は、JavaScriptが他のデータ型を文字列データ型に自動的に変換しないことを意味します</target>
        </trans-unit>
        <trans-unit id="4cc792e792c928abedc18234163e220b2c90215c" translate="yes" xml:space="preserve">
          <source>It's a good thing especially if you're checking between 0 and false and null.</source>
          <target state="translated">特に0とfalseとnullの間をチェックしている場合は良いでしょう。</target>
        </trans-unit>
        <trans-unit id="76814442e2351cc8045391978fecf4190730bd23" translate="yes" xml:space="preserve">
          <source>It's a strict check test.</source>
          <target state="translated">厳しいチェックテストですね。</target>
        </trans-unit>
        <trans-unit id="c194b6748d81866560cca42c3ec80275ce25b0fa" translate="yes" xml:space="preserve">
          <source>It's a whole new level of crazy when you use &lt;code&gt;==&lt;/code&gt; with objects.</source>
          <target state="translated">オブジェクトで &lt;code&gt;==&lt;/code&gt; を使用すると、まったく新しいレベルのクレイジーになります。</target>
        </trans-unit>
        <trans-unit id="7e5685be28423b6fa9a147ecdfab572abc4a40a1" translate="yes" xml:space="preserve">
          <source>JSLint sometimes gives you unrealistic reasons to modify stuff. &lt;code&gt;===&lt;/code&gt; has exactly the same performance as &lt;code&gt;==&lt;/code&gt; if the types are already the same.</source>
          <target state="translated">JSLintは時々、変更する非現実的な理由を提供します。 &lt;code&gt;===&lt;/code&gt; は、タイプがすでに同じである場合、 &lt;code&gt;==&lt;/code&gt; とまったく同じパフォーマンスを発揮します。</target>
        </trans-unit>
        <trans-unit id="6f75f5a9d4e62f008ab83040158a6ea4c2ffb8de" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;===&lt;/code&gt;&lt;strong&gt;vs&lt;/strong&gt;&lt;code&gt;==&lt;/code&gt; .</source>
          <target state="translated">JavaScript &lt;code&gt;===&lt;/code&gt; &lt;strong&gt;vs&lt;/strong&gt; &lt;code&gt;==&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f50ece919837ed27b6fe25229b9c0edd82a3a80" translate="yes" xml:space="preserve">
          <source>JavaScript has two sets of equality operators: &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;, and their evil twins &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.  The good ones work the way you would expect.  If the two operands are of the same type and have the same value, then &lt;code&gt;===&lt;/code&gt; produces &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt; produces &lt;code&gt;false&lt;/code&gt;.  The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values.  the rules by which they do that are complicated and unmemorable.  These are some of the interesting cases:</source>
          <target state="translated">JavaScriptには、 &lt;code&gt;===&lt;/code&gt; と &lt;code&gt;!==&lt;/code&gt; の 2つの等価演算子のセットと、それらの邪悪な双子の &lt;code&gt;==&lt;/code&gt; と &lt;code&gt;!=&lt;/code&gt; があります。 良いものはあなたが期待するように働きます。 2つのオペランドの型が同じで値が同じ場合、 &lt;code&gt;===&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; を生成し、 &lt;code&gt;!==&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; を生成します 。 悪魔の双子は、オペランドが同じ型であるときに正しいことを行いますが、それらが異なる型である場合、値を強制しようとします。 彼らがそれを行うためのルールは複雑で、記憶に残るものではありません。 これらは興味深いケースのいくつかです：</target>
        </trans-unit>
        <trans-unit id="ddcc47139dece09713aae28867a0635754940c72" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for non strict equality / comparison '=='</source>
          <target state="translated">厳密でない等値比較'=='のJavascript実行フロー図</target>
        </trans-unit>
        <trans-unit id="c489836ec904339790b4e755108af00367792205" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for strict equality / Comparison '==='</source>
          <target state="translated">厳密な平等のためのJavascript実行フロー図 比較 '==='</target>
        </trans-unit>
        <trans-unit id="8a105feba0ec261aeed869b80ed97fd71c7d981b" translate="yes" xml:space="preserve">
          <source>Let me add this counsel:</source>
          <target state="translated">この助言を加えさせてください。</target>
        </trans-unit>
        <trans-unit id="b78f589e89c4bf85c5acdcf503fa3ce05322739a" translate="yes" xml:space="preserve">
          <source>Let me say that again:</source>
          <target state="translated">もう一度言わせてください。</target>
        </trans-unit>
        <trans-unit id="7dc48ae18a400d363e4e831b1bc3f62fa17e236b" translate="yes" xml:space="preserve">
          <source>Let's check the types of the operands. Try it out for yourself by wrapping them in &lt;strong&gt;typeof()&lt;/strong&gt;. I find that &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; is an object, and step 1 is used: return &lt;strong&gt;false&lt;/strong&gt; if the types are different.</source>
          <target state="translated">オペランドの型を確認してみましょう。 それらを&lt;strong&gt;typeof（）&lt;/strong&gt;でラップして試してみてください。 &lt;strong&gt;新しいString（ &quot;a&quot;）&lt;/strong&gt;がオブジェクトであることがわかり、ステップ1が使用されます。タイプが異なる場合は&lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b61e7aec3e99c633efdc11e39208fc2dff1d3e2c" translate="yes" xml:space="preserve">
          <source>Lets take 2 vars a and b.</source>
          <target state="translated">2つのヴァールaとbを取ってみましょう。</target>
        </trans-unit>
        <trans-unit id="cfd185a2bd37b57a50c809cfa0d84c8e0b4f3ff4" translate="yes" xml:space="preserve">
          <source>Make your life less complicated.</source>
          <target state="translated">あなたの人生を複雑にしないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="63b41e8cde051766ea25feb26773d03ab2db614d" translate="yes" xml:space="preserve">
          <source>Meaning, there is no reason to change &lt;code&gt;==&lt;/code&gt; to &lt;code&gt;===&lt;/code&gt; in a check like &lt;code&gt;if (a == 'test')&lt;/code&gt; when you know it for a fact that a can only be a String.</source>
          <target state="translated">つまり、aが文字列のみであることがわかっている場合 &lt;code&gt;if (a == 'test')&lt;/code&gt; ようなチェックで &lt;code&gt;==&lt;/code&gt; を &lt;code&gt;===&lt;/code&gt; に変更する理由はありません。</target>
        </trans-unit>
        <trans-unit id="0938c27e70c1f172175d9d18522b01f7447aea0e" translate="yes" xml:space="preserve">
          <source>Modifying a lot of code that way wastes developers' and reviewers' time and achieves nothing.</source>
          <target state="translated">そのような方法で多くのコードを修正しても、開発者やレビュアーの時間を無駄にし、何も達成できません。</target>
        </trans-unit>
        <trans-unit id="f4cefe7cd2cd184bb73ed4c344cfc83710bb0d62" translate="yes" xml:space="preserve">
          <source>My results (tested five times each and averaged):</source>
          <target state="translated">私の結果(テストを5回ずつ行い、平均化したもの)。</target>
        </trans-unit>
        <trans-unit id="f0da046224ce2dc3106a3b60cd5d194e6ba42983" translate="yes" xml:space="preserve">
          <source>Not so fast!</source>
          <target state="translated">そうはいかない!</target>
        </trans-unit>
        <trans-unit id="d5b784c68e01c822fc3215d8b23457f17bc7b95f" translate="yes" xml:space="preserve">
          <source>Now it becomes interesting:</source>
          <target state="translated">これで面白くなってきました。</target>
        </trans-unit>
        <trans-unit id="26cf870c221ea623ca6c9613122347141c9e0338" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;strong&gt;identity operator &lt;code&gt;===&lt;/code&gt; does not do type coercion&lt;/strong&gt;, and thus does not convert the values when comparing, and is therefore faster (as according to &lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;This JS benchmark&lt;/a&gt; test) as it skips one step.</source>
          <target state="translated">一方、 &lt;strong&gt;識別演算子 &lt;code&gt;===&lt;/code&gt; は型強制を行わ&lt;/strong&gt;ないため、比較時に値を変換しないため、（ &lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;このJSベンチマーク&lt;/a&gt;テストによると）1つのステップをスキップするので高速です。</target>
        </trans-unit>
        <trans-unit id="bb6871c5d84a4419ab95dc8eece8700504fdd6d6" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;==&lt;/code&gt;</source>
          <target state="translated">演算子 &lt;code&gt;==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f06b526b15c78330ed724b58112444a30169da4d" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">演算子 &lt;code&gt;===&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7a3d854bfa0266e9c4a954b8a4122785d12b7cc" translate="yes" xml:space="preserve">
          <source>Or even:</source>
          <target state="translated">あるいは、それさえも。</target>
        </trans-unit>
        <trans-unit id="596eba5f701a564c8f484f75e8abdc3dd9152672" translate="yes" xml:space="preserve">
          <source>Please let me explain how to read the specification to clarify this question. I see that in this very old topic nobody had an answer for the very strange effect. So, if you can read a specification, this will help you in your profession tremendously. It is an acquired skill. So, let's continue.</source>
          <target state="translated">この質問を明確にするための仕様書の読み方を説明させてください。私は、この非常に古いトピックでは、誰もが非常に奇妙な効果についての答えを持っていなかったことを見ています。だから、もしあなたが仕様書を読むことができれば、これはあなたの職業にとてつもなく役立つでしょう。それは後天的なスキルです。ということで、続けてみましょう。</target>
        </trans-unit>
        <trans-unit id="2a07e2d0f6f8e8b2cf427f387c24f9c27a381095" translate="yes" xml:space="preserve">
          <source>Reasons are explained in in the answers above and also Douglas Crockford is pretty clear about it (&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;).</source>
          <target state="translated">理由は上記の回答で説明されており、Douglas Crockfordもそれについてかなり明確です（ &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript：The Good Parts&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d15ebe82de3e2a210aaf6dba6213d7558919e153" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;Javascript Tutorial: Comparison Operators&lt;/a&gt;</source>
          <target state="translated">リファレンス： &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;JavaScriptチュートリアル：比較演算子&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ea0f0fa0757bccc8812f547b6f8ef97346e64a" translate="yes" xml:space="preserve">
          <source>Returns true if both operands are equal and of the same type. It's generally 
better and safer if you compare this way, because there's no behind-the-scenes type conversions.</source>
          <target state="translated">両方のオペランドが等しく、同じ型であれば真を返します。この方法で比較した方が、裏で型変換が行われないので、一般的にはより良く、より安全です。</target>
        </trans-unit>
        <trans-unit id="957512be3223fc2dc3834f75c1dd58acecceff86" translate="yes" xml:space="preserve">
          <source>Returns true, when both operands are equal. The operands are converted to the same type before being compared.</source>
          <target state="translated">両方のオペランドが等しい場合、trueを返します。オペランドは、比較される前に同じ型に変換されます。</target>
        </trans-unit>
        <trans-unit id="38ce9002bb36040cd6c2edf6d1d18fcb9a616b7a" translate="yes" xml:space="preserve">
          <source>Searching the PDF file for === brings me to page 56 of the specification: &lt;strong&gt;11.9.4. The Strict Equals Operator ( === )&lt;/strong&gt;, and after wading through the specificationalese I find:</source>
          <target state="translated">PDFファイルで===を検索すると、仕様の56ページに&lt;strong&gt;移動します。&lt;/strong&gt; &lt;strong&gt;Strict Equals演算子（===）&lt;/strong&gt; 、およびspecaleseを調べた後、次のことがわかります。</target>
        </trans-unit>
        <trans-unit id="91af0d8b760b9aafb600d14166c0c131354b13a6" translate="yes" xml:space="preserve">
          <source>Simply</source>
          <target state="translated">Simply</target>
        </trans-unit>
        <trans-unit id="64c21976a1564e95206be932a9271ff8e6100731" translate="yes" xml:space="preserve">
          <source>So I'd say that the miniscule difference (this is over 100000 iterations, remember) is negligible. Performance &lt;strong&gt;&lt;em&gt;isn't&lt;/em&gt;&lt;/strong&gt; a reason to do &lt;code&gt;===&lt;/code&gt;. Type safety (well, as safe as you're going to get in JavaScript), and code quality is.</source>
          <target state="translated">したがって、ごくわずかな違い（これは10万回以上の反復であることに注意してください）は無視できると言えます。 &lt;code&gt;===&lt;/code&gt; を実行する理由&lt;strong&gt;&lt;em&gt;は&lt;/em&gt;&lt;/strong&gt;パフォーマンスで&lt;strong&gt;&lt;em&gt;はありません&lt;/em&gt;&lt;/strong&gt; 。 タイプセーフ（まあ、JavaScriptで取得するのと同じくらい安全です）で、コードの品質は安全です。</target>
        </trans-unit>
        <trans-unit id="ae0f3a56366851cea007b0cc3ec71cfe6236267c" translate="yes" xml:space="preserve">
          <source>So with the same thing as above, but a strict test:</source>
          <target state="translated">だから、上記と同じようなことで、厳密なテストをします。</target>
        </trans-unit>
        <trans-unit id="3c48ceb341b7974b0c35d68232de996773594700" translate="yes" xml:space="preserve">
          <source>So, &lt;em&gt;IMHO,&lt;/em&gt; JSLint maybe used to write new code, but useless over-optimizing should be avoided at all costs.</source>
          <target state="translated">したがって、 &lt;em&gt;私見、&lt;/em&gt; JSLintは新しいコードの記述に使用される可能性がありますが、無駄な過剰最適化は絶対に避けなければなりません。</target>
        </trans-unit>
        <trans-unit id="f5331af50eaf804f03f6a6159c25f1bb07cd7a40" translate="yes" xml:space="preserve">
          <source>So, let's take the following code:</source>
          <target state="translated">そこで、以下のコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="93b72b7d5b6694715afdca6d3fa8931c4d1db958" translate="yes" xml:space="preserve">
          <source>So, the 0, false and '' together form a sub-group. And on other hand, null &amp;amp; undefined form the second sub-group. Check the comparisons in the below image. null and undefined would equal. The other three would equal to each other. But, they all are treated as falsy conditions in JavaScript.</source>
          <target state="translated">したがって、0、false、および ''は一緒にサブグループを形成します。 一方、null＆undefinedは2番目のサブグループを形成します。 下の画像で比較を確認してください。 nullとundefinedは等しくなります。 他の3つは互いに等しくなります。 しかし、それらはすべてJavaScriptでは偽の条件として扱われます。</target>
        </trans-unit>
        <trans-unit id="1a279fa74ab72ad3bcba6d6c656bd5ebc3d0eab4" translate="yes" xml:space="preserve">
          <source>Strict equality checks (===) should be used in favor of ==. The only
  exception is when checking for undefined and null by way of null.</source>
          <target state="translated">厳密な平等性チェック(===)は==の方が有利です。 唯一の例外は、nullを使って未定義やnullをチェックする場合です。</target>
        </trans-unit>
        <trans-unit id="1d6d9051f3abc1e1858ebeb652dd4b2cace2ad46" translate="yes" xml:space="preserve">
          <source>Strings are not value types, but in Javascript they behave like value types, so they will be &quot;equal&quot; when the characters in the string are the same and when they are of the same length (as explained in the third rule)</source>
          <target state="translated">文字列は値の型ではありませんが、Javascriptでは値の型と同じように振る舞いますので、文字列の文字が同じで長さが同じであれば「等しい」ことになります(第3のルールで説明しています)。</target>
        </trans-unit>
        <trans-unit id="2fc95a3daa32ef795b3db44197ca06a9161c6605" translate="yes" xml:space="preserve">
          <source>Strings: the special case...</source>
          <target state="translated">文字列:特殊な場合...</target>
        </trans-unit>
        <trans-unit id="0a10f80e947919598b83985df0a922cea18c825f" translate="yes" xml:space="preserve">
          <source>Take the following example</source>
          <target state="translated">以下の例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="34d15b0c36f8c3a873f0aa9868dd4a2ce99ed153" translate="yes" xml:space="preserve">
          <source>That's to say: if both operands of == are objects, == behaves same as ===, which also means identity. The essential difference of this two operators is about type conversion. == has conversion before it checks equality, but === does not.</source>
          <target state="translated">つまり、==のオペランドが両方ともオブジェクトであれば、==は===と同じ動作をしますが、これは同一性を意味します。この二つの演算子の本質的な違いは型変換についてです。</target>
        </trans-unit>
        <trans-unit id="b194ffbdff61cd41449b27896d0388ad11bc6102" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator will compare for equality &lt;em&gt;after doing any necessary type conversions&lt;/em&gt;.  The &lt;code&gt;===&lt;/code&gt; operator will &lt;strong&gt;not&lt;/strong&gt; do the conversion, so if two values are not the same type &lt;code&gt;===&lt;/code&gt; will simply return &lt;code&gt;false&lt;/code&gt;. Both are equally quick.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 演算子は&lt;em&gt;、必要な型変換を行った後&lt;/em&gt; 、等しい&lt;em&gt;かどうか&lt;/em&gt;を比較します。 &lt;code&gt;===&lt;/code&gt; 演算子は変換を行わ&lt;strong&gt;ない&lt;/strong&gt;ため、2つの値が同じ型でない場合、 &lt;code&gt;===&lt;/code&gt; は単に &lt;code&gt;false&lt;/code&gt; を返します 。 どちらも同じくらい迅速です。</target>
        </trans-unit>
        <trans-unit id="94d61a1bd3d74a41d42873da5dad1d59e17caf82" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;===&lt;/strong&gt; operator is called a strict comparison operator, it &lt;strong&gt;does&lt;/strong&gt; differ from the &lt;strong&gt;==&lt;/strong&gt; operator.</source>
          <target state="translated">&lt;strong&gt;===&lt;/strong&gt;演算子は厳密比較演算子と呼ばれ、 &lt;strong&gt;==&lt;/strong&gt;演算子と&lt;strong&gt;は&lt;/strong&gt;異なります。</target>
        </trans-unit>
        <trans-unit id="6b4a3a20e019eab11a43250c848486e6d49f5365" translate="yes" xml:space="preserve">
          <source>The End.</source>
          <target state="translated">終わりだ</target>
        </trans-unit>
        <trans-unit id="afa8919ed4dc94f9cf1c114da989f410b6e7be00" translate="yes" xml:space="preserve">
          <source>The comparison x === y, where x and y are values, produces &lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;. Such a comparison is performed as follows:</source>
          <target state="translated">比較x === y（xとyは値）は、 &lt;strong&gt;true&lt;/strong&gt;または&lt;strong&gt;falseを&lt;/strong&gt;生成し&lt;strong&gt;ます&lt;/strong&gt; 。 このような比較は次のように実行されます。</target>
        </trans-unit>
        <trans-unit id="1b98b3145565493d8ec7750f669d527714ecc29b" translate="yes" xml:space="preserve">
          <source>The identity (&lt;code&gt;===&lt;/code&gt;) operator behaves identically to the equality (&lt;code&gt;==&lt;/code&gt;) operator except no type conversion is done, and the types must be the same to be considered equal.</source>
          <target state="translated">識別（ &lt;code&gt;===&lt;/code&gt; ）演算子は、型変換が行われないこと、および型が等しいと見なされるために型が同じでなければならないことを除いて、等号（ &lt;code&gt;==&lt;/code&gt; ）演算子と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="412caf725ac873e21c2342891582c7eb72241e50" translate="yes" xml:space="preserve">
          <source>The lack of transitivity is alarming.  My advice is to never use the evil twins.  Instead, always use &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;.  All of the comparisons just shown produce &lt;code&gt;false&lt;/code&gt; with the &lt;code&gt;===&lt;/code&gt; operator.</source>
          <target state="translated">推移性の欠如は憂慮すべきことです。 私のアドバイスは、邪悪な双子を決して使用しないことです。 代わりに、常に &lt;code&gt;===&lt;/code&gt; および &lt;code&gt;!==&lt;/code&gt; を使用してください 。 ここで示したすべての比較は、 &lt;code&gt;===&lt;/code&gt; 演算子で &lt;code&gt;false&lt;/code&gt; を生成します 。</target>
        </trans-unit>
        <trans-unit id="e2ca5becda5d8c525a92af853383dd2f554be5e6" translate="yes" xml:space="preserve">
          <source>The problem is that you might easily get into trouble since JavaScript have a lot of implicit conversions meaning...</source>
          <target state="translated">問題は、JavaScriptには暗黙の変換の意味がたくさんあるので、トラブルに巻き込まれやすいかもしれません...。</target>
        </trans-unit>
        <trans-unit id="1c5cdbf6f285cc357902c21867d22dceaabbfb07" translate="yes" xml:space="preserve">
          <source>The rule is:</source>
          <target state="translated">ルールは</target>
        </trans-unit>
        <trans-unit id="34e5356fba8841d2e384644ac7191e706b9b383b" translate="yes" xml:space="preserve">
          <source>The same here:</source>
          <target state="translated">ここも同じです。</target>
        </trans-unit>
        <trans-unit id="ac6a25542b0ec2ff99281bcf844b6b748cb989bf" translate="yes" xml:space="preserve">
          <source>The special case is when you compare a literal with an object that evaluates to the same literal, due to its &lt;code&gt;toString&lt;/code&gt; or &lt;code&gt;valueOf&lt;/code&gt; method. For example, consider the comparison of a string literal with a string object created by the &lt;code&gt;String&lt;/code&gt; constructor.</source>
          <target state="translated">特殊なケースは、リテラルを、 &lt;code&gt;toString&lt;/code&gt; または &lt;code&gt;valueOf&lt;/code&gt; メソッドが原因で、同じリテラルに評価されるオブジェクトと比較する場合です。 たとえば、文字列リテラルと、文字 &lt;code&gt;String&lt;/code&gt; コンストラクターによって作成された文字列オブジェクトとの比較を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="deec20d89955518508df750a0325916894b132b6" translate="yes" xml:space="preserve">
          <source>The top 2 answers both mentioned == means equality and === means identity. Unfortunately, this statement is incorrect.</source>
          <target state="translated">上位2つの回答では、どちらも==は平等を意味し、==は同一性を意味しています。残念ながら、この文は間違っています。</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="7e6e25d889bccff4888c16c5091398046e021bd5" translate="yes" xml:space="preserve">
          <source>There is unlikely to be any performance difference between the two operations in your usage. There is no type-conversion to be done because both parameters are already the same type. Both operations will have a type comparison followed by a value comparison.</source>
          <target state="translated">あなたの使用法では、2つの操作の間にパフォーマンスの差があるとは考えられません。両方のパラメータはすでに同じ型なので、型変換は行われません。どちらの操作も型の比較の後に値の比較が行われます。</target>
        </trans-unit>
        <trans-unit id="d0addef10584dbb6993cff27164cee0b6c70c9f9" translate="yes" xml:space="preserve">
          <source>This behavior is not always obvious. There's more to the story than being equal and being of the same type.</source>
          <target state="translated">この行動は、必ずしも明らかなものではありません。対等であることと、同じタイプであること以外にも色々あります。</target>
        </trans-unit>
        <trans-unit id="10b32091fa5a9c7a5536dd0b8d0dbc5d56df3f1a" translate="yes" xml:space="preserve">
          <source>This is because the &lt;strong&gt;equality operator &lt;code&gt;==&lt;/code&gt; does type coercion&lt;/strong&gt;, meaning that the interpreter implicitly tries to convert the values before comparing.</source>
          <target state="translated">これは、 &lt;strong&gt;等価演算子 &lt;code&gt;==&lt;/code&gt; が型強制&lt;/strong&gt;を行うためです。つまり、インタープリターは比較する前に暗黙的に値を変換しようとします。</target>
        </trans-unit>
        <trans-unit id="e099919ae099449d50619707a595101be1938525" translate="yes" xml:space="preserve">
          <source>This is same as any object (like {}, arrays, etc.), non-empty string &amp;amp; Boolean true are all truthy conditions. But, they are all not equal.</source>
          <target state="translated">これは他のオブジェクト（{}、配列など）と同じです。空でない文字列とブール値trueはすべて真の条件です。 しかし、それらはすべて同じではありません。</target>
        </trans-unit>
        <trans-unit id="c01421dd6e3a97aa7a750d67645c9ce033722624" translate="yes" xml:space="preserve">
          <source>To quote Douglas Crockford's excellent &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;,</source>
          <target state="translated">Douglas Crockfordの優れた&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript：The Good Parts&lt;/a&gt;を引用すると、</target>
        </trans-unit>
        <trans-unit id="1b6611f5af4feb0209552e588441f461e4827c57" translate="yes" xml:space="preserve">
          <source>Type conversion in javaScript means javaScript automatically convert any other data types to string data types.</source>
          <target state="translated">javaScriptの型変換とは、javaScriptが他のデータ型を自動的に文字列データ型に変換することです。</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="2dd151cc35444f22efefaf2a4c9200a524eabcbb" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; の代わりに &lt;code&gt;===&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4c453d7e21f4c791a03dcc4a981e5605615b7d07" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;==&lt;/code&gt; operator (&lt;em&gt;Equality&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 演算子の使用（ &lt;em&gt;Equality&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="513b5a2751665a1919f797ca492150f5a95e5dbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;===&lt;/code&gt; operator (&lt;em&gt;Identity&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 演算子（ &lt;em&gt;Identity&lt;/em&gt; ）の使用</target>
        </trans-unit>
        <trans-unit id="49fae091b162654343089eb4ba3ab8ccdfc467f0" translate="yes" xml:space="preserve">
          <source>Well it's because unlike &quot;triple equals&quot; (&lt;code&gt;===&lt;/code&gt;) which just checks if two values are the same.</source>
          <target state="translated">まあそれは、2つの値が同じかどうかをチェックするだけの &quot;トリプルイコール&quot;（ &lt;code&gt;===&lt;/code&gt; ）とは異なります。</target>
        </trans-unit>
        <trans-unit id="fbbea6dde2ab91a36ff23b57623dc1796e371116" translate="yes" xml:space="preserve">
          <source>What do you get when you compare an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; with the number zero &lt;code&gt;0&lt;/code&gt;?</source>
          <target state="translated">空の文字列 &lt;code&gt;&quot;&quot;&lt;/code&gt; と数字のゼロ &lt;code&gt;0&lt;/code&gt; を比較すると何がわかりますか？</target>
        </trans-unit>
        <trans-unit id="67709d0522046140afbdae10c9f80a805117bee6" translate="yes" xml:space="preserve">
          <source>Which equals operator (== vs ===) should be used in JavaScript comparisons</source>
          <target state="translated">JavaScriptの比較でどの等号演算子(==vs ===)を使うべきか?</target>
        </trans-unit>
        <trans-unit id="697e4e154c1261a7e33818edccc744a4d570a31e" translate="yes" xml:space="preserve">
          <source>Which means you could end up with bugs.</source>
          <target state="translated">つまり、バグで終わる可能性があるということです。</target>
        </trans-unit>
        <trans-unit id="d141d97a7a3ac22b01fd1cd75711d31e277f0a28" translate="yes" xml:space="preserve">
          <source>Which obviously during runtime does &lt;em&gt;very&lt;/em&gt; undefined things...</source>
          <target state="translated">これは明らかに実行時&lt;em&gt;に非常に&lt;/em&gt;未定義のことをします...</target>
        </trans-unit>
        <trans-unit id="36933ceea4f2db404d028c82e6364a36ace968a0" translate="yes" xml:space="preserve">
          <source>Which pretty soon becomes a problem. The best sample of why implicit conversion is &quot;evil&quot; can be taken from this code in &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C++ which actually will compile due to an implicit conversion from CString to HANDLE which is a pointer typedef type...</source>
          <target state="translated">これはすぐに問題になります。 暗黙の変換が「悪」である理由の最良のサンプルは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C ++のこのコードから取得できます。これは、CStringからポインターのtypedef型であるHANDLEへの暗黙の変換により実際にコンパイルされます...</target>
        </trans-unit>
        <trans-unit id="9fcac86aac0009e66019e4c27ea46100eaf900a2" translate="yes" xml:space="preserve">
          <source>With other words, if String wouldn't be of type Object it couldn't be used with the new operator.</source>
          <target state="translated">つまり、String が Object 型でない場合は、新しい演算子を使うことができません。</target>
        </trans-unit>
        <trans-unit id="45903fac0ea3c75afe550d2440dc48b77fd3f572" translate="yes" xml:space="preserve">
          <source>Yep, that's right according to &lt;code&gt;==&lt;/code&gt; an empty string and the number zero are the same time.</source>
          <target state="translated">うん、そうです &lt;code&gt;==&lt;/code&gt; 空の文字列と数値ゼロは同じ時間です。</target>
        </trans-unit>
        <trans-unit id="eabbe6442a6f27defee150f80d6147176f73513a" translate="yes" xml:space="preserve">
          <source>You can easily test it. Paste following code in an HTML file and open it in browser</source>
          <target state="translated">簡単にテストできます。以下のコードをHTMLファイルに貼り付けてブラウザで開いてください。</target>
        </trans-unit>
        <trans-unit id="5da640618827894fedb5feef195dd55437e5bda8" translate="yes" xml:space="preserve">
          <source>You will get '&lt;strong&gt;false&lt;/strong&gt;' in alert. Now modify the &lt;code&gt;onPageLoad()&lt;/code&gt; method to &lt;code&gt;alert(x == 5);&lt;/code&gt; you will get &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">警告では「 &lt;strong&gt;false&lt;/strong&gt; 」が表示されます。 次に、 &lt;code&gt;onPageLoad()&lt;/code&gt; メソッドを &lt;code&gt;alert(x == 5);&lt;/code&gt; あなたは&lt;strong&gt;真実&lt;/strong&gt;になり&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="786e97b3ee9fc4b292d5852c2c5943153c4ce91a" translate="yes" xml:space="preserve">
          <source>but</source>
          <target state="translated">but</target>
        </trans-unit>
        <trans-unit id="550f8bc02aebdb930e2ff4b54cf6677ee045437c" translate="yes" xml:space="preserve">
          <source>null and undefined are nothingness, that is,</source>
          <target state="translated">ヌルと未定義は無意味である、つまり。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
