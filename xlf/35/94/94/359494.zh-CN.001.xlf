<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/359494">
    <body>
      <group id="359494">
        <trans-unit id="130bf5785915eb04e8a94d3a41ec118bd8e8f0d8" translate="yes" xml:space="preserve">
          <source>&quot;Use three equals unless you fully understand the conversions that take
  place for two-equals.&quot;</source>
          <target state="translated">&quot;除非你完全理解二等式的转换,否则就用三等式。&quot;</target>
        </trans-unit>
        <trans-unit id="54f697a1ff421e46f37022813a88d0937a82090c" translate="yes" xml:space="preserve">
          <source>&amp;amp;</source>
          <target state="translated">&amp;amp;</target>
        </trans-unit>
        <trans-unit id="dea7f7f48b6202dbcdd6e2f0b470c1320197a1b3" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;1. If Type(x) is different from Type(y), return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">1.如果Type（x）与Type（y）不同，则返回&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="128316503370069a1f99b4764d5a503e65225aa7" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;10. Return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">10.返回&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f94476563997f8d2da2e6fdfb6b36c68ec81051" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;11. If Type(x) is String, then return &lt;strong&gt;true&lt;/strong&gt; if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">11.如果Type（x）为String，则如果x和y是完全相同的字符序列（相同的长度和相同位置的相同字符），则返回&lt;strong&gt;true；&lt;/strong&gt;否则，返回&lt;strong&gt;true&lt;/strong&gt; 。 否则，返回&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c30077433d472cb40022cd05bbb7b0fce6d9add" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;12. If Type(x) is Boolean, return &lt;strong&gt;true&lt;/strong&gt; if x and y are both &lt;strong&gt;true&lt;/strong&gt; or both &lt;strong&gt;false&lt;/strong&gt;; otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">12.如果Type（x）为布尔值，则如果x和y均为&lt;strong&gt;true&lt;/strong&gt;或&lt;strong&gt;false&lt;/strong&gt;则返回&lt;strong&gt;true&lt;/strong&gt; ； 否则，返回&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="25f36acdf60e7d6a4df37ffedc98b9f14faf995c" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;13. Return &lt;strong&gt;true&lt;/strong&gt; if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">13.如果x和y引用相同的对象或它们引用彼此连接的对象（请参见13.1.2），则返回&lt;strong&gt;true&lt;/strong&gt; 。 否则，返回&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6754f28eced479b11eb44690f5d4fa3822beda44" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;2. If Type(x) is Undefined, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">2.如果Type（x）为Undefined，则返回&lt;strong&gt;true&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8a41404dc0e9e4b2139c7b55b00ba4f197ed1db" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;3. If Type(x) is Null, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">3.如果Type（x）为Null，则返回&lt;strong&gt;true&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="86e81311d208ba00e8a82f89a4b6f670518af9c9" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;4. If Type(x) is not Number, go to step 11.</source>
          <target state="translated">4.如果Type（x）不是Number，请转到步骤11。</target>
        </trans-unit>
        <trans-unit id="1d11aa4bb7dc1bb6eb30029e881efcb0c773c688" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;5. If x is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">5.如果x为&lt;strong&gt;NaN&lt;/strong&gt; ，则返回&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6feedc887138d0c4493e0285c20861d70ce82b0" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;6. If y is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">6.如果y为&lt;strong&gt;NaN&lt;/strong&gt; ，则返回&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b305a8dce9f7df97f238519197a73606b9ab87f2" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;7. If x is the same number value as y, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">7.如果x与y相同，则返回&lt;strong&gt;true&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b42c345a414ab1fe5a4c613c47711966027975a5" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;8. If x is +0 and y is &amp;minus;0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">8.如果x为+0且y为&amp;minus;0，则返回&lt;strong&gt;true&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e941ba4b0fdf4fcc001e64d6bd9bd26d6a81fd02" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;9. If x is &amp;minus;0 and y is +0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">9.如果x为&amp;minus;0且y为+0，则返回&lt;strong&gt;true&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="03520e1e34120f6fae6bbeb3d5eb895994c709d3" translate="yes" xml:space="preserve">
          <source>** STRANGE: note that any two values on the first column are not equal in that sense.**</source>
          <target state="translated">**变化:请注意,第一列上的任何两个值在这个意义上都不相等。</target>
        </trans-unit>
        <trans-unit id="bfadb6bfe229d17ab6eb814049a1af7e1c35942f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality and type comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;相等和类型比较：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4311a70549d246e170e5a8f1b527e5c5a19379f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;平等比较：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1ab346462c9fcef1a02b67c403e451e31987880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does a &lt;strong&gt;&lt;em&gt;whole bunch of other stuff&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 还有&lt;strong&gt;&lt;em&gt;很多其他的东西&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b338ff3f560901a0f7f2338cb21ec9ed418bce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;with&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 表示&lt;strong&gt;具有&lt;/strong&gt; &lt;code&gt;type conversion&lt;/code&gt; 操作数之间的&lt;strong&gt;比较&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9d647aeb173e83a0130624d9b11d9a6aca4c3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; operator just checks the value of the variables for equality.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 运算符只是检查变量的值是否相等。</target>
        </trans-unit>
        <trans-unit id="86a40c35943be312d26be58ed590bcd3dd325425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; Returns &lt;code&gt;true&lt;/code&gt; if the operands are strictly equal (see above)
  with no type conversion.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 如果操作数严格相等（请参见上文）且没有类型转换，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d0976f976a35ebb6ebe62b08679b2e138576dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;without&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 表示&lt;strong&gt;不进行&lt;/strong&gt; &lt;code&gt;type conversion&lt;/code&gt; 操作数之间的&lt;strong&gt;比较&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54e23978f1caf3d9c1511fb347612a2b3442e552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator  checks the values as well as the types of the variables for equality.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 运算符检查变量的值以及变量类型是否相等。</target>
        </trans-unit>
        <trans-unit id="0784b02b5003c7729e030d9b7d490e95bab806f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator in javascript &lt;strong&gt;checks value as well as type&lt;/strong&gt; where as &lt;code&gt;==&lt;/code&gt; operator just checks &lt;strong&gt;the value (does type conversion if required)&lt;/strong&gt;.</source>
          <target state="translated">javascript中的 &lt;code&gt;===&lt;/code&gt; 运算符会&lt;strong&gt;检查值以及类型&lt;/strong&gt; ，其中 &lt;code&gt;==&lt;/code&gt; 运算符仅会检查&lt;strong&gt;值（如果需要，则进行类型转换）&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e191a0a45be586c4c0bba711c1f56571fe4d8f4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both strings and contain the exact same characters</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都是字符串并且包含完全相同的字符，则 &lt;code&gt;a === b&lt;/code&gt; 返回true</target>
        </trans-unit>
        <trans-unit id="c03f97f96e2f5f2837a1f086b8eb03c59b00a165" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same value and are of the same type</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 具有相同的值并且属于相同的类型，则 &lt;code&gt;a === b&lt;/code&gt; 返回true</target>
        </trans-unit>
        <trans-unit id="0b9afde54d1a9e309f7f55b08fcee09754103a72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reference the exact same object</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 引用完全相同的对象，则 &lt;code&gt;a === b&lt;/code&gt; 返回true</target>
        </trans-unit>
        <trans-unit id="a569658b84c50eebdb4a105bf59c6e932a3a246e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;The equal comparison operator == is confusing and should be avoided.&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;相等的比较运算符==令人困惑，应避免。&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e7e53458508d6e51aeb7d6a48cf2891cadddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.2.2 The new Operator&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;11.2.2新的运营商&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="7998aff2909b6b4706d92805f6351ca4f05e7bf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.9.6 The Strict Equality Comparison Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;11.9.6严格相等比较算法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6991c2660c1bca00359ab71ad6adcfdf32c7a356" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For reference types:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;对于参考类型：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b281c590fb85b87b5d11f1a04a3b17b4b081d21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For strings:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;对于字符串：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a449c178aebbeb356e9012aeb4b469de6ac6e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For value types (numbers):&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;对于值类型（数字）：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f73c5c4818316a7e7ba83421501c2687aba89eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;If in doubt, read the &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;specification&lt;/a&gt;!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;如有疑问，请阅读&lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;规格&lt;/a&gt; ！&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b1bf8ddd0de3be690c43c624391f8937688d9e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Moral of the story:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;这个故事所讲的道德：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83c7151c0c6f7fb762f855eb85e50c829ea14a0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Use &lt;code&gt;===&lt;/code&gt; unless you fully understand the
  conversions that take place with &lt;code&gt;==&lt;/code&gt;.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;除非您完全了解 &lt;code&gt;==&lt;/code&gt; 进行的转换，否则请使用 &lt;code&gt;===&lt;/code&gt; 。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef127aa6ac9121f82176c29f76864dbb36fe4c2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;==&lt;/code&gt; for JavaScript equality testing, some
  funky conversions take place.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;当使用 &lt;code&gt;==&lt;/code&gt; 进行JavaScript相等性测试时，会发生一些时髦的转换。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77298b36a9fcbaf746d98e1bc74886ea8bbddcff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;===&lt;/code&gt; for JavaScript equality testing, everything is as is. Nothing gets converted before being evaluated.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;当使用 &lt;code&gt;===&lt;/code&gt; 进行JavaScript相等性测试时，一切保持原样。&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;在评估之前，没有任何转换。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5583d977f70290bf3ad57016e11eed7fe1b944f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of doubt, learn by heart the following truth table:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如有疑问，请认真学习以下真值表：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4e32406ca5087fb220aee87a9159a70a2cf49c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In summary&lt;/strong&gt;; using the &lt;strong&gt;==&lt;/strong&gt; operator might evaluate to true in situations where you do not want it to so using the &lt;strong&gt;===&lt;/strong&gt; operator would be safer.</source>
          <target state="translated">&lt;strong&gt;总而言之&lt;/strong&gt; ; 在您不希望使用&lt;strong&gt;===&lt;/strong&gt;运算符的情况下，使用&lt;strong&gt;==&lt;/strong&gt;运算符可能会得出true，因此使用&lt;strong&gt;===&lt;/strong&gt;运算符会更安全。</target>
        </trans-unit>
        <trans-unit id="0fc148d6649bd47fe8e2b7cf2467f19d0bf69fd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not transitive: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(b == c)&lt;/em&gt; does not lead to &lt;em&gt;(a == c)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;它不是传递的： &lt;em&gt;（a == b）&lt;/em&gt;和&lt;em&gt;（b == c）&lt;/em&gt;不会导致&lt;em&gt;（a == c）&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b0a31f565c1a8710eee82d40a2198e9e2ade2a15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's mutually exclusive to its negation: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(a != b)&lt;/em&gt; always hold opposite Boolean values, with all a and b.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;它与否定是互斥的： &lt;em&gt;（a == b）&lt;/em&gt;和&lt;em&gt;（a！= b）&lt;/em&gt;始终持有相反的布尔值，且所有a和b都存在。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2a6eb120ac5d954b7aa47baca4f35f487d47fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e15c6bff6033a446fc6a95bbcaedcb5920c62e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So the moral of the story is...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;所以这个故事的寓意是...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f68664c3d5e1f0872cc0f7095d28293c50692b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what does this mean?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;那么这是什么意思？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcffb768a62952b163df247d1df132d1d92ba1ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source: &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http://dorey.github.io/JavaScript-Equality-Table/&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;资料来源： &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http&lt;/a&gt; : //dorey.github.io/JavaScript-Equality-Table/&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3572e23516a3bbfc97277c54e9df478818214273" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Then weirder with strings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;然后用字符串怪异&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4799deaf7c2bdd75e811e68dfa65cd85a9318390" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Things get really weird with arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;事情变得很奇怪。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c6910a7c92878ee22dbd03dfb0a4072532d90db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When is equal not equal?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么时候等于不等于？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8eb43dbcbcd365843d41af200d644bb6817377de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why &lt;code&gt;==&lt;/code&gt; is so unpredictable?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么 &lt;code&gt;==&lt;/code&gt; 如此不可预测？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="158e452fe7b5ed683ae60f76da327fa38cec4251" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why does this happen?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么会这样？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3471db61bc9f6d45c5cdde69581a956986a6defd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes!&lt;/strong&gt; It does matter.</source>
          <target state="translated">&lt;strong&gt;是!&lt;/strong&gt; 这很重要。</target>
        </trans-unit>
        <trans-unit id="72675d0e476a995d0975566582a364150fca52f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;new&lt;/strong&gt; always returns an Object, even for &lt;strong&gt;String&lt;/strong&gt; constructors, too. And alas! The value semantics for strings (see step 11) is lost.</source>
          <target state="translated">即使对于&lt;strong&gt;String&lt;/strong&gt;构造函数， &lt;strong&gt;new&lt;/strong&gt;也会始终返回Object。 a！ 字符串的值语义（请参见步骤11）丢失。</target>
        </trans-unit>
        <trans-unit id="b7f0cbff18eeec5852f5ea8c1be766cd8cf6a45d" translate="yes" xml:space="preserve">
          <source>A good point was brought up by &lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt; in the comments and in &lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;@Phillipe Laybaert's&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/957602/1288&quot;&gt;answer&lt;/a&gt; concerning reference types.  For reference types &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; act consistently with one another (except in a special case).</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt;在评论中和&lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;@Phillipe Laybaert&lt;/a&gt;关于引用类型的 &lt;a href=&quot;https://stackoverflow.com/a/957602/1288&quot;&gt;答案&lt;/a&gt;中提出了一个很好的观点。 对于引用类型， &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;===&lt;/code&gt; 彼此一致（除非在特殊情况下）。</target>
        </trans-unit>
        <trans-unit id="8b54302e5ddc3ab8451d73b4e6fbcce29f1fb9c2" translate="yes" xml:space="preserve">
          <source>A simple example is</source>
          <target state="translated">一个简单的例子是</target>
        </trans-unit>
        <trans-unit id="4e666e628adc9d3ae32638bd884bee95473bd54e" translate="yes" xml:space="preserve">
          <source>Aidiakapi wrote this in a comment below:</source>
          <target state="translated">Aidiakapi在下面的评论中这样写道。</target>
        </trans-unit>
        <trans-unit id="a54a3ffda19eea85fbc25119ad4dce8fb1e843e4" translate="yes" xml:space="preserve">
          <source>All returns true and you may not want this. Let's suppose you have a function that can return the 0th index of an array or false on failure. If you check with &quot;==&quot; false, you can get a confusing result.</source>
          <target state="translated">全部返回true,你可能不希望这样。假设你有一个函数可以返回数组的第0个索引,或者失败时返回false。如果你用&quot;===&quot;false进行检查,你可能会得到一个令人困惑的结果。</target>
        </trans-unit>
        <trans-unit id="8742264e60f01ff6e597018b6c9b30ad6c84fa0b" translate="yes" xml:space="preserve">
          <source>An interesting pictorial representation of the equality comparison between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;===&lt;/code&gt; 之间的相等比较的有趣的图形表示。</target>
        </trans-unit>
        <trans-unit id="8c1a994f0cb44644f821ea4b44798e564cbb1e78" translate="yes" xml:space="preserve">
          <source>And it doesn't end there, here's another one:</source>
          <target state="translated">而且还没完没了,这里还有一个。</target>
        </trans-unit>
        <trans-unit id="fcab40bf0cf2cc434eb0ce086ee4dfadcbc91121" translate="yes" xml:space="preserve">
          <source>And this finally means: &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">这最终意味着： &lt;strong&gt;new String（&amp;ldquo; a&amp;rdquo;）！==&amp;ldquo; a&amp;rdquo;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c997d053fe7d55a1f5eb3f9358b3b7760fec29e8" translate="yes" xml:space="preserve">
          <source>And this is just the crazy stuff you get with primitives.</source>
          <target state="translated">而这只是你对原始人的疯狂的东西。</target>
        </trans-unit>
        <trans-unit id="9353a89820dfa87107beffc7a1a273e498311936" translate="yes" xml:space="preserve">
          <source>Another common example:</source>
          <target state="translated">另一个常见的例子。</target>
        </trans-unit>
        <trans-unit id="bb0313b7b5d894d38b25b3429130ff71d7450726" translate="yes" xml:space="preserve">
          <source>Any performance improvement would be welcomed as many comparison operators exist.</source>
          <target state="translated">任何性能的改进都是值得欢迎的,因为有许多比较的经营者。</target>
        </trans-unit>
        <trans-unit id="ebdf4e9004e5ae311bc10c04cc1657d844cc2b1e" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, I would generally use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (and &lt;code&gt;!==&lt;/code&gt; instead of &lt;code&gt;!=&lt;/code&gt;).</source>
          <target state="translated">根据经验，我通常使用 &lt;code&gt;===&lt;/code&gt; 代替 &lt;code&gt;==&lt;/code&gt; （和 &lt;code&gt;!==&lt;/code&gt; 代替 &lt;code&gt;!=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="13b3f53e194e780033d076d6dfdef27478b25e97" translate="yes" xml:space="preserve">
          <source>As the conclusion states:</source>
          <target state="translated">正如结论中所说:</target>
        </trans-unit>
        <trans-unit id="2c8f8302c2c50753cc3fc038d29edd38e7d27241" translate="yes" xml:space="preserve">
          <source>At this point your probably wondering...</source>
          <target state="translated">现在你可能在想.....</target>
        </trans-unit>
        <trans-unit id="78a365d1c42cbfa956f22145534e940bf6aa204f" translate="yes" xml:space="preserve">
          <source>Because it's complicated it's hard to know what's going to happen when you use it.</source>
          <target state="translated">因为它很复杂,用了之后很难知道会发生什么事情。</target>
        </trans-unit>
        <trans-unit id="6d67a31310a8174d28abedb216692a809603aaa3" translate="yes" xml:space="preserve">
          <source>But how about this?:</source>
          <target state="translated">但是,这个怎么样?</target>
        </trans-unit>
        <trans-unit id="c0360df7ca51ade50469aaf2a05a01615c88e9dd" translate="yes" xml:space="preserve">
          <source>But personally I would do what JSLint suggests. This recommendation is there not because of performance issues, but because type coercion means &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; is true.</source>
          <target state="translated">但是我个人会按照JSLint的建议去做。 出现此建议不是因为性能问题，而是因为类型强制表示 &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; 为true。</target>
        </trans-unit>
        <trans-unit id="fbdab286eda606977bf3a9c58a18c188200a37c4" translate="yes" xml:space="preserve">
          <source>Common example:</source>
          <target state="translated">常见的例子。</target>
        </trans-unit>
        <trans-unit id="f64d819276a8e60d2cf4282031ed91641ea77411" translate="yes" xml:space="preserve">
          <source>ECMA-262 is the specification for a scripting language of which JavaScript is a dialect. Of course in practice it matters more how the most important browsers behave than an esoteric definition of how something is supposed to be handled. But it is helpful to understand why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">ECMA-262是一种脚本语言的规范，其中JavaScript是方言。 当然，在实践中，最重要的浏览器的行为方式比对应该如何处理某些事物的深奥定义更为重要。 但是了解为什么&lt;strong&gt;新的String（&amp;ldquo; a&amp;rdquo;）！==&amp;ldquo; a&amp;rdquo;&lt;/strong&gt;很有帮助。</target>
        </trans-unit>
        <trans-unit id="dd5ffe9d4172fd93e2644ec55bff755f2376bde5" translate="yes" xml:space="preserve">
          <source>EQUAL OPERATOR TRUTH TABLE IN JAVASCRIPT</source>
          <target state="translated">javascript中的等值运算符真值表</target>
        </trans-unit>
        <trans-unit id="c0cc6f9b7554c74df1b7cae7c6ef1f64783063e0" translate="yes" xml:space="preserve">
          <source>Each row in the table is a set of 3 mutually &quot;equal&quot; values, meaning that any 2 values among them are equal using the equal == sign*</source>
          <target state="translated">表格中的每一行都是一组3个相互 &quot;相等 &quot;的值,这意味着其中任何2个值都是相等的,使用等号===符号*,它们之间的任何2个值都是相等的。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58b2ed100a4c02f3e223f19e77f4fc970f37bc3e" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&quot;a == b&quot;&lt;/strong&gt; to evaluate to true a and b need to be the &lt;strong&gt;same value&lt;/strong&gt;.</source>
          <target state="translated">为了使&lt;strong&gt;&amp;ldquo; a == b&amp;rdquo;&lt;/strong&gt;评估为真，a和b必须为&lt;strong&gt;相同的值&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="38827ea4d22912a8579010ad9d43caaae3a33e79" translate="yes" xml:space="preserve">
          <source>For example jQuery 1.9.1 uses this pattern 43 times, and  the &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;JSHint syntax checker&lt;/a&gt; even provides the &lt;code&gt;eqnull&lt;/code&gt; relaxing option for this reason.</source>
          <target state="translated">例如，jQuery 1.9.1使用此模式43次，因此 &lt;code&gt;eqnull&lt;/code&gt; &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;语法检查器&lt;/a&gt;甚至提供eqnull松弛选项。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="3b5af0e25b6d033fced42a264a3e0862e363a6cc" translate="yes" xml:space="preserve">
          <source>For example, if you have:</source>
          <target state="translated">比如说,如果你有:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="93d53aae8f4cbac1a7160cd657ddf2e114550792" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;jQuery style guide&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;jQuery样式指南&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="519a4ac6eaa68eb2f5a55813ad6c7b39e2e3c9a5" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;core javascript reference&lt;/a&gt;</source>
          <target state="translated">来自&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;核心javascript参考&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33d6d15bce91547d5c6e839acec0e386194d3e54" translate="yes" xml:space="preserve">
          <source>From the specification</source>
          <target state="translated">从规范中可以看出</target>
        </trans-unit>
        <trans-unit id="078ecfcf86b689086aece409c4dd9d3597272bc8" translate="yes" xml:space="preserve">
          <source>Google for implicit conversions in C++ and &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; to get some of the arguments against it...</source>
          <target state="translated">Google在C ++和&lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL中&lt;/a&gt;进行隐式转换，以获取针对它的一些参数...</target>
        </trans-unit>
        <trans-unit id="5532825dcc419a2c608b4660ff4df27ee7b64e3b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; do not have values. Whereas, 0, false and '' are all values. One thing common beween all these are that they are all falsy values, which means they all &lt;strong&gt;satisfy&lt;/strong&gt; falsy conditions.</source>
          <target state="translated">这里 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 没有值。 而0，false和''均为值。 所有这些之间的共同点是它们都是虚假的值，这意味着它们都&lt;strong&gt;满足&lt;/strong&gt;虚假的条件。</target>
        </trans-unit>
        <trans-unit id="4f47052c940a268ebe245314f782cc99b18f0d6e" translate="yes" xml:space="preserve">
          <source>Here is a handy comparison table that shows the conversions that happen and the differences between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">这是一个方便的比较表，它显示了发生的转换以及 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;===&lt;/code&gt; 之间的差异。</target>
        </trans-unit>
        <trans-unit id="2e780233b6b8ef08d4cfd3eb493ce561f782434f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;==&lt;/code&gt; operator is checking the values of the two objects and returning &lt;code&gt;true&lt;/code&gt;, but the &lt;code&gt;===&lt;/code&gt; is seeing that they're not the same type and returning &lt;code&gt;false&lt;/code&gt;.  Which one is correct?  That really depends on what you're trying to compare.  My advice is to bypass the question entirely and just don't use the &lt;code&gt;String&lt;/code&gt; constructor to create string objects.</source>
          <target state="translated">这里 &lt;code&gt;==&lt;/code&gt; 运算符正在检查两个对象的值并返回 &lt;code&gt;true&lt;/code&gt; ，但是 &lt;code&gt;===&lt;/code&gt; 看到它们不是同一类型并返回 &lt;code&gt;false&lt;/code&gt; 。 哪一个是正确的？ 这确实取决于您要比较的内容。 我的建议是完全绕过该问题，只是不要使用 &lt;code&gt;String&lt;/code&gt; 构造函数来创建字符串对象。</target>
        </trans-unit>
        <trans-unit id="7108ec5478e370309fc5357c0e971bd4f05bbf90" translate="yes" xml:space="preserve">
          <source>However there is &lt;strong&gt;one single exception&lt;/strong&gt;:
&lt;code&gt;== null&lt;/code&gt; is an efficient way to check for 'is null or undefined':</source>
          <target state="translated">但是，只有&lt;strong&gt;一个例外&lt;/strong&gt; ： &lt;code&gt;== null&lt;/code&gt; 是检查&amp;ldquo;是否为null或未定义&amp;rdquo;的有效方法：</target>
        </trans-unit>
        <trans-unit id="f0d30f93bb4df391284d009844ff1535f26f2082" translate="yes" xml:space="preserve">
          <source>I tested this in Firefox with &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; using code like this:</source>
          <target state="translated">我使用以下代码在Firefox中使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt;测试了此代码：</target>
        </trans-unit>
        <trans-unit id="7b1c18acfb2da322223032a6ca65bcb729f0ddd1" translate="yes" xml:space="preserve">
          <source>I thought strings behave like value types? Well, it depends who you ask... In this case a and b are not the same type. &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;Object&lt;/code&gt;, while &lt;code&gt;b&lt;/code&gt; is of type &lt;code&gt;string&lt;/code&gt;. Just remember that creating a string object using the &lt;code&gt;String&lt;/code&gt; constructor creates something of type &lt;code&gt;Object&lt;/code&gt; that behaves as a string &lt;em&gt;most of the time&lt;/em&gt;.</source>
          <target state="translated">我以为字符串的行为类似于值类型？ 好吧，这取决于您问的是谁...在这种情况下，a和b不是同一类型。 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;Object&lt;/code&gt; 类型，而 &lt;code&gt;b&lt;/code&gt; 是 &lt;code&gt;string&lt;/code&gt; 类型。 只需记住，使用 &lt;code&gt;String&lt;/code&gt; 构造函数创建字符串对象会创建 &lt;code&gt;Object&lt;/code&gt; 类型的对象 ，该对象 &lt;em&gt;大多数情况下都&lt;/em&gt;表现为字符串。</target>
        </trans-unit>
        <trans-unit id="6724c10b1c4dd89e994b59c7b65ce998cb53f9b0" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;JSLint&lt;/a&gt; to go through JavaScript, and it's returning many suggestions to replace &lt;code&gt;==&lt;/code&gt; (two equals signs) with &lt;code&gt;===&lt;/code&gt; (three equals signs) when doing things like comparing &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; inside of an &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">我正在使用&lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;JSLint&lt;/a&gt;遍历JavaScript，并且在进行 &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; 内的比较idSele_UNVEHtype.value.length == 0时，返回了许多建议，将 &lt;code&gt;==&lt;/code&gt; （两个等号）替换为 &lt;code&gt;===&lt;/code&gt; （三个等号）。声明。</target>
        </trans-unit>
        <trans-unit id="699383a3720b89c508893f13174fcc345a333a00" translate="yes" xml:space="preserve">
          <source>If Type(constructor) is not Object, throw a TypeError exception.</source>
          <target state="translated">如果Type(constructor)不是Object,则抛出一个TypeError异常。</target>
        </trans-unit>
        <trans-unit id="7c1b47bf6a1abbf554dbd0ee2168db0b303f1c1f" translate="yes" xml:space="preserve">
          <source>If both operands of == are objects, then they are compared to see if they are the same object. If both operands point to the same object, then the equal operator returns true. Otherwise,
the two are not equal.</source>
          <target state="translated">如果===的两个操作符都是对象,那么就比较它们是否是同一个对象。如果两个操作符都指向同一个对象,那么等于操作符返回true。否则,这两个操作符不相等。</target>
        </trans-unit>
        <trans-unit id="cbb1a99493847058458e46837af0fc9a5702b63e" translate="yes" xml:space="preserve">
          <source>If no type conversion takes place, would there be a performance gain over &lt;code&gt;==&lt;/code&gt;?</source>
          <target state="translated">如果没有进行类型转换，是否会获得 &lt;code&gt;==&lt;/code&gt; 以上的性能提升？</target>
        </trans-unit>
        <trans-unit id="e27332524b113dae22c09288bee3e0f34778ca3c" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;HAVE TO&lt;/strong&gt; live with it, then remember the following 3 things:</source>
          <target state="translated">如果您必须忍受它，那么请记住以下三件事：</target>
        </trans-unit>
        <trans-unit id="ba83b649d7ac77ee88b91662e9dc19d8d2569046" translate="yes" xml:space="preserve">
          <source>If you wonder why &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; does not return a string, how about some exercise reading a specification? Have fun!</source>
          <target state="translated">如果您想知道为什么&lt;strong&gt;new String（&amp;ldquo; a&amp;rdquo;）&lt;/strong&gt;不返回字符串，那么阅读规范的一些练习呢？ 玩得开心！</target>
        </trans-unit>
        <trans-unit id="318588db3ab6c1c4c50c1ae4dd7cb47bf8189bab" translate="yes" xml:space="preserve">
          <source>In JavaScript it means of the same value and type.</source>
          <target state="translated">在JavaScript中,它指的是相同的值和类型。</target>
        </trans-unit>
        <trans-unit id="4bbc85798100e8a6c2b8173b4c4cc5ff26f86121" translate="yes" xml:space="preserve">
          <source>In PHP and JavaScript, it is a strict equality operator. Which means, it will compare both type and values.</source>
          <target state="translated">在PHP和JavaScript中,它是一个严格的平等运算符。这意味着,它将同时比较类型和值。</target>
        </trans-unit>
        <trans-unit id="0fd01d3c121d1dd02e0aad7a9a25393961f9968a" translate="yes" xml:space="preserve">
          <source>In a typical script there will be no performance difference. More important may be the fact that thousand &quot;===&quot; is 1&amp;nbsp;KB heavier than thousand &quot;==&quot; :) &lt;a href=&quot;https://stackoverflow.com/questions/tagged/javascript+performance&quot;&gt;JavaScript profilers&lt;/a&gt; can tell you if there is a performance difference in your case.</source>
          <target state="translated">在典型的脚本中，不会有性能差异。 可能更重要的事实是千个&amp;ldquo; ===&amp;rdquo;比1个&amp;ldquo; ==&amp;rdquo;重&lt;a href=&quot;https://stackoverflow.com/questions/tagged/javascript+performance&quot;&gt;1KB。JavaScript分析器&lt;/a&gt;可以告诉您您的情况是否存在性能差异。</target>
        </trans-unit>
        <trans-unit id="0e42d567a09b4ba932e88964ee9b8587449c04d9" translate="yes" xml:space="preserve">
          <source>In fact, if you tried to write a function that does what &lt;code&gt;==&lt;/code&gt; does it would look something like this:</source>
          <target state="translated">实际上，如果您尝试编写一个执行 &lt;code&gt;==&lt;/code&gt; 功能的函数，它将看起来像这样：</target>
        </trans-unit>
        <trans-unit id="48c572d57b17fbc593b6830a7381e7378807a00f" translate="yes" xml:space="preserve">
          <source>In the 90% usage scenario it won't matter which one you use, but it is handy to know the difference when you get some unexpected behaviour one day.</source>
          <target state="translated">在90%的使用场景中,你用哪一个并不重要,但当有一天你有了一些意外的行为时,知道它的区别就很方便。</target>
        </trans-unit>
        <trans-unit id="ec01264fb9d51cfefd427a17d74eb33ac1be156e" translate="yes" xml:space="preserve">
          <source>In the answers here, I didn't read anything about what &lt;strong&gt;equal&lt;/strong&gt; means. Some will say that &lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;equal and of the same type&lt;/strong&gt;, but that's not really true. It actually means that &lt;strong&gt;both operands reference the same object&lt;/strong&gt;, or in case of &lt;strong&gt;value types, have the same value&lt;/strong&gt;.</source>
          <target state="translated">在这里的答案中，我什么都没有读到什么&lt;strong&gt;相等的&lt;/strong&gt;意思。 有人会说 &lt;code&gt;===&lt;/code&gt; 表示&lt;strong&gt;equal且具有相同的类型&lt;/strong&gt; ，但这并不是真的。 实际上， &lt;strong&gt;这&lt;/strong&gt;意味着&lt;strong&gt;两个操作数都引用相同的对象&lt;/strong&gt; ，或者在&lt;strong&gt;值类型的&lt;/strong&gt;情况下&lt;strong&gt;，它们具有相同的value&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca385d21427dba165889d58d33e6fa5704fb46b2" translate="yes" xml:space="preserve">
          <source>In the case of &lt;strong&gt;&quot;a === b&quot;&lt;/strong&gt; a and b must be the &lt;strong&gt;same value&lt;/strong&gt; and also the &lt;strong&gt;same type&lt;/strong&gt; for it to evaluate to true.</source>
          <target state="translated">在&lt;strong&gt;&amp;ldquo; a === b&amp;rdquo;&lt;/strong&gt;的情况下，a和b必须具有&lt;strong&gt;相同的值&lt;/strong&gt;和&lt;strong&gt;相同的类型&lt;/strong&gt; ，才能将其评估为true。</target>
        </trans-unit>
        <trans-unit id="251bebdd324bcccca7535068065ec28cc534eae3" translate="yes" xml:space="preserve">
          <source>In the code above, both == and === get false because a and b are not the same objects.</source>
          <target state="translated">在上面的代码中,==和===都会得到false,因为a和b不是同一个对象。</target>
        </trans-unit>
        <trans-unit id="a4cd7b099967df429e07f68f296c07052c7aba52" translate="yes" xml:space="preserve">
          <source>Interesting is step 11. Yes, strings are treated as value types. But this does not explain why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;. Do we have a browser not conforming to ECMA-262?</source>
          <target state="translated">有趣的是步骤11。是的，字符串被视为值类型。 但这不能解释为什么&lt;strong&gt;new String（&amp;ldquo; a&amp;rdquo;）！==&amp;ldquo; a&amp;rdquo;&lt;/strong&gt; 。 我们是否有不符合ECMA-262的浏览器？</target>
        </trans-unit>
        <trans-unit id="cd2c230db52d16c62fde2c29f3b5aa18ff6b95af" translate="yes" xml:space="preserve">
          <source>Is there a performance benefit to replacing &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;===&lt;/code&gt;?</source>
          <target state="translated">将 &lt;code&gt;==&lt;/code&gt; 替换为 &lt;code&gt;===&lt;/code&gt; 有性能优势吗？</target>
        </trans-unit>
        <trans-unit id="6208d5e465527e22f406b99578ad5d55c45f7cb9" translate="yes" xml:space="preserve">
          <source>It checks if same sides are equal in &lt;strong&gt;type&lt;/strong&gt; as well as &lt;strong&gt;value&lt;/strong&gt;.</source>
          <target state="translated">它检查相同边的&lt;strong&gt;类型&lt;/strong&gt;和&lt;strong&gt;值&lt;/strong&gt;是否相等。</target>
        </trans-unit>
        <trans-unit id="3b33800c6e21e7706b86e94308ae2b6ade92ea2c" translate="yes" xml:space="preserve">
          <source>It get's pretty wacky.</source>
          <target state="translated">它得到的相当古怪。</target>
        </trans-unit>
        <trans-unit id="0c3489421f48aca78ca26cbeacff41a88d0a2485" translate="yes" xml:space="preserve">
          <source>It get's worse:</source>
          <target state="translated">情况越来越糟了。</target>
        </trans-unit>
        <trans-unit id="2461a72119f69288570a91dd4886cf1946921ace" translate="yes" xml:space="preserve">
          <source>It has special handling for functions, special handling for nulls, undefined, strings, you name it.</source>
          <target state="translated">它有对函数的特殊处理,对空位、未定义、字符串的特殊处理,你说了算。</target>
        </trans-unit>
        <trans-unit id="e7800c4331282e121e342d6b81303384bd272938" translate="yes" xml:space="preserve">
          <source>It is faster only when the types are not the same, in which case it does not try to convert types but directly returns a false.</source>
          <target state="translated">只有当类型不一样的时候,它才会更快,在这种情况下,它不尝试转换类型,而是直接返回一个false。</target>
        </trans-unit>
        <trans-unit id="faa77444bfb36c5ba995cd19f29530d0943b04a1" translate="yes" xml:space="preserve">
          <source>It means &lt;code&gt;==&lt;/code&gt; is complicated.</source>
          <target state="translated">这意味着 &lt;code&gt;==&lt;/code&gt; 很复杂。</target>
        </trans-unit>
        <trans-unit id="a65b5bfaad127fd93d57e6ab192d490bc11ac353" translate="yes" xml:space="preserve">
          <source>It means &lt;strong&gt;equality without type coercion&lt;/strong&gt;
type coercion means JavaScript do not automatically convert any other data types to string data types</source>
          <target state="translated">这意味着&lt;strong&gt;没有类型强制的相等性&lt;/strong&gt;类型强制意味着JavaScript不会自动将任何其他数据类型转换为字符串数据类型</target>
        </trans-unit>
        <trans-unit id="4cc792e792c928abedc18234163e220b2c90215c" translate="yes" xml:space="preserve">
          <source>It's a good thing especially if you're checking between 0 and false and null.</source>
          <target state="translated">这是个好东西,尤其是当你在0和false和null之间检查的时候。</target>
        </trans-unit>
        <trans-unit id="76814442e2351cc8045391978fecf4190730bd23" translate="yes" xml:space="preserve">
          <source>It's a strict check test.</source>
          <target state="translated">这是一个严格的检查考核。</target>
        </trans-unit>
        <trans-unit id="c194b6748d81866560cca42c3ec80275ce25b0fa" translate="yes" xml:space="preserve">
          <source>It's a whole new level of crazy when you use &lt;code&gt;==&lt;/code&gt; with objects.</source>
          <target state="translated">当对对象使用 &lt;code&gt;==&lt;/code&gt; 时，这是一个全新的疯狂级别。</target>
        </trans-unit>
        <trans-unit id="7e5685be28423b6fa9a147ecdfab572abc4a40a1" translate="yes" xml:space="preserve">
          <source>JSLint sometimes gives you unrealistic reasons to modify stuff. &lt;code&gt;===&lt;/code&gt; has exactly the same performance as &lt;code&gt;==&lt;/code&gt; if the types are already the same.</source>
          <target state="translated">JSLint有时会给您不切实际的理由来进行修改。 如果类型已经相同，则 &lt;code&gt;===&lt;/code&gt; 与 &lt;code&gt;==&lt;/code&gt; 具有完全相同的性能。</target>
        </trans-unit>
        <trans-unit id="6f75f5a9d4e62f008ab83040158a6ea4c2ffb8de" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;===&lt;/code&gt;&lt;strong&gt;vs&lt;/strong&gt;&lt;code&gt;==&lt;/code&gt; .</source>
          <target state="translated">JavaScript &lt;code&gt;===&lt;/code&gt; &lt;strong&gt;vs&lt;/strong&gt; &lt;code&gt;==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f50ece919837ed27b6fe25229b9c0edd82a3a80" translate="yes" xml:space="preserve">
          <source>JavaScript has two sets of equality operators: &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;, and their evil twins &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.  The good ones work the way you would expect.  If the two operands are of the same type and have the same value, then &lt;code&gt;===&lt;/code&gt; produces &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt; produces &lt;code&gt;false&lt;/code&gt;.  The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values.  the rules by which they do that are complicated and unmemorable.  These are some of the interesting cases:</source>
          <target state="translated">JavaScript有两组相等运算符： &lt;code&gt;===&lt;/code&gt; 和 &lt;code&gt;!==&lt;/code&gt; ，以及它们的邪恶双胞胎 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 。 优秀的产品以您期望的方式工作。 如果两个操作数具有相同的类型并且具有相同的值，则 &lt;code&gt;===&lt;/code&gt; 会生成 &lt;code&gt;true&lt;/code&gt; ,而 &lt;code&gt;!==&lt;/code&gt; 会生成 &lt;code&gt;false&lt;/code&gt; 。 当操作数是相同类型时，邪恶双胞胎会做正确的事情，但是如果操作数是不同类型，则它们会试图强制值。 他们所遵循的规则是复杂而难忘的。 这些是一些有趣的情况：</target>
        </trans-unit>
        <trans-unit id="ddcc47139dece09713aae28867a0635754940c72" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for non strict equality / comparison '=='</source>
          <target state="translated">非严格平等比较'=='的Javascript执行流程图</target>
        </trans-unit>
        <trans-unit id="c489836ec904339790b4e755108af00367792205" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for strict equality / Comparison '==='</source>
          <target state="translated">严格平等的Javascript执行流程图比较 '======'</target>
        </trans-unit>
        <trans-unit id="8a105feba0ec261aeed869b80ed97fd71c7d981b" translate="yes" xml:space="preserve">
          <source>Let me add this counsel:</source>
          <target state="translated">让我来补充一下这位律师。</target>
        </trans-unit>
        <trans-unit id="b78f589e89c4bf85c5acdcf503fa3ce05322739a" translate="yes" xml:space="preserve">
          <source>Let me say that again:</source>
          <target state="translated">让我再说一遍。</target>
        </trans-unit>
        <trans-unit id="7dc48ae18a400d363e4e831b1bc3f62fa17e236b" translate="yes" xml:space="preserve">
          <source>Let's check the types of the operands. Try it out for yourself by wrapping them in &lt;strong&gt;typeof()&lt;/strong&gt;. I find that &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; is an object, and step 1 is used: return &lt;strong&gt;false&lt;/strong&gt; if the types are different.</source>
          <target state="translated">让我们检查操作数的类型。 通过将它们包装在&lt;strong&gt;typeof（）中&lt;/strong&gt; ，自己尝试一下。 我发现&lt;strong&gt;new String（&amp;ldquo; a&amp;rdquo;）&lt;/strong&gt;是一个对象，并使用了步骤1：如果类型不同，则返回&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b61e7aec3e99c633efdc11e39208fc2dff1d3e2c" translate="yes" xml:space="preserve">
          <source>Lets take 2 vars a and b.</source>
          <target state="translated">让我们取2个vars a和b。</target>
        </trans-unit>
        <trans-unit id="cfd185a2bd37b57a50c809cfa0d84c8e0b4f3ff4" translate="yes" xml:space="preserve">
          <source>Make your life less complicated.</source>
          <target state="translated">让你的生活不那么复杂。</target>
        </trans-unit>
        <trans-unit id="63b41e8cde051766ea25feb26773d03ab2db614d" translate="yes" xml:space="preserve">
          <source>Meaning, there is no reason to change &lt;code&gt;==&lt;/code&gt; to &lt;code&gt;===&lt;/code&gt; in a check like &lt;code&gt;if (a == 'test')&lt;/code&gt; when you know it for a fact that a can only be a String.</source>
          <target state="translated">意思是，当您因为a只能是String的事实而知道时，没有理由像 &lt;code&gt;if (a == 'test')&lt;/code&gt; 一样将 &lt;code&gt;==&lt;/code&gt; 更改为 &lt;code&gt;===&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0938c27e70c1f172175d9d18522b01f7447aea0e" translate="yes" xml:space="preserve">
          <source>Modifying a lot of code that way wastes developers' and reviewers' time and achieves nothing.</source>
          <target state="translated">这样修改大量的代码,既浪费了开发人员和审稿人的时间,也没有达到什么效果。</target>
        </trans-unit>
        <trans-unit id="f4cefe7cd2cd184bb73ed4c344cfc83710bb0d62" translate="yes" xml:space="preserve">
          <source>My results (tested five times each and averaged):</source>
          <target state="translated">我的成绩(测试了五次,每次都是平均值)。</target>
        </trans-unit>
        <trans-unit id="f0da046224ce2dc3106a3b60cd5d194e6ba42983" translate="yes" xml:space="preserve">
          <source>Not so fast!</source>
          <target state="translated">别这么快!</target>
        </trans-unit>
        <trans-unit id="d5b784c68e01c822fc3215d8b23457f17bc7b95f" translate="yes" xml:space="preserve">
          <source>Now it becomes interesting:</source>
          <target state="translated">现在,它变得有趣了。</target>
        </trans-unit>
        <trans-unit id="26cf870c221ea623ca6c9613122347141c9e0338" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;strong&gt;identity operator &lt;code&gt;===&lt;/code&gt; does not do type coercion&lt;/strong&gt;, and thus does not convert the values when comparing, and is therefore faster (as according to &lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;This JS benchmark&lt;/a&gt; test) as it skips one step.</source>
          <target state="translated">另一方面， &lt;strong&gt;标识运算符 &lt;code&gt;===&lt;/code&gt; 不会键入强制&lt;/strong&gt; ，因此在比较时不会转换值，因此由于跳过了一步，因此运算速度更快（根据&lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;This JS基准&lt;/a&gt;测试）。</target>
        </trans-unit>
        <trans-unit id="bb6871c5d84a4419ab95dc8eece8700504fdd6d6" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;==&lt;/code&gt;</source>
          <target state="translated">运算子 &lt;code&gt;==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f06b526b15c78330ed724b58112444a30169da4d" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">运算子 &lt;code&gt;===&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7a3d854bfa0266e9c4a954b8a4122785d12b7cc" translate="yes" xml:space="preserve">
          <source>Or even:</source>
          <target state="translated">或者说,甚至。</target>
        </trans-unit>
        <trans-unit id="596eba5f701a564c8f484f75e8abdc3dd9152672" translate="yes" xml:space="preserve">
          <source>Please let me explain how to read the specification to clarify this question. I see that in this very old topic nobody had an answer for the very strange effect. So, if you can read a specification, this will help you in your profession tremendously. It is an acquired skill. So, let's continue.</source>
          <target state="translated">请允许我解释一下,如何阅读规范来澄清这个问题。我看到在这个很老的话题中,没有人对这个很奇怪的效果有答案。所以,如果你能看懂规范,这对你的专业会有很大的帮助。这是一种后天的技能。所以,我们继续说下去吧。</target>
        </trans-unit>
        <trans-unit id="2a07e2d0f6f8e8b2cf427f387c24f9c27a381095" translate="yes" xml:space="preserve">
          <source>Reasons are explained in in the answers above and also Douglas Crockford is pretty clear about it (&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;).</source>
          <target state="translated">原因在上面的答案中进行了解释，Douglas Crockford对此也很清楚（ &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript：The Good Parts&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d15ebe82de3e2a210aaf6dba6213d7558919e153" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;Javascript Tutorial: Comparison Operators&lt;/a&gt;</source>
          <target state="translated">参考： &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;Javascript教程：比较运算符&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ea0f0fa0757bccc8812f547b6f8ef97346e64a" translate="yes" xml:space="preserve">
          <source>Returns true if both operands are equal and of the same type. It's generally 
better and safer if you compare this way, because there's no behind-the-scenes type conversions.</source>
          <target state="translated">如果两个操作式都相等且类型相同,则返回true。一般情况下,如果你用这种方式进行比较会更好,也更安全,因为没有幕后的类型转换。</target>
        </trans-unit>
        <trans-unit id="957512be3223fc2dc3834f75c1dd58acecceff86" translate="yes" xml:space="preserve">
          <source>Returns true, when both operands are equal. The operands are converted to the same type before being compared.</source>
          <target state="translated">当两个操作式相等时,返回true。在比较之前,操作式被转换为相同类型。</target>
        </trans-unit>
        <trans-unit id="38ce9002bb36040cd6c2edf6d1d18fcb9a616b7a" translate="yes" xml:space="preserve">
          <source>Searching the PDF file for === brings me to page 56 of the specification: &lt;strong&gt;11.9.4. The Strict Equals Operator ( === )&lt;/strong&gt;, and after wading through the specificationalese I find:</source>
          <target state="translated">在PDF文件中搜索===使我进入规范的第56页： &lt;strong&gt;11.9.4。&lt;/strong&gt; &lt;strong&gt;Strict Equals运算符（===）&lt;/strong&gt; ，在仔细研究了规范性语言后，我发现：</target>
        </trans-unit>
        <trans-unit id="91af0d8b760b9aafb600d14166c0c131354b13a6" translate="yes" xml:space="preserve">
          <source>Simply</source>
          <target state="translated">Simply</target>
        </trans-unit>
        <trans-unit id="64c21976a1564e95206be932a9271ff8e6100731" translate="yes" xml:space="preserve">
          <source>So I'd say that the miniscule difference (this is over 100000 iterations, remember) is negligible. Performance &lt;strong&gt;&lt;em&gt;isn't&lt;/em&gt;&lt;/strong&gt; a reason to do &lt;code&gt;===&lt;/code&gt;. Type safety (well, as safe as you're going to get in JavaScript), and code quality is.</source>
          <target state="translated">因此，我想说微不足道的差异（可以记住超过100000次迭代）可以忽略不计。 性能&lt;strong&gt;&lt;em&gt;不是&lt;/em&gt;&lt;/strong&gt;要做 &lt;code&gt;===&lt;/code&gt; 的理由。 键入安全性（好吧，就像使用JavaScript一样安全），并且代码质量也是如此。</target>
        </trans-unit>
        <trans-unit id="ae0f3a56366851cea007b0cc3ec71cfe6236267c" translate="yes" xml:space="preserve">
          <source>So with the same thing as above, but a strict test:</source>
          <target state="translated">因此,与上述相同,但有了严格的考验。</target>
        </trans-unit>
        <trans-unit id="3c48ceb341b7974b0c35d68232de996773594700" translate="yes" xml:space="preserve">
          <source>So, &lt;em&gt;IMHO,&lt;/em&gt; JSLint maybe used to write new code, but useless over-optimizing should be avoided at all costs.</source>
          <target state="translated">因此， &lt;em&gt;恕我直言，&lt;/em&gt; JSLint可能用于编写新代码，但应不惜一切代价避免无用的过度优化。</target>
        </trans-unit>
        <trans-unit id="f5331af50eaf804f03f6a6159c25f1bb07cd7a40" translate="yes" xml:space="preserve">
          <source>So, let's take the following code:</source>
          <target state="translated">那么,让我们以下面的代码为例。</target>
        </trans-unit>
        <trans-unit id="93b72b7d5b6694715afdca6d3fa8931c4d1db958" translate="yes" xml:space="preserve">
          <source>So, the 0, false and '' together form a sub-group. And on other hand, null &amp;amp; undefined form the second sub-group. Check the comparisons in the below image. null and undefined would equal. The other three would equal to each other. But, they all are treated as falsy conditions in JavaScript.</source>
          <target state="translated">因此，0，false和''共同构成一个子组。 另一方面，null和undefined构成第二个子组。 检查下图中的比较。 null和undefined相等。 其他三个将彼此相等。 但是，它们在JavaScript中都被视为虚假条件。</target>
        </trans-unit>
        <trans-unit id="1a279fa74ab72ad3bcba6d6c656bd5ebc3d0eab4" translate="yes" xml:space="preserve">
          <source>Strict equality checks (===) should be used in favor of ==. The only
  exception is when checking for undefined and null by way of null.</source>
          <target state="translated">唯一的例外是在检查未定义和null的时候,用null的方式检查null。</target>
        </trans-unit>
        <trans-unit id="1d6d9051f3abc1e1858ebeb652dd4b2cace2ad46" translate="yes" xml:space="preserve">
          <source>Strings are not value types, but in Javascript they behave like value types, so they will be &quot;equal&quot; when the characters in the string are the same and when they are of the same length (as explained in the third rule)</source>
          <target state="translated">字符串不是值类型,但在Javascript中,它们的行为就像值类型一样,所以当字符串中的字符相同且长度相同时,它们就会被 &quot;等于&quot;(正如第三条规则中解释的那样</target>
        </trans-unit>
        <trans-unit id="2fc95a3daa32ef795b3db44197ca06a9161c6605" translate="yes" xml:space="preserve">
          <source>Strings: the special case...</source>
          <target state="translated">字符串:特殊情况下.....</target>
        </trans-unit>
        <trans-unit id="0a10f80e947919598b83985df0a922cea18c825f" translate="yes" xml:space="preserve">
          <source>Take the following example</source>
          <target state="translated">以下面的例子为例</target>
        </trans-unit>
        <trans-unit id="34d15b0c36f8c3a873f0aa9868dd4a2ce99ed153" translate="yes" xml:space="preserve">
          <source>That's to say: if both operands of == are objects, == behaves same as ===, which also means identity. The essential difference of this two operators is about type conversion. == has conversion before it checks equality, but === does not.</source>
          <target state="translated">也就是说:如果===的两个操作符都是对象,那么==的行为和===的行为是一样的,这也意味着身份的认同。这两个操作符的本质区别是关于类型转换,===在检查平等之前有转换,但====没有。</target>
        </trans-unit>
        <trans-unit id="b194ffbdff61cd41449b27896d0388ad11bc6102" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator will compare for equality &lt;em&gt;after doing any necessary type conversions&lt;/em&gt;.  The &lt;code&gt;===&lt;/code&gt; operator will &lt;strong&gt;not&lt;/strong&gt; do the conversion, so if two values are not the same type &lt;code&gt;===&lt;/code&gt; will simply return &lt;code&gt;false&lt;/code&gt;. Both are equally quick.</source>
          <target state="translated">&lt;em&gt;在进行任何必要的类型转换后&lt;/em&gt; ， &lt;code&gt;==&lt;/code&gt; 运算符将比较相等性。 &lt;code&gt;===&lt;/code&gt; 运算符将&lt;strong&gt;不会&lt;/strong&gt;进行转换，因此，如果两个值不同，则类型 &lt;code&gt;===&lt;/code&gt; 只会返回 &lt;code&gt;false&lt;/code&gt; 。 两者都同样快。</target>
        </trans-unit>
        <trans-unit id="94d61a1bd3d74a41d42873da5dad1d59e17caf82" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;===&lt;/strong&gt; operator is called a strict comparison operator, it &lt;strong&gt;does&lt;/strong&gt; differ from the &lt;strong&gt;==&lt;/strong&gt; operator.</source>
          <target state="translated">&lt;strong&gt;===&lt;/strong&gt;运算符称为严格比较运算符，它&lt;strong&gt;确实&lt;/strong&gt;与&lt;strong&gt;==&lt;/strong&gt;运算符不同。</target>
        </trans-unit>
        <trans-unit id="6b4a3a20e019eab11a43250c848486e6d49f5365" translate="yes" xml:space="preserve">
          <source>The End.</source>
          <target state="translated">终止了。</target>
        </trans-unit>
        <trans-unit id="afa8919ed4dc94f9cf1c114da989f410b6e7be00" translate="yes" xml:space="preserve">
          <source>The comparison x === y, where x and y are values, produces &lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;. Such a comparison is performed as follows:</source>
          <target state="translated">比较x === y（其中x和y是值）产生&lt;strong&gt;true&lt;/strong&gt;或&lt;strong&gt;false&lt;/strong&gt; 。 这样的比较执行如下：</target>
        </trans-unit>
        <trans-unit id="1b98b3145565493d8ec7750f669d527714ecc29b" translate="yes" xml:space="preserve">
          <source>The identity (&lt;code&gt;===&lt;/code&gt;) operator behaves identically to the equality (&lt;code&gt;==&lt;/code&gt;) operator except no type conversion is done, and the types must be the same to be considered equal.</source>
          <target state="translated">身份（ &lt;code&gt;===&lt;/code&gt; ）运算符的行为与相等（ &lt;code&gt;==&lt;/code&gt; ）运算符相同，只是不进行类型转换，并且类型必须相同才能被视为相等。</target>
        </trans-unit>
        <trans-unit id="412caf725ac873e21c2342891582c7eb72241e50" translate="yes" xml:space="preserve">
          <source>The lack of transitivity is alarming.  My advice is to never use the evil twins.  Instead, always use &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;.  All of the comparisons just shown produce &lt;code&gt;false&lt;/code&gt; with the &lt;code&gt;===&lt;/code&gt; operator.</source>
          <target state="translated">传递性的缺乏令人震惊。 我的建议是不要使用邪恶的双胞胎。 相反，请始终使用 &lt;code&gt;===&lt;/code&gt; 和 &lt;code&gt;!==&lt;/code&gt; 。 刚刚显示的所有比较都使用 &lt;code&gt;===&lt;/code&gt; 运算符生成了 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2ca5becda5d8c525a92af853383dd2f554be5e6" translate="yes" xml:space="preserve">
          <source>The problem is that you might easily get into trouble since JavaScript have a lot of implicit conversions meaning...</source>
          <target state="translated">问题是,你可能会很容易遇到麻烦,因为JavaScript有很多隐式转换的含义.....</target>
        </trans-unit>
        <trans-unit id="1c5cdbf6f285cc357902c21867d22dceaabbfb07" translate="yes" xml:space="preserve">
          <source>The rule is:</source>
          <target state="translated">该规则是:</target>
        </trans-unit>
        <trans-unit id="34e5356fba8841d2e384644ac7191e706b9b383b" translate="yes" xml:space="preserve">
          <source>The same here:</source>
          <target state="translated">这里也是这样。</target>
        </trans-unit>
        <trans-unit id="ac6a25542b0ec2ff99281bcf844b6b748cb989bf" translate="yes" xml:space="preserve">
          <source>The special case is when you compare a literal with an object that evaluates to the same literal, due to its &lt;code&gt;toString&lt;/code&gt; or &lt;code&gt;valueOf&lt;/code&gt; method. For example, consider the comparison of a string literal with a string object created by the &lt;code&gt;String&lt;/code&gt; constructor.</source>
          <target state="translated">特殊情况是，当您将一个文字与一个对象进行比较时，由于该对象的 &lt;code&gt;toString&lt;/code&gt; 或 &lt;code&gt;valueOf&lt;/code&gt; 方法，该对象的值等于相同的文字。 例如，考虑将字符串文字与由 &lt;code&gt;String&lt;/code&gt; 构造函数创建的字符串对象进行比较。</target>
        </trans-unit>
        <trans-unit id="deec20d89955518508df750a0325916894b132b6" translate="yes" xml:space="preserve">
          <source>The top 2 answers both mentioned == means equality and === means identity. Unfortunately, this statement is incorrect.</source>
          <target state="translated">前2个答案中都提到了===表示平等,===表示认同。遗憾的是,这个说法是不对的。</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="7e6e25d889bccff4888c16c5091398046e021bd5" translate="yes" xml:space="preserve">
          <source>There is unlikely to be any performance difference between the two operations in your usage. There is no type-conversion to be done because both parameters are already the same type. Both operations will have a type comparison followed by a value comparison.</source>
          <target state="translated">在你的使用中,这两个操作之间不太可能有任何性能差异。没有类型转换,因为两个参数都已经是相同的类型。这两个操作都会有一个类型比较,然后再进行值比较。</target>
        </trans-unit>
        <trans-unit id="d0addef10584dbb6993cff27164cee0b6c70c9f9" translate="yes" xml:space="preserve">
          <source>This behavior is not always obvious. There's more to the story than being equal and being of the same type.</source>
          <target state="translated">这种行为并不总是很明显。故事中,除了平等和同类型之外,还有更多的东西。</target>
        </trans-unit>
        <trans-unit id="10b32091fa5a9c7a5536dd0b8d0dbc5d56df3f1a" translate="yes" xml:space="preserve">
          <source>This is because the &lt;strong&gt;equality operator &lt;code&gt;==&lt;/code&gt; does type coercion&lt;/strong&gt;, meaning that the interpreter implicitly tries to convert the values before comparing.</source>
          <target state="translated">这是因为&lt;strong&gt;等于运算符 &lt;code&gt;==&lt;/code&gt; 确实键入了coercion&lt;/strong&gt; ，这意味着解释器在比较之前隐式尝试转换值。</target>
        </trans-unit>
        <trans-unit id="e099919ae099449d50619707a595101be1938525" translate="yes" xml:space="preserve">
          <source>This is same as any object (like {}, arrays, etc.), non-empty string &amp;amp; Boolean true are all truthy conditions. But, they are all not equal.</source>
          <target state="translated">这与任何对象（如{}，数组等）相同，非空字符串和布尔值true都是真实条件。 但是，它们都不相等。</target>
        </trans-unit>
        <trans-unit id="c01421dd6e3a97aa7a750d67645c9ce033722624" translate="yes" xml:space="preserve">
          <source>To quote Douglas Crockford's excellent &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;,</source>
          <target state="translated">引用Douglas Crockford出色的&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript：The Good Parts&lt;/a&gt; ，</target>
        </trans-unit>
        <trans-unit id="1b6611f5af4feb0209552e588441f461e4827c57" translate="yes" xml:space="preserve">
          <source>Type conversion in javaScript means javaScript automatically convert any other data types to string data types.</source>
          <target state="translated">javaScript中的类型转换是指javaScript自动将其他任何数据类型转换为字符串数据类型。</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="2dd151cc35444f22efefaf2a4c9200a524eabcbb" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;===&lt;/code&gt; 代替 &lt;code&gt;==&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c453d7e21f4c791a03dcc4a981e5605615b7d07" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;==&lt;/code&gt; operator (&lt;em&gt;Equality&lt;/em&gt;)</source>
          <target state="translated">使用 &lt;code&gt;==&lt;/code&gt; 运算符（ 等于 ）</target>
        </trans-unit>
        <trans-unit id="513b5a2751665a1919f797ca492150f5a95e5dbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;===&lt;/code&gt; operator (&lt;em&gt;Identity&lt;/em&gt;)</source>
          <target state="translated">使用 &lt;code&gt;===&lt;/code&gt; 运算符（ &lt;em&gt;Identity&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="49fae091b162654343089eb4ba3ab8ccdfc467f0" translate="yes" xml:space="preserve">
          <source>Well it's because unlike &quot;triple equals&quot; (&lt;code&gt;===&lt;/code&gt;) which just checks if two values are the same.</source>
          <target state="translated">这是因为与&amp;ldquo;三等分&amp;rdquo;（ &lt;code&gt;===&lt;/code&gt; ）不同，它仅检查两个值是否相同。</target>
        </trans-unit>
        <trans-unit id="fbbea6dde2ab91a36ff23b57623dc1796e371116" translate="yes" xml:space="preserve">
          <source>What do you get when you compare an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; with the number zero &lt;code&gt;0&lt;/code&gt;?</source>
          <target state="translated">比较一个空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; 与数字零 &lt;code&gt;0&lt;/code&gt; 会得到什么？</target>
        </trans-unit>
        <trans-unit id="67709d0522046140afbdae10c9f80a805117bee6" translate="yes" xml:space="preserve">
          <source>Which equals operator (== vs ===) should be used in JavaScript comparisons</source>
          <target state="translated">JavaScript比较中应该使用哪个等号运算符(===vs =====)?</target>
        </trans-unit>
        <trans-unit id="697e4e154c1261a7e33818edccc744a4d570a31e" translate="yes" xml:space="preserve">
          <source>Which means you could end up with bugs.</source>
          <target state="translated">这意味着你可能会被BUG所困扰。</target>
        </trans-unit>
        <trans-unit id="d141d97a7a3ac22b01fd1cd75711d31e277f0a28" translate="yes" xml:space="preserve">
          <source>Which obviously during runtime does &lt;em&gt;very&lt;/em&gt; undefined things...</source>
          <target state="translated">显然，在运行时这会做&lt;em&gt;非常&lt;/em&gt;不确定的事情...</target>
        </trans-unit>
        <trans-unit id="36933ceea4f2db404d028c82e6364a36ace968a0" translate="yes" xml:space="preserve">
          <source>Which pretty soon becomes a problem. The best sample of why implicit conversion is &quot;evil&quot; can be taken from this code in &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C++ which actually will compile due to an implicit conversion from CString to HANDLE which is a pointer typedef type...</source>
          <target state="translated">哪一个很快成为问题。 隐式转换为什么是&amp;ldquo;邪恶的&amp;rdquo;的最佳示例可以从&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C ++中的此代码中获取，该代码实际上将由于从CString到HANDLE的隐式转换而编译，HANDLE是指针typedef类型。</target>
        </trans-unit>
        <trans-unit id="9fcac86aac0009e66019e4c27ea46100eaf900a2" translate="yes" xml:space="preserve">
          <source>With other words, if String wouldn't be of type Object it couldn't be used with the new operator.</source>
          <target state="translated">换句话说,如果String不属于Object类型,就不能用新的操作符来使用。</target>
        </trans-unit>
        <trans-unit id="45903fac0ea3c75afe550d2440dc48b77fd3f572" translate="yes" xml:space="preserve">
          <source>Yep, that's right according to &lt;code&gt;==&lt;/code&gt; an empty string and the number zero are the same time.</source>
          <target state="translated">是的，根据 &lt;code&gt;==&lt;/code&gt; 一个空字符串和数字零是同一时间，这是正确的。</target>
        </trans-unit>
        <trans-unit id="eabbe6442a6f27defee150f80d6147176f73513a" translate="yes" xml:space="preserve">
          <source>You can easily test it. Paste following code in an HTML file and open it in browser</source>
          <target state="translated">你可以很容易地进行测试。将下面的代码粘贴到一个HTML文件中,然后在浏览器中打开它</target>
        </trans-unit>
        <trans-unit id="5da640618827894fedb5feef195dd55437e5bda8" translate="yes" xml:space="preserve">
          <source>You will get '&lt;strong&gt;false&lt;/strong&gt;' in alert. Now modify the &lt;code&gt;onPageLoad()&lt;/code&gt; method to &lt;code&gt;alert(x == 5);&lt;/code&gt; you will get &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">您将在警报中得到&amp;ldquo; &lt;strong&gt;假&lt;/strong&gt; &amp;rdquo;。 现在将 &lt;code&gt;onPageLoad()&lt;/code&gt; 方法修改为 &lt;code&gt;alert(x == 5);&lt;/code&gt; 你会做到的。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="786e97b3ee9fc4b292d5852c2c5943153c4ce91a" translate="yes" xml:space="preserve">
          <source>but</source>
          <target state="translated">but</target>
        </trans-unit>
        <trans-unit id="550f8bc02aebdb930e2ff4b54cf6677ee045437c" translate="yes" xml:space="preserve">
          <source>null and undefined are nothingness, that is,</source>
          <target state="translated">空和未定义都是虚无,即。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
