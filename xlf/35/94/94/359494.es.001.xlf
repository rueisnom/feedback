<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/359494">
    <body>
      <group id="359494">
        <trans-unit id="130bf5785915eb04e8a94d3a41ec118bd8e8f0d8" translate="yes" xml:space="preserve">
          <source>&quot;Use three equals unless you fully understand the conversions that take
  place for two-equals.&quot;</source>
          <target state="translated">&quot;Use tres iguales a menos que entienda completamente las conversiones que tienen lugar para dos iguales&quot;.</target>
        </trans-unit>
        <trans-unit id="54f697a1ff421e46f37022813a88d0937a82090c" translate="yes" xml:space="preserve">
          <source>&amp;amp;</source>
          <target state="translated">&amp;amp;</target>
        </trans-unit>
        <trans-unit id="dea7f7f48b6202dbcdd6e2f0b470c1320197a1b3" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;1. If Type(x) is different from Type(y), return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">1. Si el Tipo (x) es diferente del Tipo (y), devuelve &lt;strong&gt;falso&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="128316503370069a1f99b4764d5a503e65225aa7" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;10. Return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">10. Devolver &lt;strong&gt;falso&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9f94476563997f8d2da2e6fdfb6b36c68ec81051" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;11. If Type(x) is String, then return &lt;strong&gt;true&lt;/strong&gt; if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">11. Si Type (x) es String, devuelve &lt;strong&gt;true&lt;/strong&gt; si xey son exactamente la misma secuencia de caracteres (la misma longitud y los mismos caracteres en las posiciones correspondientes); de lo contrario, devuelve &lt;strong&gt;falso&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4c30077433d472cb40022cd05bbb7b0fce6d9add" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;12. If Type(x) is Boolean, return &lt;strong&gt;true&lt;/strong&gt; if x and y are both &lt;strong&gt;true&lt;/strong&gt; or both &lt;strong&gt;false&lt;/strong&gt;; otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">12. Si Tipo (x) es booleano, devuelve &lt;strong&gt;verdadero&lt;/strong&gt; si xey son ambos &lt;strong&gt;verdaderos&lt;/strong&gt; o ambos &lt;strong&gt;falsos&lt;/strong&gt; ; de lo contrario, devuelve &lt;strong&gt;falso&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="25f36acdf60e7d6a4df37ffedc98b9f14faf995c" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;13. Return &lt;strong&gt;true&lt;/strong&gt; if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">13. Devuelve &lt;strong&gt;verdadero&lt;/strong&gt; si x e y se refieren al mismo objeto o si se refieren a objetos unidos entre s&amp;iacute; (ver 13.1.2). De lo contrario, devuelve &lt;strong&gt;falso&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6754f28eced479b11eb44690f5d4fa3822beda44" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;2. If Type(x) is Undefined, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">2. Si Tipo (x) no est&amp;aacute; definido, devuelve &lt;strong&gt;verdadero&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a41404dc0e9e4b2139c7b55b00ba4f197ed1db" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;3. If Type(x) is Null, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">3. Si Tipo (x) es Nulo, devuelve &lt;strong&gt;verdadero&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="86e81311d208ba00e8a82f89a4b6f670518af9c9" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;4. If Type(x) is not Number, go to step 11.</source>
          <target state="translated">4. Si el Tipo (x) no es N&amp;uacute;mero, vaya al paso 11.</target>
        </trans-unit>
        <trans-unit id="1d11aa4bb7dc1bb6eb30029e881efcb0c773c688" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;5. If x is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">5. Si x es &lt;strong&gt;NaN&lt;/strong&gt; , devuelve &lt;strong&gt;falso&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e6feedc887138d0c4493e0285c20861d70ce82b0" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;6. If y is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">6. Si y es &lt;strong&gt;NaN&lt;/strong&gt; , devuelve &lt;strong&gt;falso&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b305a8dce9f7df97f238519197a73606b9ab87f2" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;7. If x is the same number value as y, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">7. Si x es el mismo valor num&amp;eacute;rico que y, devuelve &lt;strong&gt;verdadero&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b42c345a414ab1fe5a4c613c47711966027975a5" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;8. If x is +0 and y is &amp;minus;0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">8. Si x es +0 e y es &amp;minus;0, devuelve &lt;strong&gt;verdadero&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e941ba4b0fdf4fcc001e64d6bd9bd26d6a81fd02" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;9. If x is &amp;minus;0 and y is +0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">9. Si x es &amp;minus;0 e y es +0, devuelve &lt;strong&gt;verdadero&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="03520e1e34120f6fae6bbeb3d5eb895994c709d3" translate="yes" xml:space="preserve">
          <source>** STRANGE: note that any two values on the first column are not equal in that sense.**</source>
          <target state="translated">**STRANGE:note que cualquier dos valores en la primera columna no son iguales en ese sentido.**</target>
        </trans-unit>
        <trans-unit id="bfadb6bfe229d17ab6eb814049a1af7e1c35942f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality and type comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Igualdad y comparaci&amp;oacute;n de tipos:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4311a70549d246e170e5a8f1b527e5c5a19379f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Comparaci&amp;oacute;n de igualdad:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1ab346462c9fcef1a02b67c403e451e31987880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does a &lt;strong&gt;&lt;em&gt;whole bunch of other stuff&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; hace un &lt;strong&gt;&lt;em&gt;mont&amp;oacute;n de otras cosas&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1b338ff3f560901a0f7f2338cb21ec9ed418bce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;with&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; significa &lt;strong&gt;comparaci&amp;oacute;n&lt;/strong&gt; entre operandos &lt;strong&gt;con&lt;/strong&gt; &lt;code&gt;type conversion&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9d647aeb173e83a0130624d9b11d9a6aca4c3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; operator just checks the value of the variables for equality.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; operador == solo verifica el valor de las variables para la igualdad.</target>
        </trans-unit>
        <trans-unit id="86a40c35943be312d26be58ed590bcd3dd325425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; Returns &lt;code&gt;true&lt;/code&gt; if the operands are strictly equal (see above)
  with no type conversion.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; Devuelve &lt;code&gt;true&lt;/code&gt; si los operandos son estrictamente iguales (ver arriba) sin conversi&amp;oacute;n de tipo.</target>
        </trans-unit>
        <trans-unit id="9d0976f976a35ebb6ebe62b08679b2e138576dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;without&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; significa &lt;strong&gt;comparaci&amp;oacute;n&lt;/strong&gt; entre operandos &lt;strong&gt;sin&lt;/strong&gt; &lt;code&gt;type conversion&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54e23978f1caf3d9c1511fb347612a2b3442e552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator  checks the values as well as the types of the variables for equality.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; operador comprueba los valores, as&amp;iacute; como los tipos de las variables para la igualdad.</target>
        </trans-unit>
        <trans-unit id="0784b02b5003c7729e030d9b7d490e95bab806f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator in javascript &lt;strong&gt;checks value as well as type&lt;/strong&gt; where as &lt;code&gt;==&lt;/code&gt; operator just checks &lt;strong&gt;the value (does type conversion if required)&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; operador === en javascript &lt;strong&gt;verifica el valor y escribe&lt;/strong&gt; donde como &lt;code&gt;==&lt;/code&gt; el operador solo verifica &lt;strong&gt;el valor (escribe conversi&amp;oacute;n si es necesario)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e191a0a45be586c4c0bba711c1f56571fe4d8f4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both strings and contain the exact same characters</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; devuelve verdadero si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; son ambas cadenas y contienen exactamente los mismos caracteres</target>
        </trans-unit>
        <trans-unit id="c03f97f96e2f5f2837a1f086b8eb03c59b00a165" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same value and are of the same type</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; devuelve verdadero si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; tienen el mismo valor y son del mismo tipo</target>
        </trans-unit>
        <trans-unit id="0b9afde54d1a9e309f7f55b08fcee09754103a72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reference the exact same object</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; devuelve verdadero si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; hacen referencia al mismo objeto exacto</target>
        </trans-unit>
        <trans-unit id="a569658b84c50eebdb4a105bf59c6e932a3a246e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;The equal comparison operator == is confusing and should be avoided.&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;El operador de comparaci&amp;oacute;n igual == es confuso y debe evitarse.&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e7e53458508d6e51aeb7d6a48cf2891cadddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.2.2 The new Operator&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;11.2.2 El nuevo operador&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="7998aff2909b6b4706d92805f6351ca4f05e7bf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.9.6 The Strict Equality Comparison Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;11.9.6 El algoritmo estricto de comparaci&amp;oacute;n de igualdad&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6991c2660c1bca00359ab71ad6adcfdf32c7a356" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For reference types:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Para tipos de referencia:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b281c590fb85b87b5d11f1a04a3b17b4b081d21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For strings:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Para cuerdas:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a449c178aebbeb356e9012aeb4b469de6ac6e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For value types (numbers):&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Para los tipos de valor (n&amp;uacute;meros):&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f73c5c4818316a7e7ba83421501c2687aba89eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;If in doubt, read the &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;specification&lt;/a&gt;!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;En caso de duda, lea la &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;especificaci&amp;oacute;n&lt;/a&gt; !&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b1bf8ddd0de3be690c43c624391f8937688d9e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Moral of the story:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Moraleja de la historia:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83c7151c0c6f7fb762f855eb85e50c829ea14a0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Use &lt;code&gt;===&lt;/code&gt; unless you fully understand the
  conversions that take place with &lt;code&gt;==&lt;/code&gt;.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Use &lt;code&gt;===&lt;/code&gt; a menos que entienda completamente las conversiones que tienen lugar con &lt;code&gt;==&lt;/code&gt; .&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef127aa6ac9121f82176c29f76864dbb36fe4c2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;==&lt;/code&gt; for JavaScript equality testing, some
  funky conversions take place.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Cuando se utiliza &lt;code&gt;==&lt;/code&gt; para las pruebas de igualdad de JavaScript, se producen algunas conversiones originales.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77298b36a9fcbaf746d98e1bc74886ea8bbddcff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;===&lt;/code&gt; for JavaScript equality testing, everything is as is. Nothing gets converted before being evaluated.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Cuando se usa &lt;code&gt;===&lt;/code&gt; para la prueba de igualdad de JavaScript, todo es como es.&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Nada se convierte antes de ser evaluado.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5583d977f70290bf3ad57016e11eed7fe1b944f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of doubt, learn by heart the following truth table:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;En caso de duda, aprenda de memoria la siguiente tabla de verdad:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4e32406ca5087fb220aee87a9159a70a2cf49c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In summary&lt;/strong&gt;; using the &lt;strong&gt;==&lt;/strong&gt; operator might evaluate to true in situations where you do not want it to so using the &lt;strong&gt;===&lt;/strong&gt; operator would be safer.</source>
          <target state="translated">&lt;strong&gt;En resumen&lt;/strong&gt; ; el uso del operador &lt;strong&gt;==&lt;/strong&gt; podr&amp;iacute;a evaluar como verdadero en situaciones en las que no lo desee, por lo que usar el operador &lt;strong&gt;===&lt;/strong&gt; ser&amp;iacute;a m&amp;aacute;s seguro.</target>
        </trans-unit>
        <trans-unit id="0fc148d6649bd47fe8e2b7cf2467f19d0bf69fd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not transitive: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(b == c)&lt;/em&gt; does not lead to &lt;em&gt;(a == c)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;No es transitivo: &lt;em&gt;(a == b)&lt;/em&gt; y &lt;em&gt;(b == c)&lt;/em&gt; no conduce a &lt;em&gt;(a == c)&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b0a31f565c1a8710eee82d40a2198e9e2ade2a15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's mutually exclusive to its negation: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(a != b)&lt;/em&gt; always hold opposite Boolean values, with all a and b.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Se excluye mutuamente de su negaci&amp;oacute;n: &lt;em&gt;(a == b)&lt;/em&gt; y &lt;em&gt;(a! = B)&lt;/em&gt; siempre tienen valores booleanos opuestos, con todos a y b.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2a6eb120ac5d954b7aa47baca4f35f487d47fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e15c6bff6033a446fc6a95bbcaedcb5920c62e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So the moral of the story is...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Entonces la moraleja de la historia es ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f68664c3d5e1f0872cc0f7095d28293c50692b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what does this mean?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Entonces, &amp;iquest;qu&amp;eacute; significa esto?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcffb768a62952b163df247d1df132d1d92ba1ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source: &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http://dorey.github.io/JavaScript-Equality-Table/&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Fuente: &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http://dorey.github.io/JavaScript-Equality-Table/&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3572e23516a3bbfc97277c54e9df478818214273" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Then weirder with strings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Luego m&amp;aacute;s raro con cuerdas&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4799deaf7c2bdd75e811e68dfa65cd85a9318390" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Things get really weird with arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Las cosas se ponen realmente extra&amp;ntilde;as con los arreglos.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c6910a7c92878ee22dbd03dfb0a4072532d90db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When is equal not equal?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Cu&amp;aacute;ndo es igual no igual?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8eb43dbcbcd365843d41af200d644bb6817377de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why &lt;code&gt;==&lt;/code&gt; is so unpredictable?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Por qu&amp;eacute; &lt;code&gt;==&lt;/code&gt; es tan impredecible?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="158e452fe7b5ed683ae60f76da327fa38cec4251" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why does this happen?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Por qu&amp;eacute; pas&amp;oacute; esto?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3471db61bc9f6d45c5cdde69581a956986a6defd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes!&lt;/strong&gt; It does matter.</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;Si!&lt;/strong&gt; Si importa.</target>
        </trans-unit>
        <trans-unit id="72675d0e476a995d0975566582a364150fca52f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;new&lt;/strong&gt; always returns an Object, even for &lt;strong&gt;String&lt;/strong&gt; constructors, too. And alas! The value semantics for strings (see step 11) is lost.</source>
          <target state="translated">&lt;strong&gt;new&lt;/strong&gt; siempre devuelve un Object, incluso para los constructores de &lt;strong&gt;cadenas&lt;/strong&gt; . Y por desgracia! La sem&amp;aacute;ntica de valor para cadenas (consulte el paso 11) se pierde.</target>
        </trans-unit>
        <trans-unit id="b7f0cbff18eeec5852f5ea8c1be766cd8cf6a45d" translate="yes" xml:space="preserve">
          <source>A good point was brought up by &lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt; in the comments and in &lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;@Phillipe Laybaert's&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/957602/1288&quot;&gt;answer&lt;/a&gt; concerning reference types.  For reference types &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; act consistently with one another (except in a special case).</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt; trajo un buen punto en los comentarios y en &lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;la&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/957602/1288&quot;&gt;respuesta de&lt;/a&gt; @Phillipe Laybaert con respecto a los tipos de referencia. Para los tipos de referencia &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;===&lt;/code&gt; act&amp;uacute;an de manera consistente entre s&amp;iacute; (excepto en un caso especial).</target>
        </trans-unit>
        <trans-unit id="8b54302e5ddc3ab8451d73b4e6fbcce29f1fb9c2" translate="yes" xml:space="preserve">
          <source>A simple example is</source>
          <target state="translated">Un ejemplo simple es</target>
        </trans-unit>
        <trans-unit id="4e666e628adc9d3ae32638bd884bee95473bd54e" translate="yes" xml:space="preserve">
          <source>Aidiakapi wrote this in a comment below:</source>
          <target state="translated">Aidiakapi escribió esto en un comentario abajo:</target>
        </trans-unit>
        <trans-unit id="a54a3ffda19eea85fbc25119ad4dce8fb1e843e4" translate="yes" xml:space="preserve">
          <source>All returns true and you may not want this. Let's suppose you have a function that can return the 0th index of an array or false on failure. If you check with &quot;==&quot; false, you can get a confusing result.</source>
          <target state="translated">Todo vuelve a la realidad y puede que no quieras esto.Supongamos que tienes una función que puede devolver el índice 0 de una matriz o falso en caso de fallo.Si compruebas con &quot;==&quot; false,puedes obtener un resultado confuso.</target>
        </trans-unit>
        <trans-unit id="8742264e60f01ff6e597018b6c9b30ad6c84fa0b" translate="yes" xml:space="preserve">
          <source>An interesting pictorial representation of the equality comparison between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">Una representaci&amp;oacute;n pict&amp;oacute;rica interesante de la comparaci&amp;oacute;n de igualdad entre &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;===&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c1a994f0cb44644f821ea4b44798e564cbb1e78" translate="yes" xml:space="preserve">
          <source>And it doesn't end there, here's another one:</source>
          <target state="translated">Y no termina ahí,aquí hay otro:</target>
        </trans-unit>
        <trans-unit id="fcab40bf0cf2cc434eb0ce086ee4dfadcbc91121" translate="yes" xml:space="preserve">
          <source>And this finally means: &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">Y esto finalmente significa: &lt;strong&gt;nueva cadena (&quot;a&quot;)! == &quot;a&quot;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c997d053fe7d55a1f5eb3f9358b3b7760fec29e8" translate="yes" xml:space="preserve">
          <source>And this is just the crazy stuff you get with primitives.</source>
          <target state="translated">Y esto es sólo la locura que se obtiene con los primitivos.</target>
        </trans-unit>
        <trans-unit id="9353a89820dfa87107beffc7a1a273e498311936" translate="yes" xml:space="preserve">
          <source>Another common example:</source>
          <target state="translated">Otro ejemplo común:</target>
        </trans-unit>
        <trans-unit id="bb0313b7b5d894d38b25b3429130ff71d7450726" translate="yes" xml:space="preserve">
          <source>Any performance improvement would be welcomed as many comparison operators exist.</source>
          <target state="translated">Cualquier mejora del rendimiento sería bienvenida,ya que existen muchos operadores de comparación.</target>
        </trans-unit>
        <trans-unit id="ebdf4e9004e5ae311bc10c04cc1657d844cc2b1e" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, I would generally use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (and &lt;code&gt;!==&lt;/code&gt; instead of &lt;code&gt;!=&lt;/code&gt;).</source>
          <target state="translated">Como regla general, generalmente usar&amp;iacute;a &lt;code&gt;===&lt;/code&gt; en lugar de &lt;code&gt;==&lt;/code&gt; (y &lt;code&gt;!==&lt;/code&gt; lugar de &lt;code&gt;!=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13b3f53e194e780033d076d6dfdef27478b25e97" translate="yes" xml:space="preserve">
          <source>As the conclusion states:</source>
          <target state="translated">Como dice la conclusión:</target>
        </trans-unit>
        <trans-unit id="2c8f8302c2c50753cc3fc038d29edd38e7d27241" translate="yes" xml:space="preserve">
          <source>At this point your probably wondering...</source>
          <target state="translated">En este punto,probablemente te estés preguntando...</target>
        </trans-unit>
        <trans-unit id="78a365d1c42cbfa956f22145534e940bf6aa204f" translate="yes" xml:space="preserve">
          <source>Because it's complicated it's hard to know what's going to happen when you use it.</source>
          <target state="translated">Debido a que es complicado,es difícil saber qué va a pasar cuando lo uses.</target>
        </trans-unit>
        <trans-unit id="6d67a31310a8174d28abedb216692a809603aaa3" translate="yes" xml:space="preserve">
          <source>But how about this?:</source>
          <target state="translated">Pero,¿qué tal esto?</target>
        </trans-unit>
        <trans-unit id="c0360df7ca51ade50469aaf2a05a01615c88e9dd" translate="yes" xml:space="preserve">
          <source>But personally I would do what JSLint suggests. This recommendation is there not because of performance issues, but because type coercion means &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; is true.</source>
          <target state="translated">Pero personalmente har&amp;iacute;a lo que sugiere JSLint. Esta recomendaci&amp;oacute;n no existe debido a problemas de rendimiento, sino porque la coerci&amp;oacute;n de tipo significa &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; es verdadera.</target>
        </trans-unit>
        <trans-unit id="fbdab286eda606977bf3a9c58a18c188200a37c4" translate="yes" xml:space="preserve">
          <source>Common example:</source>
          <target state="translated">Ejemplo común:</target>
        </trans-unit>
        <trans-unit id="f64d819276a8e60d2cf4282031ed91641ea77411" translate="yes" xml:space="preserve">
          <source>ECMA-262 is the specification for a scripting language of which JavaScript is a dialect. Of course in practice it matters more how the most important browsers behave than an esoteric definition of how something is supposed to be handled. But it is helpful to understand why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">ECMA-262 es la especificaci&amp;oacute;n para un lenguaje de script del cual JavaScript es un dialecto. Por supuesto, en la pr&amp;aacute;ctica, importa m&amp;aacute;s c&amp;oacute;mo se comportan los navegadores m&amp;aacute;s importantes que una definici&amp;oacute;n esot&amp;eacute;rica de c&amp;oacute;mo se supone que se debe manejar algo. Pero es &amp;uacute;til entender por qu&amp;eacute; la &lt;strong&gt;nueva cadena (&quot;a&quot;)! == &quot;a&quot;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dd5ffe9d4172fd93e2644ec55bff755f2376bde5" translate="yes" xml:space="preserve">
          <source>EQUAL OPERATOR TRUTH TABLE IN JAVASCRIPT</source>
          <target state="translated">TABLA DE VERDAD DE OPERADORES IGUALES EN JAVASCRIPT</target>
        </trans-unit>
        <trans-unit id="c0cc6f9b7554c74df1b7cae7c6ef1f64783063e0" translate="yes" xml:space="preserve">
          <source>Each row in the table is a set of 3 mutually &quot;equal&quot; values, meaning that any 2 values among them are equal using the equal == sign*</source>
          <target state="translated">Cada fila de la tabla es un conjunto de 3 valores mutuamente &quot;iguales&quot;,lo que significa que cualesquiera 2 valores entre ellos son iguales usando el igual ==signo*</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58b2ed100a4c02f3e223f19e77f4fc970f37bc3e" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&quot;a == b&quot;&lt;/strong&gt; to evaluate to true a and b need to be the &lt;strong&gt;same value&lt;/strong&gt;.</source>
          <target state="translated">Para que &lt;strong&gt;&quot;a == b&quot; se&lt;/strong&gt; eval&amp;uacute;e como verdadero a y b deben tener el &lt;strong&gt;mismo valor&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="38827ea4d22912a8579010ad9d43caaae3a33e79" translate="yes" xml:space="preserve">
          <source>For example jQuery 1.9.1 uses this pattern 43 times, and  the &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;JSHint syntax checker&lt;/a&gt; even provides the &lt;code&gt;eqnull&lt;/code&gt; relaxing option for this reason.</source>
          <target state="translated">Por ejemplo, jQuery 1.9.1 usa este patr&amp;oacute;n 43 veces, y el &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;verificador de sintaxis JSHint&lt;/a&gt; incluso proporciona la opci&amp;oacute;n de relajaci&amp;oacute;n &lt;code&gt;eqnull&lt;/code&gt; por este motivo.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="3b5af0e25b6d033fced42a264a3e0862e363a6cc" translate="yes" xml:space="preserve">
          <source>For example, if you have:</source>
          <target state="translated">Por ejemplo,si usted tiene:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="93d53aae8f4cbac1a7160cd657ddf2e114550792" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;jQuery style guide&lt;/a&gt;:</source>
          <target state="translated">De la &lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;gu&amp;iacute;a de estilo jQuery&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="519a4ac6eaa68eb2f5a55813ad6c7b39e2e3c9a5" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;core javascript reference&lt;/a&gt;</source>
          <target state="translated">Desde la &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;referencia central de JavaScript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33d6d15bce91547d5c6e839acec0e386194d3e54" translate="yes" xml:space="preserve">
          <source>From the specification</source>
          <target state="translated">De la especificación</target>
        </trans-unit>
        <trans-unit id="078ecfcf86b689086aece409c4dd9d3597272bc8" translate="yes" xml:space="preserve">
          <source>Google for implicit conversions in C++ and &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; to get some of the arguments against it...</source>
          <target state="translated">Google para conversiones impl&amp;iacute;citas en C ++ y &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; para obtener algunos de los argumentos en su contra ...</target>
        </trans-unit>
        <trans-unit id="5532825dcc419a2c608b4660ff4df27ee7b64e3b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; do not have values. Whereas, 0, false and '' are all values. One thing common beween all these are that they are all falsy values, which means they all &lt;strong&gt;satisfy&lt;/strong&gt; falsy conditions.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;b&lt;/code&gt; no tienen valores. Mientras que 0, falso y '' son todos valores. Una cosa com&amp;uacute;n entre todos estos es que todos son valores falsos, lo que significa que todos &lt;strong&gt;satisfacen&lt;/strong&gt; condiciones falsas.</target>
        </trans-unit>
        <trans-unit id="4f47052c940a268ebe245314f782cc99b18f0d6e" translate="yes" xml:space="preserve">
          <source>Here is a handy comparison table that shows the conversions that happen and the differences between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; hay una pr&amp;aacute;ctica tabla de comparaci&amp;oacute;n que muestra las conversiones que ocurren y las diferencias entre &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;===&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e780233b6b8ef08d4cfd3eb493ce561f782434f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;==&lt;/code&gt; operator is checking the values of the two objects and returning &lt;code&gt;true&lt;/code&gt;, but the &lt;code&gt;===&lt;/code&gt; is seeing that they're not the same type and returning &lt;code&gt;false&lt;/code&gt;.  Which one is correct?  That really depends on what you're trying to compare.  My advice is to bypass the question entirely and just don't use the &lt;code&gt;String&lt;/code&gt; constructor to create string objects.</source>
          <target state="translated">Aqu&amp;iacute; el operador &lt;code&gt;==&lt;/code&gt; est&amp;aacute; verificando los valores de los dos objetos y devuelve &lt;code&gt;true&lt;/code&gt; , pero el &lt;code&gt;===&lt;/code&gt; est&amp;aacute; viendo que no son del mismo tipo y devuelve &lt;code&gt;false&lt;/code&gt; . &amp;iquest;Cu&amp;aacute;l es el correcto? Eso realmente depende de lo que intentes comparar. Mi consejo es omitir la pregunta por completo y simplemente no usar el constructor de &lt;code&gt;String&lt;/code&gt; para crear objetos de cadena.</target>
        </trans-unit>
        <trans-unit id="7108ec5478e370309fc5357c0e971bd4f05bbf90" translate="yes" xml:space="preserve">
          <source>However there is &lt;strong&gt;one single exception&lt;/strong&gt;:
&lt;code&gt;== null&lt;/code&gt; is an efficient way to check for 'is null or undefined':</source>
          <target state="translated">Sin embargo, hay &lt;strong&gt;una &amp;uacute;nica excepci&amp;oacute;n&lt;/strong&gt; : &lt;code&gt;== null&lt;/code&gt; es una forma eficiente de verificar si 'es nulo o indefinido':</target>
        </trans-unit>
        <trans-unit id="f0d30f93bb4df391284d009844ff1535f26f2082" translate="yes" xml:space="preserve">
          <source>I tested this in Firefox with &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; using code like this:</source>
          <target state="translated">Prob&amp;eacute; esto en Firefox con &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; usando un c&amp;oacute;digo como este:</target>
        </trans-unit>
        <trans-unit id="7b1c18acfb2da322223032a6ca65bcb729f0ddd1" translate="yes" xml:space="preserve">
          <source>I thought strings behave like value types? Well, it depends who you ask... In this case a and b are not the same type. &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;Object&lt;/code&gt;, while &lt;code&gt;b&lt;/code&gt; is of type &lt;code&gt;string&lt;/code&gt;. Just remember that creating a string object using the &lt;code&gt;String&lt;/code&gt; constructor creates something of type &lt;code&gt;Object&lt;/code&gt; that behaves as a string &lt;em&gt;most of the time&lt;/em&gt;.</source>
          <target state="translated">&amp;iquest;Pens&amp;eacute; que las cadenas se comportan como tipos de valor? Bueno, depende de a qui&amp;eacute;n le pregunte ... En este caso, ayb no son del mismo tipo. &lt;code&gt;a&lt;/code&gt; es de tipo &lt;code&gt;Object&lt;/code&gt; , mientras que &lt;code&gt;b&lt;/code&gt; es de tipo &lt;code&gt;string&lt;/code&gt; . Solo recuerde que la creaci&amp;oacute;n de un objeto de cadena utilizando el constructor de &lt;code&gt;String&lt;/code&gt; crea algo de tipo &lt;code&gt;Object&lt;/code&gt; que se comporta como una cadena la &lt;em&gt;mayor parte del tiempo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6724c10b1c4dd89e994b59c7b65ce998cb53f9b0" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;JSLint&lt;/a&gt; to go through JavaScript, and it's returning many suggestions to replace &lt;code&gt;==&lt;/code&gt; (two equals signs) with &lt;code&gt;===&lt;/code&gt; (three equals signs) when doing things like comparing &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; inside of an &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">Estoy usando &lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;JSLint&lt;/a&gt; para pasar por JavaScript, y me devuelve muchas sugerencias para reemplazar &lt;code&gt;==&lt;/code&gt; (dos signos de igual) con &lt;code&gt;===&lt;/code&gt; (tres signos de igual) al hacer cosas como comparar &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; dentro de un &lt;code&gt;if&lt;/code&gt; declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="699383a3720b89c508893f13174fcc345a333a00" translate="yes" xml:space="preserve">
          <source>If Type(constructor) is not Object, throw a TypeError exception.</source>
          <target state="translated">Si el Tipo (constructor)no es el Objeto,lanza una excepción de TipoError.</target>
        </trans-unit>
        <trans-unit id="7c1b47bf6a1abbf554dbd0ee2168db0b303f1c1f" translate="yes" xml:space="preserve">
          <source>If both operands of == are objects, then they are compared to see if they are the same object. If both operands point to the same object, then the equal operator returns true. Otherwise,
the two are not equal.</source>
          <target state="translated">Si ambos operandos de ==son objetos,entonces se comparan para ver si son el mismo objeto.Si ambos operandos apuntan al mismo objeto,entonces el operador igual retorna true.De lo contrario,los dos no son iguales.</target>
        </trans-unit>
        <trans-unit id="cbb1a99493847058458e46837af0fc9a5702b63e" translate="yes" xml:space="preserve">
          <source>If no type conversion takes place, would there be a performance gain over &lt;code&gt;==&lt;/code&gt;?</source>
          <target state="translated">Si no se realiza una conversi&amp;oacute;n de tipo, &amp;iquest;habr&amp;iacute;a una ganancia de rendimiento superior a &lt;code&gt;==&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e27332524b113dae22c09288bee3e0f34778ca3c" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;HAVE TO&lt;/strong&gt; live with it, then remember the following 3 things:</source>
          <target state="translated">Si &lt;strong&gt;TIENES QUE&lt;/strong&gt; vivir con eso, recuerda las siguientes 3 cosas:</target>
        </trans-unit>
        <trans-unit id="ba83b649d7ac77ee88b91662e9dc19d8d2569046" translate="yes" xml:space="preserve">
          <source>If you wonder why &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; does not return a string, how about some exercise reading a specification? Have fun!</source>
          <target state="translated">Si se pregunta por qu&amp;eacute; &lt;strong&gt;new String (&quot;a&quot;)&lt;/strong&gt; no devuelve una cadena, &amp;iquest;qu&amp;eacute; tal un poco de ejercicio leyendo una especificaci&amp;oacute;n? &amp;iexcl;Que te diviertas!</target>
        </trans-unit>
        <trans-unit id="318588db3ab6c1c4c50c1ae4dd7cb47bf8189bab" translate="yes" xml:space="preserve">
          <source>In JavaScript it means of the same value and type.</source>
          <target state="translated">En JavaScript significa del mismo valor y tipo.</target>
        </trans-unit>
        <trans-unit id="4bbc85798100e8a6c2b8173b4c4cc5ff26f86121" translate="yes" xml:space="preserve">
          <source>In PHP and JavaScript, it is a strict equality operator. Which means, it will compare both type and values.</source>
          <target state="translated">En PHP y JavaScript,es un operador de estricta igualdad.Lo que significa que comparará tanto el tipo como los valores.</target>
        </trans-unit>
        <trans-unit id="0fd01d3c121d1dd02e0aad7a9a25393961f9968a" translate="yes" xml:space="preserve">
          <source>In a typical script there will be no performance difference. More important may be the fact that thousand &quot;===&quot; is 1&amp;nbsp;KB heavier than thousand &quot;==&quot; :) &lt;a href=&quot;https://stackoverflow.com/questions/tagged/javascript+performance&quot;&gt;JavaScript profilers&lt;/a&gt; can tell you if there is a performance difference in your case.</source>
          <target state="translated">En un gui&amp;oacute;n t&amp;iacute;pico no habr&amp;aacute; diferencia de rendimiento. M&amp;aacute;s importante puede ser el hecho de que mil &quot;===&quot; pesa 1 KB m&amp;aacute;s que mil &quot;==&quot; :) Los &lt;a href=&quot;https://stackoverflow.com/questions/tagged/javascript+performance&quot;&gt;perfiladores de JavaScript&lt;/a&gt; pueden decirle si hay una diferencia de rendimiento en su caso.</target>
        </trans-unit>
        <trans-unit id="0e42d567a09b4ba932e88964ee9b8587449c04d9" translate="yes" xml:space="preserve">
          <source>In fact, if you tried to write a function that does what &lt;code&gt;==&lt;/code&gt; does it would look something like this:</source>
          <target state="translated">De hecho, si intentas escribir una funci&amp;oacute;n que haga lo que &lt;code&gt;==&lt;/code&gt; hace, se ver&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="48c572d57b17fbc593b6830a7381e7378807a00f" translate="yes" xml:space="preserve">
          <source>In the 90% usage scenario it won't matter which one you use, but it is handy to know the difference when you get some unexpected behaviour one day.</source>
          <target state="translated">En el escenario de uso del 90% no importará cuál uses,pero es útil saber la diferencia cuando tengas algún comportamiento inesperado algún día.</target>
        </trans-unit>
        <trans-unit id="ec01264fb9d51cfefd427a17d74eb33ac1be156e" translate="yes" xml:space="preserve">
          <source>In the answers here, I didn't read anything about what &lt;strong&gt;equal&lt;/strong&gt; means. Some will say that &lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;equal and of the same type&lt;/strong&gt;, but that's not really true. It actually means that &lt;strong&gt;both operands reference the same object&lt;/strong&gt;, or in case of &lt;strong&gt;value types, have the same value&lt;/strong&gt;.</source>
          <target state="translated">En las respuestas aqu&amp;iacute;, no le&amp;iacute; nada sobre lo que significa &lt;strong&gt;igualdad&lt;/strong&gt; . Algunos dir&amp;aacute;n que &lt;code&gt;===&lt;/code&gt; significa &lt;strong&gt;igual y del mismo tipo&lt;/strong&gt; , pero eso no es realmente cierto. En realidad, significa que &lt;strong&gt;ambos operandos hacen referencia al mismo objeto&lt;/strong&gt; , o en el caso de &lt;strong&gt;tipos&lt;/strong&gt; de &lt;strong&gt;valor, tienen el mismo valor&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ca385d21427dba165889d58d33e6fa5704fb46b2" translate="yes" xml:space="preserve">
          <source>In the case of &lt;strong&gt;&quot;a === b&quot;&lt;/strong&gt; a and b must be the &lt;strong&gt;same value&lt;/strong&gt; and also the &lt;strong&gt;same type&lt;/strong&gt; for it to evaluate to true.</source>
          <target state="translated">En el caso de &lt;strong&gt;&quot;a === b&quot;,&lt;/strong&gt; a y b deben tener el &lt;strong&gt;mismo valor&lt;/strong&gt; y tambi&amp;eacute;n el &lt;strong&gt;mismo tipo&lt;/strong&gt; para que se eval&amp;uacute;e como verdadero.</target>
        </trans-unit>
        <trans-unit id="251bebdd324bcccca7535068065ec28cc534eae3" translate="yes" xml:space="preserve">
          <source>In the code above, both == and === get false because a and b are not the same objects.</source>
          <target state="translated">En el código anterior,ambos ==y ===se vuelven falsos porque a y b no son los mismos objetos.</target>
        </trans-unit>
        <trans-unit id="a4cd7b099967df429e07f68f296c07052c7aba52" translate="yes" xml:space="preserve">
          <source>Interesting is step 11. Yes, strings are treated as value types. But this does not explain why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;. Do we have a browser not conforming to ECMA-262?</source>
          <target state="translated">Interesante es el paso 11. S&amp;iacute;, las cadenas se tratan como tipos de valor. Pero esto no explica por qu&amp;eacute; &lt;strong&gt;nueva cadena (&quot;a&quot;)! == &quot;a&quot;&lt;/strong&gt; . &amp;iquest;Tenemos un navegador que no cumple con ECMA-262?</target>
        </trans-unit>
        <trans-unit id="cd2c230db52d16c62fde2c29f3b5aa18ff6b95af" translate="yes" xml:space="preserve">
          <source>Is there a performance benefit to replacing &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;===&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Existe un beneficio de rendimiento al reemplazar &lt;code&gt;==&lt;/code&gt; con &lt;code&gt;===&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="6208d5e465527e22f406b99578ad5d55c45f7cb9" translate="yes" xml:space="preserve">
          <source>It checks if same sides are equal in &lt;strong&gt;type&lt;/strong&gt; as well as &lt;strong&gt;value&lt;/strong&gt;.</source>
          <target state="translated">Comprueba si los mismos lados son iguales en &lt;strong&gt;tipo&lt;/strong&gt; y &lt;strong&gt;valor&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3b33800c6e21e7706b86e94308ae2b6ade92ea2c" translate="yes" xml:space="preserve">
          <source>It get's pretty wacky.</source>
          <target state="translated">Se pone bastante loco.</target>
        </trans-unit>
        <trans-unit id="0c3489421f48aca78ca26cbeacff41a88d0a2485" translate="yes" xml:space="preserve">
          <source>It get's worse:</source>
          <target state="translated">Se pone peor:</target>
        </trans-unit>
        <trans-unit id="2461a72119f69288570a91dd4886cf1946921ace" translate="yes" xml:space="preserve">
          <source>It has special handling for functions, special handling for nulls, undefined, strings, you name it.</source>
          <target state="translated">Tiene un manejo especial para las funciones,un manejo especial para nulos,indefinidos,cuerdas,lo que sea.</target>
        </trans-unit>
        <trans-unit id="e7800c4331282e121e342d6b81303384bd272938" translate="yes" xml:space="preserve">
          <source>It is faster only when the types are not the same, in which case it does not try to convert types but directly returns a false.</source>
          <target state="translated">Es más rápido sólo cuando los tipos no son los mismos,en cuyo caso no intenta convertir los tipos sino que devuelve directamente un falso.</target>
        </trans-unit>
        <trans-unit id="faa77444bfb36c5ba995cd19f29530d0943b04a1" translate="yes" xml:space="preserve">
          <source>It means &lt;code&gt;==&lt;/code&gt; is complicated.</source>
          <target state="translated">Significa que &lt;code&gt;==&lt;/code&gt; es complicado.</target>
        </trans-unit>
        <trans-unit id="a65b5bfaad127fd93d57e6ab192d490bc11ac353" translate="yes" xml:space="preserve">
          <source>It means &lt;strong&gt;equality without type coercion&lt;/strong&gt;
type coercion means JavaScript do not automatically convert any other data types to string data types</source>
          <target state="translated">Significa &lt;strong&gt;igualdad sin coerci&amp;oacute;n de tipo coerci&amp;oacute;n de&lt;/strong&gt; tipo significa que JavaScript no convierte autom&amp;aacute;ticamente ning&amp;uacute;n otro tipo de datos a tipos de datos de cadena</target>
        </trans-unit>
        <trans-unit id="4cc792e792c928abedc18234163e220b2c90215c" translate="yes" xml:space="preserve">
          <source>It's a good thing especially if you're checking between 0 and false and null.</source>
          <target state="translated">Es algo bueno,sobre todo si se comprueba entre 0 y falso y nulo.</target>
        </trans-unit>
        <trans-unit id="76814442e2351cc8045391978fecf4190730bd23" translate="yes" xml:space="preserve">
          <source>It's a strict check test.</source>
          <target state="translated">Es una prueba de control estricta.</target>
        </trans-unit>
        <trans-unit id="c194b6748d81866560cca42c3ec80275ce25b0fa" translate="yes" xml:space="preserve">
          <source>It's a whole new level of crazy when you use &lt;code&gt;==&lt;/code&gt; with objects.</source>
          <target state="translated">Es un nivel completamente nuevo de locura cuando usas &lt;code&gt;==&lt;/code&gt; con objetos.</target>
        </trans-unit>
        <trans-unit id="7e5685be28423b6fa9a147ecdfab572abc4a40a1" translate="yes" xml:space="preserve">
          <source>JSLint sometimes gives you unrealistic reasons to modify stuff. &lt;code&gt;===&lt;/code&gt; has exactly the same performance as &lt;code&gt;==&lt;/code&gt; if the types are already the same.</source>
          <target state="translated">JSLint a veces te da razones poco realistas para modificar cosas. &lt;code&gt;===&lt;/code&gt; tiene exactamente el mismo rendimiento que &lt;code&gt;==&lt;/code&gt; si los tipos ya son los mismos.</target>
        </trans-unit>
        <trans-unit id="6f75f5a9d4e62f008ab83040158a6ea4c2ffb8de" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;===&lt;/code&gt;&lt;strong&gt;vs&lt;/strong&gt;&lt;code&gt;==&lt;/code&gt; .</source>
          <target state="translated">JavaScript &lt;code&gt;===&lt;/code&gt; &lt;strong&gt;vs&lt;/strong&gt; &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f50ece919837ed27b6fe25229b9c0edd82a3a80" translate="yes" xml:space="preserve">
          <source>JavaScript has two sets of equality operators: &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;, and their evil twins &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.  The good ones work the way you would expect.  If the two operands are of the same type and have the same value, then &lt;code&gt;===&lt;/code&gt; produces &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt; produces &lt;code&gt;false&lt;/code&gt;.  The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values.  the rules by which they do that are complicated and unmemorable.  These are some of the interesting cases:</source>
          <target state="translated">JavaScript tiene dos conjuntos de operadores de igualdad: &lt;code&gt;===&lt;/code&gt; y &lt;code&gt;!==&lt;/code&gt; , y sus gemelos malvados &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt; . Los buenos funcionan como cabr&amp;iacute;a esperar. Si los dos operandos son del mismo tipo y tienen el mismo valor, entonces &lt;code&gt;===&lt;/code&gt; produce &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;!==&lt;/code&gt; produce &lt;code&gt;false&lt;/code&gt; . Los gemelos malvados hacen lo correcto cuando los operandos son del mismo tipo, pero si son de diferentes tipos, intentan forzar los valores. las reglas por las cuales hacen eso son complicadas e inmemorables. Estos son algunos de los casos interesantes:</target>
        </trans-unit>
        <trans-unit id="ddcc47139dece09713aae28867a0635754940c72" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for non strict equality / comparison '=='</source>
          <target state="translated">Diagrama de flujo de ejecución de Javascript para la comparación de igualdad no estricta '=='.</target>
        </trans-unit>
        <trans-unit id="c489836ec904339790b4e755108af00367792205" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for strict equality / Comparison '==='</source>
          <target state="translated">Diagrama de flujo de ejecución de Javascript para la igualdad estricta Comparación &quot;===</target>
        </trans-unit>
        <trans-unit id="8a105feba0ec261aeed869b80ed97fd71c7d981b" translate="yes" xml:space="preserve">
          <source>Let me add this counsel:</source>
          <target state="translated">Permítame añadir este consejo:</target>
        </trans-unit>
        <trans-unit id="b78f589e89c4bf85c5acdcf503fa3ce05322739a" translate="yes" xml:space="preserve">
          <source>Let me say that again:</source>
          <target state="translated">Déjame decirlo otra vez:</target>
        </trans-unit>
        <trans-unit id="7dc48ae18a400d363e4e831b1bc3f62fa17e236b" translate="yes" xml:space="preserve">
          <source>Let's check the types of the operands. Try it out for yourself by wrapping them in &lt;strong&gt;typeof()&lt;/strong&gt;. I find that &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; is an object, and step 1 is used: return &lt;strong&gt;false&lt;/strong&gt; if the types are different.</source>
          <target state="translated">Verifiquemos los tipos de los operandos. Pru&amp;eacute;belo usted mismo envolvi&amp;eacute;ndolos en &lt;strong&gt;typeof ()&lt;/strong&gt; . Encuentro que la &lt;strong&gt;nueva Cadena (&quot;a&quot;)&lt;/strong&gt; es un objeto, y se utiliza el paso 1: devuelve &lt;strong&gt;falso&lt;/strong&gt; si los tipos son diferentes.</target>
        </trans-unit>
        <trans-unit id="b61e7aec3e99c633efdc11e39208fc2dff1d3e2c" translate="yes" xml:space="preserve">
          <source>Lets take 2 vars a and b.</source>
          <target state="translated">Tomemos 2 frascos a y b.</target>
        </trans-unit>
        <trans-unit id="cfd185a2bd37b57a50c809cfa0d84c8e0b4f3ff4" translate="yes" xml:space="preserve">
          <source>Make your life less complicated.</source>
          <target state="translated">Haz tu vida menos complicada.</target>
        </trans-unit>
        <trans-unit id="63b41e8cde051766ea25feb26773d03ab2db614d" translate="yes" xml:space="preserve">
          <source>Meaning, there is no reason to change &lt;code&gt;==&lt;/code&gt; to &lt;code&gt;===&lt;/code&gt; in a check like &lt;code&gt;if (a == 'test')&lt;/code&gt; when you know it for a fact that a can only be a String.</source>
          <target state="translated">Es decir, no hay ninguna raz&amp;oacute;n para cambiar &lt;code&gt;==&lt;/code&gt; a &lt;code&gt;===&lt;/code&gt; en una verificaci&amp;oacute;n como &lt;code&gt;if (a == 'test')&lt;/code&gt; cuando se sabe que a solo puede ser una Cadena.</target>
        </trans-unit>
        <trans-unit id="0938c27e70c1f172175d9d18522b01f7447aea0e" translate="yes" xml:space="preserve">
          <source>Modifying a lot of code that way wastes developers' and reviewers' time and achieves nothing.</source>
          <target state="translated">Modificar mucho código de esa manera hace perder el tiempo de los desarrolladores y revisores y no logra nada.</target>
        </trans-unit>
        <trans-unit id="f4cefe7cd2cd184bb73ed4c344cfc83710bb0d62" translate="yes" xml:space="preserve">
          <source>My results (tested five times each and averaged):</source>
          <target state="translated">Mis resultados (probados cinco veces cada uno y promediados):</target>
        </trans-unit>
        <trans-unit id="f0da046224ce2dc3106a3b60cd5d194e6ba42983" translate="yes" xml:space="preserve">
          <source>Not so fast!</source>
          <target state="translated">¡No tan rápido!</target>
        </trans-unit>
        <trans-unit id="d5b784c68e01c822fc3215d8b23457f17bc7b95f" translate="yes" xml:space="preserve">
          <source>Now it becomes interesting:</source>
          <target state="translated">Ahora se vuelve interesante:</target>
        </trans-unit>
        <trans-unit id="26cf870c221ea623ca6c9613122347141c9e0338" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;strong&gt;identity operator &lt;code&gt;===&lt;/code&gt; does not do type coercion&lt;/strong&gt;, and thus does not convert the values when comparing, and is therefore faster (as according to &lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;This JS benchmark&lt;/a&gt; test) as it skips one step.</source>
          <target state="translated">Por otro lado, el &lt;strong&gt;operador de identidad &lt;code&gt;===&lt;/code&gt; no realiza la coerci&amp;oacute;n de tipo&lt;/strong&gt; y, por lo tanto, no convierte los valores al comparar y, por lo tanto, es m&amp;aacute;s r&amp;aacute;pido (seg&amp;uacute;n &lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;esta&lt;/a&gt; prueba de referencia JS ), ya que omite un paso.</target>
        </trans-unit>
        <trans-unit id="bb6871c5d84a4419ab95dc8eece8700504fdd6d6" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;==&lt;/code&gt;</source>
          <target state="translated">Operador &lt;code&gt;==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f06b526b15c78330ed724b58112444a30169da4d" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">Operador &lt;code&gt;===&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7a3d854bfa0266e9c4a954b8a4122785d12b7cc" translate="yes" xml:space="preserve">
          <source>Or even:</source>
          <target state="translated">O incluso:</target>
        </trans-unit>
        <trans-unit id="596eba5f701a564c8f484f75e8abdc3dd9152672" translate="yes" xml:space="preserve">
          <source>Please let me explain how to read the specification to clarify this question. I see that in this very old topic nobody had an answer for the very strange effect. So, if you can read a specification, this will help you in your profession tremendously. It is an acquired skill. So, let's continue.</source>
          <target state="translated">Por favor,déjeme explicarle cómo leer la especificación para aclarar esta pregunta.Veo que en este tema tan antiguo nadie tenía una respuesta para el efecto tan extraño.Así que,si puede leer una especificación,esto le ayudará en su profesión tremendamente.Es una habilidad adquirida.Así que,continuemos.</target>
        </trans-unit>
        <trans-unit id="2a07e2d0f6f8e8b2cf427f387c24f9c27a381095" translate="yes" xml:space="preserve">
          <source>Reasons are explained in in the answers above and also Douglas Crockford is pretty clear about it (&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;).</source>
          <target state="translated">Las razones se explican en las respuestas anteriores y tambi&amp;eacute;n Douglas Crockford lo tiene bastante claro ( &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d15ebe82de3e2a210aaf6dba6213d7558919e153" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;Javascript Tutorial: Comparison Operators&lt;/a&gt;</source>
          <target state="translated">Referencia: &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;Tutorial de Javascript: Operadores de comparaci&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ea0f0fa0757bccc8812f547b6f8ef97346e64a" translate="yes" xml:space="preserve">
          <source>Returns true if both operands are equal and of the same type. It's generally 
better and safer if you compare this way, because there's no behind-the-scenes type conversions.</source>
          <target state="translated">Vuelve a ser cierto si ambos operandos son iguales y del mismo tipo.Generalmente es mejor y más seguro si se compara de esta manera,porque no hay conversiones de tipo entre bastidores.</target>
        </trans-unit>
        <trans-unit id="957512be3223fc2dc3834f75c1dd58acecceff86" translate="yes" xml:space="preserve">
          <source>Returns true, when both operands are equal. The operands are converted to the same type before being compared.</source>
          <target state="translated">Vuelve a ser cierto,cuando ambos operandos son iguales.Los operandos se convierten al mismo tipo antes de ser comparados.</target>
        </trans-unit>
        <trans-unit id="38ce9002bb36040cd6c2edf6d1d18fcb9a616b7a" translate="yes" xml:space="preserve">
          <source>Searching the PDF file for === brings me to page 56 of the specification: &lt;strong&gt;11.9.4. The Strict Equals Operator ( === )&lt;/strong&gt;, and after wading through the specificationalese I find:</source>
          <target state="translated">Buscar en el archivo PDF === me lleva a la p&amp;aacute;gina 56 de la especificaci&amp;oacute;n: &lt;strong&gt;11.9.4.&lt;/strong&gt; &lt;strong&gt;El operador estricto igual (===)&lt;/strong&gt; , y despu&amp;eacute;s de leer las especificaciones, encuentro:</target>
        </trans-unit>
        <trans-unit id="91af0d8b760b9aafb600d14166c0c131354b13a6" translate="yes" xml:space="preserve">
          <source>Simply</source>
          <target state="translated">Simply</target>
        </trans-unit>
        <trans-unit id="64c21976a1564e95206be932a9271ff8e6100731" translate="yes" xml:space="preserve">
          <source>So I'd say that the miniscule difference (this is over 100000 iterations, remember) is negligible. Performance &lt;strong&gt;&lt;em&gt;isn't&lt;/em&gt;&lt;/strong&gt; a reason to do &lt;code&gt;===&lt;/code&gt;. Type safety (well, as safe as you're going to get in JavaScript), and code quality is.</source>
          <target state="translated">Entonces dir&amp;iacute;a que la min&amp;uacute;scula diferencia (esto es m&amp;aacute;s de 100000 iteraciones, recuerde) es insignificante. El rendimiento &lt;strong&gt;&lt;em&gt;no es&lt;/em&gt;&lt;/strong&gt; una raz&amp;oacute;n para hacerlo &lt;code&gt;===&lt;/code&gt; . Escriba seguridad (bueno, tan seguro como va a obtener en JavaScript), y la calidad del c&amp;oacute;digo es.</target>
        </trans-unit>
        <trans-unit id="ae0f3a56366851cea007b0cc3ec71cfe6236267c" translate="yes" xml:space="preserve">
          <source>So with the same thing as above, but a strict test:</source>
          <target state="translated">Así que con lo mismo que arriba,pero con una prueba estricta:</target>
        </trans-unit>
        <trans-unit id="3c48ceb341b7974b0c35d68232de996773594700" translate="yes" xml:space="preserve">
          <source>So, &lt;em&gt;IMHO,&lt;/em&gt; JSLint maybe used to write new code, but useless over-optimizing should be avoided at all costs.</source>
          <target state="translated">Entonces, en &lt;em&gt;mi humilde opini&amp;oacute;n,&lt;/em&gt; JSLint puede usarse para escribir c&amp;oacute;digo nuevo, pero se debe evitar a toda costa la optimizaci&amp;oacute;n excesiva in&amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="f5331af50eaf804f03f6a6159c25f1bb07cd7a40" translate="yes" xml:space="preserve">
          <source>So, let's take the following code:</source>
          <target state="translated">Entonces,tomemos el siguiente código:</target>
        </trans-unit>
        <trans-unit id="93b72b7d5b6694715afdca6d3fa8931c4d1db958" translate="yes" xml:space="preserve">
          <source>So, the 0, false and '' together form a sub-group. And on other hand, null &amp;amp; undefined form the second sub-group. Check the comparisons in the below image. null and undefined would equal. The other three would equal to each other. But, they all are treated as falsy conditions in JavaScript.</source>
          <target state="translated">Entonces, el 0, falso y '' juntos forman un subgrupo. Y por otro lado, nulo e indefinido forman el segundo subgrupo. Verifique las comparaciones en la imagen de abajo. nulo e indefinido ser&amp;iacute;a igual. Los otros tres ser&amp;iacute;an iguales entre s&amp;iacute;. Pero, todos se tratan como condiciones falsas en JavaScript.</target>
        </trans-unit>
        <trans-unit id="1a279fa74ab72ad3bcba6d6c656bd5ebc3d0eab4" translate="yes" xml:space="preserve">
          <source>Strict equality checks (===) should be used in favor of ==. The only
  exception is when checking for undefined and null by way of null.</source>
          <target state="translated">Las comprobaciones de igualdad estrictas (===)deben usarse a favor de ==.La única excepción es cuando se comprueba la indefinición y la nulidad por medio de la nulidad.</target>
        </trans-unit>
        <trans-unit id="1d6d9051f3abc1e1858ebeb652dd4b2cace2ad46" translate="yes" xml:space="preserve">
          <source>Strings are not value types, but in Javascript they behave like value types, so they will be &quot;equal&quot; when the characters in the string are the same and when they are of the same length (as explained in the third rule)</source>
          <target state="translated">Las cadenas no son tipos de valores,pero en Javascript se comportan como tipos de valores,por lo que serán &quot;iguales&quot; cuando los caracteres de la cadena sean los mismos y cuando tengan la misma longitud (como se explica en la tercera regla)</target>
        </trans-unit>
        <trans-unit id="2fc95a3daa32ef795b3db44197ca06a9161c6605" translate="yes" xml:space="preserve">
          <source>Strings: the special case...</source>
          <target state="translated">Cuerdas:el caso especial...</target>
        </trans-unit>
        <trans-unit id="0a10f80e947919598b83985df0a922cea18c825f" translate="yes" xml:space="preserve">
          <source>Take the following example</source>
          <target state="translated">Tomemos el siguiente ejemplo</target>
        </trans-unit>
        <trans-unit id="34d15b0c36f8c3a873f0aa9868dd4a2ce99ed153" translate="yes" xml:space="preserve">
          <source>That's to say: if both operands of == are objects, == behaves same as ===, which also means identity. The essential difference of this two operators is about type conversion. == has conversion before it checks equality, but === does not.</source>
          <target state="translated">Es decir:si ambos operandos de ==son objetos,==se comporta igual que ===,lo que también significa identidad.La diferencia esencial de estos dos operadores es la conversión de tipos.==tiene conversión antes de comprobar la igualdad,pero ===no.</target>
        </trans-unit>
        <trans-unit id="b194ffbdff61cd41449b27896d0388ad11bc6102" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator will compare for equality &lt;em&gt;after doing any necessary type conversions&lt;/em&gt;.  The &lt;code&gt;===&lt;/code&gt; operator will &lt;strong&gt;not&lt;/strong&gt; do the conversion, so if two values are not the same type &lt;code&gt;===&lt;/code&gt; will simply return &lt;code&gt;false&lt;/code&gt;. Both are equally quick.</source>
          <target state="translated">El operador &lt;code&gt;==&lt;/code&gt; comparar&amp;aacute; la igualdad &lt;em&gt;despu&amp;eacute;s de realizar las conversiones de tipo necesarias&lt;/em&gt; . El operador &lt;code&gt;===&lt;/code&gt; &lt;strong&gt;no&lt;/strong&gt; realizar&amp;aacute; la conversi&amp;oacute;n, por lo que si dos valores no son del mismo tipo &lt;code&gt;===&lt;/code&gt; simplemente devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; . Ambos son igualmente r&amp;aacute;pidos.</target>
        </trans-unit>
        <trans-unit id="94d61a1bd3d74a41d42873da5dad1d59e17caf82" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;===&lt;/strong&gt; operator is called a strict comparison operator, it &lt;strong&gt;does&lt;/strong&gt; differ from the &lt;strong&gt;==&lt;/strong&gt; operator.</source>
          <target state="translated">El operador &lt;strong&gt;===&lt;/strong&gt; se llama operador de comparaci&amp;oacute;n estricto, difiere del operador &lt;strong&gt;==&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6b4a3a20e019eab11a43250c848486e6d49f5365" translate="yes" xml:space="preserve">
          <source>The End.</source>
          <target state="translated">El fin.</target>
        </trans-unit>
        <trans-unit id="afa8919ed4dc94f9cf1c114da989f410b6e7be00" translate="yes" xml:space="preserve">
          <source>The comparison x === y, where x and y are values, produces &lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;. Such a comparison is performed as follows:</source>
          <target state="translated">La comparaci&amp;oacute;n x === y, donde x e y son valores, produce &lt;strong&gt;verdadero&lt;/strong&gt; o &lt;strong&gt;falso&lt;/strong&gt; . Dicha comparaci&amp;oacute;n se realiza de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="1b98b3145565493d8ec7750f669d527714ecc29b" translate="yes" xml:space="preserve">
          <source>The identity (&lt;code&gt;===&lt;/code&gt;) operator behaves identically to the equality (&lt;code&gt;==&lt;/code&gt;) operator except no type conversion is done, and the types must be the same to be considered equal.</source>
          <target state="translated">El operador de identidad ( &lt;code&gt;===&lt;/code&gt; ) se comporta de manera id&amp;eacute;ntica al operador de igualdad ( &lt;code&gt;==&lt;/code&gt; ), excepto que no se realiza una conversi&amp;oacute;n de tipo, y los tipos deben ser iguales para ser considerados iguales.</target>
        </trans-unit>
        <trans-unit id="412caf725ac873e21c2342891582c7eb72241e50" translate="yes" xml:space="preserve">
          <source>The lack of transitivity is alarming.  My advice is to never use the evil twins.  Instead, always use &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;.  All of the comparisons just shown produce &lt;code&gt;false&lt;/code&gt; with the &lt;code&gt;===&lt;/code&gt; operator.</source>
          <target state="translated">La falta de transitividad es alarmante. Mi consejo es que nunca uses a los gemelos malvados. En su lugar, use siempre &lt;code&gt;===&lt;/code&gt; y &lt;code&gt;!==&lt;/code&gt; . Todas las comparaciones que se acaban de mostrar producen &lt;code&gt;false&lt;/code&gt; con el operador &lt;code&gt;===&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2ca5becda5d8c525a92af853383dd2f554be5e6" translate="yes" xml:space="preserve">
          <source>The problem is that you might easily get into trouble since JavaScript have a lot of implicit conversions meaning...</source>
          <target state="translated">El problema es que puedes meterte fácilmente en problemas ya que el JavaScript tiene muchas conversiones implícitas que significan...</target>
        </trans-unit>
        <trans-unit id="1c5cdbf6f285cc357902c21867d22dceaabbfb07" translate="yes" xml:space="preserve">
          <source>The rule is:</source>
          <target state="translated">La regla es:</target>
        </trans-unit>
        <trans-unit id="34e5356fba8841d2e384644ac7191e706b9b383b" translate="yes" xml:space="preserve">
          <source>The same here:</source>
          <target state="translated">Lo mismo aquí:</target>
        </trans-unit>
        <trans-unit id="ac6a25542b0ec2ff99281bcf844b6b748cb989bf" translate="yes" xml:space="preserve">
          <source>The special case is when you compare a literal with an object that evaluates to the same literal, due to its &lt;code&gt;toString&lt;/code&gt; or &lt;code&gt;valueOf&lt;/code&gt; method. For example, consider the comparison of a string literal with a string object created by the &lt;code&gt;String&lt;/code&gt; constructor.</source>
          <target state="translated">El caso especial es cuando compara un literal con un objeto que se eval&amp;uacute;a en el mismo literal, debido a su m&amp;eacute;todo &lt;code&gt;toString&lt;/code&gt; o &lt;code&gt;valueOf&lt;/code&gt; . Por ejemplo, considere la comparaci&amp;oacute;n de un literal de cadena con un objeto de cadena creado por el constructor de &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="deec20d89955518508df750a0325916894b132b6" translate="yes" xml:space="preserve">
          <source>The top 2 answers both mentioned == means equality and === means identity. Unfortunately, this statement is incorrect.</source>
          <target state="translated">Las dos primeras respuestas mencionadas ==significan igualdad y ===significa identidad.Desafortunadamente,esta afirmación es incorrecta.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="7e6e25d889bccff4888c16c5091398046e021bd5" translate="yes" xml:space="preserve">
          <source>There is unlikely to be any performance difference between the two operations in your usage. There is no type-conversion to be done because both parameters are already the same type. Both operations will have a type comparison followed by a value comparison.</source>
          <target state="translated">Es poco probable que haya alguna diferencia de rendimiento entre las dos operaciones en su uso.No hay que hacer ninguna conversión de tipo porque ambos parámetros ya son del mismo tipo.Ambas operaciones tendrán una comparación de tipos seguida de una comparación de valores.</target>
        </trans-unit>
        <trans-unit id="d0addef10584dbb6993cff27164cee0b6c70c9f9" translate="yes" xml:space="preserve">
          <source>This behavior is not always obvious. There's more to the story than being equal and being of the same type.</source>
          <target state="translated">Este comportamiento no siempre es obvio.Hay más en la historia que ser igual y ser del mismo tipo.</target>
        </trans-unit>
        <trans-unit id="10b32091fa5a9c7a5536dd0b8d0dbc5d56df3f1a" translate="yes" xml:space="preserve">
          <source>This is because the &lt;strong&gt;equality operator &lt;code&gt;==&lt;/code&gt; does type coercion&lt;/strong&gt;, meaning that the interpreter implicitly tries to convert the values before comparing.</source>
          <target state="translated">Esto se debe a que el &lt;strong&gt;operador de igualdad &lt;code&gt;==&lt;/code&gt; escribe coerci&amp;oacute;n&lt;/strong&gt; , lo que significa que el int&amp;eacute;rprete intenta impl&amp;iacute;citamente convertir los valores antes de comparar.</target>
        </trans-unit>
        <trans-unit id="e099919ae099449d50619707a595101be1938525" translate="yes" xml:space="preserve">
          <source>This is same as any object (like {}, arrays, etc.), non-empty string &amp;amp; Boolean true are all truthy conditions. But, they are all not equal.</source>
          <target state="translated">Esto es lo mismo que cualquier objeto (como {}, matrices, etc.), una cadena no vac&amp;iacute;a y un valor booleano verdadero son todas condiciones verdaderas. Pero, no todos son iguales.</target>
        </trans-unit>
        <trans-unit id="c01421dd6e3a97aa7a750d67645c9ce033722624" translate="yes" xml:space="preserve">
          <source>To quote Douglas Crockford's excellent &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;,</source>
          <target state="translated">Para citar el excelente &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript de&lt;/a&gt; Douglas Crockford : The Good Parts ,</target>
        </trans-unit>
        <trans-unit id="1b6611f5af4feb0209552e588441f461e4827c57" translate="yes" xml:space="preserve">
          <source>Type conversion in javaScript means javaScript automatically convert any other data types to string data types.</source>
          <target state="translated">La conversión de tipos en JavaScript significa que JavaScript convierte automáticamente cualquier otro tipo de datos en tipos de datos de cadena.</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="2dd151cc35444f22efefaf2a4c9200a524eabcbb" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">Use &lt;code&gt;===&lt;/code&gt; en lugar de &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c453d7e21f4c791a03dcc4a981e5605615b7d07" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;==&lt;/code&gt; operator (&lt;em&gt;Equality&lt;/em&gt;)</source>
          <target state="translated">Usando el operador &lt;code&gt;==&lt;/code&gt; ( &lt;em&gt;Igualdad&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="513b5a2751665a1919f797ca492150f5a95e5dbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;===&lt;/code&gt; operator (&lt;em&gt;Identity&lt;/em&gt;)</source>
          <target state="translated">Usando el operador &lt;code&gt;===&lt;/code&gt; ( &lt;em&gt;Identidad&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="49fae091b162654343089eb4ba3ab8ccdfc467f0" translate="yes" xml:space="preserve">
          <source>Well it's because unlike &quot;triple equals&quot; (&lt;code&gt;===&lt;/code&gt;) which just checks if two values are the same.</source>
          <target state="translated">Bueno, es porque a diferencia de &quot;triples iguales&quot; ( &lt;code&gt;===&lt;/code&gt; ) que solo comprueba si dos valores son iguales.</target>
        </trans-unit>
        <trans-unit id="fbbea6dde2ab91a36ff23b57623dc1796e371116" translate="yes" xml:space="preserve">
          <source>What do you get when you compare an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; with the number zero &lt;code&gt;0&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; obtienes cuando comparas una cadena vac&amp;iacute;a &lt;code&gt;&quot;&quot;&lt;/code&gt; con el n&amp;uacute;mero cero &lt;code&gt;0&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="67709d0522046140afbdae10c9f80a805117bee6" translate="yes" xml:space="preserve">
          <source>Which equals operator (== vs ===) should be used in JavaScript comparisons</source>
          <target state="translated">Que es igual al operador (==vs ===)debe ser usado en las comparaciones de JavaScript</target>
        </trans-unit>
        <trans-unit id="697e4e154c1261a7e33818edccc744a4d570a31e" translate="yes" xml:space="preserve">
          <source>Which means you could end up with bugs.</source>
          <target state="translated">Lo que significa que podrías terminar con bichos.</target>
        </trans-unit>
        <trans-unit id="d141d97a7a3ac22b01fd1cd75711d31e277f0a28" translate="yes" xml:space="preserve">
          <source>Which obviously during runtime does &lt;em&gt;very&lt;/em&gt; undefined things...</source>
          <target state="translated">Lo que obviamente durante el tiempo de ejecuci&amp;oacute;n hace cosas &lt;em&gt;muy&lt;/em&gt; indefinidas ...</target>
        </trans-unit>
        <trans-unit id="36933ceea4f2db404d028c82e6364a36ace968a0" translate="yes" xml:space="preserve">
          <source>Which pretty soon becomes a problem. The best sample of why implicit conversion is &quot;evil&quot; can be taken from this code in &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C++ which actually will compile due to an implicit conversion from CString to HANDLE which is a pointer typedef type...</source>
          <target state="translated">Que muy pronto se convierte en un problema. La mejor muestra de por qu&amp;eacute; la conversi&amp;oacute;n impl&amp;iacute;cita es &quot;malvada&quot; puede tomarse de este c&amp;oacute;digo en &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C ++, que en realidad se compilar&amp;aacute; debido a una conversi&amp;oacute;n impl&amp;iacute;cita de CString a HANDLE, que es un tipo de tipo puntero de definici&amp;oacute;n ...</target>
        </trans-unit>
        <trans-unit id="9fcac86aac0009e66019e4c27ea46100eaf900a2" translate="yes" xml:space="preserve">
          <source>With other words, if String wouldn't be of type Object it couldn't be used with the new operator.</source>
          <target state="translated">En otras palabras,si String no fuera de tipo Objeto no podría ser usado con el nuevo operador.</target>
        </trans-unit>
        <trans-unit id="45903fac0ea3c75afe550d2440dc48b77fd3f572" translate="yes" xml:space="preserve">
          <source>Yep, that's right according to &lt;code&gt;==&lt;/code&gt; an empty string and the number zero are the same time.</source>
          <target state="translated">S&amp;iacute;, eso es correcto seg&amp;uacute;n &lt;code&gt;==&lt;/code&gt; una cadena vac&amp;iacute;a y el n&amp;uacute;mero cero son al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="eabbe6442a6f27defee150f80d6147176f73513a" translate="yes" xml:space="preserve">
          <source>You can easily test it. Paste following code in an HTML file and open it in browser</source>
          <target state="translated">Puedes probarlo fácilmente.Pegue el siguiente código en un archivo HTML y ábralo en el navegador</target>
        </trans-unit>
        <trans-unit id="5da640618827894fedb5feef195dd55437e5bda8" translate="yes" xml:space="preserve">
          <source>You will get '&lt;strong&gt;false&lt;/strong&gt;' in alert. Now modify the &lt;code&gt;onPageLoad()&lt;/code&gt; method to &lt;code&gt;alert(x == 5);&lt;/code&gt; you will get &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">Obtendr&amp;aacute; ' &lt;strong&gt;falso&lt;/strong&gt; ' en alerta. Ahora modifique el m&amp;eacute;todo &lt;code&gt;onPageLoad()&lt;/code&gt; para &lt;code&gt;alert(x == 5);&lt;/code&gt; Te volver&amp;aacute;s &lt;strong&gt;sincero&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="786e97b3ee9fc4b292d5852c2c5943153c4ce91a" translate="yes" xml:space="preserve">
          <source>but</source>
          <target state="translated">but</target>
        </trans-unit>
        <trans-unit id="550f8bc02aebdb930e2ff4b54cf6677ee045437c" translate="yes" xml:space="preserve">
          <source>null and undefined are nothingness, that is,</source>
          <target state="translated">nulo e indefinido es la nada,es decir,</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
