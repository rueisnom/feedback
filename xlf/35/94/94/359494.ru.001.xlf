<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/359494">
    <body>
      <group id="359494">
        <trans-unit id="130bf5785915eb04e8a94d3a41ec118bd8e8f0d8" translate="yes" xml:space="preserve">
          <source>&quot;Use three equals unless you fully understand the conversions that take
  place for two-equals.&quot;</source>
          <target state="translated">&quot;Используйте три равных,если вы не понимаете полностью преобразования,которые происходят для двух равнозначных.&quot;</target>
        </trans-unit>
        <trans-unit id="54f697a1ff421e46f37022813a88d0937a82090c" translate="yes" xml:space="preserve">
          <source>&amp;amp;</source>
          <target state="translated">&amp;amp;</target>
        </trans-unit>
        <trans-unit id="dea7f7f48b6202dbcdd6e2f0b470c1320197a1b3" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;1. If Type(x) is different from Type(y), return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">1. Если Тип (x) отличается от Типа (y), верните &lt;strong&gt;false&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="128316503370069a1f99b4764d5a503e65225aa7" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;10. Return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">10. Вернуть &lt;strong&gt;ложь&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9f94476563997f8d2da2e6fdfb6b36c68ec81051" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;11. If Type(x) is String, then return &lt;strong&gt;true&lt;/strong&gt; if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">11. Если Type (x) - String, то вернуть &lt;strong&gt;true,&lt;/strong&gt; если x и y - это абсолютно одинаковая последовательность символов (одинаковая длина и одинаковые символы в соответствующих позициях); в противном случае верните &lt;strong&gt;false&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4c30077433d472cb40022cd05bbb7b0fce6d9add" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;12. If Type(x) is Boolean, return &lt;strong&gt;true&lt;/strong&gt; if x and y are both &lt;strong&gt;true&lt;/strong&gt; or both &lt;strong&gt;false&lt;/strong&gt;; otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">12. Если Type (x) - логическое значение, вернуть &lt;strong&gt;true,&lt;/strong&gt; если x и y оба - &lt;strong&gt;true&lt;/strong&gt; или оба &lt;strong&gt;false&lt;/strong&gt; ; в противном случае верните &lt;strong&gt;false&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="25f36acdf60e7d6a4df37ffedc98b9f14faf995c" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;13. Return &lt;strong&gt;true&lt;/strong&gt; if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">13. Верните &lt;strong&gt;true,&lt;/strong&gt; если x и y ссылаются на один и тот же объект или если они ссылаются на объекты, соединенные друг с другом (см. 13.1.2). В противном случае верните &lt;strong&gt;false&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6754f28eced479b11eb44690f5d4fa3822beda44" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;2. If Type(x) is Undefined, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">2. Если Тип (x) не определен, верните &lt;strong&gt;true&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a41404dc0e9e4b2139c7b55b00ba4f197ed1db" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;3. If Type(x) is Null, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">3. Если Тип (x) равен Null, вернуть &lt;strong&gt;true&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="86e81311d208ba00e8a82f89a4b6f670518af9c9" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;4. If Type(x) is not Number, go to step 11.</source>
          <target state="translated">4. Если Тип (x) не Номер, перейдите к шагу 11.</target>
        </trans-unit>
        <trans-unit id="1d11aa4bb7dc1bb6eb30029e881efcb0c773c688" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;5. If x is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">5. Если x равен &lt;strong&gt;NaN&lt;/strong&gt; , вернуть &lt;strong&gt;false&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e6feedc887138d0c4493e0285c20861d70ce82b0" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;6. If y is &lt;strong&gt;NaN&lt;/strong&gt;, return &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">6. Если y равен &lt;strong&gt;NaN&lt;/strong&gt; , вернуть &lt;strong&gt;false&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b305a8dce9f7df97f238519197a73606b9ab87f2" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;7. If x is the same number value as y, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">7. Если x совпадает с y, верните &lt;strong&gt;true&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b42c345a414ab1fe5a4c613c47711966027975a5" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;8. If x is +0 and y is &amp;minus;0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">8. Если x равен +0, а y равен &amp;minus;0, вернуть &lt;strong&gt;true&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e941ba4b0fdf4fcc001e64d6bd9bd26d6a81fd02" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;9. If x is &amp;minus;0 and y is +0, return &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">9. Если x равен &amp;minus;0, а y равен +0, верните &lt;strong&gt;true&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="03520e1e34120f6fae6bbeb3d5eb895994c709d3" translate="yes" xml:space="preserve">
          <source>** STRANGE: note that any two values on the first column are not equal in that sense.**</source>
          <target state="translated">**STRANGE:обратите внимание,что любые два значения в первом столбце не равны в этом смысле.**</target>
        </trans-unit>
        <trans-unit id="bfadb6bfe229d17ab6eb814049a1af7e1c35942f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality and type comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Сравнение равенства и типов:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4311a70549d246e170e5a8f1b527e5c5a19379f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Equality comparison: &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Сравнение равенства:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1ab346462c9fcef1a02b67c403e451e31987880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; does a &lt;strong&gt;&lt;em&gt;whole bunch of other stuff&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; делает &lt;strong&gt;&lt;em&gt;кучу других вещей&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1b338ff3f560901a0f7f2338cb21ec9ed418bce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;with&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; означает &lt;strong&gt;сравнение&lt;/strong&gt; операндов &lt;strong&gt;с&lt;/strong&gt; &lt;code&gt;type conversion&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9d647aeb173e83a0130624d9b11d9a6aca4c3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; operator just checks the value of the variables for equality.</source>
          <target state="translated">Оператор &lt;code&gt;==&lt;/code&gt; просто проверяет значение переменных на равенство.</target>
        </trans-unit>
        <trans-unit id="86a40c35943be312d26be58ed590bcd3dd325425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; Returns &lt;code&gt;true&lt;/code&gt; if the operands are strictly equal (see above)
  with no type conversion.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; Возвращает &lt;code&gt;true&lt;/code&gt; , если операнды строго равны (см. Выше) без преобразования типов.</target>
        </trans-unit>
        <trans-unit id="9d0976f976a35ebb6ebe62b08679b2e138576dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;comparison&lt;/strong&gt; between operands &lt;strong&gt;without&lt;/strong&gt;&lt;code&gt;type conversion&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; означает &lt;strong&gt;сравнение&lt;/strong&gt; между операндами &lt;strong&gt;без&lt;/strong&gt; &lt;code&gt;type conversion&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54e23978f1caf3d9c1511fb347612a2b3442e552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator  checks the values as well as the types of the variables for equality.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; Оператор проверяет значения и типы переменных на равенство.</target>
        </trans-unit>
        <trans-unit id="0784b02b5003c7729e030d9b7d490e95bab806f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;===&lt;/code&gt; operator in javascript &lt;strong&gt;checks value as well as type&lt;/strong&gt; where as &lt;code&gt;==&lt;/code&gt; operator just checks &lt;strong&gt;the value (does type conversion if required)&lt;/strong&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;===&lt;/code&gt; в javascript &lt;strong&gt;проверяет значение, а также тип,&lt;/strong&gt; где оператор &lt;code&gt;==&lt;/code&gt; просто проверяет &lt;strong&gt;значение (выполняет преобразование типа, если требуется)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e191a0a45be586c4c0bba711c1f56571fe4d8f4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both strings and contain the exact same characters</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; возвращает true, если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; обе строки и содержат одинаковые символы</target>
        </trans-unit>
        <trans-unit id="c03f97f96e2f5f2837a1f086b8eb03c59b00a165" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same value and are of the same type</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; возвращает true, если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; имеют одинаковое значение и имеют одинаковый тип</target>
        </trans-unit>
        <trans-unit id="0b9afde54d1a9e309f7f55b08fcee09754103a72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a === b&lt;/code&gt; returns true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reference the exact same object</source>
          <target state="translated">&lt;code&gt;a === b&lt;/code&gt; возвращает true, если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; ссылаются на один и тот же объект</target>
        </trans-unit>
        <trans-unit id="a569658b84c50eebdb4a105bf59c6e932a3a246e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;The equal comparison operator == is confusing and should be avoided.&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Оператор сравнения == сбивает с толку и его следует избегать.&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e7e53458508d6e51aeb7d6a48cf2891cadddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.2.2 The new Operator&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;11.2.2 Новый оператор&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="7998aff2909b6b4706d92805f6351ca4f05e7bf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11.9.6 The Strict Equality Comparison Algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;11.9.6 Алгоритм сравнения строгого равенства&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6991c2660c1bca00359ab71ad6adcfdf32c7a356" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For reference types:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Для справочных типов:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b281c590fb85b87b5d11f1a04a3b17b4b081d21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For strings:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Для строк:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a449c178aebbeb356e9012aeb4b469de6ac6e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;For value types (numbers):&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Для типов значений (чисел):&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f73c5c4818316a7e7ba83421501c2687aba89eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;If in doubt, read the &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;specification&lt;/a&gt;!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Если сомневаетесь, прочитайте &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;спецификацию&lt;/a&gt; !&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b1bf8ddd0de3be690c43c624391f8937688d9e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Moral of the story:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Мораль истории:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83c7151c0c6f7fb762f855eb85e50c829ea14a0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Use &lt;code&gt;===&lt;/code&gt; unless you fully understand the
  conversions that take place with &lt;code&gt;==&lt;/code&gt;.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Используйте &lt;code&gt;===&lt;/code&gt; , если вы не полностью понимаете конверсии, которые происходят с &lt;code&gt;==&lt;/code&gt; .&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef127aa6ac9121f82176c29f76864dbb36fe4c2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;==&lt;/code&gt; for JavaScript equality testing, some
  funky conversions take place.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;При использовании &lt;code&gt;==&lt;/code&gt; для проверки на равенство JavaScript происходят некоторые интересные преобразования.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77298b36a9fcbaf746d98e1bc74886ea8bbddcff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When using &lt;code&gt;===&lt;/code&gt; for JavaScript equality testing, everything is as is. Nothing gets converted before being evaluated.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;При использовании &lt;code&gt;===&lt;/code&gt; для проверки на равенство JavaScript все как есть.&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Ничто не преобразуется перед оценкой.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5583d977f70290bf3ad57016e11eed7fe1b944f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of doubt, learn by heart the following truth table:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;В случае сомнений выучите наизусть следующую таблицу истинности:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4e32406ca5087fb220aee87a9159a70a2cf49c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In summary&lt;/strong&gt;; using the &lt;strong&gt;==&lt;/strong&gt; operator might evaluate to true in situations where you do not want it to so using the &lt;strong&gt;===&lt;/strong&gt; operator would be safer.</source>
          <target state="translated">&lt;strong&gt;В итоге&lt;/strong&gt; ; использование оператора &lt;strong&gt;==&lt;/strong&gt; может дать значение true в ситуациях, когда вы этого не хотите, поэтому использование оператора &lt;strong&gt;===&lt;/strong&gt; будет безопаснее.</target>
        </trans-unit>
        <trans-unit id="0fc148d6649bd47fe8e2b7cf2467f19d0bf69fd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It is not transitive: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(b == c)&lt;/em&gt; does not lead to &lt;em&gt;(a == c)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Это не транзитивно: &lt;em&gt;(a == b)&lt;/em&gt; и &lt;em&gt;(b == c)&lt;/em&gt; не приводит к &lt;em&gt;(a == c)&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b0a31f565c1a8710eee82d40a2198e9e2ade2a15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's mutually exclusive to its negation: &lt;em&gt;(a == b)&lt;/em&gt; and &lt;em&gt;(a != b)&lt;/em&gt; always hold opposite Boolean values, with all a and b.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Он взаимоисключающий с отрицанием: &lt;em&gt;(a == b)&lt;/em&gt; и &lt;em&gt;(a! = B)&lt;/em&gt; всегда содержат противоположные логические значения со всеми a и b.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2a6eb120ac5d954b7aa47baca4f35f487d47fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e15c6bff6033a446fc6a95bbcaedcb5920c62e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So the moral of the story is...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Итак, мораль этой истории ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f68664c3d5e1f0872cc0f7095d28293c50692b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what does this mean?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Так что это значит?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcffb768a62952b163df247d1df132d1d92ba1ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source: &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http://dorey.github.io/JavaScript-Equality-Table/&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Источник: &lt;a href=&quot;http://dorey.github.io/JavaScript-Equality-Table/&quot;&gt;http://dorey.github.io/JavaScript-Equality-Table/&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3572e23516a3bbfc97277c54e9df478818214273" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Then weirder with strings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Тогда страннее со строками&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4799deaf7c2bdd75e811e68dfa65cd85a9318390" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Things get really weird with arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вещи становятся действительно странными с массивами.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c6910a7c92878ee22dbd03dfb0a4072532d90db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When is equal not equal?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Когда равен не равен?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8eb43dbcbcd365843d41af200d644bb6817377de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why &lt;code&gt;==&lt;/code&gt; is so unpredictable?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Почему &lt;code&gt;==&lt;/code&gt; это так непредсказуемо?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="158e452fe7b5ed683ae60f76da327fa38cec4251" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why does this happen?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Почему это происходит?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3471db61bc9f6d45c5cdde69581a956986a6defd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes!&lt;/strong&gt; It does matter.</source>
          <target state="translated">&lt;strong&gt;Да!&lt;/strong&gt; Это имеет значение.</target>
        </trans-unit>
        <trans-unit id="72675d0e476a995d0975566582a364150fca52f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;new&lt;/strong&gt; always returns an Object, even for &lt;strong&gt;String&lt;/strong&gt; constructors, too. And alas! The value semantics for strings (see step 11) is lost.</source>
          <target state="translated">&lt;strong&gt;new&lt;/strong&gt; всегда возвращает Object, даже для конструкторов &lt;strong&gt;String&lt;/strong&gt; . И увы! Семантика значения для строк (см. Шаг 11) теряется.</target>
        </trans-unit>
        <trans-unit id="b7f0cbff18eeec5852f5ea8c1be766cd8cf6a45d" translate="yes" xml:space="preserve">
          <source>A good point was brought up by &lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt; in the comments and in &lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;@Phillipe Laybaert's&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/957602/1288&quot;&gt;answer&lt;/a&gt; concerning reference types.  For reference types &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; act consistently with one another (except in a special case).</source>
          <target state="translated">Хороший вопрос был поднят &lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;@Casebash&lt;/a&gt; в комментариях и в &lt;a href=&quot;https://stackoverflow.com/users/113570/philippe-leybaert&quot;&gt;ответе @Phillipe Laybaert&lt;/a&gt; относительно ссылочных типов. Для ссылочных типов &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;===&lt;/code&gt; действуют согласованно друг с другом (кроме как в особом случае).</target>
        </trans-unit>
        <trans-unit id="8b54302e5ddc3ab8451d73b4e6fbcce29f1fb9c2" translate="yes" xml:space="preserve">
          <source>A simple example is</source>
          <target state="translated">Простой пример</target>
        </trans-unit>
        <trans-unit id="4e666e628adc9d3ae32638bd884bee95473bd54e" translate="yes" xml:space="preserve">
          <source>Aidiakapi wrote this in a comment below:</source>
          <target state="translated">Айдиакапи написал это в комментарии ниже:</target>
        </trans-unit>
        <trans-unit id="a54a3ffda19eea85fbc25119ad4dce8fb1e843e4" translate="yes" xml:space="preserve">
          <source>All returns true and you may not want this. Let's suppose you have a function that can return the 0th index of an array or false on failure. If you check with &quot;==&quot; false, you can get a confusing result.</source>
          <target state="translated">Все возвращается правдой,и ты можешь этого не хотеть.Допустим,у вас есть функция,которая может возвращать 0-й индекс массива или false при отказе.Если проверить &quot;==&quot; false,то можно получить запутанный результат.</target>
        </trans-unit>
        <trans-unit id="8742264e60f01ff6e597018b6c9b30ad6c84fa0b" translate="yes" xml:space="preserve">
          <source>An interesting pictorial representation of the equality comparison between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">Интересное графическое представление сравнения равенства между &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;===&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c1a994f0cb44644f821ea4b44798e564cbb1e78" translate="yes" xml:space="preserve">
          <source>And it doesn't end there, here's another one:</source>
          <target state="translated">И на этом всё не закончится,вот ещё один:</target>
        </trans-unit>
        <trans-unit id="fcab40bf0cf2cc434eb0ce086ee4dfadcbc91121" translate="yes" xml:space="preserve">
          <source>And this finally means: &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">И, наконец, это означает: &lt;strong&gt;новая строка (&amp;laquo;а&amp;raquo;)! == &amp;laquo;а&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c997d053fe7d55a1f5eb3f9358b3b7760fec29e8" translate="yes" xml:space="preserve">
          <source>And this is just the crazy stuff you get with primitives.</source>
          <target state="translated">И это просто безумие,которое ты получаешь с примитивами.</target>
        </trans-unit>
        <trans-unit id="9353a89820dfa87107beffc7a1a273e498311936" translate="yes" xml:space="preserve">
          <source>Another common example:</source>
          <target state="translated">Еще один распространенный пример:</target>
        </trans-unit>
        <trans-unit id="bb0313b7b5d894d38b25b3429130ff71d7450726" translate="yes" xml:space="preserve">
          <source>Any performance improvement would be welcomed as many comparison operators exist.</source>
          <target state="translated">Любое улучшение производительности будет приветствоваться,поскольку существует множество операторов сравнения.</target>
        </trans-unit>
        <trans-unit id="ebdf4e9004e5ae311bc10c04cc1657d844cc2b1e" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, I would generally use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (and &lt;code&gt;!==&lt;/code&gt; instead of &lt;code&gt;!=&lt;/code&gt;).</source>
          <target state="translated">Как правило, я бы использовал &lt;code&gt;===&lt;/code&gt; вместо &lt;code&gt;==&lt;/code&gt; (и &lt;code&gt;!==&lt;/code&gt; вместо &lt;code&gt;!=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13b3f53e194e780033d076d6dfdef27478b25e97" translate="yes" xml:space="preserve">
          <source>As the conclusion states:</source>
          <target state="translated">Как говорится в заключении:</target>
        </trans-unit>
        <trans-unit id="2c8f8302c2c50753cc3fc038d29edd38e7d27241" translate="yes" xml:space="preserve">
          <source>At this point your probably wondering...</source>
          <target state="translated">В данный момент тебе,наверное,интересно...</target>
        </trans-unit>
        <trans-unit id="78a365d1c42cbfa956f22145534e940bf6aa204f" translate="yes" xml:space="preserve">
          <source>Because it's complicated it's hard to know what's going to happen when you use it.</source>
          <target state="translated">Потому что это сложно,трудно понять,что случится,когда ты используешь его.</target>
        </trans-unit>
        <trans-unit id="6d67a31310a8174d28abedb216692a809603aaa3" translate="yes" xml:space="preserve">
          <source>But how about this?:</source>
          <target state="translated">Но как насчет этого?</target>
        </trans-unit>
        <trans-unit id="c0360df7ca51ade50469aaf2a05a01615c88e9dd" translate="yes" xml:space="preserve">
          <source>But personally I would do what JSLint suggests. This recommendation is there not because of performance issues, but because type coercion means &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; is true.</source>
          <target state="translated">Но лично я бы сделал то, что предлагает JSLint. Эта рекомендация существует не из-за проблем с производительностью, а потому, что приведение типа означает &lt;code&gt;('\t\r\n' == 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbdab286eda606977bf3a9c58a18c188200a37c4" translate="yes" xml:space="preserve">
          <source>Common example:</source>
          <target state="translated">Общий пример:</target>
        </trans-unit>
        <trans-unit id="f64d819276a8e60d2cf4282031ed91641ea77411" translate="yes" xml:space="preserve">
          <source>ECMA-262 is the specification for a scripting language of which JavaScript is a dialect. Of course in practice it matters more how the most important browsers behave than an esoteric definition of how something is supposed to be handled. But it is helpful to understand why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;.</source>
          <target state="translated">ECMA-262 - это спецификация языка сценариев, для которого JavaScript является диалектом. Конечно, на практике важнее то, как ведут себя наиболее важные браузеры, чем эзотерическое определение того, как что-то должно обрабатываться. Но полезно понять, почему &lt;strong&gt;новая строка (&amp;laquo;а&amp;raquo;)! == &amp;laquo;а&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dd5ffe9d4172fd93e2644ec55bff755f2376bde5" translate="yes" xml:space="preserve">
          <source>EQUAL OPERATOR TRUTH TABLE IN JAVASCRIPT</source>
          <target state="translated">ТАБЛИЦА ИСТИНЫ РАВНОГО ОПЕРАТОРА НА ЯЗЫКЕ ЯВАСКРИПТА</target>
        </trans-unit>
        <trans-unit id="c0cc6f9b7554c74df1b7cae7c6ef1f64783063e0" translate="yes" xml:space="preserve">
          <source>Each row in the table is a set of 3 mutually &quot;equal&quot; values, meaning that any 2 values among them are equal using the equal == sign*</source>
          <target state="translated">Каждая строка таблицы представляет собой набор из 3 взаимно &quot;равных&quot; значений,что означает,что любые 2 значения среди них равны,используя знак равенства ==*</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58b2ed100a4c02f3e223f19e77f4fc970f37bc3e" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;&quot;a == b&quot;&lt;/strong&gt; to evaluate to true a and b need to be the &lt;strong&gt;same value&lt;/strong&gt;.</source>
          <target state="translated">Чтобы &lt;strong&gt;&quot;a == b&quot;&lt;/strong&gt; было оценено как истинное, a и b должны быть &lt;strong&gt;одинаковыми&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="38827ea4d22912a8579010ad9d43caaae3a33e79" translate="yes" xml:space="preserve">
          <source>For example jQuery 1.9.1 uses this pattern 43 times, and  the &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;JSHint syntax checker&lt;/a&gt; even provides the &lt;code&gt;eqnull&lt;/code&gt; relaxing option for this reason.</source>
          <target state="translated">Например, jQuery 1.9.1 использует этот шаблон 43 раза, и по этой &lt;a href=&quot;http://www.jshint.com/docs/#options&quot;&gt;причине средство проверки синтаксиса JSHint&lt;/a&gt; даже предоставляет &lt;code&gt;eqnull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="3b5af0e25b6d033fced42a264a3e0862e363a6cc" translate="yes" xml:space="preserve">
          <source>For example, if you have:</source>
          <target state="translated">Например,если у тебя есть:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="93d53aae8f4cbac1a7160cd657ddf2e114550792" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;jQuery style guide&lt;/a&gt;:</source>
          <target state="translated">Из руководства по &lt;a href=&quot;http://contribute.jquery.org/style-guide/js/&quot;&gt;стилю jQuery&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="519a4ac6eaa68eb2f5a55813ad6c7b39e2e3c9a5" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;core javascript reference&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators&quot;&gt;основной ссылки javascript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33d6d15bce91547d5c6e839acec0e386194d3e54" translate="yes" xml:space="preserve">
          <source>From the specification</source>
          <target state="translated">Из спецификации</target>
        </trans-unit>
        <trans-unit id="078ecfcf86b689086aece409c4dd9d3597272bc8" translate="yes" xml:space="preserve">
          <source>Google for implicit conversions in C++ and &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL&lt;/a&gt; to get some of the arguments against it...</source>
          <target state="translated">Google для неявных преобразований в C ++ и &lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;STL,&lt;/a&gt; чтобы получить некоторые аргументы против этого ...</target>
        </trans-unit>
        <trans-unit id="5532825dcc419a2c608b4660ff4df27ee7b64e3b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; do not have values. Whereas, 0, false and '' are all values. One thing common beween all these are that they are all falsy values, which means they all &lt;strong&gt;satisfy&lt;/strong&gt; falsy conditions.</source>
          <target state="translated">Здесь &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; не имеют значений. Принимая во внимание, что 0, false и '' являются значениями. Общим для всех них является то, что все они являются ложными значениями, что означает, что все они &lt;strong&gt;удовлетворяют&lt;/strong&gt; ложным условиям.</target>
        </trans-unit>
        <trans-unit id="4f47052c940a268ebe245314f782cc99b18f0d6e" translate="yes" xml:space="preserve">
          <source>Here is a handy comparison table that shows the conversions that happen and the differences between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt;.</source>
          <target state="translated">Вот удобная сравнительная таблица, в которой показаны конверсии и различия между &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;===&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e780233b6b8ef08d4cfd3eb493ce561f782434f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;==&lt;/code&gt; operator is checking the values of the two objects and returning &lt;code&gt;true&lt;/code&gt;, but the &lt;code&gt;===&lt;/code&gt; is seeing that they're not the same type and returning &lt;code&gt;false&lt;/code&gt;.  Which one is correct?  That really depends on what you're trying to compare.  My advice is to bypass the question entirely and just don't use the &lt;code&gt;String&lt;/code&gt; constructor to create string objects.</source>
          <target state="translated">Здесь оператор &lt;code&gt;==&lt;/code&gt; проверяет значения двух объектов и возвращает &lt;code&gt;true&lt;/code&gt; , но &lt;code&gt;===&lt;/code&gt; видит, что они не одного типа, и возвращает &lt;code&gt;false&lt;/code&gt; . Который правильный? Это действительно зависит от того, что вы пытаетесь сравнить. Мой совет - полностью обойти вопрос и просто не использовать конструктор &lt;code&gt;String&lt;/code&gt; для создания строковых объектов.</target>
        </trans-unit>
        <trans-unit id="7108ec5478e370309fc5357c0e971bd4f05bbf90" translate="yes" xml:space="preserve">
          <source>However there is &lt;strong&gt;one single exception&lt;/strong&gt;:
&lt;code&gt;== null&lt;/code&gt; is an efficient way to check for 'is null or undefined':</source>
          <target state="translated">Однако есть &lt;strong&gt;одно единственное исключение&lt;/strong&gt; : &lt;code&gt;== null&lt;/code&gt; - эффективный способ проверить, является ли 'null или undefined':</target>
        </trans-unit>
        <trans-unit id="f0d30f93bb4df391284d009844ff1535f26f2082" translate="yes" xml:space="preserve">
          <source>I tested this in Firefox with &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug&lt;/a&gt; using code like this:</source>
          <target state="translated">Я проверил это в Firefox с &lt;a href=&quot;http://en.wikipedia.org/wiki/Firebug_%28software%29&quot;&gt;Firebug,&lt;/a&gt; используя такой код:</target>
        </trans-unit>
        <trans-unit id="7b1c18acfb2da322223032a6ca65bcb729f0ddd1" translate="yes" xml:space="preserve">
          <source>I thought strings behave like value types? Well, it depends who you ask... In this case a and b are not the same type. &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;Object&lt;/code&gt;, while &lt;code&gt;b&lt;/code&gt; is of type &lt;code&gt;string&lt;/code&gt;. Just remember that creating a string object using the &lt;code&gt;String&lt;/code&gt; constructor creates something of type &lt;code&gt;Object&lt;/code&gt; that behaves as a string &lt;em&gt;most of the time&lt;/em&gt;.</source>
          <target state="translated">Я думал, что строки ведут себя как типы значений? Ну, это зависит от того, кого вы спрашиваете ... В этом случае a и b не одного типа. &lt;code&gt;a&lt;/code&gt; имеет тип &lt;code&gt;Object&lt;/code&gt; , а &lt;code&gt;b&lt;/code&gt; имеет тип &lt;code&gt;string&lt;/code&gt; . Просто помните, что при создании строкового объекта с помощью конструктора &lt;code&gt;String&lt;/code&gt; создается &lt;code&gt;Object&lt;/code&gt; типа Object, который &lt;em&gt;большую часть времени&lt;/em&gt; ведет себя как строка.</target>
        </trans-unit>
        <trans-unit id="6724c10b1c4dd89e994b59c7b65ce998cb53f9b0" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;JSLint&lt;/a&gt; to go through JavaScript, and it's returning many suggestions to replace &lt;code&gt;==&lt;/code&gt; (two equals signs) with &lt;code&gt;===&lt;/code&gt; (three equals signs) when doing things like comparing &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; inside of an &lt;code&gt;if&lt;/code&gt; statement.</source>
          <target state="translated">Я использую &lt;a href=&quot;http://en.wikipedia.org/wiki/JSLint&quot;&gt;JSLint,&lt;/a&gt; чтобы пройти через JavaScript, и он возвращает много предложений о замене &lt;code&gt;==&lt;/code&gt; (два знака равенства) на &lt;code&gt;===&lt;/code&gt; (три знака равенства) при выполнении таких вещей, как сравнение &lt;code&gt;idSele_UNVEHtype.value.length == 0&lt;/code&gt; внутри &lt;code&gt;if&lt;/code&gt; заявление.</target>
        </trans-unit>
        <trans-unit id="699383a3720b89c508893f13174fcc345a333a00" translate="yes" xml:space="preserve">
          <source>If Type(constructor) is not Object, throw a TypeError exception.</source>
          <target state="translated">Если Type(конструктор)не является объектом,бросьте исключение TypeError.</target>
        </trans-unit>
        <trans-unit id="7c1b47bf6a1abbf554dbd0ee2168db0b303f1c1f" translate="yes" xml:space="preserve">
          <source>If both operands of == are objects, then they are compared to see if they are the same object. If both operands point to the same object, then the equal operator returns true. Otherwise,
the two are not equal.</source>
          <target state="translated">Если оба операнда ==являются объектами,то они сравниваются,чтобы увидеть,являются ли они одним и тем же объектом.Если оба операндов указывают на один и тот же объект,то оператор equal возвращает true.В противном случае они не равны.</target>
        </trans-unit>
        <trans-unit id="cbb1a99493847058458e46837af0fc9a5702b63e" translate="yes" xml:space="preserve">
          <source>If no type conversion takes place, would there be a performance gain over &lt;code&gt;==&lt;/code&gt;?</source>
          <target state="translated">Если преобразование типов не выполняется, будет ли увеличение производительности по сравнению с &lt;code&gt;==&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e27332524b113dae22c09288bee3e0f34778ca3c" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;HAVE TO&lt;/strong&gt; live with it, then remember the following 3 things:</source>
          <target state="translated">Если вы &lt;strong&gt;должны&lt;/strong&gt; жить с этим, то помните следующие 3 вещи:</target>
        </trans-unit>
        <trans-unit id="ba83b649d7ac77ee88b91662e9dc19d8d2569046" translate="yes" xml:space="preserve">
          <source>If you wonder why &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; does not return a string, how about some exercise reading a specification? Have fun!</source>
          <target state="translated">Если вам интересно, почему &lt;strong&gt;new String (&quot;a&quot;)&lt;/strong&gt; не возвращает строку, как насчет упражнения по чтению спецификации? Повеселись!</target>
        </trans-unit>
        <trans-unit id="318588db3ab6c1c4c50c1ae4dd7cb47bf8189bab" translate="yes" xml:space="preserve">
          <source>In JavaScript it means of the same value and type.</source>
          <target state="translated">В JavaScript это означает одно и то же значение и тип.</target>
        </trans-unit>
        <trans-unit id="4bbc85798100e8a6c2b8173b4c4cc5ff26f86121" translate="yes" xml:space="preserve">
          <source>In PHP and JavaScript, it is a strict equality operator. Which means, it will compare both type and values.</source>
          <target state="translated">В PHP и JavaScript это оператор строгого равенства.Это значит,что он будет сравнивать и тип,и значения.</target>
        </trans-unit>
        <trans-unit id="0fd01d3c121d1dd02e0aad7a9a25393961f9968a" translate="yes" xml:space="preserve">
          <source>In a typical script there will be no performance difference. More important may be the fact that thousand &quot;===&quot; is 1&amp;nbsp;KB heavier than thousand &quot;==&quot; :) &lt;a href=&quot;https://stackoverflow.com/questions/tagged/javascript+performance&quot;&gt;JavaScript profilers&lt;/a&gt; can tell you if there is a performance difference in your case.</source>
          <target state="translated">В типичном скрипте не будет разницы в производительности. Более важным может быть тот факт, что тысяча &quot;===&quot; на 1 КБ тяжелее тысячи &quot;==&quot; :) &lt;a href=&quot;https://stackoverflow.com/questions/tagged/javascript+performance&quot;&gt;Профилировщики JavaScript&lt;/a&gt; могут подсказать, есть ли разница в производительности в вашем случае.</target>
        </trans-unit>
        <trans-unit id="0e42d567a09b4ba932e88964ee9b8587449c04d9" translate="yes" xml:space="preserve">
          <source>In fact, if you tried to write a function that does what &lt;code&gt;==&lt;/code&gt; does it would look something like this:</source>
          <target state="translated">На самом деле, если вы попытаетесь написать функцию, которая делает то, что &lt;code&gt;==&lt;/code&gt; , это будет выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="48c572d57b17fbc593b6830a7381e7378807a00f" translate="yes" xml:space="preserve">
          <source>In the 90% usage scenario it won't matter which one you use, but it is handy to know the difference when you get some unexpected behaviour one day.</source>
          <target state="translated">В 90%-ом сценарии использования не имеет значения,какой из них вы используете,но удобно знать разницу,когда в один прекрасный день вы получите некоторое неожиданное поведение.</target>
        </trans-unit>
        <trans-unit id="ec01264fb9d51cfefd427a17d74eb33ac1be156e" translate="yes" xml:space="preserve">
          <source>In the answers here, I didn't read anything about what &lt;strong&gt;equal&lt;/strong&gt; means. Some will say that &lt;code&gt;===&lt;/code&gt; means &lt;strong&gt;equal and of the same type&lt;/strong&gt;, but that's not really true. It actually means that &lt;strong&gt;both operands reference the same object&lt;/strong&gt;, or in case of &lt;strong&gt;value types, have the same value&lt;/strong&gt;.</source>
          <target state="translated">В ответах здесь я ничего не читал о том, что значит &lt;strong&gt;равный&lt;/strong&gt; . Некоторые скажут, что &lt;code&gt;===&lt;/code&gt; означает &lt;strong&gt;равные и того же типа&lt;/strong&gt; , но это не совсем так. Фактически это означает, что &lt;strong&gt;оба операнда ссылаются на один и тот же объект&lt;/strong&gt; или, в случае &lt;strong&gt;типов значений, имеют одинаковое значение&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ca385d21427dba165889d58d33e6fa5704fb46b2" translate="yes" xml:space="preserve">
          <source>In the case of &lt;strong&gt;&quot;a === b&quot;&lt;/strong&gt; a and b must be the &lt;strong&gt;same value&lt;/strong&gt; and also the &lt;strong&gt;same type&lt;/strong&gt; for it to evaluate to true.</source>
          <target state="translated">В случае &lt;strong&gt;&amp;laquo;a === b&amp;raquo;&lt;/strong&gt; a и b должны иметь &lt;strong&gt;одинаковое значение,&lt;/strong&gt; а также &lt;strong&gt;один&lt;/strong&gt; и тот &lt;strong&gt;же тип,&lt;/strong&gt; чтобы оно имело значение true.</target>
        </trans-unit>
        <trans-unit id="251bebdd324bcccca7535068065ec28cc534eae3" translate="yes" xml:space="preserve">
          <source>In the code above, both == and === get false because a and b are not the same objects.</source>
          <target state="translated">В приведенном выше коде и ==,и ===получают false,так как a и b не являются одними и теми же объектами.</target>
        </trans-unit>
        <trans-unit id="a4cd7b099967df429e07f68f296c07052c7aba52" translate="yes" xml:space="preserve">
          <source>Interesting is step 11. Yes, strings are treated as value types. But this does not explain why &lt;strong&gt;new String(&quot;a&quot;) !== &quot;a&quot;&lt;/strong&gt;. Do we have a browser not conforming to ECMA-262?</source>
          <target state="translated">Интересным является шаг 11. Да, строки обрабатываются как типы значений. Но это не объясняет, почему &lt;strong&gt;новая строка (&amp;laquo;а&amp;raquo;)! == &amp;laquo;а&amp;raquo;&lt;/strong&gt; . У нас есть браузер, не соответствующий ECMA-262?</target>
        </trans-unit>
        <trans-unit id="cd2c230db52d16c62fde2c29f3b5aa18ff6b95af" translate="yes" xml:space="preserve">
          <source>Is there a performance benefit to replacing &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;===&lt;/code&gt;?</source>
          <target state="translated">Есть ли выигрыш в производительности при замене &lt;code&gt;==&lt;/code&gt; на &lt;code&gt;===&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="6208d5e465527e22f406b99578ad5d55c45f7cb9" translate="yes" xml:space="preserve">
          <source>It checks if same sides are equal in &lt;strong&gt;type&lt;/strong&gt; as well as &lt;strong&gt;value&lt;/strong&gt;.</source>
          <target state="translated">Он проверяет, равны ли одинаковые стороны по &lt;strong&gt;типу&lt;/strong&gt; и &lt;strong&gt;значению&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3b33800c6e21e7706b86e94308ae2b6ade92ea2c" translate="yes" xml:space="preserve">
          <source>It get's pretty wacky.</source>
          <target state="translated">Становится довольно странно.</target>
        </trans-unit>
        <trans-unit id="0c3489421f48aca78ca26cbeacff41a88d0a2485" translate="yes" xml:space="preserve">
          <source>It get's worse:</source>
          <target state="translated">Становится хуже:</target>
        </trans-unit>
        <trans-unit id="2461a72119f69288570a91dd4886cf1946921ace" translate="yes" xml:space="preserve">
          <source>It has special handling for functions, special handling for nulls, undefined, strings, you name it.</source>
          <target state="translated">Он имеет специальную обработку для функций,специальную обработку для нулей,неопределенных,строк,вы называете его.</target>
        </trans-unit>
        <trans-unit id="e7800c4331282e121e342d6b81303384bd272938" translate="yes" xml:space="preserve">
          <source>It is faster only when the types are not the same, in which case it does not try to convert types but directly returns a false.</source>
          <target state="translated">Он быстрее только тогда,когда типы не совпадают,и в этом случае он не пытается привести типы,а сразу же возвращает false.</target>
        </trans-unit>
        <trans-unit id="faa77444bfb36c5ba995cd19f29530d0943b04a1" translate="yes" xml:space="preserve">
          <source>It means &lt;code&gt;==&lt;/code&gt; is complicated.</source>
          <target state="translated">Это означает, что &lt;code&gt;==&lt;/code&gt; это сложно.</target>
        </trans-unit>
        <trans-unit id="a65b5bfaad127fd93d57e6ab192d490bc11ac353" translate="yes" xml:space="preserve">
          <source>It means &lt;strong&gt;equality without type coercion&lt;/strong&gt;
type coercion means JavaScript do not automatically convert any other data types to string data types</source>
          <target state="translated">Это означает &lt;strong&gt;равенство без приведения типов Приведение&lt;/strong&gt; типов означает, что JavaScript не преобразует автоматически никакие другие типы данных в строковые типы данных.</target>
        </trans-unit>
        <trans-unit id="4cc792e792c928abedc18234163e220b2c90215c" translate="yes" xml:space="preserve">
          <source>It's a good thing especially if you're checking between 0 and false and null.</source>
          <target state="translated">Это хорошо,особенно если ты проверяешь между 0 и ложью и нулем.</target>
        </trans-unit>
        <trans-unit id="76814442e2351cc8045391978fecf4190730bd23" translate="yes" xml:space="preserve">
          <source>It's a strict check test.</source>
          <target state="translated">Это строгий контрольный тест.</target>
        </trans-unit>
        <trans-unit id="c194b6748d81866560cca42c3ec80275ce25b0fa" translate="yes" xml:space="preserve">
          <source>It's a whole new level of crazy when you use &lt;code&gt;==&lt;/code&gt; with objects.</source>
          <target state="translated">Это совершенно новый уровень безумия, когда вы используете &lt;code&gt;==&lt;/code&gt; с объектами.</target>
        </trans-unit>
        <trans-unit id="7e5685be28423b6fa9a147ecdfab572abc4a40a1" translate="yes" xml:space="preserve">
          <source>JSLint sometimes gives you unrealistic reasons to modify stuff. &lt;code&gt;===&lt;/code&gt; has exactly the same performance as &lt;code&gt;==&lt;/code&gt; if the types are already the same.</source>
          <target state="translated">JSLint иногда дает вам нереальные причины для изменения материала. &lt;code&gt;===&lt;/code&gt; имеет точно такую ​​же производительность, что и &lt;code&gt;==&lt;/code&gt; , если типы уже совпадают.</target>
        </trans-unit>
        <trans-unit id="6f75f5a9d4e62f008ab83040158a6ea4c2ffb8de" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;===&lt;/code&gt;&lt;strong&gt;vs&lt;/strong&gt;&lt;code&gt;==&lt;/code&gt; .</source>
          <target state="translated">JavaScript &lt;code&gt;===&lt;/code&gt; &lt;strong&gt;против&lt;/strong&gt; &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f50ece919837ed27b6fe25229b9c0edd82a3a80" translate="yes" xml:space="preserve">
          <source>JavaScript has two sets of equality operators: &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;, and their evil twins &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.  The good ones work the way you would expect.  If the two operands are of the same type and have the same value, then &lt;code&gt;===&lt;/code&gt; produces &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt; produces &lt;code&gt;false&lt;/code&gt;.  The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values.  the rules by which they do that are complicated and unmemorable.  These are some of the interesting cases:</source>
          <target state="translated">В JavaScript есть два набора операторов равенства: &lt;code&gt;===&lt;/code&gt; и &lt;code&gt;!==&lt;/code&gt; , и их злые близнецы &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; . Хорошие работают так, как вы ожидаете. Если два операнда имеют один и тот же тип и имеют одинаковое значение, то &lt;code&gt;===&lt;/code&gt; выдает &lt;code&gt;true&lt;/code&gt; , а &lt;code&gt;!==&lt;/code&gt; выдает &lt;code&gt;false&lt;/code&gt; . Злые близнецы поступают правильно, когда операнды относятся к одному и тому же типу, но если они относятся к разным типам, они пытаются привести значения. правила, по которым они это делают, сложны и не запоминаются. Вот некоторые из интересных случаев:</target>
        </trans-unit>
        <trans-unit id="ddcc47139dece09713aae28867a0635754940c72" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for non strict equality / comparison '=='</source>
          <target state="translated">Блок-схема выполнения Javascript для нестрогого сравнения равенства '=='.</target>
        </trans-unit>
        <trans-unit id="c489836ec904339790b4e755108af00367792205" translate="yes" xml:space="preserve">
          <source>Javascript execution flow diagram for strict equality / Comparison '==='</source>
          <target state="translated">Блок-схема выполнения Javascript для строгого равенства Сравнение '==='</target>
        </trans-unit>
        <trans-unit id="8a105feba0ec261aeed869b80ed97fd71c7d981b" translate="yes" xml:space="preserve">
          <source>Let me add this counsel:</source>
          <target state="translated">Позвольте мне добавить этого адвоката:</target>
        </trans-unit>
        <trans-unit id="b78f589e89c4bf85c5acdcf503fa3ce05322739a" translate="yes" xml:space="preserve">
          <source>Let me say that again:</source>
          <target state="translated">Позволь мне повторить:</target>
        </trans-unit>
        <trans-unit id="7dc48ae18a400d363e4e831b1bc3f62fa17e236b" translate="yes" xml:space="preserve">
          <source>Let's check the types of the operands. Try it out for yourself by wrapping them in &lt;strong&gt;typeof()&lt;/strong&gt;. I find that &lt;strong&gt;new String(&quot;a&quot;)&lt;/strong&gt; is an object, and step 1 is used: return &lt;strong&gt;false&lt;/strong&gt; if the types are different.</source>
          <target state="translated">Давайте проверим типы операндов. Попробуйте сами, обернув их в &lt;strong&gt;typeof ()&lt;/strong&gt; . Я обнаружил, что &lt;strong&gt;новая строка (&amp;laquo;а&amp;raquo;)&lt;/strong&gt; является объектом, и используется шаг 1: вернуть &lt;strong&gt;false,&lt;/strong&gt; если типы различаются.</target>
        </trans-unit>
        <trans-unit id="b61e7aec3e99c633efdc11e39208fc2dff1d3e2c" translate="yes" xml:space="preserve">
          <source>Lets take 2 vars a and b.</source>
          <target state="translated">Давайте возьмем 2 Вар а и б.</target>
        </trans-unit>
        <trans-unit id="cfd185a2bd37b57a50c809cfa0d84c8e0b4f3ff4" translate="yes" xml:space="preserve">
          <source>Make your life less complicated.</source>
          <target state="translated">Сделай свою жизнь менее сложной.</target>
        </trans-unit>
        <trans-unit id="63b41e8cde051766ea25feb26773d03ab2db614d" translate="yes" xml:space="preserve">
          <source>Meaning, there is no reason to change &lt;code&gt;==&lt;/code&gt; to &lt;code&gt;===&lt;/code&gt; in a check like &lt;code&gt;if (a == 'test')&lt;/code&gt; when you know it for a fact that a can only be a String.</source>
          <target state="translated">Это означает, что нет причины менять &lt;code&gt;==&lt;/code&gt; на &lt;code&gt;===&lt;/code&gt; в проверке, например, &lt;code&gt;if (a == 'test')&lt;/code&gt; когда вы знаете, что факт может быть только строкой.</target>
        </trans-unit>
        <trans-unit id="0938c27e70c1f172175d9d18522b01f7447aea0e" translate="yes" xml:space="preserve">
          <source>Modifying a lot of code that way wastes developers' and reviewers' time and achieves nothing.</source>
          <target state="translated">Модификация большого количества кода,таким образом,тратит время разработчиков и рецензентов и ничего не достигает.</target>
        </trans-unit>
        <trans-unit id="f4cefe7cd2cd184bb73ed4c344cfc83710bb0d62" translate="yes" xml:space="preserve">
          <source>My results (tested five times each and averaged):</source>
          <target state="translated">Мои результаты (тестировались по пять раз и были усреднены):</target>
        </trans-unit>
        <trans-unit id="f0da046224ce2dc3106a3b60cd5d194e6ba42983" translate="yes" xml:space="preserve">
          <source>Not so fast!</source>
          <target state="translated">Не так быстро!</target>
        </trans-unit>
        <trans-unit id="d5b784c68e01c822fc3215d8b23457f17bc7b95f" translate="yes" xml:space="preserve">
          <source>Now it becomes interesting:</source>
          <target state="translated">Теперь это становится интересным:</target>
        </trans-unit>
        <trans-unit id="26cf870c221ea623ca6c9613122347141c9e0338" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;strong&gt;identity operator &lt;code&gt;===&lt;/code&gt; does not do type coercion&lt;/strong&gt;, and thus does not convert the values when comparing, and is therefore faster (as according to &lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;This JS benchmark&lt;/a&gt; test) as it skips one step.</source>
          <target state="translated">С другой стороны, &lt;strong&gt;оператор тождества &lt;code&gt;===&lt;/code&gt; не выполняет приведение типов&lt;/strong&gt; и, следовательно, не преобразует значения при сравнении и поэтому работает быстрее (как в соответствии с &lt;a href=&quot;http://jsben.ch/JUOm2&quot;&gt;этим&lt;/a&gt; тестом JS ), поскольку пропускает один шаг.</target>
        </trans-unit>
        <trans-unit id="bb6871c5d84a4419ab95dc8eece8700504fdd6d6" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;==&lt;/code&gt;</source>
          <target state="translated">Оператор &lt;code&gt;==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f06b526b15c78330ed724b58112444a30169da4d" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">Оператор &lt;code&gt;===&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7a3d854bfa0266e9c4a954b8a4122785d12b7cc" translate="yes" xml:space="preserve">
          <source>Or even:</source>
          <target state="translated">Или даже:</target>
        </trans-unit>
        <trans-unit id="596eba5f701a564c8f484f75e8abdc3dd9152672" translate="yes" xml:space="preserve">
          <source>Please let me explain how to read the specification to clarify this question. I see that in this very old topic nobody had an answer for the very strange effect. So, if you can read a specification, this will help you in your profession tremendously. It is an acquired skill. So, let's continue.</source>
          <target state="translated">Пожалуйста,позвольте мне объяснить,как прочитать спецификацию,чтобы прояснить этот вопрос.Я вижу,что в этой очень старой теме ни у кого не было ответа на очень странный эффект.Поэтому,если вы сможете прочитать спецификацию,это вам очень поможет в вашей профессии.Это приобретенный навык.Итак,давайте продолжим.</target>
        </trans-unit>
        <trans-unit id="2a07e2d0f6f8e8b2cf427f387c24f9c27a381095" translate="yes" xml:space="preserve">
          <source>Reasons are explained in in the answers above and also Douglas Crockford is pretty clear about it (&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;).</source>
          <target state="translated">Причины объяснены в ответах выше, и Дуглас Крокфорд довольно ясно об этом ( &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: Хорошие части&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d15ebe82de3e2a210aaf6dba6213d7558919e153" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;Javascript Tutorial: Comparison Operators&lt;/a&gt;</source>
          <target state="translated">Ссылка: &lt;a href=&quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm&quot;&gt;Учебник по Javascript: Операторы сравнения&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ea0f0fa0757bccc8812f547b6f8ef97346e64a" translate="yes" xml:space="preserve">
          <source>Returns true if both operands are equal and of the same type. It's generally 
better and safer if you compare this way, because there's no behind-the-scenes type conversions.</source>
          <target state="translated">Возвращает true,если оба операнда одинаковы и имеют одинаковый тип.Обычно лучше и безопаснее,если сравнивать таким образом,потому что нет никаких закулисных преобразований типов.</target>
        </trans-unit>
        <trans-unit id="957512be3223fc2dc3834f75c1dd58acecceff86" translate="yes" xml:space="preserve">
          <source>Returns true, when both operands are equal. The operands are converted to the same type before being compared.</source>
          <target state="translated">Возвращает истину,когда оба операнда равны.Перед сравнением операнды преобразуются в один тип.</target>
        </trans-unit>
        <trans-unit id="38ce9002bb36040cd6c2edf6d1d18fcb9a616b7a" translate="yes" xml:space="preserve">
          <source>Searching the PDF file for === brings me to page 56 of the specification: &lt;strong&gt;11.9.4. The Strict Equals Operator ( === )&lt;/strong&gt;, and after wading through the specificationalese I find:</source>
          <target state="translated">Поиск в файле PDF для === приводит меня к странице 56 спецификации: &lt;strong&gt;11.9.4.&lt;/strong&gt; &lt;strong&gt;Оператор строгого равенства (===)&lt;/strong&gt; , и после просмотра спецификации я нахожу:</target>
        </trans-unit>
        <trans-unit id="91af0d8b760b9aafb600d14166c0c131354b13a6" translate="yes" xml:space="preserve">
          <source>Simply</source>
          <target state="translated">Simply</target>
        </trans-unit>
        <trans-unit id="64c21976a1564e95206be932a9271ff8e6100731" translate="yes" xml:space="preserve">
          <source>So I'd say that the miniscule difference (this is over 100000 iterations, remember) is negligible. Performance &lt;strong&gt;&lt;em&gt;isn't&lt;/em&gt;&lt;/strong&gt; a reason to do &lt;code&gt;===&lt;/code&gt;. Type safety (well, as safe as you're going to get in JavaScript), and code quality is.</source>
          <target state="translated">Поэтому я бы сказал, что минимальная разница (это более 100000 итераций, помните) ничтожна. Производительность &lt;strong&gt;&lt;em&gt;не&lt;/em&gt;&lt;/strong&gt; повод делать &lt;code&gt;===&lt;/code&gt; . Напечатайте безопасность (ну, так же безопасно, как в JavaScript), и качество кода.</target>
        </trans-unit>
        <trans-unit id="ae0f3a56366851cea007b0cc3ec71cfe6236267c" translate="yes" xml:space="preserve">
          <source>So with the same thing as above, but a strict test:</source>
          <target state="translated">Итак,с тем же,что и выше,но со строгой проверкой:</target>
        </trans-unit>
        <trans-unit id="3c48ceb341b7974b0c35d68232de996773594700" translate="yes" xml:space="preserve">
          <source>So, &lt;em&gt;IMHO,&lt;/em&gt; JSLint maybe used to write new code, but useless over-optimizing should be avoided at all costs.</source>
          <target state="translated">Итак, &lt;em&gt;IMHO,&lt;/em&gt; JSLint может использоваться для написания нового кода, но бесполезной чрезмерной оптимизации следует избегать любой ценой.</target>
        </trans-unit>
        <trans-unit id="f5331af50eaf804f03f6a6159c25f1bb07cd7a40" translate="yes" xml:space="preserve">
          <source>So, let's take the following code:</source>
          <target state="translated">Итак,давайте возьмем следующий код:</target>
        </trans-unit>
        <trans-unit id="93b72b7d5b6694715afdca6d3fa8931c4d1db958" translate="yes" xml:space="preserve">
          <source>So, the 0, false and '' together form a sub-group. And on other hand, null &amp;amp; undefined form the second sub-group. Check the comparisons in the below image. null and undefined would equal. The other three would equal to each other. But, they all are treated as falsy conditions in JavaScript.</source>
          <target state="translated">Итак, 0, false и '' вместе образуют подгруппу. И с другой стороны, null &amp;amp; undefined образуют вторую подгруппу. Проверьте сравнения на изображении ниже. null и undefined будут равны. Три других были бы равны друг другу. Но все они рассматриваются как ложные условия в JavaScript.</target>
        </trans-unit>
        <trans-unit id="1a279fa74ab72ad3bcba6d6c656bd5ebc3d0eab4" translate="yes" xml:space="preserve">
          <source>Strict equality checks (===) should be used in favor of ==. The only
  exception is when checking for undefined and null by way of null.</source>
          <target state="translated">Строгая проверка равенства (===)должна быть использована в пользу ==.Единственное исключение-при проверке на неопределенность и ноль через ноль.</target>
        </trans-unit>
        <trans-unit id="1d6d9051f3abc1e1858ebeb652dd4b2cace2ad46" translate="yes" xml:space="preserve">
          <source>Strings are not value types, but in Javascript they behave like value types, so they will be &quot;equal&quot; when the characters in the string are the same and when they are of the same length (as explained in the third rule)</source>
          <target state="translated">Строки не являются типами значений,но в Javascript они ведут себя как типы значений,поэтому они будут &quot;равны&quot;,когда символы в строке одинаковые и когда они одинаковой длины (как объяснено в третьем правиле).</target>
        </trans-unit>
        <trans-unit id="2fc95a3daa32ef795b3db44197ca06a9161c6605" translate="yes" xml:space="preserve">
          <source>Strings: the special case...</source>
          <target state="translated">Строки:особый случай...</target>
        </trans-unit>
        <trans-unit id="0a10f80e947919598b83985df0a922cea18c825f" translate="yes" xml:space="preserve">
          <source>Take the following example</source>
          <target state="translated">Возьмем следующий пример</target>
        </trans-unit>
        <trans-unit id="34d15b0c36f8c3a873f0aa9868dd4a2ce99ed153" translate="yes" xml:space="preserve">
          <source>That's to say: if both operands of == are objects, == behaves same as ===, which also means identity. The essential difference of this two operators is about type conversion. == has conversion before it checks equality, but === does not.</source>
          <target state="translated">Это значит:если оба операнда ==являются объектами,==ведет себя так же,как ===,что также означает идентичность.Существенное отличие этих двух операторов заключается в приведении типа.==имеет приведение перед проверкой равенства,а ===нет.</target>
        </trans-unit>
        <trans-unit id="b194ffbdff61cd41449b27896d0388ad11bc6102" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator will compare for equality &lt;em&gt;after doing any necessary type conversions&lt;/em&gt;.  The &lt;code&gt;===&lt;/code&gt; operator will &lt;strong&gt;not&lt;/strong&gt; do the conversion, so if two values are not the same type &lt;code&gt;===&lt;/code&gt; will simply return &lt;code&gt;false&lt;/code&gt;. Both are equally quick.</source>
          <target state="translated">Оператор &lt;code&gt;==&lt;/code&gt; будет сравнивать на равенство &lt;em&gt;после выполнения любых необходимых преобразований типов&lt;/em&gt; . Оператор &lt;code&gt;===&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; будет выполнять преобразование, поэтому, если два значения не одного типа, &lt;code&gt;===&lt;/code&gt; просто вернет &lt;code&gt;false&lt;/code&gt; . Оба одинаково быстры.</target>
        </trans-unit>
        <trans-unit id="94d61a1bd3d74a41d42873da5dad1d59e17caf82" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;===&lt;/strong&gt; operator is called a strict comparison operator, it &lt;strong&gt;does&lt;/strong&gt; differ from the &lt;strong&gt;==&lt;/strong&gt; operator.</source>
          <target state="translated">Оператор &lt;strong&gt;===&lt;/strong&gt; называется оператором строгого сравнения, он отличается от оператора &lt;strong&gt;==&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6b4a3a20e019eab11a43250c848486e6d49f5365" translate="yes" xml:space="preserve">
          <source>The End.</source>
          <target state="translated">Конец.</target>
        </trans-unit>
        <trans-unit id="afa8919ed4dc94f9cf1c114da989f410b6e7be00" translate="yes" xml:space="preserve">
          <source>The comparison x === y, where x and y are values, produces &lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;. Such a comparison is performed as follows:</source>
          <target state="translated">Сравнение x === y, где x и y являются значениями, дает &lt;strong&gt;истину&lt;/strong&gt; или &lt;strong&gt;ложь&lt;/strong&gt; . Такое сравнение выполняется следующим образом:</target>
        </trans-unit>
        <trans-unit id="1b98b3145565493d8ec7750f669d527714ecc29b" translate="yes" xml:space="preserve">
          <source>The identity (&lt;code&gt;===&lt;/code&gt;) operator behaves identically to the equality (&lt;code&gt;==&lt;/code&gt;) operator except no type conversion is done, and the types must be the same to be considered equal.</source>
          <target state="translated">Оператор identity ( &lt;code&gt;===&lt;/code&gt; ) ведет себя идентично оператору равенства ( &lt;code&gt;==&lt;/code&gt; ), за исключением того, что преобразование типов не выполняется, и типы должны быть одинаковыми, чтобы считаться равными.</target>
        </trans-unit>
        <trans-unit id="412caf725ac873e21c2342891582c7eb72241e50" translate="yes" xml:space="preserve">
          <source>The lack of transitivity is alarming.  My advice is to never use the evil twins.  Instead, always use &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;.  All of the comparisons just shown produce &lt;code&gt;false&lt;/code&gt; with the &lt;code&gt;===&lt;/code&gt; operator.</source>
          <target state="translated">Отсутствие транзитивности вызывает тревогу. Мой совет - никогда не использовать злых близнецов. Вместо этого всегда используйте &lt;code&gt;===&lt;/code&gt; и &lt;code&gt;!==&lt;/code&gt; . Все только что показанные сравнения дают &lt;code&gt;false&lt;/code&gt; с оператором &lt;code&gt;===&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2ca5becda5d8c525a92af853383dd2f554be5e6" translate="yes" xml:space="preserve">
          <source>The problem is that you might easily get into trouble since JavaScript have a lot of implicit conversions meaning...</source>
          <target state="translated">Проблема в том,что вы можете легко попасть в неприятности,так как у JavaScript много неявных преобразований,означающих...</target>
        </trans-unit>
        <trans-unit id="1c5cdbf6f285cc357902c21867d22dceaabbfb07" translate="yes" xml:space="preserve">
          <source>The rule is:</source>
          <target state="translated">Правило таково:</target>
        </trans-unit>
        <trans-unit id="34e5356fba8841d2e384644ac7191e706b9b383b" translate="yes" xml:space="preserve">
          <source>The same here:</source>
          <target state="translated">Здесь то же самое:</target>
        </trans-unit>
        <trans-unit id="ac6a25542b0ec2ff99281bcf844b6b748cb989bf" translate="yes" xml:space="preserve">
          <source>The special case is when you compare a literal with an object that evaluates to the same literal, due to its &lt;code&gt;toString&lt;/code&gt; or &lt;code&gt;valueOf&lt;/code&gt; method. For example, consider the comparison of a string literal with a string object created by the &lt;code&gt;String&lt;/code&gt; constructor.</source>
          <target state="translated">Особый случай - когда вы сравниваете литерал с объектом, который оценивает один и тот же литерал из-за его метода &lt;code&gt;toString&lt;/code&gt; или &lt;code&gt;valueOf&lt;/code&gt; . Например, рассмотрим сравнение строкового литерала со строковым объектом, созданным конструктором &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="deec20d89955518508df750a0325916894b132b6" translate="yes" xml:space="preserve">
          <source>The top 2 answers both mentioned == means equality and === means identity. Unfortunately, this statement is incorrect.</source>
          <target state="translated">Верхняя 2 отвечает обеим упомянутым ==означает равенство и ===означает идентичность.К сожалению,это утверждение неверно.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="7e6e25d889bccff4888c16c5091398046e021bd5" translate="yes" xml:space="preserve">
          <source>There is unlikely to be any performance difference between the two operations in your usage. There is no type-conversion to be done because both parameters are already the same type. Both operations will have a type comparison followed by a value comparison.</source>
          <target state="translated">Маловероятно,что между этими двумя операциями будет существовать какая-либо разница в производительности при использовании.Преобразование типов не требуется,так как оба параметра уже являются одним и тем же типом.Обе операции будут иметь сравнение типов,за которым последует сравнение значений.</target>
        </trans-unit>
        <trans-unit id="d0addef10584dbb6993cff27164cee0b6c70c9f9" translate="yes" xml:space="preserve">
          <source>This behavior is not always obvious. There's more to the story than being equal and being of the same type.</source>
          <target state="translated">Такое поведение не всегда очевидно.В истории есть нечто большее,чем быть равным и принадлежать к одному и тому же типу.</target>
        </trans-unit>
        <trans-unit id="10b32091fa5a9c7a5536dd0b8d0dbc5d56df3f1a" translate="yes" xml:space="preserve">
          <source>This is because the &lt;strong&gt;equality operator &lt;code&gt;==&lt;/code&gt; does type coercion&lt;/strong&gt;, meaning that the interpreter implicitly tries to convert the values before comparing.</source>
          <target state="translated">Это связано с тем, что &lt;strong&gt;оператор равенства &lt;code&gt;==&lt;/code&gt; выполняет приведение типов&lt;/strong&gt; , то есть интерпретатор неявно пытается преобразовать значения перед сравнением.</target>
        </trans-unit>
        <trans-unit id="e099919ae099449d50619707a595101be1938525" translate="yes" xml:space="preserve">
          <source>This is same as any object (like {}, arrays, etc.), non-empty string &amp;amp; Boolean true are all truthy conditions. But, they are all not equal.</source>
          <target state="translated">Это то же самое, что и любой объект (например, {}, массивы и т. Д.), Непустая строка и логическое значение true - все условия истинности. Но они все не равны.</target>
        </trans-unit>
        <trans-unit id="c01421dd6e3a97aa7a750d67645c9ce033722624" translate="yes" xml:space="preserve">
          <source>To quote Douglas Crockford's excellent &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;,</source>
          <target state="translated">Процитирую превосходный &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0596517742&quot;&gt;JavaScript&lt;/a&gt; Дугласа Крокфорда : Хорошие части ,</target>
        </trans-unit>
        <trans-unit id="1b6611f5af4feb0209552e588441f461e4827c57" translate="yes" xml:space="preserve">
          <source>Type conversion in javaScript means javaScript automatically convert any other data types to string data types.</source>
          <target state="translated">Приведение типов в javaScript означает,что javaScript автоматически преобразует любые другие типы данных в строковые.</target>
        </trans-unit>
        <trans-unit id="acf72ff8536cb7c07913f02c5d05cbe20402fc3e" translate="yes" xml:space="preserve">
          <source>Update:</source>
          <target state="translated">Update:</target>
        </trans-unit>
        <trans-unit id="2dd151cc35444f22efefaf2a4c9200a524eabcbb" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;===&lt;/code&gt; вместо &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c453d7e21f4c791a03dcc4a981e5605615b7d07" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;==&lt;/code&gt; operator (&lt;em&gt;Equality&lt;/em&gt;)</source>
          <target state="translated">Использование оператора &lt;code&gt;==&lt;/code&gt; ( &lt;em&gt;Равенство&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="513b5a2751665a1919f797ca492150f5a95e5dbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;===&lt;/code&gt; operator (&lt;em&gt;Identity&lt;/em&gt;)</source>
          <target state="translated">Использование оператора &lt;code&gt;===&lt;/code&gt; ( &lt;em&gt;личность&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="49fae091b162654343089eb4ba3ab8ccdfc467f0" translate="yes" xml:space="preserve">
          <source>Well it's because unlike &quot;triple equals&quot; (&lt;code&gt;===&lt;/code&gt;) which just checks if two values are the same.</source>
          <target state="translated">Ну, это потому, что в отличие от &quot;тройного равенства&quot; ( &lt;code&gt;===&lt;/code&gt; ), который просто проверяет, являются ли два значения одинаковыми.</target>
        </trans-unit>
        <trans-unit id="fbbea6dde2ab91a36ff23b57623dc1796e371116" translate="yes" xml:space="preserve">
          <source>What do you get when you compare an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; with the number zero &lt;code&gt;0&lt;/code&gt;?</source>
          <target state="translated">Что вы получаете, когда сравниваете пустую строку &lt;code&gt;&quot;&quot;&lt;/code&gt; с числом ноль &lt;code&gt;0&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="67709d0522046140afbdae10c9f80a805117bee6" translate="yes" xml:space="preserve">
          <source>Which equals operator (== vs ===) should be used in JavaScript comparisons</source>
          <target state="translated">Который равен оператору (==vs ===)должен использоваться при сравнениях на JavaScript</target>
        </trans-unit>
        <trans-unit id="697e4e154c1261a7e33818edccc744a4d570a31e" translate="yes" xml:space="preserve">
          <source>Which means you could end up with bugs.</source>
          <target state="translated">Что означает,что ты можешь закончить с жуками.</target>
        </trans-unit>
        <trans-unit id="d141d97a7a3ac22b01fd1cd75711d31e277f0a28" translate="yes" xml:space="preserve">
          <source>Which obviously during runtime does &lt;em&gt;very&lt;/em&gt; undefined things...</source>
          <target state="translated">Который, очевидно, во время выполнения делает &lt;em&gt;очень&lt;/em&gt; неопределенные вещи ...</target>
        </trans-unit>
        <trans-unit id="36933ceea4f2db404d028c82e6364a36ace968a0" translate="yes" xml:space="preserve">
          <source>Which pretty soon becomes a problem. The best sample of why implicit conversion is &quot;evil&quot; can be taken from this code in &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C++ which actually will compile due to an implicit conversion from CString to HANDLE which is a pointer typedef type...</source>
          <target state="translated">Что довольно скоро становится проблемой. Лучший пример того, почему неявное преобразование является &amp;laquo;злым&amp;raquo;, можно взять из этого кода в &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library&quot;&gt;MFC&lt;/a&gt; / C ++, который на самом деле будет компилироваться из-за неявного преобразования из CString в HANDLE, который является указателем typedef типа ...</target>
        </trans-unit>
        <trans-unit id="9fcac86aac0009e66019e4c27ea46100eaf900a2" translate="yes" xml:space="preserve">
          <source>With other words, if String wouldn't be of type Object it couldn't be used with the new operator.</source>
          <target state="translated">Другими словами,если бы String не был типом Object,то его нельзя было бы использовать с оператором new.</target>
        </trans-unit>
        <trans-unit id="45903fac0ea3c75afe550d2440dc48b77fd3f572" translate="yes" xml:space="preserve">
          <source>Yep, that's right according to &lt;code&gt;==&lt;/code&gt; an empty string and the number zero are the same time.</source>
          <target state="translated">Да, это верно в соответствии с &lt;code&gt;==&lt;/code&gt; пустой строкой и нулевым числом одновременно.</target>
        </trans-unit>
        <trans-unit id="eabbe6442a6f27defee150f80d6147176f73513a" translate="yes" xml:space="preserve">
          <source>You can easily test it. Paste following code in an HTML file and open it in browser</source>
          <target state="translated">Ты можешь легко протестировать его.Вставьте следующий код в HTML-файл и откройте его в браузере.</target>
        </trans-unit>
        <trans-unit id="5da640618827894fedb5feef195dd55437e5bda8" translate="yes" xml:space="preserve">
          <source>You will get '&lt;strong&gt;false&lt;/strong&gt;' in alert. Now modify the &lt;code&gt;onPageLoad()&lt;/code&gt; method to &lt;code&gt;alert(x == 5);&lt;/code&gt; you will get &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">Вы получите &amp;laquo; &lt;strong&gt;ложь&lt;/strong&gt; &amp;raquo; в тревоге. Теперь измените метод &lt;code&gt;onPageLoad()&lt;/code&gt; для &lt;code&gt;alert(x == 5);&lt;/code&gt; ты получишь &lt;strong&gt;правду&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="786e97b3ee9fc4b292d5852c2c5943153c4ce91a" translate="yes" xml:space="preserve">
          <source>but</source>
          <target state="translated">but</target>
        </trans-unit>
        <trans-unit id="550f8bc02aebdb930e2ff4b54cf6677ee045437c" translate="yes" xml:space="preserve">
          <source>null and undefined are nothingness, that is,</source>
          <target state="translated">ничто и неопределенность-это небытие,</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
