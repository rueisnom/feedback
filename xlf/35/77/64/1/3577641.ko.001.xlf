<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3577641">
    <body>
      <group id="3577641">
        <trans-unit id="bd1c16acfa3e04178a7c75f46da4c487e96db82d" translate="yes" xml:space="preserve">
          <source>3rd Party Libraries (libxml based)</source>
          <target state="translated">타사 라이브러리 (libxml 기반)</target>
        </trans-unit>
        <trans-unit id="3f03912557d9e8cb0d58bb70f44693ee64e86830" translate="yes" xml:space="preserve">
          <source>3rd-Party (not libxml-based)</source>
          <target state="translated">타사 (libxml 기반 아님)</target>
        </trans-unit>
        <trans-unit id="544f420802f1b7f4381cde62a46a89f0fdd4320a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; (not updated for years)</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; (몇 년 동안 업데이트되지 않음)</target>
        </trans-unit>
        <trans-unit id="a79bf2782f9fde4ac3500bc5190a56bc3cb61962" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; and &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; are extremely similar in replicating the fluent jQuery API. That's also why they're two of the easiest approaches to &lt;em&gt;properly&lt;/em&gt; parse HTML in PHP.</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; 와 &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; 는 유창한 jQuery API 복제와 매우 유사합니다. 그렇기 때문에 PHP에서 HTML을 &lt;em&gt;올바르게&lt;/em&gt; 구문 분석하는 가장 쉬운 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="0fdffada957220d6a8a6ae26cb48926b77945a9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pear.php.net/package/XML_HTMLSax&quot;&gt;&lt;code&gt;XML_HTMLSax&lt;/code&gt;&lt;/a&gt; is rather stable - even if it's not maintained any more. Another option could be to pipe you HTML through &lt;a href=&quot;http://docs.php.net/manual/en/book.tidy.php&quot;&gt;Html Tidy&lt;/a&gt; and then parse it with standard XML tools.</source>
          <target state="translated">&lt;a href=&quot;http://pear.php.net/package/XML_HTMLSax&quot;&gt; &lt;code&gt;XML_HTMLSax&lt;/code&gt; &lt;/a&gt; 는 더 이상 유지되지 않아도 다소 안정적입니다. 또 다른 옵션은 &lt;a href=&quot;http://docs.php.net/manual/en/book.tidy.php&quot;&gt;HTML Tidy를&lt;/a&gt; 통해 HTML 을 파이프 한 다음 표준 XML 도구로 구문 분석하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d60f1b3d0678fe59836a8b6de9a8e467b681d2ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://scraperwiki.com/api/1.0&quot;&gt;ScraperWiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://scraperwiki.com/api/1.0&quot;&gt;ScraperWiki&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b7bf893d7fcdef1f2129df3b54a4823ab40bf3b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/monkeysuffrage/advanced_html_dom&quot;&gt;Advanced Html Dom&lt;/a&gt; is a simple HTML &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; replacement that offers the same interface, but it's DOM-based which means none of the associated memory issues occur.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/monkeysuffrage/advanced_html_dom&quot;&gt;Advanced Html Dom&lt;/a&gt; 은 동일한 인터페이스를 제공하는 간단한 HTML &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; 대체물이지만 DOM 기반이므로 관련 메모리 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63814451d23d80a4e01cf7d057d50122fed02b7f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/search?q=DOM+HTML+[PHP]&amp;amp;submit=search&quot;&gt;How to use the DOM extension has been covered extensively on StackOverflow&lt;/a&gt;, so if you choose to use it, you can be sure most of the issues you run into can be solved by searching/browsing Stack Overflow.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/search?q=DOM+HTML+[PHP]&amp;amp;submit=search&quot;&gt;DOM 확장을 사용하는 방법은 StackOverflow&lt;/a&gt; 에서 광범위하게 다루어 졌으므로 사용하도록 선택하면 스택 오버플로를 검색 / 탐색하여 발생하는 대부분의 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e8d52f8b266675024c8a2025e5d5aff62075d2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://thomas.weinert.info/FluentDOM/&quot;&gt;FluentDom&lt;/a&gt; - &lt;a href=&quot;https://github.com/ThomasWeinert/FluentDOM&quot;&gt;Repo&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://thomas.weinert.info/FluentDOM/&quot;&gt;FluentDom-저장소&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b87824cf6357505f2dd7bdd0cb025c91c9845e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$results&lt;/code&gt; now contains the result set for &lt;code&gt;input[name='forename']&lt;/code&gt; NOT the original query &lt;code&gt;&quot;div p&quot;&lt;/code&gt; this tripped me up a lot, what I found was that &lt;em&gt;QueryPath&lt;/em&gt; tracks the filters and finds and everything which modifies your results and stores them in the object.  you need to do this instead</source>
          <target state="translated">&lt;code&gt;$results&lt;/code&gt; 에 &lt;code&gt;input[name='forename']&lt;/code&gt; 대한 결과 세트가 포함되어 있습니다. 원래 쿼리 &lt;code&gt;&quot;div p&quot;&lt;/code&gt; 가 아닙니다.이 결과는 저를 많이 트립했습니다. 개체에 대신이 작업을 수행해야합니다</target>
        </trans-unit>
        <trans-unit id="5a16f3b4ff2ed4ef8a15b2a2e40067147b5befb0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;QueryPath&lt;/em&gt; is good, but be careful of &quot;tracking state&quot; cause if you didn't realise what it means, it can mean you waste a lot of debugging time trying to find out what happened and why the code doesn't work.</source>
          <target state="translated">&lt;em&gt;QueryPath&lt;/em&gt; 는 좋지만, 무슨 의미인지 모르는 경우 &quot;추적 상태&quot;원인에주의해야합니다. 이는 발생한 결과와 코드가 작동하지 않는 이유를 찾기 위해 많은 디버깅 시간을 낭비 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d9c38fd9cac3bee2d6ed70531b6fb14f6245a91e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Renamed 'select', for obvious reasons&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;명백한 이유로 'select'로 이름이 변경되었습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1759c585e41793ef285aed2e9382f1df5f3a5512" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Renamed 'void', since 'empty' is a reserved word in PHP&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;'empty'는 PHP에서 예약어이므로 'void'로 이름이 변경되었습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="749383e2d1cd518a40c891b7239af37b051d6989" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The library also includes its own zero-configuration autoloader for PSR-0 compatible libraries. The example included should work out of the box without any additional configuration. Alternatively, you can use it with composer.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 라이브러리에는 PSR-0 호환 라이브러리를위한 자체 제로 구성 오토로더도 포함되어 있습니다.&lt;/em&gt; &lt;em&gt;포함 된 예제는 추가 구성없이 즉시 사용할 수 있습니다.&lt;/em&gt; &lt;em&gt;또는 작곡가와 함께 사용할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="427d269cef16d7dd435f53adf9f53c88581fff03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40560fc8e231140d461163449e51ae367fdeafa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples for QueryPath&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;QueryPath의 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e306e3e190d2a70f49058d00b1b093fcf6837564" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I actually have this &lt;a href=&quot;http://fossil.include-once.org/streamtuner2/&quot;&gt;app&lt;/a&gt;, where I employ XML parsing and regular expressions alternatively. Just last week the PyQuery parsing broke, and the regex still worked. Yes weird, and I can't explain it myself. But so it happened.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 실제로이 &lt;a href=&quot;http://fossil.include-once.org/streamtuner2/&quot;&gt;응용 프로그램을&lt;/a&gt; 가지고 있는데, XML 파싱과 정규 표현식을 대안으로 사용합니다. 지난주 PyQuery 파싱이 중단되어 정규 표현식이 계속 작동했습니다. 예, 이상하고 직접 설명 할 수 없습니다. 그러나 그렇게되었습니다.</target>
        </trans-unit>
        <trans-unit id="6d72dd9553207dcc429f79cdba7b6b07adfa5efb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why you shouldn't and &lt;em&gt;when you should&lt;/em&gt; use regular expressions?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;왜 정규 표현식을 사용하지 &lt;em&gt;말아야&lt;/em&gt; 합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbfce2e86e47fefb989be5da4568b10c8adce6e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phpQuery or QueryPath?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;phpQuery 또는 QueryPath?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cae4698fc621dfc4ebc96ae78db8d2cbd4e5ad8c" translate="yes" xml:space="preserve">
          <source>A HTML DOM parser written in PHP&amp;nbsp;5+ that lets you manipulate HTML in a very easy way!</source>
          <target state="translated">매우 쉬운 방법으로 HTML을 조작 할 수있는 PHP 5+로 작성된 HTML DOM 파서!</target>
        </trans-unit>
        <trans-unit id="f5c7b3438f58d5c6af7e2b7180f26f57170d8651" translate="yes" xml:space="preserve">
          <source>A HTML beautifier (like HTML Tidy)</source>
          <target state="translated">HTML 꾸미기 (HTML Tidy와 같은)</target>
        </trans-unit>
        <trans-unit id="664ce6056bbe5b087cfd9fbfb8122d8d3f7e4fd7" translate="yes" xml:space="preserve">
          <source>A Python and PHP implementations of a HTML parser based on the WHATWG HTML5 specification for maximum compatibility with major desktop web browsers.</source>
          <target state="translated">주요 데스크탑 웹 브라우저와의 호환성을 극대화하기 위해 WHATWG HTML5 사양을 기반으로하는 HTML 파서의 Python 및 PHP 구현.</target>
        </trans-unit>
        <trans-unit id="0a002f9eab6a6a440519776a307afcbfdf2d07b8" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found at &lt;a href=&quot;https://stackoverflow.com/questions/3299033/getting-all-values-from-h1-tags-using-php/3299140#3299140&quot;&gt;getting all values from h1 tags using php&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/3299033/getting-all-values-from-h1-tags-using-php/3299140#3299140&quot;&gt;PHP를 사용하여 h1 태그에서 모든 값을 가져 오는&lt;/a&gt; 기본 사용법 예제를 찾을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c214664208233d4467d45fabbc658dff3316d329" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found at &lt;a href=&quot;https://stackoverflow.com/questions/4906073/a-simple-program-to-crud-node-and-node-values-of-xml-file&quot;&gt;A simple program to CRUD node and node values of xml file&lt;/a&gt; and there is &lt;a href=&quot;http://php.net/manual/en/simplexml.examples-basic.php&quot;&gt;lots of additional examples in the PHP Manual&lt;/a&gt;.</source>
          <target state="translated">기본 사용법 예제는 &lt;a href=&quot;https://stackoverflow.com/questions/4906073/a-simple-program-to-crud-node-and-node-values-of-xml-file&quot;&gt;xml 파일의 노드 및 노드 값을 CRUD하는 간단한 프로그램&lt;/a&gt; 에서 찾을 수 있으며 &lt;a href=&quot;http://php.net/manual/en/simplexml.examples-basic.php&quot;&gt;PHP Manual에 추가 예제&lt;/a&gt; 가 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2ec9025c32d35528d4e334718e76dd987674f48" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found in &lt;a href=&quot;https://stackoverflow.com/questions/3820666/regular-expression-for-grabbing-the-href-attribute-of-an-a-element/3820783#3820783&quot;&gt;Grabbing the href attribute of an A element&lt;/a&gt; and a general conceptual overview can be found at &lt;a href=&quot;https://stackoverflow.com/questions/4979836/noob-question-about-domdocument-in-php/4983721#4983721&quot;&gt;DOMDocument in php&lt;/a&gt;</source>
          <target state="translated">기본적인 사용법 예제 &lt;a href=&quot;https://stackoverflow.com/questions/3820666/regular-expression-for-grabbing-the-href-attribute-of-an-a-element/3820783#3820783&quot;&gt;는 A 요소의 href 속성을 잡아서&lt;/a&gt; 찾을 수 있으며 일반적인 개념적 개요는 &lt;a href=&quot;https://stackoverflow.com/questions/4979836/noob-question-about-domdocument-in-php/4983721#4983721&quot;&gt;PHP의 DOMDocument에서&lt;/a&gt; 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd1ad773e01542b3fdd423200776b4fe37d851f7" translate="yes" xml:space="preserve">
          <source>A universal tokenizer and HTML/XML/RSS DOM Parser</source>
          <target state="translated">범용 토크 나이저 및 HTML / XML / RSS DOM 파서</target>
        </trans-unit>
        <trans-unit id="2e22019c08ef666033adfcb2f0c0f12acfb35beb" translate="yes" xml:space="preserve">
          <source>Ability to manipulate elements and their attributes</source>
          <target state="translated">요소와 그 속성을 조작하는 능력</target>
        </trans-unit>
        <trans-unit id="ef04526591e535436aff90c6654fecadc86c579a" translate="yes" xml:space="preserve">
          <source>Above it's a function that parses HTML by regular expression. Note that this function is very sensitive and demands that the HTML obey certain rules, but it works very well in many scenarios. If you want a simple parser, and don't want to install libraries, give this a shot:</source>
          <target state="translated">위의 정규식으로 HTML을 구문 분석하는 함수입니다. 이 기능은 매우 민감하며 HTML은 특정 규칙을 준수해야하지만 많은 시나리오에서 잘 작동합니다. 간단한 파서를 원하고 라이브러리를 설치하지 않으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b515c9a3b099e8dbc88c77e08620321b4e837112" translate="yes" xml:space="preserve">
          <source>Again, I would not recommend this parser. It is rather slow with high CPU usage. There is also no function to clear memory of created DOM objects. These problems scale particularly with nested loops. The documentation itself is inaccurate and misspelled, with no responses to fixes since 14 Apr 16.</source>
          <target state="translated">다시, 나는이 파서를 추천하지 않을 것이다. CPU 사용량이 많으면 속도가 느립니다. 생성 된 DOM 객체의 메모리를 지우는 기능도 없습니다. 이러한 문제는 특히 중첩 루프에서 확장됩니다. 문서 자체는 정확하지 않으며 철자가 틀리며 4 월 16 일 이후 수정에 대한 응답이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ec510988bdc89bf9bd7b325c2f2553b61212a2b" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html&quot;&gt;Html The Cthulhu Way 파싱&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="d8cf1b78bb2f209698c6cdb9597abb54e96eafd6" translate="yes" xml:space="preserve">
          <source>Also see: &lt;a href=&quot;https://github.com/electrolinux/phpquery&quot;&gt;https://github.com/electrolinux/phpquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;https://github.com/electrolinux/phpquery&quot;&gt;https://github.com/electrolinux/phpquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d2a161c418bdf05eb381f6d5ea1c2d6456c164f" translate="yes" xml:space="preserve">
          <source>An HTML DOM parser written in PHP5+ lets you manipulate HTML in a very easy way!</source>
          <target state="translated">PHP5 +로 작성된 HTML DOM 파서는 매우 쉬운 방법으로 HTML을 조작 할 수있게합니다!</target>
        </trans-unit>
        <trans-unit id="144401da89869b09220cb2726f32caf87093fc51" translate="yes" xml:space="preserve">
          <source>And here's &lt;a href=&quot;http://www.ibm.com/developerworks/opensource/library/os-php-querypath/index.html?S_TACT=105AGX01&amp;amp;S_CMP=HP&quot;&gt;a comprehensive QueryPath introduction&lt;/a&gt;.</source>
          <target state="translated">다음 &lt;a href=&quot;http://www.ibm.com/developerworks/opensource/library/os-php-querypath/index.html?S_TACT=105AGX01&amp;amp;S_CMP=HP&quot;&gt;은 포괄적 인 QueryPath 소개&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a46b8d7cd67f87500b5d7718588d2c557ece05e9" translate="yes" xml:space="preserve">
          <source>And lastly, for e&lt;em&gt;xtremely simple tasks&lt;/em&gt; like extracting &amp;lt;img src= urls, they are in fact a probable tool. The speed advantage over SGML/XML parsers mostly just comes to play for these very basic extraction procedures.</source>
          <target state="translated">마지막으로 &amp;lt;img src = url 추출과 같은 &lt;em&gt;매우 간단한 작업의 경우&lt;/em&gt; 실제로 가능한 도구입니다. SGML / XML 파서에 비해 속도 이점은 이러한 기본적인 추출 절차에서 주로 작용합니다.</target>
        </trans-unit>
        <trans-unit id="c2feade56d00684694a9d9e01315c66714df0c54" translate="yes" xml:space="preserve">
          <source>And while I miss the ability to use CSS selectors for &lt;code&gt;DOMDocument&lt;/code&gt;, there is a rather simple and convenient way to add this feature: subclassing the &lt;code&gt;DOMDocument&lt;/code&gt; and adding JS-like &lt;code&gt;querySelectorAll&lt;/code&gt; and &lt;code&gt;querySelector&lt;/code&gt; methods to your subclass.</source>
          <target state="translated">그리고 &lt;code&gt;DOMDocument&lt;/code&gt; 에 CSS 선택기를 사용하는 기능이 누락되었지만 DOMDocument를 서브 클래스 화하고 JS와 같은 &lt;code&gt;querySelectorAll&lt;/code&gt; 및 &lt;code&gt;querySelector&lt;/code&gt; 메소드를 서브 클래스에 추가하는이 기능을 추가하는 다소 간단하고 편리한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2352cb26b5e77a9dad0e37a6ac99e7163a1c86d" translate="yes" xml:space="preserve">
          <source>Another option you can try is &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;. It's inspired by jQuery, but on the server in PHP and used in &lt;a href=&quot;http://en.wikipedia.org/wiki/Drupal&quot;&gt;Drupal&lt;/a&gt;.</source>
          <target state="translated">시도 할 수있는 또 다른 옵션은 &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; 입니다. jQuery에서 영감을 얻었지만 PHP의 서버에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/Drupal&quot;&gt;Drupal&lt;/a&gt; 에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="cba81c44dfc3d4be82ed0b3e1b1de3b4a22126bd" translate="yes" xml:space="preserve">
          <source>Basically you first create a queryable DOM tree from an HTML string:</source>
          <target state="translated">기본적으로 먼저 HTML 문자열에서 쿼리 가능한 DOM 트리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="7aa83623e4641c12a129d48c3ef4ede02906c309" translate="yes" xml:space="preserve">
          <source>But to your specific problem, you should take a look at this project: &lt;a href=&quot;http://fivefilters.org/content-only/&quot;&gt;http://fivefilters.org/content-only/&lt;/a&gt; -- it's a modified version of the &lt;a href=&quot;http://lab.arc90.com/2009/03/02/readability/&quot;&gt;Readability&lt;/a&gt; algorithm, which is designed to extract just the textual content (not headers and footers) from a page.</source>
          <target state="translated">그러나 특정 문제에 대해서는 다음 프로젝트를 살펴보십시오. &lt;a href=&quot;http://fivefilters.org/content-only/&quot;&gt;http://fivefilters.org/content-only/-&lt;/a&gt; 텍스트 내용 만 추출하도록 설계된 &lt;a href=&quot;http://lab.arc90.com/2009/03/02/readability/&quot;&gt;가독성&lt;/a&gt; 알고리즘의 수정 된 버전입니다 (헤더가 아님). 페이지에서</target>
        </trans-unit>
        <trans-unit id="c34ef7238086ad5070c51839516f68c811e10bf0" translate="yes" xml:space="preserve">
          <source>Can perform advanced CSS3-like queries on elements (like jQuery -- namespaces supported)</source>
          <target state="translated">요소에 대해 고급 CSS3와 같은 쿼리를 수행 할 수 있습니다 (예 : jQuery-네임 스페이스 지원)</target>
        </trans-unit>
        <trans-unit id="a1a5d5d399ebd0632976f266a1441e08ad47ca06" translate="yes" xml:space="preserve">
          <source>Consider that making a somewhat dependable HTML extraction regex:</source>
          <target state="translated">다소 안정적인 HTML 추출 정규식을 만드는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="61f6f421ef32670498c220ee8ee339df076a5ad9" translate="yes" xml:space="preserve">
          <source>DOM</source>
          <target state="translated">DOM</target>
        </trans-unit>
        <trans-unit id="55c9f512afeeb3355d19924f291d88cec7fe29e2" translate="yes" xml:space="preserve">
          <source>DOM is capable of parsing and modifying real world (broken) HTML and it can do &lt;a href=&quot;http://schlitt.info/opensource/blog/0704_xpath.html&quot;&gt;XPath queries&lt;/a&gt;. It is based on &lt;a href=&quot;http://xmlsoft.org/html/libxml-HTMLparser.html&quot;&gt;libxml&lt;/a&gt;.</source>
          <target state="translated">DOM은 실제 (깨진) HTML을 구문 분석하고 수정할 수 있으며 &lt;a href=&quot;http://schlitt.info/opensource/blog/0704_xpath.html&quot;&gt;XPath 쿼리를&lt;/a&gt; 수행 할 수 있습니다. &lt;a href=&quot;http://xmlsoft.org/html/libxml-HTMLparser.html&quot;&gt;libxml을&lt;/a&gt; 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="28f67bdf45517367ca4d6f904c2f8392f764b158" translate="yes" xml:space="preserve">
          <source>Example use :</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="12d9de7e25a720caf19e093a74306cc9a4e7c9da" translate="yes" xml:space="preserve">
          <source>Extensible</source>
          <target state="translated">Extensible</target>
        </trans-unit>
        <trans-unit id="52edc154bfd85973b447708309453d1e0d5f9e75" translate="yes" xml:space="preserve">
          <source>Extract content from HTML:</source>
          <target state="translated">HTML에서 컨텐츠를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="e4f2ed31239f8d0e814fac030378d9eb490bf0be" translate="yes" xml:space="preserve">
          <source>Extract contents from HTML in a single line.</source>
          <target state="translated">한 줄에 HTML에서 내용을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="2fe336188376aed8e3f768179ec8a4f84d70f80c" translate="yes" xml:space="preserve">
          <source>Fast and Easy</source>
          <target state="translated">빠르고 쉬운</target>
        </trans-unit>
        <trans-unit id="a7efc89443fd2e4cbb28e16621f9b53f95fe8423" translate="yes" xml:space="preserve">
          <source>Find tags on an HTML page with selectors just like jQuery.</source>
          <target state="translated">jQuery와 같은 선택기를 사용하여 HTML 페이지에서 태그를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="149712bfea49caa6ead7b107cba118d9c4a2fc2c" translate="yes" xml:space="preserve">
          <source>First off, a common misnomer: Regexps are not for &lt;em&gt;&quot;&lt;strong&gt;parsing&lt;/strong&gt;&quot;&lt;/em&gt; HTML. Regexes can however &lt;em&gt;&quot;&lt;strong&gt;extract&lt;/strong&gt;&quot;&lt;/em&gt; data. Extracting is what they're made for. The major drawback of regex HTML extraction over proper SGML toolkits or baseline XML parsers are their syntactic effort and varying reliability.</source>
          <target state="translated">먼저, 일반적인 오해 : 정규식은 HTML을 &lt;em&gt;&quot; &lt;strong&gt;구문 분석&lt;/strong&gt; &quot;하는&lt;/em&gt; 것이 아닙니다. 그러나 정규 표현식은 데이터를 &lt;em&gt;&quot; &lt;strong&gt;추출&lt;/strong&gt; &quot;&lt;/em&gt; 할 수 있습니다. 추출은 그들이 만든 것입니다. 적절한 SGML 툴킷 또는 기본 XML 파서에 대한 정규식 HTML 추출의 주요 단점은 구문 노력과 다양한 안정성입니다.</target>
        </trans-unit>
        <trans-unit id="dfce008c9e988193c2c7cc30fbe30b0aea469a5f" translate="yes" xml:space="preserve">
          <source>FluentDOM provides a jQuery-like fluent XML interface for the DOMDocument in PHP. Selectors are written in XPath or CSS (using a CSS to XPath converter). Current versions extend the DOM implementing standard interfaces and add features from the DOM Living Standard. FluentDOM can load formats like JSON, CSV, JsonML, RabbitFish and others. Can be installed via Composer.</source>
          <target state="translated">FluentDOM은 PHP의 DOMDocument에 대해 jQuery와 같은 유창한 XML 인터페이스를 제공합니다. 선택기는 XPath 또는 CSS로 작성됩니다 (CSS에서 XPath로 변환기 사용). 현재 버전은 DOM 구현 표준 인터페이스를 확장하고 DOM Living Standard의 기능을 추가합니다. FluentDOM은 JSON, CSV, JsonML, RabbitFish 등과 같은 형식을로드 할 수 있습니다. Composer를 통해 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11078285da49b0134a3aebf9e6a39b3e548b91e2" translate="yes" xml:space="preserve">
          <source>FluidXML</source>
          <target state="translated">FluidXML</target>
        </trans-unit>
        <trans-unit id="85efe7a663e33eef32d5be3e18debc0c1f84672d" translate="yes" xml:space="preserve">
          <source>FluidXML is a PHP library for manipulating XML with a concise and fluent API.
  It leverages XPath and the fluent programming pattern to be fun and effective.</source>
          <target state="translated">FluidXML은 간결하고 유창한 API로 XML을 조작하기위한 PHP 라이브러리입니다. XPath와 유창한 프로그래밍 패턴을 활용하여 재미 있고 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="f3ea98adb29e96c7277c98baf79783ffd4939bc8" translate="yes" xml:space="preserve">
          <source>For 1a and 2: I would vote for the new Symfony Componet class DOMCrawler ( &lt;a href=&quot;http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/&quot;&gt;DomCrawler&lt;/a&gt; ).
This class allows queries similar to CSS Selectors. Take a look at this presentation for real-world examples: &lt;a href=&quot;http://www.slideshare.net/fabpot/news-of-the-symfony2-world&quot;&gt;news-of-the-symfony2-world&lt;/a&gt;.</source>
          <target state="translated">1a와 2의 경우 : 새로운 Symfony Componet 클래스 DOMCrawler ( &lt;a href=&quot;http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/&quot;&gt;DomCrawler&lt;/a&gt; )에 투표합니다. 이 클래스는 CSS 선택기와 유사한 쿼리를 허용합니다. 실제 예 ( &lt;a href=&quot;http://www.slideshare.net/fabpot/news-of-the-symfony2-world&quot;&gt;news-of-the-symfony2-world)에&lt;/a&gt; 대한이 프리젠 테이션을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="019b00ae67ed9f11eae28c6c16dcb5be88663ba4" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML5&quot;&gt;HTML5&lt;/a&gt;, html5 lib has been abandoned for years now. The only HTML5 library I can find with a recent update and maintenance records is &lt;a href=&quot;https://github.com/Masterminds/html5-php/releases/1.0.0-beta1&quot;&gt;html5-php&lt;/a&gt; which was just brought to beta 1.0 a little over a week ago.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML5&quot;&gt;HTML5의&lt;/a&gt; 경우 html5 lib는 몇 년 동안 포기되었습니다. 최근 업데이트 및 유지 관리 기록에서 찾을 수있는 유일한 HTML5 라이브러리는 &lt;a href=&quot;https://github.com/Masterminds/html5-php/releases/1.0.0-beta1&quot;&gt;html5-php&lt;/a&gt; 이며, 1 주일 전에 베타 1.0이되었습니다.</target>
        </trans-unit>
        <trans-unit id="0c7b690295ff028bfb68ffa343e78b4ca38a4e07" translate="yes" xml:space="preserve">
          <source>For HTML parsing :</source>
          <target state="translated">HTML 파싱의 경우 :</target>
        </trans-unit>
        <trans-unit id="dc9166e6725c73ab185eec670858a82b9a1165c0" translate="yes" xml:space="preserve">
          <source>For further information on the differences see &lt;a href=&quot;http://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath&quot;&gt;this comparison on the wayback machine from tagbyte.org&lt;/a&gt;. (Original source went missing, so here's an internet archive link. Yes, you can still locate missing pages, people.)</source>
          <target state="translated">차이점에 대한 자세한 내용 &lt;a href=&quot;http://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath&quot;&gt;은 tagbyte.org의 웨이 백 머신에서이 비교를&lt;/a&gt; 참조하십시오. (원본 소스가 누락되었으므로 인터넷 보관 링크가 있습니다. 예, 여전히 누락 된 페이지와 사람을 찾을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="22d8d2b2fb6fda43308a6bf614eb0d42bca679b5" translate="yes" xml:space="preserve">
          <source>For parsing the selectors, I recommend using the very minimalistic &lt;a href=&quot;http://symfony.com/doc/current/components/css_selector.html&quot;&gt;CssSelector component&lt;/a&gt; from the &lt;a href=&quot;http://symfony.com/&quot;&gt;Symfony framework&lt;/a&gt;. This component just translates CSS selectors to XPath selectors, which can then be fed into a &lt;code&gt;DOMXpath&lt;/code&gt; to retrieve the corresponding Nodelist.</source>
          <target state="translated">선택기를 구문 분석하려면 &lt;a href=&quot;http://symfony.com/&quot;&gt;Symfony 프레임 워크&lt;/a&gt; 에서 매우 최소한의 &lt;a href=&quot;http://symfony.com/doc/current/components/css_selector.html&quot;&gt;CssSelector 구성 요소&lt;/a&gt; 를 사용하는 것이 좋습니다. 이 컴포넌트는 CSS 선택기를 XPath 선택기로 변환 한 다음 &lt;code&gt;DOMXpath&lt;/code&gt; 에 제공하여 해당 노드 목록 을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd0d138f0f3d01adb6e9b2bfa7e5e1226d277ea5" translate="yes" xml:space="preserve">
          <source>Ganon</source>
          <target state="translated">Ganon</target>
        </trans-unit>
        <trans-unit id="010d64aa6bcaec1c43df7f15b6e6795eaba5e6de" translate="yes" xml:space="preserve">
          <source>Generally QueryPath is better suited for manipulation of documents. While phpQuery also implements some pseudo AJAX methods (just HTTP requests) to more closely resemble jQuery. It is said that phpQuery is often faster than QueryPath (because of fewer overall features).</source>
          <target state="translated">일반적으로 QueryPath는 문서 조작에 더 적합합니다. phpQuery는 또한 의사 AJAX 메소드 (HTTP 요청 만)를 구현하여 jQuery와 더 유사합니다. phpQuery는 종종 전체 기능이 적기 때문에 QueryPath보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d33a71599358dd446b3a5c5bbb17eb6a539802b6" translate="yes" xml:space="preserve">
          <source>HTML 5</source>
          <target state="translated">HTML 5</target>
        </trans-unit>
        <trans-unit id="2481298ff8cb8b47dd8d49e8f6bf9293936053cb" translate="yes" xml:space="preserve">
          <source>HTML parsers already know the syntactical rules of HTML. Regular expressions have to be taught for each new RegEx you write. RegEx are fine in some cases, but it really depends on your use-case.</source>
          <target state="translated">HTML 파서는 이미 HTML의 구문 규칙을 알고 있습니다. 당신이 쓰는 새로운 정규식마다 정규 표현을 가르쳐야합니다. 경우에 따라 RegEx는 괜찮지 만 실제로는 사용 사례에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6ef2488e29db96459d8f0a2f4afd555a7950eb39" translate="yes" xml:space="preserve">
          <source>Here's the github repo: &lt;a href=&quot;https://github.com/pwarelis/XmlExtractor&quot;&gt;XmlExtractor&lt;/a&gt;</source>
          <target state="translated">여기 github 저장소가 있습니다 : &lt;a href=&quot;https://github.com/pwarelis/XmlExtractor&quot;&gt;XmlExtractor&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c64fd288b23d031d147bac0aa0a5b5c67e88a520" translate="yes" xml:space="preserve">
          <source>How can one parse HTML/XML and extract information from it?</source>
          <target state="translated">HTML / XML을 구문 분석하고 정보를 추출하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e3cc41a06f4bd11f3bf3b219f0962c8f9b07a883" translate="yes" xml:space="preserve">
          <source>How do you parse and process HTML/XML in PHP</source>
          <target state="translated">PHP에서 HTML / XML을 파싱하고 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="6a227cfcf5e09a8662563ee0c093ac92c4d9a454" translate="yes" xml:space="preserve">
          <source>How to get HTML elements:</source>
          <target state="translated">HTML 요소를 얻는 방법 :</target>
        </trans-unit>
        <trans-unit id="4389a53129f0579ecfb989ab0d8e483e12a6aa8e" translate="yes" xml:space="preserve">
          <source>How to modify HTML elements:</source>
          <target state="translated">HTML 요소를 수정하는 방법 :</target>
        </trans-unit>
        <trans-unit id="d88d96ba36436a05a8cfe468304396c953bf885c" translate="yes" xml:space="preserve">
          <source>HtmlPageDom</source>
          <target state="translated">HtmlPageDom</target>
        </trans-unit>
        <trans-unit id="c0d513d3128cbbe47a078efa90613fe568129ba7" translate="yes" xml:space="preserve">
          <source>I am not affiliated with PHP Architect or the authors.</source>
          <target state="translated">나는 PHP Architect 또는 저자와 제휴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbcbf01f4064f686ea8722a2a29768c36f034c48" translate="yes" xml:space="preserve">
          <source>I created a library named &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;&lt;strong&gt;PHPPowertools/DOM-Query&lt;/strong&gt;&lt;/a&gt;, which allows you to crawl HTML5 and XML documents just like you do with jQuery.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;&lt;strong&gt;PHPPowertools / DOM-Query&lt;/strong&gt;&lt;/a&gt; 라는 라이브러리를 만들었습니다.이 라이브러리를 사용하면 jQuery와 마찬가지로 HTML5 및 XML 문서를 크롤링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba6b30ea78ddf3eba99914702d1561cbba328440" translate="yes" xml:space="preserve">
          <source>I generally do not recommend this parser. The codebase is horrible and the parser itself is rather slow and memory hungry. Not all jQuery Selectors (such as &lt;a href=&quot;https://api.jquery.com/child-selector/&quot;&gt;child selectors&lt;/a&gt;) are possible. Any of the libxml based libraries should outperform this easily.</source>
          <target state="translated">나는 일반적 으로이 파서를 권장하지 않습니다. 코드베이스는 끔찍하며 파서 자체는 다소 느리고 메모리가 부족합니다. 모든 jQuery 선택기 (예 : &lt;a href=&quot;https://api.jquery.com/child-selector/&quot;&gt;하위 선택기&lt;/a&gt; )가 가능한 것은 아닙니다. libxml 기반 라이브러리는이 성능을 쉽게 능가해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb6fc4ab03473e7d17c1de5c02d235ac14fd367c" translate="yes" xml:space="preserve">
          <source>I have never used curl for the purpose but what I have learned is that curl can do the job much more efficiently and is much more solid.</source>
          <target state="translated">나는 컬을 목적으로 사용하지 않았지만 내가 배운 것은 컬이 훨씬 효율적으로 작업을 수행 할 수 있고 훨씬 견고하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a95c793e7e56b31812864ca97fa71b47951770bc" translate="yes" xml:space="preserve">
          <source>I have written a general purpose XML parser that can easily handle GB files. It's based on XMLReader and it's very easy to use:</source>
          <target state="translated">GB 파일을 쉽게 처리 할 수있는 범용 XML 파서를 작성했습니다. XMLReader를 기반으로하며 사용하기 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="357606d09d492cf4482c3593cd4945b8c282bb19" translate="yes" xml:space="preserve">
          <source>I merely want to add that I personally prefer using the DOM extension and why :</source>
          <target state="translated">필자는 개인적으로 DOM 확장을 사용하는 것을 선호한다고 덧붙이고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="339836ff45972f30237165fb9e1c7b9692b84246" translate="yes" xml:space="preserve">
          <source>I prefer using one of the &lt;a href=&quot;http://php.net/manual/en/refs.xml.php&quot;&gt;native XML extensions&lt;/a&gt; since they come bundled with PHP, are usually faster than all the 3rd party libs and give me all the control I need over the markup.</source>
          <target state="translated">PHP와 번들로 제공되는 &lt;a href=&quot;http://php.net/manual/en/refs.xml.php&quot;&gt;기본 XML 확장&lt;/a&gt; 중 하나를 사용하는 것이 좋습니다. 일반적으로 모든 타사 라이브러리보다 빠르며 마크 업에 필요한 모든 제어 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5d8cbf62fddda3fe5bed7b863aae097fe3f69e98" translate="yes" xml:space="preserve">
          <source>I recommend &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;PHP Simple HTML DOM Parser&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;PHP Simple HTML DOM Parser를&lt;/a&gt; 권장합니다.</target>
        </trans-unit>
        <trans-unit id="84ae9571dbd8d9c4e5f813977179983452830ffd" translate="yes" xml:space="preserve">
          <source>I've created a library called HTML5DOMDocument that is freely available at &lt;a href=&quot;https://github.com/ivopetkov/html5-dom-document-php&quot;&gt;https://github.com/ivopetkov/html5-dom-document-php&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ivopetkov/html5-dom-document-php&quot;&gt;https://github.com/ivopetkov/html5-dom-document-php&lt;/a&gt; 에서 자유롭게 사용할 수있는 HTML5DOMDocument라는 라이브러리를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="f1783e93efdfa64b38f9953aae0900acc436e264" translate="yes" xml:space="preserve">
          <source>I've used this in a number of tools, testing it on many different types of web pages, and I think it works great.</source>
          <target state="translated">나는 이것을 여러 도구에서 사용하여 여러 유형의 웹 페이지에서 테스트했으며 훌륭하게 작동한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="de24ae92f1c60dd3b9a2acc993da1dabf7ccfff8" translate="yes" xml:space="preserve">
          <source>If you don't feel like programming PHP, you can also use Web services. In general, I found very little utility for these, but that's just me and my use cases.</source>
          <target state="translated">PHP 프로그래밍이 마음에 들지 않으면 웹 서비스를 사용할 수도 있습니다. 일반적으로, 나는 이것들에 대한 유틸리티가 거의 없다는 것을 알았지 만 그것은 단지 나와 내 유스 케이스입니다.</target>
        </trans-unit>
        <trans-unit id="54f146095c7e90652a02eaaa284db8fac07cafa2" translate="yes" xml:space="preserve">
          <source>If you prefer to use a 3rd-party lib, I'd suggest using a lib that actually uses &lt;a href=&quot;http://php.net/manual/en/book.dom.php&quot;&gt;DOM&lt;/a&gt;/&lt;a href=&quot;http://xmlsoft.org/&quot;&gt;libxml&lt;/a&gt; underneath instead of string parsing.</source>
          <target state="translated">타사 lib를 사용하려면 문자열 구문 분석 대신 실제로 &lt;a href=&quot;http://php.net/manual/en/book.dom.php&quot;&gt;DOM&lt;/a&gt; / &lt;a href=&quot;http://xmlsoft.org/&quot;&gt;libxml&lt;/a&gt; 을 사용하는 lib를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4547441eafff3d38922bc0db40181f5ace8b4996" translate="yes" xml:space="preserve">
          <source>If you want to spend some money, have a look at</source>
          <target state="translated">돈을 쓰고 싶다면</target>
        </trans-unit>
        <trans-unit id="66264988483b0b4b5f9a545e7d1e048b3553f2a3" translate="yes" xml:space="preserve">
          <source>If you're familiar with jQuery selector, you can use &lt;a href=&quot;https://github.com/ScarletsFiction/ScarletsQuery&quot;&gt;ScarletsQuery&lt;/a&gt; for PHP</source>
          <target state="translated">jQuery 선택기에 익숙한 경우 PHP 용 &lt;a href=&quot;https://github.com/ScarletsFiction/ScarletsQuery&quot;&gt;ScarletsQuery&lt;/a&gt; 를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4d5575093d6413d3f97f557e98a63bbd8b9025e7" translate="yes" xml:space="preserve">
          <source>It also accept invalid HTML or missing quote on tag attributes.</source>
          <target state="translated">태그 속성에 잘못된 HTML 또는 누락 된 따옴표도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6d66305bb90d7ea542c8c6aad06e7a21d4ac7479" translate="yes" xml:space="preserve">
          <source>It also has full CSS support, including &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; extensions.</source>
          <target state="translated">또한 &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; 확장을 포함하여 전체 CSS를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="25432a75a0586b1da4ec0478132a4dae9bb24a9d" translate="yes" xml:space="preserve">
          <source>It really has nice features, like:</source>
          <target state="translated">실제로 다음과 같은 멋진 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c5c9e5bf0835f1de708dac8dda79e1196e30c58" translate="yes" xml:space="preserve">
          <source>It supports query selectors too that I think will be extremely helpful in your case. Here is some example code:</source>
          <target state="translated">쿼리 선택기를 지원하므로 귀하의 경우에 매우 도움이 될 것이라고 생각합니다. 예제 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f099bf29cecda917eab795da4d9f9293e52130c7" translate="yes" xml:space="preserve">
          <source>It takes some time to get productive with DOM, but that time is well worth it IMO. Since DOM is a language-agnostic interface, you'll find implementations in many languages, so if you need to change your programming language, chances are you will already know how to use that language's DOM API then.</source>
          <target state="translated">DOM으로 생산성을 얻는 데 약간의 시간이 걸리지 만 그 시간은 IMO의 가치가 있습니다. DOM은 언어에 구애받지 않는 인터페이스이므로 여러 언어로 구현 된 것을 볼 수 있으므로 프로그래밍 언어를 변경해야하는 경우 해당 언어의 DOM API를 사용하는 방법을 이미 알고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d452f4389b55a57f93798030576c7607d916d482" translate="yes" xml:space="preserve">
          <source>It treats DOM elements in an object-oriented way, and the new iteration has a lot of coverage for non-compliant code. There are also some great functions like you'd see in JavaScript, such as the &quot;find&quot; function, which will return all instances of elements of that tag name.</source>
          <target state="translated">DOM 요소를 객체 지향 방식으로 처리하며 새로운 반복에는 비 호환 코드가 많이 포함됩니다. &quot;find&quot;함수와 같이 JavaScript에서 볼 수있는 훌륭한 기능도 있습니다.이 기능은 해당 태그 이름 요소의 모든 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f77033e3cd943fcbdc5f951c94653a819b0e7a5f" translate="yes" xml:space="preserve">
          <source>It's sometimes even advisable to pre-extract a snippet of HTML using regular expressions &lt;code&gt;/&amp;lt;!--CONTENT--&amp;gt;(.+?)&amp;lt;!--END--&amp;gt;/&lt;/code&gt; and process the remainder using the simpler HTML parser frontends.</source>
          <target state="translated">정규 표현식 &lt;code&gt;/&amp;lt;!--CONTENT--&amp;gt;(.+?)&amp;lt;!--END--&amp;gt;/&lt;/code&gt; 를 사용하여 HTML 스 니펫을 사전 추출하고 더 간단한 HTML 구문 분석기 프론트 엔드를 사용하여 나머지를 처리하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c75352eba2f1997a0100830871fe331ba99a290c" translate="yes" xml:space="preserve">
          <source>JSON and array from XML in three lines:</source>
          <target state="translated">JSON 및 XML의 배열은 세 줄로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2c86a3c52b12cd6eba84f473339f4b1433a03e0d" translate="yes" xml:space="preserve">
          <source>Just use &lt;a href=&quot;http://docs.php.net/manual/en/domdocument.loadhtml.php&quot;&gt;DOMDocument-&amp;gt;loadHTML()&lt;/a&gt; and be done with it. libxml's HTML parsing algorithm is quite good and fast, and contrary to popular belief, does not choke on malformed HTML.</source>
          <target state="translated">&lt;a href=&quot;http://docs.php.net/manual/en/domdocument.loadhtml.php&quot;&gt;DOMDocument-&amp;gt; loadHTML ()을 사용&lt;/a&gt; 하고 완료하십시오. libxml의 HTML 파싱 알고리즘은 상당히 좋고 빠르며 대중의 생각과 달리 잘못된 HTML을 질식시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77af834f38039e4a75c2d1af87fc51c7f4c83af5" translate="yes" xml:space="preserve">
          <source>Kindly check out this link:&lt;a href=&quot;http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/&quot;&gt;scraping-websites-with-curl&lt;/a&gt;</source>
          <target state="translated">이 링크를 확인하십시오 : &lt;a href=&quot;http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/&quot;&gt;scraping-websites-with-curl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df5af4eaf6333c18a92e864a88a527466c8e2a87" translate="yes" xml:space="preserve">
          <source>Last and &lt;strong&gt;least recommended&lt;/strong&gt;, you can extract data from HTML with &lt;a href=&quot;https://stackoverflow.com/search?q=regular%20expression%20tutorials&quot;&gt;regular expressions&lt;/a&gt;. In general using Regular Expressions on HTML is discouraged.</source>
          <target state="translated">마지막으로 &lt;strong&gt;추천&lt;/strong&gt; 하는 것은 &lt;a href=&quot;https://stackoverflow.com/search?q=regular%20expression%20tutorials&quot;&gt;정규 표현식을 사용&lt;/a&gt; 하여 HTML에서 데이터를 추출 할 수 있습니다. 일반적으로 HTML에서 정규 표현식을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2aba8d7afde1162b4fd4210f44e3fd0179a97e30" translate="yes" xml:space="preserve">
          <source>Many DOM traversal frontends don't reveal HTML comments &lt;code&gt;&amp;lt;!--&lt;/code&gt;, which however are sometimes the more useful anchors for extraction. In particular pseudo-HTML variations &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; or SGML residues are easy to tame with regexps.</source>
          <target state="translated">많은 DOM 순회 프론트 엔드는 HTML 주석 &lt;code&gt;&amp;lt;!--&lt;/code&gt; 을 나타내지 않지만 때로는 추출에 더 유용한 앵커입니다. 특히 유사 HTML 변형 &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; 또는 SGML 잔기는 정규 표현식으로 쉽게 길들일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f83c03a7d83375b8530b744da5d4e14cb773741" translate="yes" xml:space="preserve">
          <source>Minify CSS and Javascript</source>
          <target state="translated">CSS 및 자바 스크립트 축소</target>
        </trans-unit>
        <trans-unit id="627adea35309c41eae7e01931d886d77e7c41c7d" translate="yes" xml:space="preserve">
          <source>Most of the snippets you will find on the web to match markup are brittle. In most cases they are only working for a very particular piece of HTML. Tiny markup changes, like adding whitespace somewhere, or adding, or changing attributes in a tag, can make the RegEx fails when it's not properly written. You should know what you are doing before using RegEx on HTML.</source>
          <target state="translated">웹에서 찾을 수있는 대부분의 스 니펫은 마크 업과 일치합니다. 대부분의 경우 그들은 매우 특정한 HTML 부분에서만 작동합니다. 어딘가에 공백을 추가하거나 태그에서 속성을 추가 또는 변경하는 등의 작은 마크 업 변경은 RegEx가 올바르게 작성되지 않을 때 실패하게 만들 수 있습니다. HTML에서 RegEx를 사용하기 전에 수행중인 작업을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="89b2f5b0133f65e45226a07f5cee8565bdcadf34" translate="yes" xml:space="preserve">
          <source>Mostly you want to use simple &lt;code&gt;#id&lt;/code&gt; and &lt;code&gt;.class&lt;/code&gt; or &lt;code&gt;DIV&lt;/code&gt; tag selectors for &lt;code&gt;-&amp;gt;find()&lt;/code&gt;. But you can also use &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; statements, which sometimes are faster. Also typical jQuery methods like &lt;code&gt;-&amp;gt;children()&lt;/code&gt; and &lt;code&gt;-&amp;gt;text()&lt;/code&gt; and particularly &lt;code&gt;-&amp;gt;attr()&lt;/code&gt; simplify extracting the right HTML snippets. (And already have their SGML entities decoded.)</source>
          <target state="translated">대부분 &lt;code&gt;-&amp;gt;find()&lt;/code&gt; 간단한 &lt;code&gt;#id&lt;/code&gt; 및 &lt;code&gt;.class&lt;/code&gt; 또는 &lt;code&gt;DIV&lt;/code&gt; 태그 선택기를 사용하려고합니다. 그러나 때때로 더 빠른 &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; 문을 사용할 수도 있습니다. 또한 &lt;code&gt;-&amp;gt;children()&lt;/code&gt; 및 &lt;code&gt;-&amp;gt;text()&lt;/code&gt; 및 특히 &lt;code&gt;-&amp;gt;attr()&lt;/code&gt; 과 같은 일반적인 jQuery 메소드는 올바른 HTML 스 니펫 추출을 단순화합니다. (이미 SGML 엔터티가 이미 디코딩되었습니다.)</target>
        </trans-unit>
        <trans-unit id="9031cd061d55fd09d5631c31edd51747001a785e" translate="yes" xml:space="preserve">
          <source>NOTE :</source>
          <target state="translated">노트 :</target>
        </trans-unit>
        <trans-unit id="1300a697b19e9262ea20292114599c4fd1368aef" translate="yes" xml:space="preserve">
          <source>Native XML Extensions</source>
          <target state="translated">기본 XML 확장</target>
        </trans-unit>
        <trans-unit id="1677e20649f0c9d5ffd70eb67cbee8c3b828533d" translate="yes" xml:space="preserve">
          <source>Never used it. Can't tell if it's any good.</source>
          <target state="translated">사용하지 마십시오. 그것이 좋은지 말할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="62ea675f26d38d09101a41ac861850d50fba75d0" translate="yes" xml:space="preserve">
          <source>Oftentimes regular expressions can save post-processing. However HTML entities often require manual caretaking.</source>
          <target state="translated">정규 표현식은 종종 사후 처리를 절약 할 수 있습니다. 그러나 HTML 엔터티에는 종종 수동 관리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1f83f8dcdf419895f7c7a83c7580b9a96b3f2f1c" translate="yes" xml:space="preserve">
          <source>One general approach I haven't seen mentioned here is to run HTML through &lt;a href=&quot;http://php.net/manual/en/book.tidy.php&quot;&gt;Tidy&lt;/a&gt;, which can be set to spit out guaranteed-valid XHTML. Then you can use any old XML library on it.</source>
          <target state="translated">내가 여기에 언급하지 않은 한 가지 일반적인 접근법은 &lt;a href=&quot;http://php.net/manual/en/book.tidy.php&quot;&gt;Tidy를&lt;/a&gt; 통해 HTML을 실행하는 것입니다. 유효한 유효한 XHTML을 뱉어 내도록 설정할 수 있습니다. 그런 다음 이전 XML 라이브러리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="578a94497cee464a3ed319fd370eec273b62e6df" translate="yes" xml:space="preserve">
          <source>Operations separated in smaller functions for easy overriding</source>
          <target state="translated">쉬운 오버라이드를 위해 작은 기능으로 분리 된 작업</target>
        </trans-unit>
        <trans-unit id="7ed99b9fb3a5520bfade55b9fe5642a263895c2a" translate="yes" xml:space="preserve">
          <source>PHP Architect's Guide to Webscraping with PHP</source>
          <target state="translated">PHP로 웹 스크래핑하기위한 PHP 아키텍트 안내서</target>
        </trans-unit>
        <trans-unit id="2fdc33ef5621a15328fa3e4a16e51f86b20c60b0" translate="yes" xml:space="preserve">
          <source>PHP Html Parser</source>
          <target state="translated">PHP HTML 파서</target>
        </trans-unit>
        <trans-unit id="2fccda5363a87dcdb8f1237ddb0532e23fc267f7" translate="yes" xml:space="preserve">
          <source>PHP Simple HTML DOM Parser</source>
          <target state="translated">PHP 간단한 HTML DOM 파서</target>
        </trans-unit>
        <trans-unit id="d4f4d957c818e56ebc312e877f197ce68488f02a" translate="yes" xml:space="preserve">
          <source>PHPHtmlParser is a simple, flexible, html parser which allows you to select tags using any css selector, like jQuery. The goal is to assiste in the development of tools which require a quick, easy way to scrap html, whether it's valid or not! This project was original supported by sunra/php-simple-html-dom-parser but the support seems to have stopped so this project is my adaptation of his previous work.</source>
          <target state="translated">PHPHtmlParser는 jQuery와 같은 CSS 선택기를 사용하여 태그를 선택할 수있는 간단하고 유연한 HTML 파서입니다. 목표는 HTML이 유효한지 여부에 관계없이 빠르고 쉽게 HTML을 스크랩하는 도구가 필요한 도구 개발을 지원하는 것입니다! 이 프로젝트는 sunra / php-simple-html-dom-parser에 의해 원래 지원되었지만 지원이 중단 된 것으로 보이므로이 프로젝트는 이전 작업에 대한 나의 적응입니다.</target>
        </trans-unit>
        <trans-unit id="28d936680a9cd1da534d5bab294f5e31d74394d2" translate="yes" xml:space="preserve">
          <source>Parsing documents using callbacks based on current character/token</source>
          <target state="translated">현재 문자 / 토큰을 기반으로 콜백을 사용하여 문서 파싱</target>
        </trans-unit>
        <trans-unit id="a11058217485bda936a7947b3f8dea9dca2c1f2d" translate="yes" xml:space="preserve">
          <source>Proper data unescaping (in comparison to regular expression grepping)</source>
          <target state="translated">적절한 데이터 이스케이프 처리 (정규 표현식 그 리핑과 비교)</target>
        </trans-unit>
        <trans-unit id="a81c033171fc90b40305445d7d6e17317ebc3577" translate="yes" xml:space="preserve">
          <source>QueryPath</source>
          <target state="translated">QueryPath</target>
        </trans-unit>
        <trans-unit id="9737e148f4e81913479e1971cb61a0356bc18cc5" translate="yes" xml:space="preserve">
          <source>QueryPath also allows injecting new tags into the stream (&lt;code&gt;-&amp;gt;append&lt;/code&gt;), and later output and prettify an updated document (&lt;code&gt;-&amp;gt;writeHTML&lt;/code&gt;). It can not only parse malformed HTML, but also various XML dialects (with namespaces), and even extract data from HTML microformats (XFN, vCard).</source>
          <target state="translated">또한 QueryPath를 사용하면 스트림에 새 태그를 삽입하고 ( &lt;code&gt;-&amp;gt;append&lt;/code&gt; ) 나중에 업데이트 된 문서를 출력하고 미리 정의 할 수 있습니다 ( &lt;code&gt;-&amp;gt;writeHTML&lt;/code&gt; ). 잘못된 HTML뿐만 아니라 다양한 XML 언어 (네임 스페이스 포함)를 구문 분석하고 HTML 마이크로 포맷 (XFN, vCard)에서 데이터를 추출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="95df12b37819a2adfe3f819892d0d4de469b52c4" translate="yes" xml:space="preserve">
          <source>QueryPath is a PHP library for manipulating XML and HTML. It is designed to work not only with local files, but also with web services and database resources. It implements much of the jQuery interface (including CSS-style selectors), but it is heavily tuned for server-side use.  Can be installed via Composer.</source>
          <target state="translated">QueryPath는 XML 및 HTML 조작을위한 PHP 라이브러리입니다. 로컬 파일뿐만 아니라 웹 서비스 및 데이터베이스 리소스에서도 작동하도록 설계되었습니다. CSS 스타일 선택기를 포함하여 많은 jQuery 인터페이스를 구현하지만 서버 측 사용을 위해 크게 조정되었습니다. Composer를 통해 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab140354a34bd045ff52d42f722acc1c4ffada22" translate="yes" xml:space="preserve">
          <source>Regular Expressions</source>
          <target state="translated">정규식</target>
        </trans-unit>
        <trans-unit id="036e8223cfc6af3bc474124d436998f668393599" translate="yes" xml:space="preserve">
          <source>Require PHP 5+.</source>
          <target state="translated">PHP 5 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="76a7e0d2a9377458c6ef9ab5843fd65dd104d40a" translate="yes" xml:space="preserve">
          <source>ScraperWiki's external interface allows you to extract data in the form you want for use on the web or in your own applications. You can also extract information about the state of any scraper.</source>
          <target state="translated">ScraperWiki의 외부 인터페이스를 사용하면 웹이나 자신의 응용 프로그램에서 사용하려는 형태로 데이터를 추출 할 수 있습니다. 스크레이퍼의 상태에 대한 정보를 추출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9a3a60c4a1b9153da07bbc915c70995d1fcd9b2" translate="yes" xml:space="preserve">
          <source>Scraping Slashdot:</source>
          <target state="translated">긁어 모으기</target>
        </trans-unit>
        <trans-unit id="f2508406c16bde16405a9e91ecee59698672e940" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors&quot;&gt;Parsing XML documents with CSS selectors&lt;/a&gt; by Symfony's creator Fabien Potencier on his decision to create the CssSelector component for Symfony and how to use it.</source>
          <target state="translated">Symfony의 작성자 Fabien Potencier가 Symfony 용 CssSelector 구성 요소 작성 결정 및 사용 방법에 대한 &lt;a href=&quot;http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors&quot;&gt;CSS 선택기&lt;/a&gt; 로 XML 문서 구문 분석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="20496fe36fbd9068f5e0745949f57d1a30754cf2" translate="yes" xml:space="preserve">
          <source>Simple HTML DOM is a great open-source parser:</source>
          <target state="translated">간단한 HTML DOM은 훌륭한 오픈 소스 파서입니다.</target>
        </trans-unit>
        <trans-unit id="26acadafb8b9e27c131ae620d79467303283aec3" translate="yes" xml:space="preserve">
          <source>Simple to use alternatives &lt;code&gt;-&amp;gt;find(&quot;a img, a object, div a&quot;)&lt;/code&gt;</source>
          <target state="translated">사용하기 쉬운 대안 &lt;code&gt;-&amp;gt;find(&quot;a img, a object, div a&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac04b5615f2819c31f2d067d7f8923ef7ff7ef21" translate="yes" xml:space="preserve">
          <source>SimpleXML is an option when you know the HTML is valid XHTML. If you need to parse broken HTML, don't even consider SimpleXml because it will choke.</source>
          <target state="translated">SimpleXML은 HTML이 유효한 XHTML이라는 것을 알고있을 때의 옵션입니다. 깨진 HTML을 구문 분석해야하는 경우에는 질식 할 것이므로 SimpleXml도 고려하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8b459878d5dac1498236eb8ec705c4653131f954" translate="yes" xml:space="preserve">
          <source>SimpleXml</source>
          <target state="translated">SimpleXml</target>
        </trans-unit>
        <trans-unit id="4ab9bc94de911e1bbbc353ed1187f6ef58e14b32" translate="yes" xml:space="preserve">
          <source>Simplicity and Reliability</source>
          <target state="translated">단순성과 신뢰성</target>
        </trans-unit>
        <trans-unit id="04b1d51ec3918aabce9a1745c1f2074a9358a9f6" translate="yes" xml:space="preserve">
          <source>So please don't vote real-world considerations down, just because it doesn't match the regex=evil meme. &lt;strong&gt;But let's also not vote this up too much. It's just a sidenote for this topic.&lt;/strong&gt;</source>
          <target state="translated">따라서 실제 고려 사항은 regex = evil meme와 일치하지 않기 때문에 투표하지 마십시오. &lt;strong&gt;그러나 이것을 너무 많이 투표하지 말자.&lt;/strong&gt; &lt;strong&gt;이 주제에 대한 주석 일뿐입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19dfc66630e4b772779cd9a262a504499ad4897f" translate="yes" xml:space="preserve">
          <source>Sort attributes, change character case, correct indentation, etc.</source>
          <target state="translated">속성 정렬, 대소 문자 변경, 들여 쓰기 수정 등</target>
        </trans-unit>
        <trans-unit id="6492f0b8f23e2427034e89fba4fc783788408998" translate="yes" xml:space="preserve">
          <source>Supported methods :</source>
          <target state="translated">지원되는 방법 :</target>
        </trans-unit>
        <trans-unit id="09c87bdf1f20971fcf51b21e634812d66a597646" translate="yes" xml:space="preserve">
          <source>Supports invalid HTML and UTF8</source>
          <target state="translated">유효하지 않은 HTML 및 UTF8 지원</target>
        </trans-unit>
        <trans-unit id="1b4f692c4cf3ff10d493de7506631f00988acc7a" translate="yes" xml:space="preserve">
          <source>Supports invalid HTML.</source>
          <target state="translated">잘못된 HTML을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4b51562e1d3f8c3ee0992b96a3771823cf482336" translate="yes" xml:space="preserve">
          <source>Ta da!</source>
          <target state="translated">타 다!</target>
        </trans-unit>
        <trans-unit id="22123f0c078e1328382bb3ba2c871a5312c22c9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Symfony&quot;&gt;Symfony&lt;/a&gt; framework has bundles which can parse the HTML, and you can use CSS style to select the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOMs&lt;/a&gt; instead of using &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Symfony&quot;&gt;Symfony&lt;/a&gt; 프레임 워크에는 HTML을 구문 분석 할 수있는 번들이 있으며 &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; 대신 CSS 스타일을 사용하여 &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; 을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08426608042619571ea8da728effcd8bdb8ccddf" translate="yes" xml:space="preserve">
          <source>The DOM extension allows you to operate on XML documents through the DOM API with PHP 5. It is an implementation of the W3C's Document Object Model Core Level 3, a platform- and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure and style of documents.</source>
          <target state="translated">DOM 확장을 사용하면 PHP 5가 포함 된 DOM API를 통해 XML 문서에서 작업 할 수 있습니다. W3C의 Document Object Model Core Level 3은 프로그램 및 스크립트가 동적으로 액세스하고 업데이트 할 수있는 플랫폼 및 언어 중립 인터페이스입니다. 문서의 내용, 구조 및 스타일.</target>
        </trans-unit>
        <trans-unit id="6af68a6b854fdff9293628426a280a5712ed9a80" translate="yes" xml:space="preserve">
          <source>The SimpleXML extension provides a very simple and easily usable toolset to convert XML to an object that can be processed with normal property selectors and array iterators.</source>
          <target state="translated">SimpleXML 확장은 XML을 일반 속성 선택기 및 배열 반복자로 처리 할 수있는 객체로 변환하는 매우 간단하고 쉽게 사용할 수있는 도구 집합을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="56fa67264d262a826c383e93de2a9bbeefb33eaa" translate="yes" xml:space="preserve">
          <source>The XML Parser library is also based on libxml, and implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Simple_API_for_XML&quot;&gt;SAX&lt;/a&gt; style XML push parser. It may be a better choice for memory management than DOM or SimpleXML, but will be more difficult to work with than the pull parser implemented by XMLReader.</source>
          <target state="translated">XML 파서 라이브러리는 또한 libxml을 기반으로하며 &lt;a href=&quot;http://en.wikipedia.org/wiki/Simple_API_for_XML&quot;&gt;SAX&lt;/a&gt; 스타일 XML 푸시 파서를 구현합니다. DOM 또는 SimpleXML보다 메모리 관리에 더 나은 선택이지만 XMLReader로 구현 된 풀 파서보다 작업하기가 더 어려울 것입니다.</target>
        </trans-unit>
        <trans-unit id="b67498f486aaa11938e3847d09f2dce44e5beb65" translate="yes" xml:space="preserve">
          <source>The XMLReader extension is an XML pull parser. The reader acts as a cursor going forward on the document stream and stopping at each node on the way.</source>
          <target state="translated">XMLReader 확장은 XML 풀 파서입니다. 판독기는 문서 스트림에서 진행하면서 각 노드에서 멈추는 커서 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="daf8ea6c752ba027315c1f91a513e28bb38ce9f6" translate="yes" xml:space="preserve">
          <source>The benefit of building upon DOM/libxml is that you get good performance out of the box because you are based on a native extension. However, not all 3rd-party libs go down this route. Some of them listed below</source>
          <target state="translated">DOM / libxml을 기반으로하는 이점은 기본 확장을 기반으로하기 때문에 성능이 우수하다는 것입니다. 그러나 모든 타사 라이브러리가이 경로를 따르는 것은 아닙니다. 그들 중 일부는 아래에 나열되어 있습니다</target>
        </trans-unit>
        <trans-unit id="d8816c1d03b50b77e6e6ff51bd569066e7b5a0e5" translate="yes" xml:space="preserve">
          <source>The best method for parse xml:</source>
          <target state="translated">XML을 구문 분석하는 가장 좋은 방법 :</target>
        </trans-unit>
        <trans-unit id="4132078238d9256b003dd6494bd23513c071a209" translate="yes" xml:space="preserve">
          <source>The code below comes straight out my &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;DOM-Query library&lt;/a&gt; and uses the technique I described.</source>
          <target state="translated">아래 코드는 &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;DOM-Query 라이브러리&lt;/a&gt; 에서 바로 나오며 내가 설명한 기술을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="11b52d17561803fdb6224e1ca70f26a54f943a6b" translate="yes" xml:space="preserve">
          <source>The component is designed to work standalone and can be used without Symfony.</source>
          <target state="translated">이 구성 요소는 독립형으로 작동하도록 설계되었으며 Symfony없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df302445bc11b04611b1cf770aa3b7c0254ec538" translate="yes" xml:space="preserve">
          <source>The only drawback is that it will only work with PHP 5.3 or newer.</source>
          <target state="translated">유일한 단점은 PHP 5.3 이상에서만 작동한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="58431aa1e93eb44c019b1578434838cf2038f96d" translate="yes" xml:space="preserve">
          <source>The resulting object contains a complete tree representation of the HTML document. It can be traversed using DOM methods. But the common approach is to use CSS selectors like in jQuery:</source>
          <target state="translated">결과 객체에는 HTML 문서의 완전한 트리 표현이 포함됩니다. DOM 메소드를 사용하여 순회 할 수 있습니다. 그러나 일반적인 접근 방식은 jQuery와 같은 CSS 선택기를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f669955759ac8d7fc7074861be693d4a0720bae0" translate="yes" xml:space="preserve">
          <source>There are however specific use cases where they can help.</source>
          <target state="translated">그러나 도움이 될 수있는 구체적인 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba5cb182872adb3d586144d6a301c22c0f539179" translate="yes" xml:space="preserve">
          <source>There are many ways to process HTML/XML DOM of which most have already been mentioned. Hence, I won't make any attempt to list those myself.</source>
          <target state="translated">가장 많이 언급 된 HTML / XML DOM을 처리하는 방법에는 여러 가지가 있습니다. 따라서 나는 그것들을 직접 나열하려고 시도하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7fc01c223fb450ac4e6ebdc77a0edd1badd8832f" translate="yes" xml:space="preserve">
          <source>There are several reasons to not parse HTML by regular expression. But, if you have total control of what HTML will be generated, then you can do with simple regular expression.</source>
          <target state="translated">정규식으로 HTML을 구문 분석하지 않는 몇 가지 이유가 있습니다. 그러나 생성 할 HTML을 완전히 제어 할 수 있으면 간단한 정규식으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9a9ec64bafcc374d9945fc4204431933239630f" translate="yes" xml:space="preserve">
          <source>Third party alternatives to SimpleHtmlDom that use DOM instead of String Parsing: &lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt;, &lt;a href=&quot;http://framework.zend.com/manual/en/zend.dom.html&quot;&gt;Zend_Dom&lt;/a&gt;, &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; and &lt;a href=&quot;http://www.fluentdom.org/&quot;&gt;FluentDom&lt;/a&gt;.</source>
          <target state="translated">String Parsing 대신 DOM을 사용하는 SimpleHtmlDom에 대한 타사 대안 : &lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; , &lt;a href=&quot;http://framework.zend.com/manual/en/zend.dom.html&quot;&gt;Zend_Dom&lt;/a&gt; , &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; 및 &lt;a href=&quot;http://www.fluentdom.org/&quot;&gt;FluentDom&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7416ebc9af5006b615b7faa1baa92773cc5eea4a" translate="yes" xml:space="preserve">
          <source>This extension lets you create XML parsers and then define handlers for different XML events. Each XML parser also has a few parameters you can adjust.</source>
          <target state="translated">이 확장을 사용하면 XML 파서를 작성하고 다른 XML 이벤트에 대한 핸들러를 정의 할 수 있습니다. 각 XML 파서에는 조정할 수있는 몇 가지 매개 변수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68b5d2b56e9a5e9c0691dcd4f8be37ab0fb44989" translate="yes" xml:space="preserve">
          <source>This is commonly referred to as &lt;strong&gt;screen scraping&lt;/strong&gt;, by the way. The library I have used for this is &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;Simple HTML Dom Parser&lt;/a&gt;.</source>
          <target state="translated">그런데 이것을 일반적으로 &lt;strong&gt;화면 스크래핑&lt;/strong&gt; 이라고합니다. 내가 사용한 라이브러리는 &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;Simple HTML Dom Parser&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e850b37f770cfea1cd7f56ea9dfb592e682e301e" translate="yes" xml:space="preserve">
          <source>This library usually taking less than 1 second to process offline html.</source>
          <target state="translated">이 라이브러리는 일반적으로 오프라인 html을 처리하는 데 1 초 미만이 소요됩니다.</target>
        </trans-unit>
        <trans-unit id="2beda6ba9b12df24bc719d6612622cddbc5e8c27" translate="yes" xml:space="preserve">
          <source>This sounds like a good task description of W3C &lt;a href=&quot;http://www.w3.org/TR/xpath/&quot;&gt;XPath&lt;/a&gt; technology. It's easy to express queries like &quot;return all &lt;code&gt;href&lt;/code&gt; attributes in &lt;code&gt;img&lt;/code&gt; tags that are nested in &lt;code&gt;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;&amp;lt;baz&amp;gt; elements&lt;/code&gt;.&quot; Not being a PHP buff, I can't tell you in what form XPath may be available. If you can call an external program to process the HTML file you should be able to use a command line version of XPath.
For a quick intro, see &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;http://en.wikipedia.org/wiki/XPath&lt;/a&gt;.</source>
          <target state="translated">이것은 W3C &lt;a href=&quot;http://www.w3.org/TR/xpath/&quot;&gt;XPath&lt;/a&gt; 기술에 대한 좋은 작업 설명처럼 들립니다. &quot; &lt;code&gt;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;&amp;lt;baz&amp;gt; elements&lt;/code&gt; 중첩 된 &lt;code&gt;img&lt;/code&gt; 태그의 모든 &lt;code&gt;href&lt;/code&gt; 속성 반환&quot;과 같은 쿼리를 쉽게 표현할 수 있습니다 . PHP 버프가 아니기 때문에 XPath를 사용할 수있는 형식을 말할 수 없습니다. HTML 파일을 처리하기 위해 외부 프로그램을 호출 할 수 있으면 XPath의 명령 행 버전을 사용할 수 있어야합니다. 빠른 소개는 &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;http://en.wikipedia.org/wiki/XPath를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a0b9134ff92db59b43251ec557fed51162b65e3" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;&lt;strong&gt;Simple HTML DOM Parser&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;&lt;strong&gt;간단한 HTML DOM 파서&lt;/strong&gt;&lt;/a&gt; 사용해보기</target>
        </trans-unit>
        <trans-unit id="c6d262a8d4b5d18d3efdc5b548b97d2ba672dfe1" translate="yes" xml:space="preserve">
          <source>Under the hood, it uses &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;&lt;strong&gt;symfony/DomCrawler&lt;/strong&gt;&lt;/a&gt; for conversion of CSS selectors to &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; selectors. It always uses the same DomDocument, even when passing one object to another, to ensure decent performance.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;&lt;strong&gt;기본적&lt;/strong&gt;&lt;/a&gt; 으로 CSS 선택기를 &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; 선택기로 변환하기 위해 &lt;strong&gt;symfony / DomCrawler&lt;/strong&gt; 를 사용합니다. 적절한 성능을 보장하기 위해 한 객체를 다른 객체로 전달할 때에도 항상 동일한 DomDocument를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ec1764919721d724665325102a7111340d413d7f" translate="yes" xml:space="preserve">
          <source>Wa72\HtmlPageDom` is a PHP library for easy manipulation of HTML
  documents using  It requires &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;DomCrawler from Symfony2
  components&lt;/a&gt; for traversing  the
  DOM tree and extends it by adding methods for manipulating the DOM
  tree of HTML documents.</source>
          <target state="translated">Wa72 \ HtmlPageDom`은 HTML 문서를 사용하여 쉽게 조작 할 수있는 PHP 라이브러리입니다. DOM 트리를 순회하려면 &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;Symfony2 구성 요소의 DomCrawler가&lt;/a&gt; 필요하며 HTML 문서의 DOM 트리를 조작하는 메소드를 추가하여이를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="2228452e56018a71b37010bd7c5f71859651feca" translate="yes" xml:space="preserve">
          <source>We have created quite a few crawlers for our needs before. At the end of the day, it is usually simple regular expressions that do the thing best. While libraries listed above are good for the reason they are created, if you know what you are looking for, regular expressions is a safer way to go, as you can handle also non-valid &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/XHTML&quot;&gt;XHTML&lt;/a&gt; structures, which would fail, if loaded via most of the parsers.</source>
          <target state="translated">우리는 이전에 우리의 요구에 맞는 크롤러를 많이 만들었습니다. 하루가 끝나면 일반적으로 가장 잘하는 간단한 정규 표현식입니다. 위에 나열된 라이브러리는 생성 된 이유 때문에 좋지만 찾고있는 것을 아는 경우 정규식은 더 안전한 방법입니다.로드되지 않으면 유효하지 않은 &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/XHTML&quot;&gt;XHTML&lt;/a&gt; 구조도 처리 할 수 ​​있습니다. 대부분의 파서를 통해.</target>
        </trans-unit>
        <trans-unit id="25f4d5095cb62b0b7e74915ac9d048a7b58ef20f" translate="yes" xml:space="preserve">
          <source>We might see more dedicated parsers once HTML5 is finalized. There is also a blogpost by the W3's titled &lt;a href=&quot;http://www.w3.org/QA/2008/07/html5-parsing-howto.html&quot;&gt;How-To for html 5 parsing&lt;/a&gt; that is worth checking out.</source>
          <target state="translated">HTML5가 완성되면 더 많은 전용 파서를 볼 수 있습니다. W3의 &lt;a href=&quot;http://www.w3.org/QA/2008/07/html5-parsing-howto.html&quot;&gt;How to To html 5 파싱에 대한&lt;/a&gt; 블로그 게시물도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a5d87433685e87a09cab5597b4bcd5803d667c8" translate="yes" xml:space="preserve">
          <source>WebServices</source>
          <target state="translated">WebServices</target>
        </trans-unit>
        <trans-unit id="dd7868492d1aa630c2532fbee868064147abaa60" translate="yes" xml:space="preserve">
          <source>What it means is that each call on the result set modifies the result set in the object, it's not chainable like in jquery where each link is a new set, you have a single set which is the results from your query and each function call modifies that single set.</source>
          <target state="translated">의미하는 것은 결과 세트의 각 호출이 객체의 결과 세트를 수정한다는 것입니다. 각 링크가 새로운 세트 인 jquery와 같이 체인화 할 수 없으며 쿼리의 결과 인 단일 세트가 있으며 각 함수 호출은 수정합니다 그 단일 세트.</target>
        </trans-unit>
        <trans-unit id="958c244d037d86b5bf0abe6245945f8778d00d85" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/servo-php/fluidxml&quot;&gt;&lt;strong&gt;FluidXML&lt;/strong&gt;&lt;/a&gt; you can query and iterate XML using &lt;strong&gt;XPath&lt;/strong&gt; and &lt;strong&gt;CSS Selectors&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/servo-php/fluidxml&quot;&gt;&lt;strong&gt;FluidXML&lt;/strong&gt;&lt;/a&gt; 을 사용하면 &lt;strong&gt;XPath&lt;/strong&gt; 및 &lt;strong&gt;CSS 선택기를&lt;/strong&gt; 사용하여 XML을 쿼리하고 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c133d37ec5b2dec248bc847284b37225a00466bc" translate="yes" xml:space="preserve">
          <source>XML Parser</source>
          <target state="translated">XML 파서</target>
        </trans-unit>
        <trans-unit id="482bdc24f6af5a40a01e6c07554b2e716ffcfd71" translate="yes" xml:space="preserve">
          <source>XMLReader</source>
          <target state="translated">XMLReader</target>
        </trans-unit>
        <trans-unit id="d283a97f786ccb4fc2cde7e0509f6b68fe20c76f" translate="yes" xml:space="preserve">
          <source>XMLReader, like DOM, is based on libxml. I am not aware of how to trigger the HTML Parser Module, so chances are using XMLReader for parsing broken HTML might be less robust than using DOM where you can explicitly tell it to use libxml's HTML Parser Module.</source>
          <target state="translated">DOM과 같은 XMLReader는 libxml을 기반으로합니다. HTML 파서 모듈을 트리거하는 방법을 알지 못하므로 깨진 XML을 구문 분석하기 위해 XMLReader를 사용할 가능성은 libxml의 HTML 파서 모듈을 사용하도록 명시 적으로 말할 수있는 DOM을 사용하는 것보다 덜 강력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48086d5b2c71a8118002a1eccf45fa90563bef6e" translate="yes" xml:space="preserve">
          <source>Yes you can use simple_html_dom for the purpose. However I have worked quite a lot with the simple_html_dom, particularly for web scrapping and have found it to be too vulnerable. It does the basic job but I won't recommend it anyways.</source>
          <target state="translated">예, 목적에 simple_html_dom을 사용할 수 있습니다. 그러나 나는 특히 web scrapping을 위해 simple_html_dom으로 많은 일을 해왔으며 너무 취약한 것으로 나타났습니다. 기본 작업을 수행하지만 어쨌든 권장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="afacf39f9314512f8b2e4807339393ca1d74c5e5" translate="yes" xml:space="preserve">
          <source>You &lt;a href=&quot;https://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234491#4234491&quot;&gt;can write more reliable parsers&lt;/a&gt;, but writing a &lt;em&gt;complete and reliable&lt;/em&gt; custom parser with regular expressions is a waste of time when the aforementioned libraries already exist and do a much better job on this.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234491#4234491&quot;&gt;보다 안정적인 구문 분석기를 작성할 수&lt;/a&gt; 있지만, 정규식으로 &lt;em&gt;완전하고 안정적인&lt;/em&gt; 사용자 정의 구문 분석기를 작성하면 위에서 언급 한 라이브러리가 이미 존재하고 이에 대해 훨씬 더 나은 작업을 수행하는 데 시간이 낭비됩니다.</target>
        </trans-unit>
        <trans-unit id="52244ade1e08c2102f754703196f53beec240409" translate="yes" xml:space="preserve">
          <source>You can then use this (still very low level) subclass as a foundation for more high level classes, intended to eg. parse very specific types of XML or add more jQuery-like behavior.</source>
          <target state="translated">그런 다음이 하위 클래스를 여전히 높은 수준의 클래스를위한 기초로 사용할 수 있습니다. 매우 특정한 유형의 XML을 구문 분석하거나 더 많은 jQuery와 유사한 동작을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="57d9a847a211899bc4cd6fd3518ea2a538f3dd72" translate="yes" xml:space="preserve">
          <source>You can use the above for parsing HTML5, but &lt;a href=&quot;https://stackoverflow.com/questions/4029341/dom-parser-that-allows-html5-style-in-script-tag/4029412&quot;&gt;there can be quirks&lt;/a&gt; due to the markup HTML5 allows. So for HTML5 you want to consider using a dedicated parser, like</source>
          <target state="translated">위의 HTML5 구문 분석에 사용할 수 있지만 HTML5에서 허용하는 마크 업으로 인해 문제가 &lt;a href=&quot;https://stackoverflow.com/questions/4029341/dom-parser-that-allows-html5-style-in-script-tag/4029412&quot;&gt;발생할 수 있습니다&lt;/a&gt; . HTML5의 경우 다음과 같은 전용 파서를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="118bdac2fe1f904ec22de8b22eed3538f08f7e63" translate="yes" xml:space="preserve">
          <source>You could try using something like &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML_Tidy&quot;&gt;HTML Tidy&lt;/a&gt; to cleanup any &quot;broken&quot; HTML and convert the HTML to XHTML, which you can then parse with a XML parser.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML_Tidy&quot;&gt;HTML Tidy&lt;/a&gt; 와 같은 것을 사용하여 &quot;깨진&quot;HTML을 정리하고 HTML을 XHTML로 변환 한 다음 XML 파서로 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa5f4b4b6cf574e2ed46980afeaa2a7beb181c3f" translate="yes" xml:space="preserve">
          <source>Zend_Dom</source>
          <target state="translated">Zend_Dom</target>
        </trans-unit>
        <trans-unit id="541d5b4dd20a949161f06bff576afd115dc27318" translate="yes" xml:space="preserve">
          <source>Zend_Dom provides tools for working with DOM documents and structures. Currently, we offer Zend_Dom_Query, which provides a unified interface for querying DOM documents utilizing both XPath and CSS selectors.</source>
          <target state="translated">Zend_Dom은 DOM 문서 및 구조 작업을위한 도구를 제공합니다. 현재 XPath와 CSS 선택기를 사용하여 DOM 문서를 쿼리하기위한 통합 인터페이스를 제공하는 Zend_Dom_Query를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0ec25b22947ac4e042b417da8d2b81bad44eaff3" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/add/&quot;&gt;$selection.add&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/add/&quot;&gt;$ selection.add&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d3ac6816be3e31697646b0d3f24a61ed10c7a2" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/addClass/&quot;&gt;$selection.addClass&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/addClass/&quot;&gt;$ selection.addClass&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a85d853e8ac9999031be082f20dd3c86b3e07d55" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/after/&quot;&gt;$selection.after&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/after/&quot;&gt;$ selection.after&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="855bb5684e5aaad04444a0bcf366e950952780f8" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/append/&quot;&gt;$selection.append&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/append/&quot;&gt;$ selection.append&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="303d76dbb2b71969494a3da3fd0e207352f68b81" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/attr/&quot;&gt;$selection.attr&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/attr/&quot;&gt;$ selection.attr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35be35f74fc5b6a7ede46666a50b8672913da309" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/before/&quot;&gt;$selection.before&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/before/&quot;&gt;$ selection. 전에&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1879364aaded1afd20c32ebf100fc3585e48f683" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/children/&quot;&gt;$selection.children&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/children/&quot;&gt;$ selection.children&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="678fdf480ddbd2317286e0512d39327d7446bd7b" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/closest/&quot;&gt;$selection.closest&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/closest/&quot;&gt;$ selection.closest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50da6b564af1bc96331746a72991ea045fba2992" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/contents/&quot;&gt;$selection.contents&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/contents/&quot;&gt;$ selection.contents&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52a5716ac9072af064bad7b789daadb3ef628871" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/detach/&quot;&gt;$selection.detach&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/detach/&quot;&gt;$ selection.detach&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cdeed87a0e184eeda42371e499aff6dcc08e7466" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;$selection.each&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;$ selection.each&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d78f7b714bd611131f42b9656016a521c9ee3ea3" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/empty/&quot;&gt;$selection.empty&lt;/a&gt;&lt;em&gt;(2)&lt;/em&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/empty/&quot;&gt;$ selection.empty&lt;/a&gt; &lt;em&gt;(2)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6e8102a4ebff43aa49148fd4ea1b33c02b29fd5" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/eq/&quot;&gt;$selection.eq&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/eq/&quot;&gt;$ selection.eq&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d9ee2a185ce5f56cead560d1e6223a586084cbf" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/find/&quot;&gt;$selection.find&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/find/&quot;&gt;$ selection.find&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2330f331cc5d6a73493ca3314bfdd95b0fba20e9" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/first/&quot;&gt;$selection.first&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/first/&quot;&gt;$ selection.first&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f200b75980c567c5eaef7a8096eb29ee1699ca1c" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/get/&quot;&gt;$selection.get&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/get/&quot;&gt;$ selection.get&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e76d7cf162ad4950910f97fd211357a71685955e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/insertAfter/&quot;&gt;$selection.insertAfter&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/insertAfter/&quot;&gt;$ selection.insertAfter&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b10ab7d52167901e6f202a90c53135afbe343fab" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/insertBefore/&quot;&gt;$selection.insertBefore&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/insertBefore/&quot;&gt;$ selection.insertBefore&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1116fb1f0e86324bbe307d7cfb7990cb591719e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseHTML/&quot;&gt;$.parseHTML&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseHTML/&quot;&gt;$ .parseHTML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b85b8caed5cad3a75963f879bd83444840e9fac4" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseJSON/&quot;&gt;$.parseJSON&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseJSON/&quot;&gt;$ .parseJSON&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24e21007f15fffbeb12d715b440d8dda82b0fd3e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseXML/&quot;&gt;$.parseXML&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseXML/&quot;&gt;$ .parseXML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8284a57c23d4c2602d747df3906e7d105a7ebc79" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;$&lt;/a&gt;&lt;em&gt;(1)&lt;/em&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;$&lt;/a&gt; &lt;em&gt;(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41f3041007fb1f1714223d7eb80831018345e0b8" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/last/&quot;&gt;$selection.last&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/last/&quot;&gt;$ selection.last&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b7c6e57b4bf72db36e41ed0f4996a878c5bfc40" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/parent/&quot;&gt;$selection.parent&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/parent/&quot;&gt;$ selection.parent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2966dfa24290fb0d5d1b2426cc2f1fd71d622a62" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/parents/&quot;&gt;$selection.parents&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/parents/&quot;&gt;$ selection.parents&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5e7046e307699d26a7d587af4df3b58264248b0" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/remove/&quot;&gt;$selection.remove&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/remove/&quot;&gt;$ selection.remove&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4558dad027c6574ab3dcfb49125d9a104ae9c7ed" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/removeAttr/&quot;&gt;$selection.removeAttr&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/removeAttr/&quot;&gt;$ selection.removeAttr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78105ee237b89523c07bd548a8d57ebac51c396d" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/removeClass/&quot;&gt;$selection.removeClass&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/removeClass/&quot;&gt;$ selection.removeClass&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8224fc75de7d512420526ac5229a3127fa84011d" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/text/&quot;&gt;$selection.text&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/text/&quot;&gt;$ selection.text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6bf903823bfa2ea35e684feeeee397f598eb071c" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/wrap/&quot;&gt;$selection.wrap&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/wrap/&quot;&gt;$ selection.wrap&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ece6afcddc52bae163f5f7ba435c9607ff7a44b9" translate="yes" xml:space="preserve">
          <source>fDOMDocument</source>
          <target state="translated">fDOMDocument</target>
        </trans-unit>
        <trans-unit id="fe8b7d5279a6e14f60beb4f954ad1e8d77ed6d3a" translate="yes" xml:space="preserve">
          <source>fDOMDocument extends the standard DOM to use exceptions at all occasions of errors instead of PHP warnings or notices. They also add various custom methods and shortcuts for convenience and to simplify the usage of DOM.</source>
          <target state="translated">fDOMDocument는 표준 DOM을 확장하여 PHP 경고 또는 알림 대신 오류가 발생할 때마다 예외를 사용합니다. 또한 편의성을 높이고 DOM 사용을 단순화하기 위해 다양한 사용자 정의 방법과 바로 가기를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6183fbc196e925ae7677bf0da88d2d39315c592e" translate="yes" xml:space="preserve">
          <source>html5lib</source>
          <target state="translated">html5lib</target>
        </trans-unit>
        <trans-unit id="e4a3835ab80fda4ba43679f366d992ba21d09b91" translate="yes" xml:space="preserve">
          <source>iit makes optimal use of the performance advantage of the underlying C code</source>
          <target state="translated">iit은 기본 C 코드의 성능 이점을 최적으로 활용합니다.</target>
        </trans-unit>
        <trans-unit id="c52c0b0f2b1233115b4ed3459d964df89266f51d" translate="yes" xml:space="preserve">
          <source>in order to get jquery-like behaviour, you need to branch before you do a filter/modify like operation, that means it'll mirror what happens in jquery much more closely.</source>
          <target state="translated">jquery와 같은 동작을 얻으려면 필터 / 수정 같은 작업을 수행하기 전에 분기해야합니다. 즉, jquery에서 발생하는 일을 훨씬 더 가깝게 반영합니다.</target>
        </trans-unit>
        <trans-unit id="16a2198898695f10acf40db122134ecdb1b43a35" translate="yes" xml:space="preserve">
          <source>is way less readable than a simple phpQuery or QueryPath equivalent:</source>
          <target state="translated">간단한 phpQuery 또는 QueryPath에 비해 읽기가 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e8a470cab2da73401e5efabc30513d95e8be9b3" translate="yes" xml:space="preserve">
          <source>it has a syntax used for DOM crawling that's similar to the syntax used in native Javascript.</source>
          <target state="translated">DOM 크롤링에 사용되는 구문이 있으며 이는 기본 Javascript에 사용 된 구문과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="2acd5a91faeb1fb9c21d40b879ce82bbbcf96f98" translate="yes" xml:space="preserve">
          <source>it provides access to every part of the DOM (unlike eg. SimpleXml, which ignores some of the lesser known XML features)</source>
          <target state="translated">알려진 XML 기능 중 일부를 무시하는 SimpleXml과 달리 DOM의 모든 부분에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6478e095583c0555f703929b4a75f5be57f03aff" translate="yes" xml:space="preserve">
          <source>it's OO PHP (and allows me to subclass it)</source>
          <target state="translated">그것은 OO PHP입니다 (그리고 서브 클래스 화 할 수있게 해줍니다)</target>
        </trans-unit>
        <trans-unit id="da4c11ceac906e374f2b1270f8aba16b0ded1ef2" translate="yes" xml:space="preserve">
          <source>it's rather low level (which allows me to use it as a non-bloated foundation for more advanced behavior)</source>
          <target state="translated">그것은 다소 낮은 수준입니다 (더 높은 수준의 행동을위한 비 팽창 기반으로 사용할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="f8fb16080572c5a5248ed720d5de1897d3eccaa6" translate="yes" xml:space="preserve">
          <source>phpQuery is a server-side, chainable, CSS3 selector driven Document Object Model (DOM) API based on jQuery JavaScript Library written in PHP5 and provides additional Command Line Interface (CLI).</source>
          <target state="translated">phpQuery는 PHP5로 작성된 jQuery JavaScript 라이브러리를 기반으로하는 서버 측 체인 가능 CSS3 선택기 기반 DOM (Document Object Model) API이며 추가 CLI (Command Line Interface)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="14704b5b32c155a763a90cd2bf348e51d8711978" translate="yes" xml:space="preserve">
          <source>sabre/xml</source>
          <target state="translated">sabre/xml</target>
        </trans-unit>
        <trans-unit id="1fa25a1b1b0a0b78c16fd03b682f35fe48665c99" translate="yes" xml:space="preserve">
          <source>sabre/xml is a library that wraps and extends the XMLReader and XMLWriter classes to create a simple &quot;xml to object/array&quot; mapping system and design pattern. Writing and reading XML is single-pass and can therefore be fast and require low memory on large xml files.</source>
          <target state="translated">sabre / xml은 XMLReader 및 XMLWriter 클래스를 래핑하고 확장하여 간단한 &quot;xml to object / array&quot;매핑 시스템 및 디자인 패턴을 만드는 라이브러리입니다. XML 쓰기 및 읽기는 단일 패스이므로 빠를 수 있으며 대용량 XML 파일에서 메모리가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="2726678412f8c2f63bf25a0b979427e67317dca3" translate="yes" xml:space="preserve">
          <source>simplehtmldom.sourceforge</source>
          <target state="translated">simplehtmldom.sourceforge</target>
        </trans-unit>
        <trans-unit id="3d3fda78504589a52345e3396c32f830cf7698e2" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$results&lt;/code&gt; won't be modified and you can reuse the result set again and again, perhaps somebody with much more knowledge can clear this up a bit, but it's basically like this from what I've found.</source>
          <target state="translated">그러면 &lt;code&gt;$results&lt;/code&gt; 가 수정되지 않고 결과 세트를 반복해서 재사용 할 수 있습니다. 아마도 더 많은 지식을 가진 사람이 이것을 약간 정리할 수 있지만 기본적으로 내가 찾은 것에서 이와 같습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
