<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3577641">
    <body>
      <group id="3577641">
        <trans-unit id="bd1c16acfa3e04178a7c75f46da4c487e96db82d" translate="yes" xml:space="preserve">
          <source>3rd Party Libraries (libxml based)</source>
          <target state="translated">第三方库(基于libxml)</target>
        </trans-unit>
        <trans-unit id="3f03912557d9e8cb0d58bb70f44693ee64e86830" translate="yes" xml:space="preserve">
          <source>3rd-Party (not libxml-based)</source>
          <target state="translated">第三方(不是基于libxml的)。</target>
        </trans-unit>
        <trans-unit id="544f420802f1b7f4381cde62a46a89f0fdd4320a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; (not updated for years)</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; （多年未更新）</target>
        </trans-unit>
        <trans-unit id="a79bf2782f9fde4ac3500bc5190a56bc3cb61962" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; and &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; are extremely similar in replicating the fluent jQuery API. That's also why they're two of the easiest approaches to &lt;em&gt;properly&lt;/em&gt; parse HTML in PHP.</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt;和&lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;在复制流畅的jQuery API方面极为相似。 这就是为什么它们是在PHP中&lt;em&gt;正确&lt;/em&gt;解析HTML的两种最简单方法。</target>
        </trans-unit>
        <trans-unit id="0fdffada957220d6a8a6ae26cb48926b77945a9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pear.php.net/package/XML_HTMLSax&quot;&gt;&lt;code&gt;XML_HTMLSax&lt;/code&gt;&lt;/a&gt; is rather stable - even if it's not maintained any more. Another option could be to pipe you HTML through &lt;a href=&quot;http://docs.php.net/manual/en/book.tidy.php&quot;&gt;Html Tidy&lt;/a&gt; and then parse it with standard XML tools.</source>
          <target state="translated">&lt;a href=&quot;http://pear.php.net/package/XML_HTMLSax&quot;&gt; &lt;code&gt;XML_HTMLSax&lt;/code&gt; &lt;/a&gt;相当稳定-即使不再维护。 另一个选择是通过&lt;a href=&quot;http://docs.php.net/manual/en/book.tidy.php&quot;&gt;HTML Tidy&lt;/a&gt;通过HTML传递HTML ，然后使用标准XML工具对其进行解析。</target>
        </trans-unit>
        <trans-unit id="d60f1b3d0678fe59836a8b6de9a8e467b681d2ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://scraperwiki.com/api/1.0&quot;&gt;ScraperWiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://scraperwiki.com/api/1.0&quot;&gt;ScraperWiki&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b7bf893d7fcdef1f2129df3b54a4823ab40bf3b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/monkeysuffrage/advanced_html_dom&quot;&gt;Advanced Html Dom&lt;/a&gt; is a simple HTML &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; replacement that offers the same interface, but it's DOM-based which means none of the associated memory issues occur.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/monkeysuffrage/advanced_html_dom&quot;&gt;Advanced Html Dom&lt;/a&gt;是提供相同接口的简单HTML &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;替换，但是它基于DOM，这意味着不会发生任何相关的内存问题。</target>
        </trans-unit>
        <trans-unit id="63814451d23d80a4e01cf7d057d50122fed02b7f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/search?q=DOM+HTML+[PHP]&amp;amp;submit=search&quot;&gt;How to use the DOM extension has been covered extensively on StackOverflow&lt;/a&gt;, so if you choose to use it, you can be sure most of the issues you run into can be solved by searching/browsing Stack Overflow.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/search?q=DOM+HTML+[PHP]&amp;amp;submit=search&quot;&gt;如何使用DOM扩展已在StackOverflow上进行了广泛介绍&lt;/a&gt; ，因此，如果您选择使用它，则可以确保可以通过搜索/浏览Stack Overflow来解决大部分遇到的问题。</target>
        </trans-unit>
        <trans-unit id="1e8d52f8b266675024c8a2025e5d5aff62075d2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://thomas.weinert.info/FluentDOM/&quot;&gt;FluentDom&lt;/a&gt; - &lt;a href=&quot;https://github.com/ThomasWeinert/FluentDOM&quot;&gt;Repo&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://thomas.weinert.info/FluentDOM/&quot;&gt;FluentDom-&lt;/a&gt; &lt;a href=&quot;https://github.com/ThomasWeinert/FluentDOM&quot;&gt;回购&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b87824cf6357505f2dd7bdd0cb025c91c9845e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$results&lt;/code&gt; now contains the result set for &lt;code&gt;input[name='forename']&lt;/code&gt; NOT the original query &lt;code&gt;&quot;div p&quot;&lt;/code&gt; this tripped me up a lot, what I found was that &lt;em&gt;QueryPath&lt;/em&gt; tracks the filters and finds and everything which modifies your results and stores them in the object.  you need to do this instead</source>
          <target state="translated">&lt;code&gt;$results&lt;/code&gt; 现在包含 &lt;code&gt;input[name='forename']&lt;/code&gt; 的结果集，而不是原来的查询 &lt;code&gt;&quot;div p&quot;&lt;/code&gt; 这让我&lt;em&gt;大跌眼镜&lt;/em&gt; ，我发现&lt;em&gt;QueryPath&lt;/em&gt;跟踪过滤器和查找内容以及修改您的结果和存储的所有内容他们在对象中。 您需要这样做</target>
        </trans-unit>
        <trans-unit id="5a16f3b4ff2ed4ef8a15b2a2e40067147b5befb0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;QueryPath&lt;/em&gt; is good, but be careful of &quot;tracking state&quot; cause if you didn't realise what it means, it can mean you waste a lot of debugging time trying to find out what happened and why the code doesn't work.</source>
          <target state="translated">&lt;em&gt;QueryPath&lt;/em&gt;很好，但是要小心&amp;ldquo;跟踪状态&amp;rdquo;，因为如果您没有意识到这意味着什么，那可能意味着您浪费了大量的调试时间来试图找出发生了什么以及代码为什么不起作用。</target>
        </trans-unit>
        <trans-unit id="d9c38fd9cac3bee2d6ed70531b6fb14f6245a91e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Renamed 'select', for obvious reasons&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;由于明显的原因，将其重命名为&amp;ldquo;选择&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1759c585e41793ef285aed2e9382f1df5f3a5512" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Renamed 'void', since 'empty' is a reserved word in PHP&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;重命名为&amp;ldquo; void&amp;rdquo;，因为&amp;ldquo; empty&amp;rdquo;是PHP中的保留字&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="749383e2d1cd518a40c891b7239af37b051d6989" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The library also includes its own zero-configuration autoloader for PSR-0 compatible libraries. The example included should work out of the box without any additional configuration. Alternatively, you can use it with composer.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;该库还包括其自己的用于PSR-0兼容库的零配置自动加载器。&lt;/em&gt; &lt;em&gt;所包含的示例无需任何其他配置即可直接使用。&lt;/em&gt; &lt;em&gt;或者，您可以将其与作曲家一起使用。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="427d269cef16d7dd435f53adf9f53c88581fff03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40560fc8e231140d461163449e51ae367fdeafa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples for QueryPath&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;QueryPath的示例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e306e3e190d2a70f49058d00b1b093fcf6837564" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I actually have this &lt;a href=&quot;http://fossil.include-once.org/streamtuner2/&quot;&gt;app&lt;/a&gt;, where I employ XML parsing and regular expressions alternatively. Just last week the PyQuery parsing broke, and the regex still worked. Yes weird, and I can't explain it myself. But so it happened.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;我实际上有这个&lt;a href=&quot;http://fossil.include-once.org/streamtuner2/&quot;&gt;应用程序&lt;/a&gt; ，在这里我可以选择使用XML解析和正则表达式。 就在上周，PyQuery解析中断，而正则表达式仍然有效。 是的，很奇怪，我自己也无法解释。 但是，它发生了。</target>
        </trans-unit>
        <trans-unit id="6d72dd9553207dcc429f79cdba7b6b07adfa5efb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why you shouldn't and &lt;em&gt;when you should&lt;/em&gt; use regular expressions?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么不应该以及&lt;em&gt;何时&lt;/em&gt;使用正则表达式？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbfce2e86e47fefb989be5da4568b10c8adce6e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phpQuery or QueryPath?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;phpQuery或QueryPath？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cae4698fc621dfc4ebc96ae78db8d2cbd4e5ad8c" translate="yes" xml:space="preserve">
          <source>A HTML DOM parser written in PHP&amp;nbsp;5+ that lets you manipulate HTML in a very easy way!</source>
          <target state="translated">用PHP 5+编写的HTML DOM解析器，可让您以非常简单的方式操作HTML！</target>
        </trans-unit>
        <trans-unit id="f5c7b3438f58d5c6af7e2b7180f26f57170d8651" translate="yes" xml:space="preserve">
          <source>A HTML beautifier (like HTML Tidy)</source>
          <target state="translated">一个HTML美化器(如HTML Tidy)。</target>
        </trans-unit>
        <trans-unit id="664ce6056bbe5b087cfd9fbfb8122d8d3f7e4fd7" translate="yes" xml:space="preserve">
          <source>A Python and PHP implementations of a HTML parser based on the WHATWG HTML5 specification for maximum compatibility with major desktop web browsers.</source>
          <target state="translated">一个基于WHATWG HTML5规范的HTML解析器的Python和PHP实现,最大限度地兼容主流桌面浏览器。</target>
        </trans-unit>
        <trans-unit id="0a002f9eab6a6a440519776a307afcbfdf2d07b8" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found at &lt;a href=&quot;https://stackoverflow.com/questions/3299033/getting-all-values-from-h1-tags-using-php/3299140#3299140&quot;&gt;getting all values from h1 tags using php&lt;/a&gt;</source>
          <target state="translated">一个基本的用法示例可以在&lt;a href=&quot;https://stackoverflow.com/questions/3299033/getting-all-values-from-h1-tags-using-php/3299140#3299140&quot;&gt;使用php从h1标签获取所有值的过程中&lt;/a&gt;找到</target>
        </trans-unit>
        <trans-unit id="c214664208233d4467d45fabbc658dff3316d329" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found at &lt;a href=&quot;https://stackoverflow.com/questions/4906073/a-simple-program-to-crud-node-and-node-values-of-xml-file&quot;&gt;A simple program to CRUD node and node values of xml file&lt;/a&gt; and there is &lt;a href=&quot;http://php.net/manual/en/simplexml.examples-basic.php&quot;&gt;lots of additional examples in the PHP Manual&lt;/a&gt;.</source>
          <target state="translated">一个基本的用法示例可以在&lt;a href=&quot;https://stackoverflow.com/questions/4906073/a-simple-program-to-crud-node-and-node-values-of-xml-file&quot;&gt;到CRUD节点和xml文件的节点值的简单程序中&lt;/a&gt;找到， 并且 &lt;a href=&quot;http://php.net/manual/en/simplexml.examples-basic.php&quot;&gt;PHP手册中&lt;/a&gt;还有很多其他示例 。</target>
        </trans-unit>
        <trans-unit id="d2ec9025c32d35528d4e334718e76dd987674f48" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found in &lt;a href=&quot;https://stackoverflow.com/questions/3820666/regular-expression-for-grabbing-the-href-attribute-of-an-a-element/3820783#3820783&quot;&gt;Grabbing the href attribute of an A element&lt;/a&gt; and a general conceptual overview can be found at &lt;a href=&quot;https://stackoverflow.com/questions/4979836/noob-question-about-domdocument-in-php/4983721#4983721&quot;&gt;DOMDocument in php&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;https://stackoverflow.com/questions/3820666/regular-expression-for-grabbing-the-href-attribute-of-an-a-element/3820783#3820783&quot;&gt;Grabbing A元素的href属性中&lt;/a&gt;可以找到一个基本的用法示例，而&lt;a href=&quot;https://stackoverflow.com/questions/4979836/noob-question-about-domdocument-in-php/4983721#4983721&quot;&gt;在php的DOMDocument中&lt;/a&gt;可以找到基本的概念概述。</target>
        </trans-unit>
        <trans-unit id="dd1ad773e01542b3fdd423200776b4fe37d851f7" translate="yes" xml:space="preserve">
          <source>A universal tokenizer and HTML/XML/RSS DOM Parser</source>
          <target state="translated">一个通用的tokenizer和HTMLXMLRSS DOM解析器</target>
        </trans-unit>
        <trans-unit id="2e22019c08ef666033adfcb2f0c0f12acfb35beb" translate="yes" xml:space="preserve">
          <source>Ability to manipulate elements and their attributes</source>
          <target state="translated">操纵元素及其属性的能力</target>
        </trans-unit>
        <trans-unit id="ef04526591e535436aff90c6654fecadc86c579a" translate="yes" xml:space="preserve">
          <source>Above it's a function that parses HTML by regular expression. Note that this function is very sensitive and demands that the HTML obey certain rules, but it works very well in many scenarios. If you want a simple parser, and don't want to install libraries, give this a shot:</source>
          <target state="translated">上面是一个用正则表达式解析HTML的函数。注意,这个函数非常敏感,要求HTML服从一定的规则,但在很多场景下都很好用。如果你想要一个简单的解析器,又不想安装库,可以试试这个。</target>
        </trans-unit>
        <trans-unit id="b515c9a3b099e8dbc88c77e08620321b4e837112" translate="yes" xml:space="preserve">
          <source>Again, I would not recommend this parser. It is rather slow with high CPU usage. There is also no function to clear memory of created DOM objects. These problems scale particularly with nested loops. The documentation itself is inaccurate and misspelled, with no responses to fixes since 14 Apr 16.</source>
          <target state="translated">再次,我不推荐使用这个解析器。它的速度相当慢,CPU使用率很高。另外,没有清除创建的DOM对象的内存的功能。这些问题在嵌套循环的情况下尤其严重。文档本身不准确,拼写错误,自16年4月14日以来,没有任何回复修复。</target>
        </trans-unit>
        <trans-unit id="1ec510988bdc89bf9bd7b325c2f2553b61212a2b" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt;</source>
          <target state="translated">另请参阅&lt;a href=&quot;http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html&quot;&gt;解析Cthulhu方式的HTML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8cf1b78bb2f209698c6cdb9597abb54e96eafd6" translate="yes" xml:space="preserve">
          <source>Also see: &lt;a href=&quot;https://github.com/electrolinux/phpquery&quot;&gt;https://github.com/electrolinux/phpquery&lt;/a&gt;</source>
          <target state="translated">另请参阅： &lt;a href=&quot;https://github.com/electrolinux/phpquery&quot;&gt;https&lt;/a&gt; : //github.com/electrolinux/phpquery</target>
        </trans-unit>
        <trans-unit id="7d2a161c418bdf05eb381f6d5ea1c2d6456c164f" translate="yes" xml:space="preserve">
          <source>An HTML DOM parser written in PHP5+ lets you manipulate HTML in a very easy way!</source>
          <target state="translated">一个用PHP5+编写的HTML DOM解析器,可以让你以非常简单的方式操作HTML!</target>
        </trans-unit>
        <trans-unit id="144401da89869b09220cb2726f32caf87093fc51" translate="yes" xml:space="preserve">
          <source>And here's &lt;a href=&quot;http://www.ibm.com/developerworks/opensource/library/os-php-querypath/index.html?S_TACT=105AGX01&amp;amp;S_CMP=HP&quot;&gt;a comprehensive QueryPath introduction&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;http://www.ibm.com/developerworks/opensource/library/os-php-querypath/index.html?S_TACT=105AGX01&amp;amp;S_CMP=HP&quot;&gt;QueryPath的全面介绍&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a46b8d7cd67f87500b5d7718588d2c557ece05e9" translate="yes" xml:space="preserve">
          <source>And lastly, for e&lt;em&gt;xtremely simple tasks&lt;/em&gt; like extracting &amp;lt;img src= urls, they are in fact a probable tool. The speed advantage over SGML/XML parsers mostly just comes to play for these very basic extraction procedures.</source>
          <target state="translated">最后，对于诸如提取&amp;lt;img src = url之类的&lt;em&gt;极其简单的任务&lt;/em&gt; ，它们实际上是一种可能的工具。 相对于SGML / XML解析器的速度优势主要体现在这些非常基本的提取过程中。</target>
        </trans-unit>
        <trans-unit id="c2feade56d00684694a9d9e01315c66714df0c54" translate="yes" xml:space="preserve">
          <source>And while I miss the ability to use CSS selectors for &lt;code&gt;DOMDocument&lt;/code&gt;, there is a rather simple and convenient way to add this feature: subclassing the &lt;code&gt;DOMDocument&lt;/code&gt; and adding JS-like &lt;code&gt;querySelectorAll&lt;/code&gt; and &lt;code&gt;querySelector&lt;/code&gt; methods to your subclass.</source>
          <target state="translated">而且，尽管我错过了为 &lt;code&gt;DOMDocument&lt;/code&gt; 使用CSS选择器的功能，但是有一种相当简单方便的方法来添加此功能：子类化 &lt;code&gt;DOMDocument&lt;/code&gt; 并将类JS的 &lt;code&gt;querySelectorAll&lt;/code&gt; 和 &lt;code&gt;querySelector&lt;/code&gt; 方法添加到子类中。</target>
        </trans-unit>
        <trans-unit id="b2352cb26b5e77a9dad0e37a6ac99e7163a1c86d" translate="yes" xml:space="preserve">
          <source>Another option you can try is &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;. It's inspired by jQuery, but on the server in PHP and used in &lt;a href=&quot;http://en.wikipedia.org/wiki/Drupal&quot;&gt;Drupal&lt;/a&gt;.</source>
          <target state="translated">您可以尝试的另一种选择是&lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; 。 它受jQuery的启发，但是在PHP的服务器上，并在&lt;a href=&quot;http://en.wikipedia.org/wiki/Drupal&quot;&gt;Drupal中使用&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="cba81c44dfc3d4be82ed0b3e1b1de3b4a22126bd" translate="yes" xml:space="preserve">
          <source>Basically you first create a queryable DOM tree from an HTML string:</source>
          <target state="translated">基本上你首先从一个HTML字符串中创建一个可查询的DOM树。</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="7aa83623e4641c12a129d48c3ef4ede02906c309" translate="yes" xml:space="preserve">
          <source>But to your specific problem, you should take a look at this project: &lt;a href=&quot;http://fivefilters.org/content-only/&quot;&gt;http://fivefilters.org/content-only/&lt;/a&gt; -- it's a modified version of the &lt;a href=&quot;http://lab.arc90.com/2009/03/02/readability/&quot;&gt;Readability&lt;/a&gt; algorithm, which is designed to extract just the textual content (not headers and footers) from a page.</source>
          <target state="translated">但是对于您的特定问题，您应该看一下以下项目： &lt;a href=&quot;http://fivefilters.org/content-only/&quot;&gt;http&lt;/a&gt; : //fivefilters.org/content-only/-它是&lt;a href=&quot;http://lab.arc90.com/2009/03/02/readability/&quot;&gt;Readability&lt;/a&gt;算法的修改版本，旨在仅提取文本内容（而不是标头）和页脚）。</target>
        </trans-unit>
        <trans-unit id="c34ef7238086ad5070c51839516f68c811e10bf0" translate="yes" xml:space="preserve">
          <source>Can perform advanced CSS3-like queries on elements (like jQuery -- namespaces supported)</source>
          <target state="translated">可以在元素上执行类似CSS3的高级查询(如jQuery----支持命名空间)。</target>
        </trans-unit>
        <trans-unit id="a1a5d5d399ebd0632976f266a1441e08ad47ca06" translate="yes" xml:space="preserve">
          <source>Consider that making a somewhat dependable HTML extraction regex:</source>
          <target state="translated">想想看,做一个有点靠谱的HTML提取regex。</target>
        </trans-unit>
        <trans-unit id="61f6f421ef32670498c220ee8ee339df076a5ad9" translate="yes" xml:space="preserve">
          <source>DOM</source>
          <target state="translated">DOM</target>
        </trans-unit>
        <trans-unit id="55c9f512afeeb3355d19924f291d88cec7fe29e2" translate="yes" xml:space="preserve">
          <source>DOM is capable of parsing and modifying real world (broken) HTML and it can do &lt;a href=&quot;http://schlitt.info/opensource/blog/0704_xpath.html&quot;&gt;XPath queries&lt;/a&gt;. It is based on &lt;a href=&quot;http://xmlsoft.org/html/libxml-HTMLparser.html&quot;&gt;libxml&lt;/a&gt;.</source>
          <target state="translated">DOM能够解析和修改现实世界（损坏的）HTML，并且可以执行&lt;a href=&quot;http://schlitt.info/opensource/blog/0704_xpath.html&quot;&gt;XPath查询&lt;/a&gt; 。 它基于&lt;a href=&quot;http://xmlsoft.org/html/libxml-HTMLparser.html&quot;&gt;libxml&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="28f67bdf45517367ca4d6f904c2f8392f764b158" translate="yes" xml:space="preserve">
          <source>Example use :</source>
          <target state="translated">使用示例。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="12d9de7e25a720caf19e093a74306cc9a4e7c9da" translate="yes" xml:space="preserve">
          <source>Extensible</source>
          <target state="translated">Extensible</target>
        </trans-unit>
        <trans-unit id="52edc154bfd85973b447708309453d1e0d5f9e75" translate="yes" xml:space="preserve">
          <source>Extract content from HTML:</source>
          <target state="translated">从HTML中提取内容。</target>
        </trans-unit>
        <trans-unit id="e4f2ed31239f8d0e814fac030378d9eb490bf0be" translate="yes" xml:space="preserve">
          <source>Extract contents from HTML in a single line.</source>
          <target state="translated">在单行中提取HTML的内容。</target>
        </trans-unit>
        <trans-unit id="2fe336188376aed8e3f768179ec8a4f84d70f80c" translate="yes" xml:space="preserve">
          <source>Fast and Easy</source>
          <target state="translated">快速和简单</target>
        </trans-unit>
        <trans-unit id="a7efc89443fd2e4cbb28e16621f9b53f95fe8423" translate="yes" xml:space="preserve">
          <source>Find tags on an HTML page with selectors just like jQuery.</source>
          <target state="translated">像jQuery一样,在一个HTML页面上用选择器查找标签。</target>
        </trans-unit>
        <trans-unit id="149712bfea49caa6ead7b107cba118d9c4a2fc2c" translate="yes" xml:space="preserve">
          <source>First off, a common misnomer: Regexps are not for &lt;em&gt;&quot;&lt;strong&gt;parsing&lt;/strong&gt;&quot;&lt;/em&gt; HTML. Regexes can however &lt;em&gt;&quot;&lt;strong&gt;extract&lt;/strong&gt;&quot;&lt;/em&gt; data. Extracting is what they're made for. The major drawback of regex HTML extraction over proper SGML toolkits or baseline XML parsers are their syntactic effort and varying reliability.</source>
          <target state="translated">首先，一个常见的误称：Regexps不是用于&lt;em&gt;&amp;ldquo; &lt;strong&gt;解析&lt;/strong&gt; &amp;rdquo;&lt;/em&gt; HTML。 但是，正则表达式可以&lt;em&gt;&amp;ldquo; &lt;strong&gt;提取&lt;/strong&gt; &amp;rdquo;&lt;/em&gt;数据。 提取是他们的目的。 与适当的SGML工具包或基准XML解析器相比，正则表达式HTML提取的主要缺点是其语法工作和可靠性不同。</target>
        </trans-unit>
        <trans-unit id="dfce008c9e988193c2c7cc30fbe30b0aea469a5f" translate="yes" xml:space="preserve">
          <source>FluentDOM provides a jQuery-like fluent XML interface for the DOMDocument in PHP. Selectors are written in XPath or CSS (using a CSS to XPath converter). Current versions extend the DOM implementing standard interfaces and add features from the DOM Living Standard. FluentDOM can load formats like JSON, CSV, JsonML, RabbitFish and others. Can be installed via Composer.</source>
          <target state="translated">FluentDOM为PHP中的DOMDocument提供了一个类似jQuery的流畅XML接口。选择器是用XPath或CSS编写的(使用CSS到XPath转换器)。目前的版本扩展了DOM实现标准接口,并添加了DOM生活标准中的功能。FluentDOM可以加载JSON,CSV,JsonML,RabbitFish等格式。可以通过Composer安装。</target>
        </trans-unit>
        <trans-unit id="11078285da49b0134a3aebf9e6a39b3e548b91e2" translate="yes" xml:space="preserve">
          <source>FluidXML</source>
          <target state="translated">FluidXML</target>
        </trans-unit>
        <trans-unit id="85efe7a663e33eef32d5be3e18debc0c1f84672d" translate="yes" xml:space="preserve">
          <source>FluidXML is a PHP library for manipulating XML with a concise and fluent API.
  It leverages XPath and the fluent programming pattern to be fun and effective.</source>
          <target state="translated">FluidXML是一个用于操作XML的PHP库,具有简洁流畅的API。它利用了XPath和流畅的编程模式来实现有趣而有效的操作。</target>
        </trans-unit>
        <trans-unit id="f3ea98adb29e96c7277c98baf79783ffd4939bc8" translate="yes" xml:space="preserve">
          <source>For 1a and 2: I would vote for the new Symfony Componet class DOMCrawler ( &lt;a href=&quot;http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/&quot;&gt;DomCrawler&lt;/a&gt; ).
This class allows queries similar to CSS Selectors. Take a look at this presentation for real-world examples: &lt;a href=&quot;http://www.slideshare.net/fabpot/news-of-the-symfony2-world&quot;&gt;news-of-the-symfony2-world&lt;/a&gt;.</source>
          <target state="translated">对于1a和2：我将投票支持新的Symfony Componet类DOMCrawler（ &lt;a href=&quot;http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/&quot;&gt;DomCrawler&lt;/a&gt; ）。 此类允许类似于CSS选择器的查询。 看看这个演示文稿，看看其中的真实示例： &lt;a href=&quot;http://www.slideshare.net/fabpot/news-of-the-symfony2-world&quot;&gt;news-of-the-symfony2-world&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="019b00ae67ed9f11eae28c6c16dcb5be88663ba4" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML5&quot;&gt;HTML5&lt;/a&gt;, html5 lib has been abandoned for years now. The only HTML5 library I can find with a recent update and maintenance records is &lt;a href=&quot;https://github.com/Masterminds/html5-php/releases/1.0.0-beta1&quot;&gt;html5-php&lt;/a&gt; which was just brought to beta 1.0 a little over a week ago.</source>
          <target state="translated">对于&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML5&quot;&gt;HTML5&lt;/a&gt; ，html5 lib已经被放弃了很多年。 我可以找到的唯一具有最近更新和维护记录的HTML5库是&lt;a href=&quot;https://github.com/Masterminds/html5-php/releases/1.0.0-beta1&quot;&gt;html5-php&lt;/a&gt; ，它是在一周前才发布到beta 1.0的。</target>
        </trans-unit>
        <trans-unit id="0c7b690295ff028bfb68ffa343e78b4ca38a4e07" translate="yes" xml:space="preserve">
          <source>For HTML parsing :</source>
          <target state="translated">对于HTML的解析。</target>
        </trans-unit>
        <trans-unit id="dc9166e6725c73ab185eec670858a82b9a1165c0" translate="yes" xml:space="preserve">
          <source>For further information on the differences see &lt;a href=&quot;http://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath&quot;&gt;this comparison on the wayback machine from tagbyte.org&lt;/a&gt;. (Original source went missing, so here's an internet archive link. Yes, you can still locate missing pages, people.)</source>
          <target state="translated">有关差异的更多信息，请参见&lt;a href=&quot;http://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath&quot;&gt;tagbyte.org在回溯计算机上进行的比较&lt;/a&gt; 。 （原始资料丢失了，所以这里是一个互联网存档链接。是的，您仍然可以找到丢失的页面，人们。）</target>
        </trans-unit>
        <trans-unit id="22d8d2b2fb6fda43308a6bf614eb0d42bca679b5" translate="yes" xml:space="preserve">
          <source>For parsing the selectors, I recommend using the very minimalistic &lt;a href=&quot;http://symfony.com/doc/current/components/css_selector.html&quot;&gt;CssSelector component&lt;/a&gt; from the &lt;a href=&quot;http://symfony.com/&quot;&gt;Symfony framework&lt;/a&gt;. This component just translates CSS selectors to XPath selectors, which can then be fed into a &lt;code&gt;DOMXpath&lt;/code&gt; to retrieve the corresponding Nodelist.</source>
          <target state="translated">为了解析选择器，我建议使用&lt;a href=&quot;http://symfony.com/&quot;&gt;Symfony框架中&lt;/a&gt;非常简单的&lt;a href=&quot;http://symfony.com/doc/current/components/css_selector.html&quot;&gt;CssSelector组件&lt;/a&gt; 。 该组件仅将CSS选择器转换为XPath选择器，然后可以将其输入到 &lt;code&gt;DOMXpath&lt;/code&gt; 中以检索相应的Nodelist。</target>
        </trans-unit>
        <trans-unit id="dd0d138f0f3d01adb6e9b2bfa7e5e1226d277ea5" translate="yes" xml:space="preserve">
          <source>Ganon</source>
          <target state="translated">Ganon</target>
        </trans-unit>
        <trans-unit id="010d64aa6bcaec1c43df7f15b6e6795eaba5e6de" translate="yes" xml:space="preserve">
          <source>Generally QueryPath is better suited for manipulation of documents. While phpQuery also implements some pseudo AJAX methods (just HTTP requests) to more closely resemble jQuery. It is said that phpQuery is often faster than QueryPath (because of fewer overall features).</source>
          <target state="translated">一般来说QueryPath更适合操作文档。而phpQuery也实现了一些伪AJAX方法(只是HTTP请求),更接近jQuery。据说phpQuery往往比QueryPath更快(因为整体功能更少)。</target>
        </trans-unit>
        <trans-unit id="d33a71599358dd446b3a5c5bbb17eb6a539802b6" translate="yes" xml:space="preserve">
          <source>HTML 5</source>
          <target state="translated">HTML 5</target>
        </trans-unit>
        <trans-unit id="2481298ff8cb8b47dd8d49e8f6bf9293936053cb" translate="yes" xml:space="preserve">
          <source>HTML parsers already know the syntactical rules of HTML. Regular expressions have to be taught for each new RegEx you write. RegEx are fine in some cases, but it really depends on your use-case.</source>
          <target state="translated">HTML解析器已经知道HTML的语法规则。每写一个新的RegEx,就必须学习正则表达式。RegEx在某些情况下是可以的,但这确实取决于你的使用情况。</target>
        </trans-unit>
        <trans-unit id="6ef2488e29db96459d8f0a2f4afd555a7950eb39" translate="yes" xml:space="preserve">
          <source>Here's the github repo: &lt;a href=&quot;https://github.com/pwarelis/XmlExtractor&quot;&gt;XmlExtractor&lt;/a&gt;</source>
          <target state="translated">这是github &lt;a href=&quot;https://github.com/pwarelis/XmlExtractor&quot;&gt;仓库&lt;/a&gt; ： XmlExtractor</target>
        </trans-unit>
        <trans-unit id="c64fd288b23d031d147bac0aa0a5b5c67e88a520" translate="yes" xml:space="preserve">
          <source>How can one parse HTML/XML and extract information from it?</source>
          <target state="translated">如何解析HTMLXML并从中提取信息?</target>
        </trans-unit>
        <trans-unit id="e3cc41a06f4bd11f3bf3b219f0962c8f9b07a883" translate="yes" xml:space="preserve">
          <source>How do you parse and process HTML/XML in PHP</source>
          <target state="translated">如何在PHP中解析和处理HTMLXML?</target>
        </trans-unit>
        <trans-unit id="6a227cfcf5e09a8662563ee0c093ac92c4d9a454" translate="yes" xml:space="preserve">
          <source>How to get HTML elements:</source>
          <target state="translated">如何获得HTML元素。</target>
        </trans-unit>
        <trans-unit id="4389a53129f0579ecfb989ab0d8e483e12a6aa8e" translate="yes" xml:space="preserve">
          <source>How to modify HTML elements:</source>
          <target state="translated">如何修改HTML元素。</target>
        </trans-unit>
        <trans-unit id="d88d96ba36436a05a8cfe468304396c953bf885c" translate="yes" xml:space="preserve">
          <source>HtmlPageDom</source>
          <target state="translated">HtmlPageDom</target>
        </trans-unit>
        <trans-unit id="c0d513d3128cbbe47a078efa90613fe568129ba7" translate="yes" xml:space="preserve">
          <source>I am not affiliated with PHP Architect or the authors.</source>
          <target state="translated">我与PHP架构师或作者无关。</target>
        </trans-unit>
        <trans-unit id="bbcbf01f4064f686ea8722a2a29768c36f034c48" translate="yes" xml:space="preserve">
          <source>I created a library named &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;&lt;strong&gt;PHPPowertools/DOM-Query&lt;/strong&gt;&lt;/a&gt;, which allows you to crawl HTML5 and XML documents just like you do with jQuery.</source>
          <target state="translated">我创建了一个名为&lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;&lt;strong&gt;PHPPowertools / DOM-Query&lt;/strong&gt;&lt;/a&gt;的库，该库使您可以像使用jQuery一样抓取HTML5和XML文档。</target>
        </trans-unit>
        <trans-unit id="ba6b30ea78ddf3eba99914702d1561cbba328440" translate="yes" xml:space="preserve">
          <source>I generally do not recommend this parser. The codebase is horrible and the parser itself is rather slow and memory hungry. Not all jQuery Selectors (such as &lt;a href=&quot;https://api.jquery.com/child-selector/&quot;&gt;child selectors&lt;/a&gt;) are possible. Any of the libxml based libraries should outperform this easily.</source>
          <target state="translated">我通常不建议使用此解析器。 代码库太可怕了，解析器本身也很慢并且占用大量内存。 并非所有的jQuery选择器（例如&lt;a href=&quot;https://api.jquery.com/child-selector/&quot;&gt;子选择器&lt;/a&gt; ）都是可行的。 任何基于libxml的库都应该容易地胜过它。</target>
        </trans-unit>
        <trans-unit id="eb6fc4ab03473e7d17c1de5c02d235ac14fd367c" translate="yes" xml:space="preserve">
          <source>I have never used curl for the purpose but what I have learned is that curl can do the job much more efficiently and is much more solid.</source>
          <target state="translated">我从来没有用过卷发,但我的体会是,卷发可以更有效地完成任务,而且更扎实。</target>
        </trans-unit>
        <trans-unit id="a95c793e7e56b31812864ca97fa71b47951770bc" translate="yes" xml:space="preserve">
          <source>I have written a general purpose XML parser that can easily handle GB files. It's based on XMLReader and it's very easy to use:</source>
          <target state="translated">我写了一个通用的XML解析器,可以轻松处理GB文件。它是基于XMLReader的,非常容易使用。</target>
        </trans-unit>
        <trans-unit id="357606d09d492cf4482c3593cd4945b8c282bb19" translate="yes" xml:space="preserve">
          <source>I merely want to add that I personally prefer using the DOM extension and why :</source>
          <target state="translated">我只想补充一下,我个人更喜欢使用DOM扩展,为什么?</target>
        </trans-unit>
        <trans-unit id="339836ff45972f30237165fb9e1c7b9692b84246" translate="yes" xml:space="preserve">
          <source>I prefer using one of the &lt;a href=&quot;http://php.net/manual/en/refs.xml.php&quot;&gt;native XML extensions&lt;/a&gt; since they come bundled with PHP, are usually faster than all the 3rd party libs and give me all the control I need over the markup.</source>
          <target state="translated">我更喜欢使用本&lt;a href=&quot;http://php.net/manual/en/refs.xml.php&quot;&gt;机XML扩展&lt;/a&gt;之一，因为它们与PHP捆绑在一起，通常比所有第3方库都快，并为我提供了所需的标记控制权。</target>
        </trans-unit>
        <trans-unit id="5d8cbf62fddda3fe5bed7b863aae097fe3f69e98" translate="yes" xml:space="preserve">
          <source>I recommend &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;PHP Simple HTML DOM Parser&lt;/a&gt;.</source>
          <target state="translated">我推荐&lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;PHP简单HTML DOM解析器&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="84ae9571dbd8d9c4e5f813977179983452830ffd" translate="yes" xml:space="preserve">
          <source>I've created a library called HTML5DOMDocument that is freely available at &lt;a href=&quot;https://github.com/ivopetkov/html5-dom-document-php&quot;&gt;https://github.com/ivopetkov/html5-dom-document-php&lt;/a&gt;</source>
          <target state="translated">我创建了一个名为HTML5DOMDocument的库，该库可从&lt;a href=&quot;https://github.com/ivopetkov/html5-dom-document-php&quot;&gt;https://github.com/ivopetkov/html5-dom-document-php&lt;/a&gt;免费获得</target>
        </trans-unit>
        <trans-unit id="f1783e93efdfa64b38f9953aae0900acc436e264" translate="yes" xml:space="preserve">
          <source>I've used this in a number of tools, testing it on many different types of web pages, and I think it works great.</source>
          <target state="translated">我在很多工具中使用过这个,在很多不同类型的网页上测试过,我认为它的效果很好。</target>
        </trans-unit>
        <trans-unit id="de24ae92f1c60dd3b9a2acc993da1dabf7ccfff8" translate="yes" xml:space="preserve">
          <source>If you don't feel like programming PHP, you can also use Web services. In general, I found very little utility for these, but that's just me and my use cases.</source>
          <target state="translated">如果你不喜欢PHP编程,也可以使用Web服务。总的来说,我发现这些实用的东西很少,但这只是我和我的用例。</target>
        </trans-unit>
        <trans-unit id="54f146095c7e90652a02eaaa284db8fac07cafa2" translate="yes" xml:space="preserve">
          <source>If you prefer to use a 3rd-party lib, I'd suggest using a lib that actually uses &lt;a href=&quot;http://php.net/manual/en/book.dom.php&quot;&gt;DOM&lt;/a&gt;/&lt;a href=&quot;http://xmlsoft.org/&quot;&gt;libxml&lt;/a&gt; underneath instead of string parsing.</source>
          <target state="translated">如果您更喜欢使用第三方库，则建议使用实际上在下面使用&lt;a href=&quot;http://php.net/manual/en/book.dom.php&quot;&gt;DOM&lt;/a&gt; / &lt;a href=&quot;http://xmlsoft.org/&quot;&gt;libxml&lt;/a&gt;的库，而不是字符串解析。</target>
        </trans-unit>
        <trans-unit id="4547441eafff3d38922bc0db40181f5ace8b4996" translate="yes" xml:space="preserve">
          <source>If you want to spend some money, have a look at</source>
          <target state="translated">如果你想花点钱的话,可以看一看</target>
        </trans-unit>
        <trans-unit id="66264988483b0b4b5f9a545e7d1e048b3553f2a3" translate="yes" xml:space="preserve">
          <source>If you're familiar with jQuery selector, you can use &lt;a href=&quot;https://github.com/ScarletsFiction/ScarletsQuery&quot;&gt;ScarletsQuery&lt;/a&gt; for PHP</source>
          <target state="translated">如果您熟悉jQuery选择器，则可以使用&lt;a href=&quot;https://github.com/ScarletsFiction/ScarletsQuery&quot;&gt;ScarletsQuery&lt;/a&gt; for PHP</target>
        </trans-unit>
        <trans-unit id="4d5575093d6413d3f97f557e98a63bbd8b9025e7" translate="yes" xml:space="preserve">
          <source>It also accept invalid HTML or missing quote on tag attributes.</source>
          <target state="translated">它还可以接受无效的HTML或标签属性上的无效引号。</target>
        </trans-unit>
        <trans-unit id="6d66305bb90d7ea542c8c6aad06e7a21d4ac7479" translate="yes" xml:space="preserve">
          <source>It also has full CSS support, including &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; extensions.</source>
          <target state="translated">它还具有完整的CSS支持，包括&lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="25432a75a0586b1da4ec0478132a4dae9bb24a9d" translate="yes" xml:space="preserve">
          <source>It really has nice features, like:</source>
          <target state="translated">它真的有不错的功能,比如。</target>
        </trans-unit>
        <trans-unit id="4c5c9e5bf0835f1de708dac8dda79e1196e30c58" translate="yes" xml:space="preserve">
          <source>It supports query selectors too that I think will be extremely helpful in your case. Here is some example code:</source>
          <target state="translated">它还支持查询选择器,我认为这对你的情况会有很大的帮助。下面是一些示例代码。</target>
        </trans-unit>
        <trans-unit id="f099bf29cecda917eab795da4d9f9293e52130c7" translate="yes" xml:space="preserve">
          <source>It takes some time to get productive with DOM, but that time is well worth it IMO. Since DOM is a language-agnostic interface, you'll find implementations in many languages, so if you need to change your programming language, chances are you will already know how to use that language's DOM API then.</source>
          <target state="translated">使用DOM需要一些时间,但这段时间是非常值得的。由于DOM是一个语言无关的接口,所以你会发现有很多语言的实现,所以如果你需要改变你的编程语言,很可能你已经知道如何使用该语言的DOM API。</target>
        </trans-unit>
        <trans-unit id="d452f4389b55a57f93798030576c7607d916d482" translate="yes" xml:space="preserve">
          <source>It treats DOM elements in an object-oriented way, and the new iteration has a lot of coverage for non-compliant code. There are also some great functions like you'd see in JavaScript, such as the &quot;find&quot; function, which will return all instances of elements of that tag name.</source>
          <target state="translated">它以面向对象的方式对待DOM元素,新的迭代对不合规的代码有很多覆盖。还有一些很棒的函数,就像你在JavaScript中看到的那样,比如 &quot;find &quot;函数,它将返回该标记名称的元素的所有实例。</target>
        </trans-unit>
        <trans-unit id="f77033e3cd943fcbdc5f951c94653a819b0e7a5f" translate="yes" xml:space="preserve">
          <source>It's sometimes even advisable to pre-extract a snippet of HTML using regular expressions &lt;code&gt;/&amp;lt;!--CONTENT--&amp;gt;(.+?)&amp;lt;!--END--&amp;gt;/&lt;/code&gt; and process the remainder using the simpler HTML parser frontends.</source>
          <target state="translated">有时甚至建议使用正则表达式 &lt;code&gt;/&amp;lt;!--CONTENT--&amp;gt;(.+?)&amp;lt;!--END--&amp;gt;/&lt;/code&gt; 预提取HTML片段，然后使用更简单的HTML解析器前端处理其余部分。</target>
        </trans-unit>
        <trans-unit id="c75352eba2f1997a0100830871fe331ba99a290c" translate="yes" xml:space="preserve">
          <source>JSON and array from XML in three lines:</source>
          <target state="translated">JSON和数组从XML三行。</target>
        </trans-unit>
        <trans-unit id="2c86a3c52b12cd6eba84f473339f4b1433a03e0d" translate="yes" xml:space="preserve">
          <source>Just use &lt;a href=&quot;http://docs.php.net/manual/en/domdocument.loadhtml.php&quot;&gt;DOMDocument-&amp;gt;loadHTML()&lt;/a&gt; and be done with it. libxml's HTML parsing algorithm is quite good and fast, and contrary to popular belief, does not choke on malformed HTML.</source>
          <target state="translated">只需使用&lt;a href=&quot;http://docs.php.net/manual/en/domdocument.loadhtml.php&quot;&gt;DOMDocument-&amp;gt; loadHTML（）即可&lt;/a&gt;完成。 libxml的HTML解析算法非常好且快速，并且与流行的看法相反，它不会阻止格式错误的HTML。</target>
        </trans-unit>
        <trans-unit id="77af834f38039e4a75c2d1af87fc51c7f4c83af5" translate="yes" xml:space="preserve">
          <source>Kindly check out this link:&lt;a href=&quot;http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/&quot;&gt;scraping-websites-with-curl&lt;/a&gt;</source>
          <target state="translated">请查看此链接： &lt;a href=&quot;http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/&quot;&gt;scraping-websites-with-curl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df5af4eaf6333c18a92e864a88a527466c8e2a87" translate="yes" xml:space="preserve">
          <source>Last and &lt;strong&gt;least recommended&lt;/strong&gt;, you can extract data from HTML with &lt;a href=&quot;https://stackoverflow.com/search?q=regular%20expression%20tutorials&quot;&gt;regular expressions&lt;/a&gt;. In general using Regular Expressions on HTML is discouraged.</source>
          <target state="translated">最后也是&lt;strong&gt;最不推荐的做法是&lt;/strong&gt; ，您可以使用&lt;a href=&quot;https://stackoverflow.com/search?q=regular%20expression%20tutorials&quot;&gt;正则表达式&lt;/a&gt;从HTML提取数据。 通常，不建议在HTML上使用正则表达式。</target>
        </trans-unit>
        <trans-unit id="2aba8d7afde1162b4fd4210f44e3fd0179a97e30" translate="yes" xml:space="preserve">
          <source>Many DOM traversal frontends don't reveal HTML comments &lt;code&gt;&amp;lt;!--&lt;/code&gt;, which however are sometimes the more useful anchors for extraction. In particular pseudo-HTML variations &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; or SGML residues are easy to tame with regexps.</source>
          <target state="translated">许多DOM遍历前端并没有显示HTML注释 &lt;code&gt;&amp;lt;!--&lt;/code&gt; ，但是注释有时更有用。 特别是伪HTML变体 &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; 或SGML残基易于与正则表达式配合。</target>
        </trans-unit>
        <trans-unit id="6f83c03a7d83375b8530b744da5d4e14cb773741" translate="yes" xml:space="preserve">
          <source>Minify CSS and Javascript</source>
          <target state="translated">Minify CSS和Javascript</target>
        </trans-unit>
        <trans-unit id="627adea35309c41eae7e01931d886d77e7c41c7d" translate="yes" xml:space="preserve">
          <source>Most of the snippets you will find on the web to match markup are brittle. In most cases they are only working for a very particular piece of HTML. Tiny markup changes, like adding whitespace somewhere, or adding, or changing attributes in a tag, can make the RegEx fails when it's not properly written. You should know what you are doing before using RegEx on HTML.</source>
          <target state="translated">你会在网上找到的大多数匹配标记的片段都很脆。在大多数情况下,它们只对一个非常特殊的HTML片段起作用。一些细微的标记变化,比如在某个地方添加空白处,或者在标记中添加或改变属性,都会使RegEx在写得不正确的情况下失效。在HTML上使用RegEx之前,你应该知道你在做什么。</target>
        </trans-unit>
        <trans-unit id="89b2f5b0133f65e45226a07f5cee8565bdcadf34" translate="yes" xml:space="preserve">
          <source>Mostly you want to use simple &lt;code&gt;#id&lt;/code&gt; and &lt;code&gt;.class&lt;/code&gt; or &lt;code&gt;DIV&lt;/code&gt; tag selectors for &lt;code&gt;-&amp;gt;find()&lt;/code&gt;. But you can also use &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; statements, which sometimes are faster. Also typical jQuery methods like &lt;code&gt;-&amp;gt;children()&lt;/code&gt; and &lt;code&gt;-&amp;gt;text()&lt;/code&gt; and particularly &lt;code&gt;-&amp;gt;attr()&lt;/code&gt; simplify extracting the right HTML snippets. (And already have their SGML entities decoded.)</source>
          <target state="translated">通常，您想为 &lt;code&gt;-&amp;gt;find()&lt;/code&gt; 使用简单的 &lt;code&gt;#id&lt;/code&gt; 和 &lt;code&gt;.class&lt;/code&gt; 或 &lt;code&gt;DIV&lt;/code&gt; 标签选择器。 但是您也可以使用&lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;语句，该语句有时会更快。 同样，典型的jQuery方法（如 &lt;code&gt;-&amp;gt;children()&lt;/code&gt; 和 &lt;code&gt;-&amp;gt;text()&lt;/code&gt; ，尤其是 &lt;code&gt;-&amp;gt;attr()&lt;/code&gt; 可以简化提取正确的HTML代码段的过程。 （并且已经对其SGML实体进行了解码。）</target>
        </trans-unit>
        <trans-unit id="9031cd061d55fd09d5631c31edd51747001a785e" translate="yes" xml:space="preserve">
          <source>NOTE :</source>
          <target state="translated">注:</target>
        </trans-unit>
        <trans-unit id="1300a697b19e9262ea20292114599c4fd1368aef" translate="yes" xml:space="preserve">
          <source>Native XML Extensions</source>
          <target state="translated">本地XML扩展</target>
        </trans-unit>
        <trans-unit id="1677e20649f0c9d5ffd70eb67cbee8c3b828533d" translate="yes" xml:space="preserve">
          <source>Never used it. Can't tell if it's any good.</source>
          <target state="translated">从来没有用过它。看不出有什么用处。</target>
        </trans-unit>
        <trans-unit id="62ea675f26d38d09101a41ac861850d50fba75d0" translate="yes" xml:space="preserve">
          <source>Oftentimes regular expressions can save post-processing. However HTML entities often require manual caretaking.</source>
          <target state="translated">通常情况下,正则表达式可以节省后期处理。然而HTML实体往往需要人工照顾。</target>
        </trans-unit>
        <trans-unit id="1f83f8dcdf419895f7c7a83c7580b9a96b3f2f1c" translate="yes" xml:space="preserve">
          <source>One general approach I haven't seen mentioned here is to run HTML through &lt;a href=&quot;http://php.net/manual/en/book.tidy.php&quot;&gt;Tidy&lt;/a&gt;, which can be set to spit out guaranteed-valid XHTML. Then you can use any old XML library on it.</source>
          <target state="translated">我这里没有提到的一种通用方法是通过&lt;a href=&quot;http://php.net/manual/en/book.tidy.php&quot;&gt;Tidy&lt;/a&gt;运行HTML，可以将其设置为吐出保证有效的XHTML。 然后，您可以在其上使用任何旧的XML库。</target>
        </trans-unit>
        <trans-unit id="578a94497cee464a3ed319fd370eec273b62e6df" translate="yes" xml:space="preserve">
          <source>Operations separated in smaller functions for easy overriding</source>
          <target state="translated">在较小的函数中分离出的操作,便于覆盖</target>
        </trans-unit>
        <trans-unit id="7ed99b9fb3a5520bfade55b9fe5642a263895c2a" translate="yes" xml:space="preserve">
          <source>PHP Architect's Guide to Webscraping with PHP</source>
          <target state="translated">PHP Architect's Guide to Webscraping with PHP</target>
        </trans-unit>
        <trans-unit id="2fdc33ef5621a15328fa3e4a16e51f86b20c60b0" translate="yes" xml:space="preserve">
          <source>PHP Html Parser</source>
          <target state="translated">PHP Html解析器</target>
        </trans-unit>
        <trans-unit id="2fccda5363a87dcdb8f1237ddb0532e23fc267f7" translate="yes" xml:space="preserve">
          <source>PHP Simple HTML DOM Parser</source>
          <target state="translated">PHP简单HTML DOM解析器</target>
        </trans-unit>
        <trans-unit id="d4f4d957c818e56ebc312e877f197ce68488f02a" translate="yes" xml:space="preserve">
          <source>PHPHtmlParser is a simple, flexible, html parser which allows you to select tags using any css selector, like jQuery. The goal is to assiste in the development of tools which require a quick, easy way to scrap html, whether it's valid or not! This project was original supported by sunra/php-simple-html-dom-parser but the support seems to have stopped so this project is my adaptation of his previous work.</source>
          <target state="translated">PHPHtmlParser是一个简单、灵活的html解析器,它允许你使用任何css选择器(如jQuery)来选择标签。它的目标是协助开发需要快速、简单的工具,不管它是否有效,都可以快速、简单地将html进行废止。这个项目最初是由sunraphp-simple-html-dom-parser支持的,但是现在似乎已经停止了,所以这个项目是我对他之前的工作进行了改编。</target>
        </trans-unit>
        <trans-unit id="28d936680a9cd1da534d5bab294f5e31d74394d2" translate="yes" xml:space="preserve">
          <source>Parsing documents using callbacks based on current character/token</source>
          <target state="translated">使用基于当前字符令牌的回调来解析文档</target>
        </trans-unit>
        <trans-unit id="a11058217485bda936a7947b3f8dea9dca2c1f2d" translate="yes" xml:space="preserve">
          <source>Proper data unescaping (in comparison to regular expression grepping)</source>
          <target state="translated">适当的数据解套(与正则表达式grepping相比)</target>
        </trans-unit>
        <trans-unit id="a81c033171fc90b40305445d7d6e17317ebc3577" translate="yes" xml:space="preserve">
          <source>QueryPath</source>
          <target state="translated">QueryPath</target>
        </trans-unit>
        <trans-unit id="9737e148f4e81913479e1971cb61a0356bc18cc5" translate="yes" xml:space="preserve">
          <source>QueryPath also allows injecting new tags into the stream (&lt;code&gt;-&amp;gt;append&lt;/code&gt;), and later output and prettify an updated document (&lt;code&gt;-&amp;gt;writeHTML&lt;/code&gt;). It can not only parse malformed HTML, but also various XML dialects (with namespaces), and even extract data from HTML microformats (XFN, vCard).</source>
          <target state="translated">QueryPath还允许将新标签注入到流中（ &lt;code&gt;-&amp;gt;append&lt;/code&gt; ），然后输出并美化一个更新的文档（ &lt;code&gt;-&amp;gt;writeHTML&lt;/code&gt; ）。 它不仅可以解析格式错误的HTML，还可以解析各种XML方言（带有名称空间），甚至可以从HTML微格式（XFN，vCard）提取数据。</target>
        </trans-unit>
        <trans-unit id="95df12b37819a2adfe3f819892d0d4de469b52c4" translate="yes" xml:space="preserve">
          <source>QueryPath is a PHP library for manipulating XML and HTML. It is designed to work not only with local files, but also with web services and database resources. It implements much of the jQuery interface (including CSS-style selectors), but it is heavily tuned for server-side use.  Can be installed via Composer.</source>
          <target state="translated">QueryPath是一个用于操作XML和HTML的PHP库。它不仅可以处理本地文件,还可以处理Web服务和数据库资源。它实现了很多jQuery接口(包括CSS样式的选择器),但它是为服务器端使用而调整的。可以通过Composer安装。</target>
        </trans-unit>
        <trans-unit id="ab140354a34bd045ff52d42f722acc1c4ffada22" translate="yes" xml:space="preserve">
          <source>Regular Expressions</source>
          <target state="translated">正则表达式</target>
        </trans-unit>
        <trans-unit id="036e8223cfc6af3bc474124d436998f668393599" translate="yes" xml:space="preserve">
          <source>Require PHP 5+.</source>
          <target state="translated">要求PHP 5以上。</target>
        </trans-unit>
        <trans-unit id="76a7e0d2a9377458c6ef9ab5843fd65dd104d40a" translate="yes" xml:space="preserve">
          <source>ScraperWiki's external interface allows you to extract data in the form you want for use on the web or in your own applications. You can also extract information about the state of any scraper.</source>
          <target state="translated">ScraperWiki的外部接口允许你以你想要的形式提取数据,以便在网络上或自己的应用程序中使用。你还可以提取任何刮刀的状态信息。</target>
        </trans-unit>
        <trans-unit id="c9a3a60c4a1b9153da07bbc915c70995d1fcd9b2" translate="yes" xml:space="preserve">
          <source>Scraping Slashdot:</source>
          <target state="translated">刮刮刮刮乐网。</target>
        </trans-unit>
        <trans-unit id="f2508406c16bde16405a9e91ecee59698672e940" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors&quot;&gt;Parsing XML documents with CSS selectors&lt;/a&gt; by Symfony's creator Fabien Potencier on his decision to create the CssSelector component for Symfony and how to use it.</source>
          <target state="translated">另请参见Symfony的创建者Fabien Potencier决定&lt;a href=&quot;http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors&quot;&gt;使用CSS选择器解析XML文档，以&lt;/a&gt;决定为Symfony创建CssSelector组件以及如何使用它。</target>
        </trans-unit>
        <trans-unit id="20496fe36fbd9068f5e0745949f57d1a30754cf2" translate="yes" xml:space="preserve">
          <source>Simple HTML DOM is a great open-source parser:</source>
          <target state="translated">Simple HTML DOM是一个伟大的开源解析器。</target>
        </trans-unit>
        <trans-unit id="26acadafb8b9e27c131ae620d79467303283aec3" translate="yes" xml:space="preserve">
          <source>Simple to use alternatives &lt;code&gt;-&amp;gt;find(&quot;a img, a object, div a&quot;)&lt;/code&gt;</source>
          <target state="translated">简单易用的替代方法 &lt;code&gt;-&amp;gt;find(&quot;a img, a object, div a&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac04b5615f2819c31f2d067d7f8923ef7ff7ef21" translate="yes" xml:space="preserve">
          <source>SimpleXML is an option when you know the HTML is valid XHTML. If you need to parse broken HTML, don't even consider SimpleXml because it will choke.</source>
          <target state="translated">当你知道HTML是有效的XHTML时,SimpleXML是一个选择。如果你需要解析破损的HTML,甚至不要考虑SimpleXml,因为它会窒息。</target>
        </trans-unit>
        <trans-unit id="8b459878d5dac1498236eb8ec705c4653131f954" translate="yes" xml:space="preserve">
          <source>SimpleXml</source>
          <target state="translated">SimpleXml</target>
        </trans-unit>
        <trans-unit id="4ab9bc94de911e1bbbc353ed1187f6ef58e14b32" translate="yes" xml:space="preserve">
          <source>Simplicity and Reliability</source>
          <target state="translated">简洁性和可靠性</target>
        </trans-unit>
        <trans-unit id="04b1d51ec3918aabce9a1745c1f2074a9358a9f6" translate="yes" xml:space="preserve">
          <source>So please don't vote real-world considerations down, just because it doesn't match the regex=evil meme. &lt;strong&gt;But let's also not vote this up too much. It's just a sidenote for this topic.&lt;/strong&gt;</source>
          <target state="translated">因此，请勿仅仅因为它与regex = evil meme不匹配而否决现实世界中的考虑因素。 &lt;strong&gt;但是，我们也不要对此投票太多。&lt;/strong&gt; &lt;strong&gt;这只是该主题的旁注。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19dfc66630e4b772779cd9a262a504499ad4897f" translate="yes" xml:space="preserve">
          <source>Sort attributes, change character case, correct indentation, etc.</source>
          <target state="translated">分类属性、改变字符大小写、纠正缩进等。</target>
        </trans-unit>
        <trans-unit id="6492f0b8f23e2427034e89fba4fc783788408998" translate="yes" xml:space="preserve">
          <source>Supported methods :</source>
          <target state="translated">支持的方法:</target>
        </trans-unit>
        <trans-unit id="09c87bdf1f20971fcf51b21e634812d66a597646" translate="yes" xml:space="preserve">
          <source>Supports invalid HTML and UTF8</source>
          <target state="translated">支持无效的HTML和UTF8</target>
        </trans-unit>
        <trans-unit id="1b4f692c4cf3ff10d493de7506631f00988acc7a" translate="yes" xml:space="preserve">
          <source>Supports invalid HTML.</source>
          <target state="translated">支持无效的HTML。</target>
        </trans-unit>
        <trans-unit id="4b51562e1d3f8c3ee0992b96a3771823cf482336" translate="yes" xml:space="preserve">
          <source>Ta da!</source>
          <target state="translated">哒哒!</target>
        </trans-unit>
        <trans-unit id="22123f0c078e1328382bb3ba2c871a5312c22c9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Symfony&quot;&gt;Symfony&lt;/a&gt; framework has bundles which can parse the HTML, and you can use CSS style to select the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOMs&lt;/a&gt; instead of using &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Symfony&quot;&gt;Symfony&lt;/a&gt;框架具有可以解析HTML的捆绑软件，您可以使用CSS样式选择&lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM，&lt;/a&gt;而不是使用&lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="08426608042619571ea8da728effcd8bdb8ccddf" translate="yes" xml:space="preserve">
          <source>The DOM extension allows you to operate on XML documents through the DOM API with PHP 5. It is an implementation of the W3C's Document Object Model Core Level 3, a platform- and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure and style of documents.</source>
          <target state="translated">DOM扩展允许你通过PHP 5的DOM API对XML文档进行操作,它是W3C的文档对象模型核心3级的实现,这是一个平台和语言中立的接口,允许程序和脚本动态访问和更新文档的内容、结构和样式。</target>
        </trans-unit>
        <trans-unit id="6af68a6b854fdff9293628426a280a5712ed9a80" translate="yes" xml:space="preserve">
          <source>The SimpleXML extension provides a very simple and easily usable toolset to convert XML to an object that can be processed with normal property selectors and array iterators.</source>
          <target state="translated">SimpleXML扩展提供了一个非常简单易用的工具集,可以将XML转换为一个对象,可以用普通的属性选择器和数组迭代器进行处理。</target>
        </trans-unit>
        <trans-unit id="56fa67264d262a826c383e93de2a9bbeefb33eaa" translate="yes" xml:space="preserve">
          <source>The XML Parser library is also based on libxml, and implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Simple_API_for_XML&quot;&gt;SAX&lt;/a&gt; style XML push parser. It may be a better choice for memory management than DOM or SimpleXML, but will be more difficult to work with than the pull parser implemented by XMLReader.</source>
          <target state="translated">XML解析器库也基于libxml，并实现了&lt;a href=&quot;http://en.wikipedia.org/wiki/Simple_API_for_XML&quot;&gt;SAX&lt;/a&gt;样式的XML推送解析器。 与DOM或SimpleXML相比，内存管理可能是更好的选择，但与XMLReader实现的请求解析器相比，使用起来更加困难。</target>
        </trans-unit>
        <trans-unit id="b67498f486aaa11938e3847d09f2dce44e5beb65" translate="yes" xml:space="preserve">
          <source>The XMLReader extension is an XML pull parser. The reader acts as a cursor going forward on the document stream and stopping at each node on the way.</source>
          <target state="translated">XMLReader 扩展是一个 XML 拉取解析器。该阅读器就像一个光标一样,在文档流中前进,并在途中的每个节点上停止。</target>
        </trans-unit>
        <trans-unit id="daf8ea6c752ba027315c1f91a513e28bb38ce9f6" translate="yes" xml:space="preserve">
          <source>The benefit of building upon DOM/libxml is that you get good performance out of the box because you are based on a native extension. However, not all 3rd-party libs go down this route. Some of them listed below</source>
          <target state="translated">建立在DOMlibxml基础上的好处是,你可以获得良好的性能,因为你是基于原生扩展。然而,不是所有的第三方lib都走这条路。下面列出了其中的一些</target>
        </trans-unit>
        <trans-unit id="d8816c1d03b50b77e6e6ff51bd569066e7b5a0e5" translate="yes" xml:space="preserve">
          <source>The best method for parse xml:</source>
          <target state="translated">解析xml的最佳方法。</target>
        </trans-unit>
        <trans-unit id="4132078238d9256b003dd6494bd23513c071a209" translate="yes" xml:space="preserve">
          <source>The code below comes straight out my &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;DOM-Query library&lt;/a&gt; and uses the technique I described.</source>
          <target state="translated">下面的代码直接给出了我的&lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;DOM-Query库，&lt;/a&gt;并使用了我描述的技术。</target>
        </trans-unit>
        <trans-unit id="11b52d17561803fdb6224e1ca70f26a54f943a6b" translate="yes" xml:space="preserve">
          <source>The component is designed to work standalone and can be used without Symfony.</source>
          <target state="translated">该组件设计为独立工作,可以在没有Symfony的情况下使用。</target>
        </trans-unit>
        <trans-unit id="df302445bc11b04611b1cf770aa3b7c0254ec538" translate="yes" xml:space="preserve">
          <source>The only drawback is that it will only work with PHP 5.3 or newer.</source>
          <target state="translated">唯一的缺点是它只适用于PHP5.3或更新的版本。</target>
        </trans-unit>
        <trans-unit id="58431aa1e93eb44c019b1578434838cf2038f96d" translate="yes" xml:space="preserve">
          <source>The resulting object contains a complete tree representation of the HTML document. It can be traversed using DOM methods. But the common approach is to use CSS selectors like in jQuery:</source>
          <target state="translated">由此产生的对象包含一个完整的HTML文档的树形表示。它可以使用DOM方法进行遍历。但常见的方法是使用CSS选择器,就像jQuery中的CSS选择器。</target>
        </trans-unit>
        <trans-unit id="f669955759ac8d7fc7074861be693d4a0720bae0" translate="yes" xml:space="preserve">
          <source>There are however specific use cases where they can help.</source>
          <target state="translated">然而,有一些具体的使用案例,它们可以提供帮助。</target>
        </trans-unit>
        <trans-unit id="ba5cb182872adb3d586144d6a301c22c0f539179" translate="yes" xml:space="preserve">
          <source>There are many ways to process HTML/XML DOM of which most have already been mentioned. Hence, I won't make any attempt to list those myself.</source>
          <target state="translated">处理HTMLXML DOM的方法有很多,其中大部分已经提到了。因此,我自己就不一一列举了。</target>
        </trans-unit>
        <trans-unit id="7fc01c223fb450ac4e6ebdc77a0edd1badd8832f" translate="yes" xml:space="preserve">
          <source>There are several reasons to not parse HTML by regular expression. But, if you have total control of what HTML will be generated, then you can do with simple regular expression.</source>
          <target state="translated">有几个理由不使用正则表达式解析HTML。但是,如果你完全控制了HTML会生成什么,那么你可以用简单的正则表达式来做。</target>
        </trans-unit>
        <trans-unit id="f9a9ec64bafcc374d9945fc4204431933239630f" translate="yes" xml:space="preserve">
          <source>Third party alternatives to SimpleHtmlDom that use DOM instead of String Parsing: &lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt;, &lt;a href=&quot;http://framework.zend.com/manual/en/zend.dom.html&quot;&gt;Zend_Dom&lt;/a&gt;, &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; and &lt;a href=&quot;http://www.fluentdom.org/&quot;&gt;FluentDom&lt;/a&gt;.</source>
          <target state="translated">使用DOM而不是字符串解析的SimpleHtmlDom的第三方替代产品： &lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; ， &lt;a href=&quot;http://framework.zend.com/manual/en/zend.dom.html&quot;&gt;Zend_Dom&lt;/a&gt; ， &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;和&lt;a href=&quot;http://www.fluentdom.org/&quot;&gt;FluentDom&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7416ebc9af5006b615b7faa1baa92773cc5eea4a" translate="yes" xml:space="preserve">
          <source>This extension lets you create XML parsers and then define handlers for different XML events. Each XML parser also has a few parameters you can adjust.</source>
          <target state="translated">这个扩展允许你创建XML解析器,然后为不同的XML事件定义处理程序。每个XML解析器也有一些参数可以调整。</target>
        </trans-unit>
        <trans-unit id="68b5d2b56e9a5e9c0691dcd4f8be37ab0fb44989" translate="yes" xml:space="preserve">
          <source>This is commonly referred to as &lt;strong&gt;screen scraping&lt;/strong&gt;, by the way. The library I have used for this is &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;Simple HTML Dom Parser&lt;/a&gt;.</source>
          <target state="translated">顺便说一句，这通常称为&lt;strong&gt;屏幕抓取&lt;/strong&gt; 。 我为此使用的库是&lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;Simple HTML Dom Parser&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e850b37f770cfea1cd7f56ea9dfb592e682e301e" translate="yes" xml:space="preserve">
          <source>This library usually taking less than 1 second to process offline html.</source>
          <target state="translated">这个库通常只需要不到1秒的时间就可以处理掉线下的html。</target>
        </trans-unit>
        <trans-unit id="2beda6ba9b12df24bc719d6612622cddbc5e8c27" translate="yes" xml:space="preserve">
          <source>This sounds like a good task description of W3C &lt;a href=&quot;http://www.w3.org/TR/xpath/&quot;&gt;XPath&lt;/a&gt; technology. It's easy to express queries like &quot;return all &lt;code&gt;href&lt;/code&gt; attributes in &lt;code&gt;img&lt;/code&gt; tags that are nested in &lt;code&gt;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;&amp;lt;baz&amp;gt; elements&lt;/code&gt;.&quot; Not being a PHP buff, I can't tell you in what form XPath may be available. If you can call an external program to process the HTML file you should be able to use a command line version of XPath.
For a quick intro, see &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;http://en.wikipedia.org/wiki/XPath&lt;/a&gt;.</source>
          <target state="translated">这听起来像是对W3C &lt;a href=&quot;http://www.w3.org/TR/xpath/&quot;&gt;XPath&lt;/a&gt;技术的很好的任务描述。 表达查询很容易，例如&amp;ldquo;返回嵌套在 &lt;code&gt;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;&amp;lt;baz&amp;gt; elements&lt;/code&gt; 中的 &lt;code&gt;img&lt;/code&gt; 标签中的所有 &lt;code&gt;href&lt;/code&gt; 属性&amp;rdquo;。 不是PHP爱好者，我无法告诉您XPath可用的形式。 如果可以调用外部程序来处理HTML文件，则应该能够使用XPath的命令行版本。 有关快速介绍，请参见&lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;http://en.wikipedia.org/wiki/XPath&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a0b9134ff92db59b43251ec557fed51162b65e3" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;&lt;strong&gt;Simple HTML DOM Parser&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">尝试&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;&lt;strong&gt;简单HTML DOM解析器&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c6d262a8d4b5d18d3efdc5b548b97d2ba672dfe1" translate="yes" xml:space="preserve">
          <source>Under the hood, it uses &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;&lt;strong&gt;symfony/DomCrawler&lt;/strong&gt;&lt;/a&gt; for conversion of CSS selectors to &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; selectors. It always uses the same DomDocument, even when passing one object to another, to ensure decent performance.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;&lt;strong&gt;后台&lt;/strong&gt;&lt;/a&gt; ，它使用&lt;strong&gt;symfony / DomCrawler&lt;/strong&gt;将CSS选择器转换为&lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;选择器。 即使将一个对象传递给另一个对象，它也始终使用相同的DomDocument来确保良好的性能。</target>
        </trans-unit>
        <trans-unit id="ec1764919721d724665325102a7111340d413d7f" translate="yes" xml:space="preserve">
          <source>Wa72\HtmlPageDom` is a PHP library for easy manipulation of HTML
  documents using  It requires &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;DomCrawler from Symfony2
  components&lt;/a&gt; for traversing  the
  DOM tree and extends it by adding methods for manipulating the DOM
  tree of HTML documents.</source>
          <target state="translated">Wa72 \ HtmlPageDom是一个PHP库，可使用它轻松处理HTML文档。它需要&lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;Symfony2组件中的DomCrawler&lt;/a&gt;遍历DOM树，并通过添加用于处理HTML文档DOM树的方法对其进行扩展。</target>
        </trans-unit>
        <trans-unit id="2228452e56018a71b37010bd7c5f71859651feca" translate="yes" xml:space="preserve">
          <source>We have created quite a few crawlers for our needs before. At the end of the day, it is usually simple regular expressions that do the thing best. While libraries listed above are good for the reason they are created, if you know what you are looking for, regular expressions is a safer way to go, as you can handle also non-valid &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/XHTML&quot;&gt;XHTML&lt;/a&gt; structures, which would fail, if loaded via most of the parsers.</source>
          <target state="translated">以前，我们已经为我们的需求创建了许多爬虫。 归根结底，通常最简单的正则表达式可以做到最好。 尽管上面列出的库因其创建的原因而很有用，但是如果您知道要查找的内容，则正则表达式是一种更安全的方法，因为您还可以处理无效的&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/XHTML&quot;&gt;XHTML&lt;/a&gt;结构，如果加载它们会失败通过大多数解析器。</target>
        </trans-unit>
        <trans-unit id="25f4d5095cb62b0b7e74915ac9d048a7b58ef20f" translate="yes" xml:space="preserve">
          <source>We might see more dedicated parsers once HTML5 is finalized. There is also a blogpost by the W3's titled &lt;a href=&quot;http://www.w3.org/QA/2008/07/html5-parsing-howto.html&quot;&gt;How-To for html 5 parsing&lt;/a&gt; that is worth checking out.</source>
          <target state="translated">HTML5完成后，我们可能会看到更多专用的解析器。 W3上还有一个博客文章，标题为&lt;a href=&quot;http://www.w3.org/QA/2008/07/html5-parsing-howto.html&quot;&gt;How-To，用于html 5解析&lt;/a&gt; ，值得一试。</target>
        </trans-unit>
        <trans-unit id="0a5d87433685e87a09cab5597b4bcd5803d667c8" translate="yes" xml:space="preserve">
          <source>WebServices</source>
          <target state="translated">WebServices</target>
        </trans-unit>
        <trans-unit id="dd7868492d1aa630c2532fbee868064147abaa60" translate="yes" xml:space="preserve">
          <source>What it means is that each call on the result set modifies the result set in the object, it's not chainable like in jquery where each link is a new set, you have a single set which is the results from your query and each function call modifies that single set.</source>
          <target state="translated">它的意思是,每一次对结果集的调用都会修改对象中的结果集,它不像jquery中的每一个链接都是一个新的集,你有一个单一的集,这个集就是你的查询结果,每一次函数调用都会修改这个单一的集。</target>
        </trans-unit>
        <trans-unit id="958c244d037d86b5bf0abe6245945f8778d00d85" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/servo-php/fluidxml&quot;&gt;&lt;strong&gt;FluidXML&lt;/strong&gt;&lt;/a&gt; you can query and iterate XML using &lt;strong&gt;XPath&lt;/strong&gt; and &lt;strong&gt;CSS Selectors&lt;/strong&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://github.com/servo-php/fluidxml&quot;&gt;&lt;strong&gt;FluidXML，&lt;/strong&gt;&lt;/a&gt;您可以使用&lt;strong&gt;XPath&lt;/strong&gt;和&lt;strong&gt;CSS选择器&lt;/strong&gt;查询和迭代XML。</target>
        </trans-unit>
        <trans-unit id="c133d37ec5b2dec248bc847284b37225a00466bc" translate="yes" xml:space="preserve">
          <source>XML Parser</source>
          <target state="translated">XML解析器</target>
        </trans-unit>
        <trans-unit id="482bdc24f6af5a40a01e6c07554b2e716ffcfd71" translate="yes" xml:space="preserve">
          <source>XMLReader</source>
          <target state="translated">XMLReader</target>
        </trans-unit>
        <trans-unit id="d283a97f786ccb4fc2cde7e0509f6b68fe20c76f" translate="yes" xml:space="preserve">
          <source>XMLReader, like DOM, is based on libxml. I am not aware of how to trigger the HTML Parser Module, so chances are using XMLReader for parsing broken HTML might be less robust than using DOM where you can explicitly tell it to use libxml's HTML Parser Module.</source>
          <target state="translated">XMLReader和DOM一样,都是基于libxml。我不知道如何触发 HTML Parser 模块,所以使用 XMLReader 来解析破损的 HTML 可能不如使用 DOM,因为你可以明确告诉它使用 libxml 的 HTML Parser 模块。</target>
        </trans-unit>
        <trans-unit id="48086d5b2c71a8118002a1eccf45fa90563bef6e" translate="yes" xml:space="preserve">
          <source>Yes you can use simple_html_dom for the purpose. However I have worked quite a lot with the simple_html_dom, particularly for web scrapping and have found it to be too vulnerable. It does the basic job but I won't recommend it anyways.</source>
          <target state="translated">是的,你可以用simple_html_dom来实现这个目的。但是我用过很多simple_html_dom,特别是在网页搜刮方面,发现它太过脆弱。它能完成基本的工作,但我无论如何也不会推荐它。</target>
        </trans-unit>
        <trans-unit id="afacf39f9314512f8b2e4807339393ca1d74c5e5" translate="yes" xml:space="preserve">
          <source>You &lt;a href=&quot;https://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234491#4234491&quot;&gt;can write more reliable parsers&lt;/a&gt;, but writing a &lt;em&gt;complete and reliable&lt;/em&gt; custom parser with regular expressions is a waste of time when the aforementioned libraries already exist and do a much better job on this.</source>
          <target state="translated">您&lt;a href=&quot;https://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234491#4234491&quot;&gt;可以编写更可靠的解析器&lt;/a&gt; ，但是当上述库已经存在并且在此方面做得更好时，编写具有正则表达式的&lt;em&gt;完整且可靠的&lt;/em&gt;自定义解析器会浪费时间。</target>
        </trans-unit>
        <trans-unit id="52244ade1e08c2102f754703196f53beec240409" translate="yes" xml:space="preserve">
          <source>You can then use this (still very low level) subclass as a foundation for more high level classes, intended to eg. parse very specific types of XML or add more jQuery-like behavior.</source>
          <target state="translated">然后你可以使用这个(仍然是非常低级的)子类作为更多高级类的基础,目的是为了解析非常特定的XML类型或添加更多类似jQuery的行为。</target>
        </trans-unit>
        <trans-unit id="57d9a847a211899bc4cd6fd3518ea2a538f3dd72" translate="yes" xml:space="preserve">
          <source>You can use the above for parsing HTML5, but &lt;a href=&quot;https://stackoverflow.com/questions/4029341/dom-parser-that-allows-html5-style-in-script-tag/4029412&quot;&gt;there can be quirks&lt;/a&gt; due to the markup HTML5 allows. So for HTML5 you want to consider using a dedicated parser, like</source>
          <target state="translated">您可以使用上面的代码来解析HTML5，但是由于HTML5允许标记， &lt;a href=&quot;https://stackoverflow.com/questions/4029341/dom-parser-that-allows-html5-style-in-script-tag/4029412&quot;&gt;因此可能会有一些古怪之处&lt;/a&gt; 。 因此，对于HTML5，您需要考虑使用专用的解析器，例如</target>
        </trans-unit>
        <trans-unit id="118bdac2fe1f904ec22de8b22eed3538f08f7e63" translate="yes" xml:space="preserve">
          <source>You could try using something like &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML_Tidy&quot;&gt;HTML Tidy&lt;/a&gt; to cleanup any &quot;broken&quot; HTML and convert the HTML to XHTML, which you can then parse with a XML parser.</source>
          <target state="translated">您可以尝试使用类似&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML_Tidy&quot;&gt;HTML Tidy的方法&lt;/a&gt;来清理任何&amp;ldquo;损坏的&amp;rdquo; HTML并将HTML转换为XHTML，然后可以使用XML解析器进行解析。</target>
        </trans-unit>
        <trans-unit id="fa5f4b4b6cf574e2ed46980afeaa2a7beb181c3f" translate="yes" xml:space="preserve">
          <source>Zend_Dom</source>
          <target state="translated">Zend_Dom</target>
        </trans-unit>
        <trans-unit id="541d5b4dd20a949161f06bff576afd115dc27318" translate="yes" xml:space="preserve">
          <source>Zend_Dom provides tools for working with DOM documents and structures. Currently, we offer Zend_Dom_Query, which provides a unified interface for querying DOM documents utilizing both XPath and CSS selectors.</source>
          <target state="translated">Zend_Dom提供了处理DOM文档和结构的工具。目前,我们提供了Zend_Dom_Query,它提供了一个统一的界面,可以利用XPath和CSS选择器查询DOM文档。</target>
        </trans-unit>
        <trans-unit id="0ec25b22947ac4e042b417da8d2b81bad44eaff3" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/add/&quot;&gt;$selection.add&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/add/&quot;&gt;$ selection.add&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d3ac6816be3e31697646b0d3f24a61ed10c7a2" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/addClass/&quot;&gt;$selection.addClass&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/addClass/&quot;&gt;$ selection.addClass&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a85d853e8ac9999031be082f20dd3c86b3e07d55" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/after/&quot;&gt;$selection.after&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/after/&quot;&gt;$ selection.after&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="855bb5684e5aaad04444a0bcf366e950952780f8" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/append/&quot;&gt;$selection.append&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/append/&quot;&gt;$ selection.append&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="303d76dbb2b71969494a3da3fd0e207352f68b81" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/attr/&quot;&gt;$selection.attr&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/attr/&quot;&gt;$ selection.attr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35be35f74fc5b6a7ede46666a50b8672913da309" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/before/&quot;&gt;$selection.before&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/before/&quot;&gt;$ selection.before&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1879364aaded1afd20c32ebf100fc3585e48f683" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/children/&quot;&gt;$selection.children&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/children/&quot;&gt;$ selection.children&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="678fdf480ddbd2317286e0512d39327d7446bd7b" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/closest/&quot;&gt;$selection.closest&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/closest/&quot;&gt;$ selection.closest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50da6b564af1bc96331746a72991ea045fba2992" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/contents/&quot;&gt;$selection.contents&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/contents/&quot;&gt;$ selection.contents&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52a5716ac9072af064bad7b789daadb3ef628871" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/detach/&quot;&gt;$selection.detach&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/detach/&quot;&gt;$ selection.detach&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cdeed87a0e184eeda42371e499aff6dcc08e7466" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;$selection.each&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;$ selection.each&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d78f7b714bd611131f42b9656016a521c9ee3ea3" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/empty/&quot;&gt;$selection.empty&lt;/a&gt;&lt;em&gt;(2)&lt;/em&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/empty/&quot;&gt;$ selection.empty&lt;/a&gt; &lt;em&gt;（2）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6e8102a4ebff43aa49148fd4ea1b33c02b29fd5" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/eq/&quot;&gt;$selection.eq&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/eq/&quot;&gt;$ selection.eq&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d9ee2a185ce5f56cead560d1e6223a586084cbf" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/find/&quot;&gt;$selection.find&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/find/&quot;&gt;$ selection.find&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2330f331cc5d6a73493ca3314bfdd95b0fba20e9" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/first/&quot;&gt;$selection.first&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/first/&quot;&gt;$ selection.first&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f200b75980c567c5eaef7a8096eb29ee1699ca1c" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/get/&quot;&gt;$selection.get&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/get/&quot;&gt;$ selection.get&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e76d7cf162ad4950910f97fd211357a71685955e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/insertAfter/&quot;&gt;$selection.insertAfter&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/insertAfter/&quot;&gt;$ selection.insertAfter&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b10ab7d52167901e6f202a90c53135afbe343fab" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/insertBefore/&quot;&gt;$selection.insertBefore&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/insertBefore/&quot;&gt;$ selection.insertBefore&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1116fb1f0e86324bbe307d7cfb7990cb591719e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseHTML/&quot;&gt;$.parseHTML&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseHTML/&quot;&gt;$ .parseHTML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b85b8caed5cad3a75963f879bd83444840e9fac4" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseJSON/&quot;&gt;$.parseJSON&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseJSON/&quot;&gt;$ .parseJSON&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24e21007f15fffbeb12d715b440d8dda82b0fd3e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseXML/&quot;&gt;$.parseXML&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseXML/&quot;&gt;$ .parseXML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8284a57c23d4c2602d747df3906e7d105a7ebc79" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;$&lt;/a&gt;&lt;em&gt;(1)&lt;/em&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;$&lt;/a&gt; &lt;em&gt;（1）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41f3041007fb1f1714223d7eb80831018345e0b8" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/last/&quot;&gt;$selection.last&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/last/&quot;&gt;$ selection.last&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b7c6e57b4bf72db36e41ed0f4996a878c5bfc40" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/parent/&quot;&gt;$selection.parent&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/parent/&quot;&gt;$ selection.parent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2966dfa24290fb0d5d1b2426cc2f1fd71d622a62" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/parents/&quot;&gt;$selection.parents&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/parents/&quot;&gt;$ selection.parents&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5e7046e307699d26a7d587af4df3b58264248b0" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/remove/&quot;&gt;$selection.remove&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/remove/&quot;&gt;$ selection.remove&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4558dad027c6574ab3dcfb49125d9a104ae9c7ed" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/removeAttr/&quot;&gt;$selection.removeAttr&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/removeAttr/&quot;&gt;$ selection.removeAttr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78105ee237b89523c07bd548a8d57ebac51c396d" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/removeClass/&quot;&gt;$selection.removeClass&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/removeClass/&quot;&gt;$ selection.removeClass&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8224fc75de7d512420526ac5229a3127fa84011d" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/text/&quot;&gt;$selection.text&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/text/&quot;&gt;$ selection.text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6bf903823bfa2ea35e684feeeee397f598eb071c" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/wrap/&quot;&gt;$selection.wrap&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/wrap/&quot;&gt;$ selection.wrap&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ece6afcddc52bae163f5f7ba435c9607ff7a44b9" translate="yes" xml:space="preserve">
          <source>fDOMDocument</source>
          <target state="translated">fDOMDocument</target>
        </trans-unit>
        <trans-unit id="fe8b7d5279a6e14f60beb4f954ad1e8d77ed6d3a" translate="yes" xml:space="preserve">
          <source>fDOMDocument extends the standard DOM to use exceptions at all occasions of errors instead of PHP warnings or notices. They also add various custom methods and shortcuts for convenience and to simplify the usage of DOM.</source>
          <target state="translated">fDOMDocument扩展了标准的DOM,在所有错误的场合使用异常,而不是PHP警告或通知。为了方便和简化DOM的使用,他们还添加了各种自定义方法和快捷方式。</target>
        </trans-unit>
        <trans-unit id="6183fbc196e925ae7677bf0da88d2d39315c592e" translate="yes" xml:space="preserve">
          <source>html5lib</source>
          <target state="translated">html5lib</target>
        </trans-unit>
        <trans-unit id="e4a3835ab80fda4ba43679f366d992ba21d09b91" translate="yes" xml:space="preserve">
          <source>iit makes optimal use of the performance advantage of the underlying C code</source>
          <target state="translated">它充分利用了底层C语言代码的性能优势。</target>
        </trans-unit>
        <trans-unit id="c52c0b0f2b1233115b4ed3459d964df89266f51d" translate="yes" xml:space="preserve">
          <source>in order to get jquery-like behaviour, you need to branch before you do a filter/modify like operation, that means it'll mirror what happens in jquery much more closely.</source>
          <target state="translated">为了获得类似于jquery的行为,你需要在做类似于filtermodify的操作之前进行分支,这意味着它将更接近于jquery中的镜像。</target>
        </trans-unit>
        <trans-unit id="16a2198898695f10acf40db122134ecdb1b43a35" translate="yes" xml:space="preserve">
          <source>is way less readable than a simple phpQuery or QueryPath equivalent:</source>
          <target state="translated">比起简单的phpQuery或QueryPath等价物的可读性要差很多。</target>
        </trans-unit>
        <trans-unit id="1e8a470cab2da73401e5efabc30513d95e8be9b3" translate="yes" xml:space="preserve">
          <source>it has a syntax used for DOM crawling that's similar to the syntax used in native Javascript.</source>
          <target state="translated">它有一个用于DOM爬行的语法,类似于原生Javascript中使用的语法。</target>
        </trans-unit>
        <trans-unit id="2acd5a91faeb1fb9c21d40b879ce82bbbcf96f98" translate="yes" xml:space="preserve">
          <source>it provides access to every part of the DOM (unlike eg. SimpleXml, which ignores some of the lesser known XML features)</source>
          <target state="translated">它提供了对DOM的每一个部分的访问(与SimpleXml不同,SimpleXml忽略了一些不太为人所知的XML特征</target>
        </trans-unit>
        <trans-unit id="6478e095583c0555f703929b4a75f5be57f03aff" translate="yes" xml:space="preserve">
          <source>it's OO PHP (and allows me to subclass it)</source>
          <target state="translated">它是OO PHP(并且允许我对它进行子类化)。</target>
        </trans-unit>
        <trans-unit id="da4c11ceac906e374f2b1270f8aba16b0ded1ef2" translate="yes" xml:space="preserve">
          <source>it's rather low level (which allows me to use it as a non-bloated foundation for more advanced behavior)</source>
          <target state="translated">它的水平相当低(这让我可以用它来作为一个不浮躁的基础,为更高级的行为打下基础</target>
        </trans-unit>
        <trans-unit id="f8fb16080572c5a5248ed720d5de1897d3eccaa6" translate="yes" xml:space="preserve">
          <source>phpQuery is a server-side, chainable, CSS3 selector driven Document Object Model (DOM) API based on jQuery JavaScript Library written in PHP5 and provides additional Command Line Interface (CLI).</source>
          <target state="translated">phpQuery是一个基于jQuery JavaScript库编写的服务器端、可链式、CSS3选择器驱动的文档对象模型(DOM)API,并提供额外的命令行接口(CLI)。</target>
        </trans-unit>
        <trans-unit id="14704b5b32c155a763a90cd2bf348e51d8711978" translate="yes" xml:space="preserve">
          <source>sabre/xml</source>
          <target state="translated">sabre/xml</target>
        </trans-unit>
        <trans-unit id="1fa25a1b1b0a0b78c16fd03b682f35fe48665c99" translate="yes" xml:space="preserve">
          <source>sabre/xml is a library that wraps and extends the XMLReader and XMLWriter classes to create a simple &quot;xml to object/array&quot; mapping system and design pattern. Writing and reading XML is single-pass and can therefore be fast and require low memory on large xml files.</source>
          <target state="translated">sabrexml是一个封装和扩展了XMLReader和XMLWriter类的库,可以创建一个简单的 &quot;xml to objectarray &quot;映射系统和设计模式。写入和读取XML是单通道的,因此在大的xml文件上,可以实现快速、低内存要求。</target>
        </trans-unit>
        <trans-unit id="2726678412f8c2f63bf25a0b979427e67317dca3" translate="yes" xml:space="preserve">
          <source>simplehtmldom.sourceforge</source>
          <target state="translated">simplehtmldom.sourceforge</target>
        </trans-unit>
        <trans-unit id="3d3fda78504589a52345e3396c32f830cf7698e2" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$results&lt;/code&gt; won't be modified and you can reuse the result set again and again, perhaps somebody with much more knowledge can clear this up a bit, but it's basically like this from what I've found.</source>
          <target state="translated">则 &lt;code&gt;$results&lt;/code&gt; 不会被修改，您可以一次又一次地重用结果集，也许有些知识渊博的人可以将其清除一些，但是从我发现的结果来看，基本上是这样的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
