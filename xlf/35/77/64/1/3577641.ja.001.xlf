<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3577641">
    <body>
      <group id="3577641">
        <trans-unit id="bd1c16acfa3e04178a7c75f46da4c487e96db82d" translate="yes" xml:space="preserve">
          <source>3rd Party Libraries (libxml based)</source>
          <target state="translated">サードパーティライブラリ (libxml ベース)</target>
        </trans-unit>
        <trans-unit id="3f03912557d9e8cb0d58bb70f44693ee64e86830" translate="yes" xml:space="preserve">
          <source>3rd-Party (not libxml-based)</source>
          <target state="translated">サードパーティ (libxml ベースではない)</target>
        </trans-unit>
        <trans-unit id="544f420802f1b7f4381cde62a46a89f0fdd4320a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; (not updated for years)</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; （何年も更新されません）</target>
        </trans-unit>
        <trans-unit id="a79bf2782f9fde4ac3500bc5190a56bc3cb61962" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; and &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; are extremely similar in replicating the fluent jQuery API. That's also why they're two of the easiest approaches to &lt;em&gt;properly&lt;/em&gt; parse HTML in PHP.</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt;と&lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;は、流暢なjQuery APIの複製において非常に似ています。 これが、PHPでHTMLを&lt;em&gt;適切に&lt;/em&gt;解析する最も簡単な方法の2つである理由でもあります。</target>
        </trans-unit>
        <trans-unit id="0fdffada957220d6a8a6ae26cb48926b77945a9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pear.php.net/package/XML_HTMLSax&quot;&gt;&lt;code&gt;XML_HTMLSax&lt;/code&gt;&lt;/a&gt; is rather stable - even if it's not maintained any more. Another option could be to pipe you HTML through &lt;a href=&quot;http://docs.php.net/manual/en/book.tidy.php&quot;&gt;Html Tidy&lt;/a&gt; and then parse it with standard XML tools.</source>
          <target state="translated">&lt;a href=&quot;http://pear.php.net/package/XML_HTMLSax&quot;&gt; &lt;code&gt;XML_HTMLSax&lt;/code&gt; &lt;/a&gt;はかなり安定しています-それ以上メンテナンスされていなくても。 別のオプションは、 &lt;a href=&quot;http://docs.php.net/manual/en/book.tidy.php&quot;&gt;HTML Tidy&lt;/a&gt;を介してHTMLをパイプ処理し、標準のXMLツールで解析することです。</target>
        </trans-unit>
        <trans-unit id="d60f1b3d0678fe59836a8b6de9a8e467b681d2ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://scraperwiki.com/api/1.0&quot;&gt;ScraperWiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://scraperwiki.com/api/1.0&quot;&gt;ScraperWiki&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b7bf893d7fcdef1f2129df3b54a4823ab40bf3b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/monkeysuffrage/advanced_html_dom&quot;&gt;Advanced Html Dom&lt;/a&gt; is a simple HTML &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; replacement that offers the same interface, but it's DOM-based which means none of the associated memory issues occur.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/monkeysuffrage/advanced_html_dom&quot;&gt;Advanced Html Dom&lt;/a&gt;は、同じインターフェースを提供する単純なHTML &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOMの&lt;/a&gt;代替品ですが、DOMベースであるため、関連するメモリの問題は発生しません。</target>
        </trans-unit>
        <trans-unit id="63814451d23d80a4e01cf7d057d50122fed02b7f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/search?q=DOM+HTML+[PHP]&amp;amp;submit=search&quot;&gt;How to use the DOM extension has been covered extensively on StackOverflow&lt;/a&gt;, so if you choose to use it, you can be sure most of the issues you run into can be solved by searching/browsing Stack Overflow.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/search?q=DOM+HTML+[PHP]&amp;amp;submit=search&quot;&gt;DOM拡張機能の使用方法はStackOverflow&lt;/a&gt;で広くカバーされているため、使用することを選択した場合、スタックオーバーフローを検索/参照することで、発生した問題のほとんどを解決できると確信できます。</target>
        </trans-unit>
        <trans-unit id="1e8d52f8b266675024c8a2025e5d5aff62075d2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://thomas.weinert.info/FluentDOM/&quot;&gt;FluentDom&lt;/a&gt; - &lt;a href=&quot;https://github.com/ThomasWeinert/FluentDOM&quot;&gt;Repo&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://thomas.weinert.info/FluentDOM/&quot;&gt;FluentDom-リポジトリ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b87824cf6357505f2dd7bdd0cb025c91c9845e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$results&lt;/code&gt; now contains the result set for &lt;code&gt;input[name='forename']&lt;/code&gt; NOT the original query &lt;code&gt;&quot;div p&quot;&lt;/code&gt; this tripped me up a lot, what I found was that &lt;em&gt;QueryPath&lt;/em&gt; tracks the filters and finds and everything which modifies your results and stores them in the object.  you need to do this instead</source>
          <target state="translated">&lt;code&gt;$results&lt;/code&gt; に &lt;code&gt;input[name='forename']&lt;/code&gt; の結果セットが含まれるようになりました。元のクエリ &lt;code&gt;&quot;div p&quot;&lt;/code&gt; ません。これにより、私は多くの問題を&lt;em&gt;引き起こし&lt;/em&gt;ました&lt;em&gt;。QueryPath&lt;/em&gt;がフィルターを追跡し、結果とストアを変更するすべてを追跡することがわかりましたオブジェクト内のそれら。 代わりにこれを行う必要があります</target>
        </trans-unit>
        <trans-unit id="5a16f3b4ff2ed4ef8a15b2a2e40067147b5befb0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;QueryPath&lt;/em&gt; is good, but be careful of &quot;tracking state&quot; cause if you didn't realise what it means, it can mean you waste a lot of debugging time trying to find out what happened and why the code doesn't work.</source>
          <target state="translated">&lt;em&gt;QueryPath&lt;/em&gt;は適切ですが、「追跡状態」の原因に注意してください。意味がわからない場合は、何が起こっているのか、なぜコードが機能しないのかを調べるためにデバッグに多くの時間を&lt;em&gt;費やす&lt;/em&gt;可能性があります。</target>
        </trans-unit>
        <trans-unit id="d9c38fd9cac3bee2d6ed70531b6fb14f6245a91e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Renamed 'select', for obvious reasons&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;明らかな理由により、「select」に名前が変更されました&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1759c585e41793ef285aed2e9382f1df5f3a5512" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Renamed 'void', since 'empty' is a reserved word in PHP&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;「空」はPHPの予約語であるため、「void」に改名&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="749383e2d1cd518a40c891b7239af37b051d6989" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The library also includes its own zero-configuration autoloader for PSR-0 compatible libraries. The example included should work out of the box without any additional configuration. Alternatively, you can use it with composer.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ライブラリには、PSR-0互換ライブラリ用の独自のゼロ設定オートローダーも含まれています。&lt;/em&gt; &lt;em&gt;含まれている例は、追加の構成なしでそのまま使用できます。&lt;/em&gt; &lt;em&gt;または、composerで使用することもできます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="427d269cef16d7dd435f53adf9f53c88581fff03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40560fc8e231140d461163449e51ae367fdeafa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples for QueryPath&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;QueryPathの例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e306e3e190d2a70f49058d00b1b093fcf6837564" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I actually have this &lt;a href=&quot;http://fossil.include-once.org/streamtuner2/&quot;&gt;app&lt;/a&gt;, where I employ XML parsing and regular expressions alternatively. Just last week the PyQuery parsing broke, and the regex still worked. Yes weird, and I can't explain it myself. But so it happened.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;私は実際にこの&lt;a href=&quot;http://fossil.include-once.org/streamtuner2/&quot;&gt;アプリを&lt;/a&gt;持っています。XML解析と正規表現を交互に使用しています。 ちょうど先週、PyQueryの解析が失敗し、正規表現はまだ機能していました。 はい、奇妙で、私はそれを自分で説明することはできません。 しかし、それは起こりました。</target>
        </trans-unit>
        <trans-unit id="6d72dd9553207dcc429f79cdba7b6b07adfa5efb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why you shouldn't and &lt;em&gt;when you should&lt;/em&gt; use regular expressions?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;なぜ正規表現&lt;em&gt;を&lt;/em&gt;使用すべきではなく、 &lt;em&gt;いつ&lt;/em&gt;使用&lt;em&gt;すべき&lt;/em&gt;ですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbfce2e86e47fefb989be5da4568b10c8adce6e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phpQuery or QueryPath?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;phpQueryまたはQueryPath？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cae4698fc621dfc4ebc96ae78db8d2cbd4e5ad8c" translate="yes" xml:space="preserve">
          <source>A HTML DOM parser written in PHP&amp;nbsp;5+ that lets you manipulate HTML in a very easy way!</source>
          <target state="translated">PHP 5以降で記述されたHTML DOMパーサー。HTMLを非常に簡単に操作できます。</target>
        </trans-unit>
        <trans-unit id="f5c7b3438f58d5c6af7e2b7180f26f57170d8651" translate="yes" xml:space="preserve">
          <source>A HTML beautifier (like HTML Tidy)</source>
          <target state="translated">HTMLの美化剤(HTML Tidyのようなもの</target>
        </trans-unit>
        <trans-unit id="664ce6056bbe5b087cfd9fbfb8122d8d3f7e4fd7" translate="yes" xml:space="preserve">
          <source>A Python and PHP implementations of a HTML parser based on the WHATWG HTML5 specification for maximum compatibility with major desktop web browsers.</source>
          <target state="translated">WHATWG HTML5仕様に基づいたHTMLパーサーのPythonとPHPによる実装で、主要なデスクトップWebブラウザとの互換性を最大限に高めています。</target>
        </trans-unit>
        <trans-unit id="0a002f9eab6a6a440519776a307afcbfdf2d07b8" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found at &lt;a href=&quot;https://stackoverflow.com/questions/3299033/getting-all-values-from-h1-tags-using-php/3299140#3299140&quot;&gt;getting all values from h1 tags using php&lt;/a&gt;</source>
          <target state="translated">基本的な使用例は、 &lt;a href=&quot;https://stackoverflow.com/questions/3299033/getting-all-values-from-h1-tags-using-php/3299140#3299140&quot;&gt;phpを使用してh1タグからすべての値&lt;/a&gt;を取得するときに見つけることができます</target>
        </trans-unit>
        <trans-unit id="c214664208233d4467d45fabbc658dff3316d329" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found at &lt;a href=&quot;https://stackoverflow.com/questions/4906073/a-simple-program-to-crud-node-and-node-values-of-xml-file&quot;&gt;A simple program to CRUD node and node values of xml file&lt;/a&gt; and there is &lt;a href=&quot;http://php.net/manual/en/simplexml.examples-basic.php&quot;&gt;lots of additional examples in the PHP Manual&lt;/a&gt;.</source>
          <target state="translated">基本的な使用例は&lt;a href=&quot;https://stackoverflow.com/questions/4906073/a-simple-program-to-crud-node-and-node-values-of-xml-file&quot;&gt;、XMLファイルのノードとノードの値をCRUDする単純なプログラムにあります。PHP&lt;/a&gt; &lt;a href=&quot;http://php.net/manual/en/simplexml.examples-basic.php&quot;&gt;マニュアルには、他&lt;/a&gt;にも多くの例があります 。</target>
        </trans-unit>
        <trans-unit id="d2ec9025c32d35528d4e334718e76dd987674f48" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found in &lt;a href=&quot;https://stackoverflow.com/questions/3820666/regular-expression-for-grabbing-the-href-attribute-of-an-a-element/3820783#3820783&quot;&gt;Grabbing the href attribute of an A element&lt;/a&gt; and a general conceptual overview can be found at &lt;a href=&quot;https://stackoverflow.com/questions/4979836/noob-question-about-domdocument-in-php/4983721#4983721&quot;&gt;DOMDocument in php&lt;/a&gt;</source>
          <target state="translated">基本的な使用例は&lt;a href=&quot;https://stackoverflow.com/questions/3820666/regular-expression-for-grabbing-the-href-attribute-of-an-a-element/3820783#3820783&quot;&gt;A要素のhref属性の取得に&lt;/a&gt;あり、一般的な概念の概要は&lt;a href=&quot;https://stackoverflow.com/questions/4979836/noob-question-about-domdocument-in-php/4983721#4983721&quot;&gt;phpのDOMDocumentにあります。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd1ad773e01542b3fdd423200776b4fe37d851f7" translate="yes" xml:space="preserve">
          <source>A universal tokenizer and HTML/XML/RSS DOM Parser</source>
          <target state="translated">ユニバーサルなトークナイザーと HTMLXMLRSS DOM パーサー</target>
        </trans-unit>
        <trans-unit id="2e22019c08ef666033adfcb2f0c0f12acfb35beb" translate="yes" xml:space="preserve">
          <source>Ability to manipulate elements and their attributes</source>
          <target state="translated">要素とその属性を操作する能力</target>
        </trans-unit>
        <trans-unit id="ef04526591e535436aff90c6654fecadc86c579a" translate="yes" xml:space="preserve">
          <source>Above it's a function that parses HTML by regular expression. Note that this function is very sensitive and demands that the HTML obey certain rules, but it works very well in many scenarios. If you want a simple parser, and don't want to install libraries, give this a shot:</source>
          <target state="translated">上にあるのは、正規表現で HTML を解析する関数です。この関数は非常に繊細で、HTMLが特定のルールに従うことを要求しますが、多くのシナリオで非常にうまく動作することに注意してください。シンプルなパーサーが必要で、ライブラリをインストールする必要がないのであれば、これを試してみてください。</target>
        </trans-unit>
        <trans-unit id="b515c9a3b099e8dbc88c77e08620321b4e837112" translate="yes" xml:space="preserve">
          <source>Again, I would not recommend this parser. It is rather slow with high CPU usage. There is also no function to clear memory of created DOM objects. These problems scale particularly with nested loops. The documentation itself is inaccurate and misspelled, with no responses to fixes since 14 Apr 16.</source>
          <target state="translated">繰り返しになりますが、私はこのパーサーをお勧めしません。CPU使用率が高く、かなり遅いです。また、作成された DOM オブジェクトのメモリをクリアする機能もありません。これらの問題は特に入れ子になったループで大きくなります。ドキュメント自体が不正確で誤字脱字が多く、16年4月14日以降、修正への回答がありません。</target>
        </trans-unit>
        <trans-unit id="1ec510988bdc89bf9bd7b325c2f2553b61212a2b" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html&quot;&gt;Html The Cthulhu Wayの解析&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="d8cf1b78bb2f209698c6cdb9597abb54e96eafd6" translate="yes" xml:space="preserve">
          <source>Also see: &lt;a href=&quot;https://github.com/electrolinux/phpquery&quot;&gt;https://github.com/electrolinux/phpquery&lt;/a&gt;</source>
          <target state="translated">こちらもご覧ください： &lt;a href=&quot;https://github.com/electrolinux/phpquery&quot;&gt;https&lt;/a&gt; : //github.com/electrolinux/phpquery</target>
        </trans-unit>
        <trans-unit id="7d2a161c418bdf05eb381f6d5ea1c2d6456c164f" translate="yes" xml:space="preserve">
          <source>An HTML DOM parser written in PHP5+ lets you manipulate HTML in a very easy way!</source>
          <target state="translated">PHP5+で書かれたHTMLのDOMパーサーで、HTMLを簡単に操作できます。</target>
        </trans-unit>
        <trans-unit id="144401da89869b09220cb2726f32caf87093fc51" translate="yes" xml:space="preserve">
          <source>And here's &lt;a href=&quot;http://www.ibm.com/developerworks/opensource/library/os-php-querypath/index.html?S_TACT=105AGX01&amp;amp;S_CMP=HP&quot;&gt;a comprehensive QueryPath introduction&lt;/a&gt;.</source>
          <target state="translated">そして&lt;a href=&quot;http://www.ibm.com/developerworks/opensource/library/os-php-querypath/index.html?S_TACT=105AGX01&amp;amp;S_CMP=HP&quot;&gt;、これが包括的なQueryPathの紹介&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a46b8d7cd67f87500b5d7718588d2c557ece05e9" translate="yes" xml:space="preserve">
          <source>And lastly, for e&lt;em&gt;xtremely simple tasks&lt;/em&gt; like extracting &amp;lt;img src= urls, they are in fact a probable tool. The speed advantage over SGML/XML parsers mostly just comes to play for these very basic extraction procedures.</source>
          <target state="translated">そして最後に、&amp;lt;img src = urlの抽出などの&lt;em&gt;非常に単純なタスクの&lt;/em&gt;場合、それらは実際にありそうなツールです。 SGML / XMLパーサーに対する速度の利点は、ほとんどの場合、これらの非常に基本的な抽出手順で発揮されます。</target>
        </trans-unit>
        <trans-unit id="c2feade56d00684694a9d9e01315c66714df0c54" translate="yes" xml:space="preserve">
          <source>And while I miss the ability to use CSS selectors for &lt;code&gt;DOMDocument&lt;/code&gt;, there is a rather simple and convenient way to add this feature: subclassing the &lt;code&gt;DOMDocument&lt;/code&gt; and adding JS-like &lt;code&gt;querySelectorAll&lt;/code&gt; and &lt;code&gt;querySelector&lt;/code&gt; methods to your subclass.</source>
          <target state="translated">また、 &lt;code&gt;DOMDocument&lt;/code&gt; にCSSセレクターを使用する機能はあり &lt;code&gt;querySelector&lt;/code&gt; 、 &lt;code&gt;DOMDocument&lt;/code&gt; をサブクラス化し、JSのような &lt;code&gt;querySelectorAll&lt;/code&gt; およびquerySelectorメソッドをサブクラスに追加するという、この機能を追加するかなり単純で便利な方法があります。</target>
        </trans-unit>
        <trans-unit id="b2352cb26b5e77a9dad0e37a6ac99e7163a1c86d" translate="yes" xml:space="preserve">
          <source>Another option you can try is &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;. It's inspired by jQuery, but on the server in PHP and used in &lt;a href=&quot;http://en.wikipedia.org/wiki/Drupal&quot;&gt;Drupal&lt;/a&gt;.</source>
          <target state="translated">試すことができる別のオプションは&lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;です。 これはjQueryに触発されたものですが、PHPのサーバー上にあり、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Drupal&quot;&gt;Drupal&lt;/a&gt;で使用されています。</target>
        </trans-unit>
        <trans-unit id="cba81c44dfc3d4be82ed0b3e1b1de3b4a22126bd" translate="yes" xml:space="preserve">
          <source>Basically you first create a queryable DOM tree from an HTML string:</source>
          <target state="translated">基本的には、まず HTML 文字列からクエリ可能な DOM ツリーを作成します。</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="7aa83623e4641c12a129d48c3ef4ede02906c309" translate="yes" xml:space="preserve">
          <source>But to your specific problem, you should take a look at this project: &lt;a href=&quot;http://fivefilters.org/content-only/&quot;&gt;http://fivefilters.org/content-only/&lt;/a&gt; -- it's a modified version of the &lt;a href=&quot;http://lab.arc90.com/2009/03/02/readability/&quot;&gt;Readability&lt;/a&gt; algorithm, which is designed to extract just the textual content (not headers and footers) from a page.</source>
          <target state="translated">しかし、特定の問題については、このプロジェクトを確認する必要があります： &lt;a href=&quot;http://fivefilters.org/content-only/&quot;&gt;http&lt;/a&gt; : //fivefilters.org/content-only/-これは、ヘッダーではなくテキストコンテンツのみを抽出するように設計された、 &lt;a href=&quot;http://lab.arc90.com/2009/03/02/readability/&quot;&gt;読みやすさ&lt;/a&gt;アルゴリズムの修正バージョンですおよびフッター）から。</target>
        </trans-unit>
        <trans-unit id="c34ef7238086ad5070c51839516f68c811e10bf0" translate="yes" xml:space="preserve">
          <source>Can perform advanced CSS3-like queries on elements (like jQuery -- namespaces supported)</source>
          <target state="translated">要素に対して高度な CSS3 ライクなクエリを実行することができます (jQuery のように --名前空間をサポートしています)</target>
        </trans-unit>
        <trans-unit id="a1a5d5d399ebd0632976f266a1441e08ad47ca06" translate="yes" xml:space="preserve">
          <source>Consider that making a somewhat dependable HTML extraction regex:</source>
          <target state="translated">多少頼りになるHTML抽出正規表現を作ることを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="61f6f421ef32670498c220ee8ee339df076a5ad9" translate="yes" xml:space="preserve">
          <source>DOM</source>
          <target state="translated">DOM</target>
        </trans-unit>
        <trans-unit id="55c9f512afeeb3355d19924f291d88cec7fe29e2" translate="yes" xml:space="preserve">
          <source>DOM is capable of parsing and modifying real world (broken) HTML and it can do &lt;a href=&quot;http://schlitt.info/opensource/blog/0704_xpath.html&quot;&gt;XPath queries&lt;/a&gt;. It is based on &lt;a href=&quot;http://xmlsoft.org/html/libxml-HTMLparser.html&quot;&gt;libxml&lt;/a&gt;.</source>
          <target state="translated">DOMは、実世界の（壊れた）HTMLを解析および変更でき、 &lt;a href=&quot;http://schlitt.info/opensource/blog/0704_xpath.html&quot;&gt;XPathクエリを実行でき&lt;/a&gt;ます。 &lt;a href=&quot;http://xmlsoft.org/html/libxml-HTMLparser.html&quot;&gt;libxmlに&lt;/a&gt;基づいています 。</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="28f67bdf45517367ca4d6f904c2f8392f764b158" translate="yes" xml:space="preserve">
          <source>Example use :</source>
          <target state="translated">使用例 .</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="12d9de7e25a720caf19e093a74306cc9a4e7c9da" translate="yes" xml:space="preserve">
          <source>Extensible</source>
          <target state="translated">Extensible</target>
        </trans-unit>
        <trans-unit id="52edc154bfd85973b447708309453d1e0d5f9e75" translate="yes" xml:space="preserve">
          <source>Extract content from HTML:</source>
          <target state="translated">HTMLからコンテンツを抽出します。</target>
        </trans-unit>
        <trans-unit id="e4f2ed31239f8d0e814fac030378d9eb490bf0be" translate="yes" xml:space="preserve">
          <source>Extract contents from HTML in a single line.</source>
          <target state="translated">HTMLから1行で内容を抽出します。</target>
        </trans-unit>
        <trans-unit id="2fe336188376aed8e3f768179ec8a4f84d70f80c" translate="yes" xml:space="preserve">
          <source>Fast and Easy</source>
          <target state="translated">早くて簡単</target>
        </trans-unit>
        <trans-unit id="a7efc89443fd2e4cbb28e16621f9b53f95fe8423" translate="yes" xml:space="preserve">
          <source>Find tags on an HTML page with selectors just like jQuery.</source>
          <target state="translated">jQueryと同じようにセレクタを使ってHTMLページのタグを検索します。</target>
        </trans-unit>
        <trans-unit id="149712bfea49caa6ead7b107cba118d9c4a2fc2c" translate="yes" xml:space="preserve">
          <source>First off, a common misnomer: Regexps are not for &lt;em&gt;&quot;&lt;strong&gt;parsing&lt;/strong&gt;&quot;&lt;/em&gt; HTML. Regexes can however &lt;em&gt;&quot;&lt;strong&gt;extract&lt;/strong&gt;&quot;&lt;/em&gt; data. Extracting is what they're made for. The major drawback of regex HTML extraction over proper SGML toolkits or baseline XML parsers are their syntactic effort and varying reliability.</source>
          <target state="translated">まず、よくある誤解：正規表現はHTMLを&lt;em&gt;「 &lt;strong&gt;解析&lt;/strong&gt; 」する&lt;/em&gt;ためのものではありません。 ただし、正規表現はデータを&lt;em&gt;「 &lt;strong&gt;抽出&lt;/strong&gt; 」&lt;/em&gt;できます。 抽出は、彼らのために作られたものです。 適切なSGMLツールキットまたはベースラインXMLパーサーに対する正規表現のHTML抽出の主な欠点は、構文上の労力とさまざまな信頼性です。</target>
        </trans-unit>
        <trans-unit id="dfce008c9e988193c2c7cc30fbe30b0aea469a5f" translate="yes" xml:space="preserve">
          <source>FluentDOM provides a jQuery-like fluent XML interface for the DOMDocument in PHP. Selectors are written in XPath or CSS (using a CSS to XPath converter). Current versions extend the DOM implementing standard interfaces and add features from the DOM Living Standard. FluentDOM can load formats like JSON, CSV, JsonML, RabbitFish and others. Can be installed via Composer.</source>
          <target state="translated">FluentDOM は、PHP の DOMDocument のための jQuery ライクな流暢な XML インターフェースを提供します。セレクタは XPath または CSS (CSS から XPath へのコンバータを使用)で記述されます。現在のバージョンでは、標準的なインターフェイスを実装する DOM を拡張し、DOM Living Standard の機能を追加しています。FluentDOMはJSON、CSV、JsonML、RabbitFishなどのフォーマットを読み込むことができます。Composerからインストールできます。</target>
        </trans-unit>
        <trans-unit id="11078285da49b0134a3aebf9e6a39b3e548b91e2" translate="yes" xml:space="preserve">
          <source>FluidXML</source>
          <target state="translated">FluidXML</target>
        </trans-unit>
        <trans-unit id="85efe7a663e33eef32d5be3e18debc0c1f84672d" translate="yes" xml:space="preserve">
          <source>FluidXML is a PHP library for manipulating XML with a concise and fluent API.
  It leverages XPath and the fluent programming pattern to be fun and effective.</source>
          <target state="translated">FluidXMLは、簡潔で流暢なAPIでXMLを操作するためのPHPライブラリです。XPath と流暢なプログラミングパターンを活用して、楽しくて効果的です。</target>
        </trans-unit>
        <trans-unit id="f3ea98adb29e96c7277c98baf79783ffd4939bc8" translate="yes" xml:space="preserve">
          <source>For 1a and 2: I would vote for the new Symfony Componet class DOMCrawler ( &lt;a href=&quot;http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/&quot;&gt;DomCrawler&lt;/a&gt; ).
This class allows queries similar to CSS Selectors. Take a look at this presentation for real-world examples: &lt;a href=&quot;http://www.slideshare.net/fabpot/news-of-the-symfony2-world&quot;&gt;news-of-the-symfony2-world&lt;/a&gt;.</source>
          <target state="translated">1aと2の場合：新しいSymfony ComponetクラスDOMCrawler（ &lt;a href=&quot;http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/&quot;&gt;DomCrawler&lt;/a&gt; ）に投票します。 このクラスにより、CSSセレクターと同様のクエリが可能になります。 実際の例については、このプレゼンテーションを&lt;a href=&quot;http://www.slideshare.net/fabpot/news-of-the-symfony2-world&quot;&gt;ご覧ください&lt;/a&gt; ： news-of-the-symfony2-world 。</target>
        </trans-unit>
        <trans-unit id="019b00ae67ed9f11eae28c6c16dcb5be88663ba4" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML5&quot;&gt;HTML5&lt;/a&gt;, html5 lib has been abandoned for years now. The only HTML5 library I can find with a recent update and maintenance records is &lt;a href=&quot;https://github.com/Masterminds/html5-php/releases/1.0.0-beta1&quot;&gt;html5-php&lt;/a&gt; which was just brought to beta 1.0 a little over a week ago.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML5&quot;&gt;HTML5の&lt;/a&gt;場合、html5 libは何年もの間放棄されてきました。 最近の更新とメンテナンスの記録で私が見つけることができる唯一のHTML5ライブラリは、1 &lt;a href=&quot;https://github.com/Masterminds/html5-php/releases/1.0.0-beta1&quot;&gt;か月&lt;/a&gt;以上前にベータ1.0に移行したhtml5-phpです。</target>
        </trans-unit>
        <trans-unit id="0c7b690295ff028bfb68ffa343e78b4ca38a4e07" translate="yes" xml:space="preserve">
          <source>For HTML parsing :</source>
          <target state="translated">HTML 解析のための .</target>
        </trans-unit>
        <trans-unit id="dc9166e6725c73ab185eec670858a82b9a1165c0" translate="yes" xml:space="preserve">
          <source>For further information on the differences see &lt;a href=&quot;http://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath&quot;&gt;this comparison on the wayback machine from tagbyte.org&lt;/a&gt;. (Original source went missing, so here's an internet archive link. Yes, you can still locate missing pages, people.)</source>
          <target state="translated">違いの詳細については&lt;a href=&quot;http://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath&quot;&gt;、tagbyte.orgのウェイバックマシンでのこの比較を&lt;/a&gt;参照してください。 （元のソースがなくなっていたので、ここにインターネットアーカイブリンクがあります。はい、行方不明のページを見つけることができます）。</target>
        </trans-unit>
        <trans-unit id="22d8d2b2fb6fda43308a6bf614eb0d42bca679b5" translate="yes" xml:space="preserve">
          <source>For parsing the selectors, I recommend using the very minimalistic &lt;a href=&quot;http://symfony.com/doc/current/components/css_selector.html&quot;&gt;CssSelector component&lt;/a&gt; from the &lt;a href=&quot;http://symfony.com/&quot;&gt;Symfony framework&lt;/a&gt;. This component just translates CSS selectors to XPath selectors, which can then be fed into a &lt;code&gt;DOMXpath&lt;/code&gt; to retrieve the corresponding Nodelist.</source>
          <target state="translated">セレクターの解析には、 &lt;a href=&quot;http://symfony.com/&quot;&gt;Symfonyフレームワークの&lt;/a&gt;非常に最小限の&lt;a href=&quot;http://symfony.com/doc/current/components/css_selector.html&quot;&gt;CssSelectorコンポーネント&lt;/a&gt;を使用することをお勧めします。 このコンポーネントは、CSSセレクターをXPathセレクターに変換するだけです。これをDOMXpathにフィードして、対応するノード &lt;code&gt;DOMXpath&lt;/code&gt; を取得できます。</target>
        </trans-unit>
        <trans-unit id="dd0d138f0f3d01adb6e9b2bfa7e5e1226d277ea5" translate="yes" xml:space="preserve">
          <source>Ganon</source>
          <target state="translated">Ganon</target>
        </trans-unit>
        <trans-unit id="010d64aa6bcaec1c43df7f15b6e6795eaba5e6de" translate="yes" xml:space="preserve">
          <source>Generally QueryPath is better suited for manipulation of documents. While phpQuery also implements some pseudo AJAX methods (just HTTP requests) to more closely resemble jQuery. It is said that phpQuery is often faster than QueryPath (because of fewer overall features).</source>
          <target state="translated">一般的にQueryPathはドキュメントの操作に適しています。一方で、phpQueryはjQueryに近い形でいくつかの疑似AJAXメソッド(HTTPリクエストのみ)を実装しています。phpQueryはQueryPathよりも高速であることが多いと言われています(全体的な機能が少ないため)。</target>
        </trans-unit>
        <trans-unit id="d33a71599358dd446b3a5c5bbb17eb6a539802b6" translate="yes" xml:space="preserve">
          <source>HTML 5</source>
          <target state="translated">HTML5</target>
        </trans-unit>
        <trans-unit id="2481298ff8cb8b47dd8d49e8f6bf9293936053cb" translate="yes" xml:space="preserve">
          <source>HTML parsers already know the syntactical rules of HTML. Regular expressions have to be taught for each new RegEx you write. RegEx are fine in some cases, but it really depends on your use-case.</source>
          <target state="translated">HTML パーサーは HTML の構文ルールをすでに知っています。正規表現は、新しい RegEx を書くたびに教えなければなりません。RegEx は場合によっては問題ありませんが、ユースケースに依存します。</target>
        </trans-unit>
        <trans-unit id="6ef2488e29db96459d8f0a2f4afd555a7950eb39" translate="yes" xml:space="preserve">
          <source>Here's the github repo: &lt;a href=&quot;https://github.com/pwarelis/XmlExtractor&quot;&gt;XmlExtractor&lt;/a&gt;</source>
          <target state="translated">これがgithubリポジトリです： &lt;a href=&quot;https://github.com/pwarelis/XmlExtractor&quot;&gt;XmlExtractor&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c64fd288b23d031d147bac0aa0a5b5c67e88a520" translate="yes" xml:space="preserve">
          <source>How can one parse HTML/XML and extract information from it?</source>
          <target state="translated">HTMLXMLを解析して、そこから情報を抽出するにはどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e3cc41a06f4bd11f3bf3b219f0962c8f9b07a883" translate="yes" xml:space="preserve">
          <source>How do you parse and process HTML/XML in PHP</source>
          <target state="translated">PHP で HTMLXML をパースして処理する方法</target>
        </trans-unit>
        <trans-unit id="6a227cfcf5e09a8662563ee0c093ac92c4d9a454" translate="yes" xml:space="preserve">
          <source>How to get HTML elements:</source>
          <target state="translated">HTMLの要素を取得する方法。</target>
        </trans-unit>
        <trans-unit id="4389a53129f0579ecfb989ab0d8e483e12a6aa8e" translate="yes" xml:space="preserve">
          <source>How to modify HTML elements:</source>
          <target state="translated">HTML要素を修正する方法。</target>
        </trans-unit>
        <trans-unit id="d88d96ba36436a05a8cfe468304396c953bf885c" translate="yes" xml:space="preserve">
          <source>HtmlPageDom</source>
          <target state="translated">HtmlPageDom</target>
        </trans-unit>
        <trans-unit id="c0d513d3128cbbe47a078efa90613fe568129ba7" translate="yes" xml:space="preserve">
          <source>I am not affiliated with PHP Architect or the authors.</source>
          <target state="translated">私はPHP Architectやその作者とは提携していません。</target>
        </trans-unit>
        <trans-unit id="bbcbf01f4064f686ea8722a2a29768c36f034c48" translate="yes" xml:space="preserve">
          <source>I created a library named &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;&lt;strong&gt;PHPPowertools/DOM-Query&lt;/strong&gt;&lt;/a&gt;, which allows you to crawl HTML5 and XML documents just like you do with jQuery.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;&lt;strong&gt;PHPPowertools / DOM-Query&lt;/strong&gt;&lt;/a&gt;という名前のライブラリーを作成しました。これにより、jQueryと同じようにHTML5およびXML文書をクロールできます。</target>
        </trans-unit>
        <trans-unit id="ba6b30ea78ddf3eba99914702d1561cbba328440" translate="yes" xml:space="preserve">
          <source>I generally do not recommend this parser. The codebase is horrible and the parser itself is rather slow and memory hungry. Not all jQuery Selectors (such as &lt;a href=&quot;https://api.jquery.com/child-selector/&quot;&gt;child selectors&lt;/a&gt;) are possible. Any of the libxml based libraries should outperform this easily.</source>
          <target state="translated">通常、このパーサーはお勧めしません。 コードベースは恐ろしいものであり、パーサー自体はかなり遅く、メモリを大量に消費します。 すべてのjQueryセレクター（ &lt;a href=&quot;https://api.jquery.com/child-selector/&quot;&gt;子セレクター&lt;/a&gt;など）が使用できるわけではありません。 libxmlベースのライブラリはどれも、これを簡単に上回ります。</target>
        </trans-unit>
        <trans-unit id="eb6fc4ab03473e7d17c1de5c02d235ac14fd367c" translate="yes" xml:space="preserve">
          <source>I have never used curl for the purpose but what I have learned is that curl can do the job much more efficiently and is much more solid.</source>
          <target state="translated">今までカールを目的に使ったことはありませんでしたが、学んだことは、カールの方がはるかに効率的に仕事ができて、よりしっかりしているということです。</target>
        </trans-unit>
        <trans-unit id="a95c793e7e56b31812864ca97fa71b47951770bc" translate="yes" xml:space="preserve">
          <source>I have written a general purpose XML parser that can easily handle GB files. It's based on XMLReader and it's very easy to use:</source>
          <target state="translated">GB ファイルを簡単に扱える汎用的な XML パーサーを書きました。XMLReaderをベースにしているので、とても使いやすいです。</target>
        </trans-unit>
        <trans-unit id="357606d09d492cf4482c3593cd4945b8c282bb19" translate="yes" xml:space="preserve">
          <source>I merely want to add that I personally prefer using the DOM extension and why :</source>
          <target state="translated">私は単に私が個人的にDOM拡張子を使用することを好むことを追加したいのですが、その理由は .</target>
        </trans-unit>
        <trans-unit id="339836ff45972f30237165fb9e1c7b9692b84246" translate="yes" xml:space="preserve">
          <source>I prefer using one of the &lt;a href=&quot;http://php.net/manual/en/refs.xml.php&quot;&gt;native XML extensions&lt;/a&gt; since they come bundled with PHP, are usually faster than all the 3rd party libs and give me all the control I need over the markup.</source>
          <target state="translated">PHPにバンドルされているので、 &lt;a href=&quot;http://php.net/manual/en/refs.xml.php&quot;&gt;ネイティブXML拡張機能の&lt;/a&gt; 1つを使用することを好みます。通常、すべてのサードパーティライブラリよりも高速であり、マークアップに対して必要なすべての制御を提供します。</target>
        </trans-unit>
        <trans-unit id="5d8cbf62fddda3fe5bed7b863aae097fe3f69e98" translate="yes" xml:space="preserve">
          <source>I recommend &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;PHP Simple HTML DOM Parser&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;PHP Simple HTML DOM Parser&lt;/a&gt;をお勧めします 。</target>
        </trans-unit>
        <trans-unit id="84ae9571dbd8d9c4e5f813977179983452830ffd" translate="yes" xml:space="preserve">
          <source>I've created a library called HTML5DOMDocument that is freely available at &lt;a href=&quot;https://github.com/ivopetkov/html5-dom-document-php&quot;&gt;https://github.com/ivopetkov/html5-dom-document-php&lt;/a&gt;</source>
          <target state="translated">私は&lt;a href=&quot;https://github.com/ivopetkov/html5-dom-document-php&quot;&gt;https://github.com/ivopetkov/html5-dom-document-phpで&lt;/a&gt;自由に利用できるHTML5DOMDocumentと呼ばれるライブラリを作成しました</target>
        </trans-unit>
        <trans-unit id="f1783e93efdfa64b38f9953aae0900acc436e264" translate="yes" xml:space="preserve">
          <source>I've used this in a number of tools, testing it on many different types of web pages, and I think it works great.</source>
          <target state="translated">私はこれをいくつかのツールで使用し、さまざまな種類のウェブページでテストしてきましたが、とてもうまく機能していると思います。</target>
        </trans-unit>
        <trans-unit id="de24ae92f1c60dd3b9a2acc993da1dabf7ccfff8" translate="yes" xml:space="preserve">
          <source>If you don't feel like programming PHP, you can also use Web services. In general, I found very little utility for these, but that's just me and my use cases.</source>
          <target state="translated">PHPをプログラミングする気がないのであれば、Webサービスを使うこともできます。一般的には、これらの有用性はほとんど感じられませんでしたが、それは私と私のユースケースだけです。</target>
        </trans-unit>
        <trans-unit id="54f146095c7e90652a02eaaa284db8fac07cafa2" translate="yes" xml:space="preserve">
          <source>If you prefer to use a 3rd-party lib, I'd suggest using a lib that actually uses &lt;a href=&quot;http://php.net/manual/en/book.dom.php&quot;&gt;DOM&lt;/a&gt;/&lt;a href=&quot;http://xmlsoft.org/&quot;&gt;libxml&lt;/a&gt; underneath instead of string parsing.</source>
          <target state="translated">サードパーティのlibを使用する場合は、文字列解析ではなく、実際に&lt;a href=&quot;http://php.net/manual/en/book.dom.php&quot;&gt;DOM&lt;/a&gt; / &lt;a href=&quot;http://xmlsoft.org/&quot;&gt;libxml&lt;/a&gt;を実際に使用するlibを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4547441eafff3d38922bc0db40181f5ace8b4996" translate="yes" xml:space="preserve">
          <source>If you want to spend some money, have a look at</source>
          <target state="translated">お金をかけたい方は</target>
        </trans-unit>
        <trans-unit id="66264988483b0b4b5f9a545e7d1e048b3553f2a3" translate="yes" xml:space="preserve">
          <source>If you're familiar with jQuery selector, you can use &lt;a href=&quot;https://github.com/ScarletsFiction/ScarletsQuery&quot;&gt;ScarletsQuery&lt;/a&gt; for PHP</source>
          <target state="translated">jQueryセレクターに慣れている場合は、 &lt;a href=&quot;https://github.com/ScarletsFiction/ScarletsQuery&quot;&gt;ScarletsQuery&lt;/a&gt; for PHPを使用できます。</target>
        </trans-unit>
        <trans-unit id="4d5575093d6413d3f97f557e98a63bbd8b9025e7" translate="yes" xml:space="preserve">
          <source>It also accept invalid HTML or missing quote on tag attributes.</source>
          <target state="translated">また、無効なHTMLやタグ属性の引用符の欠落も受け付けています。</target>
        </trans-unit>
        <trans-unit id="6d66305bb90d7ea542c8c6aad06e7a21d4ac7479" translate="yes" xml:space="preserve">
          <source>It also has full CSS support, including &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; extensions.</source>
          <target state="translated">また、 &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt;拡張機能を含む、CSSを完全にサポートしています。</target>
        </trans-unit>
        <trans-unit id="25432a75a0586b1da4ec0478132a4dae9bb24a9d" translate="yes" xml:space="preserve">
          <source>It really has nice features, like:</source>
          <target state="translated">本当にいい機能を持っています。</target>
        </trans-unit>
        <trans-unit id="4c5c9e5bf0835f1de708dac8dda79e1196e30c58" translate="yes" xml:space="preserve">
          <source>It supports query selectors too that I think will be extremely helpful in your case. Here is some example code:</source>
          <target state="translated">クエリセレクタもサポートしているので、あなたのケースでは非常に役立つと思います。以下にコード例を示します。</target>
        </trans-unit>
        <trans-unit id="f099bf29cecda917eab795da4d9f9293e52130c7" translate="yes" xml:space="preserve">
          <source>It takes some time to get productive with DOM, but that time is well worth it IMO. Since DOM is a language-agnostic interface, you'll find implementations in many languages, so if you need to change your programming language, chances are you will already know how to use that language's DOM API then.</source>
          <target state="translated">DOM を使って生産性を上げるには時間がかかりますが、その時間は IMO にとって十分な価値があります。DOM は言語にとらわれないインターフェースなので、多くの言語で実装されているのを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="d452f4389b55a57f93798030576c7607d916d482" translate="yes" xml:space="preserve">
          <source>It treats DOM elements in an object-oriented way, and the new iteration has a lot of coverage for non-compliant code. There are also some great functions like you'd see in JavaScript, such as the &quot;find&quot; function, which will return all instances of elements of that tag name.</source>
          <target state="translated">DOM の要素をオブジェクト指向的に扱い、新しいイテレーションでは非準拠のコードを多くカバーしています。また、JavaScript で見られるような素晴らしい関数もあります。例えば、そのタグ名の要素のすべてのインスタンスを返す &quot;find&quot; 関数などです。</target>
        </trans-unit>
        <trans-unit id="f77033e3cd943fcbdc5f951c94653a819b0e7a5f" translate="yes" xml:space="preserve">
          <source>It's sometimes even advisable to pre-extract a snippet of HTML using regular expressions &lt;code&gt;/&amp;lt;!--CONTENT--&amp;gt;(.+?)&amp;lt;!--END--&amp;gt;/&lt;/code&gt; and process the remainder using the simpler HTML parser frontends.</source>
          <target state="translated">正規表現 &lt;code&gt;/&amp;lt;!--CONTENT--&amp;gt;(.+?)&amp;lt;!--END--&amp;gt;/&lt;/code&gt; を使用してHTMLのスニペットを事前に抽出し、より簡単なHTMLパーサーのフロントエンドを使用して残りを処理することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c75352eba2f1997a0100830871fe331ba99a290c" translate="yes" xml:space="preserve">
          <source>JSON and array from XML in three lines:</source>
          <target state="translated">3行でXMLからJSONと配列を取得します。</target>
        </trans-unit>
        <trans-unit id="2c86a3c52b12cd6eba84f473339f4b1433a03e0d" translate="yes" xml:space="preserve">
          <source>Just use &lt;a href=&quot;http://docs.php.net/manual/en/domdocument.loadhtml.php&quot;&gt;DOMDocument-&amp;gt;loadHTML()&lt;/a&gt; and be done with it. libxml's HTML parsing algorithm is quite good and fast, and contrary to popular belief, does not choke on malformed HTML.</source>
          <target state="translated">&lt;a href=&quot;http://docs.php.net/manual/en/domdocument.loadhtml.php&quot;&gt;DOMDocument-&amp;gt; loadHTML（）&lt;/a&gt;を使用して、 それで完了です。 libxmlのHTML解析アルゴリズムは非常に優れて高速であり、一般に信じられていることとは異なり、不正なHTMLには影響しません。</target>
        </trans-unit>
        <trans-unit id="77af834f38039e4a75c2d1af87fc51c7f4c83af5" translate="yes" xml:space="preserve">
          <source>Kindly check out this link:&lt;a href=&quot;http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/&quot;&gt;scraping-websites-with-curl&lt;/a&gt;</source>
          <target state="translated">親切にこのリンクをチェックしてください： &lt;a href=&quot;http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/&quot;&gt;scraping-websites-with-curl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df5af4eaf6333c18a92e864a88a527466c8e2a87" translate="yes" xml:space="preserve">
          <source>Last and &lt;strong&gt;least recommended&lt;/strong&gt;, you can extract data from HTML with &lt;a href=&quot;https://stackoverflow.com/search?q=regular%20expression%20tutorials&quot;&gt;regular expressions&lt;/a&gt;. In general using Regular Expressions on HTML is discouraged.</source>
          <target state="translated">最後に&lt;strong&gt;推奨される方法は&lt;/strong&gt; 、 &lt;a href=&quot;https://stackoverflow.com/search?q=regular%20expression%20tutorials&quot;&gt;正規表現を&lt;/a&gt;使用してHTMLからデータを抽出することです。 一般に、HTMLで正規表現を使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="2aba8d7afde1162b4fd4210f44e3fd0179a97e30" translate="yes" xml:space="preserve">
          <source>Many DOM traversal frontends don't reveal HTML comments &lt;code&gt;&amp;lt;!--&lt;/code&gt;, which however are sometimes the more useful anchors for extraction. In particular pseudo-HTML variations &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; or SGML residues are easy to tame with regexps.</source>
          <target state="translated">多くのDOMトラバーサルフロントエンドは、HTMLコメント &lt;code&gt;&amp;lt;!--&lt;/code&gt; 公開しませんが、抽出に役立つアンカーになる場合があります。 特に、疑似HTMLのバリエーション &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; またはSGMLの残基は、正規表現で簡単に制御できます。</target>
        </trans-unit>
        <trans-unit id="6f83c03a7d83375b8530b744da5d4e14cb773741" translate="yes" xml:space="preserve">
          <source>Minify CSS and Javascript</source>
          <target state="translated">CSS と Javascript を Minify</target>
        </trans-unit>
        <trans-unit id="627adea35309c41eae7e01931d886d77e7c41c7d" translate="yes" xml:space="preserve">
          <source>Most of the snippets you will find on the web to match markup are brittle. In most cases they are only working for a very particular piece of HTML. Tiny markup changes, like adding whitespace somewhere, or adding, or changing attributes in a tag, can make the RegEx fails when it's not properly written. You should know what you are doing before using RegEx on HTML.</source>
          <target state="translated">ウェブ上でマークアップにマッチするスニペットを見つけることができますが、ほとんどの場合、これらのスニペットはもろいものです。ほとんどの場合、これらのスニペットは特定の HTML の一部に対してのみ機能します。どこかに空白を追加したり、タグ内の属性を追加したり変更したりするような小さなマークアップの変更は、適切に記述されていないと RegEx を失敗させてしまいます。HTML で RegEx を使用する前に、自分が何をしているのかを知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="89b2f5b0133f65e45226a07f5cee8565bdcadf34" translate="yes" xml:space="preserve">
          <source>Mostly you want to use simple &lt;code&gt;#id&lt;/code&gt; and &lt;code&gt;.class&lt;/code&gt; or &lt;code&gt;DIV&lt;/code&gt; tag selectors for &lt;code&gt;-&amp;gt;find()&lt;/code&gt;. But you can also use &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; statements, which sometimes are faster. Also typical jQuery methods like &lt;code&gt;-&amp;gt;children()&lt;/code&gt; and &lt;code&gt;-&amp;gt;text()&lt;/code&gt; and particularly &lt;code&gt;-&amp;gt;attr()&lt;/code&gt; simplify extracting the right HTML snippets. (And already have their SGML entities decoded.)</source>
          <target state="translated">ほとんどの場合、単純な &lt;code&gt;#id&lt;/code&gt; と &lt;code&gt;.class&lt;/code&gt; または &lt;code&gt;DIV&lt;/code&gt; タグセレクターを &lt;code&gt;-&amp;gt;find()&lt;/code&gt; に使用します。 ただし、 &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;ステートメントを使用することもできます。 また、 &lt;code&gt;-&amp;gt;children()&lt;/code&gt; や &lt;code&gt;-&amp;gt;text()&lt;/code&gt; 、特に &lt;code&gt;-&amp;gt;attr()&lt;/code&gt; などの一般的なjQueryメソッドは、適切なHTMLスニペットの抽出を簡素化します。 （そして既にそれらのSGMLエンティティがデコードされています。）</target>
        </trans-unit>
        <trans-unit id="9031cd061d55fd09d5631c31edd51747001a785e" translate="yes" xml:space="preserve">
          <source>NOTE :</source>
          <target state="translated">ノート .</target>
        </trans-unit>
        <trans-unit id="1300a697b19e9262ea20292114599c4fd1368aef" translate="yes" xml:space="preserve">
          <source>Native XML Extensions</source>
          <target state="translated">ネイティブ XML 拡張機能</target>
        </trans-unit>
        <trans-unit id="1677e20649f0c9d5ffd70eb67cbee8c3b828533d" translate="yes" xml:space="preserve">
          <source>Never used it. Can't tell if it's any good.</source>
          <target state="translated">使ったことがない 良いものかどうかはわからない。</target>
        </trans-unit>
        <trans-unit id="62ea675f26d38d09101a41ac861850d50fba75d0" translate="yes" xml:space="preserve">
          <source>Oftentimes regular expressions can save post-processing. However HTML entities often require manual caretaking.</source>
          <target state="translated">正規表現は、しばしば後処理を省くことができます。しかし、HTML エンティティはしばしば手動での管理が必要です。</target>
        </trans-unit>
        <trans-unit id="1f83f8dcdf419895f7c7a83c7580b9a96b3f2f1c" translate="yes" xml:space="preserve">
          <source>One general approach I haven't seen mentioned here is to run HTML through &lt;a href=&quot;http://php.net/manual/en/book.tidy.php&quot;&gt;Tidy&lt;/a&gt;, which can be set to spit out guaranteed-valid XHTML. Then you can use any old XML library on it.</source>
          <target state="translated">ここで言及していない一般的なアプローチの1つは、 &lt;a href=&quot;http://php.net/manual/en/book.tidy.php&quot;&gt;Tidy&lt;/a&gt;を介してHTMLを実行することです。Tidyは 、保証された有効なXHTMLを出力するように設定できます。 その後、古いXMLライブラリを使用できます。</target>
        </trans-unit>
        <trans-unit id="578a94497cee464a3ed319fd370eec273b62e6df" translate="yes" xml:space="preserve">
          <source>Operations separated in smaller functions for easy overriding</source>
          <target state="translated">オーバーライドを容易にするために、小さな関数に分割された操作</target>
        </trans-unit>
        <trans-unit id="7ed99b9fb3a5520bfade55b9fe5642a263895c2a" translate="yes" xml:space="preserve">
          <source>PHP Architect's Guide to Webscraping with PHP</source>
          <target state="translated">PHPアーキテクトのPHPでWebscrapingするためのガイド</target>
        </trans-unit>
        <trans-unit id="2fdc33ef5621a15328fa3e4a16e51f86b20c60b0" translate="yes" xml:space="preserve">
          <source>PHP Html Parser</source>
          <target state="translated">PHP Html パーサー</target>
        </trans-unit>
        <trans-unit id="2fccda5363a87dcdb8f1237ddb0532e23fc267f7" translate="yes" xml:space="preserve">
          <source>PHP Simple HTML DOM Parser</source>
          <target state="translated">PHP シンプルな HTML DOM パーサー</target>
        </trans-unit>
        <trans-unit id="d4f4d957c818e56ebc312e877f197ce68488f02a" translate="yes" xml:space="preserve">
          <source>PHPHtmlParser is a simple, flexible, html parser which allows you to select tags using any css selector, like jQuery. The goal is to assiste in the development of tools which require a quick, easy way to scrap html, whether it's valid or not! This project was original supported by sunra/php-simple-html-dom-parser but the support seems to have stopped so this project is my adaptation of his previous work.</source>
          <target state="translated">PHPHtmlParserはシンプルで柔軟なhtmlパーサーで、jQueryのような任意のCSSセレクタを使ってタグを選択することができます。目標は、有効かどうかに関わらず、素早く簡単にhtmlをスクラップする方法を必要とするツールの開発を支援することです。このプロジェクトはsunraphp-simple-html-dom-parserによってサポートされていましたが、サポートは終了してしまったようなので、このプロジェクトは彼の以前の作品を私がアレンジしたものです。</target>
        </trans-unit>
        <trans-unit id="28d936680a9cd1da534d5bab294f5e31d74394d2" translate="yes" xml:space="preserve">
          <source>Parsing documents using callbacks based on current character/token</source>
          <target state="translated">現在のcharactertokenに基づいたコールバックを使用したドキュメントの解析</target>
        </trans-unit>
        <trans-unit id="a11058217485bda936a7947b3f8dea9dca2c1f2d" translate="yes" xml:space="preserve">
          <source>Proper data unescaping (in comparison to regular expression grepping)</source>
          <target state="translated">適切なデータのアンエスケープ (正規表現のグリンピングと比較して)</target>
        </trans-unit>
        <trans-unit id="a81c033171fc90b40305445d7d6e17317ebc3577" translate="yes" xml:space="preserve">
          <source>QueryPath</source>
          <target state="translated">QueryPath</target>
        </trans-unit>
        <trans-unit id="9737e148f4e81913479e1971cb61a0356bc18cc5" translate="yes" xml:space="preserve">
          <source>QueryPath also allows injecting new tags into the stream (&lt;code&gt;-&amp;gt;append&lt;/code&gt;), and later output and prettify an updated document (&lt;code&gt;-&amp;gt;writeHTML&lt;/code&gt;). It can not only parse malformed HTML, but also various XML dialects (with namespaces), and even extract data from HTML microformats (XFN, vCard).</source>
          <target state="translated">QueryPathを使用すると、新しいタグをストリームに挿入（ &lt;code&gt;-&amp;gt;append&lt;/code&gt; ）し、後で更新されたドキュメントを出力してきれいに表示できます（ &lt;code&gt;-&amp;gt;writeHTML&lt;/code&gt; ）。 不正な形式のHTMLだけでなく、さまざまなXML方言（名前空間付き）も解析でき、HTMLマイクロフォーマット（XFN、vCard）からデータを抽出することもできます。</target>
        </trans-unit>
        <trans-unit id="95df12b37819a2adfe3f819892d0d4de469b52c4" translate="yes" xml:space="preserve">
          <source>QueryPath is a PHP library for manipulating XML and HTML. It is designed to work not only with local files, but also with web services and database resources. It implements much of the jQuery interface (including CSS-style selectors), but it is heavily tuned for server-side use.  Can be installed via Composer.</source>
          <target state="translated">QueryPath は、XML や HTML を操作するための PHP ライブラリです。ローカルファイルだけでなく、ウェブサービスやデータベースリソースでも動作するように設計されています。(CSS スタイルのセレクタを含む)jQuery インターフェイスの多くを実装していますが、サーバーサイドでの使用のために大きく調整されています。Composer経由でインストールできます。</target>
        </trans-unit>
        <trans-unit id="ab140354a34bd045ff52d42f722acc1c4ffada22" translate="yes" xml:space="preserve">
          <source>Regular Expressions</source>
          <target state="translated">正規表現</target>
        </trans-unit>
        <trans-unit id="036e8223cfc6af3bc474124d436998f668393599" translate="yes" xml:space="preserve">
          <source>Require PHP 5+.</source>
          <target state="translated">PHP 5以上が必要です。</target>
        </trans-unit>
        <trans-unit id="76a7e0d2a9377458c6ef9ab5843fd65dd104d40a" translate="yes" xml:space="preserve">
          <source>ScraperWiki's external interface allows you to extract data in the form you want for use on the web or in your own applications. You can also extract information about the state of any scraper.</source>
          <target state="translated">ScraperWikiの外部インターフェイスを使用すると、Web上や独自のアプリケーションで使用するために必要な形でデータを抽出することができます。また、任意のスクレーパーの状態に関する情報を抽出することもできます。</target>
        </trans-unit>
        <trans-unit id="c9a3a60c4a1b9153da07bbc915c70995d1fcd9b2" translate="yes" xml:space="preserve">
          <source>Scraping Slashdot:</source>
          <target state="translated">スラッシュドットをスクレイピング。</target>
        </trans-unit>
        <trans-unit id="f2508406c16bde16405a9e91ecee59698672e940" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors&quot;&gt;Parsing XML documents with CSS selectors&lt;/a&gt; by Symfony's creator Fabien Potencier on his decision to create the CssSelector component for Symfony and how to use it.</source>
          <target state="translated">SymfonyのCssSelectorコンポーネントを作成する決定とその使用方法については、Symfonyの作成者Fabien Potencierによる&lt;a href=&quot;http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors&quot;&gt;CSSセレクターを使用&lt;/a&gt;したXMLドキュメントの解析も参照してください。</target>
        </trans-unit>
        <trans-unit id="20496fe36fbd9068f5e0745949f57d1a30754cf2" translate="yes" xml:space="preserve">
          <source>Simple HTML DOM is a great open-source parser:</source>
          <target state="translated">Simple HTML DOM は素晴らしいオープンソースのパーサーです。</target>
        </trans-unit>
        <trans-unit id="26acadafb8b9e27c131ae620d79467303283aec3" translate="yes" xml:space="preserve">
          <source>Simple to use alternatives &lt;code&gt;-&amp;gt;find(&quot;a img, a object, div a&quot;)&lt;/code&gt;</source>
          <target state="translated">使いやすい選択肢 &lt;code&gt;-&amp;gt;find(&quot;a img, a object, div a&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac04b5615f2819c31f2d067d7f8923ef7ff7ef21" translate="yes" xml:space="preserve">
          <source>SimpleXML is an option when you know the HTML is valid XHTML. If you need to parse broken HTML, don't even consider SimpleXml because it will choke.</source>
          <target state="translated">SimpleXMLは、HTMLが有効なXHTMLであることがわかっている場合の選択肢です。壊れたHTMLを解析する必要がある場合は、SimpleXmlを検討する必要はありません。</target>
        </trans-unit>
        <trans-unit id="8b459878d5dac1498236eb8ec705c4653131f954" translate="yes" xml:space="preserve">
          <source>SimpleXml</source>
          <target state="translated">SimpleXml</target>
        </trans-unit>
        <trans-unit id="4ab9bc94de911e1bbbc353ed1187f6ef58e14b32" translate="yes" xml:space="preserve">
          <source>Simplicity and Reliability</source>
          <target state="translated">シンプルさと信頼性</target>
        </trans-unit>
        <trans-unit id="04b1d51ec3918aabce9a1745c1f2074a9358a9f6" translate="yes" xml:space="preserve">
          <source>So please don't vote real-world considerations down, just because it doesn't match the regex=evil meme. &lt;strong&gt;But let's also not vote this up too much. It's just a sidenote for this topic.&lt;/strong&gt;</source>
          <target state="translated">だから、実際の考慮事項をregex = evil memeと一致しないという理由だけで投票しないでください。 &lt;strong&gt;しかし、これもあまり投票しないでください。&lt;/strong&gt; &lt;strong&gt;これは、このトピックの補足にすぎません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19dfc66630e4b772779cd9a262a504499ad4897f" translate="yes" xml:space="preserve">
          <source>Sort attributes, change character case, correct indentation, etc.</source>
          <target state="translated">属性の並べ替え、文字の大文字小文字の変更、インデントの修正など</target>
        </trans-unit>
        <trans-unit id="6492f0b8f23e2427034e89fba4fc783788408998" translate="yes" xml:space="preserve">
          <source>Supported methods :</source>
          <target state="translated">サポートされているメソッド .</target>
        </trans-unit>
        <trans-unit id="09c87bdf1f20971fcf51b21e634812d66a597646" translate="yes" xml:space="preserve">
          <source>Supports invalid HTML and UTF8</source>
          <target state="translated">無効なHTMLとUTF8をサポート</target>
        </trans-unit>
        <trans-unit id="1b4f692c4cf3ff10d493de7506631f00988acc7a" translate="yes" xml:space="preserve">
          <source>Supports invalid HTML.</source>
          <target state="translated">無効なHTMLをサポートしています。</target>
        </trans-unit>
        <trans-unit id="4b51562e1d3f8c3ee0992b96a3771823cf482336" translate="yes" xml:space="preserve">
          <source>Ta da!</source>
          <target state="translated">タ・ダ!</target>
        </trans-unit>
        <trans-unit id="22123f0c078e1328382bb3ba2c871a5312c22c9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Symfony&quot;&gt;Symfony&lt;/a&gt; framework has bundles which can parse the HTML, and you can use CSS style to select the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOMs&lt;/a&gt; instead of using &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Symfony&quot;&gt;Symfony&lt;/a&gt;フレームワークにはHTMLを解析できるバンドルがあり、 &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;を使用する代わりにCSSスタイルを使用して&lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;を選択できます。</target>
        </trans-unit>
        <trans-unit id="08426608042619571ea8da728effcd8bdb8ccddf" translate="yes" xml:space="preserve">
          <source>The DOM extension allows you to operate on XML documents through the DOM API with PHP 5. It is an implementation of the W3C's Document Object Model Core Level 3, a platform- and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure and style of documents.</source>
          <target state="translated">DOM 拡張モジュールを使用すると、PHP 5 の DOM API を使用して XML ドキュメントを操作できるようになります。 これは W3C の Document Object Model Core Level 3 を実装したものです。</target>
        </trans-unit>
        <trans-unit id="6af68a6b854fdff9293628426a280a5712ed9a80" translate="yes" xml:space="preserve">
          <source>The SimpleXML extension provides a very simple and easily usable toolset to convert XML to an object that can be processed with normal property selectors and array iterators.</source>
          <target state="translated">SimpleXML 拡張モジュールは、XML を通常のプロパティセレクタや配列イテレータで処理できるオブジェクトに変換するための非常にシンプルで使いやすいツールセットを提供します。</target>
        </trans-unit>
        <trans-unit id="56fa67264d262a826c383e93de2a9bbeefb33eaa" translate="yes" xml:space="preserve">
          <source>The XML Parser library is also based on libxml, and implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Simple_API_for_XML&quot;&gt;SAX&lt;/a&gt; style XML push parser. It may be a better choice for memory management than DOM or SimpleXML, but will be more difficult to work with than the pull parser implemented by XMLReader.</source>
          <target state="translated">XMLパーサーライブラリもlibxmlに基づいており、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Simple_API_for_XML&quot;&gt;SAX&lt;/a&gt;スタイルのXMLプッシュパーサーを実装しています。 DOMやSimpleXMLよりもメモリ管理に適しているかもしれませんが、XMLReaderによって実装されたプルパーサーよりも操作が難しくなります。</target>
        </trans-unit>
        <trans-unit id="b67498f486aaa11938e3847d09f2dce44e5beb65" translate="yes" xml:space="preserve">
          <source>The XMLReader extension is an XML pull parser. The reader acts as a cursor going forward on the document stream and stopping at each node on the way.</source>
          <target state="translated">XMLReader 拡張モジュールは XML プルパーサーです。リーダーは、ドキュメントストリーム上を進むカーソルとして動作し、途中で各ノードで停止します。</target>
        </trans-unit>
        <trans-unit id="daf8ea6c752ba027315c1f91a513e28bb38ce9f6" translate="yes" xml:space="preserve">
          <source>The benefit of building upon DOM/libxml is that you get good performance out of the box because you are based on a native extension. However, not all 3rd-party libs go down this route. Some of them listed below</source>
          <target state="translated">DOMlibxmlをベースに構築する利点は、ネイティブの拡張機能をベースにしているので、箱から出してすぐに良いパフォーマンスが得られることです。しかし、すべてのサードパーティのlibがこのルートを通るわけではありません。そのうちのいくつかを以下に示します。</target>
        </trans-unit>
        <trans-unit id="d8816c1d03b50b77e6e6ff51bd569066e7b5a0e5" translate="yes" xml:space="preserve">
          <source>The best method for parse xml:</source>
          <target state="translated">xmlをパースするのに最適な方法。</target>
        </trans-unit>
        <trans-unit id="4132078238d9256b003dd6494bd23513c071a209" translate="yes" xml:space="preserve">
          <source>The code below comes straight out my &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;DOM-Query library&lt;/a&gt; and uses the technique I described.</source>
          <target state="translated">以下のコードは、私の&lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;DOM-Queryライブラリー&lt;/a&gt;をそのまま使用したもので、私が説明した手法を使用しています。</target>
        </trans-unit>
        <trans-unit id="11b52d17561803fdb6224e1ca70f26a54f943a6b" translate="yes" xml:space="preserve">
          <source>The component is designed to work standalone and can be used without Symfony.</source>
          <target state="translated">このコンポーネントはスタンドアロンで動作するように設計されており、Symfony を使わずに利用することができます。</target>
        </trans-unit>
        <trans-unit id="df302445bc11b04611b1cf770aa3b7c0254ec538" translate="yes" xml:space="preserve">
          <source>The only drawback is that it will only work with PHP 5.3 or newer.</source>
          <target state="translated">唯一の欠点は、PHP 5.3以降でしか動作しないことです。</target>
        </trans-unit>
        <trans-unit id="58431aa1e93eb44c019b1578434838cf2038f96d" translate="yes" xml:space="preserve">
          <source>The resulting object contains a complete tree representation of the HTML document. It can be traversed using DOM methods. But the common approach is to use CSS selectors like in jQuery:</source>
          <target state="translated">結果として得られるオブジェクトには、HTML ドキュメントの完全なツリー表現が含まれます。これは DOM メソッドを使用してトラバースすることができます。しかし、一般的なアプローチは jQuery のような CSS セレクタを使用することです。</target>
        </trans-unit>
        <trans-unit id="f669955759ac8d7fc7074861be693d4a0720bae0" translate="yes" xml:space="preserve">
          <source>There are however specific use cases where they can help.</source>
          <target state="translated">しかし、それらが役立つ具体的な使用例があります。</target>
        </trans-unit>
        <trans-unit id="ba5cb182872adb3d586144d6a301c22c0f539179" translate="yes" xml:space="preserve">
          <source>There are many ways to process HTML/XML DOM of which most have already been mentioned. Hence, I won't make any attempt to list those myself.</source>
          <target state="translated">HTMLXML DOM を処理する方法はたくさんありますが、そのほとんどはすでに述べたとおりです。したがって、私自身がそれらをリストアップする試みはしません。</target>
        </trans-unit>
        <trans-unit id="7fc01c223fb450ac4e6ebdc77a0edd1badd8832f" translate="yes" xml:space="preserve">
          <source>There are several reasons to not parse HTML by regular expression. But, if you have total control of what HTML will be generated, then you can do with simple regular expression.</source>
          <target state="translated">正規表現でHTMLを解析しない理由はいくつかあります。しかし、どのようなHTMLが生成されるかを完全にコントロールできるのであれば、単純な正規表現でも問題ありません。</target>
        </trans-unit>
        <trans-unit id="f9a9ec64bafcc374d9945fc4204431933239630f" translate="yes" xml:space="preserve">
          <source>Third party alternatives to SimpleHtmlDom that use DOM instead of String Parsing: &lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt;, &lt;a href=&quot;http://framework.zend.com/manual/en/zend.dom.html&quot;&gt;Zend_Dom&lt;/a&gt;, &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; and &lt;a href=&quot;http://www.fluentdom.org/&quot;&gt;FluentDom&lt;/a&gt;.</source>
          <target state="translated">文字列解析の代わりにDOMを使用するSimpleHtmlDomに代わるサードパーティ： &lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; 、 &lt;a href=&quot;http://framework.zend.com/manual/en/zend.dom.html&quot;&gt;Zend_Dom&lt;/a&gt; 、 &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; 、および&lt;a href=&quot;http://www.fluentdom.org/&quot;&gt;FluentDom&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7416ebc9af5006b615b7faa1baa92773cc5eea4a" translate="yes" xml:space="preserve">
          <source>This extension lets you create XML parsers and then define handlers for different XML events. Each XML parser also has a few parameters you can adjust.</source>
          <target state="translated">この拡張機能を使用すると、XML パーサーを作成し、さまざまな XML イベント用のハンドラを定義することができます。各 XML パーサーには、調整可能ないくつかのパラメータがあります。</target>
        </trans-unit>
        <trans-unit id="68b5d2b56e9a5e9c0691dcd4f8be37ab0fb44989" translate="yes" xml:space="preserve">
          <source>This is commonly referred to as &lt;strong&gt;screen scraping&lt;/strong&gt;, by the way. The library I have used for this is &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;Simple HTML Dom Parser&lt;/a&gt;.</source>
          <target state="translated">ちなみに、これは一般に&lt;strong&gt;スクリーンスクレイピング&lt;/strong&gt;と呼ばれてい&lt;strong&gt;ます&lt;/strong&gt; 。 これに使用したライブラリは&lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;Simple HTML Dom Parser&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e850b37f770cfea1cd7f56ea9dfb592e682e301e" translate="yes" xml:space="preserve">
          <source>This library usually taking less than 1 second to process offline html.</source>
          <target state="translated">このライブラリは通常、オフラインのhtmlを処理するのに1秒もかかりません。</target>
        </trans-unit>
        <trans-unit id="2beda6ba9b12df24bc719d6612622cddbc5e8c27" translate="yes" xml:space="preserve">
          <source>This sounds like a good task description of W3C &lt;a href=&quot;http://www.w3.org/TR/xpath/&quot;&gt;XPath&lt;/a&gt; technology. It's easy to express queries like &quot;return all &lt;code&gt;href&lt;/code&gt; attributes in &lt;code&gt;img&lt;/code&gt; tags that are nested in &lt;code&gt;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;&amp;lt;baz&amp;gt; elements&lt;/code&gt;.&quot; Not being a PHP buff, I can't tell you in what form XPath may be available. If you can call an external program to process the HTML file you should be able to use a command line version of XPath.
For a quick intro, see &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;http://en.wikipedia.org/wiki/XPath&lt;/a&gt;.</source>
          <target state="translated">これは、W3C &lt;a href=&quot;http://www.w3.org/TR/xpath/&quot;&gt;XPath&lt;/a&gt;テクノロジーの優れたタスクの説明のようです。 「 &lt;code&gt;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;&amp;lt;baz&amp;gt; elements&lt;/code&gt; ネストされている &lt;code&gt;img&lt;/code&gt; タグ内のすべての &lt;code&gt;href&lt;/code&gt; 属性を返す」のようなクエリは簡単に表現できます 。 PHPの愛好家ではないため、XPathがどのような形で利用できるかはわかりません。 外部プログラムを呼び出してHTMLファイルを処理できる場合は、コマンドラインバージョンのXPathを使用できるはずです。 簡単な紹介については、 &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;http://en.wikipedia.org/wiki/XPathを&lt;/a&gt;参照してください 。</target>
        </trans-unit>
        <trans-unit id="3a0b9134ff92db59b43251ec557fed51162b65e3" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;&lt;strong&gt;Simple HTML DOM Parser&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;&lt;strong&gt;Simple HTML DOM Parserを&lt;/strong&gt;&lt;/a&gt;試す</target>
        </trans-unit>
        <trans-unit id="c6d262a8d4b5d18d3efdc5b548b97d2ba672dfe1" translate="yes" xml:space="preserve">
          <source>Under the hood, it uses &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;&lt;strong&gt;symfony/DomCrawler&lt;/strong&gt;&lt;/a&gt; for conversion of CSS selectors to &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; selectors. It always uses the same DomDocument, even when passing one object to another, to ensure decent performance.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;&lt;strong&gt;内部的&lt;/strong&gt;&lt;/a&gt;には、CSSセレクターから&lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;セレクターへの変換に&lt;strong&gt;symfony / DomCrawler&lt;/strong&gt;を使用します。 適切なパフォーマンスを確保するために、1つのオブジェクトを別のオブジェクトに渡す場合でも、常に同じDomDocumentを使用します。</target>
        </trans-unit>
        <trans-unit id="ec1764919721d724665325102a7111340d413d7f" translate="yes" xml:space="preserve">
          <source>Wa72\HtmlPageDom` is a PHP library for easy manipulation of HTML
  documents using  It requires &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;DomCrawler from Symfony2
  components&lt;/a&gt; for traversing  the
  DOM tree and extends it by adding methods for manipulating the DOM
  tree of HTML documents.</source>
          <target state="translated">Wa72 \ HtmlPageDom`は、HTMLツリーをトラバースするために&lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;Symfony2コンポーネントのDomCrawlerを&lt;/a&gt;必要とし、HTMLドキュメントのDOMツリーを操作するためのメソッドを追加することで拡張するPHPライブラリです。</target>
        </trans-unit>
        <trans-unit id="2228452e56018a71b37010bd7c5f71859651feca" translate="yes" xml:space="preserve">
          <source>We have created quite a few crawlers for our needs before. At the end of the day, it is usually simple regular expressions that do the thing best. While libraries listed above are good for the reason they are created, if you know what you are looking for, regular expressions is a safer way to go, as you can handle also non-valid &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/XHTML&quot;&gt;XHTML&lt;/a&gt; structures, which would fail, if loaded via most of the parsers.</source>
          <target state="translated">以前は、私たちのニーズに合わせてかなりの数のクローラーを作成してきました。 結局のところ、最も効果的なのは通常、単純な正規表現です。 上記のライブラリは作成されたという理由で優れていますが、探しているものがわかっている場合は、正規表現を使用する方が安全です。無効な&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/XHTML&quot;&gt;XHTML&lt;/a&gt;構造もロードできるので、ロードすると失敗します。ほとんどのパーサー経由。</target>
        </trans-unit>
        <trans-unit id="25f4d5095cb62b0b7e74915ac9d048a7b58ef20f" translate="yes" xml:space="preserve">
          <source>We might see more dedicated parsers once HTML5 is finalized. There is also a blogpost by the W3's titled &lt;a href=&quot;http://www.w3.org/QA/2008/07/html5-parsing-howto.html&quot;&gt;How-To for html 5 parsing&lt;/a&gt; that is worth checking out.</source>
          <target state="translated">HTML5が完成すると、専用のパーサーが増える可能性があります。 W3の「 &lt;a href=&quot;http://www.w3.org/QA/2008/07/html5-parsing-howto.html&quot;&gt;How-To for html 5 parsing&lt;/a&gt; 」というブログポストもチェックする価値があります。</target>
        </trans-unit>
        <trans-unit id="0a5d87433685e87a09cab5597b4bcd5803d667c8" translate="yes" xml:space="preserve">
          <source>WebServices</source>
          <target state="translated">WebServices</target>
        </trans-unit>
        <trans-unit id="dd7868492d1aa630c2532fbee868064147abaa60" translate="yes" xml:space="preserve">
          <source>What it means is that each call on the result set modifies the result set in the object, it's not chainable like in jquery where each link is a new set, you have a single set which is the results from your query and each function call modifies that single set.</source>
          <target state="translated">jqueryのように各リンクが新しいセットになるような連鎖的なものではなく、クエリの結果である1つのセットを持ち、各関数の呼び出しがその1つのセットを変更するということです。</target>
        </trans-unit>
        <trans-unit id="958c244d037d86b5bf0abe6245945f8778d00d85" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/servo-php/fluidxml&quot;&gt;&lt;strong&gt;FluidXML&lt;/strong&gt;&lt;/a&gt; you can query and iterate XML using &lt;strong&gt;XPath&lt;/strong&gt; and &lt;strong&gt;CSS Selectors&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/servo-php/fluidxml&quot;&gt;&lt;strong&gt;FluidXML&lt;/strong&gt;&lt;/a&gt;を使用すると、 &lt;strong&gt;XPath&lt;/strong&gt;および&lt;strong&gt;CSSセレクター&lt;/strong&gt;を使用してXMLを照会および反復できます。</target>
        </trans-unit>
        <trans-unit id="c133d37ec5b2dec248bc847284b37225a00466bc" translate="yes" xml:space="preserve">
          <source>XML Parser</source>
          <target state="translated">XML パーサー</target>
        </trans-unit>
        <trans-unit id="482bdc24f6af5a40a01e6c07554b2e716ffcfd71" translate="yes" xml:space="preserve">
          <source>XMLReader</source>
          <target state="translated">XMLReader</target>
        </trans-unit>
        <trans-unit id="d283a97f786ccb4fc2cde7e0509f6b68fe20c76f" translate="yes" xml:space="preserve">
          <source>XMLReader, like DOM, is based on libxml. I am not aware of how to trigger the HTML Parser Module, so chances are using XMLReader for parsing broken HTML might be less robust than using DOM where you can explicitly tell it to use libxml's HTML Parser Module.</source>
          <target state="translated">XMLReaderはDOMと同様にlibxmlをベースにしています。HTML パーサーモジュールをトリガーする方法を知らないので、壊れた HTML を解析するために XMLReader を使用することは、libxml の HTML パーサーモジュールを使用するように明示的に指示できる DOM よりもロバスト性に劣るかもしれません。</target>
        </trans-unit>
        <trans-unit id="48086d5b2c71a8118002a1eccf45fa90563bef6e" translate="yes" xml:space="preserve">
          <source>Yes you can use simple_html_dom for the purpose. However I have worked quite a lot with the simple_html_dom, particularly for web scrapping and have found it to be too vulnerable. It does the basic job but I won't recommend it anyways.</source>
          <target state="translated">はい、あなたは目的のためにsimple_html_domを使用することができます。しかし、私はsimple_html_domでかなり多くの作業をしてきました、特にウェブスクラッピングのために、それがあまりにも脆弱であることがわかりました。それは基本的な仕事をしますが、私はとにかくそれをお勧めしません。</target>
        </trans-unit>
        <trans-unit id="afacf39f9314512f8b2e4807339393ca1d74c5e5" translate="yes" xml:space="preserve">
          <source>You &lt;a href=&quot;https://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234491#4234491&quot;&gt;can write more reliable parsers&lt;/a&gt;, but writing a &lt;em&gt;complete and reliable&lt;/em&gt; custom parser with regular expressions is a waste of time when the aforementioned libraries already exist and do a much better job on this.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234491#4234491&quot;&gt;より信頼性の高いパーサーを作成でき&lt;/a&gt;ますが 、前述のライブラリがすでに存在し、これに対してはるかに優れた仕事をしている場合、正規表現を使用して&lt;em&gt;完全で信頼性の高い&lt;/em&gt;カスタムパーサーを作成するのは時間の無駄です。</target>
        </trans-unit>
        <trans-unit id="52244ade1e08c2102f754703196f53beec240409" translate="yes" xml:space="preserve">
          <source>You can then use this (still very low level) subclass as a foundation for more high level classes, intended to eg. parse very specific types of XML or add more jQuery-like behavior.</source>
          <target state="translated">そして、この(まだ非常に低レベルの)サブクラスを、より高レベルのクラスの基礎として使用することができます。</target>
        </trans-unit>
        <trans-unit id="57d9a847a211899bc4cd6fd3518ea2a538f3dd72" translate="yes" xml:space="preserve">
          <source>You can use the above for parsing HTML5, but &lt;a href=&quot;https://stackoverflow.com/questions/4029341/dom-parser-that-allows-html5-style-in-script-tag/4029412&quot;&gt;there can be quirks&lt;/a&gt; due to the markup HTML5 allows. So for HTML5 you want to consider using a dedicated parser, like</source>
          <target state="translated">上記を使用してHTML5を解析できますが、HTML5で許可されているマークアップが原因で問題が&lt;a href=&quot;https://stackoverflow.com/questions/4029341/dom-parser-that-allows-html5-style-in-script-tag/4029412&quot;&gt;発生する可能性&lt;/a&gt;があります。 したがって、HTML5では、次のような専用パーサーの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="118bdac2fe1f904ec22de8b22eed3538f08f7e63" translate="yes" xml:space="preserve">
          <source>You could try using something like &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML_Tidy&quot;&gt;HTML Tidy&lt;/a&gt; to cleanup any &quot;broken&quot; HTML and convert the HTML to XHTML, which you can then parse with a XML parser.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML_Tidy&quot;&gt;HTML Tidyの&lt;/a&gt;ようなものを使用して、「壊れた」HTMLをクリーンアップし、HTMLをXHTMLに変換してから、XMLパーサーで解析することができます。</target>
        </trans-unit>
        <trans-unit id="fa5f4b4b6cf574e2ed46980afeaa2a7beb181c3f" translate="yes" xml:space="preserve">
          <source>Zend_Dom</source>
          <target state="translated">Zend_Dom</target>
        </trans-unit>
        <trans-unit id="541d5b4dd20a949161f06bff576afd115dc27318" translate="yes" xml:space="preserve">
          <source>Zend_Dom provides tools for working with DOM documents and structures. Currently, we offer Zend_Dom_Query, which provides a unified interface for querying DOM documents utilizing both XPath and CSS selectors.</source>
          <target state="translated">Zend_Dom は、DOM ドキュメントや構造体を扱うためのツールを提供しています。これは、XPath および CSS セレクタを使用して DOM ドキュメントを問い合わせるための統一されたインターフェイスを提供します。</target>
        </trans-unit>
        <trans-unit id="0ec25b22947ac4e042b417da8d2b81bad44eaff3" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/add/&quot;&gt;$selection.add&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/add/&quot;&gt;$ selection.add&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d3ac6816be3e31697646b0d3f24a61ed10c7a2" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/addClass/&quot;&gt;$selection.addClass&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/addClass/&quot;&gt;$ selection.addClass&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a85d853e8ac9999031be082f20dd3c86b3e07d55" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/after/&quot;&gt;$selection.after&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/after/&quot;&gt;$ selection.after&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="855bb5684e5aaad04444a0bcf366e950952780f8" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/append/&quot;&gt;$selection.append&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/append/&quot;&gt;$ selection.append&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="303d76dbb2b71969494a3da3fd0e207352f68b81" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/attr/&quot;&gt;$selection.attr&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/attr/&quot;&gt;$ selection.attr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35be35f74fc5b6a7ede46666a50b8672913da309" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/before/&quot;&gt;$selection.before&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/before/&quot;&gt;$ selection.before&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1879364aaded1afd20c32ebf100fc3585e48f683" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/children/&quot;&gt;$selection.children&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/children/&quot;&gt;$ selection.children&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="678fdf480ddbd2317286e0512d39327d7446bd7b" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/closest/&quot;&gt;$selection.closest&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/closest/&quot;&gt;$ selection.closest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50da6b564af1bc96331746a72991ea045fba2992" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/contents/&quot;&gt;$selection.contents&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/contents/&quot;&gt;$ selection.contents&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52a5716ac9072af064bad7b789daadb3ef628871" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/detach/&quot;&gt;$selection.detach&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/detach/&quot;&gt;$ selection.detach&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cdeed87a0e184eeda42371e499aff6dcc08e7466" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;$selection.each&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;$ selection.each&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d78f7b714bd611131f42b9656016a521c9ee3ea3" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/empty/&quot;&gt;$selection.empty&lt;/a&gt;&lt;em&gt;(2)&lt;/em&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/empty/&quot;&gt;$ selection.empty&lt;/a&gt; &lt;em&gt;（2）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6e8102a4ebff43aa49148fd4ea1b33c02b29fd5" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/eq/&quot;&gt;$selection.eq&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/eq/&quot;&gt;$ selection.eq&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d9ee2a185ce5f56cead560d1e6223a586084cbf" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/find/&quot;&gt;$selection.find&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/find/&quot;&gt;$ selection.find&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2330f331cc5d6a73493ca3314bfdd95b0fba20e9" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/first/&quot;&gt;$selection.first&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/first/&quot;&gt;$ selection.first&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f200b75980c567c5eaef7a8096eb29ee1699ca1c" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/get/&quot;&gt;$selection.get&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/get/&quot;&gt;$ selection.get&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e76d7cf162ad4950910f97fd211357a71685955e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/insertAfter/&quot;&gt;$selection.insertAfter&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/insertAfter/&quot;&gt;$ selection.insertAfter&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b10ab7d52167901e6f202a90c53135afbe343fab" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/insertBefore/&quot;&gt;$selection.insertBefore&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/insertBefore/&quot;&gt;$ selection.insertBefore&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1116fb1f0e86324bbe307d7cfb7990cb591719e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseHTML/&quot;&gt;$.parseHTML&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseHTML/&quot;&gt;$ .parseHTML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b85b8caed5cad3a75963f879bd83444840e9fac4" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseJSON/&quot;&gt;$.parseJSON&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseJSON/&quot;&gt;$ .parseJSON&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24e21007f15fffbeb12d715b440d8dda82b0fd3e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseXML/&quot;&gt;$.parseXML&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseXML/&quot;&gt;$ .parseXML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8284a57c23d4c2602d747df3906e7d105a7ebc79" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;$&lt;/a&gt;&lt;em&gt;(1)&lt;/em&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;$&lt;/a&gt; &lt;em&gt;（1）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41f3041007fb1f1714223d7eb80831018345e0b8" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/last/&quot;&gt;$selection.last&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/last/&quot;&gt;$ selection.last&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b7c6e57b4bf72db36e41ed0f4996a878c5bfc40" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/parent/&quot;&gt;$selection.parent&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/parent/&quot;&gt;$ selection.parent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2966dfa24290fb0d5d1b2426cc2f1fd71d622a62" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/parents/&quot;&gt;$selection.parents&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/parents/&quot;&gt;$ selection.parents&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5e7046e307699d26a7d587af4df3b58264248b0" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/remove/&quot;&gt;$selection.remove&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/remove/&quot;&gt;$ selection.remove&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4558dad027c6574ab3dcfb49125d9a104ae9c7ed" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/removeAttr/&quot;&gt;$selection.removeAttr&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/removeAttr/&quot;&gt;$ selection.removeAttr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78105ee237b89523c07bd548a8d57ebac51c396d" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/removeClass/&quot;&gt;$selection.removeClass&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/removeClass/&quot;&gt;$ selection.removeClass&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8224fc75de7d512420526ac5229a3127fa84011d" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/text/&quot;&gt;$selection.text&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/text/&quot;&gt;$ selection.text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6bf903823bfa2ea35e684feeeee397f598eb071c" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/wrap/&quot;&gt;$selection.wrap&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/wrap/&quot;&gt;$ selection.wrap&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ece6afcddc52bae163f5f7ba435c9607ff7a44b9" translate="yes" xml:space="preserve">
          <source>fDOMDocument</source>
          <target state="translated">fDOMDocument</target>
        </trans-unit>
        <trans-unit id="fe8b7d5279a6e14f60beb4f954ad1e8d77ed6d3a" translate="yes" xml:space="preserve">
          <source>fDOMDocument extends the standard DOM to use exceptions at all occasions of errors instead of PHP warnings or notices. They also add various custom methods and shortcuts for convenience and to simplify the usage of DOM.</source>
          <target state="translated">fDOMDocument は標準の DOM を拡張し、PHP の警告や通知の代わりに例外を使用するようにしました。また、利便性のために様々なカスタムメソッドやショートカットを追加し、DOM の使用法を単純化しています。</target>
        </trans-unit>
        <trans-unit id="6183fbc196e925ae7677bf0da88d2d39315c592e" translate="yes" xml:space="preserve">
          <source>html5lib</source>
          <target state="translated">html5lib</target>
        </trans-unit>
        <trans-unit id="e4a3835ab80fda4ba43679f366d992ba21d09b91" translate="yes" xml:space="preserve">
          <source>iit makes optimal use of the performance advantage of the underlying C code</source>
          <target state="translated">これは、基礎となる C コードのパフォーマンスの優位性を最適に利用します。</target>
        </trans-unit>
        <trans-unit id="c52c0b0f2b1233115b4ed3459d964df89266f51d" translate="yes" xml:space="preserve">
          <source>in order to get jquery-like behaviour, you need to branch before you do a filter/modify like operation, that means it'll mirror what happens in jquery much more closely.</source>
          <target state="translated">jqueryのような動作を得るためには、filtermodifyのような操作を行う前にブランチする必要があります。</target>
        </trans-unit>
        <trans-unit id="16a2198898695f10acf40db122134ecdb1b43a35" translate="yes" xml:space="preserve">
          <source>is way less readable than a simple phpQuery or QueryPath equivalent:</source>
          <target state="translated">は、単純な phpQuery や QueryPath と同等のものよりもずっと読みにくいです。</target>
        </trans-unit>
        <trans-unit id="1e8a470cab2da73401e5efabc30513d95e8be9b3" translate="yes" xml:space="preserve">
          <source>it has a syntax used for DOM crawling that's similar to the syntax used in native Javascript.</source>
          <target state="translated">には、DOM クローリングに使用される構文があり、ネイティブ Javascript で使用される構文に似ています。</target>
        </trans-unit>
        <trans-unit id="2acd5a91faeb1fb9c21d40b879ce82bbbcf96f98" translate="yes" xml:space="preserve">
          <source>it provides access to every part of the DOM (unlike eg. SimpleXml, which ignores some of the lesser known XML features)</source>
          <target state="translated">は DOM のあらゆる部分へのアクセスを提供します (あまり知られていない XML 機能を無視する SimpleXml などとは異なります)。</target>
        </trans-unit>
        <trans-unit id="6478e095583c0555f703929b4a75f5be57f03aff" translate="yes" xml:space="preserve">
          <source>it's OO PHP (and allows me to subclass it)</source>
          <target state="translated">OO PHP (サブクラス化できる)</target>
        </trans-unit>
        <trans-unit id="da4c11ceac906e374f2b1270f8aba16b0ded1ef2" translate="yes" xml:space="preserve">
          <source>it's rather low level (which allows me to use it as a non-bloated foundation for more advanced behavior)</source>
          <target state="translated">むしろレベルが低い(だからこそ、より高度な振る舞いをするための非血の基礎として使うことができる</target>
        </trans-unit>
        <trans-unit id="f8fb16080572c5a5248ed720d5de1897d3eccaa6" translate="yes" xml:space="preserve">
          <source>phpQuery is a server-side, chainable, CSS3 selector driven Document Object Model (DOM) API based on jQuery JavaScript Library written in PHP5 and provides additional Command Line Interface (CLI).</source>
          <target state="translated">phpQueryは、PHP5で書かれたjQuery JavaScriptライブラリをベースにしたサーバーサイド、チェイン可能なCSS3セレクタ駆動のDocument Object Model (DOM)APIであり、追加のコマンドラインインターフェイス(CLI)を提供しています。</target>
        </trans-unit>
        <trans-unit id="14704b5b32c155a763a90cd2bf348e51d8711978" translate="yes" xml:space="preserve">
          <source>sabre/xml</source>
          <target state="translated">sabre/xml</target>
        </trans-unit>
        <trans-unit id="1fa25a1b1b0a0b78c16fd03b682f35fe48665c99" translate="yes" xml:space="preserve">
          <source>sabre/xml is a library that wraps and extends the XMLReader and XMLWriter classes to create a simple &quot;xml to object/array&quot; mapping system and design pattern. Writing and reading XML is single-pass and can therefore be fast and require low memory on large xml files.</source>
          <target state="translated">sabrexmlは、XMLReaderとXMLWriterクラスをラップして拡張し、シンプルな &quot;xml to objectarray &quot;マッピングシステムとデザインパターンを作成するライブラリです。XMLの書き込みと読み込みはシングルパスで行われるため、大容量のXMLファイルでは高速で低メモリを必要とします。</target>
        </trans-unit>
        <trans-unit id="2726678412f8c2f63bf25a0b979427e67317dca3" translate="yes" xml:space="preserve">
          <source>simplehtmldom.sourceforge</source>
          <target state="translated">simplehtmldom.sourceforge</target>
        </trans-unit>
        <trans-unit id="3d3fda78504589a52345e3396c32f830cf7698e2" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$results&lt;/code&gt; won't be modified and you can reuse the result set again and again, perhaps somebody with much more knowledge can clear this up a bit, but it's basically like this from what I've found.</source>
          <target state="translated">その後、 &lt;code&gt;$results&lt;/code&gt; は変更されず、結果セットを何度も再利用できます。おそらく、より知識のある人がこれを少しクリアできるかもしれませんが、基本的には、私が見つけたものからはこのようなものです。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
