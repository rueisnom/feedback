<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/3577641">
    <body>
      <group id="3577641">
        <trans-unit id="bd1c16acfa3e04178a7c75f46da4c487e96db82d" translate="yes" xml:space="preserve">
          <source>3rd Party Libraries (libxml based)</source>
          <target state="translated">Библиотеки сторонних организаций (на основе libxml)</target>
        </trans-unit>
        <trans-unit id="3f03912557d9e8cb0d58bb70f44693ee64e86830" translate="yes" xml:space="preserve">
          <source>3rd-Party (not libxml-based)</source>
          <target state="translated">сторонний (не на основе libxml)</target>
        </trans-unit>
        <trans-unit id="544f420802f1b7f4381cde62a46a89f0fdd4320a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; (not updated for years)</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; (не обновлялся годами)</target>
        </trans-unit>
        <trans-unit id="a79bf2782f9fde4ac3500bc5190a56bc3cb61962" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; and &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; are extremely similar in replicating the fluent jQuery API. That's also why they're two of the easiest approaches to &lt;em&gt;properly&lt;/em&gt; parse HTML in PHP.</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; и &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; чрезвычайно похожи в репликации свободно распространяемого API jQuery. Именно поэтому они являются двумя из самых простых подходов для &lt;em&gt;правильного&lt;/em&gt; анализа HTML в PHP.</target>
        </trans-unit>
        <trans-unit id="0fdffada957220d6a8a6ae26cb48926b77945a9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://pear.php.net/package/XML_HTMLSax&quot;&gt;&lt;code&gt;XML_HTMLSax&lt;/code&gt;&lt;/a&gt; is rather stable - even if it's not maintained any more. Another option could be to pipe you HTML through &lt;a href=&quot;http://docs.php.net/manual/en/book.tidy.php&quot;&gt;Html Tidy&lt;/a&gt; and then parse it with standard XML tools.</source>
          <target state="translated">&lt;a href=&quot;http://pear.php.net/package/XML_HTMLSax&quot;&gt; &lt;code&gt;XML_HTMLSax&lt;/code&gt; &lt;/a&gt; довольно стабилен - даже если он больше не поддерживается. Другой вариант может состоять в том, чтобы передать вам HTML через &lt;a href=&quot;http://docs.php.net/manual/en/book.tidy.php&quot;&gt;HTML Tidy,&lt;/a&gt; а затем проанализировать его с помощью стандартных инструментов XML.</target>
        </trans-unit>
        <trans-unit id="d60f1b3d0678fe59836a8b6de9a8e467b681d2ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://scraperwiki.com/api/1.0&quot;&gt;ScraperWiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://scraperwiki.com/api/1.0&quot;&gt;ScraperWiki&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b7bf893d7fcdef1f2129df3b54a4823ab40bf3b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/monkeysuffrage/advanced_html_dom&quot;&gt;Advanced Html Dom&lt;/a&gt; is a simple HTML &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; replacement that offers the same interface, but it's DOM-based which means none of the associated memory issues occur.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/monkeysuffrage/advanced_html_dom&quot;&gt;Advanced Html Dom&lt;/a&gt; - это простая замена HTML &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; , предлагающая тот же интерфейс, но основанный на DOM, что означает отсутствие проблем с памятью.</target>
        </trans-unit>
        <trans-unit id="63814451d23d80a4e01cf7d057d50122fed02b7f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/search?q=DOM+HTML+[PHP]&amp;amp;submit=search&quot;&gt;How to use the DOM extension has been covered extensively on StackOverflow&lt;/a&gt;, so if you choose to use it, you can be sure most of the issues you run into can be solved by searching/browsing Stack Overflow.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/search?q=DOM+HTML+[PHP]&amp;amp;submit=search&quot;&gt;Как использовать расширение DOM широко освещалось в StackOverflow&lt;/a&gt; , поэтому, если вы решите использовать его, вы можете быть уверены, что большинство проблем, с которыми вы столкнулись, могут быть решены с помощью поиска / просмотра Переполнения стека.</target>
        </trans-unit>
        <trans-unit id="1e8d52f8b266675024c8a2025e5d5aff62075d2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://thomas.weinert.info/FluentDOM/&quot;&gt;FluentDom&lt;/a&gt; - &lt;a href=&quot;https://github.com/ThomasWeinert/FluentDOM&quot;&gt;Repo&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://thomas.weinert.info/FluentDOM/&quot;&gt;FluentDom&lt;/a&gt; - &lt;a href=&quot;https://github.com/ThomasWeinert/FluentDOM&quot;&gt;Репо&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b87824cf6357505f2dd7bdd0cb025c91c9845e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$results&lt;/code&gt; now contains the result set for &lt;code&gt;input[name='forename']&lt;/code&gt; NOT the original query &lt;code&gt;&quot;div p&quot;&lt;/code&gt; this tripped me up a lot, what I found was that &lt;em&gt;QueryPath&lt;/em&gt; tracks the filters and finds and everything which modifies your results and stores them in the object.  you need to do this instead</source>
          <target state="translated">&lt;code&gt;$results&lt;/code&gt; теперь содержит набор результатов для &lt;code&gt;input[name='forename']&lt;/code&gt; НЕ оригинальный запрос &lt;code&gt;&quot;div p&quot;&lt;/code&gt; . Это меня сильно &lt;em&gt;смутило&lt;/em&gt; , я обнаружил, что &lt;em&gt;QueryPath&lt;/em&gt; отслеживает фильтры и находит все, что изменяет ваши результаты и хранилища. их в объекте. вам нужно сделать это вместо</target>
        </trans-unit>
        <trans-unit id="5a16f3b4ff2ed4ef8a15b2a2e40067147b5befb0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;QueryPath&lt;/em&gt; is good, but be careful of &quot;tracking state&quot; cause if you didn't realise what it means, it can mean you waste a lot of debugging time trying to find out what happened and why the code doesn't work.</source>
          <target state="translated">&lt;em&gt;QueryPath&lt;/em&gt; хорош, но будьте осторожны с &amp;laquo;состоянием отслеживания&amp;raquo;, потому что, если вы не понимаете, что это значит, это может означать, что вы тратите много времени на отладку, пытаясь выяснить, что произошло и почему код не работает.</target>
        </trans-unit>
        <trans-unit id="d9c38fd9cac3bee2d6ed70531b6fb14f6245a91e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Renamed 'select', for obvious reasons&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Переименован в &amp;laquo;выбрать&amp;raquo; по понятным причинам&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1759c585e41793ef285aed2e9382f1df5f3a5512" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Renamed 'void', since 'empty' is a reserved word in PHP&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Переименован в &amp;laquo;void&amp;raquo;, так как &amp;laquo;пустой&amp;raquo; является зарезервированным словом в PHP&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="749383e2d1cd518a40c891b7239af37b051d6989" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The library also includes its own zero-configuration autoloader for PSR-0 compatible libraries. The example included should work out of the box without any additional configuration. Alternatively, you can use it with composer.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Библиотека также включает собственный автозагрузчик нулевой конфигурации для PSR-0-совместимых библиотек.&lt;/em&gt; &lt;em&gt;Приведенный пример должен работать из коробки без какой-либо дополнительной настройки.&lt;/em&gt; &lt;em&gt;Кроме того, вы можете использовать его с композитором.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="427d269cef16d7dd435f53adf9f53c88581fff03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advantages&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40560fc8e231140d461163449e51ae367fdeafa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples for QueryPath&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Примеры для QueryPath&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e306e3e190d2a70f49058d00b1b093fcf6837564" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I actually have this &lt;a href=&quot;http://fossil.include-once.org/streamtuner2/&quot;&gt;app&lt;/a&gt;, where I employ XML parsing and regular expressions alternatively. Just last week the PyQuery parsing broke, and the regex still worked. Yes weird, and I can't explain it myself. But so it happened.</source>
          <target state="translated">&lt;strong&gt;Примечание: у&lt;/strong&gt; меня действительно есть это &lt;a href=&quot;http://fossil.include-once.org/streamtuner2/&quot;&gt;приложение&lt;/a&gt; , где я использую разбор XML и регулярные выражения в качестве альтернативы. Буквально на прошлой неделе парсинг PyQuery прервался, и регулярное выражение все еще работало. Да, странно, и я не могу объяснить это сам. Но так случилось.</target>
        </trans-unit>
        <trans-unit id="6d72dd9553207dcc429f79cdba7b6b07adfa5efb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why you shouldn't and &lt;em&gt;when you should&lt;/em&gt; use regular expressions?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Почему вы не должны и &lt;em&gt;когда вы должны&lt;/em&gt; использовать регулярные выражения?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbfce2e86e47fefb989be5da4568b10c8adce6e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phpQuery or QueryPath?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;phpQuery или QueryPath?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cae4698fc621dfc4ebc96ae78db8d2cbd4e5ad8c" translate="yes" xml:space="preserve">
          <source>A HTML DOM parser written in PHP&amp;nbsp;5+ that lets you manipulate HTML in a very easy way!</source>
          <target state="translated">Анализатор HTML DOM, написанный на PHP 5+, который позволяет вам очень просто управлять HTML!</target>
        </trans-unit>
        <trans-unit id="f5c7b3438f58d5c6af7e2b7180f26f57170d8651" translate="yes" xml:space="preserve">
          <source>A HTML beautifier (like HTML Tidy)</source>
          <target state="translated">Красивый HTML-файер (например,HTML Tidy).</target>
        </trans-unit>
        <trans-unit id="664ce6056bbe5b087cfd9fbfb8122d8d3f7e4fd7" translate="yes" xml:space="preserve">
          <source>A Python and PHP implementations of a HTML parser based on the WHATWG HTML5 specification for maximum compatibility with major desktop web browsers.</source>
          <target state="translated">Реализации Python и PHP парсера HTML на основе спецификации WHATWG HTML5 для максимальной совместимости с основными настольными веб-браузерами.</target>
        </trans-unit>
        <trans-unit id="0a002f9eab6a6a440519776a307afcbfdf2d07b8" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found at &lt;a href=&quot;https://stackoverflow.com/questions/3299033/getting-all-values-from-h1-tags-using-php/3299140#3299140&quot;&gt;getting all values from h1 tags using php&lt;/a&gt;</source>
          <target state="translated">Базовый пример использования можно найти при &lt;a href=&quot;https://stackoverflow.com/questions/3299033/getting-all-values-from-h1-tags-using-php/3299140#3299140&quot;&gt;получении всех значений из тегов h1 с использованием php&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c214664208233d4467d45fabbc658dff3316d329" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found at &lt;a href=&quot;https://stackoverflow.com/questions/4906073/a-simple-program-to-crud-node-and-node-values-of-xml-file&quot;&gt;A simple program to CRUD node and node values of xml file&lt;/a&gt; and there is &lt;a href=&quot;http://php.net/manual/en/simplexml.examples-basic.php&quot;&gt;lots of additional examples in the PHP Manual&lt;/a&gt;.</source>
          <target state="translated">Базовый пример использования можно найти в &lt;a href=&quot;https://stackoverflow.com/questions/4906073/a-simple-program-to-crud-node-and-node-values-of-xml-file&quot;&gt;разделе Простая программа для узла CRUD и значения узлов файла XML,&lt;/a&gt; и &lt;a href=&quot;http://php.net/manual/en/simplexml.examples-basic.php&quot;&gt;в руководстве по PHP&lt;/a&gt; есть множество дополнительных примеров .</target>
        </trans-unit>
        <trans-unit id="d2ec9025c32d35528d4e334718e76dd987674f48" translate="yes" xml:space="preserve">
          <source>A basic usage example can be found in &lt;a href=&quot;https://stackoverflow.com/questions/3820666/regular-expression-for-grabbing-the-href-attribute-of-an-a-element/3820783#3820783&quot;&gt;Grabbing the href attribute of an A element&lt;/a&gt; and a general conceptual overview can be found at &lt;a href=&quot;https://stackoverflow.com/questions/4979836/noob-question-about-domdocument-in-php/4983721#4983721&quot;&gt;DOMDocument in php&lt;/a&gt;</source>
          <target state="translated">Базовый пример использования можно найти в &lt;a href=&quot;https://stackoverflow.com/questions/3820666/regular-expression-for-grabbing-the-href-attribute-of-an-a-element/3820783#3820783&quot;&gt;Grabbing атрибуте href элемента A,&lt;/a&gt; а общий концептуальный обзор можно найти в &lt;a href=&quot;https://stackoverflow.com/questions/4979836/noob-question-about-domdocument-in-php/4983721#4983721&quot;&gt;DOMDocument на php&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd1ad773e01542b3fdd423200776b4fe37d851f7" translate="yes" xml:space="preserve">
          <source>A universal tokenizer and HTML/XML/RSS DOM Parser</source>
          <target state="translated">Универсальный токенайзер и парсер HTMLXMLRSS DOM.</target>
        </trans-unit>
        <trans-unit id="2e22019c08ef666033adfcb2f0c0f12acfb35beb" translate="yes" xml:space="preserve">
          <source>Ability to manipulate elements and their attributes</source>
          <target state="translated">Способность манипулировать элементами и их атрибутами</target>
        </trans-unit>
        <trans-unit id="ef04526591e535436aff90c6654fecadc86c579a" translate="yes" xml:space="preserve">
          <source>Above it's a function that parses HTML by regular expression. Note that this function is very sensitive and demands that the HTML obey certain rules, but it works very well in many scenarios. If you want a simple parser, and don't want to install libraries, give this a shot:</source>
          <target state="translated">Выше приведена функция,которая разбирает HTML по регулярному выражению.Обратите внимание,что эта функция очень чувствительна и требует,чтобы HTML подчинялся определенным правилам,но работает очень хорошо во многих сценариях.Если вам нужен простой парсер,и вы не хотите устанавливать библиотеки,попробуйте:</target>
        </trans-unit>
        <trans-unit id="b515c9a3b099e8dbc88c77e08620321b4e837112" translate="yes" xml:space="preserve">
          <source>Again, I would not recommend this parser. It is rather slow with high CPU usage. There is also no function to clear memory of created DOM objects. These problems scale particularly with nested loops. The documentation itself is inaccurate and misspelled, with no responses to fixes since 14 Apr 16.</source>
          <target state="translated">Опять же,я бы не рекомендовал этот синтаксический анализатор.Он довольно медленный при высокой загрузке процессора.Также отсутствует функция очистки памяти от созданных DOM-объектов.Эти проблемы масштабируются особенно при вложенных циклах.Сама документация неточна и написанна с ошибками,на исправления не отвечает с 14 апреля 16 года.</target>
        </trans-unit>
        <trans-unit id="1ec510988bdc89bf9bd7b325c2f2553b61212a2b" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html&quot;&gt;Parsing Html The Cthulhu Way&lt;/a&gt;</source>
          <target state="translated">Также см. &lt;a href=&quot;http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html&quot;&gt;Разбор HTML Путь Ктулху&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8cf1b78bb2f209698c6cdb9597abb54e96eafd6" translate="yes" xml:space="preserve">
          <source>Also see: &lt;a href=&quot;https://github.com/electrolinux/phpquery&quot;&gt;https://github.com/electrolinux/phpquery&lt;/a&gt;</source>
          <target state="translated">Также смотрите: &lt;a href=&quot;https://github.com/electrolinux/phpquery&quot;&gt;https://github.com/electrolinux/phpquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d2a161c418bdf05eb381f6d5ea1c2d6456c164f" translate="yes" xml:space="preserve">
          <source>An HTML DOM parser written in PHP5+ lets you manipulate HTML in a very easy way!</source>
          <target state="translated">Парсер HTML DOM,написанный на PHP5+,позволяет очень легко манипулировать HTML!</target>
        </trans-unit>
        <trans-unit id="144401da89869b09220cb2726f32caf87093fc51" translate="yes" xml:space="preserve">
          <source>And here's &lt;a href=&quot;http://www.ibm.com/developerworks/opensource/library/os-php-querypath/index.html?S_TACT=105AGX01&amp;amp;S_CMP=HP&quot;&gt;a comprehensive QueryPath introduction&lt;/a&gt;.</source>
          <target state="translated">А вот и &lt;a href=&quot;http://www.ibm.com/developerworks/opensource/library/os-php-querypath/index.html?S_TACT=105AGX01&amp;amp;S_CMP=HP&quot;&gt;полное введение в QueryPath&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a46b8d7cd67f87500b5d7718588d2c557ece05e9" translate="yes" xml:space="preserve">
          <source>And lastly, for e&lt;em&gt;xtremely simple tasks&lt;/em&gt; like extracting &amp;lt;img src= urls, they are in fact a probable tool. The speed advantage over SGML/XML parsers mostly just comes to play for these very basic extraction procedures.</source>
          <target state="translated">И, наконец, для &lt;em&gt;чрезвычайно простых задач,&lt;/em&gt; таких как извлечение &amp;lt;img src = urls, они на самом деле являются вероятным инструментом. Преимущество в скорости по сравнению с синтаксическими анализаторами SGML / XML в основном проявляется в этих базовых процедурах извлечения.</target>
        </trans-unit>
        <trans-unit id="c2feade56d00684694a9d9e01315c66714df0c54" translate="yes" xml:space="preserve">
          <source>And while I miss the ability to use CSS selectors for &lt;code&gt;DOMDocument&lt;/code&gt;, there is a rather simple and convenient way to add this feature: subclassing the &lt;code&gt;DOMDocument&lt;/code&gt; and adding JS-like &lt;code&gt;querySelectorAll&lt;/code&gt; and &lt;code&gt;querySelector&lt;/code&gt; methods to your subclass.</source>
          <target state="translated">И хотя мне не хватает возможности использовать селекторы CSS для &lt;code&gt;DOMDocument&lt;/code&gt; , есть довольно простой и удобный способ добавить эту функцию: &lt;code&gt;DOMDocument&lt;/code&gt; подкласса DOMDocument и добавление JS-подобных методов querySelectorAll и querySelector в ваш подкласс.</target>
        </trans-unit>
        <trans-unit id="b2352cb26b5e77a9dad0e37a6ac99e7163a1c86d" translate="yes" xml:space="preserve">
          <source>Another option you can try is &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt;. It's inspired by jQuery, but on the server in PHP and used in &lt;a href=&quot;http://en.wikipedia.org/wiki/Drupal&quot;&gt;Drupal&lt;/a&gt;.</source>
          <target state="translated">Другой вариант, который вы можете попробовать - это &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; . Он вдохновлен jQuery, но на сервере в PHP и используется в &lt;a href=&quot;http://en.wikipedia.org/wiki/Drupal&quot;&gt;Drupal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cba81c44dfc3d4be82ed0b3e1b1de3b4a22126bd" translate="yes" xml:space="preserve">
          <source>Basically you first create a queryable DOM tree from an HTML string:</source>
          <target state="translated">В принципе,сначала вы создаете запрашиваемое DOM-дерево из HTML-строки:</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="7aa83623e4641c12a129d48c3ef4ede02906c309" translate="yes" xml:space="preserve">
          <source>But to your specific problem, you should take a look at this project: &lt;a href=&quot;http://fivefilters.org/content-only/&quot;&gt;http://fivefilters.org/content-only/&lt;/a&gt; -- it's a modified version of the &lt;a href=&quot;http://lab.arc90.com/2009/03/02/readability/&quot;&gt;Readability&lt;/a&gt; algorithm, which is designed to extract just the textual content (not headers and footers) from a page.</source>
          <target state="translated">Но если вам нужна конкретная проблема, вы должны взглянуть на этот проект: &lt;a href=&quot;http://fivefilters.org/content-only/&quot;&gt;http://fivefilters.org/content-only/&lt;/a&gt; - это модифицированная версия алгоритма &lt;a href=&quot;http://lab.arc90.com/2009/03/02/readability/&quot;&gt;Readability&lt;/a&gt; , который предназначен для извлечения только текстового содержимого (не заголовков). и нижние колонтитулы) со страницы.</target>
        </trans-unit>
        <trans-unit id="c34ef7238086ad5070c51839516f68c811e10bf0" translate="yes" xml:space="preserve">
          <source>Can perform advanced CSS3-like queries on elements (like jQuery -- namespaces supported)</source>
          <target state="translated">Может выполнять расширенные CSS3-подобные запросы на элементы (например,jQuery --поддерживаются пространства имен).</target>
        </trans-unit>
        <trans-unit id="a1a5d5d399ebd0632976f266a1441e08ad47ca06" translate="yes" xml:space="preserve">
          <source>Consider that making a somewhat dependable HTML extraction regex:</source>
          <target state="translated">Считайте,что создание несколько надежного регекса извлечения HTML:</target>
        </trans-unit>
        <trans-unit id="61f6f421ef32670498c220ee8ee339df076a5ad9" translate="yes" xml:space="preserve">
          <source>DOM</source>
          <target state="translated">DOM</target>
        </trans-unit>
        <trans-unit id="55c9f512afeeb3355d19924f291d88cec7fe29e2" translate="yes" xml:space="preserve">
          <source>DOM is capable of parsing and modifying real world (broken) HTML and it can do &lt;a href=&quot;http://schlitt.info/opensource/blog/0704_xpath.html&quot;&gt;XPath queries&lt;/a&gt;. It is based on &lt;a href=&quot;http://xmlsoft.org/html/libxml-HTMLparser.html&quot;&gt;libxml&lt;/a&gt;.</source>
          <target state="translated">DOM способен анализировать и изменять (неработающий) HTML реального мира и выполнять &lt;a href=&quot;http://schlitt.info/opensource/blog/0704_xpath.html&quot;&gt;запросы XPath&lt;/a&gt; . Он основан на &lt;a href=&quot;http://xmlsoft.org/html/libxml-HTMLparser.html&quot;&gt;libxml&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="28f67bdf45517367ca4d6f904c2f8392f764b158" translate="yes" xml:space="preserve">
          <source>Example use :</source>
          <target state="translated">Пример использования :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="12d9de7e25a720caf19e093a74306cc9a4e7c9da" translate="yes" xml:space="preserve">
          <source>Extensible</source>
          <target state="translated">Extensible</target>
        </trans-unit>
        <trans-unit id="52edc154bfd85973b447708309453d1e0d5f9e75" translate="yes" xml:space="preserve">
          <source>Extract content from HTML:</source>
          <target state="translated">Извлечение содержимого из HTML:</target>
        </trans-unit>
        <trans-unit id="e4f2ed31239f8d0e814fac030378d9eb490bf0be" translate="yes" xml:space="preserve">
          <source>Extract contents from HTML in a single line.</source>
          <target state="translated">Извлечение содержимого из HTML в одну строку.</target>
        </trans-unit>
        <trans-unit id="2fe336188376aed8e3f768179ec8a4f84d70f80c" translate="yes" xml:space="preserve">
          <source>Fast and Easy</source>
          <target state="translated">Быстро и легко</target>
        </trans-unit>
        <trans-unit id="a7efc89443fd2e4cbb28e16621f9b53f95fe8423" translate="yes" xml:space="preserve">
          <source>Find tags on an HTML page with selectors just like jQuery.</source>
          <target state="translated">Поиск тегов на HTML-странице с селекторами,как в jQuery.</target>
        </trans-unit>
        <trans-unit id="149712bfea49caa6ead7b107cba118d9c4a2fc2c" translate="yes" xml:space="preserve">
          <source>First off, a common misnomer: Regexps are not for &lt;em&gt;&quot;&lt;strong&gt;parsing&lt;/strong&gt;&quot;&lt;/em&gt; HTML. Regexes can however &lt;em&gt;&quot;&lt;strong&gt;extract&lt;/strong&gt;&quot;&lt;/em&gt; data. Extracting is what they're made for. The major drawback of regex HTML extraction over proper SGML toolkits or baseline XML parsers are their syntactic effort and varying reliability.</source>
          <target state="translated">Во-первых, распространенное заблуждение: регулярные выражения не предназначены для &lt;em&gt;&amp;laquo; &lt;strong&gt;разбора&lt;/strong&gt; &amp;raquo;&lt;/em&gt; HTML. Однако регулярные выражения могут &lt;em&gt;&amp;laquo; &lt;strong&gt;извлекать&lt;/strong&gt; &amp;raquo;&lt;/em&gt; данные. Извлечение - это то, для чего они созданы. Основным недостатком регулярного извлечения HTML-кода над надлежащими наборами инструментов SGML или базовыми синтаксическими анализаторами XML являются их синтаксические усилия и разная надежность.</target>
        </trans-unit>
        <trans-unit id="dfce008c9e988193c2c7cc30fbe30b0aea469a5f" translate="yes" xml:space="preserve">
          <source>FluentDOM provides a jQuery-like fluent XML interface for the DOMDocument in PHP. Selectors are written in XPath or CSS (using a CSS to XPath converter). Current versions extend the DOM implementing standard interfaces and add features from the DOM Living Standard. FluentDOM can load formats like JSON, CSV, JsonML, RabbitFish and others. Can be installed via Composer.</source>
          <target state="translated">FluentDOM предоставляет подобный jQuery-бесплатный XML-интерфейс для DOMDocument в PHP.Селекторы пишутся в XPath или CSS (с помощью конвертера CSS в XPath).Текущие версии расширяют DOM,реализующий стандартные интерфейсы,и добавляют возможности DOM Living Standard.FluentDOM может загружать такие форматы,как JSON,CSV,JsonML,RabbitFish и другие.Может быть установлен через Composer.</target>
        </trans-unit>
        <trans-unit id="11078285da49b0134a3aebf9e6a39b3e548b91e2" translate="yes" xml:space="preserve">
          <source>FluidXML</source>
          <target state="translated">FluidXML</target>
        </trans-unit>
        <trans-unit id="85efe7a663e33eef32d5be3e18debc0c1f84672d" translate="yes" xml:space="preserve">
          <source>FluidXML is a PHP library for manipulating XML with a concise and fluent API.
  It leverages XPath and the fluent programming pattern to be fun and effective.</source>
          <target state="translated">FluidXML-это PHP-библиотека для работы с XML с лаконичным и свободным API.Она использует XPath и шаблон беглого программирования,чтобы быть веселым и эффективным.</target>
        </trans-unit>
        <trans-unit id="f3ea98adb29e96c7277c98baf79783ffd4939bc8" translate="yes" xml:space="preserve">
          <source>For 1a and 2: I would vote for the new Symfony Componet class DOMCrawler ( &lt;a href=&quot;http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/&quot;&gt;DomCrawler&lt;/a&gt; ).
This class allows queries similar to CSS Selectors. Take a look at this presentation for real-world examples: &lt;a href=&quot;http://www.slideshare.net/fabpot/news-of-the-symfony2-world&quot;&gt;news-of-the-symfony2-world&lt;/a&gt;.</source>
          <target state="translated">За 1а и 2: я бы проголосовал за новый класс компонентов Symfony DOMCrawler ( &lt;a href=&quot;http://github.com/symfony/symfony/tree/master/src/Symfony/Component/DomCrawler/&quot;&gt;DomCrawler&lt;/a&gt; ). Этот класс позволяет выполнять запросы, аналогичные селекторам CSS. Взгляните на эту презентацию для примеров из реального мира: &lt;a href=&quot;http://www.slideshare.net/fabpot/news-of-the-symfony2-world&quot;&gt;news-of-the-symfony2-world&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="019b00ae67ed9f11eae28c6c16dcb5be88663ba4" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML5&quot;&gt;HTML5&lt;/a&gt;, html5 lib has been abandoned for years now. The only HTML5 library I can find with a recent update and maintenance records is &lt;a href=&quot;https://github.com/Masterminds/html5-php/releases/1.0.0-beta1&quot;&gt;html5-php&lt;/a&gt; which was just brought to beta 1.0 a little over a week ago.</source>
          <target state="translated">Для &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML5&quot;&gt;HTML5&lt;/a&gt; библиотека html5 была заброшена в течение многих лет. Единственная библиотека HTML5, которую я могу найти с недавними обновлениями и записями об обслуживании, - это &lt;a href=&quot;https://github.com/Masterminds/html5-php/releases/1.0.0-beta1&quot;&gt;html5-php,&lt;/a&gt; который только что был переведен в бета-версию 1.0 чуть более недели назад.</target>
        </trans-unit>
        <trans-unit id="0c7b690295ff028bfb68ffa343e78b4ca38a4e07" translate="yes" xml:space="preserve">
          <source>For HTML parsing :</source>
          <target state="translated">Для разбора HTML :</target>
        </trans-unit>
        <trans-unit id="dc9166e6725c73ab185eec670858a82b9a1165c0" translate="yes" xml:space="preserve">
          <source>For further information on the differences see &lt;a href=&quot;http://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath&quot;&gt;this comparison on the wayback machine from tagbyte.org&lt;/a&gt;. (Original source went missing, so here's an internet archive link. Yes, you can still locate missing pages, people.)</source>
          <target state="translated">Для получения дополнительной информации о различиях см. &lt;a href=&quot;http://web.archive.org/web/20101230230134/http://www.tagbytag.org/articles/phpquery-vs-querypath&quot;&gt;Это сравнение на машине обратного хода от tagbyte.org&lt;/a&gt; . (Первоначальный источник пропал, так что вот ссылка на интернет-архив. Да, вы все еще можете найти пропущенные страницы, люди.)</target>
        </trans-unit>
        <trans-unit id="22d8d2b2fb6fda43308a6bf614eb0d42bca679b5" translate="yes" xml:space="preserve">
          <source>For parsing the selectors, I recommend using the very minimalistic &lt;a href=&quot;http://symfony.com/doc/current/components/css_selector.html&quot;&gt;CssSelector component&lt;/a&gt; from the &lt;a href=&quot;http://symfony.com/&quot;&gt;Symfony framework&lt;/a&gt;. This component just translates CSS selectors to XPath selectors, which can then be fed into a &lt;code&gt;DOMXpath&lt;/code&gt; to retrieve the corresponding Nodelist.</source>
          <target state="translated">Для анализа селекторов я рекомендую использовать очень минималистичный &lt;a href=&quot;http://symfony.com/doc/current/components/css_selector.html&quot;&gt;компонент CssSelector&lt;/a&gt; из &lt;a href=&quot;http://symfony.com/&quot;&gt;среды Symfony&lt;/a&gt; . Этот компонент просто переводит селекторы CSS в селекторы XPath, которые затем могут быть переданы в &lt;code&gt;DOMXpath&lt;/code&gt; для получения соответствующего Nodelist.</target>
        </trans-unit>
        <trans-unit id="dd0d138f0f3d01adb6e9b2bfa7e5e1226d277ea5" translate="yes" xml:space="preserve">
          <source>Ganon</source>
          <target state="translated">Ganon</target>
        </trans-unit>
        <trans-unit id="010d64aa6bcaec1c43df7f15b6e6795eaba5e6de" translate="yes" xml:space="preserve">
          <source>Generally QueryPath is better suited for manipulation of documents. While phpQuery also implements some pseudo AJAX methods (just HTTP requests) to more closely resemble jQuery. It is said that phpQuery is often faster than QueryPath (because of fewer overall features).</source>
          <target state="translated">Как правило,QueryPath лучше подходит для манипуляций с документами.В то время как phpQuery также реализует некоторые псевдо AJAX-методы (только HTTP-запросы),чтобы более походить на jQuery.Говорят,что phpQuery часто быстрее,чем QueryPath (из-за меньшего количества общих возможностей).</target>
        </trans-unit>
        <trans-unit id="d33a71599358dd446b3a5c5bbb17eb6a539802b6" translate="yes" xml:space="preserve">
          <source>HTML 5</source>
          <target state="translated">HTML 5</target>
        </trans-unit>
        <trans-unit id="2481298ff8cb8b47dd8d49e8f6bf9293936053cb" translate="yes" xml:space="preserve">
          <source>HTML parsers already know the syntactical rules of HTML. Regular expressions have to be taught for each new RegEx you write. RegEx are fine in some cases, but it really depends on your use-case.</source>
          <target state="translated">Парсеры HTML уже знают синтаксические правила HTML.Регулярные выражения должны быть обучены для каждого нового RegEx,который вы пишете.В некоторых случаях RegEx подойдет,но на самом деле это зависит от того,как вы его используете.</target>
        </trans-unit>
        <trans-unit id="6ef2488e29db96459d8f0a2f4afd555a7950eb39" translate="yes" xml:space="preserve">
          <source>Here's the github repo: &lt;a href=&quot;https://github.com/pwarelis/XmlExtractor&quot;&gt;XmlExtractor&lt;/a&gt;</source>
          <target state="translated">Вот &lt;a href=&quot;https://github.com/pwarelis/XmlExtractor&quot;&gt;репозиторий Github&lt;/a&gt; : XmlExtractor</target>
        </trans-unit>
        <trans-unit id="c64fd288b23d031d147bac0aa0a5b5c67e88a520" translate="yes" xml:space="preserve">
          <source>How can one parse HTML/XML and extract information from it?</source>
          <target state="translated">Как разобрать HTMLXML и извлечь из него информацию?</target>
        </trans-unit>
        <trans-unit id="e3cc41a06f4bd11f3bf3b219f0962c8f9b07a883" translate="yes" xml:space="preserve">
          <source>How do you parse and process HTML/XML in PHP</source>
          <target state="translated">Как разобрать и обработать HTMLXML в PHP</target>
        </trans-unit>
        <trans-unit id="6a227cfcf5e09a8662563ee0c093ac92c4d9a454" translate="yes" xml:space="preserve">
          <source>How to get HTML elements:</source>
          <target state="translated">Как получить элементы HTML:</target>
        </trans-unit>
        <trans-unit id="4389a53129f0579ecfb989ab0d8e483e12a6aa8e" translate="yes" xml:space="preserve">
          <source>How to modify HTML elements:</source>
          <target state="translated">Как модифицировать элементы HTML:</target>
        </trans-unit>
        <trans-unit id="d88d96ba36436a05a8cfe468304396c953bf885c" translate="yes" xml:space="preserve">
          <source>HtmlPageDom</source>
          <target state="translated">HtmlPageDom</target>
        </trans-unit>
        <trans-unit id="c0d513d3128cbbe47a078efa90613fe568129ba7" translate="yes" xml:space="preserve">
          <source>I am not affiliated with PHP Architect or the authors.</source>
          <target state="translated">Я не связан ни с PHP Architect,ни с авторами.</target>
        </trans-unit>
        <trans-unit id="bbcbf01f4064f686ea8722a2a29768c36f034c48" translate="yes" xml:space="preserve">
          <source>I created a library named &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;&lt;strong&gt;PHPPowertools/DOM-Query&lt;/strong&gt;&lt;/a&gt;, which allows you to crawl HTML5 and XML documents just like you do with jQuery.</source>
          <target state="translated">Я создал библиотеку с именем &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;&lt;strong&gt;PHPPowertools / DOM-Query&lt;/strong&gt;&lt;/a&gt; , которая позволяет сканировать документы HTML5 и XML так же, как вы делаете это с jQuery.</target>
        </trans-unit>
        <trans-unit id="ba6b30ea78ddf3eba99914702d1561cbba328440" translate="yes" xml:space="preserve">
          <source>I generally do not recommend this parser. The codebase is horrible and the parser itself is rather slow and memory hungry. Not all jQuery Selectors (such as &lt;a href=&quot;https://api.jquery.com/child-selector/&quot;&gt;child selectors&lt;/a&gt;) are possible. Any of the libxml based libraries should outperform this easily.</source>
          <target state="translated">Я вообще не рекомендую этот парсер. Кодовая база ужасна, а сам парсер довольно медленный и требует много памяти. Не все селекторы jQuery (такие как &lt;a href=&quot;https://api.jquery.com/child-selector/&quot;&gt;дочерние селекторы&lt;/a&gt; ) возможны. Любая из библиотек на основе libxml должна легко превзойти это.</target>
        </trans-unit>
        <trans-unit id="eb6fc4ab03473e7d17c1de5c02d235ac14fd367c" translate="yes" xml:space="preserve">
          <source>I have never used curl for the purpose but what I have learned is that curl can do the job much more efficiently and is much more solid.</source>
          <target state="translated">Я никогда не использовал скручивание для этой цели,но я понял,что скручивание может делать работу намного эффективнее и намного прочнее.</target>
        </trans-unit>
        <trans-unit id="a95c793e7e56b31812864ca97fa71b47951770bc" translate="yes" xml:space="preserve">
          <source>I have written a general purpose XML parser that can easily handle GB files. It's based on XMLReader and it's very easy to use:</source>
          <target state="translated">Я написал универсальный парсер XML,который легко справляется с GB файлами.Он основан на XMLReader и очень прост в использовании:</target>
        </trans-unit>
        <trans-unit id="357606d09d492cf4482c3593cd4945b8c282bb19" translate="yes" xml:space="preserve">
          <source>I merely want to add that I personally prefer using the DOM extension and why :</source>
          <target state="translated">Я просто хочу добавить,что лично я предпочитаю использовать расширение DOM и почему :</target>
        </trans-unit>
        <trans-unit id="339836ff45972f30237165fb9e1c7b9692b84246" translate="yes" xml:space="preserve">
          <source>I prefer using one of the &lt;a href=&quot;http://php.net/manual/en/refs.xml.php&quot;&gt;native XML extensions&lt;/a&gt; since they come bundled with PHP, are usually faster than all the 3rd party libs and give me all the control I need over the markup.</source>
          <target state="translated">Я предпочитаю использовать одно из &lt;a href=&quot;http://php.net/manual/en/refs.xml.php&quot;&gt;собственных расширений XML,&lt;/a&gt; поскольку они поставляются в комплекте с PHP, обычно работают быстрее, чем все сторонние библиотеки, и дают мне полный контроль над разметкой.</target>
        </trans-unit>
        <trans-unit id="5d8cbf62fddda3fe5bed7b863aae097fe3f69e98" translate="yes" xml:space="preserve">
          <source>I recommend &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;PHP Simple HTML DOM Parser&lt;/a&gt;.</source>
          <target state="translated">Я рекомендую &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;PHP Simple HTML DOM Parser&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84ae9571dbd8d9c4e5f813977179983452830ffd" translate="yes" xml:space="preserve">
          <source>I've created a library called HTML5DOMDocument that is freely available at &lt;a href=&quot;https://github.com/ivopetkov/html5-dom-document-php&quot;&gt;https://github.com/ivopetkov/html5-dom-document-php&lt;/a&gt;</source>
          <target state="translated">Я создал библиотеку под названием HTML5DOMDocument, которая свободно доступна по адресу &lt;a href=&quot;https://github.com/ivopetkov/html5-dom-document-php&quot;&gt;https://github.com/ivopetkov/html5-dom-document-php.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1783e93efdfa64b38f9953aae0900acc436e264" translate="yes" xml:space="preserve">
          <source>I've used this in a number of tools, testing it on many different types of web pages, and I think it works great.</source>
          <target state="translated">Я использовал это во многих инструментах,тестировал его на различных типах веб-страниц,и я думаю,что это отлично работает.</target>
        </trans-unit>
        <trans-unit id="de24ae92f1c60dd3b9a2acc993da1dabf7ccfff8" translate="yes" xml:space="preserve">
          <source>If you don't feel like programming PHP, you can also use Web services. In general, I found very little utility for these, but that's just me and my use cases.</source>
          <target state="translated">Если вам не хочется программировать PHP,вы также можете воспользоваться веб-сервисами.В общем,я нашел очень мало утилит для них,но это только я и мои случаи использования.</target>
        </trans-unit>
        <trans-unit id="54f146095c7e90652a02eaaa284db8fac07cafa2" translate="yes" xml:space="preserve">
          <source>If you prefer to use a 3rd-party lib, I'd suggest using a lib that actually uses &lt;a href=&quot;http://php.net/manual/en/book.dom.php&quot;&gt;DOM&lt;/a&gt;/&lt;a href=&quot;http://xmlsoft.org/&quot;&gt;libxml&lt;/a&gt; underneath instead of string parsing.</source>
          <target state="translated">Если вы предпочитаете использовать стороннюю библиотеку, я бы предложил использовать &lt;a href=&quot;http://xmlsoft.org/&quot;&gt;библиотеку,&lt;/a&gt; которая на самом деле использует &lt;a href=&quot;http://php.net/manual/en/book.dom.php&quot;&gt;DOM&lt;/a&gt; / libxml, а не разбор строки.</target>
        </trans-unit>
        <trans-unit id="4547441eafff3d38922bc0db40181f5ace8b4996" translate="yes" xml:space="preserve">
          <source>If you want to spend some money, have a look at</source>
          <target state="translated">Если ты хочешь потратить немного денег,взгляни на то.</target>
        </trans-unit>
        <trans-unit id="66264988483b0b4b5f9a545e7d1e048b3553f2a3" translate="yes" xml:space="preserve">
          <source>If you're familiar with jQuery selector, you can use &lt;a href=&quot;https://github.com/ScarletsFiction/ScarletsQuery&quot;&gt;ScarletsQuery&lt;/a&gt; for PHP</source>
          <target state="translated">Если вы знакомы с селектором jQuery, вы можете использовать &lt;a href=&quot;https://github.com/ScarletsFiction/ScarletsQuery&quot;&gt;ScarletsQuery&lt;/a&gt; для PHP</target>
        </trans-unit>
        <trans-unit id="4d5575093d6413d3f97f557e98a63bbd8b9025e7" translate="yes" xml:space="preserve">
          <source>It also accept invalid HTML or missing quote on tag attributes.</source>
          <target state="translated">Он также принимает недействительный HTML или отсутствующие кавычки в атрибутах тегов.</target>
        </trans-unit>
        <trans-unit id="6d66305bb90d7ea542c8c6aad06e7a21d4ac7479" translate="yes" xml:space="preserve">
          <source>It also has full CSS support, including &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; extensions.</source>
          <target state="translated">Он также имеет полную поддержку CSS, включая расширения &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25432a75a0586b1da4ec0478132a4dae9bb24a9d" translate="yes" xml:space="preserve">
          <source>It really has nice features, like:</source>
          <target state="translated">У него действительно есть хорошие черты,например:</target>
        </trans-unit>
        <trans-unit id="4c5c9e5bf0835f1de708dac8dda79e1196e30c58" translate="yes" xml:space="preserve">
          <source>It supports query selectors too that I think will be extremely helpful in your case. Here is some example code:</source>
          <target state="translated">Он также поддерживает селекторы запросов,что,на мой взгляд,будет очень полезно в вашем случае.Вот пример кода:</target>
        </trans-unit>
        <trans-unit id="f099bf29cecda917eab795da4d9f9293e52130c7" translate="yes" xml:space="preserve">
          <source>It takes some time to get productive with DOM, but that time is well worth it IMO. Since DOM is a language-agnostic interface, you'll find implementations in many languages, so if you need to change your programming language, chances are you will already know how to use that language's DOM API then.</source>
          <target state="translated">Потребуется некоторое время для продуктивной работы с DOM,но это время вполне оправдано IMO.Поскольку DOM является языковым диагностическим интерфейсом,вы найдете реализации на многих языках,так что если вам нужно будет сменить язык программирования,то,скорее всего,вы уже знаете,как использовать DOM API этого языка.</target>
        </trans-unit>
        <trans-unit id="d452f4389b55a57f93798030576c7607d916d482" translate="yes" xml:space="preserve">
          <source>It treats DOM elements in an object-oriented way, and the new iteration has a lot of coverage for non-compliant code. There are also some great functions like you'd see in JavaScript, such as the &quot;find&quot; function, which will return all instances of elements of that tag name.</source>
          <target state="translated">Он обрабатывает элементы DOM объектно-ориентированным образом,и новая итерация имеет большое покрытие для несоответствующего кода.Есть также несколько замечательных функций,которые вы увидите в JavaScript,например,функция &quot;find&quot;,которая вернет все экземпляры элементов с таким именем тега.</target>
        </trans-unit>
        <trans-unit id="f77033e3cd943fcbdc5f951c94653a819b0e7a5f" translate="yes" xml:space="preserve">
          <source>It's sometimes even advisable to pre-extract a snippet of HTML using regular expressions &lt;code&gt;/&amp;lt;!--CONTENT--&amp;gt;(.+?)&amp;lt;!--END--&amp;gt;/&lt;/code&gt; and process the remainder using the simpler HTML parser frontends.</source>
          <target state="translated">Иногда даже рекомендуется предварительно извлечь фрагмент HTML с помощью регулярных выражений &lt;code&gt;/&amp;lt;!--CONTENT--&amp;gt;(.+?)&amp;lt;!--END--&amp;gt;/&lt;/code&gt; и обработать оставшуюся часть, используя более простые интерфейсы анализатора HTML.</target>
        </trans-unit>
        <trans-unit id="c75352eba2f1997a0100830871fe331ba99a290c" translate="yes" xml:space="preserve">
          <source>JSON and array from XML in three lines:</source>
          <target state="translated">JSON и массив из XML в три строки:</target>
        </trans-unit>
        <trans-unit id="2c86a3c52b12cd6eba84f473339f4b1433a03e0d" translate="yes" xml:space="preserve">
          <source>Just use &lt;a href=&quot;http://docs.php.net/manual/en/domdocument.loadhtml.php&quot;&gt;DOMDocument-&amp;gt;loadHTML()&lt;/a&gt; and be done with it. libxml's HTML parsing algorithm is quite good and fast, and contrary to popular belief, does not choke on malformed HTML.</source>
          <target state="translated">Просто используйте &lt;a href=&quot;http://docs.php.net/manual/en/domdocument.loadhtml.php&quot;&gt;DOMDocument-&amp;gt; loadHTML ()&lt;/a&gt; и покончите с этим. Алгоритм синтаксического анализа HTML в libxml достаточно хорош и быстр, и, вопреки распространенному мнению, не подавляет искаженный HTML.</target>
        </trans-unit>
        <trans-unit id="77af834f38039e4a75c2d1af87fc51c7f4c83af5" translate="yes" xml:space="preserve">
          <source>Kindly check out this link:&lt;a href=&quot;http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/&quot;&gt;scraping-websites-with-curl&lt;/a&gt;</source>
          <target state="translated">Пожалуйста, проверьте эту ссылку: &lt;a href=&quot;http://spyderwebtech.wordpress.com/2008/08/07/scraping-websites-with-curl/&quot;&gt;scraping-sites-with-curl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df5af4eaf6333c18a92e864a88a527466c8e2a87" translate="yes" xml:space="preserve">
          <source>Last and &lt;strong&gt;least recommended&lt;/strong&gt;, you can extract data from HTML with &lt;a href=&quot;https://stackoverflow.com/search?q=regular%20expression%20tutorials&quot;&gt;regular expressions&lt;/a&gt;. In general using Regular Expressions on HTML is discouraged.</source>
          <target state="translated">Последнее и &lt;strong&gt;наименее рекомендуемое&lt;/strong&gt; , вы можете извлекать данные из HTML с помощью &lt;a href=&quot;https://stackoverflow.com/search?q=regular%20expression%20tutorials&quot;&gt;регулярных выражений&lt;/a&gt; . В целом, использование регулярных выражений в HTML не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="2aba8d7afde1162b4fd4210f44e3fd0179a97e30" translate="yes" xml:space="preserve">
          <source>Many DOM traversal frontends don't reveal HTML comments &lt;code&gt;&amp;lt;!--&lt;/code&gt;, which however are sometimes the more useful anchors for extraction. In particular pseudo-HTML variations &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; or SGML residues are easy to tame with regexps.</source>
          <target state="translated">Многие внешние интерфейсы DOM не отображают HTML-комментарии &lt;code&gt;&amp;lt;!--&lt;/code&gt; , которые, тем не менее, иногда являются более полезными якорями для извлечения. В частности, псевдо-HTML-вариации &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; или остатки SGML легко укротить с помощью регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="6f83c03a7d83375b8530b744da5d4e14cb773741" translate="yes" xml:space="preserve">
          <source>Minify CSS and Javascript</source>
          <target state="translated">Уменьшить CSS и Javascript</target>
        </trans-unit>
        <trans-unit id="627adea35309c41eae7e01931d886d77e7c41c7d" translate="yes" xml:space="preserve">
          <source>Most of the snippets you will find on the web to match markup are brittle. In most cases they are only working for a very particular piece of HTML. Tiny markup changes, like adding whitespace somewhere, or adding, or changing attributes in a tag, can make the RegEx fails when it's not properly written. You should know what you are doing before using RegEx on HTML.</source>
          <target state="translated">Большинство из фрагментов,которые вы найдете на паутине для того чтобы соответствовать разметке хрупки.В большинстве случаев они работают только для очень определенного куска HTML.Крошечные изменения разметки,такие как добавление где-нибудь пробела,добавление или изменение атрибутов в теге,могут сделать RegEx неудачным,когда он написан неправильно.Вы должны знать,что вы делаете,прежде чем использовать RegEx в HTML.</target>
        </trans-unit>
        <trans-unit id="89b2f5b0133f65e45226a07f5cee8565bdcadf34" translate="yes" xml:space="preserve">
          <source>Mostly you want to use simple &lt;code&gt;#id&lt;/code&gt; and &lt;code&gt;.class&lt;/code&gt; or &lt;code&gt;DIV&lt;/code&gt; tag selectors for &lt;code&gt;-&amp;gt;find()&lt;/code&gt;. But you can also use &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; statements, which sometimes are faster. Also typical jQuery methods like &lt;code&gt;-&amp;gt;children()&lt;/code&gt; and &lt;code&gt;-&amp;gt;text()&lt;/code&gt; and particularly &lt;code&gt;-&amp;gt;attr()&lt;/code&gt; simplify extracting the right HTML snippets. (And already have their SGML entities decoded.)</source>
          <target state="translated">В основном вы хотите использовать простые селекторы тегов &lt;code&gt;#id&lt;/code&gt; и &lt;code&gt;.class&lt;/code&gt; или &lt;code&gt;DIV&lt;/code&gt; для &lt;code&gt;-&amp;gt;find()&lt;/code&gt; . Но вы также можете использовать операторы &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; , которые иногда работают быстрее. Также типичные методы jQuery, такие как &lt;code&gt;-&amp;gt;children()&lt;/code&gt; и &lt;code&gt;-&amp;gt;text()&lt;/code&gt; и особенно &lt;code&gt;-&amp;gt;attr()&lt;/code&gt; упрощают извлечение правильных фрагментов HTML. (И уже расшифрованы их сущности SGML.)</target>
        </trans-unit>
        <trans-unit id="9031cd061d55fd09d5631c31edd51747001a785e" translate="yes" xml:space="preserve">
          <source>NOTE :</source>
          <target state="translated">ПРИМЕЧАНИЕ :</target>
        </trans-unit>
        <trans-unit id="1300a697b19e9262ea20292114599c4fd1368aef" translate="yes" xml:space="preserve">
          <source>Native XML Extensions</source>
          <target state="translated">Расширения XML</target>
        </trans-unit>
        <trans-unit id="1677e20649f0c9d5ffd70eb67cbee8c3b828533d" translate="yes" xml:space="preserve">
          <source>Never used it. Can't tell if it's any good.</source>
          <target state="translated">Никогда им не пользовался.Не могу сказать,хорошо ли это.</target>
        </trans-unit>
        <trans-unit id="62ea675f26d38d09101a41ac861850d50fba75d0" translate="yes" xml:space="preserve">
          <source>Oftentimes regular expressions can save post-processing. However HTML entities often require manual caretaking.</source>
          <target state="translated">Часто регулярные выражения позволяют сохранить пост-обработку.Однако сущности HTML часто требуют ручной обработки.</target>
        </trans-unit>
        <trans-unit id="1f83f8dcdf419895f7c7a83c7580b9a96b3f2f1c" translate="yes" xml:space="preserve">
          <source>One general approach I haven't seen mentioned here is to run HTML through &lt;a href=&quot;http://php.net/manual/en/book.tidy.php&quot;&gt;Tidy&lt;/a&gt;, which can be set to spit out guaranteed-valid XHTML. Then you can use any old XML library on it.</source>
          <target state="translated">Один общий подход, о котором я не упомянул, - это запуск HTML через &lt;a href=&quot;http://php.net/manual/en/book.tidy.php&quot;&gt;Tidy&lt;/a&gt; , который можно настроить так, чтобы он выдавал гарантированно-действительный XHTML. Тогда вы можете использовать любую старую библиотеку XML.</target>
        </trans-unit>
        <trans-unit id="578a94497cee464a3ed319fd370eec273b62e6df" translate="yes" xml:space="preserve">
          <source>Operations separated in smaller functions for easy overriding</source>
          <target state="translated">Операции разделены на более мелкие функции для легкого управления</target>
        </trans-unit>
        <trans-unit id="7ed99b9fb3a5520bfade55b9fe5642a263895c2a" translate="yes" xml:space="preserve">
          <source>PHP Architect's Guide to Webscraping with PHP</source>
          <target state="translated">Руководство архитектора PHP по веб-скрейпингу с помощью PHP</target>
        </trans-unit>
        <trans-unit id="2fdc33ef5621a15328fa3e4a16e51f86b20c60b0" translate="yes" xml:space="preserve">
          <source>PHP Html Parser</source>
          <target state="translated">PHP Html Parser</target>
        </trans-unit>
        <trans-unit id="2fccda5363a87dcdb8f1237ddb0532e23fc267f7" translate="yes" xml:space="preserve">
          <source>PHP Simple HTML DOM Parser</source>
          <target state="translated">PHP Простой HTML DOM парсер</target>
        </trans-unit>
        <trans-unit id="d4f4d957c818e56ebc312e877f197ce68488f02a" translate="yes" xml:space="preserve">
          <source>PHPHtmlParser is a simple, flexible, html parser which allows you to select tags using any css selector, like jQuery. The goal is to assiste in the development of tools which require a quick, easy way to scrap html, whether it's valid or not! This project was original supported by sunra/php-simple-html-dom-parser but the support seems to have stopped so this project is my adaptation of his previous work.</source>
          <target state="translated">PHPHtmlParser-это простой,гибкий html парсер,который позволяет выбирать теги с помощью любого css-селектора,например jQuery.Целью является помощь в разработке инструментов,которые требуют быстрого и простого способа отбраковки html,независимо от того,действителен он или нет! Этот проект был изначально поддержан sunraphp-simple-html-dom-parser,но поддержка,кажется,остановилась,так что этот проект является моей адаптацией его предыдущей работы.</target>
        </trans-unit>
        <trans-unit id="28d936680a9cd1da534d5bab294f5e31d74394d2" translate="yes" xml:space="preserve">
          <source>Parsing documents using callbacks based on current character/token</source>
          <target state="translated">Разбор документов с помощью обратного вызова на основе текущего символьного кода</target>
        </trans-unit>
        <trans-unit id="a11058217485bda936a7947b3f8dea9dca2c1f2d" translate="yes" xml:space="preserve">
          <source>Proper data unescaping (in comparison to regular expression grepping)</source>
          <target state="translated">Свойственное удаление данных (по сравнению с регулярным выражением grepping)</target>
        </trans-unit>
        <trans-unit id="a81c033171fc90b40305445d7d6e17317ebc3577" translate="yes" xml:space="preserve">
          <source>QueryPath</source>
          <target state="translated">QueryPath</target>
        </trans-unit>
        <trans-unit id="9737e148f4e81913479e1971cb61a0356bc18cc5" translate="yes" xml:space="preserve">
          <source>QueryPath also allows injecting new tags into the stream (&lt;code&gt;-&amp;gt;append&lt;/code&gt;), and later output and prettify an updated document (&lt;code&gt;-&amp;gt;writeHTML&lt;/code&gt;). It can not only parse malformed HTML, but also various XML dialects (with namespaces), and even extract data from HTML microformats (XFN, vCard).</source>
          <target state="translated">QueryPath также позволяет вставлять новые теги в поток ( &lt;code&gt;-&amp;gt;append&lt;/code&gt; ), а затем выводить и предварительно обновлять обновленный документ ( &lt;code&gt;-&amp;gt;writeHTML&lt;/code&gt; ). Он может не только анализировать искаженный HTML, но также различные диалекты XML (с пространствами имен) и даже извлекать данные из микроформатов HTML (XFN, vCard).</target>
        </trans-unit>
        <trans-unit id="95df12b37819a2adfe3f819892d0d4de469b52c4" translate="yes" xml:space="preserve">
          <source>QueryPath is a PHP library for manipulating XML and HTML. It is designed to work not only with local files, but also with web services and database resources. It implements much of the jQuery interface (including CSS-style selectors), but it is heavily tuned for server-side use.  Can be installed via Composer.</source>
          <target state="translated">QueryPath-это PHP-библиотека для работы с XML и HTML.Она предназначена для работы не только с локальными файлами,но и с веб-сервисами и ресурсами баз данных.Она реализует большую часть интерфейса jQuery (включая селекторы в стиле CSS),но она сильно настроена для использования на стороне сервера.Может быть установлен через Composer.</target>
        </trans-unit>
        <trans-unit id="ab140354a34bd045ff52d42f722acc1c4ffada22" translate="yes" xml:space="preserve">
          <source>Regular Expressions</source>
          <target state="translated">Регулярные экспрессии</target>
        </trans-unit>
        <trans-unit id="036e8223cfc6af3bc474124d436998f668393599" translate="yes" xml:space="preserve">
          <source>Require PHP 5+.</source>
          <target state="translated">Требуется PHP 5+.</target>
        </trans-unit>
        <trans-unit id="76a7e0d2a9377458c6ef9ab5843fd65dd104d40a" translate="yes" xml:space="preserve">
          <source>ScraperWiki's external interface allows you to extract data in the form you want for use on the web or in your own applications. You can also extract information about the state of any scraper.</source>
          <target state="translated">Внешний интерфейс ScraperWiki позволяет извлекать данные в той форме,которая нужна вам для использования в Интернете или в ваших собственных приложениях.Вы также можете извлечь информацию о состоянии любого скрепера.</target>
        </trans-unit>
        <trans-unit id="c9a3a60c4a1b9153da07bbc915c70995d1fcd9b2" translate="yes" xml:space="preserve">
          <source>Scraping Slashdot:</source>
          <target state="translated">Скребок Слэшдот:</target>
        </trans-unit>
        <trans-unit id="f2508406c16bde16405a9e91ecee59698672e940" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors&quot;&gt;Parsing XML documents with CSS selectors&lt;/a&gt; by Symfony's creator Fabien Potencier on his decision to create the CssSelector component for Symfony and how to use it.</source>
          <target state="translated">См. Также &lt;a href=&quot;http://fabien.potencier.org/article/42/parsing-xml-documents-with-css-selectors&quot;&gt;Анализ документов XML с помощью селекторов CSS&lt;/a&gt; , создатель Symfony Фабьен Потенциер (Fabien Potencier) о его решении создать компонент CssSelector для Symfony и способы его использования.</target>
        </trans-unit>
        <trans-unit id="20496fe36fbd9068f5e0745949f57d1a30754cf2" translate="yes" xml:space="preserve">
          <source>Simple HTML DOM is a great open-source parser:</source>
          <target state="translated">Простой HTML DOM-отличный парсер с открытым исходным кодом:</target>
        </trans-unit>
        <trans-unit id="26acadafb8b9e27c131ae620d79467303283aec3" translate="yes" xml:space="preserve">
          <source>Simple to use alternatives &lt;code&gt;-&amp;gt;find(&quot;a img, a object, div a&quot;)&lt;/code&gt;</source>
          <target state="translated">Простые в использовании альтернативы &lt;code&gt;-&amp;gt;find(&quot;a img, a object, div a&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac04b5615f2819c31f2d067d7f8923ef7ff7ef21" translate="yes" xml:space="preserve">
          <source>SimpleXML is an option when you know the HTML is valid XHTML. If you need to parse broken HTML, don't even consider SimpleXml because it will choke.</source>
          <target state="translated">SimpleXML является опцией,когда вы знаете,что HTML является допустимым XHTML.Если вам нужно разобрать сломанный HTML,даже не думайте о SimpleXml,потому что он задохнется.</target>
        </trans-unit>
        <trans-unit id="8b459878d5dac1498236eb8ec705c4653131f954" translate="yes" xml:space="preserve">
          <source>SimpleXml</source>
          <target state="translated">SimpleXml</target>
        </trans-unit>
        <trans-unit id="4ab9bc94de911e1bbbc353ed1187f6ef58e14b32" translate="yes" xml:space="preserve">
          <source>Simplicity and Reliability</source>
          <target state="translated">Простота и надежность</target>
        </trans-unit>
        <trans-unit id="04b1d51ec3918aabce9a1745c1f2074a9358a9f6" translate="yes" xml:space="preserve">
          <source>So please don't vote real-world considerations down, just because it doesn't match the regex=evil meme. &lt;strong&gt;But let's also not vote this up too much. It's just a sidenote for this topic.&lt;/strong&gt;</source>
          <target state="translated">Поэтому, пожалуйста, не отрицайте реальные соображения, просто потому, что они не соответствуют регулярному выражению = злой мем. &lt;strong&gt;Но давайте также не будем голосовать слишком много.&lt;/strong&gt; &lt;strong&gt;Это просто sidenote для этой темы.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19dfc66630e4b772779cd9a262a504499ad4897f" translate="yes" xml:space="preserve">
          <source>Sort attributes, change character case, correct indentation, etc.</source>
          <target state="translated">Сортировка атрибутов,изменение регистра символов,правильный отпечаток и т.д.</target>
        </trans-unit>
        <trans-unit id="6492f0b8f23e2427034e89fba4fc783788408998" translate="yes" xml:space="preserve">
          <source>Supported methods :</source>
          <target state="translated">Поддерживаемые методы :</target>
        </trans-unit>
        <trans-unit id="09c87bdf1f20971fcf51b21e634812d66a597646" translate="yes" xml:space="preserve">
          <source>Supports invalid HTML and UTF8</source>
          <target state="translated">Поддерживает недействительный HTML и UTF8</target>
        </trans-unit>
        <trans-unit id="1b4f692c4cf3ff10d493de7506631f00988acc7a" translate="yes" xml:space="preserve">
          <source>Supports invalid HTML.</source>
          <target state="translated">Поддерживает недействительный HTML.</target>
        </trans-unit>
        <trans-unit id="4b51562e1d3f8c3ee0992b96a3771823cf482336" translate="yes" xml:space="preserve">
          <source>Ta da!</source>
          <target state="translated">Та-да!</target>
        </trans-unit>
        <trans-unit id="22123f0c078e1328382bb3ba2c871a5312c22c9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Symfony&quot;&gt;Symfony&lt;/a&gt; framework has bundles which can parse the HTML, and you can use CSS style to select the &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOMs&lt;/a&gt; instead of using &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt;.</source>
          <target state="translated">Платформа &lt;a href=&quot;http://en.wikipedia.org/wiki/Symfony&quot;&gt;Symfony&lt;/a&gt; имеет пакеты, которые могут анализировать HTML, и вы можете использовать стиль CSS для выбора &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt; вместо использования &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08426608042619571ea8da728effcd8bdb8ccddf" translate="yes" xml:space="preserve">
          <source>The DOM extension allows you to operate on XML documents through the DOM API with PHP 5. It is an implementation of the W3C's Document Object Model Core Level 3, a platform- and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure and style of documents.</source>
          <target state="translated">Расширение DOM позволяет работать с XML-документами через DOM API с PHP 5.Оно является реализацией ядра объектной модели W3C Document Object Model Core Level 3,нейтрализующего к платформе и языку интерфейса,позволяющего программам и скриптам динамически получать доступ к содержимому,структуре и стилю документов и обновлять их.</target>
        </trans-unit>
        <trans-unit id="6af68a6b854fdff9293628426a280a5712ed9a80" translate="yes" xml:space="preserve">
          <source>The SimpleXML extension provides a very simple and easily usable toolset to convert XML to an object that can be processed with normal property selectors and array iterators.</source>
          <target state="translated">Расширение SimpleXML предоставляет очень простой и удобный инструментарий для преобразования XML в объект,который может быть обработан обычными селекторами свойств и итераторами массивов.</target>
        </trans-unit>
        <trans-unit id="56fa67264d262a826c383e93de2a9bbeefb33eaa" translate="yes" xml:space="preserve">
          <source>The XML Parser library is also based on libxml, and implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Simple_API_for_XML&quot;&gt;SAX&lt;/a&gt; style XML push parser. It may be a better choice for memory management than DOM or SimpleXML, but will be more difficult to work with than the pull parser implemented by XMLReader.</source>
          <target state="translated">Библиотека XML Parser также основана на libxml и реализует push-анализатор XML в стиле &lt;a href=&quot;http://en.wikipedia.org/wiki/Simple_API_for_XML&quot;&gt;SAX&lt;/a&gt; . Это может быть лучшим выбором для управления памятью, чем DOM или SimpleXML, но с ним будет сложнее работать, чем парсером pull, реализованным XMLReader.</target>
        </trans-unit>
        <trans-unit id="b67498f486aaa11938e3847d09f2dce44e5beb65" translate="yes" xml:space="preserve">
          <source>The XMLReader extension is an XML pull parser. The reader acts as a cursor going forward on the document stream and stopping at each node on the way.</source>
          <target state="translated">Расширение XMLReader-это парсер XML.Читатель действует как курсор,идущий вперед по потоку документов и останавливающийся на каждом узле на пути.</target>
        </trans-unit>
        <trans-unit id="daf8ea6c752ba027315c1f91a513e28bb38ce9f6" translate="yes" xml:space="preserve">
          <source>The benefit of building upon DOM/libxml is that you get good performance out of the box because you are based on a native extension. However, not all 3rd-party libs go down this route. Some of them listed below</source>
          <target state="translated">Преимущество использования DOMlibxml заключается в том,что вы получаете хорошую производительность,потому что вы основываетесь на родном расширении.Однако,не все сторонние библиотеки идут по этому пути.Некоторые из них перечислены ниже</target>
        </trans-unit>
        <trans-unit id="d8816c1d03b50b77e6e6ff51bd569066e7b5a0e5" translate="yes" xml:space="preserve">
          <source>The best method for parse xml:</source>
          <target state="translated">Лучший метод для разбора xml:</target>
        </trans-unit>
        <trans-unit id="4132078238d9256b003dd6494bd23513c071a209" translate="yes" xml:space="preserve">
          <source>The code below comes straight out my &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;DOM-Query library&lt;/a&gt; and uses the technique I described.</source>
          <target state="translated">Приведенный ниже код идет прямо из моей &lt;a href=&quot;https://github.com/PHPPowertools/DOM-Query&quot;&gt;библиотеки DOM-Query&lt;/a&gt; и использует описанную мной технику.</target>
        </trans-unit>
        <trans-unit id="11b52d17561803fdb6224e1ca70f26a54f943a6b" translate="yes" xml:space="preserve">
          <source>The component is designed to work standalone and can be used without Symfony.</source>
          <target state="translated">Компонент предназначен для работы в автономном режиме и может использоваться без Symfony.</target>
        </trans-unit>
        <trans-unit id="df302445bc11b04611b1cf770aa3b7c0254ec538" translate="yes" xml:space="preserve">
          <source>The only drawback is that it will only work with PHP 5.3 or newer.</source>
          <target state="translated">Единственным недостатком является то,что он будет работать только с PHP 5.3 или более новой версией.</target>
        </trans-unit>
        <trans-unit id="58431aa1e93eb44c019b1578434838cf2038f96d" translate="yes" xml:space="preserve">
          <source>The resulting object contains a complete tree representation of the HTML document. It can be traversed using DOM methods. But the common approach is to use CSS selectors like in jQuery:</source>
          <target state="translated">Полученный объект содержит полное древовидное представление HTML-документа.Его можно обойти с помощью DOM-методов.Но общий подход заключается в использовании CSS-селекторов,как в jQuery:</target>
        </trans-unit>
        <trans-unit id="f669955759ac8d7fc7074861be693d4a0720bae0" translate="yes" xml:space="preserve">
          <source>There are however specific use cases where they can help.</source>
          <target state="translated">Однако существуют конкретные случаи использования,в которых они могут помочь.</target>
        </trans-unit>
        <trans-unit id="ba5cb182872adb3d586144d6a301c22c0f539179" translate="yes" xml:space="preserve">
          <source>There are many ways to process HTML/XML DOM of which most have already been mentioned. Hence, I won't make any attempt to list those myself.</source>
          <target state="translated">Существует множество способов обработки HTMLXML DOM,большинство из которых уже было упомянуто.Поэтому я не буду пытаться перечислить их сам.</target>
        </trans-unit>
        <trans-unit id="7fc01c223fb450ac4e6ebdc77a0edd1badd8832f" translate="yes" xml:space="preserve">
          <source>There are several reasons to not parse HTML by regular expression. But, if you have total control of what HTML will be generated, then you can do with simple regular expression.</source>
          <target state="translated">Существует несколько причин не разобрать HTML с помощью регулярных выражений.Но,если у вас есть полный контроль над тем,какой HTML будет генерироваться,то вы можете сделать это с помощью простого регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="f9a9ec64bafcc374d9945fc4204431933239630f" translate="yes" xml:space="preserve">
          <source>Third party alternatives to SimpleHtmlDom that use DOM instead of String Parsing: &lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt;, &lt;a href=&quot;http://framework.zend.com/manual/en/zend.dom.html&quot;&gt;Zend_Dom&lt;/a&gt;, &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; and &lt;a href=&quot;http://www.fluentdom.org/&quot;&gt;FluentDom&lt;/a&gt;.</source>
          <target state="translated">Сторонние альтернативы SimpleHtmlDom, использующие DOM вместо анализа строк: &lt;a href=&quot;http://code.google.com/p/phpquery/&quot;&gt;phpQuery&lt;/a&gt; , &lt;a href=&quot;http://framework.zend.com/manual/en/zend.dom.html&quot;&gt;Zend_Dom&lt;/a&gt; , &lt;a href=&quot;http://querypath.org/&quot;&gt;QueryPath&lt;/a&gt; и &lt;a href=&quot;http://www.fluentdom.org/&quot;&gt;FluentDom&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7416ebc9af5006b615b7faa1baa92773cc5eea4a" translate="yes" xml:space="preserve">
          <source>This extension lets you create XML parsers and then define handlers for different XML events. Each XML parser also has a few parameters you can adjust.</source>
          <target state="translated">Это расширение позволяет создавать парсеры XML,а затем определять обработчики для различных событий XML.Каждый парсер XML также имеет несколько параметров,которые Вы можете настроить.</target>
        </trans-unit>
        <trans-unit id="68b5d2b56e9a5e9c0691dcd4f8be37ab0fb44989" translate="yes" xml:space="preserve">
          <source>This is commonly referred to as &lt;strong&gt;screen scraping&lt;/strong&gt;, by the way. The library I have used for this is &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;Simple HTML Dom Parser&lt;/a&gt;.</source>
          <target state="translated">Кстати, это обычно называется &lt;strong&gt;скребком экрана&lt;/strong&gt; . Для этого я использовал библиотеку &lt;a href=&quot;http://sourceforge.net/projects/simplehtmldom/&quot;&gt;Simple HTML Dom Parser&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e850b37f770cfea1cd7f56ea9dfb592e682e301e" translate="yes" xml:space="preserve">
          <source>This library usually taking less than 1 second to process offline html.</source>
          <target state="translated">Эта библиотека обычно занимает менее 1 секунды на обработку html в автономном режиме.</target>
        </trans-unit>
        <trans-unit id="2beda6ba9b12df24bc719d6612622cddbc5e8c27" translate="yes" xml:space="preserve">
          <source>This sounds like a good task description of W3C &lt;a href=&quot;http://www.w3.org/TR/xpath/&quot;&gt;XPath&lt;/a&gt; technology. It's easy to express queries like &quot;return all &lt;code&gt;href&lt;/code&gt; attributes in &lt;code&gt;img&lt;/code&gt; tags that are nested in &lt;code&gt;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;&amp;lt;baz&amp;gt; elements&lt;/code&gt;.&quot; Not being a PHP buff, I can't tell you in what form XPath may be available. If you can call an external program to process the HTML file you should be able to use a command line version of XPath.
For a quick intro, see &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;http://en.wikipedia.org/wiki/XPath&lt;/a&gt;.</source>
          <target state="translated">Это звучит как хорошее описание задачи технологии W3C &lt;a href=&quot;http://www.w3.org/TR/xpath/&quot;&gt;XPath&lt;/a&gt; . Легко выражать запросы типа &amp;laquo;вернуть все атрибуты &lt;code&gt;href&lt;/code&gt; в тегах &lt;code&gt;img&lt;/code&gt; , которые вложены в &lt;code&gt;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;&amp;lt;baz&amp;gt; elements&lt;/code&gt; &amp;raquo;. Не будучи фанатом PHP, я не могу сказать вам, в какой форме XPath может быть доступен. Если вы можете вызвать внешнюю программу для обработки HTML-файла, вы сможете использовать версию XPath для командной строки. Для быстрого ознакомления см. &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;Http://en.wikipedia.org/wiki/XPath&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a0b9134ff92db59b43251ec557fed51162b65e3" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;&lt;strong&gt;Simple HTML DOM Parser&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">Попробуйте &lt;a href=&quot;http://simplehtmldom.sourceforge.net/&quot;&gt;&lt;strong&gt;простой HTML DOM Parser&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c6d262a8d4b5d18d3efdc5b548b97d2ba672dfe1" translate="yes" xml:space="preserve">
          <source>Under the hood, it uses &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;&lt;strong&gt;symfony/DomCrawler&lt;/strong&gt;&lt;/a&gt; for conversion of CSS selectors to &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; selectors. It always uses the same DomDocument, even when passing one object to another, to ensure decent performance.</source>
          <target state="translated">Под капотом он использует &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;&lt;strong&gt;symfony / DomCrawler&lt;/strong&gt;&lt;/a&gt; для преобразования селекторов CSS в селекторы &lt;a href=&quot;http://en.wikipedia.org/wiki/XPath&quot;&gt;XPath&lt;/a&gt; . Он всегда использует один и тот же DomDocument, даже при передаче одного объекта другому, чтобы обеспечить достойную производительность.</target>
        </trans-unit>
        <trans-unit id="ec1764919721d724665325102a7111340d413d7f" translate="yes" xml:space="preserve">
          <source>Wa72\HtmlPageDom` is a PHP library for easy manipulation of HTML
  documents using  It requires &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;DomCrawler from Symfony2
  components&lt;/a&gt; for traversing  the
  DOM tree and extends it by adding methods for manipulating the DOM
  tree of HTML documents.</source>
          <target state="translated">Wa72 \ HtmlPageDom` - это библиотека PHP для простого манипулирования HTML-документами. Для обхода дерева DOM требуется &lt;a href=&quot;https://github.com/symfony/DomCrawler&quot;&gt;DomCrawler из компонентов Symfony2&lt;/a&gt; и расширяет его, добавляя методы для манипулирования деревом DOM HTML-документов.</target>
        </trans-unit>
        <trans-unit id="2228452e56018a71b37010bd7c5f71859651feca" translate="yes" xml:space="preserve">
          <source>We have created quite a few crawlers for our needs before. At the end of the day, it is usually simple regular expressions that do the thing best. While libraries listed above are good for the reason they are created, if you know what you are looking for, regular expressions is a safer way to go, as you can handle also non-valid &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/XHTML&quot;&gt;XHTML&lt;/a&gt; structures, which would fail, if loaded via most of the parsers.</source>
          <target state="translated">Мы создали довольно много сканеров для наших нужд. В конце концов, обычно лучше всего использовать простые регулярные выражения. Несмотря на то, что перечисленные выше библиотеки хороши по той причине, что они созданы, если вы знаете, что ищете, регулярные выражения - более безопасный путь, поскольку вы можете обрабатывать также недействительные структуры &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/XHTML&quot;&gt;XHTML&lt;/a&gt; , которые потерпят неудачу при загрузке через большинство парсеров.</target>
        </trans-unit>
        <trans-unit id="25f4d5095cb62b0b7e74915ac9d048a7b58ef20f" translate="yes" xml:space="preserve">
          <source>We might see more dedicated parsers once HTML5 is finalized. There is also a blogpost by the W3's titled &lt;a href=&quot;http://www.w3.org/QA/2008/07/html5-parsing-howto.html&quot;&gt;How-To for html 5 parsing&lt;/a&gt; that is worth checking out.</source>
          <target state="translated">Мы можем увидеть больше выделенных парсеров после завершения HTML5. Существует также блог от W3 под названием &lt;a href=&quot;http://www.w3.org/QA/2008/07/html5-parsing-howto.html&quot;&gt;How-To для разбора html 5,&lt;/a&gt; который стоит проверить.</target>
        </trans-unit>
        <trans-unit id="0a5d87433685e87a09cab5597b4bcd5803d667c8" translate="yes" xml:space="preserve">
          <source>WebServices</source>
          <target state="translated">WebServices</target>
        </trans-unit>
        <trans-unit id="dd7868492d1aa630c2532fbee868064147abaa60" translate="yes" xml:space="preserve">
          <source>What it means is that each call on the result set modifies the result set in the object, it's not chainable like in jquery where each link is a new set, you have a single set which is the results from your query and each function call modifies that single set.</source>
          <target state="translated">Это означает,что каждый вызов в результирующем множестве изменяет результирующий набор в объекте,он не является цепным,как в запросе,где каждое звено является новым набором,у вас есть один набор,который является результатом вашего запроса,и каждый вызов функции изменяет этот единственный набор.</target>
        </trans-unit>
        <trans-unit id="958c244d037d86b5bf0abe6245945f8778d00d85" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/servo-php/fluidxml&quot;&gt;&lt;strong&gt;FluidXML&lt;/strong&gt;&lt;/a&gt; you can query and iterate XML using &lt;strong&gt;XPath&lt;/strong&gt; and &lt;strong&gt;CSS Selectors&lt;/strong&gt;.</source>
          <target state="translated">С &lt;a href=&quot;https://github.com/servo-php/fluidxml&quot;&gt;&lt;strong&gt;FluidXML&lt;/strong&gt;&lt;/a&gt; вы можете запрашивать и выполнять итерацию XML, используя &lt;strong&gt;XPath&lt;/strong&gt; и &lt;strong&gt;CSS Selector&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c133d37ec5b2dec248bc847284b37225a00466bc" translate="yes" xml:space="preserve">
          <source>XML Parser</source>
          <target state="translated">парсер XML</target>
        </trans-unit>
        <trans-unit id="482bdc24f6af5a40a01e6c07554b2e716ffcfd71" translate="yes" xml:space="preserve">
          <source>XMLReader</source>
          <target state="translated">XMLReader</target>
        </trans-unit>
        <trans-unit id="d283a97f786ccb4fc2cde7e0509f6b68fe20c76f" translate="yes" xml:space="preserve">
          <source>XMLReader, like DOM, is based on libxml. I am not aware of how to trigger the HTML Parser Module, so chances are using XMLReader for parsing broken HTML might be less robust than using DOM where you can explicitly tell it to use libxml's HTML Parser Module.</source>
          <target state="translated">XMLReader,как и DOM,основан на libxml.Я не знаю,как запустить HTML Parser Module,поэтому шансы использования XMLReader для разбора сломанного HTML могут быть менее надежными,чем использование DOM,где вы можете явно указать ему использовать HTML Parser Module от libxml.</target>
        </trans-unit>
        <trans-unit id="48086d5b2c71a8118002a1eccf45fa90563bef6e" translate="yes" xml:space="preserve">
          <source>Yes you can use simple_html_dom for the purpose. However I have worked quite a lot with the simple_html_dom, particularly for web scrapping and have found it to be too vulnerable. It does the basic job but I won't recommend it anyways.</source>
          <target state="translated">Да,для этой цели можно использовать simple_html_dom.Однако я довольно много работал с simple_html_dom,особенно для веб-скрейпинга,и нашел его слишком уязвимым.Он делает основную работу,но я все равно не буду его рекомендовать.</target>
        </trans-unit>
        <trans-unit id="afacf39f9314512f8b2e4807339393ca1d74c5e5" translate="yes" xml:space="preserve">
          <source>You &lt;a href=&quot;https://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234491#4234491&quot;&gt;can write more reliable parsers&lt;/a&gt;, but writing a &lt;em&gt;complete and reliable&lt;/em&gt; custom parser with regular expressions is a waste of time when the aforementioned libraries already exist and do a much better job on this.</source>
          <target state="translated">Вы &lt;a href=&quot;https://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234491#4234491&quot;&gt;можете писать более надежные парсеры&lt;/a&gt; , но написание &lt;em&gt;полноценного и надежного&lt;/em&gt; пользовательского парсера с регулярными выражениями - пустая трата времени, когда вышеупомянутые библиотеки уже существуют и справляются с этим гораздо лучше.</target>
        </trans-unit>
        <trans-unit id="52244ade1e08c2102f754703196f53beec240409" translate="yes" xml:space="preserve">
          <source>You can then use this (still very low level) subclass as a foundation for more high level classes, intended to eg. parse very specific types of XML or add more jQuery-like behavior.</source>
          <target state="translated">Затем вы можете использовать этот (все еще очень низкий уровень)подкласс в качестве основы для более высокоуровневых классов,предназначенных,например,для разбора очень специфических типов XML или добавления более jQuery-подобного поведения.</target>
        </trans-unit>
        <trans-unit id="57d9a847a211899bc4cd6fd3518ea2a538f3dd72" translate="yes" xml:space="preserve">
          <source>You can use the above for parsing HTML5, but &lt;a href=&quot;https://stackoverflow.com/questions/4029341/dom-parser-that-allows-html5-style-in-script-tag/4029412&quot;&gt;there can be quirks&lt;/a&gt; due to the markup HTML5 allows. So for HTML5 you want to consider using a dedicated parser, like</source>
          <target state="translated">Вы можете использовать вышеизложенное для разбора HTML5, но &lt;a href=&quot;https://stackoverflow.com/questions/4029341/dom-parser-that-allows-html5-style-in-script-tag/4029412&quot;&gt;могут быть причуды&lt;/a&gt; из-за разметки, которую позволяет HTML5. Так что для HTML5 вы хотите рассмотреть возможность использования выделенного парсера, как</target>
        </trans-unit>
        <trans-unit id="118bdac2fe1f904ec22de8b22eed3538f08f7e63" translate="yes" xml:space="preserve">
          <source>You could try using something like &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML_Tidy&quot;&gt;HTML Tidy&lt;/a&gt; to cleanup any &quot;broken&quot; HTML and convert the HTML to XHTML, which you can then parse with a XML parser.</source>
          <target state="translated">Вы можете попробовать использовать что-то вроде &lt;a href=&quot;http://en.wikipedia.org/wiki/HTML_Tidy&quot;&gt;HTML Tidy&lt;/a&gt; для очистки любого &amp;laquo;сломанного&amp;raquo; HTML и преобразования HTML в XHTML, который затем можно проанализировать с помощью синтаксического анализатора XML.</target>
        </trans-unit>
        <trans-unit id="fa5f4b4b6cf574e2ed46980afeaa2a7beb181c3f" translate="yes" xml:space="preserve">
          <source>Zend_Dom</source>
          <target state="translated">Zend_Dom</target>
        </trans-unit>
        <trans-unit id="541d5b4dd20a949161f06bff576afd115dc27318" translate="yes" xml:space="preserve">
          <source>Zend_Dom provides tools for working with DOM documents and structures. Currently, we offer Zend_Dom_Query, which provides a unified interface for querying DOM documents utilizing both XPath and CSS selectors.</source>
          <target state="translated">Zend_Dom предоставляет инструменты для работы с документами и структурами DOM.В настоящее время мы предлагаем Zend_Dom_Query,который предоставляет единый интерфейс для запроса DOM документов с использованием XPath и CSS селекторов.</target>
        </trans-unit>
        <trans-unit id="0ec25b22947ac4e042b417da8d2b81bad44eaff3" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/add/&quot;&gt;$selection.add&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/add/&quot;&gt;$ selection.add&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d3ac6816be3e31697646b0d3f24a61ed10c7a2" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/addClass/&quot;&gt;$selection.addClass&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/addClass/&quot;&gt;$ selection.addClass&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a85d853e8ac9999031be082f20dd3c86b3e07d55" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/after/&quot;&gt;$selection.after&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/after/&quot;&gt;$ selection.after&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="855bb5684e5aaad04444a0bcf366e950952780f8" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/append/&quot;&gt;$selection.append&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/append/&quot;&gt;$ selection.append&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="303d76dbb2b71969494a3da3fd0e207352f68b81" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/attr/&quot;&gt;$selection.attr&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/attr/&quot;&gt;$ selection.attr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35be35f74fc5b6a7ede46666a50b8672913da309" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/before/&quot;&gt;$selection.before&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/before/&quot;&gt;$ selection.before&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1879364aaded1afd20c32ebf100fc3585e48f683" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/children/&quot;&gt;$selection.children&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/children/&quot;&gt;$ selection.children&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="678fdf480ddbd2317286e0512d39327d7446bd7b" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/closest/&quot;&gt;$selection.closest&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/closest/&quot;&gt;$ selection.closest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50da6b564af1bc96331746a72991ea045fba2992" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/contents/&quot;&gt;$selection.contents&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/contents/&quot;&gt;$ selection.contents&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52a5716ac9072af064bad7b789daadb3ef628871" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/detach/&quot;&gt;$selection.detach&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/detach/&quot;&gt;$ selection.detach&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cdeed87a0e184eeda42371e499aff6dcc08e7466" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;$selection.each&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;$ selection.each&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d78f7b714bd611131f42b9656016a521c9ee3ea3" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/empty/&quot;&gt;$selection.empty&lt;/a&gt;&lt;em&gt;(2)&lt;/em&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/empty/&quot;&gt;$ selection.empty&lt;/a&gt; &lt;em&gt;(2)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6e8102a4ebff43aa49148fd4ea1b33c02b29fd5" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/eq/&quot;&gt;$selection.eq&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/eq/&quot;&gt;$ selection.eq&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d9ee2a185ce5f56cead560d1e6223a586084cbf" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/find/&quot;&gt;$selection.find&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/find/&quot;&gt;$ selection.find&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2330f331cc5d6a73493ca3314bfdd95b0fba20e9" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/first/&quot;&gt;$selection.first&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/first/&quot;&gt;$ selection.first&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f200b75980c567c5eaef7a8096eb29ee1699ca1c" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/get/&quot;&gt;$selection.get&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/get/&quot;&gt;$ selection.get&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e76d7cf162ad4950910f97fd211357a71685955e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/insertAfter/&quot;&gt;$selection.insertAfter&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/insertAfter/&quot;&gt;$ selection.insertAfter&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b10ab7d52167901e6f202a90c53135afbe343fab" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/insertBefore/&quot;&gt;$selection.insertBefore&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/insertBefore/&quot;&gt;$ selection.insertBefore&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1116fb1f0e86324bbe307d7cfb7990cb591719e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseHTML/&quot;&gt;$.parseHTML&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseHTML/&quot;&gt;$ .parseHTML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b85b8caed5cad3a75963f879bd83444840e9fac4" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseJSON/&quot;&gt;$.parseJSON&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseJSON/&quot;&gt;$ .parseJSON&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24e21007f15fffbeb12d715b440d8dda82b0fd3e" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseXML/&quot;&gt;$.parseXML&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery.parseXML/&quot;&gt;$ .parseXML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8284a57c23d4c2602d747df3906e7d105a7ebc79" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;$&lt;/a&gt;&lt;em&gt;(1)&lt;/em&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;$&lt;/a&gt; &lt;em&gt;(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41f3041007fb1f1714223d7eb80831018345e0b8" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/last/&quot;&gt;$selection.last&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/last/&quot;&gt;$ selection.last&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b7c6e57b4bf72db36e41ed0f4996a878c5bfc40" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/parent/&quot;&gt;$selection.parent&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/parent/&quot;&gt;$ selection.parent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2966dfa24290fb0d5d1b2426cc2f1fd71d622a62" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/parents/&quot;&gt;$selection.parents&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/parents/&quot;&gt;$ selection.parents&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5e7046e307699d26a7d587af4df3b58264248b0" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/remove/&quot;&gt;$selection.remove&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/remove/&quot;&gt;$ selection.remove&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4558dad027c6574ab3dcfb49125d9a104ae9c7ed" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/removeAttr/&quot;&gt;$selection.removeAttr&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/removeAttr/&quot;&gt;$ selection.removeAttr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78105ee237b89523c07bd548a8d57ebac51c396d" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/removeClass/&quot;&gt;$selection.removeClass&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/removeClass/&quot;&gt;$ selection.removeClass&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8224fc75de7d512420526ac5229a3127fa84011d" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/text/&quot;&gt;$selection.text&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/text/&quot;&gt;$ selection.text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6bf903823bfa2ea35e684feeeee397f598eb071c" translate="yes" xml:space="preserve">
          <source>[x] &lt;a href=&quot;http://api.jquery.com/wrap/&quot;&gt;$selection.wrap&lt;/a&gt;</source>
          <target state="translated">[x] &lt;a href=&quot;http://api.jquery.com/wrap/&quot;&gt;$ selection.wrap&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ece6afcddc52bae163f5f7ba435c9607ff7a44b9" translate="yes" xml:space="preserve">
          <source>fDOMDocument</source>
          <target state="translated">fDOMDocument</target>
        </trans-unit>
        <trans-unit id="fe8b7d5279a6e14f60beb4f954ad1e8d77ed6d3a" translate="yes" xml:space="preserve">
          <source>fDOMDocument extends the standard DOM to use exceptions at all occasions of errors instead of PHP warnings or notices. They also add various custom methods and shortcuts for convenience and to simplify the usage of DOM.</source>
          <target state="translated">fDOMDocument расширяет стандартную флэш-память,чтобы использовать исключения во всех случаях ошибок вместо предупреждений или уведомлений PHP.Они также добавляют различные пользовательские методы и ярлыки для удобства и упрощения использования DOM.</target>
        </trans-unit>
        <trans-unit id="6183fbc196e925ae7677bf0da88d2d39315c592e" translate="yes" xml:space="preserve">
          <source>html5lib</source>
          <target state="translated">html5lib</target>
        </trans-unit>
        <trans-unit id="e4a3835ab80fda4ba43679f366d992ba21d09b91" translate="yes" xml:space="preserve">
          <source>iit makes optimal use of the performance advantage of the underlying C code</source>
          <target state="translated">iit оптимально использует преимущество производительности основного кода на C</target>
        </trans-unit>
        <trans-unit id="c52c0b0f2b1233115b4ed3459d964df89266f51d" translate="yes" xml:space="preserve">
          <source>in order to get jquery-like behaviour, you need to branch before you do a filter/modify like operation, that means it'll mirror what happens in jquery much more closely.</source>
          <target state="translated">Для того,чтобы получить поведение,похожее на jquery-,вам нужно выполнить разветвление перед тем,как вы сделаете операцию по изменению фильтра,это означает,что она будет гораздо более точно отражать то,что происходит в jquery-запросе.</target>
        </trans-unit>
        <trans-unit id="16a2198898695f10acf40db122134ecdb1b43a35" translate="yes" xml:space="preserve">
          <source>is way less readable than a simple phpQuery or QueryPath equivalent:</source>
          <target state="translated">гораздо менее читабельный,чем простой phpQuery или QueryPath эквивалент:</target>
        </trans-unit>
        <trans-unit id="1e8a470cab2da73401e5efabc30513d95e8be9b3" translate="yes" xml:space="preserve">
          <source>it has a syntax used for DOM crawling that's similar to the syntax used in native Javascript.</source>
          <target state="translated">у него есть синтаксис,используемый для сканирования DOM,похожий на синтаксис,используемый в родном Javascript.</target>
        </trans-unit>
        <trans-unit id="2acd5a91faeb1fb9c21d40b879ce82bbbcf96f98" translate="yes" xml:space="preserve">
          <source>it provides access to every part of the DOM (unlike eg. SimpleXml, which ignores some of the lesser known XML features)</source>
          <target state="translated">он обеспечивает доступ к каждой части DOM (в отличие от SimpleXml,который игнорирует некоторые менее известные возможности XML).</target>
        </trans-unit>
        <trans-unit id="6478e095583c0555f703929b4a75f5be57f03aff" translate="yes" xml:space="preserve">
          <source>it's OO PHP (and allows me to subclass it)</source>
          <target state="translated">это OO PHP (и позволяет мне разбить его на подклассы).</target>
        </trans-unit>
        <trans-unit id="da4c11ceac906e374f2b1270f8aba16b0ded1ef2" translate="yes" xml:space="preserve">
          <source>it's rather low level (which allows me to use it as a non-bloated foundation for more advanced behavior)</source>
          <target state="translated">это довольно низкий уровень (что позволяет мне использовать его в качестве небесплатной основы для более продвинутого поведения).</target>
        </trans-unit>
        <trans-unit id="f8fb16080572c5a5248ed720d5de1897d3eccaa6" translate="yes" xml:space="preserve">
          <source>phpQuery is a server-side, chainable, CSS3 selector driven Document Object Model (DOM) API based on jQuery JavaScript Library written in PHP5 and provides additional Command Line Interface (CLI).</source>
          <target state="translated">phpQuery-это API Document Object Model (DOM)на основе библиотеки jQuery JavaScript Library,написанной на PHP5 и предоставляющей дополнительный интерфейс командной строки (CLI),управляемый селектором CSS3 на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="14704b5b32c155a763a90cd2bf348e51d8711978" translate="yes" xml:space="preserve">
          <source>sabre/xml</source>
          <target state="translated">sabre/xml</target>
        </trans-unit>
        <trans-unit id="1fa25a1b1b0a0b78c16fd03b682f35fe48665c99" translate="yes" xml:space="preserve">
          <source>sabre/xml is a library that wraps and extends the XMLReader and XMLWriter classes to create a simple &quot;xml to object/array&quot; mapping system and design pattern. Writing and reading XML is single-pass and can therefore be fast and require low memory on large xml files.</source>
          <target state="translated">sabrexml-это библиотека,которая обёртывает и расширяет классы XMLReader и XMLWriter для создания простой системы отображения &quot;xml в объектный массив&quot; и шаблона дизайна.Запись и чтение XML является однопроходным и поэтому может быть быстрым и требовать мало памяти на больших xml файлах.</target>
        </trans-unit>
        <trans-unit id="2726678412f8c2f63bf25a0b979427e67317dca3" translate="yes" xml:space="preserve">
          <source>simplehtmldom.sourceforge</source>
          <target state="translated">simplehtmldom.sourceforge</target>
        </trans-unit>
        <trans-unit id="3d3fda78504589a52345e3396c32f830cf7698e2" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$results&lt;/code&gt; won't be modified and you can reuse the result set again and again, perhaps somebody with much more knowledge can clear this up a bit, but it's basically like this from what I've found.</source>
          <target state="translated">тогда &lt;code&gt;$results&lt;/code&gt; не будет изменен, и вы сможете использовать набор результатов снова и снова, возможно, кто-то с гораздо большими знаниями сможет немного прояснить это, но это в основном так из того, что я нашел.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
