<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/57483">
    <body>
      <group id="57483">
        <trans-unit id="366a1392d254b91c2979dbb347d6a6006020e4a8" translate="yes" xml:space="preserve">
          <source>(A side note: the question may be significant earlier than any &quot;C-like&quot; languages are involved, like &lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;ALGOL 68 vs. PL/I&lt;/a&gt;.)</source>
          <target state="translated">(Дополнительное примечание: вопрос может быть значимым раньше, чем участвуют какие-либо &quot;C-подобные&quot; языки, такие как &lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;ALGOL 68 против PL / I.&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3c2cc5a14dd2d409d181bc8d16bec43175ff2ec5" translate="yes" xml:space="preserve">
          <source>(Similarly, &lt;em&gt;lambda-expression&lt;/em&gt;s are &lt;em&gt;not&lt;/em&gt; syntactic sugar of any other features in C++ because it cannot be precisely simulated with &quot;unspecified&quot; properties like &lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;the declaration order of the captured variables&lt;/a&gt;, which may be important because the initialization order of such variables can be significant.)</source>
          <target state="translated">(Точно так же &lt;em&gt;лямбда-выражения&lt;/em&gt; s &lt;em&gt;не&lt;/em&gt; являются синтаксическим сахаром каких-либо других функций в C ++, потому что они не могут быть точно смоделированы с &amp;laquo;неуказанными&amp;raquo; свойствами, такими &lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;как порядок объявления захваченных переменных&lt;/a&gt; , что может быть важно, потому что порядок инициализации таких переменных может быть значительное.)</target>
        </trans-unit>
        <trans-unit id="1f3d6284e82153785e1a110247b2169240f95d81" translate="yes" xml:space="preserve">
          <source>(or &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; which still relies on an implicit cast
to &lt;code&gt;T&amp;amp;&lt;/code&gt;)</source>
          <target state="translated">(или &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; который все еще полагается на неявное приведение к &lt;code&gt;T&amp;amp;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="eb9fd6a3244bc886192add4286c3f4e955b01e2c" translate="yes" xml:space="preserve">
          <source>... An object occupies a region of storage in its period of construction, throughout its lifetime, and in its period of destruction. ...</source>
          <target state="translated">...Объект занимает район хранения в период его строительства,на протяжении всего срока службы и в период его разрушения....</target>
        </trans-unit>
        <trans-unit id="aedfef1b56582c6d5ac761f02dc136e601d184b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias_Tom&lt;/code&gt; can be understood as an &lt;code&gt;alias of a variable&lt;/code&gt; (different with &lt;code&gt;typedef&lt;/code&gt;, which is &lt;code&gt;alias of a type&lt;/code&gt;) &lt;code&gt;Tom&lt;/code&gt;. It is also OK to forget the terminology of such statement is to create a reference of &lt;code&gt;Tom&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alias_Tom&lt;/code&gt; можно понимать как &lt;code&gt;alias of a variable&lt;/code&gt; (отличается от &lt;code&gt;typedef&lt;/code&gt; , который является &lt;code&gt;alias of a type&lt;/code&gt; ) &lt;code&gt;Tom&lt;/code&gt; . Также можно забыть, что терминология такого утверждения - создать ссылку на &lt;code&gt;Tom&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a7b84169fee1ce093f438b076f5fe4d63635e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo.bar&lt;/code&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; in the same way that &lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs&lt;/a&gt; :-)</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; &lt;em&gt;явно&lt;/em&gt; превосходит &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; точно так же, как &lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt; &lt;em&gt;явно&lt;/em&gt; превосходит &lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs&lt;/a&gt; :-)</target>
        </trans-unit>
        <trans-unit id="53a62ec44b159bf24f77f722d3f80606a21a3355" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C++: Reference to Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C ++: ссылка на указатель&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8503c60ec396a2706a5881136f438f315e36942e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;Pointer-to-Pointer and Reference-to-Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;Указатель на указатель и ссылка на указатель&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="48e4529752dcdcff6551309a435706e66b4247e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Copy constructors&lt;/em&gt;. Syntactically it makes sense to pass objects to copy constructors, and not pointers to objects. But there is just no way for a copy constructor to take an object by value - it would result in a recursive call to the same copy constructor. This leaves references as the only option here.</source>
          <target state="translated">&lt;em&gt;Копировать конструкторы&lt;/em&gt; . Синтаксически имеет смысл передавать объекты для копирования конструкторов, а не указатели на объекты. Но у конструктора копирования просто нет возможности получить объект по значению - это приведет к рекурсивному вызову того же конструктора копирования. Это оставляет ссылки как единственный вариант здесь.</target>
        </trans-unit>
        <trans-unit id="5429e39b4353f38912f315f0cc3b02247f3caa2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lvalues&lt;/em&gt;. Consider the statement &lt;code&gt;str[0] = 'X';&lt;/code&gt; Without references it would only work for c-strings (&lt;code&gt;char* str&lt;/code&gt;). Returning the character by reference allows user-defined classes to have the same notation.</source>
          <target state="translated">&lt;em&gt;Lvalues&lt;/em&gt; . Рассмотрим утверждение &lt;code&gt;str[0] = 'X';&lt;/code&gt; Без ссылок это будет работать только для c-строк ( &lt;code&gt;char* str&lt;/code&gt; ). Возвращение символа по ссылке позволяет пользовательским классам иметь одинаковые обозначения.</target>
        </trans-unit>
        <trans-unit id="a6bbf825dc87806d5d7ecc42e1a033d722c63bd0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Operator overloads&lt;/em&gt;. With references it is possible to introduce indirection to an operator call - say, &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; while retaining the same infix notation. This also works for regular overloaded functions.</source>
          <target state="translated">&lt;em&gt;Операторские перегрузки&lt;/em&gt; . С помощью ссылок можно ввести косвенное обращение к вызову оператора, скажем, &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; , сохраняя ту же инфиксную запись. Это также работает для обычных перегруженных функций.</target>
        </trans-unit>
        <trans-unit id="59d32a7fbc66b86330c68b00f7b2998e9416fddd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Templates&lt;/em&gt;. Since template parameters are duck-typed, syntactic properties of a type is all that matters, so often the same template can be used with both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Шаблоны&lt;/em&gt; Поскольку параметры шаблона имеют тип утка, синтаксические свойства типа имеют значение, поэтому часто один и тот же шаблон может использоваться как с &lt;code&gt;T&lt;/code&gt; ,так и с &lt;code&gt;T&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5cd9611e4f3bbd50027970fffa4f1f1bd8dbc48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;So, a pointer and a reference both use the same amount of memory.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Таким образом, указатель и ссылка используют одинаковый объем памяти.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6b3894bff8b5c460864e665b4235fd4094d8df4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remember, my examples above are just that, examples demonstrating what a reference is, you would never want to use a reference in those ways! For proper usage of a reference there are plenty of answers on here already that hit the nail on the head&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Помните, что приведенные выше примеры - это просто примеры, демонстрирующие, что такое ссылка, вы никогда не захотите использовать ссылку таким образом!&lt;/strong&gt; &lt;strong&gt;Для правильного использования ссылки здесь уже есть множество ответов, которые бьют по голове&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6654cb2acb8b91a57f09603862f530ef72caa5eb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reference&lt;/em&gt; can be thought of as a &lt;em&gt;constant pointer&lt;/em&gt; (not to be confused with a pointer to a constant value!) with automatic indirection, ie the compiler will apply the &lt;code&gt;*&lt;/code&gt; operator for you.</source>
          <target state="translated">&lt;em&gt;Ссылку&lt;/em&gt; можно рассматривать как &lt;em&gt;указатель&lt;/em&gt; на &lt;em&gt;константу&lt;/em&gt; (не путать с указателем на постоянное значение!) С автоматическим перенаправлением, т. Е. Компилятор применяет для вас оператор &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36e44be1b0929668f83744e378c80d1a24783473" translate="yes" xml:space="preserve">
          <source>A compiler keeps &quot;references&quot; to variables, associating a name with a memory address; that's its job to translate any variable name to a memory address when compiling.</source>
          <target state="translated">Компилятор хранит &quot;ссылки&quot; на переменные,связывая имя с адресом памяти;это его работа-транслировать любое имя переменной в адрес памяти при компиляции.</target>
        </trans-unit>
        <trans-unit id="959270cda595c9f1ce741e1f2ab621476334d43d" translate="yes" xml:space="preserve">
          <source>A const pointer's target can be replaced by taking its address and using a const cast.</source>
          <target state="translated">Цель указателя const может быть заменена путем взятия его адреса и использования const cast.</target>
        </trans-unit>
        <trans-unit id="d4063e6d466457440be12f195a44c703d4bcd7c2" translate="yes" xml:space="preserve">
          <source>A few more special rules on references:</source>
          <target state="translated">Еще несколько специальных правил по ссылкам:</target>
        </trans-unit>
        <trans-unit id="1b35409877b7144ea91c809ff4d316184f00d741" translate="yes" xml:space="preserve">
          <source>A pointer can be initialized to 0 and a reference not. In fact, a reference must also refer to an object, but a pointer can be the null pointer:</source>
          <target state="translated">Указатель может быть инициализирован на 0,а ссылка-нет.Фактически,ссылка также должна ссылаться на объект,но указатель может быть нулевым:</target>
        </trans-unit>
        <trans-unit id="eb1a8b8982766e580a85ab0d0eb62a2e311e86ba" translate="yes" xml:space="preserve">
          <source>A pointer can be re-assigned:</source>
          <target state="translated">Указатель может быть переназначен:</target>
        </trans-unit>
        <trans-unit id="5dcd9a2027d394eca47f36591f61027051772bca" translate="yes" xml:space="preserve">
          <source>A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.  Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable.  Note: What a pointer points to can be on the stack or heap.  Ditto a reference. My claim in this statement is not that a pointer must point to the stack.  A pointer is just a variable that holds a memory address.  This variable is on the stack.  Since a reference has its own space on the stack, and since the address is the same as the variable it references.  More on &lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;stack vs heap&lt;/a&gt;.  This implies that there is a real address of a reference that the compiler will not tell you.</source>
          <target state="translated">Указатель имеет свой собственный адрес и размер памяти в стеке (4 байта в x86), тогда как ссылка использует тот же адрес памяти (с исходной переменной), но также занимает некоторое место в стеке. Поскольку ссылка имеет тот же адрес, что и сама исходная переменная, можно с уверенностью рассматривать ссылку как другое имя для той же переменной. Примечание. То, на что указывает указатель, может быть в стеке или куче. Так же ссылка. Мое утверждение в этом утверждении не в том, что указатель должен указывать на стек. Указатель - это просто переменная, которая содержит адрес памяти. Эта переменная находится в стеке. Поскольку ссылка имеет свое собственное пространство в стеке, а адрес совпадает с переменной, на которую она ссылается. Больше в &lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;стеке против кучи&lt;/a&gt; . Это означает, что существует реальный адрес ссылки, о которой вам не сообщит компилятор.</target>
        </trans-unit>
        <trans-unit id="fd455ef49a557a536ce9186591eed75410f73093" translate="yes" xml:space="preserve">
          <source>A pointer needs to be dereferenced with &lt;code&gt;*&lt;/code&gt; to access the memory location it points to, whereas a reference can be used directly.  A pointer to a class/struct uses &lt;code&gt;-&amp;gt;&lt;/code&gt; to access it's members whereas a reference uses a &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">Чтобы получить доступ к области памяти, на которую он указывает, указатель должен быть разыменован с помощью &lt;code&gt;*&lt;/code&gt; , тогда как ссылка может использоваться напрямую. Указатель на класс / структуру использует &lt;code&gt;-&amp;gt;&lt;/code&gt; для доступа к его членам, тогда как ссылка использует &lt;code&gt;.&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="5d9e2dd57673143f5ecc15f3125a1e7c15d2ff7a" translate="yes" xml:space="preserve">
          <source>A pointer requires the location of a piece of space on screen that you assure it will contain zero or more instances of that window type.</source>
          <target state="translated">Указатель требует размещения на экране фрагмента пространства,который,как вы уверены,будет содержать ноль или больше экземпляров этого типа окна.</target>
        </trans-unit>
        <trans-unit id="01435a266fb491eeeb93f2b49ededf5562a78098" translate="yes" xml:space="preserve">
          <source>A reference can never be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Ссылка никогда не может быть &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0db1497e17b4f2171e4c44bff76f09fecf03b574" translate="yes" xml:space="preserve">
          <source>A reference cannot, and must be assigned at initialization:</source>
          <target state="translated">Ссылка не может и должна быть назначена при инициализации:</target>
        </trans-unit>
        <trans-unit id="8de8f4c2eb87e4ad0059dd772dd0e8d9c15b2d0c" translate="yes" xml:space="preserve">
          <source>A reference is an alias for another variable whereas a pointer holds the memory address of a variable. References are generally used as function parameters so that the passed object is not the copy but the object itself.</source>
          <target state="translated">Ссылка-это псевдоним для другой переменной,в то время как указатель содержит адрес памяти переменной.Ссылки обычно используются в качестве параметров функции,так что передаваемый объект-это не копия,а сам объект.</target>
        </trans-unit>
        <trans-unit id="3fc4f36217977d4385453e9d1605a1d3c9c91d83" translate="yes" xml:space="preserve">
          <source>A reference is not another name given to some memory. It's a immutable pointer that is automatically de-referenced on usage. Basically it boils down to:</source>
          <target state="translated">Ссылка-это не другое имя,данное некоторой памяти.Это неизменяемый указатель,который автоматически удаляется при использовании.По сути,она сводится к..:</target>
        </trans-unit>
        <trans-unit id="408fd2770a09c3097a4198b48fb7f80ff76674a3" translate="yes" xml:space="preserve">
          <source>A reference requires you to specify an actual window.</source>
          <target state="translated">Ссылка требует указать фактическое окно.</target>
        </trans-unit>
        <trans-unit id="7a62bb0cc0b8710c81c16b83f6655a27f1f4f924" translate="yes" xml:space="preserve">
          <source>A reference to a pointer is possible in C++, but the reverse is not possible means a pointer to a reference isn't possible. A reference to a pointer provides a cleaner syntax to modify the pointer.
Look at this example:</source>
          <target state="translated">Ссылка на указатель возможна в языке Си++,но обратное невозможно,то есть указатель на ссылку невозможен.Ссылка на указатель обеспечивает более чистый синтаксис для модификации указателя.Посмотрите на этот пример:</target>
        </trans-unit>
        <trans-unit id="f9bf408f44a75a28c1f97df5e2c724d88eaec294" translate="yes" xml:space="preserve">
          <source>A reference's target cannot be replaced in any way short of UB.</source>
          <target state="translated">Цель ссылки не может быть заменена ни в коем случае без UB.</target>
        </trans-unit>
        <trans-unit id="5355053294d8994c0ecb21bffdd545b0a989f529" translate="yes" xml:space="preserve">
          <source>Actually, a reference is not really like a pointer.</source>
          <target state="translated">На самом деле,ссылка не совсем похожа на указатель.</target>
        </trans-unit>
        <trans-unit id="e7cbf8356a1da6417d65167e6890b1ece5d79c47" translate="yes" xml:space="preserve">
          <source>After the assignment, ival, the object addressed by pi remains unchanged. The assignment changes the value of pi, making it point to a different object. Now consider a similar program that assigns two references:</source>
          <target state="translated">После назначения,двузначного,объект,адресуемый пи,остается неизменным.Присвоение изменяет значение пи,делая его указателем на другой объект.Теперь рассмотрим аналогичную программу,которая присваивает две ссылки:</target>
        </trans-unit>
        <trans-unit id="789209b07ed91340d591d3ecbd391a25bb1a617e" translate="yes" xml:space="preserve">
          <source>All references must be initialized with a non-null value or compilation will fail. It's neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references.</source>
          <target state="translated">Все ссылки должны быть инициализированы ненулевым значением,иначе компиляция будет неудачной.Получить адрес ссылки невозможно-оператор адреса вернет адрес ссылающегося значения вместо него-и арифметику по ссылкам делать нельзя.</target>
        </trans-unit>
        <trans-unit id="4a0d598143cbd5c038eec18a5364ebca3ce06755" translate="yes" xml:space="preserve">
          <source>Also, a reference that is a parameter to a function that is inlined may be handled differently than a pointer.</source>
          <target state="translated">Кроме того,ссылка,являющаяся параметром на функцию,которая встраивается,может обрабатываться не так,как указатель.</target>
        </trans-unit>
        <trans-unit id="198270e21c92ca200586af9582ab1a26ef99e93d" translate="yes" xml:space="preserve">
          <source>Also, spare 10 minutes and watch this video: &lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;https://www.youtube.com/watch?v=rlJrrGV0iOg&lt;/a&gt;</source>
          <target state="translated">Кроме того, уделите 10 минут и посмотрите это видео: &lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;https://www.youtube.com/watch?v=rlJrrGV0iOg&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="def296e5debd47695d96a2e810d313523875ea0e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;object&lt;/em&gt; type is a (possibly &lt;em&gt;cv&lt;/em&gt;-qualified) type that is not a function type, not a reference type, and not &lt;em&gt;cv&lt;/em&gt; void.</source>
          <target state="translated">Тип &lt;em&gt;объекта&lt;/em&gt; - это (возможно, &lt;em&gt;cv-&lt;/em&gt; квалифицированный) тип, который не является типом функции, не ссылочным типом и не &lt;em&gt;cv&lt;/em&gt; void.</target>
        </trans-unit>
        <trans-unit id="aaa58e7db6a960dc51cd22c3dc1684dfd20f847c" translate="yes" xml:space="preserve">
          <source>An optimizing compiler may realize that we are accessing a[0] and a[1] quite a bunch. It would love to optimize the algorithm to:</source>
          <target state="translated">Оптимизирующий компилятор может понять,что мы обращаемся к a[0]и a[1]довольно много.Ему хотелось бы оптимизировать алгоритм до:</target>
        </trans-unit>
        <trans-unit id="a77f60581112f1094707329df4c6d30c6956a373" translate="yes" xml:space="preserve">
          <source>And consider the C version of the above program. In C you have to use pointer to pointer (multiple indirection), and it leads to confusion and the program may look complicated.</source>
          <target state="translated">И рассмотрим C-версию вышеуказанной программы.В Си необходимо использовать указатель на указатель (множественное указание),что приводит к путанице,и программа может выглядеть запутанной.</target>
        </trans-unit>
        <trans-unit id="ddb61be46c893264465a08b177ca023b9286da4f" translate="yes" xml:space="preserve">
          <source>Another difference is that pointer can point to another object however reference is always referencing to the same object, let&amp;rsquo;s take this example:</source>
          <target state="translated">Другое отличие состоит в том, что указатель может указывать на другой объект, однако ссылка всегда ссылается на один и тот же объект, давайте рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="d9d2f372f903617152234f6054a59f4db746d3e3" translate="yes" xml:space="preserve">
          <source>Another difference is that you can have pointers to a void type (and it means pointer to anything) but references to void are forbidden.</source>
          <target state="translated">Другое отличие состоит в том,что вы можете иметь указатели на тип void (и это означает указатель на что угодно),но ссылки на void запрещены.</target>
        </trans-unit>
        <trans-unit id="ed06ace0f97d6901e5c79ad444c40f4d371c03fa" translate="yes" xml:space="preserve">
          <source>Another important point is that is we can make the declaration of the pointer without initialization however no such thing can be done in case of reference which must make a reference always to variable or object. However such use of a pointer is risky so generally we check if the pointer is actually is pointing to something or not. In case of a reference no such check is necessary, because we know already that referencing to an object during declaration is mandatory.</source>
          <target state="translated">Другой важный момент заключается в том,что мы можем сделать объявление указателя без инициализации,однако ничего подобного нельзя сделать в случае ссылки,которая должна всегда делать ссылку на переменную или объект.Однако такое использование указателя рискованно,поэтому обычно мы проверяем,действительно ли указатель на что-то указывает или нет.В случае ссылки нет необходимости в такой проверке,так как мы уже знаем,что ссылка на объект при объявлении является обязательной.</target>
        </trans-unit>
        <trans-unit id="cab05ab1c2c0ef5b2ba43eff8ccf5c0c4d2d12e9" translate="yes" xml:space="preserve">
          <source>Another interesting use of references is to supply a default argument of a user-defined type:</source>
          <target state="translated">Еще одним интересным использованием ссылок является предоставление аргумента по умолчанию пользовательского типа:</target>
        </trans-unit>
        <trans-unit id="8405a7757378ccd741f1d45d9bcb524d4b5f3829" translate="yes" xml:space="preserve">
          <source>Another point: When we have a template like an STL template such kind of a class template will always return a reference, not a pointer, to make easy reading or assigning new value using operator []:</source>
          <target state="translated">Еще один момент:Когда у нас есть шаблон типа STL,такой шаблон класса всегда возвращает ссылку,а не указатель,чтобы облегчить чтение или присвоение нового значения с помощью оператора []:</target>
        </trans-unit>
        <trans-unit id="8ae9e0a7b8d69bc4223ff39bbb83d311d51fca21" translate="yes" xml:space="preserve">
          <source>Apart from syntactic sugar, a reference is a &lt;code&gt;const&lt;/code&gt; pointer (&lt;em&gt;not&lt;/em&gt; pointer to a &lt;code&gt;const&lt;/code&gt;). You must establish what it refers to when you declare the reference variable, and you cannot change it later.</source>
          <target state="translated">Помимо синтаксического сахара, ссылка - это указатель &lt;code&gt;const&lt;/code&gt; (а &lt;em&gt;не&lt;/em&gt; указатель на &lt;code&gt;const&lt;/code&gt; ). Вы должны установить, к чему это относится, когда объявляете ссылочную переменную, и вы не можете изменить ее позже.</target>
        </trans-unit>
        <trans-unit id="8d8f44fcd3e6f397b6db8398ce3d44734a996ea7" translate="yes" xml:space="preserve">
          <source>As I said, a pointer to a reference isn't possible. Try the following program:</source>
          <target state="translated">Как я уже сказал,указатель на ссылку невозможен.Попробуйте следующую программу:</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">В качестве примера:</target>
        </trans-unit>
        <trans-unit id="82db7c2ab0468c723d35542df3eb95e5e5ba8cad" translate="yes" xml:space="preserve">
          <source>At the highest-level, the idea of references is that they are transparent &quot;aliases&quot;. Your computer may use an address to make them work, but you're not supposed to worry about that: you're supposed to think of them as &quot;just another name&quot; for an existing object and the syntax reflects that. They are stricter than pointers so your compiler can more reliably warn you when you about to create a dangling reference, than when you are about to create a dangling pointer.</source>
          <target state="translated">На самом высоком уровне идея ссылок заключается в том,что они являются прозрачными &quot;псевдонимами&quot;.Ваш компьютер может использовать адрес,чтобы заставить их работать,но вы не должны беспокоиться об этом:вы должны думать о них как о &quot;просто другом имени&quot; для существующего объекта,и синтаксис отражает это.Они строже,чем указатели,поэтому ваш компилятор может более надежно предупредить вас,когда вы собираетесь создать висячую ссылку,чем когда вы собираетесь создать висячий указатель.</target>
        </trans-unit>
        <trans-unit id="1c79f63a01a5e0dc422bfd0d4cf499645ee5ba60" translate="yes" xml:space="preserve">
          <source>At the risk of adding to confusion, I want to throw in some input, I'm sure it mostly depends on how the compiler implements references, but in the case of gcc the idea that a reference can only point to a variable on the stack is not actually correct, take this for example:</source>
          <target state="translated">Рискуя внести путаницу,я хочу подкинуть немного входных данных,я уверен,что это в основном зависит от того,как компилятор реализует ссылки,но в случае с gcc мысль,что ссылка может указывать только на переменную на стеке,на самом деле не правильна,возьмем,к примеру,это:</target>
        </trans-unit>
        <trans-unit id="e6de6d55fd9e888c00be46ee2285966c7f90196b" translate="yes" xml:space="preserve">
          <source>BTW, a few other contexts like initialization involving &lt;code&gt;std::initializer_list&lt;/code&gt; follows some similar rules of reference lifetime extension. It is another can of worms.</source>
          <target state="translated">Кстати, некоторые другие контексты, такие как инициализация с использованием &lt;code&gt;std::initializer_list&lt;/code&gt; следуют некоторым похожим правилам продления срока службы ссылок. Это еще одна банка червей.</target>
        </trans-unit>
        <trans-unit id="28157cc4e97b442db1a423840eb02259f1ee9ada" translate="yes" xml:space="preserve">
          <source>Back in C, a call that looks like &lt;code&gt;fn(x)&lt;/code&gt; can only be passed by value, so it definitely cannot modify &lt;code&gt;x&lt;/code&gt;; to modify an argument you would need to pass a pointer &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt;. So if an argument wasn't preceded by an &lt;code&gt;&amp;amp;&lt;/code&gt; you knew it would not be modified. (The converse, &lt;code&gt;&amp;amp;&lt;/code&gt; means modified, was not true because you would sometimes have to pass large read-only structures by &lt;code&gt;const&lt;/code&gt; pointer.)</source>
          <target state="translated">В C вызов, похожий на &lt;code&gt;fn(x)&lt;/code&gt; может быть передан только по значению, поэтому он определенно не может изменить &lt;code&gt;x&lt;/code&gt; ; чтобы изменить аргумент, вам нужно передать указатель &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt; . Поэтому, если аргументу не предшествует &lt;code&gt;&amp;amp;&lt;/code&gt; , вы знали, что он не будет изменен. (Обратное, &lt;code&gt;&amp;amp;&lt;/code&gt; означает изменение, было неверно, потому что иногда вам приходилось передавать большие структуры только для чтения с помощью &lt;code&gt;const&lt;/code&gt; указателя.)</target>
        </trans-unit>
        <trans-unit id="52fbc9beddeb6a8c7a6bb62a43b5c950f4daeb34" translate="yes" xml:space="preserve">
          <source>Beyond that, there are of course some practical differences between pointers and references. The syntax to use them is obviously different, and you cannot &quot;re-seat&quot; references, have references to nothingness, or have pointers to references.</source>
          <target state="translated">Кроме того,конечно же,существуют некоторые практические различия между указателями и ссылками.Очевидно,что синтаксис их использования отличается,и вы не можете &quot;сесть&quot; заново&quot; ссылки,иметь ссылки на ничто или иметь указатели на ссылки.</target>
        </trans-unit>
        <trans-unit id="2f0a115b892ed33dc580b0746ea765524e9adee4" translate="yes" xml:space="preserve">
          <source>But if a reference &lt;em&gt;really&lt;/em&gt; were the object, how could there be dangling references? In unmanaged languages, it's impossible for references to be any 'safer' than pointers - there generally just isn't a way to reliably alias values across scope boundaries!</source>
          <target state="translated">Но если ссылка &lt;em&gt;действительно&lt;/em&gt; была объектом, как могли быть висячие ссылки? В неуправляемых языках невозможно, чтобы ссылки были более &amp;laquo;безопасными&amp;raquo;, чем указатели - как правило, просто не существует способа надежного псевдонима значений за пределами границ области действия!</target>
        </trans-unit>
        <trans-unit id="c0f0472a48232cf765cdc5a4ed86bcc402178e6e" translate="yes" xml:space="preserve">
          <source>But this is not the whole story. I mean, there are more things than pointers vs references you have to consider.</source>
          <target state="translated">Но это не вся история.Я имею в виду,что есть больше вещей,чем указатели против ссылок.</target>
        </trans-unit>
        <trans-unit id="1219d69d4aae4754c68f172af1e20be534822a2e" translate="yes" xml:space="preserve">
          <source>But we can&amp;rsquo;t have &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; and also &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt;.</source>
          <target state="translated">Но мы не можем иметь &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; а также &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="85c1119a1a34eb5b96e7a27219b6d23bf265027f" translate="yes" xml:space="preserve">
          <source>But what are the differences?</source>
          <target state="translated">Но в чем разница?</target>
        </trans-unit>
        <trans-unit id="ea217864ff94b0a58af879bc82826ac7131e836c" translate="yes" xml:space="preserve">
          <source>C programmers might dislike C++ references as it will no longer be obvious when indirection happens or if an argument gets passed by value or by pointer without looking at function signatures.</source>
          <target state="translated">Программистам на Си может не понравиться ссылка на Си++,так как она больше не будет очевидна,когда произойдет индирекция,или если аргумент будет передан по значению или по указателю,не глядя на сигнатуры функции.</target>
        </trans-unit>
        <trans-unit id="4a06c33b9cfbaa63574bd669ad9aaf1bc634c44a" translate="yes" xml:space="preserve">
          <source>C++ only has a few kinds of syntactic sugars in this strict sense. One instance is (inherited from C) the built-in (non-overloaded) operator &lt;code&gt;[]&lt;/code&gt;, which &lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;is defined exactly having same semantic properties of specific forms of combination over built-in operator unary &lt;code&gt;*&lt;/code&gt; and binary &lt;code&gt;+&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В этом строгом смысле C ++ имеет только несколько видов синтаксических сахаров. Одним из экземпляров является (унаследованный от C) встроенный (не перегруженный) оператор &lt;code&gt;[]&lt;/code&gt; , который &lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;точно определен с такими же семантическими свойствами определенных форм комбинации, что и встроенный оператор unary &lt;code&gt;*&lt;/code&gt; и binary &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bb21fac313bcd60906b2b35ca4582ec35330749" translate="yes" xml:space="preserve">
          <source>C++ programmers might dislike using pointers as they are considered unsafe - although references aren't really any safer than constant pointers except in the most trivial cases - lack the convenience of automatic indirection and carry a different semantic connotation.</source>
          <target state="translated">Программисты на Си++могут не любить использовать указатели,так как они считаются опасными-хотя ссылки на самом деле не более безопасны,чем постоянные указатели,за исключением самых тривиальных случаев-не имеют удобства автоматического перенаправления и несут иную смысловую коннотацию.</target>
        </trans-unit>
        <trans-unit id="9d2b52840330e7a44bc694eb6918e7e64357a038" translate="yes" xml:space="preserve">
          <source>Coming from a C background, C++ references may look like a somewhat silly concept, but one should still use them instead of pointers where possible: Automatic indirection &lt;em&gt;is&lt;/em&gt; convenient, and references become especially useful when dealing with &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt; - but not because of any perceived safety advantage, but rather because they make writing idiomatic code less awkward.</source>
          <target state="translated">Исходя из фона C, ссылки на C ++ могут показаться несколько глупой концепцией, но по-прежнему следует использовать их вместо указателей, где это возможно: автоматическая косвенная адресация удобна, и ссылки становятся особенно полезными при работе с &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt; - но не из-за какой-либо предполагаемой безопасности преимущество, а скорее потому, что они делают написание идиоматического кода менее неудобным.</target>
        </trans-unit>
        <trans-unit id="059cdeb648fa366a46a8b8314ed53bd8fc068d24" translate="yes" xml:space="preserve">
          <source>Compound declarators are more restrictive on references.</source>
          <target state="translated">Сложные деклараторы более ограничены в ссылках.</target>
        </trans-unit>
        <trans-unit id="403fed44f11ec4c8ff00fd23f9802e6597c6b4a0" translate="yes" xml:space="preserve">
          <source>Consider the following statement from the &lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;C++ FAQ&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">Рассмотрим следующее утверждение из &lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;C ++ FAQ&lt;/em&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="67105debe8987091e6bdc70ef2e1c62eaeef75e5" translate="yes" xml:space="preserve">
          <source>Consider these two program fragments. In the first, we assign one pointer to another:</source>
          <target state="translated">Рассмотрим эти два фрагмента программы.В первом мы присваиваем один указатель другому:</target>
        </trans-unit>
        <trans-unit id="0cdefee66dd0f6388e32b9d6fed8a4351a84480e" translate="yes" xml:space="preserve">
          <source>Const references can be bound to temporaries. Pointers cannot (not without some indirection):</source>
          <target state="translated">Константные ссылки могут быть привязаны к временным.Указатели не могут (не без некоторой направленности):</target>
        </trans-unit>
        <trans-unit id="257ee630683f00991c22ec378f7e691a1faab887" translate="yes" xml:space="preserve">
          <source>Contrary to popular opinion, it is possible to have a reference that is NULL.</source>
          <target state="translated">Вопреки распространенному мнению,можно иметь ссылку NULL.</target>
        </trans-unit>
        <trans-unit id="43548a90788ae029335a689520a48ebf306a65a2" translate="yes" xml:space="preserve">
          <source>Copy constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually it should be &lt;code&gt;const&lt;/code&gt; qualified.)</source>
          <target state="translated">Конструкторы копирования требуют определенных типов &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;&amp;amp;&lt;/code&gt; ссылочного типа в качестве первого типа параметра. (И, как правило, он должен быть квалифицированным.)</target>
        </trans-unit>
        <trans-unit id="2dfaa6ee16a6acd02f7f18aa98b05c4a8bd6187a" translate="yes" xml:space="preserve">
          <source>Difference between pointer and reference</source>
          <target state="translated">Разница между указателем и ссылкой</target>
        </trans-unit>
        <trans-unit id="8d3aac2e61ebd63a0be37ce5d8c06b59c983898f" translate="yes" xml:space="preserve">
          <source>EDIT: Five years after posting this answer, I found an actual technical difference where references are different than just a different way of looking at the same addressing concept.  References can modify the lifespan of temporary objects in a way that pointers cannot.</source>
          <target state="translated">EDIT:Спустя пять лет после публикации этого ответа я нашел фактическую техническую разницу,где ссылки отличаются от простого взгляда на одну и ту же концепцию адресации.Ссылки могут изменять продолжительность жизни временных объектов таким образом,что указатели не могут.</target>
        </trans-unit>
        <trans-unit id="afbb5feebb594dfda93806a9043262ea69ffa66b" translate="yes" xml:space="preserve">
          <source>Even that pointers are not qualified enough to be put together with references in the sense of the language design, there are still some arguments making it debatable to make choice between them in some other contexts, for example, when making choices on parameter types.</source>
          <target state="translated">Даже если указатели недостаточно квалифицированы,чтобы их можно было собрать вместе со ссылками в смысле дизайна языка,все равно есть некоторые аргументы,делающие спорным выбор между ними в некоторых других контекстах,например,при выборе типов параметров.</target>
        </trans-unit>
        <trans-unit id="1f7c6527f15ac956bb6422655a89e581ad918f6c" translate="yes" xml:space="preserve">
          <source>Even though a reference is often implemented using an address in the
  underlying assembly language, please do &lt;em&gt;not&lt;/em&gt; think of a reference as a
  funny looking pointer to an object. A reference &lt;em&gt;is&lt;/em&gt; the object. It is
  not a pointer to the object, nor a copy of the object. It &lt;em&gt;is&lt;/em&gt; the
  object.</source>
          <target state="translated">Несмотря на то, что ссылка часто реализуется с использованием адреса на базовом ассемблере, &lt;em&gt;не&lt;/em&gt; думайте о ссылке как о забавно выглядящем указателе на объект. Ссылка &lt;em&gt;-&lt;/em&gt; это объект. Это не указатель на объект и не копия объекта. Это объект.</target>
        </trans-unit>
        <trans-unit id="1f0674352c239a778bc468638b40b47fb71b2d98" translate="yes" xml:space="preserve">
          <source>Even when you do want semantics like traditional pointer, there are often something more appropriate, like &lt;code&gt;observer_ptr&lt;/code&gt; in Library Fundamental TS.</source>
          <target state="translated">Даже когда вам нужна семантика, такая как традиционный указатель, часто есть что-то более подходящее, например &lt;code&gt;observer_ptr&lt;/code&gt; в библиотеке фундаментальных TS.</target>
        </trans-unit>
        <trans-unit id="91de4132deb2a9d1d143f39e4534fbb3726e45ff" translate="yes" xml:space="preserve">
          <source>For an older look at this problem from someone with better writing skills, see &lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;Null References&lt;/a&gt; from Jim Hyslop and Herb Sutter.</source>
          <target state="translated">Более старый взгляд на эту проблему от кого-то с лучшими навыками письма, см. &lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;Null References&lt;/a&gt; от Джима Хислопа и Херба Саттера.</target>
        </trans-unit>
        <trans-unit id="c8c71250e475a3240795bff029fac330bf5c86bc" translate="yes" xml:space="preserve">
          <source>For another example of the dangers of dereferencing a null pointer see &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;Exposing undefined behavior when trying to port code to another platform&lt;/a&gt; by Raymond Chen.</source>
          <target state="translated">Еще один пример опасности разыменования нулевого указателя см. В разделе &amp;laquo; &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;Неопределенное поведение при попытке переноса кода на другую платформу&lt;/a&gt; &amp;raquo; Раймонда Чена.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="419ffcbab3d6f22ef6fdb16e11f51ddef360025c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;the ISO C++ definition of object type&lt;/a&gt;:</source>
          <target state="translated">Из &lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;определения типа объекта в ISO C ++&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c921eb398c160fb46e416cb1d07e77fdce036162" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref]/4&lt;/a&gt;:</source>
          <target state="translated">Из &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref] / 4&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bf57a6753ab8a3e91849d0a5046139bd0ae54c97" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object]/1&lt;/a&gt;:</source>
          <target state="translated">Из &lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object] / 1&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="59b186995c92752fd57142834fecf2e2d3252883" translate="yes" xml:space="preserve">
          <source>Function pointers can be converted from lambda expressions without captures, while function references cannot. You have to use function pointers in non-generic code for such cases, even you deliberately do not want nullable values.</source>
          <target state="translated">Указатели функций могут быть преобразованы из лямбда-выражений без захватов,в то время как ссылки на функции не могут.Для таких случаев необходимо использовать указатели функций в негенерном коде,даже если вы намеренно не хотите,чтобы значения были нулевыми.</target>
        </trans-unit>
        <trans-unit id="5a8a000b2872f2ecd2628fd91b4af38afe4ab27a" translate="yes" xml:space="preserve">
          <source>Granted, it is much harder to do with a reference - but if you manage it, you'll tear your hair out trying to find it. References are &lt;em&gt;not&lt;/em&gt; inherently safe in C++!</source>
          <target state="translated">Конечно, справиться с этим гораздо сложнее, но если вы справитесь с этим, вы порвете волосы, пытаясь найти его. Ссылки &lt;em&gt;не&lt;/em&gt; являются безопасными в C ++!</target>
        </trans-unit>
        <trans-unit id="f3d615628d1fd5133dbe19b3297b67cff89e2934" translate="yes" xml:space="preserve">
          <source>Here you are not creating another variable that points to &lt;code&gt;a&lt;/code&gt;; you are just adding another name to the memory content holding the value of &lt;code&gt;a&lt;/code&gt;. This memory now has two names, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and it can be addressed using either name.</source>
          <target state="translated">Здесь вы не создаете другую переменную, которая указывает на; вы просто добавляете другое имя в содержимое памяти, содержащее значение &lt;code&gt;a&lt;/code&gt; . Эта память теперь имеет два имени, &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , и к ней можно обращаться, используя любое имя.</target>
        </trans-unit>
        <trans-unit id="6748018a83feee685129beabf05358adfb1f4a93" translate="yes" xml:space="preserve">
          <source>I can't say I'm really happy with this particular difference. I would much prefer it would be allowed with the meaning reference to anything with an address and otherwise the same behavior for references. It would allow to define some equivalents of C library functions like memcpy using references.</source>
          <target state="translated">Не могу сказать,что я действительно доволен этой особой разницей.Я бы предпочёл,чтобы это было позволено со смысловой ссылкой на всё,что имеет адрес,и в остальном то же самое поведение для ссылок.Это позволило бы определить некоторые эквиваленты функций библиотеки Си,такие как memcpy,используя ссылки.</target>
        </trans-unit>
        <trans-unit id="83cff075b67cc3caa75652556ccf090327793e2f" translate="yes" xml:space="preserve">
          <source>I feel like there is yet another point that hasn't been covered here.</source>
          <target state="translated">Я чувствую,что есть еще один момент,который здесь не освещался.</target>
        </trans-unit>
        <trans-unit id="78aca0acaa65086aab3a232e328bb0bc36aa5fcb" translate="yes" xml:space="preserve">
          <source>I know references are syntactic sugar, so code is easier to read and write.</source>
          <target state="translated">Я знаю,что ссылки-синтаксический сахар,так что код легче читать и писать.</target>
        </trans-unit>
        <trans-unit id="790a903c1bebeddd1477cdd4d06bfb3b8a62ae9b" translate="yes" xml:space="preserve">
          <source>I use references unless I need either of these:</source>
          <target state="translated">Я использую ссылки,если только они мне не нужны:</target>
        </trans-unit>
        <trans-unit id="3068917d6116da066c23030c927f12eb7a21feb4" translate="yes" xml:space="preserve">
          <source>I want to reiterate that the only way to get a null reference is through malformed code, and once you have it you're getting undefined behavior. It &lt;strong&gt;never&lt;/strong&gt; makes sense to check for a null reference; for example you can try &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; but the compiler might optimize the statement out of existence! A valid reference can never be NULL so from the compiler's view the comparison is always false, and it is free to eliminate the &lt;code&gt;if&lt;/code&gt; clause as dead code - this is the essence of undefined behavior.</source>
          <target state="translated">Я хочу повторить, что единственный способ получить нулевую ссылку - это искаженный код, и как только вы его получите, вы получите неопределенное поведение. &lt;strong&gt;Никогда не&lt;/strong&gt; имеет смысла проверять нулевую ссылку; например, вы можете попробовать &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; но компилятор может оптимизировать оператор из-за отсутствия! Допустимая ссылка никогда не может быть NULL, поэтому, с точки зрения компилятора, сравнение всегда ложно, и можно свободно исключать предложение &lt;code&gt;if&lt;/code&gt; как мертвый код - это сущность неопределенного поведения.</target>
        </trans-unit>
        <trans-unit id="28a1dd0bb23764b68abee77b06fa28aa411978df" translate="yes" xml:space="preserve">
          <source>If you are doing some iterations over a range, use iterators (or some ranges which are not provided by the standard library yet), rather than raw pointers unless you are convinced raw pointers will do better (e.g. for less header dependencies) in very specific cases.</source>
          <target state="translated">Если вы делаете некоторые итерации по диапазону,используйте итераторы (или некоторые диапазоны,которые еще не предоставлены стандартной библиотекой),а не сырые указатели,если не уверены,что сырые указатели будут работать лучше (например,при меньших зависимостях от заголовка)в очень специфических случаях.</target>
        </trans-unit>
        <trans-unit id="3ba495f422aa5c4d4099a4f3e279461a678eacba" translate="yes" xml:space="preserve">
          <source>If you come to see the question via &lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;some Google search result (not specific to C++)&lt;/a&gt;, this is very likely to be the wrong place.</source>
          <target state="translated">Если вы пришли посмотреть на вопрос через &lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;какой-то результат поиска Google (не&lt;/a&gt; относится к C ++) , это, скорее всего, будет неправильное место.</target>
        </trans-unit>
        <trans-unit id="1adb9ff9254b1ced3f48e2cba167b170d900e4b7" translate="yes" xml:space="preserve">
          <source>If you don't have to stick on such over-specific choices, in most cases the answer is short: &lt;strong&gt;you do not have the necessity to use pointers, so you don't&lt;/strong&gt;. Pointers are usually bad enough because they imply too many things you don't expect and they will rely on too many implicit assumptions undermining the maintainability and (even) portability of the code. &lt;strong&gt;Unnecessarily relying on pointers is definitely a bad style and it should be avoided in the sense of modern C++.&lt;/strong&gt; Reconsider your purpose and you will finally find that &lt;strong&gt;pointer is the feature of last sorts&lt;/strong&gt; in most cases.</source>
          <target state="translated">Если вам не нужно придерживаться такого чрезмерного выбора, в большинстве случаев ответ будет коротким: у &lt;strong&gt;вас нет необходимости использовать указатели, поэтому вы этого не делаете&lt;/strong&gt; . Указатели, как правило, достаточно плохие, потому что они подразумевают слишком много вещей, которых вы не ожидаете, и они будут полагаться на слишком много неявных предположений, подрывающих удобство сопровождения и (даже) переносимость кода. &lt;strong&gt;Излишне полагаться на указатели - это определенно плохой стиль, и его следует избегать в смысле современного C ++.&lt;/strong&gt; Пересмотрите свою цель, и вы, наконец, обнаружите, что &lt;strong&gt;указатель является функцией последних видов&lt;/strong&gt; в большинстве случаев.</target>
        </trans-unit>
        <trans-unit id="cb2d77074444d61d2cc67de2bd0e1d87f2a0a031" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value (i.e. using non-reference types) is sufficient, use it directly, particularly when using an implementation supporting C++17 mandated copy elision. (&lt;strong&gt;Warning&lt;/strong&gt;: However, to &lt;strong&gt;exhaustively&lt;/strong&gt; reason about the necessity can be &lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;very complicated&lt;/a&gt;.)</source>
          <target state="translated">Если вы знаете, что передачи по значению (т. Е. Использования не-ссылочных типов) достаточно, используйте его напрямую, особенно при использовании реализации, поддерживающей обязательное копирование C ++ 17. ( &lt;strong&gt;Предупреждение&lt;/strong&gt; : однако &lt;strong&gt;исчерпывающие&lt;/strong&gt; рассуждения о необходимости могут быть &lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;очень сложными&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="8ab269d4d0dfc63f1830ebd5af6f660e85c8c775" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is not ideal for the reasons above, and you don't want nullable semantics, use {lvalue, rvalue, forwarding}-references.</source>
          <target state="translated">Если вы знаете,что pass-by-value не идеален по причинам,указанным выше,и вам не нужна нулевая семантика,используйте {lvalue,rvalue,forwarding}-ссылки.</target>
        </trans-unit>
        <trans-unit id="95a97bbef840565852fb933bd387402999a8aa62" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is sufficient and you want some explicit nullable semantics, use wrapper like &lt;code&gt;std::optional&lt;/code&gt;, rather than raw pointers.</source>
          <target state="translated">Если вы знаете, что передача по значению достаточна и вам нужна некоторая явная обнуляемая семантика, используйте обертку, например &lt;code&gt;std::optional&lt;/code&gt; , а не необработанные указатели.</target>
        </trans-unit>
        <trans-unit id="f83f246714f814ce810c05a9ae95c69e9261bd39" translate="yes" xml:space="preserve">
          <source>If you notice even the memory addresses are exactly the same, meaning the reference is successfully pointing to a variable on the heap! Now if you really want to get freaky, this also works:</source>
          <target state="translated">Если вы заметили,что даже адреса памяти совпадают,значит,ссылка успешно указывает на переменную на куче! Теперь,если Вы действительно хотите стать ненормальным,это тоже работает:</target>
        </trans-unit>
        <trans-unit id="f057014d6ad0660324ee4744392d34f7205d30d5" translate="yes" xml:space="preserve">
          <source>If you try this without the &lt;code&gt;const&lt;/code&gt; it should fail to compile. You cannot bind a non-const reference to a temporary object, nor can you take its address for that matter.</source>
          <target state="translated">Если вы попробуете это без &lt;code&gt;const&lt;/code&gt; , он не сможет скомпилироваться. Вы не можете привязать неконстантную ссылку к временному объекту и не можете взять его адрес в этом отношении.</target>
        </trans-unit>
        <trans-unit id="543e04d6c7cf8b1ff3568e8f9fe688b2b4150999" translate="yes" xml:space="preserve">
          <source>If you want to be really pedantic, there is one thing you can do with a reference that you can't do with a pointer: extend the lifetime of a temporary object. In C++ if you bind a const reference to a temporary object, the lifetime of that object becomes the lifetime of the reference.</source>
          <target state="translated">Если вы хотите быть по-настоящему педантичным,есть одна вещь,которую вы можете сделать со ссылкой,которую вы не можете сделать с указателем:продлить срок службы временного объекта.В C++,если вы привязываете ссылку const к временному объекту,то время жизни этого объекта становится временем жизни ссылки.</target>
        </trans-unit>
        <trans-unit id="2f134bd878c28bfcf0e94f5edce84bd4768767e8" translate="yes" xml:space="preserve">
          <source>If you want to operate some handles with ownership, use smart pointers like &lt;code&gt;unique_ptr&lt;/code&gt; and &lt;code&gt;shared_ptr&lt;/code&gt; (or even with homebrew ones by yourself if you require them to be &lt;em&gt;opaque&lt;/em&gt;), rather than raw pointers.</source>
          <target state="translated">Если вы хотите использовать некоторые маркеры с правами собственности, используйте умные указатели, такие как &lt;code&gt;unique_ptr&lt;/code&gt; и &lt;code&gt;shared_ptr&lt;/code&gt; (или даже сами доморощенные, если вы хотите, чтобы они были &lt;em&gt;непрозрачными&lt;/em&gt; ), а не необработанные указатели.</target>
        </trans-unit>
        <trans-unit id="f9770a58e8e2c829e550700ed47290c2aae7fa6f" translate="yes" xml:space="preserve">
          <source>In fact to do it properly, we must have declared and defined an object at the first then we can make a reference to that object, so the correct implementation of the previous code will be:</source>
          <target state="translated">На самом деле,чтобы сделать это правильно,мы должны объявить и определить объект сначала,затем мы можем сделать ссылку на этот объект,так что правильной реализацией предыдущего кода будет:</target>
        </trans-unit>
        <trans-unit id="82769a796fb3193fe927e0baf51f38ab518d3ebb" translate="yes" xml:space="preserve">
          <source>In other words, a reference is nothing but a pointer that has the pointer mechanics abstracted away, making it safer and easier to use (no accidental pointer math, no mixing up '.' and '-&amp;gt;', etc.), assuming you don't try any nonsense like my examples above ;)</source>
          <target state="translated">Другими словами, ссылка - это не что иное, как указатель, у которого абстрагирована механика указателя, что делает его более безопасным и простым в использовании (без случайной математики указателя, без перемешивания '.' И '-&amp;gt;' и т. Д.), Предполагая, что вы не пытайтесь глупости, как мои примеры выше;)</target>
        </trans-unit>
        <trans-unit id="200b5d2213958228565fdde5b08d7bf3a0e7e8c1" translate="yes" xml:space="preserve">
          <source>In this example s3_copy copies the temporary object that is a result of the concatenation. Whereas s3_reference in essence becomes the temporary object. It's really a reference to a temporary object that now has the same lifetime as the reference.</source>
          <target state="translated">В данном примере s3_copy копирует временный объект,являющийся результатом конкатенирования.В то время как s3_reference по сути становится временным объектом.На самом деле это ссылка на временный объект,который теперь имеет то же время жизни,что и ссылка.</target>
        </trans-unit>
        <trans-unit id="ba73ce596882bac23adab797099d810c536e52c7" translate="yes" xml:space="preserve">
          <source>It also has to prove that there are no ways a future call could read/write a[0] while we have a temporary register copy of it in a0. This is often trivial to prove, because in many cases it is obvious that the reference is never stored in a permanent structure like a class instance.</source>
          <target state="translated">Он также должен доказать,что нет никаких способов,чтобы будущий вызов мог прочитать a[0],в то время как у нас есть временная копия регистра в a0.Это часто тривиально доказать,потому что во многих случаях очевидно,что ссылка никогда не хранится в постоянной структуре,как экземпляр класса.</target>
        </trans-unit>
        <trans-unit id="c0cc1580772a83020df85287d6f8e26c7bd8a5f0" translate="yes" xml:space="preserve">
          <source>It doesn't matter how much space it takes up since you can't actually see any side effect (without executing code) of whatever space it would take up.</source>
          <target state="translated">Не имеет значения,сколько места это займет,так как вы не можете увидеть никакого побочного эффекта (без выполнения кода)от того,какое место это займет.</target>
        </trans-unit>
        <trans-unit id="1d798a27c2d2b93f1136b70dcfad1e9fac904cd6" translate="yes" xml:space="preserve">
          <source>It internally becomes</source>
          <target state="translated">Внутренне становится</target>
        </trans-unit>
        <trans-unit id="2dbb06a19fcf0fb6d64e79da18f5a426b98c98ee" translate="yes" xml:space="preserve">
          <source>It is unspecified whether or not a reference requires storage.</source>
          <target state="translated">Не определено,требует ли ссылка хранения или нет.</target>
        </trans-unit>
        <trans-unit id="b288f3fae88ae371415949edcc0c9e0886821a41" translate="yes" xml:space="preserve">
          <source>It may be important to know, object type is a top-level category of the type universe in C++. Reference is also a top-level category. &lt;strong&gt;But pointer is not.&lt;/strong&gt;</source>
          <target state="translated">Может быть важно знать, что тип объекта является категорией верхнего уровня юниверса типа в C ++. Ссылка также является категорией верхнего уровня. &lt;strong&gt;Но указатель нет.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b45412ddd0ff9c77b1d05ade69b201525767735" translate="yes" xml:space="preserve">
          <source>Language neutrality caveats</source>
          <target state="translated">Оговорки о языковой нейтральности</target>
        </trans-unit>
        <trans-unit id="55dd62362caab929ec378cd05497a3ec85467b37" translate="yes" xml:space="preserve">
          <source>Look at the following statement,</source>
          <target state="translated">Посмотрите на следующее заявление,</target>
        </trans-unit>
        <trans-unit id="d7297eb6becdd735c4545511c38d16ada0827023" translate="yes" xml:space="preserve">
          <source>Many compilers when inlining the pointer version one will actually force a write to memory (we are taking the address explicitly).  However, they will leave the reference in a register which is more optimal.</source>
          <target state="translated">Многие компиляторы,когда вставляют версию указателя,на самом деле заставляют запись в память (мы берем адрес явно).Однако,они оставят ссылку в более оптимальном регистре.</target>
        </trans-unit>
        <trans-unit id="ea2aee18995ab103eed08b69ba07dcb31625dabf" translate="yes" xml:space="preserve">
          <source>Maybe some metaphors will help; 
In the context of your desktop screenspace -</source>
          <target state="translated">Может быть,помогут некоторые метафоры;В контексте экрана вашего рабочего стола -</target>
        </trans-unit>
        <trans-unit id="ac946397b09fb907e8acce3c92c880b361a9a242" translate="yes" xml:space="preserve">
          <source>Modern compilers are getting better and better at static analysis, but it is always nice to help them out and use references.</source>
          <target state="translated">Современные компиляторы становятся все лучше и лучше при статическом анализе,но всегда приятно помочь им и использовать ссылки.</target>
        </trans-unit>
        <trans-unit id="bf6c60a1e5c2679ef0162d45b8f206f16bcdd7d1" translate="yes" xml:space="preserve">
          <source>Move constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually there should be no qualifiers.)</source>
          <target state="translated">Конструкторы перемещения требуют определенных типов ссылочного типа &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; в качестве первого типа параметра. (И обычно не должно быть определителей.)</target>
        </trans-unit>
        <trans-unit id="1b9630be120a68e57ca22b6ff58fa3a235507cba" translate="yes" xml:space="preserve">
          <source>My example above is short and contrived. Here's a more real-world example.</source>
          <target state="translated">Мой пример выше коротко и наворочен.Вот более реальный пример.</target>
        </trans-unit>
        <trans-unit id="56e71102cceade878735d306276129a65b04b038" translate="yes" xml:space="preserve">
          <source>Normally temporary objects such as the one created by the call to &lt;code&gt;createF(5)&lt;/code&gt; are destroyed at the end of the expression.  However, by binding that object to a reference, &lt;code&gt;ref&lt;/code&gt;, C++ will extend the lifespan of that temporary object until &lt;code&gt;ref&lt;/code&gt; goes out of scope.</source>
          <target state="translated">Обычно временные объекты, такие как объект, созданный при вызове &lt;code&gt;createF(5)&lt;/code&gt; , уничтожаются в конце выражения. Однако, связывая этот объект со ссылкой, &lt;code&gt;ref&lt;/code&gt; , C ++ продлит срок службы этого временного объекта до тех пор, пока &lt;code&gt;ref&lt;/code&gt; не выйдет из области видимости.</target>
        </trans-unit>
        <trans-unit id="b2dd5770081924d799a48921378b48818433c7bb" translate="yes" xml:space="preserve">
          <source>Note the statements above only mentions &quot;pointers&quot; and &quot;references&quot; as types. There are some interested questions about their instances (like variables). There also come too many misconceptions.</source>
          <target state="translated">Обратите внимание,что в вышеприведенных утверждениях в качестве типов упоминаются только &quot;указатели&quot; и &quot;ссылки&quot;.Есть некоторые интересные вопросы об их экземплярах (например,о переменных).Также существует слишком много неправильных представлений.</target>
        </trans-unit>
        <trans-unit id="0112dd76dee19c15ddada9b0763e06e1cbc7faf4" translate="yes" xml:space="preserve">
          <source>Note these are &lt;em&gt;semantic&lt;/em&gt; properties.</source>
          <target state="translated">Обратите внимание, что это &lt;em&gt;семантические&lt;/em&gt; свойства.</target>
        </trans-unit>
        <trans-unit id="32c54f61399cee485b86cada14cf3ef339a2f916" translate="yes" xml:space="preserve">
          <source>Now &lt;strong&gt;regardless&lt;/strong&gt; of how a compiler handles references, it will &lt;strong&gt;always&lt;/strong&gt; have some kind of pointer under the hood, because a reference &lt;strong&gt;must&lt;/strong&gt; refer to a specific variable at a specific memory address for it to work as expected, there is no getting around this (hence the term 'reference').</source>
          <target state="translated">Теперь, &lt;strong&gt;независимо&lt;/strong&gt; от того, как компилятор обрабатывает ссылки, у него &lt;strong&gt;всегда&lt;/strong&gt; будет какой-то указатель под капотом, потому что ссылка &lt;strong&gt;должна&lt;/strong&gt; ссылаться на конкретную переменную по определенному адресу памяти, чтобы она работала как положено, от этого не обойтись (следовательно термин &amp;laquo;ссылка&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="752e698d55444e3238d56a6bc3da3af23d39ce29" translate="yes" xml:space="preserve">
          <source>Now do the same thing with pointers</source>
          <target state="translated">А теперь сделай то же самое с указателями</target>
        </trans-unit>
        <trans-unit id="e6bdf4bf7e4af7604beaed717ed9319201ff15be" translate="yes" xml:space="preserve">
          <source>Now some explanation of real code:</source>
          <target state="translated">Теперь кое-какое объяснение реального кода:</target>
        </trans-unit>
        <trans-unit id="586d3a296148dea14411f5e77a90d02cd7148035" translate="yes" xml:space="preserve">
          <source>Now there may be some cases where your compiler may not be able to know the reference when compiling, like when using an extern variable. So a reference may or may not be implemented as a pointer in the underlying code. But in the examples I gave you, it will most likely not be implemented with a pointer.</source>
          <target state="translated">Теперь могут быть некоторые случаи,когда ваш компилятор может не знать ссылку при компиляции,например,при использовании extern-переменной.Таким образом,ссылка может быть реализована или не реализована в качестве указателя в базовом коде.Но в приведенных мною примерах она,скорее всего,не будет реализована в виде указателя.</target>
        </trans-unit>
        <trans-unit id="808cc104c235301ef1bc79319f8102ad43971fef" translate="yes" xml:space="preserve">
          <source>Null pointers can be used as a
sentinel value, often a cheap way to
avoid function overloading or use of
a bool.</source>
          <target state="translated">Null указатели могут быть использованы в качестве часового значения,часто дешевый способ,чтобы избежать перегрузки функций или использования шерсти.</target>
        </trans-unit>
        <trans-unit id="67ae9809624c429d324c275faf9d92d1518e204d" translate="yes" xml:space="preserve">
          <source>Object types can have top-level &lt;code&gt;cv&lt;/code&gt; qualifiers. References cannot.</source>
          <target state="translated">Типы объектов могут иметь квалификаторы &lt;code&gt;cv&lt;/code&gt; верхнего уровня. Ссылки не могут.</target>
        </trans-unit>
        <trans-unit id="00a1b2cda377012d0e23e72a9f8fed0898939786" translate="yes" xml:space="preserve">
          <source>Of course, barring such clever optimizations, compilers will indeed turn references into pointers when needed.</source>
          <target state="translated">Конечно,если не использовать такие умные оптимизации,компиляторы действительно превратят ссылки в указатели при необходимости.</target>
        </trans-unit>
        <trans-unit id="dc07d79fb5ff33400c26bc7a53b5a0a72e7aefd6" translate="yes" xml:space="preserve">
          <source>Of course, for functions that are not inlined the pointer and reference generate the same code and it's always better to pass intrinsics by value than by reference if they are not modified and returned by the function.</source>
          <target state="translated">Конечно,для функций,которые не имеют указателя и ссылки,генерируют один и тот же код,и всегда лучше передавать intrinsics по значению,чем по ссылке,если они не модифицируются и не возвращаются функцией.</target>
        </trans-unit>
        <trans-unit id="828bf90967e721e857197022098eb853d37eaa44" translate="yes" xml:space="preserve">
          <source>On the other hand, one major difference between references and pointers is that temporaries assigned to const references live until the const reference goes out of scope.</source>
          <target state="translated">С другой стороны,одно из главных различий между ссылками и указателями заключается в том,что временные значения,назначенные для const ссылок,живут до тех пор,пока const ссылка не выйдет за пределы области действия.</target>
        </trans-unit>
        <trans-unit id="90dd91d02279fe6ccfc85544573813d23da86513" translate="yes" xml:space="preserve">
          <source>Otherwise, it is insignificant that pointers can be qualified as a specific sorts of types with references together. They simply share too few common properties besides the syntax similarity, so there is no need to put them together in most cases.</source>
          <target state="translated">В противном случае,несущественно,что указатели можно квалифицировать как специфические типы со ссылками вместе.У них просто слишком мало общих свойств,кроме синтаксического сходства,поэтому в большинстве случаев нет необходимости их объединять.</target>
        </trans-unit>
        <trans-unit id="c468e66383b3acff1decf7ebfe1722418b200e03" translate="yes" xml:space="preserve">
          <source>Overloaded &lt;code&gt;operator=&lt;/code&gt; as special member functions requires reference types similar to 1st parameter of copy/move constructors.</source>
          <target state="translated">Перегруженный &lt;code&gt;operator=&lt;/code&gt; качестве специальных функций-членов требует ссылочных типов, аналогичных 1-му параметру конструкторов копирования / перемещения.</target>
        </trans-unit>
        <trans-unit id="7f2c3e2cc509718d63ded349b2aab9f792237302" translate="yes" xml:space="preserve">
          <source>Pointer can be assigned &lt;code&gt;nullptr&lt;/code&gt; directly, whereas reference cannot. If you try hard enough, and you know how, you can make the address of a reference &lt;code&gt;nullptr&lt;/code&gt;.  Likewise, if you try hard enough you can have a reference to a pointer, and then that reference can contain &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">Указатель может быть присвоен &lt;code&gt;nullptr&lt;/code&gt; напрямую, а ссылка - нет. Если вы достаточно стараетесь и знаете, как, вы можете сделать адрес ссылки &lt;code&gt;nullptr&lt;/code&gt; . Аналогично, если вы попытаетесь сделать это достаточно усердно, у вас может быть ссылка на указатель, и тогда эта ссылка может содержать &lt;code&gt;nullptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8dd03a2b7cf3f5874fc9c97bd98b107bc98bfa9" translate="yes" xml:space="preserve">
          <source>Pointers and references are mentioned together &lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;in the context of &lt;em&gt;compound type&lt;/em&gt;&lt;/a&gt;. This is basically due to the nature of the declarator syntax inherited from (and extended) C, which has no references. (Besides, there are more than one kind of declarator of references since C++ 11, while pointers are still &quot;unityped&quot;: &lt;code&gt;&amp;amp;&lt;/code&gt;+&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; vs. &lt;code&gt;*&lt;/code&gt;.) So drafting a language specific by &quot;extension&quot; with similar style of C in this context is somewhat reasonable. (I will still argue that the syntax of declarators wastes the syntactic expressiveness &lt;em&gt;a lot&lt;/em&gt;, makes both human users and implementations frustrating. Thus, all of them are not qualified to be &lt;em&gt;built-in&lt;/em&gt; in a new language design. This is a totally different topic about PL design, though.)</source>
          <target state="translated">Указатели и ссылки упоминаются вместе &lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;в контексте &lt;em&gt;составного типа&lt;/em&gt;&lt;/a&gt; . Это в основном связано с природой синтаксиса объявления, унаследованного от (и расширенного) C, который не имеет ссылок. (Кроме того, начиная с C ++ 11 существует более одного вида деклараторов ссылок, в то время как указатели все еще &amp;laquo;единодушны&amp;raquo;: &lt;code&gt;&amp;amp;&lt;/code&gt; + &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; против &lt;code&gt;*&lt;/code&gt; .) Поэтому в этом контексте составляется язык, специфичный для &amp;laquo;расширения&amp;raquo;, с аналогичным стилем C несколько разумно. (Я по-прежнему буду утверждать, что синтаксис деклараторов &lt;em&gt;сильно&lt;/em&gt; тратит синтаксическую выразительность, расстраивает как пользователей, так и реализации. Таким образом, все они не могут быть &lt;em&gt;встроены&lt;/em&gt; в новый языковой дизайн. Это совершенно другая тема про дизайн PL, правда.)</target>
        </trans-unit>
        <trans-unit id="8e79db4216ca0b1682917f0312184de116274ee0" translate="yes" xml:space="preserve">
          <source>Pointers are variables; they contain the address of some other variable, or can be null. The important thing is that a pointer has a value, while a reference only has a variable that it is referencing.</source>
          <target state="translated">Указатели-это переменные;они содержат адрес какой-то другой переменной,или могут быть нулевыми.Важно то,что указатель имеет значение,а ссылка-только переменную,на которую он ссылается.</target>
        </trans-unit>
        <trans-unit id="a4c98c7b23dbb9c431cf37cec4103729a3b3df7c" translate="yes" xml:space="preserve">
          <source>Pointers can iterate over an array, you can use &lt;code&gt;++&lt;/code&gt; to go to the next item that a pointer is pointing to, and &lt;code&gt;+ 4&lt;/code&gt; to go to the 5th element.  This is no matter what size the object is that the pointer points to.</source>
          <target state="translated">Указатели могут перебирать массив, вы можете использовать &lt;code&gt;++&lt;/code&gt; для перехода к следующему элементу, на который указывает указатель, и &lt;code&gt;+ 4&lt;/code&gt; для перехода к 5-му элементу. Это не имеет значения, на какой размер объекта указывает указатель.</target>
        </trans-unit>
        <trans-unit id="0041b69bd78f1922ccacbca89c0bd23258263cde" translate="yes" xml:space="preserve">
          <source>Postfix &lt;code&gt;++&lt;/code&gt; requires dummy &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Postfix &lt;code&gt;++&lt;/code&gt; требует пустышки &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c40deca9098c33c4507f06a0277ec7d603682af" translate="yes" xml:space="preserve">
          <source>Pragmatics</source>
          <target state="translated">Pragmatics</target>
        </trans-unit>
        <trans-unit id="462242db0811f3f971e9fd491ae343b8badcc883" translate="yes" xml:space="preserve">
          <source>RAII is one of the central concepts of C++, but it interacts non-trivially with copying semantics. Passing objects by reference avoids these issues as no copying is involved. If references were not present in the language, you'd have to use pointers instead, which are more cumbersome to use, thus violating the language design principle that the best-practice solution should be easier than the alternatives.</source>
          <target state="translated">RAII является одним из центральных понятий С++,но взаимодействует нетривиально с копирующей семантикой.Передача объектов по ссылке позволяет избежать этих проблем,так как при этом не происходит никакого копирования.Если бы ссылок не было в языке,то вместо них пришлось бы использовать указатели,которые более громоздки в использовании,нарушая тем самым принцип проектирования языка,согласно которому наилучшее решение должно быть проще,чем альтернативы.</target>
        </trans-unit>
        <trans-unit id="055cd393f567fac0ba4089ec8ff85252aac14bdb" translate="yes" xml:space="preserve">
          <source>References are allowed to refer to variables which do not have memory addresses, such as those the compiler chooses to put into registers. If you take the address of a local variable, it is very hard for the compiler to put it in a register.</source>
          <target state="translated">Ссылки разрешены для ссылок на переменные,не имеющие адресов памяти,например,те,которые компилятор решил поместить в регистры.Если взять адрес локальной переменной,то компилятору очень сложно поместить её в регистр.</target>
        </trans-unit>
        <trans-unit id="5a853555e7fde5a31207074a784b524c82ed58aa" translate="yes" xml:space="preserve">
          <source>References are designed such that it is substantially easier for the compiler to trace which reference aliases which variables. Two major features are very important: no &quot;reference arithmetic&quot; and no reassigning of references. These allow the compiler to figure out which references alias which variables at compile time.</source>
          <target state="translated">Ссылки спроектированы таким образом,что компилятору существенно легче отслеживать,какие псевдонимы каких переменных ссылаются.Очень важны две основные особенности:отсутствие &quot;ссылочной арифметики&quot; и отсутствие переназначения ссылок.Это позволяет компилятору выяснить,какие псевдонимы ссылок на какие переменные на момент компиляции.</target>
        </trans-unit>
        <trans-unit id="e813db94099ca02f715fb0f1ba9f33611db2f553" translate="yes" xml:space="preserve">
          <source>References are very similar to pointers, but they are specifically crafted to be helpful to optimizing compilers.</source>
          <target state="translated">Ссылки очень похожи на указатели,но они специально созданы для того,чтобы быть полезными при оптимизации компиляторов.</target>
        </trans-unit>
        <trans-unit id="bf6fd50fdee7317a481645b6fae553557dc3cdd2" translate="yes" xml:space="preserve">
          <source>References can &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;collapse&lt;/a&gt;.</source>
          <target state="translated">Ссылки могут &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;рухнуть&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e3206ad161847bd2d29f9d31a405ed11c7d64c2" translate="yes" xml:space="preserve">
          <source>References cannot be stuffed into an array, whereas pointers can be (Mentioned by user @litb)</source>
          <target state="translated">Ссылки не могут быть записаны в массив,в то время как указатели могут быть (Mentioned by user @litb)</target>
        </trans-unit>
        <trans-unit id="cfca6984c06ae05fa650e3c0076a1855343215bb" translate="yes" xml:space="preserve">
          <source>References have special rules in initialization. The lifetime of variable declared as a reference type can be different to ordinary objects via extension.</source>
          <target state="translated">Ссылки имеют специальные правила при инициализации.Время жизни переменной,объявленной в качестве типа ссылки,может отличаться от времени жизни обычных объектов через расширение.</target>
        </trans-unit>
        <trans-unit id="526784942b6e34cc8eb97ec6c1946f69db4aa93c" translate="yes" xml:space="preserve">
          <source>References in C++ is quite &quot;odd&quot;, as it is essentially not first-class: &lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;they will be treated as the objects or the functions being referred to&lt;/a&gt; so they have no chance to support some first-class operations like being the left operand of &lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;the member access operator&lt;/a&gt; independently to the type of the referred object. Other languages may or may not have similar restrictions on their references.</source>
          <target state="translated">Ссылки в C ++ довольно &amp;laquo;странные&amp;raquo;, так как они по сути не первоклассные: &lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;они будут рассматриваться как объекты или функции, на которые ссылаются,&lt;/a&gt; поэтому у них нет шансов поддержать некоторые первоклассные операции, такие как левый операнд &lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;член доступа оператора&lt;/a&gt; независимо от типа указанного объекта. Другие языки могут иметь или не иметь аналогичные ограничения на свои ссылки.</target>
        </trans-unit>
        <trans-unit id="d003206a70c36ecf7a0315ea6420395ec7e35600" translate="yes" xml:space="preserve">
          <source>References in C++ will likely not preserve the meaning across different languages. For example, references in general do not imply nonnull properties on values like they in C++, so such assumptions may not work in some other languages (and you will find counterexamples quite easily, e.g. Java, C#, ...).</source>
          <target state="translated">Ссылки на Си++вряд ли сохранят смысл в разных языках.Например,ссылки в целом не подразумевают никаких свойств значений,как в Си++,поэтому такие предположения могут не сработать в некоторых других языках (и вы довольно легко найдете контрпримеры,например,Java,C#,....).</target>
        </trans-unit>
        <trans-unit id="776a07f1188f204d3f88257d0ec6a07a29887cdc" translate="yes" xml:space="preserve">
          <source>Regards,
&amp;amp;rzej</source>
          <target state="translated">Regards,
&amp;amp;rzej</target>
        </trans-unit>
        <trans-unit id="f29ff291ec91fbd3d5e03a84623244a66ed645e4" translate="yes" xml:space="preserve">
          <source>Run the program and have a look at the output and you'll understand.</source>
          <target state="translated">Запустите программу и посмотрите на результат,и вы поймете.</target>
        </trans-unit>
        <trans-unit id="01841626b366982706bd9cb74359851e4287a00f" translate="yes" xml:space="preserve">
          <source>Simply to remember that,</source>
          <target state="translated">Просто чтобы запомнить это,</target>
        </trans-unit>
        <trans-unit id="7ed3e2e5988e139dbdad2bddeb8aea77458c5333" translate="yes" xml:space="preserve">
          <source>So, in practice, the answer is so obvious: &lt;strong&gt;when in doubt, avoid pointers&lt;/strong&gt;. You have to use pointers only when there are very explicit reasons that nothing else is more appropriate. Except a few exceptional cases mentioned above, such choices are almost always not purely C++-specific (but likely to be language-implementation-specific). Such instances can be:</source>
          <target state="translated">Таким образом, на практике ответ так очевиден: &lt;strong&gt;в случае сомнений избегайте указателей&lt;/strong&gt; . Вы должны использовать указатели только тогда, когда есть очень явные причины, по которым нет ничего более подходящего. За исключением нескольких исключительных случаев, упомянутых выше, такие варианты почти всегда не являются специфичными только для C ++ (но, скорее всего, для конкретной реализации языка). Такими примерами могут быть:</target>
        </trans-unit>
        <trans-unit id="fcf6411c0b226a9fd5b245400b86fb65e325be87" translate="yes" xml:space="preserve">
          <source>Some argue that this is such a useful feature when reading code, that pointer parameters should always be used for modifiable parameters rather than non-&lt;code&gt;const&lt;/code&gt; references, even if the function never expects a &lt;code&gt;nullptr&lt;/code&gt;. That is, those people argue that function signatures like &lt;code&gt;fn3()&lt;/code&gt; above should not be allowed. &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;Google's C++ style guidelines&lt;/a&gt; are an example of this.</source>
          <target state="translated">Некоторые утверждают, что это такая полезная функция при чтении кода, что параметры указателя всегда следует использовать для изменяемых параметров, а не для &lt;code&gt;const&lt;/code&gt; ссылок, даже если функция никогда не ожидает &lt;code&gt;nullptr&lt;/code&gt; . То есть эти люди утверждают, что подписи функций, такие как &lt;code&gt;fn3()&lt;/code&gt; выше, не должны быть разрешены. &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;Руководящие принципы стиля Google C ++&lt;/a&gt; являются примером этого.</target>
        </trans-unit>
        <trans-unit id="4060e9b242b8df1a2b956d0e250e637eee184ce4" translate="yes" xml:space="preserve">
          <source>Sometimes the language rules explicitly require specific types to be used. If you want to use these features, obey the rules.</source>
          <target state="translated">Иногда правила языка явно требуют использования определенных типов.Если вы хотите использовать эти возможности,подчиняйтесь правилам.</target>
        </trans-unit>
        <trans-unit id="5fc11392b922636b6dc568f4ab0eb7cfb144157b" translate="yes" xml:space="preserve">
          <source>Special rules on &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; parameters (as the &quot;forwarding references&quot;) based on reference collapsing during template parameter deduction allow &lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;&quot;perfect forwarding&quot;&lt;/a&gt; of parameters.</source>
          <target state="translated">Специальные правила для &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; параметров (как &amp;laquo;пересылка ссылок&amp;raquo;), основанные на свертывании ссылок во время вывода параметров шаблона, позволяют &lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;&amp;laquo;совершенную пересылку&amp;raquo;&lt;/a&gt; параметров.</target>
        </trans-unit>
        <trans-unit id="e7e7e6a0d10546a8f3514b41d4f9f797c475d3c2" translate="yes" xml:space="preserve">
          <source>Specific language-interoperation routines require pointers, like &lt;code&gt;operator new&lt;/code&gt;. (However, &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;void*&lt;/code&gt; is still quite different and safer compared to the ordinary object pointers because it rules out unexpected pointer arithmetics unless you are relying on some non conforming extension on &lt;code&gt;void*&lt;/code&gt; like GNU's.)</source>
          <target state="translated">Определенные языковые процедуры взаимодействия требуют указателей, таких как &lt;code&gt;operator new&lt;/code&gt; . (Тем не менее, &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;void*&lt;/code&gt; по-прежнему довольно отличается и безопаснее по сравнению с обычными объектными указателями, потому что он исключает неожиданную арифметику указателей, если только вы не полагаетесь на какое-то несоответствующее расширение на &lt;code&gt;void*&lt;/code&gt; как в GNU.)</target>
        </trans-unit>
        <trans-unit id="918eaf9f6cafcfdb9b382a8fa017353bbc7f79e9" translate="yes" xml:space="preserve">
          <source>Specific overloads of operators require reference or non reference types. For example:</source>
          <target state="translated">Специфические перегрузки операторов требуют эталонных или не эталонных типов.Например:</target>
        </trans-unit>
        <trans-unit id="9e092dda4f0e27d0c7686ddd00272079e678b6e6" translate="yes" xml:space="preserve">
          <source>Storage</source>
          <target state="translated">Storage</target>
        </trans-unit>
        <trans-unit id="f6ceae4e1810d086bda09a8ac74e9e1fae98d4f4" translate="yes" xml:space="preserve">
          <source>Syntactic sugar</source>
          <target state="translated">Синтаксический сахар</target>
        </trans-unit>
        <trans-unit id="178786d5b288287aa798248ecdf5fc27cc41e4ba" translate="yes" xml:space="preserve">
          <source>Technically this is an &lt;strong&gt;invalid reference&lt;/strong&gt;, not a null reference.  C++ doesn't support null references as a concept as you might find in other languages.  There are other kinds of invalid references as well. &lt;em&gt;Any&lt;/em&gt; invalid reference raises the spectre of &lt;strong&gt;undefined behavior&lt;/strong&gt;, just as using an invalid pointer would.</source>
          <target state="translated">Технически это &lt;strong&gt;недопустимая ссылка&lt;/strong&gt; , а не пустая ссылка. C ++ не поддерживает нулевые ссылки как концепцию, как вы можете найти в других языках. Есть и другие виды недействительных ссылок. &lt;em&gt;Любая&lt;/em&gt; недопустимая ссылка порождает призрак &lt;strong&gt;неопределенного поведения&lt;/strong&gt; , как если бы использовался недопустимый указатель.</target>
        </trans-unit>
        <trans-unit id="19d85e5f25c953dc491251669b1a186b567d0b30" translate="yes" xml:space="preserve">
          <source>Technically, this is plain wrong. References are not syntactic sugar of any other features in C++, because they cannot be exactly replaced by other features without any semantic differences.</source>
          <target state="translated">Технически,это просто неправильно.Ссылки не являются синтаксическим сахаром любых других функций в C++,потому что они не могут быть точно заменены другими функциями без каких-либо семантических различий.</target>
        </trans-unit>
        <trans-unit id="e1271990b0fbf017a0baa7180d4771ca7fef2cb9" translate="yes" xml:space="preserve">
          <source>Templates that cover both &lt;code&gt;T&amp;amp;&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are even more common.</source>
          <target state="translated">Шаблоны, охватывающие как &lt;code&gt;T&amp;amp;&lt;/code&gt; и &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; встречаются еще чаще.</target>
        </trans-unit>
        <trans-unit id="cc2d982b9a391ad561f42bfa61ab554d2658e9c3" translate="yes" xml:space="preserve">
          <source>The actual error is in the dereferencing of the NULL pointer, prior to the assignment to a reference.  But I'm not aware of any compilers that will generate any errors on that condition - the error propagates to a point further along in the code. That's what makes this problem so insidious. Most of the time, if you dereference a NULL pointer, you crash right at that spot and it doesn't take much debugging to figure it out.</source>
          <target state="translated">Фактическая ошибка заключается в разыменовании указателя NULL перед присвоением ссылки.Но я не знаю ни одного компилятора,который генерировал бы какие-либо ошибки при таком условии-ошибка распространяется в коде еще дальше.Вот что делает эту проблему такой коварной.Чаще всего,если разыменовать ссылку на NULL указатель,то сразу в этом месте происходит падение,и для его разгадки не требуется отладка.</target>
        </trans-unit>
        <trans-unit id="36dcbb0fd485c966a6a8597e14838d2a77d340f3" translate="yes" xml:space="preserve">
          <source>The behavior is the same; only now it is much harder to prove that maybeModify does not ever modify array[1], because we already gave it a pointer; the cat is out of the bag. Now it has to do the much more difficult proof: a static analysis of maybeModify to prove it never writes to &amp;amp;x + 1. It also has to prove that it never saves off a pointer that can refer to array[0], which is just as tricky.</source>
          <target state="translated">Поведение такое же; только теперь гораздо сложнее доказать, что MaybeModify никогда не модифицирует массив [1], потому что мы уже дали ему указатель; кошка вышла из сумки. Теперь нужно сделать гораздо более сложное доказательство: статический анализ MaybeModify, чтобы доказать, что он никогда не записывает в &amp;amp; x + 1. Он также должен доказать, что он никогда не сохраняет указатель, который может ссылаться на массив [0], который просто как сложно.</target>
        </trans-unit>
        <trans-unit id="55c25474b6bbe811c3fff5d37fe3196ddf92b362" translate="yes" xml:space="preserve">
          <source>The default flavor uses the 'bind const reference to a temporary' aspect of references.</source>
          <target state="translated">Вкус по умолчанию использует 'привязку const к временному' аспекту ссылок.</target>
        </trans-unit>
        <trans-unit id="eeffd6f2cd40ebbc994170a79516a76d384f1862" translate="yes" xml:space="preserve">
          <source>The difference is that non-constant pointer variable(not to be confused with a pointer to constant) may be changed at some time during program execution, requires pointer semantics to be used(&amp;amp;,*) operators, while references can be set upon initialization only(that's why you can set them in constructor initializer list only, but not somehow else) and use ordinary value accessing semantics.  Basically references were introduced to allow support for operators overloading as I had read in some very old book. As somebody stated in this thread - pointer can be set to 0 or whatever value you want. 0(NULL, nullptr) means that the pointer is initialized with nothing. It is an error to dereference null pointer. But actually the pointer may contain a value that doesn't point to some correct memory location. References in their turn try not to allow a user to initialize a reference to something that cannot be referenced due to the fact that you always provide rvalue of correct type to it. Although there are a lot of ways to make reference variable be initialized to a wrong memory location - it is better for you not to dig this deep into details. On machine level both pointer and reference work uniformly - via pointers. Let's say in essential references are syntactic sugar. rvalue references are different to this - they are naturally stack/heap objects.</source>
          <target state="translated">Разница заключается в том, что непостоянная переменная-указатель (не путать с указателем на константу) может быть изменена в течение некоторого времени во время выполнения программы, требует использования семантики указателя (&amp;amp;, *), а ссылки могут быть установлены после инициализации только (поэтому вы можете установить их только в списке инициализатора конструктора, но никак иначе) и использовать обычную семантику доступа к значениям. В основном ссылки были введены для поддержки перегрузки операторов, как я читал в одной очень старой книге. Как кто-то заявил в этой теме - указатель может быть установлен в 0 или любое другое значение, которое вы хотите. 0 (NULL, nullptr) означает, что указатель инициализируется ничем. Ошибка разыменования нулевого указателя. Но на самом деле указатель может содержать значение, которое не указывает на какое-то правильное расположение в памяти. Ссылки, в свою очередь, стараются не позволять пользователю инициализировать ссылку на что-то, на что нельзя ссылаться из-за того, что вы всегда предоставляете ей правильное значение. Хотя существует множество способов инициализировать ссылочную переменную в неправильном месте памяти, лучше не вдаваться в детали. На уровне машины и указатель, и ссылка работают равномерно - с помощью указателей. Допустим, в основных ссылках приведены синтаксические сахара. Rvalue ссылки отличаются от этого - они, естественно, объекты стека / кучи.</target>
        </trans-unit>
        <trans-unit id="21383718ed633934236239e24d6297c4ae1335ed" translate="yes" xml:space="preserve">
          <source>The differences of the top-level categories can already reveal many concrete differences not tied to pointers directly:</source>
          <target state="translated">Различия в категориях верхнего уровня уже могут выявить многие конкретные различия,не привязанные напрямую к указателям:</target>
        </trans-unit>
        <trans-unit id="819bfb5a2d2e6000333b076e5df05cfd8d7b2a13" translate="yes" xml:space="preserve">
          <source>The direct answer</source>
          <target state="translated">Прямой ответ</target>
        </trans-unit>
        <trans-unit id="f88d1a0da318f485205557f1a4a4b91d6c82b7a4" translate="yes" xml:space="preserve">
          <source>The misconceptions</source>
          <target state="translated">Заблуждения</target>
        </trans-unit>
        <trans-unit id="7d2603e75f0c55eb2703c92e74f015d2c67447b5" translate="yes" xml:space="preserve">
          <source>The only exceptions cannot be worked around in the current language:</source>
          <target state="translated">Единственные исключения не могут быть обработаны на текущем языке:</target>
        </trans-unit>
        <trans-unit id="122da8393156782721cf3629f6cd6821668afecf" translate="yes" xml:space="preserve">
          <source>The only major rule that's important to remember with references is that they must be defined at the time of declaration (with the exception of a reference in a header, in that case it must be defined in the constructor, after the object it's contained in is constructed it's too late to define it).</source>
          <target state="translated">Единственное важное правило,которое важно запомнить со ссылками,это то,что они должны быть определены при объявлении (за исключением ссылки в заголовке,в этом случае она должна быть определена в конструкторе,после того,как объект,в котором она содержится,построен,слишком поздно ее определять).</target>
        </trans-unit>
        <trans-unit id="418b62106b171f039b854dbd9df45e23828dfba0" translate="yes" xml:space="preserve">
          <source>The proper way to stay out of trouble is to avoid dereferencing a NULL pointer to create a reference. Here's an automated way to accomplish this.</source>
          <target state="translated">Правильным способом избежать неприятностей является избежание разыменования указателя NULL для создания ссылки.Вот автоматический способ сделать это.</target>
        </trans-unit>
        <trans-unit id="5873330b5c7abf6ca602c30f272bd7c50e0cbb63" translate="yes" xml:space="preserve">
          <source>The statement above is simply wrong. To avoid such misconceptions, look at the ISO C++ rules instead:</source>
          <target state="translated">Вышеприведенное утверждение просто неверно.Чтобы избежать таких заблуждений,обратите внимание на правила ISO C++:</target>
        </trans-unit>
        <trans-unit id="163a6b49bbef328a902a3d1fe72ca7563153d744" translate="yes" xml:space="preserve">
          <source>There can still be some common properties among references in different programming languages in general, but let's leave it for some other questions in SO.</source>
          <target state="translated">По-прежнему могут быть некоторые общие свойства среди ссылок в разных языках программирования в целом,но давайте оставим это для некоторых других вопросов в SO.</target>
        </trans-unit>
        <trans-unit id="e317f9f1b18599441d13052e85296dbd4035b47d" translate="yes" xml:space="preserve">
          <source>There is a semantic difference that may appear esoteric if you are not familiar with studying computer languages in an abstract or even academic fashion.</source>
          <target state="translated">Существует семантическая разница,которая может показаться эзотерической,если вы не знакомы с изучением компьютерных языков в абстрактной или даже академической манере.</target>
        </trans-unit>
        <trans-unit id="49c3ed839f4ba592814145e1ee7dccb652641c97" translate="yes" xml:space="preserve">
          <source>There is a very important non-technical difference between pointers and references: An argument passed to a function by pointer is much more visible than an argument passed to a function by non-const reference. For example:</source>
          <target state="translated">Существует очень важная нетехническая разница между указателями и ссылками:Аргумент,передаваемый в функцию по указателю,гораздо более заметен,чем аргумент,передаваемый в функцию по неконстантной ссылке.Например:</target>
        </trans-unit>
        <trans-unit id="44e93f1f5f0ace9a170cb0b7222ca3b3580dffcb" translate="yes" xml:space="preserve">
          <source>There is one fundamental difference between pointers and references that I didn't see anyone had mentioned: references enable pass-by-reference semantics in function arguments. Pointers, although it is not visible at first do not: they only provide pass-by-value semantics. This has been very nicely described in &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">Между указателями и ссылками есть одно принципиальное различие, о котором я не видел, чтобы кто-то упомянул: ссылки обеспечивают семантику передачи по ссылке в аргументах функции. Указатели, хотя на первый взгляд они не видны, не делают: они предоставляют только семантику передачи по значению. Это было очень хорошо описано в &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;этой статье&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5066abc2ae8da58f9f9bb296820d74fa0f7a48b1" translate="yes" xml:space="preserve">
          <source>Therefore a reference IS a pointer under the hood, they both are just storing a memory address, where the address is pointing to is irrelevant, what do you think would happen if I called std::cout &amp;lt;&amp;lt; str_ref; AFTER calling delete &amp;amp;str_ref? Well, obviously it compiles fine, but causes a segmentation fault at runtime because it's no longer pointing at a valid variable, we essentially have a broken reference that still exists (until it falls out of scope), but is useless.</source>
          <target state="translated">Поэтому ссылка является указателем под капотом, они оба просто хранят адрес памяти, где адрес, на который указывает адрес, не имеет значения, как вы думаете, что произойдет, если я вызову std :: cout &amp;lt;&amp;lt; str_ref; ПОСЛЕ вызова delete &amp;amp; str_ref? Что ж, очевидно, что он хорошо компилируется, но вызывает ошибку сегментации во время выполнения, потому что он больше не указывает на допустимую переменную, у нас по существу есть неработающая ссылка, которая все еще существует (пока она не выпадает из области видимости), но бесполезна.</target>
        </trans-unit>
        <trans-unit id="94289fe5436213192f08bec365e448fa20dc244c" translate="yes" xml:space="preserve">
          <source>These points empower a considerable part of C++ and the standard library so this is quite a major property of references.</source>
          <target state="translated">Эти пункты расширяют возможности значительной части Си++и стандартной библиотеки,так что это довольно существенное свойство ссылок.</target>
        </trans-unit>
        <trans-unit id="6a0c459929817549c904c8a94991b55621527e3f" translate="yes" xml:space="preserve">
          <source>This assignment changes ival, the value referenced by ri, and not the reference itself. After the assignment, the two references still refer to their original objects, and the value of those objects is now the same as well.</source>
          <target state="translated">Это назначение изменяет двузначность,значение,на которое ссылается ри,а не саму ссылку.После присвоения эти две ссылки все еще ссылаются на свои оригинальные объекты,и теперь значение этих объектов остается неизменным.</target>
        </trans-unit>
        <trans-unit id="bc577f672dad3e6a3a69c44737f3aacd3dd1eb12" translate="yes" xml:space="preserve">
          <source>This is based on the &lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;tutorial&lt;/a&gt;. What is written makes it more clear:</source>
          <target state="translated">Это основано на &lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;учебнике&lt;/a&gt; . То, что написано, делает это более понятным:</target>
        </trans-unit>
        <trans-unit id="3ab66ed104cf4962c17c327aa4d19f6a70663d93" translate="yes" xml:space="preserve">
          <source>This is the language mechanism that allows ScopeGuard to work.</source>
          <target state="translated">Это языковой механизм,который позволяет ScopeGuard работать.</target>
        </trans-unit>
        <trans-unit id="5c9287077fd3860634cb823000e3c46b1b0d2646" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;const&amp;amp;&lt;/code&gt; safer for use in argument lists and so forth.</source>
          <target state="translated">Это делает &lt;code&gt;const&amp;amp;&lt;/code&gt; безопаснее для использования в списках аргументов и так далее.</target>
        </trans-unit>
        <trans-unit id="d92fc23c843fd5c20781bced348b9700ad555c98" translate="yes" xml:space="preserve">
          <source>This program might help in comprehending the answer of the question. This is a simple program of a reference &quot;j&quot; and a pointer &quot;ptr&quot; pointing to variable &quot;x&quot;.</source>
          <target state="translated">Эта программа может помочь в понимании ответа на вопрос.Это простая программа со ссылкой &quot;j&quot; и указателем &quot;ptr&quot;,указывающим на переменную &quot;x&quot;.</target>
        </trans-unit>
        <trans-unit id="f6a17a077fe021118aa2ad5ab8e800b9c24900ac" translate="yes" xml:space="preserve">
          <source>This should permit the compiler to do more optimization on a reference.</source>
          <target state="translated">Это должно позволить компилятору сделать больше оптимизации по ссылке.</target>
        </trans-unit>
        <trans-unit id="2f3d837dc2b38c729da0192bc97e045c3a5109ca" translate="yes" xml:space="preserve">
          <source>To make such an optimization, it needs to prove that nothing can change array[1] during the call. This is rather easy to do. i is never less than 2, so array[i] can never refer to array[1]. maybeModify() is given a0 as a reference (aliasing array[0]). Because there is no &quot;reference&quot; arithmetic, the compiler just has to prove that maybeModify never gets the address of x, and it has proven that nothing changes array[1].</source>
          <target state="translated">Для проведения такой оптимизации необходимо доказать,что ничто не может изменить массив[1]во время вызова.Это довольно просто сделать.i никогда не меньше 2,поэтому array[i]никогда не может ссылаться на array[1].Может быть,в качестве ссылки на функциюModify()дается a0 (aliasing array[0]).Так как никакой &quot;ссылочной&quot; арифметики нет,компилятор просто должен доказать,что maybeModify никогда не получит адрес x,и доказать,что ничего не меняет array[1].</target>
        </trans-unit>
        <trans-unit id="887be10c65852c56ff940b439c392da3426fe46c" translate="yes" xml:space="preserve">
          <source>Unlike the pointers, references are &lt;strong&gt;syntactically equivalent&lt;/strong&gt; to the object they refer to, i.e. any operation that can be applied to an object works for a reference, and with the exact same syntax (the exception is of course the initialization).</source>
          <target state="translated">В отличие от указателей, ссылки &lt;strong&gt;синтаксически эквивалентны&lt;/strong&gt; объекту, на который они ссылаются, то есть любая операция, которая может быть применена к объекту, работает для ссылки и с точно таким же синтаксисом (за исключением, конечно, инициализации).</target>
        </trans-unit>
        <trans-unit id="82af8ce5dd45a624f7e3a05f611fa27d013254ef" translate="yes" xml:space="preserve">
          <source>Update: now that I think about it some more, there is an important difference.</source>
          <target state="translated">Обновление:теперь,когда я думаю об этом еще немного,есть важная разница.</target>
        </trans-unit>
        <trans-unit id="255286b845d43f2eb541ea059727b48d0df67a81" translate="yes" xml:space="preserve">
          <source>Variable of object types do occupy storage as per &lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;the abstract machine&lt;/a&gt; semantics. Reference do not necessary occupy storage (see the section about misconceptions below for details).</source>
          <target state="translated">Переменные типов объектов занимают память согласно семантике &lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;абстрактной машины&lt;/a&gt; . Ссылка не обязательно занимает память (подробности см. В разделе о заблуждениях ниже).</target>
        </trans-unit>
        <trans-unit id="e955ffcb762ae563797df04ca22c14d80f8aa171" translate="yes" xml:space="preserve">
          <source>Visit the following for more information about reference to pointer:</source>
          <target state="translated">Для получения дополнительной информации о ссылке на указатель посетите следующие разделы:</target>
        </trans-unit>
        <trans-unit id="95919816eaf3c9d568884c2a1f7a85a8422fc08c" translate="yes" xml:space="preserve">
          <source>What are the differences between a pointer variable and a reference variable in C++</source>
          <target state="translated">В чем разница между переменной-указателем и переменной-справочником на С++</target>
        </trans-unit>
        <trans-unit id="ebf7dfac9cd8041f70cebb7841fd92ee7068ad0e" translate="yes" xml:space="preserve">
          <source>What is a pointer in C++? Some specific instance of type that &lt;strong&gt;is an object type&lt;/strong&gt;.</source>
          <target state="translated">Что такое указатель в C ++? Некоторый конкретный экземпляр типа, который &lt;strong&gt;является типом объекта&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f1713708129e2693fa553b3ca19fb86a7a27996c" translate="yes" xml:space="preserve">
          <source>What is a reference in C++? Some specific instance of type that &lt;strong&gt;is not an object type&lt;/strong&gt;.</source>
          <target state="translated">Что такое ссылка в C ++? Некоторый конкретный экземпляр типа, который &lt;strong&gt;не является типом объекта&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b27d4d26ba775faaca91cdf7c85e8f345955ab10" translate="yes" xml:space="preserve">
          <source>What's a C++ reference (&lt;em&gt;for C programmers&lt;/em&gt;)</source>
          <target state="translated">Что такое справочник по C ++ ( &lt;em&gt;для программистов на C&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="f4957cb2344c8ba91faaeb20076eeeb6b30d45f2" translate="yes" xml:space="preserve">
          <source>What's more, as we can refer to almost any pointer tutorial, a pointer is an object that is supported by pointer arithmetic which makes pointer similar to an array.</source>
          <target state="translated">Более того,как мы можем сослаться практически на любое учебное пособие по указателям,указатель-это объект,который поддерживается арифметикой с указателями,что делает указатель похожим на массив.</target>
        </trans-unit>
        <trans-unit id="ec620abb83732edc34ab0a338ecb3e522947253f" translate="yes" xml:space="preserve">
          <source>When calling a function, the compiler usually generates memory spaces for the arguments to be copied to. The function signature defines the spaces that should be created and gives the name that should be used for these spaces. Declaring a parameter as a reference just tells the compiler to use the input variable memory space instead of allocating a new memory space during the method call. It may seem strange to say that your function will be directly manipulating a variable declared in the calling scope, but remember that when executing compiled code, there is no more scope; there is just plain flat memory, and your function code could manipulate any variables.</source>
          <target state="translated">При вызове функции компилятор обычно генерирует пространство памяти для копирования аргументов.Сигнатура функции определяет пробелы,которые должны быть созданы,и дает имя,которое должно быть использовано для этих пробелов.Объявление параметра в качестве ссылки просто говорит компилятору использовать пространство памяти входной переменной вместо выделения нового пространства памяти во время вызова метода.Может показаться странным говорить,что ваша функция будет напрямую манипулировать переменной,объявленной в области видимости вызова,но помните,что при выполнении скомпилированного кода больше нет области видимости;есть только простая плоская память,и код вашей функции может манипулировать любыми переменными.</target>
        </trans-unit>
        <trans-unit id="d4c1912265bdef87e12cb7b1321e31b984533bfe" translate="yes" xml:space="preserve">
          <source>When you are implementing smart pointers above, you may have to deal with raw pointers.</source>
          <target state="translated">Когда вы реализуете вышеприведенные интеллектуальные указатели,вам,возможно,придется иметь дело с необработанными указателями.</target>
        </trans-unit>
        <trans-unit id="1dfec36a318fd0d200d4cdbe5653e6d388ef8b86" translate="yes" xml:space="preserve">
          <source>When you create a reference, you only tell the compiler that you assign another name to the pointer variable; that's why references cannot &quot;point to null&quot;, because a variable cannot be, and not be.</source>
          <target state="translated">Когда вы создаете ссылку,вы только сообщаете компилятору,что присваиваете переменной указателя другое имя,поэтому ссылки не могут &quot;указывать на ноль&quot;,потому что переменная не может быть,и не может быть.</target>
        </trans-unit>
        <trans-unit id="c777e0e0107a7f50f79668993af249ac372a560e" translate="yes" xml:space="preserve">
          <source>Which outputs this:</source>
          <target state="translated">Который выводит это:</target>
        </trans-unit>
        <trans-unit id="c5cc6c3d8c26b226ed34902de7cac9e3a05e8f30" translate="yes" xml:space="preserve">
          <source>While both references and pointers are used to indirectly access another value, there are two important differences between references and pointers. The first is that a reference always refers to an object: It is an error to define a reference without initializing it. The behavior of assignment is the second important difference: Assigning to a reference changes the object to which the reference is bound; it does not rebind the reference to another object. Once initialized, a reference always refers to the same underlying object.</source>
          <target state="translated">Хотя и ссылки,и указатели используются для косвенного доступа к другому значению,существуют два важных различия между ссылками и указателями.Первое-это то,что ссылка всегда ссылается на объект:Ошибкой является определение ссылки без ее инициализации.Вторым важным отличием является поведение присваивания:Присвоение ссылки изменяет объект,к которому привязана ссылка;оно не делает повторной привязки ссылки к другому объекту.После инициализации ссылка всегда ссылается на один и тот же базовый объект.</target>
        </trans-unit>
        <trans-unit id="33026a6390ada498b7595f79ab2136f07ff3040a" translate="yes" xml:space="preserve">
          <source>While this may appear superficial, I believe this property is crucial for a number of C++ features, for example:</source>
          <target state="translated">Хотя это может показаться поверхностным,я считаю,что это свойство имеет решающее значение,например,для ряда возможностей C++:</target>
        </trans-unit>
        <trans-unit id="a48d4180c32fc6ba76e32c1184f3989050537522" translate="yes" xml:space="preserve">
          <source>Why I consider C++ references useful</source>
          <target state="translated">Почему я считаю полезными ссылки на С++</target>
        </trans-unit>
        <trans-unit id="a139f82cb75f5fa1d088932ad6ca62c1a9ed365b" translate="yes" xml:space="preserve">
          <source>You can do arithmetic on a pointer.
For example, &lt;code&gt;p += offset;&lt;/code&gt;</source>
          <target state="translated">Вы можете сделать арифметику на указатель. Например, &lt;code&gt;p += offset;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34780a25d9c2fa6caeb26ac54a01416129ecb662" translate="yes" xml:space="preserve">
          <source>You can have pointers to pointers to pointers offering extra levels of indirection.  Whereas references only offer one level of indirection.</source>
          <target state="translated">Вы можете иметь указатели на указатели,которые предлагают дополнительные уровни идирекции.В то время как ссылки предлагают только один уровень индирекции.</target>
        </trans-unit>
        <trans-unit id="ca281bbb0f05d2038a489cb7276fce90296f6044" translate="yes" xml:space="preserve">
          <source>You forgot the most important part:</source>
          <target state="translated">Ты забыл самую важную часть:</target>
        </trans-unit>
        <trans-unit id="5b379fd4bb44eb684d6e0614512cecb190c0230a" translate="yes" xml:space="preserve">
          <source>You have to avoid symbol bloat in some extreme cases.</source>
          <target state="translated">В некоторых крайних случаях нужно избегать раздувания символов.</target>
        </trans-unit>
        <trans-unit id="94dc5492065b8158897a90145f93ab59e74f01ca" translate="yes" xml:space="preserve">
          <source>You have to improve efficiency of the translation (compilation &amp;amp; linking) in some extreme cases.</source>
          <target state="translated">Вы должны повысить эффективность перевода (компиляция и компоновка) в некоторых крайних случаях.</target>
        </trans-unit>
        <trans-unit id="560512056d46b11c084b62f89a3e5fff348a21e2" translate="yes" xml:space="preserve">
          <source>You have to interoperate at runtime with different language implementations (including various assemblies, language runtime and FFI of some high-level client languages) based on assumptions of specific implementations.</source>
          <target state="translated">Вы должны взаимодействовать во время исполнения с различными языковыми реализациями (включая различные ассемблеры,языковую среду исполнения и FFI некоторых высокоуровневых клиентских языков)на основе предположений о конкретных реализациях.</target>
        </trans-unit>
        <trans-unit id="92de6dbe192f694e5996d57ccfe447310dfd3ab8" translate="yes" xml:space="preserve">
          <source>You have to meet the ABI requirements of specific C++ implementations.</source>
          <target state="translated">Вы должны соответствовать требованиям ABI конкретных реализаций C++.</target>
        </trans-unit>
        <trans-unit id="184df4e9e98867001ef0b20404d00c507b584e37" translate="yes" xml:space="preserve">
          <source>You have to serve to old-style (C) APIs.</source>
          <target state="translated">Вы должны обслуживать API в старом стиле (C).</target>
        </trans-unit>
        <trans-unit id="d5c7ab9829b48d10733475f6a32872b8d1dde9fe" translate="yes" xml:space="preserve">
          <source>in simple words, we can say a reference is an alternative name for a variable whereas,
a pointer is a variable that holds the address of another variable.
e.g.</source>
          <target state="translated">простыми словами,можно сказать,что ссылка-это альтернативное имя для переменной,в то время как указатель-это переменная,содержащая адрес другой переменной,например</target>
        </trans-unit>
        <trans-unit id="344723f5f4518fc02c77a821b777b5e5ef5b14c7" translate="yes" xml:space="preserve">
          <source>member-access with pointers uses &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">членский доступ с указателями использует &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a520836c5bc91e48d3c9612930f910ee19298599" translate="yes" xml:space="preserve">
          <source>member-access with references uses &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">членский доступ со ссылками использует &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6cd4d114dbfaf6a41f6a22c17b7940a2cd45fe06" translate="yes" xml:space="preserve">
          <source>will print:</source>
          <target state="translated">напечатает:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
