<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/57483">
    <body>
      <group id="57483">
        <trans-unit id="366a1392d254b91c2979dbb347d6a6006020e4a8" translate="yes" xml:space="preserve">
          <source>(A side note: the question may be significant earlier than any &quot;C-like&quot; languages are involved, like &lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;ALGOL 68 vs. PL/I&lt;/a&gt;.)</source>
          <target state="translated">（補足：この質問は、 &lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;ALGOL 68とPL / Iの&lt;/a&gt;ように、「Cのような」言語が関与するよりも早く重要になる場合があります。）</target>
        </trans-unit>
        <trans-unit id="3c2cc5a14dd2d409d181bc8d16bec43175ff2ec5" translate="yes" xml:space="preserve">
          <source>(Similarly, &lt;em&gt;lambda-expression&lt;/em&gt;s are &lt;em&gt;not&lt;/em&gt; syntactic sugar of any other features in C++ because it cannot be precisely simulated with &quot;unspecified&quot; properties like &lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;the declaration order of the captured variables&lt;/a&gt;, which may be important because the initialization order of such variables can be significant.)</source>
          <target state="translated">（同様に、 &lt;em&gt;ラムダ式&lt;/em&gt; &lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;は、キャプチャされた変数の宣言順序&lt;/a&gt;などの「未指定」プロパティでは正確にシミュレートできないため、C ++の他の機能の構文糖ではあり&lt;em&gt;ません。&lt;/em&gt;このような変数の初期化順序は、重要です。）</target>
        </trans-unit>
        <trans-unit id="1f3d6284e82153785e1a110247b2169240f95d81" translate="yes" xml:space="preserve">
          <source>(or &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; which still relies on an implicit cast
to &lt;code&gt;T&amp;amp;&lt;/code&gt;)</source>
          <target state="translated">（または &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; でも &lt;code&gt;T&amp;amp;&lt;/code&gt; への暗黙のキャストに依存しています）</target>
        </trans-unit>
        <trans-unit id="eb9fd6a3244bc886192add4286c3f4e955b01e2c" translate="yes" xml:space="preserve">
          <source>... An object occupies a region of storage in its period of construction, throughout its lifetime, and in its period of destruction. ...</source>
          <target state="translated">...オブジェクトは、その建設の期間中、その生涯を通じて、そして破壊のその期間中にストレージの領域を占めています。...</target>
        </trans-unit>
        <trans-unit id="aedfef1b56582c6d5ac761f02dc136e601d184b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias_Tom&lt;/code&gt; can be understood as an &lt;code&gt;alias of a variable&lt;/code&gt; (different with &lt;code&gt;typedef&lt;/code&gt;, which is &lt;code&gt;alias of a type&lt;/code&gt;) &lt;code&gt;Tom&lt;/code&gt;. It is also OK to forget the terminology of such statement is to create a reference of &lt;code&gt;Tom&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alias_Tom&lt;/code&gt; &lt;code&gt;alias of a variable&lt;/code&gt; （ &lt;code&gt;alias of a type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; とは異なります ） &lt;code&gt;Tom&lt;/code&gt; として理解できます。 そのようなステートメントの用語が &lt;code&gt;Tom&lt;/code&gt; のリファレンスを作成することであることを忘れても問題ありません。</target>
        </trans-unit>
        <trans-unit id="a5a7b84169fee1ce093f438b076f5fe4d63635e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo.bar&lt;/code&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; in the same way that &lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs&lt;/a&gt; :-)</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt;が&lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs&lt;/a&gt;よりも&lt;em&gt;明らかに&lt;/em&gt;優れているのと同じように、 &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; よりも&lt;em&gt;明らかに&lt;/em&gt;優れています :-)</target>
        </trans-unit>
        <trans-unit id="53a62ec44b159bf24f77f722d3f80606a21a3355" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C++: Reference to Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C ++：ポインターへの参照&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8503c60ec396a2706a5881136f438f315e36942e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;Pointer-to-Pointer and Reference-to-Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;ポインターからポインターおよび参照からポインター&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="48e4529752dcdcff6551309a435706e66b4247e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Copy constructors&lt;/em&gt;. Syntactically it makes sense to pass objects to copy constructors, and not pointers to objects. But there is just no way for a copy constructor to take an object by value - it would result in a recursive call to the same copy constructor. This leaves references as the only option here.</source>
          <target state="translated">&lt;em&gt;コンストラクタをコピーし&lt;/em&gt;ます。 構文的には、オブジェクトへのポインターではなく、コピーコンストラクターにオブジェクトを渡すことは理にかなっています。 ただし、コピーコンストラクターがオブジェクトを値で取得する方法はありません。同じコピーコンストラクターが再帰的に呼び出されます。 これにより、参照がここでの唯一のオプションとして残ります。</target>
        </trans-unit>
        <trans-unit id="5429e39b4353f38912f315f0cc3b02247f3caa2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lvalues&lt;/em&gt;. Consider the statement &lt;code&gt;str[0] = 'X';&lt;/code&gt; Without references it would only work for c-strings (&lt;code&gt;char* str&lt;/code&gt;). Returning the character by reference allows user-defined classes to have the same notation.</source>
          <target state="translated">&lt;em&gt;左辺値&lt;/em&gt; ステートメント &lt;code&gt;str[0] = 'X';&lt;/code&gt; 考えます。 参照がなければ、c-string（ &lt;code&gt;char* str&lt;/code&gt; ）に対してのみ機能します 。 参照によって文字を返すことにより、ユーザー定義クラスが同じ表記を持つことができます。</target>
        </trans-unit>
        <trans-unit id="a6bbf825dc87806d5d7ecc42e1a033d722c63bd0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Operator overloads&lt;/em&gt;. With references it is possible to introduce indirection to an operator call - say, &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; while retaining the same infix notation. This also works for regular overloaded functions.</source>
          <target state="translated">&lt;em&gt;演算子のオーバーロード&lt;/em&gt; 。 参照を使用すると、演算子の呼び出しに間接指定を導入できます。たとえば、 &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; と同じインフィックス表記を保持します。 これは、通常のオーバーロードされた関数でも機能します。</target>
        </trans-unit>
        <trans-unit id="59d32a7fbc66b86330c68b00f7b2998e9416fddd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Templates&lt;/em&gt;. Since template parameters are duck-typed, syntactic properties of a type is all that matters, so often the same template can be used with both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;テンプレート&lt;/em&gt; 。 テンプレートパラメータはダック型であるため、型の構文プロパティが重要であり、同じテンプレートを &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;T&amp;amp;&lt;/code&gt; の両方で使用できることがよくあります。</target>
        </trans-unit>
        <trans-unit id="a5cd9611e4f3bbd50027970fffa4f1f1bd8dbc48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;So, a pointer and a reference both use the same amount of memory.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;したがって、ポインタと参照はどちらも同じ量のメモリを使用します。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6b3894bff8b5c460864e665b4235fd4094d8df4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remember, my examples above are just that, examples demonstrating what a reference is, you would never want to use a reference in those ways! For proper usage of a reference there are plenty of answers on here already that hit the nail on the head&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;上記の私の例は、参照が何であるかを示す例であり、参照をそのような方法で使用することは決してないでしょう。&lt;/strong&gt; &lt;strong&gt;参照を適切に使用するために、頭に釘を打つここにすでにたくさんの答えがあります&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6654cb2acb8b91a57f09603862f530ef72caa5eb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reference&lt;/em&gt; can be thought of as a &lt;em&gt;constant pointer&lt;/em&gt; (not to be confused with a pointer to a constant value!) with automatic indirection, ie the compiler will apply the &lt;code&gt;*&lt;/code&gt; operator for you.</source>
          <target state="translated">&lt;em&gt;参照&lt;/em&gt;は、自動間接指定を備えた&lt;em&gt;定数ポインター&lt;/em&gt; （定数値へのポインターと混同しないでください！）と考えることができます。つまり、コンパイラーが &lt;code&gt;*&lt;/code&gt; 演算子を適用します。</target>
        </trans-unit>
        <trans-unit id="36e44be1b0929668f83744e378c80d1a24783473" translate="yes" xml:space="preserve">
          <source>A compiler keeps &quot;references&quot; to variables, associating a name with a memory address; that's its job to translate any variable name to a memory address when compiling.</source>
          <target state="translated">コンパイラは変数への「参照」を保持し、変数名とメモリアドレスを関連付けます。</target>
        </trans-unit>
        <trans-unit id="959270cda595c9f1ce741e1f2ab621476334d43d" translate="yes" xml:space="preserve">
          <source>A const pointer's target can be replaced by taking its address and using a const cast.</source>
          <target state="translated">constポインタのターゲットは、そのアドレスを取得してconstキャストを使用することで置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="d4063e6d466457440be12f195a44c703d4bcd7c2" translate="yes" xml:space="preserve">
          <source>A few more special rules on references:</source>
          <target state="translated">参照に関する特別なルールをいくつか追加しました。</target>
        </trans-unit>
        <trans-unit id="1b35409877b7144ea91c809ff4d316184f00d741" translate="yes" xml:space="preserve">
          <source>A pointer can be initialized to 0 and a reference not. In fact, a reference must also refer to an object, but a pointer can be the null pointer:</source>
          <target state="translated">ポインタは0に初期化され、参照は初期化されません。実際には、参照もオブジェクトを参照しなければなりませんが、ポインタはヌルポインタにすることができます。</target>
        </trans-unit>
        <trans-unit id="eb1a8b8982766e580a85ab0d0eb62a2e311e86ba" translate="yes" xml:space="preserve">
          <source>A pointer can be re-assigned:</source>
          <target state="translated">ポインタの再割り当てが可能です。</target>
        </trans-unit>
        <trans-unit id="5dcd9a2027d394eca47f36591f61027051772bca" translate="yes" xml:space="preserve">
          <source>A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.  Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable.  Note: What a pointer points to can be on the stack or heap.  Ditto a reference. My claim in this statement is not that a pointer must point to the stack.  A pointer is just a variable that holds a memory address.  This variable is on the stack.  Since a reference has its own space on the stack, and since the address is the same as the variable it references.  More on &lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;stack vs heap&lt;/a&gt;.  This implies that there is a real address of a reference that the compiler will not tell you.</source>
          <target state="translated">ポインタは、スタック上に独自のメモリアドレスとサイズ（x86では4バイト）を持っていますが、参照は（元の変数と）同じメモリアドレスを共有しますが、スタック上のスペースも占有します。 参照は元の変数自体と同じアドレスを持っているので、参照を同じ変数の別の名前と考えるのが安全です。 注：ポインターが指すものは、スタックまたはヒープ上にあります。 同上リファレンス。 このステートメントでの私の主張は、ポインタがスタックを指す必要があるということではありません。 ポインタは、メモリアドレスを保持する単なる変数です。 この変数はスタックにあります。 参照にはスタック上に独自のスペースがあるため、アドレスは参照する変数と同じであるためです。 &lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;スタックとヒープの&lt;/a&gt;詳細。 これは、コンパイラが通知しない参照の実際のアドレスがあることを意味します。</target>
        </trans-unit>
        <trans-unit id="fd455ef49a557a536ce9186591eed75410f73093" translate="yes" xml:space="preserve">
          <source>A pointer needs to be dereferenced with &lt;code&gt;*&lt;/code&gt; to access the memory location it points to, whereas a reference can be used directly.  A pointer to a class/struct uses &lt;code&gt;-&amp;gt;&lt;/code&gt; to access it's members whereas a reference uses a &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">ポインタは、それが指すメモリ位置にアクセスするために &lt;code&gt;*&lt;/code&gt; で逆参照する必要がありますが、参照は直接使用できます。 クラス/構造体へのポインタは &lt;code&gt;-&amp;gt;&lt;/code&gt; を使用してそのメンバーにアクセスしますが、参照はを使用し &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d9e2dd57673143f5ecc15f3125a1e7c15d2ff7a" translate="yes" xml:space="preserve">
          <source>A pointer requires the location of a piece of space on screen that you assure it will contain zero or more instances of that window type.</source>
          <target state="translated">ポインタは、画面上の空間の一部の位置を必要とし、そのウィンドウタイプのインスタンスが0個以上含まれていることを保証します。</target>
        </trans-unit>
        <trans-unit id="01435a266fb491eeeb93f2b49ededf5562a78098" translate="yes" xml:space="preserve">
          <source>A reference can never be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">参照を &lt;code&gt;NULL&lt;/code&gt; にすることはできません。</target>
        </trans-unit>
        <trans-unit id="0db1497e17b4f2171e4c44bff76f09fecf03b574" translate="yes" xml:space="preserve">
          <source>A reference cannot, and must be assigned at initialization:</source>
          <target state="translated">参照は、初期化時に代入できませんし、代入しなければなりません。</target>
        </trans-unit>
        <trans-unit id="8de8f4c2eb87e4ad0059dd772dd0e8d9c15b2d0c" translate="yes" xml:space="preserve">
          <source>A reference is an alias for another variable whereas a pointer holds the memory address of a variable. References are generally used as function parameters so that the passed object is not the copy but the object itself.</source>
          <target state="translated">ポインタが変数のメモリアドレスを保持するのに対し、参照は別の変数のエイリアスです。参照は一般的に関数のパラメータとして使用され、渡されたオブジェクトはコピーではなくオブジェクトそのものになるようになっています。</target>
        </trans-unit>
        <trans-unit id="3fc4f36217977d4385453e9d1605a1d3c9c91d83" translate="yes" xml:space="preserve">
          <source>A reference is not another name given to some memory. It's a immutable pointer that is automatically de-referenced on usage. Basically it boils down to:</source>
          <target state="translated">参照はメモリに与えられた別の名前ではありません。これは、使用時に自動的に参照が解除される不変のポインタです。基本的には以下のようになります。</target>
        </trans-unit>
        <trans-unit id="408fd2770a09c3097a4198b48fb7f80ff76674a3" translate="yes" xml:space="preserve">
          <source>A reference requires you to specify an actual window.</source>
          <target state="translated">参照には実際のウィンドウを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="7a62bb0cc0b8710c81c16b83f6655a27f1f4f924" translate="yes" xml:space="preserve">
          <source>A reference to a pointer is possible in C++, but the reverse is not possible means a pointer to a reference isn't possible. A reference to a pointer provides a cleaner syntax to modify the pointer.
Look at this example:</source>
          <target state="translated">ポインタへの参照は C++で可能ですが、逆ができないということは、参照へのポインタができないということです。ポインタへの参照は、ポインタを修正するためのよりクリーンな構文を提供します。この例を見てください。</target>
        </trans-unit>
        <trans-unit id="f9bf408f44a75a28c1f97df5e2c724d88eaec294" translate="yes" xml:space="preserve">
          <source>A reference's target cannot be replaced in any way short of UB.</source>
          <target state="translated">リファレンスのターゲットはUB以外ではどうやっても置き換えられません。</target>
        </trans-unit>
        <trans-unit id="5355053294d8994c0ecb21bffdd545b0a989f529" translate="yes" xml:space="preserve">
          <source>Actually, a reference is not really like a pointer.</source>
          <target state="translated">実は、参照というのはポインタのようなものではありません。</target>
        </trans-unit>
        <trans-unit id="e7cbf8356a1da6417d65167e6890b1ece5d79c47" translate="yes" xml:space="preserve">
          <source>After the assignment, ival, the object addressed by pi remains unchanged. The assignment changes the value of pi, making it point to a different object. Now consider a similar program that assigns two references:</source>
          <target state="translated">代入後、πによって指定されたオブジェクトは変更されません。代入によってπの値が変更され、別のオブジェクトを指すようになります。次に、2つの参照を代入する同様のプログラムを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="789209b07ed91340d591d3ecbd391a25bb1a617e" translate="yes" xml:space="preserve">
          <source>All references must be initialized with a non-null value or compilation will fail. It's neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references.</source>
          <target state="translated">すべての参照は NULL 以外の値で初期化されていなければなりません。また、参照のアドレスを取得することもできません。アドレス演算子は代わりに参照されている値のアドレスを返します。</target>
        </trans-unit>
        <trans-unit id="4a0d598143cbd5c038eec18a5364ebca3ce06755" translate="yes" xml:space="preserve">
          <source>Also, a reference that is a parameter to a function that is inlined may be handled differently than a pointer.</source>
          <target state="translated">また、インライン化された関数のパラメータである参照は、ポインタとは異なる扱いになる場合があります。</target>
        </trans-unit>
        <trans-unit id="198270e21c92ca200586af9582ab1a26ef99e93d" translate="yes" xml:space="preserve">
          <source>Also, spare 10 minutes and watch this video: &lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;https://www.youtube.com/watch?v=rlJrrGV0iOg&lt;/a&gt;</source>
          <target state="translated">また、10分空けて、次のビデオを&lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;ご覧ください。https&lt;/a&gt; ： //www.youtube.com/watch？v = rlJrrGV0iOg</target>
        </trans-unit>
        <trans-unit id="def296e5debd47695d96a2e810d313523875ea0e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;object&lt;/em&gt; type is a (possibly &lt;em&gt;cv&lt;/em&gt;-qualified) type that is not a function type, not a reference type, and not &lt;em&gt;cv&lt;/em&gt; void.</source>
          <target state="translated">&lt;em&gt;オブジェクト&lt;/em&gt;型は、関数型でも参照型でもない&lt;em&gt;cv&lt;/em&gt; voidではない（場合によっては&lt;em&gt;cv&lt;/em&gt;修飾された）型です。</target>
        </trans-unit>
        <trans-unit id="aaa58e7db6a960dc51cd22c3dc1684dfd20f847c" translate="yes" xml:space="preserve">
          <source>An optimizing compiler may realize that we are accessing a[0] and a[1] quite a bunch. It would love to optimize the algorithm to:</source>
          <target state="translated">最適化コンパイラは、a[0]とa[1]にかなりの数のアクセスをしていることに気づくかもしれません。それはアルゴリズムを最適化したいのでしょう。</target>
        </trans-unit>
        <trans-unit id="a77f60581112f1094707329df4c6d30c6956a373" translate="yes" xml:space="preserve">
          <source>And consider the C version of the above program. In C you have to use pointer to pointer (multiple indirection), and it leads to confusion and the program may look complicated.</source>
          <target state="translated">そして、上記のプログラムのC版を考えてみましょう。C言語ではポインタへのポインタを使用しなければならず(マルチプルインダイレクト)、混乱を招き、プログラムが複雑に見えてしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="ddb61be46c893264465a08b177ca023b9286da4f" translate="yes" xml:space="preserve">
          <source>Another difference is that pointer can point to another object however reference is always referencing to the same object, let&amp;rsquo;s take this example:</source>
          <target state="translated">もう1つの違いは、ポインターは別のオブジェクトを指すことができるということですが、参照は常に同じオブジェクトを参照しているので、次の例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d9d2f372f903617152234f6054a59f4db746d3e3" translate="yes" xml:space="preserve">
          <source>Another difference is that you can have pointers to a void type (and it means pointer to anything) but references to void are forbidden.</source>
          <target state="translated">もう一つの違いは、void型へのポインタを持つことはできますが(何かへのポインタを意味します)、voidへの参照は禁止されているということです。</target>
        </trans-unit>
        <trans-unit id="ed06ace0f97d6901e5c79ad444c40f4d371c03fa" translate="yes" xml:space="preserve">
          <source>Another important point is that is we can make the declaration of the pointer without initialization however no such thing can be done in case of reference which must make a reference always to variable or object. However such use of a pointer is risky so generally we check if the pointer is actually is pointing to something or not. In case of a reference no such check is necessary, because we know already that referencing to an object during declaration is mandatory.</source>
          <target state="translated">もう一つの重要なポイントは、我々は初期化せずにポインタの宣言を行うことができるということですが、そのようなことは、常に変数やオブジェクトへの参照を行う必要があります参照の場合には行うことができません。しかし、このようなポインタの使用は危険なので、一般的にはポインタが実際に何かを指しているかどうかをチェックします。参照の場合は、宣言時にオブジェクトを参照することが必須であることをすでに知っているので、そのようなチェックは必要ありません。</target>
        </trans-unit>
        <trans-unit id="cab05ab1c2c0ef5b2ba43eff8ccf5c0c4d2d12e9" translate="yes" xml:space="preserve">
          <source>Another interesting use of references is to supply a default argument of a user-defined type:</source>
          <target state="translated">参照のもう一つの興味深い使い方は、ユーザー定義型のデフォルト引数を与えることです。</target>
        </trans-unit>
        <trans-unit id="8405a7757378ccd741f1d45d9bcb524d4b5f3829" translate="yes" xml:space="preserve">
          <source>Another point: When we have a template like an STL template such kind of a class template will always return a reference, not a pointer, to make easy reading or assigning new value using operator []:</source>
          <target state="translated">もう一つのポイント。STLテンプレートのようなテンプレートがある場合、このようなクラステンプレートは常にポインタではなく参照を返すので、読み込みや演算子[]を使った新しい値の代入を容易にすることができます。</target>
        </trans-unit>
        <trans-unit id="8ae9e0a7b8d69bc4223ff39bbb83d311d51fca21" translate="yes" xml:space="preserve">
          <source>Apart from syntactic sugar, a reference is a &lt;code&gt;const&lt;/code&gt; pointer (&lt;em&gt;not&lt;/em&gt; pointer to a &lt;code&gt;const&lt;/code&gt;). You must establish what it refers to when you declare the reference variable, and you cannot change it later.</source>
          <target state="translated">構文糖とは別に、参照は &lt;code&gt;const&lt;/code&gt; ポインターです（ constへのポインターではあり&lt;em&gt;ません&lt;/em&gt; ）。 参照変数を宣言するときに参照先を確立する必要があり、後で変更することはできません。</target>
        </trans-unit>
        <trans-unit id="8d8f44fcd3e6f397b6db8398ce3d44734a996ea7" translate="yes" xml:space="preserve">
          <source>As I said, a pointer to a reference isn't possible. Try the following program:</source>
          <target state="translated">先ほども言ったように、参照へのポインタは不可能です。以下のプログラムを試してみてください。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">一例として。</target>
        </trans-unit>
        <trans-unit id="82db7c2ab0468c723d35542df3eb95e5e5ba8cad" translate="yes" xml:space="preserve">
          <source>At the highest-level, the idea of references is that they are transparent &quot;aliases&quot;. Your computer may use an address to make them work, but you're not supposed to worry about that: you're supposed to think of them as &quot;just another name&quot; for an existing object and the syntax reflects that. They are stricter than pointers so your compiler can more reliably warn you when you about to create a dangling reference, than when you are about to create a dangling pointer.</source>
          <target state="translated">最高レベルでは、参照の考え方は、それが透明な「エイリアス」であるということです。コンピュータはアドレスを使用して参照を動作させるかもしれませんが、それを心配する必要はありません。ポインタよりも厳密なので、コンパイラは、ダングリングポインタを作成しようとしているときよりも、ダングリング参照を作成しようとしているときの方が、より確実に警告を出すことができます。</target>
        </trans-unit>
        <trans-unit id="1c79f63a01a5e0dc422bfd0d4cf499645ee5ba60" translate="yes" xml:space="preserve">
          <source>At the risk of adding to confusion, I want to throw in some input, I'm sure it mostly depends on how the compiler implements references, but in the case of gcc the idea that a reference can only point to a variable on the stack is not actually correct, take this for example:</source>
          <target state="translated">混乱を招く恐れがあるので、いくつかの意見を述べたいのですが、コンパイラがどのように参照を実装するかに依存すると思いますが、gccの場合、参照がスタック上の変数を指すことしかできないという考えは実際には正しくありません。</target>
        </trans-unit>
        <trans-unit id="e6de6d55fd9e888c00be46ee2285966c7f90196b" translate="yes" xml:space="preserve">
          <source>BTW, a few other contexts like initialization involving &lt;code&gt;std::initializer_list&lt;/code&gt; follows some similar rules of reference lifetime extension. It is another can of worms.</source>
          <target state="translated">ところで、 &lt;code&gt;std::initializer_list&lt;/code&gt; を伴う初期化のようないくつかの他のコンテキストは、参照存続期間拡張のいくつかの同様のルールに従います。 それはワームの別の缶です。</target>
        </trans-unit>
        <trans-unit id="28157cc4e97b442db1a423840eb02259f1ee9ada" translate="yes" xml:space="preserve">
          <source>Back in C, a call that looks like &lt;code&gt;fn(x)&lt;/code&gt; can only be passed by value, so it definitely cannot modify &lt;code&gt;x&lt;/code&gt;; to modify an argument you would need to pass a pointer &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt;. So if an argument wasn't preceded by an &lt;code&gt;&amp;amp;&lt;/code&gt; you knew it would not be modified. (The converse, &lt;code&gt;&amp;amp;&lt;/code&gt; means modified, was not true because you would sometimes have to pass large read-only structures by &lt;code&gt;const&lt;/code&gt; pointer.)</source>
          <target state="translated">Cに戻ると、 &lt;code&gt;fn(x)&lt;/code&gt; のように見える呼び出しは値でのみ渡すことができるため、 &lt;code&gt;x&lt;/code&gt; を変更することはできません。 引数を変更するには、ポインタ &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt; を渡す必要があります。 したがって、引数の前に &lt;code&gt;&amp;amp;&lt;/code&gt; がなければ、変更されないことがわかっていました。 （ &lt;code&gt;const&lt;/code&gt; ポインターによって大規模な読み取り専用構造体を渡す必要がある場合があるため、その逆、 &lt;code&gt;&amp;amp;&lt;/code&gt; 変更されたという意味は正しくありませんでした。）</target>
        </trans-unit>
        <trans-unit id="52fbc9beddeb6a8c7a6bb62a43b5c950f4daeb34" translate="yes" xml:space="preserve">
          <source>Beyond that, there are of course some practical differences between pointers and references. The syntax to use them is obviously different, and you cannot &quot;re-seat&quot; references, have references to nothingness, or have pointers to references.</source>
          <target state="translated">その先には、もちろんポインタと参照の間にはいくつかの実用的な違いがあります。それらを使用するための構文は明らかに異なっており、参照を「再座らせる」ことはできませんし、何もないところへの参照を持つことも、参照へのポインタを持つこともできません。</target>
        </trans-unit>
        <trans-unit id="2f0a115b892ed33dc580b0746ea765524e9adee4" translate="yes" xml:space="preserve">
          <source>But if a reference &lt;em&gt;really&lt;/em&gt; were the object, how could there be dangling references? In unmanaged languages, it's impossible for references to be any 'safer' than pointers - there generally just isn't a way to reliably alias values across scope boundaries!</source>
          <target state="translated">しかし、参照が&lt;em&gt;実際&lt;/em&gt;にオブジェクトである場合、参照がぶら下がっているのはどうしてでしょうか？ アンマネージ言語では、参照をポインターよりも「安全」にすることは不可能です。通常、スコープの境界を越えて値を確実にエイリアスする方法はありません。</target>
        </trans-unit>
        <trans-unit id="c0f0472a48232cf765cdc5a4ed86bcc402178e6e" translate="yes" xml:space="preserve">
          <source>But this is not the whole story. I mean, there are more things than pointers vs references you have to consider.</source>
          <target state="translated">しかし、これは全体の話ではありません。つまり、あなたが考慮しなければならないのは、ポインタ対参照よりも多くのものがあるということです。</target>
        </trans-unit>
        <trans-unit id="1219d69d4aae4754c68f172af1e20be534822a2e" translate="yes" xml:space="preserve">
          <source>But we can&amp;rsquo;t have &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; and also &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt;.</source>
          <target state="translated">しかし、 &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; することはできません。 また、 &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85c1119a1a34eb5b96e7a27219b6d23bf265027f" translate="yes" xml:space="preserve">
          <source>But what are the differences?</source>
          <target state="translated">しかし、何が違うのでしょうか?</target>
        </trans-unit>
        <trans-unit id="ea217864ff94b0a58af879bc82826ac7131e836c" translate="yes" xml:space="preserve">
          <source>C programmers might dislike C++ references as it will no longer be obvious when indirection happens or if an argument gets passed by value or by pointer without looking at function signatures.</source>
          <target state="translated">関数のシグネチャを見なくても、インダイレクトが発生したときや、引数が値やポインタで渡されたときに明らかにならないので、C プログラマは C++の参照を嫌うかもしれません。</target>
        </trans-unit>
        <trans-unit id="4a06c33b9cfbaa63574bd669ad9aaf1bc634c44a" translate="yes" xml:space="preserve">
          <source>C++ only has a few kinds of syntactic sugars in this strict sense. One instance is (inherited from C) the built-in (non-overloaded) operator &lt;code&gt;[]&lt;/code&gt;, which &lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;is defined exactly having same semantic properties of specific forms of combination over built-in operator unary &lt;code&gt;*&lt;/code&gt; and binary &lt;code&gt;+&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C ++には、この厳密な意味での数種類の構文糖があります。 1つのインスタンスは（Cから継承された）組み込み（オーバーロードされていない）演算子 &lt;code&gt;[]&lt;/code&gt; であり&lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;、組み込み演算子unary &lt;code&gt;*&lt;/code&gt; およびbinary &lt;code&gt;+&lt;/code&gt; に対する特定の組み合わせの特定の形式のセマンティックプロパティを持つように定義されてい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9bb21fac313bcd60906b2b35ca4582ec35330749" translate="yes" xml:space="preserve">
          <source>C++ programmers might dislike using pointers as they are considered unsafe - although references aren't really any safer than constant pointers except in the most trivial cases - lack the convenience of automatic indirection and carry a different semantic connotation.</source>
          <target state="translated">C++プログラマは、ポインタを使うことは安全ではないと考えられているため、ポインタの使用を嫌うかもしれません。</target>
        </trans-unit>
        <trans-unit id="9d2b52840330e7a44bc694eb6918e7e64357a038" translate="yes" xml:space="preserve">
          <source>Coming from a C background, C++ references may look like a somewhat silly concept, but one should still use them instead of pointers where possible: Automatic indirection &lt;em&gt;is&lt;/em&gt; convenient, and references become especially useful when dealing with &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt; - but not because of any perceived safety advantage, but rather because they make writing idiomatic code less awkward.</source>
          <target state="translated">Cのバックグラウンドから来ると、C ++参照はややばかげた概念のように見えるかもしれませんが、可能な場合はポインターの代わりにそれらを使用する必要があります。自動インダイレクション&lt;em&gt;は&lt;/em&gt;便利です。利点ですが、むしろ、慣用的なコードを書きにくくしません。</target>
        </trans-unit>
        <trans-unit id="059cdeb648fa366a46a8b8314ed53bd8fc068d24" translate="yes" xml:space="preserve">
          <source>Compound declarators are more restrictive on references.</source>
          <target state="translated">複合宣言子は、参照に対してより制限的です。</target>
        </trans-unit>
        <trans-unit id="403fed44f11ec4c8ff00fd23f9802e6597c6b4a0" translate="yes" xml:space="preserve">
          <source>Consider the following statement from the &lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;C++ FAQ&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;C ++ FAQ&lt;/em&gt;&lt;/a&gt;の次のステートメントについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="67105debe8987091e6bdc70ef2e1c62eaeef75e5" translate="yes" xml:space="preserve">
          <source>Consider these two program fragments. In the first, we assign one pointer to another:</source>
          <target state="translated">これら2つのプログラムの断片を考えてみましょう。前者では、あるポインタを別のポインタに代入しています。</target>
        </trans-unit>
        <trans-unit id="0cdefee66dd0f6388e32b9d6fed8a4351a84480e" translate="yes" xml:space="preserve">
          <source>Const references can be bound to temporaries. Pointers cannot (not without some indirection):</source>
          <target state="translated">Const参照はテンポラリにバインドすることができます。ポインタはできません(間接的にはできません)。</target>
        </trans-unit>
        <trans-unit id="257ee630683f00991c22ec378f7e691a1faab887" translate="yes" xml:space="preserve">
          <source>Contrary to popular opinion, it is possible to have a reference that is NULL.</source>
          <target state="translated">一般的な意見に反して、NULLである参照を持つことは可能です。</target>
        </trans-unit>
        <trans-unit id="43548a90788ae029335a689520a48ebf306a65a2" translate="yes" xml:space="preserve">
          <source>Copy constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually it should be &lt;code&gt;const&lt;/code&gt; qualified.)</source>
          <target state="translated">コピーコンストラクターには、特定のタイプの&lt;em&gt;cv-&lt;/em&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; 参照タイプが1番目のパラメータータイプとして必要です。 （通常、 &lt;code&gt;const&lt;/code&gt; 修飾されている必要があります。）</target>
        </trans-unit>
        <trans-unit id="2dfaa6ee16a6acd02f7f18aa98b05c4a8bd6187a" translate="yes" xml:space="preserve">
          <source>Difference between pointer and reference</source>
          <target state="translated">ポインタと参照の違い</target>
        </trans-unit>
        <trans-unit id="8d3aac2e61ebd63a0be37ce5d8c06b59c983898f" translate="yes" xml:space="preserve">
          <source>EDIT: Five years after posting this answer, I found an actual technical difference where references are different than just a different way of looking at the same addressing concept.  References can modify the lifespan of temporary objects in a way that pointers cannot.</source>
          <target state="translated">EDIT:この答えを投稿してから5年後、私は、参照が同じアドレッシングの概念を見るための単なる異なる方法ではなく、実際の技術的な違いを発見しました。参照は、ポインタではできない方法で一時的なオブジェクトの寿命を変更することができます。</target>
        </trans-unit>
        <trans-unit id="afbb5feebb594dfda93806a9043262ea69ffa66b" translate="yes" xml:space="preserve">
          <source>Even that pointers are not qualified enough to be put together with references in the sense of the language design, there are still some arguments making it debatable to make choice between them in some other contexts, for example, when making choices on parameter types.</source>
          <target state="translated">ポインタが言語設計の意味で参照と一緒にまとめられるほど修飾されていないということであっても、例えばパラメータ型の選択をするときのように、他のいくつかの文脈でそれらの間の選択をすることが議論の余地のあるものにするいくつかの議論が残っています。</target>
        </trans-unit>
        <trans-unit id="1f7c6527f15ac956bb6422655a89e581ad918f6c" translate="yes" xml:space="preserve">
          <source>Even though a reference is often implemented using an address in the
  underlying assembly language, please do &lt;em&gt;not&lt;/em&gt; think of a reference as a
  funny looking pointer to an object. A reference &lt;em&gt;is&lt;/em&gt; the object. It is
  not a pointer to the object, nor a copy of the object. It &lt;em&gt;is&lt;/em&gt; the
  object.</source>
          <target state="translated">参照は多くの場合、基になるアセンブリ言語のアドレスを使用して実装されますが、参照をオブジェクトへの変なポインタとして考え&lt;em&gt;ない&lt;/em&gt;でください。 参照&lt;em&gt;は&lt;/em&gt;オブジェクトです。 これは、オブジェクトへのポインタでも、オブジェクトのコピーでもありません。 それ&lt;em&gt;が&lt;/em&gt;対象です。</target>
        </trans-unit>
        <trans-unit id="1f0674352c239a778bc468638b40b47fb71b2d98" translate="yes" xml:space="preserve">
          <source>Even when you do want semantics like traditional pointer, there are often something more appropriate, like &lt;code&gt;observer_ptr&lt;/code&gt; in Library Fundamental TS.</source>
          <target state="translated">従来のポインターのようなセマンティクスが必要な場合でも、Library Fundamental TSの &lt;code&gt;observer_ptr&lt;/code&gt; のようなより適切なものがしばしばあります。</target>
        </trans-unit>
        <trans-unit id="91de4132deb2a9d1d143f39e4534fbb3726e45ff" translate="yes" xml:space="preserve">
          <source>For an older look at this problem from someone with better writing skills, see &lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;Null References&lt;/a&gt; from Jim Hyslop and Herb Sutter.</source>
          <target state="translated">より優れたライティングスキルを持つ人からのこの問題の古い見方については、ジムハイスロップとハーブサッターからの&lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;ヌル参照を参照&lt;/a&gt;してください。</target>
        </trans-unit>
        <trans-unit id="c8c71250e475a3240795bff029fac330bf5c86bc" translate="yes" xml:space="preserve">
          <source>For another example of the dangers of dereferencing a null pointer see &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;Exposing undefined behavior when trying to port code to another platform&lt;/a&gt; by Raymond Chen.</source>
          <target state="translated">nullポインターを逆参照する危険の別の例については、Raymond Chenが&lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;コードを別のプラットフォームに移植しようとしたときに未定義の動作&lt;/a&gt;を公開するを参照してください。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="419ffcbab3d6f22ef6fdb16e11f51ddef360025c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;the ISO C++ definition of object type&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;オブジェクトタイプのISO C ++定義から&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c921eb398c160fb46e416cb1d07e77fdce036162" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref]/4&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref] / 4から&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="bf57a6753ab8a3e91849d0a5046139bd0ae54c97" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object]/1&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object] / 1から&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="59b186995c92752fd57142834fecf2e2d3252883" translate="yes" xml:space="preserve">
          <source>Function pointers can be converted from lambda expressions without captures, while function references cannot. You have to use function pointers in non-generic code for such cases, even you deliberately do not want nullable values.</source>
          <target state="translated">関数ポインタはキャプチャなしでラムダ式から変換できますが、関数参照は変換できません。このような場合には、わざとヌル可能な値を必要としない場合でも、ジェネリックではないコードで関数ポインタを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="5a8a000b2872f2ecd2628fd91b4af38afe4ab27a" translate="yes" xml:space="preserve">
          <source>Granted, it is much harder to do with a reference - but if you manage it, you'll tear your hair out trying to find it. References are &lt;em&gt;not&lt;/em&gt; inherently safe in C++!</source>
          <target state="translated">確かに、参照を使用するのははるかに困難ですが、それを管理すると、それを見つけようとすると髪が裂けてしまいます。 参照はC ++では本質的に安全ではあり&lt;em&gt;ません&lt;/em&gt; ！</target>
        </trans-unit>
        <trans-unit id="f3d615628d1fd5133dbe19b3297b67cff89e2934" translate="yes" xml:space="preserve">
          <source>Here you are not creating another variable that points to &lt;code&gt;a&lt;/code&gt;; you are just adding another name to the memory content holding the value of &lt;code&gt;a&lt;/code&gt;. This memory now has two names, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and it can be addressed using either name.</source>
          <target state="translated">ここでは、を指す別の変数を作成していません。 あなただけの値を保持するメモリ内容に別の名前を追加しています。 このメモリには2つの名前 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; があり 、どちらの名前を使用してもアドレス指定できます。</target>
        </trans-unit>
        <trans-unit id="6748018a83feee685129beabf05358adfb1f4a93" translate="yes" xml:space="preserve">
          <source>I can't say I'm really happy with this particular difference. I would much prefer it would be allowed with the meaning reference to anything with an address and otherwise the same behavior for references. It would allow to define some equivalents of C library functions like memcpy using references.</source>
          <target state="translated">私はこの特定の違いに本当に満足しているとは言えません。私は、アドレスを持つ何かへの参照の意味で許可され、それ以外の場合は、参照のための同じ動作をすることをはるかに好んでいます。これにより、参照を使ってmemcpyのようなCライブラリ関数のいくつかの同等のものを定義することができるようになります。</target>
        </trans-unit>
        <trans-unit id="83cff075b67cc3caa75652556ccf090327793e2f" translate="yes" xml:space="preserve">
          <source>I feel like there is yet another point that hasn't been covered here.</source>
          <target state="translated">ここで取り上げられていない点がまだあるような気がします。</target>
        </trans-unit>
        <trans-unit id="78aca0acaa65086aab3a232e328bb0bc36aa5fcb" translate="yes" xml:space="preserve">
          <source>I know references are syntactic sugar, so code is easier to read and write.</source>
          <target state="translated">参照は構文上の糖質だからコードの方が読みやすくて書きやすいのは知っている。</target>
        </trans-unit>
        <trans-unit id="790a903c1bebeddd1477cdd4d06bfb3b8a62ae9b" translate="yes" xml:space="preserve">
          <source>I use references unless I need either of these:</source>
          <target state="translated">どちらかが必要な場合以外は参考文献を使っています。</target>
        </trans-unit>
        <trans-unit id="3068917d6116da066c23030c927f12eb7a21feb4" translate="yes" xml:space="preserve">
          <source>I want to reiterate that the only way to get a null reference is through malformed code, and once you have it you're getting undefined behavior. It &lt;strong&gt;never&lt;/strong&gt; makes sense to check for a null reference; for example you can try &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; but the compiler might optimize the statement out of existence! A valid reference can never be NULL so from the compiler's view the comparison is always false, and it is free to eliminate the &lt;code&gt;if&lt;/code&gt; clause as dead code - this is the essence of undefined behavior.</source>
          <target state="translated">繰り返しますが、null参照を取得する唯一の方法は、不正な形式のコードを使用することであり、これを取得すると、未定義の動作が発生します。 null参照をチェックして&lt;strong&gt;も&lt;/strong&gt;意味があり&lt;strong&gt;ません&lt;/strong&gt; 。 たとえば &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; を試すことができますが、コンパイラはステートメントを存在しないように最適化する可能性があります 。 有効な参照がNULLになることは決してないので、コンパイラの観点からは比較は常にfalseであり、デッドコードとしての &lt;code&gt;if&lt;/code&gt; 句を自由に削除できます。これが未定義の動作の本質です。</target>
        </trans-unit>
        <trans-unit id="28a1dd0bb23764b68abee77b06fa28aa411978df" translate="yes" xml:space="preserve">
          <source>If you are doing some iterations over a range, use iterators (or some ranges which are not provided by the standard library yet), rather than raw pointers unless you are convinced raw pointers will do better (e.g. for less header dependencies) in very specific cases.</source>
          <target state="translated">範囲の反復処理を行う場合は、非常に特殊なケースでは生ポインタの方が良いと確信している場合(例えばヘッダ依存性が少ないなど)を除き、生ポインタではなくイテレータ(あるいは標準ライブラリではまだ提供されていないいくつかの範囲)を使用するようにしてください。</target>
        </trans-unit>
        <trans-unit id="3ba495f422aa5c4d4099a4f3e279461a678eacba" translate="yes" xml:space="preserve">
          <source>If you come to see the question via &lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;some Google search result (not specific to C++)&lt;/a&gt;, this is very likely to be the wrong place.</source>
          <target state="translated">&lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;Googleの検索結果（C ++に固有ではない）&lt;/a&gt;を介して質問が表示される場合、これは間違いの可能性が高い場所です。</target>
        </trans-unit>
        <trans-unit id="1adb9ff9254b1ced3f48e2cba167b170d900e4b7" translate="yes" xml:space="preserve">
          <source>If you don't have to stick on such over-specific choices, in most cases the answer is short: &lt;strong&gt;you do not have the necessity to use pointers, so you don't&lt;/strong&gt;. Pointers are usually bad enough because they imply too many things you don't expect and they will rely on too many implicit assumptions undermining the maintainability and (even) portability of the code. &lt;strong&gt;Unnecessarily relying on pointers is definitely a bad style and it should be avoided in the sense of modern C++.&lt;/strong&gt; Reconsider your purpose and you will finally find that &lt;strong&gt;pointer is the feature of last sorts&lt;/strong&gt; in most cases.</source>
          <target state="translated">このような過度に具体的な選択に固執する必要がない場合、ほとんどの場合、答えは短く&lt;strong&gt;なります&lt;/strong&gt; 。 &lt;strong&gt;ポインタを使用する必要がないため、使用しません&lt;/strong&gt; 。 ポインターは通常、予想外のことを暗に示しすぎ、コードの保守性と（さらには）移植性を損なう暗黙の仮定に頼りすぎるため、十分に悪いものです。 &lt;strong&gt;不必要にポインターに依存することは間違いなく悪いスタイルであり、最新のC ++の意味では避ける必要があります。&lt;/strong&gt; 目的を再検討すると、ほとんどの場合、 &lt;strong&gt;ポインタが最後のソートの機能で&lt;/strong&gt;あることが最終的にわかります。</target>
        </trans-unit>
        <trans-unit id="cb2d77074444d61d2cc67de2bd0e1d87f2a0a031" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value (i.e. using non-reference types) is sufficient, use it directly, particularly when using an implementation supporting C++17 mandated copy elision. (&lt;strong&gt;Warning&lt;/strong&gt;: However, to &lt;strong&gt;exhaustively&lt;/strong&gt; reason about the necessity can be &lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;very complicated&lt;/a&gt;.)</source>
          <target state="translated">値渡し（つまり、非参照型を使用する）で十分であるとわかっている場合は、特にC ++ 17必須コピー省略をサポートする実装を使用するときに、それを直接使用してください。 （ &lt;strong&gt;警告&lt;/strong&gt; ：ただし、必要性を&lt;strong&gt;徹底的に推論&lt;/strong&gt;することは&lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;非常に複雑に&lt;/a&gt;なる可能性があります。）</target>
        </trans-unit>
        <trans-unit id="8ab269d4d0dfc63f1830ebd5af6f660e85c8c775" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is not ideal for the reasons above, and you don't want nullable semantics, use {lvalue, rvalue, forwarding}-references.</source>
          <target state="translated">上記の理由から値渡しが理想的ではないことがわかっていて、ヌル可能なセマンティクスを望まない場合は、{lvalue,rvalue,forwarding}-referenceを使用します。</target>
        </trans-unit>
        <trans-unit id="95a97bbef840565852fb933bd387402999a8aa62" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is sufficient and you want some explicit nullable semantics, use wrapper like &lt;code&gt;std::optional&lt;/code&gt;, rather than raw pointers.</source>
          <target state="translated">値渡しが十分であることがわかっていて、明示的なnull可能セマンティクスが &lt;code&gt;std::optional&lt;/code&gt; な場合は、生のポインタではなく、 std :: optionalのようなラッパーを使用します。</target>
        </trans-unit>
        <trans-unit id="f83f246714f814ce810c05a9ae95c69e9261bd39" translate="yes" xml:space="preserve">
          <source>If you notice even the memory addresses are exactly the same, meaning the reference is successfully pointing to a variable on the heap! Now if you really want to get freaky, this also works:</source>
          <target state="translated">これは、参照がヒープ上の変数を指すことに成功していることを意味します。これは、参照がヒープ上の変数を指すことに成功したことを意味します。</target>
        </trans-unit>
        <trans-unit id="f057014d6ad0660324ee4744392d34f7205d30d5" translate="yes" xml:space="preserve">
          <source>If you try this without the &lt;code&gt;const&lt;/code&gt; it should fail to compile. You cannot bind a non-const reference to a temporary object, nor can you take its address for that matter.</source>
          <target state="translated">これを &lt;code&gt;const&lt;/code&gt; なしで試すと、コンパイルに失敗するはずです。 非const参照を一時オブジェクトにバインドしたり、そのアドレスを取得したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="543e04d6c7cf8b1ff3568e8f9fe688b2b4150999" translate="yes" xml:space="preserve">
          <source>If you want to be really pedantic, there is one thing you can do with a reference that you can't do with a pointer: extend the lifetime of a temporary object. In C++ if you bind a const reference to a temporary object, the lifetime of that object becomes the lifetime of the reference.</source>
          <target state="translated">それは、一時オブジェクトの寿命を延長することです。C++では、一時オブジェクトに const 参照をバインドすると、そのオブジェクトの寿命が参照の寿命になります。</target>
        </trans-unit>
        <trans-unit id="2f134bd878c28bfcf0e94f5edce84bd4768767e8" translate="yes" xml:space="preserve">
          <source>If you want to operate some handles with ownership, use smart pointers like &lt;code&gt;unique_ptr&lt;/code&gt; and &lt;code&gt;shared_ptr&lt;/code&gt; (or even with homebrew ones by yourself if you require them to be &lt;em&gt;opaque&lt;/em&gt;), rather than raw pointers.</source>
          <target state="translated">所有権でいくつかのハンドルを操作する場合は、生のポインタではなく、 &lt;code&gt;unique_ptr&lt;/code&gt; や &lt;code&gt;shared_ptr&lt;/code&gt; などのスマートポインタを使用します（または、 &lt;em&gt;不透明に&lt;/em&gt;する必要がある場合は、自分で自家製のハンドルを使用します）。</target>
        </trans-unit>
        <trans-unit id="f9770a58e8e2c829e550700ed47290c2aae7fa6f" translate="yes" xml:space="preserve">
          <source>In fact to do it properly, we must have declared and defined an object at the first then we can make a reference to that object, so the correct implementation of the previous code will be:</source>
          <target state="translated">実際には適切にそれを行うには、我々は宣言し、最初にオブジェクトを定義している必要がありますし、我々はそのオブジェクトへの参照を行うことができますので、前のコードの正しい実装になります。</target>
        </trans-unit>
        <trans-unit id="82769a796fb3193fe927e0baf51f38ab518d3ebb" translate="yes" xml:space="preserve">
          <source>In other words, a reference is nothing but a pointer that has the pointer mechanics abstracted away, making it safer and easier to use (no accidental pointer math, no mixing up '.' and '-&amp;gt;', etc.), assuming you don't try any nonsense like my examples above ;)</source>
          <target state="translated">つまり、参照は、ポインタのメカニズムを抽象化したポインタにすぎず、安全で使いやすくなっています（偶発的なポインタ計算、「。」と「-&amp;gt;」などの混同はありません）。上記の私の例のようなナンセンスを試さないでください;）</target>
        </trans-unit>
        <trans-unit id="200b5d2213958228565fdde5b08d7bf3a0e7e8c1" translate="yes" xml:space="preserve">
          <source>In this example s3_copy copies the temporary object that is a result of the concatenation. Whereas s3_reference in essence becomes the temporary object. It's really a reference to a temporary object that now has the same lifetime as the reference.</source>
          <target state="translated">この例では、s3_copy は連結の結果である一時オブジェクトをコピーします。一方、s3_referenceは本質的に一時オブジェクトになります。これは実際には一時オブジェクトへの参照であり、参照と同じライフタイムを持つようになりました。</target>
        </trans-unit>
        <trans-unit id="ba73ce596882bac23adab797099d810c536e52c7" translate="yes" xml:space="preserve">
          <source>It also has to prove that there are no ways a future call could read/write a[0] while we have a temporary register copy of it in a0. This is often trivial to prove, because in many cases it is obvious that the reference is never stored in a permanent structure like a class instance.</source>
          <target state="translated">また、a0に一時的なレジスタのコピーがある間に、将来の呼び出しがa[0]を読み書きできる方法がないことも証明しなければなりません。多くの場合、参照がクラスインスタンスのような恒久的な構造体に保存されることはないことが明らかなので、これは証明するのには些細なことであることが多いです。</target>
        </trans-unit>
        <trans-unit id="c0cc1580772a83020df85287d6f8e26c7bd8a5f0" translate="yes" xml:space="preserve">
          <source>It doesn't matter how much space it takes up since you can't actually see any side effect (without executing code) of whatever space it would take up.</source>
          <target state="translated">それがどれだけのスペースを占有するかは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="1d798a27c2d2b93f1136b70dcfad1e9fac904cd6" translate="yes" xml:space="preserve">
          <source>It internally becomes</source>
          <target state="translated">内部的には</target>
        </trans-unit>
        <trans-unit id="2dbb06a19fcf0fb6d64e79da18f5a426b98c98ee" translate="yes" xml:space="preserve">
          <source>It is unspecified whether or not a reference requires storage.</source>
          <target state="translated">参照がストレージを必要とするかどうかは不明です。</target>
        </trans-unit>
        <trans-unit id="b288f3fae88ae371415949edcc0c9e0886821a41" translate="yes" xml:space="preserve">
          <source>It may be important to know, object type is a top-level category of the type universe in C++. Reference is also a top-level category. &lt;strong&gt;But pointer is not.&lt;/strong&gt;</source>
          <target state="translated">オブジェクトタイプは、C ++のタイプユニバースの最上位のカテゴリです。 参照も最上位のカテゴリです。 &lt;strong&gt;しかし、ポインタはそうではありません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b45412ddd0ff9c77b1d05ade69b201525767735" translate="yes" xml:space="preserve">
          <source>Language neutrality caveats</source>
          <target state="translated">言語の中立性に関する注意事項</target>
        </trans-unit>
        <trans-unit id="55dd62362caab929ec378cd05497a3ec85467b37" translate="yes" xml:space="preserve">
          <source>Look at the following statement,</source>
          <target state="translated">次の文を見てください。</target>
        </trans-unit>
        <trans-unit id="d7297eb6becdd735c4545511c38d16ada0827023" translate="yes" xml:space="preserve">
          <source>Many compilers when inlining the pointer version one will actually force a write to memory (we are taking the address explicitly).  However, they will leave the reference in a register which is more optimal.</source>
          <target state="translated">多くのコンパイラは、ポインタのバージョン1をインライン化するときに実際にメモリへの書き込みを強制します(我々は明示的にアドレスを取っている)。しかし、より最適なレジスタに参照を残します。</target>
        </trans-unit>
        <trans-unit id="ea2aee18995ab103eed08b69ba07dcb31625dabf" translate="yes" xml:space="preserve">
          <source>Maybe some metaphors will help; 
In the context of your desktop screenspace -</source>
          <target state="translated">いくつかの比喩が役に立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="ac946397b09fb907e8acce3c92c880b361a9a242" translate="yes" xml:space="preserve">
          <source>Modern compilers are getting better and better at static analysis, but it is always nice to help them out and use references.</source>
          <target state="translated">最近のコンパイラは静的解析を得意とするようになってきていますが、彼らを助けたり、リファレンスを使ったりするのはいつもいいことです。</target>
        </trans-unit>
        <trans-unit id="bf6c60a1e5c2679ef0162d45b8f206f16bcdd7d1" translate="yes" xml:space="preserve">
          <source>Move constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually there should be no qualifiers.)</source>
          <target state="translated">移動コンストラクターには、特定のタイプの&lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 参照タイプが第1パラメータータイプとして必要です。 （通常、修飾子はありません。）</target>
        </trans-unit>
        <trans-unit id="1b9630be120a68e57ca22b6ff58fa3a235507cba" translate="yes" xml:space="preserve">
          <source>My example above is short and contrived. Here's a more real-world example.</source>
          <target state="translated">上の私の例は短くて、工夫されています。ここにもっと現実的な例があります。</target>
        </trans-unit>
        <trans-unit id="56e71102cceade878735d306276129a65b04b038" translate="yes" xml:space="preserve">
          <source>Normally temporary objects such as the one created by the call to &lt;code&gt;createF(5)&lt;/code&gt; are destroyed at the end of the expression.  However, by binding that object to a reference, &lt;code&gt;ref&lt;/code&gt;, C++ will extend the lifespan of that temporary object until &lt;code&gt;ref&lt;/code&gt; goes out of scope.</source>
          <target state="translated">通常、 &lt;code&gt;createF(5)&lt;/code&gt; の呼び出しによって作成されたオブジェクトなどの一時オブジェクトは、式の最後で破棄されます。 ただし、そのオブジェクトを参照 &lt;code&gt;ref&lt;/code&gt; にバインドすることにより、C ++は &lt;code&gt;ref&lt;/code&gt; がスコープから外れるまで、その一時オブジェクトの寿命を延長します。</target>
        </trans-unit>
        <trans-unit id="b2dd5770081924d799a48921378b48818433c7bb" translate="yes" xml:space="preserve">
          <source>Note the statements above only mentions &quot;pointers&quot; and &quot;references&quot; as types. There are some interested questions about their instances (like variables). There also come too many misconceptions.</source>
          <target state="translated">上記のステートメントでは、型として「ポインタ」と「参照」にしか言及していないことに注意してください。それらのインスタンス(変数のようなもの)については興味のある質問があります。また、あまりにも多くの誤解があります。</target>
        </trans-unit>
        <trans-unit id="0112dd76dee19c15ddada9b0763e06e1cbc7faf4" translate="yes" xml:space="preserve">
          <source>Note these are &lt;em&gt;semantic&lt;/em&gt; properties.</source>
          <target state="translated">これらは&lt;em&gt;セマンティック&lt;/em&gt;プロパティであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="32c54f61399cee485b86cada14cf3ef339a2f916" translate="yes" xml:space="preserve">
          <source>Now &lt;strong&gt;regardless&lt;/strong&gt; of how a compiler handles references, it will &lt;strong&gt;always&lt;/strong&gt; have some kind of pointer under the hood, because a reference &lt;strong&gt;must&lt;/strong&gt; refer to a specific variable at a specific memory address for it to work as expected, there is no getting around this (hence the term 'reference').</source>
          <target state="translated">コンパイラが参照をどのように処理するかに&lt;strong&gt;関係なく&lt;/strong&gt; 、参照は&lt;strong&gt;常に&lt;/strong&gt;内部で何らかのポインタを持ちます。参照&lt;strong&gt;は&lt;/strong&gt; 、期待どおりに機能するために特定のメモリアドレスで特定の変数を参照する&lt;strong&gt;必要がある&lt;/strong&gt;ため、これを回避することはできません（したがって、 「参照」という用語）。</target>
        </trans-unit>
        <trans-unit id="752e698d55444e3238d56a6bc3da3af23d39ce29" translate="yes" xml:space="preserve">
          <source>Now do the same thing with pointers</source>
          <target state="translated">次に、ポインタを使って同じことをします。</target>
        </trans-unit>
        <trans-unit id="e6bdf4bf7e4af7604beaed717ed9319201ff15be" translate="yes" xml:space="preserve">
          <source>Now some explanation of real code:</source>
          <target state="translated">では、実際のコードの説明をします。</target>
        </trans-unit>
        <trans-unit id="586d3a296148dea14411f5e77a90d02cd7148035" translate="yes" xml:space="preserve">
          <source>Now there may be some cases where your compiler may not be able to know the reference when compiling, like when using an extern variable. So a reference may or may not be implemented as a pointer in the underlying code. But in the examples I gave you, it will most likely not be implemented with a pointer.</source>
          <target state="translated">外部変数を使用している場合など、コンパイル時にコンパイラが参照を知ることができない場合があるかもしれません。そのため、参照がポインタとして実装されている場合とされていない場合があります。しかし、私があげた例では、ほとんどの場合、参照はポインタで実装されていません。</target>
        </trans-unit>
        <trans-unit id="808cc104c235301ef1bc79319f8102ad43971fef" translate="yes" xml:space="preserve">
          <source>Null pointers can be used as a
sentinel value, often a cheap way to
avoid function overloading or use of
a bool.</source>
          <target state="translated">ヌルポインタはセンチネル値として使用することができ、関数のオーバーロードやboolの使用を避けるための安価な方法です。</target>
        </trans-unit>
        <trans-unit id="67ae9809624c429d324c275faf9d92d1518e204d" translate="yes" xml:space="preserve">
          <source>Object types can have top-level &lt;code&gt;cv&lt;/code&gt; qualifiers. References cannot.</source>
          <target state="translated">オブジェクト型には、最上位の &lt;code&gt;cv&lt;/code&gt; 修飾子を含めることができます。 参照はできません。</target>
        </trans-unit>
        <trans-unit id="00a1b2cda377012d0e23e72a9f8fed0898939786" translate="yes" xml:space="preserve">
          <source>Of course, barring such clever optimizations, compilers will indeed turn references into pointers when needed.</source>
          <target state="translated">もちろん、そのような巧妙な最適化を除けば、コンパイラは必要に応じて参照をポインタに変えます。</target>
        </trans-unit>
        <trans-unit id="dc07d79fb5ff33400c26bc7a53b5a0a72e7aefd6" translate="yes" xml:space="preserve">
          <source>Of course, for functions that are not inlined the pointer and reference generate the same code and it's always better to pass intrinsics by value than by reference if they are not modified and returned by the function.</source>
          <target state="translated">もちろん、インライン化されていない関数ではポインタと参照は同じコードを生成します。</target>
        </trans-unit>
        <trans-unit id="828bf90967e721e857197022098eb853d37eaa44" translate="yes" xml:space="preserve">
          <source>On the other hand, one major difference between references and pointers is that temporaries assigned to const references live until the const reference goes out of scope.</source>
          <target state="translated">一方、参照とポインタの間の大きな違いは、const参照に割り当てられたテンポラリはconst参照がスコープ外になるまで生きているということです。</target>
        </trans-unit>
        <trans-unit id="90dd91d02279fe6ccfc85544573813d23da86513" translate="yes" xml:space="preserve">
          <source>Otherwise, it is insignificant that pointers can be qualified as a specific sorts of types with references together. They simply share too few common properties besides the syntax similarity, so there is no need to put them together in most cases.</source>
          <target state="translated">そうでなければ、ポインタが一緒に参照を持つ特定の種類の型として修飾されることは取るに足らないことです。これらは単に構文の類似性以外に共通のプロパティを共有しすぎているだけで、ほとんどの場合、それらを一緒にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="c468e66383b3acff1decf7ebfe1722418b200e03" translate="yes" xml:space="preserve">
          <source>Overloaded &lt;code&gt;operator=&lt;/code&gt; as special member functions requires reference types similar to 1st parameter of copy/move constructors.</source>
          <target state="translated">特別なメンバー関数としてのオーバーロードされた &lt;code&gt;operator=&lt;/code&gt; は、コピー/移動コンストラクターの第1パラメーターと同様の参照型が必要です。</target>
        </trans-unit>
        <trans-unit id="7f2c3e2cc509718d63ded349b2aab9f792237302" translate="yes" xml:space="preserve">
          <source>Pointer can be assigned &lt;code&gt;nullptr&lt;/code&gt; directly, whereas reference cannot. If you try hard enough, and you know how, you can make the address of a reference &lt;code&gt;nullptr&lt;/code&gt;.  Likewise, if you try hard enough you can have a reference to a pointer, and then that reference can contain &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">ポインタには &lt;code&gt;nullptr&lt;/code&gt; を直接割り当てることができますが、参照には割り当てることができません。 十分に努力し、その方法を知っている場合は、参照 &lt;code&gt;nullptr&lt;/code&gt; のアドレスを作成できます。 同様に、十分に努力すると、ポインターへの参照を設定でき、その参照に &lt;code&gt;nullptr&lt;/code&gt; を含めることができます。</target>
        </trans-unit>
        <trans-unit id="d8dd03a2b7cf3f5874fc9c97bd98b107bc98bfa9" translate="yes" xml:space="preserve">
          <source>Pointers and references are mentioned together &lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;in the context of &lt;em&gt;compound type&lt;/em&gt;&lt;/a&gt;. This is basically due to the nature of the declarator syntax inherited from (and extended) C, which has no references. (Besides, there are more than one kind of declarator of references since C++ 11, while pointers are still &quot;unityped&quot;: &lt;code&gt;&amp;amp;&lt;/code&gt;+&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; vs. &lt;code&gt;*&lt;/code&gt;.) So drafting a language specific by &quot;extension&quot; with similar style of C in this context is somewhat reasonable. (I will still argue that the syntax of declarators wastes the syntactic expressiveness &lt;em&gt;a lot&lt;/em&gt;, makes both human users and implementations frustrating. Thus, all of them are not qualified to be &lt;em&gt;built-in&lt;/em&gt; in a new language design. This is a totally different topic about PL design, though.)</source>
          <target state="translated">ポインタと参照は&lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;、 &lt;em&gt;複合型の&lt;/em&gt;コンテキストで&lt;/a&gt;一緒に説明されます 。 これは基本的に、参照のないCから継承された（および拡張された）宣言子構文の性質によるものです。 （また、C ++ 11以降、参照の宣言子には複数の種類がありますが、ポインタはまだ「型付けされていません」： &lt;code&gt;&amp;amp;&lt;/code&gt; + &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; と &lt;code&gt;*&lt;/code&gt; です。）したがって、このコンテキストで同様のスタイルのCを持つ「拡張」によって特定の言語を作成します。やや合理的です。 （宣言子の構文は構文の表現力&lt;em&gt;をかなり&lt;/em&gt;浪費し、人間のユーザーと実装の両方を苛立たせていると私はまだ主張します。したがって、それらのすべては新しい言語設計に&lt;em&gt;組み込ま&lt;/em&gt;れる資格がありません。これはまったく異なるトピックですPLデザインについてですが）</target>
        </trans-unit>
        <trans-unit id="8e79db4216ca0b1682917f0312184de116274ee0" translate="yes" xml:space="preserve">
          <source>Pointers are variables; they contain the address of some other variable, or can be null. The important thing is that a pointer has a value, while a reference only has a variable that it is referencing.</source>
          <target state="translated">ポインタは変数であり、他の変数のアドレスを含んでいたり、nullであったりします。重要なことは、ポインタは値を持ちますが、参照は参照している変数のみを持つということです。</target>
        </trans-unit>
        <trans-unit id="a4c98c7b23dbb9c431cf37cec4103729a3b3df7c" translate="yes" xml:space="preserve">
          <source>Pointers can iterate over an array, you can use &lt;code&gt;++&lt;/code&gt; to go to the next item that a pointer is pointing to, and &lt;code&gt;+ 4&lt;/code&gt; to go to the 5th element.  This is no matter what size the object is that the pointer points to.</source>
          <target state="translated">ポインターは配列を反復処理できます。 &lt;code&gt;++&lt;/code&gt; を使用すると、ポインターが指している次の項目に移動でき、 &lt;code&gt;+ 4&lt;/code&gt; を使用すると5番目の要素に移動できます。 これは、ポインタが指すオブジェクトのサイズに関係ありません。</target>
        </trans-unit>
        <trans-unit id="0041b69bd78f1922ccacbca89c0bd23258263cde" translate="yes" xml:space="preserve">
          <source>Postfix &lt;code&gt;++&lt;/code&gt; requires dummy &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Postfix &lt;code&gt;++&lt;/code&gt; はダミーの &lt;code&gt;int&lt;/code&gt; を必要とします。</target>
        </trans-unit>
        <trans-unit id="9c40deca9098c33c4507f06a0277ec7d603682af" translate="yes" xml:space="preserve">
          <source>Pragmatics</source>
          <target state="translated">Pragmatics</target>
        </trans-unit>
        <trans-unit id="462242db0811f3f971e9fd491ae343b8badcc883" translate="yes" xml:space="preserve">
          <source>RAII is one of the central concepts of C++, but it interacts non-trivially with copying semantics. Passing objects by reference avoids these issues as no copying is involved. If references were not present in the language, you'd have to use pointers instead, which are more cumbersome to use, thus violating the language design principle that the best-practice solution should be easier than the alternatives.</source>
          <target state="translated">RAII は C++の中心的な概念の 1 つですが、コピーセマンティクスとの相互作用はありません。オブジェクトを参照で渡すことで、コピーが発生しないので、これらの問題を回避できます。参照が言語に存在しない場合は、代わりにポインタを使用する必要がありますが、これは使用するのがより面倒なので、最良の実践的な解決策は他の選択肢よりも簡単であるべきだという言語設計の原則に違反します。</target>
        </trans-unit>
        <trans-unit id="055cd393f567fac0ba4089ec8ff85252aac14bdb" translate="yes" xml:space="preserve">
          <source>References are allowed to refer to variables which do not have memory addresses, such as those the compiler chooses to put into registers. If you take the address of a local variable, it is very hard for the compiler to put it in a register.</source>
          <target state="translated">参照は、メモリ・アドレスを持たない変数、例えばコンパイラがレジスタに入れることを選択した変数を参照することができます。ローカル変数のアドレスを取ると、コンパイラがそれをレジスタに入れるのは非常に困難です。</target>
        </trans-unit>
        <trans-unit id="5a853555e7fde5a31207074a784b524c82ed58aa" translate="yes" xml:space="preserve">
          <source>References are designed such that it is substantially easier for the compiler to trace which reference aliases which variables. Two major features are very important: no &quot;reference arithmetic&quot; and no reassigning of references. These allow the compiler to figure out which references alias which variables at compile time.</source>
          <target state="translated">参照は、どの参照がどの変数をエイリアスしているかをコンパイラがトレースしやすくなるように設計されています。2つの主要な機能は非常に重要です:&quot;参照演算 &quot;を行わないことと、参照の再割り当てを行わないことです。これにより、コンパイラはコンパイル時にどの参照がどの変数をエイリアスしているかを把握することができます。</target>
        </trans-unit>
        <trans-unit id="e813db94099ca02f715fb0f1ba9f33611db2f553" translate="yes" xml:space="preserve">
          <source>References are very similar to pointers, but they are specifically crafted to be helpful to optimizing compilers.</source>
          <target state="translated">リファレンスはポインタに非常に似ていますが、コンパイラの最適化に役立つように特別に作られています。</target>
        </trans-unit>
        <trans-unit id="bf6fd50fdee7317a481645b6fae553557dc3cdd2" translate="yes" xml:space="preserve">
          <source>References can &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;collapse&lt;/a&gt;.</source>
          <target state="translated">参照が&lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;折りたたまれる&lt;/a&gt;可能性があります。</target>
        </trans-unit>
        <trans-unit id="9e3206ad161847bd2d29f9d31a405ed11c7d64c2" translate="yes" xml:space="preserve">
          <source>References cannot be stuffed into an array, whereas pointers can be (Mentioned by user @litb)</source>
          <target state="translated">参照は配列に詰め込むことができませんが、ポインタは可能です。</target>
        </trans-unit>
        <trans-unit id="cfca6984c06ae05fa650e3c0076a1855343215bb" translate="yes" xml:space="preserve">
          <source>References have special rules in initialization. The lifetime of variable declared as a reference type can be different to ordinary objects via extension.</source>
          <target state="translated">参照型は初期化に特別なルールがあります。参照型として宣言された変数の寿命は、拡張子を介して通常のオブジェクトとは異なるものにすることができます。</target>
        </trans-unit>
        <trans-unit id="526784942b6e34cc8eb97ec6c1946f69db4aa93c" translate="yes" xml:space="preserve">
          <source>References in C++ is quite &quot;odd&quot;, as it is essentially not first-class: &lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;they will be treated as the objects or the functions being referred to&lt;/a&gt; so they have no chance to support some first-class operations like being the left operand of &lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;the member access operator&lt;/a&gt; independently to the type of the referred object. Other languages may or may not have similar restrictions on their references.</source>
          <target state="translated">C ++での参照は、本質的にファーストクラスではないため、かなり「奇数」です。参照&lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;されるオブジェクトまたは関数として扱われる&lt;/a&gt;ため、それらの左オペランドのようなファーストクラスの操作をサポートする機会がありません。参照されるオブジェクトのタイプに依存しない&lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;メンバーアクセス演算子&lt;/a&gt; 。 他の言語は、それらの参照に同様の制限がある場合とない場合があります。</target>
        </trans-unit>
        <trans-unit id="d003206a70c36ecf7a0315ea6420395ec7e35600" translate="yes" xml:space="preserve">
          <source>References in C++ will likely not preserve the meaning across different languages. For example, references in general do not imply nonnull properties on values like they in C++, so such assumptions may not work in some other languages (and you will find counterexamples quite easily, e.g. Java, C#, ...).</source>
          <target state="translated">C++での参照は、異なる言語間での意味を保持していない可能性が高いです。たとえば、一般的な参照は C++のように値の非 null プロパティを意味しないので、このような仮定は他の言語では機能しない場合があります (Java や C#などのように、簡単に反例を見つけることができます)。</target>
        </trans-unit>
        <trans-unit id="776a07f1188f204d3f88257d0ec6a07a29887cdc" translate="yes" xml:space="preserve">
          <source>Regards,
&amp;amp;rzej</source>
          <target state="translated">Regards,
&amp;amp;rzej</target>
        </trans-unit>
        <trans-unit id="f29ff291ec91fbd3d5e03a84623244a66ed645e4" translate="yes" xml:space="preserve">
          <source>Run the program and have a look at the output and you'll understand.</source>
          <target state="translated">プログラムを実行して、出力を見てもらえればわかると思います。</target>
        </trans-unit>
        <trans-unit id="01841626b366982706bd9cb74359851e4287a00f" translate="yes" xml:space="preserve">
          <source>Simply to remember that,</source>
          <target state="translated">単純にそれを覚えておくこと。</target>
        </trans-unit>
        <trans-unit id="7ed3e2e5988e139dbdad2bddeb8aea77458c5333" translate="yes" xml:space="preserve">
          <source>So, in practice, the answer is so obvious: &lt;strong&gt;when in doubt, avoid pointers&lt;/strong&gt;. You have to use pointers only when there are very explicit reasons that nothing else is more appropriate. Except a few exceptional cases mentioned above, such choices are almost always not purely C++-specific (but likely to be language-implementation-specific). Such instances can be:</source>
          <target state="translated">したがって、実際には、答えは非常に明白です。 &lt;strong&gt;疑わしい場合は、ポインタを避けてください&lt;/strong&gt; 。 ポインターを使用する必要があるのは、他に何も適切でないという明確な理由がある場合のみです。 上記のいくつかの例外的なケースを除いて、そのような選択はほとんど常に純粋にC ++固有ではありません（ただし、言語実装固有である可能性があります）。 そのようなインスタンスには次のものがあります。</target>
        </trans-unit>
        <trans-unit id="fcf6411c0b226a9fd5b245400b86fb65e325be87" translate="yes" xml:space="preserve">
          <source>Some argue that this is such a useful feature when reading code, that pointer parameters should always be used for modifiable parameters rather than non-&lt;code&gt;const&lt;/code&gt; references, even if the function never expects a &lt;code&gt;nullptr&lt;/code&gt;. That is, those people argue that function signatures like &lt;code&gt;fn3()&lt;/code&gt; above should not be allowed. &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;Google's C++ style guidelines&lt;/a&gt; are an example of this.</source>
          <target state="translated">これはコードを読み取るときに非常に便利な機能であり、たとえ関数が &lt;code&gt;nullptr&lt;/code&gt; を期待しない場合でも、ポインターパラメーターは非 &lt;code&gt;const&lt;/code&gt; 参照ではなく常に変更可能なパラメーターに使用する必要があると主張する人もいます。 つまり、これらの人々は、上記の &lt;code&gt;fn3()&lt;/code&gt; のような関数シグネチャは許可されるべきではないと主張しています。 &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;GoogleのC ++スタイルのガイドライン&lt;/a&gt;はこの例です。</target>
        </trans-unit>
        <trans-unit id="4060e9b242b8df1a2b956d0e250e637eee184ce4" translate="yes" xml:space="preserve">
          <source>Sometimes the language rules explicitly require specific types to be used. If you want to use these features, obey the rules.</source>
          <target state="translated">時には、言語のルールで明示的に特定の型を使用するように要求されることがあります。これらの機能を使いたいのであれば、ルールに従ってください。</target>
        </trans-unit>
        <trans-unit id="5fc11392b922636b6dc568f4ab0eb7cfb144157b" translate="yes" xml:space="preserve">
          <source>Special rules on &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; parameters (as the &quot;forwarding references&quot;) based on reference collapsing during template parameter deduction allow &lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;&quot;perfect forwarding&quot;&lt;/a&gt; of parameters.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; パラメーターに関する特別なルール（「転送参照」として）は、テンプレートパラメーターの演繹中に参照を折りたたむことに基づいており、パラメーターの&lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;「完全な転送」&lt;/a&gt;が可能です。</target>
        </trans-unit>
        <trans-unit id="e7e7e6a0d10546a8f3514b41d4f9f797c475d3c2" translate="yes" xml:space="preserve">
          <source>Specific language-interoperation routines require pointers, like &lt;code&gt;operator new&lt;/code&gt;. (However, &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;void*&lt;/code&gt; is still quite different and safer compared to the ordinary object pointers because it rules out unexpected pointer arithmetics unless you are relying on some non conforming extension on &lt;code&gt;void*&lt;/code&gt; like GNU's.)</source>
          <target state="translated">特定の言語相互運用ルーチンには、 &lt;code&gt;operator new&lt;/code&gt; などのポインタが必要です。 （ただし、 &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;void*&lt;/code&gt; は、GNUのような &lt;code&gt;void*&lt;/code&gt; 準拠していない拡張機能に依存しない限り、予期しないポインター計算を除外するため、通常のオブジェクトポインターと比較して、まだかなり異なり、安全です。）</target>
        </trans-unit>
        <trans-unit id="918eaf9f6cafcfdb9b382a8fa017353bbc7f79e9" translate="yes" xml:space="preserve">
          <source>Specific overloads of operators require reference or non reference types. For example:</source>
          <target state="translated">演算子の特定のオーバーロードは、参照型または非参照型を必要とします。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="9e092dda4f0e27d0c7686ddd00272079e678b6e6" translate="yes" xml:space="preserve">
          <source>Storage</source>
          <target state="translated">Storage</target>
        </trans-unit>
        <trans-unit id="f6ceae4e1810d086bda09a8ac74e9e1fae98d4f4" translate="yes" xml:space="preserve">
          <source>Syntactic sugar</source>
          <target state="translated">構文糖</target>
        </trans-unit>
        <trans-unit id="178786d5b288287aa798248ecdf5fc27cc41e4ba" translate="yes" xml:space="preserve">
          <source>Technically this is an &lt;strong&gt;invalid reference&lt;/strong&gt;, not a null reference.  C++ doesn't support null references as a concept as you might find in other languages.  There are other kinds of invalid references as well. &lt;em&gt;Any&lt;/em&gt; invalid reference raises the spectre of &lt;strong&gt;undefined behavior&lt;/strong&gt;, just as using an invalid pointer would.</source>
          <target state="translated">技術的には、これは&lt;strong&gt;無効な参照&lt;/strong&gt;であり、null参照ではありません。 C ++は、他の言語で見られるような概念としてのnull参照をサポートしていません。 他の種類の無効な参照もあります。 無効な参照を使用すると、無効なポインタを使用した場合と同様に、無効な参照によって&lt;strong&gt;未定義の動作&lt;/strong&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="19d85e5f25c953dc491251669b1a186b567d0b30" translate="yes" xml:space="preserve">
          <source>Technically, this is plain wrong. References are not syntactic sugar of any other features in C++, because they cannot be exactly replaced by other features without any semantic differences.</source>
          <target state="translated">技術的には、これは明らかに間違っています。参照は、C++の他の機能の構文的な糖質ではありません。</target>
        </trans-unit>
        <trans-unit id="e1271990b0fbf017a0baa7180d4771ca7fef2cb9" translate="yes" xml:space="preserve">
          <source>Templates that cover both &lt;code&gt;T&amp;amp;&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are even more common.</source>
          <target state="translated">&lt;code&gt;T&amp;amp;&lt;/code&gt; と &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; 両方をカバーするテンプレートはさらに一般的です。</target>
        </trans-unit>
        <trans-unit id="cc2d982b9a391ad561f42bfa61ab554d2658e9c3" translate="yes" xml:space="preserve">
          <source>The actual error is in the dereferencing of the NULL pointer, prior to the assignment to a reference.  But I'm not aware of any compilers that will generate any errors on that condition - the error propagates to a point further along in the code. That's what makes this problem so insidious. Most of the time, if you dereference a NULL pointer, you crash right at that spot and it doesn't take much debugging to figure it out.</source>
          <target state="translated">実際のエラーは、参照に代入される前のNULLポインタの参照解除にあります。しかし、私はその条件でエラーを発生させるコンパイラを知りません。これがこの問題を陰湿なものにしています。ほとんどの場合、NULLポインタを参照解除すると、その場所でクラッシュしてしまいます。</target>
        </trans-unit>
        <trans-unit id="36dcbb0fd485c966a6a8597e14838d2a77d340f3" translate="yes" xml:space="preserve">
          <source>The behavior is the same; only now it is much harder to prove that maybeModify does not ever modify array[1], because we already gave it a pointer; the cat is out of the bag. Now it has to do the much more difficult proof: a static analysis of maybeModify to prove it never writes to &amp;amp;x + 1. It also has to prove that it never saves off a pointer that can refer to array[0], which is just as tricky.</source>
          <target state="translated">動作は同じです。 たった今、ポインタを既に与えているので、maybeModifyがarray [1]を変更しないことを証明することははるかに困難です。 猫は袋から出ています。 今では、はるかに困難な証明を行う必要があります。maybeModifyの静的分析で、＆x + 1に書き込まれないことを証明する必要があります。また、array [0]を参照できるポインターを保存しないことを証明する必要があります。トリッキー。</target>
        </trans-unit>
        <trans-unit id="55c25474b6bbe811c3fff5d37fe3196ddf92b362" translate="yes" xml:space="preserve">
          <source>The default flavor uses the 'bind const reference to a temporary' aspect of references.</source>
          <target state="translated">デフォルトのフレーバーでは、参照の 'bind const reference to a temporary' というアスペクトを使用しています。</target>
        </trans-unit>
        <trans-unit id="eeffd6f2cd40ebbc994170a79516a76d384f1862" translate="yes" xml:space="preserve">
          <source>The difference is that non-constant pointer variable(not to be confused with a pointer to constant) may be changed at some time during program execution, requires pointer semantics to be used(&amp;amp;,*) operators, while references can be set upon initialization only(that's why you can set them in constructor initializer list only, but not somehow else) and use ordinary value accessing semantics.  Basically references were introduced to allow support for operators overloading as I had read in some very old book. As somebody stated in this thread - pointer can be set to 0 or whatever value you want. 0(NULL, nullptr) means that the pointer is initialized with nothing. It is an error to dereference null pointer. But actually the pointer may contain a value that doesn't point to some correct memory location. References in their turn try not to allow a user to initialize a reference to something that cannot be referenced due to the fact that you always provide rvalue of correct type to it. Although there are a lot of ways to make reference variable be initialized to a wrong memory location - it is better for you not to dig this deep into details. On machine level both pointer and reference work uniformly - via pointers. Let's say in essential references are syntactic sugar. rvalue references are different to this - they are naturally stack/heap objects.</source>
          <target state="translated">違いは、非定数ポインター変数（定数へのポインターと混同しないでください）は、プログラムの実行中に変更される可能性があり、ポインターのセマンティクスを使用する必要がある（＆、*）演算子ですが、参照は初期化時に設定できます。のみ（だから、コンストラクタ初期化子リストでのみ設定できますが、他の方法では設定できません）、セマンティクスにアクセスする通常の値を使用します。 基本的に参照は、いくつかの非常に古い本を読んだときのように、オペレーターのオーバーロードをサポートできるように導入されました。 誰かがこのスレッドで述べたように、ポインターは0または任意の値に設定できます。 0（NULL、nullptr）は、ポインターが何も指定されずに初期化されることを意味します。 nullポインタを逆参照するとエラーになります。 ただし、実際には、ポインタには、正しいメモリ位置を指し示さない値が含まれている場合があります。 次に、参照では、常に正しいタイプの右辺値を提供するため、参照できないものへの参照をユーザーが初期化できないようにします。 参照変数を間違ったメモリ位置に初期化する方法はたくさんありますが、これを詳細に掘り下げない方が良いでしょう。 マシンレベルでは、ポインターを介して、ポインターと参照の両方が均一に機能します。 本質的な参照では、構文糖としましょう。 右辺値参照はこれとは異なります-それらは当然スタック/ヒープオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="21383718ed633934236239e24d6297c4ae1335ed" translate="yes" xml:space="preserve">
          <source>The differences of the top-level categories can already reveal many concrete differences not tied to pointers directly:</source>
          <target state="translated">トップレベルのカテゴリの違いは、すでにポインタに直接結びつかない多くの具体的な違いを明らかにすることができます。</target>
        </trans-unit>
        <trans-unit id="819bfb5a2d2e6000333b076e5df05cfd8d7b2a13" translate="yes" xml:space="preserve">
          <source>The direct answer</source>
          <target state="translated">直接的な答え</target>
        </trans-unit>
        <trans-unit id="f88d1a0da318f485205557f1a4a4b91d6c82b7a4" translate="yes" xml:space="preserve">
          <source>The misconceptions</source>
          <target state="translated">誤解されていること</target>
        </trans-unit>
        <trans-unit id="7d2603e75f0c55eb2703c92e74f015d2c67447b5" translate="yes" xml:space="preserve">
          <source>The only exceptions cannot be worked around in the current language:</source>
          <target state="translated">唯一の例外は、現在の言語では回避できません。</target>
        </trans-unit>
        <trans-unit id="122da8393156782721cf3629f6cd6821668afecf" translate="yes" xml:space="preserve">
          <source>The only major rule that's important to remember with references is that they must be defined at the time of declaration (with the exception of a reference in a header, in that case it must be defined in the constructor, after the object it's contained in is constructed it's too late to define it).</source>
          <target state="translated">参照について覚えておくべき重要な唯一の大きなルールは、それらが宣言時に定義されなければならないということです (ヘッダ内の参照を除いて、その場合はコンストラクタで定義しなければなりません。)</target>
        </trans-unit>
        <trans-unit id="418b62106b171f039b854dbd9df45e23828dfba0" translate="yes" xml:space="preserve">
          <source>The proper way to stay out of trouble is to avoid dereferencing a NULL pointer to create a reference. Here's an automated way to accomplish this.</source>
          <target state="translated">トラブルに巻き込まれないための適切な方法は、参照を作成するためにNULLポインタを参照解除しないようにすることです。これを自動化する方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="5873330b5c7abf6ca602c30f272bd7c50e0cbb63" translate="yes" xml:space="preserve">
          <source>The statement above is simply wrong. To avoid such misconceptions, look at the ISO C++ rules instead:</source>
          <target state="translated">上記の記述は単純に間違っています。このような誤解を避けるために、代わりにISO C++のルールを見てください。</target>
        </trans-unit>
        <trans-unit id="163a6b49bbef328a902a3d1fe72ca7563153d744" translate="yes" xml:space="preserve">
          <source>There can still be some common properties among references in different programming languages in general, but let's leave it for some other questions in SO.</source>
          <target state="translated">一般的には、異なるプログラミング言語の参照の間にはまだいくつかの共通の特性があるかもしれませんが、SOの他のいくつかの質問のためにそれを残しておきましょう。</target>
        </trans-unit>
        <trans-unit id="e317f9f1b18599441d13052e85296dbd4035b47d" translate="yes" xml:space="preserve">
          <source>There is a semantic difference that may appear esoteric if you are not familiar with studying computer languages in an abstract or even academic fashion.</source>
          <target state="translated">コンピュータ言語を抽象的に、あるいは学術的に勉強することに慣れていないと、難解に見えるかもしれない意味的な違いがあります。</target>
        </trans-unit>
        <trans-unit id="49c3ed839f4ba592814145e1ee7dccb652641c97" translate="yes" xml:space="preserve">
          <source>There is a very important non-technical difference between pointers and references: An argument passed to a function by pointer is much more visible than an argument passed to a function by non-const reference. For example:</source>
          <target state="translated">ポインタと参照の間には非常に重要な非技術的な違いがあります。ポインタによって関数に渡される引数は、const ではない参照によって関数に渡される引数よりもはるかに目に見えるものです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="44e93f1f5f0ace9a170cb0b7222ca3b3580dffcb" translate="yes" xml:space="preserve">
          <source>There is one fundamental difference between pointers and references that I didn't see anyone had mentioned: references enable pass-by-reference semantics in function arguments. Pointers, although it is not visible at first do not: they only provide pass-by-value semantics. This has been very nicely described in &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">ポインターと参照には、誰も言及しなかった1つの基本的な違いがあります。参照は、関数の引数で参照渡しのセマンティクスを有効にします。 ポインターは、最初は見えませんが、値渡しのセマンティクスを提供するだけです。 これは、 &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;この記事&lt;/a&gt;で非常にうまく説明されています 。</target>
        </trans-unit>
        <trans-unit id="5066abc2ae8da58f9f9bb296820d74fa0f7a48b1" translate="yes" xml:space="preserve">
          <source>Therefore a reference IS a pointer under the hood, they both are just storing a memory address, where the address is pointing to is irrelevant, what do you think would happen if I called std::cout &amp;lt;&amp;lt; str_ref; AFTER calling delete &amp;amp;str_ref? Well, obviously it compiles fine, but causes a segmentation fault at runtime because it's no longer pointing at a valid variable, we essentially have a broken reference that still exists (until it falls out of scope), but is useless.</source>
          <target state="translated">したがって、参照は内部ではポインタであり、どちらもメモリアドレスを格納しているだけで、アドレスが指している場所は関係ありません。std:: cout &amp;lt;&amp;lt; str_ref;を呼び出した場合、どうなると思いますか。 delete＆str_refを呼び出した後？ まあ、明らかにコンパイルは正常ですが、有効な変数を指していないため、実行時にセグメンテーション違反が発生し、（スコープから外れるまで）存在する壊れた参照が基本的に存在しますが、役に立ちません。</target>
        </trans-unit>
        <trans-unit id="94289fe5436213192f08bec365e448fa20dc244c" translate="yes" xml:space="preserve">
          <source>These points empower a considerable part of C++ and the standard library so this is quite a major property of references.</source>
          <target state="translated">これらのポイントは、C++と標準ライブラリのかなりの部分に力を与えているので、これは参照のかなり大きなプロパティです。</target>
        </trans-unit>
        <trans-unit id="6a0c459929817549c904c8a94991b55621527e3f" translate="yes" xml:space="preserve">
          <source>This assignment changes ival, the value referenced by ri, and not the reference itself. After the assignment, the two references still refer to their original objects, and the value of those objects is now the same as well.</source>
          <target state="translated">この代入によって、riによって参照される値であるivalが変更され、参照自体は変更されません。代入後も、2つの参照は元のオブジェクトを参照しており、それらのオブジェクトの値も同じになります。</target>
        </trans-unit>
        <trans-unit id="bc577f672dad3e6a3a69c44737f3aacd3dd1eb12" translate="yes" xml:space="preserve">
          <source>This is based on the &lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;tutorial&lt;/a&gt;. What is written makes it more clear:</source>
          <target state="translated">これは&lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;チュートリアルに&lt;/a&gt;基づいています。 書かれていることはそれをより明確にします：</target>
        </trans-unit>
        <trans-unit id="3ab66ed104cf4962c17c327aa4d19f6a70663d93" translate="yes" xml:space="preserve">
          <source>This is the language mechanism that allows ScopeGuard to work.</source>
          <target state="translated">これがScopeGuardを動作させるための言語の仕組みです。</target>
        </trans-unit>
        <trans-unit id="5c9287077fd3860634cb823000e3c46b1b0d2646" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;const&amp;amp;&lt;/code&gt; safer for use in argument lists and so forth.</source>
          <target state="translated">これにより、 &lt;code&gt;const&amp;amp;&lt;/code&gt; は引数リストなどで使用する場合により安全になります。</target>
        </trans-unit>
        <trans-unit id="d92fc23c843fd5c20781bced348b9700ad555c98" translate="yes" xml:space="preserve">
          <source>This program might help in comprehending the answer of the question. This is a simple program of a reference &quot;j&quot; and a pointer &quot;ptr&quot; pointing to variable &quot;x&quot;.</source>
          <target state="translated">このプログラムは、質問の答えを理解するのに役立つかもしれません。これは、参照 &quot;j &quot;と変数 &quot;x &quot;を指すポインタ &quot;ptr &quot;の単純なプログラムです。</target>
        </trans-unit>
        <trans-unit id="f6a17a077fe021118aa2ad5ab8e800b9c24900ac" translate="yes" xml:space="preserve">
          <source>This should permit the compiler to do more optimization on a reference.</source>
          <target state="translated">これにより、コンパイラはリファレンス上でより多くの最適化を行うことができるようになります。</target>
        </trans-unit>
        <trans-unit id="2f3d837dc2b38c729da0192bc97e045c3a5109ca" translate="yes" xml:space="preserve">
          <source>To make such an optimization, it needs to prove that nothing can change array[1] during the call. This is rather easy to do. i is never less than 2, so array[i] can never refer to array[1]. maybeModify() is given a0 as a reference (aliasing array[0]). Because there is no &quot;reference&quot; arithmetic, the compiler just has to prove that maybeModify never gets the address of x, and it has proven that nothing changes array[1].</source>
          <target state="translated">このような最適化を行うためには,呼び出し中に何もarray[1]を変更できないことを証明する必要があります.これは簡単です。 i は決して 2 より小さい値ではないので、array[i]は array[1]を参照することはできません。参照」演算がないので、コンパイラは maybeModify が x のアドレスを取得しないことを証明するだけで、array[1]は何も変更されないことを証明しています。</target>
        </trans-unit>
        <trans-unit id="887be10c65852c56ff940b439c392da3426fe46c" translate="yes" xml:space="preserve">
          <source>Unlike the pointers, references are &lt;strong&gt;syntactically equivalent&lt;/strong&gt; to the object they refer to, i.e. any operation that can be applied to an object works for a reference, and with the exact same syntax (the exception is of course the initialization).</source>
          <target state="translated">ポインタとは異なり、参照は参照先のオブジェクトと&lt;strong&gt;構文的に同等です&lt;/strong&gt; 。つまり、オブジェクトに適用できるすべての操作は、参照と同じ構文で機能します（例外はもちろん初期化です）。</target>
        </trans-unit>
        <trans-unit id="82af8ce5dd45a624f7e3a05f611fa27d013254ef" translate="yes" xml:space="preserve">
          <source>Update: now that I think about it some more, there is an important difference.</source>
          <target state="translated">更新:今、もう少し考えてみると、重要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="255286b845d43f2eb541ea059727b48d0df67a81" translate="yes" xml:space="preserve">
          <source>Variable of object types do occupy storage as per &lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;the abstract machine&lt;/a&gt; semantics. Reference do not necessary occupy storage (see the section about misconceptions below for details).</source>
          <target state="translated">オブジェクトタイプの変数は&lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;、抽象マシン&lt;/a&gt;セマンティクスに従ってストレージを占有します。 参照はストレージを占有する必要はありません（詳細については、以下の誤解に関するセクションを参照してください）。</target>
        </trans-unit>
        <trans-unit id="e955ffcb762ae563797df04ca22c14d80f8aa171" translate="yes" xml:space="preserve">
          <source>Visit the following for more information about reference to pointer:</source>
          <target state="translated">ポインターへの参照については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="95919816eaf3c9d568884c2a1f7a85a8422fc08c" translate="yes" xml:space="preserve">
          <source>What are the differences between a pointer variable and a reference variable in C++</source>
          <target state="translated">C++におけるポインタ変数と参照変数の違いは何ですか?</target>
        </trans-unit>
        <trans-unit id="ebf7dfac9cd8041f70cebb7841fd92ee7068ad0e" translate="yes" xml:space="preserve">
          <source>What is a pointer in C++? Some specific instance of type that &lt;strong&gt;is an object type&lt;/strong&gt;.</source>
          <target state="translated">C ++のポインターとは何ですか？ &lt;strong&gt;オブジェクトタイプ&lt;/strong&gt;であるタイプの特定のインスタンス。</target>
        </trans-unit>
        <trans-unit id="f1713708129e2693fa553b3ca19fb86a7a27996c" translate="yes" xml:space="preserve">
          <source>What is a reference in C++? Some specific instance of type that &lt;strong&gt;is not an object type&lt;/strong&gt;.</source>
          <target state="translated">C ++のリファレンスとは何ですか？ &lt;strong&gt;オブジェクトタイプ&lt;/strong&gt;で&lt;strong&gt;はない&lt;/strong&gt;タイプの特定のインスタンス。</target>
        </trans-unit>
        <trans-unit id="b27d4d26ba775faaca91cdf7c85e8f345955ab10" translate="yes" xml:space="preserve">
          <source>What's a C++ reference (&lt;em&gt;for C programmers&lt;/em&gt;)</source>
          <target state="translated">C ++リファレンスとは（ &lt;em&gt;Cプログラマー向け&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="f4957cb2344c8ba91faaeb20076eeeb6b30d45f2" translate="yes" xml:space="preserve">
          <source>What's more, as we can refer to almost any pointer tutorial, a pointer is an object that is supported by pointer arithmetic which makes pointer similar to an array.</source>
          <target state="translated">さらに、私たちはほぼすべてのポインタのチュートリアルを参照することができますように、ポインタは、ポインタを配列に似たようなものにするポインタ演算によってサポートされているオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="ec620abb83732edc34ab0a338ecb3e522947253f" translate="yes" xml:space="preserve">
          <source>When calling a function, the compiler usually generates memory spaces for the arguments to be copied to. The function signature defines the spaces that should be created and gives the name that should be used for these spaces. Declaring a parameter as a reference just tells the compiler to use the input variable memory space instead of allocating a new memory space during the method call. It may seem strange to say that your function will be directly manipulating a variable declared in the calling scope, but remember that when executing compiled code, there is no more scope; there is just plain flat memory, and your function code could manipulate any variables.</source>
          <target state="translated">関数を呼び出すとき、コンパイラは通常、引数がコピーされるメモリ・スペースを生成します。関数シグネチャは、生成されるスペースを定義し、これらのスペースに使用される名前を指定します。パラメータを参照として宣言することは、メソッド呼び出し時に新しいメモリ空間を確保する代わりに、入力変数のメモリ空間を使用するようにコンパイラに指示するだけです。しかし、コンパイルされたコードを実行するときには、スコープはもう存在しないことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="d4c1912265bdef87e12cb7b1321e31b984533bfe" translate="yes" xml:space="preserve">
          <source>When you are implementing smart pointers above, you may have to deal with raw pointers.</source>
          <target state="translated">上記のスマートポインタを実装する場合、生ポインタを扱う必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="1dfec36a318fd0d200d4cdbe5653e6d388ef8b86" translate="yes" xml:space="preserve">
          <source>When you create a reference, you only tell the compiler that you assign another name to the pointer variable; that's why references cannot &quot;point to null&quot;, because a variable cannot be, and not be.</source>
          <target state="translated">参照を作成するときは、ポインタ変数に別の名前を代入したことをコンパイラに伝えるだけです。</target>
        </trans-unit>
        <trans-unit id="c777e0e0107a7f50f79668993af249ac372a560e" translate="yes" xml:space="preserve">
          <source>Which outputs this:</source>
          <target state="translated">これを出力する</target>
        </trans-unit>
        <trans-unit id="c5cc6c3d8c26b226ed34902de7cac9e3a05e8f30" translate="yes" xml:space="preserve">
          <source>While both references and pointers are used to indirectly access another value, there are two important differences between references and pointers. The first is that a reference always refers to an object: It is an error to define a reference without initializing it. The behavior of assignment is the second important difference: Assigning to a reference changes the object to which the reference is bound; it does not rebind the reference to another object. Once initialized, a reference always refers to the same underlying object.</source>
          <target state="translated">参照とポインタはどちらも間接的に別の値にアクセスするために使用されますが、参照とポインタの間には2つの重要な違いがあります。1つ目は、参照は常にオブジェクトを参照するということです。初期化せずに参照を定義するとエラーになります。2 番目の重要な違いは、代入の動作です。参照への代入は、参照がバインドされているオブジェクトを変更します。一度初期化されると、参照は常に同じ基礎となるオブジェクトを参照します。</target>
        </trans-unit>
        <trans-unit id="33026a6390ada498b7595f79ab2136f07ff3040a" translate="yes" xml:space="preserve">
          <source>While this may appear superficial, I believe this property is crucial for a number of C++ features, for example:</source>
          <target state="translated">これは表面的に見えるかもしれませんが、私はこのプロパティは、例えば、多くのC++の機能にとって非常に重要だと考えています。</target>
        </trans-unit>
        <trans-unit id="a48d4180c32fc6ba76e32c1184f3989050537522" translate="yes" xml:space="preserve">
          <source>Why I consider C++ references useful</source>
          <target state="translated">私がC++リファレンスを便利だと思う理由</target>
        </trans-unit>
        <trans-unit id="a139f82cb75f5fa1d088932ad6ca62c1a9ed365b" translate="yes" xml:space="preserve">
          <source>You can do arithmetic on a pointer.
For example, &lt;code&gt;p += offset;&lt;/code&gt;</source>
          <target state="translated">ポインタに対して演算を行うことができます。 たとえば、 &lt;code&gt;p += offset;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34780a25d9c2fa6caeb26ac54a01416129ecb662" translate="yes" xml:space="preserve">
          <source>You can have pointers to pointers to pointers offering extra levels of indirection.  Whereas references only offer one level of indirection.</source>
          <target state="translated">ポインターからポインターへのポインタは、追加のレベルのインダイレクト性を提供します。一方、参照は1つのレベルしか提供しません。</target>
        </trans-unit>
        <trans-unit id="ca281bbb0f05d2038a489cb7276fce90296f6044" translate="yes" xml:space="preserve">
          <source>You forgot the most important part:</source>
          <target state="translated">一番大事なところを忘れている。</target>
        </trans-unit>
        <trans-unit id="5b379fd4bb44eb684d6e0614512cecb190c0230a" translate="yes" xml:space="preserve">
          <source>You have to avoid symbol bloat in some extreme cases.</source>
          <target state="translated">極端な話、シンボルの肥大化は避けなければなりません。</target>
        </trans-unit>
        <trans-unit id="94dc5492065b8158897a90145f93ab59e74f01ca" translate="yes" xml:space="preserve">
          <source>You have to improve efficiency of the translation (compilation &amp;amp; linking) in some extreme cases.</source>
          <target state="translated">極端な場合には、翻訳の効率（コンパイルとリンク）を改善する必要があります。</target>
        </trans-unit>
        <trans-unit id="560512056d46b11c084b62f89a3e5fff348a21e2" translate="yes" xml:space="preserve">
          <source>You have to interoperate at runtime with different language implementations (including various assemblies, language runtime and FFI of some high-level client languages) based on assumptions of specific implementations.</source>
          <target state="translated">特定の実装を想定して、異なる言語実装(様々なアセンブリ、言語実行時、いくつかの高レベルクライアント言語のFFIを含む)と実行時に相互運用する必要があります。</target>
        </trans-unit>
        <trans-unit id="92de6dbe192f694e5996d57ccfe447310dfd3ab8" translate="yes" xml:space="preserve">
          <source>You have to meet the ABI requirements of specific C++ implementations.</source>
          <target state="translated">特定のC++実装のABI要件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="184df4e9e98867001ef0b20404d00c507b584e37" translate="yes" xml:space="preserve">
          <source>You have to serve to old-style (C) APIs.</source>
          <target state="translated">オールドスタイル(C)のAPIにサーブする必要があります。</target>
        </trans-unit>
        <trans-unit id="d5c7ab9829b48d10733475f6a32872b8d1dde9fe" translate="yes" xml:space="preserve">
          <source>in simple words, we can say a reference is an alternative name for a variable whereas,
a pointer is a variable that holds the address of another variable.
e.g.</source>
          <target state="translated">簡単に言えば、参照は変数の別名であるのに対し、ポインタは別の変数のアドレスを保持する変数です。</target>
        </trans-unit>
        <trans-unit id="344723f5f4518fc02c77a821b777b5e5ef5b14c7" translate="yes" xml:space="preserve">
          <source>member-access with pointers uses &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">ポインタを使用したメンバーアクセスは次の用途に使用します &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a520836c5bc91e48d3c9612930f910ee19298599" translate="yes" xml:space="preserve">
          <source>member-access with references uses &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">参照によるメンバーアクセスでは、を使用し &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6cd4d114dbfaf6a41f6a22c17b7940a2cd45fe06" translate="yes" xml:space="preserve">
          <source>will print:</source>
          <target state="translated">が印刷されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
