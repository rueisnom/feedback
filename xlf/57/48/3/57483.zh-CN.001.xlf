<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/57483">
    <body>
      <group id="57483">
        <trans-unit id="366a1392d254b91c2979dbb347d6a6006020e4a8" translate="yes" xml:space="preserve">
          <source>(A side note: the question may be significant earlier than any &quot;C-like&quot; languages are involved, like &lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;ALGOL 68 vs. PL/I&lt;/a&gt;.)</source>
          <target state="translated">（附带说明：这个问题可能比涉及任何&amp;ldquo; C样&amp;rdquo;语言（例如&lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;ALGOL 68 vs. PL / I&lt;/a&gt; ）的时间还早。</target>
        </trans-unit>
        <trans-unit id="3c2cc5a14dd2d409d181bc8d16bec43175ff2ec5" translate="yes" xml:space="preserve">
          <source>(Similarly, &lt;em&gt;lambda-expression&lt;/em&gt;s are &lt;em&gt;not&lt;/em&gt; syntactic sugar of any other features in C++ because it cannot be precisely simulated with &quot;unspecified&quot; properties like &lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;the declaration order of the captured variables&lt;/a&gt;, which may be important because the initialization order of such variables can be significant.)</source>
          <target state="translated">（类似地， &lt;em&gt;lambda-expression&lt;/em&gt; &lt;em&gt;并不是&lt;/em&gt; C ++中任何其他功能的语法糖，因为无法使用&amp;ldquo;未指定&amp;rdquo;属性（如&lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;捕获变量的声明顺序）&lt;/a&gt;精确模拟&lt;em&gt;lambda-expression&lt;/em&gt; ，这很重要，因为此类变量的初始化顺序可以是重大。）</target>
        </trans-unit>
        <trans-unit id="1f3d6284e82153785e1a110247b2169240f95d81" translate="yes" xml:space="preserve">
          <source>(or &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; which still relies on an implicit cast
to &lt;code&gt;T&amp;amp;&lt;/code&gt;)</source>
          <target state="translated">（或 &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; 仍然依赖于对 &lt;code&gt;T&amp;amp;&lt;/code&gt; 的隐式强制转换）</target>
        </trans-unit>
        <trans-unit id="eb9fd6a3244bc886192add4286c3f4e955b01e2c" translate="yes" xml:space="preserve">
          <source>... An object occupies a region of storage in its period of construction, throughout its lifetime, and in its period of destruction. ...</source>
          <target state="translated">...一件物品在其建造期间、整个生命周期和销毁期间都占据着一个储存区域。...</target>
        </trans-unit>
        <trans-unit id="aedfef1b56582c6d5ac761f02dc136e601d184b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias_Tom&lt;/code&gt; can be understood as an &lt;code&gt;alias of a variable&lt;/code&gt; (different with &lt;code&gt;typedef&lt;/code&gt;, which is &lt;code&gt;alias of a type&lt;/code&gt;) &lt;code&gt;Tom&lt;/code&gt;. It is also OK to forget the terminology of such statement is to create a reference of &lt;code&gt;Tom&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alias_Tom&lt;/code&gt; 可以理解为 &lt;code&gt;alias of a variable&lt;/code&gt; 的别名 （与 &lt;code&gt;typedef&lt;/code&gt; 不同，后者是 &lt;code&gt;alias of a type&lt;/code&gt; ） &lt;code&gt;Tom&lt;/code&gt; 。 也可以忘记这样的声明的术语是创建 &lt;code&gt;Tom&lt;/code&gt; 的参考。</target>
        </trans-unit>
        <trans-unit id="a5a7b84169fee1ce093f438b076f5fe4d63635e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo.bar&lt;/code&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; in the same way that &lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs&lt;/a&gt; :-)</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; &lt;em&gt;明显&lt;/em&gt;优于 &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; ，就像&lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt; &lt;em&gt;明显&lt;/em&gt;优于&lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs一样&lt;/a&gt; ：-)</target>
        </trans-unit>
        <trans-unit id="53a62ec44b159bf24f77f722d3f80606a21a3355" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C++: Reference to Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C ++：对指针的引用&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8503c60ec396a2706a5881136f438f315e36942e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;Pointer-to-Pointer and Reference-to-Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;指针到指针和引用到指针&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="48e4529752dcdcff6551309a435706e66b4247e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Copy constructors&lt;/em&gt;. Syntactically it makes sense to pass objects to copy constructors, and not pointers to objects. But there is just no way for a copy constructor to take an object by value - it would result in a recursive call to the same copy constructor. This leaves references as the only option here.</source>
          <target state="translated">&lt;em&gt;复制构造函数&lt;/em&gt; 。 从语法上讲，将对象传递给复制构造函数，而不是指向对象的指针是有意义的。 但是，复制构造函数无法按值获取对象-它将导致对同一复制构造函数的递归调用。 这将引用作为唯一的选择。</target>
        </trans-unit>
        <trans-unit id="5429e39b4353f38912f315f0cc3b02247f3caa2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lvalues&lt;/em&gt;. Consider the statement &lt;code&gt;str[0] = 'X';&lt;/code&gt; Without references it would only work for c-strings (&lt;code&gt;char* str&lt;/code&gt;). Returning the character by reference allows user-defined classes to have the same notation.</source>
          <target state="translated">&lt;em&gt;左值&lt;/em&gt; 考虑语句 &lt;code&gt;str[0] = 'X';&lt;/code&gt; 如果没有引用，则仅适用于c字符串（ &lt;code&gt;char* str&lt;/code&gt; ）。 通过引用返回字符允许用户定义的类具有相同的符号。</target>
        </trans-unit>
        <trans-unit id="a6bbf825dc87806d5d7ecc42e1a033d722c63bd0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Operator overloads&lt;/em&gt;. With references it is possible to introduce indirection to an operator call - say, &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; while retaining the same infix notation. This also works for regular overloaded functions.</source>
          <target state="translated">&lt;em&gt;操作员重载&lt;/em&gt; 。 通过引用，可以向操作员调用引入间接性-例如， &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; 同时保留相同的中缀表示法。 这也适用于常规的重载函数。</target>
        </trans-unit>
        <trans-unit id="59d32a7fbc66b86330c68b00f7b2998e9416fddd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Templates&lt;/em&gt;. Since template parameters are duck-typed, syntactic properties of a type is all that matters, so often the same template can be used with both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;模板&lt;/em&gt; 。 由于模板参数是鸭子类型的，因此所有类型的语法属性都很重要，因此通常同一模板可以与 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;T&amp;amp;&lt;/code&gt; 一起使用 。</target>
        </trans-unit>
        <trans-unit id="a5cd9611e4f3bbd50027970fffa4f1f1bd8dbc48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;So, a pointer and a reference both use the same amount of memory.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;因此，指针和引用都使用相同数量的内存。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6b3894bff8b5c460864e665b4235fd4094d8df4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remember, my examples above are just that, examples demonstrating what a reference is, you would never want to use a reference in those ways! For proper usage of a reference there are plenty of answers on here already that hit the nail on the head&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;请记住，我上面的示例仅仅是说明引用是什么的示例，您永远都不想以这种方式使用引用！&lt;/strong&gt; &lt;strong&gt;为了正确使用参考，这里已经有很多答案，直指头绪&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6654cb2acb8b91a57f09603862f530ef72caa5eb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reference&lt;/em&gt; can be thought of as a &lt;em&gt;constant pointer&lt;/em&gt; (not to be confused with a pointer to a constant value!) with automatic indirection, ie the compiler will apply the &lt;code&gt;*&lt;/code&gt; operator for you.</source>
          <target state="translated">可以将&lt;em&gt;引用&lt;/em&gt;视为具有自动间接&lt;em&gt;指向&lt;/em&gt;的&lt;em&gt;常量指针&lt;/em&gt; （不要与指向常量值的指针混淆！），即编译器将为您应用 &lt;code&gt;*&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="36e44be1b0929668f83744e378c80d1a24783473" translate="yes" xml:space="preserve">
          <source>A compiler keeps &quot;references&quot; to variables, associating a name with a memory address; that's its job to translate any variable name to a memory address when compiling.</source>
          <target state="translated">编译器会保留对变量的 &quot;引用&quot;,将变量名与内存地址关联起来,这是它的工作,在编译时将任何变量名翻译成内存地址。</target>
        </trans-unit>
        <trans-unit id="959270cda595c9f1ce741e1f2ab621476334d43d" translate="yes" xml:space="preserve">
          <source>A const pointer's target can be replaced by taking its address and using a const cast.</source>
          <target state="translated">一个 const 指针的目标可以通过取其地址并使用 const cast 来替换。</target>
        </trans-unit>
        <trans-unit id="d4063e6d466457440be12f195a44c703d4bcd7c2" translate="yes" xml:space="preserve">
          <source>A few more special rules on references:</source>
          <target state="translated">关于参考文献,还有一些特殊的规定。</target>
        </trans-unit>
        <trans-unit id="1b35409877b7144ea91c809ff4d316184f00d741" translate="yes" xml:space="preserve">
          <source>A pointer can be initialized to 0 and a reference not. In fact, a reference must also refer to an object, but a pointer can be the null pointer:</source>
          <target state="translated">指针可以初始化为0,而引用不能。事实上,引用也必须是引用对象,但指针可以是空指针。</target>
        </trans-unit>
        <trans-unit id="eb1a8b8982766e580a85ab0d0eb62a2e311e86ba" translate="yes" xml:space="preserve">
          <source>A pointer can be re-assigned:</source>
          <target state="translated">指针可以被重新分配。</target>
        </trans-unit>
        <trans-unit id="5dcd9a2027d394eca47f36591f61027051772bca" translate="yes" xml:space="preserve">
          <source>A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.  Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable.  Note: What a pointer points to can be on the stack or heap.  Ditto a reference. My claim in this statement is not that a pointer must point to the stack.  A pointer is just a variable that holds a memory address.  This variable is on the stack.  Since a reference has its own space on the stack, and since the address is the same as the variable it references.  More on &lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;stack vs heap&lt;/a&gt;.  This implies that there is a real address of a reference that the compiler will not tell you.</source>
          <target state="translated">指针在堆栈上有其自己的内存地址和大小（x86上为4字节），而引用共享相同的内存地址（带有原始变量），但也占用了堆栈上的一些空间。 由于引用具有与原始变量本身相同的地址，因此可以将引用视为同一变量的另一个名称。 注意：指针指向的内容可以在堆栈或堆上。 同上一个参考。 我在此声明中的主张不是指针必须指向堆栈。 指针只是保存内存地址的变量。 此变量在堆栈上。 由于引用在堆栈上有自己的空间，并且地址与引用的变量相同。 有关&lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;堆栈与堆的&lt;/a&gt;更多信息。 这意味着编译器不会告诉您引用的真实地址。</target>
        </trans-unit>
        <trans-unit id="fd455ef49a557a536ce9186591eed75410f73093" translate="yes" xml:space="preserve">
          <source>A pointer needs to be dereferenced with &lt;code&gt;*&lt;/code&gt; to access the memory location it points to, whereas a reference can be used directly.  A pointer to a class/struct uses &lt;code&gt;-&amp;gt;&lt;/code&gt; to access it's members whereas a reference uses a &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">指针需要用 &lt;code&gt;*&lt;/code&gt; 取消引用，以访问其指向的内存位置，而引用可以直接使用。 指向类/结构的指针使用 &lt;code&gt;-&amp;gt;&lt;/code&gt; 来访问其成员，而引用则使用 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d9e2dd57673143f5ecc15f3125a1e7c15d2ff7a" translate="yes" xml:space="preserve">
          <source>A pointer requires the location of a piece of space on screen that you assure it will contain zero or more instances of that window type.</source>
          <target state="translated">指针要求在屏幕上的一个空间的位置,你保证它将包含该窗口类型的零或多个实例。</target>
        </trans-unit>
        <trans-unit id="01435a266fb491eeeb93f2b49ededf5562a78098" translate="yes" xml:space="preserve">
          <source>A reference can never be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">引用永远不能为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0db1497e17b4f2171e4c44bff76f09fecf03b574" translate="yes" xml:space="preserve">
          <source>A reference cannot, and must be assigned at initialization:</source>
          <target state="translated">引用不能,也必须在初始化时分配。</target>
        </trans-unit>
        <trans-unit id="8de8f4c2eb87e4ad0059dd772dd0e8d9c15b2d0c" translate="yes" xml:space="preserve">
          <source>A reference is an alias for another variable whereas a pointer holds the memory address of a variable. References are generally used as function parameters so that the passed object is not the copy but the object itself.</source>
          <target state="translated">引用是另一个变量的别名,而指针则持有一个变量的内存地址。引用一般作为函数参数使用,这样传递的对象不是复制对象,而是对象本身。</target>
        </trans-unit>
        <trans-unit id="3fc4f36217977d4385453e9d1605a1d3c9c91d83" translate="yes" xml:space="preserve">
          <source>A reference is not another name given to some memory. It's a immutable pointer that is automatically de-referenced on usage. Basically it boils down to:</source>
          <target state="translated">引用不是给某个内存起的另一个名字。它是一个不可变的指针,在使用时自动去掉引用。基本上,它可以归结为</target>
        </trans-unit>
        <trans-unit id="408fd2770a09c3097a4198b48fb7f80ff76674a3" translate="yes" xml:space="preserve">
          <source>A reference requires you to specify an actual window.</source>
          <target state="translated">引用需要你指定一个实际的窗口。</target>
        </trans-unit>
        <trans-unit id="7a62bb0cc0b8710c81c16b83f6655a27f1f4f924" translate="yes" xml:space="preserve">
          <source>A reference to a pointer is possible in C++, but the reverse is not possible means a pointer to a reference isn't possible. A reference to a pointer provides a cleaner syntax to modify the pointer.
Look at this example:</source>
          <target state="translated">在C++中,对指针的引用是可能的,但反之则意味着对指针的引用是不可能的。对指针的引用提供了一个更干净的语法来修改指针。看看这个例子。</target>
        </trans-unit>
        <trans-unit id="f9bf408f44a75a28c1f97df5e2c724d88eaec294" translate="yes" xml:space="preserve">
          <source>A reference's target cannot be replaced in any way short of UB.</source>
          <target state="translated">参照的目标不能以任何方式代替UB的目标。</target>
        </trans-unit>
        <trans-unit id="5355053294d8994c0ecb21bffdd545b0a989f529" translate="yes" xml:space="preserve">
          <source>Actually, a reference is not really like a pointer.</source>
          <target state="translated">其实,参照物并不是真的像一个指针。</target>
        </trans-unit>
        <trans-unit id="e7cbf8356a1da6417d65167e6890b1ece5d79c47" translate="yes" xml:space="preserve">
          <source>After the assignment, ival, the object addressed by pi remains unchanged. The assignment changes the value of pi, making it point to a different object. Now consider a similar program that assigns two references:</source>
          <target state="translated">赋值后,ival,pi所寻址的对象保持不变。该赋值改变了π的值,使其指向不同的对象。现在考虑一个类似的程序,给两个引用赋值。</target>
        </trans-unit>
        <trans-unit id="789209b07ed91340d591d3ecbd391a25bb1a617e" translate="yes" xml:space="preserve">
          <source>All references must be initialized with a non-null value or compilation will fail. It's neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references.</source>
          <target state="translated">所有的引用必须以非空值初始化,否则编译将失败。既不可能得到引用的地址--地址操作符将返回被引用值的地址--也不可能对引用进行算术处理。</target>
        </trans-unit>
        <trans-unit id="4a0d598143cbd5c038eec18a5364ebca3ce06755" translate="yes" xml:space="preserve">
          <source>Also, a reference that is a parameter to a function that is inlined may be handled differently than a pointer.</source>
          <target state="translated">另外,作为函数参数的引用,如果是内嵌式的函数的参数,其处理方式可能与指针不同。</target>
        </trans-unit>
        <trans-unit id="198270e21c92ca200586af9582ab1a26ef99e93d" translate="yes" xml:space="preserve">
          <source>Also, spare 10 minutes and watch this video: &lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;https://www.youtube.com/watch?v=rlJrrGV0iOg&lt;/a&gt;</source>
          <target state="translated">另外，请保留10分钟并观看以下视频： &lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;https&lt;/a&gt; : //www.youtube.com/watch?v=rlJrrGV0iOg</target>
        </trans-unit>
        <trans-unit id="def296e5debd47695d96a2e810d313523875ea0e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;object&lt;/em&gt; type is a (possibly &lt;em&gt;cv&lt;/em&gt;-qualified) type that is not a function type, not a reference type, and not &lt;em&gt;cv&lt;/em&gt; void.</source>
          <target state="translated">&lt;em&gt;对象&lt;/em&gt;类型是（可能是&lt;em&gt;cv&lt;/em&gt;限定的）类型，不是函数类型，引用类型和&lt;em&gt;cv&lt;/em&gt; void。</target>
        </trans-unit>
        <trans-unit id="aaa58e7db6a960dc51cd22c3dc1684dfd20f847c" translate="yes" xml:space="preserve">
          <source>An optimizing compiler may realize that we are accessing a[0] and a[1] quite a bunch. It would love to optimize the algorithm to:</source>
          <target state="translated">一个优化的编译器可能会意识到,我们在访问a[0]和a[1]的次数很多。它很想把算法优化到。</target>
        </trans-unit>
        <trans-unit id="a77f60581112f1094707329df4c6d30c6956a373" translate="yes" xml:space="preserve">
          <source>And consider the C version of the above program. In C you have to use pointer to pointer (multiple indirection), and it leads to confusion and the program may look complicated.</source>
          <target state="translated">再考虑一下上面程序的C语言版本。在C语言中,你必须使用指针(多个指针),这样会导致程序看起来很复杂,而且程序看起来很混乱。</target>
        </trans-unit>
        <trans-unit id="ddb61be46c893264465a08b177ca023b9286da4f" translate="yes" xml:space="preserve">
          <source>Another difference is that pointer can point to another object however reference is always referencing to the same object, let&amp;rsquo;s take this example:</source>
          <target state="translated">另一个区别是指针可以指向另一个对象，但是引用始终引用同一对象，让我们举个例子：</target>
        </trans-unit>
        <trans-unit id="d9d2f372f903617152234f6054a59f4db746d3e3" translate="yes" xml:space="preserve">
          <source>Another difference is that you can have pointers to a void type (and it means pointer to anything) but references to void are forbidden.</source>
          <target state="translated">另一个区别是,你可以有指向void类型的指针(而且是指指向任何东西的指针),但禁止对void的引用。</target>
        </trans-unit>
        <trans-unit id="ed06ace0f97d6901e5c79ad444c40f4d371c03fa" translate="yes" xml:space="preserve">
          <source>Another important point is that is we can make the declaration of the pointer without initialization however no such thing can be done in case of reference which must make a reference always to variable or object. However such use of a pointer is risky so generally we check if the pointer is actually is pointing to something or not. In case of a reference no such check is necessary, because we know already that referencing to an object during declaration is mandatory.</source>
          <target state="translated">另一个重要的一点是,我们可以在没有初始化的情况下进行指针的声明,但是在引用的情况下,这样的事情是不能做的,因为引用必须总是指向变量或对象。但是这样使用指针是有风险的,所以我们通常要检查指针是否指向某个东西。在引用的情况下,我们没有必要进行这样的检查,因为我们已经知道在声明中引用对象是必须的。</target>
        </trans-unit>
        <trans-unit id="cab05ab1c2c0ef5b2ba43eff8ccf5c0c4d2d12e9" translate="yes" xml:space="preserve">
          <source>Another interesting use of references is to supply a default argument of a user-defined type:</source>
          <target state="translated">引用的另一个有趣的用途是提供一个用户定义类型的默认参数。</target>
        </trans-unit>
        <trans-unit id="8405a7757378ccd741f1d45d9bcb524d4b5f3829" translate="yes" xml:space="preserve">
          <source>Another point: When we have a template like an STL template such kind of a class template will always return a reference, not a pointer, to make easy reading or assigning new value using operator []:</source>
          <target state="translated">还有一点。当我们有一个像STL模板这样的模板时,这样的类模板总是会返回一个引用,而不是指针,方便读取或使用操作符[]赋新值。</target>
        </trans-unit>
        <trans-unit id="8ae9e0a7b8d69bc4223ff39bbb83d311d51fca21" translate="yes" xml:space="preserve">
          <source>Apart from syntactic sugar, a reference is a &lt;code&gt;const&lt;/code&gt; pointer (&lt;em&gt;not&lt;/em&gt; pointer to a &lt;code&gt;const&lt;/code&gt;). You must establish what it refers to when you declare the reference variable, and you cannot change it later.</source>
          <target state="translated">除了语法糖外，引用是 &lt;code&gt;const&lt;/code&gt; 指针（ &lt;em&gt;而不是&lt;/em&gt; const指针）。 您必须在声明引用变量时建立它所引用的内容，并且以后不能更改它。</target>
        </trans-unit>
        <trans-unit id="8d8f44fcd3e6f397b6db8398ce3d44734a996ea7" translate="yes" xml:space="preserve">
          <source>As I said, a pointer to a reference isn't possible. Try the following program:</source>
          <target state="translated">正如我所说,指向引用的指针是不可能的。试试下面的程序。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">举例来说:</target>
        </trans-unit>
        <trans-unit id="82db7c2ab0468c723d35542df3eb95e5e5ba8cad" translate="yes" xml:space="preserve">
          <source>At the highest-level, the idea of references is that they are transparent &quot;aliases&quot;. Your computer may use an address to make them work, but you're not supposed to worry about that: you're supposed to think of them as &quot;just another name&quot; for an existing object and the syntax reflects that. They are stricter than pointers so your compiler can more reliably warn you when you about to create a dangling reference, than when you are about to create a dangling pointer.</source>
          <target state="translated">在最高层,引用的想法是,它们是透明的 &quot;别名&quot;。你的计算机可能会使用一个地址来使它们工作,但你不应该担心这个问题:你应该把它们看作是一个现有对象的 &quot;另一个名字&quot;,而语法反映了这一点。它们比指针更严格,所以你的编译器可以在你要创建一个悬空引用时比创建一个悬空指针时更可靠地警告你。</target>
        </trans-unit>
        <trans-unit id="1c79f63a01a5e0dc422bfd0d4cf499645ee5ba60" translate="yes" xml:space="preserve">
          <source>At the risk of adding to confusion, I want to throw in some input, I'm sure it mostly depends on how the compiler implements references, but in the case of gcc the idea that a reference can only point to a variable on the stack is not actually correct, take this for example:</source>
          <target state="translated">冒着增加混乱的风险,我想抛出一些意见,我相信这主要取决于编译器如何实现引用,但在gcc的情况下,一个引用只能指向堆栈上的一个变量的想法实际上是不正确的,以这个为例。</target>
        </trans-unit>
        <trans-unit id="e6de6d55fd9e888c00be46ee2285966c7f90196b" translate="yes" xml:space="preserve">
          <source>BTW, a few other contexts like initialization involving &lt;code&gt;std::initializer_list&lt;/code&gt; follows some similar rules of reference lifetime extension. It is another can of worms.</source>
          <target state="translated">顺便说一句，其他一些类似 &lt;code&gt;std::initializer_list&lt;/code&gt; 上下文也遵循一些类似的引用生存期扩展规则。 这是另一种蠕虫。</target>
        </trans-unit>
        <trans-unit id="28157cc4e97b442db1a423840eb02259f1ee9ada" translate="yes" xml:space="preserve">
          <source>Back in C, a call that looks like &lt;code&gt;fn(x)&lt;/code&gt; can only be passed by value, so it definitely cannot modify &lt;code&gt;x&lt;/code&gt;; to modify an argument you would need to pass a pointer &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt;. So if an argument wasn't preceded by an &lt;code&gt;&amp;amp;&lt;/code&gt; you knew it would not be modified. (The converse, &lt;code&gt;&amp;amp;&lt;/code&gt; means modified, was not true because you would sometimes have to pass large read-only structures by &lt;code&gt;const&lt;/code&gt; pointer.)</source>
          <target state="translated">回到C中，看起来像 &lt;code&gt;fn(x)&lt;/code&gt; 的调用只能按值传递，因此它绝对不能修改 &lt;code&gt;x&lt;/code&gt; ； 要修改参数，您需要传递一个指针 &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt; 。 因此，如果参数前面没有 &lt;code&gt;&amp;amp;&lt;/code&gt; ,则您将不会对其进行修改。 （相反， &lt;code&gt;&amp;amp;&lt;/code&gt; 表示已修改，是不正确的，因为您有时必须通过 &lt;code&gt;const&lt;/code&gt; 指针传递大型只读结构。）</target>
        </trans-unit>
        <trans-unit id="52fbc9beddeb6a8c7a6bb62a43b5c950f4daeb34" translate="yes" xml:space="preserve">
          <source>Beyond that, there are of course some practical differences between pointers and references. The syntax to use them is obviously different, and you cannot &quot;re-seat&quot; references, have references to nothingness, or have pointers to references.</source>
          <target state="translated">除此之外,指针和引用当然也有一些实际的区别。使用它们的语法显然是不同的,你不能 &quot;重坐 &quot;引用,不能有指向虚无的引用,也不能有指向引用的指针。</target>
        </trans-unit>
        <trans-unit id="2f0a115b892ed33dc580b0746ea765524e9adee4" translate="yes" xml:space="preserve">
          <source>But if a reference &lt;em&gt;really&lt;/em&gt; were the object, how could there be dangling references? In unmanaged languages, it's impossible for references to be any 'safer' than pointers - there generally just isn't a way to reliably alias values across scope boundaries!</source>
          <target state="translated">但是，如果引用&lt;em&gt;确实&lt;/em&gt;是对象，那么怎么会有悬挂的引用呢？ 在非托管语言中，引用不可能比指针更&amp;ldquo;安全&amp;rdquo;-通常只有一种方法才能可靠地跨作用域边界别名！</target>
        </trans-unit>
        <trans-unit id="c0f0472a48232cf765cdc5a4ed86bcc402178e6e" translate="yes" xml:space="preserve">
          <source>But this is not the whole story. I mean, there are more things than pointers vs references you have to consider.</source>
          <target state="translated">但这并不是故事的全部。我的意思是,你要考虑的东西比指针和参考文献更多。</target>
        </trans-unit>
        <trans-unit id="1219d69d4aae4754c68f172af1e20be534822a2e" translate="yes" xml:space="preserve">
          <source>But we can&amp;rsquo;t have &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; and also &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt;.</source>
          <target state="translated">但是我们不能有 &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; 并且 &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85c1119a1a34eb5b96e7a27219b6d23bf265027f" translate="yes" xml:space="preserve">
          <source>But what are the differences?</source>
          <target state="translated">但有什么不同呢?</target>
        </trans-unit>
        <trans-unit id="ea217864ff94b0a58af879bc82826ac7131e836c" translate="yes" xml:space="preserve">
          <source>C programmers might dislike C++ references as it will no longer be obvious when indirection happens or if an argument gets passed by value or by pointer without looking at function signatures.</source>
          <target state="translated">C语言程序员可能会不喜欢C++引用,因为当发生隐式引用时,或者当参数被值或指针传递时,如果不看函数签名,就不再明显。</target>
        </trans-unit>
        <trans-unit id="4a06c33b9cfbaa63574bd669ad9aaf1bc634c44a" translate="yes" xml:space="preserve">
          <source>C++ only has a few kinds of syntactic sugars in this strict sense. One instance is (inherited from C) the built-in (non-overloaded) operator &lt;code&gt;[]&lt;/code&gt;, which &lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;is defined exactly having same semantic properties of specific forms of combination over built-in operator unary &lt;code&gt;*&lt;/code&gt; and binary &lt;code&gt;+&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从严格的意义上讲，C ++只有几种语法糖。 一个实例是（从C继承）内置（非重载）运算符 &lt;code&gt;[]&lt;/code&gt; ，该运算符的&lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;定义与内置运算符unary &lt;code&gt;*&lt;/code&gt; 和binary &lt;code&gt;+&lt;/code&gt; 完全相同，具有特定组合形式的语义属性&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bb21fac313bcd60906b2b35ca4582ec35330749" translate="yes" xml:space="preserve">
          <source>C++ programmers might dislike using pointers as they are considered unsafe - although references aren't really any safer than constant pointers except in the most trivial cases - lack the convenience of automatic indirection and carry a different semantic connotation.</source>
          <target state="translated">C++程序员可能不喜欢使用指针,因为它们被认为是不安全的--虽然除了在最琐碎的情况下,引用并不比常量指针更安全--缺乏自动隐含的便利性,而且带有不同的语义内涵。</target>
        </trans-unit>
        <trans-unit id="9d2b52840330e7a44bc694eb6918e7e64357a038" translate="yes" xml:space="preserve">
          <source>Coming from a C background, C++ references may look like a somewhat silly concept, but one should still use them instead of pointers where possible: Automatic indirection &lt;em&gt;is&lt;/em&gt; convenient, and references become especially useful when dealing with &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt; - but not because of any perceived safety advantage, but rather because they make writing idiomatic code less awkward.</source>
          <target state="translated">来自C的背景，C ++引用可能看起来有点愚蠢，但是在可能的情况下，仍然应该使用它们而不是指针：自动间接调用&lt;em&gt;很&lt;/em&gt;方便，并且在处理&lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt;时引用特别有用-但不是因为任何可察觉的安全性优势，而是因为它们使编写惯用代码变得不那么尴尬。</target>
        </trans-unit>
        <trans-unit id="059cdeb648fa366a46a8b8314ed53bd8fc068d24" translate="yes" xml:space="preserve">
          <source>Compound declarators are more restrictive on references.</source>
          <target state="translated">复合声明者对引用的限制性较强。</target>
        </trans-unit>
        <trans-unit id="403fed44f11ec4c8ff00fd23f9802e6597c6b4a0" translate="yes" xml:space="preserve">
          <source>Consider the following statement from the &lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;C++ FAQ&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">考虑一下&lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;C ++ FAQ中&lt;/em&gt;&lt;/a&gt;的以下语句：</target>
        </trans-unit>
        <trans-unit id="67105debe8987091e6bdc70ef2e1c62eaeef75e5" translate="yes" xml:space="preserve">
          <source>Consider these two program fragments. In the first, we assign one pointer to another:</source>
          <target state="translated">考虑一下这两个程序片段。在第一个中,我们将一个指针分配给另一个指针。</target>
        </trans-unit>
        <trans-unit id="0cdefee66dd0f6388e32b9d6fed8a4351a84480e" translate="yes" xml:space="preserve">
          <source>Const references can be bound to temporaries. Pointers cannot (not without some indirection):</source>
          <target state="translated">Const引用可以被绑定到时域。而指针不能(不是没有一些隐含的)。</target>
        </trans-unit>
        <trans-unit id="257ee630683f00991c22ec378f7e691a1faab887" translate="yes" xml:space="preserve">
          <source>Contrary to popular opinion, it is possible to have a reference that is NULL.</source>
          <target state="translated">与流行的观点相反,有可能有一个参照物是NULL的。</target>
        </trans-unit>
        <trans-unit id="43548a90788ae029335a689520a48ebf306a65a2" translate="yes" xml:space="preserve">
          <source>Copy constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually it should be &lt;code&gt;const&lt;/code&gt; qualified.)</source>
          <target state="translated">复制构造函数需要特定类型的&lt;em&gt;cv-&lt;/em&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; 引用类型作为第一参数类型。 （通常应该是 &lt;code&gt;const&lt;/code&gt; 限定的。）</target>
        </trans-unit>
        <trans-unit id="2dfaa6ee16a6acd02f7f18aa98b05c4a8bd6187a" translate="yes" xml:space="preserve">
          <source>Difference between pointer and reference</source>
          <target state="translated">指针和参考的区别</target>
        </trans-unit>
        <trans-unit id="8d3aac2e61ebd63a0be37ce5d8c06b59c983898f" translate="yes" xml:space="preserve">
          <source>EDIT: Five years after posting this answer, I found an actual technical difference where references are different than just a different way of looking at the same addressing concept.  References can modify the lifespan of temporary objects in a way that pointers cannot.</source>
          <target state="translated">EDIT:在发布这个答案五年后,我发现了一个实际的技术差异,在这里,引用是不同的,而不仅仅是对同一寻址概念的不同看待方式。引用可以以指针所不能的方式修改临时对象的寿命。</target>
        </trans-unit>
        <trans-unit id="afbb5feebb594dfda93806a9043262ea69ffa66b" translate="yes" xml:space="preserve">
          <source>Even that pointers are not qualified enough to be put together with references in the sense of the language design, there are still some arguments making it debatable to make choice between them in some other contexts, for example, when making choices on parameter types.</source>
          <target state="translated">即使在语言设计的意义上,指向性不够合格,但在其他一些其他语境中,比如说在参数类型的选择上,仍然有一些论据使得它们之间的选择值得商榷。</target>
        </trans-unit>
        <trans-unit id="1f7c6527f15ac956bb6422655a89e581ad918f6c" translate="yes" xml:space="preserve">
          <source>Even though a reference is often implemented using an address in the
  underlying assembly language, please do &lt;em&gt;not&lt;/em&gt; think of a reference as a
  funny looking pointer to an object. A reference &lt;em&gt;is&lt;/em&gt; the object. It is
  not a pointer to the object, nor a copy of the object. It &lt;em&gt;is&lt;/em&gt; the
  object.</source>
          <target state="translated">即使经常使用底层汇编语言中的地址来实现引用，也请不要将引用视为指向对象的有趣指针。 引用&lt;em&gt;是&lt;/em&gt;对象。 它不是指向对象的指针，也不是对象的副本。 它&lt;em&gt;是&lt;/em&gt;对象。</target>
        </trans-unit>
        <trans-unit id="1f0674352c239a778bc468638b40b47fb71b2d98" translate="yes" xml:space="preserve">
          <source>Even when you do want semantics like traditional pointer, there are often something more appropriate, like &lt;code&gt;observer_ptr&lt;/code&gt; in Library Fundamental TS.</source>
          <target state="translated">即使当您确实想要像传统指针这样的语义时，通常也更合适一些，例如Library Fundamental TS中的 &lt;code&gt;observer_ptr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91de4132deb2a9d1d143f39e4534fbb3726e45ff" translate="yes" xml:space="preserve">
          <source>For an older look at this problem from someone with better writing skills, see &lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;Null References&lt;/a&gt; from Jim Hyslop and Herb Sutter.</source>
          <target state="translated">要更深入地了解写作能力更高的人，请参阅Jim Hyslop和Herb Sutter的&lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;Null参考&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8c71250e475a3240795bff029fac330bf5c86bc" translate="yes" xml:space="preserve">
          <source>For another example of the dangers of dereferencing a null pointer see &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;Exposing undefined behavior when trying to port code to another platform&lt;/a&gt; by Raymond Chen.</source>
          <target state="translated">有关取消引用空指针的危险的另一个示例，请参阅Raymond Chen &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;试图将代码移植到另一个平台时公开未定义的行为&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="419ffcbab3d6f22ef6fdb16e11f51ddef360025c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;the ISO C++ definition of object type&lt;/a&gt;:</source>
          <target state="translated">根据&lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;ISO C ++对对象类型的定义&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c921eb398c160fb46e416cb1d07e77fdce036162" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref]/4&lt;/a&gt;:</source>
          <target state="translated">来自&lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref] / 4&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="bf57a6753ab8a3e91849d0a5046139bd0ae54c97" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object]/1&lt;/a&gt;:</source>
          <target state="translated">来自&lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object] / 1&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="59b186995c92752fd57142834fecf2e2d3252883" translate="yes" xml:space="preserve">
          <source>Function pointers can be converted from lambda expressions without captures, while function references cannot. You have to use function pointers in non-generic code for such cases, even you deliberately do not want nullable values.</source>
          <target state="translated">函数指针可以从lambda表达式中转换,而函数引用不能。对于这种情况,你必须在非通用代码中使用函数指针,即使你刻意不想要nullable值,也必须使用函数指针。</target>
        </trans-unit>
        <trans-unit id="5a8a000b2872f2ecd2628fd91b4af38afe4ab27a" translate="yes" xml:space="preserve">
          <source>Granted, it is much harder to do with a reference - but if you manage it, you'll tear your hair out trying to find it. References are &lt;em&gt;not&lt;/em&gt; inherently safe in C++!</source>
          <target state="translated">当然，要使用参考文献要困难得多-但是如果您进行管理，就会发现自己的头发会撕裂。 在C ++中，引用&lt;em&gt;并不是&lt;/em&gt;天生的安全！</target>
        </trans-unit>
        <trans-unit id="f3d615628d1fd5133dbe19b3297b67cff89e2934" translate="yes" xml:space="preserve">
          <source>Here you are not creating another variable that points to &lt;code&gt;a&lt;/code&gt;; you are just adding another name to the memory content holding the value of &lt;code&gt;a&lt;/code&gt;. This memory now has two names, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and it can be addressed using either name.</source>
          <target state="translated">在这里，您不会创建另一个指向的变量。 您只是将另一个名称添加到包含 &lt;code&gt;a&lt;/code&gt; 值的内存内容中。 现在，此内存有两个名称， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，可以使用任何一个名称进行寻址。</target>
        </trans-unit>
        <trans-unit id="6748018a83feee685129beabf05358adfb1f4a93" translate="yes" xml:space="preserve">
          <source>I can't say I'm really happy with this particular difference. I would much prefer it would be allowed with the meaning reference to anything with an address and otherwise the same behavior for references. It would allow to define some equivalents of C library functions like memcpy using references.</source>
          <target state="translated">我不能说我真的对这个特殊的区别很满意。我更希望它能被允许对任何有地址的意义的引用,否则对引用的行为也是一样的。这将允许定义一些等同于C库的函数,如memcpy的引用。</target>
        </trans-unit>
        <trans-unit id="83cff075b67cc3caa75652556ccf090327793e2f" translate="yes" xml:space="preserve">
          <source>I feel like there is yet another point that hasn't been covered here.</source>
          <target state="translated">我觉得这里还没有涉及到另一点。</target>
        </trans-unit>
        <trans-unit id="78aca0acaa65086aab3a232e328bb0bc36aa5fcb" translate="yes" xml:space="preserve">
          <source>I know references are syntactic sugar, so code is easier to read and write.</source>
          <target state="translated">我知道引用是语法糖,所以代码更容易读和写。</target>
        </trans-unit>
        <trans-unit id="790a903c1bebeddd1477cdd4d06bfb3b8a62ae9b" translate="yes" xml:space="preserve">
          <source>I use references unless I need either of these:</source>
          <target state="translated">我用的是参考资料,除非我需要其中之一。</target>
        </trans-unit>
        <trans-unit id="3068917d6116da066c23030c927f12eb7a21feb4" translate="yes" xml:space="preserve">
          <source>I want to reiterate that the only way to get a null reference is through malformed code, and once you have it you're getting undefined behavior. It &lt;strong&gt;never&lt;/strong&gt; makes sense to check for a null reference; for example you can try &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; but the compiler might optimize the statement out of existence! A valid reference can never be NULL so from the compiler's view the comparison is always false, and it is free to eliminate the &lt;code&gt;if&lt;/code&gt; clause as dead code - this is the essence of undefined behavior.</source>
          <target state="translated">我要重申的是，获取空引用的唯一方法是通过格式错误的代码，一旦获得该引用，您将获得未定义的行为。 检查空引用&lt;strong&gt;从来没有任何&lt;/strong&gt;意义。 例如，您可以尝试 &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; 但是编译器可能会优化该语句而不存在！ 有效引用永远不能为NULL，因此从编译器的角度来看，比较始终为false，可以自由地将 &lt;code&gt;if&lt;/code&gt; 子句消除为无效代码-这是未定义行为的本质。</target>
        </trans-unit>
        <trans-unit id="28a1dd0bb23764b68abee77b06fa28aa411978df" translate="yes" xml:space="preserve">
          <source>If you are doing some iterations over a range, use iterators (or some ranges which are not provided by the standard library yet), rather than raw pointers unless you are convinced raw pointers will do better (e.g. for less header dependencies) in very specific cases.</source>
          <target state="translated">如果你要在一个范围内做一些迭代,请使用迭代器(或一些标准库还没有提供的范围),而不是原始指针,除非你确信在非常特殊的情况下,原始指针会做得更好(比如说,对头的依赖性更小)。</target>
        </trans-unit>
        <trans-unit id="3ba495f422aa5c4d4099a4f3e279461a678eacba" translate="yes" xml:space="preserve">
          <source>If you come to see the question via &lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;some Google search result (not specific to C++)&lt;/a&gt;, this is very likely to be the wrong place.</source>
          <target state="translated">如果您通过&lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;某些Google搜索结果（不是特定于C ++）&lt;/a&gt;来查看问题，则很可能是错误的位置。</target>
        </trans-unit>
        <trans-unit id="1adb9ff9254b1ced3f48e2cba167b170d900e4b7" translate="yes" xml:space="preserve">
          <source>If you don't have to stick on such over-specific choices, in most cases the answer is short: &lt;strong&gt;you do not have the necessity to use pointers, so you don't&lt;/strong&gt;. Pointers are usually bad enough because they imply too many things you don't expect and they will rely on too many implicit assumptions undermining the maintainability and (even) portability of the code. &lt;strong&gt;Unnecessarily relying on pointers is definitely a bad style and it should be avoided in the sense of modern C++.&lt;/strong&gt; Reconsider your purpose and you will finally find that &lt;strong&gt;pointer is the feature of last sorts&lt;/strong&gt; in most cases.</source>
          <target state="translated">如果您不必坚持这种过分具体的选择，那么在大多数情况下，答案很简单： &lt;strong&gt;您不必使用指针，而不必使用指针&lt;/strong&gt; 。 指针通常很糟糕，因为它们暗示了太多您不期望的事情，并且它们将依赖太多隐式假设，从而破坏了代码的可维护性和（甚至）可移植性。 &lt;strong&gt;不必要地依赖指针绝对是一种不好的样式，从现代C ++的意义上应该避免这种情况。&lt;/strong&gt; 重新考虑您的目的，您最终会发现在大多数情况下&lt;strong&gt;指针是&lt;/strong&gt;最后&lt;strong&gt;一种功能&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb2d77074444d61d2cc67de2bd0e1d87f2a0a031" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value (i.e. using non-reference types) is sufficient, use it directly, particularly when using an implementation supporting C++17 mandated copy elision. (&lt;strong&gt;Warning&lt;/strong&gt;: However, to &lt;strong&gt;exhaustively&lt;/strong&gt; reason about the necessity can be &lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;very complicated&lt;/a&gt;.)</source>
          <target state="translated">如果您知道值传递（即使用非引用类型）就足够了，请直接使用它，尤其是在使用支持C ++ 17强制复制省略的实现时。 （ &lt;strong&gt;警告&lt;/strong&gt; ：但是，要&lt;strong&gt;详尽地&lt;/strong&gt;论证这种必要性可能会&lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;非常复杂&lt;/a&gt; 。）</target>
        </trans-unit>
        <trans-unit id="8ab269d4d0dfc63f1830ebd5af6f660e85c8c775" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is not ideal for the reasons above, and you don't want nullable semantics, use {lvalue, rvalue, forwarding}-references.</source>
          <target state="translated">如果你知道按值传递的原因并不理想,而你又不想要nullable语义,那就使用{lvalue,rvalue,rvalue,forwarding}-引用。</target>
        </trans-unit>
        <trans-unit id="95a97bbef840565852fb933bd387402999a8aa62" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is sufficient and you want some explicit nullable semantics, use wrapper like &lt;code&gt;std::optional&lt;/code&gt;, rather than raw pointers.</source>
          <target state="translated">如果您知道传递值就足够了，并且想要一些显式的可为空的语义，请使用包装器，例如 &lt;code&gt;std::optional&lt;/code&gt; ，而不是原始指针。</target>
        </trans-unit>
        <trans-unit id="f83f246714f814ce810c05a9ae95c69e9261bd39" translate="yes" xml:space="preserve">
          <source>If you notice even the memory addresses are exactly the same, meaning the reference is successfully pointing to a variable on the heap! Now if you really want to get freaky, this also works:</source>
          <target state="translated">如果你注意到连内存地址都完全一样,意味着引用成功指向了堆上的一个变量! 现在,如果你真的想搞怪的话,这个也是可以的。</target>
        </trans-unit>
        <trans-unit id="f057014d6ad0660324ee4744392d34f7205d30d5" translate="yes" xml:space="preserve">
          <source>If you try this without the &lt;code&gt;const&lt;/code&gt; it should fail to compile. You cannot bind a non-const reference to a temporary object, nor can you take its address for that matter.</source>
          <target state="translated">如果您在没有 &lt;code&gt;const&lt;/code&gt; 的情况下尝试此操作，则它将无法编译。 您不能将非常量引用绑定到临时对象，也不能使用它的地址。</target>
        </trans-unit>
        <trans-unit id="543e04d6c7cf8b1ff3568e8f9fe688b2b4150999" translate="yes" xml:space="preserve">
          <source>If you want to be really pedantic, there is one thing you can do with a reference that you can't do with a pointer: extend the lifetime of a temporary object. In C++ if you bind a const reference to a temporary object, the lifetime of that object becomes the lifetime of the reference.</source>
          <target state="translated">如果你想迂腐一点,有一件事你可以用引用来做,但你不能用指针来做:延长一个临时对象的寿命。在C++中,如果你把一个constable引用绑定到一个临时对象上,那么这个对象的寿命就变成了这个引用的寿命。</target>
        </trans-unit>
        <trans-unit id="2f134bd878c28bfcf0e94f5edce84bd4768767e8" translate="yes" xml:space="preserve">
          <source>If you want to operate some handles with ownership, use smart pointers like &lt;code&gt;unique_ptr&lt;/code&gt; and &lt;code&gt;shared_ptr&lt;/code&gt; (or even with homebrew ones by yourself if you require them to be &lt;em&gt;opaque&lt;/em&gt;), rather than raw pointers.</source>
          <target state="translated">如果要使用所有权来处理某些句柄，请使用智能指针，例如 &lt;code&gt;unique_ptr&lt;/code&gt; 和 &lt;code&gt;shared_ptr&lt;/code&gt; （或者如果需要它们是&lt;em&gt;不透明的&lt;/em&gt; ，甚至可以自己使用自制符号），而不要使用原始指针。</target>
        </trans-unit>
        <trans-unit id="f9770a58e8e2c829e550700ed47290c2aae7fa6f" translate="yes" xml:space="preserve">
          <source>In fact to do it properly, we must have declared and defined an object at the first then we can make a reference to that object, so the correct implementation of the previous code will be:</source>
          <target state="translated">其实要做好这一点,首先我们必须先声明并定义好一个对象,然后我们才能对这个对象进行引用,这样才能正确的实现前面的代码。</target>
        </trans-unit>
        <trans-unit id="82769a796fb3193fe927e0baf51f38ab518d3ebb" translate="yes" xml:space="preserve">
          <source>In other words, a reference is nothing but a pointer that has the pointer mechanics abstracted away, making it safer and easier to use (no accidental pointer math, no mixing up '.' and '-&amp;gt;', etc.), assuming you don't try any nonsense like my examples above ;)</source>
          <target state="translated">换句话说，引用不过是一种指针，它抽象了指针机制，使其更安全，更易于使用（没有意外的指针数学，不会混淆'。'和'-&amp;gt;'等），假设您不要像我上面的例子一样尝试任何废话;）</target>
        </trans-unit>
        <trans-unit id="200b5d2213958228565fdde5b08d7bf3a0e7e8c1" translate="yes" xml:space="preserve">
          <source>In this example s3_copy copies the temporary object that is a result of the concatenation. Whereas s3_reference in essence becomes the temporary object. It's really a reference to a temporary object that now has the same lifetime as the reference.</source>
          <target state="translated">在这个例子中,s3_copy复制了临时对象,这个临时对象是连接的结果。而s3_reference本质上就变成了临时对象。它实际上是一个临时对象的引用,现在这个临时对象的生命周期和引用一样。</target>
        </trans-unit>
        <trans-unit id="ba73ce596882bac23adab797099d810c536e52c7" translate="yes" xml:space="preserve">
          <source>It also has to prove that there are no ways a future call could read/write a[0] while we have a temporary register copy of it in a0. This is often trivial to prove, because in many cases it is obvious that the reference is never stored in a permanent structure like a class instance.</source>
          <target state="translated">它还必须证明,当我们在a0中拥有一个临时的寄存器副本时,未来的调用没有办法读出a[0]。这通常是个琐碎的证明,因为在很多情况下,很明显,引用永远不会存储在类实例这样的永久结构中。</target>
        </trans-unit>
        <trans-unit id="c0cc1580772a83020df85287d6f8e26c7bd8a5f0" translate="yes" xml:space="preserve">
          <source>It doesn't matter how much space it takes up since you can't actually see any side effect (without executing code) of whatever space it would take up.</source>
          <target state="translated">它占用了多少空间并不重要,因为无论它占用了多少空间,你都无法实际看到它的副作用(不执行代码)。</target>
        </trans-unit>
        <trans-unit id="1d798a27c2d2b93f1136b70dcfad1e9fac904cd6" translate="yes" xml:space="preserve">
          <source>It internally becomes</source>
          <target state="translated">它在内部成为</target>
        </trans-unit>
        <trans-unit id="2dbb06a19fcf0fb6d64e79da18f5a426b98c98ee" translate="yes" xml:space="preserve">
          <source>It is unspecified whether or not a reference requires storage.</source>
          <target state="translated">参考文献是否需要存储,并不明确。</target>
        </trans-unit>
        <trans-unit id="b288f3fae88ae371415949edcc0c9e0886821a41" translate="yes" xml:space="preserve">
          <source>It may be important to know, object type is a top-level category of the type universe in C++. Reference is also a top-level category. &lt;strong&gt;But pointer is not.&lt;/strong&gt;</source>
          <target state="translated">可能很重要的一点是要知道，对象类型是C ++中Universe类型的顶级类别。 参考也是顶级类别。 &lt;strong&gt;但是指针不是。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b45412ddd0ff9c77b1d05ade69b201525767735" translate="yes" xml:space="preserve">
          <source>Language neutrality caveats</source>
          <target state="translated">语言中立性注意事项</target>
        </trans-unit>
        <trans-unit id="55dd62362caab929ec378cd05497a3ec85467b37" translate="yes" xml:space="preserve">
          <source>Look at the following statement,</source>
          <target state="translated">请看下面这段话。</target>
        </trans-unit>
        <trans-unit id="d7297eb6becdd735c4545511c38d16ada0827023" translate="yes" xml:space="preserve">
          <source>Many compilers when inlining the pointer version one will actually force a write to memory (we are taking the address explicitly).  However, they will leave the reference in a register which is more optimal.</source>
          <target state="translated">许多编译器在内联指针版本一的时候,实际上会强制写入内存(我们是显式取地址)。但是,他们会把引用留在寄存器中,这样做是比较理想的。</target>
        </trans-unit>
        <trans-unit id="ea2aee18995ab103eed08b69ba07dcb31625dabf" translate="yes" xml:space="preserve">
          <source>Maybe some metaphors will help; 
In the context of your desktop screenspace -</source>
          <target state="translated">也许一些隐喻会有帮助;在你的桌面屏幕空间的语境中--</target>
        </trans-unit>
        <trans-unit id="ac946397b09fb907e8acce3c92c880b361a9a242" translate="yes" xml:space="preserve">
          <source>Modern compilers are getting better and better at static analysis, but it is always nice to help them out and use references.</source>
          <target state="translated">现代的编译器在静态分析方面越来越好,但是能帮到他们,使用引用总是好的。</target>
        </trans-unit>
        <trans-unit id="bf6c60a1e5c2679ef0162d45b8f206f16bcdd7d1" translate="yes" xml:space="preserve">
          <source>Move constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually there should be no qualifiers.)</source>
          <target state="translated">移动构造函数需要特定类型的&lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 引用类型作为第一参数类型。 （通常应该没有限定符。）</target>
        </trans-unit>
        <trans-unit id="1b9630be120a68e57ca22b6ff58fa3a235507cba" translate="yes" xml:space="preserve">
          <source>My example above is short and contrived. Here's a more real-world example.</source>
          <target state="translated">我上面的例子很简略,也很矫揉造作。下面是一个比较真实的例子。</target>
        </trans-unit>
        <trans-unit id="56e71102cceade878735d306276129a65b04b038" translate="yes" xml:space="preserve">
          <source>Normally temporary objects such as the one created by the call to &lt;code&gt;createF(5)&lt;/code&gt; are destroyed at the end of the expression.  However, by binding that object to a reference, &lt;code&gt;ref&lt;/code&gt;, C++ will extend the lifespan of that temporary object until &lt;code&gt;ref&lt;/code&gt; goes out of scope.</source>
          <target state="translated">通常，临时对象（例如通过调用 &lt;code&gt;createF(5)&lt;/code&gt; 创建的对象）会在表达式的末尾销毁。 但是，通过将该对象绑定到引用 &lt;code&gt;ref&lt;/code&gt; ，C ++将延长该临时对象的寿命，直到 &lt;code&gt;ref&lt;/code&gt; 超出范围。</target>
        </trans-unit>
        <trans-unit id="b2dd5770081924d799a48921378b48818433c7bb" translate="yes" xml:space="preserve">
          <source>Note the statements above only mentions &quot;pointers&quot; and &quot;references&quot; as types. There are some interested questions about their instances (like variables). There also come too many misconceptions.</source>
          <target state="translated">注意上面的语句只提到了 &quot;指针 &quot;和 &quot;引用 &quot;作为类型。对于它们的实例(如变量),有一些感兴趣的问题。也有太多的误解。</target>
        </trans-unit>
        <trans-unit id="0112dd76dee19c15ddada9b0763e06e1cbc7faf4" translate="yes" xml:space="preserve">
          <source>Note these are &lt;em&gt;semantic&lt;/em&gt; properties.</source>
          <target state="translated">请注意，这些是&lt;em&gt;语义&lt;/em&gt;属性。</target>
        </trans-unit>
        <trans-unit id="32c54f61399cee485b86cada14cf3ef339a2f916" translate="yes" xml:space="preserve">
          <source>Now &lt;strong&gt;regardless&lt;/strong&gt; of how a compiler handles references, it will &lt;strong&gt;always&lt;/strong&gt; have some kind of pointer under the hood, because a reference &lt;strong&gt;must&lt;/strong&gt; refer to a specific variable at a specific memory address for it to work as expected, there is no getting around this (hence the term 'reference').</source>
          <target state="translated">现在， &lt;strong&gt;无论&lt;/strong&gt;编译器如何处理引用，它都将&lt;strong&gt;始终&lt;/strong&gt;具有某种内在的指针，因为引用&lt;strong&gt;必须&lt;/strong&gt;引用特定内存地址处的特定变量才能使其按预期工作，因此无法避免这种情况（因此术语&amp;ldquo;参考&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="752e698d55444e3238d56a6bc3da3af23d39ce29" translate="yes" xml:space="preserve">
          <source>Now do the same thing with pointers</source>
          <target state="translated">现在用指针做同样的事情</target>
        </trans-unit>
        <trans-unit id="e6bdf4bf7e4af7604beaed717ed9319201ff15be" translate="yes" xml:space="preserve">
          <source>Now some explanation of real code:</source>
          <target state="translated">现在对真正的代码进行一些解释。</target>
        </trans-unit>
        <trans-unit id="586d3a296148dea14411f5e77a90d02cd7148035" translate="yes" xml:space="preserve">
          <source>Now there may be some cases where your compiler may not be able to know the reference when compiling, like when using an extern variable. So a reference may or may not be implemented as a pointer in the underlying code. But in the examples I gave you, it will most likely not be implemented with a pointer.</source>
          <target state="translated">现在,可能有一些情况下,你的编译器在编译时可能无法知道引用,比如使用外部变量时。所以在底层代码中,引用不一定会以指针的形式实现。但在我给你的例子中,很可能不会用指针来实现。</target>
        </trans-unit>
        <trans-unit id="808cc104c235301ef1bc79319f8102ad43971fef" translate="yes" xml:space="preserve">
          <source>Null pointers can be used as a
sentinel value, often a cheap way to
avoid function overloading or use of
a bool.</source>
          <target state="translated">Null指针可以作为哨兵值,通常是避免函数超载或使用bool的廉价方法。</target>
        </trans-unit>
        <trans-unit id="67ae9809624c429d324c275faf9d92d1518e204d" translate="yes" xml:space="preserve">
          <source>Object types can have top-level &lt;code&gt;cv&lt;/code&gt; qualifiers. References cannot.</source>
          <target state="translated">对象类型可以具有顶级 &lt;code&gt;cv&lt;/code&gt; 限定词。 参考不能。</target>
        </trans-unit>
        <trans-unit id="00a1b2cda377012d0e23e72a9f8fed0898939786" translate="yes" xml:space="preserve">
          <source>Of course, barring such clever optimizations, compilers will indeed turn references into pointers when needed.</source>
          <target state="translated">当然,除了这些巧妙的优化之外,编译器确实会在需要的时候把引用变成指针。</target>
        </trans-unit>
        <trans-unit id="dc07d79fb5ff33400c26bc7a53b5a0a72e7aefd6" translate="yes" xml:space="preserve">
          <source>Of course, for functions that are not inlined the pointer and reference generate the same code and it's always better to pass intrinsics by value than by reference if they are not modified and returned by the function.</source>
          <target state="translated">当然,对于没有内联的函数,指针和引用产生的代码是一样的,如果函数没有修改和返回,那么通过值传递本体总是比通过引用传递本体更好。</target>
        </trans-unit>
        <trans-unit id="828bf90967e721e857197022098eb853d37eaa44" translate="yes" xml:space="preserve">
          <source>On the other hand, one major difference between references and pointers is that temporaries assigned to const references live until the const reference goes out of scope.</source>
          <target state="translated">另一方面,引用和指针之间的一个主要区别是,分配给常量引用的时域是活的,直到常量引用超出范围为止。</target>
        </trans-unit>
        <trans-unit id="90dd91d02279fe6ccfc85544573813d23da86513" translate="yes" xml:space="preserve">
          <source>Otherwise, it is insignificant that pointers can be qualified as a specific sorts of types with references together. They simply share too few common properties besides the syntax similarity, so there is no need to put them together in most cases.</source>
          <target state="translated">否则,指针可以被限定为特定类型的类型与引用放在一起,这是不重要的。它们除了语法上的相似性外,只是共同的属性太少,所以大多数情况下没有必要把它们放在一起。</target>
        </trans-unit>
        <trans-unit id="c468e66383b3acff1decf7ebfe1722418b200e03" translate="yes" xml:space="preserve">
          <source>Overloaded &lt;code&gt;operator=&lt;/code&gt; as special member functions requires reference types similar to 1st parameter of copy/move constructors.</source>
          <target state="translated">重载的 &lt;code&gt;operator=&lt;/code&gt; 作为特殊的成员函数，要求引用类型类似于copy / move构造函数的第一个参数。</target>
        </trans-unit>
        <trans-unit id="7f2c3e2cc509718d63ded349b2aab9f792237302" translate="yes" xml:space="preserve">
          <source>Pointer can be assigned &lt;code&gt;nullptr&lt;/code&gt; directly, whereas reference cannot. If you try hard enough, and you know how, you can make the address of a reference &lt;code&gt;nullptr&lt;/code&gt;.  Likewise, if you try hard enough you can have a reference to a pointer, and then that reference can contain &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">指针可以直接分配为 &lt;code&gt;nullptr&lt;/code&gt; ，而引用不能。 如果您尽力而为，并且知道如何做，则可以将引用的地址设置为 &lt;code&gt;nullptr&lt;/code&gt; 。 同样，如果您尽力而为，则可以对一个指针进行引用，然后该引用可以包含 &lt;code&gt;nullptr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8dd03a2b7cf3f5874fc9c97bd98b107bc98bfa9" translate="yes" xml:space="preserve">
          <source>Pointers and references are mentioned together &lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;in the context of &lt;em&gt;compound type&lt;/em&gt;&lt;/a&gt;. This is basically due to the nature of the declarator syntax inherited from (and extended) C, which has no references. (Besides, there are more than one kind of declarator of references since C++ 11, while pointers are still &quot;unityped&quot;: &lt;code&gt;&amp;amp;&lt;/code&gt;+&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; vs. &lt;code&gt;*&lt;/code&gt;.) So drafting a language specific by &quot;extension&quot; with similar style of C in this context is somewhat reasonable. (I will still argue that the syntax of declarators wastes the syntactic expressiveness &lt;em&gt;a lot&lt;/em&gt;, makes both human users and implementations frustrating. Thus, all of them are not qualified to be &lt;em&gt;built-in&lt;/em&gt; in a new language design. This is a totally different topic about PL design, though.)</source>
          <target state="translated">&lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;在&lt;em&gt;复合类型&lt;/em&gt;的上下文&lt;/a&gt;中一起提到了指针和引用。 这基本上是由于从（没有扩展的）C继承（和扩展）的C声明符语法的性质所致。 （此外，自C ++ 11以来，引用的声明符不止一种，而指针仍是&amp;ldquo; unityped&amp;rdquo;的： &lt;code&gt;&amp;amp;&lt;/code&gt; + &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; vs. &lt;code&gt;*&lt;/code&gt; 。）因此，在这种情况下，起草了一种由&amp;ldquo;扩展名&amp;rdquo;指定的，具有类似C样式的语言有点合理。 （我仍然会争论说，声明符的语法浪费&lt;em&gt;了很多&lt;/em&gt;语法表达性，使人类用户和实现都感到沮丧。因此，它们都不适合在新的语言设计中&lt;em&gt;内置&lt;/em&gt; 。这是完全不同的主题。关于PL设计。）</target>
        </trans-unit>
        <trans-unit id="8e79db4216ca0b1682917f0312184de116274ee0" translate="yes" xml:space="preserve">
          <source>Pointers are variables; they contain the address of some other variable, or can be null. The important thing is that a pointer has a value, while a reference only has a variable that it is referencing.</source>
          <target state="translated">指针是变量;它们包含了一些其他变量的地址,也可以是空的。重要的是,指针有一个值,而引用只包含一个变量。</target>
        </trans-unit>
        <trans-unit id="a4c98c7b23dbb9c431cf37cec4103729a3b3df7c" translate="yes" xml:space="preserve">
          <source>Pointers can iterate over an array, you can use &lt;code&gt;++&lt;/code&gt; to go to the next item that a pointer is pointing to, and &lt;code&gt;+ 4&lt;/code&gt; to go to the 5th element.  This is no matter what size the object is that the pointer points to.</source>
          <target state="translated">指针可以遍历数组，您可以使用 &lt;code&gt;++&lt;/code&gt; 转到指针所指向的下一个项目，并使用 &lt;code&gt;+ 4&lt;/code&gt; 转到第5个元素。 无论指针指向的对象大小是多少。</target>
        </trans-unit>
        <trans-unit id="0041b69bd78f1922ccacbca89c0bd23258263cde" translate="yes" xml:space="preserve">
          <source>Postfix &lt;code&gt;++&lt;/code&gt; requires dummy &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Postfix &lt;code&gt;++&lt;/code&gt; 需要哑 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c40deca9098c33c4507f06a0277ec7d603682af" translate="yes" xml:space="preserve">
          <source>Pragmatics</source>
          <target state="translated">Pragmatics</target>
        </trans-unit>
        <trans-unit id="462242db0811f3f971e9fd491ae343b8badcc883" translate="yes" xml:space="preserve">
          <source>RAII is one of the central concepts of C++, but it interacts non-trivially with copying semantics. Passing objects by reference avoids these issues as no copying is involved. If references were not present in the language, you'd have to use pointers instead, which are more cumbersome to use, thus violating the language design principle that the best-practice solution should be easier than the alternatives.</source>
          <target state="translated">RAII是C++的核心概念之一,但它与复制语义的交互性不强。通过引用传递对象就避免了这些问题,因为不涉及复制。如果语言中没有引用,你就不得不用指针来代替,而指针的使用会比较麻烦,这就违反了语言设计原则,即最佳实践方案应该比替代方案更容易。</target>
        </trans-unit>
        <trans-unit id="055cd393f567fac0ba4089ec8ff85252aac14bdb" translate="yes" xml:space="preserve">
          <source>References are allowed to refer to variables which do not have memory addresses, such as those the compiler chooses to put into registers. If you take the address of a local variable, it is very hard for the compiler to put it in a register.</source>
          <target state="translated">允许引用那些没有内存地址的变量,比如编译器选择将其放入寄存器中的变量。如果取了一个本地变量的地址,编译器很难把它放到寄存器中。</target>
        </trans-unit>
        <trans-unit id="5a853555e7fde5a31207074a784b524c82ed58aa" translate="yes" xml:space="preserve">
          <source>References are designed such that it is substantially easier for the compiler to trace which reference aliases which variables. Two major features are very important: no &quot;reference arithmetic&quot; and no reassigning of references. These allow the compiler to figure out which references alias which variables at compile time.</source>
          <target state="translated">引用的设计使编译器更容易跟踪哪些引用别名是哪些变量。有两个主要的特点非常重要:没有 &quot;引用算术 &quot;和没有重新分配引用。这使得编译器能够在编译时找出哪些引用别名为哪些变量。</target>
        </trans-unit>
        <trans-unit id="e813db94099ca02f715fb0f1ba9f33611db2f553" translate="yes" xml:space="preserve">
          <source>References are very similar to pointers, but they are specifically crafted to be helpful to optimizing compilers.</source>
          <target state="translated">引用与指针非常相似,但它们是专门为优化编译器而设计的,有助于优化编译器。</target>
        </trans-unit>
        <trans-unit id="bf6fd50fdee7317a481645b6fae553557dc3cdd2" translate="yes" xml:space="preserve">
          <source>References can &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;collapse&lt;/a&gt;.</source>
          <target state="translated">引用可能会&lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;崩溃&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e3206ad161847bd2d29f9d31a405ed11c7d64c2" translate="yes" xml:space="preserve">
          <source>References cannot be stuffed into an array, whereas pointers can be (Mentioned by user @litb)</source>
          <target state="translated">引用不能被塞进数组中,而指针可以 (用户@litb提到)</target>
        </trans-unit>
        <trans-unit id="cfca6984c06ae05fa650e3c0076a1855343215bb" translate="yes" xml:space="preserve">
          <source>References have special rules in initialization. The lifetime of variable declared as a reference type can be different to ordinary objects via extension.</source>
          <target state="translated">引用在初始化时有特殊的规则。作为引用类型声明的变量的生命周期可以通过扩展来区别于普通对象。</target>
        </trans-unit>
        <trans-unit id="526784942b6e34cc8eb97ec6c1946f69db4aa93c" translate="yes" xml:space="preserve">
          <source>References in C++ is quite &quot;odd&quot;, as it is essentially not first-class: &lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;they will be treated as the objects or the functions being referred to&lt;/a&gt; so they have no chance to support some first-class operations like being the left operand of &lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;the member access operator&lt;/a&gt; independently to the type of the referred object. Other languages may or may not have similar restrictions on their references.</source>
          <target state="translated">C ++中的引用相当&amp;ldquo;奇&amp;rdquo;，因为它本质上不是一流的： &lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;它们将被视为所引用的对象或函数，&lt;/a&gt;因此它们没有机会支持某些一流的操作，例如作为左操作数。 &lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;成员访问运算符&lt;/a&gt;独立于所引用对象的类型。 其他语言对其参考文献可能有也可能没有类似的限制。</target>
        </trans-unit>
        <trans-unit id="d003206a70c36ecf7a0315ea6420395ec7e35600" translate="yes" xml:space="preserve">
          <source>References in C++ will likely not preserve the meaning across different languages. For example, references in general do not imply nonnull properties on values like they in C++, so such assumptions may not work in some other languages (and you will find counterexamples quite easily, e.g. Java, C#, ...).</source>
          <target state="translated">C++中的引用很可能不会在不同语言中保留不同的含义。例如,一般情况下,引用并不像C++中的引用那样意味着值的非空属性,所以这样的假设在其他一些语言中可能不适用(而且你会很容易找到反例,例如Java、C#、...)。</target>
        </trans-unit>
        <trans-unit id="776a07f1188f204d3f88257d0ec6a07a29887cdc" translate="yes" xml:space="preserve">
          <source>Regards,
&amp;amp;rzej</source>
          <target state="translated">Regards,
&amp;amp;rzej</target>
        </trans-unit>
        <trans-unit id="f29ff291ec91fbd3d5e03a84623244a66ed645e4" translate="yes" xml:space="preserve">
          <source>Run the program and have a look at the output and you'll understand.</source>
          <target state="translated">运行程序,看一看输出,你就明白了。</target>
        </trans-unit>
        <trans-unit id="01841626b366982706bd9cb74359851e4287a00f" translate="yes" xml:space="preserve">
          <source>Simply to remember that,</source>
          <target state="translated">只是为了记住这一点。</target>
        </trans-unit>
        <trans-unit id="7ed3e2e5988e139dbdad2bddeb8aea77458c5333" translate="yes" xml:space="preserve">
          <source>So, in practice, the answer is so obvious: &lt;strong&gt;when in doubt, avoid pointers&lt;/strong&gt;. You have to use pointers only when there are very explicit reasons that nothing else is more appropriate. Except a few exceptional cases mentioned above, such choices are almost always not purely C++-specific (but likely to be language-implementation-specific). Such instances can be:</source>
          <target state="translated">因此，在实践中，答案是如此明显： &lt;strong&gt;如有疑问，请避免使用指针&lt;/strong&gt; 。 仅当出于非常明显的理由没有其他更合适的理由时才需要使用指针。 除了上面提到的一些例外情况外，此类选择几乎总是不完全是特定于C ++的（但可能是特定于语言实现的）。 这样的实例可以是：</target>
        </trans-unit>
        <trans-unit id="fcf6411c0b226a9fd5b245400b86fb65e325be87" translate="yes" xml:space="preserve">
          <source>Some argue that this is such a useful feature when reading code, that pointer parameters should always be used for modifiable parameters rather than non-&lt;code&gt;const&lt;/code&gt; references, even if the function never expects a &lt;code&gt;nullptr&lt;/code&gt;. That is, those people argue that function signatures like &lt;code&gt;fn3()&lt;/code&gt; above should not be allowed. &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;Google's C++ style guidelines&lt;/a&gt; are an example of this.</source>
          <target state="translated">有人认为这是读取代码时非常有用的功能，即使函数从不希望使用 &lt;code&gt;nullptr&lt;/code&gt; ，也应该始终将指针参数用于可修改的参数，而不是非 &lt;code&gt;const&lt;/code&gt; 引用。 也就是说，那些人认为不应使用上面的函数签名，例如 &lt;code&gt;fn3()&lt;/code&gt; 。 &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;Google的C ++风格指南&lt;/a&gt;就是一个例子。</target>
        </trans-unit>
        <trans-unit id="4060e9b242b8df1a2b956d0e250e637eee184ce4" translate="yes" xml:space="preserve">
          <source>Sometimes the language rules explicitly require specific types to be used. If you want to use these features, obey the rules.</source>
          <target state="translated">有时,语言规则明确要求使用特定的类型。如果你想使用这些功能,请遵守规则。</target>
        </trans-unit>
        <trans-unit id="5fc11392b922636b6dc568f4ab0eb7cfb144157b" translate="yes" xml:space="preserve">
          <source>Special rules on &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; parameters (as the &quot;forwarding references&quot;) based on reference collapsing during template parameter deduction allow &lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;&quot;perfect forwarding&quot;&lt;/a&gt; of parameters.</source>
          <target state="translated">基于模板参数推导过程中参考折叠的关于 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 参数的特殊规则（称为&amp;ldquo;转发参考&amp;rdquo;）允许参数&lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;&amp;ldquo;完美转发&amp;rdquo;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7e7e6a0d10546a8f3514b41d4f9f797c475d3c2" translate="yes" xml:space="preserve">
          <source>Specific language-interoperation routines require pointers, like &lt;code&gt;operator new&lt;/code&gt;. (However, &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;void*&lt;/code&gt; is still quite different and safer compared to the ordinary object pointers because it rules out unexpected pointer arithmetics unless you are relying on some non conforming extension on &lt;code&gt;void*&lt;/code&gt; like GNU's.)</source>
          <target state="translated">特定的语言互操作例程需要指针，例如 &lt;code&gt;operator new&lt;/code&gt; 。 （但是，与普通对象指针相比， &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;void*&lt;/code&gt; 还是有很大不同和更安全的，因为除非您依靠像GNU那样对 &lt;code&gt;void*&lt;/code&gt; 某些非标准扩展，否则它可以排除意外的指针算术。）</target>
        </trans-unit>
        <trans-unit id="918eaf9f6cafcfdb9b382a8fa017353bbc7f79e9" translate="yes" xml:space="preserve">
          <source>Specific overloads of operators require reference or non reference types. For example:</source>
          <target state="translated">操作符的特定超载需要引用或非引用类型。例如:</target>
        </trans-unit>
        <trans-unit id="9e092dda4f0e27d0c7686ddd00272079e678b6e6" translate="yes" xml:space="preserve">
          <source>Storage</source>
          <target state="translated">Storage</target>
        </trans-unit>
        <trans-unit id="f6ceae4e1810d086bda09a8ac74e9e1fae98d4f4" translate="yes" xml:space="preserve">
          <source>Syntactic sugar</source>
          <target state="translated">句法糖</target>
        </trans-unit>
        <trans-unit id="178786d5b288287aa798248ecdf5fc27cc41e4ba" translate="yes" xml:space="preserve">
          <source>Technically this is an &lt;strong&gt;invalid reference&lt;/strong&gt;, not a null reference.  C++ doesn't support null references as a concept as you might find in other languages.  There are other kinds of invalid references as well. &lt;em&gt;Any&lt;/em&gt; invalid reference raises the spectre of &lt;strong&gt;undefined behavior&lt;/strong&gt;, just as using an invalid pointer would.</source>
          <target state="translated">从技术上讲，这是&lt;strong&gt;无效引用&lt;/strong&gt; ，而不是null引用。 C ++不像其他语言那样支持将空引用作为概念。 还有其他种类的无效引用。 &lt;em&gt;任何&lt;/em&gt;无效的引用都会引起&lt;strong&gt;未定义行为的影响&lt;/strong&gt; ，就像使用无效指针一样。</target>
        </trans-unit>
        <trans-unit id="19d85e5f25c953dc491251669b1a186b567d0b30" translate="yes" xml:space="preserve">
          <source>Technically, this is plain wrong. References are not syntactic sugar of any other features in C++, because they cannot be exactly replaced by other features without any semantic differences.</source>
          <target state="translated">从技术上讲,这显然是错误的。引用不是C++中任何其他特征的语法糖,因为它们不可能完全被其他特征所取代,没有任何语义上的差异。</target>
        </trans-unit>
        <trans-unit id="e1271990b0fbf017a0baa7180d4771ca7fef2cb9" translate="yes" xml:space="preserve">
          <source>Templates that cover both &lt;code&gt;T&amp;amp;&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are even more common.</source>
          <target state="translated">涵盖 &lt;code&gt;T&amp;amp;&lt;/code&gt; 和 &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; 模板甚至更常见。</target>
        </trans-unit>
        <trans-unit id="cc2d982b9a391ad561f42bfa61ab554d2658e9c3" translate="yes" xml:space="preserve">
          <source>The actual error is in the dereferencing of the NULL pointer, prior to the assignment to a reference.  But I'm not aware of any compilers that will generate any errors on that condition - the error propagates to a point further along in the code. That's what makes this problem so insidious. Most of the time, if you dereference a NULL pointer, you crash right at that spot and it doesn't take much debugging to figure it out.</source>
          <target state="translated">实际的错误是在NULL指针的去引用中,在分配到引用之前。但我不知道有任何编译器会在这个条件下产生错误--错误会传播到代码中更远的地方。这就是为什么这个问题如此阴险的原因。大多数时候,如果你对一个NULL指针进行去掉引用,你就会在这个点上崩溃,而且不需要太多的调试就能解决这个问题。</target>
        </trans-unit>
        <trans-unit id="36dcbb0fd485c966a6a8597e14838d2a77d340f3" translate="yes" xml:space="preserve">
          <source>The behavior is the same; only now it is much harder to prove that maybeModify does not ever modify array[1], because we already gave it a pointer; the cat is out of the bag. Now it has to do the much more difficult proof: a static analysis of maybeModify to prove it never writes to &amp;amp;x + 1. It also has to prove that it never saves off a pointer that can refer to array[0], which is just as tricky.</source>
          <target state="translated">行为是相同的。 只是现在很难证明，也许Modify永远不会修改array [1]，因为我们已经给了它一个指针。 猫从书包里拿出来了。 现在，它必须做更加困难的证明：对maykModify的静态分析，以证明它永远不会写入＆x +1。它还必须证明，它永远不会保存可以引用array [0]的指针。一样棘手。</target>
        </trans-unit>
        <trans-unit id="55c25474b6bbe811c3fff5d37fe3196ddf92b362" translate="yes" xml:space="preserve">
          <source>The default flavor uses the 'bind const reference to a temporary' aspect of references.</source>
          <target state="translated">默认的味道使用了 &quot;绑定 const 引用到临时 &quot;方面的引用。</target>
        </trans-unit>
        <trans-unit id="eeffd6f2cd40ebbc994170a79516a76d384f1862" translate="yes" xml:space="preserve">
          <source>The difference is that non-constant pointer variable(not to be confused with a pointer to constant) may be changed at some time during program execution, requires pointer semantics to be used(&amp;amp;,*) operators, while references can be set upon initialization only(that's why you can set them in constructor initializer list only, but not somehow else) and use ordinary value accessing semantics.  Basically references were introduced to allow support for operators overloading as I had read in some very old book. As somebody stated in this thread - pointer can be set to 0 or whatever value you want. 0(NULL, nullptr) means that the pointer is initialized with nothing. It is an error to dereference null pointer. But actually the pointer may contain a value that doesn't point to some correct memory location. References in their turn try not to allow a user to initialize a reference to something that cannot be referenced due to the fact that you always provide rvalue of correct type to it. Although there are a lot of ways to make reference variable be initialized to a wrong memory location - it is better for you not to dig this deep into details. On machine level both pointer and reference work uniformly - via pointers. Let's say in essential references are syntactic sugar. rvalue references are different to this - they are naturally stack/heap objects.</source>
          <target state="translated">不同之处在于，非常数指针变量（不要与指向常量的指针混淆）可以在程序执行期间的某个时间更改，需要使用指针语义（＆，*）运算符，而引用可以在初始化时设置仅（这就是为什么您只能在构造函数初始值设定项列表中设置它们，而不能以其他方式设置它们）并使用普通的值访问语义。 基本上引入了引用，以支持操作员重载，就像我在一本非常古老的书中所读到的那样。 正如该线程中有人指出的那样-指针可以设置为0或任何您想要的值。 0（NULL，nullptr）表示指针不进行任何初始化。 取消引用空指针是错误的。 但是实际上指针可能包含一个不指向某个正确内存位置的值。 反过来，引用又试图不允许用户初始化对无法引用的内容的引用，因为您总是向其提供正确类型的右值。 尽管有很多方法可以将引用变量初始化为错误的内存位置-最好不要将其深入了解细节。 在机器级别，指针和引用均通过指针统一工作。 假设在必不可少的参考文献中是句法糖。 右值引用与此不同-它们自然是堆栈/堆对象。</target>
        </trans-unit>
        <trans-unit id="21383718ed633934236239e24d6297c4ae1335ed" translate="yes" xml:space="preserve">
          <source>The differences of the top-level categories can already reveal many concrete differences not tied to pointers directly:</source>
          <target state="translated">从顶层分类的差异中,已经可以看出许多没有直接绑定到指针的具体差异。</target>
        </trans-unit>
        <trans-unit id="819bfb5a2d2e6000333b076e5df05cfd8d7b2a13" translate="yes" xml:space="preserve">
          <source>The direct answer</source>
          <target state="translated">直接的答案是</target>
        </trans-unit>
        <trans-unit id="f88d1a0da318f485205557f1a4a4b91d6c82b7a4" translate="yes" xml:space="preserve">
          <source>The misconceptions</source>
          <target state="translated">误解</target>
        </trans-unit>
        <trans-unit id="7d2603e75f0c55eb2703c92e74f015d2c67447b5" translate="yes" xml:space="preserve">
          <source>The only exceptions cannot be worked around in the current language:</source>
          <target state="translated">唯一的例外情况,在目前的语言中是无法绕开的。</target>
        </trans-unit>
        <trans-unit id="122da8393156782721cf3629f6cd6821668afecf" translate="yes" xml:space="preserve">
          <source>The only major rule that's important to remember with references is that they must be defined at the time of declaration (with the exception of a reference in a header, in that case it must be defined in the constructor, after the object it's contained in is constructed it's too late to define it).</source>
          <target state="translated">对于引用,唯一需要记住的主要规则是,必须在声明时定义它们(头中的引用除外,在这种情况下,它必须在构造函数中定义,当它所包含的对象被构造后,再定义它就太晚了)。</target>
        </trans-unit>
        <trans-unit id="418b62106b171f039b854dbd9df45e23828dfba0" translate="yes" xml:space="preserve">
          <source>The proper way to stay out of trouble is to avoid dereferencing a NULL pointer to create a reference. Here's an automated way to accomplish this.</source>
          <target state="translated">正确的方法是避免去引用NULL指针来创建引用。这里有一个自动完成的方法。</target>
        </trans-unit>
        <trans-unit id="5873330b5c7abf6ca602c30f272bd7c50e0cbb63" translate="yes" xml:space="preserve">
          <source>The statement above is simply wrong. To avoid such misconceptions, look at the ISO C++ rules instead:</source>
          <target state="translated">上面的说法完全是错误的。为了避免这种误解,不妨反过来看一下ISO C++规则。</target>
        </trans-unit>
        <trans-unit id="163a6b49bbef328a902a3d1fe72ca7563153d744" translate="yes" xml:space="preserve">
          <source>There can still be some common properties among references in different programming languages in general, but let's leave it for some other questions in SO.</source>
          <target state="translated">一般来说,不同的编程语言中的引用之间还是可以有一些共性的,但是在SO中的一些其他问题就不说了。</target>
        </trans-unit>
        <trans-unit id="e317f9f1b18599441d13052e85296dbd4035b47d" translate="yes" xml:space="preserve">
          <source>There is a semantic difference that may appear esoteric if you are not familiar with studying computer languages in an abstract or even academic fashion.</source>
          <target state="translated">如果你对计算机语言的研究不熟悉,甚至是学术性地研究计算机语言,可能会有语义上的差异,这可能会显得深奥。</target>
        </trans-unit>
        <trans-unit id="49c3ed839f4ba592814145e1ee7dccb652641c97" translate="yes" xml:space="preserve">
          <source>There is a very important non-technical difference between pointers and references: An argument passed to a function by pointer is much more visible than an argument passed to a function by non-const reference. For example:</source>
          <target state="translated">指针和引用之间有一个非常重要的非技术性的区别。通过指针传递给函数的参数比通过非const引用传递给函数的参数要明显得多。比如说。</target>
        </trans-unit>
        <trans-unit id="44e93f1f5f0ace9a170cb0b7222ca3b3580dffcb" translate="yes" xml:space="preserve">
          <source>There is one fundamental difference between pointers and references that I didn't see anyone had mentioned: references enable pass-by-reference semantics in function arguments. Pointers, although it is not visible at first do not: they only provide pass-by-value semantics. This has been very nicely described in &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">指针和引用之间有一个根本的区别，我没有看到有人提到过：引用在函数参数中启用了按引用传递语义。 指针虽然一开始不可见，但它却没有：它们仅提供按值传递语义。 本文对此进行了很好的描述。</target>
        </trans-unit>
        <trans-unit id="5066abc2ae8da58f9f9bb296820d74fa0f7a48b1" translate="yes" xml:space="preserve">
          <source>Therefore a reference IS a pointer under the hood, they both are just storing a memory address, where the address is pointing to is irrelevant, what do you think would happen if I called std::cout &amp;lt;&amp;lt; str_ref; AFTER calling delete &amp;amp;str_ref? Well, obviously it compiles fine, but causes a segmentation fault at runtime because it's no longer pointing at a valid variable, we essentially have a broken reference that still exists (until it falls out of scope), but is useless.</source>
          <target state="translated">因此，引用是一个隐藏的指针，它们都只是存储一个内存地址，该地址指向的地址是无关紧要的，如果我调用std :: cout &amp;lt;&amp;lt; str_ref;会发生什么呢？ 调用delete＆str_ref之后？ 好吧，显然它可以很好地编译，但是在运行时会导致分段错误，因为它不再指向有效变量，我们实质上有一个残破的引用仍然存在（直到它超出范围），但是没有用。</target>
        </trans-unit>
        <trans-unit id="94289fe5436213192f08bec365e448fa20dc244c" translate="yes" xml:space="preserve">
          <source>These points empower a considerable part of C++ and the standard library so this is quite a major property of references.</source>
          <target state="translated">这些点赋予了相当一部分C++和标准库的能力,所以这是相当大的引用属性。</target>
        </trans-unit>
        <trans-unit id="6a0c459929817549c904c8a94991b55621527e3f" translate="yes" xml:space="preserve">
          <source>This assignment changes ival, the value referenced by ri, and not the reference itself. After the assignment, the two references still refer to their original objects, and the value of those objects is now the same as well.</source>
          <target state="translated">这个赋值改变的是iival,即被ri引用的值,而不是引用本身。在赋值后,两个引用仍然是引用原来的对象,而这些对象的值现在也是一样的。</target>
        </trans-unit>
        <trans-unit id="bc577f672dad3e6a3a69c44737f3aacd3dd1eb12" translate="yes" xml:space="preserve">
          <source>This is based on the &lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;tutorial&lt;/a&gt;. What is written makes it more clear:</source>
          <target state="translated">这是基于&lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;教程的&lt;/a&gt; 。 所写的内容更加清楚：</target>
        </trans-unit>
        <trans-unit id="3ab66ed104cf4962c17c327aa4d19f6a70663d93" translate="yes" xml:space="preserve">
          <source>This is the language mechanism that allows ScopeGuard to work.</source>
          <target state="translated">这就是允许ScopeGuard工作的语言机制。</target>
        </trans-unit>
        <trans-unit id="5c9287077fd3860634cb823000e3c46b1b0d2646" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;const&amp;amp;&lt;/code&gt; safer for use in argument lists and so forth.</source>
          <target state="translated">这使得 &lt;code&gt;const&amp;amp;&lt;/code&gt; 更安全地用于参数列表等。</target>
        </trans-unit>
        <trans-unit id="d92fc23c843fd5c20781bced348b9700ad555c98" translate="yes" xml:space="preserve">
          <source>This program might help in comprehending the answer of the question. This is a simple program of a reference &quot;j&quot; and a pointer &quot;ptr&quot; pointing to variable &quot;x&quot;.</source>
          <target state="translated">这个程序可能有助于理解问题的答案。这是一个简单的程序,由一个引用 &quot;j &quot;和一个指向变量 &quot;x &quot;的指针 &quot;ptr &quot;组成。</target>
        </trans-unit>
        <trans-unit id="f6a17a077fe021118aa2ad5ab8e800b9c24900ac" translate="yes" xml:space="preserve">
          <source>This should permit the compiler to do more optimization on a reference.</source>
          <target state="translated">这应该允许编译器在参考文献上做更多的优化。</target>
        </trans-unit>
        <trans-unit id="2f3d837dc2b38c729da0192bc97e045c3a5109ca" translate="yes" xml:space="preserve">
          <source>To make such an optimization, it needs to prove that nothing can change array[1] during the call. This is rather easy to do. i is never less than 2, so array[i] can never refer to array[1]. maybeModify() is given a0 as a reference (aliasing array[0]). Because there is no &quot;reference&quot; arithmetic, the compiler just has to prove that maybeModify never gets the address of x, and it has proven that nothing changes array[1].</source>
          <target state="translated">要进行这样的优化,需要证明在调用过程中没有任何东西可以改变数组[1]。这相当容易做到。i永远不会小于2,所以数组[i]永远不能引用数组[1]。因为没有 &quot;引用 &quot;算术,所以编译器只需要证明 maybeModify永远不会得到x的地址,它已经证明了数组[1]没有任何变化。</target>
        </trans-unit>
        <trans-unit id="887be10c65852c56ff940b439c392da3426fe46c" translate="yes" xml:space="preserve">
          <source>Unlike the pointers, references are &lt;strong&gt;syntactically equivalent&lt;/strong&gt; to the object they refer to, i.e. any operation that can be applied to an object works for a reference, and with the exact same syntax (the exception is of course the initialization).</source>
          <target state="translated">与指针不同，引用在&lt;strong&gt;语法上等同&lt;/strong&gt;于它们引用的对象，即，可以应用于对象的任何操作都可以使用引用进行操作，并且语法完全相同（当然，初始化是例外）。</target>
        </trans-unit>
        <trans-unit id="82af8ce5dd45a624f7e3a05f611fa27d013254ef" translate="yes" xml:space="preserve">
          <source>Update: now that I think about it some more, there is an important difference.</source>
          <target state="translated">更新:现在多想了一下,有一个重要的区别。</target>
        </trans-unit>
        <trans-unit id="255286b845d43f2eb541ea059727b48d0df67a81" translate="yes" xml:space="preserve">
          <source>Variable of object types do occupy storage as per &lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;the abstract machine&lt;/a&gt; semantics. Reference do not necessary occupy storage (see the section about misconceptions below for details).</source>
          <target state="translated">&lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;根据抽象机器的&lt;/a&gt;语义，对象类型的变量确实会占用存储空间。 引用不必占用存储空间（有关详细信息，请参见下面有关误解的部分）。</target>
        </trans-unit>
        <trans-unit id="e955ffcb762ae563797df04ca22c14d80f8aa171" translate="yes" xml:space="preserve">
          <source>Visit the following for more information about reference to pointer:</source>
          <target state="translated">请访问以下内容,了解更多关于指针的参考信息。</target>
        </trans-unit>
        <trans-unit id="95919816eaf3c9d568884c2a1f7a85a8422fc08c" translate="yes" xml:space="preserve">
          <source>What are the differences between a pointer variable and a reference variable in C++</source>
          <target state="translated">C++中的指针变量和引用变量的区别是什么?</target>
        </trans-unit>
        <trans-unit id="ebf7dfac9cd8041f70cebb7841fd92ee7068ad0e" translate="yes" xml:space="preserve">
          <source>What is a pointer in C++? Some specific instance of type that &lt;strong&gt;is an object type&lt;/strong&gt;.</source>
          <target state="translated">C ++中的指针是什么？ 类型的某些特定实例&lt;strong&gt;是对象类型&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1713708129e2693fa553b3ca19fb86a7a27996c" translate="yes" xml:space="preserve">
          <source>What is a reference in C++? Some specific instance of type that &lt;strong&gt;is not an object type&lt;/strong&gt;.</source>
          <target state="translated">C ++中的参考是什么？ 类型的某些特定实例&lt;strong&gt;不是对象类型&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b27d4d26ba775faaca91cdf7c85e8f345955ab10" translate="yes" xml:space="preserve">
          <source>What's a C++ reference (&lt;em&gt;for C programmers&lt;/em&gt;)</source>
          <target state="translated">什么是C ++参考（ &lt;em&gt;适用于C程序员&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="f4957cb2344c8ba91faaeb20076eeeb6b30d45f2" translate="yes" xml:space="preserve">
          <source>What's more, as we can refer to almost any pointer tutorial, a pointer is an object that is supported by pointer arithmetic which makes pointer similar to an array.</source>
          <target state="translated">更重要的是,我们几乎可以参考所有的指针教程,指针是由指针算术支持的对象,这使得指针类似于数组。</target>
        </trans-unit>
        <trans-unit id="ec620abb83732edc34ab0a338ecb3e522947253f" translate="yes" xml:space="preserve">
          <source>When calling a function, the compiler usually generates memory spaces for the arguments to be copied to. The function signature defines the spaces that should be created and gives the name that should be used for these spaces. Declaring a parameter as a reference just tells the compiler to use the input variable memory space instead of allocating a new memory space during the method call. It may seem strange to say that your function will be directly manipulating a variable declared in the calling scope, but remember that when executing compiled code, there is no more scope; there is just plain flat memory, and your function code could manipulate any variables.</source>
          <target state="translated">当调用一个函数时,编译器通常会生成要复制到参数的内存空间。函数签名定义了应该创建的空间,并给出了这些空间应该使用的名称。声明一个参数作为引用,只是告诉编译器使用输入变量的内存空间,而不是在方法调用时分配一个新的内存空间。说你的函数将直接操纵调用作用域中声明的变量,这可能看起来很奇怪,但请记住,在执行编译后的代码时,没有更多的作用域;只有普通的平面内存,你的函数代码可以操纵任何变量。</target>
        </trans-unit>
        <trans-unit id="d4c1912265bdef87e12cb7b1321e31b984533bfe" translate="yes" xml:space="preserve">
          <source>When you are implementing smart pointers above, you may have to deal with raw pointers.</source>
          <target state="translated">当你在实现上面的智能指针时,你可能需要处理原始指针。</target>
        </trans-unit>
        <trans-unit id="1dfec36a318fd0d200d4cdbe5653e6d388ef8b86" translate="yes" xml:space="preserve">
          <source>When you create a reference, you only tell the compiler that you assign another name to the pointer variable; that's why references cannot &quot;point to null&quot;, because a variable cannot be, and not be.</source>
          <target state="translated">当你创建一个引用时,你只告诉编译器,你给指针变量分配了另一个名字;这就是为什么引用不能 &quot;指向null &quot;的原因,因为一个变量不能,也不能是,也不能是。</target>
        </trans-unit>
        <trans-unit id="c777e0e0107a7f50f79668993af249ac372a560e" translate="yes" xml:space="preserve">
          <source>Which outputs this:</source>
          <target state="translated">其中输出这个。</target>
        </trans-unit>
        <trans-unit id="c5cc6c3d8c26b226ed34902de7cac9e3a05e8f30" translate="yes" xml:space="preserve">
          <source>While both references and pointers are used to indirectly access another value, there are two important differences between references and pointers. The first is that a reference always refers to an object: It is an error to define a reference without initializing it. The behavior of assignment is the second important difference: Assigning to a reference changes the object to which the reference is bound; it does not rebind the reference to another object. Once initialized, a reference always refers to the same underlying object.</source>
          <target state="translated">虽然引用和指针都是用来间接访问另一个值,但引用和指针之间有两个重要的区别。首先是引用总是指向一个对象。如果不对引用进行初始化就定义一个引用是错误的。指派的行为是第二个重要的区别。向引用赋值会改变引用被绑定的对象;它不会将引用重新绑定到另一个对象。一旦初始化,引用总是指的是同一个底层对象。</target>
        </trans-unit>
        <trans-unit id="33026a6390ada498b7595f79ab2136f07ff3040a" translate="yes" xml:space="preserve">
          <source>While this may appear superficial, I believe this property is crucial for a number of C++ features, for example:</source>
          <target state="translated">虽然这可能看起来很肤浅,但我认为这个属性对于很多C++特性来说是至关重要的,比如说。</target>
        </trans-unit>
        <trans-unit id="a48d4180c32fc6ba76e32c1184f3989050537522" translate="yes" xml:space="preserve">
          <source>Why I consider C++ references useful</source>
          <target state="translated">为什么我认为C++参考文献有用</target>
        </trans-unit>
        <trans-unit id="a139f82cb75f5fa1d088932ad6ca62c1a9ed365b" translate="yes" xml:space="preserve">
          <source>You can do arithmetic on a pointer.
For example, &lt;code&gt;p += offset;&lt;/code&gt;</source>
          <target state="translated">您可以对指针进行算术运算。 例如， &lt;code&gt;p += offset;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34780a25d9c2fa6caeb26ac54a01416129ecb662" translate="yes" xml:space="preserve">
          <source>You can have pointers to pointers to pointers offering extra levels of indirection.  Whereas references only offer one level of indirection.</source>
          <target state="translated">你可以让指针到指针提供额外的隐含层。而引用只提供了一个层次的隐性。</target>
        </trans-unit>
        <trans-unit id="ca281bbb0f05d2038a489cb7276fce90296f6044" translate="yes" xml:space="preserve">
          <source>You forgot the most important part:</source>
          <target state="translated">你忘了最重要的部分。</target>
        </trans-unit>
        <trans-unit id="5b379fd4bb44eb684d6e0614512cecb190c0230a" translate="yes" xml:space="preserve">
          <source>You have to avoid symbol bloat in some extreme cases.</source>
          <target state="translated">在一些极端情况下,你必须避免符号臃肿。</target>
        </trans-unit>
        <trans-unit id="94dc5492065b8158897a90145f93ab59e74f01ca" translate="yes" xml:space="preserve">
          <source>You have to improve efficiency of the translation (compilation &amp;amp; linking) in some extreme cases.</source>
          <target state="translated">在某些极端情况下，您必须提高翻译（编译和链接）的效率。</target>
        </trans-unit>
        <trans-unit id="560512056d46b11c084b62f89a3e5fff348a21e2" translate="yes" xml:space="preserve">
          <source>You have to interoperate at runtime with different language implementations (including various assemblies, language runtime and FFI of some high-level client languages) based on assumptions of specific implementations.</source>
          <target state="translated">你必须在运行时与不同的语言实现(包括各种汇编、语言运行时和一些高级客户端语言的FFI)基于特定的实现假设进行互操作。</target>
        </trans-unit>
        <trans-unit id="92de6dbe192f694e5996d57ccfe447310dfd3ab8" translate="yes" xml:space="preserve">
          <source>You have to meet the ABI requirements of specific C++ implementations.</source>
          <target state="translated">你必须满足特定C++实现的ABI要求。</target>
        </trans-unit>
        <trans-unit id="184df4e9e98867001ef0b20404d00c507b584e37" translate="yes" xml:space="preserve">
          <source>You have to serve to old-style (C) APIs.</source>
          <target state="translated">你必须服务于旧式(C)API。</target>
        </trans-unit>
        <trans-unit id="d5c7ab9829b48d10733475f6a32872b8d1dde9fe" translate="yes" xml:space="preserve">
          <source>in simple words, we can say a reference is an alternative name for a variable whereas,
a pointer is a variable that holds the address of another variable.
e.g.</source>
          <target state="translated">简而言之,我们可以说引用是一个变量的替代名称,而指针是一个变量,它持有另一个变量的地址。</target>
        </trans-unit>
        <trans-unit id="344723f5f4518fc02c77a821b777b5e5ef5b14c7" translate="yes" xml:space="preserve">
          <source>member-access with pointers uses &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">具有指针的成员访问使用 &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a520836c5bc91e48d3c9612930f910ee19298599" translate="yes" xml:space="preserve">
          <source>member-access with references uses &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">具有引用的member-access使用 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6cd4d114dbfaf6a41f6a22c17b7940a2cd45fe06" translate="yes" xml:space="preserve">
          <source>will print:</source>
          <target state="translated">将打印。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
