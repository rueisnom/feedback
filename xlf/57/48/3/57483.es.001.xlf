<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/57483">
    <body>
      <group id="57483">
        <trans-unit id="366a1392d254b91c2979dbb347d6a6006020e4a8" translate="yes" xml:space="preserve">
          <source>(A side note: the question may be significant earlier than any &quot;C-like&quot; languages are involved, like &lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;ALGOL 68 vs. PL/I&lt;/a&gt;.)</source>
          <target state="translated">(Una nota al margen: la pregunta puede ser significativa antes de que est&amp;eacute;n involucrados los lenguajes &quot;tipo C&quot;, como &lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;ALGOL 68 vs. PL / I&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c2cc5a14dd2d409d181bc8d16bec43175ff2ec5" translate="yes" xml:space="preserve">
          <source>(Similarly, &lt;em&gt;lambda-expression&lt;/em&gt;s are &lt;em&gt;not&lt;/em&gt; syntactic sugar of any other features in C++ because it cannot be precisely simulated with &quot;unspecified&quot; properties like &lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;the declaration order of the captured variables&lt;/a&gt;, which may be important because the initialization order of such variables can be significant.)</source>
          <target state="translated">(Del mismo modo, &lt;em&gt;las expresiones lambda&lt;/em&gt; &lt;em&gt;no&lt;/em&gt; son az&amp;uacute;car sint&amp;aacute;ctica de ninguna otra caracter&amp;iacute;stica en C ++ porque no se pueden simular con precisi&amp;oacute;n con propiedades &quot;no especificadas&quot; como &lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;el orden de declaraci&amp;oacute;n de las variables capturadas&lt;/a&gt; , lo que puede ser importante porque el orden de inicializaci&amp;oacute;n de tales variables puede ser significativo.)</target>
        </trans-unit>
        <trans-unit id="1f3d6284e82153785e1a110247b2169240f95d81" translate="yes" xml:space="preserve">
          <source>(or &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; which still relies on an implicit cast
to &lt;code&gt;T&amp;amp;&lt;/code&gt;)</source>
          <target state="translated">(o &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; que todav&amp;iacute;a se basa en una conversi&amp;oacute;n impl&amp;iacute;cita a &lt;code&gt;T&amp;amp;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="eb9fd6a3244bc886192add4286c3f4e955b01e2c" translate="yes" xml:space="preserve">
          <source>... An object occupies a region of storage in its period of construction, throughout its lifetime, and in its period of destruction. ...</source>
          <target state="translated">...Un objeto ocupa una región de almacenamiento en su período de construcción,a lo largo de su vida,y en su período de destrucción....</target>
        </trans-unit>
        <trans-unit id="aedfef1b56582c6d5ac761f02dc136e601d184b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias_Tom&lt;/code&gt; can be understood as an &lt;code&gt;alias of a variable&lt;/code&gt; (different with &lt;code&gt;typedef&lt;/code&gt;, which is &lt;code&gt;alias of a type&lt;/code&gt;) &lt;code&gt;Tom&lt;/code&gt;. It is also OK to forget the terminology of such statement is to create a reference of &lt;code&gt;Tom&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alias_Tom&lt;/code&gt; puede entenderse como un &lt;code&gt;alias of a variable&lt;/code&gt; (diferente con &lt;code&gt;typedef&lt;/code&gt; , que es un &lt;code&gt;alias of a type&lt;/code&gt; ) &lt;code&gt;Tom&lt;/code&gt; . Tambi&amp;eacute;n est&amp;aacute; bien olvidar que la terminolog&amp;iacute;a de dicha declaraci&amp;oacute;n es crear una referencia de &lt;code&gt;Tom&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a7b84169fee1ce093f438b076f5fe4d63635e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo.bar&lt;/code&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; in the same way that &lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs&lt;/a&gt; :-)</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; es &lt;em&gt;claramente&lt;/em&gt; superior a &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; de la misma manera que &lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt; es &lt;em&gt;claramente&lt;/em&gt; superior a &lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs&lt;/a&gt; :-)</target>
        </trans-unit>
        <trans-unit id="53a62ec44b159bf24f77f722d3f80606a21a3355" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C++: Reference to Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C ++: referencia al puntero&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8503c60ec396a2706a5881136f438f315e36942e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;Pointer-to-Pointer and Reference-to-Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;Puntero a puntero y referencia a puntero&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="48e4529752dcdcff6551309a435706e66b4247e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Copy constructors&lt;/em&gt;. Syntactically it makes sense to pass objects to copy constructors, and not pointers to objects. But there is just no way for a copy constructor to take an object by value - it would result in a recursive call to the same copy constructor. This leaves references as the only option here.</source>
          <target state="translated">&lt;em&gt;Copiar constructores&lt;/em&gt; . Sint&amp;aacute;cticamente tiene sentido pasar objetos para copiar constructores, y no punteros a objetos. Pero simplemente no hay forma de que un constructor de copia tome un objeto por valor: dar&amp;iacute;a lugar a una llamada recursiva al mismo constructor de copia. Esto deja referencias como la &amp;uacute;nica opci&amp;oacute;n aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="5429e39b4353f38912f315f0cc3b02247f3caa2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lvalues&lt;/em&gt;. Consider the statement &lt;code&gt;str[0] = 'X';&lt;/code&gt; Without references it would only work for c-strings (&lt;code&gt;char* str&lt;/code&gt;). Returning the character by reference allows user-defined classes to have the same notation.</source>
          <target state="translated">&lt;em&gt;Lvalues&lt;/em&gt; Considere la declaraci&amp;oacute;n &lt;code&gt;str[0] = 'X';&lt;/code&gt; Sin referencias, solo funcionar&amp;iacute;a para cadenas c ( &lt;code&gt;char* str&lt;/code&gt; ). Devolver el car&amp;aacute;cter por referencia permite que las clases definidas por el usuario tengan la misma notaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a6bbf825dc87806d5d7ecc42e1a033d722c63bd0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Operator overloads&lt;/em&gt;. With references it is possible to introduce indirection to an operator call - say, &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; while retaining the same infix notation. This also works for regular overloaded functions.</source>
          <target state="translated">&lt;em&gt;Sobrecargas del operador&lt;/em&gt; . Con referencias, es posible introducir indirecci&amp;oacute;n a una llamada de operador, por ejemplo, &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; mientras se conserva la misma notaci&amp;oacute;n infija. Esto tambi&amp;eacute;n funciona para funciones sobrecargadas regulares.</target>
        </trans-unit>
        <trans-unit id="59d32a7fbc66b86330c68b00f7b2998e9416fddd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Templates&lt;/em&gt;. Since template parameters are duck-typed, syntactic properties of a type is all that matters, so often the same template can be used with both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Plantillas&lt;/em&gt; Dado que los par&amp;aacute;metros de la plantilla son de tipo pato, las propiedades sint&amp;aacute;cticas de un tipo son lo &amp;uacute;nico que importa, por lo que a menudo se puede usar la misma plantilla con &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;T&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5cd9611e4f3bbd50027970fffa4f1f1bd8dbc48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;So, a pointer and a reference both use the same amount of memory.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Entonces, un puntero y una referencia usan la misma cantidad de memoria.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6b3894bff8b5c460864e665b4235fd4094d8df4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remember, my examples above are just that, examples demonstrating what a reference is, you would never want to use a reference in those ways! For proper usage of a reference there are plenty of answers on here already that hit the nail on the head&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Recuerde, mis ejemplos anteriores son solo eso, ejemplos que demuestran lo que es una referencia, &amp;iexcl;nunca querr&amp;aacute; usar una referencia de esa manera!&lt;/strong&gt; &lt;strong&gt;Para el uso adecuado de una referencia, ya hay muchas respuestas aqu&amp;iacute; que dan en el clavo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6654cb2acb8b91a57f09603862f530ef72caa5eb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reference&lt;/em&gt; can be thought of as a &lt;em&gt;constant pointer&lt;/em&gt; (not to be confused with a pointer to a constant value!) with automatic indirection, ie the compiler will apply the &lt;code&gt;*&lt;/code&gt; operator for you.</source>
          <target state="translated">Una &lt;em&gt;referencia&lt;/em&gt; puede considerarse como un &lt;em&gt;puntero constante&lt;/em&gt; (&amp;iexcl;no debe confundirse con un puntero a un valor constante!) Con indirecci&amp;oacute;n autom&amp;aacute;tica, es decir, el compilador aplicar&amp;aacute; el operador &lt;code&gt;*&lt;/code&gt; por usted.</target>
        </trans-unit>
        <trans-unit id="36e44be1b0929668f83744e378c80d1a24783473" translate="yes" xml:space="preserve">
          <source>A compiler keeps &quot;references&quot; to variables, associating a name with a memory address; that's its job to translate any variable name to a memory address when compiling.</source>
          <target state="translated">Un compilador mantiene &quot;referencias&quot; a las variables,asociando un nombre a una dirección de memoria;ese es su trabajo para traducir cualquier nombre de variable a una dirección de memoria al compilar.</target>
        </trans-unit>
        <trans-unit id="959270cda595c9f1ce741e1f2ab621476334d43d" translate="yes" xml:space="preserve">
          <source>A const pointer's target can be replaced by taking its address and using a const cast.</source>
          <target state="translated">El objetivo de un puntero constante puede ser reemplazado tomando su dirección y usando un molde constante.</target>
        </trans-unit>
        <trans-unit id="d4063e6d466457440be12f195a44c703d4bcd7c2" translate="yes" xml:space="preserve">
          <source>A few more special rules on references:</source>
          <target state="translated">Unas cuantas reglas especiales más sobre las referencias:</target>
        </trans-unit>
        <trans-unit id="1b35409877b7144ea91c809ff4d316184f00d741" translate="yes" xml:space="preserve">
          <source>A pointer can be initialized to 0 and a reference not. In fact, a reference must also refer to an object, but a pointer can be the null pointer:</source>
          <target state="translated">Un puntero puede ser inicializado a 0 y una referencia no.De hecho,una referencia también debe referirse a un objeto,pero un puntero puede ser el puntero nulo:</target>
        </trans-unit>
        <trans-unit id="eb1a8b8982766e580a85ab0d0eb62a2e311e86ba" translate="yes" xml:space="preserve">
          <source>A pointer can be re-assigned:</source>
          <target state="translated">Un puntero puede ser reasignado:</target>
        </trans-unit>
        <trans-unit id="5dcd9a2027d394eca47f36591f61027051772bca" translate="yes" xml:space="preserve">
          <source>A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.  Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable.  Note: What a pointer points to can be on the stack or heap.  Ditto a reference. My claim in this statement is not that a pointer must point to the stack.  A pointer is just a variable that holds a memory address.  This variable is on the stack.  Since a reference has its own space on the stack, and since the address is the same as the variable it references.  More on &lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;stack vs heap&lt;/a&gt;.  This implies that there is a real address of a reference that the compiler will not tell you.</source>
          <target state="translated">Un puntero tiene su propia direcci&amp;oacute;n y tama&amp;ntilde;o de memoria en la pila (4 bytes en x86), mientras que una referencia comparte la misma direcci&amp;oacute;n de memoria (con la variable original) pero tambi&amp;eacute;n ocupa algo de espacio en la pila. Como una referencia tiene la misma direcci&amp;oacute;n que la variable original, es seguro pensar en una referencia como otro nombre para la misma variable. Nota: Lo que apunta un puntero puede estar en la pila o en el mont&amp;oacute;n. Lo mismo una referencia. Mi afirmaci&amp;oacute;n en esta declaraci&amp;oacute;n no es que un puntero debe apuntar a la pila. Un puntero es solo una variable que contiene una direcci&amp;oacute;n de memoria. Esta variable est&amp;aacute; en la pila. Dado que una referencia tiene su propio espacio en la pila, y dado que la direcci&amp;oacute;n es la misma que la variable a la que hace referencia. M&amp;aacute;s sobre &lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;stack vs mont&amp;oacute;n&lt;/a&gt; . Esto implica que hay una direcci&amp;oacute;n real de una referencia que el compilador no le dir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="fd455ef49a557a536ce9186591eed75410f73093" translate="yes" xml:space="preserve">
          <source>A pointer needs to be dereferenced with &lt;code&gt;*&lt;/code&gt; to access the memory location it points to, whereas a reference can be used directly.  A pointer to a class/struct uses &lt;code&gt;-&amp;gt;&lt;/code&gt; to access it's members whereas a reference uses a &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">Se debe desreferenciar un puntero con &lt;code&gt;*&lt;/code&gt; para acceder a la ubicaci&amp;oacute;n de memoria a la que apunta, mientras que una referencia se puede usar directamente. Un puntero a una clase / estructura usa &lt;code&gt;-&amp;gt;&lt;/code&gt; para acceder a sus miembros, mientras que una referencia usa a &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d9e2dd57673143f5ecc15f3125a1e7c15d2ff7a" translate="yes" xml:space="preserve">
          <source>A pointer requires the location of a piece of space on screen that you assure it will contain zero or more instances of that window type.</source>
          <target state="translated">Un puntero requiere la ubicación de un trozo de espacio en la pantalla que asegure que contendrá cero o más instancias de ese tipo de ventana.</target>
        </trans-unit>
        <trans-unit id="01435a266fb491eeeb93f2b49ededf5562a78098" translate="yes" xml:space="preserve">
          <source>A reference can never be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Una referencia nunca puede ser &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0db1497e17b4f2171e4c44bff76f09fecf03b574" translate="yes" xml:space="preserve">
          <source>A reference cannot, and must be assigned at initialization:</source>
          <target state="translated">Una referencia no puede y debe ser asignada en la inicialización:</target>
        </trans-unit>
        <trans-unit id="8de8f4c2eb87e4ad0059dd772dd0e8d9c15b2d0c" translate="yes" xml:space="preserve">
          <source>A reference is an alias for another variable whereas a pointer holds the memory address of a variable. References are generally used as function parameters so that the passed object is not the copy but the object itself.</source>
          <target state="translated">Una referencia es un alias para otra variable,mientras que un puntero contiene la dirección de memoria de una variable.Las referencias se utilizan generalmente como parámetros de función,de modo que el objeto pasado no es la copia sino el objeto mismo.</target>
        </trans-unit>
        <trans-unit id="3fc4f36217977d4385453e9d1605a1d3c9c91d83" translate="yes" xml:space="preserve">
          <source>A reference is not another name given to some memory. It's a immutable pointer that is automatically de-referenced on usage. Basically it boils down to:</source>
          <target state="translated">Una referencia no es otro nombre dado a algún recuerdo.Es un puntero inmutable que se desreferencia automáticamente al usarlo.Básicamente se reduce a:</target>
        </trans-unit>
        <trans-unit id="408fd2770a09c3097a4198b48fb7f80ff76674a3" translate="yes" xml:space="preserve">
          <source>A reference requires you to specify an actual window.</source>
          <target state="translated">Una referencia requiere que se especifique una ventana real.</target>
        </trans-unit>
        <trans-unit id="7a62bb0cc0b8710c81c16b83f6655a27f1f4f924" translate="yes" xml:space="preserve">
          <source>A reference to a pointer is possible in C++, but the reverse is not possible means a pointer to a reference isn't possible. A reference to a pointer provides a cleaner syntax to modify the pointer.
Look at this example:</source>
          <target state="translated">Una referencia a un puntero es posible en C++,pero lo contrario no es posible significa que un puntero a una referencia no es posible.Una referencia a un puntero proporciona una sintaxis más limpia para modificar el puntero.Mira este ejemplo:</target>
        </trans-unit>
        <trans-unit id="f9bf408f44a75a28c1f97df5e2c724d88eaec294" translate="yes" xml:space="preserve">
          <source>A reference's target cannot be replaced in any way short of UB.</source>
          <target state="translated">El objetivo de una referencia no puede ser reemplazado de ninguna manera menos que el LU.</target>
        </trans-unit>
        <trans-unit id="5355053294d8994c0ecb21bffdd545b0a989f529" translate="yes" xml:space="preserve">
          <source>Actually, a reference is not really like a pointer.</source>
          <target state="translated">En realidad,una referencia no es realmente como un puntero.</target>
        </trans-unit>
        <trans-unit id="e7cbf8356a1da6417d65167e6890b1ece5d79c47" translate="yes" xml:space="preserve">
          <source>After the assignment, ival, the object addressed by pi remains unchanged. The assignment changes the value of pi, making it point to a different object. Now consider a similar program that assigns two references:</source>
          <target state="translated">Después de la asignación,ival,el objeto dirigido por pi permanece sin cambios.La asignación cambia el valor de pi,haciendo que apunte a un objeto diferente.Ahora considere un programa similar que asigna dos referencias:</target>
        </trans-unit>
        <trans-unit id="789209b07ed91340d591d3ecbd391a25bb1a617e" translate="yes" xml:space="preserve">
          <source>All references must be initialized with a non-null value or compilation will fail. It's neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references.</source>
          <target state="translated">Todas las referencias deben ser inicializadas con un valor no nulo o la compilación fallará.No es posible obtener la dirección de una referencia-el operador de la dirección devolverá en su lugar la dirección del valor referido-ni es posible hacer aritmética sobre las referencias.</target>
        </trans-unit>
        <trans-unit id="4a0d598143cbd5c038eec18a5364ebca3ce06755" translate="yes" xml:space="preserve">
          <source>Also, a reference that is a parameter to a function that is inlined may be handled differently than a pointer.</source>
          <target state="translated">Además,una referencia que es un parámetro de una función que está en línea puede manejarse de manera diferente a un puntero.</target>
        </trans-unit>
        <trans-unit id="198270e21c92ca200586af9582ab1a26ef99e93d" translate="yes" xml:space="preserve">
          <source>Also, spare 10 minutes and watch this video: &lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;https://www.youtube.com/watch?v=rlJrrGV0iOg&lt;/a&gt;</source>
          <target state="translated">Adem&amp;aacute;s, dedica 10 minutos y mira este video: &lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;https://www.youtube.com/watch?v=rlJrrGV0iOg&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="def296e5debd47695d96a2e810d313523875ea0e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;object&lt;/em&gt; type is a (possibly &lt;em&gt;cv&lt;/em&gt;-qualified) type that is not a function type, not a reference type, and not &lt;em&gt;cv&lt;/em&gt; void.</source>
          <target state="translated">Un tipo de &lt;em&gt;objeto&lt;/em&gt; es un tipo (posiblemente calificado por &lt;em&gt;cv&lt;/em&gt; ) que no es un tipo de funci&amp;oacute;n, no es un tipo de referencia, y no es &lt;em&gt;cv&lt;/em&gt; void.</target>
        </trans-unit>
        <trans-unit id="aaa58e7db6a960dc51cd22c3dc1684dfd20f847c" translate="yes" xml:space="preserve">
          <source>An optimizing compiler may realize that we are accessing a[0] and a[1] quite a bunch. It would love to optimize the algorithm to:</source>
          <target state="translated">Un compilador de optimización puede darse cuenta de que estamos accediendo a un[0]y a un[1]bastante.Le encantaría optimizar el algoritmo para:</target>
        </trans-unit>
        <trans-unit id="a77f60581112f1094707329df4c6d30c6956a373" translate="yes" xml:space="preserve">
          <source>And consider the C version of the above program. In C you have to use pointer to pointer (multiple indirection), and it leads to confusion and the program may look complicated.</source>
          <target state="translated">Y considere la versión C del programa anterior.En C tienes que usar puntero a puntero (indirección múltiple),y esto lleva a confusión y el programa puede parecer complicado.</target>
        </trans-unit>
        <trans-unit id="ddb61be46c893264465a08b177ca023b9286da4f" translate="yes" xml:space="preserve">
          <source>Another difference is that pointer can point to another object however reference is always referencing to the same object, let&amp;rsquo;s take this example:</source>
          <target state="translated">Otra diferencia es que el puntero puede apuntar a otro objeto, sin embargo, la referencia siempre hace referencia al mismo objeto, tomemos este ejemplo:</target>
        </trans-unit>
        <trans-unit id="d9d2f372f903617152234f6054a59f4db746d3e3" translate="yes" xml:space="preserve">
          <source>Another difference is that you can have pointers to a void type (and it means pointer to anything) but references to void are forbidden.</source>
          <target state="translated">Otra diferencia es que se pueden tener punteros a un tipo de vacío (y significa puntero a cualquier cosa)pero las referencias al vacío están prohibidas.</target>
        </trans-unit>
        <trans-unit id="ed06ace0f97d6901e5c79ad444c40f4d371c03fa" translate="yes" xml:space="preserve">
          <source>Another important point is that is we can make the declaration of the pointer without initialization however no such thing can be done in case of reference which must make a reference always to variable or object. However such use of a pointer is risky so generally we check if the pointer is actually is pointing to something or not. In case of a reference no such check is necessary, because we know already that referencing to an object during declaration is mandatory.</source>
          <target state="translated">Otro punto importante es que se puede hacer la declaración del puntero sin inicialización,pero no se puede hacer en caso de referencia que debe hacer siempre referencia a la variable o al objeto.Sin embargo,tal uso de un puntero es arriesgado,por lo que generalmente comprobamos si el puntero está realmente apuntando a algo o no.En el caso de una referencia no es necesario hacer tal comprobación,porque ya sabemos que la referencia a un objeto durante la declaración es obligatoria.</target>
        </trans-unit>
        <trans-unit id="cab05ab1c2c0ef5b2ba43eff8ccf5c0c4d2d12e9" translate="yes" xml:space="preserve">
          <source>Another interesting use of references is to supply a default argument of a user-defined type:</source>
          <target state="translated">Otro uso interesante de las referencias es proporcionar un argumento por defecto de un tipo definido por el usuario:</target>
        </trans-unit>
        <trans-unit id="8405a7757378ccd741f1d45d9bcb524d4b5f3829" translate="yes" xml:space="preserve">
          <source>Another point: When we have a template like an STL template such kind of a class template will always return a reference, not a pointer, to make easy reading or assigning new value using operator []:</source>
          <target state="translated">Otro punto:Cuando tenemos una plantilla como una plantilla STL este tipo de plantilla de clase siempre devolverá una referencia,no un puntero,para facilitar la lectura o asignar un nuevo valor usando el operador []:</target>
        </trans-unit>
        <trans-unit id="8ae9e0a7b8d69bc4223ff39bbb83d311d51fca21" translate="yes" xml:space="preserve">
          <source>Apart from syntactic sugar, a reference is a &lt;code&gt;const&lt;/code&gt; pointer (&lt;em&gt;not&lt;/em&gt; pointer to a &lt;code&gt;const&lt;/code&gt;). You must establish what it refers to when you declare the reference variable, and you cannot change it later.</source>
          <target state="translated">Adem&amp;aacute;s del az&amp;uacute;car sint&amp;aacute;ctico, una referencia es un puntero &lt;code&gt;const&lt;/code&gt; ante ( &lt;em&gt;no un&lt;/em&gt; puntero a una &lt;code&gt;const&lt;/code&gt; ante ). Debe establecer a qu&amp;eacute; se refiere cuando declara la variable de referencia, y no puede cambiarla m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="8d8f44fcd3e6f397b6db8398ce3d44734a996ea7" translate="yes" xml:space="preserve">
          <source>As I said, a pointer to a reference isn't possible. Try the following program:</source>
          <target state="translated">Como dije,no es posible señalar una referencia.Pruebe el siguiente programa:</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">Como ejemplo:</target>
        </trans-unit>
        <trans-unit id="82db7c2ab0468c723d35542df3eb95e5e5ba8cad" translate="yes" xml:space="preserve">
          <source>At the highest-level, the idea of references is that they are transparent &quot;aliases&quot;. Your computer may use an address to make them work, but you're not supposed to worry about that: you're supposed to think of them as &quot;just another name&quot; for an existing object and the syntax reflects that. They are stricter than pointers so your compiler can more reliably warn you when you about to create a dangling reference, than when you are about to create a dangling pointer.</source>
          <target state="translated">En el nivel más alto,la idea de las referencias es que son &quot;alias&quot; transparentes.Su computadora puede usar una dirección para hacerlos funcionar,pero no debe preocuparse por eso:se supone que debe pensar en ellos como &quot;sólo otro nombre&quot; para un objeto existente y la sintaxis lo refleja.Son más estrictos que los punteros,por lo que su compilador puede advertirle con mayor fiabilidad cuando está a punto de crear una referencia colgante,que cuando está a punto de crear un puntero colgante.</target>
        </trans-unit>
        <trans-unit id="1c79f63a01a5e0dc422bfd0d4cf499645ee5ba60" translate="yes" xml:space="preserve">
          <source>At the risk of adding to confusion, I want to throw in some input, I'm sure it mostly depends on how the compiler implements references, but in the case of gcc the idea that a reference can only point to a variable on the stack is not actually correct, take this for example:</source>
          <target state="translated">A riesgo de añadir confusión,quiero añadir alguna entrada,estoy seguro de que depende sobre todo de cómo el compilador implemente las referencias,pero en el caso de gcc la idea de que una referencia sólo puede apuntar a una variable de la pila no es realmente correcta,tomemos esto como ejemplo:</target>
        </trans-unit>
        <trans-unit id="e6de6d55fd9e888c00be46ee2285966c7f90196b" translate="yes" xml:space="preserve">
          <source>BTW, a few other contexts like initialization involving &lt;code&gt;std::initializer_list&lt;/code&gt; follows some similar rules of reference lifetime extension. It is another can of worms.</source>
          <target state="translated">Por cierto, algunos otros contextos como la inicializaci&amp;oacute;n que involucra &lt;code&gt;std::initializer_list&lt;/code&gt; siguen algunas reglas similares de extensi&amp;oacute;n de vida &amp;uacute;til de referencia. Es otra lata de gusanos.</target>
        </trans-unit>
        <trans-unit id="28157cc4e97b442db1a423840eb02259f1ee9ada" translate="yes" xml:space="preserve">
          <source>Back in C, a call that looks like &lt;code&gt;fn(x)&lt;/code&gt; can only be passed by value, so it definitely cannot modify &lt;code&gt;x&lt;/code&gt;; to modify an argument you would need to pass a pointer &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt;. So if an argument wasn't preceded by an &lt;code&gt;&amp;amp;&lt;/code&gt; you knew it would not be modified. (The converse, &lt;code&gt;&amp;amp;&lt;/code&gt; means modified, was not true because you would sometimes have to pass large read-only structures by &lt;code&gt;const&lt;/code&gt; pointer.)</source>
          <target state="translated">De vuelta en C, una llamada que parece &lt;code&gt;fn(x)&lt;/code&gt; solo se puede pasar por valor, por lo que definitivamente no puede modificar &lt;code&gt;x&lt;/code&gt; ; para modificar un argumento necesitar&amp;iacute;a pasar un puntero &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt; . Entonces, si un argumento no fue precedido por un &lt;code&gt;&amp;amp;&lt;/code&gt; usted sab&amp;iacute;a que no ser&amp;iacute;a modificado. (Lo contrario, &lt;code&gt;&amp;amp;&lt;/code&gt; significa modificado, no era cierto porque a veces tendr&amp;iacute;as que pasar grandes estructuras de solo lectura por puntero &lt;code&gt;const&lt;/code&gt; ante ).</target>
        </trans-unit>
        <trans-unit id="52fbc9beddeb6a8c7a6bb62a43b5c950f4daeb34" translate="yes" xml:space="preserve">
          <source>Beyond that, there are of course some practical differences between pointers and references. The syntax to use them is obviously different, and you cannot &quot;re-seat&quot; references, have references to nothingness, or have pointers to references.</source>
          <target state="translated">Más allá de eso,hay por supuesto algunas diferencias prácticas entre los punteros y las referencias.La sintaxis para usarlos es obviamente diferente,y no se pueden &quot;reubicar&quot; las referencias,tener referencias a la nada,o tener punteros a las referencias.</target>
        </trans-unit>
        <trans-unit id="2f0a115b892ed33dc580b0746ea765524e9adee4" translate="yes" xml:space="preserve">
          <source>But if a reference &lt;em&gt;really&lt;/em&gt; were the object, how could there be dangling references? In unmanaged languages, it's impossible for references to be any 'safer' than pointers - there generally just isn't a way to reliably alias values across scope boundaries!</source>
          <target state="translated">Pero si una referencia fuera &lt;em&gt;realmente&lt;/em&gt; el objeto, &amp;iquest;c&amp;oacute;mo podr&amp;iacute;a haber referencias colgantes? En los idiomas no administrados, es imposible que las referencias sean m&amp;aacute;s &quot;seguras&quot; que los punteros; en general, &amp;iexcl;no existe una forma de alias confiable de los valores a trav&amp;eacute;s de los l&amp;iacute;mites del alcance!</target>
        </trans-unit>
        <trans-unit id="c0f0472a48232cf765cdc5a4ed86bcc402178e6e" translate="yes" xml:space="preserve">
          <source>But this is not the whole story. I mean, there are more things than pointers vs references you have to consider.</source>
          <target state="translated">Pero esta no es la historia completa.Quiero decir,hay más cosas que puntos vs referencias que tienes que considerar.</target>
        </trans-unit>
        <trans-unit id="1219d69d4aae4754c68f172af1e20be534822a2e" translate="yes" xml:space="preserve">
          <source>But we can&amp;rsquo;t have &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; and also &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt;.</source>
          <target state="translated">Pero no podemos tener &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; y tambi&amp;eacute;n &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85c1119a1a34eb5b96e7a27219b6d23bf265027f" translate="yes" xml:space="preserve">
          <source>But what are the differences?</source>
          <target state="translated">¿Pero cuáles son las diferencias?</target>
        </trans-unit>
        <trans-unit id="ea217864ff94b0a58af879bc82826ac7131e836c" translate="yes" xml:space="preserve">
          <source>C programmers might dislike C++ references as it will no longer be obvious when indirection happens or if an argument gets passed by value or by pointer without looking at function signatures.</source>
          <target state="translated">A los programadores de C puede que no les gusten las referencias de C++,ya que ya no será obvio cuando ocurra una indirecta o si un argumento se pasa por valor o por puntero sin mirar las firmas de las funciones.</target>
        </trans-unit>
        <trans-unit id="4a06c33b9cfbaa63574bd669ad9aaf1bc634c44a" translate="yes" xml:space="preserve">
          <source>C++ only has a few kinds of syntactic sugars in this strict sense. One instance is (inherited from C) the built-in (non-overloaded) operator &lt;code&gt;[]&lt;/code&gt;, which &lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;is defined exactly having same semantic properties of specific forms of combination over built-in operator unary &lt;code&gt;*&lt;/code&gt; and binary &lt;code&gt;+&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C ++ solo tiene unos pocos tipos de az&amp;uacute;cares sint&amp;aacute;cticos en este sentido estricto. Una instancia es (heredada de C) el operador incorporado (no sobrecargado) &lt;code&gt;[]&lt;/code&gt; , que &lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;se define exactamente con las mismas propiedades sem&amp;aacute;nticas de formas espec&amp;iacute;ficas de combinaci&amp;oacute;n sobre el operador incorporado unario &lt;code&gt;*&lt;/code&gt; y binario &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bb21fac313bcd60906b2b35ca4582ec35330749" translate="yes" xml:space="preserve">
          <source>C++ programmers might dislike using pointers as they are considered unsafe - although references aren't really any safer than constant pointers except in the most trivial cases - lack the convenience of automatic indirection and carry a different semantic connotation.</source>
          <target state="translated">A los programadores de C++puede que no les guste usar punteros ya que se consideran inseguros -aunque las referencias no son realmente más seguras que los punteros constantes,excepto en los casos más triviales-,carecen de la conveniencia de la indirección automática y llevan una connotación semántica diferente.</target>
        </trans-unit>
        <trans-unit id="9d2b52840330e7a44bc694eb6918e7e64357a038" translate="yes" xml:space="preserve">
          <source>Coming from a C background, C++ references may look like a somewhat silly concept, but one should still use them instead of pointers where possible: Automatic indirection &lt;em&gt;is&lt;/em&gt; convenient, and references become especially useful when dealing with &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt; - but not because of any perceived safety advantage, but rather because they make writing idiomatic code less awkward.</source>
          <target state="translated">Viniendo de un fondo de C, las referencias de C ++ pueden parecer un concepto un tanto tonto, pero uno deber&amp;iacute;a usarlas en lugar de punteros cuando sea posible: la indirecci&amp;oacute;n autom&amp;aacute;tica &lt;em&gt;es&lt;/em&gt; conveniente, y las referencias se vuelven especialmente &amp;uacute;tiles cuando se trata de &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt; , pero no debido a la seguridad percibida. ventaja, sino m&amp;aacute;s bien porque hacen que escribir c&amp;oacute;digo idiom&amp;aacute;tico sea menos inc&amp;oacute;modo.</target>
        </trans-unit>
        <trans-unit id="059cdeb648fa366a46a8b8314ed53bd8fc068d24" translate="yes" xml:space="preserve">
          <source>Compound declarators are more restrictive on references.</source>
          <target state="translated">Los declarantes de compuestos son más restrictivos en cuanto a las referencias.</target>
        </trans-unit>
        <trans-unit id="403fed44f11ec4c8ff00fd23f9802e6597c6b4a0" translate="yes" xml:space="preserve">
          <source>Consider the following statement from the &lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;C++ FAQ&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">Considere la siguiente declaraci&amp;oacute;n de las &lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;preguntas frecuentes de C ++&lt;/em&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="67105debe8987091e6bdc70ef2e1c62eaeef75e5" translate="yes" xml:space="preserve">
          <source>Consider these two program fragments. In the first, we assign one pointer to another:</source>
          <target state="translated">Considere estos dos fragmentos de programa.En el primero,asignamos un puntero a otro:</target>
        </trans-unit>
        <trans-unit id="0cdefee66dd0f6388e32b9d6fed8a4351a84480e" translate="yes" xml:space="preserve">
          <source>Const references can be bound to temporaries. Pointers cannot (not without some indirection):</source>
          <target state="translated">Las referencias a las constantes pueden estar ligadas a las temporales.Los punteros no pueden (no sin alguna indirecta):</target>
        </trans-unit>
        <trans-unit id="257ee630683f00991c22ec378f7e691a1faab887" translate="yes" xml:space="preserve">
          <source>Contrary to popular opinion, it is possible to have a reference that is NULL.</source>
          <target state="translated">Contrariamente a la opinión popular,es posible tener una referencia que sea NULL.</target>
        </trans-unit>
        <trans-unit id="43548a90788ae029335a689520a48ebf306a65a2" translate="yes" xml:space="preserve">
          <source>Copy constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually it should be &lt;code&gt;const&lt;/code&gt; qualified.)</source>
          <target state="translated">Los constructores de copia requieren tipos espec&amp;iacute;ficos de &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;&amp;amp;&lt;/code&gt; tipo de referencia como el primer tipo de par&amp;aacute;metro. (Y por lo general, debe estar calificado).</target>
        </trans-unit>
        <trans-unit id="2dfaa6ee16a6acd02f7f18aa98b05c4a8bd6187a" translate="yes" xml:space="preserve">
          <source>Difference between pointer and reference</source>
          <target state="translated">Diferencia entre puntero y referencia</target>
        </trans-unit>
        <trans-unit id="8d3aac2e61ebd63a0be37ce5d8c06b59c983898f" translate="yes" xml:space="preserve">
          <source>EDIT: Five years after posting this answer, I found an actual technical difference where references are different than just a different way of looking at the same addressing concept.  References can modify the lifespan of temporary objects in a way that pointers cannot.</source>
          <target state="translated">EDITORIAL:Cinco años después de publicar esta respuesta,encontré una diferencia técnica real en la que las referencias son diferentes que sólo una forma diferente de ver el mismo concepto de dirección.Las referencias pueden modificar la vida útil de los objetos temporales de una manera que los punteros no pueden.</target>
        </trans-unit>
        <trans-unit id="afbb5feebb594dfda93806a9043262ea69ffa66b" translate="yes" xml:space="preserve">
          <source>Even that pointers are not qualified enough to be put together with references in the sense of the language design, there are still some arguments making it debatable to make choice between them in some other contexts, for example, when making choices on parameter types.</source>
          <target state="translated">Incluso si los punteros no están lo suficientemente cualificados como para ser combinados con referencias en el sentido del diseño del lenguaje,todavía hay algunos argumentos que hacen que sea discutible elegir entre ellos en algunos otros contextos,por ejemplo,al hacer elecciones sobre los tipos de parámetros.</target>
        </trans-unit>
        <trans-unit id="1f7c6527f15ac956bb6422655a89e581ad918f6c" translate="yes" xml:space="preserve">
          <source>Even though a reference is often implemented using an address in the
  underlying assembly language, please do &lt;em&gt;not&lt;/em&gt; think of a reference as a
  funny looking pointer to an object. A reference &lt;em&gt;is&lt;/em&gt; the object. It is
  not a pointer to the object, nor a copy of the object. It &lt;em&gt;is&lt;/em&gt; the
  object.</source>
          <target state="translated">Aunque una referencia a menudo se implementa utilizando una direcci&amp;oacute;n en el lenguaje ensamblador subyacente, &lt;em&gt;no&lt;/em&gt; piense en una referencia como un puntero de aspecto divertido para un objeto. Una referencia &lt;em&gt;es&lt;/em&gt; el objeto. No es un puntero al objeto, ni una copia del objeto. Es el objeto.</target>
        </trans-unit>
        <trans-unit id="1f0674352c239a778bc468638b40b47fb71b2d98" translate="yes" xml:space="preserve">
          <source>Even when you do want semantics like traditional pointer, there are often something more appropriate, like &lt;code&gt;observer_ptr&lt;/code&gt; in Library Fundamental TS.</source>
          <target state="translated">Incluso cuando desee sem&amp;aacute;ntica como el puntero tradicional, a menudo hay algo m&amp;aacute;s apropiado, como &lt;code&gt;observer_ptr&lt;/code&gt; en Library Fundamental TS.</target>
        </trans-unit>
        <trans-unit id="91de4132deb2a9d1d143f39e4534fbb3726e45ff" translate="yes" xml:space="preserve">
          <source>For an older look at this problem from someone with better writing skills, see &lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;Null References&lt;/a&gt; from Jim Hyslop and Herb Sutter.</source>
          <target state="translated">Para una visi&amp;oacute;n m&amp;aacute;s antigua de este problema de alguien con mejores habilidades de escritura, vea &lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;Referencias nulas&lt;/a&gt; de Jim Hyslop y Herb Sutter.</target>
        </trans-unit>
        <trans-unit id="c8c71250e475a3240795bff029fac330bf5c86bc" translate="yes" xml:space="preserve">
          <source>For another example of the dangers of dereferencing a null pointer see &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;Exposing undefined behavior when trying to port code to another platform&lt;/a&gt; by Raymond Chen.</source>
          <target state="translated">Para otro ejemplo de los peligros de desreferenciar un puntero nulo, vea &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;Exponer el comportamiento indefinido cuando&lt;/a&gt; Raymond Chen intenta portar c&amp;oacute;digo a otra plataforma .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="419ffcbab3d6f22ef6fdb16e11f51ddef360025c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;the ISO C++ definition of object type&lt;/a&gt;:</source>
          <target state="translated">De &lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;la definici&amp;oacute;n ISO C ++ de tipo de objeto&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c921eb398c160fb46e416cb1d07e77fdce036162" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref]/4&lt;/a&gt;:</source>
          <target state="translated">Desde &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref] / 4&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bf57a6753ab8a3e91849d0a5046139bd0ae54c97" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object]/1&lt;/a&gt;:</source>
          <target state="translated">De &lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object] / 1&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="59b186995c92752fd57142834fecf2e2d3252883" translate="yes" xml:space="preserve">
          <source>Function pointers can be converted from lambda expressions without captures, while function references cannot. You have to use function pointers in non-generic code for such cases, even you deliberately do not want nullable values.</source>
          <target state="translated">Los punteros de función pueden ser convertidos a partir de expresiones lambda sin capturas,mientras que las referencias de función no pueden.Hay que utilizar punteros de función en código no genérico para tales casos,incluso si deliberadamente no se quieren valores anulables.</target>
        </trans-unit>
        <trans-unit id="5a8a000b2872f2ecd2628fd91b4af38afe4ab27a" translate="yes" xml:space="preserve">
          <source>Granted, it is much harder to do with a reference - but if you manage it, you'll tear your hair out trying to find it. References are &lt;em&gt;not&lt;/em&gt; inherently safe in C++!</source>
          <target state="translated">De acuerdo, es mucho m&amp;aacute;s dif&amp;iacute;cil hacerlo con una referencia, pero si lo logras, te arrancar&amp;aacute;s el pelo tratando de encontrarlo. &amp;iexcl;Las referencias &lt;em&gt;no&lt;/em&gt; son inherentemente seguras en C ++!</target>
        </trans-unit>
        <trans-unit id="f3d615628d1fd5133dbe19b3297b67cff89e2934" translate="yes" xml:space="preserve">
          <source>Here you are not creating another variable that points to &lt;code&gt;a&lt;/code&gt;; you are just adding another name to the memory content holding the value of &lt;code&gt;a&lt;/code&gt;. This memory now has two names, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and it can be addressed using either name.</source>
          <target state="translated">Aqu&amp;iacute; no est&amp;aacute; creando otra variable que apunte a &lt;code&gt;a&lt;/code&gt; ; solo est&amp;aacute; agregando otro nombre al contenido de la memoria que contiene el valor de &lt;code&gt;a&lt;/code&gt; . Esta memoria ahora tiene dos nombres, &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; , y se puede direccionar con cualquiera de los nombres.</target>
        </trans-unit>
        <trans-unit id="6748018a83feee685129beabf05358adfb1f4a93" translate="yes" xml:space="preserve">
          <source>I can't say I'm really happy with this particular difference. I would much prefer it would be allowed with the meaning reference to anything with an address and otherwise the same behavior for references. It would allow to define some equivalents of C library functions like memcpy using references.</source>
          <target state="translated">No puedo decir que esté realmente feliz con esta diferencia en particular.Preferiría que se permitiera con el significado referencia a cualquier cosa con una dirección y de otra manera el mismo comportamiento para las referencias.Permitiría definir algunos equivalentes de las funciones de la biblioteca C como memcpy usando referencias.</target>
        </trans-unit>
        <trans-unit id="83cff075b67cc3caa75652556ccf090327793e2f" translate="yes" xml:space="preserve">
          <source>I feel like there is yet another point that hasn't been covered here.</source>
          <target state="translated">Siento que hay otro punto que no ha sido cubierto aquí.</target>
        </trans-unit>
        <trans-unit id="78aca0acaa65086aab3a232e328bb0bc36aa5fcb" translate="yes" xml:space="preserve">
          <source>I know references are syntactic sugar, so code is easier to read and write.</source>
          <target state="translated">Sé que las referencias son azúcar sintáctico,así que el código es más fácil de leer y escribir.</target>
        </trans-unit>
        <trans-unit id="790a903c1bebeddd1477cdd4d06bfb3b8a62ae9b" translate="yes" xml:space="preserve">
          <source>I use references unless I need either of these:</source>
          <target state="translated">Uso referencias a menos que necesite alguna de ellas:</target>
        </trans-unit>
        <trans-unit id="3068917d6116da066c23030c927f12eb7a21feb4" translate="yes" xml:space="preserve">
          <source>I want to reiterate that the only way to get a null reference is through malformed code, and once you have it you're getting undefined behavior. It &lt;strong&gt;never&lt;/strong&gt; makes sense to check for a null reference; for example you can try &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; but the compiler might optimize the statement out of existence! A valid reference can never be NULL so from the compiler's view the comparison is always false, and it is free to eliminate the &lt;code&gt;if&lt;/code&gt; clause as dead code - this is the essence of undefined behavior.</source>
          <target state="translated">Quiero reiterar que la &amp;uacute;nica forma de obtener una referencia nula es a trav&amp;eacute;s de un c&amp;oacute;digo con formato incorrecto, y una vez que lo tiene, obtiene un comportamiento indefinido. &lt;strong&gt;Nunca&lt;/strong&gt; tiene sentido buscar una referencia nula; por ejemplo, puede probar &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; pero el compilador podr&amp;iacute;a optimizar la declaraci&amp;oacute;n fuera de existencia! Una referencia v&amp;aacute;lida nunca puede ser NULL, por lo que desde el punto de vista del compilador la comparaci&amp;oacute;n siempre es falsa, y es libre de eliminar la cl&amp;aacute;usula &lt;code&gt;if&lt;/code&gt; como c&amp;oacute;digo muerto; esta es la esencia del comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="28a1dd0bb23764b68abee77b06fa28aa411978df" translate="yes" xml:space="preserve">
          <source>If you are doing some iterations over a range, use iterators (or some ranges which are not provided by the standard library yet), rather than raw pointers unless you are convinced raw pointers will do better (e.g. for less header dependencies) in very specific cases.</source>
          <target state="translated">Si está haciendo algunas iteraciones sobre un rango,utilice iteradores (o algunos rangos que aún no están provistos por la biblioteca estándar),en lugar de punteros sin procesar,a menos que esté convencido de que los punteros sin procesar lo harán mejor (por ejemplo,para tener menos dependencias de encabezamiento)en casos muy específicos.</target>
        </trans-unit>
        <trans-unit id="3ba495f422aa5c4d4099a4f3e279461a678eacba" translate="yes" xml:space="preserve">
          <source>If you come to see the question via &lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;some Google search result (not specific to C++)&lt;/a&gt;, this is very likely to be the wrong place.</source>
          <target state="translated">Si llega a ver la pregunta a trav&amp;eacute;s de &lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;alg&amp;uacute;n resultado de b&amp;uacute;squeda de Google (no espec&amp;iacute;fico de C ++)&lt;/a&gt; , es muy probable que este sea el lugar equivocado.</target>
        </trans-unit>
        <trans-unit id="1adb9ff9254b1ced3f48e2cba167b170d900e4b7" translate="yes" xml:space="preserve">
          <source>If you don't have to stick on such over-specific choices, in most cases the answer is short: &lt;strong&gt;you do not have the necessity to use pointers, so you don't&lt;/strong&gt;. Pointers are usually bad enough because they imply too many things you don't expect and they will rely on too many implicit assumptions undermining the maintainability and (even) portability of the code. &lt;strong&gt;Unnecessarily relying on pointers is definitely a bad style and it should be avoided in the sense of modern C++.&lt;/strong&gt; Reconsider your purpose and you will finally find that &lt;strong&gt;pointer is the feature of last sorts&lt;/strong&gt; in most cases.</source>
          <target state="translated">Si no tiene que apegarse a esas elecciones demasiado espec&amp;iacute;ficas, en la mayor&amp;iacute;a de los casos la respuesta es breve: &lt;strong&gt;no tiene la necesidad de usar punteros, por lo que no es necesario&lt;/strong&gt; . Los punteros suelen ser lo suficientemente malos porque implican demasiadas cosas que no esperas y depender&amp;aacute;n de demasiados supuestos impl&amp;iacute;citos que socavan la mantenibilidad e (incluso) portabilidad del c&amp;oacute;digo. &lt;strong&gt;Innecesariamente depender de punteros es definitivamente un mal estilo y debe evitarse en el sentido de C ++ moderno.&lt;/strong&gt; Reconsidere su prop&amp;oacute;sito y finalmente encontrar&amp;aacute; que el &lt;strong&gt;puntero es la caracter&amp;iacute;stica de los &amp;uacute;ltimos tipos&lt;/strong&gt; en la mayor&amp;iacute;a de los casos.</target>
        </trans-unit>
        <trans-unit id="cb2d77074444d61d2cc67de2bd0e1d87f2a0a031" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value (i.e. using non-reference types) is sufficient, use it directly, particularly when using an implementation supporting C++17 mandated copy elision. (&lt;strong&gt;Warning&lt;/strong&gt;: However, to &lt;strong&gt;exhaustively&lt;/strong&gt; reason about the necessity can be &lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;very complicated&lt;/a&gt;.)</source>
          <target state="translated">Si sabe que el paso por valor (es decir, el uso de tipos que no son de referencia) es suficiente, &amp;uacute;selo directamente, particularmente cuando use una implementaci&amp;oacute;n que admita la elisi&amp;oacute;n de copia obligatoria de C ++ 17. ( &lt;strong&gt;Advertencia&lt;/strong&gt; : Sin embargo, razonar &lt;strong&gt;exhaustivamente&lt;/strong&gt; sobre la necesidad puede ser &lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;muy complicado&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8ab269d4d0dfc63f1830ebd5af6f660e85c8c775" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is not ideal for the reasons above, and you don't want nullable semantics, use {lvalue, rvalue, forwarding}-references.</source>
          <target state="translated">Si sabes que el valor de paso no es ideal por las razones anteriores,y no quieres una semántica nula,usa {valor,rvalor,reenvío}-referencias.</target>
        </trans-unit>
        <trans-unit id="95a97bbef840565852fb933bd387402999a8aa62" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is sufficient and you want some explicit nullable semantics, use wrapper like &lt;code&gt;std::optional&lt;/code&gt;, rather than raw pointers.</source>
          <target state="translated">Si sabe que el paso por valor es suficiente y desea una sem&amp;aacute;ntica anulable expl&amp;iacute;cita, use un contenedor como &lt;code&gt;std::optional&lt;/code&gt; , en lugar de punteros sin formato.</target>
        </trans-unit>
        <trans-unit id="f83f246714f814ce810c05a9ae95c69e9261bd39" translate="yes" xml:space="preserve">
          <source>If you notice even the memory addresses are exactly the same, meaning the reference is successfully pointing to a variable on the heap! Now if you really want to get freaky, this also works:</source>
          <target state="translated">Si te das cuenta de que incluso las direcciones de la memoria son exactamente las mismas,significa que la referencia está apuntando con éxito a una variable en el montón! Ahora,si realmente quieres volverte loco,esto también funciona:</target>
        </trans-unit>
        <trans-unit id="f057014d6ad0660324ee4744392d34f7205d30d5" translate="yes" xml:space="preserve">
          <source>If you try this without the &lt;code&gt;const&lt;/code&gt; it should fail to compile. You cannot bind a non-const reference to a temporary object, nor can you take its address for that matter.</source>
          <target state="translated">Si intenta esto sin la &lt;code&gt;const&lt;/code&gt; ante , no se compilar&amp;aacute;. No puede vincular una referencia no constante a un objeto temporal, ni puede tomar su direcci&amp;oacute;n para el caso.</target>
        </trans-unit>
        <trans-unit id="543e04d6c7cf8b1ff3568e8f9fe688b2b4150999" translate="yes" xml:space="preserve">
          <source>If you want to be really pedantic, there is one thing you can do with a reference that you can't do with a pointer: extend the lifetime of a temporary object. In C++ if you bind a const reference to a temporary object, the lifetime of that object becomes the lifetime of the reference.</source>
          <target state="translated">Si quieres ser realmente pedante,hay una cosa que puedes hacer con una referencia que no puedes hacer con un puntero:extender la vida útil de un objeto temporal.En C++,si atas una referencia constante a un objeto temporal,la vida útil de ese objeto se convierte en la vida útil de la referencia.</target>
        </trans-unit>
        <trans-unit id="2f134bd878c28bfcf0e94f5edce84bd4768767e8" translate="yes" xml:space="preserve">
          <source>If you want to operate some handles with ownership, use smart pointers like &lt;code&gt;unique_ptr&lt;/code&gt; and &lt;code&gt;shared_ptr&lt;/code&gt; (or even with homebrew ones by yourself if you require them to be &lt;em&gt;opaque&lt;/em&gt;), rather than raw pointers.</source>
          <target state="translated">Si desea operar algunos manejadores con propiedad, use punteros inteligentes como &lt;code&gt;unique_ptr&lt;/code&gt; y &lt;code&gt;shared_ptr&lt;/code&gt; (o incluso con homebrew usted mismo si necesita que sean &lt;em&gt;opacos&lt;/em&gt; ), en lugar de punteros sin procesar.</target>
        </trans-unit>
        <trans-unit id="f9770a58e8e2c829e550700ed47290c2aae7fa6f" translate="yes" xml:space="preserve">
          <source>In fact to do it properly, we must have declared and defined an object at the first then we can make a reference to that object, so the correct implementation of the previous code will be:</source>
          <target state="translated">De hecho,para hacerlo correctamente,debemos haber declarado y definido un objeto al principio y luego podemos hacer una referencia a ese objeto,así que la correcta implementación del código anterior será:</target>
        </trans-unit>
        <trans-unit id="82769a796fb3193fe927e0baf51f38ab518d3ebb" translate="yes" xml:space="preserve">
          <source>In other words, a reference is nothing but a pointer that has the pointer mechanics abstracted away, making it safer and easier to use (no accidental pointer math, no mixing up '.' and '-&amp;gt;', etc.), assuming you don't try any nonsense like my examples above ;)</source>
          <target state="translated">En otras palabras, una referencia no es m&amp;aacute;s que un puntero que tiene la mec&amp;aacute;nica del puntero extra&amp;iacute;da, lo que lo hace m&amp;aacute;s seguro y f&amp;aacute;cil de usar (sin matem&amp;aacute;tica accidental del puntero, sin mezclar '.' Y '-&amp;gt;', etc.), suponiendo que no intentes ninguna tonter&amp;iacute;a como mis ejemplos anteriores;)</target>
        </trans-unit>
        <trans-unit id="200b5d2213958228565fdde5b08d7bf3a0e7e8c1" translate="yes" xml:space="preserve">
          <source>In this example s3_copy copies the temporary object that is a result of the concatenation. Whereas s3_reference in essence becomes the temporary object. It's really a reference to a temporary object that now has the same lifetime as the reference.</source>
          <target state="translated">En este ejemplo s3_copy copia el objeto temporal que es el resultado de la concatenación.Mientras que s3_reference en esencia se convierte en el objeto temporal.En realidad es una referencia a un objeto temporal que ahora tiene la misma vida útil que la referencia.</target>
        </trans-unit>
        <trans-unit id="ba73ce596882bac23adab797099d810c536e52c7" translate="yes" xml:space="preserve">
          <source>It also has to prove that there are no ways a future call could read/write a[0] while we have a temporary register copy of it in a0. This is often trivial to prove, because in many cases it is obvious that the reference is never stored in a permanent structure like a class instance.</source>
          <target state="translated">También tiene que probar que no hay formas de que una futura llamada pueda reescribir a[0]mientras tengamos una copia de registro temporal de ella en a0.Esto es a menudo trivial de probar,porque en muchos casos es obvio que la referencia nunca se almacena en una estructura permanente como una instancia de clase.</target>
        </trans-unit>
        <trans-unit id="c0cc1580772a83020df85287d6f8e26c7bd8a5f0" translate="yes" xml:space="preserve">
          <source>It doesn't matter how much space it takes up since you can't actually see any side effect (without executing code) of whatever space it would take up.</source>
          <target state="translated">No importa cuánto espacio ocupe,ya que no se puede ver ningún efecto secundario (sin ejecutar el código)de cualquier espacio que ocupe.</target>
        </trans-unit>
        <trans-unit id="1d798a27c2d2b93f1136b70dcfad1e9fac904cd6" translate="yes" xml:space="preserve">
          <source>It internally becomes</source>
          <target state="translated">Internamente se convierte en</target>
        </trans-unit>
        <trans-unit id="2dbb06a19fcf0fb6d64e79da18f5a426b98c98ee" translate="yes" xml:space="preserve">
          <source>It is unspecified whether or not a reference requires storage.</source>
          <target state="translated">No se especifica si una referencia requiere o no almacenamiento.</target>
        </trans-unit>
        <trans-unit id="b288f3fae88ae371415949edcc0c9e0886821a41" translate="yes" xml:space="preserve">
          <source>It may be important to know, object type is a top-level category of the type universe in C++. Reference is also a top-level category. &lt;strong&gt;But pointer is not.&lt;/strong&gt;</source>
          <target state="translated">Puede ser importante saber que el tipo de objeto es una categor&amp;iacute;a de nivel superior del universo tipo en C ++. La referencia tambi&amp;eacute;n es una categor&amp;iacute;a de nivel superior. &lt;strong&gt;Pero el puntero no lo es.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b45412ddd0ff9c77b1d05ade69b201525767735" translate="yes" xml:space="preserve">
          <source>Language neutrality caveats</source>
          <target state="translated">La neutralidad del lenguaje es una advertencia</target>
        </trans-unit>
        <trans-unit id="55dd62362caab929ec378cd05497a3ec85467b37" translate="yes" xml:space="preserve">
          <source>Look at the following statement,</source>
          <target state="translated">Mira la siguiente declaración,</target>
        </trans-unit>
        <trans-unit id="d7297eb6becdd735c4545511c38d16ada0827023" translate="yes" xml:space="preserve">
          <source>Many compilers when inlining the pointer version one will actually force a write to memory (we are taking the address explicitly).  However, they will leave the reference in a register which is more optimal.</source>
          <target state="translated">Muchos compiladores al alinear la versión del puntero uno en realidad obligan a escribir en la memoria (estamos tomando la dirección explícitamente).Sin embargo,dejarán la referencia en un registro que es más óptimo.</target>
        </trans-unit>
        <trans-unit id="ea2aee18995ab103eed08b69ba07dcb31625dabf" translate="yes" xml:space="preserve">
          <source>Maybe some metaphors will help; 
In the context of your desktop screenspace -</source>
          <target state="translated">Tal vez algunas metáforas ayuden;En el contexto de su espacio de pantalla de escritorio -</target>
        </trans-unit>
        <trans-unit id="ac946397b09fb907e8acce3c92c880b361a9a242" translate="yes" xml:space="preserve">
          <source>Modern compilers are getting better and better at static analysis, but it is always nice to help them out and use references.</source>
          <target state="translated">Los compiladores modernos son cada vez mejores en el análisis estático,pero siempre es bueno ayudarlos y usar referencias.</target>
        </trans-unit>
        <trans-unit id="bf6c60a1e5c2679ef0162d45b8f206f16bcdd7d1" translate="yes" xml:space="preserve">
          <source>Move constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually there should be no qualifiers.)</source>
          <target state="translated">Los constructores de movimiento requieren tipos espec&amp;iacute;ficos de tipo de referencia &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; como el primer tipo de par&amp;aacute;metro. (Y generalmente no deber&amp;iacute;a haber calificadores).</target>
        </trans-unit>
        <trans-unit id="1b9630be120a68e57ca22b6ff58fa3a235507cba" translate="yes" xml:space="preserve">
          <source>My example above is short and contrived. Here's a more real-world example.</source>
          <target state="translated">Mi ejemplo anterior es corto y artificioso.Aquí hay un ejemplo más real.</target>
        </trans-unit>
        <trans-unit id="56e71102cceade878735d306276129a65b04b038" translate="yes" xml:space="preserve">
          <source>Normally temporary objects such as the one created by the call to &lt;code&gt;createF(5)&lt;/code&gt; are destroyed at the end of the expression.  However, by binding that object to a reference, &lt;code&gt;ref&lt;/code&gt;, C++ will extend the lifespan of that temporary object until &lt;code&gt;ref&lt;/code&gt; goes out of scope.</source>
          <target state="translated">Normalmente, los objetos temporales como el creado por la llamada a &lt;code&gt;createF(5)&lt;/code&gt; se destruyen al final de la expresi&amp;oacute;n. Sin embargo, al vincular ese objeto a una referencia, &lt;code&gt;ref&lt;/code&gt; , C ++ extender&amp;aacute; la vida &amp;uacute;til de ese objeto temporal hasta que &lt;code&gt;ref&lt;/code&gt; salga del alcance.</target>
        </trans-unit>
        <trans-unit id="b2dd5770081924d799a48921378b48818433c7bb" translate="yes" xml:space="preserve">
          <source>Note the statements above only mentions &quot;pointers&quot; and &quot;references&quot; as types. There are some interested questions about their instances (like variables). There also come too many misconceptions.</source>
          <target state="translated">Nótese que en las declaraciones anteriores sólo se mencionan como tipos los &quot;punteros&quot; y las &quot;referencias&quot;.Hay algunas preguntas interesadas sobre sus instancias (como las variables).También hay demasiados conceptos erróneos.</target>
        </trans-unit>
        <trans-unit id="0112dd76dee19c15ddada9b0763e06e1cbc7faf4" translate="yes" xml:space="preserve">
          <source>Note these are &lt;em&gt;semantic&lt;/em&gt; properties.</source>
          <target state="translated">Tenga en cuenta que estas son propiedades &lt;em&gt;sem&amp;aacute;nticas&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32c54f61399cee485b86cada14cf3ef339a2f916" translate="yes" xml:space="preserve">
          <source>Now &lt;strong&gt;regardless&lt;/strong&gt; of how a compiler handles references, it will &lt;strong&gt;always&lt;/strong&gt; have some kind of pointer under the hood, because a reference &lt;strong&gt;must&lt;/strong&gt; refer to a specific variable at a specific memory address for it to work as expected, there is no getting around this (hence the term 'reference').</source>
          <target state="translated">Ahora, &lt;strong&gt;independientemente&lt;/strong&gt; de c&amp;oacute;mo un compilador maneja las referencias, &lt;strong&gt;siempre&lt;/strong&gt; tendr&amp;aacute; alg&amp;uacute;n tipo de puntero debajo del cap&amp;oacute;, porque una referencia &lt;strong&gt;debe&lt;/strong&gt; referirse a una variable espec&amp;iacute;fica en una direcci&amp;oacute;n de memoria espec&amp;iacute;fica para que funcione como se esperaba, no hay forma de evitar esto (por lo tanto el t&amp;eacute;rmino 'referencia').</target>
        </trans-unit>
        <trans-unit id="752e698d55444e3238d56a6bc3da3af23d39ce29" translate="yes" xml:space="preserve">
          <source>Now do the same thing with pointers</source>
          <target state="translated">Ahora haz lo mismo con los punteros</target>
        </trans-unit>
        <trans-unit id="e6bdf4bf7e4af7604beaed717ed9319201ff15be" translate="yes" xml:space="preserve">
          <source>Now some explanation of real code:</source>
          <target state="translated">Ahora una explicación del código real:</target>
        </trans-unit>
        <trans-unit id="586d3a296148dea14411f5e77a90d02cd7148035" translate="yes" xml:space="preserve">
          <source>Now there may be some cases where your compiler may not be able to know the reference when compiling, like when using an extern variable. So a reference may or may not be implemented as a pointer in the underlying code. But in the examples I gave you, it will most likely not be implemented with a pointer.</source>
          <target state="translated">Ahora bien,puede haber algunos casos en los que su compilador no pueda conocer la referencia al compilar,como cuando se utiliza una variable externa.Así que una referencia puede o no ser implementada como un puntero en el código subyacente.Pero en los ejemplos que te di,lo más probable es que no se implemente con un puntero.</target>
        </trans-unit>
        <trans-unit id="808cc104c235301ef1bc79319f8102ad43971fef" translate="yes" xml:space="preserve">
          <source>Null pointers can be used as a
sentinel value, often a cheap way to
avoid function overloading or use of
a bool.</source>
          <target state="translated">Los punteros nulos pueden utilizarse como valor centinela,a menudo una forma barata de evitar la sobrecarga de funciones o el uso de un bool.</target>
        </trans-unit>
        <trans-unit id="67ae9809624c429d324c275faf9d92d1518e204d" translate="yes" xml:space="preserve">
          <source>Object types can have top-level &lt;code&gt;cv&lt;/code&gt; qualifiers. References cannot.</source>
          <target state="translated">Los tipos de objeto pueden tener calificadores de &lt;code&gt;cv&lt;/code&gt; de nivel superior. Las referencias no pueden.</target>
        </trans-unit>
        <trans-unit id="00a1b2cda377012d0e23e72a9f8fed0898939786" translate="yes" xml:space="preserve">
          <source>Of course, barring such clever optimizations, compilers will indeed turn references into pointers when needed.</source>
          <target state="translated">Por supuesto,a no ser que se realicen optimizaciones tan inteligentes,los compiladores convertirán las referencias en punteros cuando sea necesario.</target>
        </trans-unit>
        <trans-unit id="dc07d79fb5ff33400c26bc7a53b5a0a72e7aefd6" translate="yes" xml:space="preserve">
          <source>Of course, for functions that are not inlined the pointer and reference generate the same code and it's always better to pass intrinsics by value than by reference if they are not modified and returned by the function.</source>
          <target state="translated">Por supuesto,para las funciones que no están alineadas el puntero y la referencia generan el mismo código y siempre es mejor pasar lo intrínseco por el valor que por la referencia si no son modificados y devueltos por la función.</target>
        </trans-unit>
        <trans-unit id="828bf90967e721e857197022098eb853d37eaa44" translate="yes" xml:space="preserve">
          <source>On the other hand, one major difference between references and pointers is that temporaries assigned to const references live until the const reference goes out of scope.</source>
          <target state="translated">Por otra parte,una diferencia importante entre las referencias y los punteros es que los temporales asignados a las referencias const viven hasta que la referencia const se sale del ámbito de aplicación.</target>
        </trans-unit>
        <trans-unit id="90dd91d02279fe6ccfc85544573813d23da86513" translate="yes" xml:space="preserve">
          <source>Otherwise, it is insignificant that pointers can be qualified as a specific sorts of types with references together. They simply share too few common properties besides the syntax similarity, so there is no need to put them together in most cases.</source>
          <target state="translated">Por lo demás,es insignificante que los punteros puedan calificarse como una clase específica de tipos con referencias juntas.Simplemente comparten muy pocas propiedades comunes además de la similitud de sintaxis,por lo que no es necesario ponerlos juntos en la mayoría de los casos.</target>
        </trans-unit>
        <trans-unit id="c468e66383b3acff1decf7ebfe1722418b200e03" translate="yes" xml:space="preserve">
          <source>Overloaded &lt;code&gt;operator=&lt;/code&gt; as special member functions requires reference types similar to 1st parameter of copy/move constructors.</source>
          <target state="translated">&lt;code&gt;operator=&lt;/code&gt; sobrecargado = como funciones miembro especiales requiere tipos de referencia similares al primer par&amp;aacute;metro de los constructores copiar / mover.</target>
        </trans-unit>
        <trans-unit id="7f2c3e2cc509718d63ded349b2aab9f792237302" translate="yes" xml:space="preserve">
          <source>Pointer can be assigned &lt;code&gt;nullptr&lt;/code&gt; directly, whereas reference cannot. If you try hard enough, and you know how, you can make the address of a reference &lt;code&gt;nullptr&lt;/code&gt;.  Likewise, if you try hard enough you can have a reference to a pointer, and then that reference can contain &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">Al puntero se le puede asignar &lt;code&gt;nullptr&lt;/code&gt; directamente, mientras que la referencia no. Si se esfuerza lo suficiente y sabe c&amp;oacute;mo, puede hacer que la direcci&amp;oacute;n de una referencia sea &lt;code&gt;nullptr&lt;/code&gt; . Del mismo modo, si se esfuerza lo suficiente, puede tener una referencia a un puntero, y luego esa referencia puede contener &lt;code&gt;nullptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8dd03a2b7cf3f5874fc9c97bd98b107bc98bfa9" translate="yes" xml:space="preserve">
          <source>Pointers and references are mentioned together &lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;in the context of &lt;em&gt;compound type&lt;/em&gt;&lt;/a&gt;. This is basically due to the nature of the declarator syntax inherited from (and extended) C, which has no references. (Besides, there are more than one kind of declarator of references since C++ 11, while pointers are still &quot;unityped&quot;: &lt;code&gt;&amp;amp;&lt;/code&gt;+&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; vs. &lt;code&gt;*&lt;/code&gt;.) So drafting a language specific by &quot;extension&quot; with similar style of C in this context is somewhat reasonable. (I will still argue that the syntax of declarators wastes the syntactic expressiveness &lt;em&gt;a lot&lt;/em&gt;, makes both human users and implementations frustrating. Thus, all of them are not qualified to be &lt;em&gt;built-in&lt;/em&gt; in a new language design. This is a totally different topic about PL design, though.)</source>
          <target state="translated">Los punteros y las referencias se mencionan juntos &lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;en el contexto del &lt;em&gt;tipo compuesto&lt;/em&gt;&lt;/a&gt; . Esto se debe b&amp;aacute;sicamente a la naturaleza de la sintaxis del declarador heredada de (y extendida) C, que no tiene referencias. (Adem&amp;aacute;s, hay m&amp;aacute;s de un tipo de declarador de referencias desde C ++ 11, mientras que los punteros todav&amp;iacute;a est&amp;aacute;n &quot;unidos&quot;: &lt;code&gt;&amp;amp;&lt;/code&gt; + &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; vs. &lt;code&gt;*&lt;/code&gt; .) As&amp;iacute; que redacta un lenguaje espec&amp;iacute;fico por &quot;extensi&amp;oacute;n&quot; con un estilo similar de C en este contexto Es algo razonable. (Todav&amp;iacute;a argumentar&amp;eacute; que la sintaxis de los declaradores desperdicia mucho la expresividad sint&amp;aacute;ctica, hace que tanto los usuarios humanos como las implementaciones sean frustrantes. Por lo tanto, no todos est&amp;aacute;n calificados para integrarse en un nuevo dise&amp;ntilde;o de lenguaje. Este es un tema totalmente diferente sobre el dise&amp;ntilde;o PL, sin embargo).</target>
        </trans-unit>
        <trans-unit id="8e79db4216ca0b1682917f0312184de116274ee0" translate="yes" xml:space="preserve">
          <source>Pointers are variables; they contain the address of some other variable, or can be null. The important thing is that a pointer has a value, while a reference only has a variable that it is referencing.</source>
          <target state="translated">Los punteros son variables;contienen la dirección de alguna otra variable,o pueden ser nulos.Lo importante es que un puntero tiene un valor,mientras que una referencia sólo tiene una variable a la que está haciendo referencia.</target>
        </trans-unit>
        <trans-unit id="a4c98c7b23dbb9c431cf37cec4103729a3b3df7c" translate="yes" xml:space="preserve">
          <source>Pointers can iterate over an array, you can use &lt;code&gt;++&lt;/code&gt; to go to the next item that a pointer is pointing to, and &lt;code&gt;+ 4&lt;/code&gt; to go to the 5th element.  This is no matter what size the object is that the pointer points to.</source>
          <target state="translated">Los punteros pueden iterar sobre una matriz, puede usar &lt;code&gt;++&lt;/code&gt; para ir al siguiente elemento al que apunta un puntero y &lt;code&gt;+ 4&lt;/code&gt; para ir al quinto elemento. Esto no importa el tama&amp;ntilde;o del objeto al que apunta el puntero.</target>
        </trans-unit>
        <trans-unit id="0041b69bd78f1922ccacbca89c0bd23258263cde" translate="yes" xml:space="preserve">
          <source>Postfix &lt;code&gt;++&lt;/code&gt; requires dummy &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Postfix &lt;code&gt;++&lt;/code&gt; requiere dummy &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c40deca9098c33c4507f06a0277ec7d603682af" translate="yes" xml:space="preserve">
          <source>Pragmatics</source>
          <target state="translated">Pragmatics</target>
        </trans-unit>
        <trans-unit id="462242db0811f3f971e9fd491ae343b8badcc883" translate="yes" xml:space="preserve">
          <source>RAII is one of the central concepts of C++, but it interacts non-trivially with copying semantics. Passing objects by reference avoids these issues as no copying is involved. If references were not present in the language, you'd have to use pointers instead, which are more cumbersome to use, thus violating the language design principle that the best-practice solution should be easier than the alternatives.</source>
          <target state="translated">La RAII es uno de los conceptos centrales de C++,pero interactúa de forma no trivial con la semántica de la copia.Pasar objetos por referencia evita estos problemas ya que no hay copia.Si las referencias no estuvieran presentes en el lenguaje,habría que utilizar en su lugar punteros,que son más engorrosos de usar,violando así el principio de diseño del lenguaje de que la solución de mejores prácticas debería ser más fácil que las alternativas.</target>
        </trans-unit>
        <trans-unit id="055cd393f567fac0ba4089ec8ff85252aac14bdb" translate="yes" xml:space="preserve">
          <source>References are allowed to refer to variables which do not have memory addresses, such as those the compiler chooses to put into registers. If you take the address of a local variable, it is very hard for the compiler to put it in a register.</source>
          <target state="translated">Se permite que las referencias se refieran a variables que no tienen direcciones de memoria,como las que el compilador elige para poner en los registros.Si se toma la dirección de una variable local,es muy difícil para el compilador ponerla en un registro.</target>
        </trans-unit>
        <trans-unit id="5a853555e7fde5a31207074a784b524c82ed58aa" translate="yes" xml:space="preserve">
          <source>References are designed such that it is substantially easier for the compiler to trace which reference aliases which variables. Two major features are very important: no &quot;reference arithmetic&quot; and no reassigning of references. These allow the compiler to figure out which references alias which variables at compile time.</source>
          <target state="translated">Las referencias están diseñadas de tal manera que es sustancialmente más fácil para el compilador rastrear qué alias de referencia y qué variables.Dos características principales son muy importantes:no hay &quot;aritmética de referencia&quot; y no hay reasignación de referencias.Éstas permiten al compilador determinar qué referencias alias qué variables en el momento de la compilación.</target>
        </trans-unit>
        <trans-unit id="e813db94099ca02f715fb0f1ba9f33611db2f553" translate="yes" xml:space="preserve">
          <source>References are very similar to pointers, but they are specifically crafted to be helpful to optimizing compilers.</source>
          <target state="translated">Las referencias son muy similares a los punteros,pero están elaboradas específicamente para ser útiles en la optimización de los compiladores.</target>
        </trans-unit>
        <trans-unit id="bf6fd50fdee7317a481645b6fae553557dc3cdd2" translate="yes" xml:space="preserve">
          <source>References can &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;collapse&lt;/a&gt;.</source>
          <target state="translated">Las referencias pueden &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;colapsar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e3206ad161847bd2d29f9d31a405ed11c7d64c2" translate="yes" xml:space="preserve">
          <source>References cannot be stuffed into an array, whereas pointers can be (Mentioned by user @litb)</source>
          <target state="translated">Las referencias no se pueden rellenar en una matriz,mientras que los punteros pueden ser (Mencionado por el usuario @litb)</target>
        </trans-unit>
        <trans-unit id="cfca6984c06ae05fa650e3c0076a1855343215bb" translate="yes" xml:space="preserve">
          <source>References have special rules in initialization. The lifetime of variable declared as a reference type can be different to ordinary objects via extension.</source>
          <target state="translated">Las referencias tienen reglas especiales en la inicialización.La vida útil de la variable declarada como tipo de referencia puede ser diferente a la de los objetos ordinarios por extensión.</target>
        </trans-unit>
        <trans-unit id="526784942b6e34cc8eb97ec6c1946f69db4aa93c" translate="yes" xml:space="preserve">
          <source>References in C++ is quite &quot;odd&quot;, as it is essentially not first-class: &lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;they will be treated as the objects or the functions being referred to&lt;/a&gt; so they have no chance to support some first-class operations like being the left operand of &lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;the member access operator&lt;/a&gt; independently to the type of the referred object. Other languages may or may not have similar restrictions on their references.</source>
          <target state="translated">Las referencias en C ++ son bastante &quot;extra&amp;ntilde;as&quot;, ya que esencialmente no son de primera clase: &lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;se tratar&amp;aacute;n como los objetos o las funciones a las que se hace referencia, por&lt;/a&gt; lo que no tienen la posibilidad de admitir algunas operaciones de primera clase, como ser el operando izquierdo del &lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;operador de acceso de miembros&lt;/a&gt; independientemente del tipo del objeto referido. Otros idiomas pueden o no tener restricciones similares en sus referencias.</target>
        </trans-unit>
        <trans-unit id="d003206a70c36ecf7a0315ea6420395ec7e35600" translate="yes" xml:space="preserve">
          <source>References in C++ will likely not preserve the meaning across different languages. For example, references in general do not imply nonnull properties on values like they in C++, so such assumptions may not work in some other languages (and you will find counterexamples quite easily, e.g. Java, C#, ...).</source>
          <target state="translated">Las referencias en C++probablemente no conservarán el significado en los diferentes idiomas.Por ejemplo,las referencias en general no implican propiedades no nulas en valores como los de C++,por lo que tales suposiciones pueden no funcionar en algunos otros lenguajes (y encontrará contraejemplos con bastante facilidad,por ejemplo,Java,C#,...).</target>
        </trans-unit>
        <trans-unit id="776a07f1188f204d3f88257d0ec6a07a29887cdc" translate="yes" xml:space="preserve">
          <source>Regards,
&amp;amp;rzej</source>
          <target state="translated">Regards,
&amp;amp;rzej</target>
        </trans-unit>
        <trans-unit id="f29ff291ec91fbd3d5e03a84623244a66ed645e4" translate="yes" xml:space="preserve">
          <source>Run the program and have a look at the output and you'll understand.</source>
          <target state="translated">Ejecute el programa y eche un vistazo a la salida y lo entenderá.</target>
        </trans-unit>
        <trans-unit id="01841626b366982706bd9cb74359851e4287a00f" translate="yes" xml:space="preserve">
          <source>Simply to remember that,</source>
          <target state="translated">Simplemente para recordar eso,</target>
        </trans-unit>
        <trans-unit id="7ed3e2e5988e139dbdad2bddeb8aea77458c5333" translate="yes" xml:space="preserve">
          <source>So, in practice, the answer is so obvious: &lt;strong&gt;when in doubt, avoid pointers&lt;/strong&gt;. You have to use pointers only when there are very explicit reasons that nothing else is more appropriate. Except a few exceptional cases mentioned above, such choices are almost always not purely C++-specific (but likely to be language-implementation-specific). Such instances can be:</source>
          <target state="translated">Entonces, en la pr&amp;aacute;ctica, la respuesta es tan obvia: &lt;strong&gt;en caso de duda, evite los punteros&lt;/strong&gt; . Tienes que usar punteros solo cuando hay razones muy expl&amp;iacute;citas de que nada m&amp;aacute;s es m&amp;aacute;s apropiado. Excepto algunos casos excepcionales mencionados anteriormente, tales elecciones casi siempre no son puramente espec&amp;iacute;ficas de C ++ (pero es probable que sean espec&amp;iacute;ficas de la implementaci&amp;oacute;n del lenguaje). Tales instancias pueden ser:</target>
        </trans-unit>
        <trans-unit id="fcf6411c0b226a9fd5b245400b86fb65e325be87" translate="yes" xml:space="preserve">
          <source>Some argue that this is such a useful feature when reading code, that pointer parameters should always be used for modifiable parameters rather than non-&lt;code&gt;const&lt;/code&gt; references, even if the function never expects a &lt;code&gt;nullptr&lt;/code&gt;. That is, those people argue that function signatures like &lt;code&gt;fn3()&lt;/code&gt; above should not be allowed. &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;Google's C++ style guidelines&lt;/a&gt; are an example of this.</source>
          <target state="translated">Algunos argumentan que esta es una caracter&amp;iacute;stica tan &amp;uacute;til cuando se lee c&amp;oacute;digo, que los par&amp;aacute;metros de puntero siempre deben usarse para par&amp;aacute;metros modificables en lugar de referencias no &lt;code&gt;const&lt;/code&gt; antes , incluso si la funci&amp;oacute;n nunca espera un &lt;code&gt;nullptr&lt;/code&gt; . Es decir, esas personas argumentan que las firmas de funciones como &lt;code&gt;fn3()&lt;/code&gt; anteriores no deber&amp;iacute;an permitirse. &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;Las pautas de estilo C ++ de Google&lt;/a&gt; son un ejemplo de esto.</target>
        </trans-unit>
        <trans-unit id="4060e9b242b8df1a2b956d0e250e637eee184ce4" translate="yes" xml:space="preserve">
          <source>Sometimes the language rules explicitly require specific types to be used. If you want to use these features, obey the rules.</source>
          <target state="translated">A veces las normas de lenguaje requieren explícitamente que se utilicen tipos específicos.Si quieres usar estas características,obedece las reglas.</target>
        </trans-unit>
        <trans-unit id="5fc11392b922636b6dc568f4ab0eb7cfb144157b" translate="yes" xml:space="preserve">
          <source>Special rules on &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; parameters (as the &quot;forwarding references&quot;) based on reference collapsing during template parameter deduction allow &lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;&quot;perfect forwarding&quot;&lt;/a&gt; of parameters.</source>
          <target state="translated">Las reglas especiales sobre los par&amp;aacute;metros &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (como las &quot;referencias de reenv&amp;iacute;o&quot;) basadas en el colapso de referencias durante la deducci&amp;oacute;n de par&amp;aacute;metros de plantilla permiten el &lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;&quot;reenv&amp;iacute;o perfecto&quot;&lt;/a&gt; de los par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="e7e7e6a0d10546a8f3514b41d4f9f797c475d3c2" translate="yes" xml:space="preserve">
          <source>Specific language-interoperation routines require pointers, like &lt;code&gt;operator new&lt;/code&gt;. (However, &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;void*&lt;/code&gt; is still quite different and safer compared to the ordinary object pointers because it rules out unexpected pointer arithmetics unless you are relying on some non conforming extension on &lt;code&gt;void*&lt;/code&gt; like GNU's.)</source>
          <target state="translated">Las rutinas espec&amp;iacute;ficas de interoperaci&amp;oacute;n de lenguaje requieren punteros, como el &lt;code&gt;operator new&lt;/code&gt; . (Sin embargo, &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;void*&lt;/code&gt; sigue siendo bastante diferente y m&amp;aacute;s seguro en comparaci&amp;oacute;n con los punteros de objetos ordinarios porque excluye la aritm&amp;eacute;tica de puntero inesperada a menos que est&amp;eacute; confiando en alguna extensi&amp;oacute;n no conforme en &lt;code&gt;void*&lt;/code&gt; como GNU).</target>
        </trans-unit>
        <trans-unit id="918eaf9f6cafcfdb9b382a8fa017353bbc7f79e9" translate="yes" xml:space="preserve">
          <source>Specific overloads of operators require reference or non reference types. For example:</source>
          <target state="translated">Las sobrecargas específicas de los operadores requieren tipos de referencia o no referencia.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="9e092dda4f0e27d0c7686ddd00272079e678b6e6" translate="yes" xml:space="preserve">
          <source>Storage</source>
          <target state="translated">Storage</target>
        </trans-unit>
        <trans-unit id="f6ceae4e1810d086bda09a8ac74e9e1fae98d4f4" translate="yes" xml:space="preserve">
          <source>Syntactic sugar</source>
          <target state="translated">Azúcar sintáctico</target>
        </trans-unit>
        <trans-unit id="178786d5b288287aa798248ecdf5fc27cc41e4ba" translate="yes" xml:space="preserve">
          <source>Technically this is an &lt;strong&gt;invalid reference&lt;/strong&gt;, not a null reference.  C++ doesn't support null references as a concept as you might find in other languages.  There are other kinds of invalid references as well. &lt;em&gt;Any&lt;/em&gt; invalid reference raises the spectre of &lt;strong&gt;undefined behavior&lt;/strong&gt;, just as using an invalid pointer would.</source>
          <target state="translated">T&amp;eacute;cnicamente, esta es una &lt;strong&gt;referencia&lt;/strong&gt; no &lt;strong&gt;v&amp;aacute;lida&lt;/strong&gt; , no una referencia nula. C ++ no admite referencias nulas como concepto como puede encontrar en otros lenguajes. Tambi&amp;eacute;n hay otros tipos de referencias no v&amp;aacute;lidas. &lt;em&gt;Cualquier&lt;/em&gt; referencia inv&amp;aacute;lida aumenta el espectro del &lt;strong&gt;comportamiento indefinido&lt;/strong&gt; , tal como lo har&amp;iacute;a un puntero inv&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="19d85e5f25c953dc491251669b1a186b567d0b30" translate="yes" xml:space="preserve">
          <source>Technically, this is plain wrong. References are not syntactic sugar of any other features in C++, because they cannot be exactly replaced by other features without any semantic differences.</source>
          <target state="translated">Técnicamente,esto está muy mal.Las referencias no son azúcar sintáctico de ninguna otra característica en C++,porque no pueden ser reemplazadas exactamente por otras características sin ninguna diferencia semántica.</target>
        </trans-unit>
        <trans-unit id="e1271990b0fbf017a0baa7180d4771ca7fef2cb9" translate="yes" xml:space="preserve">
          <source>Templates that cover both &lt;code&gt;T&amp;amp;&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are even more common.</source>
          <target state="translated">Las plantillas que cubren &lt;code&gt;T&amp;amp;&lt;/code&gt; y &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; son a&amp;uacute;n m&amp;aacute;s comunes.</target>
        </trans-unit>
        <trans-unit id="cc2d982b9a391ad561f42bfa61ab554d2658e9c3" translate="yes" xml:space="preserve">
          <source>The actual error is in the dereferencing of the NULL pointer, prior to the assignment to a reference.  But I'm not aware of any compilers that will generate any errors on that condition - the error propagates to a point further along in the code. That's what makes this problem so insidious. Most of the time, if you dereference a NULL pointer, you crash right at that spot and it doesn't take much debugging to figure it out.</source>
          <target state="translated">El error real está en la derivación del puntero NULL,antes de la asignación a una referencia.Pero no estoy al tanto de ningún compilador que genere algún error en esa condición-el error se propaga a un punto más adelante en el código.Eso es lo que hace que este problema sea tan insidioso.La mayoría de las veces,si desreferencias un puntero NULL,te caes justo en ese punto y no se necesita mucha depuración para resolverlo.</target>
        </trans-unit>
        <trans-unit id="36dcbb0fd485c966a6a8597e14838d2a77d340f3" translate="yes" xml:space="preserve">
          <source>The behavior is the same; only now it is much harder to prove that maybeModify does not ever modify array[1], because we already gave it a pointer; the cat is out of the bag. Now it has to do the much more difficult proof: a static analysis of maybeModify to prove it never writes to &amp;amp;x + 1. It also has to prove that it never saves off a pointer that can refer to array[0], which is just as tricky.</source>
          <target state="translated">El comportamiento es el mismo; solo que ahora es mucho m&amp;aacute;s dif&amp;iacute;cil demostrar que maybeModify nunca modifica la matriz [1], porque ya le dimos un puntero; El gato est&amp;aacute; fuera de la bolsa. Ahora tiene que hacer la prueba mucho m&amp;aacute;s dif&amp;iacute;cil: un an&amp;aacute;lisis est&amp;aacute;tico de maybeModify para demostrar que nunca escribe en &amp;amp; x + 1. Tambi&amp;eacute;n tiene que demostrar que nunca ahorra un puntero que pueda referirse a la matriz [0], que es solo tan complicado</target>
        </trans-unit>
        <trans-unit id="55c25474b6bbe811c3fff5d37fe3196ddf92b362" translate="yes" xml:space="preserve">
          <source>The default flavor uses the 'bind const reference to a temporary' aspect of references.</source>
          <target state="translated">El sabor por defecto utiliza la referencia &quot;bind const a un aspecto temporal&quot; de las referencias.</target>
        </trans-unit>
        <trans-unit id="eeffd6f2cd40ebbc994170a79516a76d384f1862" translate="yes" xml:space="preserve">
          <source>The difference is that non-constant pointer variable(not to be confused with a pointer to constant) may be changed at some time during program execution, requires pointer semantics to be used(&amp;amp;,*) operators, while references can be set upon initialization only(that's why you can set them in constructor initializer list only, but not somehow else) and use ordinary value accessing semantics.  Basically references were introduced to allow support for operators overloading as I had read in some very old book. As somebody stated in this thread - pointer can be set to 0 or whatever value you want. 0(NULL, nullptr) means that the pointer is initialized with nothing. It is an error to dereference null pointer. But actually the pointer may contain a value that doesn't point to some correct memory location. References in their turn try not to allow a user to initialize a reference to something that cannot be referenced due to the fact that you always provide rvalue of correct type to it. Although there are a lot of ways to make reference variable be initialized to a wrong memory location - it is better for you not to dig this deep into details. On machine level both pointer and reference work uniformly - via pointers. Let's say in essential references are syntactic sugar. rvalue references are different to this - they are naturally stack/heap objects.</source>
          <target state="translated">La diferencia es que la variable de puntero no constante (que no debe confundirse con un puntero a constante) puede cambiarse en alg&amp;uacute;n momento durante la ejecuci&amp;oacute;n del programa, requiere que se use la sem&amp;aacute;ntica del puntero (&amp;amp;, *), mientras que las referencias se pueden establecer en la inicializaci&amp;oacute;n solo (es por eso que puede configurarlos solo en la lista de inicializador de constructor, pero no de otra manera) y usar la sem&amp;aacute;ntica de acceso de valor ordinario. B&amp;aacute;sicamente, se introdujeron referencias para permitir el soporte para los operadores que sobrecargan, como hab&amp;iacute;a le&amp;iacute;do en un libro muy antiguo. Como alguien dijo en este hilo, el puntero se puede establecer en 0 o el valor que desee. 0 (NULL, nullptr) significa que el puntero se inicializa sin nada. Es un error desreferenciar el puntero nulo. Pero en realidad el puntero puede contener un valor que no apunta a alguna ubicaci&amp;oacute;n de memoria correcta. Las referencias a su vez intentan no permitir que un usuario inicialice una referencia a algo a lo que no se puede hacer referencia debido al hecho de que siempre le proporciona un valor de tipo correcto. Aunque hay muchas maneras de hacer que la variable de referencia se inicialice en una ubicaci&amp;oacute;n de memoria incorrecta, es mejor no profundizar tanto en los detalles. A nivel de m&amp;aacute;quina, tanto el puntero como la referencia funcionan de manera uniforme, a trav&amp;eacute;s de punteros. Digamos en referencias esenciales son el az&amp;uacute;car sint&amp;aacute;ctico. Las referencias de rvalue son diferentes a esto: son naturalmente objetos de pila / mont&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="21383718ed633934236239e24d6297c4ae1335ed" translate="yes" xml:space="preserve">
          <source>The differences of the top-level categories can already reveal many concrete differences not tied to pointers directly:</source>
          <target state="translated">Las diferencias de las categorías de nivel superior ya pueden revelar muchas diferencias concretas que no están ligadas directamente a los punteros:</target>
        </trans-unit>
        <trans-unit id="819bfb5a2d2e6000333b076e5df05cfd8d7b2a13" translate="yes" xml:space="preserve">
          <source>The direct answer</source>
          <target state="translated">La respuesta directa</target>
        </trans-unit>
        <trans-unit id="f88d1a0da318f485205557f1a4a4b91d6c82b7a4" translate="yes" xml:space="preserve">
          <source>The misconceptions</source>
          <target state="translated">Los conceptos erróneos</target>
        </trans-unit>
        <trans-unit id="7d2603e75f0c55eb2703c92e74f015d2c67447b5" translate="yes" xml:space="preserve">
          <source>The only exceptions cannot be worked around in the current language:</source>
          <target state="translated">Las únicas excepciones no se pueden trabajar en el lenguaje actual:</target>
        </trans-unit>
        <trans-unit id="122da8393156782721cf3629f6cd6821668afecf" translate="yes" xml:space="preserve">
          <source>The only major rule that's important to remember with references is that they must be defined at the time of declaration (with the exception of a reference in a header, in that case it must be defined in the constructor, after the object it's contained in is constructed it's too late to define it).</source>
          <target state="translated">La única regla importante que es importante recordar con las referencias es que deben ser definidas en el momento de la declaración (con la excepción de una referencia en un encabezamiento,en ese caso debe ser definida en el constructor,después de que el objeto que contiene se construye es demasiado tarde para definirlo).</target>
        </trans-unit>
        <trans-unit id="418b62106b171f039b854dbd9df45e23828dfba0" translate="yes" xml:space="preserve">
          <source>The proper way to stay out of trouble is to avoid dereferencing a NULL pointer to create a reference. Here's an automated way to accomplish this.</source>
          <target state="translated">La forma correcta de mantenerse fuera de problemas es evitar desreferenciar un puntero NULL para crear una referencia.Aquí hay una forma automatizada de lograr esto.</target>
        </trans-unit>
        <trans-unit id="5873330b5c7abf6ca602c30f272bd7c50e0cbb63" translate="yes" xml:space="preserve">
          <source>The statement above is simply wrong. To avoid such misconceptions, look at the ISO C++ rules instead:</source>
          <target state="translated">La afirmación anterior es simplemente errónea.Para evitar tales conceptos erróneos,mira las reglas de ISO C++en su lugar:</target>
        </trans-unit>
        <trans-unit id="163a6b49bbef328a902a3d1fe72ca7563153d744" translate="yes" xml:space="preserve">
          <source>There can still be some common properties among references in different programming languages in general, but let's leave it for some other questions in SO.</source>
          <target state="translated">Todavía puede haber algunas propiedades comunes entre las referencias en los diferentes lenguajes de programación en general,pero dejémoslo para algunas otras preguntas en el SO.</target>
        </trans-unit>
        <trans-unit id="e317f9f1b18599441d13052e85296dbd4035b47d" translate="yes" xml:space="preserve">
          <source>There is a semantic difference that may appear esoteric if you are not familiar with studying computer languages in an abstract or even academic fashion.</source>
          <target state="translated">Hay una diferencia semántica que puede parecer esotérica si no se está familiarizado con el estudio de los lenguajes informáticos de forma abstracta o incluso académica.</target>
        </trans-unit>
        <trans-unit id="49c3ed839f4ba592814145e1ee7dccb652641c97" translate="yes" xml:space="preserve">
          <source>There is a very important non-technical difference between pointers and references: An argument passed to a function by pointer is much more visible than an argument passed to a function by non-const reference. For example:</source>
          <target state="translated">Hay una diferencia no técnica muy importante entre los punteros y las referencias:Un argumento pasado a una función por un puntero es mucho más visible que un argumento pasado a una función por una referencia no-constante.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="44e93f1f5f0ace9a170cb0b7222ca3b3580dffcb" translate="yes" xml:space="preserve">
          <source>There is one fundamental difference between pointers and references that I didn't see anyone had mentioned: references enable pass-by-reference semantics in function arguments. Pointers, although it is not visible at first do not: they only provide pass-by-value semantics. This has been very nicely described in &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">Hay una diferencia fundamental entre punteros y referencias que no vi que nadie hubiera mencionado: las referencias permiten la sem&amp;aacute;ntica de paso por referencia en los argumentos de la funci&amp;oacute;n. Los punteros, aunque no es visible al principio, no lo hacen: solo proporcionan una sem&amp;aacute;ntica de paso por valor. Esto ha sido muy bien descrito en &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;este art&amp;iacute;culo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5066abc2ae8da58f9f9bb296820d74fa0f7a48b1" translate="yes" xml:space="preserve">
          <source>Therefore a reference IS a pointer under the hood, they both are just storing a memory address, where the address is pointing to is irrelevant, what do you think would happen if I called std::cout &amp;lt;&amp;lt; str_ref; AFTER calling delete &amp;amp;str_ref? Well, obviously it compiles fine, but causes a segmentation fault at runtime because it's no longer pointing at a valid variable, we essentially have a broken reference that still exists (until it falls out of scope), but is useless.</source>
          <target state="translated">Por lo tanto, una referencia ES un puntero debajo del cap&amp;oacute;, ambos solo est&amp;aacute;n almacenando una direcci&amp;oacute;n de memoria, donde la direcci&amp;oacute;n apunta es irrelevante, &amp;iquest;qu&amp;eacute; crees que pasar&amp;iacute;a si llamara std :: cout &amp;lt;&amp;lt; str_ref; DESPU&amp;Eacute;S de llamar a delete &amp;amp; str_ref? Bueno, obviamente se compila bien, pero causa una falla de segmentaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n porque ya no apunta a una variable v&amp;aacute;lida, esencialmente tenemos una referencia rota que todav&amp;iacute;a existe (hasta que cae fuera del alcance), pero es in&amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="94289fe5436213192f08bec365e448fa20dc244c" translate="yes" xml:space="preserve">
          <source>These points empower a considerable part of C++ and the standard library so this is quite a major property of references.</source>
          <target state="translated">Estos puntos potencian una parte considerable de C++y la biblioteca estándar,por lo que esta es una propiedad bastante importante de las referencias.</target>
        </trans-unit>
        <trans-unit id="6a0c459929817549c904c8a94991b55621527e3f" translate="yes" xml:space="preserve">
          <source>This assignment changes ival, the value referenced by ri, and not the reference itself. After the assignment, the two references still refer to their original objects, and the value of those objects is now the same as well.</source>
          <target state="translated">Esta asignación cambia ival,el valor referenciado por ri,y no la referencia en sí misma.Después de la asignación,las dos referencias siguen refiriéndose a sus objetos originales,y el valor de esos objetos es ahora el mismo también.</target>
        </trans-unit>
        <trans-unit id="bc577f672dad3e6a3a69c44737f3aacd3dd1eb12" translate="yes" xml:space="preserve">
          <source>This is based on the &lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;tutorial&lt;/a&gt;. What is written makes it more clear:</source>
          <target state="translated">Esto se basa en el &lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;tutorial&lt;/a&gt; . Lo que est&amp;aacute; escrito lo deja m&amp;aacute;s claro:</target>
        </trans-unit>
        <trans-unit id="3ab66ed104cf4962c17c327aa4d19f6a70663d93" translate="yes" xml:space="preserve">
          <source>This is the language mechanism that allows ScopeGuard to work.</source>
          <target state="translated">Este es el mecanismo de lenguaje que permite que ScopeGuard funcione.</target>
        </trans-unit>
        <trans-unit id="5c9287077fd3860634cb823000e3c46b1b0d2646" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;const&amp;amp;&lt;/code&gt; safer for use in argument lists and so forth.</source>
          <target state="translated">Esto hace que sea &lt;code&gt;const&amp;amp;&lt;/code&gt; seguro usarlo en listas de argumentos, etc.</target>
        </trans-unit>
        <trans-unit id="d92fc23c843fd5c20781bced348b9700ad555c98" translate="yes" xml:space="preserve">
          <source>This program might help in comprehending the answer of the question. This is a simple program of a reference &quot;j&quot; and a pointer &quot;ptr&quot; pointing to variable &quot;x&quot;.</source>
          <target state="translated">Este programa podría ayudar a comprender la respuesta a la pregunta.Este es un programa simple de una referencia &quot;j&quot; y un puntero &quot;ptr&quot; que apunta a la variable &quot;x&quot;.</target>
        </trans-unit>
        <trans-unit id="f6a17a077fe021118aa2ad5ab8e800b9c24900ac" translate="yes" xml:space="preserve">
          <source>This should permit the compiler to do more optimization on a reference.</source>
          <target state="translated">Esto debería permitir al compilador hacer más optimización en una referencia.</target>
        </trans-unit>
        <trans-unit id="2f3d837dc2b38c729da0192bc97e045c3a5109ca" translate="yes" xml:space="preserve">
          <source>To make such an optimization, it needs to prove that nothing can change array[1] during the call. This is rather easy to do. i is never less than 2, so array[i] can never refer to array[1]. maybeModify() is given a0 as a reference (aliasing array[0]). Because there is no &quot;reference&quot; arithmetic, the compiler just has to prove that maybeModify never gets the address of x, and it has proven that nothing changes array[1].</source>
          <target state="translated">Para hacer tal optimización,necesita probar que nada puede cambiar la matriz[1]durante la llamada.Esto es bastante fácil de hacer.i nunca es menos de 2,así que array[i]nunca puede referirse a array[1].quizásModify()se da a0 como referencia (aliasing array[0]).Como no hay aritmética de &quot;referencia&quot;,el compilador sólo tiene que probar que maybeModify nunca obtiene la dirección de x,y ha probado que nada cambia array[1].</target>
        </trans-unit>
        <trans-unit id="887be10c65852c56ff940b439c392da3426fe46c" translate="yes" xml:space="preserve">
          <source>Unlike the pointers, references are &lt;strong&gt;syntactically equivalent&lt;/strong&gt; to the object they refer to, i.e. any operation that can be applied to an object works for a reference, and with the exact same syntax (the exception is of course the initialization).</source>
          <target state="translated">A diferencia de los punteros, las referencias son &lt;strong&gt;sint&amp;aacute;cticamente equivalentes&lt;/strong&gt; al objeto al que se refieren, es decir, cualquier operaci&amp;oacute;n que pueda aplicarse a un objeto funciona para una referencia, y con la misma sintaxis exacta (la excepci&amp;oacute;n es, por supuesto, la inicializaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="82af8ce5dd45a624f7e3a05f611fa27d013254ef" translate="yes" xml:space="preserve">
          <source>Update: now that I think about it some more, there is an important difference.</source>
          <target state="translated">Actualización:ahora que lo pienso un poco más,hay una diferencia importante.</target>
        </trans-unit>
        <trans-unit id="255286b845d43f2eb541ea059727b48d0df67a81" translate="yes" xml:space="preserve">
          <source>Variable of object types do occupy storage as per &lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;the abstract machine&lt;/a&gt; semantics. Reference do not necessary occupy storage (see the section about misconceptions below for details).</source>
          <target state="translated">La variable de los tipos de objeto ocupa el almacenamiento seg&amp;uacute;n &lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;la&lt;/a&gt; sem&amp;aacute;ntica de la m&amp;aacute;quina abstracta . La referencia no ocupa necesariamente el almacenamiento (consulte la secci&amp;oacute;n sobre conceptos err&amp;oacute;neos a continuaci&amp;oacute;n para obtener m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="e955ffcb762ae563797df04ca22c14d80f8aa171" translate="yes" xml:space="preserve">
          <source>Visit the following for more information about reference to pointer:</source>
          <target state="translated">Visite lo siguiente para obtener más información sobre la referencia al puntero:</target>
        </trans-unit>
        <trans-unit id="95919816eaf3c9d568884c2a1f7a85a8422fc08c" translate="yes" xml:space="preserve">
          <source>What are the differences between a pointer variable and a reference variable in C++</source>
          <target state="translated">¿Cuáles son las diferencias entre una variable de puntero y una variable de referencia en C++</target>
        </trans-unit>
        <trans-unit id="ebf7dfac9cd8041f70cebb7841fd92ee7068ad0e" translate="yes" xml:space="preserve">
          <source>What is a pointer in C++? Some specific instance of type that &lt;strong&gt;is an object type&lt;/strong&gt;.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es un puntero en C ++? Alguna instancia espec&amp;iacute;fica de tipo que &lt;strong&gt;es un tipo de objeto&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f1713708129e2693fa553b3ca19fb86a7a27996c" translate="yes" xml:space="preserve">
          <source>What is a reference in C++? Some specific instance of type that &lt;strong&gt;is not an object type&lt;/strong&gt;.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es una referencia en C ++? Alguna instancia espec&amp;iacute;fica de tipo que &lt;strong&gt;no es un tipo de objeto&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b27d4d26ba775faaca91cdf7c85e8f345955ab10" translate="yes" xml:space="preserve">
          <source>What's a C++ reference (&lt;em&gt;for C programmers&lt;/em&gt;)</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; es una referencia de C ++? ( &lt;em&gt;Para programadores de C&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="f4957cb2344c8ba91faaeb20076eeeb6b30d45f2" translate="yes" xml:space="preserve">
          <source>What's more, as we can refer to almost any pointer tutorial, a pointer is an object that is supported by pointer arithmetic which makes pointer similar to an array.</source>
          <target state="translated">Lo que es más,como podemos referirnos a casi cualquier tutorial sobre punteros,un puntero es un objeto que se apoya en la aritmética de los punteros,lo que hace que el puntero sea similar a una matriz.</target>
        </trans-unit>
        <trans-unit id="ec620abb83732edc34ab0a338ecb3e522947253f" translate="yes" xml:space="preserve">
          <source>When calling a function, the compiler usually generates memory spaces for the arguments to be copied to. The function signature defines the spaces that should be created and gives the name that should be used for these spaces. Declaring a parameter as a reference just tells the compiler to use the input variable memory space instead of allocating a new memory space during the method call. It may seem strange to say that your function will be directly manipulating a variable declared in the calling scope, but remember that when executing compiled code, there is no more scope; there is just plain flat memory, and your function code could manipulate any variables.</source>
          <target state="translated">Al llamar una función,el compilador suele generar espacios de memoria para los argumentos a copiar.La firma de la función define los espacios que deben ser creados y da el nombre que debe ser usado para estos espacios.Declarar un parámetro como referencia sólo le dice al compilador que utilice el espacio de memoria de la variable de entrada en lugar de asignar un nuevo espacio de memoria durante la llamada al método.Puede parecer extraño decir que su función estará manipulando directamente una variable declarada en el ámbito de la llamada,pero recuerde que al ejecutar el código compilado,no hay más ámbito;sólo hay memoria plana,y su código de función podría manipular cualquier variable.</target>
        </trans-unit>
        <trans-unit id="d4c1912265bdef87e12cb7b1321e31b984533bfe" translate="yes" xml:space="preserve">
          <source>When you are implementing smart pointers above, you may have to deal with raw pointers.</source>
          <target state="translated">Cuando se implementan los punteros inteligentes de arriba,puede que tengas que lidiar con los punteros crudos.</target>
        </trans-unit>
        <trans-unit id="1dfec36a318fd0d200d4cdbe5653e6d388ef8b86" translate="yes" xml:space="preserve">
          <source>When you create a reference, you only tell the compiler that you assign another name to the pointer variable; that's why references cannot &quot;point to null&quot;, because a variable cannot be, and not be.</source>
          <target state="translated">Cuando se crea una referencia,sólo se le dice al compilador que se le asigna otro nombre a la variable puntero;por eso las referencias no pueden &quot;apuntar a nulo&quot;,porque una variable no puede ser,y no ser.</target>
        </trans-unit>
        <trans-unit id="c777e0e0107a7f50f79668993af249ac372a560e" translate="yes" xml:space="preserve">
          <source>Which outputs this:</source>
          <target state="translated">Lo que da como resultado esto:</target>
        </trans-unit>
        <trans-unit id="c5cc6c3d8c26b226ed34902de7cac9e3a05e8f30" translate="yes" xml:space="preserve">
          <source>While both references and pointers are used to indirectly access another value, there are two important differences between references and pointers. The first is that a reference always refers to an object: It is an error to define a reference without initializing it. The behavior of assignment is the second important difference: Assigning to a reference changes the object to which the reference is bound; it does not rebind the reference to another object. Once initialized, a reference always refers to the same underlying object.</source>
          <target state="translated">Aunque tanto las referencias como los punteros se utilizan para acceder indirectamente a otro valor,hay dos diferencias importantes entre las referencias y los punteros.La primera es que una referencia siempre se refiere a un objeto:Es un error definir una referencia sin inicializarla.El comportamiento de la asignación es la segunda diferencia importante:Asignar a una referencia cambia el objeto al que está vinculada la referencia;no vuelve a vincular la referencia a otro objeto.Una vez inicializada,una referencia siempre se refiere al mismo objeto subyacente.</target>
        </trans-unit>
        <trans-unit id="33026a6390ada498b7595f79ab2136f07ff3040a" translate="yes" xml:space="preserve">
          <source>While this may appear superficial, I believe this property is crucial for a number of C++ features, for example:</source>
          <target state="translated">Aunque esto pueda parecer superficial,creo que esta propiedad es crucial para una serie de características de C++,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a48d4180c32fc6ba76e32c1184f3989050537522" translate="yes" xml:space="preserve">
          <source>Why I consider C++ references useful</source>
          <target state="translated">Por qué considero útiles las referencias a C++</target>
        </trans-unit>
        <trans-unit id="a139f82cb75f5fa1d088932ad6ca62c1a9ed365b" translate="yes" xml:space="preserve">
          <source>You can do arithmetic on a pointer.
For example, &lt;code&gt;p += offset;&lt;/code&gt;</source>
          <target state="translated">Puedes hacer aritm&amp;eacute;tica en un puntero. Por ejemplo, &lt;code&gt;p += offset;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34780a25d9c2fa6caeb26ac54a01416129ecb662" translate="yes" xml:space="preserve">
          <source>You can have pointers to pointers to pointers offering extra levels of indirection.  Whereas references only offer one level of indirection.</source>
          <target state="translated">Puedes tener punteros a punteros a punteros que ofrecen niveles extra de indirección.Mientras que las referencias sólo ofrecen un nivel de indirección.</target>
        </trans-unit>
        <trans-unit id="ca281bbb0f05d2038a489cb7276fce90296f6044" translate="yes" xml:space="preserve">
          <source>You forgot the most important part:</source>
          <target state="translated">Olvidaste la parte más importante:</target>
        </trans-unit>
        <trans-unit id="5b379fd4bb44eb684d6e0614512cecb190c0230a" translate="yes" xml:space="preserve">
          <source>You have to avoid symbol bloat in some extreme cases.</source>
          <target state="translated">Tienes que evitar la hinchazón de los símbolos en algunos casos extremos.</target>
        </trans-unit>
        <trans-unit id="94dc5492065b8158897a90145f93ab59e74f01ca" translate="yes" xml:space="preserve">
          <source>You have to improve efficiency of the translation (compilation &amp;amp; linking) in some extreme cases.</source>
          <target state="translated">Debe mejorar la eficiencia de la traducci&amp;oacute;n (compilaci&amp;oacute;n y vinculaci&amp;oacute;n) en algunos casos extremos.</target>
        </trans-unit>
        <trans-unit id="560512056d46b11c084b62f89a3e5fff348a21e2" translate="yes" xml:space="preserve">
          <source>You have to interoperate at runtime with different language implementations (including various assemblies, language runtime and FFI of some high-level client languages) based on assumptions of specific implementations.</source>
          <target state="translated">Hay que interoperar en tiempo de ejecución con diferentes implementaciones de lenguaje (incluyendo varios ensamblados,tiempo de ejecución del lenguaje y FFI de algunos lenguajes cliente de alto nivel)basados en suposiciones de implementaciones específicas.</target>
        </trans-unit>
        <trans-unit id="92de6dbe192f694e5996d57ccfe447310dfd3ab8" translate="yes" xml:space="preserve">
          <source>You have to meet the ABI requirements of specific C++ implementations.</source>
          <target state="translated">Tienes que cumplir con los requisitos de la ABI de las implementaciones específicas de C++.</target>
        </trans-unit>
        <trans-unit id="184df4e9e98867001ef0b20404d00c507b584e37" translate="yes" xml:space="preserve">
          <source>You have to serve to old-style (C) APIs.</source>
          <target state="translated">Tienes que servir a los APIs de estilo antiguo (C).</target>
        </trans-unit>
        <trans-unit id="d5c7ab9829b48d10733475f6a32872b8d1dde9fe" translate="yes" xml:space="preserve">
          <source>in simple words, we can say a reference is an alternative name for a variable whereas,
a pointer is a variable that holds the address of another variable.
e.g.</source>
          <target state="translated">En palabras sencillas,podemos decir que una referencia es un nombre alternativo para una variable,mientras que un puntero es una variable que contiene la dirección de otra variable.Por ejemplo.</target>
        </trans-unit>
        <trans-unit id="344723f5f4518fc02c77a821b777b5e5ef5b14c7" translate="yes" xml:space="preserve">
          <source>member-access with pointers uses &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">el acceso de miembros con punteros utiliza &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a520836c5bc91e48d3c9612930f910ee19298599" translate="yes" xml:space="preserve">
          <source>member-access with references uses &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">acceso de miembros con referencias de usos &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6cd4d114dbfaf6a41f6a22c17b7940a2cd45fe06" translate="yes" xml:space="preserve">
          <source>will print:</source>
          <target state="translated">se imprimirá:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
