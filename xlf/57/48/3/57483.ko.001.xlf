<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/57483">
    <body>
      <group id="57483">
        <trans-unit id="366a1392d254b91c2979dbb347d6a6006020e4a8" translate="yes" xml:space="preserve">
          <source>(A side note: the question may be significant earlier than any &quot;C-like&quot; languages are involved, like &lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;ALGOL 68 vs. PL/I&lt;/a&gt;.)</source>
          <target state="translated">( &lt;a href=&quot;https://academic.oup.com/comjnl/article-pdf/17/4/325/1215152/17-4-325.pdf&quot;&gt;부설 : ALGOL 68 vs. PL / I와&lt;/a&gt; 같은 &quot;C-like&quot;언어가 포함 된 것보다 문제가 더 빠를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3c2cc5a14dd2d409d181bc8d16bec43175ff2ec5" translate="yes" xml:space="preserve">
          <source>(Similarly, &lt;em&gt;lambda-expression&lt;/em&gt;s are &lt;em&gt;not&lt;/em&gt; syntactic sugar of any other features in C++ because it cannot be precisely simulated with &quot;unspecified&quot; properties like &lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;the declaration order of the captured variables&lt;/a&gt;, which may be important because the initialization order of such variables can be significant.)</source>
          <target state="translated">유사하게, &lt;em&gt;람다-표현식&lt;/em&gt; 은 C ++의 다른 기능의 구문 설탕이 &lt;em&gt;아닙니다&lt;/em&gt; &lt;a href=&quot;http://eel.is/c++draft/expr.prim.lambda#capture-9&quot;&gt;. 캡처 된 변수의 선언 순서&lt;/a&gt; 와 같이 &quot;지정되지 않은&quot;속성으로 정확하게 시뮬레이션 할 수 없기 때문에 이러한 변수의 초기화 순서는 중요 할 수 있습니다. 중요한.)</target>
        </trans-unit>
        <trans-unit id="1f3d6284e82153785e1a110247b2169240f95d81" translate="yes" xml:space="preserve">
          <source>(or &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; which still relies on an implicit cast
to &lt;code&gt;T&amp;amp;&lt;/code&gt;)</source>
          <target state="translated">(또는 &lt;code&gt;std::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; 는 여전히 &lt;code&gt;T&amp;amp;&lt;/code&gt; 에 대한 내재 된 캐스트에 의존합니다)</target>
        </trans-unit>
        <trans-unit id="eb9fd6a3244bc886192add4286c3f4e955b01e2c" translate="yes" xml:space="preserve">
          <source>... An object occupies a region of storage in its period of construction, throughout its lifetime, and in its period of destruction. ...</source>
          <target state="translated">... 물체는 구성 기간, 수명 및 파괴 기간에 저장 영역을 차지합니다. ...</target>
        </trans-unit>
        <trans-unit id="aedfef1b56582c6d5ac761f02dc136e601d184b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias_Tom&lt;/code&gt; can be understood as an &lt;code&gt;alias of a variable&lt;/code&gt; (different with &lt;code&gt;typedef&lt;/code&gt;, which is &lt;code&gt;alias of a type&lt;/code&gt;) &lt;code&gt;Tom&lt;/code&gt;. It is also OK to forget the terminology of such statement is to create a reference of &lt;code&gt;Tom&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alias_Tom&lt;/code&gt; 은 &lt;code&gt;alias of a variable&lt;/code&gt; 의 별칭 ( &lt;code&gt;alias of a type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; 와는 다른) &lt;code&gt;Tom&lt;/code&gt; 으로 이해 될 수 있습니다. 그러한 진술의 용어를 잊어 버린 것도 &lt;code&gt;Tom&lt;/code&gt; 의 참조를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a5a7b84169fee1ce093f438b076f5fe4d63635e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo.bar&lt;/code&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; in the same way that &lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt; is &lt;em&gt;clearly&lt;/em&gt; superior to &lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs&lt;/a&gt; :-)</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; 는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Vi&quot;&gt;vi&lt;/a&gt; 가 &lt;a href=&quot;http://en.wikipedia.org/wiki/Emacs&quot;&gt;Emacs&lt;/a&gt; 보다 &lt;em&gt;분명히&lt;/em&gt; 우수한 것과 같은 방식으로 &lt;code&gt;foo-&amp;gt;bar&lt;/code&gt; 보다 &lt;em&gt;분명히&lt;/em&gt; 우수합니다. :-)</target>
        </trans-unit>
        <trans-unit id="53a62ec44b159bf24f77f722d3f80606a21a3355" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C++: Reference to Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://markgodwin.blogspot.in/2009/08/c-reference-to-pointer.html&quot;&gt;C ++ : 포인터에 대한 참조&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8503c60ec396a2706a5881136f438f315e36942e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;Pointer-to-Pointer and Reference-to-Pointer&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.codeguru.com/cpp/cpp/cpp_mfc/pointers/article.php/c4089/PointertoPointer-and-ReferencetoPointer.htm&quot;&gt;포인터-포인터 및 레퍼런스-포인터&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="48e4529752dcdcff6551309a435706e66b4247e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Copy constructors&lt;/em&gt;. Syntactically it makes sense to pass objects to copy constructors, and not pointers to objects. But there is just no way for a copy constructor to take an object by value - it would result in a recursive call to the same copy constructor. This leaves references as the only option here.</source>
          <target state="translated">&lt;em&gt;생성자를 복사&lt;/em&gt; 합니다. 문법적으로는 객체에 대한 포인터가 아닌 생성자를 복사하기 위해 객체를 전달하는 것이 좋습니다. 그러나 복사 생성자가 값으로 객체를 가져갈 수있는 방법은 없습니다. 동일한 복사 생성자를 재귀 적으로 호출하게됩니다. 여기서는 참조가 유일한 옵션으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="5429e39b4353f38912f315f0cc3b02247f3caa2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lvalues&lt;/em&gt;. Consider the statement &lt;code&gt;str[0] = 'X';&lt;/code&gt; Without references it would only work for c-strings (&lt;code&gt;char* str&lt;/code&gt;). Returning the character by reference allows user-defined classes to have the same notation.</source>
          <target state="translated">&lt;em&gt;L 값&lt;/em&gt; . 다음 문장을 보자. &lt;code&gt;str[0] = 'X';&lt;/code&gt; 참조가 없으면 c- 문자열 ( &lt;code&gt;char* str&lt;/code&gt; )에서만 작동합니다. 문자를 참조로 리턴하면 사용자 정의 클래스가 동일한 표기법을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6bbf825dc87806d5d7ecc42e1a033d722c63bd0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Operator overloads&lt;/em&gt;. With references it is possible to introduce indirection to an operator call - say, &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; while retaining the same infix notation. This also works for regular overloaded functions.</source>
          <target state="translated">&lt;em&gt;운영자 과부하&lt;/em&gt; . 참조를 사용하면 동일한 접두사 표기법을 유지하면서 운영자 호출에 대한 간접 참조 (예 : &lt;code&gt;operator+(const T&amp;amp; a, const T&amp;amp; b)&lt;/code&gt; 를 도입 할 수 있습니다. 이것은 정기적으로 오버로드 된 기능에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="59d32a7fbc66b86330c68b00f7b2998e9416fddd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Templates&lt;/em&gt;. Since template parameters are duck-typed, syntactic properties of a type is all that matters, so often the same template can be used with both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;템플릿&lt;/em&gt; . 템플릿 매개 변수는 오리 형식이므로 유형의 구문 속성이 가장 중요하므로 종종 동일한 템플릿을 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;T&amp;amp;&lt;/code&gt; 와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5cd9611e4f3bbd50027970fffa4f1f1bd8dbc48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;So, a pointer and a reference both use the same amount of memory.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;따라서 포인터와 참조는 모두 같은 양의 메모리를 사용합니다.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6b3894bff8b5c460864e665b4235fd4094d8df4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Remember, my examples above are just that, examples demonstrating what a reference is, you would never want to use a reference in those ways! For proper usage of a reference there are plenty of answers on here already that hit the nail on the head&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;위의 예는 단지 참조가 무엇인지 보여주는 예일뿐입니다. 그런 식으로 참조를 사용하고 싶지 않을 것입니다!&lt;/strong&gt; &lt;strong&gt;참조를 올바르게 사용하려면 여기에 이미 머리에 못을 박는 많은 답변이 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6654cb2acb8b91a57f09603862f530ef72caa5eb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reference&lt;/em&gt; can be thought of as a &lt;em&gt;constant pointer&lt;/em&gt; (not to be confused with a pointer to a constant value!) with automatic indirection, ie the compiler will apply the &lt;code&gt;*&lt;/code&gt; operator for you.</source>
          <target state="translated">&lt;em&gt;참조&lt;/em&gt; 는 자동 간접 지정을 사용하는 &lt;em&gt;상수 포인터&lt;/em&gt; (상수 값에 대한 포인터와 혼동하지 말 것)로 생각할 수 있습니다. 즉, 컴파일러가 &lt;code&gt;*&lt;/code&gt; 연산자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="36e44be1b0929668f83744e378c80d1a24783473" translate="yes" xml:space="preserve">
          <source>A compiler keeps &quot;references&quot; to variables, associating a name with a memory address; that's its job to translate any variable name to a memory address when compiling.</source>
          <target state="translated">컴파일러는 이름을 메모리 주소와 관련시켜 변수에 대한 &quot;참조&quot;를 유지합니다. 컴파일 할 때 변수 이름을 메모리 주소로 변환하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="959270cda595c9f1ce741e1f2ab621476334d43d" translate="yes" xml:space="preserve">
          <source>A const pointer's target can be replaced by taking its address and using a const cast.</source>
          <target state="translated">const 포인터의 대상은 주소를 가져오고 const 캐스트를 사용하여 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4063e6d466457440be12f195a44c703d4bcd7c2" translate="yes" xml:space="preserve">
          <source>A few more special rules on references:</source>
          <target state="translated">참고 문헌에 대한 몇 가지 특별한 규칙 :</target>
        </trans-unit>
        <trans-unit id="1b35409877b7144ea91c809ff4d316184f00d741" translate="yes" xml:space="preserve">
          <source>A pointer can be initialized to 0 and a reference not. In fact, a reference must also refer to an object, but a pointer can be the null pointer:</source>
          <target state="translated">포인터는 0으로 초기화되고 참조는 초기화되지 않습니다. 실제로 참조는 객체를 참조해야하지만 포인터는 널 포인터가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1a8b8982766e580a85ab0d0eb62a2e311e86ba" translate="yes" xml:space="preserve">
          <source>A pointer can be re-assigned:</source>
          <target state="translated">포인터를 재 할당 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5dcd9a2027d394eca47f36591f61027051772bca" translate="yes" xml:space="preserve">
          <source>A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.  Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable.  Note: What a pointer points to can be on the stack or heap.  Ditto a reference. My claim in this statement is not that a pointer must point to the stack.  A pointer is just a variable that holds a memory address.  This variable is on the stack.  Since a reference has its own space on the stack, and since the address is the same as the variable it references.  More on &lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;stack vs heap&lt;/a&gt;.  This implies that there is a real address of a reference that the compiler will not tell you.</source>
          <target state="translated">포인터는 스택에 자체 메모리 주소와 크기 (x86의 경우 4 바이트)를 갖지만, 참조는 원래 메모리와 동일한 메모리 주소를 공유하지만 스택의 일부 공간을 차지합니다. 참조는 원래 변수 자체와 동일한 주소를 가지므로 참조를 동일한 변수의 다른 이름으로 생각하는 것이 안전합니다. 참고 : 포인터가 가리키는 내용은 스택 또는 힙에있을 수 있습니다. 참조를 피하십시오. 이 진술에서 내 주장은 포인터가 스택을 가리켜 야한다는 것이 아닙니다. 포인터는 메모리 주소를 보유하는 변수 일뿐입니다. 이 변수는 스택에 있습니다. 참조에는 스택에 자체 공간이 있고 주소는 참조하는 변수와 동일하므로 &lt;a href=&quot;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936&quot;&gt;스택 대 힙&lt;/a&gt; 에 대한 추가 정보. 이것은 컴파일러가 알려주지 않는 실제 참조 주소가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fd455ef49a557a536ce9186591eed75410f73093" translate="yes" xml:space="preserve">
          <source>A pointer needs to be dereferenced with &lt;code&gt;*&lt;/code&gt; to access the memory location it points to, whereas a reference can be used directly.  A pointer to a class/struct uses &lt;code&gt;-&amp;gt;&lt;/code&gt; to access it's members whereas a reference uses a &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">가리키는 메모리 위치에 액세스하려면 포인터를 &lt;code&gt;*&lt;/code&gt; 로 참조 해제해야하지만 참조는 직접 사용할 수 있습니다. 클래스 / 구조체에 대한 포인터는 &lt;code&gt;-&amp;gt;&lt;/code&gt; 를 사용하여 멤버에 액세스하지만 참조는을 사용합니다 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d9e2dd57673143f5ecc15f3125a1e7c15d2ff7a" translate="yes" xml:space="preserve">
          <source>A pointer requires the location of a piece of space on screen that you assure it will contain zero or more instances of that window type.</source>
          <target state="translated">포인터는 해당 창 유형의 인스턴스가 0 개 이상 포함되도록 화면상의 공간 위치를 요구합니다.</target>
        </trans-unit>
        <trans-unit id="01435a266fb491eeeb93f2b49ededf5562a78098" translate="yes" xml:space="preserve">
          <source>A reference can never be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">참조는 &lt;code&gt;NULL&lt;/code&gt; 이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0db1497e17b4f2171e4c44bff76f09fecf03b574" translate="yes" xml:space="preserve">
          <source>A reference cannot, and must be assigned at initialization:</source>
          <target state="translated">참조는 초기화 할 수 없으며 초기화시 할당되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8de8f4c2eb87e4ad0059dd772dd0e8d9c15b2d0c" translate="yes" xml:space="preserve">
          <source>A reference is an alias for another variable whereas a pointer holds the memory address of a variable. References are generally used as function parameters so that the passed object is not the copy but the object itself.</source>
          <target state="translated">참조는 다른 변수의 별칭이며 포인터는 변수의 메모리 주소를 보유합니다. 참조는 일반적으로 전달 된 오브젝트가 사본이 아니라 오브젝트 자체가되도록 함수 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc4f36217977d4385453e9d1605a1d3c9c91d83" translate="yes" xml:space="preserve">
          <source>A reference is not another name given to some memory. It's a immutable pointer that is automatically de-referenced on usage. Basically it boils down to:</source>
          <target state="translated">참조는 일부 메모리에 지정된 다른 이름이 아닙니다. 사용법에서 자동으로 역 참조되는 불변 포인터입니다. 기본적으로 다음과 같이 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="408fd2770a09c3097a4198b48fb7f80ff76674a3" translate="yes" xml:space="preserve">
          <source>A reference requires you to specify an actual window.</source>
          <target state="translated">참조는 실제 창을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a62bb0cc0b8710c81c16b83f6655a27f1f4f924" translate="yes" xml:space="preserve">
          <source>A reference to a pointer is possible in C++, but the reverse is not possible means a pointer to a reference isn't possible. A reference to a pointer provides a cleaner syntax to modify the pointer.
Look at this example:</source>
          <target state="translated">C ++에서는 포인터에 대한 참조가 가능하지만 그 반대는 불가능합니다. 참조에 대한 포인터는 불가능합니다. 포인터에 대한 참조는 포인터를 수정하기위한보다 명확한 구문을 제공합니다. 이 예를보십시오 :</target>
        </trans-unit>
        <trans-unit id="f9bf408f44a75a28c1f97df5e2c724d88eaec294" translate="yes" xml:space="preserve">
          <source>A reference's target cannot be replaced in any way short of UB.</source>
          <target state="translated">참조의 목표는 UB보다 짧은 방법으로 대체 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5355053294d8994c0ecb21bffdd545b0a989f529" translate="yes" xml:space="preserve">
          <source>Actually, a reference is not really like a pointer.</source>
          <target state="translated">실제로, 참조는 실제로 포인터와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e7cbf8356a1da6417d65167e6890b1ece5d79c47" translate="yes" xml:space="preserve">
          <source>After the assignment, ival, the object addressed by pi remains unchanged. The assignment changes the value of pi, making it point to a different object. Now consider a similar program that assigns two references:</source>
          <target state="translated">할당, ival 후에 pi로 주소 지정된 객체는 변경되지 않습니다. 할당은 pi의 값을 변경하여 다른 객체를 가리 키도록합니다. 이제 두 개의 참조를 할당하는 유사한 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="789209b07ed91340d591d3ecbd391a25bb1a617e" translate="yes" xml:space="preserve">
          <source>All references must be initialized with a non-null value or compilation will fail. It's neither possible to get the address of a reference - the address operator will return the address of the referenced value instead - nor is it possible to do arithmetics on references.</source>
          <target state="translated">모든 참조는 널이 아닌 값으로 초기화해야합니다. 그렇지 않으면 컴파일이 실패합니다. 참조 주소를 얻을 수 없으며 주소 연산자가 참조 값의 주소를 대신 반환하거나 참조에 대한 산술을 수행 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a0d598143cbd5c038eec18a5364ebca3ce06755" translate="yes" xml:space="preserve">
          <source>Also, a reference that is a parameter to a function that is inlined may be handled differently than a pointer.</source>
          <target state="translated">또한 인라인 된 함수에 대한 매개 변수 인 참조는 포인터와 다르게 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="198270e21c92ca200586af9582ab1a26ef99e93d" translate="yes" xml:space="preserve">
          <source>Also, spare 10 minutes and watch this video: &lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;https://www.youtube.com/watch?v=rlJrrGV0iOg&lt;/a&gt;</source>
          <target state="translated">또한 10 분을 절약하고 다음 동영상을 시청하십시오. &lt;a href=&quot;https://www.youtube.com/watch?v=rlJrrGV0iOg&quot;&gt;https://www.youtube.com/watch?v=rlJrrGV0iOg&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="def296e5debd47695d96a2e810d313523875ea0e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;object&lt;/em&gt; type is a (possibly &lt;em&gt;cv&lt;/em&gt;-qualified) type that is not a function type, not a reference type, and not &lt;em&gt;cv&lt;/em&gt; void.</source>
          <target state="translated">&lt;em&gt;객체&lt;/em&gt; 유형은 함수 유형이 아니며 참조 유형이 아니며 &lt;em&gt;cv&lt;/em&gt; void가 아닌 ( &lt;em&gt;cv-&lt;/em&gt; qualified) 유형입니다.</target>
        </trans-unit>
        <trans-unit id="aaa58e7db6a960dc51cd22c3dc1684dfd20f847c" translate="yes" xml:space="preserve">
          <source>An optimizing compiler may realize that we are accessing a[0] and a[1] quite a bunch. It would love to optimize the algorithm to:</source>
          <target state="translated">최적화 컴파일러는 우리가 a [0]과 a [1]에 상당히 많이 액세스하고 있음을 알 수 있습니다. 알고리즘을 최적화하여 다음을 수행하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="a77f60581112f1094707329df4c6d30c6956a373" translate="yes" xml:space="preserve">
          <source>And consider the C version of the above program. In C you have to use pointer to pointer (multiple indirection), and it leads to confusion and the program may look complicated.</source>
          <target state="translated">그리고 위 프로그램의 C 버전을 고려하십시오. C에서는 포인터 포인터 (다중 간접)를 사용해야하며 혼란으로 이어지고 프로그램이 복잡해 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddb61be46c893264465a08b177ca023b9286da4f" translate="yes" xml:space="preserve">
          <source>Another difference is that pointer can point to another object however reference is always referencing to the same object, let&amp;rsquo;s take this example:</source>
          <target state="translated">또 다른 차이점은 포인터가 다른 객체를 가리킬 수 있지만 참조는 항상 동일한 객체를 참조한다는 것입니다.이 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="d9d2f372f903617152234f6054a59f4db746d3e3" translate="yes" xml:space="preserve">
          <source>Another difference is that you can have pointers to a void type (and it means pointer to anything) but references to void are forbidden.</source>
          <target state="translated">또 다른 차이점은 void 유형에 대한 포인터를 가질 수 있으며 (무엇에 대한 포인터를 의미하지만) void에 대한 참조는 금지된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ed06ace0f97d6901e5c79ad444c40f4d371c03fa" translate="yes" xml:space="preserve">
          <source>Another important point is that is we can make the declaration of the pointer without initialization however no such thing can be done in case of reference which must make a reference always to variable or object. However such use of a pointer is risky so generally we check if the pointer is actually is pointing to something or not. In case of a reference no such check is necessary, because we know already that referencing to an object during declaration is mandatory.</source>
          <target state="translated">또 다른 중요한 점은 초기화하지 않고 포인터를 선언 할 수 있지만 항상 변수 또는 객체를 참조 해야하는 참조의 경우에는 수행 할 수 없다는 것입니다. 그러나 이러한 포인터 사용은 위험하므로 일반적으로 포인터가 실제로 무언가를 가리키고 있는지 확인합니다. 참조의 경우 선언 중에 객체를 참조하는 것이 필수적이라는 것을 이미 알고 있기 때문에 그러한 검사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cab05ab1c2c0ef5b2ba43eff8ccf5c0c4d2d12e9" translate="yes" xml:space="preserve">
          <source>Another interesting use of references is to supply a default argument of a user-defined type:</source>
          <target state="translated">참조의 또 다른 흥미로운 용도는 사용자 정의 유형의 기본 인수를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8405a7757378ccd741f1d45d9bcb524d4b5f3829" translate="yes" xml:space="preserve">
          <source>Another point: When we have a template like an STL template such kind of a class template will always return a reference, not a pointer, to make easy reading or assigning new value using operator []:</source>
          <target state="translated">또 다른 요점 : STL 템플릿과 같은 템플릿이있을 때 연산자 []를 사용하여 새로운 값을 쉽게 읽거나 할당하기 위해 이러한 종류의 클래스 템플릿은 항상 포인터가 아닌 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ae9e0a7b8d69bc4223ff39bbb83d311d51fca21" translate="yes" xml:space="preserve">
          <source>Apart from syntactic sugar, a reference is a &lt;code&gt;const&lt;/code&gt; pointer (&lt;em&gt;not&lt;/em&gt; pointer to a &lt;code&gt;const&lt;/code&gt;). You must establish what it refers to when you declare the reference variable, and you cannot change it later.</source>
          <target state="translated">구문 설탕과는 별도로 참조는 &lt;code&gt;const&lt;/code&gt; 포인터가 아닌 const 포인터입니다. 참조 변수를 선언 할 때 참조하는 내용을 설정해야하며 나중에 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d8f44fcd3e6f397b6db8398ce3d44734a996ea7" translate="yes" xml:space="preserve">
          <source>As I said, a pointer to a reference isn't possible. Try the following program:</source>
          <target state="translated">내가 말했듯이 참조에 대한 포인터는 불가능합니다. 다음 프로그램을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">예로서:</target>
        </trans-unit>
        <trans-unit id="82db7c2ab0468c723d35542df3eb95e5e5ba8cad" translate="yes" xml:space="preserve">
          <source>At the highest-level, the idea of references is that they are transparent &quot;aliases&quot;. Your computer may use an address to make them work, but you're not supposed to worry about that: you're supposed to think of them as &quot;just another name&quot; for an existing object and the syntax reflects that. They are stricter than pointers so your compiler can more reliably warn you when you about to create a dangling reference, than when you are about to create a dangling pointer.</source>
          <target state="translated">최상위 수준에서 참조의 개념은 참조가 투명한 &quot;별칭&quot;이라는 것입니다. 컴퓨터가 주소를 사용하여 작동하게 할 수도 있지만 걱정할 필요는 없습니다. 기존 객체의 &quot;단지 다른 이름&quot;으로 생각해야하며 구문에 반영됩니다. 포인터보다 엄격하므로 매달려있는 포인터를 만들 때보 다 매달려있는 참조를 만들 때 컴파일러가보다 확실하게 경고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c79f63a01a5e0dc422bfd0d4cf499645ee5ba60" translate="yes" xml:space="preserve">
          <source>At the risk of adding to confusion, I want to throw in some input, I'm sure it mostly depends on how the compiler implements references, but in the case of gcc the idea that a reference can only point to a variable on the stack is not actually correct, take this for example:</source>
          <target state="translated">혼란에 추가 할 위험이 있으므로 입력을 던지고 싶습니다. 컴파일러가 참조를 구현하는 방법에 달려 있지만 gcc의 경우 참조가 스택의 변수 만 가리킬 수 있다는 생각 실제로 올바르지 않은 경우, 예를 들어 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e6de6d55fd9e888c00be46ee2285966c7f90196b" translate="yes" xml:space="preserve">
          <source>BTW, a few other contexts like initialization involving &lt;code&gt;std::initializer_list&lt;/code&gt; follows some similar rules of reference lifetime extension. It is another can of worms.</source>
          <target state="translated">BTW, &lt;code&gt;std::initializer_list&lt;/code&gt; 와 관련된 초기화와 같은 몇 가지 다른 컨텍스트는 유사한 유사한 참조 수명 연장 규칙을 따릅니다. 벌레의 또 다른 캔입니다.</target>
        </trans-unit>
        <trans-unit id="28157cc4e97b442db1a423840eb02259f1ee9ada" translate="yes" xml:space="preserve">
          <source>Back in C, a call that looks like &lt;code&gt;fn(x)&lt;/code&gt; can only be passed by value, so it definitely cannot modify &lt;code&gt;x&lt;/code&gt;; to modify an argument you would need to pass a pointer &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt;. So if an argument wasn't preceded by an &lt;code&gt;&amp;amp;&lt;/code&gt; you knew it would not be modified. (The converse, &lt;code&gt;&amp;amp;&lt;/code&gt; means modified, was not true because you would sometimes have to pass large read-only structures by &lt;code&gt;const&lt;/code&gt; pointer.)</source>
          <target state="translated">다시 C로 돌아 가면 &lt;code&gt;fn(x)&lt;/code&gt; 처럼 보이는 호출은 값만 전달할 수 있으므로 &lt;code&gt;x&lt;/code&gt; 를 수정할 수는 없습니다. 인수를 수정하려면 포인터 &lt;code&gt;fn(&amp;amp;x)&lt;/code&gt; 를 전달해야합니다. 따라서 인수 앞에 &lt;code&gt;&amp;amp;&lt;/code&gt; 가 없으면 수정되지 않을 것입니다. ( &lt;code&gt;const&lt;/code&gt; 포인터로 큰 읽기 전용 구조를 전달해야하기 때문에 대화 &lt;code&gt;&amp;amp;&lt;/code&gt; 수정 된 것은 사실이 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="52fbc9beddeb6a8c7a6bb62a43b5c950f4daeb34" translate="yes" xml:space="preserve">
          <source>Beyond that, there are of course some practical differences between pointers and references. The syntax to use them is obviously different, and you cannot &quot;re-seat&quot; references, have references to nothingness, or have pointers to references.</source>
          <target state="translated">그 외에도 포인터와 참조 사이에는 실질적인 차이점이 있습니다. 그것들을 사용하는 구문은 분명히 다르며, 참조를 &quot;다시 앉히거나&quot;, 아무 것도 참조하지 않거나, 참조를 가리키는 포인터를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f0a115b892ed33dc580b0746ea765524e9adee4" translate="yes" xml:space="preserve">
          <source>But if a reference &lt;em&gt;really&lt;/em&gt; were the object, how could there be dangling references? In unmanaged languages, it's impossible for references to be any 'safer' than pointers - there generally just isn't a way to reliably alias values across scope boundaries!</source>
          <target state="translated">그러나 참조가 &lt;em&gt;실제로&lt;/em&gt; 객체라면 어떻게 매달려있는 참조가있을 수 있습니까? 관리되지 않는 언어에서는 참조가 포인터보다 '사 페르'하는 것이 불가능합니다. 일반적으로 범위 경계에서 값을 안정적으로 별칭으로 지정할 수있는 방법은 없습니다!</target>
        </trans-unit>
        <trans-unit id="c0f0472a48232cf765cdc5a4ed86bcc402178e6e" translate="yes" xml:space="preserve">
          <source>But this is not the whole story. I mean, there are more things than pointers vs references you have to consider.</source>
          <target state="translated">그러나 이것은 전체 이야기가 아닙니다. 내 말은, 당신이 고려해야 할 포인터 대 참조보다 더 많은 것들이 있다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1219d69d4aae4754c68f172af1e20be534822a2e" translate="yes" xml:space="preserve">
          <source>But we can&amp;rsquo;t have &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; and also &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt;.</source>
          <target state="translated">그러나 우리는 &lt;code&gt;int&amp;amp; p = 0;&lt;/code&gt; 가질 수 없습니다 ; 또한 &lt;code&gt;int&amp;amp; p=5 ;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85c1119a1a34eb5b96e7a27219b6d23bf265027f" translate="yes" xml:space="preserve">
          <source>But what are the differences?</source>
          <target state="translated">그러나 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ea217864ff94b0a58af879bc82826ac7131e836c" translate="yes" xml:space="preserve">
          <source>C programmers might dislike C++ references as it will no longer be obvious when indirection happens or if an argument gets passed by value or by pointer without looking at function signatures.</source>
          <target state="translated">C 프로그래머는 간접적으로 발생하거나 인수가 함수 서명을 보지 않고 값이나 포인터로 전달되는 경우 더 이상 명확하지 않으므로 C ++ 참조를 싫어할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a06c33b9cfbaa63574bd669ad9aaf1bc634c44a" translate="yes" xml:space="preserve">
          <source>C++ only has a few kinds of syntactic sugars in this strict sense. One instance is (inherited from C) the built-in (non-overloaded) operator &lt;code&gt;[]&lt;/code&gt;, which &lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;is defined exactly having same semantic properties of specific forms of combination over built-in operator unary &lt;code&gt;*&lt;/code&gt; and binary &lt;code&gt;+&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C ++는이 엄격한 의미에서 몇 가지 종류의 구문 설탕 만 가지고 있습니다. &lt;a href=&quot;http://eel.is/c++draft/expr.sub#1&quot;&gt;내장 된 연산자 unary &lt;code&gt;*&lt;/code&gt; 및 binary &lt;code&gt;+&lt;/code&gt; 에 대한 특정 조합의 시맨틱 속성을 정확히 정의하는 정의 된 (비로드 된&lt;/a&gt; ) 연산자 &lt;code&gt;[]&lt;/code&gt; 가 하나의 인스턴스 (C에서 상 속됨)입니다.</target>
        </trans-unit>
        <trans-unit id="9bb21fac313bcd60906b2b35ca4582ec35330749" translate="yes" xml:space="preserve">
          <source>C++ programmers might dislike using pointers as they are considered unsafe - although references aren't really any safer than constant pointers except in the most trivial cases - lack the convenience of automatic indirection and carry a different semantic connotation.</source>
          <target state="translated">C ++ 프로그래머는 안전하지 않은 것으로 간주되므로 포인터 사용을 싫어할 수 있습니다. 비록 참조가 가장 사소한 경우를 제외하고는 상수 포인터보다 더 안전하지는 않지만 자동 간접의 편리함이없고 다른 의미 적 의미를 지니고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d2b52840330e7a44bc694eb6918e7e64357a038" translate="yes" xml:space="preserve">
          <source>Coming from a C background, C++ references may look like a somewhat silly concept, but one should still use them instead of pointers where possible: Automatic indirection &lt;em&gt;is&lt;/em&gt; convenient, and references become especially useful when dealing with &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt; - but not because of any perceived safety advantage, but rather because they make writing idiomatic code less awkward.</source>
          <target state="translated">C 배경에서 비롯된 C ++ 참조는 다소 어리석은 개념처럼 보일 수 있지만 가능한 경우 포인터 대신 참조를 사용해야합니다. 자동 간접 지정 &lt;em&gt;이&lt;/em&gt; 편리하고 참조가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII를&lt;/a&gt; 처리 할 때 특히 유용합니다. 그러나 관용적 코드 작성이 덜 어색해지기 때문에 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="059cdeb648fa366a46a8b8314ed53bd8fc068d24" translate="yes" xml:space="preserve">
          <source>Compound declarators are more restrictive on references.</source>
          <target state="translated">복합 선언자는 참조에 대해 더 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="403fed44f11ec4c8ff00fd23f9802e6597c6b4a0" translate="yes" xml:space="preserve">
          <source>Consider the following statement from the &lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;C++ FAQ&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://isocpp.org/wiki/faq/references#overview-refs&quot;&gt;&lt;em&gt;C ++ FAQ&lt;/em&gt;&lt;/a&gt; 의 다음 문장을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="67105debe8987091e6bdc70ef2e1c62eaeef75e5" translate="yes" xml:space="preserve">
          <source>Consider these two program fragments. In the first, we assign one pointer to another:</source>
          <target state="translated">이 두 프로그램 조각을 고려하십시오. 첫 번째로 한 포인터를 다른 포인터에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="0cdefee66dd0f6388e32b9d6fed8a4351a84480e" translate="yes" xml:space="preserve">
          <source>Const references can be bound to temporaries. Pointers cannot (not without some indirection):</source>
          <target state="translated">상수 참조는 임시에 바인딩 될 수 있습니다. 포인터는 (간접적 인 것이 없다면) 할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="257ee630683f00991c22ec378f7e691a1faab887" translate="yes" xml:space="preserve">
          <source>Contrary to popular opinion, it is possible to have a reference that is NULL.</source>
          <target state="translated">대중적인 의견과 달리 NULL 인 참조를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43548a90788ae029335a689520a48ebf306a65a2" translate="yes" xml:space="preserve">
          <source>Copy constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually it should be &lt;code&gt;const&lt;/code&gt; qualified.)</source>
          <target state="translated">복사 생성자는 첫 번째 매개 변수 유형으로 특정 유형의 &lt;em&gt;cv-&lt;/em&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; 참조 유형이 필요합니다. (그리고 일반적으로 &lt;code&gt;const&lt;/code&gt; 한정이어야합니다.)</target>
        </trans-unit>
        <trans-unit id="2dfaa6ee16a6acd02f7f18aa98b05c4a8bd6187a" translate="yes" xml:space="preserve">
          <source>Difference between pointer and reference</source>
          <target state="translated">포인터와 참조의 차이점</target>
        </trans-unit>
        <trans-unit id="8d3aac2e61ebd63a0be37ce5d8c06b59c983898f" translate="yes" xml:space="preserve">
          <source>EDIT: Five years after posting this answer, I found an actual technical difference where references are different than just a different way of looking at the same addressing concept.  References can modify the lifespan of temporary objects in a way that pointers cannot.</source>
          <target state="translated">편집 :이 답변을 게시한지 5 년 후, 나는 동일한 주소 지정 개념을 보는 다른 방법과 참조가 다른 실제 기술적 차이를 발견했습니다. 참조는 포인터가 할 수없는 방식으로 임시 객체의 수명을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afbb5feebb594dfda93806a9043262ea69ffa66b" translate="yes" xml:space="preserve">
          <source>Even that pointers are not qualified enough to be put together with references in the sense of the language design, there are still some arguments making it debatable to make choice between them in some other contexts, for example, when making choices on parameter types.</source>
          <target state="translated">포인터가 언어 디자인의 의미에서 참조와 함께 사용하기에 충분하지 않더라도 매개 변수 유형을 선택할 때와 같이 다른 컨텍스트에서 포인터를 선택할 수 있다는 논란이 여전히 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f7c6527f15ac956bb6422655a89e581ad918f6c" translate="yes" xml:space="preserve">
          <source>Even though a reference is often implemented using an address in the
  underlying assembly language, please do &lt;em&gt;not&lt;/em&gt; think of a reference as a
  funny looking pointer to an object. A reference &lt;em&gt;is&lt;/em&gt; the object. It is
  not a pointer to the object, nor a copy of the object. It &lt;em&gt;is&lt;/em&gt; the
  object.</source>
          <target state="translated">참조는 종종 기본 어셈블리 언어의 주소를 사용하여 구현되지만 참조를 객체에 대한 재미있는 모양의 포인터로 생각하지 &lt;em&gt;마십시오&lt;/em&gt; . 참조 &lt;em&gt;는&lt;/em&gt; 객체입니다. 객체에 대한 포인터 나 객체의 복사본이 아닙니다. 대상입니다.</target>
        </trans-unit>
        <trans-unit id="1f0674352c239a778bc468638b40b47fb71b2d98" translate="yes" xml:space="preserve">
          <source>Even when you do want semantics like traditional pointer, there are often something more appropriate, like &lt;code&gt;observer_ptr&lt;/code&gt; in Library Fundamental TS.</source>
          <target state="translated">전통적인 포인터와 같은 의미론을 원할 때도 종종 Library Fundamental TS의 &lt;code&gt;observer_ptr&lt;/code&gt; 과 같은 적절한 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91de4132deb2a9d1d143f39e4534fbb3726e45ff" translate="yes" xml:space="preserve">
          <source>For an older look at this problem from someone with better writing skills, see &lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;Null References&lt;/a&gt; from Jim Hyslop and Herb Sutter.</source>
          <target state="translated">글쓰기 능력이 더 좋은 사람이이 문제를 더 오래 본다면 Jim Hyslop과 Herb Sutter의 &lt;a href=&quot;http://www.gotw.ca/conv/002.htm&quot;&gt;Null References&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="c8c71250e475a3240795bff029fac330bf5c86bc" translate="yes" xml:space="preserve">
          <source>For another example of the dangers of dereferencing a null pointer see &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;Exposing undefined behavior when trying to port code to another platform&lt;/a&gt; by Raymond Chen.</source>
          <target state="translated">널 포인터 역 참조의 위험에 대한 다른 예는 Raymond Chen이 &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20171222-00/?p=97635&quot;&gt;코드를 다른 플랫폼&lt;/a&gt; 으로 포팅 할 때 정의되지 않은 동작 노출을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="419ffcbab3d6f22ef6fdb16e11f51ddef360025c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;the ISO C++ definition of object type&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://eel.is/c++draft/basic.types#8&quot;&gt;객체 유형의 ISO C ++ 정의에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c921eb398c160fb46e416cb1d07e77fdce036162" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref]/4&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://eel.is/c++draft/dcl.ref#4&quot;&gt;[dcl.ref] / 4에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bf57a6753ab8a3e91849d0a5046139bd0ae54c97" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object]/1&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://eel.is/c++draft/intro.object#1&quot;&gt;[intro.object] / 1에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="59b186995c92752fd57142834fecf2e2d3252883" translate="yes" xml:space="preserve">
          <source>Function pointers can be converted from lambda expressions without captures, while function references cannot. You have to use function pointers in non-generic code for such cases, even you deliberately do not want nullable values.</source>
          <target state="translated">함수 포인터는 캡처없이 람다 식에서 변환 할 수 있지만 함수 참조는 불가능합니다. 이러한 경우에는 제네릭이 아닌 코드에서 함수 포인터를 사용해야하며, 의도적으로 널 입력 가능 값을 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a8a000b2872f2ecd2628fd91b4af38afe4ab27a" translate="yes" xml:space="preserve">
          <source>Granted, it is much harder to do with a reference - but if you manage it, you'll tear your hair out trying to find it. References are &lt;em&gt;not&lt;/em&gt; inherently safe in C++!</source>
          <target state="translated">물론, 참조로 처리하기가 훨씬 어렵습니다.하지만 관리하면 머리카락을 찢어 버리게됩니다. 참조는 본질적으로 C ++에서 안전 &lt;em&gt;하지 않습니다&lt;/em&gt; !</target>
        </trans-unit>
        <trans-unit id="f3d615628d1fd5133dbe19b3297b67cff89e2934" translate="yes" xml:space="preserve">
          <source>Here you are not creating another variable that points to &lt;code&gt;a&lt;/code&gt;; you are just adding another name to the memory content holding the value of &lt;code&gt;a&lt;/code&gt;. This memory now has two names, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and it can be addressed using either name.</source>
          <target state="translated">여기서는;을 가리키는 다른 변수를 작성하지 않습니다. &lt;code&gt;a&lt;/code&gt; 의 값을 보유하는 메모리 내용에 다른 이름을 추가 하고 있습니다. 이 메모리에는 이제 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 두 이름이 있으며 어느 이름을 사용하여도 주소를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6748018a83feee685129beabf05358adfb1f4a93" translate="yes" xml:space="preserve">
          <source>I can't say I'm really happy with this particular difference. I would much prefer it would be allowed with the meaning reference to anything with an address and otherwise the same behavior for references. It would allow to define some equivalents of C library functions like memcpy using references.</source>
          <target state="translated">나는이 특별한 차이에 정말로 만족한다고 말할 수 없다. 주소가있는 모든 항목에 대한 의미 참조가 허용되고 참조에 대해 동일한 동작이 허용되는 것이 훨씬 좋습니다. 참조를 사용하여 memcpy와 같은 일부 C 라이브러리 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83cff075b67cc3caa75652556ccf090327793e2f" translate="yes" xml:space="preserve">
          <source>I feel like there is yet another point that hasn't been covered here.</source>
          <target state="translated">나는 여기에서 다루지 않은 또 다른 요점이 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="78aca0acaa65086aab3a232e328bb0bc36aa5fcb" translate="yes" xml:space="preserve">
          <source>I know references are syntactic sugar, so code is easier to read and write.</source>
          <target state="translated">참조는 구문 설탕이라는 것을 알고 있으므로 코드를 읽고 쓰기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="790a903c1bebeddd1477cdd4d06bfb3b8a62ae9b" translate="yes" xml:space="preserve">
          <source>I use references unless I need either of these:</source>
          <target state="translated">다음 중 하나가 필요하지 않으면 참조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3068917d6116da066c23030c927f12eb7a21feb4" translate="yes" xml:space="preserve">
          <source>I want to reiterate that the only way to get a null reference is through malformed code, and once you have it you're getting undefined behavior. It &lt;strong&gt;never&lt;/strong&gt; makes sense to check for a null reference; for example you can try &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; but the compiler might optimize the statement out of existence! A valid reference can never be NULL so from the compiler's view the comparison is always false, and it is free to eliminate the &lt;code&gt;if&lt;/code&gt; clause as dead code - this is the essence of undefined behavior.</source>
          <target state="translated">null 참조를 얻는 유일한 방법은 잘못된 코드를 통한 것임을 반복하고 싶습니다. 일단 코드가 있으면 정의되지 않은 동작이 나타납니다. null 참조를 확인하는 것은 의미가 &lt;strong&gt;없습니다&lt;/strong&gt; . 예를 들어 &lt;code&gt;if(&amp;amp;bar==NULL)...&lt;/code&gt; 시도해 볼 수 있지만 컴파일러는 존재하지 않는 명령문을 최적화 할 수 있습니다! 유효한 참조는 NULL이 될 수 없으므로 컴파일러의 관점에서 비교는 항상 거짓이며 &lt;code&gt;if&lt;/code&gt; 절을 데드 코드로 제거 할 수 있습니다. 이것이 정의되지 않은 동작의 본질입니다.</target>
        </trans-unit>
        <trans-unit id="28a1dd0bb23764b68abee77b06fa28aa411978df" translate="yes" xml:space="preserve">
          <source>If you are doing some iterations over a range, use iterators (or some ranges which are not provided by the standard library yet), rather than raw pointers unless you are convinced raw pointers will do better (e.g. for less header dependencies) in very specific cases.</source>
          <target state="translated">범위에 대해 일부 반복을 수행하는 경우 원시 포인터가 매우 구체적으로 더 잘 수행 할 것으로 확신하지 않는 한 원시 포인터 대신 반복자 (또는 표준 라이브러리에서 아직 제공하지 않은 일부 범위)를 사용하십시오. 사례.</target>
        </trans-unit>
        <trans-unit id="3ba495f422aa5c4d4099a4f3e279461a678eacba" translate="yes" xml:space="preserve">
          <source>If you come to see the question via &lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;some Google search result (not specific to C++)&lt;/a&gt;, this is very likely to be the wrong place.</source>
          <target state="translated">&lt;a href=&quot;https://www.google.com/search?q=pointer+vs+reference&amp;amp;hl=en&quot;&gt;일부 Google 검색 결과 (C ++에만 해당되지 않음)&lt;/a&gt; 를 통해 질문이 표시되면 잘못된 위치 일 가능성이 큽니다.</target>
        </trans-unit>
        <trans-unit id="1adb9ff9254b1ced3f48e2cba167b170d900e4b7" translate="yes" xml:space="preserve">
          <source>If you don't have to stick on such over-specific choices, in most cases the answer is short: &lt;strong&gt;you do not have the necessity to use pointers, so you don't&lt;/strong&gt;. Pointers are usually bad enough because they imply too many things you don't expect and they will rely on too many implicit assumptions undermining the maintainability and (even) portability of the code. &lt;strong&gt;Unnecessarily relying on pointers is definitely a bad style and it should be avoided in the sense of modern C++.&lt;/strong&gt; Reconsider your purpose and you will finally find that &lt;strong&gt;pointer is the feature of last sorts&lt;/strong&gt; in most cases.</source>
          <target state="translated">이러한 특정 선택을 고수 할 필요가 없다면 대부분의 경우 대답이 짧습니다. &lt;strong&gt;포인터를 사용할 필요가 없으므로 그렇게하지 마십시오&lt;/strong&gt; . 포인터는 일반적으로 예상치 못한 것들을 너무 많이 암시하기 때문에 충분히 나쁘고 코드의 유지 관리 성 및 심지어 이식성을 손상시키는 너무 많은 암시 적 가정에 의존합니다. &lt;strong&gt;불필요하게 포인터에 의존하는 것은 분명히 나쁜 스타일이므로 현대적인 C ++의 의미에서 피해야합니다.&lt;/strong&gt; 목적을 재고하면 &lt;strong&gt;포인터가&lt;/strong&gt; 대부분의 경우 &lt;strong&gt;마지막 정렬의 기능&lt;/strong&gt; 이라는 것을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb2d77074444d61d2cc67de2bd0e1d87f2a0a031" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value (i.e. using non-reference types) is sufficient, use it directly, particularly when using an implementation supporting C++17 mandated copy elision. (&lt;strong&gt;Warning&lt;/strong&gt;: However, to &lt;strong&gt;exhaustively&lt;/strong&gt; reason about the necessity can be &lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;very complicated&lt;/a&gt;.)</source>
          <target state="translated">값으로 전달 (예 : 비 참조 유형 사용)으로 충분하다는 것을 알고 있다면, 특히 C ++ 17 필수 복사 제거를 지원하는 구현을 사용할 때 직접 사용하십시오. ( &lt;strong&gt;경고&lt;/strong&gt; : 그러나 필요성에 대한 &lt;strong&gt;철저한&lt;/strong&gt; 추론은 &lt;a href=&quot;https://stackoverflow.com/a/53825424&quot;&gt;매우 복잡&lt;/a&gt; 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8ab269d4d0dfc63f1830ebd5af6f660e85c8c775" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is not ideal for the reasons above, and you don't want nullable semantics, use {lvalue, rvalue, forwarding}-references.</source>
          <target state="translated">위의 이유로 값으로 전달이 이상적이지 않고 널 입력 가능 의미를 원하지 않는 경우 {lvalue, rvalue, forwarding} -references를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="95a97bbef840565852fb933bd387402999a8aa62" translate="yes" xml:space="preserve">
          <source>If you know pass-by-value is sufficient and you want some explicit nullable semantics, use wrapper like &lt;code&gt;std::optional&lt;/code&gt;, rather than raw pointers.</source>
          <target state="translated">값별 전달이 충분하고 명시적인 nullable 의미를 원할 경우 원시 포인터 대신 &lt;code&gt;std::optional&lt;/code&gt; 과 같은 래퍼를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f83f246714f814ce810c05a9ae95c69e9261bd39" translate="yes" xml:space="preserve">
          <source>If you notice even the memory addresses are exactly the same, meaning the reference is successfully pointing to a variable on the heap! Now if you really want to get freaky, this also works:</source>
          <target state="translated">메모리 주소조차 정확히 같다는 것을 알면 참조가 힙의 변수를 성공적으로 가리키고 있음을 의미합니다! 이제 당신이 정말로 이상한 것을 원한다면, 이것은 또한 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="f057014d6ad0660324ee4744392d34f7205d30d5" translate="yes" xml:space="preserve">
          <source>If you try this without the &lt;code&gt;const&lt;/code&gt; it should fail to compile. You cannot bind a non-const reference to a temporary object, nor can you take its address for that matter.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 없이 이것을 시도하면 컴파일에 실패해야합니다. 상수가 아닌 참조를 임시 객체에 바인딩하거나 해당 문제에 대한 주소를 취할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="543e04d6c7cf8b1ff3568e8f9fe688b2b4150999" translate="yes" xml:space="preserve">
          <source>If you want to be really pedantic, there is one thing you can do with a reference that you can't do with a pointer: extend the lifetime of a temporary object. In C++ if you bind a const reference to a temporary object, the lifetime of that object becomes the lifetime of the reference.</source>
          <target state="translated">정말 장난 스럽기를 원한다면 포인터로 할 수없는 참조로 할 수있는 한 가지가 있습니다 : 임시 객체의 수명을 연장하십시오. C ++에서 const 참조를 임시 객체에 바인딩하면 해당 객체의 수명이 참조의 수명이됩니다.</target>
        </trans-unit>
        <trans-unit id="2f134bd878c28bfcf0e94f5edce84bd4768767e8" translate="yes" xml:space="preserve">
          <source>If you want to operate some handles with ownership, use smart pointers like &lt;code&gt;unique_ptr&lt;/code&gt; and &lt;code&gt;shared_ptr&lt;/code&gt; (or even with homebrew ones by yourself if you require them to be &lt;em&gt;opaque&lt;/em&gt;), rather than raw pointers.</source>
          <target state="translated">소유권을 가진 일부 핸들을 조작하려면 원시 포인터 대신 &lt;code&gt;unique_ptr&lt;/code&gt; 및 &lt;code&gt;shared_ptr&lt;/code&gt; 과 같은 스마트 포인터를 사용하십시오 (또는 &lt;em&gt;불투명&lt;/em&gt; 해야하는 경우 직접 만든자가 포인터).</target>
        </trans-unit>
        <trans-unit id="f9770a58e8e2c829e550700ed47290c2aae7fa6f" translate="yes" xml:space="preserve">
          <source>In fact to do it properly, we must have declared and defined an object at the first then we can make a reference to that object, so the correct implementation of the previous code will be:</source>
          <target state="translated">실제로 올바르게 수행하려면 처음에 객체를 선언하고 정의한 다음 해당 객체에 대한 참조를 만들 수 있으므로 이전 코드의 올바른 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82769a796fb3193fe927e0baf51f38ab518d3ebb" translate="yes" xml:space="preserve">
          <source>In other words, a reference is nothing but a pointer that has the pointer mechanics abstracted away, making it safer and easier to use (no accidental pointer math, no mixing up '.' and '-&amp;gt;', etc.), assuming you don't try any nonsense like my examples above ;)</source>
          <target state="translated">다시 말해서, 참조는 포인터 메커니즘을 추상화 한 포인터에 불과하며, 안전하고 사용하기 쉽도록 만듭니다 (우연한 포인터 수학, '.'와 '-&amp;gt;'등을 섞지 않음 등). 위의 예제와 같은 말도 안됩니다.)</target>
        </trans-unit>
        <trans-unit id="200b5d2213958228565fdde5b08d7bf3a0e7e8c1" translate="yes" xml:space="preserve">
          <source>In this example s3_copy copies the temporary object that is a result of the concatenation. Whereas s3_reference in essence becomes the temporary object. It's really a reference to a temporary object that now has the same lifetime as the reference.</source>
          <target state="translated">이 예에서 s3_copy는 연결의 결과 인 임시 객체를 복사합니다. 본질적으로 s3_reference는 임시 객체가됩니다. 실제로는 참조와 수명이 동일한 임시 객체에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="ba73ce596882bac23adab797099d810c536e52c7" translate="yes" xml:space="preserve">
          <source>It also has to prove that there are no ways a future call could read/write a[0] while we have a temporary register copy of it in a0. This is often trivial to prove, because in many cases it is obvious that the reference is never stored in a permanent structure like a class instance.</source>
          <target state="translated">또한 a0에 임시 레지스터 사본이있는 동안 향후 호출에서 a [0]을 읽고 쓸 수있는 방법이 없음을 증명해야합니다. 많은 경우에 참조가 클래스 인스턴스와 같은 영구 구조에 저장되지 않는 것이 분명하기 때문에 이는 종종 증명하기가 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0cc1580772a83020df85287d6f8e26c7bd8a5f0" translate="yes" xml:space="preserve">
          <source>It doesn't matter how much space it takes up since you can't actually see any side effect (without executing code) of whatever space it would take up.</source>
          <target state="translated">차지하는 공간에 대한 부작용 (코드 실행없이)을 실제로 볼 수 없으므로 차지하는 공간은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d798a27c2d2b93f1136b70dcfad1e9fac904cd6" translate="yes" xml:space="preserve">
          <source>It internally becomes</source>
          <target state="translated">내부적으로됩니다</target>
        </trans-unit>
        <trans-unit id="2dbb06a19fcf0fb6d64e79da18f5a426b98c98ee" translate="yes" xml:space="preserve">
          <source>It is unspecified whether or not a reference requires storage.</source>
          <target state="translated">참조에 스토리지가 필요한지 여부는 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b288f3fae88ae371415949edcc0c9e0886821a41" translate="yes" xml:space="preserve">
          <source>It may be important to know, object type is a top-level category of the type universe in C++. Reference is also a top-level category. &lt;strong&gt;But pointer is not.&lt;/strong&gt;</source>
          <target state="translated">개체 유형은 C ++에서 유형 유니버스의 최상위 범주입니다. 참조는 최상위 범주이기도합니다. &lt;strong&gt;그러나 포인터는 아닙니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b45412ddd0ff9c77b1d05ade69b201525767735" translate="yes" xml:space="preserve">
          <source>Language neutrality caveats</source>
          <target state="translated">언어 중립주의</target>
        </trans-unit>
        <trans-unit id="55dd62362caab929ec378cd05497a3ec85467b37" translate="yes" xml:space="preserve">
          <source>Look at the following statement,</source>
          <target state="translated">다음 진술을보십시오.</target>
        </trans-unit>
        <trans-unit id="d7297eb6becdd735c4545511c38d16ada0827023" translate="yes" xml:space="preserve">
          <source>Many compilers when inlining the pointer version one will actually force a write to memory (we are taking the address explicitly).  However, they will leave the reference in a register which is more optimal.</source>
          <target state="translated">포인터 버전 1을 인라인 할 때 많은 컴파일러가 실제로 메모리에 쓰기를 강제합니다 (주소를 명시 적으로 사용함). 그러나 그들은 더 최적의 레지스터에 참조를 남길 것입니다.</target>
        </trans-unit>
        <trans-unit id="ea2aee18995ab103eed08b69ba07dcb31625dabf" translate="yes" xml:space="preserve">
          <source>Maybe some metaphors will help; 
In the context of your desktop screenspace -</source>
          <target state="translated">아마도 어떤 은유가 도움이 될 것입니다. 데스크탑 화면 공간의 맥락에서-</target>
        </trans-unit>
        <trans-unit id="ac946397b09fb907e8acce3c92c880b361a9a242" translate="yes" xml:space="preserve">
          <source>Modern compilers are getting better and better at static analysis, but it is always nice to help them out and use references.</source>
          <target state="translated">최신 컴파일러는 정적 분석에서 점점 더 나아지고 있지만 항상 도움을주고 참조를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bf6c60a1e5c2679ef0162d45b8f206f16bcdd7d1" translate="yes" xml:space="preserve">
          <source>Move constructors require specific types of &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; reference type as the 1st parameter type. (And usually there should be no qualifiers.)</source>
          <target state="translated">이동 생성자는 첫 번째 매개 변수 유형으로 특정 유형의 &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 참조 유형이 필요합니다. (그리고 보통 한정자가 없어야합니다.)</target>
        </trans-unit>
        <trans-unit id="1b9630be120a68e57ca22b6ff58fa3a235507cba" translate="yes" xml:space="preserve">
          <source>My example above is short and contrived. Here's a more real-world example.</source>
          <target state="translated">위의 예는 짧고 고안되었습니다. 보다 실제적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56e71102cceade878735d306276129a65b04b038" translate="yes" xml:space="preserve">
          <source>Normally temporary objects such as the one created by the call to &lt;code&gt;createF(5)&lt;/code&gt; are destroyed at the end of the expression.  However, by binding that object to a reference, &lt;code&gt;ref&lt;/code&gt;, C++ will extend the lifespan of that temporary object until &lt;code&gt;ref&lt;/code&gt; goes out of scope.</source>
          <target state="translated">일반적으로 &lt;code&gt;createF(5)&lt;/code&gt; 호출에 의해 생성 된 것과 같은 임시 객체는 표현식의 끝에서 제거됩니다. 그러나 해당 객체를 참조 &lt;code&gt;ref&lt;/code&gt; 에 바인딩하면 C ++은 &lt;code&gt;ref&lt;/code&gt; 가 범위를 벗어날 때까지 해당 임시 객체의 수명을 연장합니다.</target>
        </trans-unit>
        <trans-unit id="b2dd5770081924d799a48921378b48818433c7bb" translate="yes" xml:space="preserve">
          <source>Note the statements above only mentions &quot;pointers&quot; and &quot;references&quot; as types. There are some interested questions about their instances (like variables). There also come too many misconceptions.</source>
          <target state="translated">위의 설명은 &quot;포인터&quot;및 &quot;참조&quot;만 유형으로 언급합니다. 인스턴스와 관련하여 변수와 같은 몇 가지 흥미로운 질문이 있습니다. 오해가 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="0112dd76dee19c15ddada9b0763e06e1cbc7faf4" translate="yes" xml:space="preserve">
          <source>Note these are &lt;em&gt;semantic&lt;/em&gt; properties.</source>
          <target state="translated">이것은 &lt;em&gt;시맨틱&lt;/em&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="32c54f61399cee485b86cada14cf3ef339a2f916" translate="yes" xml:space="preserve">
          <source>Now &lt;strong&gt;regardless&lt;/strong&gt; of how a compiler handles references, it will &lt;strong&gt;always&lt;/strong&gt; have some kind of pointer under the hood, because a reference &lt;strong&gt;must&lt;/strong&gt; refer to a specific variable at a specific memory address for it to work as expected, there is no getting around this (hence the term 'reference').</source>
          <target state="translated">이제 컴파일러가 참조를 처리하는 방법에 &lt;strong&gt;관계없이&lt;/strong&gt; 참조 &lt;strong&gt;는&lt;/strong&gt; 예상대로 작동하기 위해 특정 메모리 주소에서 특정 변수를 참조 &lt;strong&gt;해야&lt;/strong&gt; 하기 때문에 &lt;strong&gt;항상&lt;/strong&gt; 후드 아래에 일종의 포인터가 &lt;strong&gt;있어야합니다.&lt;/strong&gt; '참조'라는 용어).</target>
        </trans-unit>
        <trans-unit id="752e698d55444e3238d56a6bc3da3af23d39ce29" translate="yes" xml:space="preserve">
          <source>Now do the same thing with pointers</source>
          <target state="translated">이제 포인터로 같은 일을하십시오.</target>
        </trans-unit>
        <trans-unit id="e6bdf4bf7e4af7604beaed717ed9319201ff15be" translate="yes" xml:space="preserve">
          <source>Now some explanation of real code:</source>
          <target state="translated">이제 실제 코드에 대한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="586d3a296148dea14411f5e77a90d02cd7148035" translate="yes" xml:space="preserve">
          <source>Now there may be some cases where your compiler may not be able to know the reference when compiling, like when using an extern variable. So a reference may or may not be implemented as a pointer in the underlying code. But in the examples I gave you, it will most likely not be implemented with a pointer.</source>
          <target state="translated">extern 변수를 사용할 때와 같이 컴파일러가 컴파일 할 때 참조를 알지 못하는 경우가있을 수 있습니다. 따라서 참조는 기본 코드에서 포인터로 구현되거나 구현되지 않을 수 있습니다. 그러나 내가 준 예제에서 포인터로 구현되지 않았을 가능성이 큽니다.</target>
        </trans-unit>
        <trans-unit id="808cc104c235301ef1bc79319f8102ad43971fef" translate="yes" xml:space="preserve">
          <source>Null pointers can be used as a
sentinel value, often a cheap way to
avoid function overloading or use of
a bool.</source>
          <target state="translated">널 포인터는 센티넬 값으로 사용될 수 있으며, 종종 함수 과부하 또는 부울 사용을 피하는 저렴한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="67ae9809624c429d324c275faf9d92d1518e204d" translate="yes" xml:space="preserve">
          <source>Object types can have top-level &lt;code&gt;cv&lt;/code&gt; qualifiers. References cannot.</source>
          <target state="translated">객체 유형에는 최상위 &lt;code&gt;cv&lt;/code&gt; 한정자가있을 수 있습니다. 참조는 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="00a1b2cda377012d0e23e72a9f8fed0898939786" translate="yes" xml:space="preserve">
          <source>Of course, barring such clever optimizations, compilers will indeed turn references into pointers when needed.</source>
          <target state="translated">물론 그러한 영리한 최적화를 제외하고 컴파일러는 필요할 때 참조를 포인터로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="dc07d79fb5ff33400c26bc7a53b5a0a72e7aefd6" translate="yes" xml:space="preserve">
          <source>Of course, for functions that are not inlined the pointer and reference generate the same code and it's always better to pass intrinsics by value than by reference if they are not modified and returned by the function.</source>
          <target state="translated">물론 인라인되지 않은 함수의 경우 포인터와 참조가 동일한 코드를 생성하며 함수에 의해 수정 및 반환되지 않은 경우 참조보다 값으로 내장 함수를 전달하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="828bf90967e721e857197022098eb853d37eaa44" translate="yes" xml:space="preserve">
          <source>On the other hand, one major difference between references and pointers is that temporaries assigned to const references live until the const reference goes out of scope.</source>
          <target state="translated">반면, 참조와 포인터의 주요 차이점은 const 참조에 할당 된 임시는 const 참조가 범위를 벗어날 때까지 유지된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="90dd91d02279fe6ccfc85544573813d23da86513" translate="yes" xml:space="preserve">
          <source>Otherwise, it is insignificant that pointers can be qualified as a specific sorts of types with references together. They simply share too few common properties besides the syntax similarity, so there is no need to put them together in most cases.</source>
          <target state="translated">그렇지 않으면, 포인터가 함께 참조가있는 특정 유형의 유형으로 포인터를 규정 할 수있는 것은 중요하지 않습니다. 그것들은 구문 유사성 이외에도 너무 적은 공통 속성을 공유하므로 대부분의 경우에 그것들을 함께 묶을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c468e66383b3acff1decf7ebfe1722418b200e03" translate="yes" xml:space="preserve">
          <source>Overloaded &lt;code&gt;operator=&lt;/code&gt; as special member functions requires reference types similar to 1st parameter of copy/move constructors.</source>
          <target state="translated">특수 멤버 함수 인 오버로드 된 &lt;code&gt;operator=&lt;/code&gt; 에는 복사 / 이동 생성자의 첫 번째 매개 변수와 유사한 참조 유형이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7f2c3e2cc509718d63ded349b2aab9f792237302" translate="yes" xml:space="preserve">
          <source>Pointer can be assigned &lt;code&gt;nullptr&lt;/code&gt; directly, whereas reference cannot. If you try hard enough, and you know how, you can make the address of a reference &lt;code&gt;nullptr&lt;/code&gt;.  Likewise, if you try hard enough you can have a reference to a pointer, and then that reference can contain &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">포인터에는 &lt;code&gt;nullptr&lt;/code&gt; 을 직접 할당 할 수 있지만 참조는 할 수 없습니다. 충분히 노력하고 방법을 알고 있다면 참조 &lt;code&gt;nullptr&lt;/code&gt; 의 주소를 만들 수 있습니다. 마찬가지로, 충분히 노력하면 포인터에 대한 참조를 가질 수 있으며 해당 참조에는 &lt;code&gt;nullptr&lt;/code&gt; 이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8dd03a2b7cf3f5874fc9c97bd98b107bc98bfa9" translate="yes" xml:space="preserve">
          <source>Pointers and references are mentioned together &lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;in the context of &lt;em&gt;compound type&lt;/em&gt;&lt;/a&gt;. This is basically due to the nature of the declarator syntax inherited from (and extended) C, which has no references. (Besides, there are more than one kind of declarator of references since C++ 11, while pointers are still &quot;unityped&quot;: &lt;code&gt;&amp;amp;&lt;/code&gt;+&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; vs. &lt;code&gt;*&lt;/code&gt;.) So drafting a language specific by &quot;extension&quot; with similar style of C in this context is somewhat reasonable. (I will still argue that the syntax of declarators wastes the syntactic expressiveness &lt;em&gt;a lot&lt;/em&gt;, makes both human users and implementations frustrating. Thus, all of them are not qualified to be &lt;em&gt;built-in&lt;/em&gt; in a new language design. This is a totally different topic about PL design, though.)</source>
          <target state="translated">포인터와 참조는 &lt;a href=&quot;http://eel.is/c++draft/basic.compound#1&quot;&gt;&lt;em&gt;복합 유형&lt;/em&gt; 의 맥락에서&lt;/a&gt; 함께 언급됩니다. 이것은 기본적으로 참조가없는 C에서 상속 된 (및 확장 된) 선언자 구문의 특성 때문입니다. (또한 C ++ 11부터는 여러 종류의 참조 선언자가 있지만 포인터는 여전히 &quot;유일한&quot;형식입니다 : &lt;code&gt;&amp;amp;&lt;/code&gt; + &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; vs. &lt;code&gt;*&lt;/code&gt; . 따라서이 문맥에서 비슷한 스타일의 C를 사용하여 &quot;확장자&quot;로 특정 언어를 작성 다소 합리적입니다. (나는 여전히 선언문의 구문이 구문 표현력 &lt;em&gt;을 많이&lt;/em&gt; 낭비하고 인간 사용자와 구현을 모두 좌절하게 만든다고 주장 할 것이다. 따라서 이들 모두는 새로운 언어 디자인에 &lt;em&gt;내장&lt;/em&gt; 되어 있지 않다. 완전히 다른 주제이다. 그러나 PL 디자인에 관한 것입니다.)</target>
        </trans-unit>
        <trans-unit id="8e79db4216ca0b1682917f0312184de116274ee0" translate="yes" xml:space="preserve">
          <source>Pointers are variables; they contain the address of some other variable, or can be null. The important thing is that a pointer has a value, while a reference only has a variable that it is referencing.</source>
          <target state="translated">포인터는 변수입니다. 다른 변수의 주소를 포함하거나 null 일 수 있습니다. 중요한 것은 포인터에 값이 있고 참조에는 참조하는 변수 만 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4c98c7b23dbb9c431cf37cec4103729a3b3df7c" translate="yes" xml:space="preserve">
          <source>Pointers can iterate over an array, you can use &lt;code&gt;++&lt;/code&gt; to go to the next item that a pointer is pointing to, and &lt;code&gt;+ 4&lt;/code&gt; to go to the 5th element.  This is no matter what size the object is that the pointer points to.</source>
          <target state="translated">포인터는 배열을 반복 할 수 있습니다. &lt;code&gt;++&lt;/code&gt; 를 사용하여 포인터가 가리키는 다음 항목으로 이동하고 &lt;code&gt;+ 4&lt;/code&gt; 를 사용하여 5 번째 요소로 이동할 수 있습니다. 이것은 포인터가 가리키는 객체의 크기에 관계없이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0041b69bd78f1922ccacbca89c0bd23258263cde" translate="yes" xml:space="preserve">
          <source>Postfix &lt;code&gt;++&lt;/code&gt; requires dummy &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Postfix &lt;code&gt;++&lt;/code&gt; 에는 dint &lt;code&gt;int&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9c40deca9098c33c4507f06a0277ec7d603682af" translate="yes" xml:space="preserve">
          <source>Pragmatics</source>
          <target state="translated">Pragmatics</target>
        </trans-unit>
        <trans-unit id="462242db0811f3f971e9fd491ae343b8badcc883" translate="yes" xml:space="preserve">
          <source>RAII is one of the central concepts of C++, but it interacts non-trivially with copying semantics. Passing objects by reference avoids these issues as no copying is involved. If references were not present in the language, you'd have to use pointers instead, which are more cumbersome to use, thus violating the language design principle that the best-practice solution should be easier than the alternatives.</source>
          <target state="translated">RAII는 C ++의 핵심 개념 중 하나이지만 복사 의미론과 사소하지 않게 상호 작용합니다. 참조로 객체를 전달하면 복사가 필요 없으므로 이러한 문제를 피할 수 있습니다. 언어로 된 참조가 없으면 대신 포인터를 사용해야하므로 사용하기가 더 번거로우므로 최선의 솔루션이 대안보다 쉬워야한다는 언어 설계 원칙을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="055cd393f567fac0ba4089ec8ff85252aac14bdb" translate="yes" xml:space="preserve">
          <source>References are allowed to refer to variables which do not have memory addresses, such as those the compiler chooses to put into registers. If you take the address of a local variable, it is very hard for the compiler to put it in a register.</source>
          <target state="translated">참조는 메모리 주소가없는 변수 (예 : 컴파일러가 레지스터에 넣는 변수)를 참조 할 수 있습니다. 로컬 변수의 주소를 사용하면 컴파일러가 레지스터에 레지스터를 넣기가 매우 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="5a853555e7fde5a31207074a784b524c82ed58aa" translate="yes" xml:space="preserve">
          <source>References are designed such that it is substantially easier for the compiler to trace which reference aliases which variables. Two major features are very important: no &quot;reference arithmetic&quot; and no reassigning of references. These allow the compiler to figure out which references alias which variables at compile time.</source>
          <target state="translated">참조는 컴파일러가 변수에 대한 참조 별칭을 추적하기가 훨씬 쉬워 지도록 설계되었습니다. &quot;참조 산술&quot;및 참조 재 할당 없음의 두 가지 주요 기능이 매우 중요합니다. 이를 통해 컴파일러는 컴파일 할 때 어떤 변수가 별칭을 참조하는지 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e813db94099ca02f715fb0f1ba9f33611db2f553" translate="yes" xml:space="preserve">
          <source>References are very similar to pointers, but they are specifically crafted to be helpful to optimizing compilers.</source>
          <target state="translated">참조는 포인터와 매우 유사하지만 컴파일러 최적화에 도움이되도록 특별히 제작되었습니다.</target>
        </trans-unit>
        <trans-unit id="bf6fd50fdee7317a481645b6fae553557dc3cdd2" translate="yes" xml:space="preserve">
          <source>References can &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;collapse&lt;/a&gt;.</source>
          <target state="translated">참조가 &lt;a href=&quot;http://eel.is/c++draft/dcl.ref#6&quot;&gt;축소&lt;/a&gt; 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3206ad161847bd2d29f9d31a405ed11c7d64c2" translate="yes" xml:space="preserve">
          <source>References cannot be stuffed into an array, whereas pointers can be (Mentioned by user @litb)</source>
          <target state="translated">참조는 배열에 채워 넣을 수 없지만 포인터는 (@litb 사용자가 인용)</target>
        </trans-unit>
        <trans-unit id="cfca6984c06ae05fa650e3c0076a1855343215bb" translate="yes" xml:space="preserve">
          <source>References have special rules in initialization. The lifetime of variable declared as a reference type can be different to ordinary objects via extension.</source>
          <target state="translated">참조에는 초기화에 특별한 규칙이 있습니다. 참조 유형으로 선언 된 변수의 수명은 확장을 통해 일반 객체와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="526784942b6e34cc8eb97ec6c1946f69db4aa93c" translate="yes" xml:space="preserve">
          <source>References in C++ is quite &quot;odd&quot;, as it is essentially not first-class: &lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;they will be treated as the objects or the functions being referred to&lt;/a&gt; so they have no chance to support some first-class operations like being the left operand of &lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;the member access operator&lt;/a&gt; independently to the type of the referred object. Other languages may or may not have similar restrictions on their references.</source>
          <target state="translated">C ++의 참조는 본질적으로 일류가 아니기 때문에 상당히 &quot;홀수&quot;입니다. &lt;a href=&quot;http://eel.is/c++draft/expr#type-1&quot;&gt;그것들은 참조되는 객체 또는 함수로 취급&lt;/a&gt; 되므로 왼쪽 피연산자와 같은 일류 연산을 지원할 기회가 없습니다 &lt;a href=&quot;http://eel.is/c++draft/expr.ref&quot;&gt;.&lt;/a&gt; 참조 된 객체의 유형에 독립적으로 멤버 액세스 연산자 . 다른 언어는 참조에 대해 유사한 제한이 있거나 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d003206a70c36ecf7a0315ea6420395ec7e35600" translate="yes" xml:space="preserve">
          <source>References in C++ will likely not preserve the meaning across different languages. For example, references in general do not imply nonnull properties on values like they in C++, so such assumptions may not work in some other languages (and you will find counterexamples quite easily, e.g. Java, C#, ...).</source>
          <target state="translated">C ++의 참조는 다른 언어의 의미를 보존하지 않을 것입니다. 예를 들어, 일반적으로 참조는 C ++에서와 같은 값에 null이 아닌 속성을 의미하지 않으므로 이러한 가정은 다른 언어에서는 작동하지 않을 수 있습니다 (예 : Java, C #, ...).</target>
        </trans-unit>
        <trans-unit id="776a07f1188f204d3f88257d0ec6a07a29887cdc" translate="yes" xml:space="preserve">
          <source>Regards,
&amp;amp;rzej</source>
          <target state="translated">Regards,
&amp;amp;rzej</target>
        </trans-unit>
        <trans-unit id="f29ff291ec91fbd3d5e03a84623244a66ed645e4" translate="yes" xml:space="preserve">
          <source>Run the program and have a look at the output and you'll understand.</source>
          <target state="translated">프로그램을 실행하고 출력을 살펴보면 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01841626b366982706bd9cb74359851e4287a00f" translate="yes" xml:space="preserve">
          <source>Simply to remember that,</source>
          <target state="translated">간단히 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="7ed3e2e5988e139dbdad2bddeb8aea77458c5333" translate="yes" xml:space="preserve">
          <source>So, in practice, the answer is so obvious: &lt;strong&gt;when in doubt, avoid pointers&lt;/strong&gt;. You have to use pointers only when there are very explicit reasons that nothing else is more appropriate. Except a few exceptional cases mentioned above, such choices are almost always not purely C++-specific (but likely to be language-implementation-specific). Such instances can be:</source>
          <target state="translated">따라서 실제로 대답은 매우 분명합니다. &lt;strong&gt;의심스러운 경우 포인터를 피하십시오&lt;/strong&gt; . 다른 것이 더 적절하지 않은 명백한 이유가있는 경우에만 포인터를 사용해야합니다. 위에서 언급 한 몇 가지 예외적 인 경우를 제외하고, 그러한 선택은 거의 항상 C ++에만 국한되지는 않습니다 (그러나 언어 구현에 따라 다를 수 있음). 이러한 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcf6411c0b226a9fd5b245400b86fb65e325be87" translate="yes" xml:space="preserve">
          <source>Some argue that this is such a useful feature when reading code, that pointer parameters should always be used for modifiable parameters rather than non-&lt;code&gt;const&lt;/code&gt; references, even if the function never expects a &lt;code&gt;nullptr&lt;/code&gt;. That is, those people argue that function signatures like &lt;code&gt;fn3()&lt;/code&gt; above should not be allowed. &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;Google's C++ style guidelines&lt;/a&gt; are an example of this.</source>
          <target state="translated">어떤 사람들은 이것이 코드를 읽을 때 유용한 기능이라고 주장하는데, 함수가 &lt;code&gt;nullptr&lt;/code&gt; 을 기대하지 않더라도 포인터 매개 변수는 &lt;code&gt;const&lt;/code&gt; 가 아닌 참조가 아닌 수정 가능한 매개 변수에 항상 사용되어야한다고 주장합니다. 즉, 사람들은 위의 &lt;code&gt;fn3()&lt;/code&gt; 과 같은 함수 서명을 허용해서는 안된다고 주장합니다. &lt;a href=&quot;http://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;Google의 C ++ 스타일 가이드 라인&lt;/a&gt; 이 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="4060e9b242b8df1a2b956d0e250e637eee184ce4" translate="yes" xml:space="preserve">
          <source>Sometimes the language rules explicitly require specific types to be used. If you want to use these features, obey the rules.</source>
          <target state="translated">언어 규칙에 따라 특정 유형을 명시 적으로 사용해야하는 경우가 있습니다. 이러한 기능을 사용하려면 규칙을 준수하십시오.</target>
        </trans-unit>
        <trans-unit id="5fc11392b922636b6dc568f4ab0eb7cfb144157b" translate="yes" xml:space="preserve">
          <source>Special rules on &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; parameters (as the &quot;forwarding references&quot;) based on reference collapsing during template parameter deduction allow &lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;&quot;perfect forwarding&quot;&lt;/a&gt; of parameters.</source>
          <target state="translated">템플릿 매개 변수를 추론하는 동안 참조 축소를 기반으로하는 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 매개 변수 ( &quot;전달 참조&quot;)에 대한 특별 규칙은 매개 변수의 &lt;a href=&quot;https://stackoverflow.com/questions/3582001&quot;&gt;&quot;완벽한 전달&quot;&lt;/a&gt; 을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e7e7e6a0d10546a8f3514b41d4f9f797c475d3c2" translate="yes" xml:space="preserve">
          <source>Specific language-interoperation routines require pointers, like &lt;code&gt;operator new&lt;/code&gt;. (However, &lt;em&gt;cv&lt;/em&gt;-&lt;code&gt;void*&lt;/code&gt; is still quite different and safer compared to the ordinary object pointers because it rules out unexpected pointer arithmetics unless you are relying on some non conforming extension on &lt;code&gt;void*&lt;/code&gt; like GNU's.)</source>
          <target state="translated">특정 언어 상호 작용 루틴에는 &lt;code&gt;operator new&lt;/code&gt; 와 같은 포인터가 필요합니다. 그러나 &lt;em&gt;cv&lt;/em&gt; - &lt;code&gt;void*&lt;/code&gt; 는 GNU와 같이 &lt;code&gt;void*&lt;/code&gt; 에 부합하지 않는 확장에 의존하지 않는 한 예기치 않은 포인터 산술을 배제하기 때문에 일반 객체 포인터와 비교하여 여전히 상당히 다르고 안전합니다.</target>
        </trans-unit>
        <trans-unit id="918eaf9f6cafcfdb9b382a8fa017353bbc7f79e9" translate="yes" xml:space="preserve">
          <source>Specific overloads of operators require reference or non reference types. For example:</source>
          <target state="translated">연산자의 특정 과부하에는 참조 또는 비 참조 유형이 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e092dda4f0e27d0c7686ddd00272079e678b6e6" translate="yes" xml:space="preserve">
          <source>Storage</source>
          <target state="translated">Storage</target>
        </trans-unit>
        <trans-unit id="f6ceae4e1810d086bda09a8ac74e9e1fae98d4f4" translate="yes" xml:space="preserve">
          <source>Syntactic sugar</source>
          <target state="translated">구문 설탕</target>
        </trans-unit>
        <trans-unit id="178786d5b288287aa798248ecdf5fc27cc41e4ba" translate="yes" xml:space="preserve">
          <source>Technically this is an &lt;strong&gt;invalid reference&lt;/strong&gt;, not a null reference.  C++ doesn't support null references as a concept as you might find in other languages.  There are other kinds of invalid references as well. &lt;em&gt;Any&lt;/em&gt; invalid reference raises the spectre of &lt;strong&gt;undefined behavior&lt;/strong&gt;, just as using an invalid pointer would.</source>
          <target state="translated">기술적으로 이것은 null 참조가 아닌 &lt;strong&gt;잘못된&lt;/strong&gt; 참조입니다. C ++은 다른 언어에서 볼 수 있듯이 널 참조를 개념으로 지원하지 않습니다. 다른 종류의 잘못된 참조도 있습니다. 유효하지 않은 포인터를 사용하는 것과 같이 유효하지 않은 참조는 &lt;strong&gt;정의되지 않은 동작&lt;/strong&gt; 의 스펙터를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="19d85e5f25c953dc491251669b1a186b567d0b30" translate="yes" xml:space="preserve">
          <source>Technically, this is plain wrong. References are not syntactic sugar of any other features in C++, because they cannot be exactly replaced by other features without any semantic differences.</source>
          <target state="translated">기술적으로 이것은 명백한 잘못입니다. 참조는 의미상의 차이없이 다른 기능으로 정확하게 대체 될 수 없기 때문에 C ++의 다른 기능의 구문 설탕이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e1271990b0fbf017a0baa7180d4771ca7fef2cb9" translate="yes" xml:space="preserve">
          <source>Templates that cover both &lt;code&gt;T&amp;amp;&lt;/code&gt; and &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are even more common.</source>
          <target state="translated">&lt;code&gt;T&amp;amp;&lt;/code&gt; 와 &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; 모두 포함하는 템플릿이 훨씬 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="cc2d982b9a391ad561f42bfa61ab554d2658e9c3" translate="yes" xml:space="preserve">
          <source>The actual error is in the dereferencing of the NULL pointer, prior to the assignment to a reference.  But I'm not aware of any compilers that will generate any errors on that condition - the error propagates to a point further along in the code. That's what makes this problem so insidious. Most of the time, if you dereference a NULL pointer, you crash right at that spot and it doesn't take much debugging to figure it out.</source>
          <target state="translated">실제 오류는 참조에 할당하기 전에 NULL 포인터의 역 참조에 있습니다. 그러나 해당 조건에서 오류를 생성하는 컴파일러는 알지 못합니다. 오류는 코드에서 더 많은 지점으로 전파됩니다. 이것이이 문제를 너무 교활하게 만듭니다. 대부분의 경우 NULL 포인터를 역 참조하면 해당 지점에서 충돌이 발생하며이를 파악하기 위해 많은 디버깅 작업이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36dcbb0fd485c966a6a8597e14838d2a77d340f3" translate="yes" xml:space="preserve">
          <source>The behavior is the same; only now it is much harder to prove that maybeModify does not ever modify array[1], because we already gave it a pointer; the cat is out of the bag. Now it has to do the much more difficult proof: a static analysis of maybeModify to prove it never writes to &amp;amp;x + 1. It also has to prove that it never saves off a pointer that can refer to array[0], which is just as tricky.</source>
          <target state="translated">동작은 동일합니다. 어쩌면 이미 포인터를 주었기 때문에 maybeModify가 array [1]을 수정하지 않았다는 것을 증명하기는 훨씬 더 어렵다. 고양이가 가방에서 나왔습니다. 이제는 훨씬 더 어려운 증거를 수행해야합니다. maybeModify의 정적 분석은 &amp;amp; x + 1에 쓰지 않는다는 것을 증명합니다. 또한 array [0]을 참조 할 수있는 포인터를 저장하지 않음을 증명해야합니다. 까다로운.</target>
        </trans-unit>
        <trans-unit id="55c25474b6bbe811c3fff5d37fe3196ddf92b362" translate="yes" xml:space="preserve">
          <source>The default flavor uses the 'bind const reference to a temporary' aspect of references.</source>
          <target state="translated">기본 플레이버는 '바인드 const 참조를 임시에 대한 참조'참조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eeffd6f2cd40ebbc994170a79516a76d384f1862" translate="yes" xml:space="preserve">
          <source>The difference is that non-constant pointer variable(not to be confused with a pointer to constant) may be changed at some time during program execution, requires pointer semantics to be used(&amp;amp;,*) operators, while references can be set upon initialization only(that's why you can set them in constructor initializer list only, but not somehow else) and use ordinary value accessing semantics.  Basically references were introduced to allow support for operators overloading as I had read in some very old book. As somebody stated in this thread - pointer can be set to 0 or whatever value you want. 0(NULL, nullptr) means that the pointer is initialized with nothing. It is an error to dereference null pointer. But actually the pointer may contain a value that doesn't point to some correct memory location. References in their turn try not to allow a user to initialize a reference to something that cannot be referenced due to the fact that you always provide rvalue of correct type to it. Although there are a lot of ways to make reference variable be initialized to a wrong memory location - it is better for you not to dig this deep into details. On machine level both pointer and reference work uniformly - via pointers. Let's say in essential references are syntactic sugar. rvalue references are different to this - they are naturally stack/heap objects.</source>
          <target state="translated">차이점은 프로그램 실행 중에 일정하지 않은 포인터 변수 (상수에 대한 포인터와 혼동하지 않아야 함)가 언젠가 변경 될 수 있으며 포인터 시맨틱을 사용해야하며 (&amp;amp;, *) 연산자가 필요하지만 초기화시 참조를 설정할 수 있다는 것입니다 만 (그래서 생성자 이니셜 라이저 목록에서만 설정할 수 있지만 다른 방법으로는 할 수는 없습니다) 일반 값 액세스 시맨틱을 사용하십시오. 아주 오래된 책에서 읽은 연산자 오버로드를 지원하기 위해 기본적으로 참조가 도입되었습니다. 이 스레드에서 누군가가 언급했듯이 포인터는 0 또는 원하는 값으로 설정할 수 있습니다. 0 (NULL, nullptr)은 포인터가 아무것도 초기화되지 않았 음을 의미합니다. 널 포인터를 역 참조하는 것은 오류입니다. 그러나 실제로 포인터에는 올바른 메모리 위치를 가리 키지 않는 값이 포함될 수 있습니다. 차례로 참조는 올바른 유형의 rvalue를 항상 제공한다는 사실 때문에 사용자가 참조 할 수없는 것에 대한 참조를 초기화하지 못하게합니다. 참조 변수를 잘못된 메모리 위치로 초기화하는 방법에는 여러 가지가 있지만 세부 사항을 자세히 살펴 보지 않는 것이 좋습니다. 기계 수준에서 포인터와 참조는 포인터를 통해 균일하게 작동합니다. 필수 참고 문헌에서 구문 설탕이라고 가정 해 봅시다. rvalue 참조는 이것과 다릅니다. 자연스럽게 스택 / 힙 객체입니다.</target>
        </trans-unit>
        <trans-unit id="21383718ed633934236239e24d6297c4ae1335ed" translate="yes" xml:space="preserve">
          <source>The differences of the top-level categories can already reveal many concrete differences not tied to pointers directly:</source>
          <target state="translated">최상위 카테고리의 차이점은 포인터에 직접 연결되지 않은 많은 구체적인 차이점을 이미 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="819bfb5a2d2e6000333b076e5df05cfd8d7b2a13" translate="yes" xml:space="preserve">
          <source>The direct answer</source>
          <target state="translated">직접적인 대답</target>
        </trans-unit>
        <trans-unit id="f88d1a0da318f485205557f1a4a4b91d6c82b7a4" translate="yes" xml:space="preserve">
          <source>The misconceptions</source>
          <target state="translated">오해</target>
        </trans-unit>
        <trans-unit id="7d2603e75f0c55eb2703c92e74f015d2c67447b5" translate="yes" xml:space="preserve">
          <source>The only exceptions cannot be worked around in the current language:</source>
          <target state="translated">현재 언어에서는 예외를 해결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="122da8393156782721cf3629f6cd6821668afecf" translate="yes" xml:space="preserve">
          <source>The only major rule that's important to remember with references is that they must be defined at the time of declaration (with the exception of a reference in a header, in that case it must be defined in the constructor, after the object it's contained in is constructed it's too late to define it).</source>
          <target state="translated">참조와 함께 기억해야 할 유일한 주요 규칙은 선언시 정의해야한다는 것입니다 (헤더의 참조를 제외하고는 헤더에 포함 된 개체가 포함 된 후 생성자에서 정의되어야 함). 그것을 정의하기에는 너무 늦었습니다.)</target>
        </trans-unit>
        <trans-unit id="418b62106b171f039b854dbd9df45e23828dfba0" translate="yes" xml:space="preserve">
          <source>The proper way to stay out of trouble is to avoid dereferencing a NULL pointer to create a reference. Here's an automated way to accomplish this.</source>
          <target state="translated">문제를 피하는 올바른 방법은 참조를 만들기 위해 NULL 포인터를 역 참조하지 않는 것입니다. 이를 수행하는 자동화 된 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5873330b5c7abf6ca602c30f272bd7c50e0cbb63" translate="yes" xml:space="preserve">
          <source>The statement above is simply wrong. To avoid such misconceptions, look at the ISO C++ rules instead:</source>
          <target state="translated">위의 진술은 단순히 잘못되었습니다. 이러한 오해를 피하려면 대신 ISO C ++ 규칙을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="163a6b49bbef328a902a3d1fe72ca7563153d744" translate="yes" xml:space="preserve">
          <source>There can still be some common properties among references in different programming languages in general, but let's leave it for some other questions in SO.</source>
          <target state="translated">일반적으로 다른 프로그래밍 언어로 된 참조 사이에는 공통 속성이 여전히있을 수 있지만 SO에서 다른 질문으로 남겨 두겠습니다.</target>
        </trans-unit>
        <trans-unit id="e317f9f1b18599441d13052e85296dbd4035b47d" translate="yes" xml:space="preserve">
          <source>There is a semantic difference that may appear esoteric if you are not familiar with studying computer languages in an abstract or even academic fashion.</source>
          <target state="translated">추상적이거나 학문적 인 방식으로 컴퓨터 언어를 공부하는 데 익숙하지 않은 경우 의미 론적으로 차이가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49c3ed839f4ba592814145e1ee7dccb652641c97" translate="yes" xml:space="preserve">
          <source>There is a very important non-technical difference between pointers and references: An argument passed to a function by pointer is much more visible than an argument passed to a function by non-const reference. For example:</source>
          <target state="translated">포인터와 참조 사이에는 기술적이지 않은 중요한 차이점이 있습니다. 포인터로 함수에 전달 된 인수는 비 const 참조로 함수에 전달 된 인수보다 훨씬 더 잘 보입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44e93f1f5f0ace9a170cb0b7222ca3b3580dffcb" translate="yes" xml:space="preserve">
          <source>There is one fundamental difference between pointers and references that I didn't see anyone had mentioned: references enable pass-by-reference semantics in function arguments. Pointers, although it is not visible at first do not: they only provide pass-by-value semantics. This has been very nicely described in &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">내가 언급하지 않은 포인터와 참조 사이에는 근본적인 차이점이 있습니다. 참조는 함수 인수에서 참조로 통과 의미를 활성화합니다. 처음에는 보이지 않지만 포인터는 값별 의미 만 제공합니다. 이것은 &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;이 기사&lt;/a&gt; 에서 아주 잘 설명되었습니다.</target>
        </trans-unit>
        <trans-unit id="5066abc2ae8da58f9f9bb296820d74fa0f7a48b1" translate="yes" xml:space="preserve">
          <source>Therefore a reference IS a pointer under the hood, they both are just storing a memory address, where the address is pointing to is irrelevant, what do you think would happen if I called std::cout &amp;lt;&amp;lt; str_ref; AFTER calling delete &amp;amp;str_ref? Well, obviously it compiles fine, but causes a segmentation fault at runtime because it's no longer pointing at a valid variable, we essentially have a broken reference that still exists (until it falls out of scope), but is useless.</source>
          <target state="translated">따라서 참조는 후드 아래의 포인터이며 둘 다 메모리 주소를 저장하고 있으며 주소가 가리키는 위치와 관련이 없습니다. std :: cout &amp;lt;&amp;lt; str_ref; 삭제 후 삭제 &amp;amp; str_ref? 글쎄, 분명히 잘 컴파일되지만 런타임에 더 이상 유효한 변수를 가리 키지 않기 때문에 세그먼트 화 오류가 발생합니다. 우리는 본질적으로 여전히 존재하지만 (범위를 벗어날 때까지) 깨진 참조를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="94289fe5436213192f08bec365e448fa20dc244c" translate="yes" xml:space="preserve">
          <source>These points empower a considerable part of C++ and the standard library so this is quite a major property of references.</source>
          <target state="translated">이러한 요점은 C ++ 및 표준 라이브러리의 상당 부분을 강화하므로 참조의 주요 특성입니다.</target>
        </trans-unit>
        <trans-unit id="6a0c459929817549c904c8a94991b55621527e3f" translate="yes" xml:space="preserve">
          <source>This assignment changes ival, the value referenced by ri, and not the reference itself. After the assignment, the two references still refer to their original objects, and the value of those objects is now the same as well.</source>
          <target state="translated">이 할당은 참조 자체가 아니라 ri가 참조하는 값인 ival을 변경합니다. 할당 후에도 두 참조는 여전히 원래 객체를 참조하며 해당 객체의 값도 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bc577f672dad3e6a3a69c44737f3aacd3dd1eb12" translate="yes" xml:space="preserve">
          <source>This is based on the &lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;tutorial&lt;/a&gt;. What is written makes it more clear:</source>
          <target state="translated">이것은 &lt;a href=&quot;http://www.cplusplus.com/files/tutorial.pdf&quot;&gt;튜토리얼을&lt;/a&gt; 기반으로합니다. 작성된 내용이 더 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="3ab66ed104cf4962c17c327aa4d19f6a70663d93" translate="yes" xml:space="preserve">
          <source>This is the language mechanism that allows ScopeGuard to work.</source>
          <target state="translated">이것은 ScopeGuard가 작동하도록하는 언어 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="5c9287077fd3860634cb823000e3c46b1b0d2646" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;const&amp;amp;&lt;/code&gt; safer for use in argument lists and so forth.</source>
          <target state="translated">이것은 &lt;code&gt;const&amp;amp;&lt;/code&gt; 를 인수리스트 등에 사용하기에 더 안전하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d92fc23c843fd5c20781bced348b9700ad555c98" translate="yes" xml:space="preserve">
          <source>This program might help in comprehending the answer of the question. This is a simple program of a reference &quot;j&quot; and a pointer &quot;ptr&quot; pointing to variable &quot;x&quot;.</source>
          <target state="translated">이 프로그램은 질문에 대한 답변을 이해하는 데 도움이 될 수 있습니다. 이것은 참조 &quot;j&quot;와 변수 &quot;x&quot;를 가리키는 포인터 &quot;ptr&quot;의 간단한 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="f6a17a077fe021118aa2ad5ab8e800b9c24900ac" translate="yes" xml:space="preserve">
          <source>This should permit the compiler to do more optimization on a reference.</source>
          <target state="translated">이를 통해 컴파일러는 참조에 대해 더 많은 최적화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f3d837dc2b38c729da0192bc97e045c3a5109ca" translate="yes" xml:space="preserve">
          <source>To make such an optimization, it needs to prove that nothing can change array[1] during the call. This is rather easy to do. i is never less than 2, so array[i] can never refer to array[1]. maybeModify() is given a0 as a reference (aliasing array[0]). Because there is no &quot;reference&quot; arithmetic, the compiler just has to prove that maybeModify never gets the address of x, and it has proven that nothing changes array[1].</source>
          <target state="translated">이러한 최적화를 위해서는 호출 중에 아무것도 배열 [1]을 변경할 수 없음을 증명해야합니다. 이것은 오히려 쉽습니다. i는 2보다 작지 않으므로 array [i]는 array [1]을 참조 할 수 없습니다. maybeModify ()는 a0을 참조 (aliasing array [0])로 제공합니다. &quot;참조&quot;산술이 없기 때문에 컴파일러는 어쩌면 maybeModify가 x의 주소를 절대 얻지 못한다는 것을 증명해야하며 array [1]을 변경하는 것이 아무것도 없음을 증명했습니다.</target>
        </trans-unit>
        <trans-unit id="887be10c65852c56ff940b439c392da3426fe46c" translate="yes" xml:space="preserve">
          <source>Unlike the pointers, references are &lt;strong&gt;syntactically equivalent&lt;/strong&gt; to the object they refer to, i.e. any operation that can be applied to an object works for a reference, and with the exact same syntax (the exception is of course the initialization).</source>
          <target state="translated">포인터와 달리 참조는 참조하는 객체 &lt;strong&gt;와 구문 적으로 동일&lt;/strong&gt; 합니다. 즉, 객체에 적용 할 수있는 모든 작업은 참조를 위해 작동하며 정확히 동일한 구문을 사용합니다 (물론 초기화는 예외입니다).</target>
        </trans-unit>
        <trans-unit id="82af8ce5dd45a624f7e3a05f611fa27d013254ef" translate="yes" xml:space="preserve">
          <source>Update: now that I think about it some more, there is an important difference.</source>
          <target state="translated">업데이트 : 이제 그것에 대해 더 생각하면 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="255286b845d43f2eb541ea059727b48d0df67a81" translate="yes" xml:space="preserve">
          <source>Variable of object types do occupy storage as per &lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;the abstract machine&lt;/a&gt; semantics. Reference do not necessary occupy storage (see the section about misconceptions below for details).</source>
          <target state="translated">객체 유형의 변수는 &lt;a href=&quot;http://eel.is/c++draft/intro.abstract&quot;&gt;추상 머신&lt;/a&gt; 시맨틱에 따라 스토리지를 차지합니다. 참조가 스토리지를 차지할 필요는 없습니다 (자세한 내용은 아래 오해에 대한 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="e955ffcb762ae563797df04ca22c14d80f8aa171" translate="yes" xml:space="preserve">
          <source>Visit the following for more information about reference to pointer:</source>
          <target state="translated">포인터 참조에 대한 자세한 내용은 다음을 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="95919816eaf3c9d568884c2a1f7a85a8422fc08c" translate="yes" xml:space="preserve">
          <source>What are the differences between a pointer variable and a reference variable in C++</source>
          <target state="translated">C ++에서 포인터 변수와 참조 변수의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ebf7dfac9cd8041f70cebb7841fd92ee7068ad0e" translate="yes" xml:space="preserve">
          <source>What is a pointer in C++? Some specific instance of type that &lt;strong&gt;is an object type&lt;/strong&gt;.</source>
          <target state="translated">C ++에서 포인터는 무엇입니까? &lt;strong&gt;객체 유형 인&lt;/strong&gt; 특정 유형의 인스턴스.</target>
        </trans-unit>
        <trans-unit id="f1713708129e2693fa553b3ca19fb86a7a27996c" translate="yes" xml:space="preserve">
          <source>What is a reference in C++? Some specific instance of type that &lt;strong&gt;is not an object type&lt;/strong&gt;.</source>
          <target state="translated">C ++에서 참조 란 무엇입니까? &lt;strong&gt;객체 유형이 아닌&lt;/strong&gt; 특정 유형의 인스턴스.</target>
        </trans-unit>
        <trans-unit id="b27d4d26ba775faaca91cdf7c85e8f345955ab10" translate="yes" xml:space="preserve">
          <source>What's a C++ reference (&lt;em&gt;for C programmers&lt;/em&gt;)</source>
          <target state="translated">C ++ 참조 란 무엇입니까 ( &lt;em&gt;C 프로그래머 용&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="f4957cb2344c8ba91faaeb20076eeeb6b30d45f2" translate="yes" xml:space="preserve">
          <source>What's more, as we can refer to almost any pointer tutorial, a pointer is an object that is supported by pointer arithmetic which makes pointer similar to an array.</source>
          <target state="translated">또한 거의 모든 포인터 자습서를 참조 할 수 있듯이 포인터는 포인터를 배열과 유사하게 만드는 포인터 산술에 의해 지원되는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="ec620abb83732edc34ab0a338ecb3e522947253f" translate="yes" xml:space="preserve">
          <source>When calling a function, the compiler usually generates memory spaces for the arguments to be copied to. The function signature defines the spaces that should be created and gives the name that should be used for these spaces. Declaring a parameter as a reference just tells the compiler to use the input variable memory space instead of allocating a new memory space during the method call. It may seem strange to say that your function will be directly manipulating a variable declared in the calling scope, but remember that when executing compiled code, there is no more scope; there is just plain flat memory, and your function code could manipulate any variables.</source>
          <target state="translated">함수를 호출 할 때 컴파일러는 일반적으로 인수를 복사 할 메모리 공간을 생성합니다. 함수 시그니처는 작성해야하는 공백을 정의하고이 공백에 사용해야하는 이름을 제공합니다. 매개 변수를 참조로 선언하면 컴파일러가 메소드 호출 중에 새 메모리 공간을 할당하는 대신 입력 변수 메모리 공간을 사용하도록 지시합니다. 함수가 호출 범위에서 선언 된 변수를 직접 조작한다고 말하는 것은 이상하게 보일 수 있지만 컴파일 된 코드를 실행할 때 더 이상 범위가 없다는 것을 기억하십시오. 평평한 평평한 메모리가 있으며 함수 코드는 모든 변수를 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4c1912265bdef87e12cb7b1321e31b984533bfe" translate="yes" xml:space="preserve">
          <source>When you are implementing smart pointers above, you may have to deal with raw pointers.</source>
          <target state="translated">위의 스마트 포인터를 구현할 때 원시 포인터를 처리해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dfec36a318fd0d200d4cdbe5653e6d388ef8b86" translate="yes" xml:space="preserve">
          <source>When you create a reference, you only tell the compiler that you assign another name to the pointer variable; that's why references cannot &quot;point to null&quot;, because a variable cannot be, and not be.</source>
          <target state="translated">참조를 작성할 때, 포인터 변수에 다른 이름을 지정한다고 컴파일러에게 지시합니다. 그렇기 때문에 참조는 &quot;널을 가리킬 수없는&quot;이유는 변수가 될 수없고 그렇지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c777e0e0107a7f50f79668993af249ac372a560e" translate="yes" xml:space="preserve">
          <source>Which outputs this:</source>
          <target state="translated">이것을 출력하는 것 :</target>
        </trans-unit>
        <trans-unit id="c5cc6c3d8c26b226ed34902de7cac9e3a05e8f30" translate="yes" xml:space="preserve">
          <source>While both references and pointers are used to indirectly access another value, there are two important differences between references and pointers. The first is that a reference always refers to an object: It is an error to define a reference without initializing it. The behavior of assignment is the second important difference: Assigning to a reference changes the object to which the reference is bound; it does not rebind the reference to another object. Once initialized, a reference always refers to the same underlying object.</source>
          <target state="translated">참조와 포인터 모두 다른 값에 간접적으로 액세스하는 데 사용되지만 참조와 포인터 사이에는 두 가지 중요한 차이점이 있습니다. 첫 번째는 참조가 항상 객체를 참조한다는 것입니다. 참조를 초기화하지 않고 정의하는 것은 오류입니다. 할당 동작은 두 번째 중요한 차이점입니다. 참조에 할당하면 참조가 바인딩 된 객체가 변경됩니다. 다른 객체에 대한 참조를 리 바인드하지 않습니다. 초기화되면 참조는 항상 동일한 기본 개체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="33026a6390ada498b7595f79ab2136f07ff3040a" translate="yes" xml:space="preserve">
          <source>While this may appear superficial, I believe this property is crucial for a number of C++ features, for example:</source>
          <target state="translated">이것은 피상적 인 것처럼 보일 수 있지만이 속성은 여러 C ++ 기능에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a48d4180c32fc6ba76e32c1184f3989050537522" translate="yes" xml:space="preserve">
          <source>Why I consider C++ references useful</source>
          <target state="translated">왜 C ++ 참조가 유용하다고 생각합니까?</target>
        </trans-unit>
        <trans-unit id="a139f82cb75f5fa1d088932ad6ca62c1a9ed365b" translate="yes" xml:space="preserve">
          <source>You can do arithmetic on a pointer.
For example, &lt;code&gt;p += offset;&lt;/code&gt;</source>
          <target state="translated">포인터에서 산술을 수행 할 수 있습니다. 예를 들어, &lt;code&gt;p += offset;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34780a25d9c2fa6caeb26ac54a01416129ecb662" translate="yes" xml:space="preserve">
          <source>You can have pointers to pointers to pointers offering extra levels of indirection.  Whereas references only offer one level of indirection.</source>
          <target state="translated">여분의 간접 레벨을 제공하는 포인터에 대한 포인터를 가질 수 있습니다. 참조는 한 수준의 간접 참조 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ca281bbb0f05d2038a489cb7276fce90296f6044" translate="yes" xml:space="preserve">
          <source>You forgot the most important part:</source>
          <target state="translated">가장 중요한 부분을 잊었습니다.</target>
        </trans-unit>
        <trans-unit id="5b379fd4bb44eb684d6e0614512cecb190c0230a" translate="yes" xml:space="preserve">
          <source>You have to avoid symbol bloat in some extreme cases.</source>
          <target state="translated">극단적 인 경우 심볼 팽창을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="94dc5492065b8158897a90145f93ab59e74f01ca" translate="yes" xml:space="preserve">
          <source>You have to improve efficiency of the translation (compilation &amp;amp; linking) in some extreme cases.</source>
          <target state="translated">극단적 인 경우 번역 (컴파일 및 링크)의 효율성을 향상시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="560512056d46b11c084b62f89a3e5fff348a21e2" translate="yes" xml:space="preserve">
          <source>You have to interoperate at runtime with different language implementations (including various assemblies, language runtime and FFI of some high-level client languages) based on assumptions of specific implementations.</source>
          <target state="translated">특정 구현에 대한 가정을 기반으로 런타임에 다양한 언어 구현 (다양한 어셈블리, 언어 런타임 및 일부 고급 클라이언트 언어의 FFI 포함)과 상호 운용해야합니다.</target>
        </trans-unit>
        <trans-unit id="92de6dbe192f694e5996d57ccfe447310dfd3ab8" translate="yes" xml:space="preserve">
          <source>You have to meet the ABI requirements of specific C++ implementations.</source>
          <target state="translated">특정 C ++ 구현의 ABI 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="184df4e9e98867001ef0b20404d00c507b584e37" translate="yes" xml:space="preserve">
          <source>You have to serve to old-style (C) APIs.</source>
          <target state="translated">구식 (C) API를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d5c7ab9829b48d10733475f6a32872b8d1dde9fe" translate="yes" xml:space="preserve">
          <source>in simple words, we can say a reference is an alternative name for a variable whereas,
a pointer is a variable that holds the address of another variable.
e.g.</source>
          <target state="translated">간단히 말해, 참조는 변수의 대체 이름 인 반면 포인터는 다른 변수의 주소를 보유하는 변수입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="344723f5f4518fc02c77a821b777b5e5ef5b14c7" translate="yes" xml:space="preserve">
          <source>member-access with pointers uses &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">포인터가있는 멤버 액세스는 &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a520836c5bc91e48d3c9612930f910ee19298599" translate="yes" xml:space="preserve">
          <source>member-access with references uses &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">참조가있는 멤버 액세스는을 사용합니다 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6cd4d114dbfaf6a41f6a22c17b7940a2cd45fe06" translate="yes" xml:space="preserve">
          <source>will print:</source>
          <target state="translated">인쇄합니다 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
