<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/5741187">
    <body>
      <group id="5741187">
        <trans-unit id="1f2c2f49ed53d271ef6cdcf6885e1ffa495ab73c" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;Note</source>
          <target state="translated">&amp;nbsp;Note</target>
        </trans-unit>
        <trans-unit id="0137511bc1081a6efb0613748b98bd9d5f5c275a" translate="yes" xml:space="preserve">
          <source>...because MySQLi prepared statements are safe.</source>
          <target state="translated">... MySQLi 준비 문장이 안전하기 때문에.</target>
        </trans-unit>
        <trans-unit id="1b1f4e147f6e802158503b43d1ca60cd81f26fbd" translate="yes" xml:space="preserve">
          <source>...because PDO prepared statements are immune from this vulnerability (and ircmaxell's too, provided either that you're using PHP&amp;ge;5.3.6 and the character set has been correctly set in the DSN; or that prepared statement emulation has been disabled).</source>
          <target state="translated">... PDO 준비된 명령문은이 취약점에 영향을받지 않기 때문에 (PHP&amp;ge;5.3.6을 사용하고 문자 세트가 DSN에 올바르게 설정되어 있거나 준비된 명령문 에뮬레이션이 비활성화 된 경우 ircmaxell도 마찬가지 임) .</target>
        </trans-unit>
        <trans-unit id="6ac78ecd1f7c67c942cb53726daa7a0efbc22871" translate="yes" xml:space="preserve">
          <source>...because PDO's &lt;code&gt;quote()&lt;/code&gt; function not only escapes the literal, but also quotes it (in single-quote &lt;code&gt;'&lt;/code&gt; characters); note that to avoid ircmaxell's bug in this case, you &lt;em&gt;must&lt;/em&gt; be using PHP&amp;ge;5.3.6 &lt;em&gt;and&lt;/em&gt; have correctly set the character set in the DSN.</source>
          <target state="translated">... PDO의 &lt;code&gt;quote()&lt;/code&gt; 함수는 리터럴을 이스케이프 할뿐만 아니라 작은 따옴표 &lt;code&gt;'&lt;/code&gt; 문자로도 인용합니다. 이 경우 ircmaxell의 버그를 피하려면 PHP&amp;ge;5.3.6을 &lt;em&gt;사용해야&lt;/em&gt; 하며 DSN에 문자 세트를 올바르게 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="35754c4370182141eab5ee14a96666c610708eea" translate="yes" xml:space="preserve">
          <source>...because we're quoting our string literal with single-quotes.</source>
          <target state="translated">... 문자열 리터럴을 작은 따옴표로 인용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3c9a307826c8b7b69feae594532b8aa3104762de" translate="yes" xml:space="preserve">
          <source>...because we've explicitly selected an SQL mode that doesn't include &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;.</source>
          <target state="translated">... &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; 가 포함되지 않은 SQL 모드를 명시 적으로 선택했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="715bf0ad0483cee36e2352e88d118cd45e4a12fd" translate="yes" xml:space="preserve">
          <source>...then you &lt;em&gt;should&lt;/em&gt; be completely safe (vulnerabilities outside the scope of string escaping aside).</source>
          <target state="translated">... 그런 다음 완전히 안전 &lt;em&gt;해야&lt;/em&gt; 합니다 (문자열 이탈 범위를 벗어난 취약점).</target>
        </trans-unit>
        <trans-unit id="1652c3eb8f0740d7a95a22464a97e4d1d57d3195" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.php.net/manual/en/function.mysql-set-charset.php&quot;&gt;&lt;code&gt;mysql_set_charset()&lt;/code&gt;&lt;/a&gt; cannot help, as this has nothing to do with character sets; nor can &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;&lt;code&gt;mysqli::real_escape_string()&lt;/code&gt;&lt;/a&gt;, since that's just a different wrapper around this same function.</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/function.mysql-set-charset.php&quot;&gt; &lt;code&gt;mysql_set_charset()&lt;/code&gt; &lt;/a&gt; 은 문자 세트와 관련이 없으므로 도움이 될 수 없습니다. &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt; &lt;code&gt;mysqli::real_escape_string()&lt;/code&gt; &lt;/a&gt; 마찬가지입니다. 왜냐하면 동일한 함수 주위의 다른 래퍼이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="40b79d311fd549f7a602061aab4c7e939b44bb05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; will &lt;strong&gt;provide no protection whatsoever&lt;/strong&gt; (and could furthermore munge your data) if:</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 은 다음과 &lt;strong&gt;같은 경우 보호 기능&lt;/strong&gt; 을 &lt;strong&gt;제공하지 않으며&lt;/strong&gt; 데이터를 더 이상 조정할 수 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="704e1ed694481558f32fc9a1901b8ba42b49d1dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; will not protect you against this.
&lt;strong&gt;The fact that you use single quotes (&lt;code&gt;' '&lt;/code&gt;) around your variables inside your query is what protects you against this.&lt;/strong&gt; The following is also an option:</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 은 이것으로부터 당신을 보호하지 않습니다. &lt;strong&gt;쿼리 내부의 변수 주위에 작은 따옴표 ( &lt;code&gt;' '&lt;/code&gt; )를 사용한다는 사실이이를 방지합니다.&lt;/strong&gt; 다음도 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="2a3d913309b6e70d8a4eaffa142ac0f8fa0b10d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Incompatible Change:&lt;/em&gt;&lt;/strong&gt; A new C API function, &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;&lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt;&lt;/a&gt;, has been implemented as a replacement for &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/a&gt; because the latter function can fail to properly encode characters when the &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; SQL mode is enabled. In this case, &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/a&gt; cannot escape quote characters except by doubling them, and to do this properly, it must know more information about the quoting context than is available. &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;&lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt;&lt;/a&gt; takes an extra argument for specifying the quoting context. For usage details, see &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;mysql_real_escape_string_quote()&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;호환되지 않는 변경 :&lt;/em&gt;&lt;/strong&gt; 새로운 C API 함수 인 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt; &lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; &lt;/a&gt; SQL 모드가 활성화 된 경우 후자의 함수가 문자를 올바르게 인코딩하지 못하기 때문에 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt; &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; &lt;/a&gt; 의 대체로 구현되었습니다. 이 경우, &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt; &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; &lt;/a&gt; 은 따옴표 문자를 두 배로 늘려서 제외시킬 수 없으며,이를 올바르게 수행하려면 인용 컨텍스트에 대해 더 많은 정보를 알아야합니다. &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt; &lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt; &lt;/a&gt; 는 인용 컨텍스트를 지정하기 위해 추가 인수를 취합니다. 사용법에 대한 자세한 내용은 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;mysql_real_escape_string_quote ()를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f8e01739d5b6815e58b82ad6033855dbc821cb51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1417fe321e66a2f2b24276e42fbf203a5473bd74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selecting a Character Set&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;문자 세트 선택&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ac289cd5eeccb9543f356cfaa7dd434e4716155" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selecting an SQL Mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SQL 모드 선택&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1de1e668bd6f39316609cb114d142b1d2a27d5e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Payload&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;페이로드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2d3170421e2d93af1294eb6a67b1040b5fa48891" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Query&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;쿼리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="326f3c54f3b107c6ae380d9464c1fb003c7f9d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_real_escape_string()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mysql_real_escape_string()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73322f37c52dd54895c5ee09cec4154d749ff948" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo; inside a string quoted with &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo; may be written as &amp;ldquo;&lt;code&gt;&quot;&quot;&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&quot; &lt;code&gt;&quot;&lt;/code&gt; &quot;로 인용 된 문자열 내&quot; &lt;code&gt;&quot;&lt;/code&gt; &quot;는 &quot; &quot; &quot;로 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866f8889f57f2afeeb461f2dc9e8e2edf5ccb4f7" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;code&gt;'&lt;/code&gt;&amp;rdquo; inside a string quoted with &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo; needs no special treatment and need not be doubled or escaped. In the same way, &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo; inside a string quoted with &amp;ldquo;&lt;code&gt;'&lt;/code&gt;&amp;rdquo; needs no special treatment.</source>
          <target state="translated">&quot; &lt;code&gt;&quot;&lt;/code&gt; &quot;로 인용 된 문자열 내부의&quot; &quot; &quot;는 특별한 처리가 필요하지 않으며 두 배 또는 이스케이프 처리 할 필요가 없으며, &quot; &lt;code&gt;&quot;&lt;/code&gt; &quot;로 인용 된 문자열 내부의&quot; &lt;code&gt;'&lt;/code&gt; &quot;는 특별한 처리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc1a943df8c2823554d30c748a3335dc2a943b47" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;code&gt;'&lt;/code&gt;&amp;rdquo; inside a string quoted with &amp;ldquo;&lt;code&gt;'&lt;/code&gt;&amp;rdquo; may be written as &amp;ldquo;&lt;code&gt;''&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&quot; &lt;code&gt;'&lt;/code&gt; &quot;로 인용 된 문자열 내 &quot; &lt;code&gt;'&lt;/code&gt; &quot;는&quot; &quot; &quot;로 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ed5417d8347bd101a3334daed119b0bde1f39d" translate="yes" xml:space="preserve">
          <source>Also, the &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sql-mode-setting&quot;&gt;SQL mode of a new connection&lt;/a&gt; is set by the server according to its configuration (which a &lt;code&gt;SUPER&lt;/code&gt; user can change at any time); thus, to be certain of the server's behaviour, you must &lt;em&gt;always&lt;/em&gt; explicitly specify your desired mode after connecting.</source>
          <target state="translated">또한 &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sql-mode-setting&quot;&gt;새 연결&lt;/a&gt; 의 SQL 모드 는 구성에 따라 서버에서 설정합니다 ( &lt;code&gt;SUPER&lt;/code&gt; 사용자는 언제든지 변경할 수 있음). 따라서 서버의 동작을 확실하게하려면 연결 후 &lt;em&gt;항상&lt;/em&gt; 원하는 모드를 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="684a9120a373e354d932d00139cf2545e5e3998c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can enable the &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; SQL mode, which (amongst other things) alters the operation of &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;.  With this mode enabled, &lt;code&gt;0x27&lt;/code&gt; will be replaced with &lt;code&gt;0x2727&lt;/code&gt; rather than &lt;code&gt;0x5c27&lt;/code&gt; and thus the escaping process &lt;em&gt;cannot&lt;/em&gt; create valid characters in any of the vulnerable encodings where they did not exist previously (i.e. &lt;code&gt;0xbf27&lt;/code&gt; is still &lt;code&gt;0xbf27&lt;/code&gt; etc.)&amp;mdash;so the server will still reject the string as invalid.  However, see &lt;a href=&quot;https://stackoverflow.com/a/23277864/623041&quot;&gt;@eggyal's answer&lt;/a&gt; for a different vulnerability that can arise from using this SQL mode.</source>
          <target state="translated">또는 &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; &lt;/a&gt; SQL 모드를 활성화 할 수 있습니다.이 모드는 무엇보다도 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 의 작업을 변경합니다. 이 모드를 사용하면 &lt;code&gt;0x27&lt;/code&gt; 이 &lt;code&gt;0x2727&lt;/code&gt; 이 아닌 &lt;code&gt;0x5c27&lt;/code&gt; 로 대체되므로 이스케이프 프로세스 &lt;em&gt;는&lt;/em&gt; 이전에 존재하지 않은 취약한 인코딩에서 유효한 문자를 만들 &lt;em&gt;수 없습니다&lt;/em&gt; (예 : &lt;code&gt;0xbf27&lt;/code&gt; 은 여전히 &lt;code&gt;0xbf27&lt;/code&gt; 등). 따라서 서버는 계속 문자열을 유효하지 않은 것으로 거부하십시오. 그러나이 SQL 모드를 사용하여 발생할 수있는 다른 취약점에 대해서는 &lt;a href=&quot;https://stackoverflow.com/a/23277864/623041&quot;&gt;@eggyal의 답변&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0125850d3c197e91fbcdcb6a03bc380d4cbce4d0" translate="yes" xml:space="preserve">
          <source>Applications should be modified to use &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;&lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt;&lt;/a&gt;, instead of &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/a&gt;, which now fails and produces an &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/error-messages-client.html#error_cr_insecure_api_err&quot;&gt;&lt;code&gt;CR_INSECURE_API_ERR&lt;/code&gt;&lt;/a&gt; error if &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt; &lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt; &lt;/a&gt; 대신 mysql_real_escape_string_quote () 를 사용하도록 응용 프로그램을 수정해야합니다. 이는 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; &lt;/a&gt; 가 사용 가능한 경우 실패하고 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/error-messages-client.html#error_cr_insecure_api_err&quot;&gt; &lt;code&gt;CR_INSECURE_API_ERR&lt;/code&gt; &lt;/a&gt; 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="88e7dae832f3deb235d5883959ac5722693a0716" translate="yes" xml:space="preserve">
          <source>As documented under &lt;a href=&quot;http://dev.mysql.com/doc/en/string-literals.html&quot;&gt;String Literals&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://dev.mysql.com/doc/en/string-literals.html&quot;&gt;문자열 리터럴에&lt;/a&gt; 설명 된대로 :</target>
        </trans-unit>
        <trans-unit id="e89e6c65011e8a4d7c5bfa8b0caf77e515bc1d13" translate="yes" xml:space="preserve">
          <source>As my learned friend put it: congratulations, you just successfully attacked a program using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;...</source>
          <target state="translated">배운 친구가 말했듯이 축하합니다. &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; ...을 사용하여 프로그램을 성공적으로 공격했습니다.</target>
        </trans-unit>
        <trans-unit id="860271aa1a26075ad9948f5113f8863be3598b03" translate="yes" xml:space="preserve">
          <source>As of MySQL v5.7.6, this bug has been fixed.  See &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-6.html&quot;&gt;change log&lt;/a&gt;:</source>
          <target state="translated">MySQL v5.7.6부터이 버그가 수정되었습니다. &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-6.html&quot;&gt;변경 로그를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f518e314fb42235c4f3d6cbb119a3ec1d5e226f3" translate="yes" xml:space="preserve">
          <source>As we said at the outset, for this attack to work the database connection must be encoded using a vulnerable character set.  &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8mb4.html&quot;&gt;&lt;code&gt;utf8mb4&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not vulnerable&lt;/em&gt; and yet can support &lt;em&gt;every&lt;/em&gt; Unicode character: so you could elect to use that instead&amp;mdash;but it has only been available since MySQL 5.5.3.  An alternative is &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8.html&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt;, which is also &lt;em&gt;not vulnerable&lt;/em&gt; and can support the whole of the Unicode &lt;a href=&quot;http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane&quot;&gt;Basic Multilingual Plane&lt;/a&gt;.</source>
          <target state="translated">처음에 말했듯이이 공격이 작동하려면 데이터베이스 연결이 취약한 문자 세트를 사용하여 인코딩되어야합니다. &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8mb4.html&quot;&gt; &lt;code&gt;utf8mb4&lt;/code&gt; &lt;/a&gt; 는 &lt;em&gt;취약&lt;/em&gt; 하지는 않지만 &lt;em&gt;모든&lt;/em&gt; 유니 코드 문자를 지원할 수 있습니다. 따라서이 문자를 대신 사용하도록 선택할 수 있지만 MySQL 5.5.3부터 만 사용할 수 있습니다. 대안은 &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8.html&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt; 인데, 이는 &lt;em&gt;취약하지 않으며&lt;/em&gt; 유니 코드 &lt;a href=&quot;http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane&quot;&gt;기본 다국어 평면&lt;/a&gt; 전체를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c588b6a3c0b164ad3d10434a89c0efb53c9e05" translate="yes" xml:space="preserve">
          <source>Because MySQLi does true prepared statements all the time.</source>
          <target state="translated">MySQLi는 항상 준비된 진술을 수행하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ab3ccc3774a15cad2838d17bc59cee25b4efaa02" translate="yes" xml:space="preserve">
          <source>Because the server's expecting &lt;code&gt;utf8&lt;/code&gt;...</source>
          <target state="translated">서버가 &lt;code&gt;utf8&lt;/code&gt; 을 기대하기 때문에 ...</target>
        </trans-unit>
        <trans-unit id="9aa08df54ae5ee77bc5745d59edc07d0e6d4425b" translate="yes" xml:space="preserve">
          <source>Because we've properly set the character set so the client and the server match.</source>
          <target state="translated">클라이언트와 서버가 일치하도록 문자 세트를 올바르게 설정했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e6e40fafb086150124f1ba46290255cea1c1778d" translate="yes" xml:space="preserve">
          <source>Because we've set the character set properly.</source>
          <target state="translated">문자 세트를 올바르게 설정했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5ae657eb67501e49fa6473576ab76846e01342a4" translate="yes" xml:space="preserve">
          <source>Because we've turned off emulated prepared statements.</source>
          <target state="translated">우리는 에뮬레이트 된 준비된 진술을 해제했기 때문에.</target>
        </trans-unit>
        <trans-unit id="0eb8065189a48cf2287262d0ed3cfc832ded631c" translate="yes" xml:space="preserve">
          <source>But the worst part is that &lt;code&gt;PDO&lt;/code&gt; didn't expose the C API for &lt;code&gt;mysql_set_charset()&lt;/code&gt; until 5.3.6, so in prior versions it &lt;strong&gt;cannot&lt;/strong&gt; prevent this attack for every possible command!
 It's now exposed as a &lt;a href=&quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;DSN parameter&lt;/a&gt;.</source>
          <target state="translated">그러나 최악의 부분은 &lt;code&gt;PDO&lt;/code&gt; 가 5.3.6까지 &lt;code&gt;mysql_set_charset()&lt;/code&gt; 대한 C API를 공개하지 않았기 때문에 이전 버전에서는 가능한 모든 명령에 대해이 공격을 막을 &lt;strong&gt;수는 없다는 것입니다&lt;/strong&gt; ! 이제 &lt;a href=&quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;DSN 매개 변수&lt;/a&gt; 로 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="f025296c14b5fc464e225ba32792e8b977855f7b" translate="yes" xml:space="preserve">
          <source>Classic injections like this:</source>
          <target state="translated">다음과 같은 클래식 주사 :</target>
        </trans-unit>
        <trans-unit id="64a02599a21321950d895b4a71792c50295ebd34" translate="yes" xml:space="preserve">
          <source>Congratulations, you just successfully attacked a program using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;...</source>
          <target state="translated">축하합니다. &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; ...을 사용하여 프로그램을 성공적으로 공격했습니다.</target>
        </trans-unit>
        <trans-unit id="1e6f64ab75678829dd084a6595e2b0ae29ecddec" translate="yes" xml:space="preserve">
          <source>Consider the following query:</source>
          <target state="translated">다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="86b6f0784f01b0f24e5cd431494b3c0712fbc9e4" translate="yes" xml:space="preserve">
          <source>Consider this sample situation. SQL is constructed in PHP like this:</source>
          <target state="translated">이 샘플 상황을 고려하십시오. SQL은 다음과 같이 PHP로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="57b1a7674ba21811ac4ac6555e0308ab61bf2a2f" translate="yes" xml:space="preserve">
          <source>Do you know of any possible injection that would get through the PHP code above?</source>
          <target state="translated">위의 PHP 코드를 통해 얻을 수있는 주입에 대해 알고 있습니까?</target>
        </trans-unit>
        <trans-unit id="803967a50e0348bca88eff4b61af251e5d520585" translate="yes" xml:space="preserve">
          <source>Don't use a vulnerable character set for connection encoding (you only use &lt;code&gt;utf8&lt;/code&gt; / &lt;code&gt;latin1&lt;/code&gt; / &lt;code&gt;ascii&lt;/code&gt; / etc)</source>
          <target state="translated">연결 인코딩에 취약한 문자 세트를 사용하지 마십시오 ( &lt;code&gt;utf8&lt;/code&gt; / &lt;code&gt;latin1&lt;/code&gt; / &lt;code&gt;ascii&lt;/code&gt; 등 만 사용)</target>
        </trans-unit>
        <trans-unit id="2318c4b0b2488cce207802b573caaf58285428bb" translate="yes" xml:space="preserve">
          <source>For Very OBSCURE EDGE CASES!!!</source>
          <target state="translated">매우 엣지 케이스의 경우 !!!</target>
        </trans-unit>
        <trans-unit id="d015ba7528fb1eb280c5a43556bdaab371f6ef49" translate="yes" xml:space="preserve">
          <source>For this attack to work, we need the encoding that the server's expecting on the connection both to encode &lt;code&gt;'&lt;/code&gt; as in ASCII i.e. &lt;code&gt;0x27&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; to have some character whose final byte is an ASCII &lt;code&gt;\&lt;/code&gt; i.e. &lt;code&gt;0x5c&lt;/code&gt;.  As it turns out, there are 5 such encodings supported in MySQL 5.6 by default: &lt;code&gt;big5&lt;/code&gt;, &lt;code&gt;cp932&lt;/code&gt;, &lt;code&gt;gb2312&lt;/code&gt;, &lt;code&gt;gbk&lt;/code&gt; and &lt;code&gt;sjis&lt;/code&gt;.  We'll select &lt;code&gt;gbk&lt;/code&gt; here.</source>
          <target state="translated">이 공격이 작동하려면 서버가 ASCII, 즉 &lt;code&gt;0x27&lt;/code&gt; 에서 &lt;em&gt;와&lt;/em&gt; 같이 &lt;code&gt;'&lt;/code&gt; 인코딩 &lt;em&gt;하고&lt;/em&gt; 최종 바이트가 ASCII &lt;code&gt;\&lt;/code&gt; ie &lt;code&gt;0x5c&lt;/code&gt; 인 일부 문자를 연결하기 위해 서버가 연결을 기대하는 인코딩이 필요합니다. 결과적으로 MySQL 5.6에서는 기본적으로 &lt;code&gt;big5&lt;/code&gt; , &lt;code&gt;cp932&lt;/code&gt; , &lt;code&gt;gb2312&lt;/code&gt; , &lt;code&gt;gbk&lt;/code&gt; 및 &lt;code&gt;sjis&lt;/code&gt; 와 같은 5 가지 인코딩이 지원됩니다. 여기서는 &lt;code&gt;gbk&lt;/code&gt; 를 선택하겠습니다.</target>
        </trans-unit>
        <trans-unit id="aa1fdb589fc94178b8e4146e0b68fb9f46b62bc9" translate="yes" xml:space="preserve">
          <source>For this reason, I recommend that anyone using &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; also enables &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_ansi_quotes&quot;&gt;&lt;code&gt;ANSI_QUOTES&lt;/code&gt;&lt;/a&gt; mode, as it will force habitual use of single-quoted string literals.  Note that this does not prevent SQL injection in the event that double-quoted literals happen to be used&amp;mdash;it merely reduces the likelihood of that happening (because normal, non-malicious queries would fail).</source>
          <target state="translated">이러한 이유로 &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; 를 사용하는 사람은 모두 작은 따옴표로 묶인 문자열 리터럴을 습관적으로 사용하므로 &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_ansi_quotes&quot;&gt; &lt;code&gt;ANSI_QUOTES&lt;/code&gt; &lt;/a&gt; 모드를 사용하는 것이 좋습니다. 큰 따옴표로 묶인 리터럴이 사용되는 경우 SQL 삽입을 막을 수는 없습니다. 이는 정상적인 악의없는 쿼리가 실패하기 때문에 발생 가능성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="9b63e3ab0f3f3c328e5af9e1da909b50f98ce45d" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; does check the SQL mode and adjust its behaviour accordingly.  See &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/libmysql/libmysql.c#L1267&quot;&gt;&lt;code&gt;libmysql.c&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다행히도 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 은 SQL 모드를 확인하고 그에 따라 동작을 조정합니다. &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/libmysql/libmysql.c#L1267&quot;&gt; &lt;code&gt;libmysql.c&lt;/code&gt; 를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2d00fd64fccabbd0f52bf8ac63661bfa39008be" translate="yes" xml:space="preserve">
          <source>Functionality Added or Changed</source>
          <target state="translated">추가되거나 변경된 기능</target>
        </trans-unit>
        <trans-unit id="8cad1370c5af86b04374fcbfdbe5fc2dcb0f2116" translate="yes" xml:space="preserve">
          <source>However, this function arbitrarily &lt;em&gt;assumes&lt;/em&gt; that the string will be quoted using the single-quote &lt;code&gt;'&lt;/code&gt; character.  See &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/mysys/charset.c#L836&quot;&gt;&lt;code&gt;charset.c&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그러나이 함수는 문자열이 작은 따옴표 문자를 사용하여 인용 될 것이라고 임의로 &lt;em&gt;가정&lt;/em&gt; 합니다. &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/mysys/charset.c#L836&quot;&gt; &lt;code&gt;charset.c&lt;/code&gt; &lt;/a&gt; 참조 :</target>
        </trans-unit>
        <trans-unit id="36e26f357c029b64a1fb331af707285d8e5bd0dd" translate="yes" xml:space="preserve">
          <source>I have heard numerous people say to me that code like that is still dangerous and possible to hack even with &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; function used. But I cannot think of any possible exploit?</source>
          <target state="translated">많은 사람들이 그런 코드가 여전히 위험하고 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 함수를 사용하여 해킹 할 수 있다고 말합니다. 그러나 가능한 악용을 생각할 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="0b1b883f0b54b49d027a8f5fb5694058665c68be" translate="yes" xml:space="preserve">
          <source>I said at the very beginning that we could have prevented all of this if we had used &lt;code&gt;mysql_set_charset('gbk')&lt;/code&gt; instead of &lt;code&gt;SET NAMES gbk&lt;/code&gt;. And that's true provided you are using a MySQL release since 2006.</source>
          <target state="translated">나는 처음에 &lt;code&gt;SET NAMES gbk&lt;/code&gt; 대신 &lt;code&gt;mysql_set_charset('gbk')&lt;/code&gt; 을 사용했다면이 모든 것을 막을 수 있다고 말했다. 2006 년 이후로 MySQL 릴리스를 사용하는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="81f0dc176701bfda65f13b7c9a46ab6048a4e039" translate="yes" xml:space="preserve">
          <source>If the server's SQL mode includes &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt;, then the third of these options&amp;mdash;which is the usual approach adopted by &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&amp;mdash;is not available: one of the first two options must be used instead.  Note that the effect of the fourth bullet is that one must necessarily know the character that will be used to quote the literal in order to avoid munging one's data.</source>
          <target state="translated">서버의 SQL 모드에 &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; 가&lt;/a&gt; 포함 된 경우 , &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 의해 채택 된 일반적인 접근 방식 인 이러한 옵션 중 세 번째 옵션을 사용할 수 없습니다. 처음 두 옵션 중 하나를 대신 사용해야합니다. 네 번째 글 머리 기호의 효과는 데이터를 녹이지 않기 위해 리터럴을 인용하는 데 사용될 문자를 반드시 알아야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="86ab0b4c0397c452e673ed3642be48e6fdfe8342" translate="yes" xml:space="preserve">
          <source>If you're using an earlier MySQL release, then a &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot;&gt;bug&lt;/a&gt; in &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; meant that invalid multibyte characters such as those in our payload were treated as single bytes for escaping purposes &lt;em&gt;even if the client had been correctly informed of the connection encoding&lt;/em&gt; and so this attack would still succeed.  The bug was fixed in MySQL &lt;a href=&quot;http://dev.mysql.com/doc/refman/4.1/en/news-4-1-20.html&quot;&gt;4.1.20&lt;/a&gt;, &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html&quot;&gt;5.0.22&lt;/a&gt; and &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html&quot;&gt;5.1.11&lt;/a&gt;.</source>
          <target state="translated">이전 MySQL 릴리스를 사용하는 경우 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 의 &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot;&gt;버그&lt;/a&gt; &lt;em&gt;는 클라이언트에 연결 인코딩에 대한 정확한 정보가 있더라도&lt;/em&gt; 페이로드의 문자와 같은 유효하지 않은 멀티 바이트 문자가 이스케이프 목적으로 단일 바이트로 처리 &lt;em&gt;되었음을 의미합니다.&lt;/em&gt; 이 공격은 여전히 ​​성공할 것입니다. 버그는 MySQL &lt;a href=&quot;http://dev.mysql.com/doc/refman/4.1/en/news-4-1-20.html&quot;&gt;4.1.20&lt;/a&gt; , &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html&quot;&gt;5.0.22&lt;/a&gt; 및 &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html&quot;&gt;5.1.11&lt;/a&gt; 에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="235aa4b0c2bc1b8d4771ded0fab393b955216156" translate="yes" xml:space="preserve">
          <source>If you:</source>
          <target state="translated">만약 너라면:</target>
        </trans-unit>
        <trans-unit id="78e7eaa8d236315c8fb69481369755a898a61600" translate="yes" xml:space="preserve">
          <source>In PDO, both its equivalent function &lt;a href=&quot;http://www.php.net/manual/en/pdo.quote.php&quot;&gt;&lt;code&gt;PDO::quote()&lt;/code&gt;&lt;/a&gt; and its prepared statement emulator call upon &lt;a href=&quot;https://github.com/php/php-src/blob/af6c11c5f060870d052a2b765dc634d9e47d0f18/ext/pdo_mysql/mysql_driver.c#L302&quot;&gt;&lt;code&gt;mysql_handle_quoter()&lt;/code&gt;&lt;/a&gt;&amp;mdash;which does exactly this: it ensures that the escaped literal is quoted in single-quotes, so you can be certain that PDO is always immune from this bug.</source>
          <target state="translated">PDO에서 동등한 함수 &lt;a href=&quot;http://www.php.net/manual/en/pdo.quote.php&quot;&gt; &lt;code&gt;PDO::quote()&lt;/code&gt; &lt;/a&gt; 및 준비된 명령문 에뮬레이터는 &lt;a href=&quot;https://github.com/php/php-src/blob/af6c11c5f060870d052a2b765dc634d9e47d0f18/ext/pdo_mysql/mysql_driver.c#L302&quot;&gt; &lt;code&gt;mysql_handle_quoter()&lt;/code&gt; &lt;/a&gt; 호출합니다. 정확히 이렇게 : 이스케이프 된 리터럴이 작은 따옴표로 인용되므로 PDO가 확실하다는 것을 확신 할 수 있습니다. 항상이 버그로부터 면역됩니다.</target>
        </trans-unit>
        <trans-unit id="9d385aaa3b30c1b6d51bc5a5eecd64a89068cd9c" translate="yes" xml:space="preserve">
          <source>In certain circumstances, that will return more than 1 row. Let's dissect what's going on here:</source>
          <target state="translated">특정 상황에서는 둘 이상의 행이 반환됩니다. 여기서 무슨 일이 일어나고 있는지 해부하자 :</target>
        </trans-unit>
        <trans-unit id="fca7d62fc26dfbdd5bd711892d63ed4d75cd8722" translate="yes" xml:space="preserve">
          <source>In homage to &lt;a href=&quot;https://stackoverflow.com/a/12118602&quot;&gt;@ircmaxell's excellent answer&lt;/a&gt; (really, this is supposed to be flattery and not plagiarism!), I will adopt his format:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/12118602&quot;&gt;@ircmaxell의 탁월한 답변에&lt;/a&gt; 진심으로 (실제로 이것은 표절이 아니라 아첨해야합니다!), 나는 그의 형식을 채택 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="cd215dc2b2ecbacd3fd36421b3a2fba7cb5bfacc" translate="yes" xml:space="preserve">
          <source>Is there an SQL injection possibility even when using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; function?</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 함수를 사용할 때도 SQL 삽입 가능성이 있습니까?</target>
        </trans-unit>
        <trans-unit id="a01adb93bc3b6fc2e61af0b19dd2925d0e9c9ad7" translate="yes" xml:space="preserve">
          <source>It gets worse.  &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; may not be all that uncommon in the wild owing to the necessity of its use for compatibility with standard SQL (e.g. see section 5.3 of the &lt;a href=&quot;http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt&quot;&gt;SQL-92 specification&lt;/a&gt;, namely the &lt;code&gt;&amp;lt;quote symbol&amp;gt; ::= &amp;lt;quote&amp;gt;&amp;lt;quote&amp;gt;&lt;/code&gt; grammar production and lack of any special meaning given to backslash).  Furthermore, its use was explicitly &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html&quot;&gt;recommended as a workaround&lt;/a&gt; to the (long since fixed) &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot;&gt;bug&lt;/a&gt; that ircmaxell's post describes.  Who knows, some DBAs might even configure it to be on by default as means of discouraging use of incorrect escaping methods like &lt;a href=&quot;http://www.php.net/manual/en/function.addslashes.php&quot;&gt;&lt;code&gt;addslashes()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">악화된다. &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; 는 표준 SQL과의 호환성을 위해 사용되어야하기 때문에 일반적으로 드물지 않을 수 있습니다 (예 : &lt;a href=&quot;http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt&quot;&gt;SQL-92 사양&lt;/a&gt; 의 섹션 5.3, 즉 &lt;code&gt;&amp;lt;quote symbol&amp;gt; ::= &amp;lt;quote&amp;gt;&amp;lt;quote&amp;gt;&lt;/code&gt; 문법) 백 슬래시에 주어진 특별한 의미의 생산 및 부족). 또한 ircmaxell의 게시물에서 설명하는 (고정 된 이후의) &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot;&gt;버그에&lt;/a&gt; &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html&quot;&gt;대한 해결 방법&lt;/a&gt; 으로 사용하는 것이 명시 적으로 권장되었습니다 . 누가 알다시피, 일부 DBA는 &lt;a href=&quot;http://www.php.net/manual/en/function.addslashes.php&quot;&gt; &lt;code&gt;addslashes()&lt;/code&gt; &lt;/a&gt; 와 같은 잘못된 이스케이프 메소드 사용을 권장하지 않기 위해 기본적으로 ON 상태로 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fa30bd77891dfa8c42dc41c3dd05d912df41b95" translate="yes" xml:space="preserve">
          <source>It gets worse. &lt;code&gt;PDO&lt;/code&gt; defaults to &lt;em&gt;emulating&lt;/em&gt; prepared statements with MySQL. That means that on the client side, it basically does a sprintf through &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; (in the C library), which means the following will result in a successful injection:</source>
          <target state="translated">악화된다. &lt;code&gt;PDO&lt;/code&gt; 는 기본적으로 MySQL을 사용 &lt;em&gt;하여&lt;/em&gt; 준비된 명령문을 &lt;em&gt;에뮬레이트&lt;/em&gt; 합니다. 즉, 클라이언트 측에서는 기본적으로 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; (C 라이브러리)을 통해 sprintf를 수행하므로 다음과 같이 성공적으로 주입됩니다.</target>
        </trans-unit>
        <trans-unit id="89cfd0b4b9c37c369d254688a7865cee4b004e34" translate="yes" xml:space="preserve">
          <source>MySQL's &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; SQL mode is enabled (which it &lt;em&gt;might&lt;/em&gt; be, unless you &lt;em&gt;explicitly&lt;/em&gt; select another SQL mode &lt;em&gt;every time you connect&lt;/em&gt;); and</source>
          <target state="translated">MySQL의 &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; &lt;/a&gt; SQL 모드가 활성화되어 있습니다 ( &lt;em&gt;연결할 때마다&lt;/em&gt; 다른 SQL 모드를 &lt;em&gt;명시 적으로&lt;/em&gt; 선택하지 않는 한). 과</target>
        </trans-unit>
        <trans-unit id="0d560a10506f0b7ef8adddb39825d6e51880d891" translate="yes" xml:space="preserve">
          <source>Now, it's very important to note the use of &lt;code&gt;SET NAMES&lt;/code&gt; here. This sets the character set &lt;strong&gt;ON THE SERVER&lt;/strong&gt;. If we used the call to the C API function &lt;code&gt;mysql_set_charset()&lt;/code&gt;, we'd be fine (on MySQL releases since 2006). But more on why in a minute...</source>
          <target state="translated">이제 &lt;code&gt;SET NAMES&lt;/code&gt; 사용에 주목하는 것이 중요합니다. 이것은 &lt;strong&gt;서버에&lt;/strong&gt; 문자 세트를 설정합니다. C API 함수 &lt;code&gt;mysql_set_charset()&lt;/code&gt; 호출을 사용하면 2006 년 이후 MySQL 릴리스에서 문제가 없습니다. 그러나 왜 잠시 후에 더 많은 ...</target>
        </trans-unit>
        <trans-unit id="ee2774f4a8600878360cd4aa4dec59819c4a2daf" translate="yes" xml:space="preserve">
          <source>Now, it's worth noting that you can prevent this by disabling emulated prepared statements:</source>
          <target state="translated">이제 에뮬레이트 된 준비된 문장을 비활성화하여 이것을 막을 수 있다는 점에 주목할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37e3a83b6f32baf1ce3b99fb4397cb5192c677fd" translate="yes" xml:space="preserve">
          <source>Otherwise, you're vulnerable &lt;strong&gt;even though you're using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/strong&gt;...</source>
          <target state="translated">그렇지 않으면 &lt;strong&gt; &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 사용하더라도&lt;/strong&gt; 취약합니다 ...</target>
        </trans-unit>
        <trans-unit id="8644422a5fd7bc5ab0faf2e95c0f80b5e0de76c0" translate="yes" xml:space="preserve">
          <source>PDO;</source>
          <target state="translated">PDO;</target>
        </trans-unit>
        <trans-unit id="12facaa5c4baa8dbe06d38af1db67cfb4618c3a7" translate="yes" xml:space="preserve">
          <source>Precede the quote character by an escape character (&amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo;).</source>
          <target state="translated">따옴표 문자는 이스케이프 문자 (&amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;)로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b447cf795752cf7900ede4f8d3cb07528cd44316" translate="yes" xml:space="preserve">
          <source>References: See also Bug #19211994.</source>
          <target state="translated">참조 : 버그 # 19211994 참조.</target>
        </trans-unit>
        <trans-unit id="9464db2ea229e88ee8b162ca13c18fd0cd70c3b4" translate="yes" xml:space="preserve">
          <source>SQL injection that gets around mysql_real_escape_string()</source>
          <target state="translated">mysql_real_escape_string ()을 둘러싼 SQL 주입</target>
        </trans-unit>
        <trans-unit id="4bd13a83b5e3cd19475748abea0450580b208585" translate="yes" xml:space="preserve">
          <source>Safe Examples</source>
          <target state="translated">안전한 예</target>
        </trans-unit>
        <trans-unit id="f3a1435b2a5f8c71ecc9887e736a3b6565908745" translate="yes" xml:space="preserve">
          <source>So long as you always &lt;em&gt;explicitly&lt;/em&gt; set the SQL mode not to include &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;, or quote MySQL string literals using the single-quote character, this bug cannot rear its ugly head: respectively &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt; will not be used, or its assumption about which quote characters require repeating will be correct.</source>
          <target state="translated">항상 &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; 를 포함하지 않도록 SQL 모드를 &lt;em&gt;명시 적으로&lt;/em&gt; 설정하거나 작은 따옴표 문자를 사용하여 MySQL 문자열 리터럴을 인용하는 한,이 버그는 못생긴 머리를 &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt; 수 없습니다 : 각각 escape_quotes_for_mysql () 은 사용되지 않거나 어떤 따옴표에 대한 가정 반복해야하는 문자가 정확합니다.</target>
        </trans-unit>
        <trans-unit id="9c82cfcfd7c80f51a781706aa481de5181a2badb" translate="yes" xml:space="preserve">
          <source>So, it leaves double-quote &lt;code&gt;&quot;&lt;/code&gt; characters untouched (and doubles all single-quote &lt;code&gt;'&lt;/code&gt; characters) &lt;em&gt;irrespective of the actual character that is used to quote the literal&lt;/em&gt;!  In our case &lt;code&gt;$var&lt;/code&gt; remains exactly the same as the argument that was provided to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&amp;mdash;it's as though no escaping has taken place &lt;em&gt;at all&lt;/em&gt;.</source>
          <target state="translated">따라서 &lt;em&gt;리터럴을 인용하는 데 사용되는 실제 문자에 관계없이&lt;/em&gt; 큰 따옴표 &lt;code&gt;&quot;&lt;/code&gt; 문자를 그대로 유지하고 모든 작은 따옴표 문자를 두 배로 &lt;em&gt;만듭니다&lt;/em&gt; !이 경우 &lt;code&gt;$var&lt;/code&gt; 은 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 에 제공된 인수와 정확히 동일하게 유지됩니다. () -탈출이 전혀없는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="2bd3c2fbb16f38ebaca58d2e99147a45e4a33ffd" translate="yes" xml:space="preserve">
          <source>So, let's start off by showing the attack...</source>
          <target state="translated">이제 공격을 보여 주면서 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b94521d5250b6b4dcf2e2112579d8894701d0cb4" translate="yes" xml:space="preserve">
          <source>Something of a formality, the rendered query is:</source>
          <target state="translated">형식적인 것으로 렌더링 된 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cbb325b5206a8f47d212b34898e5c8169949014" translate="yes" xml:space="preserve">
          <source>Starting off with a demonstration...</source>
          <target state="translated">데모로 시작하는 중 ...</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="25068c6d83c499102f62408ff3863a0136e28d48" translate="yes" xml:space="preserve">
          <source>Taken together with the bug explained by ircmaxell, the following examples are entirely safe (assuming that one is either using MySQL later than 4.1.20, 5.0.22, 5.1.11; or that one is not using a GBK/Big5 connection encoding):</source>
          <target state="translated">ircmaxell에 의해 설명 된 버그와 함께, 다음 예제는 완전히 안전합니다 (4.1.20, 5.0.22, 5.1.11 이후의 MySQL을 사용하거나 GBK / Big5 연결 인코딩을 사용하지 않는 것으로 가정). :</target>
        </trans-unit>
        <trans-unit id="89bc52d9aa970eea662979097ac001b91d0a09c6" translate="yes" xml:space="preserve">
          <source>The Attack</source>
          <target state="translated">공격</target>
        </trans-unit>
        <trans-unit id="f6211e866c7239c64ef20925a961bec5d73d25aa" translate="yes" xml:space="preserve">
          <source>The Bad</source>
          <target state="translated">나쁜</target>
        </trans-unit>
        <trans-unit id="e18ed415a8c62de74d72d0537889979e1e5ad61f" translate="yes" xml:space="preserve">
          <source>The C API call to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; differs from &lt;code&gt;addslashes()&lt;/code&gt; in that it knows the connection character set. So it can perform the escaping properly for the character set that the server is expecting. However, up to this point, the client thinks that we're still using &lt;code&gt;latin1&lt;/code&gt; for the connection, because we never told it otherwise. We did tell the &lt;em&gt;server&lt;/em&gt; we're using &lt;code&gt;gbk&lt;/code&gt;, but the &lt;em&gt;client&lt;/em&gt; still thinks it's &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 대한 C API 호출은 연결 문자 세트를 알고 있다는 점에서 &lt;code&gt;addslashes()&lt;/code&gt; 와 다릅니다. 따라서 서버가 기대하는 문자 세트에 대해 이스케이프를 올바르게 수행 할 수 있습니다. 그러나 지금까지 클라이언트는 연결에 대해 &lt;code&gt;latin1&lt;/code&gt; 을 사용하고 있다고 생각합니다. 왜냐하면 우리는 달리 말하지 않았기 때문입니다. 우리는 &lt;em&gt;서버에&lt;/em&gt; &lt;code&gt;gbk&lt;/code&gt; 를 사용하고 있다고 말했지만 &lt;em&gt;클라이언트는&lt;/em&gt; 여전히 그것이 &lt;code&gt;latin1&lt;/code&gt; 이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="f719c4c198c8aa78f8261fc01cd90d7f870228d1" translate="yes" xml:space="preserve">
          <source>The Saving Grace</source>
          <target state="translated">구원의 은총</target>
        </trans-unit>
        <trans-unit id="0adbabc52b10370afa8aa9ba0a194b758fcfc4a6" translate="yes" xml:space="preserve">
          <source>The Ugly</source>
          <target state="translated">못난이</target>
        </trans-unit>
        <trans-unit id="4ca7fcff8448ca54a794cc01a9233524ca077c37" translate="yes" xml:space="preserve">
          <source>The following examples are safe:</source>
          <target state="translated">다음 예는 안전합니다.</target>
        </trans-unit>
        <trans-unit id="84cd8937e1e420f026695377c299a003071b2509" translate="yes" xml:space="preserve">
          <source>The long answer isn't so easy. It's based off an attack &lt;a href=&quot;http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string&quot;&gt;demonstrated here&lt;/a&gt;.</source>
          <target state="translated">긴 대답은 쉽지 않습니다. &lt;a href=&quot;http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string&quot;&gt;여기서 시연&lt;/a&gt; 된 공격을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="1165da1a5fb1e85299a86fab06d35f1c1da8af71" translate="yes" xml:space="preserve">
          <source>The payload initiates this injection quite literally with the &lt;code&gt;&quot;&lt;/code&gt; character.  No particular encoding.  No special characters.  No weird bytes.</source>
          <target state="translated">페이로드는 문자 그대로 &lt;code&gt;&quot;&lt;/code&gt; 문자, 특정 인코딩 없음, 특수 문자 없음, 이상한 바이트 없음 &quot;으로 문자 그대로이 주입을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="07aed08f014598f23f998bfbccd45201722e2fa4" translate="yes" xml:space="preserve">
          <source>The payload we're going to use for this injection starts with the byte sequence &lt;code&gt;0xbf27&lt;/code&gt;.  In &lt;code&gt;gbk&lt;/code&gt;, that's an invalid multibyte character; in &lt;code&gt;latin1&lt;/code&gt;, it's the string &lt;code&gt;&amp;iquest;'&lt;/code&gt;.  Note that in &lt;code&gt;latin1&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;code&gt;gbk&lt;/code&gt;, &lt;code&gt;0x27&lt;/code&gt; on its own is a literal &lt;code&gt;'&lt;/code&gt; character.</source>
          <target state="translated">이 주입에 사용할 페이로드는 바이트 시퀀스 &lt;code&gt;0xbf27&lt;/code&gt; 로 시작합니다. &lt;code&gt;gbk&lt;/code&gt; 에서는 유효하지 않은 멀티 바이트 문자입니다. &lt;code&gt;latin1&lt;/code&gt; 에서 문자열 &lt;code&gt;&amp;iquest;'&lt;/code&gt; 입니다. &lt;code&gt;latin1&lt;/code&gt; &lt;strong&gt;및&lt;/strong&gt; &lt;code&gt;gbk&lt;/code&gt; 에서 &lt;code&gt;0x27&lt;/code&gt; 자체는 리터럴 &lt;code&gt;'&lt;/code&gt; 문자입니다.</target>
        </trans-unit>
        <trans-unit id="85bd2888b9839820671225f5734478627dd03249" translate="yes" xml:space="preserve">
          <source>The problem, if not already obvious, is that the call to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;strong&gt;cannot know&lt;/strong&gt; with which character the literal will be quoted, as that's left to the developer to decide at a later time.  So, in &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; mode, there is literally &lt;em&gt;no way&lt;/em&gt; that this function can safely escape every input for use with arbitrary quoting (at least, not without doubling characters that do not require doubling and thus munging your data).</source>
          <target state="translated">문제는 아직 명확하지 않은 경우 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 호출하면 리터럴이 어떤 문자로 인용되는지 &lt;strong&gt;알 수 없다는&lt;/strong&gt; 것인데, 이는 나중에 결정하도록 개발자에게 맡겨지기 때문입니다. 따라서 &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; 모드에서는 말 그대로이 함수가 임의의 인용 부호 와 함께 사용하기 위해 모든 입력을 안전하게 이스케이프 처리 할 수있는 &lt;em&gt;방법&lt;/em&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="42547b0db8d37e67c49237fd41e6482b1196a721" translate="yes" xml:space="preserve">
          <source>The short answer is &lt;strong&gt;yes, yes there is a way to get around &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">짧은 대답은 &lt;strong&gt;그렇습니다. 그렇습니다 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 수있는 방법이&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b36b71f5cebbf3e5bb1fd67c6d133231f6b995c" translate="yes" xml:space="preserve">
          <source>There are several ways to include quote characters within a string:</source>
          <target state="translated">문자열 내에 따옴표 문자를 포함시키는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8d7f358d85c417e09e78e8cac811d79bc9e09f" translate="yes" xml:space="preserve">
          <source>Therefore the call to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; inserts the backslash, and we have a free hanging &lt;code&gt;'&lt;/code&gt; character in our &quot;escaped&quot; content! In fact, if we were to look at &lt;code&gt;$var&lt;/code&gt; in the &lt;code&gt;gbk&lt;/code&gt; character set, we'd see:</source>
          <target state="translated">따라서 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 대한 호출은 백 슬래시를 삽입하고, &quot;탈출 된&quot;컨텐츠에 자유롭게 걸려있는 &lt;code&gt;'&lt;/code&gt; 문자가 있습니다! 실제로 &lt;code&gt;gbk&lt;/code&gt; 문자 세트에서 &lt;code&gt;$var&lt;/code&gt; 를 살펴보면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de3f27253dad909a6292065ce32ea790bbf0a14b" translate="yes" xml:space="preserve">
          <source>This is another, (perhaps less?) obscure EDGE CASE!!!</source>
          <target state="translated">이것은 또 다른 (아마도 적습니까?) EDGE CASE를 모호합니다.</target>
        </trans-unit>
        <trans-unit id="a6c89c13dcd4c5d68d0db7503c9622c5b9f6bea7" translate="yes" xml:space="preserve">
          <source>This part is just a formality, but here's the rendered query:</source>
          <target state="translated">이 부분은 형식 일 뿐이지 만 렌더링 된 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6843dd3ca9404f6ea2c9c3ff1f6d3d8a330be1fa" translate="yes" xml:space="preserve">
          <source>This was filed as &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=72458&quot;&gt;bug #72458&lt;/a&gt; and has been fixed in MySQL v5.7.6 (see the section headed &quot;&lt;strong&gt;The Saving Grace&lt;/strong&gt;&quot;, below).</source>
          <target state="translated">이것은 &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=72458&quot;&gt;버그 #&lt;/a&gt; 72458로 제출되었으며 MySQL v5.7.6에서 수정되었습니다 (아래 &quot; &lt;strong&gt;저축 유예&lt;/strong&gt; &quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="540c75deef36dee1b0a10012d512093062f3975e" translate="yes" xml:space="preserve">
          <source>This will &lt;em&gt;usually&lt;/em&gt; result in a true prepared statement (i.e. the data being sent over in a separate packet from the query). However, be aware that PDO will silently &lt;a href=&quot;https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210&quot;&gt;fallback&lt;/a&gt; to emulating statements that MySQL can't prepare natively: those that it can are &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-syntax-prepared-statements.html&quot;&gt;listed&lt;/a&gt; in the manual, but beware to select the appropriate server version).</source>
          <target state="translated">이것은 &lt;em&gt;일반적으로&lt;/em&gt; 준비된 성명서 (즉, 데이터가 쿼리와 별도의 패킷으로 전송 됨)를 초래합니다. 그러나 PDO는 MySQL이 기본적으로 준비 할 수없는 명령문 (매뉴얼에 &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-syntax-prepared-statements.html&quot;&gt;나열&lt;/a&gt; 될 수 있지만 적절한 서버 버전을 선택하도록주의해야하는 명령문)을 에뮬레이션하는 것으로 자동으로 &lt;a href=&quot;https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210&quot;&gt;대체&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="90d6fd21f00e277e8719aa42844f6aeaa43c8a99" translate="yes" xml:space="preserve">
          <source>This will return all records from the &lt;code&gt;test&lt;/code&gt; table.  A dissection:</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 테이블에서 모든 레코드를 반환합니다. 해부 :</target>
        </trans-unit>
        <trans-unit id="bdb8bf736b134dd49ab0915dcc3a725d69a44cc6" translate="yes" xml:space="preserve">
          <source>Thus a different underlying function, &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt;, is invoked if the &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; SQL mode is in use.  As mentioned above, such a function needs to know which character will be used to quote the literal in order to repeat it without causing the other quotation character from being repeated literally.</source>
          <target state="translated">따라서 &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; SQL 모드가 사용중인 경우 다른 기본 함수 &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt; 이 호출됩니다. 위에서 언급 한 바와 같이, 그러한 함수는 다른 인용 문자가 문자 그대로 반복되지 않고 문자를 반복하기 위해 문자를 인용하는 데 사용될 문자를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="0806e20ed1459118ce9b52f165bc00868a177d26" translate="yes" xml:space="preserve">
          <source>Thus, if you:</source>
          <target state="translated">따라서 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="985e4313b4f69c20bac9a62ad436714ad736a0be" translate="yes" xml:space="preserve">
          <source>Use Modern Versions of MySQL (late 5.1, all 5.5, 5.6, etc) &lt;strong&gt;AND&lt;/strong&gt;&lt;code&gt;mysql_set_charset()&lt;/code&gt; / &lt;code&gt;$mysqli-&amp;gt;set_charset()&lt;/code&gt; / PDO's DSN charset parameter (in PHP &amp;ge; 5.3.6)</source>
          <target state="translated">최신 버전의 MySQL (late 5.1, all 5.5, 5.6 등) &lt;strong&gt;및&lt;/strong&gt; &lt;code&gt;mysql_set_charset()&lt;/code&gt; / &lt;code&gt;$mysqli-&amp;gt;set_charset()&lt;/code&gt; / PDO의 DSN 문자 세트 매개 변수 사용 (PHP &amp;ge; 5.3.6)</target>
        </trans-unit>
        <trans-unit id="427ec19a36c3eadeeaa0cbf7051413a63eca61b8" translate="yes" xml:space="preserve">
          <source>We have chosen this payload because, if we called &lt;code&gt;addslashes()&lt;/code&gt; on it, we'd insert an ASCII &lt;code&gt;\&lt;/code&gt; i.e. &lt;code&gt;0x5c&lt;/code&gt;, before the &lt;code&gt;'&lt;/code&gt; character. So we'd wind up with &lt;code&gt;0xbf5c27&lt;/code&gt;, which in &lt;code&gt;gbk&lt;/code&gt; is a two character sequence: &lt;code&gt;0xbf5c&lt;/code&gt; followed by &lt;code&gt;0x27&lt;/code&gt;. Or in other words, a &lt;em&gt;valid&lt;/em&gt; character followed by an unescaped &lt;code&gt;'&lt;/code&gt;. But we're not using &lt;code&gt;addslashes()&lt;/code&gt;. So on to the next step...</source>
          <target state="translated">&lt;code&gt;addslashes()&lt;/code&gt; 를 호출하면 ASCII 문자 (예 : &lt;code&gt;0x5c&lt;/code&gt; )를 &lt;code&gt;'&lt;/code&gt; 문자 앞에 삽입하기 때문에이 페이로드를 선택했습니다. 따라서 우리는 &lt;code&gt;0xbf5c27&lt;/code&gt; 을 사용합니다. gbk 에서는 &lt;code&gt;0xbf5c&lt;/code&gt; 다음에 &lt;code&gt;0x27&lt;/code&gt; 두 문자 시퀀스가 ​​있습니다. 즉, &lt;em&gt;유효한&lt;/em&gt; 문자 뒤에 이스케이프 처리되지 않은 &lt;code&gt;'&lt;/code&gt; 이 있습니다. 그러나 우리는 &lt;code&gt;addslashes()&lt;/code&gt; 사용하지 않습니다. 다음 단계로 넘어갑니다 ...</target>
        </trans-unit>
        <trans-unit id="4ea0cdc50b3e6c87d368d6f640192c16206f3e34" translate="yes" xml:space="preserve">
          <source>Well, there's nothing really that can pass through that, other than &lt;code&gt;%&lt;/code&gt; wildcard. It could be dangerous if you were using &lt;code&gt;LIKE&lt;/code&gt; statement as attacker could put just &lt;code&gt;%&lt;/code&gt; as login if you don't filter that out, and would have to just bruteforce a password of any of your users.
People often suggest using prepared statements to make it 100% safe, as data can't interfere with the query itself that way.
But for such simple queries it probably would be more efficient to do something like &lt;code&gt;$login = preg_replace('/[^a-zA-Z0-9_]/', '', $login);&lt;/code&gt;</source>
          <target state="translated">글쎄, &lt;code&gt;%&lt;/code&gt; 와일드 카드를 제외하고는 실제로 그것을 통과 할 수있는 것은 없습니다. &lt;code&gt;LIKE&lt;/code&gt; 문을 사용 하는 경우 공격자가 필터링하지 않으면 로그인에 &lt;code&gt;%&lt;/code&gt; 만 입력 할 수 있고 사용자의 암호를 무차별 처리해야하므로 위험 할 수 있습니다. 사람들은 종종 준비된 명령문을 사용하여 데이터를 쿼리 자체를 방해하지 않기 때문에 100 % 안전하도록 제안합니다. 그러나 이러한 간단한 쿼리의 경우 &lt;code&gt;$login = preg_replace('/[^a-zA-Z0-9_]/', '', $login);&lt;/code&gt; 과 같은 작업을 수행하는 것이 더 효율적일 것입니다 .</target>
        </trans-unit>
        <trans-unit id="d73739e8bcc2eca14c4e6ee94849b3f8eb574f29" translate="yes" xml:space="preserve">
          <source>Which is &lt;a href=&quot;https://www.google.com/search?q=%E7%B8%97%27%20OR&amp;amp;oq=%E7%B8%97%27%20OR&amp;amp;aqs=chrome..69i57&amp;amp;sourceid=chrome&amp;amp;es_sm=122&amp;amp;ie=UTF-8&quot;&gt;exactly what&lt;/a&gt; the attack requires.</source>
          <target state="translated">&lt;a href=&quot;https://www.google.com/search?q=%E7%B8%97%27%20OR&amp;amp;oq=%E7%B8%97%27%20OR&amp;amp;aqs=chrome..69i57&amp;amp;sourceid=chrome&amp;amp;es_sm=122&amp;amp;ie=UTF-8&quot;&gt;정확히&lt;/a&gt; 공격이 요구하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a67ed2b7ff7dba4ff8e1a412ae8d28fc8cd1aaa" translate="yes" xml:space="preserve">
          <source>Wrapping Up</source>
          <target state="translated">마무리</target>
        </trans-unit>
        <trans-unit id="f5f39e69fe287172343d624554cae09348c5c8eb" translate="yes" xml:space="preserve">
          <source>You're 100% safe.</source>
          <target state="translated">당신은 100 % 안전합니다.</target>
        </trans-unit>
        <trans-unit id="217320583edc38a0014a1114edbfde1025f77f58" translate="yes" xml:space="preserve">
          <source>an explicitly set SQL mode that does not include &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; 를 포함하지 않는 명시 적으로 설정된 SQL 모드</target>
        </trans-unit>
        <trans-unit id="30de47e3fc63619fc4bb52553661d24fc277a5e9" translate="yes" xml:space="preserve">
          <source>do not work.</source>
          <target state="translated">작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bb92a3071ca477f4a9ff10448279a15beeb7fc0" translate="yes" xml:space="preserve">
          <source>in &lt;em&gt;addition&lt;/em&gt; to employing one of the solutions in ircmaxell's summary, use at least one of:</source>
          <target state="translated">ircmaxell의 요약에서 솔루션 중 하나를 사용하는 것 &lt;em&gt;외에도 다음&lt;/em&gt; 중 하나 이상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c043e9c677741168021919c728f09616e78da5a8" translate="yes" xml:space="preserve">
          <source>single-quoted string literals; or</source>
          <target state="translated">작은 따옴표로 묶인 문자열 리터럴; 또는</target>
        </trans-unit>
        <trans-unit id="47389f249f78a198fbfe6286d101664c76a37021" translate="yes" xml:space="preserve">
          <source>use MySQL v5.7.6 or later</source>
          <target state="translated">MySQL v5.7.6 이상 사용</target>
        </trans-unit>
        <trans-unit id="693e82b31d5c236212865ca0f15c27928ec99fd3" translate="yes" xml:space="preserve">
          <source>use native prepared statements</source>
          <target state="translated">기본 준비된 진술을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="2cf9beb50c22da78348a0f66f5b58ee7b6e3b96e" translate="yes" xml:space="preserve">
          <source>your SQL string literals are quoted using double-quote &lt;code&gt;&quot;&lt;/code&gt; characters.</source>
          <target state="translated">SQL 문자열 리터럴은 큰 따옴표 &lt;code&gt;&quot;&lt;/code&gt; 문자를 사용하여 인용됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
