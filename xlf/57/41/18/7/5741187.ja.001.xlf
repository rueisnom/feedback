<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/5741187">
    <body>
      <group id="5741187">
        <trans-unit id="1f2c2f49ed53d271ef6cdcf6885e1ffa495ab73c" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;Note</source>
          <target state="translated">&amp;nbsp;Note</target>
        </trans-unit>
        <trans-unit id="0137511bc1081a6efb0613748b98bd9d5f5c275a" translate="yes" xml:space="preserve">
          <source>...because MySQLi prepared statements are safe.</source>
          <target state="translated">...MySQLiの用意されたステートメントは安全だからです。</target>
        </trans-unit>
        <trans-unit id="1b1f4e147f6e802158503b43d1ca60cd81f26fbd" translate="yes" xml:space="preserve">
          <source>...because PDO prepared statements are immune from this vulnerability (and ircmaxell's too, provided either that you're using PHP&amp;ge;5.3.6 and the character set has been correctly set in the DSN; or that prepared statement emulation has been disabled).</source>
          <target state="translated">... PDOの準備済みステートメントはこの脆弱性の影響を受けないため（そしてPHP&amp;ge;5.3.6を使用していて、DSNで文字セットが正しく設定されているか、準備済みステートメントのエミュレーションが無効になっている場合は、ircmaxellも同様です） 。</target>
        </trans-unit>
        <trans-unit id="6ac78ecd1f7c67c942cb53726daa7a0efbc22871" translate="yes" xml:space="preserve">
          <source>...because PDO's &lt;code&gt;quote()&lt;/code&gt; function not only escapes the literal, but also quotes it (in single-quote &lt;code&gt;'&lt;/code&gt; characters); note that to avoid ircmaxell's bug in this case, you &lt;em&gt;must&lt;/em&gt; be using PHP&amp;ge;5.3.6 &lt;em&gt;and&lt;/em&gt; have correctly set the character set in the DSN.</source>
          <target state="translated">... PDOの &lt;code&gt;quote()&lt;/code&gt; 関数はリテラルをエスケープするだけでなく、それを（一重引用符 &lt;code&gt;'&lt;/code&gt; 文字で）引用符で囲むためです。 この場合のircmaxellのバグを回避するには、PHP&amp;ge;5.3.6を使用していて、DSNで文字セットを正しく設定している&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="35754c4370182141eab5ee14a96666c610708eea" translate="yes" xml:space="preserve">
          <source>...because we're quoting our string literal with single-quotes.</source>
          <target state="translated">...文字列リテラルをシングルクォートで引用しているからです。</target>
        </trans-unit>
        <trans-unit id="3c9a307826c8b7b69feae594532b8aa3104762de" translate="yes" xml:space="preserve">
          <source>...because we've explicitly selected an SQL mode that doesn't include &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;.</source>
          <target state="translated">... &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; を含まないSQLモードを明示的に選択したためです 。</target>
        </trans-unit>
        <trans-unit id="715bf0ad0483cee36e2352e88d118cd45e4a12fd" translate="yes" xml:space="preserve">
          <source>...then you &lt;em&gt;should&lt;/em&gt; be completely safe (vulnerabilities outside the scope of string escaping aside).</source>
          <target state="translated">...完全に安全である&lt;em&gt;必要&lt;/em&gt;があります（文字列がエスケープされる範囲外の脆弱性）。</target>
        </trans-unit>
        <trans-unit id="1652c3eb8f0740d7a95a22464a97e4d1d57d3195" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.php.net/manual/en/function.mysql-set-charset.php&quot;&gt;&lt;code&gt;mysql_set_charset()&lt;/code&gt;&lt;/a&gt; cannot help, as this has nothing to do with character sets; nor can &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;&lt;code&gt;mysqli::real_escape_string()&lt;/code&gt;&lt;/a&gt;, since that's just a different wrapper around this same function.</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/function.mysql-set-charset.php&quot;&gt; &lt;code&gt;mysql_set_charset()&lt;/code&gt; &lt;/a&gt;は、文字セットとは何の関係もないため、役に立ちません。 &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt; &lt;code&gt;mysqli::real_escape_string()&lt;/code&gt; &lt;/a&gt;もできません。これは、同じ関数のラッパーが異なるだけだからです。</target>
        </trans-unit>
        <trans-unit id="40b79d311fd549f7a602061aab4c7e939b44bb05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; will &lt;strong&gt;provide no protection whatsoever&lt;/strong&gt; (and could furthermore munge your data) if:</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; は&lt;strong&gt;、次の場合には何の保護も提供しません&lt;/strong&gt; （さらにデータを変更する可能性があります）。</target>
        </trans-unit>
        <trans-unit id="704e1ed694481558f32fc9a1901b8ba42b49d1dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; will not protect you against this.
&lt;strong&gt;The fact that you use single quotes (&lt;code&gt;' '&lt;/code&gt;) around your variables inside your query is what protects you against this.&lt;/strong&gt; The following is also an option:</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; はこれからあなたを保護しません。 &lt;strong&gt;クエリ内の変数を単一引用符（ &lt;code&gt;' '&lt;/code&gt; ）で囲むという事実は、これを防ぐためのものです。&lt;/strong&gt; 以下もオプションです。</target>
        </trans-unit>
        <trans-unit id="2a3d913309b6e70d8a4eaffa142ac0f8fa0b10d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Incompatible Change:&lt;/em&gt;&lt;/strong&gt; A new C API function, &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;&lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt;&lt;/a&gt;, has been implemented as a replacement for &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/a&gt; because the latter function can fail to properly encode characters when the &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; SQL mode is enabled. In this case, &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/a&gt; cannot escape quote characters except by doubling them, and to do this properly, it must know more information about the quoting context than is available. &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;&lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt;&lt;/a&gt; takes an extra argument for specifying the quoting context. For usage details, see &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;mysql_real_escape_string_quote()&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;互換性のない変更：&lt;/em&gt;&lt;/strong&gt;新しいC API関数である&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt; &lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt; &lt;/a&gt;は、 mysql_real_escape_string（）の代わりとして実装されました。後者の関数は、 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; &lt;/a&gt; SQLモードが有効な場合に文字を正しくエンコードできないためです。 この場合、 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt; &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; &lt;/a&gt;は引用符文字を2倍にすることを除いてエスケープできません。これを適切に行うには、引用コンテキストに関する利用可能な情報より多くの情報を知っている必要があります。 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt; &lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt; &lt;/a&gt;は、引用コンテキストを指定するための追加の引数を取ります。 使用法の詳細については、 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;mysql_real_escape_string_quote（）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f8e01739d5b6815e58b82ad6033855dbc821cb51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1417fe321e66a2f2b24276e42fbf203a5473bd74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selecting a Character Set&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;文字セットの選択&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ac289cd5eeccb9543f356cfaa7dd434e4716155" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selecting an SQL Mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SQLモードの選択&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1de1e668bd6f39316609cb114d142b1d2a27d5e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Payload&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ペイロード&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2d3170421e2d93af1294eb6a67b1040b5fa48891" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Query&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;クエリ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="326f3c54f3b107c6ae380d9464c1fb003c7f9d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_real_escape_string()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mysql_real_escape_string()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73322f37c52dd54895c5ee09cec4154d749ff948" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo; inside a string quoted with &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo; may be written as &amp;ldquo;&lt;code&gt;&quot;&quot;&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;&quot;&lt;/code&gt; 」で囲まれた文字列内の &lt;code&gt;&quot;&lt;/code&gt; 」は、「 」と書くことができます。</target>
        </trans-unit>
        <trans-unit id="866f8889f57f2afeeb461f2dc9e8e2edf5ccb4f7" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;code&gt;'&lt;/code&gt;&amp;rdquo; inside a string quoted with &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo; needs no special treatment and need not be doubled or escaped. In the same way, &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo; inside a string quoted with &amp;ldquo;&lt;code&gt;'&lt;/code&gt;&amp;rdquo; needs no special treatment.</source>
          <target state="translated">「 &lt;code&gt;'&lt;/code&gt; 引用された文字列内の &lt;code&gt;&quot;&lt;/code&gt; 」は特別な処理を必要とせず、二重化またはエスケープする必要もありません。同様に、「 &lt;code&gt;&quot;&lt;/code&gt; 引用された文字列内 &lt;code&gt;'&lt;/code&gt; 「」は特別な処理を必要としません。</target>
        </trans-unit>
        <trans-unit id="bc1a943df8c2823554d30c748a3335dc2a943b47" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;code&gt;'&lt;/code&gt;&amp;rdquo; inside a string quoted with &amp;ldquo;&lt;code&gt;'&lt;/code&gt;&amp;rdquo; may be written as &amp;ldquo;&lt;code&gt;''&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">「 &lt;code&gt;'&lt;/code&gt; 」で囲まれた文字列内の「 &lt;code&gt;'&lt;/code&gt; 」は、「 」と記述できます。</target>
        </trans-unit>
        <trans-unit id="a5ed5417d8347bd101a3334daed119b0bde1f39d" translate="yes" xml:space="preserve">
          <source>Also, the &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sql-mode-setting&quot;&gt;SQL mode of a new connection&lt;/a&gt; is set by the server according to its configuration (which a &lt;code&gt;SUPER&lt;/code&gt; user can change at any time); thus, to be certain of the server's behaviour, you must &lt;em&gt;always&lt;/em&gt; explicitly specify your desired mode after connecting.</source>
          <target state="translated">また、 &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sql-mode-setting&quot;&gt;新しい接続のSQLモードは、&lt;/a&gt;その構成に従ってサーバーによって設定されます（ &lt;code&gt;SUPER&lt;/code&gt; ユーザーはいつでも変更できます）。 したがって、サーバーの動作を確認するには、接続後に&lt;em&gt;常に&lt;/em&gt;希望するモードを明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="684a9120a373e354d932d00139cf2545e5e3998c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can enable the &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; SQL mode, which (amongst other things) alters the operation of &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;.  With this mode enabled, &lt;code&gt;0x27&lt;/code&gt; will be replaced with &lt;code&gt;0x2727&lt;/code&gt; rather than &lt;code&gt;0x5c27&lt;/code&gt; and thus the escaping process &lt;em&gt;cannot&lt;/em&gt; create valid characters in any of the vulnerable encodings where they did not exist previously (i.e. &lt;code&gt;0xbf27&lt;/code&gt; is still &lt;code&gt;0xbf27&lt;/code&gt; etc.)&amp;mdash;so the server will still reject the string as invalid.  However, see &lt;a href=&quot;https://stackoverflow.com/a/23277864/623041&quot;&gt;@eggyal's answer&lt;/a&gt; for a different vulnerability that can arise from using this SQL mode.</source>
          <target state="translated">別の方法として、 &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; &lt;/a&gt; SQLモードを有効にして、（とりわけ） &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; の操作を変更することもできます。 このモードを有効にすると、 &lt;code&gt;0x27&lt;/code&gt; は &lt;code&gt;0x2727&lt;/code&gt; ではなく0x2727に置き換えられるため、エスケーププロセスでは、以前は存在しなかった脆弱なエンコーディング（ &lt;code&gt;0xbf27&lt;/code&gt; が &lt;code&gt;0xbf27&lt;/code&gt; のままなど）で有効な文字を作成&lt;em&gt;できない&lt;/em&gt;ため、サーバーは引き続き文字列を無効として拒否します。 ただし、このSQLモードの使用により発生する可能性のある別の脆弱性については、 &lt;a href=&quot;https://stackoverflow.com/a/23277864/623041&quot;&gt;@ eggyalの回答&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0125850d3c197e91fbcdcb6a03bc380d4cbce4d0" translate="yes" xml:space="preserve">
          <source>Applications should be modified to use &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt;&lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt;&lt;/a&gt;, instead of &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/a&gt;, which now fails and produces an &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/error-messages-client.html#error_cr_insecure_api_err&quot;&gt;&lt;code&gt;CR_INSECURE_API_ERR&lt;/code&gt;&lt;/a&gt; error if &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot;&gt; &lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt; &lt;/a&gt;代わりに&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot;&gt; &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; &lt;/a&gt;を使用するようにアプリケーションを変更する必要があります。 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; &lt;/a&gt;は、 NO_BACKSLASH_ESCAPESが有効になっている場合に失敗し、 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/error-messages-client.html#error_cr_insecure_api_err&quot;&gt; &lt;code&gt;CR_INSECURE_API_ERR&lt;/code&gt; &lt;/a&gt;エラーを生成します。</target>
        </trans-unit>
        <trans-unit id="88e7dae832f3deb235d5883959ac5722693a0716" translate="yes" xml:space="preserve">
          <source>As documented under &lt;a href=&quot;http://dev.mysql.com/doc/en/string-literals.html&quot;&gt;String Literals&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://dev.mysql.com/doc/en/string-literals.html&quot;&gt;文字列リテラルに&lt;/a&gt;記載されているように：</target>
        </trans-unit>
        <trans-unit id="e89e6c65011e8a4d7c5bfa8b0caf77e515bc1d13" translate="yes" xml:space="preserve">
          <source>As my learned friend put it: congratulations, you just successfully attacked a program using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;...</source>
          <target state="translated">私の学んだ友人が言ったように：おめでとうございます、あなたは &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; を使用してプログラムを攻撃することに成功しました...</target>
        </trans-unit>
        <trans-unit id="860271aa1a26075ad9948f5113f8863be3598b03" translate="yes" xml:space="preserve">
          <source>As of MySQL v5.7.6, this bug has been fixed.  See &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-6.html&quot;&gt;change log&lt;/a&gt;:</source>
          <target state="translated">MySQL v5.7.6以降、このバグは修正されました。 &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-6.html&quot;&gt;変更ログを&lt;/a&gt;見る：</target>
        </trans-unit>
        <trans-unit id="f518e314fb42235c4f3d6cbb119a3ec1d5e226f3" translate="yes" xml:space="preserve">
          <source>As we said at the outset, for this attack to work the database connection must be encoded using a vulnerable character set.  &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8mb4.html&quot;&gt;&lt;code&gt;utf8mb4&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not vulnerable&lt;/em&gt; and yet can support &lt;em&gt;every&lt;/em&gt; Unicode character: so you could elect to use that instead&amp;mdash;but it has only been available since MySQL 5.5.3.  An alternative is &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8.html&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt;, which is also &lt;em&gt;not vulnerable&lt;/em&gt; and can support the whole of the Unicode &lt;a href=&quot;http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane&quot;&gt;Basic Multilingual Plane&lt;/a&gt;.</source>
          <target state="translated">最初に述べたように、この攻撃が機能するには、脆弱な文字セットを使用してデータベース接続をエンコードする必要があります。 &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8mb4.html&quot;&gt; &lt;code&gt;utf8mb4&lt;/code&gt; &lt;/a&gt;は&lt;em&gt;脆弱&lt;/em&gt;では&lt;em&gt;なく&lt;/em&gt; 、 &lt;em&gt;すべての&lt;/em&gt; Unicode文字をサポートできます。そのため、代わりにそれを使用することを選択できますが、MySQL 5.5.3以降でのみ使用可能です。 もう1つの方法は&lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8.html&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; です&lt;/a&gt; 。これも&lt;em&gt;脆弱&lt;/em&gt;では&lt;em&gt;なく&lt;/em&gt; 、Unicode &lt;a href=&quot;http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane&quot;&gt;Basic Multilingual Plane&lt;/a&gt;全体をサポートできます。</target>
        </trans-unit>
        <trans-unit id="51c588b6a3c0b164ad3d10434a89c0efb53c9e05" translate="yes" xml:space="preserve">
          <source>Because MySQLi does true prepared statements all the time.</source>
          <target state="translated">なぜなら、MySQLiは常に真の準備されたステートメントを実行するからです。</target>
        </trans-unit>
        <trans-unit id="ab3ccc3774a15cad2838d17bc59cee25b4efaa02" translate="yes" xml:space="preserve">
          <source>Because the server's expecting &lt;code&gt;utf8&lt;/code&gt;...</source>
          <target state="translated">サーバーが期待している &lt;code&gt;utf8&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="9aa08df54ae5ee77bc5745d59edc07d0e6d4425b" translate="yes" xml:space="preserve">
          <source>Because we've properly set the character set so the client and the server match.</source>
          <target state="translated">クライアントとサーバーが一致するようにきちんと文字セットを設定しているからです。</target>
        </trans-unit>
        <trans-unit id="e6e40fafb086150124f1ba46290255cea1c1778d" translate="yes" xml:space="preserve">
          <source>Because we've set the character set properly.</source>
          <target state="translated">キャラ設定をきちんとしているからです。</target>
        </trans-unit>
        <trans-unit id="5ae657eb67501e49fa6473576ab76846e01342a4" translate="yes" xml:space="preserve">
          <source>Because we've turned off emulated prepared statements.</source>
          <target state="translated">エミュレートされた準備書面をオフにしたからです。</target>
        </trans-unit>
        <trans-unit id="0eb8065189a48cf2287262d0ed3cfc832ded631c" translate="yes" xml:space="preserve">
          <source>But the worst part is that &lt;code&gt;PDO&lt;/code&gt; didn't expose the C API for &lt;code&gt;mysql_set_charset()&lt;/code&gt; until 5.3.6, so in prior versions it &lt;strong&gt;cannot&lt;/strong&gt; prevent this attack for every possible command!
 It's now exposed as a &lt;a href=&quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;DSN parameter&lt;/a&gt;.</source>
          <target state="translated">しかし、最悪の部分は、 &lt;code&gt;PDO&lt;/code&gt; が5.3.6まで &lt;code&gt;mysql_set_charset()&lt;/code&gt; の C APIを公開しなかったため、以前のバージョンで&lt;strong&gt;は&lt;/strong&gt; 、可能性のあるすべてのコマンドに対してこの攻撃を防ぐこと&lt;strong&gt;はできません&lt;/strong&gt; 。 現在は&lt;a href=&quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;DSNパラメータ&lt;/a&gt;として公開されています 。</target>
        </trans-unit>
        <trans-unit id="f025296c14b5fc464e225ba32792e8b977855f7b" translate="yes" xml:space="preserve">
          <source>Classic injections like this:</source>
          <target state="translated">このような古典的な注射。</target>
        </trans-unit>
        <trans-unit id="64a02599a21321950d895b4a71792c50295ebd34" translate="yes" xml:space="preserve">
          <source>Congratulations, you just successfully attacked a program using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;...</source>
          <target state="translated">おめでとうございます &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; を使用してプログラムを正常に攻撃しました...</target>
        </trans-unit>
        <trans-unit id="1e6f64ab75678829dd084a6595e2b0ae29ecddec" translate="yes" xml:space="preserve">
          <source>Consider the following query:</source>
          <target state="translated">次のクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="86b6f0784f01b0f24e5cd431494b3c0712fbc9e4" translate="yes" xml:space="preserve">
          <source>Consider this sample situation. SQL is constructed in PHP like this:</source>
          <target state="translated">このサンプルの状況を考えてみましょう。SQLはPHPでこのように構築されています。</target>
        </trans-unit>
        <trans-unit id="57b1a7674ba21811ac4ac6555e0308ab61bf2a2f" translate="yes" xml:space="preserve">
          <source>Do you know of any possible injection that would get through the PHP code above?</source>
          <target state="translated">上記のPHPコードを通過する可能性のあるインジェクションを知っていますか?</target>
        </trans-unit>
        <trans-unit id="803967a50e0348bca88eff4b61af251e5d520585" translate="yes" xml:space="preserve">
          <source>Don't use a vulnerable character set for connection encoding (you only use &lt;code&gt;utf8&lt;/code&gt; / &lt;code&gt;latin1&lt;/code&gt; / &lt;code&gt;ascii&lt;/code&gt; / etc)</source>
          <target state="translated">接続エンコーディングに脆弱な文字セットを使用しないでください（使用するのは &lt;code&gt;utf8&lt;/code&gt; / &lt;code&gt;latin1&lt;/code&gt; / &lt;code&gt;ascii&lt;/code&gt; /などのみ）</target>
        </trans-unit>
        <trans-unit id="2318c4b0b2488cce207802b573caaf58285428bb" translate="yes" xml:space="preserve">
          <source>For Very OBSCURE EDGE CASES!!!</source>
          <target state="translated">超難解なエッジケースに!</target>
        </trans-unit>
        <trans-unit id="d015ba7528fb1eb280c5a43556bdaab371f6ef49" translate="yes" xml:space="preserve">
          <source>For this attack to work, we need the encoding that the server's expecting on the connection both to encode &lt;code&gt;'&lt;/code&gt; as in ASCII i.e. &lt;code&gt;0x27&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; to have some character whose final byte is an ASCII &lt;code&gt;\&lt;/code&gt; i.e. &lt;code&gt;0x5c&lt;/code&gt;.  As it turns out, there are 5 such encodings supported in MySQL 5.6 by default: &lt;code&gt;big5&lt;/code&gt;, &lt;code&gt;cp932&lt;/code&gt;, &lt;code&gt;gb2312&lt;/code&gt;, &lt;code&gt;gbk&lt;/code&gt; and &lt;code&gt;sjis&lt;/code&gt;.  We'll select &lt;code&gt;gbk&lt;/code&gt; here.</source>
          <target state="translated">この攻撃が機能するためには、サーバーが接続で期待するエンコードが、ASCII、つまり &lt;code&gt;0x27&lt;/code&gt; &lt;code&gt;'&lt;/code&gt; ようにエンコードされ、最後のバイトがASCII &lt;code&gt;\&lt;/code&gt; ie &lt;code&gt;0x5c&lt;/code&gt; である文字が必要です。 &lt;code&gt;big5&lt;/code&gt; 、MySQL 5.6ではデフォルトで5つのエンコーディングがサポートされています： big5 、 &lt;code&gt;cp932&lt;/code&gt; 、 &lt;code&gt;gb2312&lt;/code&gt; 、 &lt;code&gt;gbk&lt;/code&gt; および &lt;code&gt;sjis&lt;/code&gt; 。 ここでは &lt;code&gt;gbk&lt;/code&gt; を選択します。</target>
        </trans-unit>
        <trans-unit id="aa1fdb589fc94178b8e4146e0b68fb9f46b62bc9" translate="yes" xml:space="preserve">
          <source>For this reason, I recommend that anyone using &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; also enables &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_ansi_quotes&quot;&gt;&lt;code&gt;ANSI_QUOTES&lt;/code&gt;&lt;/a&gt; mode, as it will force habitual use of single-quoted string literals.  Note that this does not prevent SQL injection in the event that double-quoted literals happen to be used&amp;mdash;it merely reduces the likelihood of that happening (because normal, non-malicious queries would fail).</source>
          <target state="translated">このため、 &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; を使用する場合は、 &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_ansi_quotes&quot;&gt; &lt;code&gt;ANSI_QUOTES&lt;/code&gt; &lt;/a&gt;モードも有効にすることをお勧めします。これにより、単一引用符で囲まれた文字列リテラルが常用されるようになります。 これは、二重引用符で囲まれたリテラルが使用された場合のSQLインジェクションを防止しないことに注意してください。これは、その可能性を減らすだけです（通常の悪意のないクエリが失敗するため）。</target>
        </trans-unit>
        <trans-unit id="9b63e3ab0f3f3c328e5af9e1da909b50f98ce45d" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; does check the SQL mode and adjust its behaviour accordingly.  See &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/libmysql/libmysql.c#L1267&quot;&gt;&lt;code&gt;libmysql.c&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">幸い、 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; はSQLモードをチェックし、それに応じて動作を調整します。 &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/libmysql/libmysql.c#L1267&quot;&gt; &lt;code&gt;libmysql.c&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b2d00fd64fccabbd0f52bf8ac63661bfa39008be" translate="yes" xml:space="preserve">
          <source>Functionality Added or Changed</source>
          <target state="translated">追加・変更された機能</target>
        </trans-unit>
        <trans-unit id="8cad1370c5af86b04374fcbfdbe5fc2dcb0f2116" translate="yes" xml:space="preserve">
          <source>However, this function arbitrarily &lt;em&gt;assumes&lt;/em&gt; that the string will be quoted using the single-quote &lt;code&gt;'&lt;/code&gt; character.  See &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/mysys/charset.c#L836&quot;&gt;&lt;code&gt;charset.c&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ただし、この関数&lt;em&gt;は&lt;/em&gt; 、文字列が一重引用符 &lt;code&gt;'&lt;/code&gt; を使用して引用されることを任意に&lt;em&gt;想定し&lt;/em&gt;ています。 &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/mysys/charset.c#L836&quot;&gt; &lt;code&gt;charset.c&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="36e26f357c029b64a1fb331af707285d8e5bd0dd" translate="yes" xml:space="preserve">
          <source>I have heard numerous people say to me that code like that is still dangerous and possible to hack even with &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; function used. But I cannot think of any possible exploit?</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 関数を使用しても、そのようなコードは依然として危険であり、ハッキングする可能性があると多くの人々が私に言うのを聞いたことがあります。 しかし、私は悪用の可能性を考えることができませんか？</target>
        </trans-unit>
        <trans-unit id="0b1b883f0b54b49d027a8f5fb5694058665c68be" translate="yes" xml:space="preserve">
          <source>I said at the very beginning that we could have prevented all of this if we had used &lt;code&gt;mysql_set_charset('gbk')&lt;/code&gt; instead of &lt;code&gt;SET NAMES gbk&lt;/code&gt;. And that's true provided you are using a MySQL release since 2006.</source>
          <target state="translated">最初に、 &lt;code&gt;SET NAMES gbk&lt;/code&gt; の代わりに &lt;code&gt;mysql_set_charset('gbk')&lt;/code&gt; を使用していれば、これらすべてを防ぐことができると述べました。 そして、それはあなたが2006年以降のMySQLリリースを使用している限り当てはまります。</target>
        </trans-unit>
        <trans-unit id="81f0dc176701bfda65f13b7c9a46ab6048a4e039" translate="yes" xml:space="preserve">
          <source>If the server's SQL mode includes &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt;, then the third of these options&amp;mdash;which is the usual approach adopted by &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&amp;mdash;is not available: one of the first two options must be used instead.  Note that the effect of the fourth bullet is that one must necessarily know the character that will be used to quote the literal in order to avoid munging one's data.</source>
          <target state="translated">サーバーのSQLモードに&lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; が&lt;/a&gt;含まれている場合、これらのオプションの3番目 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 採用されている通常のアプローチ）は使用できません。最初の2つのオプションのいずれかを代わりに使用する必要があります。 4番目の箇条書きの効果は、データの変更を回避するために、リテラルの引用に使用される文字を必ず知っている必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="86ab0b4c0397c452e673ed3642be48e6fdfe8342" translate="yes" xml:space="preserve">
          <source>If you're using an earlier MySQL release, then a &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot;&gt;bug&lt;/a&gt; in &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; meant that invalid multibyte characters such as those in our payload were treated as single bytes for escaping purposes &lt;em&gt;even if the client had been correctly informed of the connection encoding&lt;/em&gt; and so this attack would still succeed.  The bug was fixed in MySQL &lt;a href=&quot;http://dev.mysql.com/doc/refman/4.1/en/news-4-1-20.html&quot;&gt;4.1.20&lt;/a&gt;, &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html&quot;&gt;5.0.22&lt;/a&gt; and &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html&quot;&gt;5.1.11&lt;/a&gt;.</source>
          <target state="translated">以前のMySQLリリースを使用している場合、 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; の &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot;&gt;バグ&lt;/a&gt;により、ペイロードにあるような無効なマルチバイト文字&lt;em&gt;は、クライアントが接続エンコーディング&lt;/em&gt;などを&lt;em&gt;正しく通知されていた&lt;/em&gt;として&lt;em&gt;も&lt;/em&gt; 、エスケープの目的&lt;em&gt;で&lt;/em&gt; 1バイトとして扱われました。この攻撃は依然として成功します。 このバグはMySQL &lt;a href=&quot;http://dev.mysql.com/doc/refman/4.1/en/news-4-1-20.html&quot;&gt;4.1.20、5.0.22、5.1.11&lt;/a&gt;で修正されました。</target>
        </trans-unit>
        <trans-unit id="235aa4b0c2bc1b8d4771ded0fab393b955216156" translate="yes" xml:space="preserve">
          <source>If you:</source>
          <target state="translated">もしあなたが</target>
        </trans-unit>
        <trans-unit id="78e7eaa8d236315c8fb69481369755a898a61600" translate="yes" xml:space="preserve">
          <source>In PDO, both its equivalent function &lt;a href=&quot;http://www.php.net/manual/en/pdo.quote.php&quot;&gt;&lt;code&gt;PDO::quote()&lt;/code&gt;&lt;/a&gt; and its prepared statement emulator call upon &lt;a href=&quot;https://github.com/php/php-src/blob/af6c11c5f060870d052a2b765dc634d9e47d0f18/ext/pdo_mysql/mysql_driver.c#L302&quot;&gt;&lt;code&gt;mysql_handle_quoter()&lt;/code&gt;&lt;/a&gt;&amp;mdash;which does exactly this: it ensures that the escaped literal is quoted in single-quotes, so you can be certain that PDO is always immune from this bug.</source>
          <target state="translated">PDOでは、同等の関数&lt;a href=&quot;http://www.php.net/manual/en/pdo.quote.php&quot;&gt; &lt;code&gt;PDO::quote()&lt;/code&gt; &lt;/a&gt;と準備されたステートメントエミュレーターの&lt;a href=&quot;https://github.com/php/php-src/blob/af6c11c5f060870d052a2b765dc634d9e47d0f18/ext/pdo_mysql/mysql_driver.c#L302&quot;&gt; &lt;code&gt;mysql_handle_quoter()&lt;/code&gt; &lt;/a&gt;呼び出します&amp;mdash;これはまさにこれを実行します。これにより、エスケープされたリテラルが単一引用符で囲まれることが保証されるため、PDOが確実に常にこのバグの影響を受けません。</target>
        </trans-unit>
        <trans-unit id="9d385aaa3b30c1b6d51bc5a5eecd64a89068cd9c" translate="yes" xml:space="preserve">
          <source>In certain circumstances, that will return more than 1 row. Let's dissect what's going on here:</source>
          <target state="translated">特定の状況では、それは1行以上の行を返します。ここで何が起こっているのか解剖してみましょう。</target>
        </trans-unit>
        <trans-unit id="fca7d62fc26dfbdd5bd711892d63ed4d75cd8722" translate="yes" xml:space="preserve">
          <source>In homage to &lt;a href=&quot;https://stackoverflow.com/a/12118602&quot;&gt;@ircmaxell's excellent answer&lt;/a&gt; (really, this is supposed to be flattery and not plagiarism!), I will adopt his format:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/12118602&quot;&gt;@ircmaxellの優れた答えに&lt;/a&gt;敬意を表して（実際には、これはお世辞であり、盗作ではないことになっています！）、私は彼の形式を採用します。</target>
        </trans-unit>
        <trans-unit id="cd215dc2b2ecbacd3fd36421b3a2fba7cb5bfacc" translate="yes" xml:space="preserve">
          <source>Is there an SQL injection possibility even when using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; function?</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 関数を使用している場合でも、SQLインジェクションの可能性はありますか？</target>
        </trans-unit>
        <trans-unit id="a01adb93bc3b6fc2e61af0b19dd2925d0e9c9ad7" translate="yes" xml:space="preserve">
          <source>It gets worse.  &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; may not be all that uncommon in the wild owing to the necessity of its use for compatibility with standard SQL (e.g. see section 5.3 of the &lt;a href=&quot;http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt&quot;&gt;SQL-92 specification&lt;/a&gt;, namely the &lt;code&gt;&amp;lt;quote symbol&amp;gt; ::= &amp;lt;quote&amp;gt;&amp;lt;quote&amp;gt;&lt;/code&gt; grammar production and lack of any special meaning given to backslash).  Furthermore, its use was explicitly &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html&quot;&gt;recommended as a workaround&lt;/a&gt; to the (long since fixed) &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot;&gt;bug&lt;/a&gt; that ircmaxell's post describes.  Who knows, some DBAs might even configure it to be on by default as means of discouraging use of incorrect escaping methods like &lt;a href=&quot;http://www.php.net/manual/en/function.addslashes.php&quot;&gt;&lt;code&gt;addslashes()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">悪化する。 &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; は、標準SQLとの互換性のために使用する必要があるため、 実際にはそれほど一般的ではない可能性があります（たとえば、 &lt;a href=&quot;http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt&quot;&gt;SQL-92仕様の&lt;/a&gt;セクション5.3、つまり &lt;code&gt;&amp;lt;quote symbol&amp;gt; ::= &amp;lt;quote&amp;gt;&amp;lt;quote&amp;gt;&lt;/code&gt; 文法を参照してください）生成およびバックスラッシュに与えられた特別な意味の欠如）。 さらに、ircmaxellの投稿で説明されている（ &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot;&gt;修正され&lt;/a&gt;てからの長い） バグの &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html&quot;&gt;回避策として&lt;/a&gt; 、その使用が明示的に推奨されました 。 知っている人もいますが、一部のDBAは、 &lt;a href=&quot;http://www.php.net/manual/en/function.addslashes.php&quot;&gt; &lt;code&gt;addslashes()&lt;/code&gt; の&lt;/a&gt;ような誤ったエスケープメソッドの使用を阻止するために、デフォルトでオンになるように設定する場合さえあります。</target>
        </trans-unit>
        <trans-unit id="6fa30bd77891dfa8c42dc41c3dd05d912df41b95" translate="yes" xml:space="preserve">
          <source>It gets worse. &lt;code&gt;PDO&lt;/code&gt; defaults to &lt;em&gt;emulating&lt;/em&gt; prepared statements with MySQL. That means that on the client side, it basically does a sprintf through &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; (in the C library), which means the following will result in a successful injection:</source>
          <target state="translated">悪化する。 &lt;code&gt;PDO&lt;/code&gt; はデフォルトで、準備されたステートメントをMySQLで&lt;em&gt;エミュレート&lt;/em&gt;します。 つまり、クライアント側では、基本的に &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; （Cライブラリ内）を介してsprintfを実行します。つまり、次の結果、正常に注入されます。</target>
        </trans-unit>
        <trans-unit id="89cfd0b4b9c37c369d254688a7865cee4b004e34" translate="yes" xml:space="preserve">
          <source>MySQL's &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; SQL mode is enabled (which it &lt;em&gt;might&lt;/em&gt; be, unless you &lt;em&gt;explicitly&lt;/em&gt; select another SQL mode &lt;em&gt;every time you connect&lt;/em&gt;); and</source>
          <target state="translated">MySQLの&lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot;&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; &lt;/a&gt; SQLモードが有効になっている（ &lt;em&gt;接続するたびに&lt;/em&gt; &lt;em&gt;明示的に&lt;/em&gt;別のSQLモードを選択しない限り、有効になる&lt;em&gt;可能性&lt;/em&gt;がある）。 そして</target>
        </trans-unit>
        <trans-unit id="0d560a10506f0b7ef8adddb39825d6e51880d891" translate="yes" xml:space="preserve">
          <source>Now, it's very important to note the use of &lt;code&gt;SET NAMES&lt;/code&gt; here. This sets the character set &lt;strong&gt;ON THE SERVER&lt;/strong&gt;. If we used the call to the C API function &lt;code&gt;mysql_set_charset()&lt;/code&gt;, we'd be fine (on MySQL releases since 2006). But more on why in a minute...</source>
          <target state="translated">ここで、ここで &lt;code&gt;SET NAMES&lt;/code&gt; の使用に注意することが非常に重要です。 これにより、 &lt;strong&gt;サーバー上の&lt;/strong&gt;文字セットが設定され&lt;strong&gt;ます&lt;/strong&gt; 。 C API関数 &lt;code&gt;mysql_set_charset()&lt;/code&gt; の呼び出しを使用した場合、問題はありません（2006年以降のMySQLリリースでは）。 しかし、その理由についての詳細...</target>
        </trans-unit>
        <trans-unit id="ee2774f4a8600878360cd4aa4dec59819c4a2daf" translate="yes" xml:space="preserve">
          <source>Now, it's worth noting that you can prevent this by disabling emulated prepared statements:</source>
          <target state="translated">さて、エミュレートされた準備されたステートメントを無効にすることで、これを防ぐことができることは注目に値します。</target>
        </trans-unit>
        <trans-unit id="37e3a83b6f32baf1ce3b99fb4397cb5192c677fd" translate="yes" xml:space="preserve">
          <source>Otherwise, you're vulnerable &lt;strong&gt;even though you're using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/strong&gt;...</source>
          <target state="translated">そうしないと、 &lt;strong&gt; &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; を使用していても&lt;/strong&gt;脆弱に&lt;strong&gt;なります&lt;/strong&gt; ...</target>
        </trans-unit>
        <trans-unit id="8644422a5fd7bc5ab0faf2e95c0f80b5e0de76c0" translate="yes" xml:space="preserve">
          <source>PDO;</source>
          <target state="translated">PDO;</target>
        </trans-unit>
        <trans-unit id="12facaa5c4baa8dbe06d38af1db67cfb4618c3a7" translate="yes" xml:space="preserve">
          <source>Precede the quote character by an escape character (&amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo;).</source>
          <target state="translated">引用文字の前にエスケープ文字（「 &lt;code&gt;\&lt;/code&gt; 」）を付けます。</target>
        </trans-unit>
        <trans-unit id="b447cf795752cf7900ede4f8d3cb07528cd44316" translate="yes" xml:space="preserve">
          <source>References: See also Bug #19211994.</source>
          <target state="translated">参考にしてください。Bug #19211994 も参照してください。</target>
        </trans-unit>
        <trans-unit id="9464db2ea229e88ee8b162ca13c18fd0cd70c3b4" translate="yes" xml:space="preserve">
          <source>SQL injection that gets around mysql_real_escape_string()</source>
          <target state="translated">mysql_real_escape_string()を回避するSQLインジェクション</target>
        </trans-unit>
        <trans-unit id="4bd13a83b5e3cd19475748abea0450580b208585" translate="yes" xml:space="preserve">
          <source>Safe Examples</source>
          <target state="translated">安全な例</target>
        </trans-unit>
        <trans-unit id="f3a1435b2a5f8c71ecc9887e736a3b6565908745" translate="yes" xml:space="preserve">
          <source>So long as you always &lt;em&gt;explicitly&lt;/em&gt; set the SQL mode not to include &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;, or quote MySQL string literals using the single-quote character, this bug cannot rear its ugly head: respectively &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt; will not be used, or its assumption about which quote characters require repeating will be correct.</source>
          <target state="translated">SQLモードを常に&lt;em&gt;明示的に&lt;/em&gt;設定して、 &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; を含めないか、一重引用符文字を使用してMySQL文字列リテラルを引用する限り、このバグは醜い頭を &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt; することはできません：それぞれescape_quotes_for_mysql（）は使用されません。繰り返しが必要な文字は正しくなります。</target>
        </trans-unit>
        <trans-unit id="9c82cfcfd7c80f51a781706aa481de5181a2badb" translate="yes" xml:space="preserve">
          <source>So, it leaves double-quote &lt;code&gt;&quot;&lt;/code&gt; characters untouched (and doubles all single-quote &lt;code&gt;'&lt;/code&gt; characters) &lt;em&gt;irrespective of the actual character that is used to quote the literal&lt;/em&gt;!  In our case &lt;code&gt;$var&lt;/code&gt; remains exactly the same as the argument that was provided to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&amp;mdash;it's as though no escaping has taken place &lt;em&gt;at all&lt;/em&gt;.</source>
          <target state="translated">その&lt;em&gt;ため、リテラルの引用に使用される実際の文字に関係なく、&lt;/em&gt;二重引用符 &lt;code&gt;&quot;&lt;/code&gt; 文字は変更されません（そしてすべての単一引用符 &lt;code&gt;'&lt;/code&gt; 文字は2倍になります）！この場合、 &lt;code&gt;$var&lt;/code&gt; は &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; に提供された引数とまったく同じままです。 （） -エスケープが&lt;em&gt;まったく&lt;/em&gt;行わ&lt;em&gt;れ&lt;/em&gt;ていないかのようです。</target>
        </trans-unit>
        <trans-unit id="2bd3c2fbb16f38ebaca58d2e99147a45e4a33ffd" translate="yes" xml:space="preserve">
          <source>So, let's start off by showing the attack...</source>
          <target state="translated">ということで、まずは攻撃の様子を......。</target>
        </trans-unit>
        <trans-unit id="b94521d5250b6b4dcf2e2112579d8894701d0cb4" translate="yes" xml:space="preserve">
          <source>Something of a formality, the rendered query is:</source>
          <target state="translated">何かの形式的なもので、レンダリングされたクエリは</target>
        </trans-unit>
        <trans-unit id="7cbb325b5206a8f47d212b34898e5c8169949014" translate="yes" xml:space="preserve">
          <source>Starting off with a demonstration...</source>
          <target state="translated">デモンストレーションから始まり...</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="25068c6d83c499102f62408ff3863a0136e28d48" translate="yes" xml:space="preserve">
          <source>Taken together with the bug explained by ircmaxell, the following examples are entirely safe (assuming that one is either using MySQL later than 4.1.20, 5.0.22, 5.1.11; or that one is not using a GBK/Big5 connection encoding):</source>
          <target state="translated">ircmaxell が説明したバグと合わせて、以下の例は完全に安全です (MySQL を 4.1.20,5.0.22,5.1.11 以降で使用しているか、GBKBig5 接続エンコーディングを使用していないことを前提としています)。</target>
        </trans-unit>
        <trans-unit id="89bc52d9aa970eea662979097ac001b91d0a09c6" translate="yes" xml:space="preserve">
          <source>The Attack</source>
          <target state="translated">攻撃</target>
        </trans-unit>
        <trans-unit id="f6211e866c7239c64ef20925a961bec5d73d25aa" translate="yes" xml:space="preserve">
          <source>The Bad</source>
          <target state="translated">バッド</target>
        </trans-unit>
        <trans-unit id="e18ed415a8c62de74d72d0537889979e1e5ad61f" translate="yes" xml:space="preserve">
          <source>The C API call to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; differs from &lt;code&gt;addslashes()&lt;/code&gt; in that it knows the connection character set. So it can perform the escaping properly for the character set that the server is expecting. However, up to this point, the client thinks that we're still using &lt;code&gt;latin1&lt;/code&gt; for the connection, because we never told it otherwise. We did tell the &lt;em&gt;server&lt;/em&gt; we're using &lt;code&gt;gbk&lt;/code&gt;, but the &lt;em&gt;client&lt;/em&gt; still thinks it's &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; へのC API呼び出しは、接続文字セットを認識しているという点で、 addslashes（）とは異なります。 したがって、サーバーが予期している文字セットに対して適切にエスケープを実行できます。 ただし、この時点までは、クライアントは &lt;code&gt;latin1&lt;/code&gt; を接続に使用していると考えています。 &lt;em&gt;サーバー&lt;/em&gt;に &lt;code&gt;gbk&lt;/code&gt; を使用していることを伝えましたが、 &lt;em&gt;クライアントは&lt;/em&gt;まだそれを &lt;code&gt;latin1&lt;/code&gt; であると考えています 。</target>
        </trans-unit>
        <trans-unit id="f719c4c198c8aa78f8261fc01cd90d7f870228d1" translate="yes" xml:space="preserve">
          <source>The Saving Grace</source>
          <target state="translated">セービンググレース</target>
        </trans-unit>
        <trans-unit id="0adbabc52b10370afa8aa9ba0a194b758fcfc4a6" translate="yes" xml:space="preserve">
          <source>The Ugly</source>
          <target state="translated">醜い</target>
        </trans-unit>
        <trans-unit id="4ca7fcff8448ca54a794cc01a9233524ca077c37" translate="yes" xml:space="preserve">
          <source>The following examples are safe:</source>
          <target state="translated">以下の例は安全です。</target>
        </trans-unit>
        <trans-unit id="84cd8937e1e420f026695377c299a003071b2509" translate="yes" xml:space="preserve">
          <source>The long answer isn't so easy. It's based off an attack &lt;a href=&quot;http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string&quot;&gt;demonstrated here&lt;/a&gt;.</source>
          <target state="translated">長い答えはそれほど簡単ではありません。 これは、 &lt;a href=&quot;http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string&quot;&gt;ここで説明&lt;/a&gt;した攻撃に基づいています 。</target>
        </trans-unit>
        <trans-unit id="1165da1a5fb1e85299a86fab06d35f1c1da8af71" translate="yes" xml:space="preserve">
          <source>The payload initiates this injection quite literally with the &lt;code&gt;&quot;&lt;/code&gt; character.  No particular encoding.  No special characters.  No weird bytes.</source>
          <target state="translated">ペイロードは、文字どおり &lt;code&gt;&quot;&lt;/code&gt; 文字でこの注入を開始します。特定のエンコーディングはありません。特殊文字はありません。奇妙なバイトはありません。</target>
        </trans-unit>
        <trans-unit id="07aed08f014598f23f998bfbccd45201722e2fa4" translate="yes" xml:space="preserve">
          <source>The payload we're going to use for this injection starts with the byte sequence &lt;code&gt;0xbf27&lt;/code&gt;.  In &lt;code&gt;gbk&lt;/code&gt;, that's an invalid multibyte character; in &lt;code&gt;latin1&lt;/code&gt;, it's the string &lt;code&gt;&amp;iquest;'&lt;/code&gt;.  Note that in &lt;code&gt;latin1&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;code&gt;gbk&lt;/code&gt;, &lt;code&gt;0x27&lt;/code&gt; on its own is a literal &lt;code&gt;'&lt;/code&gt; character.</source>
          <target state="translated">この注入に使用するペイロードは、バイトシーケンス &lt;code&gt;0xbf27&lt;/code&gt; で始まります。 &lt;code&gt;gbk&lt;/code&gt; では、これは無効なマルチバイト文字です。 &lt;code&gt;latin1&lt;/code&gt; では、文字列 &lt;code&gt;&amp;iquest;'&lt;/code&gt; です。 &lt;code&gt;latin1&lt;/code&gt; &lt;strong&gt;と&lt;/strong&gt; &lt;code&gt;gbk&lt;/code&gt; では、 &lt;code&gt;0x27&lt;/code&gt; 自体がリテラル文字 &lt;code&gt;'&lt;/code&gt; であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="85bd2888b9839820671225f5734478627dd03249" translate="yes" xml:space="preserve">
          <source>The problem, if not already obvious, is that the call to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;strong&gt;cannot know&lt;/strong&gt; with which character the literal will be quoted, as that's left to the developer to decide at a later time.  So, in &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; mode, there is literally &lt;em&gt;no way&lt;/em&gt; that this function can safely escape every input for use with arbitrary quoting (at least, not without doubling characters that do not require doubling and thus munging your data).</source>
          <target state="translated">まだ明らかではない場合の問題は、 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; の呼び出しで、リテラルが引用される文字を&lt;strong&gt;認識できないことです。&lt;/strong&gt;これは、開発者が後で決定するためです。 したがって、 &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; モードでは、この関数がすべての入力を安全にエスケープして、任意の引用で使用する方法はありません（少なくとも、2倍にする必要のない文字を2倍にしてデータを変更しない限り）。</target>
        </trans-unit>
        <trans-unit id="42547b0db8d37e67c49237fd41e6482b1196a721" translate="yes" xml:space="preserve">
          <source>The short answer is &lt;strong&gt;yes, yes there is a way to get around &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">簡単に言えば&lt;strong&gt;、はい。はい、 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; を回避する方法があります&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b36b71f5cebbf3e5bb1fd67c6d133231f6b995c" translate="yes" xml:space="preserve">
          <source>There are several ways to include quote characters within a string:</source>
          <target state="translated">文字列内に引用文字を含める方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="4b8d7f358d85c417e09e78e8cac811d79bc9e09f" translate="yes" xml:space="preserve">
          <source>Therefore the call to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; inserts the backslash, and we have a free hanging &lt;code&gt;'&lt;/code&gt; character in our &quot;escaped&quot; content! In fact, if we were to look at &lt;code&gt;$var&lt;/code&gt; in the &lt;code&gt;gbk&lt;/code&gt; character set, we'd see:</source>
          <target state="translated">したがって、 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; を呼び出すとバック​​スラッシュが挿入され、「エスケープされた」コンテンツにフリーハンギング文字 &lt;code&gt;'&lt;/code&gt; が含まれます。 実際、 &lt;code&gt;gbk&lt;/code&gt; 文字セットの &lt;code&gt;$var&lt;/code&gt; を見ると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="de3f27253dad909a6292065ce32ea790bbf0a14b" translate="yes" xml:space="preserve">
          <source>This is another, (perhaps less?) obscure EDGE CASE!!!</source>
          <target state="translated">これは、もう一つの、(おそらくそれほどではないのでしょうが)無名のEDGE CASE!</target>
        </trans-unit>
        <trans-unit id="a6c89c13dcd4c5d68d0db7503c9622c5b9f6bea7" translate="yes" xml:space="preserve">
          <source>This part is just a formality, but here's the rendered query:</source>
          <target state="translated">この部分は形式的なものですが、これがレンダリングされたクエリです。</target>
        </trans-unit>
        <trans-unit id="6843dd3ca9404f6ea2c9c3ff1f6d3d8a330be1fa" translate="yes" xml:space="preserve">
          <source>This was filed as &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=72458&quot;&gt;bug #72458&lt;/a&gt; and has been fixed in MySQL v5.7.6 (see the section headed &quot;&lt;strong&gt;The Saving Grace&lt;/strong&gt;&quot;, below).</source>
          <target state="translated">これは&lt;a href=&quot;http://bugs.mysql.com/bug.php?id=72458&quot;&gt;バグ＃72458&lt;/a&gt;として提出され、MySQL v5.7.6で修正されました（以下の「 &lt;strong&gt;節約の猶予&lt;/strong&gt; 」という見出しのセクションを参照してください）。</target>
        </trans-unit>
        <trans-unit id="540c75deef36dee1b0a10012d512093062f3975e" translate="yes" xml:space="preserve">
          <source>This will &lt;em&gt;usually&lt;/em&gt; result in a true prepared statement (i.e. the data being sent over in a separate packet from the query). However, be aware that PDO will silently &lt;a href=&quot;https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210&quot;&gt;fallback&lt;/a&gt; to emulating statements that MySQL can't prepare natively: those that it can are &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-syntax-prepared-statements.html&quot;&gt;listed&lt;/a&gt; in the manual, but beware to select the appropriate server version).</source>
          <target state="translated">これは&lt;em&gt;通常&lt;/em&gt; 、真の準備済みステートメントになります（つまり、データはクエリとは別のパケットで送信されます）。 ただし、PDOはMySQLがネイティブで準備できないステートメントをエミュレートするように静かに&lt;a href=&quot;https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210&quot;&gt;フォールバック&lt;/a&gt;することに注意してください。それはマニュアルに&lt;a href=&quot;http://dev.mysql.com/doc/en/sql-syntax-prepared-statements.html&quot;&gt;リストさ&lt;/a&gt;れている可能性があるステートメントですが、適切なサーバーバージョンを選択するように注意してください）。</target>
        </trans-unit>
        <trans-unit id="90d6fd21f00e277e8719aa42844f6aeaa43c8a99" translate="yes" xml:space="preserve">
          <source>This will return all records from the &lt;code&gt;test&lt;/code&gt; table.  A dissection:</source>
          <target state="translated">これにより、 &lt;code&gt;test&lt;/code&gt; テーブルからすべてのレコードが返されます。 解剖：</target>
        </trans-unit>
        <trans-unit id="bdb8bf736b134dd49ab0915dcc3a725d69a44cc6" translate="yes" xml:space="preserve">
          <source>Thus a different underlying function, &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt;, is invoked if the &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; SQL mode is in use.  As mentioned above, such a function needs to know which character will be used to quote the literal in order to repeat it without causing the other quotation character from being repeated literally.</source>
          <target state="translated">したがって、 &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; SQLモードが使用されている場合は、別の基礎となる関数 &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt; が呼び出されます。 上記のように、そのような関数は、他の引用文字が文字どおり繰り返されないように、リテラルを引用するためにどの文字が使用されるかを知る必要があります。</target>
        </trans-unit>
        <trans-unit id="0806e20ed1459118ce9b52f165bc00868a177d26" translate="yes" xml:space="preserve">
          <source>Thus, if you:</source>
          <target state="translated">したがって、もしあなたが</target>
        </trans-unit>
        <trans-unit id="985e4313b4f69c20bac9a62ad436714ad736a0be" translate="yes" xml:space="preserve">
          <source>Use Modern Versions of MySQL (late 5.1, all 5.5, 5.6, etc) &lt;strong&gt;AND&lt;/strong&gt;&lt;code&gt;mysql_set_charset()&lt;/code&gt; / &lt;code&gt;$mysqli-&amp;gt;set_charset()&lt;/code&gt; / PDO's DSN charset parameter (in PHP &amp;ge; 5.3.6)</source>
          <target state="translated">MySQLの最新バージョン（後期5.1、すべて &lt;code&gt;mysql_set_charset()&lt;/code&gt; など） &lt;strong&gt;および&lt;/strong&gt; mysql_set_charset（） / &lt;code&gt;$mysqli-&amp;gt;set_charset()&lt;/code&gt; / PDOのDSN文字セットパラメータ（ PHP&amp;ge;5.3.6）を使用します</target>
        </trans-unit>
        <trans-unit id="427ec19a36c3eadeeaa0cbf7051413a63eca61b8" translate="yes" xml:space="preserve">
          <source>We have chosen this payload because, if we called &lt;code&gt;addslashes()&lt;/code&gt; on it, we'd insert an ASCII &lt;code&gt;\&lt;/code&gt; i.e. &lt;code&gt;0x5c&lt;/code&gt;, before the &lt;code&gt;'&lt;/code&gt; character. So we'd wind up with &lt;code&gt;0xbf5c27&lt;/code&gt;, which in &lt;code&gt;gbk&lt;/code&gt; is a two character sequence: &lt;code&gt;0xbf5c&lt;/code&gt; followed by &lt;code&gt;0x27&lt;/code&gt;. Or in other words, a &lt;em&gt;valid&lt;/em&gt; character followed by an unescaped &lt;code&gt;'&lt;/code&gt;. But we're not using &lt;code&gt;addslashes()&lt;/code&gt;. So on to the next step...</source>
          <target state="translated">このペイロードを選択したのは、 &lt;code&gt;addslashes()&lt;/code&gt; を呼び出した場合、 &lt;code&gt;'&lt;/code&gt; 文字の前にASCII &lt;code&gt;\&lt;/code&gt; ie &lt;code&gt;0x5c&lt;/code&gt; を挿入するためです。 したがって、 &lt;code&gt;0x27&lt;/code&gt; ます。これは、 gbk &lt;code&gt;0xbf5c&lt;/code&gt; 2文字のシーケンスです： 0xbf5cの後に0x27が続きます。 または、言い換えると、 &lt;em&gt;有効な&lt;/em&gt;文字の後にエスケープされていない &lt;code&gt;'&lt;/code&gt; が続きます。 ただし、 &lt;code&gt;addslashes()&lt;/code&gt; は使用していません。 次のステップに進みます...</target>
        </trans-unit>
        <trans-unit id="4ea0cdc50b3e6c87d368d6f640192c16206f3e34" translate="yes" xml:space="preserve">
          <source>Well, there's nothing really that can pass through that, other than &lt;code&gt;%&lt;/code&gt; wildcard. It could be dangerous if you were using &lt;code&gt;LIKE&lt;/code&gt; statement as attacker could put just &lt;code&gt;%&lt;/code&gt; as login if you don't filter that out, and would have to just bruteforce a password of any of your users.
People often suggest using prepared statements to make it 100% safe, as data can't interfere with the query itself that way.
But for such simple queries it probably would be more efficient to do something like &lt;code&gt;$login = preg_replace('/[^a-zA-Z0-9_]/', '', $login);&lt;/code&gt;</source>
          <target state="translated">まあ、 &lt;code&gt;%&lt;/code&gt; ワイルドカード以外に、実際に通過できるものはありません。 &lt;code&gt;LIKE&lt;/code&gt; ステートメントを使用している場合、フィルターをかけないと攻撃者が &lt;code&gt;%&lt;/code&gt; だけをログインとして入力する可能性があり、ユーザーのパスワードを総当たりする必要があるため危険です。 データはクエリ自体に干渉しないため、準備されたステートメントを使用して100％安全にすることをお勧めします。 しかし、そのような単純なクエリの場合、おそらく &lt;code&gt;$login = preg_replace('/[^a-zA-Z0-9_]/', '', $login);&lt;/code&gt; ようにするほうが効率的です。</target>
        </trans-unit>
        <trans-unit id="d73739e8bcc2eca14c4e6ee94849b3f8eb574f29" translate="yes" xml:space="preserve">
          <source>Which is &lt;a href=&quot;https://www.google.com/search?q=%E7%B8%97%27%20OR&amp;amp;oq=%E7%B8%97%27%20OR&amp;amp;aqs=chrome..69i57&amp;amp;sourceid=chrome&amp;amp;es_sm=122&amp;amp;ie=UTF-8&quot;&gt;exactly what&lt;/a&gt; the attack requires.</source>
          <target state="translated">これは&lt;a href=&quot;https://www.google.com/search?q=%E7%B8%97%27%20OR&amp;amp;oq=%E7%B8%97%27%20OR&amp;amp;aqs=chrome..69i57&amp;amp;sourceid=chrome&amp;amp;es_sm=122&amp;amp;ie=UTF-8&quot;&gt;まさに&lt;/a&gt;攻撃に必要なものです。</target>
        </trans-unit>
        <trans-unit id="6a67ed2b7ff7dba4ff8e1a412ae8d28fc8cd1aaa" translate="yes" xml:space="preserve">
          <source>Wrapping Up</source>
          <target state="translated">ラッピング</target>
        </trans-unit>
        <trans-unit id="f5f39e69fe287172343d624554cae09348c5c8eb" translate="yes" xml:space="preserve">
          <source>You're 100% safe.</source>
          <target state="translated">100%安全です。</target>
        </trans-unit>
        <trans-unit id="217320583edc38a0014a1114edbfde1025f77f58" translate="yes" xml:space="preserve">
          <source>an explicitly set SQL mode that does not include &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; を含まない明示的に設定されたSQLモード</target>
        </trans-unit>
        <trans-unit id="30de47e3fc63619fc4bb52553661d24fc277a5e9" translate="yes" xml:space="preserve">
          <source>do not work.</source>
          <target state="translated">は動作しません。</target>
        </trans-unit>
        <trans-unit id="9bb92a3071ca477f4a9ff10448279a15beeb7fc0" translate="yes" xml:space="preserve">
          <source>in &lt;em&gt;addition&lt;/em&gt; to employing one of the solutions in ircmaxell's summary, use at least one of:</source>
          <target state="translated">ircmaxellの概要にあるソリューションの1つを使用することに&lt;em&gt;加え&lt;/em&gt;て、少なくとも次の1つを使用します。</target>
        </trans-unit>
        <trans-unit id="c043e9c677741168021919c728f09616e78da5a8" translate="yes" xml:space="preserve">
          <source>single-quoted string literals; or</source>
          <target state="translated">単一引用符で囲まれた文字列リテラル;または</target>
        </trans-unit>
        <trans-unit id="47389f249f78a198fbfe6286d101664c76a37021" translate="yes" xml:space="preserve">
          <source>use MySQL v5.7.6 or later</source>
          <target state="translated">MySQL 5.7.7.6以降を使用</target>
        </trans-unit>
        <trans-unit id="693e82b31d5c236212865ca0f15c27928ec99fd3" translate="yes" xml:space="preserve">
          <source>use native prepared statements</source>
          <target state="translated">ネイティブ調書を使う</target>
        </trans-unit>
        <trans-unit id="2cf9beb50c22da78348a0f66f5b58ee7b6e3b96e" translate="yes" xml:space="preserve">
          <source>your SQL string literals are quoted using double-quote &lt;code&gt;&quot;&lt;/code&gt; characters.</source>
          <target state="translated">SQL文字列リテラルは、二重引用符 &lt;code&gt;&quot;&lt;/code&gt; を使用して引用されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
