<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/263400">
    <body>
      <group id="263400">
        <trans-unit id="0d79426d053942f788af84f9684d1aeab86b6544" translate="yes" xml:space="preserve">
          <source>&amp;Dagger;By way of comparison. If used on a string, the SpookyHash on 64 bits is considerably faster than &lt;code&gt;string.GetHashCode()&lt;/code&gt; on 32 bits which is slightly faster than &lt;code&gt;string.GetHashCode()&lt;/code&gt; on 64 bits, which is considerably faster than SpookyHash on 32 bits, though still fast enough to be a reasonable choice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;comparison比較として。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文字列で使用される場合、64ビットでSpookyHashがかなり速くより&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;わずかに速いよりも32ビットに&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 32ビットでかなり高速SpookyHashよりも64ビットで、しかし依然として速いです合理的な選択になるのに十分です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83c2ef75ab5d9faef3f79684063ce016c8b50e49" translate="yes" xml:space="preserve">
          <source>&amp;dagger;&lt;code&gt;decimal&lt;/code&gt; isn't native from the .NET perspective though it is from the C#. The problem with it is that its own &lt;code&gt;GetHashCode()&lt;/code&gt; treats precision as significant while its own &lt;code&gt;Equals()&lt;/code&gt; does not. Both are valid choices, but not mixed like that. In implementing your own version, you need to choose to do one, or the other, but I can't know which you'd want.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;dagger; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、C＃からのものですが、.NETの観点からはネイティブではありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それに関する問題は、独自の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が精度を重要なものとして扱うのに対し、独自の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Equals()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はそうではないということです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どちらも有効な選択肢ですが、そのように混在させることはできません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;独自のバージョンを実装する場合、どちらか一方を選択する必要がありますが、どちらを希望するかわかりません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3df11bf9c11a994a6141e579ee8c87c906373481" translate="yes" xml:space="preserve">
          <source>(Note: The original technique using anonymous types seems to create an object on the heap, i.e. garbage, since anonymous types are implemented as classes, though this might be optimized out by the compiler. It would be interesting to benchmark these options, but the tuple option should be superior.)</source>
          <target state="translated">(注意:匿名型を使ったオリジナルの手法は、匿名型がクラスとして実装されているため、ヒープ上にオブジェクトを作成してしまい、ゴミとなってしまうようです。これらのオプションをベンチマークするのは興味深いことですが、タプルオプションの方が優れているはずです)。</target>
        </trans-unit>
        <trans-unit id="a3a2c16db35df35d2fe189e2fcca836853920a73" translate="yes" xml:space="preserve">
          <source>*A big surprise in this is that hand-inlining a rotation method that returned &lt;code&gt;(x &amp;lt;&amp;lt; n) | (x &amp;gt;&amp;gt; -n)&lt;/code&gt; improved things. I would have been sure that the jitter would have inlined that for me, but profiling showed otherwise.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;*これの大きな驚きは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(x &amp;lt;&amp;lt; n) | (x &amp;gt;&amp;gt; -n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を返した回転メソッドを手動でインライン化したことです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（x &amp;gt;&amp;gt; -n）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;改善されたもの。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私はジッターが私にそれをインライン化したと確信していましたが、プロファイリングはそうではありませんでした。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95d42bc65b3b6a49d6e5b97cf8c89519a4d16ef8" translate="yes" xml:space="preserve">
          <source>.NET Standard 2.1 And Above</source>
          <target state="translated">.NET標準2.1以上</target>
        </trans-unit>
        <trans-unit id="237eebd45ff1ae0b4dc2e3a1f947162eb4d30120" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx&quot;&gt;This page&lt;/a&gt; gives quite a few options. I think for most cases the above is &quot;good enough&quot; and it's incredibly easy to remember and get right. The &lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx#fnv&quot;&gt;FNV&lt;/a&gt; alternative is similarly simple, but uses different constants and &lt;code&gt;XOR&lt;/code&gt; instead of &lt;code&gt;ADD&lt;/code&gt; as a combining operation. It looks &lt;em&gt;something&lt;/em&gt; like the code below, but the normal FNV algorithm operates on individual bytes, so this would require modifying to perform one iteration per byte, instead of per 32-bit hash value. FNV is also designed for variable lengths of data, whereas the way we're using it here is always for the same number of field values. Comments on this answer suggest that the code here doesn't actually work as well (in the sample case tested) as the addition approach above.</source>
          <target state="translated">&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このページに&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はかなりの数のオプションがあります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ほとんどの場合、上記は「十分」であり、覚えて正しく理解するのは非常に簡単だと思います。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx#fnv&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNVの&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代替は、同様に単純であるが、異なる定数と使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;XOR&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代わりに&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ADD&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;組み合わせる操作として。&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;何か&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に見える&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下のコードのようですが、通常のFNVアルゴリズムは個々のバイトで動作するため、32ビットのハッシュ値ごとではなく、バイトごとに1回の反復を実行するように変更する必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNVは可変長のデータ用にも設計されていますが、ここでの使用方法は常に同じ数のフィールド値に対してです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この回答へのコメントは、ここでのコードが実際には（テストされたサンプルケースでは）上記の追加アプローチほどうまく機能しないことを示唆しています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dbfcc92679561cd466ca70d3ec5cb0ada4849da5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt; users can generate GetHashCode, Equals, and others with &lt;code&gt;ReSharper -&amp;gt; Edit -&amp;gt; Generate Code -&amp;gt; Equality Members&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ReSharper&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ユーザーは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ReSharper -&amp;gt; Edit -&amp;gt; Generate Code -&amp;gt; Equality Members&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用して、GetHashCode、Equalsなどを生成でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ea1ae0f0eb1ed12ed21ed926e7ffa399926aaaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueTuple&lt;/code&gt; is a struct and appears to have a solid &lt;code&gt;GetHashCode&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は構造体であり、確実な&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装があるようです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea0202aa9a3074625a51c3256d2dc385d6895a70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All the GetHashCode() implementations I'd coded in the past, and indeed used as the basis of answers on this site, were much worse than I'd throught&lt;/strong&gt;. Much of the time it was &quot;good enough&quot; for much of the uses, but I wanted something better.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私が過去にコーディングし、実際にこのサイトで回答の基礎として使用したすべてのGetHashCode（）実装は、私が考えたよりもはるかに悪かった&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ほとんどの場合、それは多くの用途に「十分」でしたが、もっと良いものが欲しかったです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64737e14d176ba9cf426f44088eeac87333a7a89" translate="yes" xml:space="preserve">
          <source>A good hash function should map the expected inputs as evenly as possible over its output range. It should have uniformity.</source>
          <target state="translated">良いハッシュ関数は、期待される入力を可能な限り均等に出力範囲にマッピングしなければなりません。また、一様性を持たなければなりません。</target>
        </trans-unit>
        <trans-unit id="0b087b0c644a46bd6641921114f7033df6978d64" translate="yes" xml:space="preserve">
          <source>A small change to a message should change the hash value so extensively that the new hash value appears uncorrelated with the old hash value (avalanche effect).</source>
          <target state="translated">メッセージへの小さな変更は、新しいハッシュ値が古いハッシュ値とは無関係に見えるほど広範囲にハッシュ値を変更しなければなりません(アバランシェ効果)。</target>
        </trans-unit>
        <trans-unit id="bd1a4e418ac54c54625c46768d60dc7e55d97d21" translate="yes" xml:space="preserve">
          <source>Add the result and h1 together.</source>
          <target state="translated">結果とh1を合わせて加算します。</target>
        </trans-unit>
        <trans-unit id="f1c118123f96f8220daec90522f3b96d0f84b028" translate="yes" xml:space="preserve">
          <source>Also it has extension method to provide a fluent interface, so you can use it like this:</source>
          <target state="translated">また、流暢なインターフェイスを提供するための拡張メソッドを持っているので、このように使うことができます。</target>
        </trans-unit>
        <trans-unit id="5924b5e6279dfd3f1ccd06d12d17ca745d917e31" translate="yes" xml:space="preserve">
          <source>And here is how to use it:</source>
          <target state="translated">そして、その使い方をご紹介します。</target>
        </trans-unit>
        <trans-unit id="f7e8bccebca6d7ebf1c132bf64c36d31c8b3e398" translate="yes" xml:space="preserve">
          <source>And here is the acutal builder class:</source>
          <target state="translated">そして、こちらがアキュータルビルダークラスです。</target>
        </trans-unit>
        <trans-unit id="0b0c4ee6c49ec53c99f367f324f2d13f02203ef5" translate="yes" xml:space="preserve">
          <source>And it pretty much sucked. So after a bit of experimentation and research I started re-hashing my hashes with the following:</source>
          <target state="translated">そして、それはかなりひどいものでした。そこで少し実験と研究をした後、私は以下のようにハッシュの再ハッシュを始めました。</target>
        </trans-unit>
        <trans-unit id="4753226d060c2ac7870ac15825cb98de476efddf" translate="yes" xml:space="preserve">
          <source>And one final tip: &lt;b&gt;Don't rely on GetHashCode() being stable over multiple aplication runs&lt;/b&gt;. Many .Net types don't guarantee their hash codes to stay the same after a restart, so you should only use the value of GetHashCode() for in memory data structures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして最後のヒント：&lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GetHashCode（）が複数のアプリケーション実行で安定していることに依存しないでください&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多くの.Netタイプは、再起動後もハッシュコードが同じであることを保証しないため、メモリデータ構造ではGetHashCode（）の値のみを使用する必要があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c910bf934a6df4c337ec4ebc5ec681c2f90542e" translate="yes" xml:space="preserve">
          <source>And same for multi-type: all converted first to &lt;code&gt;int&lt;/code&gt; using &lt;code&gt;GetHashCode()&lt;/code&gt;
then the int values will be xor'ed and the result is your hash.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして、マルチタイプについても同じです。最初にすべて&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;して&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;変換され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 、次にint値がxorされ、結果がハッシュになります。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d58afc915a407c9686d470da7d4718874579746d" translate="yes" xml:space="preserve">
          <source>And then my power-of-two hash table didn't suck any more.</source>
          <target state="translated">それから私のパワー・オブ・ツーのハッシュ・テーブルはもう吸わなくなった。</target>
        </trans-unit>
        <trans-unit id="e6524d5374d0dad18e089d93cca5b51530ed61a0" translate="yes" xml:space="preserve">
          <source>And this is from &lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/Common/src/System/Numerics/Hashing/HashHelpers.cs&quot;&gt;&lt;code&gt;HashHelper&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そしてこれは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/Common/src/System/Numerics/Hashing/HashHelpers.cs&quot;&gt; &lt;code&gt;HashHelper&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6ea4b5d260d1757dfef473e91d4cdc426f950356" translate="yes" xml:space="preserve">
          <source>And well, it was disturbing how much the &lt;code&gt;string.GetHashCode()&lt;/code&gt; implementations in &lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/System/string.cs,789&quot;&gt;.NET&lt;/a&gt; (or study &lt;a href=&quot;https://stackoverflow.com/a/48775953/147511&quot;&gt;here&lt;/a&gt;) could be improved this way (on the order of tests running about 20-30 times faster due to fewer collisions) and more disturbing how much my own hash codes could be improved (much more than that).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして、それは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/System/string.cs,789&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（または&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/48775953/147511&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここでの&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;研究&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;string.GetHashCode（）の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この方法（衝突が少ないために約20から30倍速く実行されるテストの順序）でどれほど改善できるか、そしてさらに私自身のハッシュコードの多くは改善される可能性があります（それ以上）。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6539f8fb88e503a8b8c34ab6bcc63de114670a0b" translate="yes" xml:space="preserve">
          <source>Anonymous Type</source>
          <target state="translated">匿名タイプ</target>
        </trans-unit>
        <trans-unit id="2ef0204701e5a8adb4295eb5e9aa0eda969ef4cf" translate="yes" xml:space="preserve">
          <source>As @cactuaroid mentions in the comments, a value tuple can be used. This saves a few keystrokes and more importantly executes purely on the stack (no Garbage):</source>
          <target state="translated">コメントで@cactuaroidさんが言及されているように、値のタプルを使うことができます。これはいくつかのキーストロークを節約できますし、より重要なのはスタック上で純粋に実行されることです(ゴミは出ません)。</target>
        </trans-unit>
        <trans-unit id="4884ca4fdea316ef7d5a10917de179b44aefe544" translate="yes" xml:space="preserve">
          <source>As noted in comments, you may find it's better to pick a large prime to multiply by instead. Apparently 486187739 is good... and although most examples I've seen with small numbers tend to use primes, there are at least similar algorithms where non-prime numbers are often used. In the not-quite-&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function&quot;&gt;FNV&lt;/a&gt; example later, for example, I've used numbers which apparently work well - but the initial value isn't a prime. (The multiplication constant &lt;em&gt;is&lt;/em&gt; prime though. I don't know quite how important that is.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コメントに記載されているように、大きい素数を選択して乗算する方が良い場合があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どうやら486187739は良いです...そして、私が小さい数で見たほとんどの例は素数を使用する傾向がありますが、非素数が頻繁に使用される少なくとも類似のアルゴリズムがあります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;後ほどかなり&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNVの&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例では、明らかにうまくいく数値を使用しましたが、初期値は素数ではありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;乗算定数&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;素数です。それがどれほど重要であるかはよくわかりません。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0fc68588324515b00e71f04c950e60480e2bd553" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14863&quot;&gt;https://github.com/dotnet/coreclr/pull/14863&lt;/a&gt;, there is a new way to generate hash codes that is super simple! Just write</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とおり&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14863&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/dotnet/coreclr/pull/14863&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、超シンプルでハッシュコードを生成するための新しい方法があります！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;書くだけ&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ba8400d7c27eb6bbe485bddce2a770e9a59f458" translate="yes" xml:space="preserve">
          <source>As per the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode#notes-to-inheritors&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode#notes-to-inheritors&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ドキュメント&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に従って&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6490b278794b35f12336f32cce320e3a69acab63" translate="yes" xml:space="preserve">
          <source>Because of this feature, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection and they should never be persisted.</source>
          <target state="translated">この機能のため、ハッシュコードは作成されたアプリケーションドメイン以外では決して使用してはいけませんし、コレクションのキーフィールドとして使用してはいけませんし、永続化してはいけません。</target>
        </trans-unit>
        <trans-unit id="11b32f5445111f35152e714852144506ca1cb530" translate="yes" xml:space="preserve">
          <source>Because the Hash output is always an int, you can just chain Hash calls.</source>
          <target state="translated">Hashの出力は常にintなので、Hashの呼び出しをチェインすればいいだけです。</target>
        </trans-unit>
        <trans-unit id="2273bd2f117653a9c56bbd3e76317b35a2b4389b" translate="yes" xml:space="preserve">
          <source>But this test passes (with ints):</source>
          <target state="translated">しかし、この試験は合格しました(インツで)。</target>
        </trans-unit>
        <trans-unit id="f120da2cf0f973ab74313965e44c104c28715694" translate="yes" xml:space="preserve">
          <source>By the way, the earlier algorithm is the one currently used by the C# compiler for anonymous types.</source>
          <target state="translated">ちなみに、先ほどのアルゴリズムは、現在C#コンパイラが匿名型で使用しているものです。</target>
        </trans-unit>
        <trans-unit id="28ec9ea2e98208ee3c50de6dbbd90da47726d6dc" translate="yes" xml:space="preserve">
          <source>Cryptographically Secure?</source>
          <target state="translated">暗号的に安全か?</target>
        </trans-unit>
        <trans-unit id="f6798670eccb448dbd7ae61707aed7700330e4b5" translate="yes" xml:space="preserve">
          <source>Deterministic</source>
          <target state="translated">Deterministic</target>
        </trans-unit>
        <trans-unit id="f399f567d30257913aa40c9a0b774a97589e3f6c" translate="yes" xml:space="preserve">
          <source>Edit (May 2018): &lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt; getter is now a JIT intrinsic - the &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14125&quot;&gt;pull request&lt;/a&gt; is mentioned by Stephen Toub in &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;編集（2018年5月）：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲッターがJIT組み込みになりました- &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14125&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プルリクエスト&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このブログの投稿&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でStephen Toubによって言及されてい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f36d236cdfc72792355b5bd010191a1697cc8e21" translate="yes" xml:space="preserve">
          <source>Edit: I was also using open-addressing, which would also have increased the sensitivity to collision, perhaps more so than the fact it was power-of-two.</source>
          <target state="translated">編集:私もオープンアドレスを使用していたので、おそらくパワーオブツーであるという事実よりも、衝突に対する感度が上がっていたでしょう。</target>
        </trans-unit>
        <trans-unit id="ec3029c0ba715ec4e3b4ba579e691c099b1e661c" translate="yes" xml:space="preserve">
          <source>For each further item, perform the operation on the previous result and the next item (e.g. h2).</source>
          <target state="translated">さらなる項目については、前の結果と次の項目(例えば h2)に対して演算を行います。</target>
        </trans-unit>
        <trans-unit id="4a750761886bb8c5c3093d7d8da1f358a99b7be3" translate="yes" xml:space="preserve">
          <source>For those who use hash as ID (I mean an unique value), hash is naturally limited to a number of digits, I think it was 5 bytes for hashing algorithm, at least MD5.</source>
          <target state="translated">ハッシュをID(一意の値という意味)として使う人にとっては、ハッシュは当然桁数に制限があるので、ハッシュアルゴリズムは5バイト、少なくともMD5だったと思います。</target>
        </trans-unit>
        <trans-unit id="d8558f6652b3cfc7c3336ced510c7c2259ad7976" translate="yes" xml:space="preserve">
          <source>GetHashCode Made Easy</source>
          <target state="translated">GetHashCodeを簡単に</target>
        </trans-unit>
        <trans-unit id="034396c26c5e4ebc5bd1068b7529411104222377" translate="yes" xml:space="preserve">
          <source>HashCode.Add</source>
          <target state="translated">HashCode.Add</target>
        </trans-unit>
        <trans-unit id="0ba1e0a5a4926cff0e03ebbdb6d52b7a661256e8" translate="yes" xml:space="preserve">
          <source>HashCode.Combine</source>
          <target state="translated">HashCode.Combine</target>
        </trans-unit>
        <trans-unit id="d38b35ccba9919ce8b5b43ef1cf490a7f721401d" translate="yes" xml:space="preserve">
          <source>Here is another fluent implementation of &lt;a href=&quot;https://stackoverflow.com/a/263416/33791&quot;&gt;the algorithm posted above by Jon Skeet&lt;/a&gt;, but which includes no allocations or boxing operations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下は&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/263416/33791&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、上記のJon Skeet&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;投稿したアルゴリズムの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;流暢な別の実装ですが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;割り当てやボクシング操作は含まれていません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b1e0b14247c35a0dd98e5ba0eb642e4dc1843c1" translate="yes" xml:space="preserve">
          <source>Here is my hashcode helper.</source>
          <target state="translated">これが私のハッシュコードヘルパーです。</target>
        </trans-unit>
        <trans-unit id="4be13d945c6ba718eeced4ba0389ce90b6ec6aa0" translate="yes" xml:space="preserve">
          <source>Here is my simplistic approach. I am using the classic builder pattern for this. It is typesafe (no boxing/unboxing) and also compatbile with .NET 2.0 (no extension methods etc.).</source>
          <target state="translated">ここに私のシンプルなアプローチがあります。これには古典的なビルダーパターンを使用しています。これはタイプセーフで(箱詰めや箱詰めをしない)、.NET 2.0との互換性があります(拡張子メソッドなどはありません)。</target>
        </trans-unit>
        <trans-unit id="b8b27f99a942c6d3ce3eb645ca556e3c906c83ac" translate="yes" xml:space="preserve">
          <source>Here's my helper class using &lt;a href=&quot;https://stackoverflow.com/a/263416/704144&quot;&gt;Jon Skeet's implementation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/263416/704144&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Jon Skeetの実装&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用したヘルパークラスを次に示し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83ac8a659ca4db3fa8d7dcfd4473a8c41782b2c9" translate="yes" xml:space="preserve">
          <source>However, since it's now already written, one can make use of it more easily:</source>
          <target state="translated">しかし、今はすでに書かれているので、もっと簡単に活用することができます。</target>
        </trans-unit>
        <trans-unit id="8cf06bfeb7893297f5b466ba135ef3e5a8c8a67d" translate="yes" xml:space="preserve">
          <source>I can guess that for multiple big int you can use this:</source>
          <target state="translated">複数のbig intの場合は、これを使うことができるのではないかと推測できます。</target>
        </trans-unit>
        <trans-unit id="6341f744676fe64ec4e97c176de06ac114def865" translate="yes" xml:space="preserve">
          <source>I changed my implementation to not use GetHashCode for the primitive types and it seems to work better</source>
          <target state="translated">プリミティブ型にGetHashCodeを使用しないように実装を変更したところ、より良く動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="d44374f08bd16dc2acc4cd4ed9fad6603e35a2dc" translate="yes" xml:space="preserve">
          <source>I didn't assess its performance, so any feedback is welcomed.</source>
          <target state="translated">私はその性能を評価していないので、どんなフィードバックでも歓迎します。</target>
        </trans-unit>
        <trans-unit id="3c7682f2756768262570b11ce2273bf6db42e85c" translate="yes" xml:space="preserve">
          <source>I have a Hashing class in Helper library that I use it for this purpose.</source>
          <target state="translated">HelperライブラリにHashingクラスがあるので、それを使っています。</target>
        </trans-unit>
        <trans-unit id="79484108e32c6a21344a0d900482a48b2c630c8f" translate="yes" xml:space="preserve">
          <source>I ran into an issue with floats and decimals using the implementation selected as the answer above.</source>
          <target state="translated">私は、上記の答えとして選択された実装を使用して、浮動小数点数と小数の問題に遭遇しました。</target>
        </trans-unit>
        <trans-unit id="7eba8db330d45d66dcb0d37cd8b2aed9484677aa" translate="yes" xml:space="preserve">
          <source>I usually go with something like the implementation given in Josh Bloch's &lt;em&gt;fabulous&lt;/em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;Effective Java&lt;/a&gt;. It's fast and creates a pretty good hash which is unlikely to cause collisions. Pick two different prime numbers, e.g. 17 and 23, and do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私は通常、Josh Blochの&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すばらしい&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;効果的なJavaで提供&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;される実装のようなものを使い&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それは高速で、衝突を引き起こす可能性が低いかなり良いハッシュを作成します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2つの異なる素数、たとえば17と23を選び、次のようにします。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecd4a4ee6fb901f76f58984b6c90616cf19d910c" translate="yes" xml:space="preserve">
          <source>If we have no more than 8 properties (hopefully), here is another alternative.</source>
          <target state="translated">8つ以上のプロパティがない場合(できれば)、ここにもう一つの選択肢があります。</target>
        </trans-unit>
        <trans-unit id="51e61bd0902dd12fd8399d10c1dfc7edf6c2bc67" translate="yes" xml:space="preserve">
          <source>If you are using .NET Standard 2.1 or above, you can use the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.hashcode?view=netcore-2.1&quot;&gt;System.HashCode&lt;/a&gt; struct. There are two methods of using it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET Standard 2.1以降を使用している場合は、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.hashcode?view=netcore-2.1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.HashCode&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;構造体を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それを使用する2つの方法があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7195ac0e83ef4a6feddbd250bff1ae20963d1157" translate="yes" xml:space="preserve">
          <source>If you want to avoid writing an extension method for System.Int32:</source>
          <target state="translated">System.Int32の拡張メソッドを書かないようにしたい場合。</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="6488742a860c14ecbed74fa734de70954bb71e77" translate="yes" xml:space="preserve">
          <source>In .NET Core each time you restart an application you will get different hash codes. This is a security feature to prevent Denial of Service attacks (DoS). For .NET Framework you &lt;strong&gt;should&lt;/strong&gt; enable this feature by adding the following App.config file:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET Coreでは、アプリケーションを再起動するたびに異なるハッシュコードを取得します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、サービス拒否攻撃（DoS）を防ぐためのセキュリティ機能です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET Frameworkの場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、次のApp.configファイルを追加して、この機能&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有効に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要が&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4738d896b60dfae58b5b259b003bf59cce6e20b" translate="yes" xml:space="preserve">
          <source>In .NET, the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode&quot;&gt;&lt;code&gt;GetHashCode&lt;/code&gt; method&lt;/a&gt; is used in a lot of places throughout the .NET base class libraries. Implementing it properly is especially important to find items quickly in a collection or when determining equality.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NETでは、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode&quot;&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッド&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が.NET基本クラスライブラリ全体の多くの場所で使用されています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;適切に実装することは、コレクション内でアイテムをすばやく見つけるか、等しいかどうかを判断するときに特に重要です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d045e350842340848d745e65b9ccc9cf28237c03" translate="yes" xml:space="preserve">
          <source>In English:</source>
          <target state="translated">英語で</target>
        </trans-unit>
        <trans-unit id="66db6221d3fcbac7088e96ff309ffb23cfb5ad58" translate="yes" xml:space="preserve">
          <source>In case you want to polyfill &lt;code&gt;HashCode&lt;/code&gt; from &lt;code&gt;netstandard2.1&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;netstandard2.1の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt; &lt;code&gt;netstandard2.1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;する場合&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c40e2b1801b414478c669a008b937281f4d2dc69" translate="yes" xml:space="preserve">
          <source>In most cases where Equals() compares multiple fields it doesn't really matter if your GetHash() hashes on one field or on many. You just have to make sure that calculating the hash is really cheap (&lt;b&gt;No allocations&lt;/b&gt;, please) and fast (&lt;b&gt;No heavy computations&lt;/b&gt; and certainly no database connections) and provides a good distribution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Equals（）が複数のフィールドを比較するほとんどの場合、GetHash（）が1つのフィールドまたは複数のフィールドでハッシュするかどうかは重要ではありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュの計算が本当に安く（&lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;割り当てを行わない&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でください）、高速であること（&lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重い計算&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がなく、データベース接続がないこと）を確認し、優れた分散を提供する必要があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70f850b780b4ffb79b7c73fda1edcded2180b380" translate="yes" xml:space="preserve">
          <source>In the end I settled on porting &lt;a href=&quot;http://burtleburtle.net/bob/hash/spooky.html&quot;&gt;SpookyHash&lt;/a&gt; to .NET. Indeed the code above is a fast-path version of using SpookyHash to produce a 32-bit output from a 32-bit input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;結局、私は&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://burtleburtle.net/bob/hash/spooky.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SpookyHash&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を.NET &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に移植することにしました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際、上記のコードはSpookyHashを使用して32ビット入力から32ビット出力を生成する高速パスバージョンです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6243d71d1d7b8aea75619231aad11f8259651c82" translate="yes" xml:space="preserve">
          <source>Is there a standard algorithm or best practice on how to implement &lt;code&gt;GetHashCode&lt;/code&gt; for my custom classes so I don't degrade performance?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パフォーマンスを低下させないようにカスタムクラスに&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を実装する方法に関する標準のアルゴリズムまたはベストプラクティス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はありますか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79e480f23d6c2078c87bb12c8c5c3744c8de3f93" translate="yes" xml:space="preserve">
          <source>It also takes seed values, so if you need to deal with untrusted input and want to protect against Hash DoS attacks you can set a seed based on uptime or similar, and make the results unpredictable by attackers:</source>
          <target state="translated">また、シード値を取るので、信頼されていない入力を扱う必要があり、Hash DoS攻撃から保護したい場合は、アップタイムなどに基づいてシードを設定し、攻撃者が予測できない結果にすることができます。</target>
        </trans-unit>
        <trans-unit id="1cca014cbc07e3c62667a380b70f66b34a5849ca" translate="yes" xml:space="preserve">
          <source>It is infeasible to find two different messages with the same hash value</source>
          <target state="translated">同じハッシュ値を持つ2つの異なるメッセージを見つけることは不可能です。</target>
        </trans-unit>
        <trans-unit id="24065692dc06162d306ce6a1810804d176e738bc" translate="yes" xml:space="preserve">
          <source>It is infeasible to generate a message that yields a given hash value</source>
          <target state="translated">与えられたハッシュ値を返すメッセージを生成することは不可能です。</target>
        </trans-unit>
        <trans-unit id="3e7c0769beb54d29fef29e364d96abec5127a859" translate="yes" xml:space="preserve">
          <source>It is used like this:</source>
          <target state="translated">こんな感じで使われています。</target>
        </trans-unit>
        <trans-unit id="775120da70c32a3d1145975d3b0b7ece50d6c047" translate="yes" xml:space="preserve">
          <source>It still avoids any heap allocation and is used exactly the same way:</source>
          <target state="translated">それでもヒープの割り当てを回避し、全く同じように使用されます。</target>
        </trans-unit>
        <trans-unit id="af44925b98c54411762b5e115d90694d80c037bb" translate="yes" xml:space="preserve">
          <source>It would be nice to know more about the properties of this ROL-5 hash code algorithm.</source>
          <target state="translated">このROL-5ハッシュコードアルゴリズムの特性についてもっと知っておくといいでしょう。</target>
        </trans-unit>
        <trans-unit id="cd73c970707454efb2b115cd12e169fd1fb86e9f" translate="yes" xml:space="preserve">
          <source>It's advantage is that it uses generic type arguments and therefore will not cause boxing:</source>
          <target state="translated">これの利点は、一般的な型の引数を使用するため、ボックス化が発生しないことです。</target>
        </trans-unit>
        <trans-unit id="f183efea3aaad2350f821613ad659f9d94954a53" translate="yes" xml:space="preserve">
          <source>It's fast, for which Bob Jenkins deserves most of the credit because his original code I ported from is faster still, especially on 64-bit machines which the algorithm is optimised for&amp;Dagger;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特に、アルゴリズムが最適化されている64ビットマシンでは、ボブジェンキンスが移植した元のコードの方が高速であるため、ボブジェンキンスはほとんどの功績があります&amp;Dagger;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db3b9d4536e07c34bc7e78f6730f683ac59ee7c3" translate="yes" xml:space="preserve">
          <source>Left rotate (circular shift) h1 by 5 positions.</source>
          <target state="translated">左回転(円移動)h1を5ポジション分回転させます。</target>
        </trans-unit>
        <trans-unit id="9befb5f7f42c778c9ce669275d1ce6ed000d3ae9" translate="yes" xml:space="preserve">
          <source>Let's take a look at .NET Core's current implementation for &lt;code&gt;ValueTuple&lt;/code&gt;'s &lt;code&gt;GetHashCode&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に対する.NET Coreの現在の実装を見てみましょう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0cf40c5cdf4e24892afe91b39db417c88cd24a93" translate="yes" xml:space="preserve">
          <source>Microsoft already provides a good generic HashCode generator: Just copy your property/field values to an anonymous type and hash it:</source>
          <target state="translated">マイクロソフトは既に良いジェネリックHashCodeジェネレータを提供しています。プロパティフィールドの値を匿名型にコピーしてハッシュ化するだけです。</target>
        </trans-unit>
        <trans-unit id="fe5e8cabf2e9ef3c90856c23a3b071fc8ffdadc2" translate="yes" xml:space="preserve">
          <source>Microsoft lead for several way of hashing...</source>
          <target state="translated">マイクロソフトは、ハッシュ化のいくつかの方法のリード...</target>
        </trans-unit>
        <trans-unit id="778fc4e9438d8fe69ff04d1a23db7d2a638261a0" translate="yes" xml:space="preserve">
          <source>Most of my work is done with database connectivity which means that my classes all have a unique identifier from the database.  I always use the ID from the database to generate the hashcode.</source>
          <target state="translated">私の仕事のほとんどはデータベースとの接続性で行われています。私はいつもハッシュコードを生成するためにデータベースからのIDを使用しています。</target>
        </trans-unit>
        <trans-unit id="ebe8b198579b5d8d43b5b5961017777a829df670" translate="yes" xml:space="preserve">
          <source>Note that one thing to be aware of is that ideally you should prevent your equality-sensitive (and thus hashcode-sensitive) state from changing after adding it to a collection that depends on the hash code.</source>
          <target state="translated">注意しなければならないことは、理想的には、ハッシュコードに依存するコレクションに追加した後に、等質性に敏感な(つまりハッシュコードに敏感な)状態が変化しないようにするべきであるということです。</target>
        </trans-unit>
        <trans-unit id="94d46ec70da897d6695de00bf38d36857c1d2fb5" translate="yes" xml:space="preserve">
          <source>Note: If used with &lt;code&gt;struct&lt;/code&gt;, it will allocate memory due to boxing</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と一緒に使用すると&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ボクシングのためにメモリが割り当てられます&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5ac46a74dbff2b805e8a5a7d2626d1c776b451a" translate="yes" xml:space="preserve">
          <source>Now, SpookyHash is not a nice quick to remember piece of code. My port of it is even less so because I hand-inlined a lot of it for better speed*. But that's what code reuse is for.</source>
          <target state="translated">さて、SpookyHashは覚えやすいコードではありません。私の移植版では、より良い速度を得るために多くの部分を手でインライン化しているので、そうではありません。しかし、それはコードの再利用のためです。</target>
        </trans-unit>
        <trans-unit id="c849d5abd7981416f7339aea0af9b86419c5d93c" translate="yes" xml:space="preserve">
          <source>PS: This is one of those times where you puke a little in your mouth, knowing that this could be refactored into one method with 9 default's but it would be slower, so you just close your eyes and try to forget about it.</source>
          <target state="translated">PS:これは、9つのデフォルトのメソッドにリファクタリングされても遅くなることを知っていながら、口の中で少し吐いてしまった時の1つです。</target>
        </trans-unit>
        <trans-unit id="f065fd929e1c22be435487e6ea63fce4d6e76802" translate="yes" xml:space="preserve">
          <source>Pretty much similar to nightcoder's solution except it's easier to raise primes if you want to.</source>
          <target state="translated">ナイトコーダの解決策によく似ているが、プライムを上げるのが簡単だという点を除けばね。</target>
        </trans-unit>
        <trans-unit id="3595239fc3035d9f6e9e92d99a2bfdc06c060789" translate="yes" xml:space="preserve">
          <source>Prevent's DoS</source>
          <target state="translated">プリベントのDoS</target>
        </trans-unit>
        <trans-unit id="b64211794d8e7415e42a8db9c7d0b1a28f11fc41" translate="yes" xml:space="preserve">
          <source>Re-mixing a hash code can only improve a hash code that did at least fairly well in avoiding absolute collisions throughout its range (2&lt;sup&gt;32&lt;/sup&gt; possible values) but badly at avoiding collisions when modulo'd down for actual use in a hash table. While the simpler modulo of a power-of-two table made this more apparent, it was also having a negative effect with the more common prime-number tables, that just wasn't as obvious (the extra work in rehashing would outweigh the benefit, but the benefit would still be there).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュコードを再混合しても、その範囲全体（2 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;32の&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能な値）で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;絶対的な衝突を回避する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことはできますが、ハッシュテーブルで実際に使用するためにモジュロダウンしたときに衝突を回避することはできません。 2のべき乗の表のより単純なモジュロはこれをより明白にしましたが、それはまた、より一般的な素数の表に悪影響を及ぼしていましたが、それはそれほど明白ではありませんでした（リハッシュの追加の作業は利点を上回るでしょう） 、しかし利点はまだそこにあります）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fce0fc5a7dcd2e788a03afe8194230572d482cb6" translate="yes" xml:space="preserve">
          <source>Re-mixing a hash code can't improve a terrible hash code, because the only possible effect is we change e.g. a large number of collisions on value 53 to a large number of value 18,3487,291.</source>
          <target state="translated">唯一の可能な効果は、我々は値18,3487,291の多数の値に値53の衝突の多数の例えば変更されているので、ハッシュコードを再ミックスすることは、ひどいハッシュコードを改善することはできません。</target>
        </trans-unit>
        <trans-unit id="3c9638d7db05fd5da4a874b5d52071ce2087a80e" translate="yes" xml:space="preserve">
          <source>Re-mixing a hashcode can't improve a great hashcode, because the only possible effect is that we introduce a few more collisions.</source>
          <target state="translated">ハッシュコードを再ミックスしても、素晴らしいハッシュコードを改善することはできません。</target>
        </trans-unit>
        <trans-unit id="af1c5729918a7c13189ba3df1d45ae50f208a20f" translate="yes" xml:space="preserve">
          <source>Read more about this &lt;a href=&quot;https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;詳細については、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;こちらをご覧ください&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="555fb017bb0db82e04dccc34f592057fdb765838" translate="yes" xml:space="preserve">
          <source>Reduce Collisions</source>
          <target state="translated">衝突を減らす</target>
        </trans-unit>
        <trans-unit id="c67f54eca7526ba65a1d69b5e9d8b38b3f5067f1" translate="yes" xml:space="preserve">
          <source>Regrettably, deferring to &lt;code&gt;ValueTuple&lt;/code&gt; for our own &lt;code&gt;GetHashCode&lt;/code&gt; may not be as fast as we would like and expect. &lt;a href=&quot;https://github.com/dotnet/corefx/issues/8034#issuecomment-260759796&quot;&gt;This comment&lt;/a&gt; in a related discussion illustrates that directly calling &lt;code&gt;HashHelpers.Combine&lt;/code&gt; is more performant. On the flip side, that one is internal, so we'd have to copy the code, sacrificing much of what we had gained here. Also, we'd be responsible for remembering to first &lt;code&gt;Combine&lt;/code&gt; with the random seed. I don't know what the consequences are if we skip that step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;残念ながら、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;独自の&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に延期する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことは、期待して期待するほど速くはないかもしれません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関連するディスカッションの&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/issues/8034#issuecomment-260759796&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このコメント&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt; &lt;code&gt;HashHelpers.Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;を直接呼び出す&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ほう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がパフォーマンスが高い&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことを示してい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;裏側では、これは内部的なものなので、ここで得たものの多くを犠牲にしてコードをコピーする必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、最初&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にランダムシードと&lt;/font&gt; &lt;code&gt;Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことを忘れないようにする必要があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのステップをスキップした場合、結果はどうなるかわかりません。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="41ef8b26263345cca597a7e0aa739b815f3e2403" translate="yes" xml:space="preserve">
          <source>So I put that project to one side (it was a pet project anyway) and started looking at how to produce a good, well-distributed hash code in .NET quickly.</source>
          <target state="translated">そこで、私はそのプロジェクトを片側に置き(とにかくそれはペットのプロジェクトでした)、.NETでうまく分散された良いハッシュコードを素早く生成する方法を探し始めました。</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="6b05d1dc7e9a6f239a0395230da12be3bfb344e6" translate="yes" xml:space="preserve">
          <source>Start by performing the above operation on { static random seed, h1 }.</source>
          <target state="translated">static random seed,h1 }に対して上記の操作を行うことから始めます。</target>
        </trans-unit>
        <trans-unit id="5e0f2002957c60cee86ff8251ef135dcad849b56" translate="yes" xml:space="preserve">
          <source>That means we could simply do this:</source>
          <target state="translated">つまり、単純にこうすればいいということです。</target>
        </trans-unit>
        <trans-unit id="826b9d7df4ba107a7469f426428004097d06f89b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Add&lt;/code&gt; method helps you to deal with collections:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;Add&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法は、コレクションに対処するのに役立ちます：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60a068f9545ee721c0e80f6ad49baf4bb1d421b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Combine&lt;/code&gt; method can be used to create a hash code, given up to eight objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法は、8つのオブジェクトにあきらめて、ハッシュコードを作成するために使用することができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d787f0415844ae018bcf56dbf50989dcd7b9f11" translate="yes" xml:space="preserve">
          <source>The algorithm does not have to be a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;Cryptographic hash function&lt;/a&gt;. Meaning it does not have to satisfy the following conditions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アルゴリズムは、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;暗号化ハッシュ関数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;である必要はありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、次の条件を満たす必要はありません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ac5541f8c7461f7bcb249fb14bcc008335a3fce" translate="yes" xml:space="preserve">
          <source>The algorithm that calculates a hash code needs to be fast. A simple algorithm is usually going to be a faster one.</source>
          <target state="translated">ハッシュコードを計算するアルゴリズムは高速である必要があります。単純なアルゴリズムの方が高速になるのが普通です。</target>
        </trans-unit>
        <trans-unit id="045833a0e2d683cb1e8c1b7d651bc273a8823621" translate="yes" xml:space="preserve">
          <source>The algorithm that calculates a hash code needs to keep &lt;a href=&quot;http://crppit.epfl.ch/documentation/Hash_Function/WiKi/Hash_collision.htm&quot;&gt;hash collisions&lt;/a&gt; to a minumum. A hash collision is a situation that occurs when two calls to &lt;code&gt;GetHashCode&lt;/code&gt; on two different objects produce identical hash codes. Note that collisions are allowed (some have the misconceptions that they are not) but they should be kept to a minimum.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュコードを計算するアルゴリズムは、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://crppit.epfl.ch/documentation/Hash_Function/WiKi/Hash_collision.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュの衝突&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を最小&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に保つ必要があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュの衝突は、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2つの異なるオブジェクトで&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を2 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;回呼び出すと&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、同一のハッシュコードが生成される場合に発生します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;衝突は許可されますが（衝突が許可されていないという誤解がある場合もあります）、衝突は最小限に抑える必要があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d740feb71d0fbf0408f6a65db8c993a4ea6592a0" translate="yes" xml:space="preserve">
          <source>The compiler will ensure &lt;code&gt;HashValue&lt;/code&gt; is not called with a class due to the generic type constraint. But there is no compiler support for &lt;code&gt;HashObject&lt;/code&gt; since adding a generic argument also adds a boxing operation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイラーは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ジェネリック型の制約により、クラスで&lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashValue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が呼び出されないようにします。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ジェネリック引数を追加するとボクシング操作も追加される&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のコンパイラサポートはありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa6cbb4a7d0cfa141362b4605fb3b5044a8ac454" translate="yes" xml:space="preserve">
          <source>The full code can be seen at &lt;a href=&quot;https://bitbucket.org/JonHanna/spookilysharp/src&quot;&gt;https://bitbucket.org/JonHanna/spookilysharp/src&lt;/a&gt; but consider that the code above is a simplified version of it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全なコードは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://bitbucket.org/JonHanna/spookilysharp/src&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://bitbucket.org/JonHanna/spookilysharp/srcで&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;確認でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が、上記のコードはコードの簡略版であると考えて&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6aea3a389963dd3279922dd6f8068aa1b709c3a3" translate="yes" xml:space="preserve">
          <source>The hashing algorithm needs to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;deterministic&lt;/a&gt; i.e. given the same input it must always produce the same output.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュアルゴリズムは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;確定&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的である必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、同じ入力が与えられた場合、常に同じ出力を生成する必要があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74843c914e569e3d934ad75c40cd9c55a7c17747" translate="yes" xml:space="preserve">
          <source>The heavy lifting should be part of the Equals() method; the hash should be a very cheap operation to enable calling Equals() on as few items as possible.</source>
          <target state="translated">ハッシュは、できるだけ少ない項目で Equals()を呼び出せるようにするための非常に安価な操作でなければなりません。</target>
        </trans-unit>
        <trans-unit id="6a3bc6502919f9edd3fdb6c625b410c86d7f8039" translate="yes" xml:space="preserve">
          <source>Then I came back, and produced a lot of overloads to easily feed just about all of the native types (except &lt;code&gt;decimal&lt;/code&gt;&amp;dagger;) into a hash code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それから私は戻ってきて、多くのオーバーロードを生成して、ほぼすべてのネイティブ型（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;dagger; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を除く&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）をハッシュコード&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に簡単にフィード&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7483c49e6eb98b52f32043abddc6764971dca6b" translate="yes" xml:space="preserve">
          <source>Then I put &lt;em&gt;that&lt;/em&gt; project to one side, because just as the original project had produced the question of how to produce a better hash code, so that project produced the question of how to produce a better .NET memcpy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から、元のプロジェクトがより良いハッシュコードを生成する方法の問題を生成したのと同じように、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プロジェクトを一方&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に置い&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;た&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ので、そのプロジェクトはより良い.NET memcpyを生成する方法の問題を生成しました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8a3dd62d6429a57deee1938c2b8d63f6dec90e7d" translate="yes" xml:space="preserve">
          <source>Then, simply you can use it as:</source>
          <target state="translated">その後、単純に、あなたはそれを使用することができます。</target>
        </trans-unit>
        <trans-unit id="75cffc3515bdc95dc9b22f8fed1ab2f02044fac8" translate="yes" xml:space="preserve">
          <source>This disturbed me though, because the above shouldn't work. Or more precisely, it shouldn't work unless the original &lt;code&gt;GetHashCode()&lt;/code&gt; was poor in a very particular way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上記の方法ではうまくいかないので、これは私を混乱させました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;より正確には、元の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が非常に特殊な方法で不十分で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なかった場合は機能しません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="516e8a7deb0de8522dade038b929c0204312d476" translate="yes" xml:space="preserve">
          <source>This is a good one:</source>
          <target state="translated">これはいいですね。</target>
        </trans-unit>
        <trans-unit id="1c7c1850d93fc274a256ffc70245af28400631ac" translate="yes" xml:space="preserve">
          <source>This is a static helper class that implements Josh Bloch's implementation; and provides explicit overloads to &quot;prevent&quot; boxing, and also to implement the hash specifically for the long primitives.</source>
          <target state="translated">これは Josh Bloch の実装を実装した静的なヘルパークラスで、ボックス化を「防ぐ」ための明示的なオーバーロードを提供します。</target>
        </trans-unit>
        <trans-unit id="1307b741efe8c22ab33dd11c4f9ced9d341c0aa2" translate="yes" xml:space="preserve">
          <source>This is better than the common practice of &lt;code&gt;XOR&lt;/code&gt;ing hashcodes for two main reasons. Suppose we have a type with two &lt;code&gt;int&lt;/code&gt; fields:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、2つの主な理由でハッシュコードを&lt;/font&gt;&lt;/font&gt; &lt;code&gt;XOR&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一般的な方法よりも優れてい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2つの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フィールド&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を持つ型があるとし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e70ae20c9fb580d40ebc1c00d330f1f1135e294b" translate="yes" xml:space="preserve">
          <source>This is from &lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.ValueTuple/src/System/ValueTuple/ValueTuple.cs&quot;&gt;&lt;code&gt;ValueTuple&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.ValueTuple/src/System/ValueTuple/ValueTuple.cs&quot;&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d3c7ae92d1ff5acbdfec20e8c34d0f9543966a2" translate="yes" xml:space="preserve">
          <source>This test fails (floats; hash is the same even though I switched 2 values to be negative):</source>
          <target state="translated">このテストは失敗しました(float;2つの値をマイナスに切り替えてもハッシュは同じです)。</target>
        </trans-unit>
        <trans-unit id="3c9c751854ebebe052bd9ac39e701ac7f3ee9751" translate="yes" xml:space="preserve">
          <source>This will generate a quality hash code without you having to worry about the implementation details.</source>
          <target state="translated">これにより、実装の詳細を気にすることなく高品質のハッシュコードを生成することができます。</target>
        </trans-unit>
        <trans-unit id="2273401922a7ec31a62bf4c06628a6050af299e8" translate="yes" xml:space="preserve">
          <source>This will work for any number of properties. It does not use boxing. It just uses the algorithm already implemented in the framework for anonymous types.</source>
          <target state="translated">これはいくら物件でも通用します。これは箱詰めを使用しません。匿名型のためにフレームワークですでに実装されているアルゴリズムを使用しています。</target>
        </trans-unit>
        <trans-unit id="d9d9e2f475ad3bfe496517e55d50603c286f604d" translate="yes" xml:space="preserve">
          <source>Up until recently my answer would have been very close to Jon Skeet's here. However, I recently started a project which used power-of-two hash tables, that is hash tables where the size of the internal table is 8, 16, 32, etc. There's a good reason for favouring prime-number sizes, but there are some advantages to power-of-two sizes too.</source>
          <target state="translated">最近まで私の答えはJon Skeetのものに非常に近いものでした。しかし、私は最近、2乗ハッシュテーブル、つまり内部テーブルのサイズが8、16、32などであるハッシュテーブルを使うプロジェクトを始めました。プライム数のサイズを好むのにはそれなりの理由がありますが、パワーオブツーのサイズにも利点があります。</target>
        </trans-unit>
        <trans-unit id="342c659777997bec12f413246e5e24d6a8317e2a" translate="yes" xml:space="preserve">
          <source>Usage Example</source>
          <target state="translated">使用例</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="b33d830517aea3e2d9bb3019a44d1af09654b9ae" translate="yes" xml:space="preserve">
          <source>ValueTuple - Update for C# 7</source>
          <target state="translated">ValueTuple-C#7用のアップデート</target>
        </trans-unit>
        <trans-unit id="7f47afe10930417b5ac38c0d4b812852c49176ff" translate="yes" xml:space="preserve">
          <source>What Makes a Good Algorithm?</source>
          <target state="translated">良いアルゴリズムとは何か?</target>
        </trans-unit>
        <trans-unit id="38242dbf222f22cf8723209c1d4c037f60de436c" translate="yes" xml:space="preserve">
          <source>What is the best algorithm for overriding GetHashCode</source>
          <target state="translated">GetHashCodeをオーバーライドするための最良のアルゴリズムは何ですか?</target>
        </trans-unit>
        <trans-unit id="a7927a0abfa9b169083b1cb33b972375e669f367" translate="yes" xml:space="preserve">
          <source>XOR the result with h2.</source>
          <target state="translated">結果を h2 で XOR します。</target>
        </trans-unit>
        <trans-unit id="df90e78c7b7f1be042309f565b3a930a77da9bf6" translate="yes" xml:space="preserve">
          <source>You can compute the hash code from fields that are not mutable; or</source>
          <target state="translated">mutableではないフィールドからハッシュコードを計算することができます。</target>
        </trans-unit>
        <trans-unit id="7e0f5da3ef3eb98ebe66a0458acbe252a1335380" translate="yes" xml:space="preserve">
          <source>You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</source>
          <target state="translated">ハッシュコードに依存しているコレクションにオブジェクトが含まれている間は、変更可能なオブジェクトのハッシュコードが変更されないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="d14544f0139a010a5f0dfdedc09f3993f9ddda5c" translate="yes" xml:space="preserve">
          <source>You can override GetHashCode for immutable reference types. In general, for mutable reference types, you should override GetHashCode only if:</source>
          <target state="translated">不変参照型に対しては、GetHashCodeをオーバーライドすることができます。一般的には、変更可能な参照型の場合にのみ、GetHashCodeをオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="e8eb5c0af93ca2647da55c48e832b72309675a22" translate="yes" xml:space="preserve">
          <source>You can pass a string comparison that matches your equals implementation.</source>
          <target state="translated">等号の実装にマッチする文字列比較を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="70eae4f6b110439731d5eafcd9cbf8d01ea4d5bf" translate="yes" xml:space="preserve">
          <source>You can read the full blog post '&lt;a href=&quot;https://rehansaeed.com/gethashcode-made-easy/&quot;&gt;GetHashCode Made Easy&lt;/a&gt;' for more details and comments.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;詳細とコメントについては&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、完全なブログ投稿「&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rehansaeed.com/gethashcode-made-easy/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GetHashCode Made Easy&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;」をご覧ください。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e8dfb137940607558d3f7f402aaf01bf7d406d2" translate="yes" xml:space="preserve">
          <source>You may turn multiple values to a hashed value and some of them be same, so don't use it as an identifier. (maybe some day I am going to use your component)</source>
          <target state="translated">複数の値をハッシュ化して同じ値にすることもあるので、識別子としては使わないようにしましょう。(いつかあなたのコンポーネントを使おうと思っています)</target>
        </trans-unit>
        <trans-unit id="98658dbce77e0b4aea26c71003da55e305bd7c92" translate="yes" xml:space="preserve">
          <source>or like this:</source>
          <target state="translated">とかこんな感じで。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
