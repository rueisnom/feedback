<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/263400">
    <body>
      <group id="263400">
        <trans-unit id="0d79426d053942f788af84f9684d1aeab86b6544" translate="yes" xml:space="preserve">
          <source>&amp;Dagger;By way of comparison. If used on a string, the SpookyHash on 64 bits is considerably faster than &lt;code&gt;string.GetHashCode()&lt;/code&gt; on 32 bits which is slightly faster than &lt;code&gt;string.GetHashCode()&lt;/code&gt; on 64 bits, which is considerably faster than SpookyHash on 32 bits, though still fast enough to be a reasonable choice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;Dagger; A modo de comparaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si se usa en una cadena, SpookyHash en 64 bits es considerablemente m&amp;aacute;s r&amp;aacute;pido que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en 32 bits, que es ligeramente m&amp;aacute;s r&amp;aacute;pido que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en 64 bits, que es considerablemente m&amp;aacute;s r&amp;aacute;pido que SpookyHash en 32 bits, aunque todav&amp;iacute;a es r&amp;aacute;pido suficiente para ser una elecci&amp;oacute;n razonable.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83c2ef75ab5d9faef3f79684063ce016c8b50e49" translate="yes" xml:space="preserve">
          <source>&amp;dagger;&lt;code&gt;decimal&lt;/code&gt; isn't native from the .NET perspective though it is from the C#. The problem with it is that its own &lt;code&gt;GetHashCode()&lt;/code&gt; treats precision as significant while its own &lt;code&gt;Equals()&lt;/code&gt; does not. Both are valid choices, but not mixed like that. In implementing your own version, you need to choose to do one, or the other, but I can't know which you'd want.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;dagger; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no es nativo desde la perspectiva .NET, aunque s&amp;iacute; lo es desde C #. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El problema es que su propio &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; trata la precisi&amp;oacute;n como significativa, mientras que su propio &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Equals()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ambas son opciones v&amp;aacute;lidas, pero no se mezclan as&amp;iacute;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Al implementar su propia versi&amp;oacute;n, debe elegir hacer una u otra, pero no puedo saber cu&amp;aacute;l desea.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3df11bf9c11a994a6141e579ee8c87c906373481" translate="yes" xml:space="preserve">
          <source>(Note: The original technique using anonymous types seems to create an object on the heap, i.e. garbage, since anonymous types are implemented as classes, though this might be optimized out by the compiler. It would be interesting to benchmark these options, but the tuple option should be superior.)</source>
          <target state="translated">(Nota:La técnica original que utiliza tipos anónimos parece crear un objeto en el montón,es decir,basura,ya que los tipos anónimos se implementan como clases,aunque esto puede ser optimizado por el compilador.Sería interesante hacer un benchmark de estas opciones,pero la opción de la tupla debería ser superior).</target>
        </trans-unit>
        <trans-unit id="a3a2c16db35df35d2fe189e2fcca836853920a73" translate="yes" xml:space="preserve">
          <source>*A big surprise in this is that hand-inlining a rotation method that returned &lt;code&gt;(x &amp;lt;&amp;lt; n) | (x &amp;gt;&amp;gt; -n)&lt;/code&gt; improved things. I would have been sure that the jitter would have inlined that for me, but profiling showed otherwise.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* Una gran sorpresa en esto es que incluy&amp;oacute; a mano un m&amp;eacute;todo de rotaci&amp;oacute;n que devolvi&amp;oacute; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(x &amp;lt;&amp;lt; n) | (x &amp;gt;&amp;gt; -n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cosas mejoradas. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Habr&amp;iacute;a estado seguro de que la inquietud me habr&amp;iacute;a inculcado eso, pero el perfil mostr&amp;oacute; lo contrario.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95d42bc65b3b6a49d6e5b97cf8c89519a4d16ef8" translate="yes" xml:space="preserve">
          <source>.NET Standard 2.1 And Above</source>
          <target state="translated">.NET Standard 2.1 y superior</target>
        </trans-unit>
        <trans-unit id="237eebd45ff1ae0b4dc2e3a1f947162eb4d30120" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx&quot;&gt;This page&lt;/a&gt; gives quite a few options. I think for most cases the above is &quot;good enough&quot; and it's incredibly easy to remember and get right. The &lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx#fnv&quot;&gt;FNV&lt;/a&gt; alternative is similarly simple, but uses different constants and &lt;code&gt;XOR&lt;/code&gt; instead of &lt;code&gt;ADD&lt;/code&gt; as a combining operation. It looks &lt;em&gt;something&lt;/em&gt; like the code below, but the normal FNV algorithm operates on individual bytes, so this would require modifying to perform one iteration per byte, instead of per 32-bit hash value. FNV is also designed for variable lengths of data, whereas the way we're using it here is always for the same number of field values. Comments on this answer suggest that the code here doesn't actually work as well (in the sample case tested) as the addition approach above.</source>
          <target state="translated">&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta p&amp;aacute;gina&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ofrece bastantes opciones. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Creo que en la mayor&amp;iacute;a de los casos lo anterior es &quot;suficientemente bueno&quot; y es incre&amp;iacute;blemente f&amp;aacute;cil de recordar y acertar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;alternativa &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx#fnv&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNV&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es similarmente simple, pero usa diferentes constantes y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;XOR&lt;/code&gt; en&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lugar de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ADD&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como una operaci&amp;oacute;n de combinaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se ve &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;algo&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;como el c&amp;oacute;digo a continuaci&amp;oacute;n, pero el algoritmo FNV normal opera en bytes individuales, por lo que esto requerir&amp;iacute;a modificaciones para realizar una iteraci&amp;oacute;n por byte, en lugar de por valor hash de 32 bits. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNV tambi&amp;eacute;n est&amp;aacute; dise&amp;ntilde;ado para longitudes variables de datos, mientras que la forma en que lo estamos usando aqu&amp;iacute; es siempre para el mismo n&amp;uacute;mero de valores de campo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los comentarios sobre esta respuesta sugieren que el c&amp;oacute;digo aqu&amp;iacute; en realidad no funciona tan bien (en el caso de muestra probado) como el enfoque de adici&amp;oacute;n anterior.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dbfcc92679561cd466ca70d3ec5cb0ada4849da5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt; users can generate GetHashCode, Equals, and others with &lt;code&gt;ReSharper -&amp;gt; Edit -&amp;gt; Generate Code -&amp;gt; Equality Members&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; usuarios de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ReSharper&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; pueden generar GetHashCode, Equals y otros con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ReSharper -&amp;gt; Edit -&amp;gt; Generate Code -&amp;gt; Equality Members&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ea1ae0f0eb1ed12ed21ed926e7ffa399926aaaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueTuple&lt;/code&gt; is a struct and appears to have a solid &lt;code&gt;GetHashCode&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es una estructura y parece tener una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;implementaci&amp;oacute;n &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;s&amp;oacute;lida de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea0202aa9a3074625a51c3256d2dc385d6895a70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All the GetHashCode() implementations I'd coded in the past, and indeed used as the basis of answers on this site, were much worse than I'd throught&lt;/strong&gt;. Much of the time it was &quot;good enough&quot; for much of the uses, but I wanted something better.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Todas las implementaciones de GetHashCode () que codifiqu&amp;eacute; en el pasado, y que de hecho utilic&amp;eacute; como la base de las respuestas en este sitio, fueron mucho peores de lo que lo hab&amp;iacute;a hecho&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La mayor parte del tiempo fue &quot;lo suficientemente bueno&quot; para muchos de los usos, pero quer&amp;iacute;a algo mejor.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64737e14d176ba9cf426f44088eeac87333a7a89" translate="yes" xml:space="preserve">
          <source>A good hash function should map the expected inputs as evenly as possible over its output range. It should have uniformity.</source>
          <target state="translated">Una buena función de hash debe mapear las entradas esperadas de la manera más uniforme posible en su rango de salida.Debería tener uniformidad.</target>
        </trans-unit>
        <trans-unit id="0b087b0c644a46bd6641921114f7033df6978d64" translate="yes" xml:space="preserve">
          <source>A small change to a message should change the hash value so extensively that the new hash value appears uncorrelated with the old hash value (avalanche effect).</source>
          <target state="translated">Un pequeño cambio en un mensaje debería cambiar el valor de hash tan extensamente que el nuevo valor de hash aparezca sin correlación con el antiguo valor de hash (efecto de avalancha).</target>
        </trans-unit>
        <trans-unit id="bd1a4e418ac54c54625c46768d60dc7e55d97d21" translate="yes" xml:space="preserve">
          <source>Add the result and h1 together.</source>
          <target state="translated">Sume el resultado y h1 juntos.</target>
        </trans-unit>
        <trans-unit id="f1c118123f96f8220daec90522f3b96d0f84b028" translate="yes" xml:space="preserve">
          <source>Also it has extension method to provide a fluent interface, so you can use it like this:</source>
          <target state="translated">También tiene un método de extensión para proporcionar una interfaz fluida,así que puedes usarlo así:</target>
        </trans-unit>
        <trans-unit id="5924b5e6279dfd3f1ccd06d12d17ca745d917e31" translate="yes" xml:space="preserve">
          <source>And here is how to use it:</source>
          <target state="translated">Y así es como se usa:</target>
        </trans-unit>
        <trans-unit id="f7e8bccebca6d7ebf1c132bf64c36d31c8b3e398" translate="yes" xml:space="preserve">
          <source>And here is the acutal builder class:</source>
          <target state="translated">Y aquí está la clase de constructores de acutal:</target>
        </trans-unit>
        <trans-unit id="0b0c4ee6c49ec53c99f367f324f2d13f02203ef5" translate="yes" xml:space="preserve">
          <source>And it pretty much sucked. So after a bit of experimentation and research I started re-hashing my hashes with the following:</source>
          <target state="translated">Y fue bastante malo.Así que después de un poco de experimentación e investigación,empecé a remezclar mis hashis con lo siguiente:</target>
        </trans-unit>
        <trans-unit id="4753226d060c2ac7870ac15825cb98de476efddf" translate="yes" xml:space="preserve">
          <source>And one final tip: &lt;b&gt;Don't rely on GetHashCode() being stable over multiple aplication runs&lt;/b&gt;. Many .Net types don't guarantee their hash codes to stay the same after a restart, so you should only use the value of GetHashCode() for in memory data structures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y un consejo final: &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no conf&amp;iacute;e en que GetHashCode () sea estable en m&amp;uacute;ltiples ejecuciones de aplicaciones&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Muchos tipos .Net no garantizan que sus c&amp;oacute;digos hash permanezcan igual despu&amp;eacute;s de un reinicio, por lo que solo debe usar el valor de GetHashCode () para las estructuras de datos en memoria.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c910bf934a6df4c337ec4ebc5ec681c2f90542e" translate="yes" xml:space="preserve">
          <source>And same for multi-type: all converted first to &lt;code&gt;int&lt;/code&gt; using &lt;code&gt;GetHashCode()&lt;/code&gt;
then the int values will be xor'ed and the result is your hash.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y lo mismo para el tipo m&amp;uacute;ltiple: todos se convierten primero a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; usando &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; luego los valores int se modificar&amp;aacute;n y el resultado ser&amp;aacute; su hash.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d58afc915a407c9686d470da7d4718874579746d" translate="yes" xml:space="preserve">
          <source>And then my power-of-two hash table didn't suck any more.</source>
          <target state="translated">Y entonces mi mesa de hachís con poder de dos no apestaba más.</target>
        </trans-unit>
        <trans-unit id="e6524d5374d0dad18e089d93cca5b51530ed61a0" translate="yes" xml:space="preserve">
          <source>And this is from &lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/Common/src/System/Numerics/Hashing/HashHelpers.cs&quot;&gt;&lt;code&gt;HashHelper&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y esto es de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/Common/src/System/Numerics/Hashing/HashHelpers.cs&quot;&gt; &lt;code&gt;HashHelper&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6ea4b5d260d1757dfef473e91d4cdc426f950356" translate="yes" xml:space="preserve">
          <source>And well, it was disturbing how much the &lt;code&gt;string.GetHashCode()&lt;/code&gt; implementations in &lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/System/string.cs,789&quot;&gt;.NET&lt;/a&gt; (or study &lt;a href=&quot;https://stackoverflow.com/a/48775953/147511&quot;&gt;here&lt;/a&gt;) could be improved this way (on the order of tests running about 20-30 times faster due to fewer collisions) and more disturbing how much my own hash codes could be improved (much more than that).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y bueno, era inquietante la cantidad de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;implementaciones &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/System/string.cs,789&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (o estudio &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/48775953/147511&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) podr&amp;iacute;a mejorarse de esta manera (en el orden de las pruebas que se ejecutan aproximadamente 20-30 veces m&amp;aacute;s r&amp;aacute;pido debido a menos colisiones) y m&amp;aacute;s inquietante c&amp;oacute;mo mucho mis propios c&amp;oacute;digos hash podr&amp;iacute;an mejorarse (mucho m&amp;aacute;s que eso).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6539f8fb88e503a8b8c34ab6bcc63de114670a0b" translate="yes" xml:space="preserve">
          <source>Anonymous Type</source>
          <target state="translated">Tipo Anónimo</target>
        </trans-unit>
        <trans-unit id="2ef0204701e5a8adb4295eb5e9aa0eda969ef4cf" translate="yes" xml:space="preserve">
          <source>As @cactuaroid mentions in the comments, a value tuple can be used. This saves a few keystrokes and more importantly executes purely on the stack (no Garbage):</source>
          <target state="translated">Como @cactuaroid menciona en los comentarios,se puede utilizar una tupla de valores.Esto ahorra unas pocas pulsaciones de teclas y lo más importante es que se ejecuta puramente en la pila (no en la basura):</target>
        </trans-unit>
        <trans-unit id="4884ca4fdea316ef7d5a10917de179b44aefe544" translate="yes" xml:space="preserve">
          <source>As noted in comments, you may find it's better to pick a large prime to multiply by instead. Apparently 486187739 is good... and although most examples I've seen with small numbers tend to use primes, there are at least similar algorithms where non-prime numbers are often used. In the not-quite-&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function&quot;&gt;FNV&lt;/a&gt; example later, for example, I've used numbers which apparently work well - but the initial value isn't a prime. (The multiplication constant &lt;em&gt;is&lt;/em&gt; prime though. I don't know quite how important that is.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como se se&amp;ntilde;al&amp;oacute; en los comentarios, es posible que sea mejor elegir una prima grande para multiplicar por ella. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aparentemente, 486187739 es bueno ... y aunque la mayor&amp;iacute;a de los ejemplos que he visto con n&amp;uacute;meros peque&amp;ntilde;os tienden a usar n&amp;uacute;meros primos, existen al menos algoritmos similares en los que a menudo se usan n&amp;uacute;meros no primos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ejemplo &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no- &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNV&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; m&amp;aacute;s adelante, por ejemplo, he usado n&amp;uacute;meros que aparentemente funcionan bien, pero el valor inicial no es primo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Sin &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;embargo, la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;constante de multiplicaci&amp;oacute;n &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; primo. No s&amp;eacute; qu&amp;eacute; tan importante es eso).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0fc68588324515b00e71f04c950e60480e2bd553" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14863&quot;&gt;https://github.com/dotnet/coreclr/pull/14863&lt;/a&gt;, there is a new way to generate hash codes that is super simple! Just write</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A partir de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14863&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/dotnet/coreclr/pull/14863&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &amp;iexcl;hay una nueva forma de generar c&amp;oacute;digos hash que es s&amp;uacute;per simple! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Solo escribe&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ba8400d7c27eb6bbe485bddce2a770e9a59f458" translate="yes" xml:space="preserve">
          <source>As per the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode#notes-to-inheritors&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Seg&amp;uacute;n la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode#notes-to-inheritors&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;documentaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6490b278794b35f12336f32cce320e3a69acab63" translate="yes" xml:space="preserve">
          <source>Because of this feature, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection and they should never be persisted.</source>
          <target state="translated">Debido a esta característica,los códigos hash no deben utilizarse nunca fuera del dominio de la aplicación en la que se crearon,no deben utilizarse nunca como campos clave de una colección y no deben persistir.</target>
        </trans-unit>
        <trans-unit id="11b32f5445111f35152e714852144506ca1cb530" translate="yes" xml:space="preserve">
          <source>Because the Hash output is always an int, you can just chain Hash calls.</source>
          <target state="translated">Debido a que la salida de Hash es siempre un int,puedes encadenar las llamadas de Hash.</target>
        </trans-unit>
        <trans-unit id="2273bd2f117653a9c56bbd3e76317b35a2b4389b" translate="yes" xml:space="preserve">
          <source>But this test passes (with ints):</source>
          <target state="translated">Pero esta prueba pasa (con ints):</target>
        </trans-unit>
        <trans-unit id="f120da2cf0f973ab74313965e44c104c28715694" translate="yes" xml:space="preserve">
          <source>By the way, the earlier algorithm is the one currently used by the C# compiler for anonymous types.</source>
          <target state="translated">Por cierto,el algoritmo anterior es el que actualmente utiliza el compilador de C#para los tipos anónimos.</target>
        </trans-unit>
        <trans-unit id="28ec9ea2e98208ee3c50de6dbbd90da47726d6dc" translate="yes" xml:space="preserve">
          <source>Cryptographically Secure?</source>
          <target state="translated">¿Seguridad criptográfica?</target>
        </trans-unit>
        <trans-unit id="f6798670eccb448dbd7ae61707aed7700330e4b5" translate="yes" xml:space="preserve">
          <source>Deterministic</source>
          <target state="translated">Deterministic</target>
        </trans-unit>
        <trans-unit id="f399f567d30257913aa40c9a0b774a97589e3f6c" translate="yes" xml:space="preserve">
          <source>Edit (May 2018): &lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt; getter is now a JIT intrinsic - the &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14125&quot;&gt;pull request&lt;/a&gt; is mentioned by Stephen Toub in &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Editar (mayo de 2018): &lt;/font&gt;&lt;/font&gt; &lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; captador &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;predeterminado&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ahora es un JIT intr&amp;iacute;nseco: &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Stephen Toub menciona la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14125&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;solicitud de extracci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;esta publicaci&amp;oacute;n de blog&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f36d236cdfc72792355b5bd010191a1697cc8e21" translate="yes" xml:space="preserve">
          <source>Edit: I was also using open-addressing, which would also have increased the sensitivity to collision, perhaps more so than the fact it was power-of-two.</source>
          <target state="translated">Editar:También estaba usando el direccionamiento abierto,lo que también habría aumentado la sensibilidad a la colisión,tal vez más que el hecho de que fuera potencia de dos.</target>
        </trans-unit>
        <trans-unit id="ec3029c0ba715ec4e3b4ba579e691c099b1e661c" translate="yes" xml:space="preserve">
          <source>For each further item, perform the operation on the previous result and the next item (e.g. h2).</source>
          <target state="translated">Para cada elemento adicional,realice la operación sobre el resultado anterior y el siguiente elemento (por ejemplo,h2).</target>
        </trans-unit>
        <trans-unit id="4a750761886bb8c5c3093d7d8da1f358a99b7be3" translate="yes" xml:space="preserve">
          <source>For those who use hash as ID (I mean an unique value), hash is naturally limited to a number of digits, I think it was 5 bytes for hashing algorithm, at least MD5.</source>
          <target state="translated">Para los que usan el hash como identificación (me refiero a un valor único),el hash se limita naturalmente a un número de dígitos,creo que eran 5 bytes para el algoritmo de hash,al menos MD5.</target>
        </trans-unit>
        <trans-unit id="d8558f6652b3cfc7c3336ced510c7c2259ad7976" translate="yes" xml:space="preserve">
          <source>GetHashCode Made Easy</source>
          <target state="translated">Conseguir que el código HashCode sea fácil</target>
        </trans-unit>
        <trans-unit id="034396c26c5e4ebc5bd1068b7529411104222377" translate="yes" xml:space="preserve">
          <source>HashCode.Add</source>
          <target state="translated">HashCode.Add</target>
        </trans-unit>
        <trans-unit id="0ba1e0a5a4926cff0e03ebbdb6d52b7a661256e8" translate="yes" xml:space="preserve">
          <source>HashCode.Combine</source>
          <target state="translated">HashCode.Combine</target>
        </trans-unit>
        <trans-unit id="d38b35ccba9919ce8b5b43ef1cf490a7f721401d" translate="yes" xml:space="preserve">
          <source>Here is another fluent implementation of &lt;a href=&quot;https://stackoverflow.com/a/263416/33791&quot;&gt;the algorithm posted above by Jon Skeet&lt;/a&gt;, but which includes no allocations or boxing operations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; hay otra implementaci&amp;oacute;n fluida del &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/263416/33791&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;algoritmo publicado anteriormente por Jon Skeet&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero que no incluye asignaciones ni operaciones de boxeo:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b1e0b14247c35a0dd98e5ba0eb642e4dc1843c1" translate="yes" xml:space="preserve">
          <source>Here is my hashcode helper.</source>
          <target state="translated">Aquí está mi ayudante de hashcode.</target>
        </trans-unit>
        <trans-unit id="4be13d945c6ba718eeced4ba0389ce90b6ec6aa0" translate="yes" xml:space="preserve">
          <source>Here is my simplistic approach. I am using the classic builder pattern for this. It is typesafe (no boxing/unboxing) and also compatbile with .NET 2.0 (no extension methods etc.).</source>
          <target state="translated">Aquí está mi enfoque simplista.Estoy usando el patrón clásico de construcción para esto.Es seguro para los tipos (no boxeo,no boxeo)y también compatible con .NET 2.0 (sin métodos de extensión,etc.).</target>
        </trans-unit>
        <trans-unit id="b8b27f99a942c6d3ce3eb645ca556e3c906c83ac" translate="yes" xml:space="preserve">
          <source>Here's my helper class using &lt;a href=&quot;https://stackoverflow.com/a/263416/704144&quot;&gt;Jon Skeet's implementation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; est&amp;aacute; mi clase de ayuda usando &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/263416/704144&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la implementaci&amp;oacute;n de Jon Skeet&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83ac8a659ca4db3fa8d7dcfd4473a8c41782b2c9" translate="yes" xml:space="preserve">
          <source>However, since it's now already written, one can make use of it more easily:</source>
          <target state="translated">Sin embargo,como ya está escrito,se puede utilizar más fácilmente:</target>
        </trans-unit>
        <trans-unit id="8cf06bfeb7893297f5b466ba135ef3e5a8c8a67d" translate="yes" xml:space="preserve">
          <source>I can guess that for multiple big int you can use this:</source>
          <target state="translated">Puedo adivinar que para múltiples grandes intentes puedes usar esto:</target>
        </trans-unit>
        <trans-unit id="6341f744676fe64ec4e97c176de06ac114def865" translate="yes" xml:space="preserve">
          <source>I changed my implementation to not use GetHashCode for the primitive types and it seems to work better</source>
          <target state="translated">Cambié mi implementación para no usar GetHashCode para los tipos primitivos y parece funcionar mejor</target>
        </trans-unit>
        <trans-unit id="d44374f08bd16dc2acc4cd4ed9fad6603e35a2dc" translate="yes" xml:space="preserve">
          <source>I didn't assess its performance, so any feedback is welcomed.</source>
          <target state="translated">No he evaluado su rendimiento,así que cualquier comentario es bienvenido.</target>
        </trans-unit>
        <trans-unit id="3c7682f2756768262570b11ce2273bf6db42e85c" translate="yes" xml:space="preserve">
          <source>I have a Hashing class in Helper library that I use it for this purpose.</source>
          <target state="translated">Tengo una clase de Hashing en la biblioteca de Helper que uso para este propósito.</target>
        </trans-unit>
        <trans-unit id="79484108e32c6a21344a0d900482a48b2c630c8f" translate="yes" xml:space="preserve">
          <source>I ran into an issue with floats and decimals using the implementation selected as the answer above.</source>
          <target state="translated">Me encontré con un problema con los flotadores y los decimales usando la implementación seleccionada como la respuesta anterior.</target>
        </trans-unit>
        <trans-unit id="7eba8db330d45d66dcb0d37cd8b2aed9484677aa" translate="yes" xml:space="preserve">
          <source>I usually go with something like the implementation given in Josh Bloch's &lt;em&gt;fabulous&lt;/em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;Effective Java&lt;/a&gt;. It's fast and creates a pretty good hash which is unlikely to cause collisions. Pick two different prime numbers, e.g. 17 and 23, and do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo general, voy con algo como la implementaci&amp;oacute;n dada en el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;fabuloso &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java eficaz de&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Josh Bloch &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es r&amp;aacute;pido y crea un hash bastante bueno que es poco probable que cause colisiones. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Elija dos n&amp;uacute;meros primos diferentes, por ejemplo, 17 y 23, y haga:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecd4a4ee6fb901f76f58984b6c90616cf19d910c" translate="yes" xml:space="preserve">
          <source>If we have no more than 8 properties (hopefully), here is another alternative.</source>
          <target state="translated">Si no tenemos más de 8 propiedades (con suerte),aquí hay otra alternativa.</target>
        </trans-unit>
        <trans-unit id="51e61bd0902dd12fd8399d10c1dfc7edf6c2bc67" translate="yes" xml:space="preserve">
          <source>If you are using .NET Standard 2.1 or above, you can use the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.hashcode?view=netcore-2.1&quot;&gt;System.HashCode&lt;/a&gt; struct. There are two methods of using it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si est&amp;aacute; utilizando .NET Standard 2.1 o superior, puede usar la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;estructura &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.hashcode?view=netcore-2.1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.HashCode&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay dos m&amp;eacute;todos para usarlo:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7195ac0e83ef4a6feddbd250bff1ae20963d1157" translate="yes" xml:space="preserve">
          <source>If you want to avoid writing an extension method for System.Int32:</source>
          <target state="translated">Si quieres evitar escribir un método de extensión para System.Int32:</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="6488742a860c14ecbed74fa734de70954bb71e77" translate="yes" xml:space="preserve">
          <source>In .NET Core each time you restart an application you will get different hash codes. This is a security feature to prevent Denial of Service attacks (DoS). For .NET Framework you &lt;strong&gt;should&lt;/strong&gt; enable this feature by adding the following App.config file:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En .NET Core cada vez que reinicia una aplicaci&amp;oacute;n obtendr&amp;aacute; diferentes c&amp;oacute;digos hash. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta es una caracter&amp;iacute;stica de seguridad para evitar ataques de denegaci&amp;oacute;n de servicio (DoS). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para .NET Framework, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;debe&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; habilitar esta caracter&amp;iacute;stica agregando el siguiente archivo App.config:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4738d896b60dfae58b5b259b003bf59cce6e20b" translate="yes" xml:space="preserve">
          <source>In .NET, the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode&quot;&gt;&lt;code&gt;GetHashCode&lt;/code&gt; method&lt;/a&gt; is used in a lot of places throughout the .NET base class libraries. Implementing it properly is especially important to find items quickly in a collection or when determining equality.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En .NET, el &lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/a&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se usa en muchos lugares en las bibliotecas de clases base .NET. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Implementarlo adecuadamente es especialmente importante para encontrar elementos r&amp;aacute;pidamente en una colecci&amp;oacute;n o al determinar la igualdad.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d045e350842340848d745e65b9ccc9cf28237c03" translate="yes" xml:space="preserve">
          <source>In English:</source>
          <target state="translated">En inglés:</target>
        </trans-unit>
        <trans-unit id="66db6221d3fcbac7088e96ff309ffb23cfb5ad58" translate="yes" xml:space="preserve">
          <source>In case you want to polyfill &lt;code&gt;HashCode&lt;/code&gt; from &lt;code&gt;netstandard2.1&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En caso de que quiera polyfill &lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;netstandard2.1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c40e2b1801b414478c669a008b937281f4d2dc69" translate="yes" xml:space="preserve">
          <source>In most cases where Equals() compares multiple fields it doesn't really matter if your GetHash() hashes on one field or on many. You just have to make sure that calculating the hash is really cheap (&lt;b&gt;No allocations&lt;/b&gt;, please) and fast (&lt;b&gt;No heavy computations&lt;/b&gt; and certainly no database connections) and provides a good distribution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En la mayor&amp;iacute;a de los casos en los que Equals () compara m&amp;uacute;ltiples campos, realmente no importa si su GetHash () tiene hash en un campo o en muchos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Solo tiene que asegurarse de que calcular el hash sea realmente barato ( &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sin asignaciones&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por favor) y r&amp;aacute;pido ( &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sin c&amp;aacute;lculos pesados&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y ciertamente sin conexiones de base de datos) y que proporcione una buena distribuci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70f850b780b4ffb79b7c73fda1edcded2180b380" translate="yes" xml:space="preserve">
          <source>In the end I settled on porting &lt;a href=&quot;http://burtleburtle.net/bob/hash/spooky.html&quot;&gt;SpookyHash&lt;/a&gt; to .NET. Indeed the code above is a fast-path version of using SpookyHash to produce a 32-bit output from a 32-bit input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Al final me &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://burtleburtle.net/bob/hash/spooky.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;decid&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;portar &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SpookyHash&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a .NET. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De hecho, el c&amp;oacute;digo anterior es una versi&amp;oacute;n de ruta r&amp;aacute;pida del uso de SpookyHash para producir una salida de 32 bits a partir de una entrada de 32 bits.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6243d71d1d7b8aea75619231aad11f8259651c82" translate="yes" xml:space="preserve">
          <source>Is there a standard algorithm or best practice on how to implement &lt;code&gt;GetHashCode&lt;/code&gt; for my custom classes so I don't degrade performance?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Existe un algoritmo est&amp;aacute;ndar o una mejor pr&amp;aacute;ctica sobre c&amp;oacute;mo implementar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para mis clases personalizadas para no degradar el rendimiento?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79e480f23d6c2078c87bb12c8c5c3744c8de3f93" translate="yes" xml:space="preserve">
          <source>It also takes seed values, so if you need to deal with untrusted input and want to protect against Hash DoS attacks you can set a seed based on uptime or similar, and make the results unpredictable by attackers:</source>
          <target state="translated">También toma valores de semilla,así que si necesitas lidiar con entradas no confiables y quieres protegerte contra los ataques de Hash DoS,puedes establecer una semilla basada en el tiempo de funcionamiento o similar,y hacer que los resultados sean impredecibles para los atacantes:</target>
        </trans-unit>
        <trans-unit id="1cca014cbc07e3c62667a380b70f66b34a5849ca" translate="yes" xml:space="preserve">
          <source>It is infeasible to find two different messages with the same hash value</source>
          <target state="translated">Es inviable encontrar dos mensajes diferentes con el mismo valor de hash</target>
        </trans-unit>
        <trans-unit id="24065692dc06162d306ce6a1810804d176e738bc" translate="yes" xml:space="preserve">
          <source>It is infeasible to generate a message that yields a given hash value</source>
          <target state="translated">Es inviable generar un mensaje que produzca un valor hash determinado</target>
        </trans-unit>
        <trans-unit id="3e7c0769beb54d29fef29e364d96abec5127a859" translate="yes" xml:space="preserve">
          <source>It is used like this:</source>
          <target state="translated">Se usa así:</target>
        </trans-unit>
        <trans-unit id="775120da70c32a3d1145975d3b0b7ece50d6c047" translate="yes" xml:space="preserve">
          <source>It still avoids any heap allocation and is used exactly the same way:</source>
          <target state="translated">Aún así,evita cualquier asignación de pila y se utiliza exactamente de la misma manera:</target>
        </trans-unit>
        <trans-unit id="af44925b98c54411762b5e115d90694d80c037bb" translate="yes" xml:space="preserve">
          <source>It would be nice to know more about the properties of this ROL-5 hash code algorithm.</source>
          <target state="translated">Sería bueno saber más sobre las propiedades de este algoritmo de código hash ROL-5.</target>
        </trans-unit>
        <trans-unit id="cd73c970707454efb2b115cd12e169fd1fb86e9f" translate="yes" xml:space="preserve">
          <source>It's advantage is that it uses generic type arguments and therefore will not cause boxing:</source>
          <target state="translated">Su ventaja es que utiliza argumentos de tipo genérico y por lo tanto no causará boxeo:</target>
        </trans-unit>
        <trans-unit id="f183efea3aaad2350f821613ad659f9d94954a53" translate="yes" xml:space="preserve">
          <source>It's fast, for which Bob Jenkins deserves most of the credit because his original code I ported from is faster still, especially on 64-bit machines which the algorithm is optimised for&amp;Dagger;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es r&amp;aacute;pido, por lo que Bob Jenkins merece la mayor parte del cr&amp;eacute;dito porque su c&amp;oacute;digo original del que lo port&amp;eacute; es a&amp;uacute;n m&amp;aacute;s r&amp;aacute;pido, especialmente en m&amp;aacute;quinas de 64 bits para las cuales el algoritmo est&amp;aacute; optimizado &amp;Dagger;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db3b9d4536e07c34bc7e78f6730f683ac59ee7c3" translate="yes" xml:space="preserve">
          <source>Left rotate (circular shift) h1 by 5 positions.</source>
          <target state="translated">Giro a la izquierda (desplazamiento circular)h1 por 5 posiciones.</target>
        </trans-unit>
        <trans-unit id="9befb5f7f42c778c9ce669275d1ce6ed000d3ae9" translate="yes" xml:space="preserve">
          <source>Let's take a look at .NET Core's current implementation for &lt;code&gt;ValueTuple&lt;/code&gt;'s &lt;code&gt;GetHashCode&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Vamos a echar un vistazo a la aplicaci&amp;oacute;n actual de .NET Core para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 's &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0cf40c5cdf4e24892afe91b39db417c88cd24a93" translate="yes" xml:space="preserve">
          <source>Microsoft already provides a good generic HashCode generator: Just copy your property/field values to an anonymous type and hash it:</source>
          <target state="translated">Microsoft ya proporciona un buen generador genérico de HashCode:Sólo copia los valores de tu campo de propiedad a un tipo anónimo y lo hash:</target>
        </trans-unit>
        <trans-unit id="fe5e8cabf2e9ef3c90856c23a3b071fc8ffdadc2" translate="yes" xml:space="preserve">
          <source>Microsoft lead for several way of hashing...</source>
          <target state="translated">Microsoft lleva la delantera en varias formas de hashing...</target>
        </trans-unit>
        <trans-unit id="778fc4e9438d8fe69ff04d1a23db7d2a638261a0" translate="yes" xml:space="preserve">
          <source>Most of my work is done with database connectivity which means that my classes all have a unique identifier from the database.  I always use the ID from the database to generate the hashcode.</source>
          <target state="translated">La mayor parte de mi trabajo se hace con la conectividad de la base de datos,lo que significa que todas mis clases tienen un identificador único de la base de datos.Siempre utilizo el identificador de la base de datos para generar el hashcode.</target>
        </trans-unit>
        <trans-unit id="ebe8b198579b5d8d43b5b5961017777a829df670" translate="yes" xml:space="preserve">
          <source>Note that one thing to be aware of is that ideally you should prevent your equality-sensitive (and thus hashcode-sensitive) state from changing after adding it to a collection that depends on the hash code.</source>
          <target state="translated">Tenga en cuenta que una cosa a tener en cuenta es que lo ideal es evitar que su estado sensible a la igualdad (y por lo tanto sensible al código hash)cambie después de añadirlo a una colección que depende del código hash.</target>
        </trans-unit>
        <trans-unit id="94d46ec70da897d6695de00bf38d36857c1d2fb5" translate="yes" xml:space="preserve">
          <source>Note: If used with &lt;code&gt;struct&lt;/code&gt;, it will allocate memory due to boxing</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nota: Si se usa con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , asignar&amp;aacute; memoria debido al boxeo&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5ac46a74dbff2b805e8a5a7d2626d1c776b451a" translate="yes" xml:space="preserve">
          <source>Now, SpookyHash is not a nice quick to remember piece of code. My port of it is even less so because I hand-inlined a lot of it for better speed*. But that's what code reuse is for.</source>
          <target state="translated">Ahora,SpookyHash no es una pieza de código fácil de recordar.Mi puerto de él es aún menos,porque lo he escrito a mano para mejorar la velocidad.Pero para eso es la reutilización del código.</target>
        </trans-unit>
        <trans-unit id="c849d5abd7981416f7339aea0af9b86419c5d93c" translate="yes" xml:space="preserve">
          <source>PS: This is one of those times where you puke a little in your mouth, knowing that this could be refactored into one method with 9 default's but it would be slower, so you just close your eyes and try to forget about it.</source>
          <target state="translated">PD:Esta es una de esas veces en las que vomitas un poco en la boca,sabiendo que esto podría ser refactorizado en un método con 9 predeterminados pero sería más lento,así que simplemente cierras los ojos y tratas de olvidarlo.</target>
        </trans-unit>
        <trans-unit id="f065fd929e1c22be435487e6ea63fce4d6e76802" translate="yes" xml:space="preserve">
          <source>Pretty much similar to nightcoder's solution except it's easier to raise primes if you want to.</source>
          <target state="translated">Bastante similar a la solución del codificador nocturno,excepto que es más fácil criar primos si quieres.</target>
        </trans-unit>
        <trans-unit id="3595239fc3035d9f6e9e92d99a2bfdc06c060789" translate="yes" xml:space="preserve">
          <source>Prevent's DoS</source>
          <target state="translated">El DoS de Prevent</target>
        </trans-unit>
        <trans-unit id="b64211794d8e7415e42a8db9c7d0b1a28f11fc41" translate="yes" xml:space="preserve">
          <source>Re-mixing a hash code can only improve a hash code that did at least fairly well in avoiding absolute collisions throughout its range (2&lt;sup&gt;32&lt;/sup&gt; possible values) but badly at avoiding collisions when modulo'd down for actual use in a hash table. While the simpler modulo of a power-of-two table made this more apparent, it was also having a negative effect with the more common prime-number tables, that just wasn't as obvious (the extra work in rehashing would outweigh the benefit, but the benefit would still be there).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Remezclar un c&amp;oacute;digo hash solo puede mejorar un c&amp;oacute;digo hash que funcion&amp;oacute; al menos bastante bien para evitar colisiones absolutas en todo su rango (2 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;32&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; valores posibles) pero mal para evitar colisiones cuando el m&amp;oacute;dulo est&amp;aacute; inactivo para uso real en una tabla hash. Si bien el m&amp;oacute;dulo m&amp;aacute;s simple de una tabla de potencia de dos lo hizo m&amp;aacute;s evidente, tambi&amp;eacute;n estaba teniendo un efecto negativo con las tablas de n&amp;uacute;meros primos m&amp;aacute;s comunes, eso no era tan obvio (el trabajo adicional en la repetici&amp;oacute;n superar&amp;iacute;a el beneficio , pero el beneficio a&amp;uacute;n estar&amp;iacute;a all&amp;iacute;).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fce0fc5a7dcd2e788a03afe8194230572d482cb6" translate="yes" xml:space="preserve">
          <source>Re-mixing a hash code can't improve a terrible hash code, because the only possible effect is we change e.g. a large number of collisions on value 53 to a large number of value 18,3487,291.</source>
          <target state="translated">La remezcla de un código hash no puede mejorar un terrible código hash,porque el único efecto posible es que cambiamos,por ejemplo,un gran número de colisiones en el valor 53 a un gran número de valor 18.3487.291.</target>
        </trans-unit>
        <trans-unit id="3c9638d7db05fd5da4a874b5d52071ce2087a80e" translate="yes" xml:space="preserve">
          <source>Re-mixing a hashcode can't improve a great hashcode, because the only possible effect is that we introduce a few more collisions.</source>
          <target state="translated">Re-mezclar un hashcode no puede mejorar un gran hashcode,porque el único efecto posible es que introduzcamos unas cuantas colisiones más.</target>
        </trans-unit>
        <trans-unit id="af1c5729918a7c13189ba3df1d45ae50f208a20f" translate="yes" xml:space="preserve">
          <source>Read more about this &lt;a href=&quot;https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lea m&amp;aacute;s sobre esto &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="555fb017bb0db82e04dccc34f592057fdb765838" translate="yes" xml:space="preserve">
          <source>Reduce Collisions</source>
          <target state="translated">Reducir las colisiones</target>
        </trans-unit>
        <trans-unit id="c67f54eca7526ba65a1d69b5e9d8b38b3f5067f1" translate="yes" xml:space="preserve">
          <source>Regrettably, deferring to &lt;code&gt;ValueTuple&lt;/code&gt; for our own &lt;code&gt;GetHashCode&lt;/code&gt; may not be as fast as we would like and expect. &lt;a href=&quot;https://github.com/dotnet/corefx/issues/8034#issuecomment-260759796&quot;&gt;This comment&lt;/a&gt; in a related discussion illustrates that directly calling &lt;code&gt;HashHelpers.Combine&lt;/code&gt; is more performant. On the flip side, that one is internal, so we'd have to copy the code, sacrificing much of what we had gained here. Also, we'd be responsible for remembering to first &lt;code&gt;Combine&lt;/code&gt; with the random seed. I don't know what the consequences are if we skip that step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lamentablemente, diferir a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para nuestro propio &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puede no ser tan r&amp;aacute;pido como nos gustar&amp;iacute;a y esperar. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/issues/8034#issuecomment-260759796&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Este comentario&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en una discusi&amp;oacute;n relacionada ilustra que llamar directamente a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashHelpers.Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es m&amp;aacute;s &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;eficaz&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por otro lado, ese es interno, por lo que tendr&amp;iacute;amos que copiar el c&amp;oacute;digo, sacrificando gran parte de lo que hab&amp;iacute;amos ganado aqu&amp;iacute;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s, ser&amp;iacute;amos responsables de recordar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; primero &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;con la semilla aleatoria. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No s&amp;eacute; cu&amp;aacute;les son las consecuencias si omitimos ese paso.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="41ef8b26263345cca597a7e0aa739b815f3e2403" translate="yes" xml:space="preserve">
          <source>So I put that project to one side (it was a pet project anyway) and started looking at how to produce a good, well-distributed hash code in .NET quickly.</source>
          <target state="translated">Así que dejé de lado ese proyecto (era un proyecto favorito de todos modos)y empecé a mirar cómo producir un buen código hash bien distribuido en .NET rápidamente.</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="6b05d1dc7e9a6f239a0395230da12be3bfb344e6" translate="yes" xml:space="preserve">
          <source>Start by performing the above operation on { static random seed, h1 }.</source>
          <target state="translated">Comienza realizando la operación anterior en {semilla aleatoria estática,h1 }.</target>
        </trans-unit>
        <trans-unit id="5e0f2002957c60cee86ff8251ef135dcad849b56" translate="yes" xml:space="preserve">
          <source>That means we could simply do this:</source>
          <target state="translated">Eso significa que podríamos simplemente hacer esto:</target>
        </trans-unit>
        <trans-unit id="826b9d7df4ba107a7469f426428004097d06f89b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Add&lt;/code&gt; method helps you to deal with collections:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Add&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; te ayuda a manejar colecciones:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60a068f9545ee721c0e80f6ad49baf4bb1d421b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Combine&lt;/code&gt; method can be used to create a hash code, given up to eight objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se puede usar para crear un c&amp;oacute;digo hash, dado hasta ocho objetos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d787f0415844ae018bcf56dbf50989dcd7b9f11" translate="yes" xml:space="preserve">
          <source>The algorithm does not have to be a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;Cryptographic hash function&lt;/a&gt;. Meaning it does not have to satisfy the following conditions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El algoritmo no tiene que ser una &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n hash criptogr&amp;aacute;fica&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo que significa que no tiene que cumplir las siguientes condiciones:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ac5541f8c7461f7bcb249fb14bcc008335a3fce" translate="yes" xml:space="preserve">
          <source>The algorithm that calculates a hash code needs to be fast. A simple algorithm is usually going to be a faster one.</source>
          <target state="translated">El algoritmo que calcula un código hash tiene que ser rápido.Un algoritmo simple normalmente va a ser más rápido.</target>
        </trans-unit>
        <trans-unit id="045833a0e2d683cb1e8c1b7d651bc273a8823621" translate="yes" xml:space="preserve">
          <source>The algorithm that calculates a hash code needs to keep &lt;a href=&quot;http://crppit.epfl.ch/documentation/Hash_Function/WiKi/Hash_collision.htm&quot;&gt;hash collisions&lt;/a&gt; to a minumum. A hash collision is a situation that occurs when two calls to &lt;code&gt;GetHashCode&lt;/code&gt; on two different objects produce identical hash codes. Note that collisions are allowed (some have the misconceptions that they are not) but they should be kept to a minimum.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El algoritmo que calcula un c&amp;oacute;digo hash necesita mantener las &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://crppit.epfl.ch/documentation/Hash_Function/WiKi/Hash_collision.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;colisiones hash&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a un m&amp;iacute;nimo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una colisi&amp;oacute;n hash es una situaci&amp;oacute;n que ocurre cuando dos llamadas a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en dos objetos diferentes producen c&amp;oacute;digos hash id&amp;eacute;nticos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tenga en cuenta que las colisiones est&amp;aacute;n permitidas (algunas tienen la idea err&amp;oacute;nea de que no lo est&amp;aacute;n), pero deben mantenerse al m&amp;iacute;nimo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d740feb71d0fbf0408f6a65db8c993a4ea6592a0" translate="yes" xml:space="preserve">
          <source>The compiler will ensure &lt;code&gt;HashValue&lt;/code&gt; is not called with a class due to the generic type constraint. But there is no compiler support for &lt;code&gt;HashObject&lt;/code&gt; since adding a generic argument also adds a boxing operation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El compilador se asegurar&amp;aacute; de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;que no se llame a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashValue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con una clase debido a la restricci&amp;oacute;n de tipo gen&amp;eacute;rico. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero no hay soporte de compilador para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya que agregar un argumento gen&amp;eacute;rico tambi&amp;eacute;n agrega una operaci&amp;oacute;n de boxeo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa6cbb4a7d0cfa141362b4605fb3b5044a8ac454" translate="yes" xml:space="preserve">
          <source>The full code can be seen at &lt;a href=&quot;https://bitbucket.org/JonHanna/spookilysharp/src&quot;&gt;https://bitbucket.org/JonHanna/spookilysharp/src&lt;/a&gt; but consider that the code above is a simplified version of it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El c&amp;oacute;digo completo se puede ver en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://bitbucket.org/JonHanna/spookilysharp/src&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://bitbucket.org/JonHanna/spookilysharp/src,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; pero considere que el c&amp;oacute;digo anterior es una versi&amp;oacute;n simplificada.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6aea3a389963dd3279922dd6f8068aa1b709c3a3" translate="yes" xml:space="preserve">
          <source>The hashing algorithm needs to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;deterministic&lt;/a&gt; i.e. given the same input it must always produce the same output.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El algoritmo de hashing debe ser &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;determinista,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es decir, dada la misma entrada, siempre debe producir la misma salida.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74843c914e569e3d934ad75c40cd9c55a7c17747" translate="yes" xml:space="preserve">
          <source>The heavy lifting should be part of the Equals() method; the hash should be a very cheap operation to enable calling Equals() on as few items as possible.</source>
          <target state="translated">El levantamiento pesado debe ser parte del método Equals();el hash debe ser una operación muy barata para permitir llamar a Equals()en el menor número de artículos posible.</target>
        </trans-unit>
        <trans-unit id="6a3bc6502919f9edd3fdb6c625b410c86d7f8039" translate="yes" xml:space="preserve">
          <source>Then I came back, and produced a lot of overloads to easily feed just about all of the native types (except &lt;code&gt;decimal&lt;/code&gt;&amp;dagger;) into a hash code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego volv&amp;iacute; y produje muchas sobrecargas para alimentar f&amp;aacute;cilmente casi todos los tipos nativos (excepto el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;dagger;) en un c&amp;oacute;digo hash.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7483c49e6eb98b52f32043abddc6764971dca6b" translate="yes" xml:space="preserve">
          <source>Then I put &lt;em&gt;that&lt;/em&gt; project to one side, because just as the original project had produced the question of how to produce a better hash code, so that project produced the question of how to produce a better .NET memcpy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego puse &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ese&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; proyecto a un lado, porque as&amp;iacute; como el proyecto original hab&amp;iacute;a producido la pregunta de c&amp;oacute;mo producir un mejor c&amp;oacute;digo hash, ese proyecto produjo la pregunta de c&amp;oacute;mo producir una mejor memoria .NET.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8a3dd62d6429a57deee1938c2b8d63f6dec90e7d" translate="yes" xml:space="preserve">
          <source>Then, simply you can use it as:</source>
          <target state="translated">Entonces,simplemente puedes usarlo como:</target>
        </trans-unit>
        <trans-unit id="75cffc3515bdc95dc9b22f8fed1ab2f02044fac8" translate="yes" xml:space="preserve">
          <source>This disturbed me though, because the above shouldn't work. Or more precisely, it shouldn't work unless the original &lt;code&gt;GetHashCode()&lt;/code&gt; was poor in a very particular way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, esto me molest&amp;oacute;, porque lo anterior no deber&amp;iacute;a funcionar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O m&amp;aacute;s precisamente, no deber&amp;iacute;a funcionar a menos que el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; original &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;fuera pobre de una manera muy particular.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="516e8a7deb0de8522dade038b929c0204312d476" translate="yes" xml:space="preserve">
          <source>This is a good one:</source>
          <target state="translated">Este es uno bueno:</target>
        </trans-unit>
        <trans-unit id="1c7c1850d93fc274a256ffc70245af28400631ac" translate="yes" xml:space="preserve">
          <source>This is a static helper class that implements Josh Bloch's implementation; and provides explicit overloads to &quot;prevent&quot; boxing, and also to implement the hash specifically for the long primitives.</source>
          <target state="translated">Esta es una clase de ayuda estática que implementa la implementación de Josh Bloch;y proporciona sobrecargas explícitas para &quot;prevenir&quot; el boxeo,y también para implementar el hash específicamente para los primitivos largos.</target>
        </trans-unit>
        <trans-unit id="1307b741efe8c22ab33dd11c4f9ced9d341c0aa2" translate="yes" xml:space="preserve">
          <source>This is better than the common practice of &lt;code&gt;XOR&lt;/code&gt;ing hashcodes for two main reasons. Suppose we have a type with two &lt;code&gt;int&lt;/code&gt; fields:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto es mejor que la pr&amp;aacute;ctica com&amp;uacute;n de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;los c&amp;oacute;digos hash &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;XOR&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; por dos razones principales. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Supongamos que tenemos un tipo con dos &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;campos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e70ae20c9fb580d40ebc1c00d330f1f1135e294b" translate="yes" xml:space="preserve">
          <source>This is from &lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.ValueTuple/src/System/ValueTuple/ValueTuple.cs&quot;&gt;&lt;code&gt;ValueTuple&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto es de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.ValueTuple/src/System/ValueTuple/ValueTuple.cs&quot;&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d3c7ae92d1ff5acbdfec20e8c34d0f9543966a2" translate="yes" xml:space="preserve">
          <source>This test fails (floats; hash is the same even though I switched 2 values to be negative):</source>
          <target state="translated">Esta prueba falla (flota;el hachís es el mismo aunque cambié 2 valores para que fueran negativos):</target>
        </trans-unit>
        <trans-unit id="3c9c751854ebebe052bd9ac39e701ac7f3ee9751" translate="yes" xml:space="preserve">
          <source>This will generate a quality hash code without you having to worry about the implementation details.</source>
          <target state="translated">Esto generará un código hash de calidad sin que tengas que preocuparte por los detalles de implementación.</target>
        </trans-unit>
        <trans-unit id="2273401922a7ec31a62bf4c06628a6050af299e8" translate="yes" xml:space="preserve">
          <source>This will work for any number of properties. It does not use boxing. It just uses the algorithm already implemented in the framework for anonymous types.</source>
          <target state="translated">Esto funcionará para cualquier número de propiedades.No utiliza el boxeo.Sólo usa el algoritmo ya implementado en el marco para tipos anónimos.</target>
        </trans-unit>
        <trans-unit id="d9d9e2f475ad3bfe496517e55d50603c286f604d" translate="yes" xml:space="preserve">
          <source>Up until recently my answer would have been very close to Jon Skeet's here. However, I recently started a project which used power-of-two hash tables, that is hash tables where the size of the internal table is 8, 16, 32, etc. There's a good reason for favouring prime-number sizes, but there are some advantages to power-of-two sizes too.</source>
          <target state="translated">Hasta hace poco mi respuesta habría estado muy cerca de la de Jon Skeet aquí.Sin embargo,recientemente he comenzado un proyecto que utiliza el poder de dos mesas de hachís,es decir,mesas de hachís donde el tamaño de la mesa interna es de 8,16,32,etc.Hay una buena razón para favorecer los tamaños de números primos,pero también hay algunas ventajas en los tamaños de potencia de dos.</target>
        </trans-unit>
        <trans-unit id="342c659777997bec12f413246e5e24d6a8317e2a" translate="yes" xml:space="preserve">
          <source>Usage Example</source>
          <target state="translated">Ejemplo de uso</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="b33d830517aea3e2d9bb3019a44d1af09654b9ae" translate="yes" xml:space="preserve">
          <source>ValueTuple - Update for C# 7</source>
          <target state="translated">ValueTuple-Actualización para C#7</target>
        </trans-unit>
        <trans-unit id="7f47afe10930417b5ac38c0d4b812852c49176ff" translate="yes" xml:space="preserve">
          <source>What Makes a Good Algorithm?</source>
          <target state="translated">¿Qué hace un buen algoritmo?</target>
        </trans-unit>
        <trans-unit id="38242dbf222f22cf8723209c1d4c037f60de436c" translate="yes" xml:space="preserve">
          <source>What is the best algorithm for overriding GetHashCode</source>
          <target state="translated">¿Cuál es el mejor algoritmo para anular el GetHashCode</target>
        </trans-unit>
        <trans-unit id="a7927a0abfa9b169083b1cb33b972375e669f367" translate="yes" xml:space="preserve">
          <source>XOR the result with h2.</source>
          <target state="translated">XOR el resultado con h2.</target>
        </trans-unit>
        <trans-unit id="df90e78c7b7f1be042309f565b3a930a77da9bf6" translate="yes" xml:space="preserve">
          <source>You can compute the hash code from fields that are not mutable; or</source>
          <target state="translated">Puedes calcular el código hash de los campos que no son mutables;o</target>
        </trans-unit>
        <trans-unit id="7e0f5da3ef3eb98ebe66a0458acbe252a1335380" translate="yes" xml:space="preserve">
          <source>You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</source>
          <target state="translated">Puede asegurarse de que el código hash de un objeto mutable no cambie mientras el objeto esté contenido en una colección que se basa en su código hash.</target>
        </trans-unit>
        <trans-unit id="d14544f0139a010a5f0dfdedc09f3993f9ddda5c" translate="yes" xml:space="preserve">
          <source>You can override GetHashCode for immutable reference types. In general, for mutable reference types, you should override GetHashCode only if:</source>
          <target state="translated">Puedes anular GetHashCode para tipos de referencia inmutables.En general,para los tipos de referencia mutables,debes anular GetHashCode sólo si:</target>
        </trans-unit>
        <trans-unit id="e8eb5c0af93ca2647da55c48e832b72309675a22" translate="yes" xml:space="preserve">
          <source>You can pass a string comparison that matches your equals implementation.</source>
          <target state="translated">Puedes pasar una comparación de cadenas que coincida con la implementación de tus iguales.</target>
        </trans-unit>
        <trans-unit id="70eae4f6b110439731d5eafcd9cbf8d01ea4d5bf" translate="yes" xml:space="preserve">
          <source>You can read the full blog post '&lt;a href=&quot;https://rehansaeed.com/gethashcode-made-easy/&quot;&gt;GetHashCode Made Easy&lt;/a&gt;' for more details and comments.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede leer la publicaci&amp;oacute;n completa del blog ' &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rehansaeed.com/gethashcode-made-easy/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GetHashCode Made Easy&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ' para obtener m&amp;aacute;s detalles y comentarios.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e8dfb137940607558d3f7f402aaf01bf7d406d2" translate="yes" xml:space="preserve">
          <source>You may turn multiple values to a hashed value and some of them be same, so don't use it as an identifier. (maybe some day I am going to use your component)</source>
          <target state="translated">Puedes convertir múltiples valores en un valor de hash y algunos de ellos son iguales,así que no lo uses como identificador.(tal vez algún día voy a usar tu componente)</target>
        </trans-unit>
        <trans-unit id="98658dbce77e0b4aea26c71003da55e305bd7c92" translate="yes" xml:space="preserve">
          <source>or like this:</source>
          <target state="translated">o así:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
