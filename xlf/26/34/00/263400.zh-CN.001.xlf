<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/263400">
    <body>
      <group id="263400">
        <trans-unit id="0d79426d053942f788af84f9684d1aeab86b6544" translate="yes" xml:space="preserve">
          <source>&amp;Dagger;By way of comparison. If used on a string, the SpookyHash on 64 bits is considerably faster than &lt;code&gt;string.GetHashCode()&lt;/code&gt; on 32 bits which is slightly faster than &lt;code&gt;string.GetHashCode()&lt;/code&gt; on 64 bits, which is considerably faster than SpookyHash on 32 bits, though still fast enough to be a reasonable choice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;Dagger;通过比较的方式。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果在字符串中使用，在64位的SpookyHash是大大高于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在32位，它们是略快于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在64位，这是显着地快于SpookyHash上32位，尽管仍然快足以成为一个合理的选择。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83c2ef75ab5d9faef3f79684063ce016c8b50e49" translate="yes" xml:space="preserve">
          <source>&amp;dagger;&lt;code&gt;decimal&lt;/code&gt; isn't native from the .NET perspective though it is from the C#. The problem with it is that its own &lt;code&gt;GetHashCode()&lt;/code&gt; treats precision as significant while its own &lt;code&gt;Equals()&lt;/code&gt; does not. Both are valid choices, but not mixed like that. In implementing your own version, you need to choose to do one, or the other, but I can't know which you'd want.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;dagger; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从.NET角度来看，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不是本机的，尽管它是C＃的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它的问题在于它自己的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将精度视为重要，而它自己的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Equals()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;却不。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两者都是有效的选择，但并非如此。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在实现自己的版本时，您需要选择一个或另一个，但是我不知道您想要哪个。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3df11bf9c11a994a6141e579ee8c87c906373481" translate="yes" xml:space="preserve">
          <source>(Note: The original technique using anonymous types seems to create an object on the heap, i.e. garbage, since anonymous types are implemented as classes, though this might be optimized out by the compiler. It would be interesting to benchmark these options, but the tuple option should be superior.)</source>
          <target state="translated">(注意:使用匿名类型的原始技术似乎会在堆上创建一个对象,也就是垃圾,因为匿名类型是以类的形式实现的,不过这可能会被编译器优化掉。对这些选项进行基准测试会很有意思,但tuple选项应该更胜一筹。)</target>
        </trans-unit>
        <trans-unit id="a3a2c16db35df35d2fe189e2fcca836853920a73" translate="yes" xml:space="preserve">
          <source>*A big surprise in this is that hand-inlining a rotation method that returned &lt;code&gt;(x &amp;lt;&amp;lt; n) | (x &amp;gt;&amp;gt; -n)&lt;/code&gt; improved things. I would have been sure that the jitter would have inlined that for me, but profiling showed otherwise.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;*一个很大的惊喜是手动内联了返回的旋转方法&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(x &amp;lt;&amp;lt; n) | (x &amp;gt;&amp;gt; -n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有所改善。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我本来可以确定抖动会为我内联，但是剖析表明情况并非如此。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95d42bc65b3b6a49d6e5b97cf8c89519a4d16ef8" translate="yes" xml:space="preserve">
          <source>.NET Standard 2.1 And Above</source>
          <target state="translated">.NET标准2.1及以上版本</target>
        </trans-unit>
        <trans-unit id="237eebd45ff1ae0b4dc2e3a1f947162eb4d30120" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx&quot;&gt;This page&lt;/a&gt; gives quite a few options. I think for most cases the above is &quot;good enough&quot; and it's incredibly easy to remember and get right. The &lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx#fnv&quot;&gt;FNV&lt;/a&gt; alternative is similarly simple, but uses different constants and &lt;code&gt;XOR&lt;/code&gt; instead of &lt;code&gt;ADD&lt;/code&gt; as a combining operation. It looks &lt;em&gt;something&lt;/em&gt; like the code below, but the normal FNV algorithm operates on individual bytes, so this would require modifying to perform one iteration per byte, instead of per 32-bit hash value. FNV is also designed for variable lengths of data, whereas the way we're using it here is always for the same number of field values. Comments on this answer suggest that the code here doesn't actually work as well (in the sample case tested) as the addition approach above.</source>
          <target state="translated">&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此页面&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供了很多选项。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我认为，在大多数情况下，以上内容&amp;ldquo;足够好&amp;rdquo;，并且很难记住和正确设置。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所述&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx#fnv&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNV&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;替代方案是同样简单，但使用不同的常数和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;XOR&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代替&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ADD&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为组合操作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它看起来&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;像下面的代码一样，但是普通的FNV算法对单个字节进行操作，因此需要进行修改以对每个字节执行一次迭代，而不是对每个32位哈希值进行一次迭代。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNV还设计用于可变长度的数据，而我们在这里使用它的方式始终是针对相同数量的字段值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对这个答案的评论表明，这里的代码实际上不如上面的添加方法那样工作（在测试的示例案例中）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dbfcc92679561cd466ca70d3ec5cb0ada4849da5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt; users can generate GetHashCode, Equals, and others with &lt;code&gt;ReSharper -&amp;gt; Edit -&amp;gt; Generate Code -&amp;gt; Equality Members&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ReSharper&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用户可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ReSharper -&amp;gt; Edit -&amp;gt; Generate Code -&amp;gt; Equality Members&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来生成GetHashCode，等于等&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ea1ae0f0eb1ed12ed21ed926e7ffa399926aaaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueTuple&lt;/code&gt; is a struct and appears to have a solid &lt;code&gt;GetHashCode&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个结构，似乎具有可靠的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea0202aa9a3074625a51c3256d2dc385d6895a70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All the GetHashCode() implementations I'd coded in the past, and indeed used as the basis of answers on this site, were much worse than I'd throught&lt;/strong&gt;. Much of the time it was &quot;good enough&quot; for much of the uses, but I wanted something better.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我过去编写的所有GetHashCode（）实现（实际上已用作该站点的答案的基础）都比我经历的要差得多&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在很多时候，它对于许多用途来说都&amp;ldquo;足够好&amp;rdquo;，但是我想要更好的东西。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64737e14d176ba9cf426f44088eeac87333a7a89" translate="yes" xml:space="preserve">
          <source>A good hash function should map the expected inputs as evenly as possible over its output range. It should have uniformity.</source>
          <target state="translated">一个好的散列函数应该在其输出范围内尽可能均匀地映射预期的输入。它应该具有均匀性。</target>
        </trans-unit>
        <trans-unit id="0b087b0c644a46bd6641921114f7033df6978d64" translate="yes" xml:space="preserve">
          <source>A small change to a message should change the hash value so extensively that the new hash value appears uncorrelated with the old hash value (avalanche effect).</source>
          <target state="translated">对消息的一个小的改动应该会使散列值发生大范围的变化,以至于新的散列值与旧的散列值看起来毫无关联(雪崩效应)。</target>
        </trans-unit>
        <trans-unit id="bd1a4e418ac54c54625c46768d60dc7e55d97d21" translate="yes" xml:space="preserve">
          <source>Add the result and h1 together.</source>
          <target state="translated">把结果和h1加在一起。</target>
        </trans-unit>
        <trans-unit id="f1c118123f96f8220daec90522f3b96d0f84b028" translate="yes" xml:space="preserve">
          <source>Also it has extension method to provide a fluent interface, so you can use it like this:</source>
          <target state="translated">而且它还有扩展方法,提供了一个流畅的接口,所以你可以这样使用它。</target>
        </trans-unit>
        <trans-unit id="5924b5e6279dfd3f1ccd06d12d17ca745d917e31" translate="yes" xml:space="preserve">
          <source>And here is how to use it:</source>
          <target state="translated">下面是如何使用它。</target>
        </trans-unit>
        <trans-unit id="f7e8bccebca6d7ebf1c132bf64c36d31c8b3e398" translate="yes" xml:space="preserve">
          <source>And here is the acutal builder class:</source>
          <target state="translated">而这里,是指的是 &quot;尖顶建造师班&quot;。</target>
        </trans-unit>
        <trans-unit id="0b0c4ee6c49ec53c99f367f324f2d13f02203ef5" translate="yes" xml:space="preserve">
          <source>And it pretty much sucked. So after a bit of experimentation and research I started re-hashing my hashes with the following:</source>
          <target state="translated">而且它很烂。所以经过一番实验和研究后,我开始用下面的哈希值进行重新编码。</target>
        </trans-unit>
        <trans-unit id="4753226d060c2ac7870ac15825cb98de476efddf" translate="yes" xml:space="preserve">
          <source>And one final tip: &lt;b&gt;Don't rely on GetHashCode() being stable over multiple aplication runs&lt;/b&gt;. Many .Net types don't guarantee their hash codes to stay the same after a restart, so you should only use the value of GetHashCode() for in memory data structures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最后一条提示：&lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不要依赖GetHashCode（）在多次复制运行中保持稳定&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;许多.Net类型不保证其哈希码在重新启动后保持不变，因此您仅应将GetHashCode（）的值用于内存数据结构中。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c910bf934a6df4c337ec4ebc5ec681c2f90542e" translate="yes" xml:space="preserve">
          <source>And same for multi-type: all converted first to &lt;code&gt;int&lt;/code&gt; using &lt;code&gt;GetHashCode()&lt;/code&gt;
then the int values will be xor'ed and the result is your hash.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与多类型相同：首先全部&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 然后将对int值进行异或运算，结果就是您的哈希。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d58afc915a407c9686d470da7d4718874579746d" translate="yes" xml:space="preserve">
          <source>And then my power-of-two hash table didn't suck any more.</source>
          <target state="translated">然后,我的二人组力量的哈希表就不逊色了。</target>
        </trans-unit>
        <trans-unit id="e6524d5374d0dad18e089d93cca5b51530ed61a0" translate="yes" xml:space="preserve">
          <source>And this is from &lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/Common/src/System/Numerics/Hashing/HashHelpers.cs&quot;&gt;&lt;code&gt;HashHelper&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是来自&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/Common/src/System/Numerics/Hashing/HashHelpers.cs&quot;&gt; &lt;code&gt;HashHelper&lt;/code&gt; 的&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6ea4b5d260d1757dfef473e91d4cdc426f950356" translate="yes" xml:space="preserve">
          <source>And well, it was disturbing how much the &lt;code&gt;string.GetHashCode()&lt;/code&gt; implementations in &lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/System/string.cs,789&quot;&gt;.NET&lt;/a&gt; (or study &lt;a href=&quot;https://stackoverflow.com/a/48775953/147511&quot;&gt;here&lt;/a&gt;) could be improved this way (on the order of tests running about 20-30 times faster due to fewer collisions) and more disturbing how much my own hash codes could be improved (much more than that).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很好，令人感到不安多少&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/System/string.cs,789&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（或研究&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/48775953/147511&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）可以这样（更快的运行约20-30次测试的顺序上，由于较少的冲突）得到改善，更令人不安的是如何我自己的哈希码有很多可以改进的地方（远远不止这些）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6539f8fb88e503a8b8c34ab6bcc63de114670a0b" translate="yes" xml:space="preserve">
          <source>Anonymous Type</source>
          <target state="translated">匿名类型</target>
        </trans-unit>
        <trans-unit id="2ef0204701e5a8adb4295eb5e9aa0eda969ef4cf" translate="yes" xml:space="preserve">
          <source>As @cactuaroid mentions in the comments, a value tuple can be used. This saves a few keystrokes and more importantly executes purely on the stack (no Garbage):</source>
          <target state="translated">正如 @cactuaroid 在评论中提到的,可以使用一个值 tuple。这样做可以节省一些按键,更重要的是可以在堆栈上纯粹执行(没有Garbage)。</target>
        </trans-unit>
        <trans-unit id="4884ca4fdea316ef7d5a10917de179b44aefe544" translate="yes" xml:space="preserve">
          <source>As noted in comments, you may find it's better to pick a large prime to multiply by instead. Apparently 486187739 is good... and although most examples I've seen with small numbers tend to use primes, there are at least similar algorithms where non-prime numbers are often used. In the not-quite-&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function&quot;&gt;FNV&lt;/a&gt; example later, for example, I've used numbers which apparently work well - but the initial value isn't a prime. (The multiplication constant &lt;em&gt;is&lt;/em&gt; prime though. I don't know quite how important that is.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如评论中所述，您可能会发现最好选择一个大质数乘以。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显然486187739是个好主意&amp;hellip;&amp;hellip;虽然我看到的大多数带有小数的示例都倾向于使用质数，但至少有一些类似的算法经常使用非质数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，在稍后&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的非&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNV&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示例中，我使用的数字似乎很有效-但初始值不是素数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（尽管乘法常数&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;素数。我不知道它的重要性。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0fc68588324515b00e71f04c950e60480e2bd553" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14863&quot;&gt;https://github.com/dotnet/coreclr/pull/14863&lt;/a&gt;, there is a new way to generate hash codes that is super simple! Just write</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14863&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/dotnet/coreclr/pull/14863开始&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，有一种新的生成哈希码的方法非常简单！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;写就好了&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ba8400d7c27eb6bbe485bddce2a770e9a59f458" translate="yes" xml:space="preserve">
          <source>As per the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode#notes-to-inheritors&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode#notes-to-inheritors&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文档&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6490b278794b35f12336f32cce320e3a69acab63" translate="yes" xml:space="preserve">
          <source>Because of this feature, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection and they should never be persisted.</source>
          <target state="translated">由于这一特性,哈希码不应该在创建哈希码的应用域之外使用,也不应该作为集合中的关键字段使用,并且不应该被持久化。</target>
        </trans-unit>
        <trans-unit id="11b32f5445111f35152e714852144506ca1cb530" translate="yes" xml:space="preserve">
          <source>Because the Hash output is always an int, you can just chain Hash calls.</source>
          <target state="translated">因为Hash的输出始终是一个int,所以你可以直接连锁Hash调用。</target>
        </trans-unit>
        <trans-unit id="2273bd2f117653a9c56bbd3e76317b35a2b4389b" translate="yes" xml:space="preserve">
          <source>But this test passes (with ints):</source>
          <target state="translated">但这个测试是通过了(有了ints)。</target>
        </trans-unit>
        <trans-unit id="f120da2cf0f973ab74313965e44c104c28715694" translate="yes" xml:space="preserve">
          <source>By the way, the earlier algorithm is the one currently used by the C# compiler for anonymous types.</source>
          <target state="translated">顺便说一下,前面的算法是目前C#编译器中用于匿名类型的算法。</target>
        </trans-unit>
        <trans-unit id="28ec9ea2e98208ee3c50de6dbbd90da47726d6dc" translate="yes" xml:space="preserve">
          <source>Cryptographically Secure?</source>
          <target state="translated">加密安全?</target>
        </trans-unit>
        <trans-unit id="f6798670eccb448dbd7ae61707aed7700330e4b5" translate="yes" xml:space="preserve">
          <source>Deterministic</source>
          <target state="translated">Deterministic</target>
        </trans-unit>
        <trans-unit id="f399f567d30257913aa40c9a0b774a97589e3f6c" translate="yes" xml:space="preserve">
          <source>Edit (May 2018): &lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt; getter is now a JIT intrinsic - the &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14125&quot;&gt;pull request&lt;/a&gt; is mentioned by Stephen Toub in &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编辑（2018年5月）：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; getter现在是JIT内在函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-Stephen Toub在&lt;/font&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此博客文章中&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提到&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;了&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14125&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pull请求&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f36d236cdfc72792355b5bd010191a1697cc8e21" translate="yes" xml:space="preserve">
          <source>Edit: I was also using open-addressing, which would also have increased the sensitivity to collision, perhaps more so than the fact it was power-of-two.</source>
          <target state="translated">编辑:我当时也是用的是开配,这样也会增加碰撞的灵敏度,也许比起二电的事实,更多的是增加了碰撞的灵敏度。</target>
        </trans-unit>
        <trans-unit id="ec3029c0ba715ec4e3b4ba579e691c099b1e661c" translate="yes" xml:space="preserve">
          <source>For each further item, perform the operation on the previous result and the next item (e.g. h2).</source>
          <target state="translated">对于每个进一步的项目,对上一个结果和下一个项目(如h2)进行操作。</target>
        </trans-unit>
        <trans-unit id="4a750761886bb8c5c3093d7d8da1f358a99b7be3" translate="yes" xml:space="preserve">
          <source>For those who use hash as ID (I mean an unique value), hash is naturally limited to a number of digits, I think it was 5 bytes for hashing algorithm, at least MD5.</source>
          <target state="translated">对于那些用哈希作为ID(我指的是唯一值)的人来说,哈希自然是被限制在若干位数,我认为哈希算法是5个字节,至少是MD5。</target>
        </trans-unit>
        <trans-unit id="d8558f6652b3cfc7c3336ced510c7c2259ad7976" translate="yes" xml:space="preserve">
          <source>GetHashCode Made Easy</source>
          <target state="translated">GetHashCode Made Easy</target>
        </trans-unit>
        <trans-unit id="034396c26c5e4ebc5bd1068b7529411104222377" translate="yes" xml:space="preserve">
          <source>HashCode.Add</source>
          <target state="translated">HashCode.Add</target>
        </trans-unit>
        <trans-unit id="0ba1e0a5a4926cff0e03ebbdb6d52b7a661256e8" translate="yes" xml:space="preserve">
          <source>HashCode.Combine</source>
          <target state="translated">HashCode.Combine</target>
        </trans-unit>
        <trans-unit id="d38b35ccba9919ce8b5b43ef1cf490a7f721401d" translate="yes" xml:space="preserve">
          <source>Here is another fluent implementation of &lt;a href=&quot;https://stackoverflow.com/a/263416/33791&quot;&gt;the algorithm posted above by Jon Skeet&lt;/a&gt;, but which includes no allocations or boxing operations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/263416/33791&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Jon Skeet在上面发布的算法的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一种流畅的实现&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是不包括分配或装箱操作：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b1e0b14247c35a0dd98e5ba0eb642e4dc1843c1" translate="yes" xml:space="preserve">
          <source>Here is my hashcode helper.</source>
          <target state="translated">这是我的hashcode助手。</target>
        </trans-unit>
        <trans-unit id="4be13d945c6ba718eeced4ba0389ce90b6ec6aa0" translate="yes" xml:space="preserve">
          <source>Here is my simplistic approach. I am using the classic builder pattern for this. It is typesafe (no boxing/unboxing) and also compatbile with .NET 2.0 (no extension methods etc.).</source>
          <target state="translated">下面是我的简单化方法。我使用的是经典的builder模式。它是类型安全的(没有boxingunboxing),而且还与.NET 2.0兼容(没有扩展方法等)。</target>
        </trans-unit>
        <trans-unit id="b8b27f99a942c6d3ce3eb645ca556e3c906c83ac" translate="yes" xml:space="preserve">
          <source>Here's my helper class using &lt;a href=&quot;https://stackoverflow.com/a/263416/704144&quot;&gt;Jon Skeet's implementation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是我使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/263416/704144&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Jon Skeet的实现的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;帮助程序类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83ac8a659ca4db3fa8d7dcfd4473a8c41782b2c9" translate="yes" xml:space="preserve">
          <source>However, since it's now already written, one can make use of it more easily:</source>
          <target state="translated">不过,既然现在已经写好了,就可以更方便地利用它了。</target>
        </trans-unit>
        <trans-unit id="8cf06bfeb7893297f5b466ba135ef3e5a8c8a67d" translate="yes" xml:space="preserve">
          <source>I can guess that for multiple big int you can use this:</source>
          <target state="translated">我可以猜测,对于多个大的int可以用这个。</target>
        </trans-unit>
        <trans-unit id="6341f744676fe64ec4e97c176de06ac114def865" translate="yes" xml:space="preserve">
          <source>I changed my implementation to not use GetHashCode for the primitive types and it seems to work better</source>
          <target state="translated">我改变了我的实现,不使用GetHashCode来实现基元类型,似乎效果更好。</target>
        </trans-unit>
        <trans-unit id="d44374f08bd16dc2acc4cd4ed9fad6603e35a2dc" translate="yes" xml:space="preserve">
          <source>I didn't assess its performance, so any feedback is welcomed.</source>
          <target state="translated">我没有评估它的表现,所以欢迎任何反馈。</target>
        </trans-unit>
        <trans-unit id="3c7682f2756768262570b11ce2273bf6db42e85c" translate="yes" xml:space="preserve">
          <source>I have a Hashing class in Helper library that I use it for this purpose.</source>
          <target state="translated">我在Helper库里有一个Hashing类,我用它来实现这个目的。</target>
        </trans-unit>
        <trans-unit id="79484108e32c6a21344a0d900482a48b2c630c8f" translate="yes" xml:space="preserve">
          <source>I ran into an issue with floats and decimals using the implementation selected as the answer above.</source>
          <target state="translated">我在使用上面的答案时遇到了一个问题,那就是浮点数和小数的问题。</target>
        </trans-unit>
        <trans-unit id="7eba8db330d45d66dcb0d37cd8b2aed9484677aa" translate="yes" xml:space="preserve">
          <source>I usually go with something like the implementation given in Josh Bloch's &lt;em&gt;fabulous&lt;/em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;Effective Java&lt;/a&gt;. It's fast and creates a pretty good hash which is unlikely to cause collisions. Pick two different prime numbers, e.g. 17 and 23, and do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我通常会使用类似于Josh Bloch &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出色的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Effective Java中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给出的实现的东西&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它速度很快，并且创建了一个很好的哈希，不太可能导致冲突。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;选择两个不同的质数，例如17和23，然后执行：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecd4a4ee6fb901f76f58984b6c90616cf19d910c" translate="yes" xml:space="preserve">
          <source>If we have no more than 8 properties (hopefully), here is another alternative.</source>
          <target state="translated">如果我们的属性不超过8个(希望),这里有另一种选择。</target>
        </trans-unit>
        <trans-unit id="51e61bd0902dd12fd8399d10c1dfc7edf6c2bc67" translate="yes" xml:space="preserve">
          <source>If you are using .NET Standard 2.1 or above, you can use the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.hashcode?view=netcore-2.1&quot;&gt;System.HashCode&lt;/a&gt; struct. There are two methods of using it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果使用的是.NET Standard 2.1或更高版本，则可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.hashcode?view=netcore-2.1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.HashCode&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;结构。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有两种使用方法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7195ac0e83ef4a6feddbd250bff1ae20963d1157" translate="yes" xml:space="preserve">
          <source>If you want to avoid writing an extension method for System.Int32:</source>
          <target state="translated">如果你想避免为System.Int32编写一个扩展方法。</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="6488742a860c14ecbed74fa734de70954bb71e77" translate="yes" xml:space="preserve">
          <source>In .NET Core each time you restart an application you will get different hash codes. This is a security feature to prevent Denial of Service attacks (DoS). For .NET Framework you &lt;strong&gt;should&lt;/strong&gt; enable this feature by adding the following App.config file:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在.NET Core中，每次重新启动应用程序时，您将获得不同的哈希码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一项安全功能，可防止拒绝服务攻击（DoS）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于.NET Framework，您&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过添加以下App.config文件&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;启用此功能：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4738d896b60dfae58b5b259b003bf59cce6e20b" translate="yes" xml:space="preserve">
          <source>In .NET, the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode&quot;&gt;&lt;code&gt;GetHashCode&lt;/code&gt; method&lt;/a&gt; is used in a lot of places throughout the .NET base class libraries. Implementing it properly is especially important to find items quickly in a collection or when determining equality.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在.NET中，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;整个.NET基类库的许多地方都使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode&quot;&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正确实施它对于在集合中或确定相等性时快速查找项目尤为重要。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d045e350842340848d745e65b9ccc9cf28237c03" translate="yes" xml:space="preserve">
          <source>In English:</source>
          <target state="translated">用英语说:</target>
        </trans-unit>
        <trans-unit id="66db6221d3fcbac7088e96ff309ffb23cfb5ad58" translate="yes" xml:space="preserve">
          <source>In case you want to polyfill &lt;code&gt;HashCode&lt;/code&gt; from &lt;code&gt;netstandard2.1&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您想&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt; &lt;code&gt;netstandard2.1&lt;/code&gt; 填充&lt;/font&gt; &lt;code&gt;HashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c40e2b1801b414478c669a008b937281f4d2dc69" translate="yes" xml:space="preserve">
          <source>In most cases where Equals() compares multiple fields it doesn't really matter if your GetHash() hashes on one field or on many. You just have to make sure that calculating the hash is really cheap (&lt;b&gt;No allocations&lt;/b&gt;, please) and fast (&lt;b&gt;No heavy computations&lt;/b&gt; and certainly no database connections) and provides a good distribution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在大多数情况下，Equals（）比较多个字段，如果您的GetHash（）散列在一个或多个字段上并没有关系。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您只需要确保计算哈希值确实便宜（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请&lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不要分配&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）和快速（&lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不需要繁重的计算&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，当然也没有数据库连接）并且提供了良好的分布。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70f850b780b4ffb79b7c73fda1edcded2180b380" translate="yes" xml:space="preserve">
          <source>In the end I settled on porting &lt;a href=&quot;http://burtleburtle.net/bob/hash/spooky.html&quot;&gt;SpookyHash&lt;/a&gt; to .NET. Indeed the code above is a fast-path version of using SpookyHash to produce a 32-bit output from a 32-bit input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最后，我决定将&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://burtleburtle.net/bob/hash/spooky.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SpookyHash&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;移植&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到.NET。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的确，以上代码是使用SpookyHash从32位输入生成32位输出的快速路径版本。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6243d71d1d7b8aea75619231aad11f8259651c82" translate="yes" xml:space="preserve">
          <source>Is there a standard algorithm or best practice on how to implement &lt;code&gt;GetHashCode&lt;/code&gt; for my custom classes so I don't degrade performance?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是否有关于如何&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为自定义类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的标准算法或最佳实践，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以免降低性能？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79e480f23d6c2078c87bb12c8c5c3744c8de3f93" translate="yes" xml:space="preserve">
          <source>It also takes seed values, so if you need to deal with untrusted input and want to protect against Hash DoS attacks you can set a seed based on uptime or similar, and make the results unpredictable by attackers:</source>
          <target state="translated">它还采取种子值,所以如果你需要处理不信任的输入,并想防备Hash DoS攻击,你可以根据正常运行时间或类似的情况设置一个种子,让攻击者无法预测结果。</target>
        </trans-unit>
        <trans-unit id="1cca014cbc07e3c62667a380b70f66b34a5849ca" translate="yes" xml:space="preserve">
          <source>It is infeasible to find two different messages with the same hash value</source>
          <target state="translated">不可能找到两个不同的信息有相同的散列值的信息。</target>
        </trans-unit>
        <trans-unit id="24065692dc06162d306ce6a1810804d176e738bc" translate="yes" xml:space="preserve">
          <source>It is infeasible to generate a message that yields a given hash value</source>
          <target state="translated">生成一个产生给定散列值的消息是不可行的。</target>
        </trans-unit>
        <trans-unit id="3e7c0769beb54d29fef29e364d96abec5127a859" translate="yes" xml:space="preserve">
          <source>It is used like this:</source>
          <target state="translated">它是这样使用的。</target>
        </trans-unit>
        <trans-unit id="775120da70c32a3d1145975d3b0b7ece50d6c047" translate="yes" xml:space="preserve">
          <source>It still avoids any heap allocation and is used exactly the same way:</source>
          <target state="translated">它仍然避免了任何堆分配,使用的方式完全一样。</target>
        </trans-unit>
        <trans-unit id="af44925b98c54411762b5e115d90694d80c037bb" translate="yes" xml:space="preserve">
          <source>It would be nice to know more about the properties of this ROL-5 hash code algorithm.</source>
          <target state="translated">如果能知道更多关于这种ROL-5散列码算法的属性就好了。</target>
        </trans-unit>
        <trans-unit id="cd73c970707454efb2b115cd12e169fd1fb86e9f" translate="yes" xml:space="preserve">
          <source>It's advantage is that it uses generic type arguments and therefore will not cause boxing:</source>
          <target state="translated">它的优点是使用通用类型的参数,因此不会造成箱体化。</target>
        </trans-unit>
        <trans-unit id="f183efea3aaad2350f821613ad659f9d94954a53" translate="yes" xml:space="preserve">
          <source>It's fast, for which Bob Jenkins deserves most of the credit because his original code I ported from is faster still, especially on 64-bit machines which the algorithm is optimised for&amp;Dagger;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;鲍勃&amp;middot;詹金斯（Bob Jenkins）值得赞扬的是它的速度很快，因为我移植的原始代码仍然更快，尤其是在针对该算法进行了优化的64位计算机上。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db3b9d4536e07c34bc7e78f6730f683ac59ee7c3" translate="yes" xml:space="preserve">
          <source>Left rotate (circular shift) h1 by 5 positions.</source>
          <target state="translated">左转(圆移)h1的5个位置。</target>
        </trans-unit>
        <trans-unit id="9befb5f7f42c778c9ce669275d1ce6ed000d3ae9" translate="yes" xml:space="preserve">
          <source>Let's take a look at .NET Core's current implementation for &lt;code&gt;ValueTuple&lt;/code&gt;'s &lt;code&gt;GetHashCode&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;让我们看一下.NET Core对&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的当前实现&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0cf40c5cdf4e24892afe91b39db417c88cd24a93" translate="yes" xml:space="preserve">
          <source>Microsoft already provides a good generic HashCode generator: Just copy your property/field values to an anonymous type and hash it:</source>
          <target state="translated">微软已经提供了一个很好的通用HashCode生成器。只需将你的属性场值复制到一个匿名类型,然后进行哈希。</target>
        </trans-unit>
        <trans-unit id="fe5e8cabf2e9ef3c90856c23a3b071fc8ffdadc2" translate="yes" xml:space="preserve">
          <source>Microsoft lead for several way of hashing...</source>
          <target state="translated">微软主导的几种散列的方式.....</target>
        </trans-unit>
        <trans-unit id="778fc4e9438d8fe69ff04d1a23db7d2a638261a0" translate="yes" xml:space="preserve">
          <source>Most of my work is done with database connectivity which means that my classes all have a unique identifier from the database.  I always use the ID from the database to generate the hashcode.</source>
          <target state="translated">我的大部分工作都是通过数据库连接完成的,这意味着我的类都有一个来自数据库的唯一标识符。我总是使用数据库中的ID来生成哈希码。</target>
        </trans-unit>
        <trans-unit id="ebe8b198579b5d8d43b5b5961017777a829df670" translate="yes" xml:space="preserve">
          <source>Note that one thing to be aware of is that ideally you should prevent your equality-sensitive (and thus hashcode-sensitive) state from changing after adding it to a collection that depends on the hash code.</source>
          <target state="translated">需要注意的是,有一点需要注意的是,理想情况下,你应该防止你的平等敏感(因此也就是哈希码敏感)的状态在添加到依赖哈希码的集合后改变。</target>
        </trans-unit>
        <trans-unit id="94d46ec70da897d6695de00bf38d36857c1d2fb5" translate="yes" xml:space="preserve">
          <source>Note: If used with &lt;code&gt;struct&lt;/code&gt;, it will allocate memory due to boxing</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：如果与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct&lt;/code&gt; 一起使用&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它将由于装箱而分配内存&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5ac46a74dbff2b805e8a5a7d2626d1c776b451a" translate="yes" xml:space="preserve">
          <source>Now, SpookyHash is not a nice quick to remember piece of code. My port of it is even less so because I hand-inlined a lot of it for better speed*. But that's what code reuse is for.</source>
          <target state="translated">现在,SpookyHash并不是一个很好的快速记忆的代码。我对它的移植就更不用说了,因为我为了更好的速度而手工划线了很多。但这就是代码重用的目的。</target>
        </trans-unit>
        <trans-unit id="c849d5abd7981416f7339aea0af9b86419c5d93c" translate="yes" xml:space="preserve">
          <source>PS: This is one of those times where you puke a little in your mouth, knowing that this could be refactored into one method with 9 default's but it would be slower, so you just close your eyes and try to forget about it.</source>
          <target state="translated">PS:这个时候,你会有点想吐槽,明明知道可以把这个方法重构成一个9个默认的方法,但是会比较慢,所以你就闭上眼睛,努力把它忘掉。</target>
        </trans-unit>
        <trans-unit id="f065fd929e1c22be435487e6ea63fce4d6e76802" translate="yes" xml:space="preserve">
          <source>Pretty much similar to nightcoder's solution except it's easier to raise primes if you want to.</source>
          <target state="translated">和夜行者的解决方案很相似,只是如果你想的话,提升primes比较容易。</target>
        </trans-unit>
        <trans-unit id="3595239fc3035d9f6e9e92d99a2bfdc06c060789" translate="yes" xml:space="preserve">
          <source>Prevent's DoS</source>
          <target state="translated">防范的DoS</target>
        </trans-unit>
        <trans-unit id="b64211794d8e7415e42a8db9c7d0b1a28f11fc41" translate="yes" xml:space="preserve">
          <source>Re-mixing a hash code can only improve a hash code that did at least fairly well in avoiding absolute collisions throughout its range (2&lt;sup&gt;32&lt;/sup&gt; possible values) but badly at avoiding collisions when modulo'd down for actual use in a hash table. While the simpler modulo of a power-of-two table made this more apparent, it was also having a negative effect with the more common prime-number tables, that just wasn't as obvious (the extra work in rehashing would outweigh the benefit, but the benefit would still be there).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重新混合哈希码只能改善一个哈希码，该哈希码至少在避免整个范围内的绝对冲突（2 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;32个&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能的值）方面做得&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相当好，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是在为哈希表中的实际使用取模时避免避免冲突很差。虽然2的幂的表的简单模数使这一点更加明显，但它对更常见的质数表也有负面影响，但效果却不那么明显（重新哈希处理的额外工作将超过收益） ，但好处仍然存在）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fce0fc5a7dcd2e788a03afe8194230572d482cb6" translate="yes" xml:space="preserve">
          <source>Re-mixing a hash code can't improve a terrible hash code, because the only possible effect is we change e.g. a large number of collisions on value 53 to a large number of value 18,3487,291.</source>
          <target state="translated">重新混合一个哈希码并不能改善一个可怕的哈希码,因为唯一可能的效果就是我们把比如说值53的大量碰撞变成了值183487291的大量碰撞。</target>
        </trans-unit>
        <trans-unit id="3c9638d7db05fd5da4a874b5d52071ce2087a80e" translate="yes" xml:space="preserve">
          <source>Re-mixing a hashcode can't improve a great hashcode, because the only possible effect is that we introduce a few more collisions.</source>
          <target state="translated">重新混合一个哈希码并不能改善一个伟大的哈希码,因为唯一可能的效果就是我们多引入一些碰撞。</target>
        </trans-unit>
        <trans-unit id="af1c5729918a7c13189ba3df1d45ae50f208a20f" translate="yes" xml:space="preserve">
          <source>Read more about this &lt;a href=&quot;https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在此处&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;阅读有关此内容的更多信息&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="555fb017bb0db82e04dccc34f592057fdb765838" translate="yes" xml:space="preserve">
          <source>Reduce Collisions</source>
          <target state="translated">减少碰撞</target>
        </trans-unit>
        <trans-unit id="c67f54eca7526ba65a1d69b5e9d8b38b3f5067f1" translate="yes" xml:space="preserve">
          <source>Regrettably, deferring to &lt;code&gt;ValueTuple&lt;/code&gt; for our own &lt;code&gt;GetHashCode&lt;/code&gt; may not be as fast as we would like and expect. &lt;a href=&quot;https://github.com/dotnet/corefx/issues/8034#issuecomment-260759796&quot;&gt;This comment&lt;/a&gt; in a related discussion illustrates that directly calling &lt;code&gt;HashHelpers.Combine&lt;/code&gt; is more performant. On the flip side, that one is internal, so we'd have to copy the code, sacrificing much of what we had gained here. Also, we'd be responsible for remembering to first &lt;code&gt;Combine&lt;/code&gt; with the random seed. I don't know what the consequences are if we skip that step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;遗憾的是，将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们自己的&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;推迟到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能不会像我们期望的那样快。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在相关讨论中，&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/issues/8034#issuecomment-260759796&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此注释&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;说明直接调用&lt;/font&gt; &lt;code&gt;HashHelpers.Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的性能更高。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一方面，该代码是内部的，因此我们必须复制代码，以牺牲我们在此处获得的很多东西。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此外，我们会负责记住先&lt;/font&gt; &lt;code&gt;Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;与随机种子。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不知道如果跳过这一步会带来什么后果。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="41ef8b26263345cca597a7e0aa739b815f3e2403" translate="yes" xml:space="preserve">
          <source>So I put that project to one side (it was a pet project anyway) and started looking at how to produce a good, well-distributed hash code in .NET quickly.</source>
          <target state="translated">于是我把那个项目放到一边(反正是个宠物项目),开始研究如何在.NET中快速生成一个好的、分布良好的散列代码。</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="6b05d1dc7e9a6f239a0395230da12be3bfb344e6" translate="yes" xml:space="preserve">
          <source>Start by performing the above operation on { static random seed, h1 }.</source>
          <target state="translated">开始对{静态随机种子,h1 }执行上述操作。</target>
        </trans-unit>
        <trans-unit id="5e0f2002957c60cee86ff8251ef135dcad849b56" translate="yes" xml:space="preserve">
          <source>That means we could simply do this:</source>
          <target state="translated">这意味着我们可以简单地这样做。</target>
        </trans-unit>
        <trans-unit id="826b9d7df4ba107a7469f426428004097d06f89b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Add&lt;/code&gt; method helps you to deal with collections:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Add&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法可以帮助你处理集合：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60a068f9545ee721c0e80f6ad49baf4bb1d421b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Combine&lt;/code&gt; method can be used to create a hash code, given up to eight objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法可以用于创建哈希码，给出多达八个对象。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d787f0415844ae018bcf56dbf50989dcd7b9f11" translate="yes" xml:space="preserve">
          <source>The algorithm does not have to be a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;Cryptographic hash function&lt;/a&gt;. Meaning it does not have to satisfy the following conditions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该算法不必是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;加密哈希函数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示它不必满足以下条件：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ac5541f8c7461f7bcb249fb14bcc008335a3fce" translate="yes" xml:space="preserve">
          <source>The algorithm that calculates a hash code needs to be fast. A simple algorithm is usually going to be a faster one.</source>
          <target state="translated">计算出哈希码的算法要快。一个简单的算法通常会是一个比较快的算法。</target>
        </trans-unit>
        <trans-unit id="045833a0e2d683cb1e8c1b7d651bc273a8823621" translate="yes" xml:space="preserve">
          <source>The algorithm that calculates a hash code needs to keep &lt;a href=&quot;http://crppit.epfl.ch/documentation/Hash_Function/WiKi/Hash_collision.htm&quot;&gt;hash collisions&lt;/a&gt; to a minumum. A hash collision is a situation that occurs when two calls to &lt;code&gt;GetHashCode&lt;/code&gt; on two different objects produce identical hash codes. Note that collisions are allowed (some have the misconceptions that they are not) but they should be kept to a minimum.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;计算哈希码的算法需要将&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://crppit.epfl.ch/documentation/Hash_Function/WiKi/Hash_collision.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;哈希冲突&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保持&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在最低水平。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;哈希冲突是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在两个不同对象上的两次&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;产生相同的哈希码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时发生的情况&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，碰撞是允许的（有些会误以为不允许），但应将碰撞减到最少。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d740feb71d0fbf0408f6a65db8c993a4ea6592a0" translate="yes" xml:space="preserve">
          <source>The compiler will ensure &lt;code&gt;HashValue&lt;/code&gt; is not called with a class due to the generic type constraint. But there is no compiler support for &lt;code&gt;HashObject&lt;/code&gt; since adding a generic argument also adds a boxing operation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于通用类型约束&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，编译器将确保&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不使用类调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashValue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于添加了通用参数也增加了装箱操作&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此不支持&lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashObject&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译器&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa6cbb4a7d0cfa141362b4605fb3b5044a8ac454" translate="yes" xml:space="preserve">
          <source>The full code can be seen at &lt;a href=&quot;https://bitbucket.org/JonHanna/spookilysharp/src&quot;&gt;https://bitbucket.org/JonHanna/spookilysharp/src&lt;/a&gt; but consider that the code above is a simplified version of it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完整的代码可以在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://bitbucket.org/JonHanna/spookilysharp/src&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://bitbucket.org/JonHanna/spookilysharp/src上找到，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是请考虑上面的代码是它的简化版本。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6aea3a389963dd3279922dd6f8068aa1b709c3a3" translate="yes" xml:space="preserve">
          <source>The hashing algorithm needs to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;deterministic&lt;/a&gt; i.e. given the same input it must always produce the same output.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;哈希算法必须是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;确定性的，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即，给定相同的输入，它必须始终产生相同的输出。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74843c914e569e3d934ad75c40cd9c55a7c17747" translate="yes" xml:space="preserve">
          <source>The heavy lifting should be part of the Equals() method; the hash should be a very cheap operation to enable calling Equals() on as few items as possible.</source>
          <target state="translated">重头戏应该是Equals()方法的一部分;哈希操作应该是一个非常便宜的操作,可以在尽可能少的项目上调用Equals()。</target>
        </trans-unit>
        <trans-unit id="6a3bc6502919f9edd3fdb6c625b410c86d7f8039" translate="yes" xml:space="preserve">
          <source>Then I came back, and produced a lot of overloads to easily feed just about all of the native types (except &lt;code&gt;decimal&lt;/code&gt;&amp;dagger;) into a hash code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，我回来了，并产生了很多重载，可以轻松地将几乎所有本机类型（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;dagger; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除外&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）输入哈希码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7483c49e6eb98b52f32043abddc6764971dca6b" translate="yes" xml:space="preserve">
          <source>Then I put &lt;em&gt;that&lt;/em&gt; project to one side, because just as the original project had produced the question of how to produce a better hash code, so that project produced the question of how to produce a better .NET memcpy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，我&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将该&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;项目&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;放在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一边，因为就像原始项目产生了如何产生更好的哈希码的问题一样，那个项目也产生了如何产生更好的.NET memcpy的问题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8a3dd62d6429a57deee1938c2b8d63f6dec90e7d" translate="yes" xml:space="preserve">
          <source>Then, simply you can use it as:</source>
          <target state="translated">那么,简单的说,你可以用它作为。</target>
        </trans-unit>
        <trans-unit id="75cffc3515bdc95dc9b22f8fed1ab2f02044fac8" translate="yes" xml:space="preserve">
          <source>This disturbed me though, because the above shouldn't work. Or more precisely, it shouldn't work unless the original &lt;code&gt;GetHashCode()&lt;/code&gt; was poor in a very particular way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，这使我不安，因为上述方法不起作用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或者更确切地说，除非原始的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以某种特殊方式变差，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;否则它不起作用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="516e8a7deb0de8522dade038b929c0204312d476" translate="yes" xml:space="preserve">
          <source>This is a good one:</source>
          <target state="translated">这是个好东西。</target>
        </trans-unit>
        <trans-unit id="1c7c1850d93fc274a256ffc70245af28400631ac" translate="yes" xml:space="preserve">
          <source>This is a static helper class that implements Josh Bloch's implementation; and provides explicit overloads to &quot;prevent&quot; boxing, and also to implement the hash specifically for the long primitives.</source>
          <target state="translated">这是一个静态的帮助类,实现了Josh Bloch的实现;并且提供了显式的重载来 &quot;防止 &quot;装箱,还专门为长基元实现了哈希。</target>
        </trans-unit>
        <trans-unit id="1307b741efe8c22ab33dd11c4f9ced9d341c0aa2" translate="yes" xml:space="preserve">
          <source>This is better than the common practice of &lt;code&gt;XOR&lt;/code&gt;ing hashcodes for two main reasons. Suppose we have a type with two &lt;code&gt;int&lt;/code&gt; fields:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出于两个主要原因，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这比&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对哈希码进行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;XOR&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的常规做法要好&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设我们有一个带有两个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字段&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e70ae20c9fb580d40ebc1c00d330f1f1135e294b" translate="yes" xml:space="preserve">
          <source>This is from &lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.ValueTuple/src/System/ValueTuple/ValueTuple.cs&quot;&gt;&lt;code&gt;ValueTuple&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.ValueTuple/src/System/ValueTuple/ValueTuple.cs&quot;&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d3c7ae92d1ff5acbdfec20e8c34d0f9543966a2" translate="yes" xml:space="preserve">
          <source>This test fails (floats; hash is the same even though I switched 2 values to be negative):</source>
          <target state="translated">这个测试失败了(虽然我把2个值换成了负值,但哈希还是一样)。</target>
        </trans-unit>
        <trans-unit id="3c9c751854ebebe052bd9ac39e701ac7f3ee9751" translate="yes" xml:space="preserve">
          <source>This will generate a quality hash code without you having to worry about the implementation details.</source>
          <target state="translated">这将生成一个高质量的哈希代码,而不必担心实现细节问题。</target>
        </trans-unit>
        <trans-unit id="2273401922a7ec31a62bf4c06628a6050af299e8" translate="yes" xml:space="preserve">
          <source>This will work for any number of properties. It does not use boxing. It just uses the algorithm already implemented in the framework for anonymous types.</source>
          <target state="translated">这对任何属性都是有效的。它不使用框选。它只是使用了框架中已经实现的匿名类型的算法。</target>
        </trans-unit>
        <trans-unit id="d9d9e2f475ad3bfe496517e55d50603c286f604d" translate="yes" xml:space="preserve">
          <source>Up until recently my answer would have been very close to Jon Skeet's here. However, I recently started a project which used power-of-two hash tables, that is hash tables where the size of the internal table is 8, 16, 32, etc. There's a good reason for favouring prime-number sizes, but there are some advantages to power-of-two sizes too.</source>
          <target state="translated">直到最近,我的答案与Jon Skeet这里的答案非常接近。然而,我最近开始了一个项目,它使用的是 power-of-two 散列表,也就是内部表的大小是 8、16、32 等。偏爱prim-number大小是有道理的,但power-of-two大小也有一些优势。</target>
        </trans-unit>
        <trans-unit id="342c659777997bec12f413246e5e24d6a8317e2a" translate="yes" xml:space="preserve">
          <source>Usage Example</source>
          <target state="translated">使用示例</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="b33d830517aea3e2d9bb3019a44d1af09654b9ae" translate="yes" xml:space="preserve">
          <source>ValueTuple - Update for C# 7</source>
          <target state="translated">ValueTuple-C#7的更新</target>
        </trans-unit>
        <trans-unit id="7f47afe10930417b5ac38c0d4b812852c49176ff" translate="yes" xml:space="preserve">
          <source>What Makes a Good Algorithm?</source>
          <target state="translated">什么是好的算法?</target>
        </trans-unit>
        <trans-unit id="38242dbf222f22cf8723209c1d4c037f60de436c" translate="yes" xml:space="preserve">
          <source>What is the best algorithm for overriding GetHashCode</source>
          <target state="translated">覆盖GetHashCode的最佳算法是什么?</target>
        </trans-unit>
        <trans-unit id="a7927a0abfa9b169083b1cb33b972375e669f367" translate="yes" xml:space="preserve">
          <source>XOR the result with h2.</source>
          <target state="translated">XOR结果与h2。</target>
        </trans-unit>
        <trans-unit id="df90e78c7b7f1be042309f565b3a930a77da9bf6" translate="yes" xml:space="preserve">
          <source>You can compute the hash code from fields that are not mutable; or</source>
          <target state="translated">你可以从不可突变的字段中计算出哈希码;或</target>
        </trans-unit>
        <trans-unit id="7e0f5da3ef3eb98ebe66a0458acbe252a1335380" translate="yes" xml:space="preserve">
          <source>You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</source>
          <target state="translated">你可以确保当一个可变对象被包含在依赖其哈希码的集合中时,该对象的哈希码不会改变。</target>
        </trans-unit>
        <trans-unit id="d14544f0139a010a5f0dfdedc09f3993f9ddda5c" translate="yes" xml:space="preserve">
          <source>You can override GetHashCode for immutable reference types. In general, for mutable reference types, you should override GetHashCode only if:</source>
          <target state="translated">对于不可变的引用类型,你可以重写GetHashCode。一般来说,对于可变的引用类型,你应该只在以下情况下覆盖GetHashCode。</target>
        </trans-unit>
        <trans-unit id="e8eb5c0af93ca2647da55c48e832b72309675a22" translate="yes" xml:space="preserve">
          <source>You can pass a string comparison that matches your equals implementation.</source>
          <target state="translated">你可以传递一个与你的等价实现相匹配的字符串比较。</target>
        </trans-unit>
        <trans-unit id="70eae4f6b110439731d5eafcd9cbf8d01ea4d5bf" translate="yes" xml:space="preserve">
          <source>You can read the full blog post '&lt;a href=&quot;https://rehansaeed.com/gethashcode-made-easy/&quot;&gt;GetHashCode Made Easy&lt;/a&gt;' for more details and comments.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以阅读完整的博客文章&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rehansaeed.com/gethashcode-made-easy/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GetHashCode Made Easy&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;，以获取更多详细信息和评论。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e8dfb137940607558d3f7f402aaf01bf7d406d2" translate="yes" xml:space="preserve">
          <source>You may turn multiple values to a hashed value and some of them be same, so don't use it as an identifier. (maybe some day I am going to use your component)</source>
          <target state="translated">你可以把多个值变成一个散列值,其中一些值是相同的,所以不要用它作为标识符。(也许有一天我会使用你的组件)</target>
        </trans-unit>
        <trans-unit id="98658dbce77e0b4aea26c71003da55e305bd7c92" translate="yes" xml:space="preserve">
          <source>or like this:</source>
          <target state="translated">或者像这样。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
