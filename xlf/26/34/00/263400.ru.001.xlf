<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/263400">
    <body>
      <group id="263400">
        <trans-unit id="0d79426d053942f788af84f9684d1aeab86b6544" translate="yes" xml:space="preserve">
          <source>&amp;Dagger;By way of comparison. If used on a string, the SpookyHash on 64 bits is considerably faster than &lt;code&gt;string.GetHashCode()&lt;/code&gt; on 32 bits which is slightly faster than &lt;code&gt;string.GetHashCode()&lt;/code&gt; on 64 bits, which is considerably faster than SpookyHash on 32 bits, though still fast enough to be a reasonable choice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;Dagger; Для сравнения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;При использовании в строке SpookyHash на 64 бита значительно быстрее, чем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на 32 бита, что немного быстрее, чем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на 64 бита, что значительно быстрее, чем SpookyHash на 32 бита, хотя все еще быстро достаточно, чтобы быть разумным выбором.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83c2ef75ab5d9faef3f79684063ce016c8b50e49" translate="yes" xml:space="preserve">
          <source>&amp;dagger;&lt;code&gt;decimal&lt;/code&gt; isn't native from the .NET perspective though it is from the C#. The problem with it is that its own &lt;code&gt;GetHashCode()&lt;/code&gt; treats precision as significant while its own &lt;code&gt;Equals()&lt;/code&gt; does not. Both are valid choices, but not mixed like that. In implementing your own version, you need to choose to do one, or the other, but I can't know which you'd want.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;dagger; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не является родной с точки зрения .NET, хотя и с C #. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Проблема в том, что его собственный &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; обрабатывает точность как значимую, в то время как его собственный &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Equals()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - нет. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Оба являются допустимыми, но не смешанными. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;При реализации своей собственной версии вам нужно выбрать одну или другую, но я не могу знать, что вы хотите.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3df11bf9c11a994a6141e579ee8c87c906373481" translate="yes" xml:space="preserve">
          <source>(Note: The original technique using anonymous types seems to create an object on the heap, i.e. garbage, since anonymous types are implemented as classes, though this might be optimized out by the compiler. It would be interesting to benchmark these options, but the tuple option should be superior.)</source>
          <target state="translated">(Замечание:Оригинальная техника,использующая анонимные типы,кажется,создает объект на куче,т.е.мусор,так как анонимные типы реализованы в виде классов,хотя это может быть оптимизировано компилятором.Было бы интересно сравнить эти опции,но опция кортежа должна быть выше).</target>
        </trans-unit>
        <trans-unit id="a3a2c16db35df35d2fe189e2fcca836853920a73" translate="yes" xml:space="preserve">
          <source>*A big surprise in this is that hand-inlining a rotation method that returned &lt;code&gt;(x &amp;lt;&amp;lt; n) | (x &amp;gt;&amp;gt; -n)&lt;/code&gt; improved things. I would have been sure that the jitter would have inlined that for me, but profiling showed otherwise.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* Большим сюрпризом в этом является то, что ручной метод ротации вернул &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(x &amp;lt;&amp;lt; n) | (x &amp;gt;&amp;gt; -n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; улучшенные вещи. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я был бы уверен, что дрожание указало бы на это для меня, но профилирование показало обратное.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95d42bc65b3b6a49d6e5b97cf8c89519a4d16ef8" translate="yes" xml:space="preserve">
          <source>.NET Standard 2.1 And Above</source>
          <target state="translated">.NET Стандарт 2.1 и выше.</target>
        </trans-unit>
        <trans-unit id="237eebd45ff1ae0b4dc2e3a1f947162eb4d30120" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx&quot;&gt;This page&lt;/a&gt; gives quite a few options. I think for most cases the above is &quot;good enough&quot; and it's incredibly easy to remember and get right. The &lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx#fnv&quot;&gt;FNV&lt;/a&gt; alternative is similarly simple, but uses different constants and &lt;code&gt;XOR&lt;/code&gt; instead of &lt;code&gt;ADD&lt;/code&gt; as a combining operation. It looks &lt;em&gt;something&lt;/em&gt; like the code below, but the normal FNV algorithm operates on individual bytes, so this would require modifying to perform one iteration per byte, instead of per 32-bit hash value. FNV is also designed for variable lengths of data, whereas the way we're using it here is always for the same number of field values. Comments on this answer suggest that the code here doesn't actually work as well (in the sample case tested) as the addition approach above.</source>
          <target state="translated">&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта страница&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; дает довольно много вариантов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я думаю, что в большинстве случаев вышесказанное &amp;laquo;достаточно хорошо&amp;raquo;, и его невероятно легко запомнить и понять правильно. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx#fnv&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ФПНА&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; альтернатива является аналогично простой, но использует различные константы и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;XOR&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вместо &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ADD&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в качестве операции комбинирования. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это выглядит &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что-то&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;как и в приведенном ниже коде, но обычный алгоритм FNV работает с отдельными байтами, поэтому для этого потребуется модификация для выполнения одной итерации на байт вместо 32-битного хеш-значения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNV также предназначен для переменных длин данных, тогда как мы используем его здесь всегда для одного и того же числа значений полей. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Комментарии к этому ответу предполагают, что код здесь на самом деле не работает (в тестируемом примере), как подход к добавлению, описанный выше.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dbfcc92679561cd466ca70d3ec5cb0ada4849da5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt; users can generate GetHashCode, Equals, and others with &lt;code&gt;ReSharper -&amp;gt; Edit -&amp;gt; Generate Code -&amp;gt; Equality Members&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Пользователи &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ReSharper&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; могут создавать GetHashCode, Equals и другие с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ReSharper -&amp;gt; Edit -&amp;gt; Generate Code -&amp;gt; Equality Members&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ea1ae0f0eb1ed12ed21ed926e7ffa399926aaaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueTuple&lt;/code&gt; is a struct and appears to have a solid &lt;code&gt;GetHashCode&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является структурой и, похоже, имеет твердую &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;реализацию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea0202aa9a3074625a51c3256d2dc385d6895a70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All the GetHashCode() implementations I'd coded in the past, and indeed used as the basis of answers on this site, were much worse than I'd throught&lt;/strong&gt;. Much of the time it was &quot;good enough&quot; for much of the uses, but I wanted something better.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Все реализации GetHashCode (), которые я кодировал в прошлом и действительно использовал в качестве основы для ответов на этом сайте, были намного хуже, чем я думал&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Большую часть времени это было &amp;laquo;достаточно хорошо&amp;raquo; для большей части использования, но я хотел чего-то лучшего.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64737e14d176ba9cf426f44088eeac87333a7a89" translate="yes" xml:space="preserve">
          <source>A good hash function should map the expected inputs as evenly as possible over its output range. It should have uniformity.</source>
          <target state="translated">Хорошая хэш-функция должна как можно более равномерно отображать ожидаемые входы в своем выходном диапазоне.Она должна иметь однородность.</target>
        </trans-unit>
        <trans-unit id="0b087b0c644a46bd6641921114f7033df6978d64" translate="yes" xml:space="preserve">
          <source>A small change to a message should change the hash value so extensively that the new hash value appears uncorrelated with the old hash value (avalanche effect).</source>
          <target state="translated">Небольшое изменение сообщения должно настолько сильно изменить значение хэша,что новое значение хэша окажется не связанным со старым значением хэша (лавинный эффект).</target>
        </trans-unit>
        <trans-unit id="bd1a4e418ac54c54625c46768d60dc7e55d97d21" translate="yes" xml:space="preserve">
          <source>Add the result and h1 together.</source>
          <target state="translated">Сложите результат и h1 вместе.</target>
        </trans-unit>
        <trans-unit id="f1c118123f96f8220daec90522f3b96d0f84b028" translate="yes" xml:space="preserve">
          <source>Also it has extension method to provide a fluent interface, so you can use it like this:</source>
          <target state="translated">Кроме того,он имеет метод расширения для обеспечения свободного интерфейса,так что вы можете использовать его таким образом:</target>
        </trans-unit>
        <trans-unit id="5924b5e6279dfd3f1ccd06d12d17ca745d917e31" translate="yes" xml:space="preserve">
          <source>And here is how to use it:</source>
          <target state="translated">И вот как им пользоваться:</target>
        </trans-unit>
        <trans-unit id="f7e8bccebca6d7ebf1c132bf64c36d31c8b3e398" translate="yes" xml:space="preserve">
          <source>And here is the acutal builder class:</source>
          <target state="translated">А вот и класс заостренных строителей:</target>
        </trans-unit>
        <trans-unit id="0b0c4ee6c49ec53c99f367f324f2d13f02203ef5" translate="yes" xml:space="preserve">
          <source>And it pretty much sucked. So after a bit of experimentation and research I started re-hashing my hashes with the following:</source>
          <target state="translated">И это было довольно отстойно.Так что после небольших экспериментов и исследований я начал затирать свои хэши следующим образом:</target>
        </trans-unit>
        <trans-unit id="4753226d060c2ac7870ac15825cb98de476efddf" translate="yes" xml:space="preserve">
          <source>And one final tip: &lt;b&gt;Don't rely on GetHashCode() being stable over multiple aplication runs&lt;/b&gt;. Many .Net types don't guarantee their hash codes to stay the same after a restart, so you should only use the value of GetHashCode() for in memory data structures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И последний совет: &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не надейтесь, что GetHashCode () будет стабильным в течение нескольких запусков приложений&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Многие типы .Net не гарантируют, что их хэш-коды останутся прежними после перезапуска, поэтому вы должны использовать только значение GetHashCode () для структур данных памяти.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c910bf934a6df4c337ec4ebc5ec681c2f90542e" translate="yes" xml:space="preserve">
          <source>And same for multi-type: all converted first to &lt;code&gt;int&lt;/code&gt; using &lt;code&gt;GetHashCode()&lt;/code&gt;
then the int values will be xor'ed and the result is your hash.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И то же самое для &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; мультитипа &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;: все сначала преобразуются в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; затем значения int будут занесены в xor, и в результате получится ваш хеш.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d58afc915a407c9686d470da7d4718874579746d" translate="yes" xml:space="preserve">
          <source>And then my power-of-two hash table didn't suck any more.</source>
          <target state="translated">А потом мой столик с двумя гашишами больше не сосал.</target>
        </trans-unit>
        <trans-unit id="e6524d5374d0dad18e089d93cca5b51530ed61a0" translate="yes" xml:space="preserve">
          <source>And this is from &lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/Common/src/System/Numerics/Hashing/HashHelpers.cs&quot;&gt;&lt;code&gt;HashHelper&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И это из &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/Common/src/System/Numerics/Hashing/HashHelpers.cs&quot;&gt; &lt;code&gt;HashHelper&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6ea4b5d260d1757dfef473e91d4cdc426f950356" translate="yes" xml:space="preserve">
          <source>And well, it was disturbing how much the &lt;code&gt;string.GetHashCode()&lt;/code&gt; implementations in &lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/System/string.cs,789&quot;&gt;.NET&lt;/a&gt; (or study &lt;a href=&quot;https://stackoverflow.com/a/48775953/147511&quot;&gt;here&lt;/a&gt;) could be improved this way (on the order of tests running about 20-30 times faster due to fewer collisions) and more disturbing how much my own hash codes could be improved (much more than that).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string.GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; беспокоит, насколько сильно &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;могут быть &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;реализованы реализации &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;string.GetHashCode ()&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/System/string.cs,789&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (или &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;изучено &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/48775953/147511&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) (порядка тестов, выполняющихся примерно в 20-30 раз быстрее из-за меньшего количества коллизий), и еще больше беспокоит то, как много моих хэш-кодов может быть улучшено (гораздо больше).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6539f8fb88e503a8b8c34ab6bcc63de114670a0b" translate="yes" xml:space="preserve">
          <source>Anonymous Type</source>
          <target state="translated">Анонимный тип</target>
        </trans-unit>
        <trans-unit id="2ef0204701e5a8adb4295eb5e9aa0eda969ef4cf" translate="yes" xml:space="preserve">
          <source>As @cactuaroid mentions in the comments, a value tuple can be used. This saves a few keystrokes and more importantly executes purely on the stack (no Garbage):</source>
          <target state="translated">Как упоминает @cactuaroid в комментариях,можно использовать кортеж значения.Это экономит несколько нажатий клавиш и,что более важно,выполняется чисто на стеке (без &quot;мусора&quot;):</target>
        </trans-unit>
        <trans-unit id="4884ca4fdea316ef7d5a10917de179b44aefe544" translate="yes" xml:space="preserve">
          <source>As noted in comments, you may find it's better to pick a large prime to multiply by instead. Apparently 486187739 is good... and although most examples I've seen with small numbers tend to use primes, there are at least similar algorithms where non-prime numbers are often used. In the not-quite-&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function&quot;&gt;FNV&lt;/a&gt; example later, for example, I've used numbers which apparently work well - but the initial value isn't a prime. (The multiplication constant &lt;em&gt;is&lt;/em&gt; prime though. I don't know quite how important that is.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как отмечено в комментариях, вы можете обнаружить, что вместо этого лучше выбрать большое простое число, на которое нужно умножить. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Очевидно, что 486187739 - это хорошо ... и хотя большинство примеров, которые я видел с небольшими числами, имеют тенденцию использовать простые числа, существуют, по крайней мере, похожие алгоритмы, где часто используются не простые числа. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, в примере &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;с не совсем &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FNV&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; позже я использовал числа, которые, по-видимому, работают хорошо, но начальное значение не является простым. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Постоянное умножение &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;является&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; простой , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;хотя. Я не знаю, как это важно.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0fc68588324515b00e71f04c950e60480e2bd553" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14863&quot;&gt;https://github.com/dotnet/coreclr/pull/14863&lt;/a&gt;, there is a new way to generate hash codes that is super simple! Just write</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Начиная с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14863&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/dotnet/coreclr/pull/14863&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , существует новый способ генерации хеш-кодов, который очень прост! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Просто пиши&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ba8400d7c27eb6bbe485bddce2a770e9a59f458" translate="yes" xml:space="preserve">
          <source>As per the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode#notes-to-inheritors&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Согласно &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode#notes-to-inheritors&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;документации&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6490b278794b35f12336f32cce320e3a69acab63" translate="yes" xml:space="preserve">
          <source>Because of this feature, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection and they should never be persisted.</source>
          <target state="translated">Благодаря этой функции,хэш-коды никогда не должны использоваться вне домена приложения,в котором они были созданы,они никогда не должны использоваться в качестве ключевых полей в коллекции и никогда не должны сохраняться.</target>
        </trans-unit>
        <trans-unit id="11b32f5445111f35152e714852144506ca1cb530" translate="yes" xml:space="preserve">
          <source>Because the Hash output is always an int, you can just chain Hash calls.</source>
          <target state="translated">Так как Хэш-выход всегда является int,вы можете просто цепь Хэш-вызовов.</target>
        </trans-unit>
        <trans-unit id="2273bd2f117653a9c56bbd3e76317b35a2b4389b" translate="yes" xml:space="preserve">
          <source>But this test passes (with ints):</source>
          <target state="translated">Но этот тест пройдет (с инъекциями):</target>
        </trans-unit>
        <trans-unit id="f120da2cf0f973ab74313965e44c104c28715694" translate="yes" xml:space="preserve">
          <source>By the way, the earlier algorithm is the one currently used by the C# compiler for anonymous types.</source>
          <target state="translated">Кстати,более ранний алгоритм в настоящее время используется компилятором C#для анонимных типов.</target>
        </trans-unit>
        <trans-unit id="28ec9ea2e98208ee3c50de6dbbd90da47726d6dc" translate="yes" xml:space="preserve">
          <source>Cryptographically Secure?</source>
          <target state="translated">Криптографически безопасно?</target>
        </trans-unit>
        <trans-unit id="f6798670eccb448dbd7ae61707aed7700330e4b5" translate="yes" xml:space="preserve">
          <source>Deterministic</source>
          <target state="translated">Deterministic</target>
        </trans-unit>
        <trans-unit id="f399f567d30257913aa40c9a0b774a97589e3f6c" translate="yes" xml:space="preserve">
          <source>Edit (May 2018): &lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt; getter is now a JIT intrinsic - the &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14125&quot;&gt;pull request&lt;/a&gt; is mentioned by Stephen Toub in &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Изменить (май 2018 г.): &lt;/font&gt;&lt;/font&gt; &lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; теперь является внутренним &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;свойством&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; JIT - &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14125&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;запрос&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;извлечение&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; упомянут Стивеном Тубом в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;этом сообщении&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;блоге&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f36d236cdfc72792355b5bd010191a1697cc8e21" translate="yes" xml:space="preserve">
          <source>Edit: I was also using open-addressing, which would also have increased the sensitivity to collision, perhaps more so than the fact it was power-of-two.</source>
          <target state="translated">Редакция:Я также использовал открытую адресацию,что также повысило бы чувствительность к столкновениям,возможно,больше,чем тот факт,что это было power-of-two.</target>
        </trans-unit>
        <trans-unit id="ec3029c0ba715ec4e3b4ba579e691c099b1e661c" translate="yes" xml:space="preserve">
          <source>For each further item, perform the operation on the previous result and the next item (e.g. h2).</source>
          <target state="translated">Для каждого последующего элемента выполните операцию по предыдущему результату и следующему элементу (например,h2).</target>
        </trans-unit>
        <trans-unit id="4a750761886bb8c5c3093d7d8da1f358a99b7be3" translate="yes" xml:space="preserve">
          <source>For those who use hash as ID (I mean an unique value), hash is naturally limited to a number of digits, I think it was 5 bytes for hashing algorithm, at least MD5.</source>
          <target state="translated">Для тех,кто использует хэш в качестве идентификатора (я имею в виду уникальное значение),хэш,естественно,ограничен количеством цифр,я думаю,это было 5 байт для алгоритма хэширования,как минимум MD5.</target>
        </trans-unit>
        <trans-unit id="d8558f6652b3cfc7c3336ced510c7c2259ad7976" translate="yes" xml:space="preserve">
          <source>GetHashCode Made Easy</source>
          <target state="translated">GetHashCode Made Easy</target>
        </trans-unit>
        <trans-unit id="034396c26c5e4ebc5bd1068b7529411104222377" translate="yes" xml:space="preserve">
          <source>HashCode.Add</source>
          <target state="translated">HashCode.Add</target>
        </trans-unit>
        <trans-unit id="0ba1e0a5a4926cff0e03ebbdb6d52b7a661256e8" translate="yes" xml:space="preserve">
          <source>HashCode.Combine</source>
          <target state="translated">HashCode.Combine</target>
        </trans-unit>
        <trans-unit id="d38b35ccba9919ce8b5b43ef1cf490a7f721401d" translate="yes" xml:space="preserve">
          <source>Here is another fluent implementation of &lt;a href=&quot;https://stackoverflow.com/a/263416/33791&quot;&gt;the algorithm posted above by Jon Skeet&lt;/a&gt;, but which includes no allocations or boxing operations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот еще одна свободная реализация &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/263416/33791&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;алгоритма, опубликованная выше Джоном Скитом&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но которая не включает в себя операции выделения или упаковки:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b1e0b14247c35a0dd98e5ba0eb642e4dc1843c1" translate="yes" xml:space="preserve">
          <source>Here is my hashcode helper.</source>
          <target state="translated">Вот мой помощник по хэшкоду.</target>
        </trans-unit>
        <trans-unit id="4be13d945c6ba718eeced4ba0389ce90b6ec6aa0" translate="yes" xml:space="preserve">
          <source>Here is my simplistic approach. I am using the classic builder pattern for this. It is typesafe (no boxing/unboxing) and also compatbile with .NET 2.0 (no extension methods etc.).</source>
          <target state="translated">Вот мой упрощенный подход.Я использую для этого классическую модель строителя.Он типизирован (без бокс-разборки),а также скомпилирован с .NET 2.0 (без методов расширения и т.д.).</target>
        </trans-unit>
        <trans-unit id="b8b27f99a942c6d3ce3eb645ca556e3c906c83ac" translate="yes" xml:space="preserve">
          <source>Here's my helper class using &lt;a href=&quot;https://stackoverflow.com/a/263416/704144&quot;&gt;Jon Skeet's implementation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот мой вспомогательный класс, использующий реализацию &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/263416/704144&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Джона Скита&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83ac8a659ca4db3fa8d7dcfd4473a8c41782b2c9" translate="yes" xml:space="preserve">
          <source>However, since it's now already written, one can make use of it more easily:</source>
          <target state="translated">Однако,так как он уже написан,его легче использовать:</target>
        </trans-unit>
        <trans-unit id="8cf06bfeb7893297f5b466ba135ef3e5a8c8a67d" translate="yes" xml:space="preserve">
          <source>I can guess that for multiple big int you can use this:</source>
          <target state="translated">Могу догадаться,что для множества важных дел ты можешь использовать это:</target>
        </trans-unit>
        <trans-unit id="6341f744676fe64ec4e97c176de06ac114def865" translate="yes" xml:space="preserve">
          <source>I changed my implementation to not use GetHashCode for the primitive types and it seems to work better</source>
          <target state="translated">Я изменил свою реализацию,чтобы не использовать GetHashCode для примитивных типов,и,похоже,это работает лучше.</target>
        </trans-unit>
        <trans-unit id="d44374f08bd16dc2acc4cd4ed9fad6603e35a2dc" translate="yes" xml:space="preserve">
          <source>I didn't assess its performance, so any feedback is welcomed.</source>
          <target state="translated">Я не оценивал его работу,поэтому любые отзывы приветствуются.</target>
        </trans-unit>
        <trans-unit id="3c7682f2756768262570b11ce2273bf6db42e85c" translate="yes" xml:space="preserve">
          <source>I have a Hashing class in Helper library that I use it for this purpose.</source>
          <target state="translated">У меня есть класс Hashing в библиотеке Helper,который я использую для этой цели.</target>
        </trans-unit>
        <trans-unit id="79484108e32c6a21344a0d900482a48b2c630c8f" translate="yes" xml:space="preserve">
          <source>I ran into an issue with floats and decimals using the implementation selected as the answer above.</source>
          <target state="translated">Я столкнулся с проблемой с плавающими и десятичными числами,используя реализацию,выбранную в качестве ответа выше.</target>
        </trans-unit>
        <trans-unit id="7eba8db330d45d66dcb0d37cd8b2aed9484677aa" translate="yes" xml:space="preserve">
          <source>I usually go with something like the implementation given in Josh Bloch's &lt;em&gt;fabulous&lt;/em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;Effective Java&lt;/a&gt;. It's fast and creates a pretty good hash which is unlikely to cause collisions. Pick two different prime numbers, e.g. 17 and 23, and do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обычно я использую что-то вроде реализации, описанной в &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сказочной &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0321356683&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эффективной Java&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Джоша Блоха &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это быстро и создает довольно хороший хеш, который вряд ли вызовет столкновения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Выберите два разных простых числа, например, 17 и 23, и выполните:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecd4a4ee6fb901f76f58984b6c90616cf19d910c" translate="yes" xml:space="preserve">
          <source>If we have no more than 8 properties (hopefully), here is another alternative.</source>
          <target state="translated">Если у нас не более 8 свойств (будем надеяться),то вот еще одна альтернатива.</target>
        </trans-unit>
        <trans-unit id="51e61bd0902dd12fd8399d10c1dfc7edf6c2bc67" translate="yes" xml:space="preserve">
          <source>If you are using .NET Standard 2.1 or above, you can use the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.hashcode?view=netcore-2.1&quot;&gt;System.HashCode&lt;/a&gt; struct. There are two methods of using it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы используете .NET Standard 2.1 или выше, вы можете использовать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;структуру &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.hashcode?view=netcore-2.1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.HashCode&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Есть два способа его использования:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7195ac0e83ef4a6feddbd250bff1ae20963d1157" translate="yes" xml:space="preserve">
          <source>If you want to avoid writing an extension method for System.Int32:</source>
          <target state="translated">Если вы хотите избежать написания метода расширения для System.Int32:</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="6488742a860c14ecbed74fa734de70954bb71e77" translate="yes" xml:space="preserve">
          <source>In .NET Core each time you restart an application you will get different hash codes. This is a security feature to prevent Denial of Service attacks (DoS). For .NET Framework you &lt;strong&gt;should&lt;/strong&gt; enable this feature by adding the following App.config file:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В .NET Core каждый раз при перезапуске приложения вы получаете разные хеш-коды. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это функция безопасности для предотвращения атак типа &amp;laquo;отказ в обслуживании&amp;raquo; (DoS). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для .NET Framework вы &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;должны&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; включить эту функцию, добавив следующий файл App.config:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4738d896b60dfae58b5b259b003bf59cce6e20b" translate="yes" xml:space="preserve">
          <source>In .NET, the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode&quot;&gt;&lt;code&gt;GetHashCode&lt;/code&gt; method&lt;/a&gt; is used in a lot of places throughout the .NET base class libraries. Implementing it properly is especially important to find items quickly in a collection or when determining equality.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В .NET &lt;/font&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метод &lt;/font&gt;&lt;/a&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; используется во многих местах в библиотеках базовых классов .NET. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для правильной его реализации особенно важно быстро находить элементы в коллекции или при определении равенства.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d045e350842340848d745e65b9ccc9cf28237c03" translate="yes" xml:space="preserve">
          <source>In English:</source>
          <target state="translated">На английском:</target>
        </trans-unit>
        <trans-unit id="66db6221d3fcbac7088e96ff309ffb23cfb5ad58" translate="yes" xml:space="preserve">
          <source>In case you want to polyfill &lt;code&gt;HashCode&lt;/code&gt; from &lt;code&gt;netstandard2.1&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы хотите заполнить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из &lt;/font&gt;&lt;/font&gt; &lt;code&gt;netstandard2.1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c40e2b1801b414478c669a008b937281f4d2dc69" translate="yes" xml:space="preserve">
          <source>In most cases where Equals() compares multiple fields it doesn't really matter if your GetHash() hashes on one field or on many. You just have to make sure that calculating the hash is really cheap (&lt;b&gt;No allocations&lt;/b&gt;, please) and fast (&lt;b&gt;No heavy computations&lt;/b&gt; and certainly no database connections) and provides a good distribution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В большинстве случаев, когда Equals () сравнивает несколько полей, на самом деле не имеет значения, хеширует ли ваш GetHash () одно или несколько полей. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вам просто нужно убедиться, что вычисление хеш-функции действительно дешево ( &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;без выделения ресурсов&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , пожалуйста) и быстро ( &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;без сложных вычислений&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и, конечно, без соединений с базой данных) и обеспечивает хорошее распределение.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70f850b780b4ffb79b7c73fda1edcded2180b380" translate="yes" xml:space="preserve">
          <source>In the end I settled on porting &lt;a href=&quot;http://burtleburtle.net/bob/hash/spooky.html&quot;&gt;SpookyHash&lt;/a&gt; to .NET. Indeed the code above is a fast-path version of using SpookyHash to produce a 32-bit output from a 32-bit input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В конце концов я остановился на портировании &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://burtleburtle.net/bob/hash/spooky.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SpookyHash&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на .NET. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Действительно, приведенный выше код является версией быстрого использования SpookyHash для получения 32-битного вывода из 32-битного ввода.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6243d71d1d7b8aea75619231aad11f8259651c82" translate="yes" xml:space="preserve">
          <source>Is there a standard algorithm or best practice on how to implement &lt;code&gt;GetHashCode&lt;/code&gt; for my custom classes so I don't degrade performance?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Существует ли стандартный алгоритм или лучшие рекомендации по реализации &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для моих пользовательских классов, чтобы я не снижал производительность?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79e480f23d6c2078c87bb12c8c5c3744c8de3f93" translate="yes" xml:space="preserve">
          <source>It also takes seed values, so if you need to deal with untrusted input and want to protect against Hash DoS attacks you can set a seed based on uptime or similar, and make the results unpredictable by attackers:</source>
          <target state="translated">Кроме того,для этого требуются начальные значения,так что если вам нужно иметь дело с недоверенными входными данными и вы хотите защитить себя от хеш-атак DoS,вы можете задать начальные значения,основанные на времени безотказной работы или аналогичные,и сделать результаты непредсказуемыми для злоумышленников:</target>
        </trans-unit>
        <trans-unit id="1cca014cbc07e3c62667a380b70f66b34a5849ca" translate="yes" xml:space="preserve">
          <source>It is infeasible to find two different messages with the same hash value</source>
          <target state="translated">Невозможно найти два разных сообщения с одинаковым значением хэша</target>
        </trans-unit>
        <trans-unit id="24065692dc06162d306ce6a1810804d176e738bc" translate="yes" xml:space="preserve">
          <source>It is infeasible to generate a message that yields a given hash value</source>
          <target state="translated">Невозможно сгенерировать сообщение,которое дает заданное хэш-значение.</target>
        </trans-unit>
        <trans-unit id="3e7c0769beb54d29fef29e364d96abec5127a859" translate="yes" xml:space="preserve">
          <source>It is used like this:</source>
          <target state="translated">Его используют вот так:</target>
        </trans-unit>
        <trans-unit id="775120da70c32a3d1145975d3b0b7ece50d6c047" translate="yes" xml:space="preserve">
          <source>It still avoids any heap allocation and is used exactly the same way:</source>
          <target state="translated">Он по-прежнему избегает любого распределения кучи и используется точно так же:</target>
        </trans-unit>
        <trans-unit id="af44925b98c54411762b5e115d90694d80c037bb" translate="yes" xml:space="preserve">
          <source>It would be nice to know more about the properties of this ROL-5 hash code algorithm.</source>
          <target state="translated">Было бы неплохо узнать больше о свойствах этого алгоритма хэш-кода ROL-5.</target>
        </trans-unit>
        <trans-unit id="cd73c970707454efb2b115cd12e169fd1fb86e9f" translate="yes" xml:space="preserve">
          <source>It's advantage is that it uses generic type arguments and therefore will not cause boxing:</source>
          <target state="translated">Преимущество заключается в том,что он использует общие аргументы типа и,следовательно,не вызовет бокса:</target>
        </trans-unit>
        <trans-unit id="f183efea3aaad2350f821613ad659f9d94954a53" translate="yes" xml:space="preserve">
          <source>It's fast, for which Bob Jenkins deserves most of the credit because his original code I ported from is faster still, especially on 64-bit machines which the algorithm is optimised for&amp;Dagger;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это быстро, за что Боб Дженкинс заслуживает большей части уважения, потому что его оригинальный код, с которого я портировал, еще быстрее, особенно на 64-битных машинах, алгоритм которых оптимизирован для &amp;Dagger;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db3b9d4536e07c34bc7e78f6730f683ac59ee7c3" translate="yes" xml:space="preserve">
          <source>Left rotate (circular shift) h1 by 5 positions.</source>
          <target state="translated">Вращайте влево (круговое смещение)h1 на 5 положений.</target>
        </trans-unit>
        <trans-unit id="9befb5f7f42c778c9ce669275d1ce6ed000d3ae9" translate="yes" xml:space="preserve">
          <source>Let's take a look at .NET Core's current implementation for &lt;code&gt;ValueTuple&lt;/code&gt;'s &lt;code&gt;GetHashCode&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Давайте посмотрим на текущей реализации .NET сердечника для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;laquo;s &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0cf40c5cdf4e24892afe91b39db417c88cd24a93" translate="yes" xml:space="preserve">
          <source>Microsoft already provides a good generic HashCode generator: Just copy your property/field values to an anonymous type and hash it:</source>
          <target state="translated">Microsoft уже предоставляет хороший генератор общего HashCode:Просто скопируйте значения поля свойств в анонимный тип и хэшируйте его:</target>
        </trans-unit>
        <trans-unit id="fe5e8cabf2e9ef3c90856c23a3b071fc8ffdadc2" translate="yes" xml:space="preserve">
          <source>Microsoft lead for several way of hashing...</source>
          <target state="translated">Майкрософт записал несколько способов хеширования...</target>
        </trans-unit>
        <trans-unit id="778fc4e9438d8fe69ff04d1a23db7d2a638261a0" translate="yes" xml:space="preserve">
          <source>Most of my work is done with database connectivity which means that my classes all have a unique identifier from the database.  I always use the ID from the database to generate the hashcode.</source>
          <target state="translated">Большая часть моей работы выполняется с подключением к базе данных,что означает,что все мои классы имеют уникальный идентификатор из базы данных.Я всегда использую идентификатор из базы данных для генерации хэш-кода.</target>
        </trans-unit>
        <trans-unit id="ebe8b198579b5d8d43b5b5961017777a829df670" translate="yes" xml:space="preserve">
          <source>Note that one thing to be aware of is that ideally you should prevent your equality-sensitive (and thus hashcode-sensitive) state from changing after adding it to a collection that depends on the hash code.</source>
          <target state="translated">Обратите внимание на то,что в идеале вы должны предотвратить изменение вашего чувствительного к равенству (и,следовательно,чувствительного к хэшу)состояния после добавления его в коллекцию,которая зависит от хэш-кода.</target>
        </trans-unit>
        <trans-unit id="94d46ec70da897d6695de00bf38d36857c1d2fb5" translate="yes" xml:space="preserve">
          <source>Note: If used with &lt;code&gt;struct&lt;/code&gt;, it will allocate memory due to boxing</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примечание: если используется со &lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , он будет выделять память из-за бокса&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5ac46a74dbff2b805e8a5a7d2626d1c776b451a" translate="yes" xml:space="preserve">
          <source>Now, SpookyHash is not a nice quick to remember piece of code. My port of it is even less so because I hand-inlined a lot of it for better speed*. But that's what code reuse is for.</source>
          <target state="translated">Теперь,SpookyHash-не лучший способ запомнить кусок кода.Мой порт его еще меньше,потому что я обработал его вручную для лучшей скорости*.Но для этого и нужно повторное использование кода.</target>
        </trans-unit>
        <trans-unit id="c849d5abd7981416f7339aea0af9b86419c5d93c" translate="yes" xml:space="preserve">
          <source>PS: This is one of those times where you puke a little in your mouth, knowing that this could be refactored into one method with 9 default's but it would be slower, so you just close your eyes and try to forget about it.</source>
          <target state="translated">PS:Это один из тех случаев,когда вас немного тошнит во рту,зная,что это можно переделать в один метод с 9 по умолчанию,но это будет медленнее,так что вы просто закроете глаза и попытаетесь забыть об этом.</target>
        </trans-unit>
        <trans-unit id="f065fd929e1c22be435487e6ea63fce4d6e76802" translate="yes" xml:space="preserve">
          <source>Pretty much similar to nightcoder's solution except it's easier to raise primes if you want to.</source>
          <target state="translated">Довольно похоже на раствор ночного кодирования,за исключением того,что при желании легче поднимать праймы.</target>
        </trans-unit>
        <trans-unit id="3595239fc3035d9f6e9e92d99a2bfdc06c060789" translate="yes" xml:space="preserve">
          <source>Prevent's DoS</source>
          <target state="translated">Предотвратить DoS</target>
        </trans-unit>
        <trans-unit id="b64211794d8e7415e42a8db9c7d0b1a28f11fc41" translate="yes" xml:space="preserve">
          <source>Re-mixing a hash code can only improve a hash code that did at least fairly well in avoiding absolute collisions throughout its range (2&lt;sup&gt;32&lt;/sup&gt; possible values) but badly at avoiding collisions when modulo'd down for actual use in a hash table. While the simpler modulo of a power-of-two table made this more apparent, it was also having a negative effect with the more common prime-number tables, that just wasn't as obvious (the extra work in rehashing would outweigh the benefit, but the benefit would still be there).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Повторное смешивание хеш-кода может улучшить только хеш-код, который, по крайней мере, довольно хорошо избежал абсолютных коллизий по всему диапазону (2 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;32&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; возможных значения), но плохо избежал коллизий, когда по модулю был выключен для фактического использования в хеш-таблице. В то время как более простой модуль таблицы степеней двух сделал это более очевидным, он также имел отрицательный эффект с более распространенными таблицами простых чисел, что было не так очевидно (дополнительная работа по перефразировке перевесила бы преимущество , но выгода все равно будет там).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fce0fc5a7dcd2e788a03afe8194230572d482cb6" translate="yes" xml:space="preserve">
          <source>Re-mixing a hash code can't improve a terrible hash code, because the only possible effect is we change e.g. a large number of collisions on value 53 to a large number of value 18,3487,291.</source>
          <target state="translated">Повторное смешивание хэш-кода не может улучшить ужасный хэш-код,потому что единственный возможный эффект-это изменение,например,большого количества столкновений на величину 53 на большое количество на величину 18 3487 291.</target>
        </trans-unit>
        <trans-unit id="3c9638d7db05fd5da4a874b5d52071ce2087a80e" translate="yes" xml:space="preserve">
          <source>Re-mixing a hashcode can't improve a great hashcode, because the only possible effect is that we introduce a few more collisions.</source>
          <target state="translated">Повторное смешивание хэшкода не может улучшить отличный хэшкод,потому что единственный возможный эффект-это то,что мы введем еще несколько коллизий.</target>
        </trans-unit>
        <trans-unit id="af1c5729918a7c13189ba3df1d45ae50f208a20f" translate="yes" xml:space="preserve">
          <source>Read more about this &lt;a href=&quot;https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подробнее об этом читайте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="555fb017bb0db82e04dccc34f592057fdb765838" translate="yes" xml:space="preserve">
          <source>Reduce Collisions</source>
          <target state="translated">Уменьшить число столкновений</target>
        </trans-unit>
        <trans-unit id="c67f54eca7526ba65a1d69b5e9d8b38b3f5067f1" translate="yes" xml:space="preserve">
          <source>Regrettably, deferring to &lt;code&gt;ValueTuple&lt;/code&gt; for our own &lt;code&gt;GetHashCode&lt;/code&gt; may not be as fast as we would like and expect. &lt;a href=&quot;https://github.com/dotnet/corefx/issues/8034#issuecomment-260759796&quot;&gt;This comment&lt;/a&gt; in a related discussion illustrates that directly calling &lt;code&gt;HashHelpers.Combine&lt;/code&gt; is more performant. On the flip side, that one is internal, so we'd have to copy the code, sacrificing much of what we had gained here. Also, we'd be responsible for remembering to first &lt;code&gt;Combine&lt;/code&gt; with the random seed. I don't know what the consequences are if we skip that step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;К сожалению, откладывание &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для нашего собственного &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; может быть не таким быстрым, как хотелось бы и ожидаем. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/issues/8034#issuecomment-260759796&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот комментарий&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в связанном обсуждении показывает, что прямой вызов &lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashHelpers.Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; более производительный. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С другой стороны, это внутреннее, поэтому нам пришлось бы копировать код, жертвуя большей частью того, что мы получили здесь. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, мы будем ответственны за то, что помним сначала &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; со случайным семенем. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я не знаю, каковы будут последствия, если мы пропустим этот шаг.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="41ef8b26263345cca597a7e0aa739b815f3e2403" translate="yes" xml:space="preserve">
          <source>So I put that project to one side (it was a pet project anyway) and started looking at how to produce a good, well-distributed hash code in .NET quickly.</source>
          <target state="translated">Так что я положил этот проект в одну сторону (это все равно был звериный проект)и начал смотреть,как быстро произвести хороший,хорошо распределенный хэш-код в .NET.</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="6b05d1dc7e9a6f239a0395230da12be3bfb344e6" translate="yes" xml:space="preserve">
          <source>Start by performing the above operation on { static random seed, h1 }.</source>
          <target state="translated">Начните с выполнения вышеуказанной операции над{статическим случайным семенем,h1 }.</target>
        </trans-unit>
        <trans-unit id="5e0f2002957c60cee86ff8251ef135dcad849b56" translate="yes" xml:space="preserve">
          <source>That means we could simply do this:</source>
          <target state="translated">Это значит,что мы можем просто сделать это:</target>
        </trans-unit>
        <trans-unit id="826b9d7df4ba107a7469f426428004097d06f89b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Add&lt;/code&gt; method helps you to deal with collections:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Add&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; помогает вам работать с коллекциями:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60a068f9545ee721c0e80f6ad49baf4bb1d421b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Combine&lt;/code&gt; method can be used to create a hash code, given up to eight objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Combine&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; можно использовать для создания хеш-кода, используя до восьми объектов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d787f0415844ae018bcf56dbf50989dcd7b9f11" translate="yes" xml:space="preserve">
          <source>The algorithm does not have to be a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;Cryptographic hash function&lt;/a&gt;. Meaning it does not have to satisfy the following conditions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм не обязательно должен быть &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;криптографической хеш-функцией&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это означает, что он не должен удовлетворять следующим условиям:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ac5541f8c7461f7bcb249fb14bcc008335a3fce" translate="yes" xml:space="preserve">
          <source>The algorithm that calculates a hash code needs to be fast. A simple algorithm is usually going to be a faster one.</source>
          <target state="translated">Алгоритм,вычисляющий хэш-код,должен быть быстрым.Простой алгоритм обычно будет более быстрым.</target>
        </trans-unit>
        <trans-unit id="045833a0e2d683cb1e8c1b7d651bc273a8823621" translate="yes" xml:space="preserve">
          <source>The algorithm that calculates a hash code needs to keep &lt;a href=&quot;http://crppit.epfl.ch/documentation/Hash_Function/WiKi/Hash_collision.htm&quot;&gt;hash collisions&lt;/a&gt; to a minumum. A hash collision is a situation that occurs when two calls to &lt;code&gt;GetHashCode&lt;/code&gt; on two different objects produce identical hash codes. Note that collisions are allowed (some have the misconceptions that they are not) but they should be kept to a minimum.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм, который вычисляет хеш-код, должен поддерживать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;минимальные &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://crppit.epfl.ch/documentation/Hash_Function/WiKi/Hash_collision.htm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;коллизии&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; хеш-кодов &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Столкновение хеша - это ситуация, которая возникает, когда два вызова &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для двух разных объектов производят идентичные хеш-коды. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что коллизии разрешены (у некоторых есть неправильные представления о том, что это не так), но они должны быть сведены к минимуму.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d740feb71d0fbf0408f6a65db8c993a4ea6592a0" translate="yes" xml:space="preserve">
          <source>The compiler will ensure &lt;code&gt;HashValue&lt;/code&gt; is not called with a class due to the generic type constraint. But there is no compiler support for &lt;code&gt;HashObject&lt;/code&gt; since adding a generic argument also adds a boxing operation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Компилятор гарантирует, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashValue&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не вызывается с классом из-за ограничения общего типа. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но &lt;/font&gt;&lt;/font&gt; &lt;code&gt;HashObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не поддерживает &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;компилятор,&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поскольку добавление универсального аргумента также добавляет операцию бокса.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa6cbb4a7d0cfa141362b4605fb3b5044a8ac454" translate="yes" xml:space="preserve">
          <source>The full code can be seen at &lt;a href=&quot;https://bitbucket.org/JonHanna/spookilysharp/src&quot;&gt;https://bitbucket.org/JonHanna/spookilysharp/src&lt;/a&gt; but consider that the code above is a simplified version of it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Полный код можно увидеть по адресу &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://bitbucket.org/JonHanna/spookilysharp/src&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://bitbucket.org/JonHanna/spookilysharp/src,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; но учтите, что приведенный выше код является его упрощенной версией.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6aea3a389963dd3279922dd6f8068aa1b709c3a3" translate="yes" xml:space="preserve">
          <source>The hashing algorithm needs to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;deterministic&lt;/a&gt; i.e. given the same input it must always produce the same output.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм хеширования должен быть &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Deterministic_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;детерминированным,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; т. Е. При одинаковых входных данных он всегда должен давать одинаковые выходные данные.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74843c914e569e3d934ad75c40cd9c55a7c17747" translate="yes" xml:space="preserve">
          <source>The heavy lifting should be part of the Equals() method; the hash should be a very cheap operation to enable calling Equals() on as few items as possible.</source>
          <target state="translated">Подъем тяжести должен быть частью метода Equals();хэш должен быть очень дешевой операцией,позволяющей вызывать Equals()на как можно меньшем количестве элементов.</target>
        </trans-unit>
        <trans-unit id="6a3bc6502919f9edd3fdb6c625b410c86d7f8039" translate="yes" xml:space="preserve">
          <source>Then I came back, and produced a lot of overloads to easily feed just about all of the native types (except &lt;code&gt;decimal&lt;/code&gt;&amp;dagger;) into a hash code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем я вернулся и произвел много перегрузок, чтобы легко передать почти все нативные типы (кроме &lt;/font&gt;&lt;/font&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;dagger;) в хеш-код.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f7483c49e6eb98b52f32043abddc6764971dca6b" translate="yes" xml:space="preserve">
          <source>Then I put &lt;em&gt;that&lt;/em&gt; project to one side, because just as the original project had produced the question of how to produce a better hash code, so that project produced the question of how to produce a better .NET memcpy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем я отложил &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;этот&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; проект в сторону, потому что так же, как исходный проект породил вопрос о том, как создать лучший хеш-код, так и этот проект поставил вопрос о том, как создать лучшую .NET memcpy.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8a3dd62d6429a57deee1938c2b8d63f6dec90e7d" translate="yes" xml:space="preserve">
          <source>Then, simply you can use it as:</source>
          <target state="translated">Тогда,просто ты можешь использовать его как:</target>
        </trans-unit>
        <trans-unit id="75cffc3515bdc95dc9b22f8fed1ab2f02044fac8" translate="yes" xml:space="preserve">
          <source>This disturbed me though, because the above shouldn't work. Or more precisely, it shouldn't work unless the original &lt;code&gt;GetHashCode()&lt;/code&gt; was poor in a very particular way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это беспокоило меня, потому что выше не должно работать. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Или, точнее говоря, он не должен работать, если исходный &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetHashCode()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не очень хорошо работает.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="516e8a7deb0de8522dade038b929c0204312d476" translate="yes" xml:space="preserve">
          <source>This is a good one:</source>
          <target state="translated">Хорошая шутка:</target>
        </trans-unit>
        <trans-unit id="1c7c1850d93fc274a256ffc70245af28400631ac" translate="yes" xml:space="preserve">
          <source>This is a static helper class that implements Josh Bloch's implementation; and provides explicit overloads to &quot;prevent&quot; boxing, and also to implement the hash specifically for the long primitives.</source>
          <target state="translated">Это статический вспомогательный класс,реализующий реализацию Josh Bloch;и предоставляющий явные перегрузки для &quot;предотвращения&quot; бокса,а также для реализации хэша специально для длинных примитивов.</target>
        </trans-unit>
        <trans-unit id="1307b741efe8c22ab33dd11c4f9ced9d341c0aa2" translate="yes" xml:space="preserve">
          <source>This is better than the common practice of &lt;code&gt;XOR&lt;/code&gt;ing hashcodes for two main reasons. Suppose we have a type with two &lt;code&gt;int&lt;/code&gt; fields:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это лучше, чем обычная практика использования &lt;/font&gt;&lt;/font&gt; &lt;code&gt;XOR&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; кодов &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;XOR&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; по двум основным причинам. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предположим, у нас есть тип с двумя &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;полями &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e70ae20c9fb580d40ebc1c00d330f1f1135e294b" translate="yes" xml:space="preserve">
          <source>This is from &lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.ValueTuple/src/System/ValueTuple/ValueTuple.cs&quot;&gt;&lt;code&gt;ValueTuple&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это из &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.ValueTuple/src/System/ValueTuple/ValueTuple.cs&quot;&gt; &lt;code&gt;ValueTuple&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d3c7ae92d1ff5acbdfec20e8c34d0f9543966a2" translate="yes" xml:space="preserve">
          <source>This test fails (floats; hash is the same even though I switched 2 values to be negative):</source>
          <target state="translated">Этот тест не удался (плавает;хэш тот же самый,даже если я переключил 2 значения на отрицательные):</target>
        </trans-unit>
        <trans-unit id="3c9c751854ebebe052bd9ac39e701ac7f3ee9751" translate="yes" xml:space="preserve">
          <source>This will generate a quality hash code without you having to worry about the implementation details.</source>
          <target state="translated">Это сгенерирует качественный хэш-код,и вам не придется беспокоиться о деталях реализации.</target>
        </trans-unit>
        <trans-unit id="2273401922a7ec31a62bf4c06628a6050af299e8" translate="yes" xml:space="preserve">
          <source>This will work for any number of properties. It does not use boxing. It just uses the algorithm already implemented in the framework for anonymous types.</source>
          <target state="translated">Это сработает для любого количества объектов.При этом не используется бокс.Он просто использует алгоритм,уже реализованный во фреймворке для анонимных типов.</target>
        </trans-unit>
        <trans-unit id="d9d9e2f475ad3bfe496517e55d50603c286f604d" translate="yes" xml:space="preserve">
          <source>Up until recently my answer would have been very close to Jon Skeet's here. However, I recently started a project which used power-of-two hash tables, that is hash tables where the size of the internal table is 8, 16, 32, etc. There's a good reason for favouring prime-number sizes, but there are some advantages to power-of-two sizes too.</source>
          <target state="translated">До недавнего времени мой ответ был бы очень близок к тому,что Джон Скит здесь.Однако недавно я запустил проект,в котором использовали power-of-two хэш-таблицы,то есть хэш-таблицы,в которых размер внутренней таблицы составляет 8,16,32 и т.д.Есть веская причина отдавать предпочтение прайм-номерным размерам,но есть и некоторые преимущества в Power-of-two размерах.</target>
        </trans-unit>
        <trans-unit id="342c659777997bec12f413246e5e24d6a8317e2a" translate="yes" xml:space="preserve">
          <source>Usage Example</source>
          <target state="translated">Пример использования</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="b33d830517aea3e2d9bb3019a44d1af09654b9ae" translate="yes" xml:space="preserve">
          <source>ValueTuple - Update for C# 7</source>
          <target state="translated">ValueTuple-обновление для C#7</target>
        </trans-unit>
        <trans-unit id="7f47afe10930417b5ac38c0d4b812852c49176ff" translate="yes" xml:space="preserve">
          <source>What Makes a Good Algorithm?</source>
          <target state="translated">Что делает хороший алгоритм?</target>
        </trans-unit>
        <trans-unit id="38242dbf222f22cf8723209c1d4c037f60de436c" translate="yes" xml:space="preserve">
          <source>What is the best algorithm for overriding GetHashCode</source>
          <target state="translated">Какой наилучший алгоритм переопределения GetHashCode</target>
        </trans-unit>
        <trans-unit id="a7927a0abfa9b169083b1cb33b972375e669f367" translate="yes" xml:space="preserve">
          <source>XOR the result with h2.</source>
          <target state="translated">XOR результат с h2.</target>
        </trans-unit>
        <trans-unit id="df90e78c7b7f1be042309f565b3a930a77da9bf6" translate="yes" xml:space="preserve">
          <source>You can compute the hash code from fields that are not mutable; or</source>
          <target state="translated">Вы можете вычислить хэш-код из полей,которые не являются мутируемыми;или</target>
        </trans-unit>
        <trans-unit id="7e0f5da3ef3eb98ebe66a0458acbe252a1335380" translate="yes" xml:space="preserve">
          <source>You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</source>
          <target state="translated">Вы можете гарантировать,что хэш-код мутируемого объекта не изменится,в то время как объект содержится в коллекции,которая полагается на его хэш-код.</target>
        </trans-unit>
        <trans-unit id="d14544f0139a010a5f0dfdedc09f3993f9ddda5c" translate="yes" xml:space="preserve">
          <source>You can override GetHashCode for immutable reference types. In general, for mutable reference types, you should override GetHashCode only if:</source>
          <target state="translated">Вы можете переопределить GetHashCode для неизменяемых типов ссылок.Обычно для мутируемых типов ссылок GetHashCode следует переопределять только в том случае,если:</target>
        </trans-unit>
        <trans-unit id="e8eb5c0af93ca2647da55c48e832b72309675a22" translate="yes" xml:space="preserve">
          <source>You can pass a string comparison that matches your equals implementation.</source>
          <target state="translated">Вы можете передать сравнение строк,которое соответствует реализации вашего равенства.</target>
        </trans-unit>
        <trans-unit id="70eae4f6b110439731d5eafcd9cbf8d01ea4d5bf" translate="yes" xml:space="preserve">
          <source>You can read the full blog post '&lt;a href=&quot;https://rehansaeed.com/gethashcode-made-easy/&quot;&gt;GetHashCode Made Easy&lt;/a&gt;' for more details and comments.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете прочитать полный пост в блоге &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rehansaeed.com/gethashcode-made-easy/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GetHashCode Made Easy&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo; для более подробной информации и комментариев.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e8dfb137940607558d3f7f402aaf01bf7d406d2" translate="yes" xml:space="preserve">
          <source>You may turn multiple values to a hashed value and some of them be same, so don't use it as an identifier. (maybe some day I am going to use your component)</source>
          <target state="translated">Вы можете превратить несколько значений в хэш-значение,и некоторые из них будут одинаковыми,поэтому не используйте их в качестве идентификатора.(может быть,когда-нибудь я использую ваш компонент).</target>
        </trans-unit>
        <trans-unit id="98658dbce77e0b4aea26c71003da55e305bd7c92" translate="yes" xml:space="preserve">
          <source>or like this:</source>
          <target state="translated">или вот так:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
