<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/2612802">
    <body>
      <group id="2612802">
        <trans-unit id="6cb2908973d6e330ac0831d07b21e8772ada79a7" translate="yes" xml:space="preserve">
          <source>(Here's the script if anyone's interested or wants to raise any issues:)</source>
          <target state="translated">(興味のある人や問題提起したい人は、この台本を見てください:)</target>
        </trans-unit>
        <trans-unit id="ebb3c26aa2a50c6bcf9364047f9a610d479174c0" translate="yes" xml:space="preserve">
          <source>.&lt;strong&gt;Bonus&lt;/strong&gt;: If you don't want to copy elements use (aka shallow copy):</source>
          <target state="translated">。 &lt;strong&gt;おまけ&lt;/strong&gt; ：要素をコピーしたくない場合（別名浅いコピー）：</target>
        </trans-unit>
        <trans-unit id="831f577c0630013fd2dd428aa6f69fbb8227958b" translate="yes" xml:space="preserve">
          <source>0.039 sec (0.39us/itn) - &lt;code&gt;old_list[:]&lt;/code&gt; (&lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;list slicing&lt;/a&gt;)</source>
          <target state="translated">0.039秒（0.39us / itn） &lt;code&gt;old_list[:]&lt;/code&gt; （ &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;リストのスライス&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="6576742e9a532381a3048dc91ed10879c2220a99" translate="yes" xml:space="preserve">
          <source>0.053 sec (0.53us/itn) - &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt;</source>
          <target state="translated">0.053秒（0.53us / itn） &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt; new_list.extend（old_list）</target>
        </trans-unit>
        <trans-unit id="589e176d08ceaa47627386f4c2ee43ef0e412c6f" translate="yes" xml:space="preserve">
          <source>0.075 sec (0.75us/itn) - &lt;code&gt;list(old_list)&lt;/code&gt;</source>
          <target state="translated">0.075秒（0.75us / itn）- &lt;code&gt;list(old_list)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbf31d4e561cfc6f0a7055b18ae7bb85966be0c" translate="yes" xml:space="preserve">
          <source>0.186 sec (1.86us/itn) - &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">0.186秒（1.86us / itn） &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9741537872f078018c930db04bb6b7a099568129" translate="yes" xml:space="preserve">
          <source>0.217 sec (2.17us/itn) - &lt;code&gt;[i for i in old_list]&lt;/code&gt; (a &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;list comprehension&lt;/a&gt;)</source>
          <target state="translated">0.217秒（2.17us / itn）- &lt;code&gt;[i for i in old_list]&lt;/code&gt; old_listのi for i] （ &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;リスト内包&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="fcb2fce8f80e6e96b412e3deb49a4a01eef9d95c" translate="yes" xml:space="preserve">
          <source>0.325 sec (3.25us/itn) - &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</source>
          <target state="translated">0.325秒（3.25us / itn） &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a196696ac9e805fcf92036506af3ef7d8ab819d" translate="yes" xml:space="preserve">
          <source>1.488 sec (14.88us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method not copying classes (only dicts/lists/tuples)</source>
          <target state="translated">1.488秒（14.88us / itn）-純粋なpython &lt;code&gt;Copy()&lt;/code&gt; メソッドがクラスをコピーしない（dicts / lists / tuplesのみ）</target>
        </trans-unit>
        <trans-unit id="c36d3f84b0185c78311f648cfb81e4cacde6b9c9" translate="yes" xml:space="preserve">
          <source>10.16 sec (101.6us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method copying classes with deepcopy</source>
          <target state="translated">10.16秒（101.6us / itn）-deepcopyでクラスをコピーする純粋なPython &lt;code&gt;Copy()&lt;/code&gt; メソッド</target>
        </trans-unit>
        <trans-unit id="892f509cfed7a878055c5d6330a5e7a7032f54b5" translate="yes" xml:space="preserve">
          <source>10.59 sec (105.9us/itn) -  &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">10.59秒（105.9us / itn） &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24d242d81528698f099460d3c52d07280215058e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;Alex Martelli's&lt;/a&gt; opinion (at least &lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;back in 2007&lt;/a&gt;) about this is, that &lt;em&gt;it is a weird syntax and it does not make sense to use it ever&lt;/em&gt;. ;) (In his opinion, the next one is more readable).</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;これに関するAlex Martelliの&lt;/a&gt;意見（少なくとも&lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;2007年には&lt;/a&gt; ）は、これは&lt;em&gt;奇妙な構文であり、これを使用しても意味がありません&lt;/em&gt; 。 ;）（彼の意見では、次のものはもっと読みやすいです）。</target>
        </trans-unit>
        <trans-unit id="cb21dd5df394bc7fae7c132b18417ae29a3bc579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b = a * 1&lt;/code&gt; also does surprisingly well.</source>
          <target state="translated">&lt;code&gt;b = a * 1&lt;/code&gt; も驚くほどうまくいきます。</target>
        </trans-unit>
        <trans-unit id="d9ef3187620786222a615d86bcc314673d3289f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list_2&lt;/code&gt; should reference to another object which is copy of &lt;code&gt;list_2&lt;/code&gt;. Let's check:</source>
          <target state="translated">&lt;code&gt;list_2&lt;/code&gt; は、 &lt;code&gt;list_2&lt;/code&gt; のコピーである別のオブジェクトを参照する必要があります。 確認しよう：</target>
        </trans-unit>
        <trans-unit id="4f36085cfc8ae8adb7dd3849ea72baa17b0c317a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_list&lt;/code&gt; is just a name that points to the actual list in memory. When you say &lt;code&gt;new_list = my_list&lt;/code&gt; you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists.</source>
          <target state="translated">&lt;code&gt;my_list&lt;/code&gt; は、メモリ内の実際のリストを指す単なる名前です。 &lt;code&gt;new_list = my_list&lt;/code&gt; と言うと、コピーを作成するのではなく、メモリ内の元のリストを指す別の名前を追加するだけです。 リストのコピーを作成すると、同様の問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="2041e8c18dbff0914a06b5e2a1252d4733642d53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_list = my_list&lt;/code&gt;
Try to understand this. Let's say that my_list is in the heap memory at location X i.e. my_list is pointing to the X. Now by assigning &lt;code&gt;new_list = my_list&lt;/code&gt; you're Letting new_list pointing to the X. This is known as shallow Copy.</source>
          <target state="translated">&lt;code&gt;new_list = my_list&lt;/code&gt; これを理解してみてください。 my_listがXのヒープメモリにあるとしましょう。つまり、my_listがXを指しています。ここで、 &lt;code&gt;new_list = my_list&lt;/code&gt; を割り当てることにより、new_listがXを指しています。これは、浅いコピーと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="8ef17a4719ab0f78b42c3681f36203e226fb86dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EXAMPLES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EXAMPLES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fd15ef13529e8eb7aac1e4fb2625df3343dbcd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that these methods do &lt;em&gt;not&lt;/em&gt; output equivalent results for any input other than lists.&lt;/strong&gt; They all work for sliceable objects, a few work for any iterable, but only &lt;code&gt;copy.copy()&lt;/code&gt; works for more general Python objects.</source>
          <target state="translated">&lt;strong&gt;これらのメソッドは、リスト以外の入力に対して同等の結果を出力し&lt;em&gt;ない&lt;/em&gt;ことに注意してください。&lt;/strong&gt; これらはすべてスライス可能オブジェクトで機能し、一部は反復可能オブジェクトで機能しますが、より一般的なPythonオブジェクトで機能するのは &lt;code&gt;copy.copy()&lt;/code&gt; のみです。</target>
        </trans-unit>
        <trans-unit id="6044cdaafb431c7ebd900f17cd900457b458ca20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;: Deepcopy uses recursion to duplicate objects, and merely returns the same immutable objects as before, as immutable objects cannot be duplicated. However, it deepcopies the most inner layers of mutable objects until it reaches the outermost mutable layer of an object.</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt; ：不変オブジェクトは複製できないため、Deepcopyは再帰を使用してオブジェクトを複製し、以前と同じ不変オブジェクトを返すだけです。 ただし、オブジェクトの最も外側の変更可能なレイヤーに到達するまで、変更可能なオブジェクトの最も内側のレイヤーをディープコピーします。</target>
        </trans-unit>
        <trans-unit id="0669e0817e0ab8178fe6bdeadc9d599cc4692d12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using new_list = my_list then modifies new_list every time my_list changes. Why is this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;次に、new_list = my_listを使用すると、my_listが変更されるたびにnew_listが変更されます。&lt;/strong&gt; &lt;strong&gt;どうしてこれなの？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d45c9a0fde240fd63fbe4e27fddcf428b240c39" translate="yes" xml:space="preserve">
          <source>A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists.</source>
          <target state="translated">浅いコピーは、リストに含まれるオブジェクトへの参照の入れ物であるリスト自体をコピーするだけです。含まれているオブジェクト自体が変異可能であり、一方が変更された場合、その変更は両方のリストに反映されます。</target>
        </trans-unit>
        <trans-unit id="005c37f0237b5cb139854b9e4687176ca563565b" translate="yes" xml:space="preserve">
          <source>A slight practical perspective to look into memory through id and gc.</source>
          <target state="translated">idとgcからメモリを覗くちょっと実用的な視点。</target>
        </trans-unit>
        <trans-unit id="8261b218a41d10fe8c0dcd15e9088d1cb42e6891" translate="yes" xml:space="preserve">
          <source>A very simple approach independent of python version was missing in already given answers which you can use most of the time (at least I do):</source>
          <target state="translated">pythonのバージョンに依存しない非常にシンプルなアプローチは、あなたがほとんどの時間(少なくとも私は)を使用することができますすでに与えられた答えに欠けていた。</target>
        </trans-unit>
        <trans-unit id="3498a4737c6e7fe24088dc089c3bcc79dda6d821" translate="yes" xml:space="preserve">
          <source>All of the other contributors gave &lt;strong&gt;great&lt;/strong&gt; answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only &lt;code&gt;copy.deepcopy()&lt;/code&gt; works to clone/copy a list and not have it point to the nested &lt;code&gt;list&lt;/code&gt; objects when you are working with multidimensional, nested lists (list of lists). While &lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;Felix Kling&lt;/a&gt; refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to &lt;code&gt;deepcopy&lt;/code&gt;.</source>
          <target state="translated">他のすべての貢献者が&lt;strong&gt;素晴らしい&lt;/strong&gt;答えを出しましたが、これは単一の次元（レベル化）リストがある場合に機能しますが、これまでに述べたメソッドの場合、 &lt;code&gt;copy.deepcopy()&lt;/code&gt; のみが機能し、リストを複製/コピーして、多次元のネストされたリスト（リストのリスト）で作業しているときのネストされた &lt;code&gt;list&lt;/code&gt; オブジェクト。 &lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;Felix Kling&lt;/a&gt;は彼の回答でそれについて言及していますが、この問題にはもう少しあります。おそらく、 &lt;code&gt;deepcopy&lt;/code&gt; のより高速な代替手段となる可能性のあるビルトインを使用した回避策があります。</target>
        </trans-unit>
        <trans-unit id="6a258d25732edb4a8dc4c53104d80ea8e8ba4b1f" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;deepcopy_list&lt;/strong&gt; looks like this:</source>
          <target state="translated">そして、 &lt;strong&gt;deepcopy_list&lt;/strong&gt;は次のようになります。</target>
        </trans-unit>
        <trans-unit id="99c81ac1dec28ab432158972b11dcd87811305fd" translate="yes" xml:space="preserve">
          <source>And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.</source>
          <target state="translated">そして、ディープコピーされたリストはオリジナルとは全く異なるリストであることがわかります。独自の関数をロールすることもできますが、そうしないでください。標準ライブラリのディープコピー関数を使うことで、そうでなければ発生しなかったバグが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="baf0b49d9e610c1e0b9aaf4f81c197fe9b3f4561" translate="yes" xml:space="preserve">
          <source>And we have to copy both lists, now starting from the first list:</source>
          <target state="translated">両方のリストをコピーして、最初のリストから始めます。</target>
        </trans-unit>
        <trans-unit id="9d4cea5d2aa1cef4716a69ab86f2a6adcf09e2c9" translate="yes" xml:space="preserve">
          <source>As others have stated, there  &lt;strong&gt;&lt;em&gt;are significant&lt;/em&gt;&lt;/strong&gt; performance issues using the &lt;code&gt;copy&lt;/code&gt; module and &lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;strong&gt;&lt;em&gt;for multidimensional lists&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">他の人が述べたように、 &lt;strong&gt;&lt;em&gt;多次元リストに対して&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;copy&lt;/code&gt; モジュールと &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;strong&gt;&lt;em&gt;を&lt;/em&gt;&lt;/strong&gt;使用すると、パフォーマンスに&lt;strong&gt;&lt;em&gt;重大&lt;/em&gt;&lt;/strong&gt;な問題があり&lt;strong&gt;&lt;em&gt;ます&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c03a694d0b4332e4b08b86ede988da2173792481" translate="yes" xml:space="preserve">
          <source>As was pointed out by both &lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;Aaron Hall&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ring&lt;/a&gt;&lt;strong&gt;using &lt;code&gt;eval()&lt;/code&gt; is not only a bad idea, it is also much slower than &lt;code&gt;copy.deepcopy()&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;アーロンホール&lt;/a&gt;と&lt;strong&gt; &lt;code&gt;eval()&lt;/code&gt; を使用&lt;/strong&gt;した&lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ringの&lt;/a&gt;両方が指摘した&lt;strong&gt;ように、これは悪い考えであるだけでなく、 &lt;code&gt;copy.deepcopy()&lt;/code&gt; よりもはるかに低速です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0bae3de46c365ceae27557d207d519a16f03d1f" translate="yes" xml:space="preserve">
          <source>As you can see Solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.</source>
          <target state="translated">ご覧のように、入れ子になったリストを使用していないときには、ソリューション#1は完璧に動作しました。解決策#1を入れ子になったリストに適用するとどうなるかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="1fa9f6c88dde54a4948d45a55a86287ba1ddfa53" translate="yes" xml:space="preserve">
          <source>As you can see both IDs are different, meaning we can assume that both nested lists are pointing different object now.</source>
          <target state="translated">つまり、入れ子になっているリストは両方とも別のオブジェクトを指していることになります。</target>
        </trans-unit>
        <trans-unit id="76931cafef2a867dc6f7e1459fcb607ba73ac1cc" translate="yes" xml:space="preserve">
          <source>As you can see, it didn't modify the original nested list, it only modified the copied list.</source>
          <target state="translated">ご覧のように、これは元の入れ子になったリストを変更せず、コピーされたリストを変更しただけです。</target>
        </trans-unit>
        <trans-unit id="3bd849e1d81d4729cb3f7546cfc9844c9422980a" translate="yes" xml:space="preserve">
          <source>As you can see, it only modified the copied list. That means it worked.</source>
          <target state="translated">ご覧の通り、コピーされたリストを修正しただけです。つまり、うまくいったということです。</target>
        </trans-unit>
        <trans-unit id="7f5db9e07be4014478905b5c75e8654633a0eeb3" translate="yes" xml:space="preserve">
          <source>At the core of any deep copy function is way to make a shallow copy. How? Simple. Any deep copy function only duplicates the containers of immutable objects. When you deepcopy a nested list, you are only duplicating the outer lists, not the mutable objects inside of the lists. You are only duplicating the containers. The same works for classes, too. When you deepcopy a class, you deepcopy all of its mutable attributes. So, how? How come you only have to copy the containers, like lists, dicts, tuples, iters, classes, and class instances?</source>
          <target state="translated">深いコピー機能の核心は、浅いコピーを作る方法です。どうやって?簡単です。どんなディープコピー関数も、不変オブジェクトのコンテナを複製するだけです。入れ子になったリストをディープコピーするときは、外側のリストを複製しているだけで、リストの中の不変オブジェクトを複製しているわけではありません。複製しているのはコンテナだけです。これはクラスに対しても同じことが言えます。クラスをディープコピーするときには、そのクラスのすべての変異可能な属性をディープコピーします。では、どうやって?リスト、ディクト、タプル、イター、クラス、クラスインスタンスのようなコンテナだけをコピーすればいいのですか?</target>
        </trans-unit>
        <trans-unit id="e99ab5abd5933a0d7d0b66c200bfec3d28b8a6b1" translate="yes" xml:space="preserve">
          <source>Both nested lists are pointing different object and they have separate copy of nested list now.</source>
          <target state="translated">両方のネストされたリストは別のオブジェクトを指しており、ネストされたリストのコピーを別々に持っています。</target>
        </trans-unit>
        <trans-unit id="836b19e7f8037813d193adb0ea22763be677a48c" translate="yes" xml:space="preserve">
          <source>Both outer lists have different IDs, let's try this on the inner nested lists.</source>
          <target state="translated">外側のリストと外側のリストではIDが異なるので、内側の入れ子になっているリストで試してみましょう。</target>
        </trans-unit>
        <trans-unit id="f079e1b881840a2f35a6dd6a384ae5baae282f12" translate="yes" xml:space="preserve">
          <source>Both variables are the exact same argument. Are you surprised?</source>
          <target state="translated">どちらの変数も全く同じ引数です。驚いた?</target>
        </trans-unit>
        <trans-unit id="97e297e7f407d34ed9e7296aa23537583633a817" translate="yes" xml:space="preserve">
          <source>Deep copies</source>
          <target state="translated">ディープコピー</target>
        </trans-unit>
        <trans-unit id="80c240c06fa36efab33567b8dd004136b3a42e84" translate="yes" xml:space="preserve">
          <source>Do you think we're done? No. Let's try to copy our nested list.</source>
          <target state="translated">これで終わりかな?いや、入れ子になったリストをコピーしてみよう。</target>
        </trans-unit>
        <trans-unit id="579defd972ab926c631e8d21e9eff8c734a498e0" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; を使用しない</target>
        </trans-unit>
        <trans-unit id="1a27986749695e29a6ff85bbb5c2f396fd63cf1d" translate="yes" xml:space="preserve">
          <source>Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.</source>
          <target state="translated">リストの各要素は、それぞれの要素がオブジェクトに非排他的に結合するという点で、名前のように動作します。浅いコピーは、要素が以前と同じオブジェクトにバインドされた新しいリストを作成します。</target>
        </trans-unit>
        <trans-unit id="100e61c040833faea556e102ff4c6f46b647f7ed" translate="yes" xml:space="preserve">
          <source>Edit: New information brought to light</source>
          <target state="translated">編集:新たな情報が明らかに</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="e959b489a54884803ea418506d068419cb2bc499" translate="yes" xml:space="preserve">
          <source>Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:</source>
          <target state="translated">フェリックスはすでに素晴らしい回答を提供してくれましたが、私は様々な方法のスピード比較をしてみようと思いました。</target>
        </trans-unit>
        <trans-unit id="dd44e670da0e5e9141f6396dd8d5c9a9a6ec0348" translate="yes" xml:space="preserve">
          <source>Here are the timing results using Python 3.6.8. Keep in mind these times are relative to one another, not absolute.</source>
          <target state="translated">以下はPython 3.6.8を使ったタイミングの結果です。これらの時間は互いに相対的なものであり、絶対的なものではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7aa26673265eca05d895ce387611ec36d0b80e52" translate="yes" xml:space="preserve">
          <source>Here in the image list_1 and copy are two variable names but the object is same for both variable which is &lt;code&gt;list&lt;/code&gt;</source>
          <target state="translated">ここの画像では、 &lt;code&gt;list&lt;/code&gt; _1とコピーは2つの変数名ですが、オブジェクトはリストである両方の変数で同じです</target>
        </trans-unit>
        <trans-unit id="9767ca12b4902a277abb578b041a4030915e4f7b" translate="yes" xml:space="preserve">
          <source>Here is the testing code for interested parties (&lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;Template from here&lt;/a&gt;):</source>
          <target state="translated">これは関係者のためのテストコードです（ &lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;ここからのテンプレート&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="290e2f376f5eaf8c22b1793823c15aae8fcd1d51" translate="yes" xml:space="preserve">
          <source>How to clone or copy a list</source>
          <target state="translated">リストをクローンまたはコピーする方法</target>
        </trans-unit>
        <trans-unit id="25d3f80cbc35ca2648934a22a93b5357eecb73c4" translate="yes" xml:space="preserve">
          <source>However, If my_list contains other containers (for eg. nested lists) you must use deepcopy as others suggested in the answers above from the copy library. For example:</source>
          <target state="translated">しかし、my_listに他のコンテナ(例えば、入れ子になったリスト)が含まれている場合は、上記の回答で提案されているように、コピーライブラリからディープコピーを使用する必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4edc1a0498725bd60f03b13cb73da0476b50e73c" translate="yes" xml:space="preserve">
          <source>I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python2, such as &lt;code&gt;list.copy()&lt;/code&gt; (the Python3 &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;slice equivalent&lt;/a&gt;) and two forms of &lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;list unpacking&lt;/a&gt; (&lt;code&gt;*new_list, = list&lt;/code&gt; and &lt;code&gt;new_list = [*list]&lt;/code&gt;):</source>
          <target state="translated">浅いコピーのみを行うことにこだわり、 &lt;code&gt;list.copy()&lt;/code&gt; （Python3の&lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;スライスに相当するもの&lt;/a&gt; ）や2つの形式の&lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;リストのアンパック&lt;/a&gt; （ &lt;code&gt;*new_list, = list&lt;/code&gt; および &lt;code&gt;new_list = [*list]&lt;/code&gt; ）など、Python2では不可能だったいくつかの新しいメソッドも追加しました[*リスト] ）：</target>
        </trans-unit>
        <trans-unit id="013e110db0a05f5dbd20f8b57eade2f83a54868e" translate="yes" xml:space="preserve">
          <source>I wanted to post something a bit different then some of the other answers. Even though this is most likely not the most understandable, or fastest option, it provides a bit of an inside view of how deep copy works, as well as being another alternative option for deep copying. It doesn't really matter if my function has bugs, since the point of this is to show a way to copy objects like the question answers, but also to use this as a point to explain how deepcopy works at its core.</source>
          <target state="translated">他の回答とは少し違ったものを投稿したいと思いました。これは、おそらく最も理解しやすい、あるいは最も速いオプションではないでしょうが、ディープコピーがどのように動作するかの内部のビューを提供しています。私の関数にバグがあっても問題ではありません。これのポイントは、質問の答えのようにオブジェクトをコピーする方法を示すことですが、ディープコピーがどのように動作するかを説明するポイントとしても使用します。</target>
        </trans-unit>
        <trans-unit id="09c0b5ded50202962dc2368628c1933a8369a2c8" translate="yes" xml:space="preserve">
          <source>I've &lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;been told&lt;/a&gt; that Python 3.3+ &lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt;adds &lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method, which should be as fast as slicing:</source>
          <target state="translated">Python 3.3以降で&lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt;は、 &lt;code&gt;list.copy()&lt;/code&gt; &lt;/a&gt;メソッドが追加 &lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;されると言われ&lt;/a&gt;ています 。これはスライスと同じくらい高速です。</target>
        </trans-unit>
        <trans-unit id="d8a425aac0dd5c097429125cc2f15c4bcc6557bd" translate="yes" xml:space="preserve">
          <source>If the list contains objects and you want to copy them as well, use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">リストにオブジェクトが含まれていて、それらもコピーする場合は、汎用の&lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy()&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="508aa1ec404f76db49d3513ef7b4d07bcec9be02" translate="yes" xml:space="preserve">
          <source>If you like my detailed answer, I would appreciate if you would upvote it. If you have any doubt about this answer, you can comment it down below.</source>
          <target state="translated">私の詳細な回答を気に入っていただけましたら、アップコメントしていただけると幸いです。この回答について疑問がある場合は、以下にコメントしてください。</target>
        </trans-unit>
        <trans-unit id="f608b902f462e04b6d6182623136fb4a743d3d57" translate="yes" xml:space="preserve">
          <source>In 64 bit Python 2.7:</source>
          <target state="translated">64ビットのPython 2.7で。</target>
        </trans-unit>
        <trans-unit id="2212a7dd8b8134dc3343d8ad7cbe5fae3fce8816" translate="yes" xml:space="preserve">
          <source>In Python 2 and 3, you can get a shallow copy with a full slice of the original:</source>
          <target state="translated">Python2と3では、浅いコピーをフルスライスで取得できるようになっています。</target>
        </trans-unit>
        <trans-unit id="4ac599cde0b2c5ab6842e5b2c183be812be9d03e" translate="yes" xml:space="preserve">
          <source>In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:</source>
          <target state="translated">Python 2では、リストの浅いコピーを作るには、元のリストを完全にスライスして作るという慣用的な方法をとっています。</target>
        </trans-unit>
        <trans-unit id="c1a7abb8ba4c30e338a899c8b6ef3d8068af2771" translate="yes" xml:space="preserve">
          <source>In Python 3, a shallow copy can be made with:</source>
          <target state="translated">Python 3では、浅いコピーができるようになりました。</target>
        </trans-unit>
        <trans-unit id="8fb02af71a6aec0493954b8ede599618597636b0" translate="yes" xml:space="preserve">
          <source>In Python 3, lists get the &lt;code&gt;list.copy&lt;/code&gt; method:</source>
          <target state="translated">Python 3では、リストは &lt;code&gt;list.copy&lt;/code&gt; メソッドを取得します。</target>
        </trans-unit>
        <trans-unit id="80e3fc6970cca93fe92c32b6c4ba9f0ab890dd92" translate="yes" xml:space="preserve">
          <source>In Python 3.5:</source>
          <target state="translated">Python 3.5 で。</target>
        </trans-unit>
        <trans-unit id="e1e6045a5cef20010f69d146803165ac49a5152d" translate="yes" xml:space="preserve">
          <source>It creates the copy of list but only outer list copy, not the nested list copy, nested list is same for both variable, so if you try to modify the nested list then it will modify the original list too as the nested list object is same for both lists.</source>
          <target state="translated">これはリストのコピーを作成しますが、外側のリストのコピーのみを作成し、入れ子になったリストのコピーは作成しません。入れ子になったリストは両方の変数に対して同じです。</target>
        </trans-unit>
        <trans-unit id="d34c379d10b758183565c52320bbe1d3d85b2994" translate="yes" xml:space="preserve">
          <source>It outputs:</source>
          <target state="translated">出力します。</target>
        </trans-unit>
        <trans-unit id="98a7ab1fd383d07403bec0fdbf00b56735e9d4fa" translate="yes" xml:space="preserve">
          <source>It surprises me that this hasn't been mentioned yet, so for the sake of completeness...</source>
          <target state="translated">これがまだ言及されていないのには驚いたので、完全性のために...</target>
        </trans-unit>
        <trans-unit id="f22686b03873b3c74078fb08c5978fac2477ccf4" translate="yes" xml:space="preserve">
          <source>It uses a new one for lists:</source>
          <target state="translated">リストには新しいものを使用しています。</target>
        </trans-unit>
        <trans-unit id="c598a66587c1a2b513dfdee0f11cfe379df4fc51" translate="yes" xml:space="preserve">
          <source>It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.</source>
          <target state="translated">その場合の唯一の本当の選択肢は、複数のリストを初期化して独立して作業することだと思われます。多次元リストのコピーを処理する方法について、他に何か提案があれば、ありがたいです。</target>
        </trans-unit>
        <trans-unit id="bfec348e3000941e5686d75ef056c9817e63c4f9" translate="yes" xml:space="preserve">
          <source>It's also less performant.</source>
          <target state="translated">演技力も落ちている。</target>
        </trans-unit>
        <trans-unit id="e5e39dfe9f9b8c35e9d451cae1bbf0f97001f659" translate="yes" xml:space="preserve">
          <source>It's dangerous, particularly if you're evaluating something from a source you don't trust.</source>
          <target state="translated">特に信用できないソースからの評価なら危険です。</target>
        </trans-unit>
        <trans-unit id="30201c551b5097249c25a2dcab3ffcb946ee7734" translate="yes" xml:space="preserve">
          <source>It's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.</source>
          <target state="translated">コピーしている部分要素が、等価な要素を再現するためにevalできる表現を持っていないと、信頼性がありません。</target>
        </trans-unit>
        <trans-unit id="92b01213c7f0b76ca02c2f59a64061096e1ca746" translate="yes" xml:space="preserve">
          <source>It's simple. A mutable object can't really be duplicated. It can never be changed, so it is only a single value. That means you never have to duplicate strings, numbers, bools, or any of those. But how would you duplicate the containers? Simple. You make just initialize a new container with all of the values. Deepcopy relies on recursion. It duplicates all the containers, even ones with containers inside of them, until no containers are left. A container is an immutable object.</source>
          <target state="translated">単純なことです。変異可能なオブジェクトは本当に複製することができません。決して変更することができないので、1つの値だけになります。つまり、文字列や数字、boolなどを複製する必要がないということです。しかし、コンテナをどうやって複製するのでしょうか?簡単です。すべての値を含む新しいコンテナを初期化するだけです。ディープコピーは再帰に依存しています。コンテナの中にコンテナが入っているものも含めて、コンテナがなくなるまですべてのコンテナを複製します。コンテナは不変のオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="45fb77de6753c9a311b64100017c382af6c0cc51" translate="yes" xml:space="preserve">
          <source>Let's check this:</source>
          <target state="translated">これを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="0c5355b2834dda4cbab54f13603bb0d4f281a582" translate="yes" xml:space="preserve">
          <source>Let's start from the beginning and explore this question.</source>
          <target state="translated">最初からこの疑問を探っていきましょう。</target>
        </trans-unit>
        <trans-unit id="4ea13a33e351858421ccf9c6208908351b78f68b" translate="yes" xml:space="preserve">
          <source>Let's understand difference between Solution#1 and Solution #2</source>
          <target state="translated">解#1と解#2の違いを理解しよう</target>
        </trans-unit>
        <trans-unit id="6fc2993f803fe2bce5ebd68d1671312a116f8f99" translate="yes" xml:space="preserve">
          <source>List2 isn't storing the actual list, but a reference to list1. So when you do anything to list1, list2 changes as well. use the copy module (not default, download on pip) to make an original copy of the list(&lt;code&gt;copy.copy()&lt;/code&gt; for simple lists, &lt;code&gt;copy.deepcopy()&lt;/code&gt; for nested ones). This makes a copy that doesn't change with the first list.</source>
          <target state="translated">List2は実際のリストではなく、list1への参照を格納しています。 したがって、list1に対して何かを行うと、list2も変更されます。 copyモジュール（デフォルトではなく、pipでダウンロード）を使用して、リストの元のコピーを作成します（単純なリストの場合は &lt;code&gt;copy.deepcopy()&lt;/code&gt; 、ネストされたリストの場合はcopy.deepcopy（） ）。 これにより、最初のリストで変更されないコピーが作成されます。</target>
        </trans-unit>
        <trans-unit id="cf2a1e2bb3e71888a0f43aeb3ac08c80b8fcc911" translate="yes" xml:space="preserve">
          <source>Making another pointer does &lt;em&gt;not&lt;/em&gt; make a copy</source>
          <target state="translated">別のポインタを作成してもコピー&lt;em&gt;は&lt;/em&gt;作成されませ&lt;em&gt;ん&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e97c704d7d43e21b1fcfda833b090668ec5e244" translate="yes" xml:space="preserve">
          <source>Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use &lt;code&gt;copy.copy()&lt;/code&gt; or &lt;code&gt;copy.deepcopy()&lt;/code&gt; rather than the alternatives, for example in Python 3:</source>
          <target state="translated">独自のカスタムクラスを定義し、属性を保持したい場合は、Python 3などの代替手段ではなく、 &lt;code&gt;copy.copy()&lt;/code&gt; または &lt;code&gt;copy.deepcopy()&lt;/code&gt; を使用する必要がある場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e3932369e81674c80f98992bf457167b246e6424" translate="yes" xml:space="preserve">
          <source>Now if you are thinking copy copied the list_1, then you are wrong. The &lt;code&gt;id&lt;/code&gt; function can show us if two variables can point to the same object. Let's try this:</source>
          <target state="translated">これで、list_1がコピーされたと考えている場合は、誤りです。 &lt;code&gt;id&lt;/code&gt; 関数は、2つの変数が同じオブジェクトを指すかどうかを示します。 これを試してみましょう：</target>
        </trans-unit>
        <trans-unit id="00347d0a4cb14f4559c30793412031205df3863d" translate="yes" xml:space="preserve">
          <source>Now if you assign &lt;code&gt;new_list = my_list[:]&lt;/code&gt; You're simply copying each object of my_list to new_list. This is known as Deep copy.</source>
          <target state="translated">ここで、 &lt;code&gt;new_list = my_list[:]&lt;/code&gt; を割り当てると、 my_listの各オブジェクトをnew_listにコピーするだけです。 これはディープコピーと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="a7d1d79d92c9e349b139fe633f0b6526fad09ce4" translate="yes" xml:space="preserve">
          <source>Now let's move onto a pythonic method for copying lists.</source>
          <target state="translated">それでは、リストをコピーするためのパイソニックな方法に移りましょう。</target>
        </trans-unit>
        <trans-unit id="3df54c02f5f581cc533561dc1118e595e1076275" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the list and let's see if we still face the previous problem:</source>
          <target state="translated">では、リストを修正してみて、前回の問題にまだ直面しているかどうかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="aa39e23942a2753c10c8d3f75f878396c89495a5" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the nested list and see if it solved the previous issue or not:</source>
          <target state="translated">では、入れ子になっているリストを修正してみて、前回の問題が解決したかどうかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="18d4f8f9dd5560fdbaaa044248879e0f414571a4" translate="yes" xml:space="preserve">
          <source>Now we can assume both lists are pointing different object, so now let's try to modify it and let's see it is giving what we want:</source>
          <target state="translated">これで、両方のリストが異なるオブジェクトを指していると仮定して、それを修正してみましょう。</target>
        </trans-unit>
        <trans-unit id="f36cb40ae7ff021457ab561b8f3c65237590561c" translate="yes" xml:space="preserve">
          <source>Now, imagine you have this list: &lt;em&gt;[[1, 2], [3, 4], [5, 6]]&lt;/em&gt;. This time, you want to make a function, which uses recursion to deep copy all layers of the list. Instead of the previous list comprehension:</source>
          <target state="translated">今、あなたがこのリストを持っていると想像してください： &lt;em&gt;[[1、2]、[3、4]、[5、6]]&lt;/em&gt; 。 今回は、再帰を使用してリストのすべてのレイヤーをディープコピーする関数を作成します。 前のリストの理解の代わりに：</target>
        </trans-unit>
        <trans-unit id="69f5f45134cb9ec012385bfbf42d5088f5cf8d41" translate="yes" xml:space="preserve">
          <source>Obviously the slowest and most memory-needing method, but sometimes unavoidable.</source>
          <target state="translated">明らかに最も遅く、最も記憶を必要とする方法ですが、時には避けられないこともあります。</target>
        </trans-unit>
        <trans-unit id="dbbf697d62aa4fc57077ea24851b4247f69fc822" translate="yes" xml:space="preserve">
          <source>Once you know that, completely duplicating an object without any references is pretty easy. Here's a function for deepcopying basic data-types (wouldn't work for custom classes but you could always add that)</source>
          <target state="translated">これがわかれば、参照なしでオブジェクトを完全に複製するのはとても簡単です。以下は、基本的なデータ型をディープコピーするための関数です (カスタムクラスでは動作しませんが、いつでも追加できます)</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="85428b26db4c1794e05f4269b0c513309de817c9" translate="yes" xml:space="preserve">
          <source>Python 2</source>
          <target state="translated">Python 2</target>
        </trans-unit>
        <trans-unit id="0101a74afd88d622354b05b2b6416e029264bbac" translate="yes" xml:space="preserve">
          <source>Python 3</source>
          <target state="translated">パイソン 3</target>
        </trans-unit>
        <trans-unit id="4349126aac22c987d016e24c14dcae82a88269df" translate="yes" xml:space="preserve">
          <source>Python 3.6 Timings</source>
          <target state="translated">Python 3.6 タイミング</target>
        </trans-unit>
        <trans-unit id="6ac4e03df57920cae5a01b21d070287f63116c43" translate="yes" xml:space="preserve">
          <source>Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by &lt;code&gt;my_list&lt;/code&gt; and bound it to &lt;code&gt;new_list&lt;/code&gt; as well. No matter which name you use there is still only one list, so changes made when referring to it as &lt;code&gt;my_list&lt;/code&gt; will persist when referring to it as &lt;code&gt;new_list&lt;/code&gt;. Each of the other answers to this question give you different ways of creating a new object to bind to &lt;code&gt;new_list&lt;/code&gt;.</source>
          <target state="translated">Pythonは変数に値を格納しません。 名前をオブジェクトにバインドします。 元の割り当てでは、 &lt;code&gt;my_list&lt;/code&gt; によって参照されるオブジェクトを取得し 、それを &lt;code&gt;new_list&lt;/code&gt; にもバインドしました。 どちらの名前を使用しても、リストは1つしかないため、 &lt;code&gt;my_list&lt;/code&gt; として参照するときに加えられた変更は、 new_listとして参照するときにも保持され &lt;code&gt;new_list&lt;/code&gt; 。 この質問に対する他の回答はそれぞれ、 &lt;code&gt;new_list&lt;/code&gt; にバインドする新しいオブジェクトを作成するさまざまな方法を提供します。</target>
        </trans-unit>
        <trans-unit id="431a4d86ecae97814d808e75432c4497870cb5a0" translate="yes" xml:space="preserve">
          <source>Python's idiom for doing this is &lt;code&gt;newList = oldList[:]&lt;/code&gt;</source>
          <target state="translated">これを行うためのPythonのイディオムは &lt;code&gt;newList = oldList[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c6ddaaef7312488cd7088001672817f1f759347" translate="yes" xml:space="preserve">
          <source>Python's own built-in deepcopy is based around that example. The only difference is it supports other types, and also supports user-classes by duplicating the attributes into a new duplicate class, and also blocks infinite-recursion with a reference to an object it's already seen using a memo list or dictionary. And that's really it for making deep copies. At its core, making a deep copy is just making shallow copies. I hope this answer adds something to the question.</source>
          <target state="translated">Python 自身の組み込み deepcopy はこの例をベースにしています。唯一の違いは、他の型をサポートしていることと、属性を新しい複製クラスに複製することでユーザークラスをサポートしていること、メモリストや辞書を使って既に見たオブジェクトへの参照で無限再帰をブロックしていることです。そして、ディープコピーを作成するには、本当にそれだけです。核心的には、深いコピーを作ることは浅いコピーを作ることに過ぎません。この答えが何かの参考になれば幸いです。</target>
        </trans-unit>
        <trans-unit id="cdb020da6f04f980578edbeea557ee080eae15e7" translate="yes" xml:space="preserve">
          <source>Remember that in Python when you do:</source>
          <target state="translated">その際にはPythonで覚えておきましょう。</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="0c5d365ba03417b1814c4317a93bd505f3d45686" translate="yes" xml:space="preserve">
          <source>Say you have this list: &lt;em&gt;[1, 2, 3]&lt;/em&gt;. The immutable numbers cannot be duplicated, but the other layer can. You can duplicate it using a list comprehension: &lt;em&gt;[x for x in [1, 2, 3]&lt;/em&gt;</source>
          <target state="translated">次のリストがあるとします： &lt;em&gt;[1、2、3]&lt;/em&gt; 。 不変の数値は複製できませんが、他の層は複製できます。 リスト内包表記を使用して複製できます： &lt;em&gt;[x for x in [1、2、3]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a382c1a79a9abea2c3b456d682976a5c9462e5a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;the documentation&lt;/a&gt; for more information about corner cases in copying.</source>
          <target state="translated">コピーのコーナーケースの詳細について&lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;は、ドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6772e3c75e46f3d9be01bc50c86027112d2938bf" translate="yes" xml:space="preserve">
          <source>Shallow list copy</source>
          <target state="translated">浅いリストコピー</target>
        </trans-unit>
        <trans-unit id="9a11a8945f8d6b48081dbf5ea5d6e5f5c801b470" translate="yes" xml:space="preserve">
          <source>So as we can see our both list having different id and it means that both variables are pointing to different objects. So what actually going on here is:</source>
          <target state="translated">つまり、両方のリストが異なるidを持っていることがわかるように、これは両方の変数が異なるオブジェクトを指していることを意味します。ここで実際に何が起こっているのかというと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="3513e3f3b28e2724f6f965025e19894e50855199" translate="yes" xml:space="preserve">
          <source>So as we know python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is a &lt;code&gt;list&lt;/code&gt; but we created two references to that same object by two different variable names. This means that both variables are pointing to the same object, just with different names.</source>
          <target state="translated">Pythonが変数に何も格納しないことがわかっているので、変数はオブジェクトを参照しているだけで、オブジェクトは値を格納しています。 ここではオブジェクトは &lt;code&gt;list&lt;/code&gt; が、同じオブジェクトへの2つの参照を2つの異なる変数名で作成しました。 つまり、両方の変数が同じオブジェクトを指しており、名前が異なるだけです。</target>
        </trans-unit>
        <trans-unit id="cd1487edc9546c18ca2fb6958037f7bc45eccdcc" translate="yes" xml:space="preserve">
          <source>So first let's try by setting the variable &lt;code&gt;copy&lt;/code&gt; to our original list, &lt;code&gt;list_1&lt;/code&gt;:</source>
          <target state="translated">したがって、まず変数の &lt;code&gt;copy&lt;/code&gt; を元のリスト &lt;code&gt;list_1&lt;/code&gt; に設定してみましょう。</target>
        </trans-unit>
        <trans-unit id="35599f5f6a22799b9a1065745b9e8a7525311cbe" translate="yes" xml:space="preserve">
          <source>So if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:</source>
          <target state="translated">コピーされたリストを修正しようとすると、元のリストも修正されてしまうので、コピーされたリストを修正しても元のリストを修正しても、コピーされたリストを修正することになります。</target>
        </trans-unit>
        <trans-unit id="0e6bad77f39dcb244d41a51049f33dcea7721965" translate="yes" xml:space="preserve">
          <source>So it modified the original list :</source>
          <target state="translated">だから、それは元のリストを修正しました。</target>
        </trans-unit>
        <trans-unit id="f008a22270d77fa388373610112fcf2f544b4006" translate="yes" xml:space="preserve">
          <source>So let's suppose you have two lists:</source>
          <target state="translated">では、2つのリストを持っているとしましょう。</target>
        </trans-unit>
        <trans-unit id="eda3d79321d8e8a6c5f43e602583a85978e82115" translate="yes" xml:space="preserve">
          <source>So the fastest is list slicing. But be aware that &lt;code&gt;copy.copy()&lt;/code&gt;, &lt;code&gt;list[:]&lt;/code&gt; and &lt;code&gt;list(list)&lt;/code&gt;, unlike &lt;code&gt;copy.deepcopy()&lt;/code&gt; and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.</source>
          <target state="translated">したがって、最速はリストのスライスです。 ただし、 &lt;code&gt;copy.deepcopy()&lt;/code&gt; やpythonバージョンとは異なり、 &lt;code&gt;copy.copy()&lt;/code&gt; 、 &lt;code&gt;list[:]&lt;/code&gt; 、 &lt;code&gt;list(list)&lt;/code&gt; は 、リスト内のリスト、辞書、クラスインスタンスをコピーしないので、オリジナルが変更された場合は注意してください。 、それらはコピーされたリストでも変更され、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="8bbc00ebc1fe27804a2faefef2b2a7c8e80ddd52" translate="yes" xml:space="preserve">
          <source>The Other way you can do this are :</source>
          <target state="translated">これを行うことができる他の方法は、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a51bd5a9f88582672dcba66c5148c7d26e24a8aa" translate="yes" xml:space="preserve">
          <source>The dark horse is the unpacking and repacking method (&lt;code&gt;b = [*a]&lt;/code&gt;), which is ~25% faster than raw slicing, and more than twice as fast as the other unpacking method (&lt;code&gt;*b, = a&lt;/code&gt;).</source>
          <target state="translated">ダークホースは、アンパックおよび再パック方法（ &lt;code&gt;b = [*a]&lt;/code&gt; ）です。これは、生のスライスより〜25％速く、他のアンパック方法（ &lt;code&gt;*b, = a&lt;/code&gt; ）の2倍以上高速です。</target>
        </trans-unit>
        <trans-unit id="efdb3e2274e3293e0058ed73476dabfc0b9f7297" translate="yes" xml:space="preserve">
          <source>The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.</source>
          <target state="translated">リストは内容へのポインタの配列にすぎないので、浅いコピーはポインタをコピーするだけなので、2つの異なるリストを持つことになりますが、同じ内容を持っています。内容のコピーを作るには、深いコピーが必要です。</target>
        </trans-unit>
        <trans-unit id="afa75f9e3be68e27350aefb47205502bf0a9e6e5" translate="yes" xml:space="preserve">
          <source>The obvious downside to this method is that it is only available in Python 3.5+.</source>
          <target state="translated">この方法の明らかな欠点は、Python 3.5+でしか利用できないことです。</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">出力されます。</target>
        </trans-unit>
        <trans-unit id="90fa1fae686fa6b34b07514c61aa94123be63447" translate="yes" xml:space="preserve">
          <source>Then now you have a function which can deepcopy any list of &lt;strong&gt;strs, bools, floast, ints&lt;/strong&gt; and even &lt;strong&gt;lists&lt;/strong&gt; to infinitely many layers using recursion. And there you have it, deepcopying.</source>
          <target state="translated">これで&lt;strong&gt;、&lt;/strong&gt;再帰を使用して&lt;strong&gt;、strs、bool、floast、int&lt;/strong&gt; 、さらに&lt;strong&gt;はリストのリスト&lt;/strong&gt;を無限に多くのレイヤーに&lt;strong&gt;ディープコピー&lt;/strong&gt;できる関数ができました。 ディープコピーがあります。</target>
        </trans-unit>
        <trans-unit id="220890ce8fb4c2412811019ffb2db9f207227214" translate="yes" xml:space="preserve">
          <source>There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.</source>
          <target state="translated">Python 2と3ではやり方が違います。Python 2の方法はPython 3でも動作します。</target>
        </trans-unit>
        <trans-unit id="b6d1fa502414f389e3c4893a7f6454394e1dd9d1" translate="yes" xml:space="preserve">
          <source>There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed.</source>
          <target state="translated">適切なコピーの作り方を教えてくれる回答はすでにたくさんありますが、オリジナルの「コピー」がなぜ失敗したのかを教えてくれるものはありません。</target>
        </trans-unit>
        <trans-unit id="66abe6803af6fc0a90902cfc1672796b3aae06b4" translate="yes" xml:space="preserve">
          <source>There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.</source>
          <target state="translated">リストをコピーするには、2つの意味的な方法があります。浅いコピーは同じオブジェクトの新しいリストを作成し、深いコピーは新しい等価オブジェクトを含む新しいリストを作成します。</target>
        </trans-unit>
        <trans-unit id="bc4ca653a23068dcf7ae97de3b9e4f63df0f559e" translate="yes" xml:space="preserve">
          <source>This gives us the output:</source>
          <target state="translated">これで出力されます。</target>
        </trans-unit>
        <trans-unit id="557c91f0d91bf8aa2deea01cceab9c91400d0ec2" translate="yes" xml:space="preserve">
          <source>This is a little slower than &lt;code&gt;list()&lt;/code&gt; because it has to find out the datatype of &lt;code&gt;old_list&lt;/code&gt; first.</source>
          <target state="translated">これは、最初に &lt;code&gt;old_list&lt;/code&gt; のデータ型を見つける必要があるため、 &lt;code&gt;list()&lt;/code&gt; よりも少し遅くなります。</target>
        </trans-unit>
        <trans-unit id="49bb04f0f459e1ca1287d6676b347a76839b4290" translate="yes" xml:space="preserve">
          <source>This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy.</source>
          <target state="translated">なぜなら、リストの各要素は、リストがその要素に縛られているのと同じように、他のオブジェクトを参照している可能性があるからです。リストの各要素を再帰的にコピーし、各要素が参照する他のオブジェクトを再帰的にコピーするには、ディープコピーを実行します。</target>
        </trans-unit>
        <trans-unit id="3c04fe0cc698e2ba7a6efcd47118a60302f9c23f" translate="yes" xml:space="preserve">
          <source>This may seem a little bit confusing, because the same method we previously used worked. Let's try to understand this.</source>
          <target state="translated">以前使っていた方法と同じ方法でうまくいったので、ちょっとわかりにくいかもしれません。これを理解してみましょう。</target>
        </trans-unit>
        <trans-unit id="00f93f5227a8e28c60a94b27101682842e37414b" translate="yes" xml:space="preserve">
          <source>This means that for multidimensional lists, the only option is &lt;code&gt;copy.deepcopy()&lt;/code&gt;. With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to &lt;code&gt;timeit&lt;/code&gt; using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.</source>
          <target state="translated">つまり、多次元リストの場合、唯一のオプションは &lt;code&gt;copy.deepcopy()&lt;/code&gt; です。 そうは言っても、適度なサイズの多次元配列で使用しようとするとパフォーマンスが大幅に低下するため、これは実際にはオプションではありません。 バイオインフォマティクスアプリケーションでは前例のない42x42の配列を使用して時間を &lt;code&gt;timeit&lt;/code&gt; うとしましたが、応答を待つことをあきらめ、この投稿への編集の入力を開始しました。</target>
        </trans-unit>
        <trans-unit id="0a9d3f3184e470a21dfb005cbe5d56f43c9b998b" translate="yes" xml:space="preserve">
          <source>This means when you do &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; what actually happens:</source>
          <target state="translated">これは、 &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; を実行すると 、実際に何が起こるかを意味します。</target>
        </trans-unit>
        <trans-unit id="04a5a8b7256438d8150475968ea5b994c8232285" translate="yes" xml:space="preserve">
          <source>This method fixes the first issue we had:</source>
          <target state="translated">この方法は、最初にあった問題を修正します。</target>
        </trans-unit>
        <trans-unit id="e7902de440301cd9e6f660692a60815b9d105656" translate="yes" xml:space="preserve">
          <source>Timing wise though, this appears to perform better than other common methods.</source>
          <target state="translated">しかし、タイミング的には、これは他の一般的な方法よりも優れたパフォーマンスを発揮するように見えます。</target>
        </trans-unit>
        <trans-unit id="6b58f0a40765b5b08203954d86f7c9ff6bee49da" translate="yes" xml:space="preserve">
          <source>To actually copy the list, you have various possibilities:</source>
          <target state="translated">実際にリストをコピーするには、様々な可能性があります。</target>
        </trans-unit>
        <trans-unit id="946633aa3cdcc201da0bfd3b79549497b06ce48f" translate="yes" xml:space="preserve">
          <source>To demonstrate how this allows us to make new sub-lists:</source>
          <target state="translated">これで新しいサブリストを作成する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="18c166dc2118c18ca2195aded821b172eef596bd" translate="yes" xml:space="preserve">
          <source>To make a &lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;deep copy of a list, in Python 2 or 3, use &lt;code&gt;deepcopy&lt;/code&gt; in the &lt;code&gt;copy&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;リストのディープコピー&lt;/a&gt;を作成するには、Python 2または3では、 &lt;code&gt;copy&lt;/code&gt; モジュールで &lt;code&gt;deepcopy&lt;/code&gt; を使用します 。</target>
        </trans-unit>
        <trans-unit id="77a0cef14012e7b83ed88a073f164fddcf757041" translate="yes" xml:space="preserve">
          <source>To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list.</source>
          <target state="translated">リストのコピーをさらに一歩進めるには、リストが参照している各オブジェクトをコピーし、それらの要素のコピーを新しいリストにバインドします。</target>
        </trans-unit>
        <trans-unit id="94a001d83f43e327f9bf5308ade41bb93e8b8b9b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;thing[:]&lt;/code&gt;</source>
          <target state="translated">ことを使用してください &lt;code&gt;thing[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="704ff25c262b4989c3e885b9c631ea5f00ee2274" translate="yes" xml:space="preserve">
          <source>We can see the Python2 winner still does well, but doesn't edge out Python3 &lt;code&gt;list.copy()&lt;/code&gt; by much, especially considering the superior readability of the latter.</source>
          <target state="translated">Python2の勝者は今でもうまく機能していることがわかりますが、特に後者の優れた可読性を考慮すれば、Python3の &lt;code&gt;list.copy()&lt;/code&gt; をそれほど除外していません。</target>
        </trans-unit>
        <trans-unit id="88fa58a7d8228094b91bae093cb54c6c760187cc" translate="yes" xml:space="preserve">
          <source>We get the output:</source>
          <target state="translated">アウトプットを得ています。</target>
        </trans-unit>
        <trans-unit id="20b49cce5a91432e085e1764e90ac0273068bbc7" translate="yes" xml:space="preserve">
          <source>What are the options to clone or copy a list in Python?</source>
          <target state="translated">Pythonでリストをクローンまたはコピーするオプションは何ですか?</target>
        </trans-unit>
        <trans-unit id="365d64ca08030dc6b88428870f53a2fcdac7e978" translate="yes" xml:space="preserve">
          <source>What is the solution? The solution is the &lt;code&gt;deepcopy&lt;/code&gt; function.</source>
          <target state="translated">解決策は何ですか？ 解決策は、 &lt;code&gt;deepcopy&lt;/code&gt; 関数です。</target>
        </trans-unit>
        <trans-unit id="8e8115e5fa0f64b2d78e179223b2acf529f438cd" translate="yes" xml:space="preserve">
          <source>When we do &lt;code&gt;copy_2=list_2[:]&lt;/code&gt;, this happens:</source>
          <target state="translated">&lt;code&gt;copy_2=list_2[:]&lt;/code&gt; 、次のようになります。</target>
        </trans-unit>
        <trans-unit id="7d92247dca50cce0446da6df8b14549d6a725f7b" translate="yes" xml:space="preserve">
          <source>When you do &lt;code&gt;copy=list_1&lt;/code&gt;, it is actually doing:</source>
          <target state="translated">&lt;code&gt;copy=list_1&lt;/code&gt; を実行すると、実際には次のようになります 。</target>
        </trans-unit>
        <trans-unit id="2e8ee345e21d7df889e916663fa72306a26db891" translate="yes" xml:space="preserve">
          <source>When you do:</source>
          <target state="translated">その時は</target>
        </trans-unit>
        <trans-unit id="25aeb6ff8ce6046a534c673463f7363bfa51d100" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;new_list = old_list[:]&lt;/code&gt;, &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; and for Py3k &lt;code&gt;old_list.copy()&lt;/code&gt; work for single-leveled lists, they revert to pointing at the &lt;code&gt;list&lt;/code&gt; objects nested within the &lt;code&gt;old_list&lt;/code&gt; and the &lt;code&gt;new_list&lt;/code&gt;, and changes to one of the &lt;code&gt;list&lt;/code&gt; objects are perpetuated in the other.</source>
          <target state="translated">&lt;code&gt;new_list = old_list[:]&lt;/code&gt; 、 &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; およびPy3k &lt;code&gt;old_list.copy()&lt;/code&gt; は単一レベルのリストで機能しますが、 &lt;code&gt;old_list&lt;/code&gt; およびnew_list内にネストされている &lt;code&gt;list&lt;/code&gt; オブジェクトを指すように戻り、1つに変更されます &lt;code&gt;list&lt;/code&gt; オブジェクトのうち、他のものに永続化されます。</target>
        </trans-unit>
        <trans-unit id="46a5e0acd81721a83e102ba1cc3b2c2c40347a6d" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;new_list = my_list&lt;/code&gt;, any modifications to &lt;code&gt;new_list&lt;/code&gt; changes &lt;code&gt;my_list&lt;/code&gt; everytime.
Why is this?</source>
          <target state="translated">&lt;code&gt;new_list = my_list&lt;/code&gt; を使用している間、 new_listを変更すると、毎回 &lt;code&gt;new_list&lt;/code&gt; が変更さ &lt;code&gt;my_list&lt;/code&gt; ます。 どうしてこれなの？</target>
        </trans-unit>
        <trans-unit id="4ccc750900a14314384b3bf271f406314a22ce63" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;new_list = my_list&lt;/code&gt;, you don't actually have two lists. The assignment just copies the reference to the list, not the actual list, so both &lt;code&gt;new_list&lt;/code&gt; and &lt;code&gt;my_list&lt;/code&gt; refer to the same list after the assignment.</source>
          <target state="translated">&lt;code&gt;new_list = my_list&lt;/code&gt; 、実際には2つのリストはありません。 割り当ては実際のリストではなくリストへの参照をコピーするだけなので、 &lt;code&gt;new_list&lt;/code&gt; と &lt;code&gt;my_list&lt;/code&gt; は両方とも割り当て後に同じリストを参照します。</target>
        </trans-unit>
        <trans-unit id="225441c8d6bd2a8e2654bc1fd302a0897594025a" translate="yes" xml:space="preserve">
          <source>You can also accomplish the same thing by passing the list through the list constructor,</source>
          <target state="translated">リストのコンストラクタにリストを渡すことでも同じことができます。</target>
        </trans-unit>
        <trans-unit id="a9e1c8ff6e281ab525b473cb57dfc86a34e5f554" translate="yes" xml:space="preserve">
          <source>You can perform list unpacking with the &quot;splat operator&quot;: &lt;code&gt;*&lt;/code&gt;, which will also copy elements of your list.</source>
          <target state="translated">&quot;splat演算子&quot;： &lt;code&gt;*&lt;/code&gt; を使用して 、リストのアンパックを実行できます。これにより、リストの要素もコピーされます。</target>
        </trans-unit>
        <trans-unit id="204a07b1b7642695ed4e50226442ee5bd889a56d" translate="yes" xml:space="preserve">
          <source>You can slice it:</source>
          <target state="translated">スライスしてもいいですよ。</target>
        </trans-unit>
        <trans-unit id="8b60affbd66d1ab22f4db2b35f4476c0bc727885" translate="yes" xml:space="preserve">
          <source>You can use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">一般的な&lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy()&lt;/code&gt; を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="f7c4e65f4ef8f5a93e4955911a9d09385dd4e0e2" translate="yes" xml:space="preserve">
          <source>You can use the built in &lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt;&lt;code&gt;list()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">組み込みの&lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt; &lt;code&gt;list()&lt;/code&gt; &lt;/a&gt;関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="74e2cb68ed9fb5f2c5405875004d794d14a5f066" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt;&lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method (available since Python 3.3):</source>
          <target state="translated">組み込みの&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt; &lt;code&gt;list.copy()&lt;/code&gt; &lt;/a&gt;メソッド（Python 3.3以降で使用可能）を使用できます。</target>
        </trans-unit>
        <trans-unit id="897a434f7844b828ae3989a342e35cc3c21bf0d6" translate="yes" xml:space="preserve">
          <source>You may see this used as a way to deepcopy, but don't do it:</source>
          <target state="translated">ディープコピーの手段として使われているのを見かけることがあるかもしれませんが、やめておきましょう。</target>
        </trans-unit>
        <trans-unit id="76244e96c4d1fb0eec733ac274efa594300304e7" translate="yes" xml:space="preserve">
          <source>You're only copying the outer list, not the inside list. We can use the &lt;code&gt;id&lt;/code&gt; function once again to check this.</source>
          <target state="translated">内部リストではなく、外部リストのみをコピーします。 &lt;code&gt;id&lt;/code&gt; 関数をもう一度使用して、これを確認できます。</target>
        </trans-unit>
        <trans-unit id="9356e95d4f6f104855f95803d19cc415fcbbdf4f" translate="yes" xml:space="preserve">
          <source>but using the constructor is less efficient:</source>
          <target state="translated">を使用していますが、コンストラクタを使用すると効率が悪くなります。</target>
        </trans-unit>
        <trans-unit id="6bac1115690000182dc538b79519b1c469db850e" translate="yes" xml:space="preserve">
          <source>on 64 bit Python 3.5:</source>
          <target state="translated">64ビットのPython 3.5で</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
