<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2612802">
    <body>
      <group id="2612802">
        <trans-unit id="6cb2908973d6e330ac0831d07b21e8772ada79a7" translate="yes" xml:space="preserve">
          <source>(Here's the script if anyone's interested or wants to raise any issues:)</source>
          <target state="translated">(以下是剧本,如果有人感兴趣或想提出任何问题:)</target>
        </trans-unit>
        <trans-unit id="ebb3c26aa2a50c6bcf9364047f9a610d479174c0" translate="yes" xml:space="preserve">
          <source>.&lt;strong&gt;Bonus&lt;/strong&gt;: If you don't want to copy elements use (aka shallow copy):</source>
          <target state="translated">。 &lt;strong&gt;奖励&lt;/strong&gt; ：如果您不想复制元素，请使用（也称为浅表复制）：</target>
        </trans-unit>
        <trans-unit id="831f577c0630013fd2dd428aa6f69fbb8227958b" translate="yes" xml:space="preserve">
          <source>0.039 sec (0.39us/itn) - &lt;code&gt;old_list[:]&lt;/code&gt; (&lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;list slicing&lt;/a&gt;)</source>
          <target state="translated">0.039秒（0.39us / itn） &lt;code&gt;old_list[:]&lt;/code&gt; （ &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;列表切片&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="6576742e9a532381a3048dc91ed10879c2220a99" translate="yes" xml:space="preserve">
          <source>0.053 sec (0.53us/itn) - &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt;</source>
          <target state="translated">0.053秒（0.53us / itn） &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt; new_list.extend（old_list）</target>
        </trans-unit>
        <trans-unit id="589e176d08ceaa47627386f4c2ee43ef0e412c6f" translate="yes" xml:space="preserve">
          <source>0.075 sec (0.75us/itn) - &lt;code&gt;list(old_list)&lt;/code&gt;</source>
          <target state="translated">0.075秒（0.75us / itn）- &lt;code&gt;list(old_list)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbf31d4e561cfc6f0a7055b18ae7bb85966be0c" translate="yes" xml:space="preserve">
          <source>0.186 sec (1.86us/itn) - &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">0.186秒（1.86us / itn） &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9741537872f078018c930db04bb6b7a099568129" translate="yes" xml:space="preserve">
          <source>0.217 sec (2.17us/itn) - &lt;code&gt;[i for i in old_list]&lt;/code&gt; (a &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;list comprehension&lt;/a&gt;)</source>
          <target state="translated">0.217秒（2.17us / itn）- &lt;code&gt;[i for i in old_list]&lt;/code&gt; （ &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;列表理解&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="fcb2fce8f80e6e96b412e3deb49a4a01eef9d95c" translate="yes" xml:space="preserve">
          <source>0.325 sec (3.25us/itn) - &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</source>
          <target state="translated">0.325秒（3.25us / itn）- &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a196696ac9e805fcf92036506af3ef7d8ab819d" translate="yes" xml:space="preserve">
          <source>1.488 sec (14.88us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method not copying classes (only dicts/lists/tuples)</source>
          <target state="translated">1.488秒（14.88us / itn）-纯python &lt;code&gt;Copy()&lt;/code&gt; 方法不复制类（仅字典/列表/元组）</target>
        </trans-unit>
        <trans-unit id="c36d3f84b0185c78311f648cfb81e4cacde6b9c9" translate="yes" xml:space="preserve">
          <source>10.16 sec (101.6us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method copying classes with deepcopy</source>
          <target state="translated">10.16秒（101.6us / itn）-使用Deepcopy复制类的纯python &lt;code&gt;Copy()&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="892f509cfed7a878055c5d6330a5e7a7032f54b5" translate="yes" xml:space="preserve">
          <source>10.59 sec (105.9us/itn) -  &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">10.59秒（105.9us / itn） &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24d242d81528698f099460d3c52d07280215058e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;Alex Martelli's&lt;/a&gt; opinion (at least &lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;back in 2007&lt;/a&gt;) about this is, that &lt;em&gt;it is a weird syntax and it does not make sense to use it ever&lt;/em&gt;. ;) (In his opinion, the next one is more readable).</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;Alex Martelli&lt;/a&gt;对此的看法（至少是&lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;在2007年&lt;/a&gt; ）是， &lt;em&gt;这是一种怪异的语法，永远不要使用它&lt;/em&gt; 。 ;）（在他看来，下一个更具可读性）。</target>
        </trans-unit>
        <trans-unit id="cb21dd5df394bc7fae7c132b18417ae29a3bc579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b = a * 1&lt;/code&gt; also does surprisingly well.</source>
          <target state="translated">&lt;code&gt;b = a * 1&lt;/code&gt; 也非常好。</target>
        </trans-unit>
        <trans-unit id="d9ef3187620786222a615d86bcc314673d3289f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list_2&lt;/code&gt; should reference to another object which is copy of &lt;code&gt;list_2&lt;/code&gt;. Let's check:</source>
          <target state="translated">&lt;code&gt;list_2&lt;/code&gt; 应该引用另一个对象，它是 &lt;code&gt;list_2&lt;/code&gt; 的副本。 让我们检查：</target>
        </trans-unit>
        <trans-unit id="4f36085cfc8ae8adb7dd3849ea72baa17b0c317a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_list&lt;/code&gt; is just a name that points to the actual list in memory. When you say &lt;code&gt;new_list = my_list&lt;/code&gt; you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists.</source>
          <target state="translated">&lt;code&gt;my_list&lt;/code&gt; 只是指向内存中实际列表的名称。 当您说 &lt;code&gt;new_list = my_list&lt;/code&gt; 您并没有进行复制，只是添加了另一个指向内存中原始列表的名称。 复制列表时，我们可能会遇到类似的问题。</target>
        </trans-unit>
        <trans-unit id="2041e8c18dbff0914a06b5e2a1252d4733642d53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_list = my_list&lt;/code&gt;
Try to understand this. Let's say that my_list is in the heap memory at location X i.e. my_list is pointing to the X. Now by assigning &lt;code&gt;new_list = my_list&lt;/code&gt; you're Letting new_list pointing to the X. This is known as shallow Copy.</source>
          <target state="translated">&lt;code&gt;new_list = my_list&lt;/code&gt; 尝试了解这一点。 假设my_list位于X位置的堆内存中，即my_list指向X。现在，通过分配 &lt;code&gt;new_list = my_list&lt;/code&gt; 您将new_list指向X。这称为浅拷贝。</target>
        </trans-unit>
        <trans-unit id="8ef17a4719ab0f78b42c3681f36203e226fb86dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EXAMPLES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EXAMPLES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fd15ef13529e8eb7aac1e4fb2625df3343dbcd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that these methods do &lt;em&gt;not&lt;/em&gt; output equivalent results for any input other than lists.&lt;/strong&gt; They all work for sliceable objects, a few work for any iterable, but only &lt;code&gt;copy.copy()&lt;/code&gt; works for more general Python objects.</source>
          <target state="translated">&lt;strong&gt;请注意，这些方法&lt;em&gt;不会&lt;/em&gt;为列表以外的任何输入输出等效的结果。&lt;/strong&gt; 它们都适用于可切片的对象，少数适用于任何可迭代的对象，但只有 &lt;code&gt;copy.copy()&lt;/code&gt; 适用于更通用的Python对象。</target>
        </trans-unit>
        <trans-unit id="6044cdaafb431c7ebd900f17cd900457b458ca20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;: Deepcopy uses recursion to duplicate objects, and merely returns the same immutable objects as before, as immutable objects cannot be duplicated. However, it deepcopies the most inner layers of mutable objects until it reaches the outermost mutable layer of an object.</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt; ：Deepcopy使用递归来复制对象，并且仅返回与以前相同的不可变对象，因为不能复制不可变对象。 但是，它将深度复制可变对象的最内层，直到到达对象的最外层可变层。</target>
        </trans-unit>
        <trans-unit id="0669e0817e0ab8178fe6bdeadc9d599cc4692d12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using new_list = my_list then modifies new_list every time my_list changes. Why is this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;然后，每次使用my_list更改时，使用new_list = my_list都会修改new_list。&lt;/strong&gt; &lt;strong&gt;为什么是这样？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d45c9a0fde240fd63fbe4e27fddcf428b240c39" translate="yes" xml:space="preserve">
          <source>A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists.</source>
          <target state="translated">浅层复制只复制列表本身,而列表本身就是列表中的对象的引用容器。如果包含的对象本身是可突变的,如果其中一个对象被改变了,那么这个改变就会在两个列表中反映出来。</target>
        </trans-unit>
        <trans-unit id="005c37f0237b5cb139854b9e4687176ca563565b" translate="yes" xml:space="preserve">
          <source>A slight practical perspective to look into memory through id and gc.</source>
          <target state="translated">透过ID和GC,略显实用的角度来考察记忆。</target>
        </trans-unit>
        <trans-unit id="8261b218a41d10fe8c0dcd15e9088d1cb42e6891" translate="yes" xml:space="preserve">
          <source>A very simple approach independent of python version was missing in already given answers which you can use most of the time (at least I do):</source>
          <target state="translated">一个独立于python版本的非常简单的方法,在已经给出的答案中,你可以使用的大部分时间(至少我是这样做的),缺少了一个非常简单的方法。</target>
        </trans-unit>
        <trans-unit id="3498a4737c6e7fe24088dc089c3bcc79dda6d821" translate="yes" xml:space="preserve">
          <source>All of the other contributors gave &lt;strong&gt;great&lt;/strong&gt; answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only &lt;code&gt;copy.deepcopy()&lt;/code&gt; works to clone/copy a list and not have it point to the nested &lt;code&gt;list&lt;/code&gt; objects when you are working with multidimensional, nested lists (list of lists). While &lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;Felix Kling&lt;/a&gt; refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to &lt;code&gt;deepcopy&lt;/code&gt;.</source>
          <target state="translated">所有其他贡献者都给出了&lt;strong&gt;不错的&lt;/strong&gt;答案，当您只有一个维（级别）列表时，这些方法就可以工作，但是到目前为止，提到的方法中，只有 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 可以克隆/复制列表，而不能指向列表。使用多维嵌套列表（列表列表）时的嵌套 &lt;code&gt;list&lt;/code&gt; 对象。 尽管&lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;Felix Kling&lt;/a&gt;在回答中提到了这一点，但这个问题还有更多的地方，并且可能使用内置方法的变通办法可能证明是 &lt;code&gt;deepcopy&lt;/code&gt; 的更快替代方法。</target>
        </trans-unit>
        <trans-unit id="6a258d25732edb4a8dc4c53104d80ea8e8ba4b1f" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;deepcopy_list&lt;/strong&gt; looks like this:</source>
          <target state="translated">而且&lt;strong&gt;deepcopy_list&lt;/strong&gt;看起来像这样：</target>
        </trans-unit>
        <trans-unit id="99c81ac1dec28ab432158972b11dcd87811305fd" translate="yes" xml:space="preserve">
          <source>And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.</source>
          <target state="translated">于是我们看到,深度复制的列表与原版完全不同。你可以滚动自己的函数--但不要。你很可能会因为使用标准库的深度复制函数而产生一些BUG,否则就不会有。</target>
        </trans-unit>
        <trans-unit id="baf0b49d9e610c1e0b9aaf4f81c197fe9b3f4561" translate="yes" xml:space="preserve">
          <source>And we have to copy both lists, now starting from the first list:</source>
          <target state="translated">而我们必须复制这两个列表,现在从第一个列表开始。</target>
        </trans-unit>
        <trans-unit id="9d4cea5d2aa1cef4716a69ab86f2a6adcf09e2c9" translate="yes" xml:space="preserve">
          <source>As others have stated, there  &lt;strong&gt;&lt;em&gt;are significant&lt;/em&gt;&lt;/strong&gt; performance issues using the &lt;code&gt;copy&lt;/code&gt; module and &lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;strong&gt;&lt;em&gt;for multidimensional lists&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">如其他人所述，将 &lt;code&gt;copy&lt;/code&gt; 模块和 &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;strong&gt;&lt;em&gt;用于多维列表&lt;/em&gt;&lt;/strong&gt;存在&lt;strong&gt;&lt;em&gt;严重的&lt;/em&gt;&lt;/strong&gt;性能问题。</target>
        </trans-unit>
        <trans-unit id="c03a694d0b4332e4b08b86ede988da2173792481" translate="yes" xml:space="preserve">
          <source>As was pointed out by both &lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;Aaron Hall&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ring&lt;/a&gt;&lt;strong&gt;using &lt;code&gt;eval()&lt;/code&gt; is not only a bad idea, it is also much slower than &lt;code&gt;copy.deepcopy()&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">正如&lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;Aaron Hall&lt;/a&gt;和&lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ring&lt;/a&gt;指出的那样， &lt;strong&gt;使用 &lt;code&gt;eval()&lt;/code&gt; 不仅是一个坏主意，而且它比 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 还要慢得多。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0bae3de46c365ceae27557d207d519a16f03d1f" translate="yes" xml:space="preserve">
          <source>As you can see Solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.</source>
          <target state="translated">正如你所看到的那样,当我们不使用嵌套列表时,解决方案#1的效果非常好。让我们来看看当我们将解决方案#1应用到嵌套列表中会发生什么。</target>
        </trans-unit>
        <trans-unit id="1fa9f6c88dde54a4948d45a55a86287ba1ddfa53" translate="yes" xml:space="preserve">
          <source>As you can see both IDs are different, meaning we can assume that both nested lists are pointing different object now.</source>
          <target state="translated">可以看到两个ID都是不同的,这意味着我们可以假设两个嵌套的列表现在指向不同的对象。</target>
        </trans-unit>
        <trans-unit id="76931cafef2a867dc6f7e1459fcb607ba73ac1cc" translate="yes" xml:space="preserve">
          <source>As you can see, it didn't modify the original nested list, it only modified the copied list.</source>
          <target state="translated">可以看到,它并没有修改原来的嵌套列表,只是修改了复制的列表。</target>
        </trans-unit>
        <trans-unit id="3bd849e1d81d4729cb3f7546cfc9844c9422980a" translate="yes" xml:space="preserve">
          <source>As you can see, it only modified the copied list. That means it worked.</source>
          <target state="translated">如你所见,它只修改了复制的列表。这说明它成功了。</target>
        </trans-unit>
        <trans-unit id="7f5db9e07be4014478905b5c75e8654633a0eeb3" translate="yes" xml:space="preserve">
          <source>At the core of any deep copy function is way to make a shallow copy. How? Simple. Any deep copy function only duplicates the containers of immutable objects. When you deepcopy a nested list, you are only duplicating the outer lists, not the mutable objects inside of the lists. You are only duplicating the containers. The same works for classes, too. When you deepcopy a class, you deepcopy all of its mutable attributes. So, how? How come you only have to copy the containers, like lists, dicts, tuples, iters, classes, and class instances?</source>
          <target state="translated">任何深度复制功能的核心是浅层复制的方法。怎么做?很简单。任何深度复制函数都只复制不可变对象的容器。当你深度复制一个嵌套的列表时,你只复制了外层的列表,而不是复制列表内的可变对象。你只复制了容器。同样的道理也适用于类。当你深层复制一个类时,你会深层复制它所有的可突变属性。那么,怎么会呢?为什么你只需要复制容器,比如list、dicts、tuples、iters、class和class实例?</target>
        </trans-unit>
        <trans-unit id="e99ab5abd5933a0d7d0b66c200bfec3d28b8a6b1" translate="yes" xml:space="preserve">
          <source>Both nested lists are pointing different object and they have separate copy of nested list now.</source>
          <target state="translated">这两个嵌套的列表都指向不同的对象,它们现在有单独的嵌套列表副本。</target>
        </trans-unit>
        <trans-unit id="836b19e7f8037813d193adb0ea22763be677a48c" translate="yes" xml:space="preserve">
          <source>Both outer lists have different IDs, let's try this on the inner nested lists.</source>
          <target state="translated">两个外列表都有不同的ID,让我们在内嵌套的列表上试试。</target>
        </trans-unit>
        <trans-unit id="f079e1b881840a2f35a6dd6a384ae5baae282f12" translate="yes" xml:space="preserve">
          <source>Both variables are the exact same argument. Are you surprised?</source>
          <target state="translated">这两个变量是完全相同的论点。你是否感到惊讶?</target>
        </trans-unit>
        <trans-unit id="97e297e7f407d34ed9e7296aa23537583633a817" translate="yes" xml:space="preserve">
          <source>Deep copies</source>
          <target state="translated">深度副本</target>
        </trans-unit>
        <trans-unit id="80c240c06fa36efab33567b8dd004136b3a42e84" translate="yes" xml:space="preserve">
          <source>Do you think we're done? No. Let's try to copy our nested list.</source>
          <target state="translated">你觉得我们做完了吗?不,让我们试着复制一下我们的嵌套名单。</target>
        </trans-unit>
        <trans-unit id="579defd972ab926c631e8d21e9eff8c734a498e0" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="translated">不要使用 &lt;code&gt;eval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a27986749695e29a6ff85bbb5c2f396fd63cf1d" translate="yes" xml:space="preserve">
          <source>Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.</source>
          <target state="translated">列表的每一个元素的作用就像一个名字一样,每个元素都与一个对象非排他性地绑定。浅层复制创建了一个新的列表,其元素与之前的对象绑定在一起。</target>
        </trans-unit>
        <trans-unit id="100e61c040833faea556e102ff4c6f46b647f7ed" translate="yes" xml:space="preserve">
          <source>Edit: New information brought to light</source>
          <target state="translated">编辑:有了新的信息</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="e959b489a54884803ea418506d068419cb2bc499" translate="yes" xml:space="preserve">
          <source>Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:</source>
          <target state="translated">菲利克斯已经给出了一个很好的答案,但我想我要做一个各种方法的速度对比。</target>
        </trans-unit>
        <trans-unit id="dd44e670da0e5e9141f6396dd8d5c9a9a6ec0348" translate="yes" xml:space="preserve">
          <source>Here are the timing results using Python 3.6.8. Keep in mind these times are relative to one another, not absolute.</source>
          <target state="translated">下面是使用 Python 3.6.8 的计时结果。请记住,这些时间是相对的,不是绝对的。</target>
        </trans-unit>
        <trans-unit id="7aa26673265eca05d895ce387611ec36d0b80e52" translate="yes" xml:space="preserve">
          <source>Here in the image list_1 and copy are two variable names but the object is same for both variable which is &lt;code&gt;list&lt;/code&gt;</source>
          <target state="translated">在图像list_1和副本中，这是两个变量名，但是两个变量的对象都是相同的，即 &lt;code&gt;list&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9767ca12b4902a277abb578b041a4030915e4f7b" translate="yes" xml:space="preserve">
          <source>Here is the testing code for interested parties (&lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;Template from here&lt;/a&gt;):</source>
          <target state="translated">这是有关各方的测试代码（ &lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;来自此处的模板&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="290e2f376f5eaf8c22b1793823c15aae8fcd1d51" translate="yes" xml:space="preserve">
          <source>How to clone or copy a list</source>
          <target state="translated">如何克隆或复制一个列表</target>
        </trans-unit>
        <trans-unit id="25d3f80cbc35ca2648934a22a93b5357eecb73c4" translate="yes" xml:space="preserve">
          <source>However, If my_list contains other containers (for eg. nested lists) you must use deepcopy as others suggested in the answers above from the copy library. For example:</source>
          <target state="translated">但是,如果my_list包含其他容器(例如:嵌套列表),你必须按照上面的答案中其他人建议的那样,从copy库中使用deepcopy。比如说</target>
        </trans-unit>
        <trans-unit id="4edc1a0498725bd60f03b13cb73da0476b50e73c" translate="yes" xml:space="preserve">
          <source>I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python2, such as &lt;code&gt;list.copy()&lt;/code&gt; (the Python3 &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;slice equivalent&lt;/a&gt;) and two forms of &lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;list unpacking&lt;/a&gt; (&lt;code&gt;*new_list, = list&lt;/code&gt; and &lt;code&gt;new_list = [*list]&lt;/code&gt;):</source>
          <target state="translated">我坚持只做浅表副本，还添加了一些新的方法，这些新方法在Python2中是不可能的，例如 &lt;code&gt;list.copy()&lt;/code&gt; （ &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;等效&lt;/a&gt;于Python3 slice ）和&lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;列表解&lt;/a&gt; &lt;code&gt;*new_list, = list&lt;/code&gt; 两种形式（ * new_list，= list和 &lt;code&gt;new_list = [*list]&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="013e110db0a05f5dbd20f8b57eade2f83a54868e" translate="yes" xml:space="preserve">
          <source>I wanted to post something a bit different then some of the other answers. Even though this is most likely not the most understandable, or fastest option, it provides a bit of an inside view of how deep copy works, as well as being another alternative option for deep copying. It doesn't really matter if my function has bugs, since the point of this is to show a way to copy objects like the question answers, but also to use this as a point to explain how deepcopy works at its core.</source>
          <target state="translated">我想发表一些与其他一些答案不同的东西。尽管这可能不是最容易理解的,也不是最快的选择,但它提供了一个关于深度复制工作原理的内部视图,也是深度复制的另一种选择。其实我的函数是否有bug并不重要,因为这一点是为了展示一种复制对象的方法,就像问题的答案一样,同时也是为了用这一点来解释deepcopy的核心工作原理。</target>
        </trans-unit>
        <trans-unit id="09c0b5ded50202962dc2368628c1933a8369a2c8" translate="yes" xml:space="preserve">
          <source>I've &lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;been told&lt;/a&gt; that Python 3.3+ &lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt;adds &lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method, which should be as fast as slicing:</source>
          <target state="translated">&lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;有人告诉&lt;/a&gt;我Python 3.3+ &lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt;添加了 &lt;code&gt;list.copy()&lt;/code&gt; &lt;/a&gt;方法，该方法应与切片速度一样快：</target>
        </trans-unit>
        <trans-unit id="d8a425aac0dd5c097429125cc2f15c4bcc6557bd" translate="yes" xml:space="preserve">
          <source>If the list contains objects and you want to copy them as well, use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果列表包含对象，并且您也想复制它们，请使用常规&lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy()&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="508aa1ec404f76db49d3513ef7b4d07bcec9be02" translate="yes" xml:space="preserve">
          <source>If you like my detailed answer, I would appreciate if you would upvote it. If you have any doubt about this answer, you can comment it down below.</source>
          <target state="translated">如果您喜欢我的详细回答,请您给我投上一票。如果你对这个答案有什么疑问,可以在下面评论。</target>
        </trans-unit>
        <trans-unit id="f608b902f462e04b6d6182623136fb4a743d3d57" translate="yes" xml:space="preserve">
          <source>In 64 bit Python 2.7:</source>
          <target state="translated">在64位Python 2.7中。</target>
        </trans-unit>
        <trans-unit id="2212a7dd8b8134dc3343d8ad7cbe5fae3fce8816" translate="yes" xml:space="preserve">
          <source>In Python 2 and 3, you can get a shallow copy with a full slice of the original:</source>
          <target state="translated">在Python 2和3中,你可以得到一个浅层次的副本,里面有完整的切片。</target>
        </trans-unit>
        <trans-unit id="4ac599cde0b2c5ab6842e5b2c183be812be9d03e" translate="yes" xml:space="preserve">
          <source>In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:</source>
          <target state="translated">在Python 2中,浅层次的拷贝列表的成语方式是用完整的片断来制作。</target>
        </trans-unit>
        <trans-unit id="c1a7abb8ba4c30e338a899c8b6ef3d8068af2771" translate="yes" xml:space="preserve">
          <source>In Python 3, a shallow copy can be made with:</source>
          <target state="translated">在Python 3中,浅层复制可以用。</target>
        </trans-unit>
        <trans-unit id="8fb02af71a6aec0493954b8ede599618597636b0" translate="yes" xml:space="preserve">
          <source>In Python 3, lists get the &lt;code&gt;list.copy&lt;/code&gt; method:</source>
          <target state="translated">在Python 3中，列表获取 &lt;code&gt;list.copy&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="80e3fc6970cca93fe92c32b6c4ba9f0ab890dd92" translate="yes" xml:space="preserve">
          <source>In Python 3.5:</source>
          <target state="translated">在Python 3.5中。</target>
        </trans-unit>
        <trans-unit id="e1e6045a5cef20010f69d146803165ac49a5152d" translate="yes" xml:space="preserve">
          <source>It creates the copy of list but only outer list copy, not the nested list copy, nested list is same for both variable, so if you try to modify the nested list then it will modify the original list too as the nested list object is same for both lists.</source>
          <target state="translated">它只创建了列表的副本,但只创建了外列表的副本,而不是嵌套的列表副本,嵌套的列表对两个变量都是一样的,所以如果你试图修改嵌套的列表,那么它也会修改原来的列表,因为嵌套的列表对象对两个列表都是一样的。</target>
        </trans-unit>
        <trans-unit id="d34c379d10b758183565c52320bbe1d3d85b2994" translate="yes" xml:space="preserve">
          <source>It outputs:</source>
          <target state="translated">它的输出是:</target>
        </trans-unit>
        <trans-unit id="98a7ab1fd383d07403bec0fdbf00b56735e9d4fa" translate="yes" xml:space="preserve">
          <source>It surprises me that this hasn't been mentioned yet, so for the sake of completeness...</source>
          <target state="translated">我很惊讶,这一点还没有被提及,所以为了完整起见......</target>
        </trans-unit>
        <trans-unit id="f22686b03873b3c74078fb08c5978fac2477ccf4" translate="yes" xml:space="preserve">
          <source>It uses a new one for lists:</source>
          <target state="translated">它使用了一个新的列表。</target>
        </trans-unit>
        <trans-unit id="c598a66587c1a2b513dfdee0f11cfe379df4fc51" translate="yes" xml:space="preserve">
          <source>It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.</source>
          <target state="translated">这样看来,唯一的选择就是初始化多个列表并独立处理它们。如果有人有任何其他建议,关于如何处理多维列表复制,将不胜感激。</target>
        </trans-unit>
        <trans-unit id="bfec348e3000941e5686d75ef056c9817e63c4f9" translate="yes" xml:space="preserve">
          <source>It's also less performant.</source>
          <target state="translated">它的性能也比较差。</target>
        </trans-unit>
        <trans-unit id="e5e39dfe9f9b8c35e9d451cae1bbf0f97001f659" translate="yes" xml:space="preserve">
          <source>It's dangerous, particularly if you're evaluating something from a source you don't trust.</source>
          <target state="translated">这是很危险的,尤其是当你从一个你不信任的来源评估一些东西的时候。</target>
        </trans-unit>
        <trans-unit id="30201c551b5097249c25a2dcab3ffcb946ee7734" translate="yes" xml:space="preserve">
          <source>It's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.</source>
          <target state="translated">如果你复制的子元素没有一个可以被评估的表示方式来重现一个等价元素,这是不可靠的。</target>
        </trans-unit>
        <trans-unit id="92b01213c7f0b76ca02c2f59a64061096e1ca746" translate="yes" xml:space="preserve">
          <source>It's simple. A mutable object can't really be duplicated. It can never be changed, so it is only a single value. That means you never have to duplicate strings, numbers, bools, or any of those. But how would you duplicate the containers? Simple. You make just initialize a new container with all of the values. Deepcopy relies on recursion. It duplicates all the containers, even ones with containers inside of them, until no containers are left. A container is an immutable object.</source>
          <target state="translated">这很简单。一个可突变的对象是不能真正复制的。它永远不能被改变,所以它只是一个单一的值。这意味着你永远不需要复制字符串、数字、bools或其他任何一个。但是,你如何复制容器呢?很简单,你只需要初始化一个新的容器就可以了。你只需要用所有的值初始化一个新的容器。Deepcopy依赖于递归。它复制所有的容器,即使是有容器的容器,它也会复制所有的容器,直到没有容器了。容器是一个不可变的对象。</target>
        </trans-unit>
        <trans-unit id="45fb77de6753c9a311b64100017c382af6c0cc51" translate="yes" xml:space="preserve">
          <source>Let's check this:</source>
          <target state="translated">我们来看看这个。</target>
        </trans-unit>
        <trans-unit id="0c5355b2834dda4cbab54f13603bb0d4f281a582" translate="yes" xml:space="preserve">
          <source>Let's start from the beginning and explore this question.</source>
          <target state="translated">让我们从头开始,探讨这个问题。</target>
        </trans-unit>
        <trans-unit id="4ea13a33e351858421ccf9c6208908351b78f68b" translate="yes" xml:space="preserve">
          <source>Let's understand difference between Solution#1 and Solution #2</source>
          <target state="translated">我们来了解一下解决方案1和解决方案2的区别</target>
        </trans-unit>
        <trans-unit id="6fc2993f803fe2bce5ebd68d1671312a116f8f99" translate="yes" xml:space="preserve">
          <source>List2 isn't storing the actual list, but a reference to list1. So when you do anything to list1, list2 changes as well. use the copy module (not default, download on pip) to make an original copy of the list(&lt;code&gt;copy.copy()&lt;/code&gt; for simple lists, &lt;code&gt;copy.deepcopy()&lt;/code&gt; for nested ones). This makes a copy that doesn't change with the first list.</source>
          <target state="translated">List2不是存储实际的列表，而是对list1的引用。 因此，当您对list1执行任何操作时，list2也会发生变化。 使用复制模块（不是默认值，可从pip下载）制作列表的原始副本（ &lt;code&gt;copy.copy()&lt;/code&gt; 用于简单列表， &lt;code&gt;copy.deepcopy()&lt;/code&gt; 用于嵌套列表）。 这将使副本不会随第一个列表更改。</target>
        </trans-unit>
        <trans-unit id="cf2a1e2bb3e71888a0f43aeb3ac08c80b8fcc911" translate="yes" xml:space="preserve">
          <source>Making another pointer does &lt;em&gt;not&lt;/em&gt; make a copy</source>
          <target state="translated">制作另一个指针不会复制</target>
        </trans-unit>
        <trans-unit id="6e97c704d7d43e21b1fcfda833b090668ec5e244" translate="yes" xml:space="preserve">
          <source>Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use &lt;code&gt;copy.copy()&lt;/code&gt; or &lt;code&gt;copy.deepcopy()&lt;/code&gt; rather than the alternatives, for example in Python 3:</source>
          <target state="translated">请注意，在某些情况下，如果您定义了自己的自定义类并希望保留属性，则应使用 &lt;code&gt;copy.copy()&lt;/code&gt; 或 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 而不是其他方法，例如在Python 3中：</target>
        </trans-unit>
        <trans-unit id="e3932369e81674c80f98992bf457167b246e6424" translate="yes" xml:space="preserve">
          <source>Now if you are thinking copy copied the list_1, then you are wrong. The &lt;code&gt;id&lt;/code&gt; function can show us if two variables can point to the same object. Let's try this:</source>
          <target state="translated">现在，如果您正在考虑将副本复制到list_1，那么您错了。 &lt;code&gt;id&lt;/code&gt; 函数可以告诉我们两个变量是否可以指向同一个对象。 让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="00347d0a4cb14f4559c30793412031205df3863d" translate="yes" xml:space="preserve">
          <source>Now if you assign &lt;code&gt;new_list = my_list[:]&lt;/code&gt; You're simply copying each object of my_list to new_list. This is known as Deep copy.</source>
          <target state="translated">现在，如果您分配 &lt;code&gt;new_list = my_list[:]&lt;/code&gt; 只需将my_list的每个对象复制到new_list。 这称为深拷贝。</target>
        </trans-unit>
        <trans-unit id="a7d1d79d92c9e349b139fe633f0b6526fad09ce4" translate="yes" xml:space="preserve">
          <source>Now let's move onto a pythonic method for copying lists.</source>
          <target state="translated">现在让我们转到一个复制列表的拟态方法。</target>
        </trans-unit>
        <trans-unit id="3df54c02f5f581cc533561dc1118e595e1076275" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the list and let's see if we still face the previous problem:</source>
          <target state="translated">现在让我们试着修改一下列表,看看我们是否还面临着之前的问题。</target>
        </trans-unit>
        <trans-unit id="aa39e23942a2753c10c8d3f75f878396c89495a5" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the nested list and see if it solved the previous issue or not:</source>
          <target state="translated">现在让我们试着修改一下嵌套列表,看看是否解决了之前的问题。</target>
        </trans-unit>
        <trans-unit id="18d4f8f9dd5560fdbaaa044248879e0f414571a4" translate="yes" xml:space="preserve">
          <source>Now we can assume both lists are pointing different object, so now let's try to modify it and let's see it is giving what we want:</source>
          <target state="translated">现在我们可以假设两个列表都指向不同的对象,所以现在让我们试着修改一下,看看它是否给出了我们想要的东西。</target>
        </trans-unit>
        <trans-unit id="f36cb40ae7ff021457ab561b8f3c65237590561c" translate="yes" xml:space="preserve">
          <source>Now, imagine you have this list: &lt;em&gt;[[1, 2], [3, 4], [5, 6]]&lt;/em&gt;. This time, you want to make a function, which uses recursion to deep copy all layers of the list. Instead of the previous list comprehension:</source>
          <target state="translated">现在，假设您有以下列表： &lt;em&gt;[[1，2]，[3，4]，[5，6]]&lt;/em&gt; 。 这次，您想创建一个函数，该函数使用递归来深度复制列表的所有层。 代替先前的列表理解：</target>
        </trans-unit>
        <trans-unit id="69f5f45134cb9ec012385bfbf42d5088f5cf8d41" translate="yes" xml:space="preserve">
          <source>Obviously the slowest and most memory-needing method, but sometimes unavoidable.</source>
          <target state="translated">显然是最慢、最需要记忆的方法,但有时也是不可避免的。</target>
        </trans-unit>
        <trans-unit id="dbbf697d62aa4fc57077ea24851b4247f69fc822" translate="yes" xml:space="preserve">
          <source>Once you know that, completely duplicating an object without any references is pretty easy. Here's a function for deepcopying basic data-types (wouldn't work for custom classes but you could always add that)</source>
          <target state="translated">一旦你知道了这一点,完全复制一个对象而不需要任何引用就很容易。这里有一个用于深度复制基本数据类型的函数(对于自定义类就不行,但你可以随时添加这个函数)</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="85428b26db4c1794e05f4269b0c513309de817c9" translate="yes" xml:space="preserve">
          <source>Python 2</source>
          <target state="translated">Python 2</target>
        </trans-unit>
        <trans-unit id="0101a74afd88d622354b05b2b6416e029264bbac" translate="yes" xml:space="preserve">
          <source>Python 3</source>
          <target state="translated">Python 3</target>
        </trans-unit>
        <trans-unit id="4349126aac22c987d016e24c14dcae82a88269df" translate="yes" xml:space="preserve">
          <source>Python 3.6 Timings</source>
          <target state="translated">Python 3.6 时序</target>
        </trans-unit>
        <trans-unit id="6ac4e03df57920cae5a01b21d070287f63116c43" translate="yes" xml:space="preserve">
          <source>Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by &lt;code&gt;my_list&lt;/code&gt; and bound it to &lt;code&gt;new_list&lt;/code&gt; as well. No matter which name you use there is still only one list, so changes made when referring to it as &lt;code&gt;my_list&lt;/code&gt; will persist when referring to it as &lt;code&gt;new_list&lt;/code&gt;. Each of the other answers to this question give you different ways of creating a new object to bind to &lt;code&gt;new_list&lt;/code&gt;.</source>
          <target state="translated">Python不会将值存储在变量中。 它将名称绑定到对象。 您的原始分配使用了 &lt;code&gt;my_list&lt;/code&gt; 引用的对象，并将其也绑定到 &lt;code&gt;new_list&lt;/code&gt; 。 无论您使用哪个名称，仍然只有一个列表，因此将其称为 &lt;code&gt;my_list&lt;/code&gt; 时所做的更改将保留为 &lt;code&gt;new_list&lt;/code&gt; 。 该问题的其他每个答案都为您提供了创建新对象以绑定到 &lt;code&gt;new_list&lt;/code&gt; 的不同方法。</target>
        </trans-unit>
        <trans-unit id="431a4d86ecae97814d808e75432c4497870cb5a0" translate="yes" xml:space="preserve">
          <source>Python's idiom for doing this is &lt;code&gt;newList = oldList[:]&lt;/code&gt;</source>
          <target state="translated">Python的惯用法是 &lt;code&gt;newList = oldList[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c6ddaaef7312488cd7088001672817f1f759347" translate="yes" xml:space="preserve">
          <source>Python's own built-in deepcopy is based around that example. The only difference is it supports other types, and also supports user-classes by duplicating the attributes into a new duplicate class, and also blocks infinite-recursion with a reference to an object it's already seen using a memo list or dictionary. And that's really it for making deep copies. At its core, making a deep copy is just making shallow copies. I hope this answer adds something to the question.</source>
          <target state="translated">Python自己的内置deepcopy就是围绕着这个例子来的。唯一的区别是它支持其他类型,还支持用户类,通过将属性复制到一个新的重复类中,还可以用备注列表或字典来阻止无限递归与它已经看到的对象的引用。而对于深度复制来说,真的就是这样了。就其核心而言,做深度复制就是做浅层复制。我希望这个答案能给这个问题增加一些内容。</target>
        </trans-unit>
        <trans-unit id="cdb020da6f04f980578edbeea557ee080eae15e7" translate="yes" xml:space="preserve">
          <source>Remember that in Python when you do:</source>
          <target state="translated">记住,在Python中,当你做的时候。</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="0c5d365ba03417b1814c4317a93bd505f3d45686" translate="yes" xml:space="preserve">
          <source>Say you have this list: &lt;em&gt;[1, 2, 3]&lt;/em&gt;. The immutable numbers cannot be duplicated, but the other layer can. You can duplicate it using a list comprehension: &lt;em&gt;[x for x in [1, 2, 3]&lt;/em&gt;</source>
          <target state="translated">假设您有此列表： &lt;em&gt;[1,2,3]&lt;/em&gt; 。 不可变的数字不能重复，但是另一层可以重复。 您可以使用列表理解来复制它： &lt;em&gt;[x表示[1、2、3]中的x&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a382c1a79a9abea2c3b456d682976a5c9462e5a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;the documentation&lt;/a&gt; for more information about corner cases in copying.</source>
          <target state="translated">有关复制中极端情况的更多信息，请参见&lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="6772e3c75e46f3d9be01bc50c86027112d2938bf" translate="yes" xml:space="preserve">
          <source>Shallow list copy</source>
          <target state="translated">浅表复制</target>
        </trans-unit>
        <trans-unit id="9a11a8945f8d6b48081dbf5ea5d6e5f5c801b470" translate="yes" xml:space="preserve">
          <source>So as we can see our both list having different id and it means that both variables are pointing to different objects. So what actually going on here is:</source>
          <target state="translated">所以我们可以看到我们的两个列表都有不同的id,这意味着两个变量指向不同的对象。因此,这里的实际情况是:</target>
        </trans-unit>
        <trans-unit id="3513e3f3b28e2724f6f965025e19894e50855199" translate="yes" xml:space="preserve">
          <source>So as we know python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is a &lt;code&gt;list&lt;/code&gt; but we created two references to that same object by two different variable names. This means that both variables are pointing to the same object, just with different names.</source>
          <target state="translated">因此，我们知道python在变量中不存储任何内容，变量只是引用对象，而对象存储值。 这里的对象是一个 &lt;code&gt;list&lt;/code&gt; 但是我们通过两个不同的变量名称创建了对同一对象的两个引用。 这意味着两个变量都指向相同的对象，只是名称不同。</target>
        </trans-unit>
        <trans-unit id="cd1487edc9546c18ca2fb6958037f7bc45eccdcc" translate="yes" xml:space="preserve">
          <source>So first let's try by setting the variable &lt;code&gt;copy&lt;/code&gt; to our original list, &lt;code&gt;list_1&lt;/code&gt;:</source>
          <target state="translated">因此，首先让我们尝试将变量 &lt;code&gt;copy&lt;/code&gt; 设置为原始列表 &lt;code&gt;list_1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="35599f5f6a22799b9a1065745b9e8a7525311cbe" translate="yes" xml:space="preserve">
          <source>So if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:</source>
          <target state="translated">所以,如果你试图修改复制的列表,那么它也会修改原来的列表,因为这个列表只有一个,无论你从复制的列表还是从原来的列表中修改,你都会修改这个列表。</target>
        </trans-unit>
        <trans-unit id="0e6bad77f39dcb244d41a51049f33dcea7721965" translate="yes" xml:space="preserve">
          <source>So it modified the original list :</source>
          <target state="translated">所以,它修改了原来的列表。</target>
        </trans-unit>
        <trans-unit id="f008a22270d77fa388373610112fcf2f544b4006" translate="yes" xml:space="preserve">
          <source>So let's suppose you have two lists:</source>
          <target state="translated">所以,我们假设你有两个名单。</target>
        </trans-unit>
        <trans-unit id="eda3d79321d8e8a6c5f43e602583a85978e82115" translate="yes" xml:space="preserve">
          <source>So the fastest is list slicing. But be aware that &lt;code&gt;copy.copy()&lt;/code&gt;, &lt;code&gt;list[:]&lt;/code&gt; and &lt;code&gt;list(list)&lt;/code&gt;, unlike &lt;code&gt;copy.deepcopy()&lt;/code&gt; and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.</source>
          <target state="translated">因此最快的是列表切片。 但是请注意， &lt;code&gt;copy.copy()&lt;/code&gt; ， &lt;code&gt;list[:]&lt;/code&gt; 和 &lt;code&gt;list(list)&lt;/code&gt; 与 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 和python版本不同，它不会复制列表中的任何列表，字典和类实例，因此如果原始版本改变了，它们也会在复制的列表中更改，反之亦然。</target>
        </trans-unit>
        <trans-unit id="8bbc00ebc1fe27804a2faefef2b2a7c8e80ddd52" translate="yes" xml:space="preserve">
          <source>The Other way you can do this are :</source>
          <target state="translated">其他的方法有:.NET、.NET、.NET、.NET</target>
        </trans-unit>
        <trans-unit id="a51bd5a9f88582672dcba66c5148c7d26e24a8aa" translate="yes" xml:space="preserve">
          <source>The dark horse is the unpacking and repacking method (&lt;code&gt;b = [*a]&lt;/code&gt;), which is ~25% faster than raw slicing, and more than twice as fast as the other unpacking method (&lt;code&gt;*b, = a&lt;/code&gt;).</source>
          <target state="translated">黑马是拆包和重新打包的方法（ &lt;code&gt;b = [*a]&lt;/code&gt; ），比原始切片快约25％，是其他拆包方法（ &lt;code&gt;*b, = a&lt;/code&gt; ）的两倍以上。</target>
        </trans-unit>
        <trans-unit id="efdb3e2274e3293e0058ed73476dabfc0b9f7297" translate="yes" xml:space="preserve">
          <source>The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.</source>
          <target state="translated">列表只是一个内容的指针数组,所以浅层复制只是复制指针,所以你有两个不同的列表,但它们的内容是一样的。要复制内容,就需要一个深度复制。</target>
        </trans-unit>
        <trans-unit id="afa75f9e3be68e27350aefb47205502bf0a9e6e5" translate="yes" xml:space="preserve">
          <source>The obvious downside to this method is that it is only available in Python 3.5+.</source>
          <target state="translated">这种方法的明显缺点是,它只在Python 3.5+中可用。</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">输出是:</target>
        </trans-unit>
        <trans-unit id="90fa1fae686fa6b34b07514c61aa94123be63447" translate="yes" xml:space="preserve">
          <source>Then now you have a function which can deepcopy any list of &lt;strong&gt;strs, bools, floast, ints&lt;/strong&gt; and even &lt;strong&gt;lists&lt;/strong&gt; to infinitely many layers using recursion. And there you have it, deepcopying.</source>
          <target state="translated">然后，现在您有了一个函数，该函数可以使用递归&lt;strong&gt;将&lt;/strong&gt; &lt;strong&gt;str，bool，floast，int&lt;/strong&gt;和甚至list的任何列表&lt;strong&gt;深度复制&lt;/strong&gt;到无限多个图层。 在那里，您可以进行深度复制。</target>
        </trans-unit>
        <trans-unit id="220890ce8fb4c2412811019ffb2db9f207227214" translate="yes" xml:space="preserve">
          <source>There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.</source>
          <target state="translated">在Python 2 和 3 中有不同的方法。Python 2 的方法也可以在 Python 3 中使用。</target>
        </trans-unit>
        <trans-unit id="b6d1fa502414f389e3c4893a7f6454394e1dd9d1" translate="yes" xml:space="preserve">
          <source>There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed.</source>
          <target state="translated">已经有很多答案告诉你如何做一个合适的副本,但没有一个人说为什么你原来的 &quot;副本 &quot;失败了。</target>
        </trans-unit>
        <trans-unit id="66abe6803af6fc0a90902cfc1672796b3aae06b4" translate="yes" xml:space="preserve">
          <source>There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.</source>
          <target state="translated">复制一个列表有两种语义上的方法。浅层复制会创建一个相同对象的新列表,深度复制会创建一个包含新的等价对象的新列表。</target>
        </trans-unit>
        <trans-unit id="bc4ca653a23068dcf7ae97de3b9e4f63df0f559e" translate="yes" xml:space="preserve">
          <source>This gives us the output:</source>
          <target state="translated">这样一来,我们的输出就有了。</target>
        </trans-unit>
        <trans-unit id="557c91f0d91bf8aa2deea01cceab9c91400d0ec2" translate="yes" xml:space="preserve">
          <source>This is a little slower than &lt;code&gt;list()&lt;/code&gt; because it has to find out the datatype of &lt;code&gt;old_list&lt;/code&gt; first.</source>
          <target state="translated">这比 &lt;code&gt;list()&lt;/code&gt; 慢一点，因为它必须先找出 &lt;code&gt;old_list&lt;/code&gt; 的数据类型。</target>
        </trans-unit>
        <trans-unit id="49bb04f0f459e1ca1287d6676b347a76839b4290" translate="yes" xml:space="preserve">
          <source>This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy.</source>
          <target state="translated">这还不是深度复制,因为列表中的每一个元素都可以引用其他对象,就像列表中的元素被绑定到其他对象一样。要递归复制列表中的每一个元素,然后再递归复制每个元素所引用的其他对象,以此类推:执行深度复制。</target>
        </trans-unit>
        <trans-unit id="3c04fe0cc698e2ba7a6efcd47118a60302f9c23f" translate="yes" xml:space="preserve">
          <source>This may seem a little bit confusing, because the same method we previously used worked. Let's try to understand this.</source>
          <target state="translated">这可能会让人觉得有点疑惑,因为我们之前用的方法也是一样的,那么这个方法能不能用呢?让我们试着去了解一下这个问题。</target>
        </trans-unit>
        <trans-unit id="00f93f5227a8e28c60a94b27101682842e37414b" translate="yes" xml:space="preserve">
          <source>This means that for multidimensional lists, the only option is &lt;code&gt;copy.deepcopy()&lt;/code&gt;. With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to &lt;code&gt;timeit&lt;/code&gt; using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.</source>
          <target state="translated">这意味着对于多维列表，唯一的选择是 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 。 话虽这么说，当您尝试在中等大小的多维数组上使用它时，性能实际上会下降，这实际上不是一个选择。 我尝试使用42x42的数组进行计时，这对于生物信息学应用程序来说并不是闻所未闻的，甚至还不是那么大，我放弃了等待回复，只是开始输入我对这篇文章的编辑。</target>
        </trans-unit>
        <trans-unit id="0a9d3f3184e470a21dfb005cbe5d56f43c9b998b" translate="yes" xml:space="preserve">
          <source>This means when you do &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; what actually happens:</source>
          <target state="translated">这意味着当您执行 &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; 时 ，实际发生的情况是：</target>
        </trans-unit>
        <trans-unit id="04a5a8b7256438d8150475968ea5b994c8232285" translate="yes" xml:space="preserve">
          <source>This method fixes the first issue we had:</source>
          <target state="translated">这个方法修复了我们的第一个问题。</target>
        </trans-unit>
        <trans-unit id="e7902de440301cd9e6f660692a60815b9d105656" translate="yes" xml:space="preserve">
          <source>Timing wise though, this appears to perform better than other common methods.</source>
          <target state="translated">计时明智,虽然这似乎比其他常用的方法表现得更好。</target>
        </trans-unit>
        <trans-unit id="6b58f0a40765b5b08203954d86f7c9ff6bee49da" translate="yes" xml:space="preserve">
          <source>To actually copy the list, you have various possibilities:</source>
          <target state="translated">要实际复制列表,你有各种可能。</target>
        </trans-unit>
        <trans-unit id="946633aa3cdcc201da0bfd3b79549497b06ce48f" translate="yes" xml:space="preserve">
          <source>To demonstrate how this allows us to make new sub-lists:</source>
          <target state="translated">为了证明这样做可以让我们制作新的子列表。</target>
        </trans-unit>
        <trans-unit id="18c166dc2118c18ca2195aded821b172eef596bd" translate="yes" xml:space="preserve">
          <source>To make a &lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;deep copy of a list, in Python 2 or 3, use &lt;code&gt;deepcopy&lt;/code&gt; in the &lt;code&gt;copy&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">要制作&lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;列表&lt;/a&gt;的深层副本，请在Python 2或3中使用 &lt;code&gt;copy&lt;/code&gt; 模块中的 &lt;code&gt;deepcopy&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="77a0cef14012e7b83ed88a073f164fddcf757041" translate="yes" xml:space="preserve">
          <source>To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list.</source>
          <target state="translated">要进一步复制你的列表,可以复制你的列表中的每个对象,并将这些元素复制到一个新的列表中。</target>
        </trans-unit>
        <trans-unit id="94a001d83f43e327f9bf5308ade41bb93e8b8b9b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;thing[:]&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;thing[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="704ff25c262b4989c3e885b9c631ea5f00ee2274" translate="yes" xml:space="preserve">
          <source>We can see the Python2 winner still does well, but doesn't edge out Python3 &lt;code&gt;list.copy()&lt;/code&gt; by much, especially considering the superior readability of the latter.</source>
          <target state="translated">我们可以看到Python2赢家仍然表现不错，但是并没有在很大程度上 &lt;code&gt;list.copy()&lt;/code&gt; Python3 list.copy（） ，特别是考虑到后者的优越可读性。</target>
        </trans-unit>
        <trans-unit id="88fa58a7d8228094b91bae093cb54c6c760187cc" translate="yes" xml:space="preserve">
          <source>We get the output:</source>
          <target state="translated">我们得到的输出。</target>
        </trans-unit>
        <trans-unit id="20b49cce5a91432e085e1764e90ac0273068bbc7" translate="yes" xml:space="preserve">
          <source>What are the options to clone or copy a list in Python?</source>
          <target state="translated">在Python中克隆或复制一个列表有哪些选项?</target>
        </trans-unit>
        <trans-unit id="365d64ca08030dc6b88428870f53a2fcdac7e978" translate="yes" xml:space="preserve">
          <source>What is the solution? The solution is the &lt;code&gt;deepcopy&lt;/code&gt; function.</source>
          <target state="translated">解决办法是什么？ 解决方案是 &lt;code&gt;deepcopy&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="8e8115e5fa0f64b2d78e179223b2acf529f438cd" translate="yes" xml:space="preserve">
          <source>When we do &lt;code&gt;copy_2=list_2[:]&lt;/code&gt;, this happens:</source>
          <target state="translated">当我们执行 &lt;code&gt;copy_2=list_2[:]&lt;/code&gt; ，会发生以下情况：</target>
        </trans-unit>
        <trans-unit id="7d92247dca50cce0446da6df8b14549d6a725f7b" translate="yes" xml:space="preserve">
          <source>When you do &lt;code&gt;copy=list_1&lt;/code&gt;, it is actually doing:</source>
          <target state="translated">当您执行 &lt;code&gt;copy=list_1&lt;/code&gt; 时 ，它实际上是在做：</target>
        </trans-unit>
        <trans-unit id="2e8ee345e21d7df889e916663fa72306a26db891" translate="yes" xml:space="preserve">
          <source>When you do:</source>
          <target state="translated">当你做的时候。</target>
        </trans-unit>
        <trans-unit id="25aeb6ff8ce6046a534c673463f7363bfa51d100" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;new_list = old_list[:]&lt;/code&gt;, &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; and for Py3k &lt;code&gt;old_list.copy()&lt;/code&gt; work for single-leveled lists, they revert to pointing at the &lt;code&gt;list&lt;/code&gt; objects nested within the &lt;code&gt;old_list&lt;/code&gt; and the &lt;code&gt;new_list&lt;/code&gt;, and changes to one of the &lt;code&gt;list&lt;/code&gt; objects are perpetuated in the other.</source>
          <target state="translated">当 &lt;code&gt;new_list = old_list[:]&lt;/code&gt; ， &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; 和Py3k &lt;code&gt;old_list.copy()&lt;/code&gt; 用于单层列表时，它们恢复为指向嵌套在 &lt;code&gt;old_list&lt;/code&gt; 和 &lt;code&gt;new_list&lt;/code&gt; 中的 &lt;code&gt;list&lt;/code&gt; 对象，并更改为一个 &lt;code&gt;list&lt;/code&gt; 对象中的另一个被永久保留。</target>
        </trans-unit>
        <trans-unit id="46a5e0acd81721a83e102ba1cc3b2c2c40347a6d" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;new_list = my_list&lt;/code&gt;, any modifications to &lt;code&gt;new_list&lt;/code&gt; changes &lt;code&gt;my_list&lt;/code&gt; everytime.
Why is this?</source>
          <target state="translated">使用 &lt;code&gt;new_list = my_list&lt;/code&gt; ，对 &lt;code&gt;new_list&lt;/code&gt; 的任何修改都会每次更改 &lt;code&gt;my_list&lt;/code&gt; 。 为什么是这样？</target>
        </trans-unit>
        <trans-unit id="4ccc750900a14314384b3bf271f406314a22ce63" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;new_list = my_list&lt;/code&gt;, you don't actually have two lists. The assignment just copies the reference to the list, not the actual list, so both &lt;code&gt;new_list&lt;/code&gt; and &lt;code&gt;my_list&lt;/code&gt; refer to the same list after the assignment.</source>
          <target state="translated">使用 &lt;code&gt;new_list = my_list&lt;/code&gt; ，您实际上没有两个列表。 分配仅将引用复制到列表，而不是实际列表，因此 &lt;code&gt;new_list&lt;/code&gt; 和 &lt;code&gt;my_list&lt;/code&gt; 都在分配后引用同一列表。</target>
        </trans-unit>
        <trans-unit id="225441c8d6bd2a8e2654bc1fd302a0897594025a" translate="yes" xml:space="preserve">
          <source>You can also accomplish the same thing by passing the list through the list constructor,</source>
          <target state="translated">你也可以通过传递列表构造函数来完成同样的事情。</target>
        </trans-unit>
        <trans-unit id="a9e1c8ff6e281ab525b473cb57dfc86a34e5f554" translate="yes" xml:space="preserve">
          <source>You can perform list unpacking with the &quot;splat operator&quot;: &lt;code&gt;*&lt;/code&gt;, which will also copy elements of your list.</source>
          <target state="translated">您可以使用&amp;ldquo; splat运算符&amp;rdquo;： &lt;code&gt;*&lt;/code&gt; 执行列表解压缩，这还将复制列表中的元素。</target>
        </trans-unit>
        <trans-unit id="204a07b1b7642695ed4e50226442ee5bd889a56d" translate="yes" xml:space="preserve">
          <source>You can slice it:</source>
          <target state="translated">你可以切开它。</target>
        </trans-unit>
        <trans-unit id="8b60affbd66d1ab22f4db2b35f4476c0bc727885" translate="yes" xml:space="preserve">
          <source>You can use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">您可以使用通用&lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy()&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="f7c4e65f4ef8f5a93e4955911a9d09385dd4e0e2" translate="yes" xml:space="preserve">
          <source>You can use the built in &lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt;&lt;code&gt;list()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">您可以使用内置的&lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt; &lt;code&gt;list()&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="74e2cb68ed9fb5f2c5405875004d794d14a5f066" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt;&lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method (available since Python 3.3):</source>
          <target state="translated">您可以使用内置的&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt; &lt;code&gt;list.copy()&lt;/code&gt; &lt;/a&gt;方法（自Python 3.3起可用）：</target>
        </trans-unit>
        <trans-unit id="897a434f7844b828ae3989a342e35cc3c21bf0d6" translate="yes" xml:space="preserve">
          <source>You may see this used as a way to deepcopy, but don't do it:</source>
          <target state="translated">你可能会看到这样做是作为深抄的一种方式,但不要这样做。</target>
        </trans-unit>
        <trans-unit id="76244e96c4d1fb0eec733ac274efa594300304e7" translate="yes" xml:space="preserve">
          <source>You're only copying the outer list, not the inside list. We can use the &lt;code&gt;id&lt;/code&gt; function once again to check this.</source>
          <target state="translated">您只复制外部列表，而不复制内部列表。 我们可以再次使用 &lt;code&gt;id&lt;/code&gt; 函数进行检查。</target>
        </trans-unit>
        <trans-unit id="9356e95d4f6f104855f95803d19cc415fcbbdf4f" translate="yes" xml:space="preserve">
          <source>but using the constructor is less efficient:</source>
          <target state="translated">但使用构造函数的效率较低。</target>
        </trans-unit>
        <trans-unit id="6bac1115690000182dc538b79519b1c469db850e" translate="yes" xml:space="preserve">
          <source>on 64 bit Python 3.5:</source>
          <target state="translated">在64位Python 3.5上。</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
