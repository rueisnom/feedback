<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2612802">
    <body>
      <group id="2612802">
        <trans-unit id="6cb2908973d6e330ac0831d07b21e8772ada79a7" translate="yes" xml:space="preserve">
          <source>(Here's the script if anyone's interested or wants to raise any issues:)</source>
          <target state="translated">(누군가 관심이 있거나 문제를 제기하려는 경우 스크립트는 다음과 같습니다.)</target>
        </trans-unit>
        <trans-unit id="ebb3c26aa2a50c6bcf9364047f9a610d479174c0" translate="yes" xml:space="preserve">
          <source>.&lt;strong&gt;Bonus&lt;/strong&gt;: If you don't want to copy elements use (aka shallow copy):</source>
          <target state="translated">. &lt;strong&gt;보너스&lt;/strong&gt; : 요소를 복사하지 않으려면 (얕은 복사)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="831f577c0630013fd2dd428aa6f69fbb8227958b" translate="yes" xml:space="preserve">
          <source>0.039 sec (0.39us/itn) - &lt;code&gt;old_list[:]&lt;/code&gt; (&lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;list slicing&lt;/a&gt;)</source>
          <target state="translated">0.039 초 (0.39us / itn) &lt;code&gt;old_list[:]&lt;/code&gt; ( &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;목록 슬라이싱&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6576742e9a532381a3048dc91ed10879c2220a99" translate="yes" xml:space="preserve">
          <source>0.053 sec (0.53us/itn) - &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt;</source>
          <target state="translated">0.053 초 (0.53us / itn)-new_list &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt; new_list.extend (old_list)</target>
        </trans-unit>
        <trans-unit id="589e176d08ceaa47627386f4c2ee43ef0e412c6f" translate="yes" xml:space="preserve">
          <source>0.075 sec (0.75us/itn) - &lt;code&gt;list(old_list)&lt;/code&gt;</source>
          <target state="translated">0.075 초 (0.75us / itn)- &lt;code&gt;list(old_list)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbf31d4e561cfc6f0a7055b18ae7bb85966be0c" translate="yes" xml:space="preserve">
          <source>0.186 sec (1.86us/itn) - &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">0.186 초 (1.86us / itn) &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9741537872f078018c930db04bb6b7a099568129" translate="yes" xml:space="preserve">
          <source>0.217 sec (2.17us/itn) - &lt;code&gt;[i for i in old_list]&lt;/code&gt; (a &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;list comprehension&lt;/a&gt;)</source>
          <target state="translated">0.217 초 (2.17us / itn)- &lt;code&gt;[i for i in old_list]&lt;/code&gt; old_list의 i에 대한 i] ( &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;목록 이해&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="fcb2fce8f80e6e96b412e3deb49a4a01eef9d95c" translate="yes" xml:space="preserve">
          <source>0.325 sec (3.25us/itn) - &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</source>
          <target state="translated">0.325 초 (3.25us / itn) &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a196696ac9e805fcf92036506af3ef7d8ab819d" translate="yes" xml:space="preserve">
          <source>1.488 sec (14.88us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method not copying classes (only dicts/lists/tuples)</source>
          <target state="translated">1.488 sec (14.88us / itn)-클래스를 복사하지 않는 순수 Python &lt;code&gt;Copy()&lt;/code&gt; 메소드 (dicts / lists / tuples 만)</target>
        </trans-unit>
        <trans-unit id="c36d3f84b0185c78311f648cfb81e4cacde6b9c9" translate="yes" xml:space="preserve">
          <source>10.16 sec (101.6us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method copying classes with deepcopy</source>
          <target state="translated">10.16 sec (101.6us / itn)-딥 카피로 클래스를 복사하는 순수 Python &lt;code&gt;Copy()&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="892f509cfed7a878055c5d6330a5e7a7032f54b5" translate="yes" xml:space="preserve">
          <source>10.59 sec (105.9us/itn) -  &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">10.59 초 (105.9us / itn) &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24d242d81528698f099460d3c52d07280215058e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;Alex Martelli's&lt;/a&gt; opinion (at least &lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;back in 2007&lt;/a&gt;) about this is, that &lt;em&gt;it is a weird syntax and it does not make sense to use it ever&lt;/em&gt;. ;) (In his opinion, the next one is more readable).</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;이것에 대한 Alex Martelli의&lt;/a&gt; 의견 (적어도 &lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;2007 년에 되돌아온&lt;/a&gt; )은 &lt;em&gt;그것이 이상한 구문이며 그것을 사용하는 것은 의미가 없다는 것입니다&lt;/em&gt; . ;) (그의 의견으로는 다음 내용이 더 읽기 쉽습니다).</target>
        </trans-unit>
        <trans-unit id="cb21dd5df394bc7fae7c132b18417ae29a3bc579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b = a * 1&lt;/code&gt; also does surprisingly well.</source>
          <target state="translated">&lt;code&gt;b = a * 1&lt;/code&gt; 도 놀랍게 잘 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d9ef3187620786222a615d86bcc314673d3289f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list_2&lt;/code&gt; should reference to another object which is copy of &lt;code&gt;list_2&lt;/code&gt;. Let's check:</source>
          <target state="translated">&lt;code&gt;list_2&lt;/code&gt; 는 list_2의 사본 인 다른 오브젝트를 참조해야합니다. 점검 해보자:</target>
        </trans-unit>
        <trans-unit id="4f36085cfc8ae8adb7dd3849ea72baa17b0c317a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_list&lt;/code&gt; is just a name that points to the actual list in memory. When you say &lt;code&gt;new_list = my_list&lt;/code&gt; you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists.</source>
          <target state="translated">&lt;code&gt;my_list&lt;/code&gt; 는 메모리의 실제 목록을 가리키는 이름입니다. &lt;code&gt;new_list = my_list&lt;/code&gt; 라고 말하면 복사하지 않고 메모리의 원래 목록을 가리키는 다른 이름을 추가하는 것입니다. 목록을 복사 할 때 비슷한 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2041e8c18dbff0914a06b5e2a1252d4733642d53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_list = my_list&lt;/code&gt;
Try to understand this. Let's say that my_list is in the heap memory at location X i.e. my_list is pointing to the X. Now by assigning &lt;code&gt;new_list = my_list&lt;/code&gt; you're Letting new_list pointing to the X. This is known as shallow Copy.</source>
          <target state="translated">&lt;code&gt;new_list = my_list&lt;/code&gt; 이것을 이해하십시오. my_list가 X 위치의 힙 메모리에 있다고 가정합니다. 즉, my_list는 X를 가리 킵니다. 이제 &lt;code&gt;new_list = my_list&lt;/code&gt; 를 지정하면 new_list가 X를 가리키게됩니다. 이것을 얕은 복사라고합니다.</target>
        </trans-unit>
        <trans-unit id="8ef17a4719ab0f78b42c3681f36203e226fb86dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EXAMPLES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EXAMPLES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fd15ef13529e8eb7aac1e4fb2625df3343dbcd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that these methods do &lt;em&gt;not&lt;/em&gt; output equivalent results for any input other than lists.&lt;/strong&gt; They all work for sliceable objects, a few work for any iterable, but only &lt;code&gt;copy.copy()&lt;/code&gt; works for more general Python objects.</source>
          <target state="translated">&lt;strong&gt;이러한 방법은 목록 이외의 입력에 대해 동등한 결과를 출력하지 &lt;em&gt;않습니다&lt;/em&gt; .&lt;/strong&gt; 그것들은 모두 슬라이스 가능한 객체에서 작동하고 반복 가능한 모든 경우에는 작동하지만 &lt;code&gt;copy.copy()&lt;/code&gt; 만이 일반적인 Python 객체에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6044cdaafb431c7ebd900f17cd900457b458ca20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;: Deepcopy uses recursion to duplicate objects, and merely returns the same immutable objects as before, as immutable objects cannot be duplicated. However, it deepcopies the most inner layers of mutable objects until it reaches the outermost mutable layer of an object.</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt; : Deepcopy는 재귀를 사용하여 객체를 복제하며 불변 객체는 복제 할 수 없으므로 이전과 동일한 불변 객체를 반환합니다. 그러나 객체의 가장 바깥쪽에있는 변경 가능 레이어에 도달 할 때까지 가변 객체의 가장 안쪽 레이어를 심층 복사합니다.</target>
        </trans-unit>
        <trans-unit id="0669e0817e0ab8178fe6bdeadc9d599cc4692d12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using new_list = my_list then modifies new_list every time my_list changes. Why is this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;new_list = my_list를 사용하면 my_list가 변경 될 때마다 new_list가 수정됩니다.&lt;/strong&gt; &lt;strong&gt;왜 이런거야?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d45c9a0fde240fd63fbe4e27fddcf428b240c39" translate="yes" xml:space="preserve">
          <source>A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists.</source>
          <target state="translated">단순 복사본은 목록 자체 만 복사하며, 목록의 개체에 대한 참조 컨테이너입니다. 포함 된 개체가 변경 가능하고 하나가 변경되면 변경 사항이 두 목록에 모두 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="005c37f0237b5cb139854b9e4687176ca563565b" translate="yes" xml:space="preserve">
          <source>A slight practical perspective to look into memory through id and gc.</source>
          <target state="translated">id와 gc를 통해 메모리를 살펴볼 약간의 실용적인 관점.</target>
        </trans-unit>
        <trans-unit id="8261b218a41d10fe8c0dcd15e9088d1cb42e6891" translate="yes" xml:space="preserve">
          <source>A very simple approach independent of python version was missing in already given answers which you can use most of the time (at least I do):</source>
          <target state="translated">파이썬 버전과 독립적 인 매우 간단한 접근 방식은 이미 주어진 대답에서 누락되어 대부분의 시간을 사용할 수 있습니다 (적어도 나는합니다).</target>
        </trans-unit>
        <trans-unit id="3498a4737c6e7fe24088dc089c3bcc79dda6d821" translate="yes" xml:space="preserve">
          <source>All of the other contributors gave &lt;strong&gt;great&lt;/strong&gt; answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only &lt;code&gt;copy.deepcopy()&lt;/code&gt; works to clone/copy a list and not have it point to the nested &lt;code&gt;list&lt;/code&gt; objects when you are working with multidimensional, nested lists (list of lists). While &lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;Felix Kling&lt;/a&gt; refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to &lt;code&gt;deepcopy&lt;/code&gt;.</source>
          <target state="translated">다른 모든 기고자들은 단일 차원 (레벨 화 된) 목록이있을 때 작동하는 &lt;strong&gt;훌륭한&lt;/strong&gt; 답변을 주 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 지금까지 언급 된 방법 중 copy.deepcopy () 만이 목록을 복제 / 복사하고 목록을 가리 키지 않습니다. 다차원의 중첩 목록 (목록 목록)으로 작업 할 때 중첩 &lt;code&gt;list&lt;/code&gt; 객체. &lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;펠릭스 클링&lt;/a&gt; 은 그의 답변에서이 문제를 언급하지만, &lt;code&gt;deepcopy&lt;/code&gt; 의 더 빠른 대안을 입증 할 수있는 내장 기능을 사용하는 문제와 해결 방법이 조금 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a258d25732edb4a8dc4c53104d80ea8e8ba4b1f" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;deepcopy_list&lt;/strong&gt; looks like this:</source>
          <target state="translated">&lt;strong&gt;deepcopy_list&lt;/strong&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99c81ac1dec28ab432158972b11dcd87811305fd" translate="yes" xml:space="preserve">
          <source>And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.</source>
          <target state="translated">따라서 우리는 딥 카피 목록이 원본과 완전히 다른 목록임을 알 수 있습니다. 당신은 자신의 기능을 굴릴 수는 있지만 그렇지 않습니다. 표준 라이브러리의 딥 카피 기능을 사용하면 그렇지 않은 버그를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baf0b49d9e610c1e0b9aaf4f81c197fe9b3f4561" translate="yes" xml:space="preserve">
          <source>And we have to copy both lists, now starting from the first list:</source>
          <target state="translated">그리고 이제 첫 번째 목록부터 시작하여 두 목록을 모두 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d4cea5d2aa1cef4716a69ab86f2a6adcf09e2c9" translate="yes" xml:space="preserve">
          <source>As others have stated, there  &lt;strong&gt;&lt;em&gt;are significant&lt;/em&gt;&lt;/strong&gt; performance issues using the &lt;code&gt;copy&lt;/code&gt; module and &lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;strong&gt;&lt;em&gt;for multidimensional lists&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">다른 사람들이 언급했듯이, &lt;strong&gt;&lt;em&gt;다차원 목록의&lt;/em&gt;&lt;/strong&gt; 경우 &lt;code&gt;copy&lt;/code&gt; 모듈 및 &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;strong&gt;&lt;em&gt;를&lt;/em&gt;&lt;/strong&gt; 사용하면 성능 &lt;strong&gt;&lt;em&gt;에 심각한&lt;/em&gt;&lt;/strong&gt; 문제가 &lt;strong&gt;&lt;em&gt;있습니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c03a694d0b4332e4b08b86ede988da2173792481" translate="yes" xml:space="preserve">
          <source>As was pointed out by both &lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;Aaron Hall&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ring&lt;/a&gt;&lt;strong&gt;using &lt;code&gt;eval()&lt;/code&gt; is not only a bad idea, it is also much slower than &lt;code&gt;copy.deepcopy()&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;Aaron Hall&lt;/a&gt; 과 &lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ring이&lt;/a&gt; &lt;strong&gt; &lt;code&gt;eval()&lt;/code&gt; 사용하는 것이 나쁜 생각 일뿐 만 아니라 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 보다 훨씬 느립니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0bae3de46c365ceae27557d207d519a16f03d1f" translate="yes" xml:space="preserve">
          <source>As you can see Solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.</source>
          <target state="translated">보시다시피 솔루션 # 1은 중첩 목록을 사용하지 않을 때 완벽하게 작동했습니다. 솔루션 # 1을 중첩 된 목록에 적용 할 때 어떤 일이 발생하는지 확인하겠습니다.</target>
        </trans-unit>
        <trans-unit id="1fa9f6c88dde54a4948d45a55a86287ba1ddfa53" translate="yes" xml:space="preserve">
          <source>As you can see both IDs are different, meaning we can assume that both nested lists are pointing different object now.</source>
          <target state="translated">보시다시피 두 ID가 다름을 알 수 있습니다. 즉, 중첩 된 두 목록이 모두 다른 개체를 가리키고 있다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76931cafef2a867dc6f7e1459fcb607ba73ac1cc" translate="yes" xml:space="preserve">
          <source>As you can see, it didn't modify the original nested list, it only modified the copied list.</source>
          <target state="translated">보시다시피 원래 중첩 목록은 수정하지 않고 복사 된 목록 만 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="3bd849e1d81d4729cb3f7546cfc9844c9422980a" translate="yes" xml:space="preserve">
          <source>As you can see, it only modified the copied list. That means it worked.</source>
          <target state="translated">보시다시피 복사 된 목록 만 수정되었습니다. 그것은 그것이 효과가 있다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7f5db9e07be4014478905b5c75e8654633a0eeb3" translate="yes" xml:space="preserve">
          <source>At the core of any deep copy function is way to make a shallow copy. How? Simple. Any deep copy function only duplicates the containers of immutable objects. When you deepcopy a nested list, you are only duplicating the outer lists, not the mutable objects inside of the lists. You are only duplicating the containers. The same works for classes, too. When you deepcopy a class, you deepcopy all of its mutable attributes. So, how? How come you only have to copy the containers, like lists, dicts, tuples, iters, classes, and class instances?</source>
          <target state="translated">깊은 복사 기능의 핵심은 얕은 복사를 만드는 방법입니다. 어떻게? 단순한. 모든 깊은 복사 기능은 변경 불가능한 객체의 컨테이너 만 복제합니다. 중첩 된 목록을 딥 카피하면 목록 내부의 변경 가능한 개체가 아닌 외부 목록 만 복제됩니다. 컨테이너를 복제하는 중입니다. 수업에서도 마찬가지입니다. 클래스를 딥 카피 할 때 변경 가능한 모든 속성을 딥 카피합니다. 그래서 방법? 목록, dicts, 튜플, iter, 클래스 및 클래스 인스턴스와 같은 컨테이너 만 어떻게 복사해야합니까?</target>
        </trans-unit>
        <trans-unit id="e99ab5abd5933a0d7d0b66c200bfec3d28b8a6b1" translate="yes" xml:space="preserve">
          <source>Both nested lists are pointing different object and they have separate copy of nested list now.</source>
          <target state="translated">두 중첩 목록이 서로 다른 객체를 가리키고 있으며 이제 중첩 목록의 별도 사본이 있습니다.</target>
        </trans-unit>
        <trans-unit id="836b19e7f8037813d193adb0ea22763be677a48c" translate="yes" xml:space="preserve">
          <source>Both outer lists have different IDs, let's try this on the inner nested lists.</source>
          <target state="translated">두 외부 목록 모두 ID가 다르므로 내부 중첩 목록에서 시도해 봅시다.</target>
        </trans-unit>
        <trans-unit id="f079e1b881840a2f35a6dd6a384ae5baae282f12" translate="yes" xml:space="preserve">
          <source>Both variables are the exact same argument. Are you surprised?</source>
          <target state="translated">두 변수는 모두 동일한 인수입니다. 너 놀랐 니?</target>
        </trans-unit>
        <trans-unit id="97e297e7f407d34ed9e7296aa23537583633a817" translate="yes" xml:space="preserve">
          <source>Deep copies</source>
          <target state="translated">딥 카피</target>
        </trans-unit>
        <trans-unit id="80c240c06fa36efab33567b8dd004136b3a42e84" translate="yes" xml:space="preserve">
          <source>Do you think we're done? No. Let's try to copy our nested list.</source>
          <target state="translated">우리가 끝났다고 생각합니까? 아니요. 중첩 목록을 복사 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="579defd972ab926c631e8d21e9eff8c734a498e0" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="1a27986749695e29a6ff85bbb5c2f396fd63cf1d" translate="yes" xml:space="preserve">
          <source>Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.</source>
          <target state="translated">목록의 각 요소는 이름과 같은 역할을합니다. 각 요소는 배타적으로 개체에 바인딩됩니다. 얕은 복사본은 요소가 이전과 동일한 개체에 바인딩되는 새 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="100e61c040833faea556e102ff4c6f46b647f7ed" translate="yes" xml:space="preserve">
          <source>Edit: New information brought to light</source>
          <target state="translated">편집 : 새로운 정보가 등장</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="e959b489a54884803ea418506d068419cb2bc499" translate="yes" xml:space="preserve">
          <source>Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:</source>
          <target state="translated">펠릭스는 이미 훌륭한 답변을 제공했지만 다양한 방법을 속도 비교할 것이라고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="dd44e670da0e5e9141f6396dd8d5c9a9a6ec0348" translate="yes" xml:space="preserve">
          <source>Here are the timing results using Python 3.6.8. Keep in mind these times are relative to one another, not absolute.</source>
          <target state="translated">다음은 Python 3.6.8을 사용한 타이밍 결과입니다. 이 시간은 절대적이 아니라 서로에 대한 것임을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="7aa26673265eca05d895ce387611ec36d0b80e52" translate="yes" xml:space="preserve">
          <source>Here in the image list_1 and copy are two variable names but the object is same for both variable which is &lt;code&gt;list&lt;/code&gt;</source>
          <target state="translated">여기에 이미지 list_1과 copy는 두 개의 변수 이름이지만 객체는 &lt;code&gt;list&lt;/code&gt; 인 두 변수에 대해 동일 합니다</target>
        </trans-unit>
        <trans-unit id="9767ca12b4902a277abb578b041a4030915e4f7b" translate="yes" xml:space="preserve">
          <source>Here is the testing code for interested parties (&lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;Template from here&lt;/a&gt;):</source>
          <target state="translated">이해 당사자를위한 테스트 코드는 다음과 같습니다 ( &lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;여기에서 템플릿&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="290e2f376f5eaf8c22b1793823c15aae8fcd1d51" translate="yes" xml:space="preserve">
          <source>How to clone or copy a list</source>
          <target state="translated">목록을 복제하거나 복사하는 방법</target>
        </trans-unit>
        <trans-unit id="25d3f80cbc35ca2648934a22a93b5357eecb73c4" translate="yes" xml:space="preserve">
          <source>However, If my_list contains other containers (for eg. nested lists) you must use deepcopy as others suggested in the answers above from the copy library. For example:</source>
          <target state="translated">그러나 my_list에 다른 컨테이너 (예 : 중첩 목록)가 포함되어 있으면 위의 답변에서 복사 라이브러리에서 제안 된 다른 것과 같이 deepcopy를 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4edc1a0498725bd60f03b13cb73da0476b50e73c" translate="yes" xml:space="preserve">
          <source>I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python2, such as &lt;code&gt;list.copy()&lt;/code&gt; (the Python3 &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;slice equivalent&lt;/a&gt;) and two forms of &lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;list unpacking&lt;/a&gt; (&lt;code&gt;*new_list, = list&lt;/code&gt; and &lt;code&gt;new_list = [*list]&lt;/code&gt;):</source>
          <target state="translated">얕은 사본 만 사용하고 &lt;code&gt;list.copy()&lt;/code&gt; (Python3 &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;슬라이스와 동등한&lt;/a&gt; ) 및 두 가지 형태의 &lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;목록 압축 풀기&lt;/a&gt; ( &lt;code&gt;*new_list, = list&lt;/code&gt; and &lt;code&gt;new_list = [*list]&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="013e110db0a05f5dbd20f8b57eade2f83a54868e" translate="yes" xml:space="preserve">
          <source>I wanted to post something a bit different then some of the other answers. Even though this is most likely not the most understandable, or fastest option, it provides a bit of an inside view of how deep copy works, as well as being another alternative option for deep copying. It doesn't really matter if my function has bugs, since the point of this is to show a way to copy objects like the question answers, but also to use this as a point to explain how deepcopy works at its core.</source>
          <target state="translated">다른 답변과 약간 다른 것을 게시하고 싶었습니다. 이것이 가장 이해하기 쉽지 않거나 가장 빠른 옵션은 아니지만 딥 카피의 작동 방식에 대한 약간의 내부 견해와 딥 카피의 또 다른 대체 옵션입니다. 내 함수에 버그가 있는지 여부는 중요하지 않습니다.이 시점의 핵심은 질문 답변과 같은 객체를 복사하는 방법을 보여 주지만 심층 복사가 핵심에서 어떻게 작동하는지 설명하는 지점으로 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="09c0b5ded50202962dc2368628c1933a8369a2c8" translate="yes" xml:space="preserve">
          <source>I've &lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;been told&lt;/a&gt; that Python 3.3+ &lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt;adds &lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method, which should be as fast as slicing:</source>
          <target state="translated">파이썬 3.3 이상은 &lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt; &lt;code&gt;list.copy()&lt;/code&gt; &lt;/a&gt; 메소드를 추가 &lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;한다고 말&lt;/a&gt; 했는데, 슬라이싱만큼 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d8a425aac0dd5c097429125cc2f15c4bcc6557bd" translate="yes" xml:space="preserve">
          <source>If the list contains objects and you want to copy them as well, use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">목록에 객체가 포함되어 있고 복사하려는 경우 일반 &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="508aa1ec404f76db49d3513ef7b4d07bcec9be02" translate="yes" xml:space="preserve">
          <source>If you like my detailed answer, I would appreciate if you would upvote it. If you have any doubt about this answer, you can comment it down below.</source>
          <target state="translated">당신이 내 자세한 답변을 좋아한다면, 당신이 그것을 높이면 감사하겠습니다. 이 답변에 대해 의문이있는 경우 아래에 댓글을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f608b902f462e04b6d6182623136fb4a743d3d57" translate="yes" xml:space="preserve">
          <source>In 64 bit Python 2.7:</source>
          <target state="translated">64 비트 Python 2.7에서 :</target>
        </trans-unit>
        <trans-unit id="2212a7dd8b8134dc3343d8ad7cbe5fae3fce8816" translate="yes" xml:space="preserve">
          <source>In Python 2 and 3, you can get a shallow copy with a full slice of the original:</source>
          <target state="translated">파이썬 2와 3에서는 원본의 전체 조각으로 얕은 사본을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ac599cde0b2c5ab6842e5b2c183be812be9d03e" translate="yes" xml:space="preserve">
          <source>In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:</source>
          <target state="translated">Python 2에서 목록의 얕은 사본을 만드는 관용적 방법은 원본의 전체 조각입니다.</target>
        </trans-unit>
        <trans-unit id="c1a7abb8ba4c30e338a899c8b6ef3d8068af2771" translate="yes" xml:space="preserve">
          <source>In Python 3, a shallow copy can be made with:</source>
          <target state="translated">Python 3에서는 다음을 사용하여 얕은 사본을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fb02af71a6aec0493954b8ede599618597636b0" translate="yes" xml:space="preserve">
          <source>In Python 3, lists get the &lt;code&gt;list.copy&lt;/code&gt; method:</source>
          <target state="translated">Python 3에서 list는 &lt;code&gt;list.copy&lt;/code&gt; 메소드를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="80e3fc6970cca93fe92c32b6c4ba9f0ab890dd92" translate="yes" xml:space="preserve">
          <source>In Python 3.5:</source>
          <target state="translated">파이썬 3.5에서 :</target>
        </trans-unit>
        <trans-unit id="e1e6045a5cef20010f69d146803165ac49a5152d" translate="yes" xml:space="preserve">
          <source>It creates the copy of list but only outer list copy, not the nested list copy, nested list is same for both variable, so if you try to modify the nested list then it will modify the original list too as the nested list object is same for both lists.</source>
          <target state="translated">중첩 된 목록 복사본이 아닌 목록의 사본을 생성하지만 외부 목록 사본 만 생성합니다. 중첩 된 목록은 두 변수에 대해 동일하므로 중첩 된 목록을 수정하려고하면 중첩 된 목록 객체가 동일하므로 원래 목록도 수정됩니다 두 목록 모두.</target>
        </trans-unit>
        <trans-unit id="d34c379d10b758183565c52320bbe1d3d85b2994" translate="yes" xml:space="preserve">
          <source>It outputs:</source>
          <target state="translated">출력합니다 :</target>
        </trans-unit>
        <trans-unit id="98a7ab1fd383d07403bec0fdbf00b56735e9d4fa" translate="yes" xml:space="preserve">
          <source>It surprises me that this hasn't been mentioned yet, so for the sake of completeness...</source>
          <target state="translated">이것이 아직 언급되지 않았다는 것이 놀랍습니다. 따라서 완전성을 위해 ...</target>
        </trans-unit>
        <trans-unit id="f22686b03873b3c74078fb08c5978fac2477ccf4" translate="yes" xml:space="preserve">
          <source>It uses a new one for lists:</source>
          <target state="translated">목록에 새로운 것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c598a66587c1a2b513dfdee0f11cfe379df4fc51" translate="yes" xml:space="preserve">
          <source>It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.</source>
          <target state="translated">그렇다면 유일한 유일한 옵션은 여러 목록을 초기화하고 독립적으로 작업하는 것입니다. 다차원 목록 복사를 처리하는 방법에 대한 다른 제안이 있으면 누구나 감사하겠습니다.</target>
        </trans-unit>
        <trans-unit id="bfec348e3000941e5686d75ef056c9817e63c4f9" translate="yes" xml:space="preserve">
          <source>It's also less performant.</source>
          <target state="translated">또한 성능이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="e5e39dfe9f9b8c35e9d451cae1bbf0f97001f659" translate="yes" xml:space="preserve">
          <source>It's dangerous, particularly if you're evaluating something from a source you don't trust.</source>
          <target state="translated">특히 신뢰할 수없는 출처에서 무언가를 평가하는 경우 위험합니다.</target>
        </trans-unit>
        <trans-unit id="30201c551b5097249c25a2dcab3ffcb946ee7734" translate="yes" xml:space="preserve">
          <source>It's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.</source>
          <target state="translated">복사하는 하위 요소에 동등한 요소를 재현하기 위해 평가할 수있는 표현이없는 경우 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92b01213c7f0b76ca02c2f59a64061096e1ca746" translate="yes" xml:space="preserve">
          <source>It's simple. A mutable object can't really be duplicated. It can never be changed, so it is only a single value. That means you never have to duplicate strings, numbers, bools, or any of those. But how would you duplicate the containers? Simple. You make just initialize a new container with all of the values. Deepcopy relies on recursion. It duplicates all the containers, even ones with containers inside of them, until no containers are left. A container is an immutable object.</source>
          <target state="translated">간단 해. 변경 가능한 객체는 실제로 복제 할 수 없습니다. 변경할 수 없으므로 단일 값일뿐입니다. 즉, 문자열, 숫자, 부울 또는 그중 하나를 복제 할 필요가 없습니다. 그러나 컨테이너를 어떻게 복제합니까? 단순한. 모든 값으로 새 컨테이너를 초기화하십시오. Deepcopy는 재귀에 의존합니다. 컨테이너가 남아 있지 않을 때까지 모든 컨테이너, 심지어 컨테이너가 내부에있는 컨테이너를 복제합니다. 컨테이너는 불변의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="45fb77de6753c9a311b64100017c382af6c0cc51" translate="yes" xml:space="preserve">
          <source>Let's check this:</source>
          <target state="translated">이것을 확인하자 :</target>
        </trans-unit>
        <trans-unit id="0c5355b2834dda4cbab54f13603bb0d4f281a582" translate="yes" xml:space="preserve">
          <source>Let's start from the beginning and explore this question.</source>
          <target state="translated">처음부터 시작하여이 질문을 살펴 봅시다.</target>
        </trans-unit>
        <trans-unit id="4ea13a33e351858421ccf9c6208908351b78f68b" translate="yes" xml:space="preserve">
          <source>Let's understand difference between Solution#1 and Solution #2</source>
          <target state="translated">솔루션 # 1과 솔루션 # 2의 차이점을 이해합시다</target>
        </trans-unit>
        <trans-unit id="6fc2993f803fe2bce5ebd68d1671312a116f8f99" translate="yes" xml:space="preserve">
          <source>List2 isn't storing the actual list, but a reference to list1. So when you do anything to list1, list2 changes as well. use the copy module (not default, download on pip) to make an original copy of the list(&lt;code&gt;copy.copy()&lt;/code&gt; for simple lists, &lt;code&gt;copy.deepcopy()&lt;/code&gt; for nested ones). This makes a copy that doesn't change with the first list.</source>
          <target state="translated">List2는 실제 목록을 저장하지 않고 list1에 대한 참조를 저장합니다. 따라서 list1에 무언가를하면 list2도 변경됩니다. 복사 모듈 (기본값은 아님, pip로 다운로드)을 사용하여 목록의 원본을 복사하십시오 (단순 목록의 경우 &lt;code&gt;copy.deepcopy()&lt;/code&gt; , 중첩 된 목록의 경우 copy.deepcopy () ). 첫 번째 목록으로 변경되지 않은 사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cf2a1e2bb3e71888a0f43aeb3ac08c80b8fcc911" translate="yes" xml:space="preserve">
          <source>Making another pointer does &lt;em&gt;not&lt;/em&gt; make a copy</source>
          <target state="translated">다른 포인터를 만들면 복사되지 &lt;em&gt;않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e97c704d7d43e21b1fcfda833b090668ec5e244" translate="yes" xml:space="preserve">
          <source>Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use &lt;code&gt;copy.copy()&lt;/code&gt; or &lt;code&gt;copy.deepcopy()&lt;/code&gt; rather than the alternatives, for example in Python 3:</source>
          <target state="translated">자체 사용자 정의 클래스를 정의하고 속성을 유지하려는 경우 Python 3과 같은 대안 대신 &lt;code&gt;copy.copy()&lt;/code&gt; 또는 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 를 사용해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3932369e81674c80f98992bf457167b246e6424" translate="yes" xml:space="preserve">
          <source>Now if you are thinking copy copied the list_1, then you are wrong. The &lt;code&gt;id&lt;/code&gt; function can show us if two variables can point to the same object. Let's try this:</source>
          <target state="translated">이제 copy가 list_1을 복사했다고 생각하면 잘못되었습니다. &lt;code&gt;id&lt;/code&gt; 함수는 두 변수가 같은 객체를 가리킬 수 있는지 보여줍니다. 이것을 시도하자 :</target>
        </trans-unit>
        <trans-unit id="00347d0a4cb14f4559c30793412031205df3863d" translate="yes" xml:space="preserve">
          <source>Now if you assign &lt;code&gt;new_list = my_list[:]&lt;/code&gt; You're simply copying each object of my_list to new_list. This is known as Deep copy.</source>
          <target state="translated">이제 &lt;code&gt;new_list = my_list[:]&lt;/code&gt; 를 할당하면 my_list의 각 객체를 new_list로 복사하기 만하면됩니다. 이것을 딥 카피라고합니다.</target>
        </trans-unit>
        <trans-unit id="a7d1d79d92c9e349b139fe633f0b6526fad09ce4" translate="yes" xml:space="preserve">
          <source>Now let's move onto a pythonic method for copying lists.</source>
          <target state="translated">이제리스트를 복사하기위한 pythonic 방법으로 넘어 갑시다.</target>
        </trans-unit>
        <trans-unit id="3df54c02f5f581cc533561dc1118e595e1076275" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the list and let's see if we still face the previous problem:</source>
          <target state="translated">이제 목록을 수정하고 이전 문제가 계속 발생하는지 확인해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="aa39e23942a2753c10c8d3f75f878396c89495a5" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the nested list and see if it solved the previous issue or not:</source>
          <target state="translated">이제 중첩 목록을 수정하고 이전 문제가 해결되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="18d4f8f9dd5560fdbaaa044248879e0f414571a4" translate="yes" xml:space="preserve">
          <source>Now we can assume both lists are pointing different object, so now let's try to modify it and let's see it is giving what we want:</source>
          <target state="translated">이제 두 목록이 다른 객체를 가리키고 있다고 가정 할 수 있습니다. 이제 수정하고 우리가 원하는 것을주는 것을 보자.</target>
        </trans-unit>
        <trans-unit id="f36cb40ae7ff021457ab561b8f3c65237590561c" translate="yes" xml:space="preserve">
          <source>Now, imagine you have this list: &lt;em&gt;[[1, 2], [3, 4], [5, 6]]&lt;/em&gt;. This time, you want to make a function, which uses recursion to deep copy all layers of the list. Instead of the previous list comprehension:</source>
          <target state="translated">이제 &lt;em&gt;[[1, 2], [3, 4], [5, 6]]&lt;/em&gt; 목록이 있다고 가정하십시오. 이번에는 재귀를 사용하여 목록의 모든 레이어를 딥 카피하는 함수를 만들고 싶습니다. 이전 목록 이해 대신 :</target>
        </trans-unit>
        <trans-unit id="69f5f45134cb9ec012385bfbf42d5088f5cf8d41" translate="yes" xml:space="preserve">
          <source>Obviously the slowest and most memory-needing method, but sometimes unavoidable.</source>
          <target state="translated">분명히 가장 느리고 가장 메모리 니딩 방법이지만 때로는 피할 수없는 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbbf697d62aa4fc57077ea24851b4247f69fc822" translate="yes" xml:space="preserve">
          <source>Once you know that, completely duplicating an object without any references is pretty easy. Here's a function for deepcopying basic data-types (wouldn't work for custom classes but you could always add that)</source>
          <target state="translated">일단 알면 참조없이 객체를 완전히 복제하는 것은 매우 쉽습니다. 다음은 기본 데이터 유형을 심층 복사하는 기능입니다 (사용자 정의 클래스에서는 작동하지 않지만 항상 추가 할 수는 있습니다)</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="85428b26db4c1794e05f4269b0c513309de817c9" translate="yes" xml:space="preserve">
          <source>Python 2</source>
          <target state="translated">파이썬 2</target>
        </trans-unit>
        <trans-unit id="0101a74afd88d622354b05b2b6416e029264bbac" translate="yes" xml:space="preserve">
          <source>Python 3</source>
          <target state="translated">파이썬 3</target>
        </trans-unit>
        <trans-unit id="4349126aac22c987d016e24c14dcae82a88269df" translate="yes" xml:space="preserve">
          <source>Python 3.6 Timings</source>
          <target state="translated">파이썬 3.6 타이밍</target>
        </trans-unit>
        <trans-unit id="6ac4e03df57920cae5a01b21d070287f63116c43" translate="yes" xml:space="preserve">
          <source>Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by &lt;code&gt;my_list&lt;/code&gt; and bound it to &lt;code&gt;new_list&lt;/code&gt; as well. No matter which name you use there is still only one list, so changes made when referring to it as &lt;code&gt;my_list&lt;/code&gt; will persist when referring to it as &lt;code&gt;new_list&lt;/code&gt;. Each of the other answers to this question give you different ways of creating a new object to bind to &lt;code&gt;new_list&lt;/code&gt;.</source>
          <target state="translated">파이썬은 변수에 값을 저장하지 않습니다. 이름을 객체에 바인딩합니다. 원래 과제는 &lt;code&gt;my_list&lt;/code&gt; 에서 참조한 객체를 가져 와서 &lt;code&gt;new_list&lt;/code&gt; 에도 바인딩했습니다. 어떤 이름을 사용하든 여전히 하나의 목록 만 있으므로 &lt;code&gt;my_list&lt;/code&gt; 로 참조 할 때 변경 한 내용은 &lt;code&gt;new_list&lt;/code&gt; 로 참조 할 때 유지됩니다. 이 질문에 대한 다른 답변은 각각 &lt;code&gt;new_list&lt;/code&gt; 에 바인딩 할 새 객체를 만드는 다양한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="431a4d86ecae97814d808e75432c4497870cb5a0" translate="yes" xml:space="preserve">
          <source>Python's idiom for doing this is &lt;code&gt;newList = oldList[:]&lt;/code&gt;</source>
          <target state="translated">이것을하기위한 파이썬의 관용구는 &lt;code&gt;newList = oldList[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c6ddaaef7312488cd7088001672817f1f759347" translate="yes" xml:space="preserve">
          <source>Python's own built-in deepcopy is based around that example. The only difference is it supports other types, and also supports user-classes by duplicating the attributes into a new duplicate class, and also blocks infinite-recursion with a reference to an object it's already seen using a memo list or dictionary. And that's really it for making deep copies. At its core, making a deep copy is just making shallow copies. I hope this answer adds something to the question.</source>
          <target state="translated">파이썬 자체 내장 심도 복사는이 예제를 기반으로합니다. 유일한 차이점은 다른 유형을 지원하고 속성을 새로운 복제 클래스로 복제하여 사용자 클래스를 지원하며 메모 목록 또는 사전을 사용하여 이미 본 객체에 대한 참조로 무한 재귀를 차단합니다. 딥 카피를 만들기위한 것입니다. 기본적으로 딥 카피는 얕은 카피를 만드는 것입니다. 이 답변이 질문에 무언가를 추가하기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="cdb020da6f04f980578edbeea557ee080eae15e7" translate="yes" xml:space="preserve">
          <source>Remember that in Python when you do:</source>
          <target state="translated">파이썬에서는 다음을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="0c5d365ba03417b1814c4317a93bd505f3d45686" translate="yes" xml:space="preserve">
          <source>Say you have this list: &lt;em&gt;[1, 2, 3]&lt;/em&gt;. The immutable numbers cannot be duplicated, but the other layer can. You can duplicate it using a list comprehension: &lt;em&gt;[x for x in [1, 2, 3]&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[1, 2, 3]&lt;/em&gt; 목록이 있다고 가정하십시오. 불변의 숫자는 복제 할 수 없지만 다른 레이어는 복제 할 수 없습니다. 리스트 이해를 사용하여 복제 할 수 있습니다. &lt;em&gt;[[x in x in [1, 2, 3]]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a382c1a79a9abea2c3b456d682976a5c9462e5a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;the documentation&lt;/a&gt; for more information about corner cases in copying.</source>
          <target state="translated">복사시 코너 케이스에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6772e3c75e46f3d9be01bc50c86027112d2938bf" translate="yes" xml:space="preserve">
          <source>Shallow list copy</source>
          <target state="translated">얕은 목록 사본</target>
        </trans-unit>
        <trans-unit id="9a11a8945f8d6b48081dbf5ea5d6e5f5c801b470" translate="yes" xml:space="preserve">
          <source>So as we can see our both list having different id and it means that both variables are pointing to different objects. So what actually going on here is:</source>
          <target state="translated">우리가 볼 수 있듯이 두 목록이 서로 다른 ID를 가지고 있다는 것은 두 변수가 다른 객체를 가리키고 있음을 의미합니다. 실제로 여기서 진행되는 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3513e3f3b28e2724f6f965025e19894e50855199" translate="yes" xml:space="preserve">
          <source>So as we know python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is a &lt;code&gt;list&lt;/code&gt; but we created two references to that same object by two different variable names. This means that both variables are pointing to the same object, just with different names.</source>
          <target state="translated">파이썬이 변수에 아무것도 저장하지 않는다는 것을 알기 때문에 변수는 객체를 참조하고 객체는 값을 저장합니다. 여기서 object는 &lt;code&gt;list&lt;/code&gt; 이지만 두 개의 다른 변수 이름으로 같은 동일한 오브젝트에 대한 두 개의 참조를 작성했습니다. 이것은 두 변수가 다른 이름을 가진 동일한 객체를 가리키고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cd1487edc9546c18ca2fb6958037f7bc45eccdcc" translate="yes" xml:space="preserve">
          <source>So first let's try by setting the variable &lt;code&gt;copy&lt;/code&gt; to our original list, &lt;code&gt;list_1&lt;/code&gt;:</source>
          <target state="translated">먼저 변수 &lt;code&gt;copy&lt;/code&gt; 를 원래 목록 인 &lt;code&gt;list_1&lt;/code&gt; 로 설정해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="35599f5f6a22799b9a1065745b9e8a7525311cbe" translate="yes" xml:space="preserve">
          <source>So if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:</source>
          <target state="translated">따라서 복사 된 목록을 수정하려고하면 목록이 하나이기 때문에 원본 목록도 수정됩니다. 복사 된 목록 또는 원본 목록에서 수행 한 목록에 관계없이 해당 목록을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="0e6bad77f39dcb244d41a51049f33dcea7721965" translate="yes" xml:space="preserve">
          <source>So it modified the original list :</source>
          <target state="translated">그래서 원래 목록을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="f008a22270d77fa388373610112fcf2f544b4006" translate="yes" xml:space="preserve">
          <source>So let's suppose you have two lists:</source>
          <target state="translated">따라서 두 개의 목록이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="eda3d79321d8e8a6c5f43e602583a85978e82115" translate="yes" xml:space="preserve">
          <source>So the fastest is list slicing. But be aware that &lt;code&gt;copy.copy()&lt;/code&gt;, &lt;code&gt;list[:]&lt;/code&gt; and &lt;code&gt;list(list)&lt;/code&gt;, unlike &lt;code&gt;copy.deepcopy()&lt;/code&gt; and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.</source>
          <target state="translated">따라서 가장 빠른 것은 목록 슬라이싱입니다. 그러나 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 및 python 버전과 달리 &lt;code&gt;copy.copy()&lt;/code&gt; , &lt;code&gt;list[:]&lt;/code&gt; 및 &lt;code&gt;list(list)&lt;/code&gt; 는 목록의 목록, 사전 및 클래스 인스턴스를 복사하지 않으므로 원본이 변경되면 복사 된 목록에서도 변경되며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="8bbc00ebc1fe27804a2faefef2b2a7c8e80ddd52" translate="yes" xml:space="preserve">
          <source>The Other way you can do this are :</source>
          <target state="translated">다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a51bd5a9f88582672dcba66c5148c7d26e24a8aa" translate="yes" xml:space="preserve">
          <source>The dark horse is the unpacking and repacking method (&lt;code&gt;b = [*a]&lt;/code&gt;), which is ~25% faster than raw slicing, and more than twice as fast as the other unpacking method (&lt;code&gt;*b, = a&lt;/code&gt;).</source>
          <target state="translated">다크 호스는 포장 풀기 및 재 포장 방법 ( &lt;code&gt;b = [*a]&lt;/code&gt; )으로, 원시 슬라이싱보다 ~ 25 % 빠르며 다른 포장 풀기 방법 ( &lt;code&gt;*b, = a&lt;/code&gt; )보다 2 배 이상 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="efdb3e2274e3293e0058ed73476dabfc0b9f7297" translate="yes" xml:space="preserve">
          <source>The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.</source>
          <target state="translated">목록은 내용에 대한 포인터 배열이므로 얕은 사본은 포인터를 복사하기 때문에 두 개의 다른 목록이 있지만 내용은 동일합니다. 내용을 복사하려면 깊은 사본이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="afa75f9e3be68e27350aefb47205502bf0a9e6e5" translate="yes" xml:space="preserve">
          <source>The obvious downside to this method is that it is only available in Python 3.5+.</source>
          <target state="translated">이 방법의 명백한 단점은 Python 3.5 이상에서만 사용할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90fa1fae686fa6b34b07514c61aa94123be63447" translate="yes" xml:space="preserve">
          <source>Then now you have a function which can deepcopy any list of &lt;strong&gt;strs, bools, floast, ints&lt;/strong&gt; and even &lt;strong&gt;lists&lt;/strong&gt; to infinitely many layers using recursion. And there you have it, deepcopying.</source>
          <target state="translated">그런 다음 재귀를 사용하여 &lt;strong&gt;strs, bools, floast, int&lt;/strong&gt; 및 &lt;strong&gt;list&lt;/strong&gt; 를 무한히 많은 레이어로 &lt;strong&gt;딥 카피&lt;/strong&gt; 할 수있는 기능이 있습니다. 그리고 거기에는 심층 복사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="220890ce8fb4c2412811019ffb2db9f207227214" translate="yes" xml:space="preserve">
          <source>There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.</source>
          <target state="translated">파이썬 2와 3에서는 이것을하는 다른 방법이 있습니다. 파이썬 2는 파이썬 3에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b6d1fa502414f389e3c4893a7f6454394e1dd9d1" translate="yes" xml:space="preserve">
          <source>There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed.</source>
          <target state="translated">올바른 사본을 만드는 방법을 알려주는 많은 답변이 이미 있지만, 왜 '원본'복사가 실패했는지는 아무도 대답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66abe6803af6fc0a90902cfc1672796b3aae06b4" translate="yes" xml:space="preserve">
          <source>There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.</source>
          <target state="translated">리스트를 복사하는 두 가지 의미 론적 방법이 있습니다. 얕은 사본은 동일한 오브젝트의 새 목록을 작성하고 깊은 사본은 새로운 동등한 오브젝트를 포함하는 새 목록을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="bc4ca653a23068dcf7ae97de3b9e4f63df0f559e" translate="yes" xml:space="preserve">
          <source>This gives us the output:</source>
          <target state="translated">이것은 우리에게 출력을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="557c91f0d91bf8aa2deea01cceab9c91400d0ec2" translate="yes" xml:space="preserve">
          <source>This is a little slower than &lt;code&gt;list()&lt;/code&gt; because it has to find out the datatype of &lt;code&gt;old_list&lt;/code&gt; first.</source>
          <target state="translated">&lt;code&gt;old_list&lt;/code&gt; 의 데이터 유형을 먼저 찾아야하므로 &lt;code&gt;list()&lt;/code&gt; 보다 약간 느립니다.</target>
        </trans-unit>
        <trans-unit id="49bb04f0f459e1ca1287d6676b347a76839b4290" translate="yes" xml:space="preserve">
          <source>This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy.</source>
          <target state="translated">목록의 각 요소가 해당 요소에 바인딩 된 것처럼 목록의 각 요소가 다른 개체를 참조 할 수 있기 때문에 아직 딥 카피는 아닙니다. 목록의 모든 요소를 ​​반복해서 복사 한 다음 각 요소가 참조하는 서로 다른 개체 등을 반복적으로 복사하려면 다음과 같이하십시오. 깊은 복사를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3c04fe0cc698e2ba7a6efcd47118a60302f9c23f" translate="yes" xml:space="preserve">
          <source>This may seem a little bit confusing, because the same method we previously used worked. Let's try to understand this.</source>
          <target state="translated">이전에 사용한 것과 동일한 방법으로 작동했기 때문에 약간 혼란스러워 보일 수 있습니다. 이것을 이해하려고 노력합시다.</target>
        </trans-unit>
        <trans-unit id="00f93f5227a8e28c60a94b27101682842e37414b" translate="yes" xml:space="preserve">
          <source>This means that for multidimensional lists, the only option is &lt;code&gt;copy.deepcopy()&lt;/code&gt;. With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to &lt;code&gt;timeit&lt;/code&gt; using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.</source>
          <target state="translated">이는 다차원 목록의 경우 유일한 옵션은 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 입니다. 말했듯이, 적당한 크기의 다차원 배열에서 성능을 사용하려고 할 때 성능이 남쪽으로 가므로 실제로는 옵션이 아닙니다. 나는 생물 정보학 응용 프로그램에 대해 들어 보지 못했거나 그다지 크지 않은 42x42 배열을 사용하여 &lt;code&gt;timeit&lt;/code&gt; 을 맞추려고 했지만 응답을 기다리는 것을 포기 하고이 게시물에 편집 내용을 입력하기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="0a9d3f3184e470a21dfb005cbe5d56f43c9b998b" translate="yes" xml:space="preserve">
          <source>This means when you do &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; what actually happens:</source>
          <target state="translated">이것은 당신이 &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; 할 때 실제로 일어나는 것을 의미합니다 :</target>
        </trans-unit>
        <trans-unit id="04a5a8b7256438d8150475968ea5b994c8232285" translate="yes" xml:space="preserve">
          <source>This method fixes the first issue we had:</source>
          <target state="translated">이 방법은 첫 번째 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="e7902de440301cd9e6f660692a60815b9d105656" translate="yes" xml:space="preserve">
          <source>Timing wise though, this appears to perform better than other common methods.</source>
          <target state="translated">그러나 현명한 타이밍은 다른 일반적인 방법보다 성능이 우수합니다.</target>
        </trans-unit>
        <trans-unit id="6b58f0a40765b5b08203954d86f7c9ff6bee49da" translate="yes" xml:space="preserve">
          <source>To actually copy the list, you have various possibilities:</source>
          <target state="translated">실제로 목록을 복사하려면 다양한 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="946633aa3cdcc201da0bfd3b79549497b06ce48f" translate="yes" xml:space="preserve">
          <source>To demonstrate how this allows us to make new sub-lists:</source>
          <target state="translated">이것이 어떻게 새로운 하위 목록을 만들 수 있는지 보여주기 위해 :</target>
        </trans-unit>
        <trans-unit id="18c166dc2118c18ca2195aded821b172eef596bd" translate="yes" xml:space="preserve">
          <source>To make a &lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;deep copy of a list, in Python 2 or 3, use &lt;code&gt;deepcopy&lt;/code&gt; in the &lt;code&gt;copy&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;Python 2 또는 3에서 목록&lt;/a&gt; 의 딥 카피 를 만들려면 &lt;code&gt;copy&lt;/code&gt; 모듈에서 &lt;code&gt;deepcopy&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="77a0cef14012e7b83ed88a073f164fddcf757041" translate="yes" xml:space="preserve">
          <source>To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list.</source>
          <target state="translated">목록 복사를 한 단계 더 진행하려면 목록에서 참조하는 각 개체를 복사하고 해당 요소 복사본을 새 목록에 바인딩하십시오.</target>
        </trans-unit>
        <trans-unit id="94a001d83f43e327f9bf5308ade41bb93e8b8b9b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;thing[:]&lt;/code&gt;</source>
          <target state="translated">사용하는 &lt;code&gt;thing[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="704ff25c262b4989c3e885b9c631ea5f00ee2274" translate="yes" xml:space="preserve">
          <source>We can see the Python2 winner still does well, but doesn't edge out Python3 &lt;code&gt;list.copy()&lt;/code&gt; by much, especially considering the superior readability of the latter.</source>
          <target state="translated">우리는 Python2 우승자가 여전히 잘하는 것을 볼 수 있지만, 특히 후자의 우수한 가독성을 고려할 때 Python3 &lt;code&gt;list.copy()&lt;/code&gt; 를 많이 능가 하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="88fa58a7d8228094b91bae093cb54c6c760187cc" translate="yes" xml:space="preserve">
          <source>We get the output:</source>
          <target state="translated">우리는 출력을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="20b49cce5a91432e085e1764e90ac0273068bbc7" translate="yes" xml:space="preserve">
          <source>What are the options to clone or copy a list in Python?</source>
          <target state="translated">파이썬에서 목록을 복제하거나 복사하는 옵션은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="365d64ca08030dc6b88428870f53a2fcdac7e978" translate="yes" xml:space="preserve">
          <source>What is the solution? The solution is the &lt;code&gt;deepcopy&lt;/code&gt; function.</source>
          <target state="translated">해결 방안은 무엇인가? 해결책은 &lt;code&gt;deepcopy&lt;/code&gt; 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8e8115e5fa0f64b2d78e179223b2acf529f438cd" translate="yes" xml:space="preserve">
          <source>When we do &lt;code&gt;copy_2=list_2[:]&lt;/code&gt;, this happens:</source>
          <target state="translated">&lt;code&gt;copy_2=list_2[:]&lt;/code&gt; 하면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7d92247dca50cce0446da6df8b14549d6a725f7b" translate="yes" xml:space="preserve">
          <source>When you do &lt;code&gt;copy=list_1&lt;/code&gt;, it is actually doing:</source>
          <target state="translated">&lt;code&gt;copy=list_1&lt;/code&gt; 을 수행하면 실제로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8ee345e21d7df889e916663fa72306a26db891" translate="yes" xml:space="preserve">
          <source>When you do:</source>
          <target state="translated">할 때 :</target>
        </trans-unit>
        <trans-unit id="25aeb6ff8ce6046a534c673463f7363bfa51d100" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;new_list = old_list[:]&lt;/code&gt;, &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; and for Py3k &lt;code&gt;old_list.copy()&lt;/code&gt; work for single-leveled lists, they revert to pointing at the &lt;code&gt;list&lt;/code&gt; objects nested within the &lt;code&gt;old_list&lt;/code&gt; and the &lt;code&gt;new_list&lt;/code&gt;, and changes to one of the &lt;code&gt;list&lt;/code&gt; objects are perpetuated in the other.</source>
          <target state="translated">&lt;code&gt;new_list = old_list[:]&lt;/code&gt; , &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; 및 Py3k &lt;code&gt;old_list.copy()&lt;/code&gt; 는 단일 레벨 목록에서 작동하지만 &lt;code&gt;old_list&lt;/code&gt; 및 &lt;code&gt;new_list&lt;/code&gt; 내에 중첩 된 &lt;code&gt;list&lt;/code&gt; 객체를 가리키고 1로 변경됩니다. &lt;code&gt;list&lt;/code&gt; 개체 중 다른 개체는 영구적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="46a5e0acd81721a83e102ba1cc3b2c2c40347a6d" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;new_list = my_list&lt;/code&gt;, any modifications to &lt;code&gt;new_list&lt;/code&gt; changes &lt;code&gt;my_list&lt;/code&gt; everytime.
Why is this?</source>
          <target state="translated">&lt;code&gt;new_list = my_list&lt;/code&gt; 사용하는 동안 new_list를 수정하면 매번 &lt;code&gt;my_list&lt;/code&gt; 가 변경됩니다. 왜 이런거야?</target>
        </trans-unit>
        <trans-unit id="4ccc750900a14314384b3bf271f406314a22ce63" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;new_list = my_list&lt;/code&gt;, you don't actually have two lists. The assignment just copies the reference to the list, not the actual list, so both &lt;code&gt;new_list&lt;/code&gt; and &lt;code&gt;my_list&lt;/code&gt; refer to the same list after the assignment.</source>
          <target state="translated">&lt;code&gt;new_list = my_list&lt;/code&gt; 를 사용하면 실제로 두 개의 목록이 없습니다. 할당은 실제 목록이 아닌 목록에 대한 참조 만 복사하므로 &lt;code&gt;new_list&lt;/code&gt; 와 &lt;code&gt;my_list&lt;/code&gt; 는 모두 할당 후 동일한 목록을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="225441c8d6bd2a8e2654bc1fd302a0897594025a" translate="yes" xml:space="preserve">
          <source>You can also accomplish the same thing by passing the list through the list constructor,</source>
          <target state="translated">목록 생성자를 통해 목록을 전달하여 동일한 작업을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e1c8ff6e281ab525b473cb57dfc86a34e5f554" translate="yes" xml:space="preserve">
          <source>You can perform list unpacking with the &quot;splat operator&quot;: &lt;code&gt;*&lt;/code&gt;, which will also copy elements of your list.</source>
          <target state="translated">&quot;splat operator&quot;: &lt;code&gt;*&lt;/code&gt; 를 사용하여 목록 압축 풀기를 수행 할 수 있으며, 목록의 요소도 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="204a07b1b7642695ed4e50226442ee5bd889a56d" translate="yes" xml:space="preserve">
          <source>You can slice it:</source>
          <target state="translated">당신은 그것을 슬라이스 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8b60affbd66d1ab22f4db2b35f4476c0bc727885" translate="yes" xml:space="preserve">
          <source>You can use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">일반적인 &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f7c4e65f4ef8f5a93e4955911a9d09385dd4e0e2" translate="yes" xml:space="preserve">
          <source>You can use the built in &lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt;&lt;code&gt;list()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">내장 &lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt; &lt;code&gt;list()&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74e2cb68ed9fb5f2c5405875004d794d14a5f066" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt;&lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method (available since Python 3.3):</source>
          <target state="translated">내장 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt; &lt;code&gt;list.copy()&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다 (Python 3.3부터 사용 가능).</target>
        </trans-unit>
        <trans-unit id="897a434f7844b828ae3989a342e35cc3c21bf0d6" translate="yes" xml:space="preserve">
          <source>You may see this used as a way to deepcopy, but don't do it:</source>
          <target state="translated">이것을 심도 복사 방법으로 사용했을 수도 있지만 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="76244e96c4d1fb0eec733ac274efa594300304e7" translate="yes" xml:space="preserve">
          <source>You're only copying the outer list, not the inside list. We can use the &lt;code&gt;id&lt;/code&gt; function once again to check this.</source>
          <target state="translated">내부 목록이 아닌 외부 목록 만 복사하고 있습니다. &lt;code&gt;id&lt;/code&gt; 함수를 다시 한 번 사용하여이를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9356e95d4f6f104855f95803d19cc415fcbbdf4f" translate="yes" xml:space="preserve">
          <source>but using the constructor is less efficient:</source>
          <target state="translated">그러나 생성자를 사용하는 것이 덜 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6bac1115690000182dc538b79519b1c469db850e" translate="yes" xml:space="preserve">
          <source>on 64 bit Python 3.5:</source>
          <target state="translated">64 비트 Python 3.5 :</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
