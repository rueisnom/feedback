<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2612802">
    <body>
      <group id="2612802">
        <trans-unit id="6cb2908973d6e330ac0831d07b21e8772ada79a7" translate="yes" xml:space="preserve">
          <source>(Here's the script if anyone's interested or wants to raise any issues:)</source>
          <target state="translated">(Вот сценарий,если кто-нибудь заинтересуется или захочет поднять какие-нибудь вопросы:)</target>
        </trans-unit>
        <trans-unit id="ebb3c26aa2a50c6bcf9364047f9a610d479174c0" translate="yes" xml:space="preserve">
          <source>.&lt;strong&gt;Bonus&lt;/strong&gt;: If you don't want to copy elements use (aka shallow copy):</source>
          <target state="translated">, &lt;strong&gt;Бонус&lt;/strong&gt; : если вы не хотите копировать элементы, используйте (или мелкое копирование):</target>
        </trans-unit>
        <trans-unit id="831f577c0630013fd2dd428aa6f69fbb8227958b" translate="yes" xml:space="preserve">
          <source>0.039 sec (0.39us/itn) - &lt;code&gt;old_list[:]&lt;/code&gt; (&lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;list slicing&lt;/a&gt;)</source>
          <target state="translated">0,039 с (0,39us / itn) - &lt;code&gt;old_list[:]&lt;/code&gt; ( &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;нарезка списка&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6576742e9a532381a3048dc91ed10879c2220a99" translate="yes" xml:space="preserve">
          <source>0.053 sec (0.53us/itn) - &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt;</source>
          <target state="translated">0,053 с (0,53us / itn) - &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt; new_list.extend (old_list)</target>
        </trans-unit>
        <trans-unit id="589e176d08ceaa47627386f4c2ee43ef0e412c6f" translate="yes" xml:space="preserve">
          <source>0.075 sec (0.75us/itn) - &lt;code&gt;list(old_list)&lt;/code&gt;</source>
          <target state="translated">0.075 сек (0.75us / itn) - &lt;code&gt;list(old_list)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbf31d4e561cfc6f0a7055b18ae7bb85966be0c" translate="yes" xml:space="preserve">
          <source>0.186 sec (1.86us/itn) - &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">0,186 с (1,86US / ITN) - &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9741537872f078018c930db04bb6b7a099568129" translate="yes" xml:space="preserve">
          <source>0.217 sec (2.17us/itn) - &lt;code&gt;[i for i in old_list]&lt;/code&gt; (a &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;list comprehension&lt;/a&gt;)</source>
          <target state="translated">0,217 с (2,17us / itn) - &lt;code&gt;[i for i in old_list]&lt;/code&gt; ( &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;понимание списка&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="fcb2fce8f80e6e96b412e3deb49a4a01eef9d95c" translate="yes" xml:space="preserve">
          <source>0.325 sec (3.25us/itn) - &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</source>
          <target state="translated">0,325 с (3,25US / ITN) - &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a196696ac9e805fcf92036506af3ef7d8ab819d" translate="yes" xml:space="preserve">
          <source>1.488 sec (14.88us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method not copying classes (only dicts/lists/tuples)</source>
          <target state="translated">1.488 сек (14.88us / itn) - чистый метод Python &lt;code&gt;Copy()&lt;/code&gt; не копирующий классы (только dicts / lists / tuples)</target>
        </trans-unit>
        <trans-unit id="c36d3f84b0185c78311f648cfb81e4cacde6b9c9" translate="yes" xml:space="preserve">
          <source>10.16 sec (101.6us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method copying classes with deepcopy</source>
          <target state="translated">10,16 с (101,6us / itn) - метод Python &lt;code&gt;Copy()&lt;/code&gt; копирующий классы с помощью глубокой копии</target>
        </trans-unit>
        <trans-unit id="892f509cfed7a878055c5d6330a5e7a7032f54b5" translate="yes" xml:space="preserve">
          <source>10.59 sec (105.9us/itn) -  &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">10,59 с (105,9us / itn) - &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24d242d81528698f099460d3c52d07280215058e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;Alex Martelli's&lt;/a&gt; opinion (at least &lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;back in 2007&lt;/a&gt;) about this is, that &lt;em&gt;it is a weird syntax and it does not make sense to use it ever&lt;/em&gt;. ;) (In his opinion, the next one is more readable).</source>
          <target state="translated">Мнение &lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;Алекса Мартелли&lt;/a&gt; (по крайней мере, &lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;в 2007 году&lt;/a&gt; ) об этом заключается в том, что &lt;em&gt;это странный синтаксис, и нет смысла использовать его когда-либо&lt;/em&gt; . ;) (По его мнению, следующий более читабелен).</target>
        </trans-unit>
        <trans-unit id="cb21dd5df394bc7fae7c132b18417ae29a3bc579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b = a * 1&lt;/code&gt; also does surprisingly well.</source>
          <target state="translated">&lt;code&gt;b = a * 1&lt;/code&gt; также на удивление хорошо.</target>
        </trans-unit>
        <trans-unit id="d9ef3187620786222a615d86bcc314673d3289f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list_2&lt;/code&gt; should reference to another object which is copy of &lt;code&gt;list_2&lt;/code&gt;. Let's check:</source>
          <target state="translated">&lt;code&gt;list_2&lt;/code&gt; должен ссылаться на другой объект, который является копией &lt;code&gt;list_2&lt;/code&gt; . Давайте проверим:</target>
        </trans-unit>
        <trans-unit id="4f36085cfc8ae8adb7dd3849ea72baa17b0c317a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_list&lt;/code&gt; is just a name that points to the actual list in memory. When you say &lt;code&gt;new_list = my_list&lt;/code&gt; you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists.</source>
          <target state="translated">&lt;code&gt;my_list&lt;/code&gt; - это просто имя, которое указывает на фактический список в памяти. Когда вы говорите, что &lt;code&gt;new_list = my_list&lt;/code&gt; вы не делаете копию, вы просто добавляете другое имя, которое указывает на этот оригинальный список в памяти. У нас могут быть похожие проблемы, когда мы делаем копии списков.</target>
        </trans-unit>
        <trans-unit id="2041e8c18dbff0914a06b5e2a1252d4733642d53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_list = my_list&lt;/code&gt;
Try to understand this. Let's say that my_list is in the heap memory at location X i.e. my_list is pointing to the X. Now by assigning &lt;code&gt;new_list = my_list&lt;/code&gt; you're Letting new_list pointing to the X. This is known as shallow Copy.</source>
          <target state="translated">&lt;code&gt;new_list = my_list&lt;/code&gt; Попробуйте понять это. Допустим, что my_list находится в куче памяти в местоположении X, т.е. my_list указывает на X. Теперь, присваивая &lt;code&gt;new_list = my_list&lt;/code&gt; вы позволяете new_list указывать на X. Это называется мелким копированием.</target>
        </trans-unit>
        <trans-unit id="8ef17a4719ab0f78b42c3681f36203e226fb86dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EXAMPLES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EXAMPLES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fd15ef13529e8eb7aac1e4fb2625df3343dbcd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that these methods do &lt;em&gt;not&lt;/em&gt; output equivalent results for any input other than lists.&lt;/strong&gt; They all work for sliceable objects, a few work for any iterable, but only &lt;code&gt;copy.copy()&lt;/code&gt; works for more general Python objects.</source>
          <target state="translated">&lt;strong&gt;Обратите внимание, что эти методы &lt;em&gt;не&lt;/em&gt; выводят эквивалентные результаты для любого ввода, кроме списков.&lt;/strong&gt; Все они работают для срезаемых объектов, некоторые работают для любых итерируемых, но только &lt;code&gt;copy.copy()&lt;/code&gt; работает для более общих объектов Python.</target>
        </trans-unit>
        <trans-unit id="6044cdaafb431c7ebd900f17cd900457b458ca20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;: Deepcopy uses recursion to duplicate objects, and merely returns the same immutable objects as before, as immutable objects cannot be duplicated. However, it deepcopies the most inner layers of mutable objects until it reaches the outermost mutable layer of an object.</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt; : Deepcopy использует рекурсию для дублирования объектов и просто возвращает те же неизменяемые объекты, что и раньше, поскольку неизменяемые объекты не могут дублироваться. Однако он копирует самые внутренние слои изменяемых объектов до тех пор, пока не достигнет самого изменчивого слоя объекта.</target>
        </trans-unit>
        <trans-unit id="0669e0817e0ab8178fe6bdeadc9d599cc4692d12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using new_list = my_list then modifies new_list every time my_list changes. Why is this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Использование new_list = my_list затем изменяет new_list каждый раз, когда изменяется my_list.&lt;/strong&gt; &lt;strong&gt;Почему это?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d45c9a0fde240fd63fbe4e27fddcf428b240c39" translate="yes" xml:space="preserve">
          <source>A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists.</source>
          <target state="translated">Мелкая копия копирует только сам список,который является контейнером ссылок на объекты в списке.Если содержащиеся в нем объекты мутируются и один из них изменяется,то изменение будет отражено в обоих списках.</target>
        </trans-unit>
        <trans-unit id="005c37f0237b5cb139854b9e4687176ca563565b" translate="yes" xml:space="preserve">
          <source>A slight practical perspective to look into memory through id and gc.</source>
          <target state="translated">Небольшая практическая перспектива заглянуть в память через id и gc.</target>
        </trans-unit>
        <trans-unit id="8261b218a41d10fe8c0dcd15e9088d1cb42e6891" translate="yes" xml:space="preserve">
          <source>A very simple approach independent of python version was missing in already given answers which you can use most of the time (at least I do):</source>
          <target state="translated">Очень простой подход,не зависящий от версии питона,отсутствовал в уже данных ответах,которые можно было использовать большую часть времени (по крайней мере,я):</target>
        </trans-unit>
        <trans-unit id="3498a4737c6e7fe24088dc089c3bcc79dda6d821" translate="yes" xml:space="preserve">
          <source>All of the other contributors gave &lt;strong&gt;great&lt;/strong&gt; answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only &lt;code&gt;copy.deepcopy()&lt;/code&gt; works to clone/copy a list and not have it point to the nested &lt;code&gt;list&lt;/code&gt; objects when you are working with multidimensional, nested lists (list of lists). While &lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;Felix Kling&lt;/a&gt; refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to &lt;code&gt;deepcopy&lt;/code&gt;.</source>
          <target state="translated">Все остальные авторы дали &lt;strong&gt;отличные&lt;/strong&gt; ответы, которые работают, когда у вас есть &lt;code&gt;copy.deepcopy()&lt;/code&gt; выровненный) список, однако из методов, упомянутых до сих пор, только copy.deepcopy () работает для клонирования / копирования списка и не дает ему указывать на объекты вложенных &lt;code&gt;list&lt;/code&gt; при работе с многомерными вложенными списками (list of lists). Хотя &lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;Феликс Клинг&lt;/a&gt; ссылается на это в своем ответе, есть еще &lt;code&gt;deepcopy&lt;/code&gt; -что к проблеме и, возможно, обходной путь, использующий встроенные модули, которые могут оказаться более быстрой альтернативой глубокому копированию .</target>
        </trans-unit>
        <trans-unit id="6a258d25732edb4a8dc4c53104d80ea8e8ba4b1f" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;deepcopy_list&lt;/strong&gt; looks like this:</source>
          <target state="translated">И &lt;strong&gt;deepcopy_list&lt;/strong&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="99c81ac1dec28ab432158972b11dcd87811305fd" translate="yes" xml:space="preserve">
          <source>And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.</source>
          <target state="translated">И так мы видим,что глубоко скопированный список совершенно отличается от оригинала.Ты можешь сам свернуть свою функцию-но не надо.Скорее всего,вы создадите ошибки,которых у вас не было бы,если бы вы использовали стандартную функцию глубокой копировки библиотеки.</target>
        </trans-unit>
        <trans-unit id="baf0b49d9e610c1e0b9aaf4f81c197fe9b3f4561" translate="yes" xml:space="preserve">
          <source>And we have to copy both lists, now starting from the first list:</source>
          <target state="translated">И мы должны скопировать оба списка,начиная с первого:</target>
        </trans-unit>
        <trans-unit id="9d4cea5d2aa1cef4716a69ab86f2a6adcf09e2c9" translate="yes" xml:space="preserve">
          <source>As others have stated, there  &lt;strong&gt;&lt;em&gt;are significant&lt;/em&gt;&lt;/strong&gt; performance issues using the &lt;code&gt;copy&lt;/code&gt; module and &lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;strong&gt;&lt;em&gt;for multidimensional lists&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">Как уже &lt;code&gt;copy.deepcopy&lt;/code&gt; другие, существуют &lt;strong&gt;&lt;em&gt;значительные&lt;/em&gt;&lt;/strong&gt; проблемы с производительностью при использовании модуля &lt;code&gt;copy&lt;/code&gt; и copy.deepcopy &lt;strong&gt;&lt;em&gt;для многомерных списков&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c03a694d0b4332e4b08b86ede988da2173792481" translate="yes" xml:space="preserve">
          <source>As was pointed out by both &lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;Aaron Hall&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ring&lt;/a&gt;&lt;strong&gt;using &lt;code&gt;eval()&lt;/code&gt; is not only a bad idea, it is also much slower than &lt;code&gt;copy.deepcopy()&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">Как было отмечено &lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;Aaron Hall&lt;/a&gt; и &lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ring,&lt;/a&gt; &lt;strong&gt;использование &lt;code&gt;eval()&lt;/code&gt; не только плохая идея, но и намного медленнее, чем &lt;code&gt;copy.deepcopy()&lt;/code&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0bae3de46c365ceae27557d207d519a16f03d1f" translate="yes" xml:space="preserve">
          <source>As you can see Solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.</source>
          <target state="translated">Как видите,решение #1 отлично работало,когда мы не использовали вложенные списки.Давайте проверим,что произойдет,когда мы применим решение #1 к вложенным спискам.</target>
        </trans-unit>
        <trans-unit id="1fa9f6c88dde54a4948d45a55a86287ba1ddfa53" translate="yes" xml:space="preserve">
          <source>As you can see both IDs are different, meaning we can assume that both nested lists are pointing different object now.</source>
          <target state="translated">Как вы видите,оба ID разные,то есть можно предположить,что оба вложенных списка теперь указывают на разные объекты.</target>
        </trans-unit>
        <trans-unit id="76931cafef2a867dc6f7e1459fcb607ba73ac1cc" translate="yes" xml:space="preserve">
          <source>As you can see, it didn't modify the original nested list, it only modified the copied list.</source>
          <target state="translated">Как видите,он не изменял исходный вложенный список,а только изменил скопированный список.</target>
        </trans-unit>
        <trans-unit id="3bd849e1d81d4729cb3f7546cfc9844c9422980a" translate="yes" xml:space="preserve">
          <source>As you can see, it only modified the copied list. That means it worked.</source>
          <target state="translated">Как видите,он изменил только скопированный список.Это значит,что он сработал.</target>
        </trans-unit>
        <trans-unit id="7f5db9e07be4014478905b5c75e8654633a0eeb3" translate="yes" xml:space="preserve">
          <source>At the core of any deep copy function is way to make a shallow copy. How? Simple. Any deep copy function only duplicates the containers of immutable objects. When you deepcopy a nested list, you are only duplicating the outer lists, not the mutable objects inside of the lists. You are only duplicating the containers. The same works for classes, too. When you deepcopy a class, you deepcopy all of its mutable attributes. So, how? How come you only have to copy the containers, like lists, dicts, tuples, iters, classes, and class instances?</source>
          <target state="translated">В основе любой функции глубокого копирования лежит способ сделать неглубокую копию.Как? Просто.Любая функция глубокого копирования дублирует только контейнеры непреложных объектов.Когда вы делаете глубокую копию вложенного списка,вы дублируете только внешние списки,а не мутируемые объекты внутри списков.Вы дублируете только контейнеры.То же самое работает и для классов.Когда вы делаете глубокое копирование класса,вы делаете глубокое копирование всех его изменяемых атрибутов.И как же? Почему вам нужно копировать только контейнеры,такие как списки,диктаты,кортежи,итеры,классы и экземпляры классов?</target>
        </trans-unit>
        <trans-unit id="e99ab5abd5933a0d7d0b66c200bfec3d28b8a6b1" translate="yes" xml:space="preserve">
          <source>Both nested lists are pointing different object and they have separate copy of nested list now.</source>
          <target state="translated">Оба вложенных списка указывают на различные объекты,и теперь у них есть отдельная копия вложенного списка.</target>
        </trans-unit>
        <trans-unit id="836b19e7f8037813d193adb0ea22763be677a48c" translate="yes" xml:space="preserve">
          <source>Both outer lists have different IDs, let's try this on the inner nested lists.</source>
          <target state="translated">Оба внешних списка имеют разные ID,давайте попробуем это на внутренних вложенных списках.</target>
        </trans-unit>
        <trans-unit id="f079e1b881840a2f35a6dd6a384ae5baae282f12" translate="yes" xml:space="preserve">
          <source>Both variables are the exact same argument. Are you surprised?</source>
          <target state="translated">Обе переменные являются одним и тем же аргументом.Ты удивлена?</target>
        </trans-unit>
        <trans-unit id="97e297e7f407d34ed9e7296aa23537583633a817" translate="yes" xml:space="preserve">
          <source>Deep copies</source>
          <target state="translated">Глубокие копии</target>
        </trans-unit>
        <trans-unit id="80c240c06fa36efab33567b8dd004136b3a42e84" translate="yes" xml:space="preserve">
          <source>Do you think we're done? No. Let's try to copy our nested list.</source>
          <target state="translated">Думаешь,мы закончили? Нет.Попробуем скопировать наш вложенный список.</target>
        </trans-unit>
        <trans-unit id="579defd972ab926c631e8d21e9eff8c734a498e0" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="translated">Не используйте &lt;code&gt;eval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a27986749695e29a6ff85bbb5c2f396fd63cf1d" translate="yes" xml:space="preserve">
          <source>Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.</source>
          <target state="translated">Каждый элемент списка действует как имя,в том смысле,что каждый элемент привязывается неисключительно к объекту.Мелкая копия создает новый список,элементы которого привязываются к тем же самым объектам,что и раньше.</target>
        </trans-unit>
        <trans-unit id="100e61c040833faea556e102ff4c6f46b647f7ed" translate="yes" xml:space="preserve">
          <source>Edit: New information brought to light</source>
          <target state="translated">Редакция:Выпущена новая информация</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="e959b489a54884803ea418506d068419cb2bc499" translate="yes" xml:space="preserve">
          <source>Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:</source>
          <target state="translated">Феликс уже дал отличный ответ,но я решил сделать сравнение различных методов со скоростью:</target>
        </trans-unit>
        <trans-unit id="dd44e670da0e5e9141f6396dd8d5c9a9a6ec0348" translate="yes" xml:space="preserve">
          <source>Here are the timing results using Python 3.6.8. Keep in mind these times are relative to one another, not absolute.</source>
          <target state="translated">Вот результаты хронометража с использованием Python 3.6.8.Имейте в виду,что эти времена относительны друг к другу,а не абсолютны.</target>
        </trans-unit>
        <trans-unit id="7aa26673265eca05d895ce387611ec36d0b80e52" translate="yes" xml:space="preserve">
          <source>Here in the image list_1 and copy are two variable names but the object is same for both variable which is &lt;code&gt;list&lt;/code&gt;</source>
          <target state="translated">Здесь на изображении list_1 и copy два имени переменных, но объект одинаков для обеих переменных, которые являются &lt;code&gt;list&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9767ca12b4902a277abb578b041a4030915e4f7b" translate="yes" xml:space="preserve">
          <source>Here is the testing code for interested parties (&lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;Template from here&lt;/a&gt;):</source>
          <target state="translated">Вот код тестирования для заинтересованных сторон ( &lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;Шаблон отсюда&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="290e2f376f5eaf8c22b1793823c15aae8fcd1d51" translate="yes" xml:space="preserve">
          <source>How to clone or copy a list</source>
          <target state="translated">Как клонировать или копировать список</target>
        </trans-unit>
        <trans-unit id="25d3f80cbc35ca2648934a22a93b5357eecb73c4" translate="yes" xml:space="preserve">
          <source>However, If my_list contains other containers (for eg. nested lists) you must use deepcopy as others suggested in the answers above from the copy library. For example:</source>
          <target state="translated">Однако,если my_list содержит другие контейнеры (например,вложенные списки),вы должны использовать deepcopy,как и другие,предложенные в ответах выше из библиотеки копирования.Например:</target>
        </trans-unit>
        <trans-unit id="4edc1a0498725bd60f03b13cb73da0476b50e73c" translate="yes" xml:space="preserve">
          <source>I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python2, such as &lt;code&gt;list.copy()&lt;/code&gt; (the Python3 &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;slice equivalent&lt;/a&gt;) and two forms of &lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;list unpacking&lt;/a&gt; (&lt;code&gt;*new_list, = list&lt;/code&gt; and &lt;code&gt;new_list = [*list]&lt;/code&gt;):</source>
          <target state="translated">Я придерживался только мелкого копирования, а также добавил некоторые новые методы, которые не были возможны в Python2, такие как &lt;code&gt;list.copy()&lt;/code&gt; (эквивалент &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;фрагмента&lt;/a&gt; Python3) и две формы &lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;распаковки списка&lt;/a&gt; ( &lt;code&gt;*new_list, = list&lt;/code&gt; и &lt;code&gt;new_list = [*list]&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="013e110db0a05f5dbd20f8b57eade2f83a54868e" translate="yes" xml:space="preserve">
          <source>I wanted to post something a bit different then some of the other answers. Even though this is most likely not the most understandable, or fastest option, it provides a bit of an inside view of how deep copy works, as well as being another alternative option for deep copying. It doesn't really matter if my function has bugs, since the point of this is to show a way to copy objects like the question answers, but also to use this as a point to explain how deepcopy works at its core.</source>
          <target state="translated">Я хотел опубликовать что-то немного другое,чем некоторые другие ответы.Несмотря на то,что это,скорее всего,не самый понятный или самый быстрый вариант,он обеспечивает немного внутреннего представления о том,как работает глубокое копирование,а также является еще одним альтернативным вариантом для глубокого копирования.На самом деле,не имеет значения,есть ли у моей функции ошибки,так как суть в том,чтобы показать способ копирования объектов,таких как ответы на вопросы,а также использовать это как точку зрения для объяснения того,как глубокая копия работает в своей основе.</target>
        </trans-unit>
        <trans-unit id="09c0b5ded50202962dc2368628c1933a8369a2c8" translate="yes" xml:space="preserve">
          <source>I've &lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;been told&lt;/a&gt; that Python 3.3+ &lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt;adds &lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method, which should be as fast as slicing:</source>
          <target state="translated">Мне &lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;сказали,&lt;/a&gt; что Python 3.3+ &lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt;добавляет &lt;code&gt;list.copy()&lt;/code&gt; &lt;/a&gt; , который должен быть таким же быстрым, как и нарезка:</target>
        </trans-unit>
        <trans-unit id="d8a425aac0dd5c097429125cc2f15c4bcc6557bd" translate="yes" xml:space="preserve">
          <source>If the list contains objects and you want to copy them as well, use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Если список содержит объекты, и вы также хотите скопировать их, используйте generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="508aa1ec404f76db49d3513ef7b4d07bcec9be02" translate="yes" xml:space="preserve">
          <source>If you like my detailed answer, I would appreciate if you would upvote it. If you have any doubt about this answer, you can comment it down below.</source>
          <target state="translated">Если вам нравится мой подробный ответ,я был бы признателен,если бы вы проголосовали против.Если у вас есть сомнения по поводу этого ответа,вы можете прокомментировать его ниже.</target>
        </trans-unit>
        <trans-unit id="f608b902f462e04b6d6182623136fb4a743d3d57" translate="yes" xml:space="preserve">
          <source>In 64 bit Python 2.7:</source>
          <target state="translated">В 64-битном Python 2.7:</target>
        </trans-unit>
        <trans-unit id="2212a7dd8b8134dc3343d8ad7cbe5fae3fce8816" translate="yes" xml:space="preserve">
          <source>In Python 2 and 3, you can get a shallow copy with a full slice of the original:</source>
          <target state="translated">На питонах 2 и 3 можно получить неглубокую копию с полным ломтиком оригинала:</target>
        </trans-unit>
        <trans-unit id="4ac599cde0b2c5ab6842e5b2c183be812be9d03e" translate="yes" xml:space="preserve">
          <source>In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:</source>
          <target state="translated">На Python 2 идиоматический способ сделать неглубокую копию списка-полный кусок оригинала:</target>
        </trans-unit>
        <trans-unit id="c1a7abb8ba4c30e338a899c8b6ef3d8068af2771" translate="yes" xml:space="preserve">
          <source>In Python 3, a shallow copy can be made with:</source>
          <target state="translated">На Python 3 можно сделать неглубокую копию:</target>
        </trans-unit>
        <trans-unit id="8fb02af71a6aec0493954b8ede599618597636b0" translate="yes" xml:space="preserve">
          <source>In Python 3, lists get the &lt;code&gt;list.copy&lt;/code&gt; method:</source>
          <target state="translated">В Python 3 списки получают метод &lt;code&gt;list.copy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="80e3fc6970cca93fe92c32b6c4ba9f0ab890dd92" translate="yes" xml:space="preserve">
          <source>In Python 3.5:</source>
          <target state="translated">На Питоне 3.5:</target>
        </trans-unit>
        <trans-unit id="e1e6045a5cef20010f69d146803165ac49a5152d" translate="yes" xml:space="preserve">
          <source>It creates the copy of list but only outer list copy, not the nested list copy, nested list is same for both variable, so if you try to modify the nested list then it will modify the original list too as the nested list object is same for both lists.</source>
          <target state="translated">Он создает копию списка,но только внешнюю копию списка,а не копию вложенного списка,вложенный список одинаков для обеих переменных,так что если вы попытаетесь изменить вложенный список,то он изменит и исходный список,так как объект вложенного списка одинаков для обоих списков.</target>
        </trans-unit>
        <trans-unit id="d34c379d10b758183565c52320bbe1d3d85b2994" translate="yes" xml:space="preserve">
          <source>It outputs:</source>
          <target state="translated">Выходит:</target>
        </trans-unit>
        <trans-unit id="98a7ab1fd383d07403bec0fdbf00b56735e9d4fa" translate="yes" xml:space="preserve">
          <source>It surprises me that this hasn't been mentioned yet, so for the sake of completeness...</source>
          <target state="translated">Меня удивляет,что об этом еще не упоминали,так что ради полноты...</target>
        </trans-unit>
        <trans-unit id="f22686b03873b3c74078fb08c5978fac2477ccf4" translate="yes" xml:space="preserve">
          <source>It uses a new one for lists:</source>
          <target state="translated">Он использует новый для списков:</target>
        </trans-unit>
        <trans-unit id="c598a66587c1a2b513dfdee0f11cfe379df4fc51" translate="yes" xml:space="preserve">
          <source>It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.</source>
          <target state="translated">Казалось бы,единственный реальный вариант-это инициализировать несколько списков и работать над ними самостоятельно.Если у кого-нибудь есть другие предложения по поводу того,как работать с многомерным копированием списков,было бы желательно.</target>
        </trans-unit>
        <trans-unit id="bfec348e3000941e5686d75ef056c9817e63c4f9" translate="yes" xml:space="preserve">
          <source>It's also less performant.</source>
          <target state="translated">А еще он менее производительный.</target>
        </trans-unit>
        <trans-unit id="e5e39dfe9f9b8c35e9d451cae1bbf0f97001f659" translate="yes" xml:space="preserve">
          <source>It's dangerous, particularly if you're evaluating something from a source you don't trust.</source>
          <target state="translated">Это опасно,особенно если ты оцениваешь что-то из источника,которому не доверяешь.</target>
        </trans-unit>
        <trans-unit id="30201c551b5097249c25a2dcab3ffcb946ee7734" translate="yes" xml:space="preserve">
          <source>It's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.</source>
          <target state="translated">Это ненадежно,если подэлемент,который вы копируете,не имеет представления,которое можно было бы оценить,чтобы воспроизвести эквивалентный элемент.</target>
        </trans-unit>
        <trans-unit id="92b01213c7f0b76ca02c2f59a64061096e1ca746" translate="yes" xml:space="preserve">
          <source>It's simple. A mutable object can't really be duplicated. It can never be changed, so it is only a single value. That means you never have to duplicate strings, numbers, bools, or any of those. But how would you duplicate the containers? Simple. You make just initialize a new container with all of the values. Deepcopy relies on recursion. It duplicates all the containers, even ones with containers inside of them, until no containers are left. A container is an immutable object.</source>
          <target state="translated">Все просто.Мутируемый объект на самом деле не может быть дублирован.Он никогда не может быть изменен,так что это только одно значение.Это значит,что вам никогда не придётся дублировать строки,числа,булы или что-то из этого.Но как бы вы дублировали контейнеры? Просто.Вы просто инициализируете новый контейнер всеми значениями.Глубокая копия основана на рекурсии.Она дублирует все контейнеры,даже те,в которых есть контейнеры внутри,пока не останется контейнеров.Контейнер-это неизменный объект.</target>
        </trans-unit>
        <trans-unit id="45fb77de6753c9a311b64100017c382af6c0cc51" translate="yes" xml:space="preserve">
          <source>Let's check this:</source>
          <target state="translated">Давай проверим это:</target>
        </trans-unit>
        <trans-unit id="0c5355b2834dda4cbab54f13603bb0d4f281a582" translate="yes" xml:space="preserve">
          <source>Let's start from the beginning and explore this question.</source>
          <target state="translated">Давайте начнем с начала и исследуем этот вопрос.</target>
        </trans-unit>
        <trans-unit id="4ea13a33e351858421ccf9c6208908351b78f68b" translate="yes" xml:space="preserve">
          <source>Let's understand difference between Solution#1 and Solution #2</source>
          <target state="translated">Давайте поймем разницу между Solution #1 и Solution #2.</target>
        </trans-unit>
        <trans-unit id="6fc2993f803fe2bce5ebd68d1671312a116f8f99" translate="yes" xml:space="preserve">
          <source>List2 isn't storing the actual list, but a reference to list1. So when you do anything to list1, list2 changes as well. use the copy module (not default, download on pip) to make an original copy of the list(&lt;code&gt;copy.copy()&lt;/code&gt; for simple lists, &lt;code&gt;copy.deepcopy()&lt;/code&gt; for nested ones). This makes a copy that doesn't change with the first list.</source>
          <target state="translated">List2 хранит не фактический список, а ссылку на list1. Поэтому, когда вы делаете что-либо для list1, list2 также меняется. используйте модуль копирования (не по умолчанию, скачать на pip), чтобы сделать оригинальную копию списка ( &lt;code&gt;copy.copy()&lt;/code&gt; для простых списков, &lt;code&gt;copy.deepcopy()&lt;/code&gt; для вложенных). Это делает копию, которая не изменяется с первым списком.</target>
        </trans-unit>
        <trans-unit id="cf2a1e2bb3e71888a0f43aeb3ac08c80b8fcc911" translate="yes" xml:space="preserve">
          <source>Making another pointer does &lt;em&gt;not&lt;/em&gt; make a copy</source>
          <target state="translated">Создание другого указателя &lt;em&gt;не&lt;/em&gt; делает копию</target>
        </trans-unit>
        <trans-unit id="6e97c704d7d43e21b1fcfda833b090668ec5e244" translate="yes" xml:space="preserve">
          <source>Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use &lt;code&gt;copy.copy()&lt;/code&gt; or &lt;code&gt;copy.deepcopy()&lt;/code&gt; rather than the alternatives, for example in Python 3:</source>
          <target state="translated">Обратите внимание, что в некоторых случаях, если вы определили свой собственный класс и хотите сохранить атрибуты, вам следует использовать &lt;code&gt;copy.copy()&lt;/code&gt; или &lt;code&gt;copy.deepcopy()&lt;/code&gt; вместо альтернатив, например, в Python 3:</target>
        </trans-unit>
        <trans-unit id="e3932369e81674c80f98992bf457167b246e6424" translate="yes" xml:space="preserve">
          <source>Now if you are thinking copy copied the list_1, then you are wrong. The &lt;code&gt;id&lt;/code&gt; function can show us if two variables can point to the same object. Let's try this:</source>
          <target state="translated">Теперь, если вы думаете, скопировать скопированный список_1, то вы не правы. Функция &lt;code&gt;id&lt;/code&gt; может показать нам, если две переменные могут указывать на один и тот же объект. Давайте попробуем это:</target>
        </trans-unit>
        <trans-unit id="00347d0a4cb14f4559c30793412031205df3863d" translate="yes" xml:space="preserve">
          <source>Now if you assign &lt;code&gt;new_list = my_list[:]&lt;/code&gt; You're simply copying each object of my_list to new_list. This is known as Deep copy.</source>
          <target state="translated">Теперь, если вы назначаете &lt;code&gt;new_list = my_list[:]&lt;/code&gt; вы просто копируете каждый объект my_list в new_list. Это известно как Глубокая копия.</target>
        </trans-unit>
        <trans-unit id="a7d1d79d92c9e349b139fe633f0b6526fad09ce4" translate="yes" xml:space="preserve">
          <source>Now let's move onto a pythonic method for copying lists.</source>
          <target state="translated">Теперь давайте перейдем к питоническому методу копирования списков.</target>
        </trans-unit>
        <trans-unit id="3df54c02f5f581cc533561dc1118e595e1076275" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the list and let's see if we still face the previous problem:</source>
          <target state="translated">Теперь давайте попробуем изменить список и посмотрим,сталкиваемся ли мы все еще с предыдущей проблемой:</target>
        </trans-unit>
        <trans-unit id="aa39e23942a2753c10c8d3f75f878396c89495a5" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the nested list and see if it solved the previous issue or not:</source>
          <target state="translated">Теперь попробуем изменить вложенный список и посмотрим,решил ли он предыдущую проблему или нет:</target>
        </trans-unit>
        <trans-unit id="18d4f8f9dd5560fdbaaa044248879e0f414571a4" translate="yes" xml:space="preserve">
          <source>Now we can assume both lists are pointing different object, so now let's try to modify it and let's see it is giving what we want:</source>
          <target state="translated">Теперь мы можем предположить,что оба списка указывают на разные объекты,так что давайте попробуем изменить его и посмотрим,что он дает то,что мы хотим:</target>
        </trans-unit>
        <trans-unit id="f36cb40ae7ff021457ab561b8f3c65237590561c" translate="yes" xml:space="preserve">
          <source>Now, imagine you have this list: &lt;em&gt;[[1, 2], [3, 4], [5, 6]]&lt;/em&gt;. This time, you want to make a function, which uses recursion to deep copy all layers of the list. Instead of the previous list comprehension:</source>
          <target state="translated">Теперь представьте, что у вас есть этот список: &lt;em&gt;[[1, 2], [3, 4], [5, 6]]&lt;/em&gt; . На этот раз вы хотите создать функцию, которая использует рекурсию для глубокого копирования всех слоев списка. Вместо предыдущего понимания списка:</target>
        </trans-unit>
        <trans-unit id="69f5f45134cb9ec012385bfbf42d5088f5cf8d41" translate="yes" xml:space="preserve">
          <source>Obviously the slowest and most memory-needing method, but sometimes unavoidable.</source>
          <target state="translated">Очевидно,что это самый медленный и требующий памяти метод,но иногда неизбежный.</target>
        </trans-unit>
        <trans-unit id="dbbf697d62aa4fc57077ea24851b4247f69fc822" translate="yes" xml:space="preserve">
          <source>Once you know that, completely duplicating an object without any references is pretty easy. Here's a function for deepcopying basic data-types (wouldn't work for custom classes but you could always add that)</source>
          <target state="translated">Как только вы это знаете,полностью дублировать объект без каких-либо ссылок довольно просто.Вот функция для глубокого копирования базовых типов данных (не подойдет для пользовательских классов,но вы всегда можете это добавить).</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="85428b26db4c1794e05f4269b0c513309de817c9" translate="yes" xml:space="preserve">
          <source>Python 2</source>
          <target state="translated">питон 2</target>
        </trans-unit>
        <trans-unit id="0101a74afd88d622354b05b2b6416e029264bbac" translate="yes" xml:space="preserve">
          <source>Python 3</source>
          <target state="translated">Питон 3</target>
        </trans-unit>
        <trans-unit id="4349126aac22c987d016e24c14dcae82a88269df" translate="yes" xml:space="preserve">
          <source>Python 3.6 Timings</source>
          <target state="translated">Питон 3.6 Таймингс</target>
        </trans-unit>
        <trans-unit id="6ac4e03df57920cae5a01b21d070287f63116c43" translate="yes" xml:space="preserve">
          <source>Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by &lt;code&gt;my_list&lt;/code&gt; and bound it to &lt;code&gt;new_list&lt;/code&gt; as well. No matter which name you use there is still only one list, so changes made when referring to it as &lt;code&gt;my_list&lt;/code&gt; will persist when referring to it as &lt;code&gt;new_list&lt;/code&gt;. Each of the other answers to this question give you different ways of creating a new object to bind to &lt;code&gt;new_list&lt;/code&gt;.</source>
          <target state="translated">Python не хранит значения в переменных; это связывает имена с объектами. Ваше первоначальное назначение взяло объект, на который ссылается &lt;code&gt;my_list&lt;/code&gt; , и связало его с &lt;code&gt;new_list&lt;/code&gt; Независимо от того, какое имя вы используете, по-прежнему существует только один список, поэтому изменения, сделанные при обращении к нему как к &lt;code&gt;my_list&lt;/code&gt; , будут сохраняться при обращении к нему как к &lt;code&gt;new_list&lt;/code&gt; . Каждый из остальных ответов на этот вопрос дает вам различные способы создания нового объекта для привязки к &lt;code&gt;new_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="431a4d86ecae97814d808e75432c4497870cb5a0" translate="yes" xml:space="preserve">
          <source>Python's idiom for doing this is &lt;code&gt;newList = oldList[:]&lt;/code&gt;</source>
          <target state="translated">Идиома Python для этого - &lt;code&gt;newList = oldList[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c6ddaaef7312488cd7088001672817f1f759347" translate="yes" xml:space="preserve">
          <source>Python's own built-in deepcopy is based around that example. The only difference is it supports other types, and also supports user-classes by duplicating the attributes into a new duplicate class, and also blocks infinite-recursion with a reference to an object it's already seen using a memo list or dictionary. And that's really it for making deep copies. At its core, making a deep copy is just making shallow copies. I hope this answer adds something to the question.</source>
          <target state="translated">Собственная встроенная глубокая копия Python основана на этом примере.Единственное отличие состоит в том,что он поддерживает другие типы,а также поддерживает пользовательские классы,дублируя атрибуты в новый дублирующий класс,а также блокирует бесконечную рекурсию со ссылкой на объект,который он уже видел,используя список заметок или словарь.И это действительно для создания глубоких копий.По сути,создание глубокой копии-это просто создание неглубоких копий.Надеюсь,этот ответ что-нибудь добавит к вопросу.</target>
        </trans-unit>
        <trans-unit id="cdb020da6f04f980578edbeea557ee080eae15e7" translate="yes" xml:space="preserve">
          <source>Remember that in Python when you do:</source>
          <target state="translated">Помни об этом в Пайтоне,когда будешь:</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="0c5d365ba03417b1814c4317a93bd505f3d45686" translate="yes" xml:space="preserve">
          <source>Say you have this list: &lt;em&gt;[1, 2, 3]&lt;/em&gt;. The immutable numbers cannot be duplicated, but the other layer can. You can duplicate it using a list comprehension: &lt;em&gt;[x for x in [1, 2, 3]&lt;/em&gt;</source>
          <target state="translated">Скажем, у вас есть этот список: &lt;em&gt;[1, 2, 3]&lt;/em&gt; . Неизменяемые числа не могут быть дублированы, но другой слой может. Вы можете продублировать его, используя понимание списка: &lt;em&gt;[x для x в [1, 2, 3]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a382c1a79a9abea2c3b456d682976a5c9462e5a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;the documentation&lt;/a&gt; for more information about corner cases in copying.</source>
          <target state="translated">См. &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;Документацию&lt;/a&gt; для получения дополнительной информации об угловых случаях при копировании.</target>
        </trans-unit>
        <trans-unit id="6772e3c75e46f3d9be01bc50c86027112d2938bf" translate="yes" xml:space="preserve">
          <source>Shallow list copy</source>
          <target state="translated">Малая копия списка</target>
        </trans-unit>
        <trans-unit id="9a11a8945f8d6b48081dbf5ea5d6e5f5c801b470" translate="yes" xml:space="preserve">
          <source>So as we can see our both list having different id and it means that both variables are pointing to different objects. So what actually going on here is:</source>
          <target state="translated">Так как мы видим,что оба списка имеют разные идентификаторы,это означает,что обе переменные указывают на разные объекты.Так что на самом деле происходит:</target>
        </trans-unit>
        <trans-unit id="3513e3f3b28e2724f6f965025e19894e50855199" translate="yes" xml:space="preserve">
          <source>So as we know python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is a &lt;code&gt;list&lt;/code&gt; but we created two references to that same object by two different variable names. This means that both variables are pointing to the same object, just with different names.</source>
          <target state="translated">Так как мы знаем, что python ничего не хранит в переменной, переменные просто ссылаются на объект, а объект хранит значение. Здесь объект является &lt;code&gt;list&lt;/code&gt; но мы создали две ссылки на один и тот же объект под двумя разными именами переменных. Это означает, что обе переменные указывают на один и тот же объект, только с разными именами.</target>
        </trans-unit>
        <trans-unit id="cd1487edc9546c18ca2fb6958037f7bc45eccdcc" translate="yes" xml:space="preserve">
          <source>So first let's try by setting the variable &lt;code&gt;copy&lt;/code&gt; to our original list, &lt;code&gt;list_1&lt;/code&gt;:</source>
          <target state="translated">Итак, сначала давайте попробуем установить &lt;code&gt;copy&lt;/code&gt; переменной в наш оригинальный список &lt;code&gt;list_1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="35599f5f6a22799b9a1065745b9e8a7525311cbe" translate="yes" xml:space="preserve">
          <source>So if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:</source>
          <target state="translated">Таким образом,если вы попытаетесь изменить скопированный список,то он изменит и исходный список,потому что там только один список,вы будете изменять этот список,независимо от того,что вы делаете из скопированного списка или из исходного списка:</target>
        </trans-unit>
        <trans-unit id="0e6bad77f39dcb244d41a51049f33dcea7721965" translate="yes" xml:space="preserve">
          <source>So it modified the original list :</source>
          <target state="translated">Таким образом,он изменил исходный список :</target>
        </trans-unit>
        <trans-unit id="f008a22270d77fa388373610112fcf2f544b4006" translate="yes" xml:space="preserve">
          <source>So let's suppose you have two lists:</source>
          <target state="translated">Предположим,у тебя два списка:</target>
        </trans-unit>
        <trans-unit id="eda3d79321d8e8a6c5f43e602583a85978e82115" translate="yes" xml:space="preserve">
          <source>So the fastest is list slicing. But be aware that &lt;code&gt;copy.copy()&lt;/code&gt;, &lt;code&gt;list[:]&lt;/code&gt; and &lt;code&gt;list(list)&lt;/code&gt;, unlike &lt;code&gt;copy.deepcopy()&lt;/code&gt; and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.</source>
          <target state="translated">Так что самым быстрым является нарезка списка. Но имейте в &lt;code&gt;copy.copy()&lt;/code&gt; что copy.copy () , &lt;code&gt;list[:]&lt;/code&gt; и &lt;code&gt;list(list)&lt;/code&gt; , в отличие от &lt;code&gt;copy.deepcopy()&lt;/code&gt; и версии python, не копируют никакие списки, словари и экземпляры классов в списке, поэтому, если оригиналы меняются , они также изменятся в скопированном списке и наоборот.</target>
        </trans-unit>
        <trans-unit id="8bbc00ebc1fe27804a2faefef2b2a7c8e80ddd52" translate="yes" xml:space="preserve">
          <source>The Other way you can do this are :</source>
          <target state="translated">Другой способ-это :</target>
        </trans-unit>
        <trans-unit id="a51bd5a9f88582672dcba66c5148c7d26e24a8aa" translate="yes" xml:space="preserve">
          <source>The dark horse is the unpacking and repacking method (&lt;code&gt;b = [*a]&lt;/code&gt;), which is ~25% faster than raw slicing, and more than twice as fast as the other unpacking method (&lt;code&gt;*b, = a&lt;/code&gt;).</source>
          <target state="translated">Темная лошадка - это метод распаковки и повторной упаковки ( &lt;code&gt;b = [*a]&lt;/code&gt; ), который на ~ 25% быстрее, чем нарезка в сыром виде, и более чем в два раза быстрее, чем другой метод распаковки ( &lt;code&gt;*b, = a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="efdb3e2274e3293e0058ed73476dabfc0b9f7297" translate="yes" xml:space="preserve">
          <source>The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.</source>
          <target state="translated">Список-это просто массив указателей на содержимое,поэтому неглубокая копия просто копирует указатели,и поэтому у вас есть два разных списка,но они имеют одно и то же содержимое.Чтобы сделать копии содержимого,вам понадобится глубокая копия.</target>
        </trans-unit>
        <trans-unit id="afa75f9e3be68e27350aefb47205502bf0a9e6e5" translate="yes" xml:space="preserve">
          <source>The obvious downside to this method is that it is only available in Python 3.5+.</source>
          <target state="translated">Очевидным недостатком этого метода является то,что он доступен только на Python 3.5+.</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">Выход:</target>
        </trans-unit>
        <trans-unit id="90fa1fae686fa6b34b07514c61aa94123be63447" translate="yes" xml:space="preserve">
          <source>Then now you have a function which can deepcopy any list of &lt;strong&gt;strs, bools, floast, ints&lt;/strong&gt; and even &lt;strong&gt;lists&lt;/strong&gt; to infinitely many layers using recursion. And there you have it, deepcopying.</source>
          <target state="translated">Теперь у вас есть функция, которая может копировать любой список &lt;strong&gt;strs, bools, floast, ints&lt;/strong&gt; и даже &lt;strong&gt;списки&lt;/strong&gt; в бесконечное число слоев, используя рекурсию. И вот, у вас это есть, глубокий копирование.</target>
        </trans-unit>
        <trans-unit id="220890ce8fb4c2412811019ffb2db9f207227214" translate="yes" xml:space="preserve">
          <source>There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.</source>
          <target state="translated">Есть разные способы сделать это на питоне 2 и 3.Способы на Python 2 также будут работать на Python 3.</target>
        </trans-unit>
        <trans-unit id="b6d1fa502414f389e3c4893a7f6454394e1dd9d1" translate="yes" xml:space="preserve">
          <source>There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed.</source>
          <target state="translated">Уже есть много ответов,которые говорят вам,как сделать правильную копию,но ни в одном из них не сказано,почему ваша оригинальная &quot;копия&quot; не удалась.</target>
        </trans-unit>
        <trans-unit id="66abe6803af6fc0a90902cfc1672796b3aae06b4" translate="yes" xml:space="preserve">
          <source>There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.</source>
          <target state="translated">Есть два семантических способа скопировать список.Мелкая копия создает новый список тех же самых объектов,глубокая копия-новый список,содержащий новые эквивалентные объекты.</target>
        </trans-unit>
        <trans-unit id="bc4ca653a23068dcf7ae97de3b9e4f63df0f559e" translate="yes" xml:space="preserve">
          <source>This gives us the output:</source>
          <target state="translated">Это дает нам выход:</target>
        </trans-unit>
        <trans-unit id="557c91f0d91bf8aa2deea01cceab9c91400d0ec2" translate="yes" xml:space="preserve">
          <source>This is a little slower than &lt;code&gt;list()&lt;/code&gt; because it has to find out the datatype of &lt;code&gt;old_list&lt;/code&gt; first.</source>
          <target state="translated">Это немного медленнее, чем &lt;code&gt;list()&lt;/code&gt; потому что сначала нужно выяснить тип данных &lt;code&gt;old_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49bb04f0f459e1ca1287d6676b347a76839b4290" translate="yes" xml:space="preserve">
          <source>This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy.</source>
          <target state="translated">Это еще не глубокая копия,потому что каждый элемент списка может ссылаться на другие объекты,точно так же,как список привязан к своим элементам.Чтобы рекурсивно скопировать каждый элемент списка,а затем и каждый другой объект,на который ссылается каждый элемент,и т.д.:выполните глубокое копирование.</target>
        </trans-unit>
        <trans-unit id="3c04fe0cc698e2ba7a6efcd47118a60302f9c23f" translate="yes" xml:space="preserve">
          <source>This may seem a little bit confusing, because the same method we previously used worked. Let's try to understand this.</source>
          <target state="translated">Это может показаться немного запутанным,потому что тот же самый метод,который мы использовали ранее,работал.Давайте попробуем понять это.</target>
        </trans-unit>
        <trans-unit id="00f93f5227a8e28c60a94b27101682842e37414b" translate="yes" xml:space="preserve">
          <source>This means that for multidimensional lists, the only option is &lt;code&gt;copy.deepcopy()&lt;/code&gt;. With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to &lt;code&gt;timeit&lt;/code&gt; using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.</source>
          <target state="translated">Это означает, что для многомерных списков единственным вариантом является &lt;code&gt;copy.deepcopy()&lt;/code&gt; . С учетом вышесказанного, это действительно не вариант, поскольку производительность снижается, когда вы пытаетесь использовать ее в многомерном массиве умеренного размера. Я попытался &lt;code&gt;timeit&lt;/code&gt; использования массива 42x42, что было неслыханно или даже слишком много для приложений биоинформатики, и я разочаровался в ожидании ответа и просто начал печатать мое редактирование в этом посте.</target>
        </trans-unit>
        <trans-unit id="0a9d3f3184e470a21dfb005cbe5d56f43c9b998b" translate="yes" xml:space="preserve">
          <source>This means when you do &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; what actually happens:</source>
          <target state="translated">Это означает, что когда вы делаете &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; что на самом деле происходит:</target>
        </trans-unit>
        <trans-unit id="04a5a8b7256438d8150475968ea5b994c8232285" translate="yes" xml:space="preserve">
          <source>This method fixes the first issue we had:</source>
          <target state="translated">Этот метод исправляет первую проблему,которая у нас была:</target>
        </trans-unit>
        <trans-unit id="e7902de440301cd9e6f660692a60815b9d105656" translate="yes" xml:space="preserve">
          <source>Timing wise though, this appears to perform better than other common methods.</source>
          <target state="translated">Однако,с точки зрения времени,это,кажется,работает лучше,чем другие распространенные методы.</target>
        </trans-unit>
        <trans-unit id="6b58f0a40765b5b08203954d86f7c9ff6bee49da" translate="yes" xml:space="preserve">
          <source>To actually copy the list, you have various possibilities:</source>
          <target state="translated">Чтобы действительно скопировать список,у вас есть различные возможности:</target>
        </trans-unit>
        <trans-unit id="946633aa3cdcc201da0bfd3b79549497b06ce48f" translate="yes" xml:space="preserve">
          <source>To demonstrate how this allows us to make new sub-lists:</source>
          <target state="translated">Чтобы продемонстрировать,как это позволяет нам создавать новые под-листы:</target>
        </trans-unit>
        <trans-unit id="18c166dc2118c18ca2195aded821b172eef596bd" translate="yes" xml:space="preserve">
          <source>To make a &lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;deep copy of a list, in Python 2 or 3, use &lt;code&gt;deepcopy&lt;/code&gt; in the &lt;code&gt;copy&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">Чтобы сделать &lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;глубокую копию списка, в Python 2 или 3 используйте &lt;code&gt;deepcopy&lt;/code&gt; в модуле &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="77a0cef14012e7b83ed88a073f164fddcf757041" translate="yes" xml:space="preserve">
          <source>To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list.</source>
          <target state="translated">Чтобы сделать копию списка на один шаг дальше,скопируйте каждый объект,на который ссылается ваш список,и привяжите эти копии элементов к новому списку.</target>
        </trans-unit>
        <trans-unit id="94a001d83f43e327f9bf5308ade41bb93e8b8b9b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;thing[:]&lt;/code&gt;</source>
          <target state="translated">Используйте &lt;code&gt;thing[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="704ff25c262b4989c3e885b9c631ea5f00ee2274" translate="yes" xml:space="preserve">
          <source>We can see the Python2 winner still does well, but doesn't edge out Python3 &lt;code&gt;list.copy()&lt;/code&gt; by much, especially considering the superior readability of the latter.</source>
          <target state="translated">Мы можем видеть, что победитель Python2 по-прежнему преуспевает, но не сильно &lt;code&gt;list.copy()&lt;/code&gt; Python3 list.copy () , особенно учитывая его превосходную читаемость.</target>
        </trans-unit>
        <trans-unit id="88fa58a7d8228094b91bae093cb54c6c760187cc" translate="yes" xml:space="preserve">
          <source>We get the output:</source>
          <target state="translated">Мы получаем выход:</target>
        </trans-unit>
        <trans-unit id="20b49cce5a91432e085e1764e90ac0273068bbc7" translate="yes" xml:space="preserve">
          <source>What are the options to clone or copy a list in Python?</source>
          <target state="translated">Какие есть варианты клонирования или копирования списка на Python?</target>
        </trans-unit>
        <trans-unit id="365d64ca08030dc6b88428870f53a2fcdac7e978" translate="yes" xml:space="preserve">
          <source>What is the solution? The solution is the &lt;code&gt;deepcopy&lt;/code&gt; function.</source>
          <target state="translated">Каково решение? Решением является функция &lt;code&gt;deepcopy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8115e5fa0f64b2d78e179223b2acf529f438cd" translate="yes" xml:space="preserve">
          <source>When we do &lt;code&gt;copy_2=list_2[:]&lt;/code&gt;, this happens:</source>
          <target state="translated">Когда мы делаем &lt;code&gt;copy_2=list_2[:]&lt;/code&gt; , это происходит:</target>
        </trans-unit>
        <trans-unit id="7d92247dca50cce0446da6df8b14549d6a725f7b" translate="yes" xml:space="preserve">
          <source>When you do &lt;code&gt;copy=list_1&lt;/code&gt;, it is actually doing:</source>
          <target state="translated">Когда вы делаете &lt;code&gt;copy=list_1&lt;/code&gt; , он на самом деле делает:</target>
        </trans-unit>
        <trans-unit id="2e8ee345e21d7df889e916663fa72306a26db891" translate="yes" xml:space="preserve">
          <source>When you do:</source>
          <target state="translated">Когда ты это сделаешь:</target>
        </trans-unit>
        <trans-unit id="25aeb6ff8ce6046a534c673463f7363bfa51d100" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;new_list = old_list[:]&lt;/code&gt;, &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; and for Py3k &lt;code&gt;old_list.copy()&lt;/code&gt; work for single-leveled lists, they revert to pointing at the &lt;code&gt;list&lt;/code&gt; objects nested within the &lt;code&gt;old_list&lt;/code&gt; and the &lt;code&gt;new_list&lt;/code&gt;, and changes to one of the &lt;code&gt;list&lt;/code&gt; objects are perpetuated in the other.</source>
          <target state="translated">Хотя &lt;code&gt;new_list = old_list[:]&lt;/code&gt; , &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; и для Py3k &lt;code&gt;old_list.copy()&lt;/code&gt; работают для одноуровневых списков, они возвращаются к указанию на объекты &lt;code&gt;list&lt;/code&gt; вложенные в &lt;code&gt;old_list&lt;/code&gt; и &lt;code&gt;new_list&lt;/code&gt; , и изменяются на один из &lt;code&gt;list&lt;/code&gt; объектов увековечены в другом.</target>
        </trans-unit>
        <trans-unit id="46a5e0acd81721a83e102ba1cc3b2c2c40347a6d" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;new_list = my_list&lt;/code&gt;, any modifications to &lt;code&gt;new_list&lt;/code&gt; changes &lt;code&gt;my_list&lt;/code&gt; everytime.
Why is this?</source>
          <target state="translated">При использовании &lt;code&gt;new_list = my_list&lt;/code&gt; любые изменения в &lt;code&gt;new_list&lt;/code&gt; изменяют &lt;code&gt;my_list&lt;/code&gt; каждый раз. Почему это?</target>
        </trans-unit>
        <trans-unit id="4ccc750900a14314384b3bf271f406314a22ce63" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;new_list = my_list&lt;/code&gt;, you don't actually have two lists. The assignment just copies the reference to the list, not the actual list, so both &lt;code&gt;new_list&lt;/code&gt; and &lt;code&gt;my_list&lt;/code&gt; refer to the same list after the assignment.</source>
          <target state="translated">С &lt;code&gt;new_list = my_list&lt;/code&gt; вас фактически нет двух списков. Назначение просто копирует ссылку на список, а не фактический список, поэтому и &lt;code&gt;new_list&lt;/code&gt; , и &lt;code&gt;my_list&lt;/code&gt; ссылаются на один и тот же список после назначения.</target>
        </trans-unit>
        <trans-unit id="225441c8d6bd2a8e2654bc1fd302a0897594025a" translate="yes" xml:space="preserve">
          <source>You can also accomplish the same thing by passing the list through the list constructor,</source>
          <target state="translated">То же самое можно сделать,пропустив список через конструктор списка,</target>
        </trans-unit>
        <trans-unit id="a9e1c8ff6e281ab525b473cb57dfc86a34e5f554" translate="yes" xml:space="preserve">
          <source>You can perform list unpacking with the &quot;splat operator&quot;: &lt;code&gt;*&lt;/code&gt;, which will also copy elements of your list.</source>
          <target state="translated">Вы можете выполнить распаковку списка с помощью оператора &amp;laquo;splat&amp;raquo;: &lt;code&gt;*&lt;/code&gt; , который также скопирует элементы вашего списка.</target>
        </trans-unit>
        <trans-unit id="204a07b1b7642695ed4e50226442ee5bd889a56d" translate="yes" xml:space="preserve">
          <source>You can slice it:</source>
          <target state="translated">Ты можешь порезать его:</target>
        </trans-unit>
        <trans-unit id="8b60affbd66d1ab22f4db2b35f4476c0bc727885" translate="yes" xml:space="preserve">
          <source>You can use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вы можете использовать универсальный &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f7c4e65f4ef8f5a93e4955911a9d09385dd4e0e2" translate="yes" xml:space="preserve">
          <source>You can use the built in &lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt;&lt;code&gt;list()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Вы можете использовать встроенную функцию &lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt; &lt;code&gt;list()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="74e2cb68ed9fb5f2c5405875004d794d14a5f066" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt;&lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method (available since Python 3.3):</source>
          <target state="translated">Вы можете использовать встроенный &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt; &lt;code&gt;list.copy()&lt;/code&gt; &lt;/a&gt; (доступен начиная с Python 3.3):</target>
        </trans-unit>
        <trans-unit id="897a434f7844b828ae3989a342e35cc3c21bf0d6" translate="yes" xml:space="preserve">
          <source>You may see this used as a way to deepcopy, but don't do it:</source>
          <target state="translated">Ты можешь видеть,что это используется как способ сделать глубокую копию,но не делай этого:</target>
        </trans-unit>
        <trans-unit id="76244e96c4d1fb0eec733ac274efa594300304e7" translate="yes" xml:space="preserve">
          <source>You're only copying the outer list, not the inside list. We can use the &lt;code&gt;id&lt;/code&gt; function once again to check this.</source>
          <target state="translated">Вы копируете только внешний список, а не внутренний. Мы можем использовать функцию &lt;code&gt;id&lt;/code&gt; еще раз, чтобы проверить это.</target>
        </trans-unit>
        <trans-unit id="9356e95d4f6f104855f95803d19cc415fcbbdf4f" translate="yes" xml:space="preserve">
          <source>but using the constructor is less efficient:</source>
          <target state="translated">но использование конструктора менее эффективно:</target>
        </trans-unit>
        <trans-unit id="6bac1115690000182dc538b79519b1c469db850e" translate="yes" xml:space="preserve">
          <source>on 64 bit Python 3.5:</source>
          <target state="translated">на 64-битном Пайтоне 3.5:</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
