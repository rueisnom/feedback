<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2612802">
    <body>
      <group id="2612802">
        <trans-unit id="6cb2908973d6e330ac0831d07b21e8772ada79a7" translate="yes" xml:space="preserve">
          <source>(Here's the script if anyone's interested or wants to raise any issues:)</source>
          <target state="translated">(Aquí está el guión si alguien está interesado o quiere plantear algún tema:)</target>
        </trans-unit>
        <trans-unit id="ebb3c26aa2a50c6bcf9364047f9a610d479174c0" translate="yes" xml:space="preserve">
          <source>.&lt;strong&gt;Bonus&lt;/strong&gt;: If you don't want to copy elements use (aka shallow copy):</source>
          <target state="translated">. &lt;strong&gt;Bonificaci&amp;oacute;n&lt;/strong&gt; : si no desea copiar elementos, use (tambi&amp;eacute;n conocido como copia superficial):</target>
        </trans-unit>
        <trans-unit id="831f577c0630013fd2dd428aa6f69fbb8227958b" translate="yes" xml:space="preserve">
          <source>0.039 sec (0.39us/itn) - &lt;code&gt;old_list[:]&lt;/code&gt; (&lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;list slicing&lt;/a&gt;)</source>
          <target state="translated">0.039 sec (0.39us / itn) - &lt;code&gt;old_list[:]&lt;/code&gt; ( &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#lists&quot;&gt;corte de lista&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6576742e9a532381a3048dc91ed10879c2220a99" translate="yes" xml:space="preserve">
          <source>0.053 sec (0.53us/itn) - &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt;</source>
          <target state="translated">0.053 segundos (0.53us / itn) - &lt;code&gt;new_list = []; new_list.extend(old_list)&lt;/code&gt; new_list.extend (old_list)</target>
        </trans-unit>
        <trans-unit id="589e176d08ceaa47627386f4c2ee43ef0e412c6f" translate="yes" xml:space="preserve">
          <source>0.075 sec (0.75us/itn) - &lt;code&gt;list(old_list)&lt;/code&gt;</source>
          <target state="translated">0.075 sec (0.75us / itn) - &lt;code&gt;list(old_list)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbf31d4e561cfc6f0a7055b18ae7bb85966be0c" translate="yes" xml:space="preserve">
          <source>0.186 sec (1.86us/itn) - &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">0.186 sec (1.86us / itn) - &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9741537872f078018c930db04bb6b7a099568129" translate="yes" xml:space="preserve">
          <source>0.217 sec (2.17us/itn) - &lt;code&gt;[i for i in old_list]&lt;/code&gt; (a &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;list comprehension&lt;/a&gt;)</source>
          <target state="translated">0.217 sec (2.17us / itn) - &lt;code&gt;[i for i in old_list]&lt;/code&gt; (una &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;comprensi&amp;oacute;n de la lista&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="fcb2fce8f80e6e96b412e3deb49a4a01eef9d95c" translate="yes" xml:space="preserve">
          <source>0.325 sec (3.25us/itn) - &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</source>
          <target state="translated">0.325 sec (3.25us / itn) - &lt;code&gt;for item in old_list: new_list.append(item)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a196696ac9e805fcf92036506af3ef7d8ab819d" translate="yes" xml:space="preserve">
          <source>1.488 sec (14.88us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method not copying classes (only dicts/lists/tuples)</source>
          <target state="translated">1.488 sec (14.88us / itn) - el m&amp;eacute;todo puro Python &lt;code&gt;Copy()&lt;/code&gt; no copia clases (solo dicts / lists / tuples)</target>
        </trans-unit>
        <trans-unit id="c36d3f84b0185c78311f648cfb81e4cacde6b9c9" translate="yes" xml:space="preserve">
          <source>10.16 sec (101.6us/itn) - pure python &lt;code&gt;Copy()&lt;/code&gt; method copying classes with deepcopy</source>
          <target state="translated">10.16 sec (101.6us / itn) - m&amp;eacute;todo puro de Python &lt;code&gt;Copy()&lt;/code&gt; copiando clases con deepcopy</target>
        </trans-unit>
        <trans-unit id="892f509cfed7a878055c5d6330a5e7a7032f54b5" translate="yes" xml:space="preserve">
          <source>10.59 sec (105.9us/itn) -  &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">10.59 sec (105.9us / itn) - &lt;a href=&quot;http://docs.python.org/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy(old_list)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24d242d81528698f099460d3c52d07280215058e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;Alex Martelli's&lt;/a&gt; opinion (at least &lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;back in 2007&lt;/a&gt;) about this is, that &lt;em&gt;it is a weird syntax and it does not make sense to use it ever&lt;/em&gt;. ;) (In his opinion, the next one is more readable).</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Alex_Martelli&quot;&gt;La&lt;/a&gt; opini&amp;oacute;n de Alex Martelli (al menos &lt;a href=&quot;https://www.youtube.com/watch?v=g7V89K8QfgQ&quot;&gt;en 2007&lt;/a&gt; ) sobre esto es que &lt;em&gt;es una sintaxis extra&amp;ntilde;a y que no tiene sentido usarla nunca&lt;/em&gt; . ;) (En su opini&amp;oacute;n, el siguiente es m&amp;aacute;s legible).</target>
        </trans-unit>
        <trans-unit id="cb21dd5df394bc7fae7c132b18417ae29a3bc579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b = a * 1&lt;/code&gt; also does surprisingly well.</source>
          <target state="translated">&lt;code&gt;b = a * 1&lt;/code&gt; tambi&amp;eacute;n lo hace sorprendentemente bien.</target>
        </trans-unit>
        <trans-unit id="d9ef3187620786222a615d86bcc314673d3289f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list_2&lt;/code&gt; should reference to another object which is copy of &lt;code&gt;list_2&lt;/code&gt;. Let's check:</source>
          <target state="translated">&lt;code&gt;list_2&lt;/code&gt; debe hacer referencia a otro objeto que es una copia de &lt;code&gt;list_2&lt;/code&gt; . Vamos a revisar:</target>
        </trans-unit>
        <trans-unit id="4f36085cfc8ae8adb7dd3849ea72baa17b0c317a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_list&lt;/code&gt; is just a name that points to the actual list in memory. When you say &lt;code&gt;new_list = my_list&lt;/code&gt; you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists.</source>
          <target state="translated">&lt;code&gt;my_list&lt;/code&gt; es solo un nombre que apunta a la lista real en la memoria. Cuando dices &lt;code&gt;new_list = my_list&lt;/code&gt; no est&amp;aacute;s haciendo una copia, solo est&amp;aacute;s agregando otro nombre que apunta a esa lista original en la memoria. Podemos tener problemas similares cuando hacemos copias de las listas.</target>
        </trans-unit>
        <trans-unit id="2041e8c18dbff0914a06b5e2a1252d4733642d53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_list = my_list&lt;/code&gt;
Try to understand this. Let's say that my_list is in the heap memory at location X i.e. my_list is pointing to the X. Now by assigning &lt;code&gt;new_list = my_list&lt;/code&gt; you're Letting new_list pointing to the X. This is known as shallow Copy.</source>
          <target state="translated">&lt;code&gt;new_list = my_list&lt;/code&gt; Intenta entender esto. Digamos que my_list est&amp;aacute; en la memoria de almacenamiento din&amp;aacute;mico en la ubicaci&amp;oacute;n X, es decir, my_list apunta a la X. Ahora, al asignar &lt;code&gt;new_list = my_list&lt;/code&gt; est&amp;aacute;s dejando que new_list apunte a la X. Esto se conoce como copia superficial.</target>
        </trans-unit>
        <trans-unit id="8ef17a4719ab0f78b42c3681f36203e226fb86dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EXAMPLES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EXAMPLES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fd15ef13529e8eb7aac1e4fb2625df3343dbcd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that these methods do &lt;em&gt;not&lt;/em&gt; output equivalent results for any input other than lists.&lt;/strong&gt; They all work for sliceable objects, a few work for any iterable, but only &lt;code&gt;copy.copy()&lt;/code&gt; works for more general Python objects.</source>
          <target state="translated">&lt;strong&gt;Tenga en cuenta que estos m&amp;eacute;todos &lt;em&gt;no&lt;/em&gt; generan resultados equivalentes para ninguna entrada que no sean listas.&lt;/strong&gt; Todos funcionan para objetos divisibles, algunos funcionan para cualquier iterable, pero solo &lt;code&gt;copy.copy()&lt;/code&gt; funciona para objetos Python m&amp;aacute;s generales.</target>
        </trans-unit>
        <trans-unit id="6044cdaafb431c7ebd900f17cd900457b458ca20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;: Deepcopy uses recursion to duplicate objects, and merely returns the same immutable objects as before, as immutable objects cannot be duplicated. However, it deepcopies the most inner layers of mutable objects until it reaches the outermost mutable layer of an object.</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt; : Deepcopy utiliza la recursividad para duplicar objetos, y simplemente devuelve los mismos objetos inmutables que antes, ya que los objetos inmutables no pueden duplicarse. Sin embargo, copia en profundidad las capas m&amp;aacute;s internas de objetos mutables hasta que alcanza la capa mutable m&amp;aacute;s externa de un objeto.</target>
        </trans-unit>
        <trans-unit id="0669e0817e0ab8178fe6bdeadc9d599cc4692d12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using new_list = my_list then modifies new_list every time my_list changes. Why is this?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usando new_list = my_list luego modifica new_list cada vez que my_list cambia.&lt;/strong&gt; &lt;strong&gt;&amp;iquest;Por qu&amp;eacute; es esto?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d45c9a0fde240fd63fbe4e27fddcf428b240c39" translate="yes" xml:space="preserve">
          <source>A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists.</source>
          <target state="translated">Una copia superficial sólo copia la propia lista,que es un contenedor de referencias a los objetos de la lista.Si los objetos contenidos en sí mismos son mutables y se cambia uno,el cambio se reflejará en ambas listas.</target>
        </trans-unit>
        <trans-unit id="005c37f0237b5cb139854b9e4687176ca563565b" translate="yes" xml:space="preserve">
          <source>A slight practical perspective to look into memory through id and gc.</source>
          <target state="translated">Una ligera perspectiva práctica para mirar en la memoria a través de id y gc.</target>
        </trans-unit>
        <trans-unit id="8261b218a41d10fe8c0dcd15e9088d1cb42e6891" translate="yes" xml:space="preserve">
          <source>A very simple approach independent of python version was missing in already given answers which you can use most of the time (at least I do):</source>
          <target state="translated">Un enfoque muy simple e independiente de la versión en pitón faltaba en las respuestas ya dadas,que se pueden usar la mayoría de las veces (al menos yo lo hago):</target>
        </trans-unit>
        <trans-unit id="3498a4737c6e7fe24088dc089c3bcc79dda6d821" translate="yes" xml:space="preserve">
          <source>All of the other contributors gave &lt;strong&gt;great&lt;/strong&gt; answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only &lt;code&gt;copy.deepcopy()&lt;/code&gt; works to clone/copy a list and not have it point to the nested &lt;code&gt;list&lt;/code&gt; objects when you are working with multidimensional, nested lists (list of lists). While &lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;Felix Kling&lt;/a&gt; refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to &lt;code&gt;deepcopy&lt;/code&gt;.</source>
          <target state="translated">Todos los dem&amp;aacute;s contribuyentes dieron &lt;strong&gt;excelentes&lt;/strong&gt; respuestas, que funcionan cuando tiene una lista de una sola dimensi&amp;oacute;n (nivelada), sin embargo, de los m&amp;eacute;todos mencionados hasta ahora, solo &lt;code&gt;copy.deepcopy()&lt;/code&gt; funciona para clonar / copiar una lista y no hacer que apunte al objetos de &lt;code&gt;list&lt;/code&gt; a anidada cuando trabaja con listas anidadas multidimensionales (lista de listas). Si bien &lt;a href=&quot;https://stackoverflow.com/users/218196/felix-kling&quot;&gt;Felix Kling se&lt;/a&gt; refiere a eso en su respuesta, hay un poco m&amp;aacute;s sobre el problema y posiblemente una soluci&amp;oacute;n alternativa con el uso de elementos integrados que podr&amp;iacute;an ser una alternativa m&amp;aacute;s r&amp;aacute;pida a la &lt;code&gt;deepcopy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a258d25732edb4a8dc4c53104d80ea8e8ba4b1f" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;deepcopy_list&lt;/strong&gt; looks like this:</source>
          <target state="translated">Y &lt;strong&gt;deepcopy_list&lt;/strong&gt; tiene este aspecto:</target>
        </trans-unit>
        <trans-unit id="99c81ac1dec28ab432158972b11dcd87811305fd" translate="yes" xml:space="preserve">
          <source>And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.</source>
          <target state="translated">Y así vemos que la lista de copias profundas es una lista completamente diferente de la original.Podrías hacer tu propia función,pero no lo hagas.Es probable que crees errores que de otra manera no tendrías usando la función de copia profunda de la biblioteca estándar.</target>
        </trans-unit>
        <trans-unit id="baf0b49d9e610c1e0b9aaf4f81c197fe9b3f4561" translate="yes" xml:space="preserve">
          <source>And we have to copy both lists, now starting from the first list:</source>
          <target state="translated">Y tenemos que copiar ambas listas,ahora empezando por la primera lista:</target>
        </trans-unit>
        <trans-unit id="9d4cea5d2aa1cef4716a69ab86f2a6adcf09e2c9" translate="yes" xml:space="preserve">
          <source>As others have stated, there  &lt;strong&gt;&lt;em&gt;are significant&lt;/em&gt;&lt;/strong&gt; performance issues using the &lt;code&gt;copy&lt;/code&gt; module and &lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;strong&gt;&lt;em&gt;for multidimensional lists&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">Como han dicho otros, existen problemas de rendimiento importantes al usar el m&amp;oacute;dulo de &lt;code&gt;copy&lt;/code&gt; y &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;strong&gt;&lt;em&gt;para listas multidimensionales&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c03a694d0b4332e4b08b86ede988da2173792481" translate="yes" xml:space="preserve">
          <source>As was pointed out by both &lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;Aaron Hall&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ring&lt;/a&gt;&lt;strong&gt;using &lt;code&gt;eval()&lt;/code&gt; is not only a bad idea, it is also much slower than &lt;code&gt;copy.deepcopy()&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">Como se&amp;ntilde;alaron &lt;a href=&quot;https://stackoverflow.com/users/541136/aaron-hall&quot;&gt;Aaron Hall&lt;/a&gt; y &lt;a href=&quot;https://stackoverflow.com/users/4014959/pm-2ring&quot;&gt;PM 2Ring&lt;/a&gt; &lt;strong&gt;usando &lt;code&gt;eval()&lt;/code&gt; no solo es una mala idea, tambi&amp;eacute;n es mucho m&amp;aacute;s lenta que &lt;code&gt;copy.deepcopy()&lt;/code&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0bae3de46c365ceae27557d207d519a16f03d1f" translate="yes" xml:space="preserve">
          <source>As you can see Solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.</source>
          <target state="translated">Como pueden ver,la Solución #1 funcionaba perfectamente cuando no usábamos las listas anidadas.Comprobemos lo que sucederá cuando apliquemos la solución #1 a las listas anidadas.</target>
        </trans-unit>
        <trans-unit id="1fa9f6c88dde54a4948d45a55a86287ba1ddfa53" translate="yes" xml:space="preserve">
          <source>As you can see both IDs are different, meaning we can assume that both nested lists are pointing different object now.</source>
          <target state="translated">Como pueden ver,ambas identificaciones son diferentes,lo que significa que podemos asumir que ambas listas anidadas están apuntando a un objeto diferente ahora.</target>
        </trans-unit>
        <trans-unit id="76931cafef2a867dc6f7e1459fcb607ba73ac1cc" translate="yes" xml:space="preserve">
          <source>As you can see, it didn't modify the original nested list, it only modified the copied list.</source>
          <target state="translated">Como pueden ver,no modificó la lista anidada original,sólo modificó la lista copiada.</target>
        </trans-unit>
        <trans-unit id="3bd849e1d81d4729cb3f7546cfc9844c9422980a" translate="yes" xml:space="preserve">
          <source>As you can see, it only modified the copied list. That means it worked.</source>
          <target state="translated">Como pueden ver,sólo modificó la lista copiada.Eso significa que funcionó.</target>
        </trans-unit>
        <trans-unit id="7f5db9e07be4014478905b5c75e8654633a0eeb3" translate="yes" xml:space="preserve">
          <source>At the core of any deep copy function is way to make a shallow copy. How? Simple. Any deep copy function only duplicates the containers of immutable objects. When you deepcopy a nested list, you are only duplicating the outer lists, not the mutable objects inside of the lists. You are only duplicating the containers. The same works for classes, too. When you deepcopy a class, you deepcopy all of its mutable attributes. So, how? How come you only have to copy the containers, like lists, dicts, tuples, iters, classes, and class instances?</source>
          <target state="translated">En el centro de cualquier función de copia profunda está la manera de hacer una copia superficial.¿Cómo? Simple.Cualquier función de copia profunda sólo duplica los contenedores de objetos inmutables.Cuando se copia en profundidad una lista anidada,sólo se duplican las listas exteriores,no los objetos mutables dentro de las listas.Sólo estás duplicando los contenedores.Lo mismo funciona para las clases,también.Cuando profundizas en una clase,profundizas en todos sus atributos mutables.Entonces,¿cómo? ¿Cómo es que sólo tienes que copiar los contenedores,como listas,dictados,tuplas,iters,clases e instancias de clase?</target>
        </trans-unit>
        <trans-unit id="e99ab5abd5933a0d7d0b66c200bfec3d28b8a6b1" translate="yes" xml:space="preserve">
          <source>Both nested lists are pointing different object and they have separate copy of nested list now.</source>
          <target state="translated">Ambas listas anidadas apuntan a objetos diferentes y ahora tienen una copia separada de la lista anidada.</target>
        </trans-unit>
        <trans-unit id="836b19e7f8037813d193adb0ea22763be677a48c" translate="yes" xml:space="preserve">
          <source>Both outer lists have different IDs, let's try this on the inner nested lists.</source>
          <target state="translated">Ambas listas externas tienen diferentes identificaciones,probemos esto en las listas internas anidadas.</target>
        </trans-unit>
        <trans-unit id="f079e1b881840a2f35a6dd6a384ae5baae282f12" translate="yes" xml:space="preserve">
          <source>Both variables are the exact same argument. Are you surprised?</source>
          <target state="translated">Ambas variables son exactamente el mismo argumento.¿Te sorprende?</target>
        </trans-unit>
        <trans-unit id="97e297e7f407d34ed9e7296aa23537583633a817" translate="yes" xml:space="preserve">
          <source>Deep copies</source>
          <target state="translated">Copias profundas</target>
        </trans-unit>
        <trans-unit id="80c240c06fa36efab33567b8dd004136b3a42e84" translate="yes" xml:space="preserve">
          <source>Do you think we're done? No. Let's try to copy our nested list.</source>
          <target state="translated">¿Crees que hemos terminado? No.Intentemos copiar nuestra lista anidada.</target>
        </trans-unit>
        <trans-unit id="579defd972ab926c631e8d21e9eff8c734a498e0" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="translated">No uses &lt;code&gt;eval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a27986749695e29a6ff85bbb5c2f396fd63cf1d" translate="yes" xml:space="preserve">
          <source>Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.</source>
          <target state="translated">Cada elemento de una lista actúa como un nombre,en el sentido de que cada elemento se une de forma no exclusiva a un objeto.Una copia superficial crea una nueva lista cuyos elementos se unen a los mismos objetos que antes.</target>
        </trans-unit>
        <trans-unit id="100e61c040833faea556e102ff4c6f46b647f7ed" translate="yes" xml:space="preserve">
          <source>Edit: New information brought to light</source>
          <target state="translated">Edición:Nueva información sacada a la luz</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="e959b489a54884803ea418506d068419cb2bc499" translate="yes" xml:space="preserve">
          <source>Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:</source>
          <target state="translated">Félix ya dio una excelente respuesta,pero pensé en hacer una comparación de velocidad de los distintos métodos:</target>
        </trans-unit>
        <trans-unit id="dd44e670da0e5e9141f6396dd8d5c9a9a6ec0348" translate="yes" xml:space="preserve">
          <source>Here are the timing results using Python 3.6.8. Keep in mind these times are relative to one another, not absolute.</source>
          <target state="translated">Aquí están los resultados de la cronología usando Python 3.6.8.Tengan en cuenta que estos tiempos son relativos entre sí,no absolutos.</target>
        </trans-unit>
        <trans-unit id="7aa26673265eca05d895ce387611ec36d0b80e52" translate="yes" xml:space="preserve">
          <source>Here in the image list_1 and copy are two variable names but the object is same for both variable which is &lt;code&gt;list&lt;/code&gt;</source>
          <target state="translated">Aqu&amp;iacute; en la imagen list_1 y copy hay dos nombres de variables, pero el objeto es el mismo para ambas variables, que es &lt;code&gt;list&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9767ca12b4902a277abb578b041a4030915e4f7b" translate="yes" xml:space="preserve">
          <source>Here is the testing code for interested parties (&lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;Template from here&lt;/a&gt;):</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el c&amp;oacute;digo de prueba para las partes interesadas ( &lt;a href=&quot;https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python&quot;&gt;Plantilla de aqu&amp;iacute;&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="290e2f376f5eaf8c22b1793823c15aae8fcd1d51" translate="yes" xml:space="preserve">
          <source>How to clone or copy a list</source>
          <target state="translated">Cómo clonar o copiar una lista</target>
        </trans-unit>
        <trans-unit id="25d3f80cbc35ca2648934a22a93b5357eecb73c4" translate="yes" xml:space="preserve">
          <source>However, If my_list contains other containers (for eg. nested lists) you must use deepcopy as others suggested in the answers above from the copy library. For example:</source>
          <target state="translated">Sin embargo,si mi_lista contiene otros contenedores (por ejemplo,listas anidadas),debe utilizar la copia profunda como se sugiere en las respuestas anteriores de la biblioteca de copias.Por ejemplo</target>
        </trans-unit>
        <trans-unit id="4edc1a0498725bd60f03b13cb73da0476b50e73c" translate="yes" xml:space="preserve">
          <source>I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python2, such as &lt;code&gt;list.copy()&lt;/code&gt; (the Python3 &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;slice equivalent&lt;/a&gt;) and two forms of &lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;list unpacking&lt;/a&gt; (&lt;code&gt;*new_list, = list&lt;/code&gt; and &lt;code&gt;new_list = [*list]&lt;/code&gt;):</source>
          <target state="translated">Me limit&amp;eacute; a hacer solo copias superficiales, y tambi&amp;eacute;n agregu&amp;eacute; algunos m&amp;eacute;todos nuevos que no eran posibles en Python2, como &lt;code&gt;list.copy()&lt;/code&gt; (el &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;equivalente de&lt;/a&gt; Python3 slice ) y dos formas de &lt;a href=&quot;https://stackoverflow.com/questions/43190992/understanding-x-lst&quot;&gt;desempaquetado&lt;/a&gt; de listas ( &lt;code&gt;*new_list, = list&lt;/code&gt; y &lt;code&gt;new_list = [*list]&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="013e110db0a05f5dbd20f8b57eade2f83a54868e" translate="yes" xml:space="preserve">
          <source>I wanted to post something a bit different then some of the other answers. Even though this is most likely not the most understandable, or fastest option, it provides a bit of an inside view of how deep copy works, as well as being another alternative option for deep copying. It doesn't really matter if my function has bugs, since the point of this is to show a way to copy objects like the question answers, but also to use this as a point to explain how deepcopy works at its core.</source>
          <target state="translated">Quería publicar algo un poco diferente a algunas de las otras respuestas.Aunque lo más probable es que no sea la opción más comprensible,o la más rápida,proporciona un poco de visión interna de cómo funciona la copia profunda,además de ser otra opción alternativa para la copia profunda.En realidad no importa si mi función tiene errores,ya que el objetivo de esto es mostrar una forma de copiar objetos como las respuestas a las preguntas,pero también usar esto como un punto para explicar cómo funciona la copia profunda en su núcleo.</target>
        </trans-unit>
        <trans-unit id="09c0b5ded50202962dc2368628c1933a8369a2c8" translate="yes" xml:space="preserve">
          <source>I've &lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;been told&lt;/a&gt; that Python 3.3+ &lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt;adds &lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method, which should be as fast as slicing:</source>
          <target state="translated">Me &lt;a href=&quot;http://mail.python.org/pipermail/python-ideas/2013-July/022368.html&quot;&gt;han dicho&lt;/a&gt; que Python 3.3+ &lt;a href=&quot;http://bugs.python.org/issue10516&quot;&gt;agrega el&lt;/a&gt; m&amp;eacute;todo &lt;code&gt;list.copy()&lt;/code&gt; , que deber&amp;iacute;a ser tan r&amp;aacute;pido como cortar:</target>
        </trans-unit>
        <trans-unit id="d8a425aac0dd5c097429125cc2f15c4bcc6557bd" translate="yes" xml:space="preserve">
          <source>If the list contains objects and you want to copy them as well, use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Si la lista contiene objetos y desea copiarlos tambi&amp;eacute;n, use &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy()&lt;/code&gt; &lt;/a&gt; gen&amp;eacute;rico:</target>
        </trans-unit>
        <trans-unit id="508aa1ec404f76db49d3513ef7b4d07bcec9be02" translate="yes" xml:space="preserve">
          <source>If you like my detailed answer, I would appreciate if you would upvote it. If you have any doubt about this answer, you can comment it down below.</source>
          <target state="translated">Si le gusta mi respuesta detallada,le agradecería que la votara.Si tiene alguna duda sobre esta respuesta,puede comentarla abajo.</target>
        </trans-unit>
        <trans-unit id="f608b902f462e04b6d6182623136fb4a743d3d57" translate="yes" xml:space="preserve">
          <source>In 64 bit Python 2.7:</source>
          <target state="translated">En 64 bit Python 2.7:</target>
        </trans-unit>
        <trans-unit id="2212a7dd8b8134dc3343d8ad7cbe5fae3fce8816" translate="yes" xml:space="preserve">
          <source>In Python 2 and 3, you can get a shallow copy with a full slice of the original:</source>
          <target state="translated">En Python 2 y 3,puedes obtener una copia superficial con un trozo completo del original:</target>
        </trans-unit>
        <trans-unit id="4ac599cde0b2c5ab6842e5b2c183be812be9d03e" translate="yes" xml:space="preserve">
          <source>In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:</source>
          <target state="translated">En Python 2,la forma idiomática de hacer una copia superficial de una lista es con un trozo completo del original:</target>
        </trans-unit>
        <trans-unit id="c1a7abb8ba4c30e338a899c8b6ef3d8068af2771" translate="yes" xml:space="preserve">
          <source>In Python 3, a shallow copy can be made with:</source>
          <target state="translated">En Python 3,se puede hacer una copia superficial con:</target>
        </trans-unit>
        <trans-unit id="8fb02af71a6aec0493954b8ede599618597636b0" translate="yes" xml:space="preserve">
          <source>In Python 3, lists get the &lt;code&gt;list.copy&lt;/code&gt; method:</source>
          <target state="translated">En Python 3, las listas obtienen el m&amp;eacute;todo &lt;code&gt;list.copy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="80e3fc6970cca93fe92c32b6c4ba9f0ab890dd92" translate="yes" xml:space="preserve">
          <source>In Python 3.5:</source>
          <target state="translated">En Python 3.5:</target>
        </trans-unit>
        <trans-unit id="e1e6045a5cef20010f69d146803165ac49a5152d" translate="yes" xml:space="preserve">
          <source>It creates the copy of list but only outer list copy, not the nested list copy, nested list is same for both variable, so if you try to modify the nested list then it will modify the original list too as the nested list object is same for both lists.</source>
          <target state="translated">Crea la copia de lista pero sólo la copia de lista externa,no la copia de lista anidada,la lista anidada es la misma para ambas variables,por lo que si se intenta modificar la lista anidada entonces modificará la lista original también ya que el objeto de lista anidada es el mismo para ambas listas.</target>
        </trans-unit>
        <trans-unit id="d34c379d10b758183565c52320bbe1d3d85b2994" translate="yes" xml:space="preserve">
          <source>It outputs:</source>
          <target state="translated">Sale:</target>
        </trans-unit>
        <trans-unit id="98a7ab1fd383d07403bec0fdbf00b56735e9d4fa" translate="yes" xml:space="preserve">
          <source>It surprises me that this hasn't been mentioned yet, so for the sake of completeness...</source>
          <target state="translated">Me sorprende que esto no se haya mencionado aún,así que para completar...</target>
        </trans-unit>
        <trans-unit id="f22686b03873b3c74078fb08c5978fac2477ccf4" translate="yes" xml:space="preserve">
          <source>It uses a new one for lists:</source>
          <target state="translated">Utiliza uno nuevo para las listas:</target>
        </trans-unit>
        <trans-unit id="c598a66587c1a2b513dfdee0f11cfe379df4fc51" translate="yes" xml:space="preserve">
          <source>It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.</source>
          <target state="translated">Parecería que la única opción real entonces es inicializar múltiples listas y trabajar en ellas de forma independiente.Si alguien tiene alguna otra sugerencia,sobre cómo manejar la copia de listas multidimensionales,se agradecería.</target>
        </trans-unit>
        <trans-unit id="bfec348e3000941e5686d75ef056c9817e63c4f9" translate="yes" xml:space="preserve">
          <source>It's also less performant.</source>
          <target state="translated">También es menos eficaz.</target>
        </trans-unit>
        <trans-unit id="e5e39dfe9f9b8c35e9d451cae1bbf0f97001f659" translate="yes" xml:space="preserve">
          <source>It's dangerous, particularly if you're evaluating something from a source you don't trust.</source>
          <target state="translated">Es peligroso,sobre todo si estás evaluando algo de una fuente en la que no confías.</target>
        </trans-unit>
        <trans-unit id="30201c551b5097249c25a2dcab3ffcb946ee7734" translate="yes" xml:space="preserve">
          <source>It's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.</source>
          <target state="translated">No es fiable,si un subelemento que estás copiando no tiene una representación que pueda ser evaluada para reproducir un elemento equivalente.</target>
        </trans-unit>
        <trans-unit id="92b01213c7f0b76ca02c2f59a64061096e1ca746" translate="yes" xml:space="preserve">
          <source>It's simple. A mutable object can't really be duplicated. It can never be changed, so it is only a single value. That means you never have to duplicate strings, numbers, bools, or any of those. But how would you duplicate the containers? Simple. You make just initialize a new container with all of the values. Deepcopy relies on recursion. It duplicates all the containers, even ones with containers inside of them, until no containers are left. A container is an immutable object.</source>
          <target state="translated">Es simple.Un objeto mutable no puede ser duplicado.Nunca puede ser cambiado,por lo que es sólo un valor único.Eso significa que nunca tienes que duplicar cuerdas,números,bools,o cualquiera de esos.¿Pero cómo duplicarías los contenedores? Es simple.Sólo tienes que inicializar un nuevo contenedor con todos los valores.Deepcopy se basa en la recursión.Duplica todos los contenedores,incluso aquellos con contenedores dentro de ellos,hasta que no queden contenedores.Un contenedor es un objeto inmutable.</target>
        </trans-unit>
        <trans-unit id="45fb77de6753c9a311b64100017c382af6c0cc51" translate="yes" xml:space="preserve">
          <source>Let's check this:</source>
          <target state="translated">Revisemos esto:</target>
        </trans-unit>
        <trans-unit id="0c5355b2834dda4cbab54f13603bb0d4f281a582" translate="yes" xml:space="preserve">
          <source>Let's start from the beginning and explore this question.</source>
          <target state="translated">Empecemos desde el principio y exploremos esta cuestión.</target>
        </trans-unit>
        <trans-unit id="4ea13a33e351858421ccf9c6208908351b78f68b" translate="yes" xml:space="preserve">
          <source>Let's understand difference between Solution#1 and Solution #2</source>
          <target state="translated">Entendamos la diferencia entre la Solución #1 y la Solución #2</target>
        </trans-unit>
        <trans-unit id="6fc2993f803fe2bce5ebd68d1671312a116f8f99" translate="yes" xml:space="preserve">
          <source>List2 isn't storing the actual list, but a reference to list1. So when you do anything to list1, list2 changes as well. use the copy module (not default, download on pip) to make an original copy of the list(&lt;code&gt;copy.copy()&lt;/code&gt; for simple lists, &lt;code&gt;copy.deepcopy()&lt;/code&gt; for nested ones). This makes a copy that doesn't change with the first list.</source>
          <target state="translated">List2 no almacena la lista real, sino una referencia a list1. Entonces, cuando haces algo para list1, list2 tambi&amp;eacute;n cambia. use el m&amp;oacute;dulo de copia (no predeterminado, descarga en pip) para hacer una copia original de la lista ( &lt;code&gt;copy.copy()&lt;/code&gt; para listas simples, &lt;code&gt;copy.deepcopy()&lt;/code&gt; para las anidadas). Esto hace una copia que no cambia con la primera lista.</target>
        </trans-unit>
        <trans-unit id="cf2a1e2bb3e71888a0f43aeb3ac08c80b8fcc911" translate="yes" xml:space="preserve">
          <source>Making another pointer does &lt;em&gt;not&lt;/em&gt; make a copy</source>
          <target state="translated">Hacer otro puntero &lt;em&gt;no&lt;/em&gt; hace una copia</target>
        </trans-unit>
        <trans-unit id="6e97c704d7d43e21b1fcfda833b090668ec5e244" translate="yes" xml:space="preserve">
          <source>Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use &lt;code&gt;copy.copy()&lt;/code&gt; or &lt;code&gt;copy.deepcopy()&lt;/code&gt; rather than the alternatives, for example in Python 3:</source>
          <target state="translated">Tenga en cuenta que hay algunos casos en los que si ha definido su propia clase personalizada y desea conservar los atributos, debe usar &lt;code&gt;copy.copy()&lt;/code&gt; o &lt;code&gt;copy.deepcopy()&lt;/code&gt; lugar de las alternativas, por ejemplo, en Python 3:</target>
        </trans-unit>
        <trans-unit id="e3932369e81674c80f98992bf457167b246e6424" translate="yes" xml:space="preserve">
          <source>Now if you are thinking copy copied the list_1, then you are wrong. The &lt;code&gt;id&lt;/code&gt; function can show us if two variables can point to the same object. Let's try this:</source>
          <target state="translated">Ahora, si est&amp;aacute; pensando que la copia copi&amp;oacute; la lista_1, entonces est&amp;aacute; equivocado. La funci&amp;oacute;n &lt;code&gt;id&lt;/code&gt; nos puede mostrar si dos variables pueden apuntar al mismo objeto. Intentemos esto:</target>
        </trans-unit>
        <trans-unit id="00347d0a4cb14f4559c30793412031205df3863d" translate="yes" xml:space="preserve">
          <source>Now if you assign &lt;code&gt;new_list = my_list[:]&lt;/code&gt; You're simply copying each object of my_list to new_list. This is known as Deep copy.</source>
          <target state="translated">Ahora, si asigna &lt;code&gt;new_list = my_list[:]&lt;/code&gt; Simplemente est&amp;aacute; copiando cada objeto de my_list a new_list. Esto se conoce como copia profunda.</target>
        </trans-unit>
        <trans-unit id="a7d1d79d92c9e349b139fe633f0b6526fad09ce4" translate="yes" xml:space="preserve">
          <source>Now let's move onto a pythonic method for copying lists.</source>
          <target state="translated">Ahora pasemos a un método pitónico para copiar listas.</target>
        </trans-unit>
        <trans-unit id="3df54c02f5f581cc533561dc1118e595e1076275" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the list and let's see if we still face the previous problem:</source>
          <target state="translated">Ahora intentemos modificar la lista y veamos si todavía nos enfrentamos al problema anterior:</target>
        </trans-unit>
        <trans-unit id="aa39e23942a2753c10c8d3f75f878396c89495a5" translate="yes" xml:space="preserve">
          <source>Now let's try to modify the nested list and see if it solved the previous issue or not:</source>
          <target state="translated">Ahora intentemos modificar la lista anidada y veamos si resolvió el problema anterior o no:</target>
        </trans-unit>
        <trans-unit id="18d4f8f9dd5560fdbaaa044248879e0f414571a4" translate="yes" xml:space="preserve">
          <source>Now we can assume both lists are pointing different object, so now let's try to modify it and let's see it is giving what we want:</source>
          <target state="translated">Ahora podemos asumir que ambas listas apuntan a un objeto diferente,así que ahora intentemos modificarlo y veamos que está dando lo que queremos:</target>
        </trans-unit>
        <trans-unit id="f36cb40ae7ff021457ab561b8f3c65237590561c" translate="yes" xml:space="preserve">
          <source>Now, imagine you have this list: &lt;em&gt;[[1, 2], [3, 4], [5, 6]]&lt;/em&gt;. This time, you want to make a function, which uses recursion to deep copy all layers of the list. Instead of the previous list comprehension:</source>
          <target state="translated">Ahora, imagine que tiene esta lista: &lt;em&gt;[[1, 2], [3, 4], [5, 6]]&lt;/em&gt; . Esta vez, desea hacer una funci&amp;oacute;n, que utiliza la recursividad para copiar en profundidad todas las capas de la lista. En lugar de la comprensi&amp;oacute;n de la lista anterior:</target>
        </trans-unit>
        <trans-unit id="69f5f45134cb9ec012385bfbf42d5088f5cf8d41" translate="yes" xml:space="preserve">
          <source>Obviously the slowest and most memory-needing method, but sometimes unavoidable.</source>
          <target state="translated">Obviamente el método más lento y que más memoria necesita,pero a veces inevitable.</target>
        </trans-unit>
        <trans-unit id="dbbf697d62aa4fc57077ea24851b4247f69fc822" translate="yes" xml:space="preserve">
          <source>Once you know that, completely duplicating an object without any references is pretty easy. Here's a function for deepcopying basic data-types (wouldn't work for custom classes but you could always add that)</source>
          <target state="translated">Una vez que sabes eso,duplicar completamente un objeto sin referencias es bastante fácil.Aquí hay una función para profundizar en los tipos de datos básicos (no funcionaría para las clases personalizadas pero siempre se puede añadir eso)</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="85428b26db4c1794e05f4269b0c513309de817c9" translate="yes" xml:space="preserve">
          <source>Python 2</source>
          <target state="translated">Python 2</target>
        </trans-unit>
        <trans-unit id="0101a74afd88d622354b05b2b6416e029264bbac" translate="yes" xml:space="preserve">
          <source>Python 3</source>
          <target state="translated">Python 3</target>
        </trans-unit>
        <trans-unit id="4349126aac22c987d016e24c14dcae82a88269df" translate="yes" xml:space="preserve">
          <source>Python 3.6 Timings</source>
          <target state="translated">Python 3.6 Tiempos</target>
        </trans-unit>
        <trans-unit id="6ac4e03df57920cae5a01b21d070287f63116c43" translate="yes" xml:space="preserve">
          <source>Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by &lt;code&gt;my_list&lt;/code&gt; and bound it to &lt;code&gt;new_list&lt;/code&gt; as well. No matter which name you use there is still only one list, so changes made when referring to it as &lt;code&gt;my_list&lt;/code&gt; will persist when referring to it as &lt;code&gt;new_list&lt;/code&gt;. Each of the other answers to this question give you different ways of creating a new object to bind to &lt;code&gt;new_list&lt;/code&gt;.</source>
          <target state="translated">Python no almacena valores en variables; une nombres a objetos. Su asignaci&amp;oacute;n original tom&amp;oacute; el objeto al que hace referencia &lt;code&gt;my_list&lt;/code&gt; y tambi&amp;eacute;n lo vincul&amp;oacute; a &lt;code&gt;new_list&lt;/code&gt; . No importa qu&amp;eacute; nombre use, todav&amp;iacute;a hay una sola lista, por lo que los cambios realizados al referirse a ella como &lt;code&gt;my_list&lt;/code&gt; persistir&amp;aacute;n al referirse a ella como &lt;code&gt;new_list&lt;/code&gt; . Cada una de las otras respuestas a esta pregunta le brinda diferentes formas de crear un nuevo objeto para vincular a &lt;code&gt;new_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="431a4d86ecae97814d808e75432c4497870cb5a0" translate="yes" xml:space="preserve">
          <source>Python's idiom for doing this is &lt;code&gt;newList = oldList[:]&lt;/code&gt;</source>
          <target state="translated">El idioma de Python para hacer esto es &lt;code&gt;newList = oldList[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c6ddaaef7312488cd7088001672817f1f759347" translate="yes" xml:space="preserve">
          <source>Python's own built-in deepcopy is based around that example. The only difference is it supports other types, and also supports user-classes by duplicating the attributes into a new duplicate class, and also blocks infinite-recursion with a reference to an object it's already seen using a memo list or dictionary. And that's really it for making deep copies. At its core, making a deep copy is just making shallow copies. I hope this answer adds something to the question.</source>
          <target state="translated">La propia profundización incorporada de Python se basa en ese ejemplo.La única diferencia es que admite otros tipos,y también admite clases de usuario duplicando los atributos en una nueva clase duplicada,y también bloquea la corrección infinita con una referencia a un objeto que ya se ve usando una lista de notas o un diccionario.Y eso es todo para hacer copias profundas.En el fondo,hacer una copia profunda es sólo hacer copias superficiales.Espero que esta respuesta añada algo a la pregunta.</target>
        </trans-unit>
        <trans-unit id="cdb020da6f04f980578edbeea557ee080eae15e7" translate="yes" xml:space="preserve">
          <source>Remember that in Python when you do:</source>
          <target state="translated">Recuerda eso en Python cuando lo hagas:</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="0c5d365ba03417b1814c4317a93bd505f3d45686" translate="yes" xml:space="preserve">
          <source>Say you have this list: &lt;em&gt;[1, 2, 3]&lt;/em&gt;. The immutable numbers cannot be duplicated, but the other layer can. You can duplicate it using a list comprehension: &lt;em&gt;[x for x in [1, 2, 3]&lt;/em&gt;</source>
          <target state="translated">Digamos que tiene esta lista: &lt;em&gt;[1, 2, 3]&lt;/em&gt; . Los n&amp;uacute;meros inmutables no pueden duplicarse, pero la otra capa s&amp;iacute;. Puede duplicarlo utilizando una lista de comprensi&amp;oacute;n: &lt;em&gt;[x para x en [1, 2, 3]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a382c1a79a9abea2c3b456d682976a5c9462e5a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;the documentation&lt;/a&gt; for more information about corner cases in copying.</source>
          <target state="translated">Consulte &lt;a href=&quot;https://docs.python.org/2/library/copy.html&quot;&gt;la documentaci&amp;oacute;n&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre casos de esquina en la copia.</target>
        </trans-unit>
        <trans-unit id="6772e3c75e46f3d9be01bc50c86027112d2938bf" translate="yes" xml:space="preserve">
          <source>Shallow list copy</source>
          <target state="translated">Copia de la lista superficial</target>
        </trans-unit>
        <trans-unit id="9a11a8945f8d6b48081dbf5ea5d6e5f5c801b470" translate="yes" xml:space="preserve">
          <source>So as we can see our both list having different id and it means that both variables are pointing to different objects. So what actually going on here is:</source>
          <target state="translated">Así que como podemos ver que nuestra lista tiene diferentes identificaciones y significa que ambas variables apuntan a diferentes objetos.Así que lo que realmente está pasando aquí es:</target>
        </trans-unit>
        <trans-unit id="3513e3f3b28e2724f6f965025e19894e50855199" translate="yes" xml:space="preserve">
          <source>So as we know python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is a &lt;code&gt;list&lt;/code&gt; but we created two references to that same object by two different variable names. This means that both variables are pointing to the same object, just with different names.</source>
          <target state="translated">Entonces, como sabemos, python no almacena nada en una variable, las variables solo hacen referencia al objeto y el objeto almacena el valor. Aqu&amp;iacute; el objeto es una &lt;code&gt;list&lt;/code&gt; a, pero creamos dos referencias a ese mismo objeto con dos nombres de variables diferentes. Esto significa que ambas variables apuntan al mismo objeto, solo que con diferentes nombres.</target>
        </trans-unit>
        <trans-unit id="cd1487edc9546c18ca2fb6958037f7bc45eccdcc" translate="yes" xml:space="preserve">
          <source>So first let's try by setting the variable &lt;code&gt;copy&lt;/code&gt; to our original list, &lt;code&gt;list_1&lt;/code&gt;:</source>
          <target state="translated">Entonces, primero intentemos estableciendo la &lt;code&gt;copy&lt;/code&gt; variable en nuestra lista original, &lt;code&gt;list_1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="35599f5f6a22799b9a1065745b9e8a7525311cbe" translate="yes" xml:space="preserve">
          <source>So if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:</source>
          <target state="translated">Así que si intentas modificar la lista copiada,entonces modificará la lista original también porque la lista es sólo una allí,modificarás esa lista no importa si lo haces desde la lista copiada o desde la lista original:</target>
        </trans-unit>
        <trans-unit id="0e6bad77f39dcb244d41a51049f33dcea7721965" translate="yes" xml:space="preserve">
          <source>So it modified the original list :</source>
          <target state="translated">Así que modificó la lista original:</target>
        </trans-unit>
        <trans-unit id="f008a22270d77fa388373610112fcf2f544b4006" translate="yes" xml:space="preserve">
          <source>So let's suppose you have two lists:</source>
          <target state="translated">Así que supongamos que tienes dos listas:</target>
        </trans-unit>
        <trans-unit id="eda3d79321d8e8a6c5f43e602583a85978e82115" translate="yes" xml:space="preserve">
          <source>So the fastest is list slicing. But be aware that &lt;code&gt;copy.copy()&lt;/code&gt;, &lt;code&gt;list[:]&lt;/code&gt; and &lt;code&gt;list(list)&lt;/code&gt;, unlike &lt;code&gt;copy.deepcopy()&lt;/code&gt; and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.</source>
          <target state="translated">Entonces, el m&amp;aacute;s r&amp;aacute;pido es el corte de listas. Pero tenga en cuenta que &lt;code&gt;copy.copy()&lt;/code&gt; , &lt;code&gt;list[:]&lt;/code&gt; y &lt;code&gt;list(list)&lt;/code&gt; , a diferencia de &lt;code&gt;copy.deepcopy()&lt;/code&gt; y la versi&amp;oacute;n de python, no copie ninguna lista, diccionario o instancia de clase en la lista, as&amp;iacute; que si los originales cambian , tambi&amp;eacute;n cambiar&amp;aacute;n en la lista copiada y viceversa.</target>
        </trans-unit>
        <trans-unit id="8bbc00ebc1fe27804a2faefef2b2a7c8e80ddd52" translate="yes" xml:space="preserve">
          <source>The Other way you can do this are :</source>
          <target state="translated">La otra forma en que puedes hacer esto es..:</target>
        </trans-unit>
        <trans-unit id="a51bd5a9f88582672dcba66c5148c7d26e24a8aa" translate="yes" xml:space="preserve">
          <source>The dark horse is the unpacking and repacking method (&lt;code&gt;b = [*a]&lt;/code&gt;), which is ~25% faster than raw slicing, and more than twice as fast as the other unpacking method (&lt;code&gt;*b, = a&lt;/code&gt;).</source>
          <target state="translated">El caballo oscuro es el m&amp;eacute;todo de desempaque y reempaque ( &lt;code&gt;b = [*a]&lt;/code&gt; ), que es ~ 25% m&amp;aacute;s r&amp;aacute;pido que el corte en bruto, y m&amp;aacute;s del doble de r&amp;aacute;pido que el otro m&amp;eacute;todo de desempaque ( &lt;code&gt;*b, = a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="efdb3e2274e3293e0058ed73476dabfc0b9f7297" translate="yes" xml:space="preserve">
          <source>The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.</source>
          <target state="translated">La lista es sólo un conjunto de punteros al contenido,así que una copia superficial sólo copia los punteros,y así tienes dos listas diferentes,pero tienen el mismo contenido.Para hacer copias de los contenidos,necesitas una copia profunda.</target>
        </trans-unit>
        <trans-unit id="afa75f9e3be68e27350aefb47205502bf0a9e6e5" translate="yes" xml:space="preserve">
          <source>The obvious downside to this method is that it is only available in Python 3.5+.</source>
          <target state="translated">La desventaja obvia de este método es que sólo está disponible en Python 3.5+.</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">La salida es:</target>
        </trans-unit>
        <trans-unit id="90fa1fae686fa6b34b07514c61aa94123be63447" translate="yes" xml:space="preserve">
          <source>Then now you have a function which can deepcopy any list of &lt;strong&gt;strs, bools, floast, ints&lt;/strong&gt; and even &lt;strong&gt;lists&lt;/strong&gt; to infinitely many layers using recursion. And there you have it, deepcopying.</source>
          <target state="translated">Entonces ahora tiene una funci&amp;oacute;n que puede hacer una copia en profundidad de cualquier lista de &lt;strong&gt;strs, bools, floast, ints&lt;/strong&gt; e incluso &lt;strong&gt;listas&lt;/strong&gt; de infinitas capas usando recursividad. Y ah&amp;iacute; lo tienes, copiando en profundidad.</target>
        </trans-unit>
        <trans-unit id="220890ce8fb4c2412811019ffb2db9f207227214" translate="yes" xml:space="preserve">
          <source>There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.</source>
          <target state="translated">Hay diferentes maneras de hacer esto en Python 2 y 3.Las formas de Python 2 también funcionarán en Python 3.</target>
        </trans-unit>
        <trans-unit id="b6d1fa502414f389e3c4893a7f6454394e1dd9d1" translate="yes" xml:space="preserve">
          <source>There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed.</source>
          <target state="translated">Ya hay muchas respuestas que te dicen cómo hacer una copia adecuada,pero ninguna de ellas dice por qué tu &quot;copia&quot; original falló.</target>
        </trans-unit>
        <trans-unit id="66abe6803af6fc0a90902cfc1672796b3aae06b4" translate="yes" xml:space="preserve">
          <source>There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.</source>
          <target state="translated">Hay dos formas semánticas de copiar una lista.Una copia superficial crea una nueva lista de los mismos objetos,una copia profunda crea una nueva lista que contiene nuevos objetos equivalentes.</target>
        </trans-unit>
        <trans-unit id="bc4ca653a23068dcf7ae97de3b9e4f63df0f559e" translate="yes" xml:space="preserve">
          <source>This gives us the output:</source>
          <target state="translated">Esto nos da la salida:</target>
        </trans-unit>
        <trans-unit id="557c91f0d91bf8aa2deea01cceab9c91400d0ec2" translate="yes" xml:space="preserve">
          <source>This is a little slower than &lt;code&gt;list()&lt;/code&gt; because it has to find out the datatype of &lt;code&gt;old_list&lt;/code&gt; first.</source>
          <target state="translated">Esto es un poco m&amp;aacute;s lento que &lt;code&gt;list()&lt;/code&gt; porque primero tiene que encontrar el tipo de datos de &lt;code&gt;old_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49bb04f0f459e1ca1287d6676b347a76839b4290" translate="yes" xml:space="preserve">
          <source>This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy.</source>
          <target state="translated">No se trata todavía de una copia profunda,porque cada elemento de una lista puede referirse a otros objetos,al igual que la lista está ligada a sus elementos.Para copiar recursivamente cada elemento de la lista,y luego cada otro objeto al que se refiere cada elemento,y así sucesivamente:realizar una copia profunda.</target>
        </trans-unit>
        <trans-unit id="3c04fe0cc698e2ba7a6efcd47118a60302f9c23f" translate="yes" xml:space="preserve">
          <source>This may seem a little bit confusing, because the same method we previously used worked. Let's try to understand this.</source>
          <target state="translated">Esto puede parecer un poco confuso,porque el mismo método que usamos anteriormente funcionó.Tratemos de entender esto.</target>
        </trans-unit>
        <trans-unit id="00f93f5227a8e28c60a94b27101682842e37414b" translate="yes" xml:space="preserve">
          <source>This means that for multidimensional lists, the only option is &lt;code&gt;copy.deepcopy()&lt;/code&gt;. With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to &lt;code&gt;timeit&lt;/code&gt; using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.</source>
          <target state="translated">Esto significa que para las listas multidimensionales, la &amp;uacute;nica opci&amp;oacute;n es &lt;code&gt;copy.deepcopy()&lt;/code&gt; . Dicho esto, realmente no es una opci&amp;oacute;n, ya que el rendimiento va al sur cuando intentas usarlo en una matriz multidimensional de tama&amp;ntilde;o moderado. Trat&amp;eacute; de &lt;code&gt;timeit&lt;/code&gt; uso de una matriz de 42x42, no tan desconocida o incluso tan grande para aplicaciones de bioinform&amp;aacute;tica, y dej&amp;eacute; de esperar una respuesta y comenc&amp;eacute; a escribir mi edici&amp;oacute;n en esta publicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0a9d3f3184e470a21dfb005cbe5d56f43c9b998b" translate="yes" xml:space="preserve">
          <source>This means when you do &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; what actually happens:</source>
          <target state="translated">Esto significa que cuando haces &lt;code&gt;deep=deepcopy(list_2)&lt;/code&gt; lo que realmente sucede:</target>
        </trans-unit>
        <trans-unit id="04a5a8b7256438d8150475968ea5b994c8232285" translate="yes" xml:space="preserve">
          <source>This method fixes the first issue we had:</source>
          <target state="translated">Este método arregla el primer problema que tuvimos:</target>
        </trans-unit>
        <trans-unit id="e7902de440301cd9e6f660692a60815b9d105656" translate="yes" xml:space="preserve">
          <source>Timing wise though, this appears to perform better than other common methods.</source>
          <target state="translated">Sin embargo,en términos de tiempo,esto parece funcionar mejor que otros métodos comunes.</target>
        </trans-unit>
        <trans-unit id="6b58f0a40765b5b08203954d86f7c9ff6bee49da" translate="yes" xml:space="preserve">
          <source>To actually copy the list, you have various possibilities:</source>
          <target state="translated">Para copiar realmente la lista,tienes varias posibilidades:</target>
        </trans-unit>
        <trans-unit id="946633aa3cdcc201da0bfd3b79549497b06ce48f" translate="yes" xml:space="preserve">
          <source>To demonstrate how this allows us to make new sub-lists:</source>
          <target state="translated">Para demostrar cómo esto nos permite hacer nuevas sub-listas:</target>
        </trans-unit>
        <trans-unit id="18c166dc2118c18ca2195aded821b172eef596bd" translate="yes" xml:space="preserve">
          <source>To make a &lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;deep copy of a list, in Python 2 or 3, use &lt;code&gt;deepcopy&lt;/code&gt; in the &lt;code&gt;copy&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">Para hacer una &lt;a href=&quot;https://docs.python.org/library/copy.html&quot;&gt;copia profunda de una lista, en Python 2 o 3, use la &lt;code&gt;copy&lt;/code&gt; &lt;code&gt;deepcopy&lt;/code&gt; en el m&amp;oacute;dulo de copia&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="77a0cef14012e7b83ed88a073f164fddcf757041" translate="yes" xml:space="preserve">
          <source>To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list.</source>
          <target state="translated">Para llevar la copia de su lista un paso más allá,copie cada uno de los objetos a los que se refiere su lista y vincule esas copias de elementos a una nueva lista.</target>
        </trans-unit>
        <trans-unit id="94a001d83f43e327f9bf5308ade41bb93e8b8b9b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;thing[:]&lt;/code&gt;</source>
          <target state="translated">Usar &lt;code&gt;thing[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="704ff25c262b4989c3e885b9c631ea5f00ee2274" translate="yes" xml:space="preserve">
          <source>We can see the Python2 winner still does well, but doesn't edge out Python3 &lt;code&gt;list.copy()&lt;/code&gt; by much, especially considering the superior readability of the latter.</source>
          <target state="translated">Podemos ver que el ganador de Python2 todav&amp;iacute;a lo hace bien, pero no supera &lt;code&gt;list.copy()&lt;/code&gt; Python3 list.copy () , especialmente teniendo en cuenta la legibilidad superior de este &amp;uacute;ltimo.</target>
        </trans-unit>
        <trans-unit id="88fa58a7d8228094b91bae093cb54c6c760187cc" translate="yes" xml:space="preserve">
          <source>We get the output:</source>
          <target state="translated">Tenemos la salida:</target>
        </trans-unit>
        <trans-unit id="20b49cce5a91432e085e1764e90ac0273068bbc7" translate="yes" xml:space="preserve">
          <source>What are the options to clone or copy a list in Python?</source>
          <target state="translated">¿Cuáles son las opciones para clonar o copiar una lista en Python?</target>
        </trans-unit>
        <trans-unit id="365d64ca08030dc6b88428870f53a2fcdac7e978" translate="yes" xml:space="preserve">
          <source>What is the solution? The solution is the &lt;code&gt;deepcopy&lt;/code&gt; function.</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la soluci&amp;oacute;n? La soluci&amp;oacute;n es la funci&amp;oacute;n de &lt;code&gt;deepcopy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8115e5fa0f64b2d78e179223b2acf529f438cd" translate="yes" xml:space="preserve">
          <source>When we do &lt;code&gt;copy_2=list_2[:]&lt;/code&gt;, this happens:</source>
          <target state="translated">Cuando hacemos &lt;code&gt;copy_2=list_2[:]&lt;/code&gt; , esto sucede:</target>
        </trans-unit>
        <trans-unit id="7d92247dca50cce0446da6df8b14549d6a725f7b" translate="yes" xml:space="preserve">
          <source>When you do &lt;code&gt;copy=list_1&lt;/code&gt;, it is actually doing:</source>
          <target state="translated">Cuando haces &lt;code&gt;copy=list_1&lt;/code&gt; , en realidad est&amp;aacute; haciendo:</target>
        </trans-unit>
        <trans-unit id="2e8ee345e21d7df889e916663fa72306a26db891" translate="yes" xml:space="preserve">
          <source>When you do:</source>
          <target state="translated">Cuando lo hagas:</target>
        </trans-unit>
        <trans-unit id="25aeb6ff8ce6046a534c673463f7363bfa51d100" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;new_list = old_list[:]&lt;/code&gt;, &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; and for Py3k &lt;code&gt;old_list.copy()&lt;/code&gt; work for single-leveled lists, they revert to pointing at the &lt;code&gt;list&lt;/code&gt; objects nested within the &lt;code&gt;old_list&lt;/code&gt; and the &lt;code&gt;new_list&lt;/code&gt;, and changes to one of the &lt;code&gt;list&lt;/code&gt; objects are perpetuated in the other.</source>
          <target state="translated">Mientras &lt;code&gt;new_list = old_list[:]&lt;/code&gt; , &lt;code&gt;copy.copy(old_list)'&lt;/code&gt; y para Py3k &lt;code&gt;old_list.copy()&lt;/code&gt; funcionan para listas de un solo nivel, vuelven a apuntar a los objetos de &lt;code&gt;list&lt;/code&gt; a anidados dentro de &lt;code&gt;old_list&lt;/code&gt; y &lt;code&gt;new_list&lt;/code&gt; , y cambia a uno de los objetos de la &lt;code&gt;list&lt;/code&gt; a se perpet&amp;uacute;an en el otro.</target>
        </trans-unit>
        <trans-unit id="46a5e0acd81721a83e102ba1cc3b2c2c40347a6d" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;new_list = my_list&lt;/code&gt;, any modifications to &lt;code&gt;new_list&lt;/code&gt; changes &lt;code&gt;my_list&lt;/code&gt; everytime.
Why is this?</source>
          <target state="translated">Al usar &lt;code&gt;new_list = my_list&lt;/code&gt; , cualquier modificaci&amp;oacute;n a &lt;code&gt;new_list&lt;/code&gt; cambia &lt;code&gt;my_list&lt;/code&gt; cada vez. &amp;iquest;Por qu&amp;eacute; es esto?</target>
        </trans-unit>
        <trans-unit id="4ccc750900a14314384b3bf271f406314a22ce63" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;new_list = my_list&lt;/code&gt;, you don't actually have two lists. The assignment just copies the reference to the list, not the actual list, so both &lt;code&gt;new_list&lt;/code&gt; and &lt;code&gt;my_list&lt;/code&gt; refer to the same list after the assignment.</source>
          <target state="translated">Con &lt;code&gt;new_list = my_list&lt;/code&gt; , en realidad no tienes dos listas. La asignaci&amp;oacute;n solo copia la referencia a la lista, no la lista real, por lo que &lt;code&gt;new_list&lt;/code&gt; y &lt;code&gt;my_list&lt;/code&gt; hacen referencia a la misma lista despu&amp;eacute;s de la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="225441c8d6bd2a8e2654bc1fd302a0897594025a" translate="yes" xml:space="preserve">
          <source>You can also accomplish the same thing by passing the list through the list constructor,</source>
          <target state="translated">También puedes lograr lo mismo pasando la lista a través del constructor de la lista,</target>
        </trans-unit>
        <trans-unit id="a9e1c8ff6e281ab525b473cb57dfc86a34e5f554" translate="yes" xml:space="preserve">
          <source>You can perform list unpacking with the &quot;splat operator&quot;: &lt;code&gt;*&lt;/code&gt;, which will also copy elements of your list.</source>
          <target state="translated">Puede realizar el desempaquetado de la lista con el &quot;operador splat&quot;: &lt;code&gt;*&lt;/code&gt; , que tambi&amp;eacute;n copiar&amp;aacute; elementos de su lista.</target>
        </trans-unit>
        <trans-unit id="204a07b1b7642695ed4e50226442ee5bd889a56d" translate="yes" xml:space="preserve">
          <source>You can slice it:</source>
          <target state="translated">Puedes cortarlo:</target>
        </trans-unit>
        <trans-unit id="8b60affbd66d1ab22f4db2b35f4476c0bc727885" translate="yes" xml:space="preserve">
          <source>You can use generic &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Puede usar &lt;a href=&quot;https://docs.python.org/2/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy()&lt;/code&gt; &lt;/a&gt; gen&amp;eacute;rico () :</target>
        </trans-unit>
        <trans-unit id="f7c4e65f4ef8f5a93e4955911a9d09385dd4e0e2" translate="yes" xml:space="preserve">
          <source>You can use the built in &lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt;&lt;code&gt;list()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Puede usar la funci&amp;oacute;n incorporada &lt;a href=&quot;https://docs.python.org/2/library/functions.html#list&quot;&gt; &lt;code&gt;list()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="74e2cb68ed9fb5f2c5405875004d794d14a5f066" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt;&lt;code&gt;list.copy()&lt;/code&gt;&lt;/a&gt; method (available since Python 3.3):</source>
          <target state="translated">Puede usar el &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types&quot;&gt; &lt;code&gt;list.copy()&lt;/code&gt; &lt;/a&gt; incorporado list.copy () (disponible desde Python 3.3):</target>
        </trans-unit>
        <trans-unit id="897a434f7844b828ae3989a342e35cc3c21bf0d6" translate="yes" xml:space="preserve">
          <source>You may see this used as a way to deepcopy, but don't do it:</source>
          <target state="translated">Puede que veas esto usado como una forma de hacer una copia profunda,pero no lo hagas:</target>
        </trans-unit>
        <trans-unit id="76244e96c4d1fb0eec733ac274efa594300304e7" translate="yes" xml:space="preserve">
          <source>You're only copying the outer list, not the inside list. We can use the &lt;code&gt;id&lt;/code&gt; function once again to check this.</source>
          <target state="translated">Solo est&amp;aacute; copiando la lista externa, no la lista interna. Podemos usar la funci&amp;oacute;n &lt;code&gt;id&lt;/code&gt; una vez m&amp;aacute;s para verificar esto.</target>
        </trans-unit>
        <trans-unit id="9356e95d4f6f104855f95803d19cc415fcbbdf4f" translate="yes" xml:space="preserve">
          <source>but using the constructor is less efficient:</source>
          <target state="translated">pero usar el constructor es menos eficiente:</target>
        </trans-unit>
        <trans-unit id="6bac1115690000182dc538b79519b1c469db850e" translate="yes" xml:space="preserve">
          <source>on 64 bit Python 3.5:</source>
          <target state="translated">en Python 3.5 de 64 bits:</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
