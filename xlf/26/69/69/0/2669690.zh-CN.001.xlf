<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2669690">
    <body>
      <group id="2669690">
        <trans-unit id="6ed88095f6356427e065e4f0da1dc4208b5b2eaa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;edit&lt;/em&gt; &amp;mdash; note the comment (and other answers). The issue has to do with subverted built-in facilities, specifically the &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; constructors. Those can be altered such that otherwise innocuous JSON, when parsed, could trigger attacker code.</source>
          <target state="translated">&lt;em&gt;编辑&lt;/em&gt; -注意评论（和其他答案）。 这个问题与颠覆的内置功能有关，尤其是 &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;Array&lt;/code&gt; 构造函数。 可以对其进行更改，以使否则当解析时使用无害的JSON可能会触发攻击者代码。</target>
        </trans-unit>
        <trans-unit id="57fd21beefa78406c6c5367148ed26ac53b78c6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: as of 2019, many of the old vulnerabilities that lead to the preventative measures discussed in this question are no longer an issue in modern browsers.  I'll leave the answer below as a historical curiosity, but really the whole topic has changed radically since 2010 (!!) when this was asked.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：从2019年开始，导致该问题中讨论的预防措施的许多旧漏洞不再是现代浏览器中的问题。 我将以下答案保留为历史性的好奇心，但实际上自2010年问起以来，整个主题已经发生了根本变化（!!）。</target>
        </trans-unit>
        <trans-unit id="71b65b72e474c79efaa1968eb5081ff39c79eee5" translate="yes" xml:space="preserve">
          <source>A same-site request using XHR and a separate JSON parser, on the other hand, can easily ignore the &lt;code&gt;while(1);&lt;/code&gt; prefix.</source>
          <target state="translated">另一方面，使用XHR和单独的JSON解析器的同一站点请求可以轻松地忽略 &lt;code&gt;while(1);&lt;/code&gt; 。 字首。</target>
        </trans-unit>
        <trans-unit id="28c456b213ff34c390dcff80ef63fb23c1ce5122" translate="yes" xml:space="preserve">
          <source>A valid JSON object, when not enclosed by anything, is not valid in Javascript:</source>
          <target state="translated">一个有效的JSON对象,当没有被任何东西包围时,在Javascript中是无效的。</target>
        </trans-unit>
        <trans-unit id="7daffc89a7b8aec7532d4838fa6a40f1f70b311b" translate="yes" xml:space="preserve">
          <source>After authentication is in place, JSON hijacking protection can take a
  variety of forms. Google appends &lt;strong&gt;while(1)&lt;/strong&gt; into their JSON data, so
  that if any malicious script evaluates it, the malicious script enters
  an infinite loop.</source>
          <target state="translated">身份验证到位后，JSON劫持保护可以采取多种形式。 Google将&lt;strong&gt;while（1）&lt;/strong&gt;附加到其JSON数据中，因此，如果有任何恶意脚本对其进行评估，则该恶意脚本会进入无限循环。</target>
        </trans-unit>
        <trans-unit id="7be6a6f5a84ff1bd0bc12a6d53c2432306a8338c" translate="yes" xml:space="preserve">
          <source>Always return JSON with an Object on the outside</source>
          <target state="translated">总是返回外部有对象的JSON。</target>
        </trans-unit>
        <trans-unit id="38657cd1deca0c38601450000e8c4ee8e3254dce" translate="yes" xml:space="preserve">
          <source>An attacker can request pages on other domains on your behalf, e.g. by using a &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag, but it can't get any information about the result (headers, contents).</source>
          <target state="translated">攻击者可以代表您请求其他域上的页面，例如，使用 &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标记，但它无法获取有关结果的任何信息（标题，内容）。</target>
        </trans-unit>
        <trans-unit id="4076d258e698a41cd58be09271d7235422cbb6bf" translate="yes" xml:space="preserve">
          <source>As noted by @hvd in the comments, the empty object &lt;code&gt;{}&lt;/code&gt; is valid Javascript, and knowing the object is empty may itself be valuable information.</source>
          <target state="translated">正如@hvd在评论中指出的那样，空对象 &lt;code&gt;{}&lt;/code&gt; 是有效的Javascript，知道该对象为空可能本身就是有价值的信息。</target>
        </trans-unit>
        <trans-unit id="88546fce7b19dd78f569d725399c113f191387f3" translate="yes" xml:space="preserve">
          <source>Both methods require server-side changes to avoid developers from accidentally sending vulnerable JSON.</source>
          <target state="translated">这两种方法都需要在服务器端进行修改,以避免开发人员不小心发送易受攻击的JSON。</target>
        </trans-unit>
        <trans-unit id="7648f1875c9c0f61d7f7135068a8d63184cda276" translate="yes" xml:space="preserve">
          <source>By placing a &lt;code&gt;while(1);&lt;/code&gt; statement before the JSON data, Google makes sure that the JSON data is never executed as Javascript.</source>
          <target state="translated">通过放置 &lt;code&gt;while(1);&lt;/code&gt; 在JSON数据之前声明，Google确保JSON数据永远不会作为Javascript执行。</target>
        </trans-unit>
        <trans-unit id="7ff41c40cdaa12bb4b0f0be685d8174ce53a7093" translate="yes" xml:space="preserve">
          <source>Comparison of above methods</source>
          <target state="translated">上述方法的比较</target>
        </trans-unit>
        <trans-unit id="5cc0ef8ebf1d3e8d4667d491bff6ea11477f47b4" translate="yes" xml:space="preserve">
          <source>Contrived example: say Google has a URL like &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; which returns the first 50 messages of your inbox in JSON format. Evil websites on other domains can't make AJAX requests to get this data due to the same-origin policy, but they can include the URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. The URL is visited with &lt;em&gt;your&lt;/em&gt; cookies, and by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;overriding the global array constructor or accessor methods&lt;/a&gt; they can have a method called whenever an object (array or hash) attribute is set, allowing them to read the JSON content.</source>
          <target state="translated">人为的例子：假设Google有一个类似 &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; 的URL，它以JSON格式返回收件箱中的前50条消息。 由于同源政策，其他域上的邪恶网站无法发出AJAX请求来获取此数据，但它们可以通过 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记包含URL。 随&lt;em&gt;您的&lt;/em&gt; cookie一起访问URL，并且通过&lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;覆盖全局数组构造函数或访问器方法&lt;/a&gt; ，只要设置了对象（数组或哈希）属性，它们就可以拥有一个被调用的方法，从而允许它们读取JSON内容。</target>
        </trans-unit>
        <trans-unit id="0a899fbe9a5bae6b89125ccbf8c6667d4af13c9e" translate="yes" xml:space="preserve">
          <source>Except that when using a script tag to request JSON content, the JSON is executed as Javascript in an attacker's controlled environment. If the attacker can replace the Array or Object constructor or some other method used during object construction, anything in the JSON would pass through the attacker's code, and be disclosed.</source>
          <target state="translated">只是,当使用脚本标记请求JSON内容时,JSON在攻击者的控制环境中作为Javascript执行。如果攻击者可以替换掉对象构造过程中使用的Array或Object构造函数或其他一些方法,那么JSON中的任何内容都会通过攻击者的代码,被泄露。</target>
        </trans-unit>
        <trans-unit id="03fdac45ae96e608cfb4e1753008813ff5f0bb85" translate="yes" xml:space="preserve">
          <source>For example, here's a response while turning a calendar on and off in &lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;Google Calendar&lt;/a&gt;:</source>
          <target state="translated">例如，这是在&lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;Google日历中&lt;/a&gt;打开和关闭日历时的响应：</target>
        </trans-unit>
        <trans-unit id="9afbbc0bacc7b9d361b66d602e97e7c70b23f706" translate="yes" xml:space="preserve">
          <source>Google's way requires the client library for it to support automatic de-serialization and can be considered to be safer about browser bugs.</source>
          <target state="translated">谷歌的方式要求客户端库支持自动去序列化,可以说是对浏览器BUG比较安全。</target>
        </trans-unit>
        <trans-unit id="23ad849cb3512da4fc03ab0386e87a3b5900544d" translate="yes" xml:space="preserve">
          <source>I would assume this is to prevent people from doing an &lt;code&gt;eval()&lt;/code&gt; on it, but all you'd really have to do is replace the &lt;code&gt;while&lt;/code&gt; and then you'd be set. I would assume the eval prevention is to make sure people write safe JSON parsing code.</source>
          <target state="translated">我认为这是为了防止人们对它执行 &lt;code&gt;eval()&lt;/code&gt; ，但是您真正要做的就是替换 &lt;code&gt;while&lt;/code&gt; ，然后进行设置。 我认为评估的目的是确保人们编写安全的JSON解析代码。</target>
        </trans-unit>
        <trans-unit id="9ec8b77b7bc0a99ad31f1d55c0d2ee7330d63d84" translate="yes" xml:space="preserve">
          <source>I've seen this used in a couple of other places, too, but a lot more so with Google (Mail, Calendar, Contacts, etc.) Strangely enough, &lt;a href=&quot;https://www.google.com/docs/about/&quot;&gt;Google Docs&lt;/a&gt; starts with &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; instead, and Google Contacts seems to start with &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">我也曾在其他几个地方看到过这种用法，但在Google（邮件，日历，联系人等）中使用的次数更多。 &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &amp;amp;&amp;amp;&amp;amp; START &amp;amp;&amp;amp;&amp;amp; 。</target>
        </trans-unit>
        <trans-unit id="82ec8480b6d03af801f80b5ee8091ae409a11277" translate="yes" xml:space="preserve">
          <source>In theory, the content of HTTP responses are protected by the Same Origin Policy: pages from one domain cannot get any pieces of information from pages on the other domain (unless explicitly allowed).</source>
          <target state="translated">理论上,HTTP响应的内容受同源政策的保护:一个域的页面不能从另一个域的页面获取任何信息(除非明确允许)。</target>
        </trans-unit>
        <trans-unit id="c01ca5858305e902adb7c735cb337c7e46db9b23" translate="yes" xml:space="preserve">
          <source>It prevents &lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;JSON hijacking&lt;/a&gt;, a major JSON security issue that is formally &lt;a href=&quot;https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed&quot;&gt;fixed&lt;/a&gt; in all major browsers &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;since 2011&lt;/a&gt; with ECMAScript 5.</source>
          <target state="translated">它可以防止&lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;JSON劫持&lt;/a&gt; ，这是&lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;自2011年以来&lt;/a&gt;使用ECMAScript 5在所有主要浏览器中正式&lt;a href=&quot;https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed&quot;&gt;修复&lt;/a&gt;的主要JSON安全问题。</target>
        </trans-unit>
        <trans-unit id="c7c40d576012cf240f7632ab339b57b595515add" translate="yes" xml:space="preserve">
          <source>It prevents disclosure of the response through JSON hijacking.</source>
          <target state="translated">它可以防止通过JSON劫持来泄露响应的信息。</target>
        </trans-unit>
        <trans-unit id="a1aa1b13e0d9fdf70db263078977f3d38acd3ad3" translate="yes" xml:space="preserve">
          <source>It prevents it from being used as the target of a simple &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. (Well, it doesn't prevent it, but it makes it unpleasant.)  That way bad guys can't just put that script tag in their own site and rely on an active session to make it possible to fetch your content.</source>
          <target state="translated">它防止将其用作简单 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记的目标。 （嗯，这并不能阻止它，但是它使它不愉快。）那样，坏蛋就不能只将脚本标记放在自己的站点中，而是依靠活动会话来获取内容。</target>
        </trans-unit>
        <trans-unit id="7ea6ab3ebd624cfe48a934a9c8d1f5a2b5da81f7" translate="yes" xml:space="preserve">
          <source>Making sure the JSON is not valid Javascript</source>
          <target state="translated">确保JSON不是有效的Javascript</target>
        </trans-unit>
        <trans-unit id="edf6e049119a5a0470202ae214dba539bbf2941d" translate="yes" xml:space="preserve">
          <source>Making sure the JSON never executes</source>
          <target state="translated">确保JSON从不执行</target>
        </trans-unit>
        <trans-unit id="febec8be0b81b2feb1513f23b1b0842cfda8281f" translate="yes" xml:space="preserve">
          <source>Note that this happens at the time the JSON is executed as Javascript, not at the time it's parsed.</source>
          <target state="translated">请注意,这发生在JSON作为Javascript执行时,而不是在解析时。</target>
        </trans-unit>
        <trans-unit id="68382c925cd44b6363a76a407b89bca9f818e2f7" translate="yes" xml:space="preserve">
          <source>Only a legitimate page could get the whole content, strip the &lt;code&gt;while(1);&lt;/code&gt;, and parse the remainder as JSON.</source>
          <target state="translated">除去 &lt;code&gt;while(1);&lt;/code&gt; 只有合法的页面才能获取全部内容。 ，并将其余部分解析为JSON。</target>
        </trans-unit>
        <trans-unit id="bc7cf8ff662f5a3091b16d09c3b12b6d71093ebd" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;Web Security Testing Cookbook: Systematic Techniques to Find Problems Fast&lt;/a&gt;</source>
          <target state="translated">参考： &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;Web安全测试手册：快速发现问题的系统技术&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9a6df7cbe191da1a26b102b682aa4681d0a0ec" translate="yes" xml:space="preserve">
          <source>Similar to the previous counter-measures, it makes sure that the JSON is never executed as Javascript.</source>
          <target state="translated">与之前的对策类似,它可以确保JSON永远不会被当作Javascript执行。</target>
        </trans-unit>
        <trans-unit id="19a1209ad05215641679ef27706ab76a7c14298b" translate="yes" xml:space="preserve">
          <source>Similarly, adding invalid tokens before the JSON, like &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;, makes sure that it is never executed.</source>
          <target state="translated">同样，在JSON之前添加无效令牌，例如 &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; ，以确保它永远不会执行。</target>
        </trans-unit>
        <trans-unit id="a8576bf9b39e4b58222cbecd8050077417f14c7d" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempted from the Same Origin Policy which is a security necessity in the web world, &lt;code&gt;while(1)&lt;/code&gt; when added to the JSON response prevents misuse of it in the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">由于 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记不受Web环境中安全性必需的Same Origin Policy的限制，因此 &lt;code&gt;while(1)&lt;/code&gt; 当添加到JSON响应时，可以防止在 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记中滥用它。</target>
        </trans-unit>
        <trans-unit id="265e18163ded129866441b9562b684e40cfa81d6" translate="yes" xml:space="preserve">
          <source>So, make sure you always return an Object at the top level of the response makes sure that the JSON is not valid Javascript, while still being valid JSON.</source>
          <target state="translated">所以,确保你总是在响应的最高层返回一个对象,确保JSON是无效的Javascript,而JSON仍然是有效的。</target>
        </trans-unit>
        <trans-unit id="47645ade00c4230d7c88790f7f1e2fffce64acd9" translate="yes" xml:space="preserve">
          <source>That would be to make it difficult for a third-party to insert the JSON response into an HTML document with the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. Remember that the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempt from the &lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;Same Origin Policy&lt;/a&gt;.</source>
          <target state="translated">这将使第三方很难使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签将JSON响应插入HTML文档中。 请记住， &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记不受&lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;Same Origin Policy约束&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c70b262e3848de4bc0df4a3158b105318dddf4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while(1);&lt;/code&gt; or &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; prevents this: an AJAX request at &lt;code&gt;mail.google.com&lt;/code&gt; will have full access to the text content, and can strip it away. But a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag insertion blindly executes the JavaScript without any processing, resulting in either an infinite loop or a syntax error.</source>
          <target state="translated">&lt;code&gt;while(1);&lt;/code&gt; 或 &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 阻止这种情况： &lt;code&gt;mail.google.com&lt;/code&gt; 上的AJAX请求将拥有对文本内容的完全访问权限，并可将其删除。 但是 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记插入会盲目执行JavaScript，而不进行任何处理，从而导致无限循环或语法错误。</target>
        </trans-unit>
        <trans-unit id="01c747e61f5bb1dd235f2fe00fa38dc12f026fe1" translate="yes" xml:space="preserve">
          <source>The OWASP way is less intrusive, as it needs no client library changes, and transfers valid JSON. It is unsure whether past or future browser bugs could defeat this, however.  As noted by @oriadam, it is unclear whether data could be leaked in a parse error through an error-handling or not (e.g. window.onerror).</source>
          <target state="translated">OWASP方式的侵入性较低,因为它不需要修改客户端库,并且传输有效的JSON。然而,不确定过去或未来的浏览器bug是否能打败这一点。正如@oriadam所指出的,目前还不清楚数据是否可以通过错误处理(例如window.onerror)在解析错误中泄露。</target>
        </trans-unit>
        <trans-unit id="0404af8312f4e69068ca7857605696398b6e0155" translate="yes" xml:space="preserve">
          <source>There are multiple countermeasures:</source>
          <target state="translated">有多种应对措施。</target>
        </trans-unit>
        <trans-unit id="3255cdcca3cabb924d221cf59beaf12a7c41cf73" translate="yes" xml:space="preserve">
          <source>Things like &lt;code&gt;for(;;);&lt;/code&gt; have been seen at Facebook for instance, with the same results.</source>
          <target state="translated">像 &lt;code&gt;for(;;);&lt;/code&gt; 之类的东西 例如在Facebook上看到的结果相同。</target>
        </trans-unit>
        <trans-unit id="91f4151f017e676f45a575b1c641b34a589d4d0e" translate="yes" xml:space="preserve">
          <source>This does not address the issue of &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;cross-site request forgery&lt;/a&gt;.</source>
          <target state="translated">这不能解决&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;跨站点请求伪造的问题&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e46ff1ede1332f3270709e81fead34240d725952" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;&lt;strong&gt;&lt;code&gt;OWASP&lt;/code&gt;&lt;/strong&gt; recommended way&lt;/a&gt; to protect from JSON hijacking and is the less intrusive one.</source>
          <target state="translated">这是&lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;&lt;strong&gt; &lt;code&gt;OWASP&lt;/code&gt; &lt;/strong&gt;建议的&lt;/a&gt;防止JSON劫持的方法，并且侵入性较小。</target>
        </trans-unit>
        <trans-unit id="a6e8debd00ab99c1f20dafceedfbe9a340387982" translate="yes" xml:space="preserve">
          <source>This is however valid JSON:</source>
          <target state="translated">但这是有效的JSON。</target>
        </trans-unit>
        <trans-unit id="65aee6c6c83a14d05ff8b42bdda59f2453e8b8c4" translate="yes" xml:space="preserve">
          <source>This is to ensure some other site can't do nasty tricks to try to steal your data. For example, by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;replacing the array constructor&lt;/a&gt;, then including this JSON URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, a malicious third-party site could steal the data from the JSON response. By putting a &lt;code&gt;while(1);&lt;/code&gt; at the start, the script will hang instead.</source>
          <target state="translated">这是为了确保其他某些网站无法采取令人讨厌的手段来窃取您的数据。 例如，通过&lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;替换数组构造函数&lt;/a&gt; ，然后通过 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记包括此JSON URL，恶意第三方站点可能会从JSON响应中窃取数据。 通过放置 &lt;code&gt;while(1);&lt;/code&gt; 在开始时，脚本将挂起。</target>
        </trans-unit>
        <trans-unit id="cd74173708ca6bae4ae52f64b0eac1a47f06f86c" translate="yes" xml:space="preserve">
          <source>Thus, if you visit an attacker's page, it couldn't read your email from gmail.com.</source>
          <target state="translated">因此,如果你访问攻击者的页面,它无法从gmail.com中读取你的邮件。</target>
        </trans-unit>
        <trans-unit id="a80832a90f0eb46f0620cb5802e9e519794d6d1a" translate="yes" xml:space="preserve">
          <source>What's going on here?</source>
          <target state="translated">这到底是怎么回事?</target>
        </trans-unit>
        <trans-unit id="32638f7cfa546de73f10b0ac2d66e66c0ee66d77" translate="yes" xml:space="preserve">
          <source>Why does Google prepend &lt;code&gt;while(1);&lt;/code&gt; to their (private) JSON responses?</source>
          <target state="translated">为什么Google会优先使用 &lt;code&gt;while(1);&lt;/code&gt; 他们的（私有）JSON响应？</target>
        </trans-unit>
        <trans-unit id="fb290a5cb43b280973a446bf92cdb413bcb39df7" translate="yes" xml:space="preserve">
          <source>Why does Google prepend while(1); to their JSON responses</source>
          <target state="translated">为什么Google在其JSON响应中加入了while(1);的前缀?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
