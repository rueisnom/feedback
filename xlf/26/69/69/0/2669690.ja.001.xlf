<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/2669690">
    <body>
      <group id="2669690">
        <trans-unit id="6ed88095f6356427e065e4f0da1dc4208b5b2eaa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;edit&lt;/em&gt; &amp;mdash; note the comment (and other answers). The issue has to do with subverted built-in facilities, specifically the &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; constructors. Those can be altered such that otherwise innocuous JSON, when parsed, could trigger attacker code.</source>
          <target state="translated">&lt;em&gt;編集&lt;/em&gt; &amp;mdash;コメント（およびその他の回答）を書き留めます。 問題は、破壊された組み込み機能、特に &lt;code&gt;Object&lt;/code&gt; および &lt;code&gt;Array&lt;/code&gt; コンストラクターに関係しています。 それらを変更して、そうでなければ無害なJSONが解析されたときに攻撃者のコードをトリガーする可能性があります。</target>
        </trans-unit>
        <trans-unit id="57fd21beefa78406c6c5367148ed26ac53b78c6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: as of 2019, many of the old vulnerabilities that lead to the preventative measures discussed in this question are no longer an issue in modern browsers.  I'll leave the answer below as a historical curiosity, but really the whole topic has changed radically since 2010 (!!) when this was asked.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt; ：2019年以降、この質問で説明されている予防策につながる古い脆弱性の多くは、最新のブラウザーでは問題ではなくなりました。 以下の答えは歴史的な好奇心として残しておきますが、実際にはトピック全体が2010年（!!）に質問されてから根本的に変更されています。</target>
        </trans-unit>
        <trans-unit id="71b65b72e474c79efaa1968eb5081ff39c79eee5" translate="yes" xml:space="preserve">
          <source>A same-site request using XHR and a separate JSON parser, on the other hand, can easily ignore the &lt;code&gt;while(1);&lt;/code&gt; prefix.</source>
          <target state="translated">一方、XHRと個別のJSONパーサーを使用する同じサイトのリクエストは、 &lt;code&gt;while(1);&lt;/code&gt; 簡単に無視できます。 接頭辞。</target>
        </trans-unit>
        <trans-unit id="28c456b213ff34c390dcff80ef63fb23c1ce5122" translate="yes" xml:space="preserve">
          <source>A valid JSON object, when not enclosed by anything, is not valid in Javascript:</source>
          <target state="translated">何も囲まれていない状態で有効なJSONオブジェクトは、Javascriptでは有効ではありません。</target>
        </trans-unit>
        <trans-unit id="7daffc89a7b8aec7532d4838fa6a40f1f70b311b" translate="yes" xml:space="preserve">
          <source>After authentication is in place, JSON hijacking protection can take a
  variety of forms. Google appends &lt;strong&gt;while(1)&lt;/strong&gt; into their JSON data, so
  that if any malicious script evaluates it, the malicious script enters
  an infinite loop.</source>
          <target state="translated">認証が行われると、JSONハイジャック保護はさまざまな形になります。 Googleは&lt;strong&gt;while（1）&lt;/strong&gt;をJSONデータに追加するため、悪意のあるスクリプトがそれを評価した場合、悪意のあるスクリプトは無限ループに入ります。</target>
        </trans-unit>
        <trans-unit id="7be6a6f5a84ff1bd0bc12a6d53c2432306a8338c" translate="yes" xml:space="preserve">
          <source>Always return JSON with an Object on the outside</source>
          <target state="translated">常に外側にObjectを置いてJSONを返す</target>
        </trans-unit>
        <trans-unit id="38657cd1deca0c38601450000e8c4ee8e3254dce" translate="yes" xml:space="preserve">
          <source>An attacker can request pages on other domains on your behalf, e.g. by using a &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag, but it can't get any information about the result (headers, contents).</source>
          <target state="translated">攻撃者は、 &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; タグを使用するなどして、ユーザーに代わって他のドメインのページをリクエストできますが、結果（ヘッダー、コンテンツ）に関する情報は取得できません。</target>
        </trans-unit>
        <trans-unit id="4076d258e698a41cd58be09271d7235422cbb6bf" translate="yes" xml:space="preserve">
          <source>As noted by @hvd in the comments, the empty object &lt;code&gt;{}&lt;/code&gt; is valid Javascript, and knowing the object is empty may itself be valuable information.</source>
          <target state="translated">コメントの@hvdで指摘されているように、空のオブジェクト &lt;code&gt;{}&lt;/code&gt; は有効なJavascriptであり、オブジェクトが空であることを知ること自体が貴重な情報になる場合があります。</target>
        </trans-unit>
        <trans-unit id="88546fce7b19dd78f569d725399c113f191387f3" translate="yes" xml:space="preserve">
          <source>Both methods require server-side changes to avoid developers from accidentally sending vulnerable JSON.</source>
          <target state="translated">どちらの方法も、開発者が誤って脆弱性のあるJSONを送信しないようにするために、サーバー側の変更が必要です。</target>
        </trans-unit>
        <trans-unit id="7648f1875c9c0f61d7f7135068a8d63184cda276" translate="yes" xml:space="preserve">
          <source>By placing a &lt;code&gt;while(1);&lt;/code&gt; statement before the JSON data, Google makes sure that the JSON data is never executed as Javascript.</source>
          <target state="translated">&lt;code&gt;while(1);&lt;/code&gt; 配置することにより、 JSONデータの前のステートメントでは、GoogleはJSONデータがJavaScriptとして実行されないようにします。</target>
        </trans-unit>
        <trans-unit id="7ff41c40cdaa12bb4b0f0be685d8174ce53a7093" translate="yes" xml:space="preserve">
          <source>Comparison of above methods</source>
          <target state="translated">上記の方法の比較</target>
        </trans-unit>
        <trans-unit id="5cc0ef8ebf1d3e8d4667d491bff6ea11477f47b4" translate="yes" xml:space="preserve">
          <source>Contrived example: say Google has a URL like &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; which returns the first 50 messages of your inbox in JSON format. Evil websites on other domains can't make AJAX requests to get this data due to the same-origin policy, but they can include the URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. The URL is visited with &lt;em&gt;your&lt;/em&gt; cookies, and by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;overriding the global array constructor or accessor methods&lt;/a&gt; they can have a method called whenever an object (array or hash) attribute is set, allowing them to read the JSON content.</source>
          <target state="translated">不自然な例：Googleに &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; のようなURLがあり、受信トレイの最初の50メッセージをJSON形式で返すとします。 他のドメインの悪質なWebサイトは、同じ生成元のポリシーのため、このデータを取得するためにAJAX要求を行うことができませんが、 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを介してURLを含めることができます。 URLはCookieでアクセスされ&lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;、グローバル配列コンストラクターまたはアクセサーメソッド&lt;/a&gt;をオーバーライドすることで、オブジェクト（配列またはハッシュ）属性が設定されるたびに呼び出されるメソッドを使用して、JSONコンテンツを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="0a899fbe9a5bae6b89125ccbf8c6667d4af13c9e" translate="yes" xml:space="preserve">
          <source>Except that when using a script tag to request JSON content, the JSON is executed as Javascript in an attacker's controlled environment. If the attacker can replace the Array or Object constructor or some other method used during object construction, anything in the JSON would pass through the attacker's code, and be disclosed.</source>
          <target state="translated">スクリプトタグを使用してJSONの内容を要求する場合、攻撃者の制御された環境でJavascriptとしてJSONが実行されることを除いては、JSONの内容は攻撃者の制御された環境で実行されます。攻撃者がArrayやObjectのコンストラクタやオブジェクト構築時に使用される何らかのメソッドを置き換えることができれば、JSONの中の何かが攻撃者のコードを通過し、公開されることになります。</target>
        </trans-unit>
        <trans-unit id="03fdac45ae96e608cfb4e1753008813ff5f0bb85" translate="yes" xml:space="preserve">
          <source>For example, here's a response while turning a calendar on and off in &lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;Google Calendar&lt;/a&gt;:</source>
          <target state="translated">たとえば、 &lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;Googleカレンダーでカレンダーを&lt;/a&gt;オンまたはオフにしたときの応答は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9afbbc0bacc7b9d361b66d602e97e7c70b23f706" translate="yes" xml:space="preserve">
          <source>Google's way requires the client library for it to support automatic de-serialization and can be considered to be safer about browser bugs.</source>
          <target state="translated">Googleの方法は、自動デシリアライズをサポートするためにクライアントライブラリを必要とし、ブラウザのバグについてはより安全であると考えることができます。</target>
        </trans-unit>
        <trans-unit id="23ad849cb3512da4fc03ab0386e87a3b5900544d" translate="yes" xml:space="preserve">
          <source>I would assume this is to prevent people from doing an &lt;code&gt;eval()&lt;/code&gt; on it, but all you'd really have to do is replace the &lt;code&gt;while&lt;/code&gt; and then you'd be set. I would assume the eval prevention is to make sure people write safe JSON parsing code.</source>
          <target state="translated">これは、人々が &lt;code&gt;eval()&lt;/code&gt; を実行できないようにするためだと思いますが、実際に行う必要があるのは、 &lt;code&gt;while&lt;/code&gt; を置き換えるだけで、設定されます。 評価の防止は、人々が安全なJSON解析コードを書くようにすることだと思います。</target>
        </trans-unit>
        <trans-unit id="9ec8b77b7bc0a99ad31f1d55c0d2ee7330d63d84" translate="yes" xml:space="preserve">
          <source>I've seen this used in a couple of other places, too, but a lot more so with Google (Mail, Calendar, Contacts, etc.) Strangely enough, &lt;a href=&quot;https://www.google.com/docs/about/&quot;&gt;Google Docs&lt;/a&gt; starts with &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; instead, and Google Contacts seems to start with &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">これは他のいくつかの場所でも使用されているのを見たことがありますが、Google（メール、カレンダー、連絡先など）の方がはるかに使用されています。奇妙なことに、 &lt;a href=&quot;https://www.google.com/docs/about/&quot;&gt;Googleドキュメント&lt;/a&gt;は &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 始まり、 &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &amp;amp;&amp;amp;&amp;amp; START &amp;amp;&amp;amp;&amp;amp; 。</target>
        </trans-unit>
        <trans-unit id="82ec8480b6d03af801f80b5ee8091ae409a11277" translate="yes" xml:space="preserve">
          <source>In theory, the content of HTTP responses are protected by the Same Origin Policy: pages from one domain cannot get any pieces of information from pages on the other domain (unless explicitly allowed).</source>
          <target state="translated">理論的には、HTTPレスポンスの内容は同一オリジンポリシーによって保護されています:あるドメインのページは、明示的に許可されていない限り、他のドメインのページから情報の断片を取得することはできません。</target>
        </trans-unit>
        <trans-unit id="c01ca5858305e902adb7c735cb337c7e46db9b23" translate="yes" xml:space="preserve">
          <source>It prevents &lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;JSON hijacking&lt;/a&gt;, a major JSON security issue that is formally &lt;a href=&quot;https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed&quot;&gt;fixed&lt;/a&gt; in all major browsers &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;since 2011&lt;/a&gt; with ECMAScript 5.</source>
          <target state="translated">&lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;JSONハイジャックを&lt;/a&gt;防ぎます。これは、 JSONの主要なセキュリティ問題であり&lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;、2011年以降&lt;/a&gt; ECMAScript 5を使用してすべての主要なブラウザーで正式に&lt;a href=&quot;https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed&quot;&gt;修正さ&lt;/a&gt;れています。</target>
        </trans-unit>
        <trans-unit id="c7c40d576012cf240f7632ab339b57b595515add" translate="yes" xml:space="preserve">
          <source>It prevents disclosure of the response through JSON hijacking.</source>
          <target state="translated">JSONハイジャックによるレスポンスの公開を防ぎます。</target>
        </trans-unit>
        <trans-unit id="a1aa1b13e0d9fdf70db263078977f3d38acd3ad3" translate="yes" xml:space="preserve">
          <source>It prevents it from being used as the target of a simple &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. (Well, it doesn't prevent it, but it makes it unpleasant.)  That way bad guys can't just put that script tag in their own site and rely on an active session to make it possible to fetch your content.</source>
          <target state="translated">単純な &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグのターゲットとして使用されるのを防ぎます。 （まあ、それはそれを妨げるものではありませんが、それは不愉快なことです。）そのようにして、悪意のある人は自分のサイトにそのスクリプトタグを置くだけでなく、あなたのコンテンツをフェッチすることを可能にするためにアクティブなセッションに頼ることはできません。</target>
        </trans-unit>
        <trans-unit id="7ea6ab3ebd624cfe48a934a9c8d1f5a2b5da81f7" translate="yes" xml:space="preserve">
          <source>Making sure the JSON is not valid Javascript</source>
          <target state="translated">JSONが有効なJavascriptでないことを確認する</target>
        </trans-unit>
        <trans-unit id="edf6e049119a5a0470202ae214dba539bbf2941d" translate="yes" xml:space="preserve">
          <source>Making sure the JSON never executes</source>
          <target state="translated">JSONが実行されないようにする</target>
        </trans-unit>
        <trans-unit id="febec8be0b81b2feb1513f23b1b0842cfda8281f" translate="yes" xml:space="preserve">
          <source>Note that this happens at the time the JSON is executed as Javascript, not at the time it's parsed.</source>
          <target state="translated">これは、JSONがパースされた時ではなく、Javascriptとして実行された時に発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="68382c925cd44b6363a76a407b89bca9f818e2f7" translate="yes" xml:space="preserve">
          <source>Only a legitimate page could get the whole content, strip the &lt;code&gt;while(1);&lt;/code&gt;, and parse the remainder as JSON.</source>
          <target state="translated">正当なページだけがコンテンツ全体を取得でき、 &lt;code&gt;while(1);&lt;/code&gt; 、残りをJSONとして解析します。</target>
        </trans-unit>
        <trans-unit id="bc7cf8ff662f5a3091b16d09c3b12b6d71093ebd" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;Web Security Testing Cookbook: Systematic Techniques to Find Problems Fast&lt;/a&gt;</source>
          <target state="translated">参照： &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;Webセキュリティテストクックブック：問題をすばやく見つけるための体系的な手法&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9a6df7cbe191da1a26b102b682aa4681d0a0ec" translate="yes" xml:space="preserve">
          <source>Similar to the previous counter-measures, it makes sure that the JSON is never executed as Javascript.</source>
          <target state="translated">先ほどの対策と同様に、JavascriptとしてJSONを絶対に実行しないようにしてくれます。</target>
        </trans-unit>
        <trans-unit id="19a1209ad05215641679ef27706ab76a7c14298b" translate="yes" xml:space="preserve">
          <source>Similarly, adding invalid tokens before the JSON, like &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;, makes sure that it is never executed.</source>
          <target state="translated">同様に、 &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; ように、JSONの前に無効なトークンを追加すると、実行されないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="a8576bf9b39e4b58222cbecd8050077417f14c7d" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempted from the Same Origin Policy which is a security necessity in the web world, &lt;code&gt;while(1)&lt;/code&gt; when added to the JSON response prevents misuse of it in the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグはWebの世界でセキュリティの必要性であるSame Origin Policyから除外されているため、JSON応答に追加された場合、 &lt;code&gt;while(1)&lt;/code&gt; は &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグでの誤用を防ぎます。</target>
        </trans-unit>
        <trans-unit id="265e18163ded129866441b9562b684e40cfa81d6" translate="yes" xml:space="preserve">
          <source>So, make sure you always return an Object at the top level of the response makes sure that the JSON is not valid Javascript, while still being valid JSON.</source>
          <target state="translated">そのため、レスポンスのトップレベルで常にObjectを返すようにすることで、有効なJSONでありながら、有効なJavascriptではないことを確認することができます。</target>
        </trans-unit>
        <trans-unit id="47645ade00c4230d7c88790f7f1e2fffce64acd9" translate="yes" xml:space="preserve">
          <source>That would be to make it difficult for a third-party to insert the JSON response into an HTML document with the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. Remember that the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempt from the &lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;Same Origin Policy&lt;/a&gt;.</source>
          <target state="translated">これは、サードパーティが &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを使用してJSON応答をHTMLドキュメントに挿入することを困難にすることになります。 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;同一生成元ポリシー&lt;/a&gt;から除外されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c70b262e3848de4bc0df4a3158b105318dddf4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while(1);&lt;/code&gt; or &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; prevents this: an AJAX request at &lt;code&gt;mail.google.com&lt;/code&gt; will have full access to the text content, and can strip it away. But a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag insertion blindly executes the JavaScript without any processing, resulting in either an infinite loop or a syntax error.</source>
          <target state="translated">&lt;code&gt;while(1);&lt;/code&gt; または &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; はこれを防止します。mail.google.comでのAJAXリクエストはテキストコンテンツへのフルアクセスを持ち、それを取り除くことができます。 ただし、 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを挿入すると、JavaScriptが何も処理されずに盲目的に実行され、無限ループまたは構文エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="01c747e61f5bb1dd235f2fe00fa38dc12f026fe1" translate="yes" xml:space="preserve">
          <source>The OWASP way is less intrusive, as it needs no client library changes, and transfers valid JSON. It is unsure whether past or future browser bugs could defeat this, however.  As noted by @oriadam, it is unclear whether data could be leaked in a parse error through an error-handling or not (e.g. window.onerror).</source>
          <target state="translated">OWASP の方法は、クライアントライブラリの変更を必要とせず、有効な JSON を転送するので、押しつけがましいものではありません。しかし、過去や将来のブラウザのバグがこれを打ち負かすかどうかは不明です。oriadam さんが指摘されているように、データがエラー処理(例えば window.onerror など)を介してパースエラーの中に漏れるかどうかは不明です。</target>
        </trans-unit>
        <trans-unit id="0404af8312f4e69068ca7857605696398b6e0155" translate="yes" xml:space="preserve">
          <source>There are multiple countermeasures:</source>
          <target state="translated">対策は複数あります。</target>
        </trans-unit>
        <trans-unit id="3255cdcca3cabb924d221cf59beaf12a7c41cf73" translate="yes" xml:space="preserve">
          <source>Things like &lt;code&gt;for(;;);&lt;/code&gt; have been seen at Facebook for instance, with the same results.</source>
          <target state="translated">&lt;code&gt;for(;;);&lt;/code&gt; のようなもの たとえば、Facebookでも同じ結果が出ています。</target>
        </trans-unit>
        <trans-unit id="91f4151f017e676f45a575b1c641b34a589d4d0e" translate="yes" xml:space="preserve">
          <source>This does not address the issue of &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;cross-site request forgery&lt;/a&gt;.</source>
          <target state="translated">これは、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;クロスサイトリクエストフォージェリの&lt;/a&gt;問題には対応していません。</target>
        </trans-unit>
        <trans-unit id="e46ff1ede1332f3270709e81fead34240d725952" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;&lt;strong&gt;&lt;code&gt;OWASP&lt;/code&gt;&lt;/strong&gt; recommended way&lt;/a&gt; to protect from JSON hijacking and is the less intrusive one.</source>
          <target state="translated">これは、JSONハイジャックから保護するための&lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;&lt;strong&gt; &lt;code&gt;OWASP&lt;/code&gt; &lt;/strong&gt;推奨の方法&lt;/a&gt;であり、それほど煩わしくない方法です。</target>
        </trans-unit>
        <trans-unit id="a6e8debd00ab99c1f20dafceedfbe9a340387982" translate="yes" xml:space="preserve">
          <source>This is however valid JSON:</source>
          <target state="translated">しかし、これは有効なJSONです。</target>
        </trans-unit>
        <trans-unit id="65aee6c6c83a14d05ff8b42bdda59f2453e8b8c4" translate="yes" xml:space="preserve">
          <source>This is to ensure some other site can't do nasty tricks to try to steal your data. For example, by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;replacing the array constructor&lt;/a&gt;, then including this JSON URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, a malicious third-party site could steal the data from the JSON response. By putting a &lt;code&gt;while(1);&lt;/code&gt; at the start, the script will hang instead.</source>
          <target state="translated">これは、他のサイトがデータを盗もうとする悪質なトリックを実行できないようにするためです。 たとえば&lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;、配列コンストラクターを置き換え、&lt;/a&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを介してこのJSON URLを含めることにより、悪意のあるサードパーティのサイトがJSON応答からデータを盗む可能性があります。 &lt;code&gt;while(1);&lt;/code&gt; 置くことによって; 最初は、スクリプトは代わりにハングします。</target>
        </trans-unit>
        <trans-unit id="cd74173708ca6bae4ae52f64b0eac1a47f06f86c" translate="yes" xml:space="preserve">
          <source>Thus, if you visit an attacker's page, it couldn't read your email from gmail.com.</source>
          <target state="translated">このように、攻撃者のページにアクセスすると、gmail.comからのメールを読むことができませんでした。</target>
        </trans-unit>
        <trans-unit id="a80832a90f0eb46f0620cb5802e9e519794d6d1a" translate="yes" xml:space="preserve">
          <source>What's going on here?</source>
          <target state="translated">どうしたんだ?</target>
        </trans-unit>
        <trans-unit id="32638f7cfa546de73f10b0ac2d66e66c0ee66d77" translate="yes" xml:space="preserve">
          <source>Why does Google prepend &lt;code&gt;while(1);&lt;/code&gt; to their (private) JSON responses?</source>
          <target state="translated">なぜGoogleは &lt;code&gt;while(1);&lt;/code&gt; 付加するのですか？ 彼らの（プライベート）JSON応答に？</target>
        </trans-unit>
        <trans-unit id="fb290a5cb43b280973a446bf92cdb413bcb39df7" translate="yes" xml:space="preserve">
          <source>Why does Google prepend while(1); to their JSON responses</source>
          <target state="translated">なぜ Google は JSON レスポンスに while(1);を付加するのか?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
