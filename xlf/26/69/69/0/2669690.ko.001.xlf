<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2669690">
    <body>
      <group id="2669690">
        <trans-unit id="6ed88095f6356427e065e4f0da1dc4208b5b2eaa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;edit&lt;/em&gt; &amp;mdash; note the comment (and other answers). The issue has to do with subverted built-in facilities, specifically the &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; constructors. Those can be altered such that otherwise innocuous JSON, when parsed, could trigger attacker code.</source>
          <target state="translated">&lt;em&gt;편집&lt;/em&gt; &amp;mdash; 주석 (및 기타 답변)을 기록합니다. 문제는 전복 된 내장 기능, 특히 &lt;code&gt;Object&lt;/code&gt; 및 &lt;code&gt;Array&lt;/code&gt; 생성자와 관련이 있습니다. 그렇지 않으면 무해한 JSON이 구문 분석 될 때 공격자 코드를 트리거 할 수 있도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57fd21beefa78406c6c5367148ed26ac53b78c6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: as of 2019, many of the old vulnerabilities that lead to the preventative measures discussed in this question are no longer an issue in modern browsers.  I'll leave the answer below as a historical curiosity, but really the whole topic has changed radically since 2010 (!!) when this was asked.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 2019 년 현재이 질문에서 논의 된 예방 조치로 이어지는 많은 오래된 취약점은 더 이상 최신 브라우저에서 문제가되지 않습니다. 아래의 답변을 역사적 호기심으로 남겨 두겠습니다. 그러나 이것이 요청되었을 때 실제로 모든 주제는 2010 년 이후 급격히 변했습니다 (!!).</target>
        </trans-unit>
        <trans-unit id="71b65b72e474c79efaa1968eb5081ff39c79eee5" translate="yes" xml:space="preserve">
          <source>A same-site request using XHR and a separate JSON parser, on the other hand, can easily ignore the &lt;code&gt;while(1);&lt;/code&gt; prefix.</source>
          <target state="translated">반면에 XHR과 별도의 JSON 파서를 사용하는 동일한 사이트 요청은 &lt;code&gt;while(1);&lt;/code&gt; 쉽게 무시할 수 있습니다 . 접두사.</target>
        </trans-unit>
        <trans-unit id="28c456b213ff34c390dcff80ef63fb23c1ce5122" translate="yes" xml:space="preserve">
          <source>A valid JSON object, when not enclosed by anything, is not valid in Javascript:</source>
          <target state="translated">어떤 것으로 묶이지 않은 유효한 JSON 객체는 Javascript에서 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7daffc89a7b8aec7532d4838fa6a40f1f70b311b" translate="yes" xml:space="preserve">
          <source>After authentication is in place, JSON hijacking protection can take a
  variety of forms. Google appends &lt;strong&gt;while(1)&lt;/strong&gt; into their JSON data, so
  that if any malicious script evaluates it, the malicious script enters
  an infinite loop.</source>
          <target state="translated">인증이 완료되면 JSON 하이재킹 보호는 다양한 형태를 취할 수 있습니다. Google은 &lt;strong&gt;while (1)&lt;/strong&gt; 을 JSON 데이터에 추가하여 악의적 인 스크립트가 평가하면 악의적 인 스크립트가 무한 루프에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="7be6a6f5a84ff1bd0bc12a6d53c2432306a8338c" translate="yes" xml:space="preserve">
          <source>Always return JSON with an Object on the outside</source>
          <target state="translated">항상 외부에 객체가있는 JSON을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="38657cd1deca0c38601450000e8c4ee8e3254dce" translate="yes" xml:space="preserve">
          <source>An attacker can request pages on other domains on your behalf, e.g. by using a &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag, but it can't get any information about the result (headers, contents).</source>
          <target state="translated">공격자는 &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 태그를 사용하여 사용자를 대신하여 다른 도메인의 페이지를 요청할 수 있지만 결과에 대한 정보 (헤더, 내용)는 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4076d258e698a41cd58be09271d7235422cbb6bf" translate="yes" xml:space="preserve">
          <source>As noted by @hvd in the comments, the empty object &lt;code&gt;{}&lt;/code&gt; is valid Javascript, and knowing the object is empty may itself be valuable information.</source>
          <target state="translated">주석에서 @hvd에 의해 언급 된 바와 같이, 빈 객체 &lt;code&gt;{}&lt;/code&gt; 는 유효한 Javascript이며, 객체가 비어 있다는 것을 알면 그 자체가 유용한 정보 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88546fce7b19dd78f569d725399c113f191387f3" translate="yes" xml:space="preserve">
          <source>Both methods require server-side changes to avoid developers from accidentally sending vulnerable JSON.</source>
          <target state="translated">두 방법 모두 개발자가 실수로 취약한 JSON을 전송하지 않도록 서버 측 변경이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7648f1875c9c0f61d7f7135068a8d63184cda276" translate="yes" xml:space="preserve">
          <source>By placing a &lt;code&gt;while(1);&lt;/code&gt; statement before the JSON data, Google makes sure that the JSON data is never executed as Javascript.</source>
          <target state="translated">&lt;code&gt;while(1);&lt;/code&gt; 을 배치함으로써 ; Google은 JSON 데이터 이전에 Google이 JSON 데이터를 Javascript로 실행하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="7ff41c40cdaa12bb4b0f0be685d8174ce53a7093" translate="yes" xml:space="preserve">
          <source>Comparison of above methods</source>
          <target state="translated">위의 방법 비교</target>
        </trans-unit>
        <trans-unit id="5cc0ef8ebf1d3e8d4667d491bff6ea11477f47b4" translate="yes" xml:space="preserve">
          <source>Contrived example: say Google has a URL like &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; which returns the first 50 messages of your inbox in JSON format. Evil websites on other domains can't make AJAX requests to get this data due to the same-origin policy, but they can include the URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. The URL is visited with &lt;em&gt;your&lt;/em&gt; cookies, and by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;overriding the global array constructor or accessor methods&lt;/a&gt; they can have a method called whenever an object (array or hash) attribute is set, allowing them to read the JSON content.</source>
          <target state="translated">고안된 예 : Google에 &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; 와 같은 URL이 있으며받은 편지함의 처음 50 개 메시지를 JSON 형식으로 반환합니다. 다른 도메인의 악의적 인 웹 사이트는 동일한 출처 정책으로 인해이 데이터를 얻기 위해 AJAX 요청을 할 수 없지만 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 통해 URL을 포함 할 수 있습니다. URL은 쿠키와 함께 방문되며 &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;전역 배열 생성자 또는 접근 자 메서드&lt;/a&gt; 를 재정 의하여 객체 (배열 또는 해시) 속성이 설정 될 때마다 호출 된 메서드를 가질 수 있으므로 JSON 콘텐츠를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a899fbe9a5bae6b89125ccbf8c6667d4af13c9e" translate="yes" xml:space="preserve">
          <source>Except that when using a script tag to request JSON content, the JSON is executed as Javascript in an attacker's controlled environment. If the attacker can replace the Array or Object constructor or some other method used during object construction, anything in the JSON would pass through the attacker's code, and be disclosed.</source>
          <target state="translated">스크립트 태그를 사용하여 JSON 컨텐츠를 요청하는 경우를 제외하고 JSON은 공격자의 제어 환경에서 Javascript로 실행됩니다. 공격자가 Array 또는 Object 생성자 또는 객체 생성 중에 사용 된 다른 방법을 대체 할 수 있으면 JSON의 모든 항목이 침입자의 코드를 통과하여 공개됩니다.</target>
        </trans-unit>
        <trans-unit id="03fdac45ae96e608cfb4e1753008813ff5f0bb85" translate="yes" xml:space="preserve">
          <source>For example, here's a response while turning a calendar on and off in &lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;Google Calendar&lt;/a&gt;:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;Google 캘린더&lt;/a&gt; 에서 캘린더를 켜고 끄는 동안의 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9afbbc0bacc7b9d361b66d602e97e7c70b23f706" translate="yes" xml:space="preserve">
          <source>Google's way requires the client library for it to support automatic de-serialization and can be considered to be safer about browser bugs.</source>
          <target state="translated">구글의 방법은 클라이언트 라이브러리가 자동 역 직렬화를 지원하고 브라우저 버그에 대해 더 안전한 것으로 간주 될 수 있도록 클라이언트 라이브러리를 필요로한다.</target>
        </trans-unit>
        <trans-unit id="23ad849cb3512da4fc03ab0386e87a3b5900544d" translate="yes" xml:space="preserve">
          <source>I would assume this is to prevent people from doing an &lt;code&gt;eval()&lt;/code&gt; on it, but all you'd really have to do is replace the &lt;code&gt;while&lt;/code&gt; and then you'd be set. I would assume the eval prevention is to make sure people write safe JSON parsing code.</source>
          <target state="translated">나는 이것이 사람들이 &lt;code&gt;eval()&lt;/code&gt; 을하지 못하게하는 것이라고 가정하지만 실제로해야 할 일은 &lt;code&gt;while&lt;/code&gt; 을 바꾸고 설정하는 것입니다. 나는 사람들이 안전한 JSON 파싱 코드를 작성하게하는 것이 평가 방지라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9ec8b77b7bc0a99ad31f1d55c0d2ee7330d63d84" translate="yes" xml:space="preserve">
          <source>I've seen this used in a couple of other places, too, but a lot more so with Google (Mail, Calendar, Contacts, etc.) Strangely enough, &lt;a href=&quot;https://www.google.com/docs/about/&quot;&gt;Google Docs&lt;/a&gt; starts with &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; instead, and Google Contacts seems to start with &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">나는 이것을 다른 두 곳에서도 사용하는 것을 보았지만 Google (메일, 캘린더, 연락처 등)에서도 훨씬 더 그렇습니다. 이상하게도 &lt;a href=&quot;https://www.google.com/docs/about/&quot;&gt;Google 문서&lt;/a&gt; 는 &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 로 시작하고 Google 주소록은 시작하는 것처럼 보입니다. &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &amp;amp;&amp;amp;&amp;amp; START &amp;amp;&amp;amp;&amp;amp; .</target>
        </trans-unit>
        <trans-unit id="82ec8480b6d03af801f80b5ee8091ae409a11277" translate="yes" xml:space="preserve">
          <source>In theory, the content of HTTP responses are protected by the Same Origin Policy: pages from one domain cannot get any pieces of information from pages on the other domain (unless explicitly allowed).</source>
          <target state="translated">이론적으로 HTTP 응답의 내용은 동일한 출처 정책에 의해 보호됩니다. 한 도메인의 페이지는 명시 적으로 허용되지 않는 한 다른 도메인의 페이지에서 정보를 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c01ca5858305e902adb7c735cb337c7e46db9b23" translate="yes" xml:space="preserve">
          <source>It prevents &lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;JSON hijacking&lt;/a&gt;, a major JSON security issue that is formally &lt;a href=&quot;https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed&quot;&gt;fixed&lt;/a&gt; in all major browsers &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;since 2011&lt;/a&gt; with ECMAScript 5.</source>
          <target state="translated">ECMAScript 5를 사용하여 &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;2011 년 이후&lt;/a&gt; 모든 주요 브라우저에서 공식적으로 해결되는 주요 JSON 보안 문제인 &lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;JSON 하이재킹을&lt;/a&gt; 방지합니다.</target>
        </trans-unit>
        <trans-unit id="c7c40d576012cf240f7632ab339b57b595515add" translate="yes" xml:space="preserve">
          <source>It prevents disclosure of the response through JSON hijacking.</source>
          <target state="translated">JSON 하이재킹을 통한 응답 공개를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="a1aa1b13e0d9fdf70db263078977f3d38acd3ad3" translate="yes" xml:space="preserve">
          <source>It prevents it from being used as the target of a simple &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. (Well, it doesn't prevent it, but it makes it unpleasant.)  That way bad guys can't just put that script tag in their own site and rely on an active session to make it possible to fetch your content.</source>
          <target state="translated">간단한 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그의 대상으로 사용되지 않습니다. (잘 막지는 않지만 불쾌하게 만듭니다.) 그렇게 나쁜 사람들은 자신의 사이트에 해당 스크립트 태그를 넣을 수 없으며 콘텐츠를 가져올 수 있도록 활성 세션에 의존 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ea6ab3ebd624cfe48a934a9c8d1f5a2b5da81f7" translate="yes" xml:space="preserve">
          <source>Making sure the JSON is not valid Javascript</source>
          <target state="translated">JSON이 유효한 Javascript가 아닌지 확인</target>
        </trans-unit>
        <trans-unit id="edf6e049119a5a0470202ae214dba539bbf2941d" translate="yes" xml:space="preserve">
          <source>Making sure the JSON never executes</source>
          <target state="translated">JSON이 절대로 실행되지 않도록 확인</target>
        </trans-unit>
        <trans-unit id="febec8be0b81b2feb1513f23b1b0842cfda8281f" translate="yes" xml:space="preserve">
          <source>Note that this happens at the time the JSON is executed as Javascript, not at the time it's parsed.</source>
          <target state="translated">이는 JSON이 구문 분석 될 때가 아니라 Javascript로 실행될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68382c925cd44b6363a76a407b89bca9f818e2f7" translate="yes" xml:space="preserve">
          <source>Only a legitimate page could get the whole content, strip the &lt;code&gt;while(1);&lt;/code&gt;, and parse the remainder as JSON.</source>
          <target state="translated">합법적 인 페이지 만 전체 내용을 얻을 수 있으며 &lt;code&gt;while(1);&lt;/code&gt; 제거하십시오 . 나머지를 JSON으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="bc7cf8ff662f5a3091b16d09c3b12b6d71093ebd" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;Web Security Testing Cookbook: Systematic Techniques to Find Problems Fast&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;웹 보안 테스팅 요리 책 : 문제를 빨리 찾아내는 체계적인 기술&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9a6df7cbe191da1a26b102b682aa4681d0a0ec" translate="yes" xml:space="preserve">
          <source>Similar to the previous counter-measures, it makes sure that the JSON is never executed as Javascript.</source>
          <target state="translated">이전 대책과 마찬가지로 JSON이 Javascript로 실행되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="19a1209ad05215641679ef27706ab76a7c14298b" translate="yes" xml:space="preserve">
          <source>Similarly, adding invalid tokens before the JSON, like &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;, makes sure that it is never executed.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 와 같이 JSON 앞에 유효하지 않은 토큰을 추가하면 절대 토큰이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8576bf9b39e4b58222cbecd8050077417f14c7d" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempted from the Same Origin Policy which is a security necessity in the web world, &lt;code&gt;while(1)&lt;/code&gt; when added to the JSON response prevents misuse of it in the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그는 웹 세계에서 보안이 필요한 동일 출처 정책에서 제외되므로 &lt;code&gt;while(1)&lt;/code&gt; JSON 응답에 추가하면 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그에서 오용이 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="265e18163ded129866441b9562b684e40cfa81d6" translate="yes" xml:space="preserve">
          <source>So, make sure you always return an Object at the top level of the response makes sure that the JSON is not valid Javascript, while still being valid JSON.</source>
          <target state="translated">따라서 응답의 최상위 수준에서 항상 Object를 반환해야 JSON이 유효한 JSON이면서 JSON이 유효한 Javascript가 아닌지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47645ade00c4230d7c88790f7f1e2fffce64acd9" translate="yes" xml:space="preserve">
          <source>That would be to make it difficult for a third-party to insert the JSON response into an HTML document with the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. Remember that the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempt from the &lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;Same Origin Policy&lt;/a&gt;.</source>
          <target state="translated">이는 타사가 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 사용하여 JSON 응답을 HTML 문서에 삽입하는 것을 어렵게합니다. &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;동일한 오리진 정책&lt;/a&gt; 에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="c70b262e3848de4bc0df4a3158b105318dddf4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while(1);&lt;/code&gt; or &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; prevents this: an AJAX request at &lt;code&gt;mail.google.com&lt;/code&gt; will have full access to the text content, and can strip it away. But a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag insertion blindly executes the JavaScript without any processing, resulting in either an infinite loop or a syntax error.</source>
          <target state="translated">&lt;code&gt;while(1);&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 는이를 방지합니다. &lt;code&gt;mail.google.com&lt;/code&gt; 의 AJAX 요청은 텍스트 내용에 대한 모든 액세스 권한을 가지며이를 제거 할 수 있습니다. 그러나 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 삽입은 처리없이 JavaScript를 맹목적으로 실행하므로 무한 루프 또는 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="01c747e61f5bb1dd235f2fe00fa38dc12f026fe1" translate="yes" xml:space="preserve">
          <source>The OWASP way is less intrusive, as it needs no client library changes, and transfers valid JSON. It is unsure whether past or future browser bugs could defeat this, however.  As noted by @oriadam, it is unclear whether data could be leaked in a parse error through an error-handling or not (e.g. window.onerror).</source>
          <target state="translated">클라이언트 라이브러리 변경이 필요하지 않고 유효한 JSON을 전송하므로 OWASP 방식은 덜 방해가되지 않습니다. 그러나 과거 또는 미래의 브라우저 버그로이 문제를 해결할 수 있는지 확실하지 않습니다. @oriadam이 지적했듯이, 오류 처리를 통해 구문 분석 오류에서 데이터가 유출 될 수 있는지 여부는 확실하지 않습니다 (예 : window.onerror).</target>
        </trans-unit>
        <trans-unit id="0404af8312f4e69068ca7857605696398b6e0155" translate="yes" xml:space="preserve">
          <source>There are multiple countermeasures:</source>
          <target state="translated">여러 가지 대책이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3255cdcca3cabb924d221cf59beaf12a7c41cf73" translate="yes" xml:space="preserve">
          <source>Things like &lt;code&gt;for(;;);&lt;/code&gt; have been seen at Facebook for instance, with the same results.</source>
          <target state="translated">&lt;code&gt;for(;;);&lt;/code&gt; 예를 들어 Facebook에서도 같은 결과를 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="91f4151f017e676f45a575b1c641b34a589d4d0e" translate="yes" xml:space="preserve">
          <source>This does not address the issue of &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;cross-site request forgery&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;교차 사이트 요청 위조&lt;/a&gt; 문제는 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e46ff1ede1332f3270709e81fead34240d725952" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;&lt;strong&gt;&lt;code&gt;OWASP&lt;/code&gt;&lt;/strong&gt; recommended way&lt;/a&gt; to protect from JSON hijacking and is the less intrusive one.</source>
          <target state="translated">이것은 JSON 하이재킹을 방지하기 위해 &lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;&lt;strong&gt; &lt;code&gt;OWASP&lt;/code&gt; &lt;/strong&gt; 권장 방법&lt;/a&gt; 이며 덜 방해가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6e8debd00ab99c1f20dafceedfbe9a340387982" translate="yes" xml:space="preserve">
          <source>This is however valid JSON:</source>
          <target state="translated">그러나 이것은 유효한 JSON입니다.</target>
        </trans-unit>
        <trans-unit id="65aee6c6c83a14d05ff8b42bdda59f2453e8b8c4" translate="yes" xml:space="preserve">
          <source>This is to ensure some other site can't do nasty tricks to try to steal your data. For example, by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;replacing the array constructor&lt;/a&gt;, then including this JSON URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, a malicious third-party site could steal the data from the JSON response. By putting a &lt;code&gt;while(1);&lt;/code&gt; at the start, the script will hang instead.</source>
          <target state="translated">이것은 다른 사이트가 데이터를 훔치려 고 시도하는 속임수를 쓰지 않도록하기위한 것입니다. 예를 들어, &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;배열 생성자&lt;/a&gt; 를 교체 한 다음 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 통해이 JSON URL을 포함 시키면 악의적 인 타사 사이트가 JSON 응답에서 데이터를 훔칠 수 있습니다. &lt;code&gt;while(1);&lt;/code&gt; 시작할 때 스크립트가 대신 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="cd74173708ca6bae4ae52f64b0eac1a47f06f86c" translate="yes" xml:space="preserve">
          <source>Thus, if you visit an attacker's page, it couldn't read your email from gmail.com.</source>
          <target state="translated">따라서 침입자 페이지를 방문하면 gmail.com에서 전자 메일을 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a80832a90f0eb46f0620cb5802e9e519794d6d1a" translate="yes" xml:space="preserve">
          <source>What's going on here?</source>
          <target state="translated">무슨 일이야?</target>
        </trans-unit>
        <trans-unit id="32638f7cfa546de73f10b0ac2d66e66c0ee66d77" translate="yes" xml:space="preserve">
          <source>Why does Google prepend &lt;code&gt;while(1);&lt;/code&gt; to their (private) JSON responses?</source>
          <target state="translated">왜 Google이 앞에 붙는가 &lt;code&gt;while(1);&lt;/code&gt; (개인) JSON 응답에?</target>
        </trans-unit>
        <trans-unit id="fb290a5cb43b280973a446bf92cdb413bcb39df7" translate="yes" xml:space="preserve">
          <source>Why does Google prepend while(1); to their JSON responses</source>
          <target state="translated">왜 Google이 앞에 붙는가 (1); 그들의 JSON 응답에</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
