<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2669690">
    <body>
      <group id="2669690">
        <trans-unit id="6ed88095f6356427e065e4f0da1dc4208b5b2eaa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;edit&lt;/em&gt; &amp;mdash; note the comment (and other answers). The issue has to do with subverted built-in facilities, specifically the &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; constructors. Those can be altered such that otherwise innocuous JSON, when parsed, could trigger attacker code.</source>
          <target state="translated">&lt;em&gt;editar&lt;/em&gt; : tenga en cuenta el comentario (y otras respuestas). El problema tiene que ver con las instalaciones integradas subvertidas, espec&amp;iacute;ficamente los constructores &lt;code&gt;Object&lt;/code&gt; y &lt;code&gt;Array&lt;/code&gt; . Esos pueden ser alterados de tal manera que JSON, de otra manera inocuo, cuando se analiza, podr&amp;iacute;a desencadenar el c&amp;oacute;digo del atacante.</target>
        </trans-unit>
        <trans-unit id="57fd21beefa78406c6c5367148ed26ac53b78c6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: as of 2019, many of the old vulnerabilities that lead to the preventative measures discussed in this question are no longer an issue in modern browsers.  I'll leave the answer below as a historical curiosity, but really the whole topic has changed radically since 2010 (!!) when this was asked.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : a partir de 2019, muchas de las vulnerabilidades antiguas que conducen a las medidas preventivas discutidas en esta pregunta ya no son un problema en los navegadores modernos. Dejar&amp;eacute; la respuesta a continuaci&amp;oacute;n como una curiosidad hist&amp;oacute;rica, pero realmente todo el tema ha cambiado radicalmente desde 2010 (!!) cuando se pregunt&amp;oacute; esto.</target>
        </trans-unit>
        <trans-unit id="71b65b72e474c79efaa1968eb5081ff39c79eee5" translate="yes" xml:space="preserve">
          <source>A same-site request using XHR and a separate JSON parser, on the other hand, can easily ignore the &lt;code&gt;while(1);&lt;/code&gt; prefix.</source>
          <target state="translated">Una solicitud del mismo sitio usando XHR y un analizador JSON separado, por otro lado, puede ignorar f&amp;aacute;cilmente el &lt;code&gt;while(1);&lt;/code&gt; prefijo.</target>
        </trans-unit>
        <trans-unit id="28c456b213ff34c390dcff80ef63fb23c1ce5122" translate="yes" xml:space="preserve">
          <source>A valid JSON object, when not enclosed by anything, is not valid in Javascript:</source>
          <target state="translated">Un objeto JSON válido,cuando no está incluido en nada,no es válido en Javascript:</target>
        </trans-unit>
        <trans-unit id="7daffc89a7b8aec7532d4838fa6a40f1f70b311b" translate="yes" xml:space="preserve">
          <source>After authentication is in place, JSON hijacking protection can take a
  variety of forms. Google appends &lt;strong&gt;while(1)&lt;/strong&gt; into their JSON data, so
  that if any malicious script evaluates it, the malicious script enters
  an infinite loop.</source>
          <target state="translated">Despu&amp;eacute;s de la autenticaci&amp;oacute;n, la protecci&amp;oacute;n de secuestro de JSON puede adoptar una variedad de formas. Google agrega &lt;strong&gt;while (1)&lt;/strong&gt; a sus datos JSON, de modo que si alg&amp;uacute;n script malintencionado lo eval&amp;uacute;a, el script malicioso entra en un bucle infinito.</target>
        </trans-unit>
        <trans-unit id="7be6a6f5a84ff1bd0bc12a6d53c2432306a8338c" translate="yes" xml:space="preserve">
          <source>Always return JSON with an Object on the outside</source>
          <target state="translated">Siempre devuelve a JSON con un objeto en el exterior</target>
        </trans-unit>
        <trans-unit id="38657cd1deca0c38601450000e8c4ee8e3254dce" translate="yes" xml:space="preserve">
          <source>An attacker can request pages on other domains on your behalf, e.g. by using a &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag, but it can't get any information about the result (headers, contents).</source>
          <target state="translated">Un atacante puede solicitar p&amp;aacute;ginas en otros dominios en su nombre, por ejemplo, utilizando una etiqueta &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; , pero no puede obtener ninguna informaci&amp;oacute;n sobre el resultado (encabezados, contenido).</target>
        </trans-unit>
        <trans-unit id="4076d258e698a41cd58be09271d7235422cbb6bf" translate="yes" xml:space="preserve">
          <source>As noted by @hvd in the comments, the empty object &lt;code&gt;{}&lt;/code&gt; is valid Javascript, and knowing the object is empty may itself be valuable information.</source>
          <target state="translated">Como se&amp;ntilde;al&amp;oacute; @hvd en los comentarios, el objeto vac&amp;iacute;o &lt;code&gt;{}&lt;/code&gt; es Javascript v&amp;aacute;lido, y saber que el objeto est&amp;aacute; vac&amp;iacute;o puede ser una informaci&amp;oacute;n valiosa.</target>
        </trans-unit>
        <trans-unit id="88546fce7b19dd78f569d725399c113f191387f3" translate="yes" xml:space="preserve">
          <source>Both methods require server-side changes to avoid developers from accidentally sending vulnerable JSON.</source>
          <target state="translated">Ambos métodos requieren cambios del lado del servidor para evitar que los desarrolladores envíen accidentalmente un JSON vulnerable.</target>
        </trans-unit>
        <trans-unit id="7648f1875c9c0f61d7f7135068a8d63184cda276" translate="yes" xml:space="preserve">
          <source>By placing a &lt;code&gt;while(1);&lt;/code&gt; statement before the JSON data, Google makes sure that the JSON data is never executed as Javascript.</source>
          <target state="translated">Al colocar un &lt;code&gt;while(1);&lt;/code&gt; antes de los datos JSON, Google se asegura de que los datos JSON nunca se ejecuten como Javascript.</target>
        </trans-unit>
        <trans-unit id="7ff41c40cdaa12bb4b0f0be685d8174ce53a7093" translate="yes" xml:space="preserve">
          <source>Comparison of above methods</source>
          <target state="translated">Comparación de los métodos anteriores</target>
        </trans-unit>
        <trans-unit id="5cc0ef8ebf1d3e8d4667d491bff6ea11477f47b4" translate="yes" xml:space="preserve">
          <source>Contrived example: say Google has a URL like &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; which returns the first 50 messages of your inbox in JSON format. Evil websites on other domains can't make AJAX requests to get this data due to the same-origin policy, but they can include the URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. The URL is visited with &lt;em&gt;your&lt;/em&gt; cookies, and by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;overriding the global array constructor or accessor methods&lt;/a&gt; they can have a method called whenever an object (array or hash) attribute is set, allowing them to read the JSON content.</source>
          <target state="translated">Ejemplo contribuido: digamos que Google tiene una URL como &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; que devuelve los primeros 50 mensajes de su bandeja de entrada en formato JSON. Los sitios web malvados en otros dominios no pueden realizar solicitudes AJAX para obtener estos datos debido a la pol&amp;iacute;tica del mismo origen, pero pueden incluir la URL a trav&amp;eacute;s de una etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; . La URL se visita con &lt;em&gt;sus&lt;/em&gt; cookies, y al &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;anular el constructor de matriz global o los m&amp;eacute;todos de acceso&lt;/a&gt; pueden tener un m&amp;eacute;todo llamado cada vez que se establece un atributo de objeto (matriz o hash), lo que les permite leer el contenido JSON.</target>
        </trans-unit>
        <trans-unit id="0a899fbe9a5bae6b89125ccbf8c6667d4af13c9e" translate="yes" xml:space="preserve">
          <source>Except that when using a script tag to request JSON content, the JSON is executed as Javascript in an attacker's controlled environment. If the attacker can replace the Array or Object constructor or some other method used during object construction, anything in the JSON would pass through the attacker's code, and be disclosed.</source>
          <target state="translated">Excepto que cuando se utiliza una etiqueta de script para solicitar el contenido de JSON,el JSON se ejecuta como Javascript en el entorno controlado por el atacante.Si el atacante puede reemplazar el constructor de la matriz o del objeto o algún otro método utilizado durante la construcción del objeto,cualquier cosa en el JSON pasaría a través del código del atacante,y sería revelado.</target>
        </trans-unit>
        <trans-unit id="03fdac45ae96e608cfb4e1753008813ff5f0bb85" translate="yes" xml:space="preserve">
          <source>For example, here's a response while turning a calendar on and off in &lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;Google Calendar&lt;/a&gt;:</source>
          <target state="translated">Por ejemplo, aqu&amp;iacute; hay una respuesta al activar y desactivar un calendario en &lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;Google Calendar&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9afbbc0bacc7b9d361b66d602e97e7c70b23f706" translate="yes" xml:space="preserve">
          <source>Google's way requires the client library for it to support automatic de-serialization and can be considered to be safer about browser bugs.</source>
          <target state="translated">La manera de Google requiere que la biblioteca del cliente sea compatible con la deserialización automática y puede considerarse más segura en cuanto a los errores del navegador.</target>
        </trans-unit>
        <trans-unit id="23ad849cb3512da4fc03ab0386e87a3b5900544d" translate="yes" xml:space="preserve">
          <source>I would assume this is to prevent people from doing an &lt;code&gt;eval()&lt;/code&gt; on it, but all you'd really have to do is replace the &lt;code&gt;while&lt;/code&gt; and then you'd be set. I would assume the eval prevention is to make sure people write safe JSON parsing code.</source>
          <target state="translated">Supongo que esto es para evitar que las personas hagan un &lt;code&gt;eval()&lt;/code&gt; en &amp;eacute;l, pero todo lo que realmente tiene que hacer es reemplazar el &lt;code&gt;while&lt;/code&gt; y luego se establecer&amp;aacute;. Supongo que la prevenci&amp;oacute;n de evaluaci&amp;oacute;n es garantizar que las personas escriban un c&amp;oacute;digo de an&amp;aacute;lisis JSON seguro.</target>
        </trans-unit>
        <trans-unit id="9ec8b77b7bc0a99ad31f1d55c0d2ee7330d63d84" translate="yes" xml:space="preserve">
          <source>I've seen this used in a couple of other places, too, but a lot more so with Google (Mail, Calendar, Contacts, etc.) Strangely enough, &lt;a href=&quot;https://www.google.com/docs/about/&quot;&gt;Google Docs&lt;/a&gt; starts with &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; instead, and Google Contacts seems to start with &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n he visto esto en otros lugares, pero mucho m&amp;aacute;s con Google (Correo, Calendario, Contactos, etc.) Curiosamente, &lt;a href=&quot;https://www.google.com/docs/about/&quot;&gt;Google Docs&lt;/a&gt; comienza con &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; , y Google Contacts parece comenzar con &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &amp;amp;&amp;amp;&amp;amp; START &amp;amp;&amp;amp;&amp;amp; .</target>
        </trans-unit>
        <trans-unit id="82ec8480b6d03af801f80b5ee8091ae409a11277" translate="yes" xml:space="preserve">
          <source>In theory, the content of HTTP responses are protected by the Same Origin Policy: pages from one domain cannot get any pieces of information from pages on the other domain (unless explicitly allowed).</source>
          <target state="translated">En teoría,el contenido de las respuestas HTTP está protegido por la Política del Mismo Origen:las páginas de un dominio no pueden obtener ninguna información de las páginas del otro dominio (a menos que se permita explícitamente).</target>
        </trans-unit>
        <trans-unit id="c01ca5858305e902adb7c735cb337c7e46db9b23" translate="yes" xml:space="preserve">
          <source>It prevents &lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;JSON hijacking&lt;/a&gt;, a major JSON security issue that is formally &lt;a href=&quot;https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed&quot;&gt;fixed&lt;/a&gt; in all major browsers &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;since 2011&lt;/a&gt; with ECMAScript 5.</source>
          <target state="translated">Impide el &lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;secuestro de JSON&lt;/a&gt; , un importante problema de seguridad de JSON que se &lt;a href=&quot;https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed&quot;&gt;corrige&lt;/a&gt; formalmente en todos los principales navegadores &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;desde 2011&lt;/a&gt; con ECMAScript 5.</target>
        </trans-unit>
        <trans-unit id="c7c40d576012cf240f7632ab339b57b595515add" translate="yes" xml:space="preserve">
          <source>It prevents disclosure of the response through JSON hijacking.</source>
          <target state="translated">Evita que se revele la respuesta a través del secuestro de JSON.</target>
        </trans-unit>
        <trans-unit id="a1aa1b13e0d9fdf70db263078977f3d38acd3ad3" translate="yes" xml:space="preserve">
          <source>It prevents it from being used as the target of a simple &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. (Well, it doesn't prevent it, but it makes it unpleasant.)  That way bad guys can't just put that script tag in their own site and rely on an active session to make it possible to fetch your content.</source>
          <target state="translated">Impide que se use como el objetivo de una etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; simple. (Bueno, no lo previene, pero lo hace desagradable.) De esa manera, los malos no pueden simplemente poner esa etiqueta de script en su propio sitio y confiar en una sesi&amp;oacute;n activa para que sea posible recuperar su contenido.</target>
        </trans-unit>
        <trans-unit id="7ea6ab3ebd624cfe48a934a9c8d1f5a2b5da81f7" translate="yes" xml:space="preserve">
          <source>Making sure the JSON is not valid Javascript</source>
          <target state="translated">Asegurarse de que el JSON no es válido Javascript</target>
        </trans-unit>
        <trans-unit id="edf6e049119a5a0470202ae214dba539bbf2941d" translate="yes" xml:space="preserve">
          <source>Making sure the JSON never executes</source>
          <target state="translated">Asegurarse de que el JSON nunca se ejecute</target>
        </trans-unit>
        <trans-unit id="febec8be0b81b2feb1513f23b1b0842cfda8281f" translate="yes" xml:space="preserve">
          <source>Note that this happens at the time the JSON is executed as Javascript, not at the time it's parsed.</source>
          <target state="translated">Tengan en cuenta que esto ocurre en el momento en que el JSON se ejecuta como Javascript,no en el momento en que se analiza.</target>
        </trans-unit>
        <trans-unit id="68382c925cd44b6363a76a407b89bca9f818e2f7" translate="yes" xml:space="preserve">
          <source>Only a legitimate page could get the whole content, strip the &lt;code&gt;while(1);&lt;/code&gt;, and parse the remainder as JSON.</source>
          <target state="translated">Solo una p&amp;aacute;gina leg&amp;iacute;tima podr&amp;iacute;a obtener todo el contenido, eliminar el &lt;code&gt;while(1);&lt;/code&gt; y analiza el resto como JSON.</target>
        </trans-unit>
        <trans-unit id="bc7cf8ff662f5a3091b16d09c3b12b6d71093ebd" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;Web Security Testing Cookbook: Systematic Techniques to Find Problems Fast&lt;/a&gt;</source>
          <target state="translated">Referencia: &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;Libro de cocina de pruebas de seguridad web: t&amp;eacute;cnicas sistem&amp;aacute;ticas para encontrar problemas r&amp;aacute;pidamente&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9a6df7cbe191da1a26b102b682aa4681d0a0ec" translate="yes" xml:space="preserve">
          <source>Similar to the previous counter-measures, it makes sure that the JSON is never executed as Javascript.</source>
          <target state="translated">Al igual que las contramedidas anteriores,se asegura de que el JSON nunca se ejecute como Javascript.</target>
        </trans-unit>
        <trans-unit id="19a1209ad05215641679ef27706ab76a7c14298b" translate="yes" xml:space="preserve">
          <source>Similarly, adding invalid tokens before the JSON, like &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;, makes sure that it is never executed.</source>
          <target state="translated">Del mismo modo, al agregar tokens no v&amp;aacute;lidos antes del JSON, como &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; , se asegura de que nunca se ejecute.</target>
        </trans-unit>
        <trans-unit id="a8576bf9b39e4b58222cbecd8050077417f14c7d" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempted from the Same Origin Policy which is a security necessity in the web world, &lt;code&gt;while(1)&lt;/code&gt; when added to the JSON response prevents misuse of it in the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">Dado que la etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; est&amp;aacute; exenta de la Pol&amp;iacute;tica del mismo origen, que es una necesidad de seguridad en el mundo web, &lt;code&gt;while(1)&lt;/code&gt; cuando se agrega a la respuesta JSON evita el uso indebido de la misma en la etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="265e18163ded129866441b9562b684e40cfa81d6" translate="yes" xml:space="preserve">
          <source>So, make sure you always return an Object at the top level of the response makes sure that the JSON is not valid Javascript, while still being valid JSON.</source>
          <target state="translated">Por lo tanto,asegúrese de que siempre devuelva un objeto en el nivel superior de la respuesta se asegura de que el JSON no es válido Javascript,mientras que sigue siendo válido JSON.</target>
        </trans-unit>
        <trans-unit id="47645ade00c4230d7c88790f7f1e2fffce64acd9" translate="yes" xml:space="preserve">
          <source>That would be to make it difficult for a third-party to insert the JSON response into an HTML document with the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. Remember that the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempt from the &lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;Same Origin Policy&lt;/a&gt;.</source>
          <target state="translated">Eso ser&amp;iacute;a para dificultar que un tercero inserte la respuesta JSON en un documento HTML con la etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; . Recuerde que la etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; est&amp;aacute; exenta de la &lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;Pol&amp;iacute;tica&lt;/a&gt; del mismo origen .</target>
        </trans-unit>
        <trans-unit id="c70b262e3848de4bc0df4a3158b105318dddf4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while(1);&lt;/code&gt; or &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; prevents this: an AJAX request at &lt;code&gt;mail.google.com&lt;/code&gt; will have full access to the text content, and can strip it away. But a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag insertion blindly executes the JavaScript without any processing, resulting in either an infinite loop or a syntax error.</source>
          <target state="translated">El &lt;code&gt;while(1);&lt;/code&gt; o &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; evita esto: una solicitud de AJAX en &lt;code&gt;mail.google.com&lt;/code&gt; tendr&amp;aacute; acceso completo al contenido de texto y puede eliminarlo. Pero una inserci&amp;oacute;n de etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; ejecuta ciegamente el JavaScript sin ning&amp;uacute;n procesamiento, lo que resulta en un bucle infinito o un error de sintaxis.</target>
        </trans-unit>
        <trans-unit id="01c747e61f5bb1dd235f2fe00fa38dc12f026fe1" translate="yes" xml:space="preserve">
          <source>The OWASP way is less intrusive, as it needs no client library changes, and transfers valid JSON. It is unsure whether past or future browser bugs could defeat this, however.  As noted by @oriadam, it is unclear whether data could be leaked in a parse error through an error-handling or not (e.g. window.onerror).</source>
          <target state="translated">La forma OWASP es menos intrusiva,ya que no necesita cambios en la biblioteca del cliente,y transfiere un JSON válido.Sin embargo,no es seguro que los errores pasados o futuros del navegador puedan vencer esto.Como ha señalado @oriadam,no está claro si los datos podrían filtrarse en un error de análisis a través de un error de manejo o no (por ejemplo,window.onerror).</target>
        </trans-unit>
        <trans-unit id="0404af8312f4e69068ca7857605696398b6e0155" translate="yes" xml:space="preserve">
          <source>There are multiple countermeasures:</source>
          <target state="translated">Hay múltiples contramedidas:</target>
        </trans-unit>
        <trans-unit id="3255cdcca3cabb924d221cf59beaf12a7c41cf73" translate="yes" xml:space="preserve">
          <source>Things like &lt;code&gt;for(;;);&lt;/code&gt; have been seen at Facebook for instance, with the same results.</source>
          <target state="translated">Cosas como &lt;code&gt;for(;;);&lt;/code&gt; se han visto en Facebook, por ejemplo, con los mismos resultados.</target>
        </trans-unit>
        <trans-unit id="91f4151f017e676f45a575b1c641b34a589d4d0e" translate="yes" xml:space="preserve">
          <source>This does not address the issue of &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;cross-site request forgery&lt;/a&gt;.</source>
          <target state="translated">Esto no aborda el problema de la &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;falsificaci&amp;oacute;n de solicitudes entre sitios&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e46ff1ede1332f3270709e81fead34240d725952" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;&lt;strong&gt;&lt;code&gt;OWASP&lt;/code&gt;&lt;/strong&gt; recommended way&lt;/a&gt; to protect from JSON hijacking and is the less intrusive one.</source>
          <target state="translated">Esta es la &lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;forma recomendada por &lt;strong&gt; &lt;code&gt;OWASP&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; para protegerse del secuestro de JSON y es la menos intrusiva.</target>
        </trans-unit>
        <trans-unit id="a6e8debd00ab99c1f20dafceedfbe9a340387982" translate="yes" xml:space="preserve">
          <source>This is however valid JSON:</source>
          <target state="translated">Sin embargo,esto es válido JSON:</target>
        </trans-unit>
        <trans-unit id="65aee6c6c83a14d05ff8b42bdda59f2453e8b8c4" translate="yes" xml:space="preserve">
          <source>This is to ensure some other site can't do nasty tricks to try to steal your data. For example, by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;replacing the array constructor&lt;/a&gt;, then including this JSON URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, a malicious third-party site could steal the data from the JSON response. By putting a &lt;code&gt;while(1);&lt;/code&gt; at the start, the script will hang instead.</source>
          <target state="translated">Esto es para garantizar que alg&amp;uacute;n otro sitio no pueda hacer trucos desagradables para intentar robar sus datos. Por ejemplo, al &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;reemplazar el constructor de matriz&lt;/a&gt; , y luego incluir esta URL JSON a trav&amp;eacute;s de una etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; , un sitio de terceros malintencionado podr&amp;iacute;a robar los datos de la respuesta JSON. Poniendo un &lt;code&gt;while(1);&lt;/code&gt; al principio, el script se bloquear&amp;aacute; en su lugar.</target>
        </trans-unit>
        <trans-unit id="cd74173708ca6bae4ae52f64b0eac1a47f06f86c" translate="yes" xml:space="preserve">
          <source>Thus, if you visit an attacker's page, it couldn't read your email from gmail.com.</source>
          <target state="translated">Así,si visitas la página de un atacante,no podrá leer tu correo electrónico de gmail.com.</target>
        </trans-unit>
        <trans-unit id="a80832a90f0eb46f0620cb5802e9e519794d6d1a" translate="yes" xml:space="preserve">
          <source>What's going on here?</source>
          <target state="translated">¿Qué está pasando aquí?</target>
        </trans-unit>
        <trans-unit id="32638f7cfa546de73f10b0ac2d66e66c0ee66d77" translate="yes" xml:space="preserve">
          <source>Why does Google prepend &lt;code&gt;while(1);&lt;/code&gt; to their (private) JSON responses?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; antecede Google &lt;code&gt;while(1);&lt;/code&gt; a sus respuestas JSON (privadas)?</target>
        </trans-unit>
        <trans-unit id="fb290a5cb43b280973a446bf92cdb413bcb39df7" translate="yes" xml:space="preserve">
          <source>Why does Google prepend while(1); to their JSON responses</source>
          <target state="translated">¿Por qué Google se adelanta mientras(1);a sus respuestas JSON</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
