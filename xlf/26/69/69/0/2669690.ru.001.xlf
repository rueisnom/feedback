<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2669690">
    <body>
      <group id="2669690">
        <trans-unit id="6ed88095f6356427e065e4f0da1dc4208b5b2eaa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;edit&lt;/em&gt; &amp;mdash; note the comment (and other answers). The issue has to do with subverted built-in facilities, specifically the &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; constructors. Those can be altered such that otherwise innocuous JSON, when parsed, could trigger attacker code.</source>
          <target state="translated">&lt;em&gt;редактировать&lt;/em&gt; - отметить комментарий (и другие ответы). Проблема связана с извращенными встроенными средствами, в частности с конструкторами &lt;code&gt;Object&lt;/code&gt; и &lt;code&gt;Array&lt;/code&gt; . Они могут быть изменены таким образом, чтобы в противном случае безобидный JSON при анализе мог вызвать код злоумышленника.</target>
        </trans-unit>
        <trans-unit id="57fd21beefa78406c6c5367148ed26ac53b78c6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: as of 2019, many of the old vulnerabilities that lead to the preventative measures discussed in this question are no longer an issue in modern browsers.  I'll leave the answer below as a historical curiosity, but really the whole topic has changed radically since 2010 (!!) when this was asked.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : с 2019 года многие из старых уязвимостей, которые приводят к профилактическим мерам, обсуждаемым в этом вопросе, больше не являются проблемой в современных браузерах. Я оставлю ответ ниже как историческое любопытство, но на самом деле вся тема радикально изменилась с 2010 года (!!), когда об этом спросили.</target>
        </trans-unit>
        <trans-unit id="71b65b72e474c79efaa1968eb5081ff39c79eee5" translate="yes" xml:space="preserve">
          <source>A same-site request using XHR and a separate JSON parser, on the other hand, can easily ignore the &lt;code&gt;while(1);&lt;/code&gt; prefix.</source>
          <target state="translated">С другой стороны, запрос на одном сайте с использованием XHR и отдельного анализатора JSON может легко игнорировать &lt;code&gt;while(1);&lt;/code&gt; приставка.</target>
        </trans-unit>
        <trans-unit id="28c456b213ff34c390dcff80ef63fb23c1ce5122" translate="yes" xml:space="preserve">
          <source>A valid JSON object, when not enclosed by anything, is not valid in Javascript:</source>
          <target state="translated">Действительный JSON-объект,когда он ничем не прикреплен,недействителен в Javascript:</target>
        </trans-unit>
        <trans-unit id="7daffc89a7b8aec7532d4838fa6a40f1f70b311b" translate="yes" xml:space="preserve">
          <source>After authentication is in place, JSON hijacking protection can take a
  variety of forms. Google appends &lt;strong&gt;while(1)&lt;/strong&gt; into their JSON data, so
  that if any malicious script evaluates it, the malicious script enters
  an infinite loop.</source>
          <target state="translated">После проверки подлинности защита от угона JSON может принимать различные формы. Google добавляет &lt;strong&gt;while (1)&lt;/strong&gt; в свои данные JSON, поэтому, если какой-либо вредоносный скрипт его оценивает, он входит в бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="7be6a6f5a84ff1bd0bc12a6d53c2432306a8338c" translate="yes" xml:space="preserve">
          <source>Always return JSON with an Object on the outside</source>
          <target state="translated">Всегда возвращайте JSON с Объектом снаружи.</target>
        </trans-unit>
        <trans-unit id="38657cd1deca0c38601450000e8c4ee8e3254dce" translate="yes" xml:space="preserve">
          <source>An attacker can request pages on other domains on your behalf, e.g. by using a &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag, but it can't get any information about the result (headers, contents).</source>
          <target state="translated">Злоумышленник может запросить страницы в других доменах от вашего имени, например, с помощью &lt;code&gt;&amp;lt;script src=...&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; , но он не может получить никакой информации о результате (заголовки, содержимое).</target>
        </trans-unit>
        <trans-unit id="4076d258e698a41cd58be09271d7235422cbb6bf" translate="yes" xml:space="preserve">
          <source>As noted by @hvd in the comments, the empty object &lt;code&gt;{}&lt;/code&gt; is valid Javascript, and knowing the object is empty may itself be valuable information.</source>
          <target state="translated">Как отмечает @hvd в комментариях, пустой объект &lt;code&gt;{}&lt;/code&gt; является допустимым Javascript, и знание того, что объект пуст, само по себе может быть ценной информацией.</target>
        </trans-unit>
        <trans-unit id="88546fce7b19dd78f569d725399c113f191387f3" translate="yes" xml:space="preserve">
          <source>Both methods require server-side changes to avoid developers from accidentally sending vulnerable JSON.</source>
          <target state="translated">Оба метода требуют внесения изменений на стороне сервера,чтобы избежать случайной отправки уязвимого JSON разработчиками.</target>
        </trans-unit>
        <trans-unit id="7648f1875c9c0f61d7f7135068a8d63184cda276" translate="yes" xml:space="preserve">
          <source>By placing a &lt;code&gt;while(1);&lt;/code&gt; statement before the JSON data, Google makes sure that the JSON data is never executed as Javascript.</source>
          <target state="translated">Размещая некоторое &lt;code&gt;while(1);&lt;/code&gt; Заявление перед данными JSON, Google гарантирует, что данные JSON никогда не выполняются как Javascript.</target>
        </trans-unit>
        <trans-unit id="7ff41c40cdaa12bb4b0f0be685d8174ce53a7093" translate="yes" xml:space="preserve">
          <source>Comparison of above methods</source>
          <target state="translated">Сравнение вышеуказанных методов</target>
        </trans-unit>
        <trans-unit id="5cc0ef8ebf1d3e8d4667d491bff6ea11477f47b4" translate="yes" xml:space="preserve">
          <source>Contrived example: say Google has a URL like &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; which returns the first 50 messages of your inbox in JSON format. Evil websites on other domains can't make AJAX requests to get this data due to the same-origin policy, but they can include the URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. The URL is visited with &lt;em&gt;your&lt;/em&gt; cookies, and by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;overriding the global array constructor or accessor methods&lt;/a&gt; they can have a method called whenever an object (array or hash) attribute is set, allowing them to read the JSON content.</source>
          <target state="translated">Придуманный пример: скажем, у Google есть URL-адрес, такой как &lt;code&gt;mail.google.com/json?action=inbox&lt;/code&gt; , который возвращает первые 50 сообщений из вашего почтового ящика в формате JSON. Злые веб-сайты в других доменах не могут отправлять запросы AJAX на получение этих данных из-за политики того же происхождения, но они могут включать URL-адрес с помощью &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; . URL посещают &lt;em&gt;ваши&lt;/em&gt; куки, и, &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;переопределяя конструктор глобального массива или методы доступа,&lt;/a&gt; они могут иметь метод, вызываемый всякий раз, когда установлен атрибут объекта (массива или хеша), позволяющий им читать содержимое JSON.</target>
        </trans-unit>
        <trans-unit id="0a899fbe9a5bae6b89125ccbf8c6667d4af13c9e" translate="yes" xml:space="preserve">
          <source>Except that when using a script tag to request JSON content, the JSON is executed as Javascript in an attacker's controlled environment. If the attacker can replace the Array or Object constructor or some other method used during object construction, anything in the JSON would pass through the attacker's code, and be disclosed.</source>
          <target state="translated">За исключением того,что при использовании тега сценария для запроса JSON-контента,JSON выполняется как Javascript в контролируемой злоумышленником среде.Если атакующий может заменить массив или конструктор объектов или какой-либо другой метод,используемый при построении объектов,все,что в JSON будет проходить через код атакующего,будет раскрыто.</target>
        </trans-unit>
        <trans-unit id="03fdac45ae96e608cfb4e1753008813ff5f0bb85" translate="yes" xml:space="preserve">
          <source>For example, here's a response while turning a calendar on and off in &lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;Google Calendar&lt;/a&gt;:</source>
          <target state="translated">Например, вот ответ при включении и выключении &lt;a href=&quot;https://calendar.google.com/calendar/about/&quot;&gt;календаря&lt;/a&gt; в Календаре Google :</target>
        </trans-unit>
        <trans-unit id="9afbbc0bacc7b9d361b66d602e97e7c70b23f706" translate="yes" xml:space="preserve">
          <source>Google's way requires the client library for it to support automatic de-serialization and can be considered to be safer about browser bugs.</source>
          <target state="translated">Путь Google требует,чтобы клиентская библиотека поддерживала автоматическую десериализацию,и может считаться более безопасным при возникновении ошибок в браузере.</target>
        </trans-unit>
        <trans-unit id="23ad849cb3512da4fc03ab0386e87a3b5900544d" translate="yes" xml:space="preserve">
          <source>I would assume this is to prevent people from doing an &lt;code&gt;eval()&lt;/code&gt; on it, but all you'd really have to do is replace the &lt;code&gt;while&lt;/code&gt; and then you'd be set. I would assume the eval prevention is to make sure people write safe JSON parsing code.</source>
          <target state="translated">Я бы предположил, что это не позволяет людям выполнять &lt;code&gt;eval()&lt;/code&gt; , но все, что вам действительно нужно сделать, это заменить &lt;code&gt;while&lt;/code&gt; и тогда вы будете настроены. Я хотел бы предположить, что eval предотвращение состоит в том, чтобы гарантировать, что люди пишут безопасный код анализа JSON.</target>
        </trans-unit>
        <trans-unit id="9ec8b77b7bc0a99ad31f1d55c0d2ee7330d63d84" translate="yes" xml:space="preserve">
          <source>I've seen this used in a couple of other places, too, but a lot more so with Google (Mail, Calendar, Contacts, etc.) Strangely enough, &lt;a href=&quot;https://www.google.com/docs/about/&quot;&gt;Google Docs&lt;/a&gt; starts with &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; instead, and Google Contacts seems to start with &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Я видел, что это использовалось и в нескольких других местах, но гораздо больше с Google (Почта, Календарь, Контакты и т. Д.) Как ни странно, &lt;a href=&quot;https://www.google.com/docs/about/&quot;&gt;Документы Google&lt;/a&gt; начинаются с &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; , а Контакты Google, кажется, начинаются с &lt;code&gt;while(1); &amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &amp;amp;&amp;amp;&amp;amp; START &amp;amp;&amp;amp;&amp;amp; .</target>
        </trans-unit>
        <trans-unit id="82ec8480b6d03af801f80b5ee8091ae409a11277" translate="yes" xml:space="preserve">
          <source>In theory, the content of HTTP responses are protected by the Same Origin Policy: pages from one domain cannot get any pieces of information from pages on the other domain (unless explicitly allowed).</source>
          <target state="translated">Теоретически,содержание HTTP-ответов защищено Политикой того же происхождения:страницы одного домена не могут получить никаких кусочков информации со страниц другого домена (если это явно не разрешено).</target>
        </trans-unit>
        <trans-unit id="c01ca5858305e902adb7c735cb337c7e46db9b23" translate="yes" xml:space="preserve">
          <source>It prevents &lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;JSON hijacking&lt;/a&gt;, a major JSON security issue that is formally &lt;a href=&quot;https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed&quot;&gt;fixed&lt;/a&gt; in all major browsers &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;since 2011&lt;/a&gt; with ECMAScript 5.</source>
          <target state="translated">Он предотвращает &lt;a href=&quot;http://haacked.com/archive/2009/06/25/json-hijacking.aspx&quot;&gt;угон JSON&lt;/a&gt; , серьезную проблему безопасности JSON, которая официально &lt;a href=&quot;https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed&quot;&gt;исправлена&lt;/a&gt; во всех основных браузерах &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;с 2011 года в&lt;/a&gt; ECMAScript 5.</target>
        </trans-unit>
        <trans-unit id="c7c40d576012cf240f7632ab339b57b595515add" translate="yes" xml:space="preserve">
          <source>It prevents disclosure of the response through JSON hijacking.</source>
          <target state="translated">Она предотвращает разглашение информации об ответных действиях посредством угона JSON.</target>
        </trans-unit>
        <trans-unit id="a1aa1b13e0d9fdf70db263078977f3d38acd3ad3" translate="yes" xml:space="preserve">
          <source>It prevents it from being used as the target of a simple &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. (Well, it doesn't prevent it, but it makes it unpleasant.)  That way bad guys can't just put that script tag in their own site and rely on an active session to make it possible to fetch your content.</source>
          <target state="translated">Это предотвращает его использование в качестве цели простого &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; . (Ну, это не мешает этому, но делает его неприятным.) Таким образом, плохие парни не могут просто разместить этот тег сценария на своем собственном сайте и полагаться на активный сеанс, чтобы сделать возможным получение вашего контента.</target>
        </trans-unit>
        <trans-unit id="7ea6ab3ebd624cfe48a934a9c8d1f5a2b5da81f7" translate="yes" xml:space="preserve">
          <source>Making sure the JSON is not valid Javascript</source>
          <target state="translated">Убедитесь,что JSON недействителен Javascript.</target>
        </trans-unit>
        <trans-unit id="edf6e049119a5a0470202ae214dba539bbf2941d" translate="yes" xml:space="preserve">
          <source>Making sure the JSON never executes</source>
          <target state="translated">Убедиться,что JSON никогда не выполнит</target>
        </trans-unit>
        <trans-unit id="febec8be0b81b2feb1513f23b1b0842cfda8281f" translate="yes" xml:space="preserve">
          <source>Note that this happens at the time the JSON is executed as Javascript, not at the time it's parsed.</source>
          <target state="translated">Обратите внимание,что это происходит в то время,когда JSON выполняется как Javascript,а не в то время,когда он анализируется.</target>
        </trans-unit>
        <trans-unit id="68382c925cd44b6363a76a407b89bca9f818e2f7" translate="yes" xml:space="preserve">
          <source>Only a legitimate page could get the whole content, strip the &lt;code&gt;while(1);&lt;/code&gt;, and parse the remainder as JSON.</source>
          <target state="translated">Только легальная страница может получить весь контент, убрав &lt;code&gt;while(1);&lt;/code&gt; и проанализировать остаток как JSON.</target>
        </trans-unit>
        <trans-unit id="bc7cf8ff662f5a3091b16d09c3b12b6d71093ebd" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;Web Security Testing Cookbook: Systematic Techniques to Find Problems Fast&lt;/a&gt;</source>
          <target state="translated">Справочник: &lt;a href=&quot;https://books.google.co.nz/books?id=VmrSJ3V-s_MC&amp;amp;lpg=PA214&amp;amp;ots=cXaR_XGXSH&amp;amp;dq=google%20while(1)&amp;amp;pg=PA214#v=onepage&amp;amp;q=google%20while(1)&amp;amp;f=false&quot;&gt;Поваренная книга по тестированию веб-безопасности: системные методы быстрого поиска проблем&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9a6df7cbe191da1a26b102b682aa4681d0a0ec" translate="yes" xml:space="preserve">
          <source>Similar to the previous counter-measures, it makes sure that the JSON is never executed as Javascript.</source>
          <target state="translated">Подобно предыдущим контрмерам,он гарантирует,что JSON никогда не будет выполнен как Javascript.</target>
        </trans-unit>
        <trans-unit id="19a1209ad05215641679ef27706ab76a7c14298b" translate="yes" xml:space="preserve">
          <source>Similarly, adding invalid tokens before the JSON, like &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;, makes sure that it is never executed.</source>
          <target state="translated">Аналогично, добавление недопустимых токенов перед JSON, например &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;START&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; , гарантирует, что он никогда не будет выполнен.</target>
        </trans-unit>
        <trans-unit id="a8576bf9b39e4b58222cbecd8050077417f14c7d" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempted from the Same Origin Policy which is a security necessity in the web world, &lt;code&gt;while(1)&lt;/code&gt; when added to the JSON response prevents misuse of it in the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">Поскольку &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; освобожден от той же политики происхождения, что является необходимостью безопасности в веб-мире, &lt;code&gt;while(1)&lt;/code&gt; при добавлении в ответ JSON предотвращает его неправильное использование в &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="265e18163ded129866441b9562b684e40cfa81d6" translate="yes" xml:space="preserve">
          <source>So, make sure you always return an Object at the top level of the response makes sure that the JSON is not valid Javascript, while still being valid JSON.</source>
          <target state="translated">Итак,убедитесь,что вы всегда возвращаете Объект на верхнем уровне ответа,убедитесь,что JSON не является действительным Javascript,в то же время оставаясь действительным JSON.</target>
        </trans-unit>
        <trans-unit id="47645ade00c4230d7c88790f7f1e2fffce64acd9" translate="yes" xml:space="preserve">
          <source>That would be to make it difficult for a third-party to insert the JSON response into an HTML document with the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. Remember that the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is exempt from the &lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;Same Origin Policy&lt;/a&gt;.</source>
          <target state="translated">Это может затруднить стороннее вставление ответа JSON в HTML-документ с &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; . Помните, что &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; освобожден от той &lt;a href=&quot;http://en.wikipedia.org/wiki/Same_origin_policy&quot;&gt;же политики происхождения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c70b262e3848de4bc0df4a3158b105318dddf4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while(1);&lt;/code&gt; or &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; prevents this: an AJAX request at &lt;code&gt;mail.google.com&lt;/code&gt; will have full access to the text content, and can strip it away. But a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag insertion blindly executes the JavaScript without any processing, resulting in either an infinite loop or a syntax error.</source>
          <target state="translated">Время &lt;code&gt;while(1);&lt;/code&gt; или &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;BLAH&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; предотвращает это: запрос AJAX на &lt;code&gt;mail.google.com&lt;/code&gt; будет иметь полный доступ к текстовому контенту и может его убрать. Но вставка тега &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; слепо выполняет JavaScript без какой-либо обработки, что приводит либо к бесконечному циклу, либо к синтаксической ошибке.</target>
        </trans-unit>
        <trans-unit id="01c747e61f5bb1dd235f2fe00fa38dc12f026fe1" translate="yes" xml:space="preserve">
          <source>The OWASP way is less intrusive, as it needs no client library changes, and transfers valid JSON. It is unsure whether past or future browser bugs could defeat this, however.  As noted by @oriadam, it is unclear whether data could be leaked in a parse error through an error-handling or not (e.g. window.onerror).</source>
          <target state="translated">Способ OWASP менее интрузивный,так как не требует изменения клиентской библиотеки,и передает действительный JSON.Однако,не уверен,могут ли прошлые или будущие ошибки браузера победить это.Как отмечает @oriadam,неясно,могут ли данные быть утеряны в результате ошибки при разборе через обработку ошибок или нет (например,window.onerror).</target>
        </trans-unit>
        <trans-unit id="0404af8312f4e69068ca7857605696398b6e0155" translate="yes" xml:space="preserve">
          <source>There are multiple countermeasures:</source>
          <target state="translated">Есть несколько контрмер:</target>
        </trans-unit>
        <trans-unit id="3255cdcca3cabb924d221cf59beaf12a7c41cf73" translate="yes" xml:space="preserve">
          <source>Things like &lt;code&gt;for(;;);&lt;/code&gt; have been seen at Facebook for instance, with the same results.</source>
          <target state="translated">Вещи, как &lt;code&gt;for(;;);&lt;/code&gt; например, были замечены на Facebook с такими же результатами.</target>
        </trans-unit>
        <trans-unit id="91f4151f017e676f45a575b1c641b34a589d4d0e" translate="yes" xml:space="preserve">
          <source>This does not address the issue of &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;cross-site request forgery&lt;/a&gt;.</source>
          <target state="translated">Это не решает проблему &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;подделки межсайтовых запросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e46ff1ede1332f3270709e81fead34240d725952" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;&lt;strong&gt;&lt;code&gt;OWASP&lt;/code&gt;&lt;/strong&gt; recommended way&lt;/a&gt; to protect from JSON hijacking and is the less intrusive one.</source>
          <target state="translated">Это &lt;a href=&quot;https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside&quot;&gt;рекомендуемый &lt;strong&gt; &lt;code&gt;OWASP&lt;/code&gt; &lt;/strong&gt; способ&lt;/a&gt; защиты от угона JSON, и он менее навязчив.</target>
        </trans-unit>
        <trans-unit id="a6e8debd00ab99c1f20dafceedfbe9a340387982" translate="yes" xml:space="preserve">
          <source>This is however valid JSON:</source>
          <target state="translated">Это,однако,является действительным JSON:</target>
        </trans-unit>
        <trans-unit id="65aee6c6c83a14d05ff8b42bdda59f2453e8b8c4" translate="yes" xml:space="preserve">
          <source>This is to ensure some other site can't do nasty tricks to try to steal your data. For example, by &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;replacing the array constructor&lt;/a&gt;, then including this JSON URL via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, a malicious third-party site could steal the data from the JSON response. By putting a &lt;code&gt;while(1);&lt;/code&gt; at the start, the script will hang instead.</source>
          <target state="translated">Это сделано для того, чтобы какой-то другой сайт не мог делать неприятные трюки, пытаясь украсть ваши данные. Например, &lt;a href=&quot;http://ejohn.org/blog/re-securing-json/&quot;&gt;заменив конструктор массива&lt;/a&gt; , а затем включив этот URL-адрес JSON через &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; , злонамеренный сторонний сайт может украсть данные из ответа JSON. Положив некоторое &lt;code&gt;while(1);&lt;/code&gt; в начале сценарий будет висеть вместо этого.</target>
        </trans-unit>
        <trans-unit id="cd74173708ca6bae4ae52f64b0eac1a47f06f86c" translate="yes" xml:space="preserve">
          <source>Thus, if you visit an attacker's page, it couldn't read your email from gmail.com.</source>
          <target state="translated">Таким образом,если вы посещаете страницу злоумышленника,он не может прочитать вашу электронную почту с gmail.com.</target>
        </trans-unit>
        <trans-unit id="a80832a90f0eb46f0620cb5802e9e519794d6d1a" translate="yes" xml:space="preserve">
          <source>What's going on here?</source>
          <target state="translated">Что здесь происходит?</target>
        </trans-unit>
        <trans-unit id="32638f7cfa546de73f10b0ac2d66e66c0ee66d77" translate="yes" xml:space="preserve">
          <source>Why does Google prepend &lt;code&gt;while(1);&lt;/code&gt; to their (private) JSON responses?</source>
          <target state="translated">Почему Google работает в &lt;code&gt;while(1);&lt;/code&gt; на их (частные) ответы JSON?</target>
        </trans-unit>
        <trans-unit id="fb290a5cb43b280973a446bf92cdb413bcb39df7" translate="yes" xml:space="preserve">
          <source>Why does Google prepend while(1); to their JSON responses</source>
          <target state="translated">Почему Google готовит while(1);к их ответам на JSON</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
