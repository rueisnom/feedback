<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/52704">
    <body>
      <group id="52704">
        <trans-unit id="fed9ac100b0f08b31a7bd88c0c53e1f0ce411dc3" translate="yes" xml:space="preserve">
          <source>-d Remove untracked directories in addition to untracked files. If an untracked directory is managed by a different Git repository, it is
  not removed by default. Use -f option twice if you really want to
  remove such a directory.</source>
          <target state="translated">-d 除了未跟踪的文件,还可以删除未跟踪的目录。如果一个未被跟踪的目录是由不同的 Git 仓库管理的,默认情况下不会被删除。如果真的要删除这样的目录,请使用 -f 选项两次。</target>
        </trans-unit>
        <trans-unit id="c0689b1195a2d2494831311528c78cbd2c81d25f" translate="yes" xml:space="preserve">
          <source>-f
  --force If the Git configuration variable clean.requireForce is not set to false, git clean will refuse to run unless given -f, -n or -i.</source>
          <target state="translated">-f --force 如果 Git 配置变量 clean.requireForce 没有被设置为 false,git clean 将拒绝运行,除非给定 -f、-n 或 -i。</target>
        </trans-unit>
        <trans-unit id="afc2d1dacec6bf8a41b596c662443a54f59b539e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://git-scm.com/docs/git-clean&quot;&gt;&lt;code&gt;git clean&lt;/code&gt;&lt;/a&gt; removes all untracked files (&lt;strong&gt;warning&lt;/strong&gt;: while it won't delete ignored files mentioned directly in .gitignore, &lt;strong&gt;it may delete ignored files residing in folders&lt;/strong&gt;) and &lt;code&gt;git checkout&lt;/code&gt; clears all unstaged changes.</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/docs/git-clean&quot;&gt; &lt;code&gt;git clean&lt;/code&gt; &lt;/a&gt;删除所有未跟踪的文件（ &lt;strong&gt;警告&lt;/strong&gt; ：虽然它不会删除.gitignore中直接提及的被忽略文件， &lt;strong&gt;但可能会删除驻留在文件夹中的被忽略文件&lt;/strong&gt; ），并且 &lt;code&gt;git checkout&lt;/code&gt; 会清除所有未暂存的更改。</target>
        </trans-unit>
        <trans-unit id="2d7a7ed51e610e0e5e84ca28c30ed03480f47b5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt; here to remove &lt;a href=&quot;https://git-scm.com/docs/git-checkout#_argument_disambiguation&quot;&gt;argument ambiguation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 在这里消除&lt;a href=&quot;https://git-scm.com/docs/git-checkout#_argument_disambiguation&quot;&gt;争论的歧义&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="72799af98b1f5308f3529726c1792cf61e182c2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-d&lt;/code&gt;: Remove untracked directories in addition to untracked files</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; ：除未跟踪的文件外，删除未跟踪的目录</target>
        </trans-unit>
        <trans-unit id="53f62437a5af272cdc0c0f1087ed0fd5693a62f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-f&lt;/code&gt;: Force (might be not necessary depending on  &lt;code&gt;clean.requireForce&lt;/code&gt; setting)</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; ：强制（根据 &lt;code&gt;clean.requireForce&lt;/code&gt; 设置可能不是必需的）</target>
        </trans-unit>
        <trans-unit id="a716245a2809abce91a9d776dbbfc112b617201a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add . -A&lt;/code&gt; instead of &lt;code&gt;git add .&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git add . -A&lt;/code&gt; -A代替 &lt;code&gt;git add .&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb74c3f26ce1eb8d8c4c079f858137216a815cb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;man git-checkout&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;man git-checkout&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="94723bfd82f0ae0caf628ef46e610c3eec39a5cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Be very careful with this later command however as you might discard files you did not intend to get rid of.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;但是，请谨慎使用此后面的命令，因为您可能会丢弃不想删除的文件。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ddd1868251030fa30ddb023ff889dd017606c761" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2019 update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2019更新：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d583721fdee9eda617809d6d5f0932df533809dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Description&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27d9508a3b74080e0b435baa8bf80d7d81a6bc0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I was able to fix the problem by deleting my forked repository and all local repositories, and reforking. This alone was not enough; upstream had to rename the files in question to new filenames.&lt;/strong&gt; As long as you don't have any uncommited work, no wikis, and no issues that diverge from the upstream repository, you should be just fine. Upstream may not be very happy with you, to say the least. As for my problem, it is undoubtedly a user error as I'm not that proficient with git, but the fact that it is far from easy to fix points to an issue with git as well.</source>
          <target state="translated">&lt;strong&gt;通过删除叉状存储库和所有本地存储库，然后重新分叉，我得以解决此问题。&lt;/strong&gt; &lt;strong&gt;仅此一项是不够的。&lt;/strong&gt; &lt;strong&gt;上游不得不将有问题的文件重命名为新文件名。&lt;/strong&gt; 只要您没有任何未提交的工作，没有Wiki和没有与上游存储库有分歧的问题，就可以了。 至少可以说，上游可能对您不太满意。 至于我的问题，毫无疑问，这是一个用户错误，因为我不精通git，但事实也很不容易解决git问题。</target>
        </trans-unit>
        <trans-unit id="1884cdfa60ba48980b662b025f75e0ba67f99cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Options&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Options&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0949b40739737db3aca0e50aed86aa96b9b8a4f" translate="yes" xml:space="preserve">
          <source>A handful of options are available for more nuanced stashing; see the documentation.</source>
          <target state="translated">有少量选项可用于更细微的存储;请参见文档。</target>
        </trans-unit>
        <trans-unit id="b35af8cb225549965ddc586ff74ea587c627c5dc" translate="yes" xml:space="preserve">
          <source>A handful of other options are available for a quicker execution; see the documentation.</source>
          <target state="translated">还有一些其他选项可供快速执行;见文档。</target>
        </trans-unit>
        <trans-unit id="bdb3d9d11666a557cb5dac66319c6a3bdc844f3e" translate="yes" xml:space="preserve">
          <source>A keen eye will note that these files have dopplegangers that are a single letter in case off. Somehow, and I have no idea what led me down this path to start with (as I was not working with these files myself from the upstream repo), I had switched these files. Try the many solutions listed on this page (and other pages) did not seem to help.</source>
          <target state="translated">敏锐的眼睛会注意到这些文件中的dopplegangers是一个字母,以防万一。不知怎么的,我不知道是什么原因导致我走到了这条路上(因为我自己并没有从上游repo中找到这些文件),我把这些文件调换了。尝试这个页面上列出的许多解决方案(和其他页面)似乎都没有帮助。</target>
        </trans-unit>
        <trans-unit id="b39d5ddf0fc59abdea98c912f732b3c25809600a" translate="yes" xml:space="preserve">
          <source>After that, you can drop that stash with a &lt;code&gt;git stash drop&lt;/code&gt; command if you like.</source>
          <target state="translated">之后，您可以根据需要使用 &lt;code&gt;git stash drop&lt;/code&gt; 命令删除该存储。</target>
        </trans-unit>
        <trans-unit id="98e0506021752e4d376c394e1673d4fed4834a98" translate="yes" xml:space="preserve">
          <source>All changes will be moved to Git's Stash, for possible later access.</source>
          <target state="translated">所有的修改都将被转移到Git的缓存中,以便以后可能的访问。</target>
        </trans-unit>
        <trans-unit id="2dbf857966032bb2e5ee10d185df2f47b79c5d45" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;git checkout .&lt;/code&gt; needs to be done in the root of the repo.</source>
          <target state="translated">另外， &lt;code&gt;git checkout .&lt;/code&gt; 需要在仓库的根部完成。</target>
        </trans-unit>
        <trans-unit id="d4a3db2fca5b6d490e0d0666be31df78f925bfbd" translate="yes" xml:space="preserve">
          <source>And to remove all unstaged changes in the current repository:</source>
          <target state="translated">并删除当前存储库中所有未定型的修改。</target>
        </trans-unit>
        <trans-unit id="00bae78952a21817e9ff9b8f29e228f4b557b7a5" translate="yes" xml:space="preserve">
          <source>Another quicker way is:</source>
          <target state="translated">另一个比较快捷的方法是:</target>
        </trans-unit>
        <trans-unit id="629f09ca4ad9b66bb50fa2c4dcda91208cf09d47" translate="yes" xml:space="preserve">
          <source>Another way to get rid of new files that is more specific than git clean -df (it will allow you to get rid of some files not necessarily all), is to add the new files to the index first, then stash, then drop the stash.</source>
          <target state="translated">另一个比git clean -df更具体的摆脱新文件的方法是,先把新文件添加到索引中,然后是stash,再放下stash。</target>
        </trans-unit>
        <trans-unit id="3ab852661ea78d7491e0b8d339b188a5a85861c6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git checkout -- .&lt;/code&gt;, this will only discard changes to files tracked by Git and will not discard any new untracked files. If you want to discard any unstaged changes, including new untracked files, you could run an additional:</source>
          <target state="translated">与 &lt;code&gt;git checkout -- .&lt;/code&gt; ，这只会丢弃对Git跟踪的文件所做的更改，而不会丢弃任何新的未跟踪文件。 如果要丢弃任何未暂存的更改，包括新的未跟踪文件，则可以运行其他：</target>
        </trans-unit>
        <trans-unit id="0bb06bd83e97a5112661b65ead766c7aefb3ca6f" translate="yes" xml:space="preserve">
          <source>As you type git status, 
&lt;strong&gt;(use &quot;git checkout -- ...&quot; to discard changes in working directory)&lt;/strong&gt;
is shown.</source>
          <target state="translated">当您键入git status时&lt;strong&gt;（使用&amp;ldquo; git checkout-...&amp;rdquo;放弃工作目录中的更改）&lt;/strong&gt;将显示。</target>
        </trans-unit>
        <trans-unit id="9e4b2a87fb0c352693a1bd2db71c132ee44b38d5" translate="yes" xml:space="preserve">
          <source>Clean and discard changes and untracked files in working tree</source>
          <target state="translated">清理并丢弃工作树中的更改和未跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="42dcbc11ebcca8013128e188e07a667fd189817d" translate="yes" xml:space="preserve">
          <source>Cleans the working tree by recursively removing files that
  are not under version control, starting from the current directory.</source>
          <target state="translated">从当前目录开始,递归删除不受版本控制的文件,从而清理工作树。</target>
        </trans-unit>
        <trans-unit id="0854cfe68459fb9743ea87944a08ab9f2f41c3f2" translate="yes" xml:space="preserve">
          <source>Discard changes in a (list of) file(s) in working tree</source>
          <target state="translated">丢弃工作树中的(列表)文件的更改</target>
        </trans-unit>
        <trans-unit id="3703c5109b970db48fd2ad0fd5b85c35cce1361a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the ignore rules from &lt;code&gt;.gitignore&lt;/code&gt; (per directory) and &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;, but do still use the ignore rules given with &lt;code&gt;-e&lt;/code&gt; options. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with &lt;code&gt;git reset&lt;/code&gt;) to create a pristine working directory to test a clean build.</source>
          <target state="translated">不要使用 &lt;code&gt;.gitignore&lt;/code&gt; （每个目录）和 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 的忽略规则，但仍要使用 &lt;code&gt;-e&lt;/code&gt; 选项提供的忽略规则。 这允许删除所有未跟踪的文件，包括构建产品。 可以使用它（可能与 &lt;code&gt;git reset&lt;/code&gt; 结合使用）创建一个原始的工作目录以测试干净的构建。</target>
        </trans-unit>
        <trans-unit id="82021c36126c9d2972b261fbe6e9eed34c3be7aa" translate="yes" xml:space="preserve">
          <source>Done. Easy.</source>
          <target state="translated">顺利完成。很容易。</target>
        </trans-unit>
        <trans-unit id="1ad395b6696331a11075129d3a05a93a404bde8f" translate="yes" xml:space="preserve">
          <source>For a specific file use:</source>
          <target state="translated">对于具体的文件使用。</target>
        </trans-unit>
        <trans-unit id="30d953d36f4d87f6c54e1ffe33fd2c7b4568ac7f" translate="yes" xml:space="preserve">
          <source>For all unstaged files in current working directory use:</source>
          <target state="translated">对于当前工作目录中的所有非阶段性文件使用。</target>
        </trans-unit>
        <trans-unit id="2fc195e08169ea5ea29dab03ebd736643c24c496" translate="yes" xml:space="preserve">
          <source>Happened to me recently</source>
          <target state="translated">最近发生在我身上</target>
        </trans-unit>
        <trans-unit id="864d442672a2358879583b94bf582ea97a8424c9" translate="yes" xml:space="preserve">
          <source>How do I discard changes in my working copy that are not in the index?</source>
          <target state="translated">如何丢弃工作副本中不在索引中的更改?</target>
        </trans-unit>
        <trans-unit id="1fce62b7a2652a934ca474f0c5c63bb8b3b6e6c2" translate="yes" xml:space="preserve">
          <source>How do I discard unstaged changes in Git</source>
          <target state="translated">如何在Git中丢弃未完成的修改?</target>
        </trans-unit>
        <trans-unit id="eb60139211fc9388fb2f815a246c52e21943c2e4" translate="yes" xml:space="preserve">
          <source>I had a similar problem, perhaps not identical, and I'm sad to say my solution is not ideal, but it is ultimately effective.</source>
          <target state="translated">我也遇到过类似的问题,也许不尽相同,很遗憾,我的解决方案并不理想,但最终还是有效的。</target>
        </trans-unit>
        <trans-unit id="ee7ba19ebd0319622aee0d033dc1de473768df0f" translate="yes" xml:space="preserve">
          <source>I had a weird situation where a file is always unstaged, this helps me to resolve.</source>
          <target state="translated">我曾经遇到过一个奇怪的情况,一个文件总是不稳定,这个可以帮助我解决。</target>
        </trans-unit>
        <trans-unit id="ad84e904a2bcf085535faf5356692e18f46fe974" translate="yes" xml:space="preserve">
          <source>I really found this article helpful for explaining when to use what command: &lt;a href=&quot;http://www.szakmeister.net/blog/2011/oct/12/reverting-changes-git/&quot;&gt;http://www.szakmeister.net/blog/2011/oct/12/reverting-changes-git/&lt;/a&gt;</source>
          <target state="translated">我真的发现这篇文章有助于解释何时使用什么命令： &lt;a href=&quot;http://www.szakmeister.net/blog/2011/oct/12/reverting-changes-git/&quot;&gt;http&lt;/a&gt; : //www.szakmeister.net/blog/2011/oct/12/reverting-changes-git/</target>
        </trans-unit>
        <trans-unit id="5e6cde860870936f1e6000fe5438f36756de4bc6" translate="yes" xml:space="preserve">
          <source>I suspect that using &lt;code&gt;git stash&lt;/code&gt; is a popular choice since it's a little less dangerous.  You can always go back to it if you accidently blow too much away when using git reset.  Reset is recursive by default.</source>
          <target state="translated">我怀疑使用 &lt;code&gt;git stash&lt;/code&gt; 是一种流行的选择，因为它的危险性要小一些。 如果您在使用git reset时不小心吹了太多东西，可以随时返回到它。 默认情况下，重置是递归的。</target>
        </trans-unit>
        <trans-unit id="3587b4e2335f7d08a6418b42308fa22c6a17d065" translate="yes" xml:space="preserve">
          <source>I think there is 1 more change (don't know why this worked for me before):</source>
          <target state="translated">我觉得还有1个变化(不知道为什么以前这个方法对我有效)。</target>
        </trans-unit>
        <trans-unit id="8335e2269ae8550747eb62a058eaf6b8da22da46" translate="yes" xml:space="preserve">
          <source>I use the next alias to discard changes.</source>
          <target state="translated">我用下一个别名来丢弃更改。</target>
        </trans-unit>
        <trans-unit id="3dd312407e6bafcf3506f4027cc72a8a6476cbcd" translate="yes" xml:space="preserve">
          <source>I would often have git status messages like this (involving at least 2/4 files):</source>
          <target state="translated">我经常会有这样的git状态消息(涉及至少24个文件)。</target>
        </trans-unit>
        <trans-unit id="8816b09a32358ab8c2c7fac6aad970834a86eb5e" translate="yes" xml:space="preserve">
          <source>If any optional ... arguments are given, only those paths are
  affected.</source>
          <target state="translated">如果给出了任何可选的...参数,只影响到这些路径。</target>
        </trans-unit>
        <trans-unit id="529d47024d50b097a96e1e2122d526c7f5d4d692" translate="yes" xml:space="preserve">
          <source>If the Git configuration variable &lt;code&gt;clean.requireForce&lt;/code&gt; is not set to &lt;code&gt;false&lt;/code&gt;, Git clean will refuse to delete files or directories unless given &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-n&lt;/code&gt;, or &lt;code&gt;-i&lt;/code&gt;. Git will refuse to delete directories within the &lt;code&gt;.git&lt;/code&gt; subdirectory or file, unless a second &lt;code&gt;-f&lt;/code&gt; is given.</source>
          <target state="translated">如果Git配置变量 &lt;code&gt;clean.requireForce&lt;/code&gt; 未设置为 &lt;code&gt;false&lt;/code&gt; ，除非给定 &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-n&lt;/code&gt; 或 &lt;code&gt;-i&lt;/code&gt; ，否则Git clean将拒绝删除文件或目录。 除非给出第二个 &lt;code&gt;-f&lt;/code&gt; ，否则Git将拒绝删除 &lt;code&gt;.git&lt;/code&gt; 子目录或文件中的目录 。</target>
        </trans-unit>
        <trans-unit id="a876d321713c260c6efea388116771a1af8f9749" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;really&lt;/em&gt; care about your stash stack then you can follow with &lt;code&gt;git stash drop&lt;/code&gt;. But at that point you're better off using (from Mariusz Nowak):</source>
          <target state="translated">如果您&lt;em&gt;真的很&lt;/em&gt;在乎您的隐藏堆栈，则可以执行 &lt;code&gt;git stash drop&lt;/code&gt; 。 但是到那时，您最好使用（来自Mariusz Nowak）：</target>
        </trans-unit>
        <trans-unit id="6b1ae5b423635758e0a25c5cc6760e00e87b9176" translate="yes" xml:space="preserve">
          <source>If you aren't interested in keeping the unstaged changes (especially if the staged changes are new files), I found this handy:</source>
          <target state="translated">如果你对保留未分阶段的修改不感兴趣(特别是当分阶段的修改是新文件时),我发现这个很方便。</target>
        </trans-unit>
        <trans-unit id="dd23bb8ae4a841004bc72ddbfb3a7f79fc1cfbac" translate="yes" xml:space="preserve">
          <source>If you have staged the file, then use git reset.  Reset changes the index to match a commit.</source>
          <target state="translated">如果你已经分阶段提交了文件,那么使用git reset。reset会改变索引以匹配提交。</target>
        </trans-unit>
        <trans-unit id="3bd1003c321636caa648ef432ab3c21b2f41bed5" translate="yes" xml:space="preserve">
          <source>If you haven't staged the file, then you use &lt;code&gt;git checkout&lt;/code&gt;.  Checkout &quot;updates files in the working tree to match the version in the index&quot;.  If the files have not been staged (aka added to the index)... this command will essentially revert the files to what your last commit was.</source>
          <target state="translated">如果尚未暂存文件，则可以使用 &lt;code&gt;git checkout&lt;/code&gt; 。 签出&amp;ldquo;更新工作树中的文件以匹配索引中的版本&amp;rdquo;。 如果文件尚未暂存（又添加到索引），则此命令实际上会将文件还原为上一次提交的文件。</target>
        </trans-unit>
        <trans-unit id="f8d19102a6786fdcfae490d52ca3fc8f40c3495a" translate="yes" xml:space="preserve">
          <source>If you merely wish &lt;strong&gt;to remove changes to existing files&lt;/strong&gt;, use &lt;code&gt;checkout&lt;/code&gt; (&lt;a href=&quot;https://git-scm.com/docs/git-checkout&quot;&gt;documented here&lt;/a&gt;).</source>
          <target state="translated">如果您只想&lt;strong&gt;删除对现有文件的更改&lt;/strong&gt; ，请使用 &lt;code&gt;checkout&lt;/code&gt; （ &lt;a href=&quot;https://git-scm.com/docs/git-checkout&quot;&gt;在此处记录&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79cad392748bde549e75bc03a7473563f1e11676" translate="yes" xml:space="preserve">
          <source>If you want &lt;strong&gt;to remove files added&lt;/strong&gt; since your last commit, use &lt;code&gt;clean&lt;/code&gt; (&lt;a href=&quot;https://git-scm.com/docs/git-clean&quot;&gt;documented here&lt;/a&gt;):</source>
          <target state="translated">如果要&lt;strong&gt;删除&lt;/strong&gt;自上次提交以来&lt;strong&gt;添加的文件&lt;/strong&gt; ，请使用 &lt;code&gt;clean&lt;/code&gt; （ &lt;a href=&quot;https://git-scm.com/docs/git-clean&quot;&gt;在此处记录&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="94bef346d72e50bfd317274138d0f36470fc38a2" translate="yes" xml:space="preserve">
          <source>If you wish &lt;strong&gt;to move changes to a holding space for later access&lt;/strong&gt;, use &lt;code&gt;stash&lt;/code&gt; (&lt;a href=&quot;https://git-scm.com/docs/git-stash&quot;&gt;documented here&lt;/a&gt;):</source>
          <target state="translated">如果您希望&lt;strong&gt;将更改移至存放空间以供以后访问&lt;/strong&gt; ，请使用 &lt;code&gt;stash&lt;/code&gt; （ &lt;a href=&quot;https://git-scm.com/docs/git-stash&quot;&gt;在此处记录&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c8f0dcd22582ea400212c4bf2bf1ecb8196f22a0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;git status&lt;/code&gt;, now Git recommends using this command instead of &lt;code&gt;git checkout&lt;/code&gt; as it used to.</source>
          <target state="translated">在 &lt;code&gt;git status&lt;/code&gt; 中 ，现在Git建议使用此命令，而不是像以前那样使用 &lt;code&gt;git checkout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a66d8064b895089a51d39f45d330836cf5cf130" translate="yes" xml:space="preserve">
          <source>In git command, stashing of untracked files is achieved by using:</source>
          <target state="translated">在git命令中,存储未被跟踪的文件是通过使用。</target>
        </trans-unit>
        <trans-unit id="4f9dfa38b31d7d270d8aa454fe54f373205f54e8" translate="yes" xml:space="preserve">
          <source>In my opinion,</source>
          <target state="translated">在我看来。</target>
        </trans-unit>
        <trans-unit id="a710bcb2db12bb6ea9b79bfea29fc08590a3fc1e" translate="yes" xml:space="preserve">
          <source>Instead of discarding changes, I reset my remote to the origin. Note - this method is to completely restore your folder to that of the repo.</source>
          <target state="translated">我没有丢弃更改,而是将我的远程重置到原点。注意-这个方法是将你的文件夹完全恢复到repo的文件夹。</target>
        </trans-unit>
        <trans-unit id="e4ce5f1cd096b70edf7ccafdff1608da7b9a35c2" translate="yes" xml:space="preserve">
          <source>It seems like the complete solution is:</source>
          <target state="translated">看来,完整的解决方案是。</target>
        </trans-unit>
        <trans-unit id="19c8ae84a2a96946e0800bd4424233488d724cbe" translate="yes" xml:space="preserve">
          <source>It will remove all your local changes. You also can use later by saying</source>
          <target state="translated">它将删除你所有的本地修改。你也可以在以后使用时说</target>
        </trans-unit>
        <trans-unit id="098c5131b876d1833842c7915ad8820685fc825d" translate="yes" xml:space="preserve">
          <source>Just use:</source>
          <target state="translated">只要用。</target>
        </trans-unit>
        <trans-unit id="94314a06159d9c31a2ff55cd1415fe59ca943e2b" translate="yes" xml:space="preserve">
          <source>My favorite is</source>
          <target state="translated">我最喜欢的是</target>
        </trans-unit>
        <trans-unit id="c5c68720f904987895c38abb89689c82d8316808" translate="yes" xml:space="preserve">
          <source>NOTE: If you want to keep files not yet tracked, but not in GITIGNORE you may wish to skip this step, as it will Wipe these untracked files not found on your remote repository (thanks @XtrmJosh).</source>
          <target state="translated">注意:如果你想保留未被跟踪的文件,但不在GITIGNORE中,你可能希望跳过这一步,因为它将擦除这些未被跟踪的文件,在你的远程仓库中没有找到(感谢@XtrmJosh)。</target>
        </trans-unit>
        <trans-unit id="90f19de07eaa816f337291f8dbf8ed55cc13ebbe" translate="yes" xml:space="preserve">
          <source>No branch is specified, so it checks out the current branch.</source>
          <target state="translated">没有指定分支,所以它检查出当前分支。</target>
        </trans-unit>
        <trans-unit id="b9c6e3583ee2c594287b4a6fc73da8e7b11401d3" translate="yes" xml:space="preserve">
          <source>No matter what state your repo is in you can always reset to any previous commit:</source>
          <target state="translated">无论你的repo处于什么状态,你都可以重置到之前的任何提交。</target>
        </trans-unit>
        <trans-unit id="a4336fe427713d23c760add6d199455e6017811f" translate="yes" xml:space="preserve">
          <source>Nonetheless, I like &lt;code&gt;git stash -u&lt;/code&gt; the best because it &quot;discards&quot; all tracked and untracked changes in just &lt;em&gt;one command&lt;/em&gt;. Yet &lt;code&gt;git checkout -- .&lt;/code&gt; only discards tracked changes,
and &lt;code&gt;git clean -df&lt;/code&gt; only discards untracked changes... and typing both commands is &lt;em&gt;far&lt;/em&gt; too much work :)</source>
          <target state="translated">尽管如此，我还是最喜欢 &lt;code&gt;git stash -u&lt;/code&gt; ，因为它仅用&lt;em&gt;一个命令&lt;/em&gt;就&amp;ldquo;丢弃&amp;rdquo;所有已跟​​踪和未跟踪的更改。 但是 &lt;code&gt;git checkout -- .&lt;/code&gt; 仅丢弃跟踪的更改，而 &lt;code&gt;git clean -df&lt;/code&gt; 仅丢弃未跟踪的更改...，同时输入两个命令的工作量很大：)</target>
        </trans-unit>
        <trans-unit id="396cec2961d1019f503136da105dd323f822741b" translate="yes" xml:space="preserve">
          <source>Normally, only files unknown to Git are removed, but if the -x option
  is specified, ignored files are also removed. This can, for example,
  be useful to remove all build products.</source>
          <target state="translated">通常情况下,只删除 Git 不知道的文件,但如果指定了 -x 选项,也会删除被忽略的文件。例如,这可以用于删除所有的构建产品。</target>
        </trans-unit>
        <trans-unit id="6b667358b3ffd2bdbf9e8690c38a516866fc3d10" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;git restore&lt;/code&gt;: as this is a new command, &lt;a href=&quot;https://git-scm.com/docs/git-restore/2.23.0&quot;&gt;its man page&lt;/a&gt; gives a warning:</source>
          <target state="translated">关于 &lt;code&gt;git restore&lt;/code&gt; 的注意事项：由于这是一个新命令，因此&lt;a href=&quot;https://git-scm.com/docs/git-restore/2.23.0&quot;&gt;其手册页&lt;/a&gt;会给出警告：</target>
        </trans-unit>
        <trans-unit id="971dcad694fa90c95d79cb3e35f8800172a46f99" translate="yes" xml:space="preserve">
          <source>Now is available in the next Github repo which contains a lot of aliases:</source>
          <target state="translated">现在可以在下一个Github repo中使用,里面有很多别名。</target>
        </trans-unit>
        <trans-unit id="72e095f37cbb08d62af2ddc2eb1cb1d7393138c7" translate="yes" xml:space="preserve">
          <source>Or just a file:</source>
          <target state="translated">或者只是一个文件。</target>
        </trans-unit>
        <trans-unit id="4d0f3ef1dd38153720613b554c65d9bbcfc7d902" translate="yes" xml:space="preserve">
          <source>Otherwise, if you want to discard all changes and also the untracked files, I use a mix of checkout and clean:</source>
          <target state="translated">否则,如果你想丢弃所有的修改,也要丢弃未被跟踪的文件,我用的是结账和清理的混合方式。</target>
        </trans-unit>
        <trans-unit id="478b2510a9b32cfb4adf26e1a8d78520b35a469c" translate="yes" xml:space="preserve">
          <source>Remove untracked directories in addition to untracked files. If an untracked directory is managed by a different Git repository, it is not removed by default. Use &lt;code&gt;-f&lt;/code&gt; option twice if you really want to remove such a directory.</source>
          <target state="translated">除未跟踪的文件外，还删除未跟踪的目录。 如果未跟踪的目录由其他Git存储库管理，则默认情况下不会将其删除。 如果您确实要删除这样的目录，请使用 &lt;code&gt;-f&lt;/code&gt; 选项两次。</target>
        </trans-unit>
        <trans-unit id="6d80714ab625f9250b860a48bb052401b69c068c" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;git help clean&lt;/code&gt; to see the manual</source>
          <target state="translated">运行 &lt;code&gt;git help clean&lt;/code&gt; 来查看手册</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">也见。</target>
        </trans-unit>
        <trans-unit id="5f08bd2d55361c1ba94df735ac5ccb3fa855221c" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://github.com/git/git/commit/f496b064fc1135e0dded7f93d85d72eb0b302c22&quot;&gt;July 2019&lt;/a&gt;, there has been a new command which does exactly this: &lt;code&gt;git restore&lt;/code&gt;.</source>
          <target state="translated">自&lt;a href=&quot;https://github.com/git/git/commit/f496b064fc1135e0dded7f93d85d72eb0b302c22&quot;&gt;2019&lt;/a&gt;年7月以来，已经出现了一个新命令来执行此操作： &lt;code&gt;git restore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04acd8c1f0e76597bca9508038665bb9b88a4344" translate="yes" xml:space="preserve">
          <source>Since no answer suggests the exact option combination that I use, here it is:</source>
          <target state="translated">由于没有答案表明我用的是确切的选项组合,所以就在这里。</target>
        </trans-unit>
        <trans-unit id="b010ecc92659c76e1f93d2a5401f106185699a12" translate="yes" xml:space="preserve">
          <source>So I do this to make sure they don't sit there when I git reset (later - excludes gitignores on the Origin/branchname)</source>
          <target state="translated">所以我这样做是为了确保当我git重置的时候,他们不会坐在那里(后来--不包括Originbranchname上的gitignores)。</target>
        </trans-unit>
        <trans-unit id="32b93eceaf5edd5bbbe16dce5b2ef08bf8c1641c" translate="yes" xml:space="preserve">
          <source>So it is possible that this answer might become outdated if the behaviour does change in the future. It might thus be wise to run a quick &lt;code&gt;man git-restore&lt;/code&gt; before using it.</source>
          <target state="translated">因此，如果将来的行为发生变化，则此答案可能会过时。 因此，在使用前快速运行 &lt;code&gt;man git-restore&lt;/code&gt; 是明智的。</target>
        </trans-unit>
        <trans-unit id="96d550362eff6a29040d66c0bc830c58b2c76f8c" translate="yes" xml:space="preserve">
          <source>So the use is simple as next:</source>
          <target state="translated">所以使用方法很简单,就像下一个。</target>
        </trans-unit>
        <trans-unit id="16ec2b549f9cf7514b2409954745896f69ab7d7e" translate="yes" xml:space="preserve">
          <source>So, in order to restore the files matching a pathspec (getting rid of their unstaged changes), you would do:</source>
          <target state="translated">所以,为了恢复与路径规格匹配的文件(摆脱它们的非阶段性变化),你要做的是:</target>
        </trans-unit>
        <trans-unit id="7e6294c015403474dc533fce25008ae9e9ef152a" translate="yes" xml:space="preserve">
          <source>Take a look at the article above for further advice.</source>
          <target state="translated">看了上面的文章后,再看一看,有更多的建议。</target>
        </trans-unit>
        <trans-unit id="8c87610aaa7616e71adb720d209bde226e5b0bdf" translate="yes" xml:space="preserve">
          <source>That lets you selectively revert chunks.</source>
          <target state="translated">这让你可以有选择地还原大块。</target>
        </trans-unit>
        <trans-unit id="a625cdf5db5e1eadfae9daa74b20d41adaf50ccf" translate="yes" xml:space="preserve">
          <source>That will put it back to square one. Just like RE-Cloning the branch, WHILE keeping all my gitignored files locally and in place.</source>
          <target state="translated">这将使它回到原点。就像重新克隆分支一样,同时把我所有的gitignored文件都保留在本地,而且是原地。</target>
        </trans-unit>
        <trans-unit id="6b79228633a397f43b5ec158dc62bd7b541c62f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-i&lt;/code&gt; option initiates an interactive &lt;code&gt;clean&lt;/code&gt;, to prevent mistaken deletions.</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; 选项启动一个交互式 &lt;code&gt;clean&lt;/code&gt; ，以防止误删除。</target>
        </trans-unit>
        <trans-unit id="34a4059081536a4ba0807042845f6d37b9ed4564" translate="yes" xml:space="preserve">
          <source>The answer from Bilal Maqsood with &lt;code&gt;git clean&lt;/code&gt; also worked for me, but with the stash I have more control - if I do sth accidentally, I can still get my changes back</source>
          <target state="translated">来自Bilal Maqsood的 &lt;code&gt;git clean&lt;/code&gt; 答案也对我有用，但是有了存储，我有了更多控制权-如果我偶然地做某事，我仍然可以找回我的更改</target>
        </trans-unit>
        <trans-unit id="62345698e50d705132cfe6c077bc2d02c9628493" translate="yes" xml:space="preserve">
          <source>The double-hyphen (&lt;code&gt;--&lt;/code&gt;) tells Git that what follows should be taken as its second argument (path), that you skipped specification of a branch.</source>
          <target state="translated">双连字符（ &lt;code&gt;--&lt;/code&gt; ）告诉Git，以下内容应作为其第二个参数（路径），您跳过了分支的指定。</target>
        </trans-unit>
        <trans-unit id="1909fa0ba14ff86f3491b939c47fed3b8449c198" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is by using this command:</source>
          <target state="translated">最简单的方法就是使用这个命令。</target>
        </trans-unit>
        <trans-unit id="7e827872d90fac1fb3bc15c8233749d210363511" translate="yes" xml:space="preserve">
          <source>The period (&lt;code&gt;.&lt;/code&gt;) indicates all paths.</source>
          <target state="translated">句点（ &lt;code&gt;.&lt;/code&gt; ）表示所有路径。</target>
        </trans-unit>
        <trans-unit id="af0d1b4328276812686a9206c83d6172e0087443" translate="yes" xml:space="preserve">
          <source>Then I</source>
          <target state="translated">然后,我</target>
        </trans-unit>
        <trans-unit id="33de23d10db20d49224f8ef3b6bfe6a9ced5e313" translate="yes" xml:space="preserve">
          <source>Then I reset to origin</source>
          <target state="translated">然后我重设为原点</target>
        </trans-unit>
        <trans-unit id="76b16061fde005910f67c6e862f0d2f89d69be22" translate="yes" xml:space="preserve">
          <source>Then you can use it as next to discard all changes:</source>
          <target state="translated">然后,你可以把它作为下一个丢弃所有变化。</target>
        </trans-unit>
        <trans-unit id="8a58f32e5d8df2105e56e8f81f5a86e77ad4892f" translate="yes" xml:space="preserve">
          <source>There are a couple different cases:</source>
          <target state="translated">有几种不同的情况。</target>
        </trans-unit>
        <trans-unit id="03c3d16189699026ec8beb0dd2eed7cb1d8710f3" translate="yes" xml:space="preserve">
          <source>This checks out the current index for the current directory, throwing away all changes in files from the current directory downwards.</source>
          <target state="translated">这样就会检查出当前目录下的索引,将当前目录下的所有文件变化扔掉。</target>
        </trans-unit>
        <trans-unit id="0e4a34fc85d235e5640196e9fff5dfa6f28d404f" translate="yes" xml:space="preserve">
          <source>This command is experimental. The behavior may change.</source>
          <target state="translated">这个命令是实验性的。该行为可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="56c33c8ae8b1c644ac03d5c863fdcb0c359f2c14" translate="yes" xml:space="preserve">
          <source>This command is used to discard changes in working directory -</source>
          <target state="translated">该命令用于丢弃工作目录中的更改 --</target>
        </trans-unit>
        <trans-unit id="5cc465bdc8bdd458dd144f1d0a2b1ddcbfd3ad74" translate="yes" xml:space="preserve">
          <source>This is the online help text for the used &lt;code&gt;git clean&lt;/code&gt; options:</source>
          <target state="translated">这是所使用的 &lt;code&gt;git clean&lt;/code&gt; 选项的在线帮助文​​本：</target>
        </trans-unit>
        <trans-unit id="80fa3a5b6d70e6761f8985fdd6e2ecdeb0b34882" translate="yes" xml:space="preserve">
          <source>This technique is useful when, for some reason, you can't easily delete all of the untracked files by some ordinary mechanism (like rm).</source>
          <target state="translated">当由于某种原因,你无法通过一些普通的机制(如rm)轻易地删除所有未被跟踪的文件时,这种技术就很有用。</target>
        </trans-unit>
        <trans-unit id="1f8124b5c16b5fd081e0614cc45f57a3149cacb1" translate="yes" xml:space="preserve">
          <source>This will discard all changes which were made after that commit.</source>
          <target state="translated">这将丢弃所有在该提交之后所做的修改。</target>
        </trans-unit>
        <trans-unit id="48ef74511807e4984a8be1b2ff03f8014e243c25" translate="yes" xml:space="preserve">
          <source>This works even in directories that are; outside of normal git permissions.</source>
          <target state="translated">即使是在正常的git权限之外的目录中也可以使用。</target>
        </trans-unit>
        <trans-unit id="840522ea5495652351bf360bd472b3cec13403d1" translate="yes" xml:space="preserve">
          <source>To do a permanent discard:
&lt;code&gt;git reset --hard&lt;/code&gt;</source>
          <target state="translated">要永久丢弃： &lt;code&gt;git reset --hard&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9df261d84d1342fec04eee973e46058211d6ac08" translate="yes" xml:space="preserve">
          <source>To save changes for later:
&lt;code&gt;git stash&lt;/code&gt;</source>
          <target state="translated">要保存更改以供以后使用： &lt;code&gt;git stash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb758e77878dc87ac9bc038e9cf5cd33895820bc" translate="yes" xml:space="preserve">
          <source>Tried all the solutions above but still couldn't get rid of new, unstaged files.</source>
          <target state="translated">尝试了上面所有的解决方案,但仍然无法摆脱新的、未定格的文件。</target>
        </trans-unit>
        <trans-unit id="34ac0e36e8b6f6dc6c81473bc49f174e7c451fef" translate="yes" xml:space="preserve">
          <source>Updated per user comment below:
Variation to reset the to whatever current branch the user is on.</source>
          <target state="translated">根据下面的用户评论进行了更新。变化是将用户的分支重置为当前用户所在的任何分支。</target>
        </trans-unit>
        <trans-unit id="0fae9274cadaf5a62b8d077660a2fc6bd0ccfbd1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git clean -f&lt;/code&gt; to remove those new files - &lt;em&gt;with caution though!&lt;/em&gt; Note the force option.</source>
          <target state="translated">使用 &lt;code&gt;git clean -f&lt;/code&gt; 删除那些新文件- &lt;em&gt;但是要小心！&lt;/em&gt; 注意强制选项。</target>
        </trans-unit>
        <trans-unit id="054f5391b4b0019a1b99703d8745fdb99aff680e" translate="yes" xml:space="preserve">
          <source>What follows is really only a solution if you are working with a fork of a repository where you regularly synchronize (e.g. pull request) with another repo. Short answer: delete fork and refork, but &lt;strong&gt;read the warnings on github&lt;/strong&gt;.</source>
          <target state="translated">如果您使用的是存储库的派生库，并且在其中定期与另一个存储库定期进行同步（例如拉取请求），那么以下内容实际上只是一个解决方案。 简短的答案：删除fork和refork，但请&lt;strong&gt;阅读github上的警告&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">当从索引中检查出路径时,不要在未合并的条目中失败;相反,未合并的条目被忽略。</target>
        </trans-unit>
        <trans-unit id="339698f3b0818650e35a92a839071fd456c09740" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from HEAD. This is used to throw away local changes.</source>
          <target state="translated">切换分支时,即使索引或工作树与head不同,也要继续进行。这是用来扔掉局部变化。</target>
        </trans-unit>
        <trans-unit id="cf4964dd07c2993ac1859d71d57b7b394dc0ecd9" translate="yes" xml:space="preserve">
          <source>When you want to transfer a stash to someone else:</source>
          <target state="translated">当你想把藏品转让给别人的时候。</target>
        </trans-unit>
        <trans-unit id="5d25f19cf7fc6045ca7bcece484c02bdf1c4549f" translate="yes" xml:space="preserve">
          <source>While this command can also be used to restore the working tree to a specific commit or to restore the content of the index, by default, the working tree is restored to the state in the index (what is asked here).</source>
          <target state="translated">虽然这个命令也可以用来将工作树恢复到特定的提交或恢复索引的内容,但在默认情况下,工作树会被恢复到索引中的状态(这里要求的是)。</target>
        </trans-unit>
        <trans-unit id="91d13c281a07ada3b09124fbcef665fe08376db0" translate="yes" xml:space="preserve">
          <source>You can use git stash - if something goes wrong, you can still revert from the stash.
Similar to some other answer here, but this one also removes all unstaged files and also all unstaged deletes:</source>
          <target state="translated">你可以使用git stash--如果出了问题,你仍然可以从stash中恢复。和这里的一些其他答案类似,但这个也是删除所有未缓存的文件,也是删除所有未缓存的文件。</target>
        </trans-unit>
        <trans-unit id="3a786b2c6474e9d4945f7bd1392ad1016bb4e52c" translate="yes" xml:space="preserve">
          <source>You could create your own alias which describes how to do it in a descriptive way.</source>
          <target state="translated">你可以创建自己的别名,用描述性的方式来描述如何做。</target>
        </trans-unit>
        <trans-unit id="850fc0cdc183d0805afc8909ccea1eda9e804430" translate="yes" xml:space="preserve">
          <source>You don't need to include &lt;code&gt;--include-untracked&lt;/code&gt; if you don't want to be thorough about it.</source>
          <target state="translated">如果您不希望透彻了解，则无需包含 &lt;code&gt;--include-untracked&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38c85a26f680cdb6e74e127bf49b223b752a9de2" translate="yes" xml:space="preserve">
          <source>[edit] as commented, it &amp;iacute;s possible to name stashes. Well, use this if you want to share your stash ;)</source>
          <target state="translated">如评论所述，可以命名藏匿处。 好吧，如果您想共享存储空间，请使用它；）</target>
        </trans-unit>
        <trans-unit id="a71f1153b1446d4f3a1c243462ede23483d27947" translate="yes" xml:space="preserve">
          <source>e.g. &lt;code&gt;git checkout -- .&lt;/code&gt;</source>
          <target state="translated">例如 &lt;code&gt;git checkout -- .&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d43b64f144ca0689fea30adb6e5cb2150c971a0c" translate="yes" xml:space="preserve">
          <source>git add -A</source>
          <target state="translated">git add -A</target>
        </trans-unit>
        <trans-unit id="cf136d60baf6dbfd88ddc6f362f5619f4ffa9281" translate="yes" xml:space="preserve">
          <source>git reset --hard</source>
          <target state="translated">git重置 --hard</target>
        </trans-unit>
        <trans-unit id="f939b3ea803117df2cf35178a5068615ae3309ee" translate="yes" xml:space="preserve">
          <source>git rm .gitattributes</source>
          <target state="translated">git rm .gitattributes</target>
        </trans-unit>
        <trans-unit id="b36ac78bd6c3fab8ecba0ab82eec39608eda415e" translate="yes" xml:space="preserve">
          <source>git-clean - Remove untracked files from the working tree</source>
          <target state="translated">git-clean-从工作树中删除未被跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="e3826907be3b030bedd7b5dd69ab8984357e8c0d" translate="yes" xml:space="preserve">
          <source>if you check that everything is OK, throw the stash away:</source>
          <target state="translated">如果你检查一切正常,就把藏匿的东西扔了。</target>
        </trans-unit>
        <trans-unit id="b69f8baa9971a8a8eeb12eea1571ad9075d66776" translate="yes" xml:space="preserve">
          <source>or 
    git stash pop</source>
          <target state="translated">或git存储空间</target>
        </trans-unit>
        <trans-unit id="981cf047b6a7f7b88ac32ad8cd8a0ed27cf1c913" translate="yes" xml:space="preserve">
          <source>or this which checks out all files from the index, overwriting working tree files.</source>
          <target state="translated">或这个可以从索引中检查出所有文件,覆盖工作树文件。</target>
        </trans-unit>
        <trans-unit id="9072dcdd106620ddc2d34fe8b2f61bcb590fefd6" translate="yes" xml:space="preserve">
          <source>should do the trick. As per &lt;a href=&quot;https://git-scm.com/docs/git-clean/2.2.0&quot;&gt;Git documentation on git clean&lt;/a&gt;</source>
          <target state="translated">应该可以。 根据&lt;a href=&quot;https://git-scm.com/docs/git-clean/2.2.0&quot;&gt;git clean上的Git文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f07da77a32a6a913637dce1c7bf34b34e362b5f" translate="yes" xml:space="preserve">
          <source>simply say</source>
          <target state="translated">简单地说</target>
        </trans-unit>
        <trans-unit id="ffcd08491969c6b6c012c238c4b91150d946d9de" translate="yes" xml:space="preserve">
          <source>without the &lt;code&gt;-A&lt;/code&gt; the removed files will not be staged</source>
          <target state="translated">如果没有 &lt;code&gt;-A&lt;/code&gt; ，则不会暂存已删除的文件</target>
        </trans-unit>
        <trans-unit id="362810874f5225484e34025a86bc8884d1cb6217" translate="yes" xml:space="preserve">
          <source>you have a very simple git command &lt;code&gt;git checkout .&lt;/code&gt;</source>
          <target state="translated">你有一个非常简单的git命令 &lt;code&gt;git checkout .&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
