<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/52704">
    <body>
      <group id="52704">
        <trans-unit id="fed9ac100b0f08b31a7bd88c0c53e1f0ce411dc3" translate="yes" xml:space="preserve">
          <source>-d Remove untracked directories in addition to untracked files. If an untracked directory is managed by a different Git repository, it is
  not removed by default. Use -f option twice if you really want to
  remove such a directory.</source>
          <target state="translated">-d 추적되지 않은 파일 외에 추적되지 않은 디렉토리를 제거합니다. 추적되지 않은 디렉토리가 다른 Git 리포지토리에 의해 관리되는 경우 기본적으로 제거되지 않습니다. 그러한 디렉토리를 실제로 제거하려면 -f 옵션을 두 번 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c0689b1195a2d2494831311528c78cbd2c81d25f" translate="yes" xml:space="preserve">
          <source>-f
  --force If the Git configuration variable clean.requireForce is not set to false, git clean will refuse to run unless given -f, -n or -i.</source>
          <target state="translated">-f --force Git 구성 변수 clean.requireForce가 false로 설정되지 않은 경우 -f, -n 또는 -i를 지정하지 않으면 git clean이 실행을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="afc2d1dacec6bf8a41b596c662443a54f59b539e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://git-scm.com/docs/git-clean&quot;&gt;&lt;code&gt;git clean&lt;/code&gt;&lt;/a&gt; removes all untracked files (&lt;strong&gt;warning&lt;/strong&gt;: while it won't delete ignored files mentioned directly in .gitignore, &lt;strong&gt;it may delete ignored files residing in folders&lt;/strong&gt;) and &lt;code&gt;git checkout&lt;/code&gt; clears all unstaged changes.</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/docs/git-clean&quot;&gt; &lt;code&gt;git clean&lt;/code&gt; &lt;/a&gt; 은 추적되지 않은 모든 파일을 제거합니다 ( &lt;strong&gt;경고&lt;/strong&gt; : .gitignore에 직접 언급 된 무시 된 파일은 삭제하지 않지만 &lt;strong&gt;폴더에있는 무시 된 파일은 삭제할 수 있음&lt;/strong&gt; ) .git &lt;code&gt;git checkout&lt;/code&gt; 모든 스테이지되지 않은 변경 사항을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="2d7a7ed51e610e0e5e84ca28c30ed03480f47b5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt; here to remove &lt;a href=&quot;https://git-scm.com/docs/git-checkout#_argument_disambiguation&quot;&gt;argument ambiguation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 여기 &lt;a href=&quot;https://git-scm.com/docs/git-checkout#_argument_disambiguation&quot;&gt;모호한 주장&lt;/a&gt; 을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="72799af98b1f5308f3529726c1792cf61e182c2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-d&lt;/code&gt;: Remove untracked directories in addition to untracked files</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; : 추적되지 않은 파일 외에 추적되지 않은 디렉토리를 제거합니다</target>
        </trans-unit>
        <trans-unit id="53f62437a5af272cdc0c0f1087ed0fd5693a62f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-f&lt;/code&gt;: Force (might be not necessary depending on  &lt;code&gt;clean.requireForce&lt;/code&gt; setting)</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; : 힘 ( &lt;code&gt;clean.requireForce&lt;/code&gt; 설정에 따라 필요하지 않을 수 있음)</target>
        </trans-unit>
        <trans-unit id="a716245a2809abce91a9d776dbbfc112b617201a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add . -A&lt;/code&gt; instead of &lt;code&gt;git add .&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git add . -A&lt;/code&gt; &lt;code&gt;git add .&lt;/code&gt; 대신 -A .</target>
        </trans-unit>
        <trans-unit id="bb74c3f26ce1eb8d8c4c079f858137216a815cb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;man git-checkout&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;man git-checkout&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="94723bfd82f0ae0caf628ef46e610c3eec39a5cc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Be very careful with this later command however as you might discard files you did not intend to get rid of.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;그러나 제거하지 않으려는 파일을 버릴 수 있으므로이 나중 명령에 매우주의하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ddd1868251030fa30ddb023ff889dd017606c761" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2019 update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2019 년 업데이트 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d583721fdee9eda617809d6d5f0932df533809dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Description&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27d9508a3b74080e0b435baa8bf80d7d81a6bc0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I was able to fix the problem by deleting my forked repository and all local repositories, and reforking. This alone was not enough; upstream had to rename the files in question to new filenames.&lt;/strong&gt; As long as you don't have any uncommited work, no wikis, and no issues that diverge from the upstream repository, you should be just fine. Upstream may not be very happy with you, to say the least. As for my problem, it is undoubtedly a user error as I'm not that proficient with git, but the fact that it is far from easy to fix points to an issue with git as well.</source>
          <target state="translated">&lt;strong&gt;분기 저장소와 모든 로컬 저장소를 삭제하고 다시 분기하여 문제를 해결할 수있었습니다.&lt;/strong&gt; &lt;strong&gt;이것만으로는 충분하지 않았다.&lt;/strong&gt; &lt;strong&gt;업스트림은 문제의 파일 이름을 새 파일 이름으로 바꿔야했습니다.&lt;/strong&gt; 커밋되지 않은 작업, Wiki 및 업스트림 저장소와 다른 문제가없는 한 괜찮습니다. 상류층은 당신에게 만족하지 않을 수도 있습니다. 내 문제에 관해서는 의심 할 여지없이 git에 능숙하지 않기 때문에 사용자 오류이지만, git 관련 문제를 해결하기가 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1884cdfa60ba48980b662b025f75e0ba67f99cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Options&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Options&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0949b40739737db3aca0e50aed86aa96b9b8a4f" translate="yes" xml:space="preserve">
          <source>A handful of options are available for more nuanced stashing; see the documentation.</source>
          <target state="translated">미묘한 스 태싱을위한 몇 가지 옵션이 제공됩니다. 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b35af8cb225549965ddc586ff74ea587c627c5dc" translate="yes" xml:space="preserve">
          <source>A handful of other options are available for a quicker execution; see the documentation.</source>
          <target state="translated">더 빠른 실행을 위해 몇 가지 다른 옵션을 사용할 수 있습니다. 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bdb3d9d11666a557cb5dac66319c6a3bdc844f3e" translate="yes" xml:space="preserve">
          <source>A keen eye will note that these files have dopplegangers that are a single letter in case off. Somehow, and I have no idea what led me down this path to start with (as I was not working with these files myself from the upstream repo), I had switched these files. Try the many solutions listed on this page (and other pages) did not seem to help.</source>
          <target state="translated">예리한 눈을 가진 사람들은이 파일들이 도피 레 그런 저를 가지고 있다는 것을 알아 차릴 것입니다. 어쨌든,이 경로로 내려 가서 무엇을 시작했는지 알지 못합니다 (업스트림 저장소에서 직접이 파일을 사용하지 않았기 때문에)이 파일을 전환했습니다. 이 페이지 (및 다른 페이지)에 나열된 많은 솔루션이 도움이되지 않은 것처럼보십시오.</target>
        </trans-unit>
        <trans-unit id="b39d5ddf0fc59abdea98c912f732b3c25809600a" translate="yes" xml:space="preserve">
          <source>After that, you can drop that stash with a &lt;code&gt;git stash drop&lt;/code&gt; command if you like.</source>
          <target state="translated">그런 다음 원하는 경우 &lt;code&gt;git stash drop&lt;/code&gt; 명령으로 해당 숨김을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98e0506021752e4d376c394e1673d4fed4834a98" translate="yes" xml:space="preserve">
          <source>All changes will be moved to Git's Stash, for possible later access.</source>
          <target state="translated">모든 변경 사항은 나중에 액세스 할 수 있도록 Git 's Stash로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2dbf857966032bb2e5ee10d185df2f47b79c5d45" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;git checkout .&lt;/code&gt; needs to be done in the root of the repo.</source>
          <target state="translated">또한 &lt;code&gt;git checkout .&lt;/code&gt; repo의 루트에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4a3db2fca5b6d490e0d0666be31df78f925bfbd" translate="yes" xml:space="preserve">
          <source>And to remove all unstaged changes in the current repository:</source>
          <target state="translated">현재 저장소에서 모든 비 단계적 변경 사항을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="00bae78952a21817e9ff9b8f29e228f4b557b7a5" translate="yes" xml:space="preserve">
          <source>Another quicker way is:</source>
          <target state="translated">또 다른 빠른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="629f09ca4ad9b66bb50fa2c4dcda91208cf09d47" translate="yes" xml:space="preserve">
          <source>Another way to get rid of new files that is more specific than git clean -df (it will allow you to get rid of some files not necessarily all), is to add the new files to the index first, then stash, then drop the stash.</source>
          <target state="translated">git clean -df보다 더 구체적인 새 파일을 제거하는 또 다른 방법은 (일부 파일을 모두 제거 할 수는 없지만) 새 파일을 먼저 색인에 추가 한 다음 숨겨 놓는 것입니다. 숨기는 장소.</target>
        </trans-unit>
        <trans-unit id="3ab852661ea78d7491e0b8d339b188a5a85861c6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git checkout -- .&lt;/code&gt;, this will only discard changes to files tracked by Git and will not discard any new untracked files. If you want to discard any unstaged changes, including new untracked files, you could run an additional:</source>
          <target state="translated">&lt;code&gt;git checkout -- .&lt;/code&gt; 과 마찬가지로 -. , 이것은 Git에 의해 추적 된 파일에 대한 변경 사항 만 버리고 추적되지 않은 새로운 파일은 버리지 않습니다. 추적되지 않은 새 파일을 포함하여 준비되지 않은 변경 사항을 삭제하려면 추가로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bb06bd83e97a5112661b65ead766c7aefb3ca6f" translate="yes" xml:space="preserve">
          <source>As you type git status, 
&lt;strong&gt;(use &quot;git checkout -- ...&quot; to discard changes in working directory)&lt;/strong&gt;
is shown.</source>
          <target state="translated">git status를 입력하면 &lt;strong&gt;( &quot;git checkout-...&quot;을 사용하여 작업 디렉토리의 변경 사항을 버립니다)&lt;/strong&gt; 가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9e4b2a87fb0c352693a1bd2db71c132ee44b38d5" translate="yes" xml:space="preserve">
          <source>Clean and discard changes and untracked files in working tree</source>
          <target state="translated">작업 트리에서 변경 내용과 추적되지 않은 파일을 정리하고 삭제</target>
        </trans-unit>
        <trans-unit id="42dcbc11ebcca8013128e188e07a667fd189817d" translate="yes" xml:space="preserve">
          <source>Cleans the working tree by recursively removing files that
  are not under version control, starting from the current directory.</source>
          <target state="translated">현재 디렉토리에서 시작하여 버전 제어를받지 않는 파일을 재귀 적으로 제거하여 작업 트리를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="0854cfe68459fb9743ea87944a08ab9f2f41c3f2" translate="yes" xml:space="preserve">
          <source>Discard changes in a (list of) file(s) in working tree</source>
          <target state="translated">작업 트리의 파일 목록에서 변경 사항을 버리십시오.</target>
        </trans-unit>
        <trans-unit id="3703c5109b970db48fd2ad0fd5b85c35cce1361a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the ignore rules from &lt;code&gt;.gitignore&lt;/code&gt; (per directory) and &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;, but do still use the ignore rules given with &lt;code&gt;-e&lt;/code&gt; options. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with &lt;code&gt;git reset&lt;/code&gt;) to create a pristine working directory to test a clean build.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; (디렉토리 당) 및 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 의 무시 규칙을 사용하지 말고 여전히 &lt;code&gt;-e&lt;/code&gt; 옵션과 함께 제공된 무시 규칙을 사용하십시오. 이를 통해 빌드 제품을 포함하여 추적되지 않은 모든 파일을 제거 할 수 있습니다. 이것은 &lt;code&gt;git reset&lt;/code&gt; 과 함께 사용되어 깨끗한 빌드를 테스트하기 위해 깨끗한 작업 디렉토리를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82021c36126c9d2972b261fbe6e9eed34c3be7aa" translate="yes" xml:space="preserve">
          <source>Done. Easy.</source>
          <target state="translated">끝난. 쉬운.</target>
        </trans-unit>
        <trans-unit id="1ad395b6696331a11075129d3a05a93a404bde8f" translate="yes" xml:space="preserve">
          <source>For a specific file use:</source>
          <target state="translated">특정 파일 사용 :</target>
        </trans-unit>
        <trans-unit id="30d953d36f4d87f6c54e1ffe33fd2c7b4568ac7f" translate="yes" xml:space="preserve">
          <source>For all unstaged files in current working directory use:</source>
          <target state="translated">현재 작업 디렉토리에있는 모든 스테이지되지 않은 파일의 경우 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2fc195e08169ea5ea29dab03ebd736643c24c496" translate="yes" xml:space="preserve">
          <source>Happened to me recently</source>
          <target state="translated">최근에 나에게 일어난</target>
        </trans-unit>
        <trans-unit id="864d442672a2358879583b94bf582ea97a8424c9" translate="yes" xml:space="preserve">
          <source>How do I discard changes in my working copy that are not in the index?</source>
          <target state="translated">색인에없는 작업 사본의 변경 사항을 어떻게 버립니까?</target>
        </trans-unit>
        <trans-unit id="1fce62b7a2652a934ca474f0c5c63bb8b3b6e6c2" translate="yes" xml:space="preserve">
          <source>How do I discard unstaged changes in Git</source>
          <target state="translated">Git에서 스테이지되지 않은 변경 사항을 버리는 방법</target>
        </trans-unit>
        <trans-unit id="eb60139211fc9388fb2f815a246c52e21943c2e4" translate="yes" xml:space="preserve">
          <source>I had a similar problem, perhaps not identical, and I'm sad to say my solution is not ideal, but it is ultimately effective.</source>
          <target state="translated">비슷한 문제가 있었는데 아마도 동일하지는 않았으며 솔루션이 이상적이지 않다는 것이 슬프지만 궁극적으로 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="ee7ba19ebd0319622aee0d033dc1de473768df0f" translate="yes" xml:space="preserve">
          <source>I had a weird situation where a file is always unstaged, this helps me to resolve.</source>
          <target state="translated">파일이 항상 준비되지 않은 이상한 상황이 발생하여 해결하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ad84e904a2bcf085535faf5356692e18f46fe974" translate="yes" xml:space="preserve">
          <source>I really found this article helpful for explaining when to use what command: &lt;a href=&quot;http://www.szakmeister.net/blog/2011/oct/12/reverting-changes-git/&quot;&gt;http://www.szakmeister.net/blog/2011/oct/12/reverting-changes-git/&lt;/a&gt;</source>
          <target state="translated">나는이 기사가 어떤 명령을 사용 해야하는지 설명하는 데 도움이된다는 것을 실제로 발견했습니다 &lt;a href=&quot;http://www.szakmeister.net/blog/2011/oct/12/reverting-changes-git/&quot;&gt;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e6cde860870936f1e6000fe5438f36756de4bc6" translate="yes" xml:space="preserve">
          <source>I suspect that using &lt;code&gt;git stash&lt;/code&gt; is a popular choice since it's a little less dangerous.  You can always go back to it if you accidently blow too much away when using git reset.  Reset is recursive by default.</source>
          <target state="translated">&lt;code&gt;git stash&lt;/code&gt; 를 사용하는 것이 덜 위험하기 때문에 인기있는 선택이라고 생각합니다. git reset을 사용할 때 실수로 너무 많이 날리면 언제든지 다시 돌아갈 수 있습니다. 재설정은 기본적으로 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="3587b4e2335f7d08a6418b42308fa22c6a17d065" translate="yes" xml:space="preserve">
          <source>I think there is 1 more change (don't know why this worked for me before):</source>
          <target state="translated">나는 더 많은 변화가 있다고 생각합니다 (이전에 왜 그것이 효과가 있었는지 모르겠습니다).</target>
        </trans-unit>
        <trans-unit id="8335e2269ae8550747eb62a058eaf6b8da22da46" translate="yes" xml:space="preserve">
          <source>I use the next alias to discard changes.</source>
          <target state="translated">다음 별칭을 사용하여 변경 사항을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="3dd312407e6bafcf3506f4027cc72a8a6476cbcd" translate="yes" xml:space="preserve">
          <source>I would often have git status messages like this (involving at least 2/4 files):</source>
          <target state="translated">나는 종종 다음과 같은 git status 메시지를 가질 것입니다 (최소 2/4 파일 포함).</target>
        </trans-unit>
        <trans-unit id="8816b09a32358ab8c2c7fac6aad970834a86eb5e" translate="yes" xml:space="preserve">
          <source>If any optional ... arguments are given, only those paths are
  affected.</source>
          <target state="translated">선택적 ... 인수가 제공되면 해당 경로 만 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="529d47024d50b097a96e1e2122d526c7f5d4d692" translate="yes" xml:space="preserve">
          <source>If the Git configuration variable &lt;code&gt;clean.requireForce&lt;/code&gt; is not set to &lt;code&gt;false&lt;/code&gt;, Git clean will refuse to delete files or directories unless given &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-n&lt;/code&gt;, or &lt;code&gt;-i&lt;/code&gt;. Git will refuse to delete directories within the &lt;code&gt;.git&lt;/code&gt; subdirectory or file, unless a second &lt;code&gt;-f&lt;/code&gt; is given.</source>
          <target state="translated">Git 구성 변수 &lt;code&gt;clean.requireForce&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 설정되지 않은 경우, Git clean은 &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;-i&lt;/code&gt; 를 지정하지 않으면 파일 또는 디렉토리 삭제를 거부합니다. Git은 두 번째 &lt;code&gt;-f&lt;/code&gt; 를 지정하지 않으면 &lt;code&gt;.git&lt;/code&gt; 서브 디렉토리 또는 파일 내의 디렉토리 삭제를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="a876d321713c260c6efea388116771a1af8f9749" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;really&lt;/em&gt; care about your stash stack then you can follow with &lt;code&gt;git stash drop&lt;/code&gt;. But at that point you're better off using (from Mariusz Nowak):</source>
          <target state="translated">숨김 스택에 관심이 있다면 &lt;code&gt;git stash drop&lt;/code&gt; 을 따를 수 있습니다. 그러나 그 시점에서 (Mariusz Nowak에서) 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6b1ae5b423635758e0a25c5cc6760e00e87b9176" translate="yes" xml:space="preserve">
          <source>If you aren't interested in keeping the unstaged changes (especially if the staged changes are new files), I found this handy:</source>
          <target state="translated">준비되지 않은 변경 사항을 유지하지 않으려는 경우 (특히 준비된 변경 사항이 새 파일 인 경우) 다음과 같이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="dd23bb8ae4a841004bc72ddbfb3a7f79fc1cfbac" translate="yes" xml:space="preserve">
          <source>If you have staged the file, then use git reset.  Reset changes the index to match a commit.</source>
          <target state="translated">파일을 준비한 경우 git reset을 사용하십시오. 재설정은 커밋과 일치하도록 인덱스를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="3bd1003c321636caa648ef432ab3c21b2f41bed5" translate="yes" xml:space="preserve">
          <source>If you haven't staged the file, then you use &lt;code&gt;git checkout&lt;/code&gt;.  Checkout &quot;updates files in the working tree to match the version in the index&quot;.  If the files have not been staged (aka added to the index)... this command will essentially revert the files to what your last commit was.</source>
          <target state="translated">파일을 준비하지 않았다면 &lt;code&gt;git checkout&lt;/code&gt; 을 사용하십시오. Checkout &quot;작업 트리의 파일을 색인의 버전과 일치하도록 업데이트합니다&quot;. 파일이 준비되지 않은 경우 (일명 색인에 추가됨) ...이 명령은 기본적으로 파일을 마지막 커밋으로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="f8d19102a6786fdcfae490d52ca3fc8f40c3495a" translate="yes" xml:space="preserve">
          <source>If you merely wish &lt;strong&gt;to remove changes to existing files&lt;/strong&gt;, use &lt;code&gt;checkout&lt;/code&gt; (&lt;a href=&quot;https://git-scm.com/docs/git-checkout&quot;&gt;documented here&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;기존 파일에 대한 변경 사항&lt;/strong&gt; 만 &lt;strong&gt;제거&lt;/strong&gt; 하려면 &lt;code&gt;checkout&lt;/code&gt; ( &lt;a href=&quot;https://git-scm.com/docs/git-checkout&quot;&gt;여기에 설명되어 있음&lt;/a&gt; )을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="79cad392748bde549e75bc03a7473563f1e11676" translate="yes" xml:space="preserve">
          <source>If you want &lt;strong&gt;to remove files added&lt;/strong&gt; since your last commit, use &lt;code&gt;clean&lt;/code&gt; (&lt;a href=&quot;https://git-scm.com/docs/git-clean&quot;&gt;documented here&lt;/a&gt;):</source>
          <target state="translated">마지막 커밋 이후 &lt;strong&gt;추가 된 파일을 제거&lt;/strong&gt; 하려면 &lt;code&gt;clean&lt;/code&gt; ( &lt;a href=&quot;https://git-scm.com/docs/git-clean&quot;&gt;here 문서화 됨&lt;/a&gt; )을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="94bef346d72e50bfd317274138d0f36470fc38a2" translate="yes" xml:space="preserve">
          <source>If you wish &lt;strong&gt;to move changes to a holding space for later access&lt;/strong&gt;, use &lt;code&gt;stash&lt;/code&gt; (&lt;a href=&quot;https://git-scm.com/docs/git-stash&quot;&gt;documented here&lt;/a&gt;):</source>
          <target state="translated">&lt;strong&gt;나중에 액세스 할 수 있도록 변경 사항을 보류 공간으로 이동&lt;/strong&gt; 하려면 &lt;code&gt;stash&lt;/code&gt; 사용 &lt;a href=&quot;https://git-scm.com/docs/git-stash&quot;&gt;하십시오&lt;/a&gt; ( 여기에 문서화 됨 ).</target>
        </trans-unit>
        <trans-unit id="c8f0dcd22582ea400212c4bf2bf1ecb8196f22a0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;git status&lt;/code&gt;, now Git recommends using this command instead of &lt;code&gt;git checkout&lt;/code&gt; as it used to.</source>
          <target state="translated">&lt;code&gt;git status&lt;/code&gt; 에서 Git은 &lt;code&gt;git checkout&lt;/code&gt; 대신이 명령을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6a66d8064b895089a51d39f45d330836cf5cf130" translate="yes" xml:space="preserve">
          <source>In git command, stashing of untracked files is achieved by using:</source>
          <target state="translated">git 명령에서 추적되지 않은 파일의 숨김은 다음을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4f9dfa38b31d7d270d8aa454fe54f373205f54e8" translate="yes" xml:space="preserve">
          <source>In my opinion,</source>
          <target state="translated">제 생각에는</target>
        </trans-unit>
        <trans-unit id="a710bcb2db12bb6ea9b79bfea29fc08590a3fc1e" translate="yes" xml:space="preserve">
          <source>Instead of discarding changes, I reset my remote to the origin. Note - this method is to completely restore your folder to that of the repo.</source>
          <target state="translated">변경 사항을 버리는 대신 리모컨을 원점으로 재설정했습니다. 참고-이 방법은 폴더를 리포지토리의 폴더로 완전히 복원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e4ce5f1cd096b70edf7ccafdff1608da7b9a35c2" translate="yes" xml:space="preserve">
          <source>It seems like the complete solution is:</source>
          <target state="translated">완전한 해결책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19c8ae84a2a96946e0800bd4424233488d724cbe" translate="yes" xml:space="preserve">
          <source>It will remove all your local changes. You also can use later by saying</source>
          <target state="translated">모든 로컬 변경 사항이 제거됩니다. 당신은 또한 말함으로써 나중에 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="098c5131b876d1833842c7915ad8820685fc825d" translate="yes" xml:space="preserve">
          <source>Just use:</source>
          <target state="translated">그냥 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="94314a06159d9c31a2ff55cd1415fe59ca943e2b" translate="yes" xml:space="preserve">
          <source>My favorite is</source>
          <target state="translated">내가 가장 좋아하는 것은</target>
        </trans-unit>
        <trans-unit id="c5c68720f904987895c38abb89689c82d8316808" translate="yes" xml:space="preserve">
          <source>NOTE: If you want to keep files not yet tracked, but not in GITIGNORE you may wish to skip this step, as it will Wipe these untracked files not found on your remote repository (thanks @XtrmJosh).</source>
          <target state="translated">참고 : 아직 추적되지 않았지만 GITIGNORE에서는 파일을 유지하지 않으려면 원격 저장소에서 찾을 수없는 추적되지 않은 파일 (@XtrmJosh 덕분에)을 지우므로이 단계를 건너 뛰어도됩니다.</target>
        </trans-unit>
        <trans-unit id="90f19de07eaa816f337291f8dbf8ed55cc13ebbe" translate="yes" xml:space="preserve">
          <source>No branch is specified, so it checks out the current branch.</source>
          <target state="translated">분기가 지정되지 않았으므로 현재 분기를 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="b9c6e3583ee2c594287b4a6fc73da8e7b11401d3" translate="yes" xml:space="preserve">
          <source>No matter what state your repo is in you can always reset to any previous commit:</source>
          <target state="translated">리포지토리 상태에 관계없이 언제든지 이전 커밋으로 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4336fe427713d23c760add6d199455e6017811f" translate="yes" xml:space="preserve">
          <source>Nonetheless, I like &lt;code&gt;git stash -u&lt;/code&gt; the best because it &quot;discards&quot; all tracked and untracked changes in just &lt;em&gt;one command&lt;/em&gt;. Yet &lt;code&gt;git checkout -- .&lt;/code&gt; only discards tracked changes,
and &lt;code&gt;git clean -df&lt;/code&gt; only discards untracked changes... and typing both commands is &lt;em&gt;far&lt;/em&gt; too much work :)</source>
          <target state="translated">그럼에도 불구하고, 나는 &lt;em&gt;하나의 명령으로&lt;/em&gt; 모든 추적 및 추적되지 않은 변경 사항을 &quot;삭제&quot; &lt;code&gt;git stash -u&lt;/code&gt; 가 가장 좋습니다. 그러나 &lt;code&gt;git checkout -- .&lt;/code&gt; 추적 된 변경 사항 만 버리고 &lt;code&gt;git clean -df&lt;/code&gt; 는 추적되지 않은 변경 사항 만 버립니다 ... 두 명령을 입력하면 너무 많은 작업이 발생합니다 :)</target>
        </trans-unit>
        <trans-unit id="396cec2961d1019f503136da105dd323f822741b" translate="yes" xml:space="preserve">
          <source>Normally, only files unknown to Git are removed, but if the -x option
  is specified, ignored files are also removed. This can, for example,
  be useful to remove all build products.</source>
          <target state="translated">일반적으로 Git에 알려지지 않은 파일 만 제거되지만 -x 옵션을 지정하면 무시 된 파일도 제거됩니다. 예를 들어 모든 빌드 제품을 제거하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b667358b3ffd2bdbf9e8690c38a516866fc3d10" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;git restore&lt;/code&gt;: as this is a new command, &lt;a href=&quot;https://git-scm.com/docs/git-restore/2.23.0&quot;&gt;its man page&lt;/a&gt; gives a warning:</source>
          <target state="translated">&lt;code&gt;git restore&lt;/code&gt; 에 대한 참고 사항 : 이것은 새로운 명령이므로 &lt;a href=&quot;https://git-scm.com/docs/git-restore/2.23.0&quot;&gt;맨 페이지&lt;/a&gt; 에 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="971dcad694fa90c95d79cb3e35f8800172a46f99" translate="yes" xml:space="preserve">
          <source>Now is available in the next Github repo which contains a lot of aliases:</source>
          <target state="translated">이제 다음 Github 저장소에서 많은 별명을 포함하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e095f37cbb08d62af2ddc2eb1cb1d7393138c7" translate="yes" xml:space="preserve">
          <source>Or just a file:</source>
          <target state="translated">또는 단지 파일 :</target>
        </trans-unit>
        <trans-unit id="4d0f3ef1dd38153720613b554c65d9bbcfc7d902" translate="yes" xml:space="preserve">
          <source>Otherwise, if you want to discard all changes and also the untracked files, I use a mix of checkout and clean:</source>
          <target state="translated">그렇지 않으면 모든 변경 사항과 추적되지 않은 파일을 모두 삭제하려면 체크 아웃과 정리를 혼합하여 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="478b2510a9b32cfb4adf26e1a8d78520b35a469c" translate="yes" xml:space="preserve">
          <source>Remove untracked directories in addition to untracked files. If an untracked directory is managed by a different Git repository, it is not removed by default. Use &lt;code&gt;-f&lt;/code&gt; option twice if you really want to remove such a directory.</source>
          <target state="translated">추적되지 않은 파일 외에 추적되지 않은 디렉토리를 제거하십시오. 추적되지 않은 디렉토리가 다른 Git 리포지토리에 의해 관리되는 경우 기본적으로 제거되지 않습니다. 그러한 디렉토리를 실제로 제거하려면 &lt;code&gt;-f&lt;/code&gt; 옵션을 두 번 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6d80714ab625f9250b860a48bb052401b69c068c" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;git help clean&lt;/code&gt; to see the manual</source>
          <target state="translated">&lt;code&gt;git help clean&lt;/code&gt; 을 실행하여 매뉴얼을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="5f08bd2d55361c1ba94df735ac5ccb3fa855221c" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://github.com/git/git/commit/f496b064fc1135e0dded7f93d85d72eb0b302c22&quot;&gt;July 2019&lt;/a&gt;, there has been a new command which does exactly this: &lt;code&gt;git restore&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/git/git/commit/f496b064fc1135e0dded7f93d85d72eb0b302c22&quot;&gt;2019&lt;/a&gt; 년 7 월 부터 정확하게 &lt;code&gt;git restore&lt;/code&gt; 명령을 수행하는 새로운 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="04acd8c1f0e76597bca9508038665bb9b88a4344" translate="yes" xml:space="preserve">
          <source>Since no answer suggests the exact option combination that I use, here it is:</source>
          <target state="translated">내가 사용하는 정확한 옵션 조합을 제안하는 답변이 없으므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b010ecc92659c76e1f93d2a5401f106185699a12" translate="yes" xml:space="preserve">
          <source>So I do this to make sure they don't sit there when I git reset (later - excludes gitignores on the Origin/branchname)</source>
          <target state="translated">그래서 내가 자식 재설정 할 때 그들이 거기에 앉지 않도록하기 위해이 작업을 수행합니다 (나중에-출발지 / 지점 이름에서 gitignores 제외)</target>
        </trans-unit>
        <trans-unit id="32b93eceaf5edd5bbbe16dce5b2ef08bf8c1641c" translate="yes" xml:space="preserve">
          <source>So it is possible that this answer might become outdated if the behaviour does change in the future. It might thus be wise to run a quick &lt;code&gt;man git-restore&lt;/code&gt; before using it.</source>
          <target state="translated">따라서 앞으로 동작이 변경되면이 답변이 오래 될 수 있습니다. 따라서 빠른 &lt;code&gt;man git-restore&lt;/code&gt; 를 사용하기 전에 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="96d550362eff6a29040d66c0bc830c58b2c76f8c" translate="yes" xml:space="preserve">
          <source>So the use is simple as next:</source>
          <target state="translated">따라서 다음과 같이 사용이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="16ec2b549f9cf7514b2409954745896f69ab7d7e" translate="yes" xml:space="preserve">
          <source>So, in order to restore the files matching a pathspec (getting rid of their unstaged changes), you would do:</source>
          <target state="translated">따라서 경로 지정과 일치하는 파일을 복원하려면 (단계별되지 않은 변경 사항 제거) 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7e6294c015403474dc533fce25008ae9e9ef152a" translate="yes" xml:space="preserve">
          <source>Take a look at the article above for further advice.</source>
          <target state="translated">자세한 내용은 위 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c87610aaa7616e71adb720d209bde226e5b0bdf" translate="yes" xml:space="preserve">
          <source>That lets you selectively revert chunks.</source>
          <target state="translated">청크를 선택적으로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a625cdf5db5e1eadfae9daa74b20d41adaf50ccf" translate="yes" xml:space="preserve">
          <source>That will put it back to square one. Just like RE-Cloning the branch, WHILE keeping all my gitignored files locally and in place.</source>
          <target state="translated">그것은 다시 정사각형으로 되돌릴 것입니다. 지사를 다시 복제하는 것과 마찬가지로 모든 지정된 파일을 로컬에 보관합니다.</target>
        </trans-unit>
        <trans-unit id="6b79228633a397f43b5ec158dc62bd7b541c62f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-i&lt;/code&gt; option initiates an interactive &lt;code&gt;clean&lt;/code&gt;, to prevent mistaken deletions.</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; 옵션은 대화식 &lt;code&gt;clean&lt;/code&gt; 시작하여 실수로 삭제하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="34a4059081536a4ba0807042845f6d37b9ed4564" translate="yes" xml:space="preserve">
          <source>The answer from Bilal Maqsood with &lt;code&gt;git clean&lt;/code&gt; also worked for me, but with the stash I have more control - if I do sth accidentally, I can still get my changes back</source>
          <target state="translated">&lt;code&gt;git clean&lt;/code&gt; 으로 Bilal Maqsood의 답변도 나에게 도움이되었지만 숨은 자세로 더 많은 통제력을 얻었습니다. 실수로 sth를 수행해도 여전히 변경 사항을 되돌릴 수 있습니다</target>
        </trans-unit>
        <trans-unit id="62345698e50d705132cfe6c077bc2d02c9628493" translate="yes" xml:space="preserve">
          <source>The double-hyphen (&lt;code&gt;--&lt;/code&gt;) tells Git that what follows should be taken as its second argument (path), that you skipped specification of a branch.</source>
          <target state="translated">이중 하이픈 ( &lt;code&gt;--&lt;/code&gt; )은 Git에 분기의 사양을 건너 뛰었다는 것을 두 번째 인수 (경로)로 취해야한다고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="1909fa0ba14ff86f3491b939c47fed3b8449c198" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is by using this command:</source>
          <target state="translated">가장 쉬운 방법은 다음 명령을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e827872d90fac1fb3bc15c8233749d210363511" translate="yes" xml:space="preserve">
          <source>The period (&lt;code&gt;.&lt;/code&gt;) indicates all paths.</source>
          <target state="translated">마침표 ( &lt;code&gt;.&lt;/code&gt; )는 모든 경로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="af0d1b4328276812686a9206c83d6172e0087443" translate="yes" xml:space="preserve">
          <source>Then I</source>
          <target state="translated">그럼 내가</target>
        </trans-unit>
        <trans-unit id="33de23d10db20d49224f8ef3b6bfe6a9ced5e313" translate="yes" xml:space="preserve">
          <source>Then I reset to origin</source>
          <target state="translated">그런 다음 원점으로 재설정</target>
        </trans-unit>
        <trans-unit id="76b16061fde005910f67c6e862f0d2f89d69be22" translate="yes" xml:space="preserve">
          <source>Then you can use it as next to discard all changes:</source>
          <target state="translated">그런 다음 다음으로 사용하여 모든 변경 사항을 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a58f32e5d8df2105e56e8f81f5a86e77ad4892f" translate="yes" xml:space="preserve">
          <source>There are a couple different cases:</source>
          <target state="translated">몇 가지 다른 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c3d16189699026ec8beb0dd2eed7cb1d8710f3" translate="yes" xml:space="preserve">
          <source>This checks out the current index for the current directory, throwing away all changes in files from the current directory downwards.</source>
          <target state="translated">현재 디렉토리의 현재 색인을 검사하여 현재 디렉토리에서 파일의 모든 변경 사항을 아래쪽으로 버립니다.</target>
        </trans-unit>
        <trans-unit id="0e4a34fc85d235e5640196e9fff5dfa6f28d404f" translate="yes" xml:space="preserve">
          <source>This command is experimental. The behavior may change.</source>
          <target state="translated">이 명령은 실험적입니다. 동작이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56c33c8ae8b1c644ac03d5c863fdcb0c359f2c14" translate="yes" xml:space="preserve">
          <source>This command is used to discard changes in working directory -</source>
          <target state="translated">이 명령은 작업 디렉토리의 변경 사항을 삭제하는 데 사용됩니다-</target>
        </trans-unit>
        <trans-unit id="5cc465bdc8bdd458dd144f1d0a2b1ddcbfd3ad74" translate="yes" xml:space="preserve">
          <source>This is the online help text for the used &lt;code&gt;git clean&lt;/code&gt; options:</source>
          <target state="translated">다음은 사용 된 &lt;code&gt;git clean&lt;/code&gt; 옵션에 대한 온라인 도움말입니다.</target>
        </trans-unit>
        <trans-unit id="80fa3a5b6d70e6761f8985fdd6e2ecdeb0b34882" translate="yes" xml:space="preserve">
          <source>This technique is useful when, for some reason, you can't easily delete all of the untracked files by some ordinary mechanism (like rm).</source>
          <target state="translated">이 기법은 어떤 이유로 든 일반적인 메커니즘 (예 : rm)으로 추적되지 않은 모든 파일을 쉽게 삭제할 수없는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1f8124b5c16b5fd081e0614cc45f57a3149cacb1" translate="yes" xml:space="preserve">
          <source>This will discard all changes which were made after that commit.</source>
          <target state="translated">커밋 후에 이루어진 모든 변경 사항이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="48ef74511807e4984a8be1b2ff03f8014e243c25" translate="yes" xml:space="preserve">
          <source>This works even in directories that are; outside of normal git permissions.</source>
          <target state="translated">이것은 디렉토리에도 작동합니다. 일반적인 자식 권한 외부.</target>
        </trans-unit>
        <trans-unit id="840522ea5495652351bf360bd472b3cec13403d1" translate="yes" xml:space="preserve">
          <source>To do a permanent discard:
&lt;code&gt;git reset --hard&lt;/code&gt;</source>
          <target state="translated">영구 폐기를하려면 : &lt;code&gt;git reset --hard&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9df261d84d1342fec04eee973e46058211d6ac08" translate="yes" xml:space="preserve">
          <source>To save changes for later:
&lt;code&gt;git stash&lt;/code&gt;</source>
          <target state="translated">나중에 변경 사항을 저장하려면 &lt;code&gt;git stash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb758e77878dc87ac9bc038e9cf5cd33895820bc" translate="yes" xml:space="preserve">
          <source>Tried all the solutions above but still couldn't get rid of new, unstaged files.</source>
          <target state="translated">위의 모든 솔루션을 시도했지만 아직 준비되지 않은 새 파일을 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="34ac0e36e8b6f6dc6c81473bc49f174e7c451fef" translate="yes" xml:space="preserve">
          <source>Updated per user comment below:
Variation to reset the to whatever current branch the user is on.</source>
          <target state="translated">아래의 사용자 의견에 따라 업데이트되었습니다 : 사용자가있는 현재 분기로 재설정하는 변형.</target>
        </trans-unit>
        <trans-unit id="0fae9274cadaf5a62b8d077660a2fc6bd0ccfbd1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git clean -f&lt;/code&gt; to remove those new files - &lt;em&gt;with caution though!&lt;/em&gt; Note the force option.</source>
          <target state="translated">&lt;code&gt;git clean -f&lt;/code&gt; 를 사용하여 새 파일을 제거하십시오 &lt;em&gt;.&lt;/em&gt; 강제 옵션에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="054f5391b4b0019a1b99703d8745fdb99aff680e" translate="yes" xml:space="preserve">
          <source>What follows is really only a solution if you are working with a fork of a repository where you regularly synchronize (e.g. pull request) with another repo. Short answer: delete fork and refork, but &lt;strong&gt;read the warnings on github&lt;/strong&gt;.</source>
          <target state="translated">다음은 다른 리포지토리와 정기적으로 동기화 (예 : 풀 요청)하는 리포지토리 포크로 작업하는 경우 실제로 솔루션 일뿐입니다. 짧은 대답 : 포크와 포크를 삭제하지만 &lt;strong&gt;github의 경고를 읽으십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">색인에서 경로를 체크 아웃 할 때 병합되지 않은 항목에 실패하지 마십시오. 대신 병합되지 않은 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="339698f3b0818650e35a92a839071fd456c09740" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from HEAD. This is used to throw away local changes.</source>
          <target state="translated">분기를 전환 할 때 색인 또는 작업 트리가 HEAD와 다른 경우에도 진행하십시오. 로컬 변경 사항을 버리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf4964dd07c2993ac1859d71d57b7b394dc0ecd9" translate="yes" xml:space="preserve">
          <source>When you want to transfer a stash to someone else:</source>
          <target state="translated">숨김을 다른 사람에게 이전하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="5d25f19cf7fc6045ca7bcece484c02bdf1c4549f" translate="yes" xml:space="preserve">
          <source>While this command can also be used to restore the working tree to a specific commit or to restore the content of the index, by default, the working tree is restored to the state in the index (what is asked here).</source>
          <target state="translated">이 명령을 사용하여 작업 트리를 특정 커밋으로 복원하거나 색인의 내용을 복원 할 수도 있지만 기본적으로 작업 트리는 색인의 상태 (여기에서 요청 된 상태)로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="91d13c281a07ada3b09124fbcef665fe08376db0" translate="yes" xml:space="preserve">
          <source>You can use git stash - if something goes wrong, you can still revert from the stash.
Similar to some other answer here, but this one also removes all unstaged files and also all unstaged deletes:</source>
          <target state="translated">git stash를 사용할 수 있습니다-무언가 잘못되면 여전히 숨김에서 되돌릴 수 있습니다. 여기에있는 다른 답변과 비슷하지만이 파일은 준비되지 않은 모든 파일과 모든 준비되지 않은 삭제도 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3a786b2c6474e9d4945f7bd1392ad1016bb4e52c" translate="yes" xml:space="preserve">
          <source>You could create your own alias which describes how to do it in a descriptive way.</source>
          <target state="translated">설명적인 방법으로 설명하는 고유 한 별명을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="850fc0cdc183d0805afc8909ccea1eda9e804430" translate="yes" xml:space="preserve">
          <source>You don't need to include &lt;code&gt;--include-untracked&lt;/code&gt; if you don't want to be thorough about it.</source>
          <target state="translated">철저히 원하지 않는 경우 &lt;code&gt;--include-untracked&lt;/code&gt; 를 포함 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="38c85a26f680cdb6e74e127bf49b223b752a9de2" translate="yes" xml:space="preserve">
          <source>[edit] as commented, it &amp;iacute;s possible to name stashes. Well, use this if you want to share your stash ;)</source>
          <target state="translated">의견대로 주석을 붙일 수 있습니다. 당신이 은닉을 공유하고 싶다면 이것을 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="a71f1153b1446d4f3a1c243462ede23483d27947" translate="yes" xml:space="preserve">
          <source>e.g. &lt;code&gt;git checkout -- .&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;git checkout -- .&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d43b64f144ca0689fea30adb6e5cb2150c971a0c" translate="yes" xml:space="preserve">
          <source>git add -A</source>
          <target state="translated">자식 추가 -A</target>
        </trans-unit>
        <trans-unit id="cf136d60baf6dbfd88ddc6f362f5619f4ffa9281" translate="yes" xml:space="preserve">
          <source>git reset --hard</source>
          <target state="translated">git reset-하드</target>
        </trans-unit>
        <trans-unit id="f939b3ea803117df2cf35178a5068615ae3309ee" translate="yes" xml:space="preserve">
          <source>git rm .gitattributes</source>
          <target state="translated">git rm .gitattributes</target>
        </trans-unit>
        <trans-unit id="b36ac78bd6c3fab8ecba0ab82eec39608eda415e" translate="yes" xml:space="preserve">
          <source>git-clean - Remove untracked files from the working tree</source>
          <target state="translated">git-clean-작업 트리에서 추적되지 않은 파일 제거</target>
        </trans-unit>
        <trans-unit id="e3826907be3b030bedd7b5dd69ab8984357e8c0d" translate="yes" xml:space="preserve">
          <source>if you check that everything is OK, throw the stash away:</source>
          <target state="translated">모든 것이 정상인지 확인하면 은신처를 버립니다.</target>
        </trans-unit>
        <trans-unit id="b69f8baa9971a8a8eeb12eea1571ad9075d66776" translate="yes" xml:space="preserve">
          <source>or 
    git stash pop</source>
          <target state="translated">또는 자식 숨김 팝</target>
        </trans-unit>
        <trans-unit id="981cf047b6a7f7b88ac32ad8cd8a0ed27cf1c913" translate="yes" xml:space="preserve">
          <source>or this which checks out all files from the index, overwriting working tree files.</source>
          <target state="translated">또는 이것은 인덱스에서 모든 파일을 체크 아웃하여 작업 트리 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="9072dcdd106620ddc2d34fe8b2f61bcb590fefd6" translate="yes" xml:space="preserve">
          <source>should do the trick. As per &lt;a href=&quot;https://git-scm.com/docs/git-clean/2.2.0&quot;&gt;Git documentation on git clean&lt;/a&gt;</source>
          <target state="translated">트릭을해야합니다. &lt;a href=&quot;https://git-scm.com/docs/git-clean/2.2.0&quot;&gt;git clean에 대한 Git 문서에&lt;/a&gt; 따라</target>
        </trans-unit>
        <trans-unit id="8f07da77a32a6a913637dce1c7bf34b34e362b5f" translate="yes" xml:space="preserve">
          <source>simply say</source>
          <target state="translated">간단히 말해</target>
        </trans-unit>
        <trans-unit id="ffcd08491969c6b6c012c238c4b91150d946d9de" translate="yes" xml:space="preserve">
          <source>without the &lt;code&gt;-A&lt;/code&gt; the removed files will not be staged</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; 가 없으면 제거 된 파일이 준비되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="362810874f5225484e34025a86bc8884d1cb6217" translate="yes" xml:space="preserve">
          <source>you have a very simple git command &lt;code&gt;git checkout .&lt;/code&gt;</source>
          <target state="translated">매우 간단한 git 명령 &lt;code&gt;git checkout .&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
