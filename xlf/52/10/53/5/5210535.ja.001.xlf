<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/5210535">
    <body>
      <group id="5210535">
        <trans-unit id="5128e9d8380cba42898da6b0b4c094f182f31368" translate="yes" xml:space="preserve">
          <source>1&amp;gt;We need to crate string object in SecondViewController.h file</source>
          <target state="translated">1&amp;gt; SecondViewController.hファイルに文字列オブジェクトを作成する必要があります</target>
        </trans-unit>
        <trans-unit id="382568f3d5638e45d07eaa2ba4e79626c6e35495" translate="yes" xml:space="preserve">
          <source>2&amp;gt;Need to declare property as below below declaration in .h file</source>
          <target state="translated">2&amp;gt; .hファイルの宣言の下で、以下のようにプロパティを宣言する必要があります</target>
        </trans-unit>
        <trans-unit id="ca8fae13e1609c64d729ca50adc43575fd915a5d" translate="yes" xml:space="preserve">
          <source>3&amp;gt;Need synthesize that value in FirstViewController.m file below header declaration</source>
          <target state="translated">3&amp;gt;ヘッダー宣言の下のFirstViewController.mファイルでその値を合成する必要があります</target>
        </trans-unit>
        <trans-unit id="7e6c2732929d97145ee56f3dbef06b5bd1d4b710" translate="yes" xml:space="preserve">
          <source>4 lines of code inside the method and you are done.</source>
          <target state="translated">メソッド内に4行のコードを記述すれば完了です。</target>
        </trans-unit>
        <trans-unit id="12af7e16d59d006e71a07aade88fd2f960f7d040" translate="yes" xml:space="preserve">
          <source>4&amp;gt;In FirstViewController,From which method we navigate to second view please write below code in that method.</source>
          <target state="translated">4&amp;gt; FirstViewControllerで、どのメソッドから2番目のビューに移動するかを、そのメソッドのコードの下に記述してください。</target>
        </trans-unit>
        <trans-unit id="8e9441a605f9f93f88f097003026bbcbdb4e55b8" translate="yes" xml:space="preserve">
          <source>:) Cheers.</source>
          <target state="translated">:)乾杯</target>
        </trans-unit>
        <trans-unit id="c7e0fd5894134e3a798732701f0ee5582c0e8363" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ManagingDataFlowBetweenViewControllers/ManagingDataFlowBetweenViewControllers.html#//apple_ref/doc/uid/TP40007457-CH8-SW9&quot;&gt;Using Delegation to Communicate With Other View Controllers&lt;/a&gt; in the &lt;em&gt;View Controller Programming Guide&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ManagingDataFlowBetweenViewControllers/ManagingDataFlowBetweenViewControllers.html#//apple_ref/doc/uid/TP40007457-CH8-SW9&quot;&gt;委任を使用&lt;/a&gt;して、 &lt;em&gt;View Controllerプログラミングガイドの&lt;/em&gt; 他のView Controllerと通信する</target>
        </trans-unit>
        <trans-unit id="9cddb9f240b7be5a6c0e6206779adba0c54ad320" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.iphonedevsdk.com/forum/iphone-sdk-development/54859-sharing-data-between-view-controllers-other-objects.html&quot;&gt;Sharing data between view controllers and other objects&lt;/a&gt; @ iPhone Dev SDK</source>
          <target state="translated">&lt;a href=&quot;http://www.iphonedevsdk.com/forum/iphone-sdk-development/54859-sharing-data-between-view-controllers-other-objects.html&quot;&gt;View Controllerと他のオブジェクト間でデータを共有する&lt;/a&gt; @ iPhone Dev SDK</target>
        </trans-unit>
        <trans-unit id="a561b48e56f3bead23ac829c64c64003e3095e17" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/RamdhanChoudhary/A-Simple-iOS-App-for-Passing-Data-Between-Controllers-in-Swift&quot;&gt;You can find complete sample Application at my GitHub&lt;/a&gt; Please let me know if you have any question(s) on this.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/RamdhanChoudhary/A-Simple-iOS-App-for-Passing-Data-Between-Controllers-in-Swift&quot;&gt;あなたは私のGitHubで完全なサンプルアプリケーションを見つけることができます&lt;/a&gt;これについて質問があれば私に知らせてください。</target>
        </trans-unit>
        <trans-unit id="4a01486c528ad5e980ae4089d498cd8c88f97fa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@synthesize  indexNumber;&lt;/code&gt;           in NextVC.m</source>
          <target state="translated">&lt;code&gt;@synthesize indexNumber;&lt;/code&gt; NextVC.m</target>
        </trans-unit>
        <trans-unit id="b78c51f4a043a824f5e08ef6eaf7ecfb3f33270d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Blocks are anonymous functions.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ブロックは無名関数です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1021f754895d902d9dddaf8f14272d74668e6de6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Using Block callbacks:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;-ブロックコールバックの使用：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c37f6c389f441f0686ad2157cb488b1e89332e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Using storyboards Unwind (Exit)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;-ストーリーボードの使用（巻き戻し）（終了）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f6e3b19fd1dae9c65f2307816e0fe1c6c694e84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt; Create the instance of first View Controller in the second View Controller and make its property &lt;code&gt;@property (nonatomic,assign)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt; 2番目のビューコントローラーに最初のビューコントローラーのインスタンスを作成し、そのプロパティを &lt;code&gt;@property (nonatomic,assign)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="caa8b857bce2edcc30a0b3967af6102ff7c4e3cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt; Assign the &lt;code&gt;SecondviewController&lt;/code&gt; instance of this view controller.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt;このビューコントローラーの &lt;code&gt;SecondviewController&lt;/code&gt; インスタンスを割り当てます。</target>
        </trans-unit>
        <trans-unit id="c1ab9d883587e24a8d31adae458d2e6b60264d54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt; When you finish the selection operation copy the array to first View Controller,When u unload the SecondView ,FirstView will hold the Array Data.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt;選択操作が完了したら、配列を最初のView Controllerにコピーします。SecondViewをアンロードすると、FirstViewは配列データを保持します。</target>
        </trans-unit>
        <trans-unit id="69324ef579d371a172a46ed3433537adafdd0323" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Application Scenarios&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アプリケーションシナリオ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19d3c711e8278b4bcb9dc5b3925628e10a4961cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't forget&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;忘れないで&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55779cd52cf0b0e46e2fe75e0ae7c25906301bd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First View Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;First View Controller&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c0c0b273313e9e6e2211fefaab5837fd17c6153" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例えば&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c300eb69852a39b53d39a423e83febc84bb7ecf5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Go to Controller B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;コントローラBに移動&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd3b42b839c0fa27211813e4f7a2b41b323efb59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NSNotification center&lt;/strong&gt;
It's another way to pass data.</source>
          <target state="translated">&lt;strong&gt;NSNotificationセンター&lt;/strong&gt;データを渡すもう1つの方法です。</target>
        </trans-unit>
        <trans-unit id="f83086999fd5c7eccf89cda212980e525c8ee244" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsDetailViewController.h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsDetailViewController.h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2e498d6299003ee4bb995fd064cfff0f5031dd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsDetailViewController.m&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsDetailViewController.m&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="170aa6c3a45436cad64cb27754574f9f66c7007d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsViewController&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsViewController&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fcf13efd0f4fde8b8e30afec77961f30fe04bf16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Back&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;データの受け渡し&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4056ba2648992080e38f34e858850a2675ff28c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Forward using Segues&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;セグエを使用してデータを転送する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="806df0e91c6a17443dc044857cd2e12e700908c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Forward&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;データを転送する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a823b2509776072df9c2f284478ab9d56976c87d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data back from one class to another&lt;/strong&gt; (A class can be any controller, Network/session manager, UIView subclass or any other class)</source>
          <target state="translated">&lt;strong&gt;あるクラスから別のクラスにデータを返す&lt;/strong&gt; （クラスは、任意のコントローラー、ネットワーク/セッションマネージャー、UIViewサブクラス、またはその他のクラスにすることができます）</target>
        </trans-unit>
        <trans-unit id="3a2d4f96ca3cdcbd2c5729cfeeddcfe8a83ef0da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data between FirstViewController to SecondViewController as below&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;以下のようにFirstViewControllerからSecondViewControllerにデータを渡す&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1633208f374584ce5b10f1cf78b22a2eeba7eee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Block&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;ブロックを介してデータを渡す&lt;/strong&gt; ： &lt;em&gt;ViewControllerBからViewControllerAへ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="024c5395573bc2998ff2187cbf90e249d2fd7f30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Delegate&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;デリゲートを介してデータを渡す&lt;/strong&gt; ： &lt;em&gt;ViewControllerBからViewControllerAへ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c82eb764b54c062d5349bd59c7a3fb7fcbc641b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Navigation Controller Push&lt;/strong&gt; : &lt;em&gt;From ViewControllerA to ViewControllerB&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;ナビゲーションコントローラプッシュを介してデータを渡す&lt;/strong&gt; ： &lt;em&gt;ViewControllerAからViewControllerBへ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55db90aacfef6b7797ad7a5da078395659732e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Notification Observer&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;通知オブザーバーを介したデータの受け渡し&lt;/strong&gt; ： &lt;em&gt;ViewControllerBからViewControllerAへ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0561e6d1d3b1f23d57d8291ca2684d08bcde0b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Segue&lt;/strong&gt; : &lt;em&gt;From ViewControllerA to ViewControllerB&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Segueを介したデータの受け渡し&lt;/strong&gt; ： &lt;em&gt;ViewControllerAからViewControllerBへ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf80e7bc29bfca96a73722d3c8c419ee4f8a9df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scenario one:&lt;/strong&gt; maximum two view controllers ever need to share information.
See diagram one.</source>
          <target state="translated">&lt;strong&gt;シナリオ1：&lt;/strong&gt;最大2つのView Controllerが情報を共有する必要があります。 図1を参照してください。</target>
        </trans-unit>
        <trans-unit id="b5cb92a49a24b197803d86b1055b30b5711cba2a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scenario two&lt;/strong&gt;: more than two view controllers need to share the same information.
See diagram two.</source>
          <target state="translated">&lt;strong&gt;シナリオ2&lt;/strong&gt; ：3 &lt;strong&gt;つ&lt;/strong&gt;以上のView Controllerが同じ情報を共有する必要があります。 図2を参照してください。</target>
        </trans-unit>
        <trans-unit id="f945b9a41062fc17eb825c26426f171f0d86ed91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second View Controller and Protocol&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;セカンドビューコントローラーとプロトコル&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ce77aea00bcbf439da1f87290ce172463ea140c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second View Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;セカンドビューコントローラー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bd48716ff2de9235461890349819ae353247ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setup The Storyboard&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ストーリーボードのセットアップ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="089fc6cd09fa49635621f8cfa746223ca053b190" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Create Segue from ViewControllerA to ViewControllerB and give Identifier = showDetailSegue in Storyboard as shown below</source>
          <target state="translated">&lt;strong&gt;ステップ1.&lt;/strong&gt; ViewControllerAからViewControllerBにSegueを作成し、以下に示すように、ストーリーボードでIdentifier = showDetailSegueを指定します。</target>
        </trans-unit>
        <trans-unit id="02d6487d795d944e58f58e4366b35bc8d1b32dc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Declare Protocol &lt;strong&gt;&lt;em&gt;ViewControllerBDelegate&lt;/em&gt;&lt;/strong&gt; in ViewControllerB file but outside the class</source>
          <target state="translated">&lt;strong&gt;ステップ1.&lt;/strong&gt; ViewControllerBファイルでプロトコル&lt;strong&gt;&lt;em&gt;ViewControllerBDelegate&lt;/em&gt;&lt;/strong&gt;を宣言するが、クラス外</target>
        </trans-unit>
        <trans-unit id="0cfd0efef879069214eec7da3b7a25e5918e36d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Declare variable in ViewControllerB</source>
          <target state="translated">&lt;strong&gt;ステップ1.&lt;/strong&gt; ViewControllerBで変数を宣言する</target>
        </trans-unit>
        <trans-unit id="63f0b24521041c6431c75964ba6cefcaea19944c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; Declare Delegate variable instance in ViewControllerB</source>
          <target state="translated">&lt;strong&gt;ステップ2.&lt;/strong&gt; ViewControllerBでデリゲート変数インスタンスを宣言する</target>
        </trans-unit>
        <trans-unit id="cf2aa8929fa2c0c9c4a6b1ac4ca41b9ce1e5280a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; In ViewControllerB Declare a viable named &lt;strong&gt;isSomethingEnabled&lt;/strong&gt; and print its value.</source>
          <target state="translated">&lt;strong&gt;ステップ2.&lt;/strong&gt; &lt;strong&gt;ViewControllerBで&lt;/strong&gt; 、 &lt;strong&gt;isSomethingEnabled&lt;/strong&gt;という名前の実行可能変数を宣言し、その値を出力します。</target>
        </trans-unit>
        <trans-unit id="673106a11e8d268ad485367e76e5b7fe1a54be95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; Print Variable in ViewControllerB' ViewDidLoad method</source>
          <target state="translated">&lt;strong&gt;ステップ2.&lt;/strong&gt; ViewControllerBのViewDidLoadメソッドで変数を出力する</target>
        </trans-unit>
        <trans-unit id="c79ecb62ba912afd27284dd7da413af362a92fe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; In ViewControllerA Pass Data while pushing through Navigation Controller</source>
          <target state="translated">&lt;strong&gt;手順3.&lt;/strong&gt; Navigation Controllerを介してプッシュしながらViewControllerAにデータを渡す</target>
        </trans-unit>
        <trans-unit id="4b0af6a719a13383d29f0e86f0830773e5362336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; In ViewControllerA pass isSomethingEnabled's value while passing Segue</source>
          <target state="translated">&lt;strong&gt;ステップ3.&lt;/strong&gt; ViewControllerAで、Segueを渡すときにisSomethingEnabledの値を渡します。</target>
        </trans-unit>
        <trans-unit id="e879cf49b95c873ff028951588aa65e4dc76e026" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; Send data for delegate inside viewDidLoad method of ViewControllerB</source>
          <target state="translated">&lt;strong&gt;ステップ3.&lt;/strong&gt; ViewControllerBのviewDidLoadメソッド内のデリゲートのデータを送信する</target>
        </trans-unit>
        <trans-unit id="c0971f452794a6e92bcbbc194c9499089ede4379" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 4.&lt;/strong&gt; Confirm ViewControllerBDelegate in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;ステップ4.&lt;/strong&gt; ViewControllerAでViewControllerBDelegateを確認する</target>
        </trans-unit>
        <trans-unit id="400cecca8d5ee34aed2e79bed634a5f6417ad26a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 5.&lt;/strong&gt; Confirm that you will implement delegate in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;手順5.&lt;/strong&gt; ViewControllerAにデリゲートを実装することを確認する</target>
        </trans-unit>
        <trans-unit id="a6946e7fb9eb003efc11719f3b07f5e5dd24240e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 6.&lt;/strong&gt; Implement delegate method for receiving data in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;手順6.&lt;/strong&gt; ViewControllerAでデータを受信するためのデリゲートメソッドを実装する</target>
        </trans-unit>
        <trans-unit id="dae0e54a74abfd074492d26eb16ee245aa1b2bad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Swift 5&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;スウィフト5&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28379284774a4bc3f1d8c071ddb2db954d9799db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Solutions: Delegates and the Observer Pattern, and Singletons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ソリューション：デリゲートとオブザーバーパターン、およびシングルトン&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67f11916500f3f87c23f865722bfb004fcf67670" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The View Controllers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ビューコントローラー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4223100f431b368002a27fc7e5a1b02d95268402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is a very old answer and this is anti pattern, please use delegates. Do not use this Approach !!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これは非常に古い回答であり、これはアンチパターンです。デリゲートを使用してください。&lt;/strong&gt; &lt;strong&gt;このアプローチは使用しないでください!!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f90d261e0a84b99ac74b5c70573c76458761db1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ViewControllerA&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ViewControllerA&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="48b18e371bee61f8b3cc40f6098e6c3da05ba232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ViewControllerB&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ViewControllerB&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7695880e46c35fa27304925b1429e1f63dcc24f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;add block handler (listener)&lt;/strong&gt;
where you need a value (for example you need your API response in ControllerA or you need ContorllerB data on A)</source>
          <target state="translated">値が必要な場所に&lt;strong&gt;ブロックハンドラー（リスナー）を追加&lt;/strong&gt;します（たとえば、ControllerAでAPI応答が必要であるか、AにContorllerBデータが必要です）。</target>
        </trans-unit>
        <trans-unit id="c5d2857c643c79b0380179ffbc7e423000f801e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;define a block&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ブロックを定義する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93db5e336a184ed3fa5d32c57284bb8d6714d03a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fire block&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ファイアーブロック&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3915169e39c880b6db82aad68f146c88205b079" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;singleton&lt;/strong&gt; is an instance of a class, that instance being the only instance in existence during its lifetime. A singleton gets its name from the fact that it is the single instance. Normally developers who use singletons have special class methods for accessing them.</source>
          <target state="translated">&lt;strong&gt;シングルトン&lt;/strong&gt;はクラスのインスタンスであり、そのインスタンスはその存続期間中に存在する唯一のインスタンスです。 シングルトンは、それが単一のインスタンスであるという事実からその名前を取得します。 通常、シングルトンを使用する開発者には、それらにアクセスするための特別なクラスメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="f28e068fdcf0539a305afd3501e8a77424964acf" translate="yes" xml:space="preserve">
          <source>Add a new file to your project (Objective-C Protocol) File -&amp;gt; New, now name it ViewController1Delegate or whatever you want and write these between the @interface and @end directives</source>
          <target state="translated">新しいファイルをプロジェクトに追加します（Objective-C Protocol）File-&amp;gt; New、今それをViewController1Delegateなどの名前にして、@ interfaceディレクティブと@endディレクティブの間に記述します。</target>
        </trans-unit>
        <trans-unit id="3f0eff45a4a19a3b442bc835b668a6a9ac78b01f" translate="yes" xml:space="preserve">
          <source>Add this &lt;code&gt;property&lt;/code&gt; in NextVC.h on nextVC</source>
          <target state="translated">この &lt;code&gt;property&lt;/code&gt; をnextVCのNextVC.hに追加します</target>
        </trans-unit>
        <trans-unit id="804108390422b4e4ce16d7dd070e8cd51d8926e4" translate="yes" xml:space="preserve">
          <source>After more research it seemed that Protocols and Delegates is the correct/Apple prefered way of doing this.</source>
          <target state="translated">さらに調査した結果、Protocols and Delegatesは正しいAppleが好む方法であるように思えました。</target>
        </trans-unit>
        <trans-unit id="a12d91c7bf75162aeefa8045f7e5bc4e2c65ef2b" translate="yes" xml:space="preserve">
          <source>All of your views that conform to this need to be subclasses of MCViewController, which allow you to override the new onResume: method, allowing you access to the data you've passed in.</source>
          <target state="translated">これに準拠するすべてのビューは、MCViewControllerのサブクラスである必要があり、新しいonResume:メソッドをオーバーライドして、渡されたデータにアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="0d8ab1246f6106fb56d5a9574573a871cd55050d" translate="yes" xml:space="preserve">
          <source>And in the prepareForSegue of VC1 you can change any property you want to share.</source>
          <target state="translated">そしてVC1のprepareForSegueでは、共有したいプロパティを任意に変更することができます。</target>
        </trans-unit>
        <trans-unit id="bccdba78cf0a1ca896692cedf94279f07a532726" translate="yes" xml:space="preserve">
          <source>And last</source>
          <target state="translated">そして最後に</target>
        </trans-unit>
        <trans-unit id="b969e3b40597dea269830b21f5cd87d1fbd3744f" translate="yes" xml:space="preserve">
          <source>And the code for the Second View Controller is</source>
          <target state="translated">そして、セカンドビューコントローラのコードは</target>
        </trans-unit>
        <trans-unit id="18cc65ab16292fba4c64e85d6cc81210aac335ef" translate="yes" xml:space="preserve">
          <source>Another Working Example for Blocks</source>
          <target state="translated">ブロックの別の使用例</target>
        </trans-unit>
        <trans-unit id="118227ed38ee9d82b2542b27e2ded76929153d04" translate="yes" xml:space="preserve">
          <source>Another approach is to handle a screen full of data at a time and instead of coupling the view controllers to each other couple each view controller to single data source that they can get to independently.</source>
          <target state="translated">もう一つのアプローチは、画面いっぱいのデータを一度に処理し、ビューコントローラをお互いに結合するのではなく、各ビューコントローラを独立して取得できる単一のデータソースに結合することです。</target>
        </trans-unit>
        <trans-unit id="24aa503d35146161367e2853117eb922f7c7e249" translate="yes" xml:space="preserve">
          <source>Another option of using storyboards Undwind (Exit)  - you can
use the method you wrote in VC1</source>
          <target state="translated">ストーリーボードのUndwind(終了)を使用する別のオプション-あなたはVC1で書いた方法を使用することができます。</target>
        </trans-unit>
        <trans-unit id="0b6c72a6ce36ed0135ebc104f4837a0d4628e2ba" translate="yes" xml:space="preserve">
          <source>Another solution is use singleton class pattern initialize it once and use it in your entire app.</source>
          <target state="translated">もう一つの解決策は、シングルトンクラスのパターンを使用して一度初期化し、それをアプリ全体で使用することです。</target>
        </trans-unit>
        <trans-unit id="485e9762fc4e98806a8bb291a5c98ca65cca0c5d" translate="yes" xml:space="preserve">
          <source>Any time an individual item is created or edited, it must also synchronize with the other view controllers. For example, if we add a boat in ViewControllerD, but it is not yet insured, then the boat must appear when the user goes to ViewControllerA (Luxury Items), and also ViewControllerC (Entire Home Inventory), but not when the user goes to ViewControllerB (Non-insured Items). We need be concerned with not only adding new items, but also deleting items (which may be allowed from any of the four view controllers), or editing existing items (which may be allowed from the &quot;Add New Item Form&quot;, repurposing the same for editing).</source>
          <target state="translated">個々のアイテムを作成したり編集したりする際には、他のビューコントローラと同期する必要があります。例えば、ViewControllerD にボートを追加したが、まだ保険に加入していない場合、ユーザが ViewControllerA (Luxury Items)と ViewControllerC (Entire Home Inventory)に移動したときにはボートが表示され、ViewControllerB (Non-insured Items)に移動したときには表示されないということになります。新しいアイテムを追加するだけでなく、アイテムの削除(4つのビューコントローラのいずれからでも可能)や既存のアイテムの編集(&quot;Add New Item Form &quot;からでも可能で、編集用に同じものを再利用)にも気を配る必要があります。</target>
        </trans-unit>
        <trans-unit id="64849ae90e58e40914c4de26bdae632804d0010e" translate="yes" xml:space="preserve">
          <source>Any time your Application Delegate starts to get bloated, start to remove functionality into singletons. For example, the Core Data Stack should not be left in the AppDelegate, but should instead be put in its own class, a coreDataManager class.</source>
          <target state="translated">Application Delegate が肥大化し始めたら、いつでも、機能をシングルトンに削除し始めてください。例えば、コアデータスタックは AppDelegate に残すべきではなく、その代わりに独自のクラス、coreDataManager クラスに置くべきです。</target>
        </trans-unit>
        <trans-unit id="3f40fedcce16e602b145be79b8076ddf17738736" translate="yes" xml:space="preserve">
          <source>Assuming we use Storyboard, first controller sets callback block, for example during segue preparation:</source>
          <target state="translated">Storyboardを使用すると仮定して、最初のコントローラは、例えばセグエの準備中などにコールバックブロックを設定します。</target>
        </trans-unit>
        <trans-unit id="937c87dd061dc69a2f97f40ce08377952484a667" translate="yes" xml:space="preserve">
          <source>Asynchronous JSON Requests in Objective-C</source>
          <target state="translated">Objective-C での非同期 JSON リクエスト</target>
        </trans-unit>
        <trans-unit id="7a23b7a9d6d6baa93168423a429c497e0668b171" translate="yes" xml:space="preserve">
          <source>Before pushing &lt;code&gt;viewControllerB&lt;/code&gt; to navigation stack we need to tell  &lt;code&gt;ViewControllerB&lt;/code&gt; that &lt;code&gt;ViewControllerA&lt;/code&gt; is its delegate, otherwise we will get an error.</source>
          <target state="translated">&lt;code&gt;viewControllerB&lt;/code&gt; をナビゲーションスタックにプッシュする前に、 &lt;code&gt;ViewControllerA&lt;/code&gt; がそのデリゲートであることをViewControllerBに通知する必要があります。そうしないと、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8eac8dd9c4975fc8c45b35fda8f1d46a26aaa269" translate="yes" xml:space="preserve">
          <source>Brute force iteration on view controllers (in Navigation or Tab Bar Controller) to set the data</source>
          <target state="translated">ビューコントローラ(ナビゲーションまたはタブバーコントローラ)でのブルートフォース反復処理でデータを設定します。</target>
        </trans-unit>
        <trans-unit id="54b5e333081c3612757c1545a54070e785c64a95" translate="yes" xml:space="preserve">
          <source>But for the simple scenario of passing a value to a different class whose allocation is done in the current class, the most common and preferred method would be the direct setting of values after allocation. This is done as follows:-</source>
          <target state="translated">しかし、現在のクラスで割り当てが行われている別のクラスに値を渡すという単純なシナリオのために、最も一般的で好ましい方法は、割り当て後に値を直接設定することでしょう。これは次のように行います。</target>
        </trans-unit>
        <trans-unit id="ea1d3df298ca84104dbf8b2f6f916c02f6f77c6e" translate="yes" xml:space="preserve">
          <source>Control</source>
          <target state="translated">Control</target>
        </trans-unit>
        <trans-unit id="959abf1f5e9c99d137dc34e9bffd461476893b28" translate="yes" xml:space="preserve">
          <source>Core Data</source>
          <target state="translated">コアデータ</target>
        </trans-unit>
        <trans-unit id="dec7ea0ef8ddc0be363fac5318ec6d035445e81a" translate="yes" xml:space="preserve">
          <source>Create a the segue from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; on the storyboard and give it an identifier, in this example we'll call it &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt;</source>
          <target state="translated">ストーリーボード上で &lt;code&gt;ViewControllerA&lt;/code&gt; からViewControllerBへのセグエを作成し、 それに識別子を付けます。この例では、 &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; と呼びます。</target>
        </trans-unit>
        <trans-unit id="7d6106a2b404bee4c3c16acfce805678171d2723" translate="yes" xml:space="preserve">
          <source>Create the property on next &lt;code&gt;view controller .h&lt;/code&gt; and define getter and setter.</source>
          <target state="translated">次の &lt;code&gt;view controller .h&lt;/code&gt; プロパティを作成し、ゲッターとセッターを定義します。</target>
        </trans-unit>
        <trans-unit id="3dd4a61a93a6d9b50322d5da189d9a661c072e48" translate="yes" xml:space="preserve">
          <source>Create the storyboard layout in the Interface Builder. Again, to make the segue, you just</source>
          <target state="translated">インターフェイスビルダーでストーリーボードのレイアウトを作成します。ここでも、セグセグを作成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="2851431431fb0af8a145e641673ca993d6a20f60" translate="yes" xml:space="preserve">
          <source>Create the storyboard layout in the Interface Builder. To make the segue, you just</source>
          <target state="translated">インターフェイスビルダーでストーリーボードのレイアウトを作成します。セグスを作るには</target>
        </trans-unit>
        <trans-unit id="863b2164a4f2bf227ea1d1aef73ad8543480c495" translate="yes" xml:space="preserve">
          <source>Data Source</source>
          <target state="translated">データソース</target>
        </trans-unit>
        <trans-unit id="2aac74bd52b9c492652ab12ed22c5b9514f39d8b" translate="yes" xml:space="preserve">
          <source>Databases and other storage mechanisms like plist, etc.</source>
          <target state="translated">データベースやplistなどのストレージメカニズム。</target>
        </trans-unit>
        <trans-unit id="12ab214df85e4910f7e4400eea924b9565854a9f" translate="yes" xml:space="preserve">
          <source>Delegate</source>
          <target state="translated">Delegate</target>
        </trans-unit>
        <trans-unit id="7dcb8a7fd6d2299b039ffb1a88ed98c93cfc5c8c" translate="yes" xml:space="preserve">
          <source>Delegate Pattern</source>
          <target state="translated">代行パターン</target>
        </trans-unit>
        <trans-unit id="55f0774bd4a8ef9ee512f251043f191561770ae9" translate="yes" xml:space="preserve">
          <source>Delegation - for passing data back</source>
          <target state="translated">委任-データの受け渡しのための</target>
        </trans-unit>
        <trans-unit id="4e3967fb23456a60f72119d5b28aa0e415a7f7e8" translate="yes" xml:space="preserve">
          <source>Delegation is the only one solution to perform such operations when you are using .xib files however all answers described above are for &lt;code&gt;storyboard&lt;/code&gt; for .xibs files you need to use delegation. that's only solution you can.</source>
          <target state="translated">委任は、.xibファイルを使用しているときにこのような操作を実行する唯一のソリューションですが、上記のすべての回答は、委任を使用する必要がある.xibsファイルの &lt;code&gt;storyboard&lt;/code&gt; に関するものです。 それができる唯一のソリューションです。</target>
        </trans-unit>
        <trans-unit id="b4207fd5520139aa96bd6e9274602042b4534a20" translate="yes" xml:space="preserve">
          <source>Direct initialization after the allocation of another class.</source>
          <target state="translated">他のクラスの割り当て後に直接初期化する。</target>
        </trans-unit>
        <trans-unit id="bcfc557b28b79f1b85cc19619bb82e338660c8e4" translate="yes" xml:space="preserve">
          <source>FirstViewController String value as</source>
          <target state="translated">FirstViewController 文字列の値を</target>
        </trans-unit>
        <trans-unit id="57a94d454ba6c87c92cf93163d87c89f165d195a" translate="yes" xml:space="preserve">
          <source>FirstViewController.h</source>
          <target state="translated">FirstViewController.h</target>
        </trans-unit>
        <trans-unit id="f8e78f0e3c0970f488a281208ad26ef9f20bbdf0" translate="yes" xml:space="preserve">
          <source>FirstViewController.m</source>
          <target state="translated">FirstViewController.m</target>
        </trans-unit>
        <trans-unit id="9609a00b7fb972ff05c1431d4f283cdd084f76ce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;ViewControllerA&lt;/code&gt; to be a delegate of &lt;code&gt;ViewControllerB&lt;/code&gt; it must conform to &lt;code&gt;ViewControllerB&lt;/code&gt;'s protocol which we have to specify. This tells &lt;code&gt;ViewControllerA&lt;/code&gt; which methods it must implement.</source>
          <target state="translated">&lt;code&gt;ViewControllerA&lt;/code&gt; がViewControllerBのデリゲートになるためには、指定する必要のある &lt;code&gt;ViewControllerB&lt;/code&gt; のプロトコルに準拠する必要があります。 これにより、 &lt;code&gt;ViewControllerA&lt;/code&gt; が実装する必要のあるメソッドがわかります。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="ddb095a25c86563637fe3a13523173efa1d4bd90" translate="yes" xml:space="preserve">
          <source>For this example, we will have &lt;code&gt;ViewControllerA&lt;/code&gt; and &lt;code&gt;ViewControllerB&lt;/code&gt;</source>
          <target state="translated">この例では、 &lt;code&gt;ViewControllerA&lt;/code&gt; と &lt;code&gt;ViewControllerB&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="9fd567287999a459caadcea427cbafc09d8c04a6" translate="yes" xml:space="preserve">
          <source>For those interested, I wrote some articles that address these points more in depth and highlight the various drawbacks:</source>
          <target state="translated">興味のある方のために、これらのポイントをより深く取り上げ、様々な欠点を浮き彫りにした記事をいくつか書いてみました。</target>
        </trans-unit>
        <trans-unit id="32096c328bd65055c2650eb54a84201d94dbdd3e" translate="yes" xml:space="preserve">
          <source>Go to your SecondViewController.h and write two methods</source>
          <target state="translated">SecondViewController.h に移動して、2 つのメソッドを書きます。</target>
        </trans-unit>
        <trans-unit id="66b1fbfc6e5394baafe61e59c041f14de3f8dfa2" translate="yes" xml:space="preserve">
          <source>Here are two trivial examples of the segue glue.  The first is straightforward showing one parameter passed for input, the second for output.</source>
          <target state="translated">ここでは、セグエグルーの2つの些細な例を紹介します。最初の例では、入力に渡されたパラメータが1つ、出力に渡されたパラメータが2つあります。</target>
        </trans-unit>
        <trans-unit id="c503ca63bb5c748744204770c2f45a34800264da" translate="yes" xml:space="preserve">
          <source>Here is the setup for the receiver.</source>
          <target state="translated">受信機のセットアップです。</target>
        </trans-unit>
        <trans-unit id="27ec3a0713aa1a15fc2589ac80289f434c756874" translate="yes" xml:space="preserve">
          <source>Here is the setup for the sender</source>
          <target state="translated">送信者の設定は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2ed131c901fbe28ddf0ce2cd8b65f252fbcb1bac" translate="yes" xml:space="preserve">
          <source>Hook up the outlets for the &lt;code&gt;UITextField&lt;/code&gt; and the &lt;code&gt;UILabel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UITextField&lt;/code&gt; と &lt;code&gt;UILabel&lt;/code&gt; のアウトレットを接続します。</target>
        </trans-unit>
        <trans-unit id="c858c878a55e6b91f549851d54d1a349d5effd3d" translate="yes" xml:space="preserve">
          <source>Hope This Helps.</source>
          <target state="translated">これが助けになることを願っています。</target>
        </trans-unit>
        <trans-unit id="0f0122ee4a988027a9316eb9e7ae9f1f39324dd0" translate="yes" xml:space="preserve">
          <source>Hope i added something to the discussion.</source>
          <target state="translated">私は議論に何かを加えたことを願っています。</target>
        </trans-unit>
        <trans-unit id="5a142ce919975d47656e09ab99d87f6db6c24f1b" translate="yes" xml:space="preserve">
          <source>Hope some of you find this solution useful/interesting.</source>
          <target state="translated">あなたの中には、この解決策に興味を持っている人がいることを願っています。</target>
        </trans-unit>
        <trans-unit id="3dde88ebb2cd0d70e69aeb2a7ef870a86f8e1b6f" translate="yes" xml:space="preserve">
          <source>Hope this helps</source>
          <target state="translated">これが助けになることを願っています。</target>
        </trans-unit>
        <trans-unit id="2cdfefbe424649534d9db2ab8261c3eafbd9a6e9" translate="yes" xml:space="preserve">
          <source>How iOS View Controllers Communicate With Each Other</source>
          <target state="translated">iOSのビューコントローラがお互いに通信する方法</target>
        </trans-unit>
        <trans-unit id="c7727df2be19971e8927f49141a1a5496f4054e8" translate="yes" xml:space="preserve">
          <source>How to Structure the Code of iOS Apps</source>
          <target state="translated">iOSアプリのコードの構成方法</target>
        </trans-unit>
        <trans-unit id="a7486bddaa4b0348571f0d1a8a53e76566788cb0" translate="yes" xml:space="preserve">
          <source>I am currently contributing to an open source solution to this problem through a project called MCViewFactory, which may be found here:</source>
          <target state="translated">私は現在、MCViewFactoryというプロジェクトを通じて、この問題のオープンソースの解決策に貢献しています。</target>
        </trans-unit>
        <trans-unit id="f2d0ca81764b2c3a3e1f362cde1e9ab36322bd51" translate="yes" xml:space="preserve">
          <source>I am going to rewrite his logic in Swift with latest iOS Framework</source>
          <target state="translated">最新のiOSフレームワークでSwiftのロジックを書き換えようと思っています。</target>
        </trans-unit>
        <trans-unit id="32993e505110576861bf61a7774bb4e29093aa24" translate="yes" xml:space="preserve">
          <source>I ended up using this example</source>
          <target state="translated">結局この例を使ってみました。</target>
        </trans-unit>
        <trans-unit id="fb06d1564152df661993e0e7090fe2a1f0d5b7e9" translate="yes" xml:space="preserve">
          <source>I find simplest and most elegant version with passing blocks.
Let's name view controller that waits for returned data as &quot;A&quot; and returning view controller as &quot;B&quot;. In this example we want to get 2 values: first of Type1 and second of Type2.</source>
          <target state="translated">パッシングブロックを使った最もシンプルでエレガントなバージョンを見つけました。返されたデータを待つビューコントローラを &quot;A &quot;とし、返すビューコントローラを &quot;B &quot;とします。この例では、Type1とType2の2つの値を取得したいとします。</target>
        </trans-unit>
        <trans-unit id="1333860eaa3d97443744ef9200f6a80fa125579a" translate="yes" xml:space="preserve">
          <source>I found there are more ways:</source>
          <target state="translated">他にも方法があることがわかりました。</target>
        </trans-unit>
        <trans-unit id="63c023c5a80422806d084a6c97842a45d00ed69c" translate="yes" xml:space="preserve">
          <source>I have a view that acts as a data entry form and I want to give the user the option to select multiple products. The products are listed on another view with a &lt;code&gt;UITableViewController&lt;/code&gt; and I have enabled multiple selections.</source>
          <target state="translated">データ入力フォームとして機能するビューがあり、ユーザーに複数の製品を選択するオプションを提供したいと考えています。 製品は、 &lt;code&gt;UITableViewController&lt;/code&gt; を使用して別のビューにリストされ、複数の選択を有効にしました。</target>
        </trans-unit>
        <trans-unit id="daab7a9e1660ea80bf746f2a7ffe137093641504" translate="yes" xml:space="preserve">
          <source>I have seen a lot of people over complicating this using the &lt;code&gt;didSelectRowAtPath&lt;/code&gt; method. I am using Core Data in my example.</source>
          <target state="translated">&lt;code&gt;didSelectRowAtPath&lt;/code&gt; メソッドを使用してこれを複雑にしている人はたくさんいます。 私の例ではCore Dataを使用しています。</target>
        </trans-unit>
        <trans-unit id="16aeeef45f1fe8a16c172b0d0778c79a341461c5" translate="yes" xml:space="preserve">
          <source>I have surfed around and seen some people declare an array in the app delegate. I read something about Singletons but don't understand what these are and I read something about creating a data model.</source>
          <target state="translated">私はサーフィンをして、いくつかの人々がアプリのデリゲートで配列を宣言するのを見てきました。私はシングルトンについての何かを読みましたが、これらが何であるか理解していませんし、データモデルを作成することについての何かを読みました。</target>
        </trans-unit>
        <trans-unit id="814549b2a629fcb2811c5678e6e7c5629c9fa79a" translate="yes" xml:space="preserve">
          <source>I hope this answer is clear enough for people to understand and that I have not missed anything.</source>
          <target state="translated">この回答が、人に理解してもらえるように、私が見落としていないことを願っています。</target>
        </trans-unit>
        <trans-unit id="15f9e48f7ce909c17212445d5661bf8a3c542dbc" translate="yes" xml:space="preserve">
          <source>I know this is a beaten subject but for those looking to answer this question with a SWIFT slant and want a bare-bones example, here my go-to method for passing data if you are using a segue to get around.</source>
          <target state="translated">私はこれが叩かれた主題であることを知っていますが、SWIFTの傾斜でこの質問に答えたいと思っている人のために、ここでは、あなたが回避するためにセグエを使用している場合は、データを渡すための私のゴー-ト-メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="81a9e22efbeff10a44db5b8cdb745bd06025c82b" translate="yes" xml:space="preserve">
          <source>I like the idea of Model objects and Mock objects based on NSProxy to commit or discard data if what user selects can be cancelled.</source>
          <target state="translated">私はNSProxyをベースにしたモデルオブジェクトとモックオブジェクトのアイデアが好きで、ユーザーが選択したものがキャンセルできる場合は、データをコミットまたは破棄します。</target>
        </trans-unit>
        <trans-unit id="baaf8a3ca4379be9cd2bab483d766c8d34304728" translate="yes" xml:space="preserve">
          <source>I was searching this solution for long time, Atlast I found it. First of all declare all the objects in your SecondViewController.h file like</source>
          <target state="translated">この解決策をずっと探していたのですが、Atlastで見つけました。まず、SecondViewController.hファイルの中にあるすべてのオブジェクトを</target>
        </trans-unit>
        <trans-unit id="62c982b0a0ffe5bca814c4394638faed462207da" translate="yes" xml:space="preserve">
          <source>I wrote a blog post about this a while back: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;Sharing Model Code&lt;/a&gt;. Here's a brief summary:</source>
          <target state="translated">私はこれについてブログ記事を書きました： &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;モデルコードの共有&lt;/a&gt; 。 ここに簡単な要約があります：</target>
        </trans-unit>
        <trans-unit id="f35d400cc0a2783a34596a1675a4eb5991195da1" translate="yes" xml:space="preserve">
          <source>I'm new to iOS and Objective-C and the whole MVC paradigm and I'm stuck with the following:</source>
          <target state="translated">iOSとObjective-Cは初めてで、MVCのパラダイム全体を見ても、以下のようなことに行き詰まっています。</target>
        </trans-unit>
        <trans-unit id="df1f75720203e34b8f92760b6e05286c591390f8" translate="yes" xml:space="preserve">
          <source>If you are using Storyboards you are most likely using segues and will need this procedure to pass data forward. This is similar to the above but instead of passing the data before you push the view controller, you use a method called</source>
          <target state="translated">ストーリーボードを使用している場合は、ほとんどの場合セグを使用していると思いますが、データを転送するためにこの手順が必要になります。これは上記と似ていますが、ビューコントローラをプッシュする前にデータを渡す代わりに</target>
        </trans-unit>
        <trans-unit id="09342e817a09bfb2e555b89afe5f0a71bebde6b8" translate="yes" xml:space="preserve">
          <source>If you have your views embedded in a navigation controller you need to change the method above slightly to the following</source>
          <target state="translated">ナビゲーションコントローラにビューを埋め込んでいる場合は、上記のメソッドを以下のように少し変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="c057436dcaf9858c8a465dcfbcf74653c62e56d3" translate="yes" xml:space="preserve">
          <source>If you want to pass data from one controller to other try this code</source>
          <target state="translated">あるコントローラから他のコントローラにデータを渡したい場合は、次のコードを試してみてください。</target>
        </trans-unit>
        <trans-unit id="5aaeee5260096b956e2adc18507a3dbdbd4de81b" translate="yes" xml:space="preserve">
          <source>If you want to send data from one to another viewController, here's a way to it:</source>
          <target state="translated">あるViewControllerから別のViewControllerにデータを送りたい場合、その方法は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="df625f6457413343ada0786d3f8df7e44cb409c4" translate="yes" xml:space="preserve">
          <source>Implement a method with a    UIStoryboardSegue argument in  VC 1,    like this one:</source>
          <target state="translated">このようにVC 1にUIStoryboardSegue引数を持つメソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="d5bbe6ca201c4fe5dda1d1e053bb7f12a4edd65d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerA.m&lt;/code&gt; implement the following method from our protocol</source>
          <target state="translated">&lt;code&gt;ViewControllerA.m&lt;/code&gt; で 、プロトコルから次のメソッドを実装します</target>
        </trans-unit>
        <trans-unit id="9d6547b304166959ffcc04dfdf16623cf62b971e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerB.h&lt;/code&gt;, below the &lt;code&gt;#import&lt;/code&gt;, but above &lt;code&gt;@interface&lt;/code&gt; you specify the protocol.</source>
          <target state="translated">&lt;code&gt;ViewControllerB.h&lt;/code&gt; では、 #importの下、ただし &lt;code&gt;@interface&lt;/code&gt; の上で、プロトコルを指定します。</target>
        </trans-unit>
        <trans-unit id="34f4b01f04c9ab50f1dc277e194a6c707b3ae757" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerB&lt;/code&gt; we call a message on the &lt;code&gt;delegate&lt;/code&gt; when we pop the view controller.</source>
          <target state="translated">&lt;code&gt;ViewControllerB&lt;/code&gt; では 、ビューコントローラーをポップするときに &lt;code&gt;delegate&lt;/code&gt; メッセージを呼び出します。</target>
        </trans-unit>
        <trans-unit id="d4cb986f06c8a358bb0ac401e2255be7435b3ec6" translate="yes" xml:space="preserve">
          <source>In NewViewController.h</source>
          <target state="translated">NewViewController.hにおいて</target>
        </trans-unit>
        <trans-unit id="ee25efeb34aea96a92caf4d24a919db9885aa93d" translate="yes" xml:space="preserve">
          <source>In NewViewController.m</source>
          <target state="translated">NewViewController.mにおいて</target>
        </trans-unit>
        <trans-unit id="fcfba25eeca43facefb5d34107096b545f63a8ea" translate="yes" xml:space="preserve">
          <source>In both unwind options you can set the tag property of the button and check it in
        the prepareForSegue.</source>
          <target state="translated">どちらの巻き戻しオプションでも、ボタンのタグプロパティを設定し、prepareForSegueで確認することができます。</target>
        </trans-unit>
        <trans-unit id="61da207f2a6f23452f52382b7096f549ed3ae3a9" translate="yes" xml:space="preserve">
          <source>In my case I used a singleton class which can work as a global object allowing accesses to the data from almost everywhere in the app. First thing is to build a singleton class. Please refer to the page,&quot; &lt;a href=&quot;https://stackoverflow.com/questions/145154/what-does-your-objective-c-singleton-look-like&quot;&gt;What should my Objective-C singleton look like?&lt;/a&gt; &quot;
And what I did to make the object globally accessible was simply import it in &lt;code&gt;appName_Prefix.pch&lt;/code&gt; which is for applying import statement in every classes.
To access this object and to use, I simply implemented class method to return the shared instance, which contains its own variables</source>
          <target state="translated">私の場合、グローバルオブジェクトとして機能するシングルトンクラスを使用して、アプリのほぼすべての場所からデータにアクセスできるようにしました。 最初に、シングルトンクラスを作成します。 「 &lt;a href=&quot;https://stackoverflow.com/questions/145154/what-does-your-objective-c-singleton-look-like&quot;&gt;Objective-Cシングルトンの外観をどうするか&lt;/a&gt; 」のページを参照してください。オブジェクトをグローバルにアクセスできるようにするには、すべてのクラスにインポートステートメントを適用するための &lt;code&gt;appName_Prefix.pch&lt;/code&gt; にオブジェクトをインポートするだけでした。 このオブジェクトにアクセスして使用するには、クラスメソッドを実装して、独自の変数を含む共有インスタンスを返します</target>
        </trans-unit>
        <trans-unit id="4347c7d44969ad5ed12d4df451dd2631e4a3c195" translate="yes" xml:space="preserve">
          <source>In practice, in my opinion only a few solutions are recommended:</source>
          <target state="translated">実際には、私の意見では、いくつかの解決策を推奨しています。</target>
        </trans-unit>
        <trans-unit id="bf835249be3289308815771b6433af2277b90842" translate="yes" xml:space="preserve">
          <source>In scenario one, we have several viable solutions, as other answers have given</source>
          <target state="translated">シナリオ1では、他の回答が与えているように、いくつかの実行可能な解決策があります。</target>
        </trans-unit>
        <trans-unit id="24e6d5a69f4225a7a61ed046e01222766c16f892" translate="yes" xml:space="preserve">
          <source>In scenario two, we do not have a single property of the HouseholdInventoryManager which could be observed using KVO. Because we do not have a single property which is easily observable, the observer pattern, in this case, must be implemented using NSNotificationCenter. Each of the four view controllers would subscribe to notifications, and the sharedManager would send notifications to the notification center when appropriate. The inventory manager does not need to know anything about the view controllers or instances of any other classes which may be interested in knowing when the collection of inventory items changes; the NSNotificationCenter takes care of these implementation details. The View Controllers simply subscribe to notifications, and the data manager simply posts notifications.</source>
          <target state="translated">シナリオ2では、KVOを使用して観測可能なHouseholdInventoryManagerの単一のプロパティを持っていません。簡単に観察できる単一のプロパティを持っていないので、この場合のオブザーバパターンは NSNotificationCenter を使用して実装する必要があります。4つのビューコントローラのそれぞれが通知をサブスクライブし、sharedManagerが適切なタイミングで通知センターに通知を送信することになります。インベントリ管理者は、インベントリアイテムのコレクションが変更されたときに知ることに興味があるかもしれないビューコントローラや他のクラスのインスタンスについて何も知る必要はありません;NSNotificationCenterがこれらの実装の詳細を処理します。ビューコントローラは単に通知を購読し、データマネージャは単に通知を投稿します。</target>
        </trans-unit>
        <trans-unit id="e1379c7d385f5fd318471115c5d1d1f688e6b7f5" translate="yes" xml:space="preserve">
          <source>In scenario two, we have other viable solutions:</source>
          <target state="translated">シナリオ2では、他にも実行可能な解決策があります。</target>
        </trans-unit>
        <trans-unit id="58156148d8f8b4168742db8860d1cd7839fb7ebe" translate="yes" xml:space="preserve">
          <source>In the implementation of the Controller2 class there will be this function as-</source>
          <target state="translated">Controller2クラスの実装では、次のような関数があります。</target>
        </trans-unit>
        <trans-unit id="5156e8c6be3a57c9fa8103860d77229d47cc7974" translate="yes" xml:space="preserve">
          <source>In the storyBoard hook the &quot;return&quot; button to the green Exit
button(Unwind) of the vc.
 Now you have a segue that &quot;goes back&quot; so u can use the
destinationViewController property in the prepareForSegue of VC2 and
change any property of VC1 before it goes back.</source>
          <target state="translated">storyBoardでは、VCの緑色のExitボタンに &quot;return &quot;ボタンをフックします。これで &quot;戻る &quot;セグエができたので、VC2のprepareForSegueでdestinationViewControllerプロパティを使って、VC1のプロパティを変更してから戻るようにします。</target>
        </trans-unit>
        <trans-unit id="4e86367af7272fc181fb5bcd8c70015239a60e37" translate="yes" xml:space="preserve">
          <source>In viewControllerA.m</source>
          <target state="translated">viewControllerA.mでは</target>
        </trans-unit>
        <trans-unit id="8a08c48c65d645ac979b803ebbf4f71b0159c9d9" translate="yes" xml:space="preserve">
          <source>In viewControllerB.m</source>
          <target state="translated">viewControllerB.mでは</target>
        </trans-unit>
        <trans-unit id="cb79757699a18236287e35ceb1f9e3b022bb1e91" translate="yes" xml:space="preserve">
          <source>Independent access</source>
          <target state="translated">独立したアクセス</target>
        </trans-unit>
        <trans-unit id="3880381f94e658ae2233113129d0559225e916ff" translate="yes" xml:space="preserve">
          <source>It is similar to the above but without the buttons, labels and such.  Just simply passing data from one view to the next.</source>
          <target state="translated">上記と似ていますが、ボタンやラベルなどはありません。ただ単にあるビューから次のビューにデータを渡すだけです。</target>
        </trans-unit>
        <trans-unit id="b906440f7eeb43644c0bf66e1e5221e013acae00" translate="yes" xml:space="preserve">
          <source>It's easy to pass data around since it's single object or couple of objects and if you have let's say UINavigationController controller, you can keep the reference to model inside and all pushed view controllers can access it directly from navigation controller.</source>
          <target state="translated">単一のオブジェクトでも複数のオブジェクトでもデータの受け渡しが簡単で、例えばUINavigationControllerコントローラがあれば、モデルへの参照を内部に保持しておくことができ、プッシュされたビューコントローラはすべてナビゲーションコントローラから直接アクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="0b5d7461b214a33821ecc10f031e0f6c05ecb915" translate="yes" xml:space="preserve">
          <source>Key-Value Observing</source>
          <target state="translated">キーバリュー観測</target>
        </trans-unit>
        <trans-unit id="8d8b4106a4bbadd0d9b29b9a2e51f6ef83bfb01d" translate="yes" xml:space="preserve">
          <source>Key-Value-Observing (KVO)</source>
          <target state="translated">キー値観測(KVO)</target>
        </trans-unit>
        <trans-unit id="083eb368f20ff79cd32a80916799dbc06c14959b" translate="yes" xml:space="preserve">
          <source>Lastly, the setup for the segue.</source>
          <target state="translated">最後にセグの設定。</target>
        </trans-unit>
        <trans-unit id="f46a343ce085e475c030eeb1bc56e9b6d0820f1a" translate="yes" xml:space="preserve">
          <source>Managing Data Flow Between View Controllers</source>
          <target state="translated">ビューコントローラ間のデータフローの管理</target>
        </trans-unit>
        <trans-unit id="6261f4593d459846fc2f53486c547ab992d8a961" translate="yes" xml:space="preserve">
          <source>Many beginner programmers take advantage of the fact that there is always exactly one &lt;strong&gt;Application Delegate&lt;/strong&gt; in the lifetime of the application, which is globally accessible. Beginning programmers use this fact to stuff objects and functionality into the appDelegate as a convenience for access from anywhere else in the application. Just because the AppDelegate is a singleton doesn't mean it should replace all other singletons. This is a poor practice as it places too much burden on one class, breaking good object-oriented practices. Each class should have a clear role that is easily explained, often just by the name of the class.</source>
          <target state="translated">多くの初心者プログラマーは、グローバルにアクセス可能なアプリケーションの存続期間中に常に1つの&lt;strong&gt;アプリケーションデリゲート&lt;/strong&gt;が存在するという事実を利用しています。 初心者のプログラマーは、この事実を使用して、アプリケーション内のどこからでもアクセスできるように、オブジェクトと機能をappDelegateに詰め込みます。 AppDelegateがシングルトンだからといって、他のすべてのシングルトンを置き換える必要があるわけではありません。 これは1つのクラスに過度の負担をかけ、オブジェクト指向の優れたプラクティスを壊すため、不適切なプラクティスです。 各クラスには、多くの場合クラスの名前だけで簡単に説明できる明確な役割が必要です。</target>
        </trans-unit>
        <trans-unit id="ee93bc5d4f01f7c4f087cb3eea0c1a1fa3b208c9" translate="yes" xml:space="preserve">
          <source>My question is, how do I transfer the data from one view to another? I will be holding the selections on the &lt;code&gt;UITableView&lt;/code&gt; in an array, but how do I then pass that back to the previous data entry form view so it can be saved along with the other data to Core Data on submission of the form?</source>
          <target state="translated">私の質問は、あるビューから別のビューにデータを転送するにはどうすればよいですか？ &lt;code&gt;UITableView&lt;/code&gt; の選択を配列で保持しますが、フォームの送信時に他のデータと一緒にコアデータに保存できるように、それを前のデータ入力フォームビューにどのように渡しますか？</target>
        </trans-unit>
        <trans-unit id="a18e3f8bc52ea9a0b5de60e0fda22bd4b604ae4c" translate="yes" xml:space="preserve">
          <source>NSFetchedResultsController</source>
          <target state="translated">NSFetchedResultsController</target>
        </trans-unit>
        <trans-unit id="3f1be4da3d97e7743b4732f8a89228df11998162" translate="yes" xml:space="preserve">
          <source>NSNotification</source>
          <target state="translated">NSNotification</target>
        </trans-unit>
        <trans-unit id="703e1cf67303eac1ee399d96fe268f382746c5ae" translate="yes" xml:space="preserve">
          <source>NSNotificationCenter.</source>
          <target state="translated">NSNotificationCenter.</target>
        </trans-unit>
        <trans-unit id="433d340991507812dfa779c7f285cce0740b90aa" translate="yes" xml:space="preserve">
          <source>NSUserDefaults (actually a poor choice)</source>
          <target state="translated">NSUserDefaults (実際には悪い選択)</target>
        </trans-unit>
        <trans-unit id="3ddf7238b6f7a09861615351dda77ab298ecd4c4" translate="yes" xml:space="preserve">
          <source>Next, we need to add the method to &lt;code&gt;ViewControllerA&lt;/code&gt; that is called when any segue is performed, because of this we need to detect which segue was called and then do something. In our example we will check for &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; and if that's performed we will pass our &lt;code&gt;BOOL&lt;/code&gt; value to &lt;code&gt;ViewControllerB&lt;/code&gt;</source>
          <target state="translated">次に、どのセグエが実行されたときに呼び出される &lt;code&gt;ViewControllerA&lt;/code&gt; にメソッドを追加する必要があります。これは、どのセグエが呼び出されたかを検出して何かを行う必要があるためです。 この例では、 &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; をチェックし、それが実行された場合は、 &lt;code&gt;BOOL&lt;/code&gt; 値を &lt;code&gt;ViewControllerB&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="bae49983d331f8ba8153193a85e0fefdfdfa8445" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;protocol&lt;/code&gt; is outside of the View Controller class.</source>
          <target state="translated">&lt;code&gt;protocol&lt;/code&gt; はView Controllerクラスの外にあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7b5b766ef197bc7d0023a5f3e888401660c5170a" translate="yes" xml:space="preserve">
          <source>Note the use of our custom &lt;code&gt;DataEnteredDelegate&lt;/code&gt; protocol.</source>
          <target state="translated">カスタム &lt;code&gt;DataEnteredDelegate&lt;/code&gt; プロトコルの使用に注意してください。</target>
        </trans-unit>
        <trans-unit id="c18f8f255ab9c208f23d0340eb9dff5a84efe311" translate="yes" xml:space="preserve">
          <source>Notification</source>
          <target state="translated">Notification</target>
        </trans-unit>
        <trans-unit id="01ae3c85aad097022aea128cd630e363a5a0b504" translate="yes" xml:space="preserve">
          <source>Notification - for broadcasting data to multiple classes at a single time</source>
          <target state="translated">通知-一度に複数のクラスにデータをブロードキャストするために</target>
        </trans-unit>
        <trans-unit id="4b1ac88a12c84ad56cbb34ecd00cd8b11ad67ab8" translate="yes" xml:space="preserve">
          <source>Now go to ViewController1.h and add the following property:</source>
          <target state="translated">ViewController1.hに移動して、以下のプロパティを追加します。</target>
        </trans-unit>
        <trans-unit id="f4fdc026034f453314cb2b9feb3226cf19c866df" translate="yes" xml:space="preserve">
          <source>Now go to ViewController2.h and add</source>
          <target state="translated">ViewController2.h に移動して、次のように追加します。</target>
        </trans-unit>
        <trans-unit id="07293e03847eaf2deb454753b5701dde56438146" translate="yes" xml:space="preserve">
          <source>Now go to ViewController2.m and inside the implementation add:</source>
          <target state="translated">今すぐViewController2.mに移動し、実装の中で追加します。</target>
        </trans-unit>
        <trans-unit id="1891d36db45cf91dbf1adab42bd7124ff5f7b4aa" translate="yes" xml:space="preserve">
          <source>Now if you are creating ViewController1 inside ViewController2 after some event, then you should do it this way using NIB files:</source>
          <target state="translated">ViewController1をイベント後にViewController2の中に作成する場合は、NIBファイルを使ってこのようにします。</target>
        </trans-unit>
        <trans-unit id="81718fed0b8059c2699c24b22f89672b462cced7" translate="yes" xml:space="preserve">
          <source>Now in viewControllerB.h</source>
          <target state="translated">viewControllerB.hでは</target>
        </trans-unit>
        <trans-unit id="066cfa98ab2af89a37dd0692de1da1e510da9279" translate="yes" xml:space="preserve">
          <source>Now in your implementation file allocate the memory for those objects like this</source>
          <target state="translated">実装ファイルの中で、以下のようにオブジェクトのメモリを確保してください。</target>
        </trans-unit>
        <trans-unit id="25d28a372f3af29852f3a97a0f8b0fbc603109d9" translate="yes" xml:space="preserve">
          <source>Now that we understand what a singleton is, let's discuss how a singleton fits into the observer pattern. The observer pattern is used for one object to respond to changes by another object. In the second scenario, we have four different view controllers, who all want to know about changes to the underlying data. The &quot;underlying data&quot; should belong to a single instance, a singleton. The &quot;know about changes&quot; is accomplished by observing changes made to the singleton.</source>
          <target state="translated">シングルトンとは何かを理解したところで、オブザーバ・パターンにどのようにシングルトンが適合するかを説明します。オブザーバ パターンは、あるオブジェクトが別のオブジェクトの変更に応答するために使用されます。2つ目のシナリオでは、4つの異なるビューコントローラがあり、それぞれが基礎となるデータの変更を知りたがっています。基になるデータ」は単一のインスタンス、シングルトンに属していなければなりません。変更を知る」ということは、シングルトンに加えられた変更を観察することによって達成されます。</target>
        </trans-unit>
        <trans-unit id="810d6004f87bdd4f1aaf25235b9fc765e7454783" translate="yes" xml:space="preserve">
          <source>Now you are all set, whenever you detect the event of check changed in ViewController1, all you have to do is the below</source>
          <target state="translated">これで、ViewController1で変更されたチェックのイベントを検出した場合は、以下のようにするだけでOKです。</target>
        </trans-unit>
        <trans-unit id="b3a73828042eb03dcbae2c139bf92a09db907f20" translate="yes" xml:space="preserve">
          <source>Now you have allocated the memory for &lt;code&gt;Array&lt;/code&gt; and object. now you can fill that memory before pushing this &lt;code&gt;ViewController&lt;/code&gt;</source>
          <target state="translated">これで、 &lt;code&gt;Array&lt;/code&gt; とオブジェクトにメモリが割り当てられました。 今、あなたはこの &lt;code&gt;ViewController&lt;/code&gt; をプッシュする前にそのメモリを埋めることができます</target>
        </trans-unit>
        <trans-unit id="9f65e68be86324bc6597c188e4d73418ae145285" translate="yes" xml:space="preserve">
          <source>Now, in your VC, anytime you want to move to a new VC and pass data, you create a new intent and add data to its dictionary (savedInstanceState). Then, just set the current intent of factory:</source>
          <target state="translated">さて、あなたのVCでは、新しいVCに移動してデータを渡したいときはいつでも、新しいインテントを作成して、その辞書(savedInstanceState)にデータを追加します。あとは、現在のFACTORYのインテントを設定するだけです。</target>
        </trans-unit>
        <trans-unit id="bec1d95a6f86d7011a1b0191ad1cb2a79100a6f0" translate="yes" xml:space="preserve">
          <source>Observer Pattern</source>
          <target state="translated">オブザーバパターン</target>
        </trans-unit>
        <trans-unit id="6869e328e00e68ce2087969b13da4a7500c52bc3" translate="yes" xml:space="preserve">
          <source>Once it is run it should switch to the receiver view automatically and pass the value from the sender to the receiver, displaying the value in the console.</source>
          <target state="translated">一度実行すると、自動的にレシーバービューに切り替わり、送信者からレシーバーに値を渡し、コンソールに値を表示します。</target>
        </trans-unit>
        <trans-unit id="1a8ee395cb2fe5ae68947c4ee9e43e6c00f1c91e" translate="yes" xml:space="preserve">
          <source>One approach is to share pointers to the model objects between view controllers.</source>
          <target state="translated">1つのアプローチは、ビューコントローラ間でモデルオブジェクトへのポインタを共有することです。</target>
        </trans-unit>
        <trans-unit id="c4076a44a136b6e3d1dde14cee2663da71d34347" translate="yes" xml:space="preserve">
          <source>One thing to remember is that using block often needs to manage strong and __weak references  like explained &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW16&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">覚えておくべきことの1つは、ブロックを使用すると、 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW16&quot;&gt;ここで&lt;/a&gt;説明するような強い参照と__weak参照を管理する必要があることが多い</target>
        </trans-unit>
        <trans-unit id="0e88c4b3dfd5e93f534f4bbe8851936f162bd94e" translate="yes" xml:space="preserve">
          <source>Or if you need to pass more than 3 parameters which are related to a common feature you can store the values to a Model class and pass that modelObject to the next class</source>
          <target state="translated">あるいは、共通の機能に関連する3つ以上のパラメータを渡す必要がある場合は、モデルクラスに値を保存し、そのモデルオブジェクトを次のクラスに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="ad245eca6b5201f4babe15b0ebc45f1a1101dc9c" translate="yes" xml:space="preserve">
          <source>Passing Data Between View Controllers</source>
          <target state="translated">ビューコントローラ間でのデータの受け渡し</target>
        </trans-unit>
        <trans-unit id="06cd07cfe5ceeea538fa8519602b78db4a7a221b" translate="yes" xml:space="preserve">
          <source>Passing Data between View Controllers</source>
          <target state="translated">ビューコントローラ間でのデータの受け渡し</target>
        </trans-unit>
        <trans-unit id="e969e4903b74ca67d170b3ed2c9867a31ea779e7" translate="yes" xml:space="preserve">
          <source>Passing data back from ViewController 2(destination) to viewController 1(Source) is the more interesting thing.
Assuming you use storyBoard those are all the ways i found out:</source>
          <target state="translated">ViewController 2(destination)からViewController 1(Source)へのデータの受け渡しの方が面白いです。storyBoardを使用していると仮定すると、これらの方法は私が見つけたすべての方法です。</target>
        </trans-unit>
        <trans-unit id="90994a166764b8045c671701e6012101fbad1f99" translate="yes" xml:space="preserve">
          <source>Passing data back to the previous View Controller</source>
          <target state="translated">データを前のビューコントローラに戻す</target>
        </trans-unit>
        <trans-unit id="f34143ad2ab7c3261acf61c694d57262c6895d43" translate="yes" xml:space="preserve">
          <source>Passing data forward to a view controller from another view controller. You would use this method if you wanted to pass an object/value from one view controller to another view controller that you may be pushing on to a navigation stack.</source>
          <target state="translated">別のビューコントローラからビューコントローラにデータを転送します。あるビューコントローラから別のビューコントローラにオブジェクト値を渡したい場合にこのメソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="72012e34fc1aeacc4018406263df2a50524a13b3" translate="yes" xml:space="preserve">
          <source>Passing data forward to the next View Controller</source>
          <target state="translated">データを次のビューコントローラに転送する</target>
        </trans-unit>
        <trans-unit id="7cbc262874edf29fb88c6eb2ae168aa523c5bed0" translate="yes" xml:space="preserve">
          <source>Passing data through notifications</source>
          <target state="translated">通知を介したデータの受け渡し</target>
        </trans-unit>
        <trans-unit id="e73c1b3673eb3091a3411becb205b9ac61c3efb6" translate="yes" xml:space="preserve">
          <source>Passing data through the app delegate</source>
          <target state="translated">アプリデリゲートを介したデータの受け渡し</target>
        </trans-unit>
        <trans-unit id="a915a260ebb52c58c5ddeb3943b28412a9cefd74" translate="yes" xml:space="preserve">
          <source>Please tell me if there's anything that's not clear of if I didn't understand your question properly.</source>
          <target state="translated">質問の内容をきちんと理解していなかったのであれば、何かわからないことがあれば教えてください。</target>
        </trans-unit>
        <trans-unit id="f176ff29bfb1c8e95257d7a079bef36426919bfd" translate="yes" xml:space="preserve">
          <source>Rather than having a highly hypothetical, abstract discussion, it helps to have concrete applications in mind. To help define a two-view-controller situation and a more-than-two-view-controller situation, I am going to define two concrete application scenarios.</source>
          <target state="translated">高度に仮説的で抽象的な議論をするよりも、具体的なアプリケーションを念頭に置いておくことが役立ちます。2 つのビュー コ ン ト ロ ー ラ ー状況 と 2 つ以上のビュー コ ン ト ロ ー ラ ー状況を定義す る ために、2 つの具体的なアプ リ ケーシ ョ ン シ ナ リ オを定義 し ます。</target>
        </trans-unit>
        <trans-unit id="96723c17d633897e26d4e0d1557b30b3a18133db" translate="yes" xml:space="preserve">
          <source>Read more about this in my blog post: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;Sharing Model Code&lt;/a&gt;</source>
          <target state="translated">これについて詳しくは、ブログの投稿： &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;モデルコードの共有&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="a6171b282836b161fc897d0e7facdf82f4d8f378" translate="yes" xml:space="preserve">
          <source>Referencing the previous controller directly instead of using delegation</source>
          <target state="translated">委任を使わずに、前のコントローラを直接参照します。</target>
        </trans-unit>
        <trans-unit id="47f40c97b581997edd1f3619ce23a4265e1431df" translate="yes" xml:space="preserve">
          <source>Saving in &lt;code&gt;NSUserDefaults&lt;/code&gt; - for accessing it later</source>
          <target state="translated">&lt;code&gt;NSUserDefaults&lt;/code&gt; に保存-後でアクセスするため</target>
        </trans-unit>
        <trans-unit id="0bcf73dc223ca8c4becbbceb7de2d7cdd2d55fd9" translate="yes" xml:space="preserve">
          <source>Say we have viewControllers: ViewController and NewViewController.</source>
          <target state="translated">viewControllers.ViewController と NewViewController があるとします。ViewController と NewViewController があるとします。</target>
        </trans-unit>
        <trans-unit id="569d57f11dc5d61438be375ec49d9c3b862b507e" translate="yes" xml:space="preserve">
          <source>Say we have viewControllers: viewControllerA and viewControllerB</source>
          <target state="translated">以下のような viewControllers:viewControllerA と viewControllerB があるとします。</target>
        </trans-unit>
        <trans-unit id="7995203d870462ca887f06daef0b98c3ee08ad6a" translate="yes" xml:space="preserve">
          <source>SecondViewController.h</source>
          <target state="translated">SecondViewController.h</target>
        </trans-unit>
        <trans-unit id="1915fd9b6120253558e8f5d765575ff18961657e" translate="yes" xml:space="preserve">
          <source>Set data in prepareForSegue (if storyboards) or init (if programmatic)</source>
          <target state="translated">prepareForSegue (ストーリーボードの場合)または init (プログラムの場合)でデータを設定します。</target>
        </trans-unit>
        <trans-unit id="9f9b397db477e0a2585ce2a75ed1b81d61e4549c" translate="yes" xml:space="preserve">
          <source>Set the first and second View Controllers to the appropriate Swift files in IB.</source>
          <target state="translated">1 番目と 2 番目のビューコントローラを IB の適切な Swift ファイルに設定します。</target>
        </trans-unit>
        <trans-unit id="ccfa21b36505d345ced6258f5060e6876076d7db" translate="yes" xml:space="preserve">
          <source>Shared data</source>
          <target state="translated">共有データ</target>
        </trans-unit>
        <trans-unit id="63b646be139048f00d5075927d5ac6aa1bc9e3fd" translate="yes" xml:space="preserve">
          <source>Sharing data through a singleton</source>
          <target state="translated">シングルトンによるデータの共有</target>
        </trans-unit>
        <trans-unit id="88026f64b6a3f47cdb4c499ea8d5bb82d8ae7191" translate="yes" xml:space="preserve">
          <source>Sharing data through the user defaults</source>
          <target state="translated">ユーザーを介したデータの共有がデフォルト</target>
        </trans-unit>
        <trans-unit id="a81942be08afc02b07b690161fca39667b375b36" translate="yes" xml:space="preserve">
          <source>Since all the view controllers do need to share the same data, all four view controllers need to remain in synchronization, and therefore there needs to be some sort of communication to all other view controllers, whenever any single view controller changes the underlying data. It should be fairly obvious that we do not want each view controller communicating directly with each other view controller in this scenario. In case it is not obvious, consider if we had 20 different view controllers (rather than just 4). How difficult and error-prone would it be to notify each of the other 19 view controllers any time one view controller made a change?</source>
          <target state="translated">すべてのビューコントローラが同じデータを共有する必要があるため、4つのビューコントローラはすべて同期状態を維持する必要があり、したがって、1つのビューコントローラが基礎となるデータを変更するたびに、他のすべてのビューコントローラと何らかの通信を行う必要があります。このシナリオでは、各ビューコントローラが他のビューコントローラと直接通信する必要はないことは明らかです。自明ではない場合は、20個のビューコントローラがあった場合を考えてみましょう(4個だけではなく)。あるビューコントローラが変更を加えたときに、他の19個のビューコントローラのそれぞれに通知するのは、どれほど困難でエラーが発生しやすいでしょうか?</target>
        </trans-unit>
        <trans-unit id="956ba40003839a7f10984a661afb553e5a9a4ec6" translate="yes" xml:space="preserve">
          <source>Since prepare for segue is the most common here is an example:</source>
          <target state="translated">分離のための準備が最も一般的なので、ここでは例を示しています。</target>
        </trans-unit>
        <trans-unit id="39892ce8d343b16aa782fc0cc427d7c5ce4bcd1d" translate="yes" xml:space="preserve">
          <source>Singleton</source>
          <target state="translated">Singleton</target>
        </trans-unit>
        <trans-unit id="5f4a7d1855bedb7eb4c08667076bebd6d20d2643" translate="yes" xml:space="preserve">
          <source>Singleton classes</source>
          <target state="translated">シングルトンクラス</target>
        </trans-unit>
        <trans-unit id="f4952f106d9d3b4bccd6d238d2f11b71e55ecb4c" translate="yes" xml:space="preserve">
          <source>Singletons</source>
          <target state="translated">Singletons</target>
        </trans-unit>
        <trans-unit id="b57cd7bb78daf1f63929b88ccbd517476d4ae4d7" translate="yes" xml:space="preserve">
          <source>So Here is the complete code for :</source>
          <target state="translated">そこで、ここでは.NETの完全なコードを紹介します。</target>
        </trans-unit>
        <trans-unit id="067b41481717b1f69eb20355ee8195bf00f43e67" translate="yes" xml:space="preserve">
          <source>So in-short if you want to -</source>
          <target state="translated">だから、あなたがしたい場合は、インショートで-。</target>
        </trans-unit>
        <trans-unit id="630e7f3acca48624176a82489c5a93d213da2351" translate="yes" xml:space="preserve">
          <source>So this is how you can pass data from viewControllerA to viewControllerB without setting any delegate. ;)</source>
          <target state="translated">このようにして、デリゲートを設定せずに viewControllerA から viewControllerB にデータを渡すことができます。)</target>
        </trans-unit>
        <trans-unit id="156495cd7dd5073171ae3eca350eda618cbfbef4" translate="yes" xml:space="preserve">
          <source>So this way we can pass the data from one viewcontroller to another view controller...</source>
          <target state="translated">このようにして、あるビューコントローラから別のビューコントローラにデータを渡すことができます...</target>
        </trans-unit>
        <trans-unit id="9fa353fb1913b923bef4e523da2474a47221935b" translate="yes" xml:space="preserve">
          <source>So to pass a &lt;code&gt;BOOL&lt;/code&gt; from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; we would do the following:</source>
          <target state="translated">したがって、 &lt;code&gt;BOOL&lt;/code&gt; を &lt;code&gt;ViewControllerA&lt;/code&gt; からViewControllerBに &lt;code&gt;ViewControllerB&lt;/code&gt; には、次のようにします。</target>
        </trans-unit>
        <trans-unit id="98d77a00cf4d2b88573bd271f511f0e79ed4f054" translate="yes" xml:space="preserve">
          <source>Solutions I recommend NOT to use:</source>
          <target state="translated">使わないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b08338f95aa0ad8470939d5e2faa60ab6d042c8f" translate="yes" xml:space="preserve">
          <source>Step 1. Declare block in ViewControllerB</source>
          <target state="translated">ステップ1.ViewControllerBでブロックを宣言する</target>
        </trans-unit>
        <trans-unit id="b2e9b0649764d10cd7a0faf97a6596c1df79f36a" translate="yes" xml:space="preserve">
          <source>Step 1. Set and Post data in Notification observer in ViewControllerB</source>
          <target state="translated">ステップ1.ViewControllerBのNotificationオブザーバーにデータを設定して投稿する</target>
        </trans-unit>
        <trans-unit id="68b389f0cd09c0cdce9598cbf02e200602cae14b" translate="yes" xml:space="preserve">
          <source>Step 2. Add Notification Observer in ViewControllerA</source>
          <target state="translated">ステップ2.ViewControllerAにNotificationオブザーバを追加する</target>
        </trans-unit>
        <trans-unit id="0b56714eef4294da9118c9f272a4110e07a65e76" translate="yes" xml:space="preserve">
          <source>Step 2. Set data in block in ViewControllerB</source>
          <target state="translated">ステップ2.ViewControllerBのブロックにデータを設定する</target>
        </trans-unit>
        <trans-unit id="a2546740685a30020fdf8994c5e6ec2f4358487b" translate="yes" xml:space="preserve">
          <source>Step 3. Receive Notification data value in ViewControllerA</source>
          <target state="translated">ステップ3.ViewControllerAで通知データの値を受信する</target>
        </trans-unit>
        <trans-unit id="8fc7fedaa6db88ca11b7a1de1f3aca654b50e838" translate="yes" xml:space="preserve">
          <source>Step 3. Receive block data in ViewControllerA</source>
          <target state="translated">ステップ3.ViewControllerAでブロックデータを受信する</target>
        </trans-unit>
        <trans-unit id="270b96d467cbf5437502201704dee28da77c95f4" translate="yes" xml:space="preserve">
          <source>Storyboard segues, ARC and LLVM blocks make this easier than ever for me.  Some answers above mentioned storyboards and segues already but still relied on delegation.  Defining delegates certainly works but some people may find it easier to pass pointers or code blocks.</source>
          <target state="translated">ストーリーボードのセグ、ARCとLLVMブロックは、私にとってこれまで以上に簡単になります。上記の回答の中には、既にストーリーボードとセグに言及しているものもありましたが、やはり委任に頼っていました。委任を定義することは確かに機能しますが、人によってはポインタやコードブロックを渡す方が簡単だと感じるかもしれません。</target>
        </trans-unit>
        <trans-unit id="3b14c615ad076500bec6990bd3e8c11b39b908a7" translate="yes" xml:space="preserve">
          <source>Suppose in Controller1 class you want to create the Controller2 object and push it with a String value being passed. This can be done as this:-</source>
          <target state="translated">Controller1クラスでController2オブジェクトを作成し、それに文字列を渡してプッシュしたいとします。これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="112ab020698e5fc0f4baecd7821a512d8c419a69" translate="yes" xml:space="preserve">
          <source>Swift</source>
          <target state="translated">Swift</target>
        </trans-unit>
        <trans-unit id="19d9195fc6303123e2881ef15e4a993bb8b3dec5" translate="yes" xml:space="preserve">
          <source>Synthesize str2 in ViewControllerTwo.m</source>
          <target state="translated">ViewControllerTwo.m で str2 を合成します。</target>
        </trans-unit>
        <trans-unit id="0207a1f2edfc990bff7a614c26a4e4edee42239e" translate="yes" xml:space="preserve">
          <source>Take care for spelling mistakes.</source>
          <target state="translated">誤字脱字には注意しましょう。</target>
        </trans-unit>
        <trans-unit id="09429d005a789be54befa1f80bc0eeaac578f2e8" translate="yes" xml:space="preserve">
          <source>Than in implementation file BViewController.m after we have desired values to return our callback should be called:</source>
          <target state="translated">実装ファイルBViewController.mの中で、コールバックを返す値を指定した後に、コールバックを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="03d7f840d11dff1bc5d8b6d191428b355e3aebb7" translate="yes" xml:space="preserve">
          <source>Thanks for all your help</source>
          <target state="translated">お世話になりました</target>
        </trans-unit>
        <trans-unit id="8527cb919ee3a95cff65ca01028642d6226a89b6" translate="yes" xml:space="preserve">
          <source>That is how you can tackle it if you want to use a segue and you don't have your pages under a navigation controller.</source>
          <target state="translated">それはあなたがセグセグを使用したい場合は、それに取り組むことができますし、あなたはナビゲーションコントローラの下にあなたのページを持っていない場合は、それに取り組むことができます。</target>
        </trans-unit>
        <trans-unit id="95e8fe02f9d9ffb578ba4e865a2725ad960d20a6" translate="yes" xml:space="preserve">
          <source>That's it for &lt;code&gt;ViewControllerB&lt;/code&gt;. Now in &lt;code&gt;ViewControllerA.h&lt;/code&gt;, tell &lt;code&gt;ViewControllerA&lt;/code&gt; to import &lt;code&gt;ViewControllerB&lt;/code&gt; and conform to its protocol.</source>
          <target state="translated">&lt;code&gt;ViewControllerB&lt;/code&gt; については以上です。 次に &lt;code&gt;ViewControllerA.h&lt;/code&gt; で 、 &lt;code&gt;ViewControllerA&lt;/code&gt; にViewControllerBをインポートしてそのプロトコルに準拠するように伝えます。</target>
        </trans-unit>
        <trans-unit id="56ac635adbb66b598268b04a53cefa274b67ac90" translate="yes" xml:space="preserve">
          <source>That's it. Running the app now you should be able to send data back from the second view controller to the first.</source>
          <target state="translated">これで完了です。今アプリを実行すると、2番目のビューコントローラから1番目のビューコントローラにデータを送り返すことができるはずです。</target>
        </trans-unit>
        <trans-unit id="61f175a537a69568d4d36d5d1c44c51c042c2dc5" translate="yes" xml:space="preserve">
          <source>The M in MVC is for &quot;Model&quot; and in the MVC paradigm the role of model classes is to manage a program's data. A model is the opposite of a view -- a view knows how to display data, but it knows nothing about what to do with data, whereas a model knows everything about how to work with data, but nothing about how to display it. Models can be complicated, but they don't have to be -- the model for your app might be as simple as an array of strings or dictionaries.</source>
          <target state="translated">MVCのMは「モデル」のことで、MVCパラダイムではモデルクラスの役割はプログラムのデータを管理することです。ビューはデータの表示方法を知っていますが、データをどう扱うかについては何も知りません。アプリのモデルは、文字列や辞書の配列のように単純なものかもしれません。</target>
        </trans-unit>
        <trans-unit id="de4d0fb8549c6a726ff58a67a687beaccbe06a26" translate="yes" xml:space="preserve">
          <source>The OP didn't mention view controllers but so many of the answers do, that I wanted to chime in with what some of the new features of the LLVM allow to make this easier when wanting to pass data from one view controller to another and then getting some results back.</source>
          <target state="translated">OPではビューコントローラについては触れられていませんが、多くの回答がそうなので、あるビューコントローラから別のビューコントローラにデータを渡して結果を返したい場合に、LLVMの新機能のいくつかがどのようにこれを容易にしてくれるのかを教えてもらいたいと思いました。</target>
        </trans-unit>
        <trans-unit id="c20529383e6407f57b3ff8211721c8adde0bba28" translate="yes" xml:space="preserve">
          <source>The Receiver</source>
          <target state="translated">受信者</target>
        </trans-unit>
        <trans-unit id="4154dd7ff0aa610daf859664a9f5cdd415da28f3" translate="yes" xml:space="preserve">
          <source>The Segue</source>
          <target state="translated">セグエ</target>
        </trans-unit>
        <trans-unit id="ebcf3ab1a842c17f7a5edda449755a002af952e2" translate="yes" xml:space="preserve">
          <source>The Sender</source>
          <target state="translated">送信者</target>
        </trans-unit>
        <trans-unit id="b93bdfec7ee7436d0d31a07d163e319c506ba2dd" translate="yes" xml:space="preserve">
          <source>The code for the First View Controller is</source>
          <target state="translated">ファーストビューコントローラのコードは</target>
        </trans-unit>
        <trans-unit id="16d83b85f70f1ef1d672a4056bde27f526c1f3e4" translate="yes" xml:space="preserve">
          <source>The code for the second view controller is</source>
          <target state="translated">2つ目のビューコントローラのコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="1427436496c2ed01688bdba0dfac3d0163918947" translate="yes" xml:space="preserve">
          <source>The following is an example based on the video (with a few modifications).</source>
          <target state="translated">以下は、動画を元にした例です(若干の修正あり)。</target>
        </trans-unit>
        <trans-unit id="27168310b19624bfd7d1406057bd1581233f19b9" translate="yes" xml:space="preserve">
          <source>The following is an example based on the video. The idea is to pass a string from the text field in the First View Controller to the label in the Second View Controller.</source>
          <target state="translated">以下は動画を元にした例です。第一ビューコントローラのテキストフィールドから第二ビューコントローラのラベルに文字列を渡すというものです。</target>
        </trans-unit>
        <trans-unit id="07cf6b0d487458fa179fc57899f7a0abf454ed14" translate="yes" xml:space="preserve">
          <source>The home inventory application would have a single instance of a class which is designed to manage a list of inventory items. The manager would manage a collection of household items. The following is a class definition for the data manager:</source>
          <target state="translated">ホームインベントリアプリケーションは、インベントリアイテムのリストを管理するように設計されたクラスの単一のインスタンスを持つことになります。マネージャは、家庭用品のコレクションを管理します。以下はデータ・マネージャーのクラス定義です。</target>
        </trans-unit>
        <trans-unit id="3883ea5969f34a183a8fdf68d24a5c4df97e7e94" translate="yes" xml:space="preserve">
          <source>The idea is imitate Android's intent paradigm, using a global factory to manage which view you are looking at and using &quot;intents&quot; to switch and pass data between views. All the documentation is on the github page, but here are some highlights:</source>
          <target state="translated">このアイデアはAndroidのインテントパラダイムを真似たもので、グローバルファクトリを使ってどのビューを見ているかを管理し、&quot;intent &quot;を使ってビュー間でデータを切り替えたり渡したりするというものです。ドキュメントはすべてgithubページにありますが、ここではいくつかのハイライトを紹介します。</target>
        </trans-unit>
        <trans-unit id="f4deb3d745148fadb3c8578e557f0283203b359a" translate="yes" xml:space="preserve">
          <source>The most common way I've seen this done is a &lt;a href=&quot;http://koreyhinton.com/blog/singleton-pattern-in-swift.html&quot;&gt;singleton&lt;/a&gt; instance. So if your singleton object was &lt;code&gt;DataAccess&lt;/code&gt; you could do the following in the viewDidLoad method of UIViewController:</source>
          <target state="translated">これを確認した最も一般的な方法は、 &lt;a href=&quot;http://koreyhinton.com/blog/singleton-pattern-in-swift.html&quot;&gt;シングルトン&lt;/a&gt;インスタンスです。 したがって、シングルトンオブジェクトがDataAccessの場合、UIViewControllerのviewDidLoadメソッドで次のことを実行できます。</target>
        </trans-unit>
        <trans-unit id="270c440ea6ee47f9a7fab1f1471c613f9ba1ab40" translate="yes" xml:space="preserve">
          <source>The nice thing about Core Data is that it has inverse relationships. So if you want to just give a NotesViewController the notes object you can because it'll have an inverse relationship to something else like the notebook. If you need data on the notebook in the NotesViewController you can walk back up the object graph by doing the following:</source>
          <target state="translated">Core Dataの良いところは、逆の関係を持っていることです。そのため、NotesViewControllerにノートのオブジェクトを渡したい場合は、ノートのような他の何かとは逆の関係になるからです。NotesViewControllerのノートのデータが必要な場合は、以下のようにしてオブジェクトグラフを遡ることができます。</target>
        </trans-unit>
        <trans-unit id="014260d3b948862434b9fa2f84c8640f401e09aa" translate="yes" xml:space="preserve">
          <source>The original poster also asked about &lt;strong&gt;Singletons&lt;/strong&gt; and the use of the &lt;strong&gt;AppDelegate&lt;/strong&gt;. These questions need to be answered.</source>
          <target state="translated">元の投稿者は、 &lt;strong&gt;シングルトン&lt;/strong&gt;と&lt;strong&gt;AppDelegateの&lt;/strong&gt;使用についても尋ね&lt;strong&gt;ました&lt;/strong&gt; 。 これらの質問には答える必要があります。</target>
        </trans-unit>
        <trans-unit id="4051bc4c8e14e8ba896618084a6ea2e97b0c1335" translate="yes" xml:space="preserve">
          <source>The question asks about passing information between view controllers. The specific example given asks about passing information between views, but given the self-stated newness to iOS, the original poster likely meant between viewControllers, not between views (without any involvement from the ViewControllers). It seems that all the answers focus on two view controllers, but what if the app evolves to need to involve more than two view controllers in the information exchange?</source>
          <target state="translated">この質問はビューコントローラ間での情報の受け渡しについて尋ねています。特定の例ではビュー間での情報の受け渡しについて質問していますが、iOSへの自称新しさを考えると、元の投稿者はビュー間ではなくビューコントローラ間のことを意味している可能性が高いです(ビューコントローラが関与していない)。すべての回答は2つのビュー コントローラに焦点を当てているように見えますが、アプリが進化して情報交換に2つ以上のビュー コントローラを関与させる必要がある場合はどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="63899f87ba40f61b456ad097f7880f169dadb468" translate="yes" xml:space="preserve">
          <source>The role of a controller is to mediate between view and model. Therefore, they need a reference to one or more view objects and one or more model objects. Let's say that your model is an array of dictionaries, with each dictionary representing one row in your table. The root view for your app displays that table, and it might be responsible for loading the array from a file. When the user decides to add a new row to the table, they tap some button and your controller creates a new (mutable) dictionary and adds it to the array. In order to fill in the row, the controller creates a detail view controller and gives it the new dictionary. The detail view controller fills in the dictionary and returns. The dictionary is already part of the model, so nothing else needs to happen.</source>
          <target state="translated">コントローラの役割は、ビューとモデルの間を仲介することです。したがって、1つ以上のビューオブジェクトと1つ以上のモデルオブジェクトへの参照が必要です。モデルがディクショナリの配列で、各ディクショナリがテーブルの1行を表しているとします。アプリのルートビューはそのテーブルを表示し、ファイルから配列をロードします。ユーザーがテーブルに新しい行を追加すると決定すると、ユーザーはボタンをタップして、コントローラが新しい(変更可能な)辞書を作成して配列に追加します。行を埋めるために、コントローラは詳細ビューコントローラを作成し、そのコントローラに新しい辞書を与えます。詳細ビューコントローラは、ディクショナリを埋めて返します。ディクショナリはすでにモデルの一部なので、他に何もする必要はありません。</target>
        </trans-unit>
        <trans-unit id="862d75bb0f5e8e1bf177a0884bd45d4099f46cae" translate="yes" xml:space="preserve">
          <source>Then where you want to load the view eg. &lt;code&gt;didSelectRowAtIndex&lt;/code&gt; or some &lt;code&gt;IBAction&lt;/code&gt; you need to set the property in &lt;code&gt;ViewControllerB&lt;/code&gt; before you push it onto nav stack.</source>
          <target state="translated">次に、ビューをロードする場所。 &lt;code&gt;didSelectRowAtIndex&lt;/code&gt; またはいくつかの &lt;code&gt;IBAction&lt;/code&gt; をナビスタックにプッシュする前に、 &lt;code&gt;ViewControllerB&lt;/code&gt; でプロパティを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5db5c8fd4b2f27895e7362cba1af3ede532b9753" translate="yes" xml:space="preserve">
          <source>There are addition tools that also help pass along data:</source>
          <target state="translated">また、データを渡すのに役立つ追加ツールもあります。</target>
        </trans-unit>
        <trans-unit id="31d86b3beff40f0926f74e37f90530611aeeffd6" translate="yes" xml:space="preserve">
          <source>There are four view controllers in the application. It is a tab-based application for managing home inventory. Three view controllers present differently filtered views of the same data:</source>
          <target state="translated">アプリには4つのビューコントローラーがあります。これは、ホームインベントリを管理するためのタブベースのアプリケーションです。3つのビューコントローラは、同じデータの異なるフィルタリングされたビューを表示します。</target>
        </trans-unit>
        <trans-unit id="e97a58b0ba4425fd3070b8fbcc8e0520fcec97d9" translate="yes" xml:space="preserve">
          <source>There are many answers to this questions offering many different ways to perform view controller communication that would indeed work, but I don't see anywhere mentioned which one are actually best to use and which ones to avoid.</source>
          <target state="translated">ビューコントローラ通信を実行するための多くの異なる方法を提供するこの質問への多くの答えがありますが、私はどこにも言及された1つが実際に使用するのが最善であり、どのものを避けるべきであるかを見たことがありません。</target>
        </trans-unit>
        <trans-unit id="dbd19e78c5369d7ba92070651ccf13b36f340393" translate="yes" xml:space="preserve">
          <source>There are multiple methods for sharing data.</source>
          <target state="translated">データを共有する方法は複数あります。</target>
        </trans-unit>
        <trans-unit id="e8c21a80ff30368c9db68fd252bbe172753c326e" translate="yes" xml:space="preserve">
          <source>There are multiple options for Passing Data between View Controllers.</source>
          <target state="translated">ビューコントローラ間でデータを渡すには、複数のオプションがあります。</target>
        </trans-unit>
        <trans-unit id="6b070a9e49cdb6fb5eedc6805c49fc2267e7f279" translate="yes" xml:space="preserve">
          <source>There are three parts.</source>
          <target state="translated">3つのパートに分かれています。</target>
        </trans-unit>
        <trans-unit id="960919526c1232c2ceccc14249d25e632af94356" translate="yes" xml:space="preserve">
          <source>There are tons and tons of explanations here and around StackOverflow, but if you are a beginner just trying to get something basic to work, try watching this YouTube tutorial (It's what helped me to finally understand how to do it).</source>
          <target state="translated">ここやStackOverflowの周りにはたくさんの説明がありますが、もしあなたが初心者で何か基本的なことを動作させようとしているのであれば、このYouTubeのチュートリアルを見てみてください(私がようやくやり方を理解するのに役立ったのはこのチュートリアルのおかげです)。</target>
        </trans-unit>
        <trans-unit id="e8afd6f06c1bbab721680e593a168e06c21f9e95" translate="yes" xml:space="preserve">
          <source>There are tons of ways to do this and it's important to pick the right one. Probably one of the biggest architectural decisions lies on how the model code will be shared or accessed throughout the app.</source>
          <target state="translated">これを行う方法はたくさんありますが、正しい方法を選ぶことが重要です。おそらく、最大のアーキテクチャ上の決定の一つは、モデルコードをどのようにアプリ全体で共有するか、またはアクセスするかにあります。</target>
        </trans-unit>
        <trans-unit id="add7b260a0c3a797d43225e8dd73c9d548468567" translate="yes" xml:space="preserve">
          <source>There are two view controllers in the application. There is a ViewControllerA (Data Entry Form), and View Controller B (Product List). The items selected in the product list must match the items displayed in the text box in the data entry form. In this scenario, ViewControllerA and ViewControllerB must communicate directly with each other and no other view controllers.</source>
          <target state="translated">アプリケーションには2つのビューコントローラがあります。ViewControllerA(データ入力フォーム)とViewControllerB(商品リスト)があります。商品リストで選択された項目は、データ入力フォームのテキストボックスに表示された項目と一致しなければなりません。このシナリオでは、ViewControllerAとViewControllerBは直接通信しなければならず、他のビューコントローラは使用できません。</target>
        </trans-unit>
        <trans-unit id="5ad48280e06634ee952854dfb7d646a39384f662" translate="yes" xml:space="preserve">
          <source>There are various ways by which a data can be received to a different class in iOS. For example -</source>
          <target state="translated">iOSでは、データを別のクラスに受信する方法がいろいろあります。例えば</target>
        </trans-unit>
        <trans-unit id="6366268fa2a29045a4f2964c6049a44dee20ec43" translate="yes" xml:space="preserve">
          <source>There is some good information in many of the answers given, but none address the question fully.</source>
          <target state="translated">多くの回答の中には良い情報がありますが、質問に完全に対応しているものはありませんでした。</target>
        </trans-unit>
        <trans-unit id="2244b353f7eacc064ac43be42125be2888874124" translate="yes" xml:space="preserve">
          <source>These solutions, although working in the short term, introduce too many dependencies that will garble the architecture of the app and create more problems later.</source>
          <target state="translated">これらのソリューションは短期的には機能しますが、あまりにも多くの依存関係を導入してしまうと、アプリのアーキテクチャが文字化けしてしまい、後になってより多くの問題が発生します。</target>
        </trans-unit>
        <trans-unit id="4feffb40e53daab15d1fd2a31b491d1a986d94e5" translate="yes" xml:space="preserve">
          <source>This example passes data from &lt;strong&gt;Controller B&lt;/strong&gt; to &lt;strong&gt;Controller A&lt;/strong&gt;</source>
          <target state="translated">この例では、 &lt;strong&gt;コントローラーB&lt;/strong&gt;から&lt;strong&gt;コントローラーAに&lt;/strong&gt;データを渡し&lt;strong&gt;ます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72942e4d622ebca94f54d92fc991209dbbc62e1b" translate="yes" xml:space="preserve">
          <source>This is a very simple view layout with a segue between them.</source>
          <target state="translated">間にセグメンテーションを挟んだ非常にシンプルなビューレイアウトです。</target>
        </trans-unit>
        <trans-unit id="dc585b46d7fdc70eda1e5bd71fce0fb21a21baaf" translate="yes" xml:space="preserve">
          <source>This is not the way to do it, you should use delegates, I'll assume we have two view controllers ViewController1 and ViewController2 and this check thing is in the first one and when its state changes, you want to do something in ViewController2, to achieve that in the proper way, you should do the below:</source>
          <target state="translated">この方法ではなく、デリゲートを使用する必要があります。2つのビューコントローラViewController1とViewController2があり、このチェックは最初の方にあり、その状態が変化したときにViewController2で何かをしたいとします。</target>
        </trans-unit>
        <trans-unit id="8073a2ecfc42ee7250cf1e560c182673934a6f7f" translate="yes" xml:space="preserve">
          <source>This page just sends the value of the variable to the console when it loads.  By this point, our favorite movie should be in that variable.</source>
          <target state="translated">このページでは、ロード時に変数の値をコンソールに送信しています。この時点で、お気に入りのムービーがその変数に入っているはずです。</target>
        </trans-unit>
        <trans-unit id="53aebdd79abe6d5b1bdd1f334b4ef03089ec8441" translate="yes" xml:space="preserve">
          <source>This page takes the initially loaded value and passes it along.</source>
          <target state="translated">このページは、最初に読み込まれた値を受け取り、それを渡します。</target>
        </trans-unit>
        <trans-unit id="7c7f8bc26f34edac64e4f9e9a10d6758f2fd6803" translate="yes" xml:space="preserve">
          <source>This question seems to be very popular here on stackoverflow so I thought I would try and give a better answer to help out people starting in the world of iOS like me.</source>
          <target state="translated">この質問はここstackoverflow上で非常に人気があるようなので、私のようにiOSの世界で始める人を助けるために、より良い答えを出してみようと思いました。</target>
        </trans-unit>
        <trans-unit id="17b7883c0d9c134005d8b98f4a635cdcdce103d0" translate="yes" xml:space="preserve">
          <source>This second example shows passing a callback block for the second argument.  I like using blocks because it keeps the relevant details close together in the source - the higher level source.</source>
          <target state="translated">この 2 番目の例では、2 番目の引数にコールバック ブロックを渡しています。ブロックを使うのが好きなのは、関連する詳細な情報をソースの中で、より高いレベルのソースの近くに置いておくからです。</target>
        </trans-unit>
        <trans-unit id="5f05e53b88ac8f87becf055c72279b70a06d25c6" translate="yes" xml:space="preserve">
          <source>This will set &lt;code&gt;isSomethingEnabled&lt;/code&gt; in &lt;code&gt;ViewControllerB&lt;/code&gt; to &lt;code&gt;BOOL&lt;/code&gt; value &lt;code&gt;YES&lt;/code&gt;.</source>
          <target state="translated">これ &lt;code&gt;isSomethingEnabled&lt;/code&gt; 、 &lt;code&gt;ViewControllerB&lt;/code&gt; のisSomethingEnabledが &lt;code&gt;BOOL&lt;/code&gt; 値 &lt;code&gt;YES&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="702efc9cba1bbd3afb5e2a9f9ce7d9ec865cbd29" translate="yes" xml:space="preserve">
          <source>Those were  discussed here already.</source>
          <target state="translated">それはすでにここで議論されています。</target>
        </trans-unit>
        <trans-unit id="83ec681c5928fb675fe4016bcba307422f910286" translate="yes" xml:space="preserve">
          <source>To do this we will make &lt;code&gt;ViewControllerA&lt;/code&gt; a delegate of &lt;code&gt;ViewControllerB&lt;/code&gt;. This allows &lt;code&gt;ViewControllerB&lt;/code&gt; to send a message back to &lt;code&gt;ViewControllerA&lt;/code&gt; enabling us to send data back.</source>
          <target state="translated">これを行うには、 &lt;code&gt;ViewControllerA&lt;/code&gt; をViewControllerBのデリゲートにし &lt;code&gt;ViewControllerB&lt;/code&gt; 。 これにより、 &lt;code&gt;ViewControllerB&lt;/code&gt; はViewControllerAにメッセージを &lt;code&gt;ViewControllerA&lt;/code&gt; ことができ、データを送り返すことができます。</target>
        </trans-unit>
        <trans-unit id="3555496de4df0b39a8ca1903be2fae52ab2bbaf3" translate="yes" xml:space="preserve">
          <source>To help anyone else looking at this question, who wants a full answer, I'm going to attempt to provide it.</source>
          <target state="translated">この質問を見ている他の誰かを助けるために、完全な答えを求めている人のために、私はそれを提供しようとしています。</target>
        </trans-unit>
        <trans-unit id="86f2cf886389b424cfb810b4716cc6f04bb3d86b" translate="yes" xml:space="preserve">
          <source>To pass a &lt;code&gt;BOOL&lt;/code&gt; value from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; we would do the following.</source>
          <target state="translated">&lt;code&gt;BOOL&lt;/code&gt; 値を &lt;code&gt;ViewControllerA&lt;/code&gt; からViewControllerBに &lt;code&gt;ViewControllerB&lt;/code&gt; には、次のようにします。</target>
        </trans-unit>
        <trans-unit id="76a9d2c2e66054b80996174e8affc8b1fb823ba9" translate="yes" xml:space="preserve">
          <source>To pass data back from &lt;code&gt;ViewControllerB&lt;/code&gt; to &lt;code&gt;ViewControllerA&lt;/code&gt; you need to use &lt;em&gt;Protocols and Delegates&lt;/em&gt; or &lt;em&gt;Blocks&lt;/em&gt;, the latter can be used as a loosely coupled mechanism for callbacks.</source>
          <target state="translated">&lt;code&gt;ViewControllerB&lt;/code&gt; からViewControllerAにデータを返すには、 &lt;em&gt;プロトコルとデリゲート&lt;/em&gt;または&lt;em&gt;ブロック&lt;/em&gt;を使用する必要があります。後者は、コールバックの疎結合メカニズムとして使用できます。</target>
        </trans-unit>
        <trans-unit id="e3d70b08f9dc80f74d10c82b4cd60670d8719e71" translate="yes" xml:space="preserve">
          <source>To pass data back from the second view controller to the first view controller, you use &lt;a href=&quot;https://stackoverflow.com/a/33549729/3681880&quot;&gt;a protocol and a delegate&lt;/a&gt;. This video is a very clear walk though of that process:</source>
          <target state="translated">2番目のView Controllerから最初のView Controllerにデータを戻すには&lt;a href=&quot;https://stackoverflow.com/a/33549729/3681880&quot;&gt;、プロトコルとデリゲート&lt;/a&gt;を使用します 。 このビデオはそのプロセスの非常に明確なウォークです：</target>
        </trans-unit>
        <trans-unit id="af916557c74c3f51d623fa988c413ad3e34f0d4f" translate="yes" xml:space="preserve">
          <source>To pass data backwards</source>
          <target state="translated">データを後方に渡すには</target>
        </trans-unit>
        <trans-unit id="4441e2165a2cbe180a97d71650d577cbf837d6f0" translate="yes" xml:space="preserve">
          <source>To pass data forward:</source>
          <target state="translated">データを転送すること。</target>
        </trans-unit>
        <trans-unit id="7c739773a6d176365e02604ef2ba8b5fd773295f" translate="yes" xml:space="preserve">
          <source>To pass multiple values you can use the multiple parameters like :-</source>
          <target state="translated">複数の値を渡すには :-のように複数のパラメータを使用することができます。</target>
        </trans-unit>
        <trans-unit id="6f53c9cc79789d2d8364b25f78aa09dd33f52a64" translate="yes" xml:space="preserve">
          <source>Understanding the Core Architectural Principles of iOS Development with a Practical Example</source>
          <target state="translated">iOS開発のコアとなるアーキテクチャ原則を実例で理解する</target>
        </trans-unit>
        <trans-unit id="df0a8289feb92488ac5fae24f2db741969a2acff" translate="yes" xml:space="preserve">
          <source>User defaults</source>
          <target state="translated">ユーザーデフォルト</target>
        </trans-unit>
        <trans-unit id="c2f8f14f958b77389a48a3fc1d929fbaf7455857" translate="yes" xml:space="preserve">
          <source>Using Block</source>
          <target state="translated">ブロックの使用</target>
        </trans-unit>
        <trans-unit id="35e87779d93205c9cdc86bc39ef7d0b7dce13230" translate="yes" xml:space="preserve">
          <source>Using Delegate</source>
          <target state="translated">代議員の使用</target>
        </trans-unit>
        <trans-unit id="73cc3f60dc8287f62aa63d4644544e391cbe3bb3" translate="yes" xml:space="preserve">
          <source>Using Navigation Controller Push</source>
          <target state="translated">ナビゲーションコントローラを使用したプッシュ</target>
        </trans-unit>
        <trans-unit id="52e7b3127ded3378ce3725c8ccc384212ac615ad" translate="yes" xml:space="preserve">
          <source>Using Notification Observer</source>
          <target state="translated">通知オブザーバの利用</target>
        </trans-unit>
        <trans-unit id="02bbe182682f0bbed6aeec5deb6f00b94667bbc3" translate="yes" xml:space="preserve">
          <source>Using Segue</source>
          <target state="translated">セグを使う</target>
        </trans-unit>
        <trans-unit id="0d6f7bc3f49a828edf12dd0581aaa92e4ef44e6e" translate="yes" xml:space="preserve">
          <source>ViewControllerA - Luxury Items</source>
          <target state="translated">ViewControllerA-ラグジュアリーアイテム</target>
        </trans-unit>
        <trans-unit id="e5ffea5e8eb8d723ab0498aa5a4d88e881a60886" translate="yes" xml:space="preserve">
          <source>ViewControllerB - Non-insured Items</source>
          <target state="translated">ViewControllerB-保険外項目</target>
        </trans-unit>
        <trans-unit id="e7a39785336a96e44901846cba211ded9e0abc2e" translate="yes" xml:space="preserve">
          <source>ViewControllerC - Entire Home Inventory</source>
          <target state="translated">ViewControllerC-家全体のインベントリ</target>
        </trans-unit>
        <trans-unit id="135d305cf4a08db515d94b35f7f6f4250be7f807" translate="yes" xml:space="preserve">
          <source>ViewControllerD - Add New Item Form</source>
          <target state="translated">ViewControllerD-新しいアイテムフォームを追加する</target>
        </trans-unit>
        <trans-unit id="81942d9a4347a174680fafdd5ec8b8b344284237" translate="yes" xml:space="preserve">
          <source>We are keeping this simple so no buttons, not actions, we are simply moving data from the sender to the receiver when the application loads and then outputting the transmitted value to the console.</source>
          <target state="translated">ボタンやアクションではなく、アプリケーションがロードされたときに送信者から受信者にデータを移動させ、送信された値をコンソールに出力するというシンプルなものです。</target>
        </trans-unit>
        <trans-unit id="ff03a716d90bbf29f516cac4b83abbaba194bc8c" translate="yes" xml:space="preserve">
          <source>We can understand it using two controllers - &lt;strong&gt;Controller1 and Controller2&lt;/strong&gt;</source>
          <target state="translated">2つのコントローラー（ &lt;strong&gt;Controller1とController2）&lt;/strong&gt;を使用してそれを理解でき&lt;strong&gt;ます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f75d1fd3c3fa39412cf75f97e5bcfb258a2d5a9" translate="yes" xml:space="preserve">
          <source>Well &lt;a href=&quot;https://stackoverflow.com/a/9736559/1371853&quot;&gt;Matt Price's Answer&lt;/a&gt; is perfectly fine for passing data but I
  am going to rewrite it, in Latest Swift version because I believe new
  programmers find it quit challenging due to new Syntax and
  methods/frameworks, as original post is in Objective-C.</source>
          <target state="translated">まあ&lt;a href=&quot;https://stackoverflow.com/a/9736559/1371853&quot;&gt;マットプライスの回答&lt;/a&gt;はデータを渡すのに最適ですが、最新のSwiftバージョンでは、元の投稿がObjective-Cにあるため、新しい構文とメソッド/フレームワークが原因で新しいプログラマーが難しいと思うので、書き直します。</target>
        </trans-unit>
        <trans-unit id="95ed8045cbbb7af3a960ea88cfa49e1488ceac17" translate="yes" xml:space="preserve">
          <source>What would be the correct way of performing this and how would I go about it?</source>
          <target state="translated">これを行うには、どのような方法が正しいのか、また、どのような方法で行えばよいのか。</target>
        </trans-unit>
        <trans-unit id="8a4e940579167cf02a3ba46b206936601e18844d" translate="yes" xml:space="preserve">
          <source>When the collection of home inventory items changes, the view controllers need to be made aware of this change. The class definition above does not make it obvious how this will happen. We need to follow the observer pattern. The view controllers must formally observe the sharedManager. There are two ways to observe another object:</source>
          <target state="translated">ホームインベントリのアイテムのコレクションが変更されたとき、ビューコントローラはこの変更を認識させる必要があります。上記のクラス定義では、これがどのようにして起こるのかは明らかではありません。オブザーバパターンに従う必要があります。ビューコントローラは正式にsharedManagerを観察しなければなりません。別のオブジェクトを観察するには、2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="d89b94ecc160001694e602dfbde749a28101857f" translate="yes" xml:space="preserve">
          <source>With UINavigators and segues, there are easy ways of passing information to the subservient controller and getting the information back.  ARC makes passing pointers to things derived from NSObjects simple so if you want the subservient controller to add/change/modify some data for you, pass it a pointer to a mutable instance.  Blocks make passing actions easy so if you want the subservient controller to invoke an action on your higher level controller, pass it a block.  You define the block to accept any number of arguments that makes sense to you.  You can also design the API to use multiple blocks if that suits things better.</source>
          <target state="translated">UINavigators とセグエでは、従属コントローラに情報を渡して情報を取得する簡単な方法があります。ARC を使用すると、NSObject から派生したものへのポインタを簡単に渡すことができるので、従属コントローラにいくつかのデータを追加したり、変更したりさせたい場合は、ミュー タブルインスタンスへのポインタを渡します。ブロックを使用すると、アクションを簡単に渡すことができるので、下位コントローラに上位コントローラ上でアクションを起動させたい場合は、ブロックを渡します。ブロックを定義して、納得のいく数の引数を受け付けるようにします。より適切であれば、複数のブロックを使用するように API を設計することもできます。</target>
        </trans-unit>
        <trans-unit id="eb4193cf6b58cbdb5fa018799e8c3e460fd383dc" translate="yes" xml:space="preserve">
          <source>Worked fine and allowed me to pass a string and an array forward and back between my views.</source>
          <target state="translated">正常に動作し、文字列と配列をビュー間で前後に渡すことができました。</target>
        </trans-unit>
        <trans-unit id="27deb3303dc171f62381c3af6e857bbf1acf83bb" translate="yes" xml:space="preserve">
          <source>You can also create custom delegates for this.</source>
          <target state="translated">そのためのカスタムデリゲートを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="1a3ff3057c97981bf35a32f3b4007efceb28f6a3" translate="yes" xml:space="preserve">
          <source>You can also directly set the properties of the Controller2 class in the similar way as this:</source>
          <target state="translated">このようにController2クラスのプロパティを直接設定することもできます。</target>
        </trans-unit>
        <trans-unit id="e9e418ef389cb9594cfd0c613d54195e941dba88" translate="yes" xml:space="preserve">
          <source>You can always share data using &lt;code&gt;NSUserDefaults&lt;/code&gt;. Set the value you want to share with respect to a key of your choice and get the value from &lt;code&gt;NSUserDefault&lt;/code&gt; associated to that key in the next view controller.</source>
          <target state="translated">&lt;code&gt;NSUserDefaults&lt;/code&gt; を使用すると、いつでもデータを共有できます 。 選択したキーに関して共有する値を設定し、次のビューコントローラでそのキーに関連付けられている &lt;code&gt;NSUserDefault&lt;/code&gt; から値を取得します。</target>
        </trans-unit>
        <trans-unit id="a7d7d2e500cdd3b21928259a0c992d9c6ea65145" translate="yes" xml:space="preserve">
          <source>You can just create a property in &lt;code&gt;viewcontrollerA&lt;/code&gt;. Create an object of &lt;code&gt;viewcontrollerA&lt;/code&gt; in &lt;code&gt;viewcontrollerB&lt;/code&gt; and assign the desired value to that property.</source>
          <target state="translated">&lt;code&gt;viewcontrollerA&lt;/code&gt; でプロパティを作成するだけです 。 &lt;code&gt;viewcontrollerA&lt;/code&gt; に &lt;code&gt;viewcontrollerB&lt;/code&gt; オブジェクトを作成し、目的の値をそのプロパティに割り当てます。</target>
        </trans-unit>
        <trans-unit id="abfb49ee8dd0bcc5f71fa827feb6ceb49bd14bd1" translate="yes" xml:space="preserve">
          <source>You can save data in App delegate to access it across view controllers in your application. All you have to do is create a shared instance of app delegate</source>
          <target state="translated">App delegateにデータを保存して、アプリケーション内のビューコントローラにまたがってアクセスすることができます。の共有インスタンスを作成するだけです。</target>
        </trans-unit>
        <trans-unit id="576941d1618435efb4e91b03c919b15afddc8a68" translate="yes" xml:space="preserve">
          <source>You setup all your views in .XIB files and register them in the app delegate, while initializing the factory.</source>
          <target state="translated">ファクトリーを初期化しながら、すべてのビューを.XIBファイルに設定し、アプリデリゲートに登録します。</target>
        </trans-unit>
        <trans-unit id="1e2fbc115bc2af08bed183bab4b31314c65a2dc1" translate="yes" xml:space="preserve">
          <source>YouTube tutorial: &lt;a href=&quot;https://www.youtube.com/watch?v=9LHDsSWc680&quot;&gt;iOS Swift Basics Tutorial: Protocols and Delegates&lt;/a&gt; But also read &lt;a href=&quot;http://krakendev.io/blog/weak-and-unowned-references-in-swift&quot;&gt;this post&lt;/a&gt; to make sure you don't get into a strong reference cycle.</source>
          <target state="translated">YouTubeチュートリアル： &lt;a href=&quot;https://www.youtube.com/watch?v=9LHDsSWc680&quot;&gt;iOS Swift Basics Tutorial：Protocols and Delegates&lt;/a&gt;また、 &lt;a href=&quot;http://krakendev.io/blog/weak-and-unowned-references-in-swift&quot;&gt;この投稿&lt;/a&gt;を読んで、強い参照サイクルに陥らないようにしてください。</target>
        </trans-unit>
        <trans-unit id="72d5f33455747500ff0e39389f26e2a366965ae1" translate="yes" xml:space="preserve">
          <source>YouTube tutorial: &lt;a href=&quot;https://www.youtube.com/watch?v=Kpwrc1PRDsg&quot;&gt;How to send data through segue (swift)&lt;/a&gt;</source>
          <target state="translated">YouTubeチュートリアル： &lt;a href=&quot;https://www.youtube.com/watch?v=Kpwrc1PRDsg&quot;&gt;セグエを介してデータを送信する方法（Swift）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd92b6a59301aaf7df021b06434d7fd97281c993" translate="yes" xml:space="preserve">
          <source>and &quot;B&quot; view controller should declare callback property, BViewController.h:</source>
          <target state="translated">ビューコントローラはBViewController.hというコールバックプロパティを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="d22cdc632e153fe14ede39b227947423e9ef48b1" translate="yes" xml:space="preserve">
          <source>and in FirstViewController.h :</source>
          <target state="translated">と、FirstViewController.h の中にあります。</target>
        </trans-unit>
        <trans-unit id="1303845f47ba68fca8499482aa29a0b1ca63c1c8" translate="yes" xml:space="preserve">
          <source>click on the button and drag over to the Second View Controller.</source>
          <target state="translated">ボタンをクリックして、セカンドビューコントローラにドラッグします。</target>
        </trans-unit>
        <trans-unit id="edb401d8d776a314f5a6c4744d5c898beb932df9" translate="yes" xml:space="preserve">
          <source>delegates</source>
          <target state="translated">delegates</target>
        </trans-unit>
        <trans-unit id="071cd75033ae8e8688a44265cb1850670988a924" translate="yes" xml:space="preserve">
          <source>do these in ViewControlerOne.h</source>
          <target state="translated">ViewControlerOne.h でこれらを実行します。</target>
        </trans-unit>
        <trans-unit id="d2c16f26c821a75d79d3c762d88ff8151b2cef90" translate="yes" xml:space="preserve">
          <source>do these in ViewControlerOne.m</source>
          <target state="translated">ViewControlerOne.mでこれらを実行します。</target>
        </trans-unit>
        <trans-unit id="4ab7cc959e41e827a458876138723cac6658ff71" translate="yes" xml:space="preserve">
          <source>do these in ViewControllerTwo.h</source>
          <target state="translated">ViewControllerTwo.h でこれらを実行します。</target>
        </trans-unit>
        <trans-unit id="537d8d6119fe77d8b87bdfec992c7335ce2c30a3" translate="yes" xml:space="preserve">
          <source>do these in ViewControllerTwo.m</source>
          <target state="translated">ViewControllerTwo.mでこれらを実行します。</target>
        </trans-unit>
        <trans-unit id="78f6225c0a29d685123f4713fb8d64650c5d455a" translate="yes" xml:space="preserve">
          <source>drag from the button to the Second View Controller. Set the segue identifier to &lt;code&gt;showSecondViewController&lt;/code&gt;. Also, don't forget to hook up the outlets and actions using the names in the following code.</source>
          <target state="translated">ボタンからセカンドビューコントローラーにドラッグします。 セグエ識別子を &lt;code&gt;showSecondViewController&lt;/code&gt; に設定します 。 また、次のコードの名前を使用して、アウトレットとアクションを接続することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="e89c71751ece180f696d67c4cc55aff1a2e78a1b" translate="yes" xml:space="preserve">
          <source>expecting that your &lt;code&gt;CustomObject&lt;/code&gt; must have a setter function with it.</source>
          <target state="translated">&lt;code&gt;CustomObject&lt;/code&gt; には、setter関数が必要であると想定しています。</target>
        </trans-unit>
        <trans-unit id="9a601619d63281ffad7a5e7742ff3e95493c069d" translate="yes" xml:space="preserve">
          <source>if you declare a &lt;code&gt;NSArray object *arrayXYZ&lt;/code&gt; then you can access it in any view controller by &lt;code&gt;appDelegate.arrayXYZ&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NSArray object *arrayXYZ&lt;/code&gt; を宣言すると、 appDelegate.arrayXYZを使用して任意のビューコントローラーでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="782fff5ac840ff68307a9fc122193c5707e4c512" translate="yes" xml:space="preserve">
          <source>if you wants to pass data from ViewControlerOne to ViewControllerTwo try these..</source>
          <target state="translated">ViewControlerOne から ViewControllerTwo にデータを渡したい場合は、以下を試してみてください。</target>
        </trans-unit>
        <trans-unit id="be71d332d065bfca5adcf4764b2e5dcf0067a681" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;ViewControllerA&lt;/code&gt; you need to tell it about &lt;code&gt;ViewControllerB&lt;/code&gt; so use an</source>
          <target state="translated">&lt;code&gt;ViewControllerA&lt;/code&gt; では、 &lt;code&gt;ViewControllerB&lt;/code&gt; についてそれを伝える必要があるので、</target>
        </trans-unit>
        <trans-unit id="65b58b2b8602f0dcd3e15e13e48c2cf1071404f5" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;ViewControllerB.h&lt;/code&gt; create a property for the &lt;code&gt;BOOL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ViewControllerB.h&lt;/code&gt; で &lt;code&gt;BOOL&lt;/code&gt; のプロパティを作成します</target>
        </trans-unit>
        <trans-unit id="99069faddac71d51fb4234f0748c9713172c03f9" translate="yes" xml:space="preserve">
          <source>in ViewController.h</source>
          <target state="translated">ViewController.hで</target>
        </trans-unit>
        <trans-unit id="131175d1468a88ef378a2491456c5cb0422143b7" translate="yes" xml:space="preserve">
          <source>in ViewController.m</source>
          <target state="translated">ViewController.mで</target>
        </trans-unit>
        <trans-unit id="be71d06d1de5c0a0fdb2be6af089b062df524e57" translate="yes" xml:space="preserve">
          <source>in implementation file you can implement the function</source>
          <target state="translated">関数を実装することができます。</target>
        </trans-unit>
        <trans-unit id="a4325deae2d4ec787216962c095e8ecd5c3486e6" translate="yes" xml:space="preserve">
          <source>next still in the &lt;code&gt;ViewControllerB.h&lt;/code&gt; you need to setup a &lt;code&gt;delegate&lt;/code&gt; property and synthesize in &lt;code&gt;ViewControllerB.m&lt;/code&gt;</source>
          <target state="translated">次に、まだ &lt;code&gt;ViewControllerB.h&lt;/code&gt; で 、 &lt;code&gt;delegate&lt;/code&gt; プロパティを設定し、 ViewControllerB.mで合成する必要があります。</target>
        </trans-unit>
        <trans-unit id="386cbb45fb634a4cc7cc5f0d2dd999b1d4e98035" translate="yes" xml:space="preserve">
          <source>now your basic work is done. go to the place where you want to push the &lt;code&gt;SecondViewController&lt;/code&gt; and do the following stuff</source>
          <target state="translated">これで基本的な作業は完了です。 &lt;code&gt;SecondViewController&lt;/code&gt; をプッシュする場所に移動し、次のことを行います</target>
        </trans-unit>
        <trans-unit id="37f0c63aa5984813b557482775d277cd538c0cde" translate="yes" xml:space="preserve">
          <source>on the buttons click event do this..</source>
          <target state="translated">ボタンをクリックすると、このようなイベントが発生します。</target>
        </trans-unit>
        <trans-unit id="46a5e3a49371630a136eb9da775d08eb729e16f4" translate="yes" xml:space="preserve">
          <source>override the &lt;code&gt;prepare(for:sender:)&lt;/code&gt; method of &lt;code&gt;UIViewController&lt;/code&gt; when using a storyboard and segues</source>
          <target state="translated">ストーリーボードと &lt;code&gt;UIViewController&lt;/code&gt; を使用する場合、 UIViewControllerの &lt;code&gt;prepare(for:sender:)&lt;/code&gt; メソッドをオーバーライドします</target>
        </trans-unit>
        <trans-unit id="4d25f70727ad257203a7cb4eb327698d18e7aa99" translate="yes" xml:space="preserve">
          <source>pass data through an initializer or through properties when performing view controller transitions thtough code</source>
          <target state="translated">ビューコントローラの遷移を実行する際に、イニシャライザやプロパティを介してデータをコードに渡す。</target>
        </trans-unit>
        <trans-unit id="7311cc1f0f20c0620db17343ab40307e824143ea" translate="yes" xml:space="preserve">
          <source>segues</source>
          <target state="translated">segues</target>
        </trans-unit>
        <trans-unit id="7f2d647110dc98a6cf4ef95feec7e141e6b5b5d7" translate="yes" xml:space="preserve">
          <source>setting properties on view controllers directly</source>
          <target state="translated">ビューコントローラに直接プロパティを設定する</target>
        </trans-unit>
        <trans-unit id="9e37ace74b364d63001657a8ab63e157a0a748b9" translate="yes" xml:space="preserve">
          <source>so we can pass this value in second class using below step</source>
          <target state="translated">この値は、以下のステップを使って2番目のクラスに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="1b1760ac8cee45ff111cddcf3355ccffae7b6192" translate="yes" xml:space="preserve">
          <source>then change its definition to</source>
          <target state="translated">のように定義を変更します。</target>
        </trans-unit>
        <trans-unit id="e61eda4f8db1e4d3af098df52ca88723ae4b33e4" translate="yes" xml:space="preserve">
          <source>update the app shared state (which you can pass forward between view controllers with either one of the methods above)</source>
          <target state="translated">アプリの共有状態を更新します(上記のいずれかのメソッドを使ってビューコントローラ間で転送することができます)。</target>
        </trans-unit>
        <trans-unit id="5edd9def88440cf132c20a45c93726634b543a58" translate="yes" xml:space="preserve">
          <source>use an unwind segue</source>
          <target state="translated">巻き戻す</target>
        </trans-unit>
        <trans-unit id="1089f6b4bab9307f50a4d74cae6292d00032982e" translate="yes" xml:space="preserve">
          <source>use delegation</source>
          <target state="translated">使う</target>
        </trans-unit>
        <trans-unit id="4f77b4fd6e2ebd82da33ee94540fe10ea274781f" translate="yes" xml:space="preserve">
          <source>use it in the &lt;code&gt;prepareForSegue&lt;/code&gt; method in the VC1</source>
          <target state="translated">VC1の &lt;code&gt;prepareForSegue&lt;/code&gt; メソッドで使用します。</target>
        </trans-unit>
        <trans-unit id="3397791b6f7f7ea840ba49d831f7e5f45f3ad769" translate="yes" xml:space="preserve">
          <source>var authorizationCompletionBlock:((Bool)-&amp;gt;())? = {_ in}</source>
          <target state="translated">var authorizationCompletionBlock：（（Bool）-&amp;gt;（））？ = {_ in}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
