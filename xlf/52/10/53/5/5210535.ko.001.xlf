<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/5210535">
    <body>
      <group id="5210535">
        <trans-unit id="5128e9d8380cba42898da6b0b4c094f182f31368" translate="yes" xml:space="preserve">
          <source>1&amp;gt;We need to crate string object in SecondViewController.h file</source>
          <target state="translated">1&amp;gt; 우리는 SecondViewController.h 파일에서 문자열 객체를 크레이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="382568f3d5638e45d07eaa2ba4e79626c6e35495" translate="yes" xml:space="preserve">
          <source>2&amp;gt;Need to declare property as below below declaration in .h file</source>
          <target state="translated">2&amp;gt; .h 파일에서 아래 선언과 같이 속성을 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca8fae13e1609c64d729ca50adc43575fd915a5d" translate="yes" xml:space="preserve">
          <source>3&amp;gt;Need synthesize that value in FirstViewController.m file below header declaration</source>
          <target state="translated">3&amp;gt; 헤더 선언 아래의 FirstViewController.m 파일에서 해당 값을 합성해야 함</target>
        </trans-unit>
        <trans-unit id="7e6c2732929d97145ee56f3dbef06b5bd1d4b710" translate="yes" xml:space="preserve">
          <source>4 lines of code inside the method and you are done.</source>
          <target state="translated">메소드 내부에 4 줄의 코드가 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="12af7e16d59d006e71a07aade88fd2f960f7d040" translate="yes" xml:space="preserve">
          <source>4&amp;gt;In FirstViewController,From which method we navigate to second view please write below code in that method.</source>
          <target state="translated">4&amp;gt; FirstViewController에서 어떤 메소드에서 두 번째보기로 이동하면 해당 메소드에 아래 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8e9441a605f9f93f88f097003026bbcbdb4e55b8" translate="yes" xml:space="preserve">
          <source>:) Cheers.</source>
          <target state="translated">:) 건배.</target>
        </trans-unit>
        <trans-unit id="c7e0fd5894134e3a798732701f0ee5582c0e8363" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ManagingDataFlowBetweenViewControllers/ManagingDataFlowBetweenViewControllers.html#//apple_ref/doc/uid/TP40007457-CH8-SW9&quot;&gt;Using Delegation to Communicate With Other View Controllers&lt;/a&gt; in the &lt;em&gt;View Controller Programming Guide&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;View Controller 프로그래밍 가이드&lt;/em&gt; 에서 &lt;a href=&quot;http://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ManagingDataFlowBetweenViewControllers/ManagingDataFlowBetweenViewControllers.html#//apple_ref/doc/uid/TP40007457-CH8-SW9&quot;&gt;위임을 사용하여 다른 View Controller와 통신&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9cddb9f240b7be5a6c0e6206779adba0c54ad320" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.iphonedevsdk.com/forum/iphone-sdk-development/54859-sharing-data-between-view-controllers-other-objects.html&quot;&gt;Sharing data between view controllers and other objects&lt;/a&gt; @ iPhone Dev SDK</source>
          <target state="translated">iPhone Dev SDK &lt;a href=&quot;http://www.iphonedevsdk.com/forum/iphone-sdk-development/54859-sharing-data-between-view-controllers-other-objects.html&quot;&gt;에서 뷰 컨트롤러와 다른 객체간에 데이터 공유&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a561b48e56f3bead23ac829c64c64003e3095e17" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/RamdhanChoudhary/A-Simple-iOS-App-for-Passing-Data-Between-Controllers-in-Swift&quot;&gt;You can find complete sample Application at my GitHub&lt;/a&gt; Please let me know if you have any question(s) on this.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/RamdhanChoudhary/A-Simple-iOS-App-for-Passing-Data-Between-Controllers-in-Swift&quot;&gt;내 GitHub에서 완전한 샘플 응용 프로그램을 찾을 수 있습니다&lt;/a&gt; . 이것에 대한 질문이 있으면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="4a01486c528ad5e980ae4089d498cd8c88f97fa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@synthesize  indexNumber;&lt;/code&gt;           in NextVC.m</source>
          <target state="translated">&lt;code&gt;@synthesize indexNumber;&lt;/code&gt; NextVC.m에서</target>
        </trans-unit>
        <trans-unit id="b78c51f4a043a824f5e08ef6eaf7ecfb3f33270d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Blocks are anonymous functions.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;블록은 익명 함수입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1021f754895d902d9dddaf8f14272d74668e6de6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Using Block callbacks:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;-콜백 차단 사용 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c37f6c389f441f0686ad2157cb488b1e89332e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Using storyboards Unwind (Exit)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스토리 보드 사용 해제 (종료)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f6e3b19fd1dae9c65f2307816e0fe1c6c694e84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt; Create the instance of first View Controller in the second View Controller and make its property &lt;code&gt;@property (nonatomic,assign)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt; 두 번째 View Controller에서 첫 번째 View Controller 인스턴스를 생성하고 속성을 &lt;code&gt;@property (nonatomic,assign)&lt;/code&gt; 로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="caa8b857bce2edcc30a0b3967af6102ff7c4e3cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt; Assign the &lt;code&gt;SecondviewController&lt;/code&gt; instance of this view controller.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt; 이 뷰 컨트롤러의 &lt;code&gt;SecondviewController&lt;/code&gt; 인스턴스를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="c1ab9d883587e24a8d31adae458d2e6b60264d54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt; When you finish the selection operation copy the array to first View Controller,When u unload the SecondView ,FirstView will hold the Array Data.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt; 선택 작업을 마치면 배열을 첫 번째 View Controller에 복사합니다. u SecondView를 언로드하면 FirstView가 배열 데이터를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="69324ef579d371a172a46ed3433537adafdd0323" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Application Scenarios&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;응용 프로그램 시나리오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19d3c711e8278b4bcb9dc5b3925628e10a4961cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't forget&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;잊지 마세요&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55779cd52cf0b0e46e2fe75e0ae7c25906301bd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First View Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;퍼스트 뷰 컨트롤러&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c0c0b273313e9e6e2211fefaab5837fd17c6153" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예를 들어&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c300eb69852a39b53d39a423e83febc84bb7ecf5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Go to Controller B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컨트롤러 B로 이동&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd3b42b839c0fa27211813e4f7a2b41b323efb59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NSNotification center&lt;/strong&gt;
It's another way to pass data.</source>
          <target state="translated">&lt;strong&gt;NSNotification center&lt;/strong&gt; 데이터를 전달하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f83086999fd5c7eccf89cda212980e525c8ee244" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsDetailViewController.h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsDetailViewController.h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2e498d6299003ee4bb995fd064cfff0f5031dd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsDetailViewController.m&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsDetailViewController.m&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="170aa6c3a45436cad64cb27754574f9f66c7007d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsViewController&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsViewController&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fcf13efd0f4fde8b8e30afec77961f30fe04bf16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Back&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;데이터 전달&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4056ba2648992080e38f34e858850a2675ff28c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Forward using Segues&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Segues를 사용하여 데이터 전달&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="806df0e91c6a17443dc044857cd2e12e700908c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Forward&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;데이터 전달&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a823b2509776072df9c2f284478ab9d56976c87d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data back from one class to another&lt;/strong&gt; (A class can be any controller, Network/session manager, UIView subclass or any other class)</source>
          <target state="translated">&lt;strong&gt;한 클래스에서 다른 클래스로 데이터 전달&lt;/strong&gt; (클래스는 컨트롤러, 네트워크 / 세션 관리자, UIView 서브 클래스 또는 다른 클래스 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="3a2d4f96ca3cdcbd2c5729cfeeddcfe8a83ef0da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data between FirstViewController to SecondViewController as below&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;아래와 같이 FirstViewController에서 SecondViewController로 데이터 전달&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1633208f374584ce5b10f1cf78b22a2eeba7eee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Block&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;블록을 통한 데이터 전달&lt;/strong&gt; : &lt;em&gt;ViewControllerB에서 ViewControllerA로&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="024c5395573bc2998ff2187cbf90e249d2fd7f30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Delegate&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;델리게이트를 통한 데이터 전달&lt;/strong&gt; : &lt;em&gt;ViewControllerB에서 ViewControllerA로&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c82eb764b54c062d5349bd59c7a3fb7fcbc641b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Navigation Controller Push&lt;/strong&gt; : &lt;em&gt;From ViewControllerA to ViewControllerB&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;네비게이션 컨트롤러 푸시를 통한 데이터 전달&lt;/strong&gt; : &lt;em&gt;ViewControllerA에서 ViewControllerB로&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55db90aacfef6b7797ad7a5da078395659732e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Notification Observer&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;알림 관찰자를 통한 데이터 전달&lt;/strong&gt; : &lt;em&gt;ViewControllerB에서 ViewControllerA로&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0561e6d1d3b1f23d57d8291ca2684d08bcde0b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Segue&lt;/strong&gt; : &lt;em&gt;From ViewControllerA to ViewControllerB&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Segue를 통한 데이터 전달&lt;/strong&gt; : &lt;em&gt;ViewControllerA에서 ViewControllerB로&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf80e7bc29bfca96a73722d3c8c419ee4f8a9df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scenario one:&lt;/strong&gt; maximum two view controllers ever need to share information.
See diagram one.</source>
          <target state="translated">&lt;strong&gt;시나리오 1 :&lt;/strong&gt; 최대 두 개의 뷰 컨트롤러가 정보를 공유해야합니다. 다이어그램 1을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5cb92a49a24b197803d86b1055b30b5711cba2a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scenario two&lt;/strong&gt;: more than two view controllers need to share the same information.
See diagram two.</source>
          <target state="translated">&lt;strong&gt;시나리오 2&lt;/strong&gt; : &lt;strong&gt;두&lt;/strong&gt; 개 이상의 뷰 컨트롤러가 동일한 정보를 공유해야합니다. 다이어그램 2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f945b9a41062fc17eb825c26426f171f0d86ed91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second View Controller and Protocol&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;두 번째 뷰 컨트롤러 및 프로토콜&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ce77aea00bcbf439da1f87290ce172463ea140c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second View Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;두 번째 뷰 컨트롤러&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bd48716ff2de9235461890349819ae353247ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setup The Storyboard&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스토리 보드 설정&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="089fc6cd09fa49635621f8cfa746223ca053b190" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Create Segue from ViewControllerA to ViewControllerB and give Identifier = showDetailSegue in Storyboard as shown below</source>
          <target state="translated">&lt;strong&gt;1 단계.&lt;/strong&gt; ViewControllerA에서 ViewControllerB로 Segue를 생성하고 아래와 같이 스토리 보드에서 Identifier = showDetailSegue를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="02d6487d795d944e58f58e4366b35bc8d1b32dc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Declare Protocol &lt;strong&gt;&lt;em&gt;ViewControllerBDelegate&lt;/em&gt;&lt;/strong&gt; in ViewControllerB file but outside the class</source>
          <target state="translated">&lt;strong&gt;1 단계.&lt;/strong&gt; ViewControllerB 파일에서 클래스 외부의 프로토콜 &lt;strong&gt;&lt;em&gt;ViewControllerBDelegate&lt;/em&gt;&lt;/strong&gt; 선언</target>
        </trans-unit>
        <trans-unit id="0cfd0efef879069214eec7da3b7a25e5918e36d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Declare variable in ViewControllerB</source>
          <target state="translated">&lt;strong&gt;1 단계.&lt;/strong&gt; ViewControllerB에서 변수 선언</target>
        </trans-unit>
        <trans-unit id="63f0b24521041c6431c75964ba6cefcaea19944c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; Declare Delegate variable instance in ViewControllerB</source>
          <target state="translated">&lt;strong&gt;2 단계.&lt;/strong&gt; ViewControllerB에서 델리게이트 변수 인스턴스 선언</target>
        </trans-unit>
        <trans-unit id="cf2aa8929fa2c0c9c4a6b1ac4ca41b9ce1e5280a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; In ViewControllerB Declare a viable named &lt;strong&gt;isSomethingEnabled&lt;/strong&gt; and print its value.</source>
          <target state="translated">&lt;strong&gt;2 단계.&lt;/strong&gt; ViewControllerB에서 &lt;strong&gt;isSomethingEnabled&lt;/strong&gt; 라는 실행 파일을 선언하고 해당 값을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="673106a11e8d268ad485367e76e5b7fe1a54be95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; Print Variable in ViewControllerB' ViewDidLoad method</source>
          <target state="translated">&lt;strong&gt;2 단계.&lt;/strong&gt; ViewControllerB의 ViewDidLoad 메소드에서 변수 인쇄</target>
        </trans-unit>
        <trans-unit id="c79ecb62ba912afd27284dd7da413af362a92fe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; In ViewControllerA Pass Data while pushing through Navigation Controller</source>
          <target state="translated">&lt;strong&gt;3 단계&lt;/strong&gt; . ViewController에서 탐색 컨트롤러를 통해 데이터를 전달</target>
        </trans-unit>
        <trans-unit id="4b0af6a719a13383d29f0e86f0830773e5362336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; In ViewControllerA pass isSomethingEnabled's value while passing Segue</source>
          <target state="translated">&lt;strong&gt;3 단계&lt;/strong&gt; . ViewController에서 Segue를 전달하는 동안 isSomethingEnabled의 값을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="e879cf49b95c873ff028951588aa65e4dc76e026" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; Send data for delegate inside viewDidLoad method of ViewControllerB</source>
          <target state="translated">&lt;strong&gt;3 단계.&lt;/strong&gt; ViewControllerB의 viewDidLoad 메서드 내에서 델리게이트에 대한 데이터 보내기</target>
        </trans-unit>
        <trans-unit id="c0971f452794a6e92bcbbc194c9499089ede4379" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 4.&lt;/strong&gt; Confirm ViewControllerBDelegate in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;4 단계.&lt;/strong&gt; ViewControllerA에서 ViewControllerBDelegate 확인</target>
        </trans-unit>
        <trans-unit id="400cecca8d5ee34aed2e79bed634a5f6417ad26a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 5.&lt;/strong&gt; Confirm that you will implement delegate in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;5 단계.&lt;/strong&gt; ViewControllerA에서 델리게이트를 구현할 것임을 확인</target>
        </trans-unit>
        <trans-unit id="a6946e7fb9eb003efc11719f3b07f5e5dd24240e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 6.&lt;/strong&gt; Implement delegate method for receiving data in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;6 단계.&lt;/strong&gt; ViewControllerA에서 데이터 수신을위한 델리게이트 메소드 구현</target>
        </trans-unit>
        <trans-unit id="dae0e54a74abfd074492d26eb16ee245aa1b2bad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Swift 5&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스위프트 5&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28379284774a4bc3f1d8c071ddb2db954d9799db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Solutions: Delegates and the Observer Pattern, and Singletons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;솔루션 : 대리인과 관찰자 패턴 및 싱글 톤&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67f11916500f3f87c23f865722bfb004fcf67670" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The View Controllers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;뷰 컨트롤러&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4223100f431b368002a27fc7e5a1b02d95268402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is a very old answer and this is anti pattern, please use delegates. Do not use this Approach !!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것은 매우 오래된 답변이며 안티 패턴입니다. 대리인을 사용하십시오.&lt;/strong&gt; &lt;strong&gt;이 접근법을 사용하지 마십시오!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f90d261e0a84b99ac74b5c70573c76458761db1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ViewControllerA&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ViewControllerA&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="48b18e371bee61f8b3cc40f6098e6c3da05ba232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ViewControllerB&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ViewControllerB&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7695880e46c35fa27304925b1429e1f63dcc24f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;add block handler (listener)&lt;/strong&gt;
where you need a value (for example you need your API response in ControllerA or you need ContorllerB data on A)</source>
          <target state="translated">값이 필요한 곳에 &lt;strong&gt;블록 핸들러 (리스너)를 추가하십시오&lt;/strong&gt; (예 : ControllerA에서 API 응답이 필요하거나 A에서 ContorllerB 데이터가 필요함)</target>
        </trans-unit>
        <trans-unit id="c5d2857c643c79b0380179ffbc7e423000f801e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;define a block&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;블록을 정의하다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93db5e336a184ed3fa5d32c57284bb8d6714d03a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fire block&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;화재 차단&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3915169e39c880b6db82aad68f146c88205b079" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;singleton&lt;/strong&gt; is an instance of a class, that instance being the only instance in existence during its lifetime. A singleton gets its name from the fact that it is the single instance. Normally developers who use singletons have special class methods for accessing them.</source>
          <target state="translated">&lt;strong&gt;싱글 톤&lt;/strong&gt; 은 클래스의 인스턴스이며, 해당 인스턴스는 수명 동안 존재하는 유일한 인스턴스입니다. 싱글 톤은 단일 인스턴스라는 사실에서 이름을 얻습니다. 일반적으로 싱글 톤을 사용하는 개발자는 액세스 할 수있는 특수 클래스 메소드를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="f28e068fdcf0539a305afd3501e8a77424964acf" translate="yes" xml:space="preserve">
          <source>Add a new file to your project (Objective-C Protocol) File -&amp;gt; New, now name it ViewController1Delegate or whatever you want and write these between the @interface and @end directives</source>
          <target state="translated">프로젝트에 새 파일을 추가하십시오 (Objective-C Protocol) File-&amp;gt; New, 이제 이름을 ViewController1Delegate 또는 원하는 이름으로 지정하고 @interface 및 @end 지시문 사이에 작성하십시오</target>
        </trans-unit>
        <trans-unit id="3f0eff45a4a19a3b442bc835b668a6a9ac78b01f" translate="yes" xml:space="preserve">
          <source>Add this &lt;code&gt;property&lt;/code&gt; in NextVC.h on nextVC</source>
          <target state="translated">nextVC의 NextVC.h에이 &lt;code&gt;property&lt;/code&gt; 을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="804108390422b4e4ce16d7dd070e8cd51d8926e4" translate="yes" xml:space="preserve">
          <source>After more research it seemed that Protocols and Delegates is the correct/Apple prefered way of doing this.</source>
          <target state="translated">더 많은 연구를 한 후에는 프로토콜과 대리인이 올바른 방법 / 애플이 선호하는 방법 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="a12d91c7bf75162aeefa8045f7e5bc4e2c65ef2b" translate="yes" xml:space="preserve">
          <source>All of your views that conform to this need to be subclasses of MCViewController, which allow you to override the new onResume: method, allowing you access to the data you've passed in.</source>
          <target state="translated">이를 준수하는 모든 뷰는 MCViewController의 서브 클래스 여야합니다.이를 통해 새로운 onResume : 메소드를 재정 의하여 전달한 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8ab1246f6106fb56d5a9574573a871cd55050d" translate="yes" xml:space="preserve">
          <source>And in the prepareForSegue of VC1 you can change any property you want to share.</source>
          <target state="translated">그리고 VC1의 PreparingForSegue에서 공유하려는 모든 속성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bccdba78cf0a1ca896692cedf94279f07a532726" translate="yes" xml:space="preserve">
          <source>And last</source>
          <target state="translated">그리고 마침내</target>
        </trans-unit>
        <trans-unit id="b969e3b40597dea269830b21f5cd87d1fbd3744f" translate="yes" xml:space="preserve">
          <source>And the code for the Second View Controller is</source>
          <target state="translated">그리고 두 번째 View Controller의 코드는</target>
        </trans-unit>
        <trans-unit id="18cc65ab16292fba4c64e85d6cc81210aac335ef" translate="yes" xml:space="preserve">
          <source>Another Working Example for Blocks</source>
          <target state="translated">블록의 또 다른 작업 예</target>
        </trans-unit>
        <trans-unit id="118227ed38ee9d82b2542b27e2ded76929153d04" translate="yes" xml:space="preserve">
          <source>Another approach is to handle a screen full of data at a time and instead of coupling the view controllers to each other couple each view controller to single data source that they can get to independently.</source>
          <target state="translated">또 다른 방법은 한 번에 데이터로 가득 찬 화면을 처리하고 뷰 컨트롤러를 서로 연결하는 대신 각 뷰 컨트롤러를 독립적으로 얻을 수있는 단일 데이터 소스에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="24aa503d35146161367e2853117eb922f7c7e249" translate="yes" xml:space="preserve">
          <source>Another option of using storyboards Undwind (Exit)  - you can
use the method you wrote in VC1</source>
          <target state="translated">스토리 보드 Undwind (Exit)를 사용하는 또 다른 옵션-VC1에서 작성한 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0b6c72a6ce36ed0135ebc104f4837a0d4628e2ba" translate="yes" xml:space="preserve">
          <source>Another solution is use singleton class pattern initialize it once and use it in your entire app.</source>
          <target state="translated">또 다른 해결책은 싱글 톤 클래스 패턴을 사용하여 한 번 초기화하고 전체 앱에서 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="485e9762fc4e98806a8bb291a5c98ca65cca0c5d" translate="yes" xml:space="preserve">
          <source>Any time an individual item is created or edited, it must also synchronize with the other view controllers. For example, if we add a boat in ViewControllerD, but it is not yet insured, then the boat must appear when the user goes to ViewControllerA (Luxury Items), and also ViewControllerC (Entire Home Inventory), but not when the user goes to ViewControllerB (Non-insured Items). We need be concerned with not only adding new items, but also deleting items (which may be allowed from any of the four view controllers), or editing existing items (which may be allowed from the &quot;Add New Item Form&quot;, repurposing the same for editing).</source>
          <target state="translated">개별 항목을 생성하거나 편집 할 때마다 다른 뷰 컨트롤러와도 동기화해야합니다. 예를 들어, ViewControllerD에 보트를 추가했지만 아직 보험에 가입되어 있지 않은 경우 사용자가 ViewControllerA (고급 품목)로 이동하면 ViewControllerC (전체 주택 재고)로 이동해야하지만 사용자는 ViewControllerB (비보험 품목). 새 항목 추가뿐만 아니라 항목 (4 개의보기 컨트롤러 중 하나에서 허용 될 수 있음)을 삭제하거나 기존 항목 ( &quot;새 항목 추가 양식&quot;에서 허용 될 수 있음)을 변경하여 동일한 용도로 변경해야합니다. 편집 용).</target>
        </trans-unit>
        <trans-unit id="64849ae90e58e40914c4de26bdae632804d0010e" translate="yes" xml:space="preserve">
          <source>Any time your Application Delegate starts to get bloated, start to remove functionality into singletons. For example, the Core Data Stack should not be left in the AppDelegate, but should instead be put in its own class, a coreDataManager class.</source>
          <target state="translated">Application Delegate가 부풀어 오르기 시작할 때마다 기능을 싱글 톤으로 제거하기 시작하십시오. 예를 들어, Core Data Stack은 AppDelegate에 그대로 두지 말고 대신 coreDataManager 클래스 자체 클래스에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f40fedcce16e602b145be79b8076ddf17738736" translate="yes" xml:space="preserve">
          <source>Assuming we use Storyboard, first controller sets callback block, for example during segue preparation:</source>
          <target state="translated">Storyboard를 사용한다고 가정하면 첫 번째 컨트롤러는 예를 들어 segue 준비 중에 콜백 블록을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="937c87dd061dc69a2f97f40ce08377952484a667" translate="yes" xml:space="preserve">
          <source>Asynchronous JSON Requests in Objective-C</source>
          <target state="translated">Objective-C의 비동기 JSON 요청</target>
        </trans-unit>
        <trans-unit id="7a23b7a9d6d6baa93168423a429c497e0668b171" translate="yes" xml:space="preserve">
          <source>Before pushing &lt;code&gt;viewControllerB&lt;/code&gt; to navigation stack we need to tell  &lt;code&gt;ViewControllerB&lt;/code&gt; that &lt;code&gt;ViewControllerA&lt;/code&gt; is its delegate, otherwise we will get an error.</source>
          <target state="translated">&lt;code&gt;viewControllerB&lt;/code&gt; 를 탐색 스택으로 푸시하기 전에 &lt;code&gt;ViewControllerB&lt;/code&gt; 에 &lt;code&gt;ViewControllerA&lt;/code&gt; 가 대리자임을 알려야 합니다 . 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8eac8dd9c4975fc8c45b35fda8f1d46a26aaa269" translate="yes" xml:space="preserve">
          <source>Brute force iteration on view controllers (in Navigation or Tab Bar Controller) to set the data</source>
          <target state="translated">데이터를 설정하기 위해 뷰 컨트롤러 (탐색 또는 탭 막대 컨트롤러)에서 무차별 강제 반복</target>
        </trans-unit>
        <trans-unit id="54b5e333081c3612757c1545a54070e785c64a95" translate="yes" xml:space="preserve">
          <source>But for the simple scenario of passing a value to a different class whose allocation is done in the current class, the most common and preferred method would be the direct setting of values after allocation. This is done as follows:-</source>
          <target state="translated">그러나 현재 클래스에서 할당이 수행되는 다른 클래스에 값을 전달하는 간단한 시나리오의 경우 가장 일반적이고 선호되는 방법은 할당 후 값을 직접 설정하는 것입니다. 이것은 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ea1d3df298ca84104dbf8b2f6f916c02f6f77c6e" translate="yes" xml:space="preserve">
          <source>Control</source>
          <target state="translated">Control</target>
        </trans-unit>
        <trans-unit id="959abf1f5e9c99d137dc34e9bffd461476893b28" translate="yes" xml:space="preserve">
          <source>Core Data</source>
          <target state="translated">핵심 데이터</target>
        </trans-unit>
        <trans-unit id="dec7ea0ef8ddc0be363fac5318ec6d035445e81a" translate="yes" xml:space="preserve">
          <source>Create a the segue from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; on the storyboard and give it an identifier, in this example we'll call it &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt;</source>
          <target state="translated">스토리 보드에서 &lt;code&gt;ViewControllerA&lt;/code&gt; 에서 ViewControllerB 로 segue를 생성하고 식별자를 제공합니다.이 예에서는 &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="7d6106a2b404bee4c3c16acfce805678171d2723" translate="yes" xml:space="preserve">
          <source>Create the property on next &lt;code&gt;view controller .h&lt;/code&gt; and define getter and setter.</source>
          <target state="translated">다음 &lt;code&gt;view controller .h&lt;/code&gt; 에서 특성을 작성하고 getter 및 setter를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="3dd4a61a93a6d9b50322d5da189d9a661c072e48" translate="yes" xml:space="preserve">
          <source>Create the storyboard layout in the Interface Builder. Again, to make the segue, you just</source>
          <target state="translated">인터페이스 빌더에서 스토리 보드 레이아웃을 작성하십시오. 다시, segue를 만들기 위해, 당신은 단지</target>
        </trans-unit>
        <trans-unit id="2851431431fb0af8a145e641673ca993d6a20f60" translate="yes" xml:space="preserve">
          <source>Create the storyboard layout in the Interface Builder. To make the segue, you just</source>
          <target state="translated">인터페이스 빌더에서 스토리 보드 레이아웃을 작성하십시오. segue를 만들기 위해, 당신은 단지</target>
        </trans-unit>
        <trans-unit id="863b2164a4f2bf227ea1d1aef73ad8543480c495" translate="yes" xml:space="preserve">
          <source>Data Source</source>
          <target state="translated">데이터 소스</target>
        </trans-unit>
        <trans-unit id="2aac74bd52b9c492652ab12ed22c5b9514f39d8b" translate="yes" xml:space="preserve">
          <source>Databases and other storage mechanisms like plist, etc.</source>
          <target state="translated">plist 등과 같은 데이터베이스 및 기타 스토리지 메커니즘</target>
        </trans-unit>
        <trans-unit id="12ab214df85e4910f7e4400eea924b9565854a9f" translate="yes" xml:space="preserve">
          <source>Delegate</source>
          <target state="translated">Delegate</target>
        </trans-unit>
        <trans-unit id="7dcb8a7fd6d2299b039ffb1a88ed98c93cfc5c8c" translate="yes" xml:space="preserve">
          <source>Delegate Pattern</source>
          <target state="translated">델리게이트 패턴</target>
        </trans-unit>
        <trans-unit id="55f0774bd4a8ef9ee512f251043f191561770ae9" translate="yes" xml:space="preserve">
          <source>Delegation - for passing data back</source>
          <target state="translated">위임-데이터를 다시 전달</target>
        </trans-unit>
        <trans-unit id="4e3967fb23456a60f72119d5b28aa0e415a7f7e8" translate="yes" xml:space="preserve">
          <source>Delegation is the only one solution to perform such operations when you are using .xib files however all answers described above are for &lt;code&gt;storyboard&lt;/code&gt; for .xibs files you need to use delegation. that's only solution you can.</source>
          <target state="translated">.xib 파일을 사용할 때 위임은 이러한 작업을 수행하는 유일한 솔루션이지만 위에서 설명한 모든 대답은 위임을 사용해야하는 .xibs 파일에 대한 &lt;code&gt;storyboard&lt;/code&gt; 대한 것입니다. 그것은 당신이 할 수있는 유일한 해결책입니다.</target>
        </trans-unit>
        <trans-unit id="b4207fd5520139aa96bd6e9274602042b4534a20" translate="yes" xml:space="preserve">
          <source>Direct initialization after the allocation of another class.</source>
          <target state="translated">다른 클래스 할당 후 직접 초기화</target>
        </trans-unit>
        <trans-unit id="bcfc557b28b79f1b85cc19619bb82e338660c8e4" translate="yes" xml:space="preserve">
          <source>FirstViewController String value as</source>
          <target state="translated">FirstViewController 문자열 값</target>
        </trans-unit>
        <trans-unit id="57a94d454ba6c87c92cf93163d87c89f165d195a" translate="yes" xml:space="preserve">
          <source>FirstViewController.h</source>
          <target state="translated">FirstViewController.h</target>
        </trans-unit>
        <trans-unit id="f8e78f0e3c0970f488a281208ad26ef9f20bbdf0" translate="yes" xml:space="preserve">
          <source>FirstViewController.m</source>
          <target state="translated">FirstViewController.m</target>
        </trans-unit>
        <trans-unit id="9609a00b7fb972ff05c1431d4f283cdd084f76ce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;ViewControllerA&lt;/code&gt; to be a delegate of &lt;code&gt;ViewControllerB&lt;/code&gt; it must conform to &lt;code&gt;ViewControllerB&lt;/code&gt;'s protocol which we have to specify. This tells &lt;code&gt;ViewControllerA&lt;/code&gt; which methods it must implement.</source>
          <target state="translated">&lt;code&gt;ViewControllerA&lt;/code&gt; 가 ViewControllerB 의 델리게이트가 되려면 &lt;code&gt;ViewControllerB&lt;/code&gt; 의 프로토콜을 따라야합니다. 이것은 &lt;code&gt;ViewControllerA&lt;/code&gt; 에게 어떤 메소드를 구현 해야하는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ddb095a25c86563637fe3a13523173efa1d4bd90" translate="yes" xml:space="preserve">
          <source>For this example, we will have &lt;code&gt;ViewControllerA&lt;/code&gt; and &lt;code&gt;ViewControllerB&lt;/code&gt;</source>
          <target state="translated">이 예제에서는 &lt;code&gt;ViewControllerA&lt;/code&gt; 와 &lt;code&gt;ViewControllerB&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fd567287999a459caadcea427cbafc09d8c04a6" translate="yes" xml:space="preserve">
          <source>For those interested, I wrote some articles that address these points more in depth and highlight the various drawbacks:</source>
          <target state="translated">관심있는 사람들을 위해, 나는 이러한 요점을 더 깊이 다루고 다양한 단점을 강조하는 기사를 썼습니다.</target>
        </trans-unit>
        <trans-unit id="32096c328bd65055c2650eb54a84201d94dbdd3e" translate="yes" xml:space="preserve">
          <source>Go to your SecondViewController.h and write two methods</source>
          <target state="translated">SecondViewController.h로 이동하여 두 가지 메소드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="66b1fbfc6e5394baafe61e59c041f14de3f8dfa2" translate="yes" xml:space="preserve">
          <source>Here are two trivial examples of the segue glue.  The first is straightforward showing one parameter passed for input, the second for output.</source>
          <target state="translated">다음은 세구 접착제의 두 가지 사소한 예입니다. 첫 번째는 입력을 위해 전달 된 하나의 매개 변수를 보여주는 간단한 것이고, 두 번째는 출력을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c503ca63bb5c748744204770c2f45a34800264da" translate="yes" xml:space="preserve">
          <source>Here is the setup for the receiver.</source>
          <target state="translated">다음은 수신기 설정입니다.</target>
        </trans-unit>
        <trans-unit id="27ec3a0713aa1a15fc2589ac80289f434c756874" translate="yes" xml:space="preserve">
          <source>Here is the setup for the sender</source>
          <target state="translated">발신자 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ed131c901fbe28ddf0ce2cd8b65f252fbcb1bac" translate="yes" xml:space="preserve">
          <source>Hook up the outlets for the &lt;code&gt;UITextField&lt;/code&gt; and the &lt;code&gt;UILabel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UITextField&lt;/code&gt; 및 &lt;code&gt;UILabel&lt;/code&gt; 의 콘센트를 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="c858c878a55e6b91f549851d54d1a349d5effd3d" translate="yes" xml:space="preserve">
          <source>Hope This Helps.</source>
          <target state="translated">도움이 되었기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="0f0122ee4a988027a9316eb9e7ae9f1f39324dd0" translate="yes" xml:space="preserve">
          <source>Hope i added something to the discussion.</source>
          <target state="translated">토론에 무언가를 추가했으면 좋겠습니다.</target>
        </trans-unit>
        <trans-unit id="5a142ce919975d47656e09ab99d87f6db6c24f1b" translate="yes" xml:space="preserve">
          <source>Hope some of you find this solution useful/interesting.</source>
          <target state="translated">이 솔루션이 유용하고 흥미 롭다는 것을 알게되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="3dde88ebb2cd0d70e69aeb2a7ef870a86f8e1b6f" translate="yes" xml:space="preserve">
          <source>Hope this helps</source>
          <target state="translated">도움이 되었기를 바랍니다</target>
        </trans-unit>
        <trans-unit id="2cdfefbe424649534d9db2ab8261c3eafbd9a6e9" translate="yes" xml:space="preserve">
          <source>How iOS View Controllers Communicate With Each Other</source>
          <target state="translated">iOS View Controller가 서로 통신하는 방법</target>
        </trans-unit>
        <trans-unit id="c7727df2be19971e8927f49141a1a5496f4054e8" translate="yes" xml:space="preserve">
          <source>How to Structure the Code of iOS Apps</source>
          <target state="translated">iOS 앱의 코드를 구성하는 방법</target>
        </trans-unit>
        <trans-unit id="a7486bddaa4b0348571f0d1a8a53e76566788cb0" translate="yes" xml:space="preserve">
          <source>I am currently contributing to an open source solution to this problem through a project called MCViewFactory, which may be found here:</source>
          <target state="translated">현재 MCViewFactory라는 프로젝트를 통해이 문제에 대한 오픈 소스 솔루션에 기여하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2d0ca81764b2c3a3e1f362cde1e9ab36322bd51" translate="yes" xml:space="preserve">
          <source>I am going to rewrite his logic in Swift with latest iOS Framework</source>
          <target state="translated">최신 iOS 프레임 워크를 사용하여 Swift에서 그의 논리를 다시 작성하겠습니다.</target>
        </trans-unit>
        <trans-unit id="32993e505110576861bf61a7774bb4e29093aa24" translate="yes" xml:space="preserve">
          <source>I ended up using this example</source>
          <target state="translated">이 예제를 사용하여 끝났습니다.</target>
        </trans-unit>
        <trans-unit id="fb06d1564152df661993e0e7090fe2a1f0d5b7e9" translate="yes" xml:space="preserve">
          <source>I find simplest and most elegant version with passing blocks.
Let's name view controller that waits for returned data as &quot;A&quot; and returning view controller as &quot;B&quot;. In this example we want to get 2 values: first of Type1 and second of Type2.</source>
          <target state="translated">통과 블록이있는 가장 단순하고 가장 우아한 버전을 찾습니다. 반환 된 데이터를 &quot;A&quot;로, 뷰 컨트롤러를 &quot;B&quot;로 반환하는 뷰 컨트롤러의 이름을 지정합니다. 이 예에서는 첫 번째는 Type1의 두 번째와 두 번째는 Type2의 두 가지 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1333860eaa3d97443744ef9200f6a80fa125579a" translate="yes" xml:space="preserve">
          <source>I found there are more ways:</source>
          <target state="translated">더 많은 방법이 있다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="63c023c5a80422806d084a6c97842a45d00ed69c" translate="yes" xml:space="preserve">
          <source>I have a view that acts as a data entry form and I want to give the user the option to select multiple products. The products are listed on another view with a &lt;code&gt;UITableViewController&lt;/code&gt; and I have enabled multiple selections.</source>
          <target state="translated">데이터 입력 양식의 역할을하는 뷰가 있으며 사용자에게 여러 제품을 선택할 수있는 옵션을 제공하려고합니다. 제품이 &lt;code&gt;UITableViewController&lt;/code&gt; 와 함께 다른보기에 나열되어 있으며 여러 항목을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daab7a9e1660ea80bf746f2a7ffe137093641504" translate="yes" xml:space="preserve">
          <source>I have seen a lot of people over complicating this using the &lt;code&gt;didSelectRowAtPath&lt;/code&gt; method. I am using Core Data in my example.</source>
          <target state="translated">&lt;code&gt;didSelectRowAtPath&lt;/code&gt; 메소드를 사용하여 이것을 복잡하게 만드는 많은 사람들을 보았습니다. 예제에서 Core Data를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="16aeeef45f1fe8a16c172b0d0778c79a341461c5" translate="yes" xml:space="preserve">
          <source>I have surfed around and seen some people declare an array in the app delegate. I read something about Singletons but don't understand what these are and I read something about creating a data model.</source>
          <target state="translated">나는 서핑을하고 일부 사람들이 앱 델리게이트에서 배열을 선언하는 것을 보았습니다. Singleton에 대해서는 읽었지만 이것이 무엇인지 이해하지 못하고 데이터 모델을 만드는 것에 대해 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="814549b2a629fcb2811c5678e6e7c5629c9fa79a" translate="yes" xml:space="preserve">
          <source>I hope this answer is clear enough for people to understand and that I have not missed anything.</source>
          <target state="translated">이 답변이 사람들이 이해하기에 충분하고 내가 놓친 부분이 없기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="15f9e48f7ce909c17212445d5661bf8a3c542dbc" translate="yes" xml:space="preserve">
          <source>I know this is a beaten subject but for those looking to answer this question with a SWIFT slant and want a bare-bones example, here my go-to method for passing data if you are using a segue to get around.</source>
          <target state="translated">나는 이것이 구타의 주제라는 것을 알고 있지만 SWIFT 경사로이 질문에 대답하고 베어 본 예제를 원한다면 여기에서 segue를 사용하여 데이터를 전달하는 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="81a9e22efbeff10a44db5b8cdb745bd06025c82b" translate="yes" xml:space="preserve">
          <source>I like the idea of Model objects and Mock objects based on NSProxy to commit or discard data if what user selects can be cancelled.</source>
          <target state="translated">NSProxy를 기반으로 한 Model 객체와 Mock 객체가 사용자가 선택한 것을 취소 할 수있는 경우 데이터를 커밋하거나 버리는 아이디어를 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="baaf8a3ca4379be9cd2bab483d766c8d34304728" translate="yes" xml:space="preserve">
          <source>I was searching this solution for long time, Atlast I found it. First of all declare all the objects in your SecondViewController.h file like</source>
          <target state="translated">이 솔루션을 오랫동안 찾고 있었는데 Atlast에서 찾았습니다. 우선 SecondViewController.h 파일의 모든 객체를 다음과 같이 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="62c982b0a0ffe5bca814c4394638faed462207da" translate="yes" xml:space="preserve">
          <source>I wrote a blog post about this a while back: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;Sharing Model Code&lt;/a&gt;. Here's a brief summary:</source>
          <target state="translated">나는 이것에 관한 블로그 게시물을 작성했습니다 : &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;공유 모델 코드&lt;/a&gt; . 다음은 간단한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="f35d400cc0a2783a34596a1675a4eb5991195da1" translate="yes" xml:space="preserve">
          <source>I'm new to iOS and Objective-C and the whole MVC paradigm and I'm stuck with the following:</source>
          <target state="translated">iOS 및 Objective-C와 전체 MVC 패러다임에 익숙하지 않으며 다음과 같은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="df1f75720203e34b8f92760b6e05286c591390f8" translate="yes" xml:space="preserve">
          <source>If you are using Storyboards you are most likely using segues and will need this procedure to pass data forward. This is similar to the above but instead of passing the data before you push the view controller, you use a method called</source>
          <target state="translated">스토리 보드를 사용하는 경우 segue를 사용하고있을 가능성이 높으며 데이터를 전달하려면이 절차가 필요합니다. 이것은 위와 비슷하지만 뷰 컨트롤러를 푸시하기 전에 데이터를 전달하는 대신</target>
        </trans-unit>
        <trans-unit id="09342e817a09bfb2e555b89afe5f0a71bebde6b8" translate="yes" xml:space="preserve">
          <source>If you have your views embedded in a navigation controller you need to change the method above slightly to the following</source>
          <target state="translated">네비게이션 컨트롤러에 뷰가 내장되어 있으면 위의 방법을 다음과 같이 약간 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="c057436dcaf9858c8a465dcfbcf74653c62e56d3" translate="yes" xml:space="preserve">
          <source>If you want to pass data from one controller to other try this code</source>
          <target state="translated">한 컨트롤러에서 다른 컨트롤러로 데이터를 전달하려면이 코드를 사용해보십시오</target>
        </trans-unit>
        <trans-unit id="5aaeee5260096b956e2adc18507a3dbdbd4de81b" translate="yes" xml:space="preserve">
          <source>If you want to send data from one to another viewController, here's a way to it:</source>
          <target state="translated">하나에서 다른 viewController로 데이터를 보내려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="df625f6457413343ada0786d3f8df7e44cb409c4" translate="yes" xml:space="preserve">
          <source>Implement a method with a    UIStoryboardSegue argument in  VC 1,    like this one:</source>
          <target state="translated">다음과 같이 VC 1에서 UIStoryboardSegue 인수를 사용하여 메소드를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="d5bbe6ca201c4fe5dda1d1e053bb7f12a4edd65d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerA.m&lt;/code&gt; implement the following method from our protocol</source>
          <target state="translated">&lt;code&gt;ViewControllerA.m&lt;/code&gt; 에서 프로토콜에서 다음 메소드를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="9d6547b304166959ffcc04dfdf16623cf62b971e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerB.h&lt;/code&gt;, below the &lt;code&gt;#import&lt;/code&gt;, but above &lt;code&gt;@interface&lt;/code&gt; you specify the protocol.</source>
          <target state="translated">&lt;code&gt;ViewControllerB.h&lt;/code&gt; 에서 &lt;code&gt;#import&lt;/code&gt; 아래, &lt;code&gt;@interface&lt;/code&gt; 위에는 프로토콜을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="34f4b01f04c9ab50f1dc277e194a6c707b3ae757" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerB&lt;/code&gt; we call a message on the &lt;code&gt;delegate&lt;/code&gt; when we pop the view controller.</source>
          <target state="translated">&lt;code&gt;ViewControllerB&lt;/code&gt; 에서 뷰 컨트롤러를 &lt;code&gt;delegate&lt;/code&gt; 때 델리게이트 에 대한 메시지를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d4cb986f06c8a358bb0ac401e2255be7435b3ec6" translate="yes" xml:space="preserve">
          <source>In NewViewController.h</source>
          <target state="translated">NewViewController.h에서</target>
        </trans-unit>
        <trans-unit id="ee25efeb34aea96a92caf4d24a919db9885aa93d" translate="yes" xml:space="preserve">
          <source>In NewViewController.m</source>
          <target state="translated">NewViewController.m에서</target>
        </trans-unit>
        <trans-unit id="fcfba25eeca43facefb5d34107096b545f63a8ea" translate="yes" xml:space="preserve">
          <source>In both unwind options you can set the tag property of the button and check it in
        the prepareForSegue.</source>
          <target state="translated">두 가지 해제 옵션 모두에서 단추의 tag 속성을 설정하고 PreparingForSegue에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61da207f2a6f23452f52382b7096f549ed3ae3a9" translate="yes" xml:space="preserve">
          <source>In my case I used a singleton class which can work as a global object allowing accesses to the data from almost everywhere in the app. First thing is to build a singleton class. Please refer to the page,&quot; &lt;a href=&quot;https://stackoverflow.com/questions/145154/what-does-your-objective-c-singleton-look-like&quot;&gt;What should my Objective-C singleton look like?&lt;/a&gt; &quot;
And what I did to make the object globally accessible was simply import it in &lt;code&gt;appName_Prefix.pch&lt;/code&gt; which is for applying import statement in every classes.
To access this object and to use, I simply implemented class method to return the shared instance, which contains its own variables</source>
          <target state="translated">필자의 경우 앱의 거의 모든 곳에서 데이터에 액세스 할 수있는 전역 객체로 작동 할 수있는 싱글 톤 클래스를 사용했습니다. 첫 번째는 싱글 톤 클래스를 만드는 것입니다. &quot; &lt;a href=&quot;https://stackoverflow.com/questions/145154/what-does-your-objective-c-singleton-look-like&quot;&gt;Objective-C 싱글 톤은&lt;/a&gt; 어떻게 &lt;code&gt;appName_Prefix.pch&lt;/code&gt; ? &quot;페이지를 참조하십시오. 그리고 객체를 전역 적으로 액세스 할 수있게하려면 단순히 모든 클래스에 import 문을 적용하기위한 appName_Prefix.pch 로 가져 오십시오. 이 객체에 액세스하고 사용하기 위해 클래스 메소드를 구현하여 자체 인스턴스를 포함하는 공유 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4347c7d44969ad5ed12d4df451dd2631e4a3c195" translate="yes" xml:space="preserve">
          <source>In practice, in my opinion only a few solutions are recommended:</source>
          <target state="translated">실제로 내 의견으로는 몇 가지 솔루션 만 권장합니다.</target>
        </trans-unit>
        <trans-unit id="bf835249be3289308815771b6433af2277b90842" translate="yes" xml:space="preserve">
          <source>In scenario one, we have several viable solutions, as other answers have given</source>
          <target state="translated">시나리오 1에는 다른 답변이 제시 한 것처럼 여러 가지 실용적인 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="24e6d5a69f4225a7a61ed046e01222766c16f892" translate="yes" xml:space="preserve">
          <source>In scenario two, we do not have a single property of the HouseholdInventoryManager which could be observed using KVO. Because we do not have a single property which is easily observable, the observer pattern, in this case, must be implemented using NSNotificationCenter. Each of the four view controllers would subscribe to notifications, and the sharedManager would send notifications to the notification center when appropriate. The inventory manager does not need to know anything about the view controllers or instances of any other classes which may be interested in knowing when the collection of inventory items changes; the NSNotificationCenter takes care of these implementation details. The View Controllers simply subscribe to notifications, and the data manager simply posts notifications.</source>
          <target state="translated">시나리오 2에서는 KVO를 사용하여 관찰 할 수있는 가정용 인벤토리 관리자의 단일 속성이 없습니다. 관찰하기 쉬운 단일 속성이 없으므로이 경우 관찰자 패턴은 NSNotificationCenter를 사용하여 구현해야합니다. 4 개의보기 컨트롤러 각각은 알림을 구독하고, sharedManager는 적절한 경우 알림 센터에 알림을 보냅니다. 재고 관리자는 재고 항목의 콜렉션이 변경되는시기를 알고 싶어 할 수있는 다른 클래스의보기 제어기 또는 인스턴스에 대해 아무것도 알 필요가 없습니다. NSNotificationCenter는 이러한 구현 세부 사항을 처리합니다. View Controller는 단순히 알림을 구독하고 데이터 관리자는 단순히 알림을 게시합니다.</target>
        </trans-unit>
        <trans-unit id="e1379c7d385f5fd318471115c5d1d1f688e6b7f5" translate="yes" xml:space="preserve">
          <source>In scenario two, we have other viable solutions:</source>
          <target state="translated">시나리오 2에는 다른 실행 가능한 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58156148d8f8b4168742db8860d1cd7839fb7ebe" translate="yes" xml:space="preserve">
          <source>In the implementation of the Controller2 class there will be this function as-</source>
          <target state="translated">Controller2 클래스의 구현에는 다음과 같은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5156e8c6be3a57c9fa8103860d77229d47cc7974" translate="yes" xml:space="preserve">
          <source>In the storyBoard hook the &quot;return&quot; button to the green Exit
button(Unwind) of the vc.
 Now you have a segue that &quot;goes back&quot; so u can use the
destinationViewController property in the prepareForSegue of VC2 and
change any property of VC1 before it goes back.</source>
          <target state="translated">스토리 보드에서 &quot;return&quot;버튼을 vc의 녹색 Exit 버튼 (Unwind)에 연결합니다. 이제 &quot;돌아가는&quot;segue가 있으므로 VC2의 PreparingForSegue에서 destinationViewController 속성을 사용하고 VC1의 속성을 변경하기 전에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e86367af7272fc181fb5bcd8c70015239a60e37" translate="yes" xml:space="preserve">
          <source>In viewControllerA.m</source>
          <target state="translated">viewControllerA.m에서</target>
        </trans-unit>
        <trans-unit id="8a08c48c65d645ac979b803ebbf4f71b0159c9d9" translate="yes" xml:space="preserve">
          <source>In viewControllerB.m</source>
          <target state="translated">viewControllerB.m에서</target>
        </trans-unit>
        <trans-unit id="cb79757699a18236287e35ceb1f9e3b022bb1e91" translate="yes" xml:space="preserve">
          <source>Independent access</source>
          <target state="translated">독립적 인 접근</target>
        </trans-unit>
        <trans-unit id="3880381f94e658ae2233113129d0559225e916ff" translate="yes" xml:space="preserve">
          <source>It is similar to the above but without the buttons, labels and such.  Just simply passing data from one view to the next.</source>
          <target state="translated">위와 비슷하지만 버튼, 레이블 등은 없습니다. 한 뷰에서 다음 뷰로 데이터를 전달하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b906440f7eeb43644c0bf66e1e5221e013acae00" translate="yes" xml:space="preserve">
          <source>It's easy to pass data around since it's single object or couple of objects and if you have let's say UINavigationController controller, you can keep the reference to model inside and all pushed view controllers can access it directly from navigation controller.</source>
          <target state="translated">단일 객체 또는 두 개의 객체이기 때문에 데이터를 쉽게 전달할 수 있으며 UINavigationController 컨트롤러를 사용하면 모델에 대한 참조를 유지할 수 있으며 모든 푸시 뷰 컨트롤러는 내비게이션 컨트롤러에서 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b5d7461b214a33821ecc10f031e0f6c05ecb915" translate="yes" xml:space="preserve">
          <source>Key-Value Observing</source>
          <target state="translated">키-값 관찰</target>
        </trans-unit>
        <trans-unit id="8d8b4106a4bbadd0d9b29b9a2e51f6ef83bfb01d" translate="yes" xml:space="preserve">
          <source>Key-Value-Observing (KVO)</source>
          <target state="translated">키-값-관찰 (KVO)</target>
        </trans-unit>
        <trans-unit id="083eb368f20ff79cd32a80916799dbc06c14959b" translate="yes" xml:space="preserve">
          <source>Lastly, the setup for the segue.</source>
          <target state="translated">마지막으로, segue 설정.</target>
        </trans-unit>
        <trans-unit id="f46a343ce085e475c030eeb1bc56e9b6d0820f1a" translate="yes" xml:space="preserve">
          <source>Managing Data Flow Between View Controllers</source>
          <target state="translated">View Controller 간 데이터 흐름 관리</target>
        </trans-unit>
        <trans-unit id="6261f4593d459846fc2f53486c547ab992d8a961" translate="yes" xml:space="preserve">
          <source>Many beginner programmers take advantage of the fact that there is always exactly one &lt;strong&gt;Application Delegate&lt;/strong&gt; in the lifetime of the application, which is globally accessible. Beginning programmers use this fact to stuff objects and functionality into the appDelegate as a convenience for access from anywhere else in the application. Just because the AppDelegate is a singleton doesn't mean it should replace all other singletons. This is a poor practice as it places too much burden on one class, breaking good object-oriented practices. Each class should have a clear role that is easily explained, often just by the name of the class.</source>
          <target state="translated">많은 초보자 프로그래머는 응용 프로그램 수명 동안 항상 정확히 하나의 &lt;strong&gt;응용 프로그램 위임&lt;/strong&gt; 이 있으며 이는 전 세계적으로 액세스 할 수 있다는 사실을 이용합니다. 초보자는이 사실을 사용하여 응용 프로그램의 어느 곳에서나 액세스 할 수있는 편의상 개체와 기능을 appDelegate에 넣습니다. AppDelegate가 싱글 톤이라고해서 다른 모든 싱글 톤을 교체해야한다는 의미는 아닙니다. 한 클래스에 너무 많은 부담을 주면서 좋은 객체 지향 사례를 깨뜨리는 것은 나쁜 습관입니다. 각 클래스는 종종 클래스 이름으로 쉽게 설명 할 수있는 명확한 역할을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="ee93bc5d4f01f7c4f087cb3eea0c1a1fa3b208c9" translate="yes" xml:space="preserve">
          <source>My question is, how do I transfer the data from one view to another? I will be holding the selections on the &lt;code&gt;UITableView&lt;/code&gt; in an array, but how do I then pass that back to the previous data entry form view so it can be saved along with the other data to Core Data on submission of the form?</source>
          <target state="translated">내 질문은 데이터를 한보 기에서 다른보기로 어떻게 전송합니까? &lt;code&gt;UITableView&lt;/code&gt; 의 선택 항목을 배열로 유지하지만 양식을 제출할 때 다른 데이터와 함께 Core Data에 저장할 수 있도록 이전 데이터 입력 양식보기로 다시 전달하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a18e3f8bc52ea9a0b5de60e0fda22bd4b604ae4c" translate="yes" xml:space="preserve">
          <source>NSFetchedResultsController</source>
          <target state="translated">NSFetchedResultsController</target>
        </trans-unit>
        <trans-unit id="3f1be4da3d97e7743b4732f8a89228df11998162" translate="yes" xml:space="preserve">
          <source>NSNotification</source>
          <target state="translated">NSNotification</target>
        </trans-unit>
        <trans-unit id="703e1cf67303eac1ee399d96fe268f382746c5ae" translate="yes" xml:space="preserve">
          <source>NSNotificationCenter.</source>
          <target state="translated">NSNotificationCenter.</target>
        </trans-unit>
        <trans-unit id="433d340991507812dfa779c7f285cce0740b90aa" translate="yes" xml:space="preserve">
          <source>NSUserDefaults (actually a poor choice)</source>
          <target state="translated">NSUserDefaults (실제로 좋지 않은 선택)</target>
        </trans-unit>
        <trans-unit id="3ddf7238b6f7a09861615351dda77ab298ecd4c4" translate="yes" xml:space="preserve">
          <source>Next, we need to add the method to &lt;code&gt;ViewControllerA&lt;/code&gt; that is called when any segue is performed, because of this we need to detect which segue was called and then do something. In our example we will check for &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; and if that's performed we will pass our &lt;code&gt;BOOL&lt;/code&gt; value to &lt;code&gt;ViewControllerB&lt;/code&gt;</source>
          <target state="translated">다음으로, segue가 수행 될 때 호출되는 &lt;code&gt;ViewControllerA&lt;/code&gt; 에 메소드를 추가해야합니다. 이로 인해 호출 된 segue를 감지 한 후 무언가를 수행해야합니다. 이 예에서는 &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; 를 확인하고 수행되면 &lt;code&gt;BOOL&lt;/code&gt; 값을 &lt;code&gt;ViewControllerB&lt;/code&gt; 에 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="bae49983d331f8ba8153193a85e0fefdfdfa8445" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;protocol&lt;/code&gt; is outside of the View Controller class.</source>
          <target state="translated">&lt;code&gt;protocol&lt;/code&gt; 은 View Controller 클래스 외부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b5b766ef197bc7d0023a5f3e888401660c5170a" translate="yes" xml:space="preserve">
          <source>Note the use of our custom &lt;code&gt;DataEnteredDelegate&lt;/code&gt; protocol.</source>
          <target state="translated">사용자 정의 &lt;code&gt;DataEnteredDelegate&lt;/code&gt; 프로토콜 사용에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="c18f8f255ab9c208f23d0340eb9dff5a84efe311" translate="yes" xml:space="preserve">
          <source>Notification</source>
          <target state="translated">Notification</target>
        </trans-unit>
        <trans-unit id="01ae3c85aad097022aea128cd630e363a5a0b504" translate="yes" xml:space="preserve">
          <source>Notification - for broadcasting data to multiple classes at a single time</source>
          <target state="translated">알림-한 번에 여러 클래스로 데이터 브로드 캐스트</target>
        </trans-unit>
        <trans-unit id="4b1ac88a12c84ad56cbb34ecd00cd8b11ad67ab8" translate="yes" xml:space="preserve">
          <source>Now go to ViewController1.h and add the following property:</source>
          <target state="translated">이제 ViewController1.h로 이동하여 다음 속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f4fdc026034f453314cb2b9feb3226cf19c866df" translate="yes" xml:space="preserve">
          <source>Now go to ViewController2.h and add</source>
          <target state="translated">이제 ViewController2.h로 이동하여 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="07293e03847eaf2deb454753b5701dde56438146" translate="yes" xml:space="preserve">
          <source>Now go to ViewController2.m and inside the implementation add:</source>
          <target state="translated">이제 ViewController2.m으로 이동하여 구현 내부에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1891d36db45cf91dbf1adab42bd7124ff5f7b4aa" translate="yes" xml:space="preserve">
          <source>Now if you are creating ViewController1 inside ViewController2 after some event, then you should do it this way using NIB files:</source>
          <target state="translated">이제 이벤트 후 ViewController2 내에 ViewController1을 생성하는 경우 NIB 파일을 사용하여 다음과 같이해야합니다.</target>
        </trans-unit>
        <trans-unit id="81718fed0b8059c2699c24b22f89672b462cced7" translate="yes" xml:space="preserve">
          <source>Now in viewControllerB.h</source>
          <target state="translated">이제 viewControllerB.h에서</target>
        </trans-unit>
        <trans-unit id="066cfa98ab2af89a37dd0692de1da1e510da9279" translate="yes" xml:space="preserve">
          <source>Now in your implementation file allocate the memory for those objects like this</source>
          <target state="translated">이제 구현 파일에서 이와 같은 객체에 메모리를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="25d28a372f3af29852f3a97a0f8b0fbc603109d9" translate="yes" xml:space="preserve">
          <source>Now that we understand what a singleton is, let's discuss how a singleton fits into the observer pattern. The observer pattern is used for one object to respond to changes by another object. In the second scenario, we have four different view controllers, who all want to know about changes to the underlying data. The &quot;underlying data&quot; should belong to a single instance, a singleton. The &quot;know about changes&quot; is accomplished by observing changes made to the singleton.</source>
          <target state="translated">이제 싱글 톤이 무엇인지 이해 했으므로 싱글 톤이 옵저버 패턴에 어떻게 맞는지 논의하겠습니다. 관찰자 패턴은 한 객체가 다른 객체의 변경에 응답하는 데 사용됩니다. 두 번째 시나리오에는 기본 데이터의 변경 사항에 대해 알고 싶은 4 개의 서로 다른 뷰 컨트롤러가 있습니다. &quot;기본 데이터&quot;는 단일 인스턴스 인 싱글 톤에 속해야합니다. &quot;변경에 대한 정보&quot;는 싱글 톤의 변경 사항을 관찰함으로써 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="810d6004f87bdd4f1aaf25235b9fc765e7454783" translate="yes" xml:space="preserve">
          <source>Now you are all set, whenever you detect the event of check changed in ViewController1, all you have to do is the below</source>
          <target state="translated">이제 ViewController1에서 변경된 확인 이벤트를 감지 할 때마다 아래 사항 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="b3a73828042eb03dcbae2c139bf92a09db907f20" translate="yes" xml:space="preserve">
          <source>Now you have allocated the memory for &lt;code&gt;Array&lt;/code&gt; and object. now you can fill that memory before pushing this &lt;code&gt;ViewController&lt;/code&gt;</source>
          <target state="translated">이제 &lt;code&gt;Array&lt;/code&gt; 과 객체에 메모리를 할당했습니다. 이제이 &lt;code&gt;ViewController&lt;/code&gt; 를 푸시하기 전에 해당 메모리를 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f65e68be86324bc6597c188e4d73418ae145285" translate="yes" xml:space="preserve">
          <source>Now, in your VC, anytime you want to move to a new VC and pass data, you create a new intent and add data to its dictionary (savedInstanceState). Then, just set the current intent of factory:</source>
          <target state="translated">이제 VC에서 새 VC로 이동하고 데이터를 전달할 때마다 새로운 의도를 작성하고 사전 (savedInstanceState)에 데이터를 추가합니다. 그런 다음 공장의 현재 의도를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bec1d95a6f86d7011a1b0191ad1cb2a79100a6f0" translate="yes" xml:space="preserve">
          <source>Observer Pattern</source>
          <target state="translated">관찰자 패턴</target>
        </trans-unit>
        <trans-unit id="6869e328e00e68ce2087969b13da4a7500c52bc3" translate="yes" xml:space="preserve">
          <source>Once it is run it should switch to the receiver view automatically and pass the value from the sender to the receiver, displaying the value in the console.</source>
          <target state="translated">일단 실행되면 수신자보기로 자동 전환하고 발신자에서 수신자에게 값을 전달하여 콘솔에 값을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a8ee395cb2fe5ae68947c4ee9e43e6c00f1c91e" translate="yes" xml:space="preserve">
          <source>One approach is to share pointers to the model objects between view controllers.</source>
          <target state="translated">한 가지 방법은 뷰 컨트롤러간에 모델 객체에 대한 포인터를 공유하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c4076a44a136b6e3d1dde14cee2663da71d34347" translate="yes" xml:space="preserve">
          <source>One thing to remember is that using block often needs to manage strong and __weak references  like explained &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW16&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">기억해야 할 것은 블록을 사용하면 종종 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW16&quot;&gt;여기에&lt;/a&gt; 설명 된 것처럼 강력하고 __ 약한 참조를 관리해야한다는 것입니다</target>
        </trans-unit>
        <trans-unit id="0e88c4b3dfd5e93f534f4bbe8851936f162bd94e" translate="yes" xml:space="preserve">
          <source>Or if you need to pass more than 3 parameters which are related to a common feature you can store the values to a Model class and pass that modelObject to the next class</source>
          <target state="translated">또는 공통 기능과 관련된 3 개 이상의 매개 변수를 전달해야하는 경우 값을 모델 클래스에 저장하고 해당 모델 오브젝트를 다음 클래스에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad245eca6b5201f4babe15b0ebc45f1a1101dc9c" translate="yes" xml:space="preserve">
          <source>Passing Data Between View Controllers</source>
          <target state="translated">뷰 컨트롤러간에 데이터 전달</target>
        </trans-unit>
        <trans-unit id="06cd07cfe5ceeea538fa8519602b78db4a7a221b" translate="yes" xml:space="preserve">
          <source>Passing Data between View Controllers</source>
          <target state="translated">View Controller간에 데이터 전달</target>
        </trans-unit>
        <trans-unit id="e969e4903b74ca67d170b3ed2c9867a31ea779e7" translate="yes" xml:space="preserve">
          <source>Passing data back from ViewController 2(destination) to viewController 1(Source) is the more interesting thing.
Assuming you use storyBoard those are all the ways i found out:</source>
          <target state="translated">ViewController 2 (대상)에서 viewController 1 (소스)로 데이터를 다시 전달하는 것이 더 흥미로운 것입니다. 당신이 storyBoard를 사용한다고 가정하면 그것들은 내가 찾은 모든 방법입니다.</target>
        </trans-unit>
        <trans-unit id="90994a166764b8045c671701e6012101fbad1f99" translate="yes" xml:space="preserve">
          <source>Passing data back to the previous View Controller</source>
          <target state="translated">이전 View Controller로 데이터 전달</target>
        </trans-unit>
        <trans-unit id="f34143ad2ab7c3261acf61c694d57262c6895d43" translate="yes" xml:space="preserve">
          <source>Passing data forward to a view controller from another view controller. You would use this method if you wanted to pass an object/value from one view controller to another view controller that you may be pushing on to a navigation stack.</source>
          <target state="translated">다른 뷰 컨트롤러에서 뷰 컨트롤러로 데이터를 전달합니다. 탐색 스택으로 푸시 할 수있는 한 뷰 컨트롤러에서 다른 뷰 컨트롤러로 객체 / 값을 전달하려는 경우이 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="72012e34fc1aeacc4018406263df2a50524a13b3" translate="yes" xml:space="preserve">
          <source>Passing data forward to the next View Controller</source>
          <target state="translated">다음 View Controller로 데이터 전달</target>
        </trans-unit>
        <trans-unit id="7cbc262874edf29fb88c6eb2ae168aa523c5bed0" translate="yes" xml:space="preserve">
          <source>Passing data through notifications</source>
          <target state="translated">알림을 통해 데이터 전달</target>
        </trans-unit>
        <trans-unit id="e73c1b3673eb3091a3411becb205b9ac61c3efb6" translate="yes" xml:space="preserve">
          <source>Passing data through the app delegate</source>
          <target state="translated">앱 델리게이트를 통해 데이터 전달</target>
        </trans-unit>
        <trans-unit id="a915a260ebb52c58c5ddeb3943b28412a9cefd74" translate="yes" xml:space="preserve">
          <source>Please tell me if there's anything that's not clear of if I didn't understand your question properly.</source>
          <target state="translated">귀하의 질문을 제대로 이해하지 못했다면 분명하지 않은 것이 있으면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="f176ff29bfb1c8e95257d7a079bef36426919bfd" translate="yes" xml:space="preserve">
          <source>Rather than having a highly hypothetical, abstract discussion, it helps to have concrete applications in mind. To help define a two-view-controller situation and a more-than-two-view-controller situation, I am going to define two concrete application scenarios.</source>
          <target state="translated">매우 가설적이고 추상적 인 토론을하는 대신 구체적인 응용 프로그램을 염두에 두는 데 도움이됩니다. 2 뷰 컨트롤러 상황과 2 뷰 이상의 컨트롤러 상황을 정의하는 데 도움을주기 위해 두 가지 구체적인 애플리케이션 시나리오를 정의하겠습니다.</target>
        </trans-unit>
        <trans-unit id="96723c17d633897e26d4e0d1557b30b3a18133db" translate="yes" xml:space="preserve">
          <source>Read more about this in my blog post: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;Sharing Model Code&lt;/a&gt;</source>
          <target state="translated">내 블로그 게시물 : &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;모델 코드 공유&lt;/a&gt; 에서 이에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="a6171b282836b161fc897d0e7facdf82f4d8f378" translate="yes" xml:space="preserve">
          <source>Referencing the previous controller directly instead of using delegation</source>
          <target state="translated">위임을 사용하는 대신 이전 컨트롤러를 직접 참조</target>
        </trans-unit>
        <trans-unit id="47f40c97b581997edd1f3619ce23a4265e1431df" translate="yes" xml:space="preserve">
          <source>Saving in &lt;code&gt;NSUserDefaults&lt;/code&gt; - for accessing it later</source>
          <target state="translated">&lt;code&gt;NSUserDefaults&lt;/code&gt; 에 저장-나중에 액세스하기 위해</target>
        </trans-unit>
        <trans-unit id="0bcf73dc223ca8c4becbbceb7de2d7cdd2d55fd9" translate="yes" xml:space="preserve">
          <source>Say we have viewControllers: ViewController and NewViewController.</source>
          <target state="translated">viewController : ViewController와 NewViewController가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="569d57f11dc5d61438be375ec49d9c3b862b507e" translate="yes" xml:space="preserve">
          <source>Say we have viewControllers: viewControllerA and viewControllerB</source>
          <target state="translated">viewController가 있다고 가정 해보십시오 : viewControllerA와 viewControllerB</target>
        </trans-unit>
        <trans-unit id="7995203d870462ca887f06daef0b98c3ee08ad6a" translate="yes" xml:space="preserve">
          <source>SecondViewController.h</source>
          <target state="translated">SecondViewController.h</target>
        </trans-unit>
        <trans-unit id="1915fd9b6120253558e8f5d765575ff18961657e" translate="yes" xml:space="preserve">
          <source>Set data in prepareForSegue (if storyboards) or init (if programmatic)</source>
          <target state="translated">PreparingForSegue (스토리 보드 인 경우) 또는 init (프로그래밍 된 경우)에서 데이터 설정</target>
        </trans-unit>
        <trans-unit id="9f9b397db477e0a2585ce2a75ed1b81d61e4549c" translate="yes" xml:space="preserve">
          <source>Set the first and second View Controllers to the appropriate Swift files in IB.</source>
          <target state="translated">첫 번째 및 두 번째 View Controller를 IB에서 적절한 Swift 파일로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ccfa21b36505d345ced6258f5060e6876076d7db" translate="yes" xml:space="preserve">
          <source>Shared data</source>
          <target state="translated">공유 데이터</target>
        </trans-unit>
        <trans-unit id="63b646be139048f00d5075927d5ac6aa1bc9e3fd" translate="yes" xml:space="preserve">
          <source>Sharing data through a singleton</source>
          <target state="translated">싱글 톤을 통한 데이터 공유</target>
        </trans-unit>
        <trans-unit id="88026f64b6a3f47cdb4c499ea8d5bb82d8ae7191" translate="yes" xml:space="preserve">
          <source>Sharing data through the user defaults</source>
          <target state="translated">사용자 기본값을 통한 데이터 공유</target>
        </trans-unit>
        <trans-unit id="a81942be08afc02b07b690161fca39667b375b36" translate="yes" xml:space="preserve">
          <source>Since all the view controllers do need to share the same data, all four view controllers need to remain in synchronization, and therefore there needs to be some sort of communication to all other view controllers, whenever any single view controller changes the underlying data. It should be fairly obvious that we do not want each view controller communicating directly with each other view controller in this scenario. In case it is not obvious, consider if we had 20 different view controllers (rather than just 4). How difficult and error-prone would it be to notify each of the other 19 view controllers any time one view controller made a change?</source>
          <target state="translated">모든 뷰 컨트롤러가 동일한 데이터를 공유해야하므로 4 개의 뷰 컨트롤러는 모두 동기화 상태를 유지해야하므로 단일 뷰 컨트롤러가 기본 데이터를 변경할 때마다 다른 모든 뷰 컨트롤러와 통신해야합니다. 이 시나리오에서는 각 뷰 컨트롤러가 서로 다른 뷰 컨트롤러와 직접 통신하는 것을 원하지 않습니다. 분명하지 않은 경우, 4 개가 아닌 20 개의 서로 다른 뷰 컨트롤러가 있는지 고려하십시오. 하나의 뷰 컨트롤러가 변경 될 때마다 다른 19 개의 뷰 컨트롤러 각각에 알리는 것이 얼마나 어렵고 오류가 발생합니까?</target>
        </trans-unit>
        <trans-unit id="956ba40003839a7f10984a661afb553e5a9a4ec6" translate="yes" xml:space="preserve">
          <source>Since prepare for segue is the most common here is an example:</source>
          <target state="translated">segue 준비가 가장 일반적이므로 여기에 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="39892ce8d343b16aa782fc0cc427d7c5ce4bcd1d" translate="yes" xml:space="preserve">
          <source>Singleton</source>
          <target state="translated">Singleton</target>
        </trans-unit>
        <trans-unit id="5f4a7d1855bedb7eb4c08667076bebd6d20d2643" translate="yes" xml:space="preserve">
          <source>Singleton classes</source>
          <target state="translated">싱글턴 수업</target>
        </trans-unit>
        <trans-unit id="f4952f106d9d3b4bccd6d238d2f11b71e55ecb4c" translate="yes" xml:space="preserve">
          <source>Singletons</source>
          <target state="translated">Singletons</target>
        </trans-unit>
        <trans-unit id="b57cd7bb78daf1f63929b88ccbd517476d4ae4d7" translate="yes" xml:space="preserve">
          <source>So Here is the complete code for :</source>
          <target state="translated">다음은 완전한 코드입니다.</target>
        </trans-unit>
        <trans-unit id="067b41481717b1f69eb20355ee8195bf00f43e67" translate="yes" xml:space="preserve">
          <source>So in-short if you want to -</source>
          <target state="translated">원한다면 짧게-</target>
        </trans-unit>
        <trans-unit id="630e7f3acca48624176a82489c5a93d213da2351" translate="yes" xml:space="preserve">
          <source>So this is how you can pass data from viewControllerA to viewControllerB without setting any delegate. ;)</source>
          <target state="translated">따라서 이것은 대리자를 설정하지 않고 viewControllerA에서 viewControllerB로 데이터를 전달할 수있는 방법입니다. ;)</target>
        </trans-unit>
        <trans-unit id="156495cd7dd5073171ae3eca350eda618cbfbef4" translate="yes" xml:space="preserve">
          <source>So this way we can pass the data from one viewcontroller to another view controller...</source>
          <target state="translated">따라서이 방법으로 하나의 뷰 컨트롤러에서 다른 뷰 컨트롤러로 데이터를 전달할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="9fa353fb1913b923bef4e523da2474a47221935b" translate="yes" xml:space="preserve">
          <source>So to pass a &lt;code&gt;BOOL&lt;/code&gt; from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; we would do the following:</source>
          <target state="translated">따라서 &lt;code&gt;ViewControllerA&lt;/code&gt; 에서 ViewControllerB 로 &lt;code&gt;BOOL&lt;/code&gt; 을 전달하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="98d77a00cf4d2b88573bd271f511f0e79ed4f054" translate="yes" xml:space="preserve">
          <source>Solutions I recommend NOT to use:</source>
          <target state="translated">사용하지 않는 것이 좋습니다 :</target>
        </trans-unit>
        <trans-unit id="b08338f95aa0ad8470939d5e2faa60ab6d042c8f" translate="yes" xml:space="preserve">
          <source>Step 1. Declare block in ViewControllerB</source>
          <target state="translated">1 단계. ViewControllerB에서 블록 선언</target>
        </trans-unit>
        <trans-unit id="b2e9b0649764d10cd7a0faf97a6596c1df79f36a" translate="yes" xml:space="preserve">
          <source>Step 1. Set and Post data in Notification observer in ViewControllerB</source>
          <target state="translated">1 단계. ViewControllerB의 알림 관찰자에서 데이터 설정 및 게시</target>
        </trans-unit>
        <trans-unit id="68b389f0cd09c0cdce9598cbf02e200602cae14b" translate="yes" xml:space="preserve">
          <source>Step 2. Add Notification Observer in ViewControllerA</source>
          <target state="translated">2 단계. ViewControllerA에서 알림 관찰자 추가</target>
        </trans-unit>
        <trans-unit id="0b56714eef4294da9118c9f272a4110e07a65e76" translate="yes" xml:space="preserve">
          <source>Step 2. Set data in block in ViewControllerB</source>
          <target state="translated">2 단계. ViewControllerB에서 블록으로 데이터 설정</target>
        </trans-unit>
        <trans-unit id="a2546740685a30020fdf8994c5e6ec2f4358487b" translate="yes" xml:space="preserve">
          <source>Step 3. Receive Notification data value in ViewControllerA</source>
          <target state="translated">3 단계. ViewControllerA에서 알림 데이터 값 수신</target>
        </trans-unit>
        <trans-unit id="8fc7fedaa6db88ca11b7a1de1f3aca654b50e838" translate="yes" xml:space="preserve">
          <source>Step 3. Receive block data in ViewControllerA</source>
          <target state="translated">3 단계. ViewControllerA에서 블록 데이터 수신</target>
        </trans-unit>
        <trans-unit id="270b96d467cbf5437502201704dee28da77c95f4" translate="yes" xml:space="preserve">
          <source>Storyboard segues, ARC and LLVM blocks make this easier than ever for me.  Some answers above mentioned storyboards and segues already but still relied on delegation.  Defining delegates certainly works but some people may find it easier to pass pointers or code blocks.</source>
          <target state="translated">스토리 보드 segues, ARC 및 LLVM 블록은 나를 위해 그 어느 때보 다 쉬워졌습니다. 위에서 언급 한 일부 스토리 보드와 말은 이미 위임에 의존하고 있습니다. 델리게이트 정의는 확실히 작동하지만 일부 사람들은 포인터 나 코드 블록을 전달하는 것이 더 쉽다는 것을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="3b14c615ad076500bec6990bd3e8c11b39b908a7" translate="yes" xml:space="preserve">
          <source>Suppose in Controller1 class you want to create the Controller2 object and push it with a String value being passed. This can be done as this:-</source>
          <target state="translated">Controller1 클래스에서 Controller2 객체를 생성하고 전달되는 문자열 값으로 푸시한다고 가정합니다. 이것은 다음과 같이 수행 할 수 있습니다 :-</target>
        </trans-unit>
        <trans-unit id="112ab020698e5fc0f4baecd7821a512d8c419a69" translate="yes" xml:space="preserve">
          <source>Swift</source>
          <target state="translated">Swift</target>
        </trans-unit>
        <trans-unit id="19d9195fc6303123e2881ef15e4a993bb8b3dec5" translate="yes" xml:space="preserve">
          <source>Synthesize str2 in ViewControllerTwo.m</source>
          <target state="translated">ViewControllerTwo.m에서 str2를 합성하십시오</target>
        </trans-unit>
        <trans-unit id="0207a1f2edfc990bff7a614c26a4e4edee42239e" translate="yes" xml:space="preserve">
          <source>Take care for spelling mistakes.</source>
          <target state="translated">철자 실수를 조심하십시오.</target>
        </trans-unit>
        <trans-unit id="09429d005a789be54befa1f80bc0eeaac578f2e8" translate="yes" xml:space="preserve">
          <source>Than in implementation file BViewController.m after we have desired values to return our callback should be called:</source>
          <target state="translated">콜백을 반환하기 위해 원하는 값을 얻은 후 구현 파일 BViewController.m보다 다음을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="03d7f840d11dff1bc5d8b6d191428b355e3aebb7" translate="yes" xml:space="preserve">
          <source>Thanks for all your help</source>
          <target state="translated">모든 도움을 주셔서 감사합니다</target>
        </trans-unit>
        <trans-unit id="8527cb919ee3a95cff65ca01028642d6226a89b6" translate="yes" xml:space="preserve">
          <source>That is how you can tackle it if you want to use a segue and you don't have your pages under a navigation controller.</source>
          <target state="translated">segue를 사용하고 탐색 컨트롤러 아래에 페이지가없는 경우이를 해결하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="95e8fe02f9d9ffb578ba4e865a2725ad960d20a6" translate="yes" xml:space="preserve">
          <source>That's it for &lt;code&gt;ViewControllerB&lt;/code&gt;. Now in &lt;code&gt;ViewControllerA.h&lt;/code&gt;, tell &lt;code&gt;ViewControllerA&lt;/code&gt; to import &lt;code&gt;ViewControllerB&lt;/code&gt; and conform to its protocol.</source>
          <target state="translated">이것이 &lt;code&gt;ViewControllerB&lt;/code&gt; 에 대한 것입니다. 이제 &lt;code&gt;ViewControllerA.h&lt;/code&gt; 에서 ViewControllerA 에게 &lt;code&gt;ViewControllerA&lt;/code&gt; 를 가져오고 해당 프로토콜을 따르도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="56ac635adbb66b598268b04a53cefa274b67ac90" translate="yes" xml:space="preserve">
          <source>That's it. Running the app now you should be able to send data back from the second view controller to the first.</source>
          <target state="translated">그게 다야. 이제 앱을 실행하면 두 번째 뷰 컨트롤러에서 첫 번째 컨트롤러로 데이터를 다시 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f175a537a69568d4d36d5d1c44c51c042c2dc5" translate="yes" xml:space="preserve">
          <source>The M in MVC is for &quot;Model&quot; and in the MVC paradigm the role of model classes is to manage a program's data. A model is the opposite of a view -- a view knows how to display data, but it knows nothing about what to do with data, whereas a model knows everything about how to work with data, but nothing about how to display it. Models can be complicated, but they don't have to be -- the model for your app might be as simple as an array of strings or dictionaries.</source>
          <target state="translated">MVC의 M은 &quot;모델&quot;을위한 것이며 MVC 패러다임에서 모델 클래스의 역할은 프로그램의 데이터를 관리하는 것입니다. 모델은 뷰의 반대입니다. 뷰는 데이터를 표시하는 방법을 알고 있지만 데이터를 어떻게 처리해야하는지 아는 것은 없지만 모델은 데이터를 처리하는 방법에 대한 모든 것을 알고 있지만 표시하는 방법에 대해서는 아는 것이 없습니다. 모델은 복잡 할 수 있지만 반드시 그럴 필요는 없습니다. 앱의 모델은 문자열이나 사전 배열처럼 단순 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de4d0fb8549c6a726ff58a67a687beaccbe06a26" translate="yes" xml:space="preserve">
          <source>The OP didn't mention view controllers but so many of the answers do, that I wanted to chime in with what some of the new features of the LLVM allow to make this easier when wanting to pass data from one view controller to another and then getting some results back.</source>
          <target state="translated">OP는 뷰 컨트롤러를 언급하지 않았지만 많은 답변이 있었으므로 LLVM의 새로운 기능 중 일부가 뷰 컨트롤러에서 다른 뷰 컨트롤러로 데이터를 전달할 때 더 쉽게 수행 할 수있는 기능에 대해 설명하고 싶었습니다. 결과를 다시 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c20529383e6407f57b3ff8211721c8adde0bba28" translate="yes" xml:space="preserve">
          <source>The Receiver</source>
          <target state="translated">수신자</target>
        </trans-unit>
        <trans-unit id="4154dd7ff0aa610daf859664a9f5cdd415da28f3" translate="yes" xml:space="preserve">
          <source>The Segue</source>
          <target state="translated">세구</target>
        </trans-unit>
        <trans-unit id="ebcf3ab1a842c17f7a5edda449755a002af952e2" translate="yes" xml:space="preserve">
          <source>The Sender</source>
          <target state="translated">발신자</target>
        </trans-unit>
        <trans-unit id="b93bdfec7ee7436d0d31a07d163e319c506ba2dd" translate="yes" xml:space="preserve">
          <source>The code for the First View Controller is</source>
          <target state="translated">First View Controller의 코드는</target>
        </trans-unit>
        <trans-unit id="16d83b85f70f1ef1d672a4056bde27f526c1f3e4" translate="yes" xml:space="preserve">
          <source>The code for the second view controller is</source>
          <target state="translated">두 번째 뷰 컨트롤러의 코드는</target>
        </trans-unit>
        <trans-unit id="1427436496c2ed01688bdba0dfac3d0163918947" translate="yes" xml:space="preserve">
          <source>The following is an example based on the video (with a few modifications).</source>
          <target state="translated">다음은 비디오를 기반으로 한 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="27168310b19624bfd7d1406057bd1581233f19b9" translate="yes" xml:space="preserve">
          <source>The following is an example based on the video. The idea is to pass a string from the text field in the First View Controller to the label in the Second View Controller.</source>
          <target state="translated">다음은 비디오를 기반으로 한 예입니다. 아이디어는 문자열을 첫 번째보기 컨트롤러의 텍스트 필드에서 두 번째보기 컨트롤러의 레이블로 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="07cf6b0d487458fa179fc57899f7a0abf454ed14" translate="yes" xml:space="preserve">
          <source>The home inventory application would have a single instance of a class which is designed to manage a list of inventory items. The manager would manage a collection of household items. The following is a class definition for the data manager:</source>
          <target state="translated">주택 재고 응용 프로그램에는 재고 품목 목록을 관리하도록 설계된 클래스의 단일 인스턴스가 있습니다. 관리자는 가정 용품 컬렉션을 관리합니다. 다음은 데이터 관리자에 대한 클래스 정의입니다.</target>
        </trans-unit>
        <trans-unit id="3883ea5969f34a183a8fdf68d24a5c4df97e7e94" translate="yes" xml:space="preserve">
          <source>The idea is imitate Android's intent paradigm, using a global factory to manage which view you are looking at and using &quot;intents&quot; to switch and pass data between views. All the documentation is on the github page, but here are some highlights:</source>
          <target state="translated">이 아이디어는 글로벌 팩토리를 사용하여보고있는 뷰를 관리하고 &quot;인 텐트&quot;를 사용하여 뷰간에 데이터를 전환하고 전달하는 Android의 의도 패러다임을 모방합니다. 모든 문서는 github 페이지에 있지만 다음과 같은 주요 내용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4deb3d745148fadb3c8578e557f0283203b359a" translate="yes" xml:space="preserve">
          <source>The most common way I've seen this done is a &lt;a href=&quot;http://koreyhinton.com/blog/singleton-pattern-in-swift.html&quot;&gt;singleton&lt;/a&gt; instance. So if your singleton object was &lt;code&gt;DataAccess&lt;/code&gt; you could do the following in the viewDidLoad method of UIViewController:</source>
          <target state="translated">내가 본 가장 일반적인 방법은 &lt;a href=&quot;http://koreyhinton.com/blog/singleton-pattern-in-swift.html&quot;&gt;싱글 톤&lt;/a&gt; 인스턴스입니다. 따라서 싱글 톤 객체가 &lt;code&gt;DataAccess&lt;/code&gt; 인 경우 UIViewController의 viewDidLoad 메소드에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270c440ea6ee47f9a7fab1f1471c613f9ba1ab40" translate="yes" xml:space="preserve">
          <source>The nice thing about Core Data is that it has inverse relationships. So if you want to just give a NotesViewController the notes object you can because it'll have an inverse relationship to something else like the notebook. If you need data on the notebook in the NotesViewController you can walk back up the object graph by doing the following:</source>
          <target state="translated">Core Data의 장점은 역 관계가 있다는 것입니다. 따라서 NotesViewController에 노트 객체를 주려면 노트와 같은 다른 객체와 역의 관계가 있기 때문에 노트 객체를 제공하십시오. NotesViewController의 노트북에 데이터가 필요한 경우 다음을 수행하여 오브젝트 그래프를 다시 걸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="014260d3b948862434b9fa2f84c8640f401e09aa" translate="yes" xml:space="preserve">
          <source>The original poster also asked about &lt;strong&gt;Singletons&lt;/strong&gt; and the use of the &lt;strong&gt;AppDelegate&lt;/strong&gt;. These questions need to be answered.</source>
          <target state="translated">원래 포스터는 또한 &lt;strong&gt;싱글 톤&lt;/strong&gt; 과 &lt;strong&gt;AppDelegate&lt;/strong&gt; 의 사용에 대해 물었습니다. 이 질문에 답해야합니다.</target>
        </trans-unit>
        <trans-unit id="4051bc4c8e14e8ba896618084a6ea2e97b0c1335" translate="yes" xml:space="preserve">
          <source>The question asks about passing information between view controllers. The specific example given asks about passing information between views, but given the self-stated newness to iOS, the original poster likely meant between viewControllers, not between views (without any involvement from the ViewControllers). It seems that all the answers focus on two view controllers, but what if the app evolves to need to involve more than two view controllers in the information exchange?</source>
          <target state="translated">이 질문은 뷰 컨트롤러간에 정보를 전달하는 방법을 묻습니다. 주어진 특정 예제는 뷰 사이에 정보를 전달하는 것에 대해 묻지 만 자체적으로 새로운 기능을 iOS에 제공하면 원래 포스터는 viewController가 아닌 viewController가 아닌 viewControllers 사이를 의미했을 가능성이 높습니다. 모든 답변이 두 개의 뷰 컨트롤러에 중점을 둔 것처럼 보이지만 앱이 정보 교환에 두 개 이상의 뷰 컨트롤러를 포함해야한다면 어떻게 될까요?</target>
        </trans-unit>
        <trans-unit id="63899f87ba40f61b456ad097f7880f169dadb468" translate="yes" xml:space="preserve">
          <source>The role of a controller is to mediate between view and model. Therefore, they need a reference to one or more view objects and one or more model objects. Let's say that your model is an array of dictionaries, with each dictionary representing one row in your table. The root view for your app displays that table, and it might be responsible for loading the array from a file. When the user decides to add a new row to the table, they tap some button and your controller creates a new (mutable) dictionary and adds it to the array. In order to fill in the row, the controller creates a detail view controller and gives it the new dictionary. The detail view controller fills in the dictionary and returns. The dictionary is already part of the model, so nothing else needs to happen.</source>
          <target state="translated">컨트롤러의 역할은 뷰와 모델을 중재하는 것입니다. 따라서 하나 이상의 뷰 객체와 하나 이상의 모델 객체에 대한 참조가 필요합니다. 모델이 사전의 배열이며 각 사전이 테이블의 한 행을 나타냅니다. 앱의 루트보기는 해당 테이블을 표시하며 파일에서 배열을로드해야 할 수도 있습니다. 사용자가 테이블에 새 행을 추가하기로 결정하면 일부 버튼을 탭하면 컨트롤러가 새로운 (변경 가능한) 사전을 만들어 배열에 추가합니다. 행을 채우기 위해 제어기는 상세보기 제어기를 작성하여 새 사전을 제공합니다. 상세도 제어기가 사전을 채우고 리턴합니다. 사전은 이미 모델의 일부이므로 다른 작업은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="862d75bb0f5e8e1bf177a0884bd45d4099f46cae" translate="yes" xml:space="preserve">
          <source>Then where you want to load the view eg. &lt;code&gt;didSelectRowAtIndex&lt;/code&gt; or some &lt;code&gt;IBAction&lt;/code&gt; you need to set the property in &lt;code&gt;ViewControllerB&lt;/code&gt; before you push it onto nav stack.</source>
          <target state="translated">그런 다음 뷰를로드하려는 위치입니다 (예 : &lt;code&gt;didSelectRowAtIndex&lt;/code&gt; 또는 일부 &lt;code&gt;IBAction&lt;/code&gt; 속성을 탐색 스택으로 푸시하기 전에 &lt;code&gt;ViewControllerB&lt;/code&gt; 에서 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5db5c8fd4b2f27895e7362cba1af3ede532b9753" translate="yes" xml:space="preserve">
          <source>There are addition tools that also help pass along data:</source>
          <target state="translated">데이터를 전달하는 데 도움이되는 추가 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="31d86b3beff40f0926f74e37f90530611aeeffd6" translate="yes" xml:space="preserve">
          <source>There are four view controllers in the application. It is a tab-based application for managing home inventory. Three view controllers present differently filtered views of the same data:</source>
          <target state="translated">애플리케이션에는 4 개의 뷰 컨트롤러가 있습니다. 주택 재고 관리를위한 탭 기반 응용 프로그램입니다. 세 개의 뷰 컨트롤러는 동일한 데이터에 대해 다르게 필터링 된 뷰를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e97a58b0ba4425fd3070b8fbcc8e0520fcec97d9" translate="yes" xml:space="preserve">
          <source>There are many answers to this questions offering many different ways to perform view controller communication that would indeed work, but I don't see anywhere mentioned which one are actually best to use and which ones to avoid.</source>
          <target state="translated">이 질문에 대한 많은 답변이 실제로 작동하는 뷰 컨트롤러 통신을 수행하는 여러 가지 방법을 제공하지만 실제로 사용하기에 가장 적합한 것과 피해야 할 것을 언급 한 곳은 없습니다.</target>
        </trans-unit>
        <trans-unit id="dbd19e78c5369d7ba92070651ccf13b36f340393" translate="yes" xml:space="preserve">
          <source>There are multiple methods for sharing data.</source>
          <target state="translated">데이터를 공유하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8c21a80ff30368c9db68fd252bbe172753c326e" translate="yes" xml:space="preserve">
          <source>There are multiple options for Passing Data between View Controllers.</source>
          <target state="translated">View Controller간에 데이터 전달에 대한 여러 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b070a9e49cdb6fb5eedc6805c49fc2267e7f279" translate="yes" xml:space="preserve">
          <source>There are three parts.</source>
          <target state="translated">세 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="960919526c1232c2ceccc14249d25e632af94356" translate="yes" xml:space="preserve">
          <source>There are tons and tons of explanations here and around StackOverflow, but if you are a beginner just trying to get something basic to work, try watching this YouTube tutorial (It's what helped me to finally understand how to do it).</source>
          <target state="translated">여기저기서 StackOverflow에 대한 많은 설명이 있지만 초보자가 작업을 위해 기본적인 것을 얻으려고한다면이 YouTube 자습서를 시청하십시오 (최종적으로 수행 방법을 이해하는 데 도움이되었습니다).</target>
        </trans-unit>
        <trans-unit id="e8afd6f06c1bbab721680e593a168e06c21f9e95" translate="yes" xml:space="preserve">
          <source>There are tons of ways to do this and it's important to pick the right one. Probably one of the biggest architectural decisions lies on how the model code will be shared or accessed throughout the app.</source>
          <target state="translated">이 작업을 수행하는 방법은 다양하며 올바른 방법을 선택하는 것이 중요합니다. 아마도 가장 큰 아키텍처 결정 중 하나는 앱 전체에서 모델 코드를 공유하거나 액세스하는 방법에 있습니다.</target>
        </trans-unit>
        <trans-unit id="add7b260a0c3a797d43225e8dd73c9d548468567" translate="yes" xml:space="preserve">
          <source>There are two view controllers in the application. There is a ViewControllerA (Data Entry Form), and View Controller B (Product List). The items selected in the product list must match the items displayed in the text box in the data entry form. In this scenario, ViewControllerA and ViewControllerB must communicate directly with each other and no other view controllers.</source>
          <target state="translated">응용 프로그램에는 두 개의 뷰 컨트롤러가 있습니다. ViewControllerA (데이터 입력 양식) 및 View Controller B (제품 목록)가 있습니다. 제품 목록에서 선택한 항목은 데이터 입력 양식의 텍스트 상자에 표시된 항목과 일치해야합니다. 이 시나리오에서 ViewControllerA와 ViewControllerB는 다른 뷰 컨트롤러가 아닌 서로 직접 통신해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ad48280e06634ee952854dfb7d646a39384f662" translate="yes" xml:space="preserve">
          <source>There are various ways by which a data can be received to a different class in iOS. For example -</source>
          <target state="translated">iOS에서 다른 클래스로 데이터를 수신하는 방법에는 여러 가지가 있습니다. 예를 들어-</target>
        </trans-unit>
        <trans-unit id="6366268fa2a29045a4f2964c6049a44dee20ec43" translate="yes" xml:space="preserve">
          <source>There is some good information in many of the answers given, but none address the question fully.</source>
          <target state="translated">주어진 많은 답변에 좋은 정보가 있지만 질문을 완전히 다루지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2244b353f7eacc064ac43be42125be2888874124" translate="yes" xml:space="preserve">
          <source>These solutions, although working in the short term, introduce too many dependencies that will garble the architecture of the app and create more problems later.</source>
          <target state="translated">이러한 솔루션은 단기적으로 작동하지만 너무 많은 종속성을 가져와 앱의 아키텍처를 손상시키고 나중에 더 많은 문제를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="4feffb40e53daab15d1fd2a31b491d1a986d94e5" translate="yes" xml:space="preserve">
          <source>This example passes data from &lt;strong&gt;Controller B&lt;/strong&gt; to &lt;strong&gt;Controller A&lt;/strong&gt;</source>
          <target state="translated">이 예는 &lt;strong&gt;컨트롤러 B&lt;/strong&gt; 에서 &lt;strong&gt;컨트롤러 A로&lt;/strong&gt; 데이터를 전달합니다 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72942e4d622ebca94f54d92fc991209dbbc62e1b" translate="yes" xml:space="preserve">
          <source>This is a very simple view layout with a segue between them.</source>
          <target state="translated">이것은 그들 사이에 segue가있는 매우 간단한 뷰 레이아웃입니다.</target>
        </trans-unit>
        <trans-unit id="dc585b46d7fdc70eda1e5bd71fce0fb21a21baaf" translate="yes" xml:space="preserve">
          <source>This is not the way to do it, you should use delegates, I'll assume we have two view controllers ViewController1 and ViewController2 and this check thing is in the first one and when its state changes, you want to do something in ViewController2, to achieve that in the proper way, you should do the below:</source>
          <target state="translated">이것은 그것을하는 방법이 아니며, 대리자를 사용해야합니다 .ViewController1과 ViewController2라는 두 개의 뷰 컨트롤러가 있다고 가정 하고이 검사는 첫 번째 컨트롤러 상태이며 상태가 변경되면 ViewController2에서 무언가를하고 싶습니다. 올바른 방법으로 달성하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8073a2ecfc42ee7250cf1e560c182673934a6f7f" translate="yes" xml:space="preserve">
          <source>This page just sends the value of the variable to the console when it loads.  By this point, our favorite movie should be in that variable.</source>
          <target state="translated">이 페이지는 변수가로드 될 때 변수 값을 콘솔로 보냅니다. 이 시점에서 가장 좋아하는 영화는 해당 변수에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="53aebdd79abe6d5b1bdd1f334b4ef03089ec8441" translate="yes" xml:space="preserve">
          <source>This page takes the initially loaded value and passes it along.</source>
          <target state="translated">이 페이지는 처음에로드 된 값을 가져 와서 전달합니다.</target>
        </trans-unit>
        <trans-unit id="7c7f8bc26f34edac64e4f9e9a10d6758f2fd6803" translate="yes" xml:space="preserve">
          <source>This question seems to be very popular here on stackoverflow so I thought I would try and give a better answer to help out people starting in the world of iOS like me.</source>
          <target state="translated">이 질문은 stackoverflow에서 매우 인기가있는 것 같습니다. 저와 같은 iOS 세계에서 시작하는 사람들을 돕기 위해 더 나은 답변을 줄 것이라고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="17b7883c0d9c134005d8b98f4a635cdcdce103d0" translate="yes" xml:space="preserve">
          <source>This second example shows passing a callback block for the second argument.  I like using blocks because it keeps the relevant details close together in the source - the higher level source.</source>
          <target state="translated">이 두 번째 예는 두 번째 인수에 대한 콜백 블록 전달을 보여줍니다. 블록을 사용하는 것이 좋습니다. 상위 레벨 소스 인 소스에서 관련 세부 정보를 가깝게 유지하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5f05e53b88ac8f87becf055c72279b70a06d25c6" translate="yes" xml:space="preserve">
          <source>This will set &lt;code&gt;isSomethingEnabled&lt;/code&gt; in &lt;code&gt;ViewControllerB&lt;/code&gt; to &lt;code&gt;BOOL&lt;/code&gt; value &lt;code&gt;YES&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ViewControllerB&lt;/code&gt; 에서 &lt;code&gt;isSomethingEnabled&lt;/code&gt; 가 &lt;code&gt;BOOL&lt;/code&gt; 값 &lt;code&gt;YES&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="702efc9cba1bbd3afb5e2a9f9ce7d9ec865cbd29" translate="yes" xml:space="preserve">
          <source>Those were  discussed here already.</source>
          <target state="translated">그것들은 이미 여기에서 논의되었습니다.</target>
        </trans-unit>
        <trans-unit id="83ec681c5928fb675fe4016bcba307422f910286" translate="yes" xml:space="preserve">
          <source>To do this we will make &lt;code&gt;ViewControllerA&lt;/code&gt; a delegate of &lt;code&gt;ViewControllerB&lt;/code&gt;. This allows &lt;code&gt;ViewControllerB&lt;/code&gt; to send a message back to &lt;code&gt;ViewControllerA&lt;/code&gt; enabling us to send data back.</source>
          <target state="translated">이를 위해 &lt;code&gt;ViewControllerA&lt;/code&gt; 를 ViewControllerB 의 대리자로 만듭니다. 이를 통해 &lt;code&gt;ViewControllerB&lt;/code&gt; 는 ViewControllerA 로 메시지를 다시 보내서 데이터를 다시 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3555496de4df0b39a8ca1903be2fae52ab2bbaf3" translate="yes" xml:space="preserve">
          <source>To help anyone else looking at this question, who wants a full answer, I'm going to attempt to provide it.</source>
          <target state="translated">전체 답변을 원하는 다른 사람이이 질문을 볼 수 있도록 돕기 위해 노력하겠습니다.</target>
        </trans-unit>
        <trans-unit id="86f2cf886389b424cfb810b4716cc6f04bb3d86b" translate="yes" xml:space="preserve">
          <source>To pass a &lt;code&gt;BOOL&lt;/code&gt; value from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; we would do the following.</source>
          <target state="translated">&lt;code&gt;ViewControllerA&lt;/code&gt; 에서 ViewControllerB 로 &lt;code&gt;BOOL&lt;/code&gt; 값을 전달하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="76a9d2c2e66054b80996174e8affc8b1fb823ba9" translate="yes" xml:space="preserve">
          <source>To pass data back from &lt;code&gt;ViewControllerB&lt;/code&gt; to &lt;code&gt;ViewControllerA&lt;/code&gt; you need to use &lt;em&gt;Protocols and Delegates&lt;/em&gt; or &lt;em&gt;Blocks&lt;/em&gt;, the latter can be used as a loosely coupled mechanism for callbacks.</source>
          <target state="translated">&lt;code&gt;ViewControllerB&lt;/code&gt; 에서 ViewControllerA 로 데이터를 다시 전달하려면 &lt;em&gt;Protocols 및 Delegates&lt;/em&gt; 또는 &lt;em&gt;Blocks&lt;/em&gt; 를 사용해야합니다. 후자는 콜백을위한 느슨하게 결합 된 메커니즘으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d70b08f9dc80f74d10c82b4cd60670d8719e71" translate="yes" xml:space="preserve">
          <source>To pass data back from the second view controller to the first view controller, you use &lt;a href=&quot;https://stackoverflow.com/a/33549729/3681880&quot;&gt;a protocol and a delegate&lt;/a&gt;. This video is a very clear walk though of that process:</source>
          <target state="translated">두 번째 뷰 컨트롤러에서 첫 번째 뷰 컨트롤러로 데이터를 다시 전달하려면 &lt;a href=&quot;https://stackoverflow.com/a/33549729/3681880&quot;&gt;프로토콜과 델리게이트&lt;/a&gt; 를 사용 합니다 . 이 비디오는 그 과정을 통해 매우 분명한 걸음입니다.</target>
        </trans-unit>
        <trans-unit id="af916557c74c3f51d623fa988c413ad3e34f0d4f" translate="yes" xml:space="preserve">
          <source>To pass data backwards</source>
          <target state="translated">데이터를 뒤로 전달하려면</target>
        </trans-unit>
        <trans-unit id="4441e2165a2cbe180a97d71650d577cbf837d6f0" translate="yes" xml:space="preserve">
          <source>To pass data forward:</source>
          <target state="translated">데이터를 전달하려면</target>
        </trans-unit>
        <trans-unit id="7c739773a6d176365e02604ef2ba8b5fd773295f" translate="yes" xml:space="preserve">
          <source>To pass multiple values you can use the multiple parameters like :-</source>
          <target state="translated">여러 값을 전달하려면 다음과 같은 여러 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f53c9cc79789d2d8364b25f78aa09dd33f52a64" translate="yes" xml:space="preserve">
          <source>Understanding the Core Architectural Principles of iOS Development with a Practical Example</source>
          <target state="translated">실제 사례를 사용하여 iOS 개발의 핵심 아키텍처 원칙 이해</target>
        </trans-unit>
        <trans-unit id="df0a8289feb92488ac5fae24f2db741969a2acff" translate="yes" xml:space="preserve">
          <source>User defaults</source>
          <target state="translated">사용자 기본값</target>
        </trans-unit>
        <trans-unit id="c2f8f14f958b77389a48a3fc1d929fbaf7455857" translate="yes" xml:space="preserve">
          <source>Using Block</source>
          <target state="translated">블록 사용</target>
        </trans-unit>
        <trans-unit id="35e87779d93205c9cdc86bc39ef7d0b7dce13230" translate="yes" xml:space="preserve">
          <source>Using Delegate</source>
          <target state="translated">델리게이트 사용</target>
        </trans-unit>
        <trans-unit id="73cc3f60dc8287f62aa63d4644544e391cbe3bb3" translate="yes" xml:space="preserve">
          <source>Using Navigation Controller Push</source>
          <target state="translated">네비게이션 컨트롤러 푸시 사용</target>
        </trans-unit>
        <trans-unit id="52e7b3127ded3378ce3725c8ccc384212ac615ad" translate="yes" xml:space="preserve">
          <source>Using Notification Observer</source>
          <target state="translated">알림 관찰자 사용</target>
        </trans-unit>
        <trans-unit id="02bbe182682f0bbed6aeec5deb6f00b94667bbc3" translate="yes" xml:space="preserve">
          <source>Using Segue</source>
          <target state="translated">Segue 사용</target>
        </trans-unit>
        <trans-unit id="0d6f7bc3f49a828edf12dd0581aaa92e4ef44e6e" translate="yes" xml:space="preserve">
          <source>ViewControllerA - Luxury Items</source>
          <target state="translated">ViewControllerA-럭셔리 아이템</target>
        </trans-unit>
        <trans-unit id="e5ffea5e8eb8d723ab0498aa5a4d88e881a60886" translate="yes" xml:space="preserve">
          <source>ViewControllerB - Non-insured Items</source>
          <target state="translated">ViewControllerB-비보험 품목</target>
        </trans-unit>
        <trans-unit id="e7a39785336a96e44901846cba211ded9e0abc2e" translate="yes" xml:space="preserve">
          <source>ViewControllerC - Entire Home Inventory</source>
          <target state="translated">ViewControllerC-집 전체 재고</target>
        </trans-unit>
        <trans-unit id="135d305cf4a08db515d94b35f7f6f4250be7f807" translate="yes" xml:space="preserve">
          <source>ViewControllerD - Add New Item Form</source>
          <target state="translated">ViewControllerD-새 항목 양식 추가</target>
        </trans-unit>
        <trans-unit id="81942d9a4347a174680fafdd5ec8b8b344284237" translate="yes" xml:space="preserve">
          <source>We are keeping this simple so no buttons, not actions, we are simply moving data from the sender to the receiver when the application loads and then outputting the transmitted value to the console.</source>
          <target state="translated">우리는이 작업을 간단하게 수행하지 않고 버튼을 사용하지 않고 응용 프로그램이로드 될 때 발신자에서 수신자로 데이터를 이동 한 다음 전송 된 값을 콘솔에 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ff03a716d90bbf29f516cac4b83abbaba194bc8c" translate="yes" xml:space="preserve">
          <source>We can understand it using two controllers - &lt;strong&gt;Controller1 and Controller2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Controller1과 Controller2의&lt;/strong&gt; 두 컨트롤러를 사용하여 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f75d1fd3c3fa39412cf75f97e5bcfb258a2d5a9" translate="yes" xml:space="preserve">
          <source>Well &lt;a href=&quot;https://stackoverflow.com/a/9736559/1371853&quot;&gt;Matt Price's Answer&lt;/a&gt; is perfectly fine for passing data but I
  am going to rewrite it, in Latest Swift version because I believe new
  programmers find it quit challenging due to new Syntax and
  methods/frameworks, as original post is in Objective-C.</source>
          <target state="translated">Well &lt;a href=&quot;https://stackoverflow.com/a/9736559/1371853&quot;&gt;Matt Price의 답변&lt;/a&gt; 은 데이터 전달에 완벽하게 적합하지만 최신 프로그래머 버전은 원래 게시물이 Objective-C에 있기 때문에 새로운 프로그래머가 새로운 구문 및 메소드 / 프레임 워크로 인해 도전을 끝내기 때문에 최신 Swift 버전에서 다시 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="95ed8045cbbb7af3a960ea88cfa49e1488ceac17" translate="yes" xml:space="preserve">
          <source>What would be the correct way of performing this and how would I go about it?</source>
          <target state="translated">이것을 수행하는 올바른 방법은 무엇이며 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="8a4e940579167cf02a3ba46b206936601e18844d" translate="yes" xml:space="preserve">
          <source>When the collection of home inventory items changes, the view controllers need to be made aware of this change. The class definition above does not make it obvious how this will happen. We need to follow the observer pattern. The view controllers must formally observe the sharedManager. There are two ways to observe another object:</source>
          <target state="translated">주택 재고 품목의 수집이 변경 될 때 뷰 컨트롤러는이 변경을 인식해야합니다. 위의 클래스 정의는 이것이 어떻게 일어날 지 명확하게하지 않습니다. 관찰자 패턴을 따라야합니다. 뷰 컨트롤러는 공식적으로 sharedManager를 관찰해야합니다. 다른 물체를 관찰하는 두 가지 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d89b94ecc160001694e602dfbde749a28101857f" translate="yes" xml:space="preserve">
          <source>With UINavigators and segues, there are easy ways of passing information to the subservient controller and getting the information back.  ARC makes passing pointers to things derived from NSObjects simple so if you want the subservient controller to add/change/modify some data for you, pass it a pointer to a mutable instance.  Blocks make passing actions easy so if you want the subservient controller to invoke an action on your higher level controller, pass it a block.  You define the block to accept any number of arguments that makes sense to you.  You can also design the API to use multiple blocks if that suits things better.</source>
          <target state="translated">UINavigators 및 segue를 사용하면 하위 하위 컨트롤러에 정보를 전달하고 정보를 다시 가져올 수있는 쉬운 방법이 있습니다. ARC는 NSObjects에서 파생 된 것들에 대한 포인터를 간단하게 전달하므로 보조 서브 컨트롤러가 일부 데이터를 추가 / 변경 / 수정하도록하려면 가변 인스턴스에 대한 포인터를 전달하십시오. 블록은 전달 조치를 쉽게 만들어 보조 서브 컨트롤러가 상위 레벨 제어기에서 조치를 호출하도록하려면 블록을 전달하십시오. 자신에게 맞는 여러 개의 인수를 허용하도록 블록을 정의합니다. 여러 블록이 더 적합한 경우 여러 블록을 사용하도록 API를 디자인 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb4193cf6b58cbdb5fa018799e8c3e460fd383dc" translate="yes" xml:space="preserve">
          <source>Worked fine and allowed me to pass a string and an array forward and back between my views.</source>
          <target state="translated">잘 작동하여 뷰와 뷰 사이에서 문자열과 배열을 앞뒤로 전달할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="27deb3303dc171f62381c3af6e857bbf1acf83bb" translate="yes" xml:space="preserve">
          <source>You can also create custom delegates for this.</source>
          <target state="translated">이를 위해 사용자 지정 대리자를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a3ff3057c97981bf35a32f3b4007efceb28f6a3" translate="yes" xml:space="preserve">
          <source>You can also directly set the properties of the Controller2 class in the similar way as this:</source>
          <target state="translated">다음과 유사한 방식으로 Controller2 클래스의 속성을 직접 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9e418ef389cb9594cfd0c613d54195e941dba88" translate="yes" xml:space="preserve">
          <source>You can always share data using &lt;code&gt;NSUserDefaults&lt;/code&gt;. Set the value you want to share with respect to a key of your choice and get the value from &lt;code&gt;NSUserDefault&lt;/code&gt; associated to that key in the next view controller.</source>
          <target state="translated">&lt;code&gt;NSUserDefaults&lt;/code&gt; 를 사용하여 항상 데이터를 공유 할 수 있습니다. 선택한 키와 관련하여 공유하려는 값을 설정하고 다음보기 컨트롤러에서 해당 키와 연관된 &lt;code&gt;NSUserDefault&lt;/code&gt; 의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a7d7d2e500cdd3b21928259a0c992d9c6ea65145" translate="yes" xml:space="preserve">
          <source>You can just create a property in &lt;code&gt;viewcontrollerA&lt;/code&gt;. Create an object of &lt;code&gt;viewcontrollerA&lt;/code&gt; in &lt;code&gt;viewcontrollerB&lt;/code&gt; and assign the desired value to that property.</source>
          <target state="translated">&lt;code&gt;viewcontrollerA&lt;/code&gt; 에서 속성을 만들 수 있습니다. &lt;code&gt;viewcontrollerA&lt;/code&gt; 에 &lt;code&gt;viewcontrollerB&lt;/code&gt; 의 객체를 생성하고 원하는 값을 해당 속성에 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="abfb49ee8dd0bcc5f71fa827feb6ceb49bd14bd1" translate="yes" xml:space="preserve">
          <source>You can save data in App delegate to access it across view controllers in your application. All you have to do is create a shared instance of app delegate</source>
          <target state="translated">앱 대리자에 데이터를 저장하여 애플리케이션의 뷰 컨트롤러에서 액세스 할 수 있습니다. 앱 델리게이트의 공유 인스턴스를 생성하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="576941d1618435efb4e91b03c919b15afddc8a68" translate="yes" xml:space="preserve">
          <source>You setup all your views in .XIB files and register them in the app delegate, while initializing the factory.</source>
          <target state="translated">팩토리를 초기화하는 동안 모든보기를 .XIB 파일로 설정하고 앱 델리게이트에 등록합니다.</target>
        </trans-unit>
        <trans-unit id="1e2fbc115bc2af08bed183bab4b31314c65a2dc1" translate="yes" xml:space="preserve">
          <source>YouTube tutorial: &lt;a href=&quot;https://www.youtube.com/watch?v=9LHDsSWc680&quot;&gt;iOS Swift Basics Tutorial: Protocols and Delegates&lt;/a&gt; But also read &lt;a href=&quot;http://krakendev.io/blog/weak-and-unowned-references-in-swift&quot;&gt;this post&lt;/a&gt; to make sure you don't get into a strong reference cycle.</source>
          <target state="translated">YouTube 자습서 : &lt;a href=&quot;https://www.youtube.com/watch?v=9LHDsSWc680&quot;&gt;iOS Swift Basics 자습서 : 프로토콜 및 대리인&lt;/a&gt; 뿐만 아니라이 &lt;a href=&quot;http://krakendev.io/blog/weak-and-unowned-references-in-swift&quot;&gt;게시물&lt;/a&gt; 을 읽고 강력한 참조주기에 빠지지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="72d5f33455747500ff0e39389f26e2a366965ae1" translate="yes" xml:space="preserve">
          <source>YouTube tutorial: &lt;a href=&quot;https://www.youtube.com/watch?v=Kpwrc1PRDsg&quot;&gt;How to send data through segue (swift)&lt;/a&gt;</source>
          <target state="translated">YouTube 자습서 : &lt;a href=&quot;https://www.youtube.com/watch?v=Kpwrc1PRDsg&quot;&gt;segue를 통해 데이터를 보내는 방법 (빠른)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd92b6a59301aaf7df021b06434d7fd97281c993" translate="yes" xml:space="preserve">
          <source>and &quot;B&quot; view controller should declare callback property, BViewController.h:</source>
          <target state="translated">&quot;B&quot;뷰 컨트롤러는 콜백 속성 BViewController.h를 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="d22cdc632e153fe14ede39b227947423e9ef48b1" translate="yes" xml:space="preserve">
          <source>and in FirstViewController.h :</source>
          <target state="translated">그리고 FirstViewController.h에서 :</target>
        </trans-unit>
        <trans-unit id="1303845f47ba68fca8499482aa29a0b1ca63c1c8" translate="yes" xml:space="preserve">
          <source>click on the button and drag over to the Second View Controller.</source>
          <target state="translated">버튼을 클릭하고 두 번째 뷰 컨트롤러로 드래그하십시오.</target>
        </trans-unit>
        <trans-unit id="edb401d8d776a314f5a6c4744d5c898beb932df9" translate="yes" xml:space="preserve">
          <source>delegates</source>
          <target state="translated">delegates</target>
        </trans-unit>
        <trans-unit id="071cd75033ae8e8688a44265cb1850670988a924" translate="yes" xml:space="preserve">
          <source>do these in ViewControlerOne.h</source>
          <target state="translated">ViewControlerOne.h에서 이것을하십시오</target>
        </trans-unit>
        <trans-unit id="d2c16f26c821a75d79d3c762d88ff8151b2cef90" translate="yes" xml:space="preserve">
          <source>do these in ViewControlerOne.m</source>
          <target state="translated">ViewControlerOne.m 에서이 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4ab7cc959e41e827a458876138723cac6658ff71" translate="yes" xml:space="preserve">
          <source>do these in ViewControllerTwo.h</source>
          <target state="translated">ViewControllerTwo.h 에서이 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="537d8d6119fe77d8b87bdfec992c7335ce2c30a3" translate="yes" xml:space="preserve">
          <source>do these in ViewControllerTwo.m</source>
          <target state="translated">ViewControllerTwo.m 에서이 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="78f6225c0a29d685123f4713fb8d64650c5d455a" translate="yes" xml:space="preserve">
          <source>drag from the button to the Second View Controller. Set the segue identifier to &lt;code&gt;showSecondViewController&lt;/code&gt;. Also, don't forget to hook up the outlets and actions using the names in the following code.</source>
          <target state="translated">버튼에서 두 번째 뷰 컨트롤러로 드래그하십시오. segue 식별자를 &lt;code&gt;showSecondViewController&lt;/code&gt; 로 설정하십시오. 또한 다음 코드의 이름을 사용하여 콘센트와 작업을 연결하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e89c71751ece180f696d67c4cc55aff1a2e78a1b" translate="yes" xml:space="preserve">
          <source>expecting that your &lt;code&gt;CustomObject&lt;/code&gt; must have a setter function with it.</source>
          <target state="translated">&lt;code&gt;CustomObject&lt;/code&gt; 에 setter 함수가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9a601619d63281ffad7a5e7742ff3e95493c069d" translate="yes" xml:space="preserve">
          <source>if you declare a &lt;code&gt;NSArray object *arrayXYZ&lt;/code&gt; then you can access it in any view controller by &lt;code&gt;appDelegate.arrayXYZ&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NSArray object *arrayXYZ&lt;/code&gt; 를 선언하면 appDelegate.arrayXYZ 를 통해 모든 뷰 컨트롤러에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="782fff5ac840ff68307a9fc122193c5707e4c512" translate="yes" xml:space="preserve">
          <source>if you wants to pass data from ViewControlerOne to ViewControllerTwo try these..</source>
          <target state="translated">ViewControlerOne에서 ViewControllerT로 데이터를 전달하려면 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="be71d332d065bfca5adcf4764b2e5dcf0067a681" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;ViewControllerA&lt;/code&gt; you need to tell it about &lt;code&gt;ViewControllerB&lt;/code&gt; so use an</source>
          <target state="translated">&lt;code&gt;ViewControllerA&lt;/code&gt; 에서 ViewControllerB에 대해 알려 주어야하므로</target>
        </trans-unit>
        <trans-unit id="65b58b2b8602f0dcd3e15e13e48c2cf1071404f5" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;ViewControllerB.h&lt;/code&gt; create a property for the &lt;code&gt;BOOL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ViewControllerB.h&lt;/code&gt; 에서 &lt;code&gt;BOOL&lt;/code&gt; 에 대한 속성을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="99069faddac71d51fb4234f0748c9713172c03f9" translate="yes" xml:space="preserve">
          <source>in ViewController.h</source>
          <target state="translated">ViewController.h에서</target>
        </trans-unit>
        <trans-unit id="131175d1468a88ef378a2491456c5cb0422143b7" translate="yes" xml:space="preserve">
          <source>in ViewController.m</source>
          <target state="translated">ViewController.m에서</target>
        </trans-unit>
        <trans-unit id="be71d06d1de5c0a0fdb2be6af089b062df524e57" translate="yes" xml:space="preserve">
          <source>in implementation file you can implement the function</source>
          <target state="translated">구현 파일에서 함수를 구현할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a4325deae2d4ec787216962c095e8ecd5c3486e6" translate="yes" xml:space="preserve">
          <source>next still in the &lt;code&gt;ViewControllerB.h&lt;/code&gt; you need to setup a &lt;code&gt;delegate&lt;/code&gt; property and synthesize in &lt;code&gt;ViewControllerB.m&lt;/code&gt;</source>
          <target state="translated">다음으로 &lt;code&gt;ViewControllerB.h&lt;/code&gt; 에서 &lt;code&gt;delegate&lt;/code&gt; 속성을 설정하고 &lt;code&gt;ViewControllerB.m&lt;/code&gt; 에서 합성해야합니다.</target>
        </trans-unit>
        <trans-unit id="386cbb45fb634a4cc7cc5f0d2dd999b1d4e98035" translate="yes" xml:space="preserve">
          <source>now your basic work is done. go to the place where you want to push the &lt;code&gt;SecondViewController&lt;/code&gt; and do the following stuff</source>
          <target state="translated">이제 기본 작업이 완료되었습니다. &lt;code&gt;SecondViewController&lt;/code&gt; 를 푸시하려는 위치로 이동하여 다음 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="37f0c63aa5984813b557482775d277cd538c0cde" translate="yes" xml:space="preserve">
          <source>on the buttons click event do this..</source>
          <target state="translated">버튼 클릭 이벤트에서이 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="46a5e3a49371630a136eb9da775d08eb729e16f4" translate="yes" xml:space="preserve">
          <source>override the &lt;code&gt;prepare(for:sender:)&lt;/code&gt; method of &lt;code&gt;UIViewController&lt;/code&gt; when using a storyboard and segues</source>
          <target state="translated">스토리 보드 및 segues를 사용할 때 &lt;code&gt;UIViewController&lt;/code&gt; 의 &lt;code&gt;prepare(for:sender:)&lt;/code&gt; 메소드 를 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d25f70727ad257203a7cb4eb327698d18e7aa99" translate="yes" xml:space="preserve">
          <source>pass data through an initializer or through properties when performing view controller transitions thtough code</source>
          <target state="translated">코드를 통해 뷰 컨트롤러 전환을 수행 할 때 이니셜 라이저 또는 속성을 통해 데이터 전달</target>
        </trans-unit>
        <trans-unit id="7311cc1f0f20c0620db17343ab40307e824143ea" translate="yes" xml:space="preserve">
          <source>segues</source>
          <target state="translated">segues</target>
        </trans-unit>
        <trans-unit id="7f2d647110dc98a6cf4ef95feec7e141e6b5b5d7" translate="yes" xml:space="preserve">
          <source>setting properties on view controllers directly</source>
          <target state="translated">뷰 컨트롤러에서 직접 속성 설정</target>
        </trans-unit>
        <trans-unit id="9e37ace74b364d63001657a8ab63e157a0a748b9" translate="yes" xml:space="preserve">
          <source>so we can pass this value in second class using below step</source>
          <target state="translated">아래 단계를 사용하여 두 번째 클래스 에서이 값을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1760ac8cee45ff111cddcf3355ccffae7b6192" translate="yes" xml:space="preserve">
          <source>then change its definition to</source>
          <target state="translated">그런 다음 정의를 다음으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e61eda4f8db1e4d3af098df52ca88723ae4b33e4" translate="yes" xml:space="preserve">
          <source>update the app shared state (which you can pass forward between view controllers with either one of the methods above)</source>
          <target state="translated">앱 공유 상태 업데이트 (위의 방법 중 하나를 사용하여 뷰 컨트롤러간에 전달할 수 있음)</target>
        </trans-unit>
        <trans-unit id="5edd9def88440cf132c20a45c93726634b543a58" translate="yes" xml:space="preserve">
          <source>use an unwind segue</source>
          <target state="translated">긴장을 풀다</target>
        </trans-unit>
        <trans-unit id="1089f6b4bab9307f50a4d74cae6292d00032982e" translate="yes" xml:space="preserve">
          <source>use delegation</source>
          <target state="translated">위임 사용</target>
        </trans-unit>
        <trans-unit id="4f77b4fd6e2ebd82da33ee94540fe10ea274781f" translate="yes" xml:space="preserve">
          <source>use it in the &lt;code&gt;prepareForSegue&lt;/code&gt; method in the VC1</source>
          <target state="translated">VC1의 &lt;code&gt;prepareForSegue&lt;/code&gt; 메소드에서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3397791b6f7f7ea840ba49d831f7e5f45f3ad769" translate="yes" xml:space="preserve">
          <source>var authorizationCompletionBlock:((Bool)-&amp;gt;())? = {_ in}</source>
          <target state="translated">var authorizationCompletionBlock : ((Bool)-&amp;gt; ())? = {_ in}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
