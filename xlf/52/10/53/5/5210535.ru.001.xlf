<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/5210535">
    <body>
      <group id="5210535">
        <trans-unit id="5128e9d8380cba42898da6b0b4c094f182f31368" translate="yes" xml:space="preserve">
          <source>1&amp;gt;We need to crate string object in SecondViewController.h file</source>
          <target state="translated">1&amp;gt; Нам нужно создать строковый объект в файле SecondViewController.h</target>
        </trans-unit>
        <trans-unit id="382568f3d5638e45d07eaa2ba4e79626c6e35495" translate="yes" xml:space="preserve">
          <source>2&amp;gt;Need to declare property as below below declaration in .h file</source>
          <target state="translated">2&amp;gt; Необходимо объявить свойство, как показано ниже в декларации в файле .h</target>
        </trans-unit>
        <trans-unit id="ca8fae13e1609c64d729ca50adc43575fd915a5d" translate="yes" xml:space="preserve">
          <source>3&amp;gt;Need synthesize that value in FirstViewController.m file below header declaration</source>
          <target state="translated">3&amp;gt; Необходимо синтезировать это значение в файле FirstViewController.m ниже объявления заголовка</target>
        </trans-unit>
        <trans-unit id="7e6c2732929d97145ee56f3dbef06b5bd1d4b710" translate="yes" xml:space="preserve">
          <source>4 lines of code inside the method and you are done.</source>
          <target state="translated">4 строки кода внутри метода и все готово.</target>
        </trans-unit>
        <trans-unit id="12af7e16d59d006e71a07aade88fd2f960f7d040" translate="yes" xml:space="preserve">
          <source>4&amp;gt;In FirstViewController,From which method we navigate to second view please write below code in that method.</source>
          <target state="translated">4&amp;gt; В FirstViewController, из какого метода мы переходим ко второму виду, пожалуйста, напишите ниже код в этом методе.</target>
        </trans-unit>
        <trans-unit id="8e9441a605f9f93f88f097003026bbcbdb4e55b8" translate="yes" xml:space="preserve">
          <source>:) Cheers.</source>
          <target state="translated">:)Спасибо.</target>
        </trans-unit>
        <trans-unit id="c7e0fd5894134e3a798732701f0ee5582c0e8363" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ManagingDataFlowBetweenViewControllers/ManagingDataFlowBetweenViewControllers.html#//apple_ref/doc/uid/TP40007457-CH8-SW9&quot;&gt;Using Delegation to Communicate With Other View Controllers&lt;/a&gt; in the &lt;em&gt;View Controller Programming Guide&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ManagingDataFlowBetweenViewControllers/ManagingDataFlowBetweenViewControllers.html#//apple_ref/doc/uid/TP40007457-CH8-SW9&quot;&gt;Использование делегирования для связи с другими контроллерами представления&lt;/a&gt; в &lt;em&gt;Руководстве по программированию контроллера представления&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9cddb9f240b7be5a6c0e6206779adba0c54ad320" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.iphonedevsdk.com/forum/iphone-sdk-development/54859-sharing-data-between-view-controllers-other-objects.html&quot;&gt;Sharing data between view controllers and other objects&lt;/a&gt; @ iPhone Dev SDK</source>
          <target state="translated">&lt;a href=&quot;http://www.iphonedevsdk.com/forum/iphone-sdk-development/54859-sharing-data-between-view-controllers-other-objects.html&quot;&gt;Обмен данными между контроллерами представления и другими объектами&lt;/a&gt; @ iPhone Dev SDK</target>
        </trans-unit>
        <trans-unit id="a561b48e56f3bead23ac829c64c64003e3095e17" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/RamdhanChoudhary/A-Simple-iOS-App-for-Passing-Data-Between-Controllers-in-Swift&quot;&gt;You can find complete sample Application at my GitHub&lt;/a&gt; Please let me know if you have any question(s) on this.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/RamdhanChoudhary/A-Simple-iOS-App-for-Passing-Data-Between-Controllers-in-Swift&quot;&gt;Вы можете найти полный образец приложения на моем GitHub.&lt;/a&gt; Пожалуйста, дайте мне знать, если у вас есть какие-либо вопросы по этому вопросу.</target>
        </trans-unit>
        <trans-unit id="4a01486c528ad5e980ae4089d498cd8c88f97fa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@synthesize  indexNumber;&lt;/code&gt;           in NextVC.m</source>
          <target state="translated">&lt;code&gt;@synthesize indexNumber;&lt;/code&gt; в NextVC.m</target>
        </trans-unit>
        <trans-unit id="b78c51f4a043a824f5e08ef6eaf7ecfb3f33270d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Blocks are anonymous functions.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Блоки являются анонимными функциями.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1021f754895d902d9dddaf8f14272d74668e6de6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Using Block callbacks:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;-Использование блокировки обратных вызовов:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c37f6c389f441f0686ad2157cb488b1e89332e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Using storyboards Unwind (Exit)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;-Использование раскадровки Unwind (Выход)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f6e3b19fd1dae9c65f2307816e0fe1c6c694e84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt; Create the instance of first View Controller in the second View Controller and make its property &lt;code&gt;@property (nonatomic,assign)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt; Создайте экземпляр первого View Controller во втором View Controller и &lt;code&gt;@property (nonatomic,assign)&lt;/code&gt; ему свойство @property (nonatomic, assign) .</target>
        </trans-unit>
        <trans-unit id="caa8b857bce2edcc30a0b3967af6102ff7c4e3cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt; Assign the &lt;code&gt;SecondviewController&lt;/code&gt; instance of this view controller.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt; Назначьте экземпляр &lt;code&gt;SecondviewController&lt;/code&gt; этого контроллера представления.</target>
        </trans-unit>
        <trans-unit id="c1ab9d883587e24a8d31adae458d2e6b60264d54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt; When you finish the selection operation copy the array to first View Controller,When u unload the SecondView ,FirstView will hold the Array Data.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt; Когда вы закончите операцию выбора, скопируйте массив в первый View Controller. Когда вы выгрузите SecondView, FirstView будет содержать данные массива.</target>
        </trans-unit>
        <trans-unit id="69324ef579d371a172a46ed3433537adafdd0323" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Application Scenarios&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сценарии применения&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19d3c711e8278b4bcb9dc5b3925628e10a4961cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't forget&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Не забывай&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55779cd52cf0b0e46e2fe75e0ae7c25906301bd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First View Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Контроллер первого вида&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c0c0b273313e9e6e2211fefaab5837fd17c6153" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Например&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c300eb69852a39b53d39a423e83febc84bb7ecf5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Go to Controller B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Перейти к контроллеру B&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd3b42b839c0fa27211813e4f7a2b41b323efb59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NSNotification center&lt;/strong&gt;
It's another way to pass data.</source>
          <target state="translated">&lt;strong&gt;NSNotification Center&lt;/strong&gt; Это еще один способ передачи данных.</target>
        </trans-unit>
        <trans-unit id="f83086999fd5c7eccf89cda212980e525c8ee244" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsDetailViewController.h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsDetailViewController.h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2e498d6299003ee4bb995fd064cfff0f5031dd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsDetailViewController.m&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsDetailViewController.m&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="170aa6c3a45436cad64cb27754574f9f66c7007d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsViewController&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsViewController&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fcf13efd0f4fde8b8e30afec77961f30fe04bf16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Back&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Передача данных назад&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4056ba2648992080e38f34e858850a2675ff28c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Forward using Segues&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Передача данных вперед с использованием сегментов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="806df0e91c6a17443dc044857cd2e12e700908c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Forward&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Передача данных вперед&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a823b2509776072df9c2f284478ab9d56976c87d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data back from one class to another&lt;/strong&gt; (A class can be any controller, Network/session manager, UIView subclass or any other class)</source>
          <target state="translated">&lt;strong&gt;Передача данных обратно из одного класса в другой&lt;/strong&gt; (классом может быть любой контроллер, менеджер сети / сеанса, подкласс UIView или любой другой класс)</target>
        </trans-unit>
        <trans-unit id="3a2d4f96ca3cdcbd2c5729cfeeddcfe8a83ef0da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data between FirstViewController to SecondViewController as below&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Передача данных между FirstViewController в SecondViewController, как показано ниже&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1633208f374584ce5b10f1cf78b22a2eeba7eee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Block&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Передача данных через блок&lt;/strong&gt; : &lt;em&gt;из ViewControllerB в ViewControllerA&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="024c5395573bc2998ff2187cbf90e249d2fd7f30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Delegate&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Передача данных через делегат&lt;/strong&gt; : &lt;em&gt;из ViewControllerB в ViewControllerA&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c82eb764b54c062d5349bd59c7a3fb7fcbc641b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Navigation Controller Push&lt;/strong&gt; : &lt;em&gt;From ViewControllerA to ViewControllerB&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Передача данных через контроллер навигации Push&lt;/strong&gt; : &lt;em&gt;из ViewControllerA в ViewControllerB&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55db90aacfef6b7797ad7a5da078395659732e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Notification Observer&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Передача данных через Notification Observer&lt;/strong&gt; : &lt;em&gt;из ViewControllerB в ViewControllerA&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0561e6d1d3b1f23d57d8291ca2684d08bcde0b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Segue&lt;/strong&gt; : &lt;em&gt;From ViewControllerA to ViewControllerB&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Передача данных через Segue&lt;/strong&gt; : &lt;em&gt;из ViewControllerA в ViewControllerB&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf80e7bc29bfca96a73722d3c8c419ee4f8a9df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scenario one:&lt;/strong&gt; maximum two view controllers ever need to share information.
See diagram one.</source>
          <target state="translated">&lt;strong&gt;Сценарий первый:&lt;/strong&gt; максимум два контроллера представления когда-либо должны обмениваться информацией. Смотрите диаграмму один.</target>
        </trans-unit>
        <trans-unit id="b5cb92a49a24b197803d86b1055b30b5711cba2a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scenario two&lt;/strong&gt;: more than two view controllers need to share the same information.
See diagram two.</source>
          <target state="translated">&lt;strong&gt;Сценарий второй&lt;/strong&gt; : более двух контроллеров представления должны совместно использовать одну и ту же информацию. Смотрите схему два.</target>
        </trans-unit>
        <trans-unit id="f945b9a41062fc17eb825c26426f171f0d86ed91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second View Controller and Protocol&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Контроллер второго вида и протокол&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ce77aea00bcbf439da1f87290ce172463ea140c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second View Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Контроллер второго вида&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bd48716ff2de9235461890349819ae353247ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setup The Storyboard&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Настройте раскадровку&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="089fc6cd09fa49635621f8cfa746223ca053b190" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Create Segue from ViewControllerA to ViewControllerB and give Identifier = showDetailSegue in Storyboard as shown below</source>
          <target state="translated">&lt;strong&gt;Шаг 1.&lt;/strong&gt; Создайте Segue из ViewControllerA в ViewControllerB и задайте Identifier = showDetailSegue в раскадровке, как показано ниже</target>
        </trans-unit>
        <trans-unit id="02d6487d795d944e58f58e4366b35bc8d1b32dc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Declare Protocol &lt;strong&gt;&lt;em&gt;ViewControllerBDelegate&lt;/em&gt;&lt;/strong&gt; in ViewControllerB file but outside the class</source>
          <target state="translated">&lt;strong&gt;Шаг 1.&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Объявите&lt;/em&gt;&lt;/strong&gt; протокол &lt;strong&gt;&lt;em&gt;ViewControllerBDelegate&lt;/em&gt;&lt;/strong&gt; в файле ViewControllerB, но вне класса</target>
        </trans-unit>
        <trans-unit id="0cfd0efef879069214eec7da3b7a25e5918e36d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Declare variable in ViewControllerB</source>
          <target state="translated">&lt;strong&gt;Шаг 1.&lt;/strong&gt; Объявите переменную в ViewControllerB</target>
        </trans-unit>
        <trans-unit id="63f0b24521041c6431c75964ba6cefcaea19944c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; Declare Delegate variable instance in ViewControllerB</source>
          <target state="translated">&lt;strong&gt;Шаг 2.&lt;/strong&gt; Объявление экземпляра делегированной переменной в ViewControllerB</target>
        </trans-unit>
        <trans-unit id="cf2aa8929fa2c0c9c4a6b1ac4ca41b9ce1e5280a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; In ViewControllerB Declare a viable named &lt;strong&gt;isSomethingEnabled&lt;/strong&gt; and print its value.</source>
          <target state="translated">&lt;strong&gt;Шаг 2.&lt;/strong&gt; В ViewControllerB объявите переменную с именем &lt;strong&gt;isSomethingEnabled&lt;/strong&gt; и напечатайте ее значение.</target>
        </trans-unit>
        <trans-unit id="673106a11e8d268ad485367e76e5b7fe1a54be95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; Print Variable in ViewControllerB' ViewDidLoad method</source>
          <target state="translated">&lt;strong&gt;Шаг 2.&lt;/strong&gt; Печать переменной в методе ViewControllerB 'ViewDidLoad</target>
        </trans-unit>
        <trans-unit id="c79ecb62ba912afd27284dd7da413af362a92fe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; In ViewControllerA Pass Data while pushing through Navigation Controller</source>
          <target state="translated">&lt;strong&gt;Шаг 3.&lt;/strong&gt; В ViewControllerA передать данные во время проталкивания через контроллер навигации</target>
        </trans-unit>
        <trans-unit id="4b0af6a719a13383d29f0e86f0830773e5362336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; In ViewControllerA pass isSomethingEnabled's value while passing Segue</source>
          <target state="translated">&lt;strong&gt;Шаг 3.&lt;/strong&gt; В ViewControllerA передайте значение isSomethingEnabled при передаче Segue</target>
        </trans-unit>
        <trans-unit id="e879cf49b95c873ff028951588aa65e4dc76e026" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; Send data for delegate inside viewDidLoad method of ViewControllerB</source>
          <target state="translated">&lt;strong&gt;Шаг 3.&lt;/strong&gt; Отправка данных для делегата внутри метода viewDidLoad ViewControllerB</target>
        </trans-unit>
        <trans-unit id="c0971f452794a6e92bcbbc194c9499089ede4379" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 4.&lt;/strong&gt; Confirm ViewControllerBDelegate in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;Шаг 4.&lt;/strong&gt; Подтвердите ViewControllerBDelegate в ViewControllerA</target>
        </trans-unit>
        <trans-unit id="400cecca8d5ee34aed2e79bed634a5f6417ad26a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 5.&lt;/strong&gt; Confirm that you will implement delegate in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;Шаг 5.&lt;/strong&gt; Подтвердите, что вы реализуете делегат в ViewControllerA</target>
        </trans-unit>
        <trans-unit id="a6946e7fb9eb003efc11719f3b07f5e5dd24240e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 6.&lt;/strong&gt; Implement delegate method for receiving data in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;Шаг 6.&lt;/strong&gt; Реализация метода делегата для получения данных в ViewControllerA</target>
        </trans-unit>
        <trans-unit id="dae0e54a74abfd074492d26eb16ee245aa1b2bad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Swift 5&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Swift 5&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28379284774a4bc3f1d8c071ddb2db954d9799db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Solutions: Delegates and the Observer Pattern, and Singletons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Решения: делегаты, шаблон наблюдателя и синглтоны&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67f11916500f3f87c23f865722bfb004fcf67670" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The View Controllers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Контроллеры представления&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4223100f431b368002a27fc7e5a1b02d95268402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is a very old answer and this is anti pattern, please use delegates. Do not use this Approach !!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Это очень старый ответ, и это анти-шаблон, пожалуйста, используйте делегатов.&lt;/strong&gt; &lt;strong&gt;Не используйте этот подход!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f90d261e0a84b99ac74b5c70573c76458761db1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ViewControllerA&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ViewControllerA&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="48b18e371bee61f8b3cc40f6098e6c3da05ba232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ViewControllerB&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ViewControllerB&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7695880e46c35fa27304925b1429e1f63dcc24f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;add block handler (listener)&lt;/strong&gt;
where you need a value (for example you need your API response in ControllerA or you need ContorllerB data on A)</source>
          <target state="translated">&lt;strong&gt;Добавьте обработчик блока (слушатель),&lt;/strong&gt; где вам нужно значение (например, вам нужен ответ API в ControllerA или вам нужны данные ContorllerB на A)</target>
        </trans-unit>
        <trans-unit id="c5d2857c643c79b0380179ffbc7e423000f801e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;define a block&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;определить блок&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93db5e336a184ed3fa5d32c57284bb8d6714d03a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fire block&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;пожарный блок&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3915169e39c880b6db82aad68f146c88205b079" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;singleton&lt;/strong&gt; is an instance of a class, that instance being the only instance in existence during its lifetime. A singleton gets its name from the fact that it is the single instance. Normally developers who use singletons have special class methods for accessing them.</source>
          <target state="translated">&lt;strong&gt;Singleton&lt;/strong&gt; - это экземпляр класса, который является единственным существующим экземпляром в течение его жизни. Синглтон получил свое название от того факта, что это единственный экземпляр. Обычно разработчики, которые используют синглтоны, имеют специальные методы класса для доступа к ним.</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="f28e068fdcf0539a305afd3501e8a77424964acf" translate="yes" xml:space="preserve">
          <source>Add a new file to your project (Objective-C Protocol) File -&amp;gt; New, now name it ViewController1Delegate or whatever you want and write these between the @interface and @end directives</source>
          <target state="translated">Добавьте новый файл в ваш проект (протокол Objective-C) Файл -&amp;gt; Новый, теперь назовите его ViewController1Delegate или как хотите, и напишите их между директивами @interface и @end</target>
        </trans-unit>
        <trans-unit id="3f0eff45a4a19a3b442bc835b668a6a9ac78b01f" translate="yes" xml:space="preserve">
          <source>Add this &lt;code&gt;property&lt;/code&gt; in NextVC.h on nextVC</source>
          <target state="translated">Добавьте это &lt;code&gt;property&lt;/code&gt; в NextVC.h на nextVC</target>
        </trans-unit>
        <trans-unit id="804108390422b4e4ce16d7dd070e8cd51d8926e4" translate="yes" xml:space="preserve">
          <source>After more research it seemed that Protocols and Delegates is the correct/Apple prefered way of doing this.</source>
          <target state="translated">После дополнительных исследований казалось,что Протоколы и Делегаты-это правильный,предпочтительный способ сделать это.</target>
        </trans-unit>
        <trans-unit id="a12d91c7bf75162aeefa8045f7e5bc4e2c65ef2b" translate="yes" xml:space="preserve">
          <source>All of your views that conform to this need to be subclasses of MCViewController, which allow you to override the new onResume: method, allowing you access to the data you've passed in.</source>
          <target state="translated">Все ваши представления,соответствующие этому,должны быть подклассами MCViewController,которые позволяют переопределить новый метод onResume:,позволяющий получить доступ к данным,которые вы передали.</target>
        </trans-unit>
        <trans-unit id="0d8ab1246f6106fb56d5a9574573a871cd55050d" translate="yes" xml:space="preserve">
          <source>And in the prepareForSegue of VC1 you can change any property you want to share.</source>
          <target state="translated">А в prepareForSegue VC1 вы можете изменить любое свойство,которым хотите поделиться.</target>
        </trans-unit>
        <trans-unit id="bccdba78cf0a1ca896692cedf94279f07a532726" translate="yes" xml:space="preserve">
          <source>And last</source>
          <target state="translated">И последнее</target>
        </trans-unit>
        <trans-unit id="b969e3b40597dea269830b21f5cd87d1fbd3744f" translate="yes" xml:space="preserve">
          <source>And the code for the Second View Controller is</source>
          <target state="translated">И код для второго контроллера просмотра -</target>
        </trans-unit>
        <trans-unit id="18cc65ab16292fba4c64e85d6cc81210aac335ef" translate="yes" xml:space="preserve">
          <source>Another Working Example for Blocks</source>
          <target state="translated">Другой рабочий пример для блоков</target>
        </trans-unit>
        <trans-unit id="118227ed38ee9d82b2542b27e2ded76929153d04" translate="yes" xml:space="preserve">
          <source>Another approach is to handle a screen full of data at a time and instead of coupling the view controllers to each other couple each view controller to single data source that they can get to independently.</source>
          <target state="translated">Другой подход заключается в обработке экрана,полного данных одновременно,и вместо того,чтобы соединять контроллеры представлений друг с другом,они соединяют каждый контроллер представлений с одним источником данных,к которому они могут добраться самостоятельно.</target>
        </trans-unit>
        <trans-unit id="24aa503d35146161367e2853117eb922f7c7e249" translate="yes" xml:space="preserve">
          <source>Another option of using storyboards Undwind (Exit)  - you can
use the method you wrote in VC1</source>
          <target state="translated">Еще один вариант использования раскадровок Undwind (Exit)-вы можете использовать метод,который вы написали в VC1.</target>
        </trans-unit>
        <trans-unit id="0b6c72a6ce36ed0135ebc104f4837a0d4628e2ba" translate="yes" xml:space="preserve">
          <source>Another solution is use singleton class pattern initialize it once and use it in your entire app.</source>
          <target state="translated">Другим решением является использование однокнопочного шаблона класса,инициализирующего его один раз и использующего его во всем приложении.</target>
        </trans-unit>
        <trans-unit id="485e9762fc4e98806a8bb291a5c98ca65cca0c5d" translate="yes" xml:space="preserve">
          <source>Any time an individual item is created or edited, it must also synchronize with the other view controllers. For example, if we add a boat in ViewControllerD, but it is not yet insured, then the boat must appear when the user goes to ViewControllerA (Luxury Items), and also ViewControllerC (Entire Home Inventory), but not when the user goes to ViewControllerB (Non-insured Items). We need be concerned with not only adding new items, but also deleting items (which may be allowed from any of the four view controllers), or editing existing items (which may be allowed from the &quot;Add New Item Form&quot;, repurposing the same for editing).</source>
          <target state="translated">Каждый раз,когда создается или редактируется отдельный элемент,он также должен синхронизироваться с другими контроллерами вида.Например,если мы добавляем лодку в ViewControllerD,но она еще не застрахована,то лодка должна появиться,когда пользователь переходит в ViewControllerA (Объекты роскоши),а также в ViewControllerC (Вся домашняя инвентаризация),но не тогда,когда пользователь переходит в ViewControllerB (Объекты,не застрахованные).Нам необходимо заниматься не только добавлением новых элементов,но и удалением элементов (что может быть разрешено с любого из четырех контроллеров просмотра),или редактированием существующих элементов (что может быть разрешено с &quot;Формы добавления новых элементов&quot;,перепрофилируя их для редактирования).</target>
        </trans-unit>
        <trans-unit id="64849ae90e58e40914c4de26bdae632804d0010e" translate="yes" xml:space="preserve">
          <source>Any time your Application Delegate starts to get bloated, start to remove functionality into singletons. For example, the Core Data Stack should not be left in the AppDelegate, but should instead be put in its own class, a coreDataManager class.</source>
          <target state="translated">Всякий раз,когда начинает раздуваться Ваше приложение Delegate,начинайте удалять функциональность в синглонах.Например,Core Data Stack не следует оставлять в AppDelegate,а поместить в свой собственный класс,класс coreDataManager.</target>
        </trans-unit>
        <trans-unit id="3f40fedcce16e602b145be79b8076ddf17738736" translate="yes" xml:space="preserve">
          <source>Assuming we use Storyboard, first controller sets callback block, for example during segue preparation:</source>
          <target state="translated">Если предположить,что мы используем Storyboard,то первый контроллер устанавливает блок обратного вызова,например,во время подготовки сегмента:</target>
        </trans-unit>
        <trans-unit id="937c87dd061dc69a2f97f40ce08377952484a667" translate="yes" xml:space="preserve">
          <source>Asynchronous JSON Requests in Objective-C</source>
          <target state="translated">Асинхронные JSON Запросы в Цели-С</target>
        </trans-unit>
        <trans-unit id="7a23b7a9d6d6baa93168423a429c497e0668b171" translate="yes" xml:space="preserve">
          <source>Before pushing &lt;code&gt;viewControllerB&lt;/code&gt; to navigation stack we need to tell  &lt;code&gt;ViewControllerB&lt;/code&gt; that &lt;code&gt;ViewControllerA&lt;/code&gt; is its delegate, otherwise we will get an error.</source>
          <target state="translated">Прежде чем &lt;code&gt;viewControllerB&lt;/code&gt; в стек навигации, мы должны сообщить &lt;code&gt;ViewControllerB&lt;/code&gt; , что &lt;code&gt;ViewControllerA&lt;/code&gt; является его делегатом, в противном случае мы получим ошибку.</target>
        </trans-unit>
        <trans-unit id="8eac8dd9c4975fc8c45b35fda8f1d46a26aaa269" translate="yes" xml:space="preserve">
          <source>Brute force iteration on view controllers (in Navigation or Tab Bar Controller) to set the data</source>
          <target state="translated">Итерация грубой силы на контроллерах просмотра (в Навигации или Контроллере табличек)для установки данных</target>
        </trans-unit>
        <trans-unit id="54b5e333081c3612757c1545a54070e785c64a95" translate="yes" xml:space="preserve">
          <source>But for the simple scenario of passing a value to a different class whose allocation is done in the current class, the most common and preferred method would be the direct setting of values after allocation. This is done as follows:-</source>
          <target state="translated">Но для простого сценария передачи значения другому классу,распределение которого производится в текущем классе,наиболее распространенным и предпочтительным методом будет прямая установка значений после распределения.Это делается следующим образом:-</target>
        </trans-unit>
        <trans-unit id="ea1d3df298ca84104dbf8b2f6f916c02f6f77c6e" translate="yes" xml:space="preserve">
          <source>Control</source>
          <target state="translated">Control</target>
        </trans-unit>
        <trans-unit id="959abf1f5e9c99d137dc34e9bffd461476893b28" translate="yes" xml:space="preserve">
          <source>Core Data</source>
          <target state="translated">Основные данные</target>
        </trans-unit>
        <trans-unit id="dec7ea0ef8ddc0be363fac5318ec6d035445e81a" translate="yes" xml:space="preserve">
          <source>Create a the segue from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; on the storyboard and give it an identifier, in this example we'll call it &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt;</source>
          <target state="translated">Создайте переход от &lt;code&gt;ViewControllerA&lt;/code&gt; к &lt;code&gt;ViewControllerB&lt;/code&gt; на раскадровке и дайте ему идентификатор, в этом примере мы назовем его &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d6106a2b404bee4c3c16acfce805678171d2723" translate="yes" xml:space="preserve">
          <source>Create the property on next &lt;code&gt;view controller .h&lt;/code&gt; and define getter and setter.</source>
          <target state="translated">Создайте свойство на следующем &lt;code&gt;view controller .h&lt;/code&gt; и определите getter и setter.</target>
        </trans-unit>
        <trans-unit id="3dd4a61a93a6d9b50322d5da189d9a661c072e48" translate="yes" xml:space="preserve">
          <source>Create the storyboard layout in the Interface Builder. Again, to make the segue, you just</source>
          <target state="translated">Создайте раскадровку раскадровки в конструкторе интерфейсов.Опять же,чтобы сделать сегмент,ты просто</target>
        </trans-unit>
        <trans-unit id="2851431431fb0af8a145e641673ca993d6a20f60" translate="yes" xml:space="preserve">
          <source>Create the storyboard layout in the Interface Builder. To make the segue, you just</source>
          <target state="translated">Создайте раскадровку раскадровки в конструкторе интерфейсов.Чтобы сделать сегмент,вы просто</target>
        </trans-unit>
        <trans-unit id="863b2164a4f2bf227ea1d1aef73ad8543480c495" translate="yes" xml:space="preserve">
          <source>Data Source</source>
          <target state="translated">Источник данных</target>
        </trans-unit>
        <trans-unit id="2aac74bd52b9c492652ab12ed22c5b9514f39d8b" translate="yes" xml:space="preserve">
          <source>Databases and other storage mechanisms like plist, etc.</source>
          <target state="translated">Базы данных и другие механизмы хранения,такие как плист и т.д.</target>
        </trans-unit>
        <trans-unit id="12ab214df85e4910f7e4400eea924b9565854a9f" translate="yes" xml:space="preserve">
          <source>Delegate</source>
          <target state="translated">Delegate</target>
        </trans-unit>
        <trans-unit id="7dcb8a7fd6d2299b039ffb1a88ed98c93cfc5c8c" translate="yes" xml:space="preserve">
          <source>Delegate Pattern</source>
          <target state="translated">Картина делегата</target>
        </trans-unit>
        <trans-unit id="55f0774bd4a8ef9ee512f251043f191561770ae9" translate="yes" xml:space="preserve">
          <source>Delegation - for passing data back</source>
          <target state="translated">Делегация-для передачи данных обратно</target>
        </trans-unit>
        <trans-unit id="4e3967fb23456a60f72119d5b28aa0e415a7f7e8" translate="yes" xml:space="preserve">
          <source>Delegation is the only one solution to perform such operations when you are using .xib files however all answers described above are for &lt;code&gt;storyboard&lt;/code&gt; for .xibs files you need to use delegation. that's only solution you can.</source>
          <target state="translated">Делегирование - это единственное решение для выполнения таких операций при использовании файлов .xib, однако все ответы, описанные выше, предназначены для &lt;code&gt;storyboard&lt;/code&gt; файлов .xibs, которые необходимо использовать для делегирования. это единственное решение, которое вы можете.</target>
        </trans-unit>
        <trans-unit id="b4207fd5520139aa96bd6e9274602042b4534a20" translate="yes" xml:space="preserve">
          <source>Direct initialization after the allocation of another class.</source>
          <target state="translated">Прямая инициализация после выделения другого класса.</target>
        </trans-unit>
        <trans-unit id="bcfc557b28b79f1b85cc19619bb82e338660c8e4" translate="yes" xml:space="preserve">
          <source>FirstViewController String value as</source>
          <target state="translated">FirstViewController Значение строки как</target>
        </trans-unit>
        <trans-unit id="57a94d454ba6c87c92cf93163d87c89f165d195a" translate="yes" xml:space="preserve">
          <source>FirstViewController.h</source>
          <target state="translated">FirstViewController.h</target>
        </trans-unit>
        <trans-unit id="f8e78f0e3c0970f488a281208ad26ef9f20bbdf0" translate="yes" xml:space="preserve">
          <source>FirstViewController.m</source>
          <target state="translated">FirstViewController.m</target>
        </trans-unit>
        <trans-unit id="9609a00b7fb972ff05c1431d4f283cdd084f76ce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;ViewControllerA&lt;/code&gt; to be a delegate of &lt;code&gt;ViewControllerB&lt;/code&gt; it must conform to &lt;code&gt;ViewControllerB&lt;/code&gt;'s protocol which we have to specify. This tells &lt;code&gt;ViewControllerA&lt;/code&gt; which methods it must implement.</source>
          <target state="translated">Чтобы &lt;code&gt;ViewControllerA&lt;/code&gt; был делегатом &lt;code&gt;ViewControllerB&lt;/code&gt; , он должен соответствовать протоколу &lt;code&gt;ViewControllerB&lt;/code&gt; , который мы должны указать. Это сообщает &lt;code&gt;ViewControllerA&lt;/code&gt; , какие методы он должен реализовать.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="ddb095a25c86563637fe3a13523173efa1d4bd90" translate="yes" xml:space="preserve">
          <source>For this example, we will have &lt;code&gt;ViewControllerA&lt;/code&gt; and &lt;code&gt;ViewControllerB&lt;/code&gt;</source>
          <target state="translated">Для этого примера у нас будут &lt;code&gt;ViewControllerA&lt;/code&gt; и &lt;code&gt;ViewControllerB&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fd567287999a459caadcea427cbafc09d8c04a6" translate="yes" xml:space="preserve">
          <source>For those interested, I wrote some articles that address these points more in depth and highlight the various drawbacks:</source>
          <target state="translated">Для тех,кому интересно,я написал несколько статей,в которых более подробно остановился на этих моментах и выделил различные недостатки:</target>
        </trans-unit>
        <trans-unit id="32096c328bd65055c2650eb54a84201d94dbdd3e" translate="yes" xml:space="preserve">
          <source>Go to your SecondViewController.h and write two methods</source>
          <target state="translated">Перейдите на свой SecondViewController.h и напишите два способа</target>
        </trans-unit>
        <trans-unit id="66b1fbfc6e5394baafe61e59c041f14de3f8dfa2" translate="yes" xml:space="preserve">
          <source>Here are two trivial examples of the segue glue.  The first is straightforward showing one parameter passed for input, the second for output.</source>
          <target state="translated">Вот два тривиальных примера клея для сегментации.Первый простой пример,показывающий один параметр,переданный на вход,второй-на выход.</target>
        </trans-unit>
        <trans-unit id="c503ca63bb5c748744204770c2f45a34800264da" translate="yes" xml:space="preserve">
          <source>Here is the setup for the receiver.</source>
          <target state="translated">Вот настройка приемника.</target>
        </trans-unit>
        <trans-unit id="27ec3a0713aa1a15fc2589ac80289f434c756874" translate="yes" xml:space="preserve">
          <source>Here is the setup for the sender</source>
          <target state="translated">Вот настройка для отправителя</target>
        </trans-unit>
        <trans-unit id="2ed131c901fbe28ddf0ce2cd8b65f252fbcb1bac" translate="yes" xml:space="preserve">
          <source>Hook up the outlets for the &lt;code&gt;UITextField&lt;/code&gt; and the &lt;code&gt;UILabel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UITextField&lt;/code&gt; розетки для UITextField и &lt;code&gt;UILabel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c858c878a55e6b91f549851d54d1a349d5effd3d" translate="yes" xml:space="preserve">
          <source>Hope This Helps.</source>
          <target state="translated">Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="0f0122ee4a988027a9316eb9e7ae9f1f39324dd0" translate="yes" xml:space="preserve">
          <source>Hope i added something to the discussion.</source>
          <target state="translated">Надеюсь,я что-то добавил в обсуждение.</target>
        </trans-unit>
        <trans-unit id="5a142ce919975d47656e09ab99d87f6db6c24f1b" translate="yes" xml:space="preserve">
          <source>Hope some of you find this solution useful/interesting.</source>
          <target state="translated">Надеюсь,некоторые из вас найдут это решение полезным.</target>
        </trans-unit>
        <trans-unit id="3dde88ebb2cd0d70e69aeb2a7ef870a86f8e1b6f" translate="yes" xml:space="preserve">
          <source>Hope this helps</source>
          <target state="translated">Надеюсь,это поможет</target>
        </trans-unit>
        <trans-unit id="2cdfefbe424649534d9db2ab8261c3eafbd9a6e9" translate="yes" xml:space="preserve">
          <source>How iOS View Controllers Communicate With Each Other</source>
          <target state="translated">Как контроллеры iOS View взаимодействуют друг с другом</target>
        </trans-unit>
        <trans-unit id="c7727df2be19971e8927f49141a1a5496f4054e8" translate="yes" xml:space="preserve">
          <source>How to Structure the Code of iOS Apps</source>
          <target state="translated">Как структурировать код iOS Apps</target>
        </trans-unit>
        <trans-unit id="a7486bddaa4b0348571f0d1a8a53e76566788cb0" translate="yes" xml:space="preserve">
          <source>I am currently contributing to an open source solution to this problem through a project called MCViewFactory, which may be found here:</source>
          <target state="translated">В настоящее время я вношу свой вклад в решение этой проблемы с открытым исходным кодом через проект под названием MCViewFactory,который можно найти здесь:</target>
        </trans-unit>
        <trans-unit id="f2d0ca81764b2c3a3e1f362cde1e9ab36322bd51" translate="yes" xml:space="preserve">
          <source>I am going to rewrite his logic in Swift with latest iOS Framework</source>
          <target state="translated">Я собираюсь переписать его логику в Свифте с помощью новейшей iOS Framework.</target>
        </trans-unit>
        <trans-unit id="32993e505110576861bf61a7774bb4e29093aa24" translate="yes" xml:space="preserve">
          <source>I ended up using this example</source>
          <target state="translated">В итоге я использовал этот пример</target>
        </trans-unit>
        <trans-unit id="fb06d1564152df661993e0e7090fe2a1f0d5b7e9" translate="yes" xml:space="preserve">
          <source>I find simplest and most elegant version with passing blocks.
Let's name view controller that waits for returned data as &quot;A&quot; and returning view controller as &quot;B&quot;. In this example we want to get 2 values: first of Type1 and second of Type2.</source>
          <target state="translated">Я нахожу самую простую и элегантную версию с проходящими блоками.Назовем контроллер вида,который ждет возвращаемых данных,&quot;A&quot;,а возвращаемый контроллер вида-&quot;B&quot;.В этом примере мы хотим получить 2 значения:первое из Type1 и второе из Type2.</target>
        </trans-unit>
        <trans-unit id="1333860eaa3d97443744ef9200f6a80fa125579a" translate="yes" xml:space="preserve">
          <source>I found there are more ways:</source>
          <target state="translated">Я нашел,что есть и другие способы:</target>
        </trans-unit>
        <trans-unit id="63c023c5a80422806d084a6c97842a45d00ed69c" translate="yes" xml:space="preserve">
          <source>I have a view that acts as a data entry form and I want to give the user the option to select multiple products. The products are listed on another view with a &lt;code&gt;UITableViewController&lt;/code&gt; and I have enabled multiple selections.</source>
          <target state="translated">У меня есть представление, которое действует как форма ввода данных, и я хочу дать пользователю возможность выбрать несколько продуктов. Продукты перечислены в другом представлении с &lt;code&gt;UITableViewController&lt;/code&gt; , и я включил несколько вариантов выбора.</target>
        </trans-unit>
        <trans-unit id="daab7a9e1660ea80bf746f2a7ffe137093641504" translate="yes" xml:space="preserve">
          <source>I have seen a lot of people over complicating this using the &lt;code&gt;didSelectRowAtPath&lt;/code&gt; method. I am using Core Data in my example.</source>
          <target state="translated">Я видел много людей, которые усложняли это с &lt;code&gt;didSelectRowAtPath&lt;/code&gt; метода didSelectRowAtPath . Я использую Core Data в моем примере.</target>
        </trans-unit>
        <trans-unit id="16aeeef45f1fe8a16c172b0d0778c79a341461c5" translate="yes" xml:space="preserve">
          <source>I have surfed around and seen some people declare an array in the app delegate. I read something about Singletons but don't understand what these are and I read something about creating a data model.</source>
          <target state="translated">Я покопался в серфинге и видел,как некоторые объявляли массив в делегате приложения.Я прочитал кое-что о синглетах,но не понимаю,что это такое,и прочитал кое-что о создании модели данных.</target>
        </trans-unit>
        <trans-unit id="814549b2a629fcb2811c5678e6e7c5629c9fa79a" translate="yes" xml:space="preserve">
          <source>I hope this answer is clear enough for people to understand and that I have not missed anything.</source>
          <target state="translated">Я надеюсь,что этот ответ будет достаточно ясен для того,чтобы люди поняли,и что я ничего не пропустил.</target>
        </trans-unit>
        <trans-unit id="15f9e48f7ce909c17212445d5661bf8a3c542dbc" translate="yes" xml:space="preserve">
          <source>I know this is a beaten subject but for those looking to answer this question with a SWIFT slant and want a bare-bones example, here my go-to method for passing data if you are using a segue to get around.</source>
          <target state="translated">Я знаю,что это избитая тема,но для тех,кто хочет ответить на этот вопрос с наклоном SWIFT и хочет получить пример с голыми костями,вот мой метод передачи данных,если вы используете сегмент,чтобы обойти его.</target>
        </trans-unit>
        <trans-unit id="81a9e22efbeff10a44db5b8cdb745bd06025c82b" translate="yes" xml:space="preserve">
          <source>I like the idea of Model objects and Mock objects based on NSProxy to commit or discard data if what user selects can be cancelled.</source>
          <target state="translated">Мне нравится идея Model objects и Mock objects,основанных на NSProxy для фиксации или отбрасывания данных,если то,что выбирает пользователь,может быть отменено.</target>
        </trans-unit>
        <trans-unit id="baaf8a3ca4379be9cd2bab483d766c8d34304728" translate="yes" xml:space="preserve">
          <source>I was searching this solution for long time, Atlast I found it. First of all declare all the objects in your SecondViewController.h file like</source>
          <target state="translated">Я долго искал это решение,Атласт нашел его.Прежде всего,объявите все объекты в вашем SecondViewController.h файле как</target>
        </trans-unit>
        <trans-unit id="62c982b0a0ffe5bca814c4394638faed462207da" translate="yes" xml:space="preserve">
          <source>I wrote a blog post about this a while back: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;Sharing Model Code&lt;/a&gt;. Here's a brief summary:</source>
          <target state="translated">Я написал пост в блоге об этом некоторое время назад: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;совместное использование кода модели&lt;/a&gt; . Вот краткое резюме:</target>
        </trans-unit>
        <trans-unit id="f35d400cc0a2783a34596a1675a4eb5991195da1" translate="yes" xml:space="preserve">
          <source>I'm new to iOS and Objective-C and the whole MVC paradigm and I'm stuck with the following:</source>
          <target state="translated">Я новичок в iOS и Objective-C и во всей парадигме MVC,и я застрял со следующим:</target>
        </trans-unit>
        <trans-unit id="df1f75720203e34b8f92760b6e05286c591390f8" translate="yes" xml:space="preserve">
          <source>If you are using Storyboards you are most likely using segues and will need this procedure to pass data forward. This is similar to the above but instead of passing the data before you push the view controller, you use a method called</source>
          <target state="translated">Если вы используете Storyboards,то,скорее всего,вы используете сегменты,и вам понадобится эта процедура для передачи данных.Это похоже на то,что было сказано выше,но вместо того,чтобы передавать данные до того,как вы нажимаете на контроллер вида,вы используете метод,называемый</target>
        </trans-unit>
        <trans-unit id="09342e817a09bfb2e555b89afe5f0a71bebde6b8" translate="yes" xml:space="preserve">
          <source>If you have your views embedded in a navigation controller you need to change the method above slightly to the following</source>
          <target state="translated">Если ваши виды встроены в навигационный контроллер,вам необходимо слегка изменить метод,описанный выше,на следующий.</target>
        </trans-unit>
        <trans-unit id="c057436dcaf9858c8a465dcfbcf74653c62e56d3" translate="yes" xml:space="preserve">
          <source>If you want to pass data from one controller to other try this code</source>
          <target state="translated">Если вы хотите передать данные с одного контроллера на другой,попробуйте этот код.</target>
        </trans-unit>
        <trans-unit id="5aaeee5260096b956e2adc18507a3dbdbd4de81b" translate="yes" xml:space="preserve">
          <source>If you want to send data from one to another viewController, here's a way to it:</source>
          <target state="translated">Если вы хотите отправить данные от одного к другому ViewController,вот способ,как это сделать:</target>
        </trans-unit>
        <trans-unit id="df625f6457413343ada0786d3f8df7e44cb409c4" translate="yes" xml:space="preserve">
          <source>Implement a method with a    UIStoryboardSegue argument in  VC 1,    like this one:</source>
          <target state="translated">Реализуйте метод с аргументом UIStoryboardSegue в ВК 1,как этот:</target>
        </trans-unit>
        <trans-unit id="d5bbe6ca201c4fe5dda1d1e053bb7f12a4edd65d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerA.m&lt;/code&gt; implement the following method from our protocol</source>
          <target state="translated">В &lt;code&gt;ViewControllerA.m&lt;/code&gt; реализуем следующий метод из нашего протокола</target>
        </trans-unit>
        <trans-unit id="9d6547b304166959ffcc04dfdf16623cf62b971e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerB.h&lt;/code&gt;, below the &lt;code&gt;#import&lt;/code&gt;, but above &lt;code&gt;@interface&lt;/code&gt; you specify the protocol.</source>
          <target state="translated">В &lt;code&gt;ViewControllerB.h&lt;/code&gt; ниже &lt;code&gt;#import&lt;/code&gt; , но выше &lt;code&gt;@interface&lt;/code&gt; вы указываете протокол.</target>
        </trans-unit>
        <trans-unit id="34f4b01f04c9ab50f1dc277e194a6c707b3ae757" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerB&lt;/code&gt; we call a message on the &lt;code&gt;delegate&lt;/code&gt; when we pop the view controller.</source>
          <target state="translated">В &lt;code&gt;ViewControllerB&lt;/code&gt; мы вызываем сообщение на делегате, когда мы выталкиваем контроллер представления.</target>
        </trans-unit>
        <trans-unit id="d4cb986f06c8a358bb0ac401e2255be7435b3ec6" translate="yes" xml:space="preserve">
          <source>In NewViewController.h</source>
          <target state="translated">В NewViewController.h</target>
        </trans-unit>
        <trans-unit id="ee25efeb34aea96a92caf4d24a919db9885aa93d" translate="yes" xml:space="preserve">
          <source>In NewViewController.m</source>
          <target state="translated">В NewViewController.m</target>
        </trans-unit>
        <trans-unit id="fcfba25eeca43facefb5d34107096b545f63a8ea" translate="yes" xml:space="preserve">
          <source>In both unwind options you can set the tag property of the button and check it in
        the prepareForSegue.</source>
          <target state="translated">В обеих опциях размотки вы можете установить свойство тега кнопки и проверить его в prepareForSegue.</target>
        </trans-unit>
        <trans-unit id="61da207f2a6f23452f52382b7096f549ed3ae3a9" translate="yes" xml:space="preserve">
          <source>In my case I used a singleton class which can work as a global object allowing accesses to the data from almost everywhere in the app. First thing is to build a singleton class. Please refer to the page,&quot; &lt;a href=&quot;https://stackoverflow.com/questions/145154/what-does-your-objective-c-singleton-look-like&quot;&gt;What should my Objective-C singleton look like?&lt;/a&gt; &quot;
And what I did to make the object globally accessible was simply import it in &lt;code&gt;appName_Prefix.pch&lt;/code&gt; which is for applying import statement in every classes.
To access this object and to use, I simply implemented class method to return the shared instance, which contains its own variables</source>
          <target state="translated">В моем случае я использовал одноэлементный класс, который может работать как глобальный объект, предоставляя доступ к данным практически из любого места в приложении. Первое, что нужно сделать - создать класс синглтонов Пожалуйста, обратитесь к странице &amp;laquo; &lt;a href=&quot;https://stackoverflow.com/questions/145154/what-does-your-objective-c-singleton-look-like&quot;&gt;Как должен выглядеть мой синглтон Objective C?&lt;/a&gt; &amp;raquo; И что я сделал, чтобы сделать объект глобально доступным, просто импортировал его в &lt;code&gt;appName_Prefix.pch&lt;/code&gt; , который предназначен для применения оператора import во всех классах. Чтобы получить доступ к этому объекту и использовать его, я просто реализовал метод класса для возврата общего экземпляра, который содержит свои собственные переменные</target>
        </trans-unit>
        <trans-unit id="4347c7d44969ad5ed12d4df451dd2631e4a3c195" translate="yes" xml:space="preserve">
          <source>In practice, in my opinion only a few solutions are recommended:</source>
          <target state="translated">На практике,на мой взгляд,рекомендуются лишь некоторые решения:</target>
        </trans-unit>
        <trans-unit id="bf835249be3289308815771b6433af2277b90842" translate="yes" xml:space="preserve">
          <source>In scenario one, we have several viable solutions, as other answers have given</source>
          <target state="translated">В первом сценарии у нас есть несколько жизнеспособных решений,как и в других ответах.</target>
        </trans-unit>
        <trans-unit id="24e6d5a69f4225a7a61ed046e01222766c16f892" translate="yes" xml:space="preserve">
          <source>In scenario two, we do not have a single property of the HouseholdInventoryManager which could be observed using KVO. Because we do not have a single property which is easily observable, the observer pattern, in this case, must be implemented using NSNotificationCenter. Each of the four view controllers would subscribe to notifications, and the sharedManager would send notifications to the notification center when appropriate. The inventory manager does not need to know anything about the view controllers or instances of any other classes which may be interested in knowing when the collection of inventory items changes; the NSNotificationCenter takes care of these implementation details. The View Controllers simply subscribe to notifications, and the data manager simply posts notifications.</source>
          <target state="translated">Во втором сценарии у нас нет ни одного объекта собственности HouseholdInventoryManager,который можно было бы наблюдать,используя KVO.Так как у нас нет единого свойства,которое было бы легко наблюдаемым,то паттерн наблюдателя в этом случае должен быть реализован с использованием NSNotificationCenter.Каждый из четырех контроллеров просмотра будет подписываться на уведомления,а sharedManager будет отправлять уведомления в центр уведомлений,когда это необходимо.Менеджеру инвентаризации не нужно ничего знать о контроллерах видов или экземплярах любых других классов,которые могут быть заинтересованы в том,чтобы знать,когда изменяется коллекция инвентарных единиц;NSNotificationCenter позаботится об этих деталях реализации.Контроллеры видов просто подписываются на уведомления,а менеджер данных просто публикует уведомления.</target>
        </trans-unit>
        <trans-unit id="e1379c7d385f5fd318471115c5d1d1f688e6b7f5" translate="yes" xml:space="preserve">
          <source>In scenario two, we have other viable solutions:</source>
          <target state="translated">Во втором сценарии у нас есть другие жизнеспособные решения:</target>
        </trans-unit>
        <trans-unit id="58156148d8f8b4168742db8860d1cd7839fb7ebe" translate="yes" xml:space="preserve">
          <source>In the implementation of the Controller2 class there will be this function as-</source>
          <target state="translated">В реализации класса Controller2 будет реализована функция as-</target>
        </trans-unit>
        <trans-unit id="5156e8c6be3a57c9fa8103860d77229d47cc7974" translate="yes" xml:space="preserve">
          <source>In the storyBoard hook the &quot;return&quot; button to the green Exit
button(Unwind) of the vc.
 Now you have a segue that &quot;goes back&quot; so u can use the
destinationViewController property in the prepareForSegue of VC2 and
change any property of VC1 before it goes back.</source>
          <target state="translated">В сюжетной доске крючок &quot;Return&quot; (Возврат)на зеленой кнопке &quot;Exit&quot; (Размотка)vc.Теперь у вас есть сегмент,который &quot;возвращается&quot;,чтобы вы могли использовать свойство destinationViewController в prepareForSegue VC2 и изменить любое свойство VC1 до того,как оно вернется.</target>
        </trans-unit>
        <trans-unit id="4e86367af7272fc181fb5bcd8c70015239a60e37" translate="yes" xml:space="preserve">
          <source>In viewControllerA.m</source>
          <target state="translated">In viewControllerA.m</target>
        </trans-unit>
        <trans-unit id="8a08c48c65d645ac979b803ebbf4f71b0159c9d9" translate="yes" xml:space="preserve">
          <source>In viewControllerB.m</source>
          <target state="translated">In viewControllerB.m</target>
        </trans-unit>
        <trans-unit id="cb79757699a18236287e35ceb1f9e3b022bb1e91" translate="yes" xml:space="preserve">
          <source>Independent access</source>
          <target state="translated">Независимый доступ</target>
        </trans-unit>
        <trans-unit id="3880381f94e658ae2233113129d0559225e916ff" translate="yes" xml:space="preserve">
          <source>It is similar to the above but without the buttons, labels and such.  Just simply passing data from one view to the next.</source>
          <target state="translated">Это похоже на то,что было сказано выше,но без кнопок,этикеток и тому подобного.Просто передача данных из одного вида в другой.</target>
        </trans-unit>
        <trans-unit id="b906440f7eeb43644c0bf66e1e5221e013acae00" translate="yes" xml:space="preserve">
          <source>It's easy to pass data around since it's single object or couple of objects and if you have let's say UINavigationController controller, you can keep the reference to model inside and all pushed view controllers can access it directly from navigation controller.</source>
          <target state="translated">Легко передавать данные,так как это один или несколько объектов,и если у вас есть,скажем,контроллер UINavigationController,вы можете держать ссылку на модель внутри,и все подталкиваемые контроллеры просмотра могут получить доступ к ней непосредственно с контроллера навигации.</target>
        </trans-unit>
        <trans-unit id="0b5d7461b214a33821ecc10f031e0f6c05ecb915" translate="yes" xml:space="preserve">
          <source>Key-Value Observing</source>
          <target state="translated">Наблюдение за ключевыми значениями</target>
        </trans-unit>
        <trans-unit id="8d8b4106a4bbadd0d9b29b9a2e51f6ef83bfb01d" translate="yes" xml:space="preserve">
          <source>Key-Value-Observing (KVO)</source>
          <target state="translated">Сохранение стоимости ключа (KVO)</target>
        </trans-unit>
        <trans-unit id="083eb368f20ff79cd32a80916799dbc06c14959b" translate="yes" xml:space="preserve">
          <source>Lastly, the setup for the segue.</source>
          <target state="translated">Наконец,настройка сегмента.</target>
        </trans-unit>
        <trans-unit id="f46a343ce085e475c030eeb1bc56e9b6d0820f1a" translate="yes" xml:space="preserve">
          <source>Managing Data Flow Between View Controllers</source>
          <target state="translated">Управление потоком данных между контроллерами просмотра</target>
        </trans-unit>
        <trans-unit id="6261f4593d459846fc2f53486c547ab992d8a961" translate="yes" xml:space="preserve">
          <source>Many beginner programmers take advantage of the fact that there is always exactly one &lt;strong&gt;Application Delegate&lt;/strong&gt; in the lifetime of the application, which is globally accessible. Beginning programmers use this fact to stuff objects and functionality into the appDelegate as a convenience for access from anywhere else in the application. Just because the AppDelegate is a singleton doesn't mean it should replace all other singletons. This is a poor practice as it places too much burden on one class, breaking good object-oriented practices. Each class should have a clear role that is easily explained, often just by the name of the class.</source>
          <target state="translated">Многие начинающие программисты используют тот факт, что в жизни приложения всегда есть ровно один &lt;strong&gt;делегат&lt;/strong&gt; приложения, который доступен во всем мире. Начинающие программисты используют этот факт для помещения объектов и функций в appDelegate для удобства доступа из любой точки приложения. То, что AppDelegate является синглтоном, не означает, что он должен заменить все остальные синглтоны. Это плохая практика, поскольку она ложится слишком большим бременем на один класс, нарушая хорошие объектно-ориентированные практики. Каждый класс должен иметь четкую роль, которую легко объяснить, часто просто по названию класса.</target>
        </trans-unit>
        <trans-unit id="ee93bc5d4f01f7c4f087cb3eea0c1a1fa3b208c9" translate="yes" xml:space="preserve">
          <source>My question is, how do I transfer the data from one view to another? I will be holding the selections on the &lt;code&gt;UITableView&lt;/code&gt; in an array, but how do I then pass that back to the previous data entry form view so it can be saved along with the other data to Core Data on submission of the form?</source>
          <target state="translated">У меня вопрос, как мне перенести данные из одного представления в другое? Я буду удерживать выборки в &lt;code&gt;UITableView&lt;/code&gt; в массиве, но как мне затем передать это обратно в предыдущее представление формы ввода данных, чтобы его можно было сохранить вместе с другими данными в Core Data при отправке формы?</target>
        </trans-unit>
        <trans-unit id="a18e3f8bc52ea9a0b5de60e0fda22bd4b604ae4c" translate="yes" xml:space="preserve">
          <source>NSFetchedResultsController</source>
          <target state="translated">NSFetchedResultsController</target>
        </trans-unit>
        <trans-unit id="3f1be4da3d97e7743b4732f8a89228df11998162" translate="yes" xml:space="preserve">
          <source>NSNotification</source>
          <target state="translated">NSNotification</target>
        </trans-unit>
        <trans-unit id="703e1cf67303eac1ee399d96fe268f382746c5ae" translate="yes" xml:space="preserve">
          <source>NSNotificationCenter.</source>
          <target state="translated">NSNotificationCenter.</target>
        </trans-unit>
        <trans-unit id="433d340991507812dfa779c7f285cce0740b90aa" translate="yes" xml:space="preserve">
          <source>NSUserDefaults (actually a poor choice)</source>
          <target state="translated">NSUserDefault (на самом деле плохой выбор)</target>
        </trans-unit>
        <trans-unit id="3ddf7238b6f7a09861615351dda77ab298ecd4c4" translate="yes" xml:space="preserve">
          <source>Next, we need to add the method to &lt;code&gt;ViewControllerA&lt;/code&gt; that is called when any segue is performed, because of this we need to detect which segue was called and then do something. In our example we will check for &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; and if that's performed we will pass our &lt;code&gt;BOOL&lt;/code&gt; value to &lt;code&gt;ViewControllerB&lt;/code&gt;</source>
          <target state="translated">Затем нам нужно добавить метод в &lt;code&gt;ViewControllerA&lt;/code&gt; , который вызывается при выполнении любого перехода, поэтому нам необходимо определить, какой вызов вызван, а затем что-то сделать. В нашем примере мы проверим &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; и, если это будет выполнено, мы передадим наше значение &lt;code&gt;BOOL&lt;/code&gt; в &lt;code&gt;ViewControllerB&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bae49983d331f8ba8153193a85e0fefdfdfa8445" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;protocol&lt;/code&gt; is outside of the View Controller class.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;protocol&lt;/code&gt; находится вне класса View Controller.</target>
        </trans-unit>
        <trans-unit id="7b5b766ef197bc7d0023a5f3e888401660c5170a" translate="yes" xml:space="preserve">
          <source>Note the use of our custom &lt;code&gt;DataEnteredDelegate&lt;/code&gt; protocol.</source>
          <target state="translated">Обратите внимание на использование нашего собственного протокола &lt;code&gt;DataEnteredDelegate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c18f8f255ab9c208f23d0340eb9dff5a84efe311" translate="yes" xml:space="preserve">
          <source>Notification</source>
          <target state="translated">Notification</target>
        </trans-unit>
        <trans-unit id="01ae3c85aad097022aea128cd630e363a5a0b504" translate="yes" xml:space="preserve">
          <source>Notification - for broadcasting data to multiple classes at a single time</source>
          <target state="translated">Уведомление-для передачи данных нескольким классам за один раз.</target>
        </trans-unit>
        <trans-unit id="4b1ac88a12c84ad56cbb34ecd00cd8b11ad67ab8" translate="yes" xml:space="preserve">
          <source>Now go to ViewController1.h and add the following property:</source>
          <target state="translated">Теперь перейдите к ViewController1.h и добавьте следующее свойство:</target>
        </trans-unit>
        <trans-unit id="f4fdc026034f453314cb2b9feb3226cf19c866df" translate="yes" xml:space="preserve">
          <source>Now go to ViewController2.h and add</source>
          <target state="translated">Теперь перейдите к ViewController2.h и добавьте</target>
        </trans-unit>
        <trans-unit id="07293e03847eaf2deb454753b5701dde56438146" translate="yes" xml:space="preserve">
          <source>Now go to ViewController2.m and inside the implementation add:</source>
          <target state="translated">Теперь перейдите к ViewController2.m и внутри реализации добавьте:</target>
        </trans-unit>
        <trans-unit id="1891d36db45cf91dbf1adab42bd7124ff5f7b4aa" translate="yes" xml:space="preserve">
          <source>Now if you are creating ViewController1 inside ViewController2 after some event, then you should do it this way using NIB files:</source>
          <target state="translated">Теперь,если вы создаете ViewController1 внутри ViewController2 после какого-то события,то вы должны сделать это таким образом,используя NIB-файлы:</target>
        </trans-unit>
        <trans-unit id="81718fed0b8059c2699c24b22f89672b462cced7" translate="yes" xml:space="preserve">
          <source>Now in viewControllerB.h</source>
          <target state="translated">Теперь в viewControllerB.h</target>
        </trans-unit>
        <trans-unit id="066cfa98ab2af89a37dd0692de1da1e510da9279" translate="yes" xml:space="preserve">
          <source>Now in your implementation file allocate the memory for those objects like this</source>
          <target state="translated">Теперь в вашем реализационном файле выделите память для таких объектов,как этот.</target>
        </trans-unit>
        <trans-unit id="25d28a372f3af29852f3a97a0f8b0fbc603109d9" translate="yes" xml:space="preserve">
          <source>Now that we understand what a singleton is, let's discuss how a singleton fits into the observer pattern. The observer pattern is used for one object to respond to changes by another object. In the second scenario, we have four different view controllers, who all want to know about changes to the underlying data. The &quot;underlying data&quot; should belong to a single instance, a singleton. The &quot;know about changes&quot; is accomplished by observing changes made to the singleton.</source>
          <target state="translated">Теперь,когда мы понимаем,что такое одиночка,давайте обсудим,как одиночка вписывается в схему наблюдателя.Шаблон наблюдателя используется для того,чтобы один объект реагировал на изменения другого объекта.Во втором сценарии у нас есть четыре различных контроллера просмотра,которые все хотят знать об изменениях в базовых данных.Базовые данные&quot; должны принадлежать одному экземпляру-одиночке.Знание об изменениях&quot; осуществляется путем наблюдения за изменениями,вносимыми в одиночку.</target>
        </trans-unit>
        <trans-unit id="810d6004f87bdd4f1aaf25235b9fc765e7454783" translate="yes" xml:space="preserve">
          <source>Now you are all set, whenever you detect the event of check changed in ViewController1, all you have to do is the below</source>
          <target state="translated">Теперь вы все настроены,всякий раз,когда вы обнаруживаете изменение события проверки в ViewController1,все,что вам нужно сделать,это следующее</target>
        </trans-unit>
        <trans-unit id="b3a73828042eb03dcbae2c139bf92a09db907f20" translate="yes" xml:space="preserve">
          <source>Now you have allocated the memory for &lt;code&gt;Array&lt;/code&gt; and object. now you can fill that memory before pushing this &lt;code&gt;ViewController&lt;/code&gt;</source>
          <target state="translated">Теперь вы выделили память для &lt;code&gt;Array&lt;/code&gt; и объекта. Теперь вы можете заполнить эту память, прежде чем нажать этот &lt;code&gt;ViewController&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f65e68be86324bc6597c188e4d73418ae145285" translate="yes" xml:space="preserve">
          <source>Now, in your VC, anytime you want to move to a new VC and pass data, you create a new intent and add data to its dictionary (savedInstanceState). Then, just set the current intent of factory:</source>
          <target state="translated">Теперь,в Вашей виртуальной машине,в любое время,когда Вы захотите перейти на новую виртуальную машину и передать данные,Вы создадите новое намерение и добавите данные в ее словарь (savedInstanceState).Затем,просто установите текущее намерение на заводе:</target>
        </trans-unit>
        <trans-unit id="bec1d95a6f86d7011a1b0191ad1cb2a79100a6f0" translate="yes" xml:space="preserve">
          <source>Observer Pattern</source>
          <target state="translated">Наблюдательный образ</target>
        </trans-unit>
        <trans-unit id="6869e328e00e68ce2087969b13da4a7500c52bc3" translate="yes" xml:space="preserve">
          <source>Once it is run it should switch to the receiver view automatically and pass the value from the sender to the receiver, displaying the value in the console.</source>
          <target state="translated">После запуска он должен автоматически переключиться в режим просмотра приемника и передать значение от отправителя к приемнику,отобразив его в консоли.</target>
        </trans-unit>
        <trans-unit id="1a8ee395cb2fe5ae68947c4ee9e43e6c00f1c91e" translate="yes" xml:space="preserve">
          <source>One approach is to share pointers to the model objects between view controllers.</source>
          <target state="translated">Один из подходов заключается в совместном использовании указателей на объекты модели между контроллерами просмотра.</target>
        </trans-unit>
        <trans-unit id="c4076a44a136b6e3d1dde14cee2663da71d34347" translate="yes" xml:space="preserve">
          <source>One thing to remember is that using block often needs to manage strong and __weak references  like explained &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW16&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Следует помнить одну вещь: использование блока часто требует управления сильными и слабыми ссылками, как описано &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW16&quot;&gt;здесь.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e88c4b3dfd5e93f534f4bbe8851936f162bd94e" translate="yes" xml:space="preserve">
          <source>Or if you need to pass more than 3 parameters which are related to a common feature you can store the values to a Model class and pass that modelObject to the next class</source>
          <target state="translated">Или,если вам нужно передать более 3 параметров,связанных с общим свойством,вы можете сохранить значения в классе Model и передать этот modelObject в следующий класс</target>
        </trans-unit>
        <trans-unit id="ad245eca6b5201f4babe15b0ebc45f1a1101dc9c" translate="yes" xml:space="preserve">
          <source>Passing Data Between View Controllers</source>
          <target state="translated">Передача данных между контроллерами просмотра</target>
        </trans-unit>
        <trans-unit id="06cd07cfe5ceeea538fa8519602b78db4a7a221b" translate="yes" xml:space="preserve">
          <source>Passing Data between View Controllers</source>
          <target state="translated">Передача данных между контроллерами просмотра</target>
        </trans-unit>
        <trans-unit id="e969e4903b74ca67d170b3ed2c9867a31ea779e7" translate="yes" xml:space="preserve">
          <source>Passing data back from ViewController 2(destination) to viewController 1(Source) is the more interesting thing.
Assuming you use storyBoard those are all the ways i found out:</source>
          <target state="translated">Передача данных обратно из ViewController 2(destination)в viewController 1(Source)-более интересная вещь.Если предположить,что вы используете storyBoard,то это все,что я узнал:</target>
        </trans-unit>
        <trans-unit id="90994a166764b8045c671701e6012101fbad1f99" translate="yes" xml:space="preserve">
          <source>Passing data back to the previous View Controller</source>
          <target state="translated">Передача данных обратно на предыдущий просмотровый контроллер</target>
        </trans-unit>
        <trans-unit id="f34143ad2ab7c3261acf61c694d57262c6895d43" translate="yes" xml:space="preserve">
          <source>Passing data forward to a view controller from another view controller. You would use this method if you wanted to pass an object/value from one view controller to another view controller that you may be pushing on to a navigation stack.</source>
          <target state="translated">Передача данных на контроллер вида с другого контроллера вида.Этот метод используется,если вы хотите передать значение объекта с одного контроллера вида на другой контроллер вида,на который вы можете нажимать в навигационном стеке.</target>
        </trans-unit>
        <trans-unit id="72012e34fc1aeacc4018406263df2a50524a13b3" translate="yes" xml:space="preserve">
          <source>Passing data forward to the next View Controller</source>
          <target state="translated">Передача данных на следующий просмотровый контроллер</target>
        </trans-unit>
        <trans-unit id="7cbc262874edf29fb88c6eb2ae168aa523c5bed0" translate="yes" xml:space="preserve">
          <source>Passing data through notifications</source>
          <target state="translated">Передача данных через уведомления</target>
        </trans-unit>
        <trans-unit id="e73c1b3673eb3091a3411becb205b9ac61c3efb6" translate="yes" xml:space="preserve">
          <source>Passing data through the app delegate</source>
          <target state="translated">Передача данных через делегата приложения</target>
        </trans-unit>
        <trans-unit id="a915a260ebb52c58c5ddeb3943b28412a9cefd74" translate="yes" xml:space="preserve">
          <source>Please tell me if there's anything that's not clear of if I didn't understand your question properly.</source>
          <target state="translated">Пожалуйста,скажите мне,есть ли что-нибудь,что неясно,если я неправильно понял ваш вопрос.</target>
        </trans-unit>
        <trans-unit id="f176ff29bfb1c8e95257d7a079bef36426919bfd" translate="yes" xml:space="preserve">
          <source>Rather than having a highly hypothetical, abstract discussion, it helps to have concrete applications in mind. To help define a two-view-controller situation and a more-than-two-view-controller situation, I am going to define two concrete application scenarios.</source>
          <target state="translated">Вместо того,чтобы вести крайне гипотетическую,абстрактную дискуссию,она помогает иметь в виду конкретные приложения.Для того,чтобы помочь определить ситуацию с контроллером,состоящим из двух видов,и ситуацию с контроллером,состоящим из более чем двух видов,я собираюсь определить два конкретных сценария применения.</target>
        </trans-unit>
        <trans-unit id="96723c17d633897e26d4e0d1557b30b3a18133db" translate="yes" xml:space="preserve">
          <source>Read more about this in my blog post: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;Sharing Model Code&lt;/a&gt;</source>
          <target state="translated">Подробнее об этом читайте в моем блоге: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;разделение кода модели&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="a6171b282836b161fc897d0e7facdf82f4d8f378" translate="yes" xml:space="preserve">
          <source>Referencing the previous controller directly instead of using delegation</source>
          <target state="translated">Прямая ссылка на предыдущий контроллер вместо использования делегирования</target>
        </trans-unit>
        <trans-unit id="47f40c97b581997edd1f3619ce23a4265e1431df" translate="yes" xml:space="preserve">
          <source>Saving in &lt;code&gt;NSUserDefaults&lt;/code&gt; - for accessing it later</source>
          <target state="translated">Сохранение в &lt;code&gt;NSUserDefaults&lt;/code&gt; - для доступа к нему позже</target>
        </trans-unit>
        <trans-unit id="0bcf73dc223ca8c4becbbceb7de2d7cdd2d55fd9" translate="yes" xml:space="preserve">
          <source>Say we have viewControllers: ViewController and NewViewController.</source>
          <target state="translated">Скажем,у нас есть ViewControllers:ViewController и NewViewController.</target>
        </trans-unit>
        <trans-unit id="569d57f11dc5d61438be375ec49d9c3b862b507e" translate="yes" xml:space="preserve">
          <source>Say we have viewControllers: viewControllerA and viewControllerB</source>
          <target state="translated">Скажем,у нас есть viewControllers:viewControllerA и viewControllerB</target>
        </trans-unit>
        <trans-unit id="7995203d870462ca887f06daef0b98c3ee08ad6a" translate="yes" xml:space="preserve">
          <source>SecondViewController.h</source>
          <target state="translated">SecondViewController.h</target>
        </trans-unit>
        <trans-unit id="1915fd9b6120253558e8f5d765575ff18961657e" translate="yes" xml:space="preserve">
          <source>Set data in prepareForSegue (if storyboards) or init (if programmatic)</source>
          <target state="translated">Установите данные в prepareForSegue (если раскадровка)или init (если программная)</target>
        </trans-unit>
        <trans-unit id="9f9b397db477e0a2585ce2a75ed1b81d61e4549c" translate="yes" xml:space="preserve">
          <source>Set the first and second View Controllers to the appropriate Swift files in IB.</source>
          <target state="translated">Установите первый и второй просмотровые контроллеры на соответствующие файлы Swift в IB.</target>
        </trans-unit>
        <trans-unit id="ccfa21b36505d345ced6258f5060e6876076d7db" translate="yes" xml:space="preserve">
          <source>Shared data</source>
          <target state="translated">Общие данные</target>
        </trans-unit>
        <trans-unit id="63b646be139048f00d5075927d5ac6aa1bc9e3fd" translate="yes" xml:space="preserve">
          <source>Sharing data through a singleton</source>
          <target state="translated">Обмен данными через одну кнопку</target>
        </trans-unit>
        <trans-unit id="88026f64b6a3f47cdb4c499ea8d5bb82d8ae7191" translate="yes" xml:space="preserve">
          <source>Sharing data through the user defaults</source>
          <target state="translated">Обмен данными через пользовательские настройки по умолчанию</target>
        </trans-unit>
        <trans-unit id="a81942be08afc02b07b690161fca39667b375b36" translate="yes" xml:space="preserve">
          <source>Since all the view controllers do need to share the same data, all four view controllers need to remain in synchronization, and therefore there needs to be some sort of communication to all other view controllers, whenever any single view controller changes the underlying data. It should be fairly obvious that we do not want each view controller communicating directly with each other view controller in this scenario. In case it is not obvious, consider if we had 20 different view controllers (rather than just 4). How difficult and error-prone would it be to notify each of the other 19 view controllers any time one view controller made a change?</source>
          <target state="translated">Поскольку все контроллеры представлений должны совместно использовать одни и те же данные,все четыре контроллера представлений должны оставаться в синхронизации,и поэтому должна быть какая-то связь со всеми остальными контроллерами представлений,всякий раз,когда какой-либо один контроллер представления изменяет базовые данные.Должно быть довольно очевидно,что мы не хотим,чтобы каждый контроллер взгляда взаимодействовал непосредственно с другими контроллерами взглядов в этом сценарии.В случае,если это не очевидно,подумайте,было ли у нас 20 различных контроллеров представления (а не только 4).Насколько сложным и подверженным ошибкам было бы уведомление каждого из 19 других контроллеров взглядов при изменении одного контроллера взгляда?</target>
        </trans-unit>
        <trans-unit id="956ba40003839a7f10984a661afb553e5a9a4ec6" translate="yes" xml:space="preserve">
          <source>Since prepare for segue is the most common here is an example:</source>
          <target state="translated">Так как подготовка к сегменту является наиболее распространенным здесь является примером:</target>
        </trans-unit>
        <trans-unit id="39892ce8d343b16aa782fc0cc427d7c5ce4bcd1d" translate="yes" xml:space="preserve">
          <source>Singleton</source>
          <target state="translated">Singleton</target>
        </trans-unit>
        <trans-unit id="5f4a7d1855bedb7eb4c08667076bebd6d20d2643" translate="yes" xml:space="preserve">
          <source>Singleton classes</source>
          <target state="translated">Одноэлементные классы</target>
        </trans-unit>
        <trans-unit id="f4952f106d9d3b4bccd6d238d2f11b71e55ecb4c" translate="yes" xml:space="preserve">
          <source>Singletons</source>
          <target state="translated">Singletons</target>
        </trans-unit>
        <trans-unit id="b57cd7bb78daf1f63929b88ccbd517476d4ae4d7" translate="yes" xml:space="preserve">
          <source>So Here is the complete code for :</source>
          <target state="translated">Итак,вот полный код для :</target>
        </trans-unit>
        <trans-unit id="067b41481717b1f69eb20355ee8195bf00f43e67" translate="yes" xml:space="preserve">
          <source>So in-short if you want to -</source>
          <target state="translated">Так что вкратце,если хочешь...</target>
        </trans-unit>
        <trans-unit id="630e7f3acca48624176a82489c5a93d213da2351" translate="yes" xml:space="preserve">
          <source>So this is how you can pass data from viewControllerA to viewControllerB without setting any delegate. ;)</source>
          <target state="translated">Таким образом,вы можете передавать данные из viewControllerA в viewControllerB без установки какого-либо делегата ;).</target>
        </trans-unit>
        <trans-unit id="156495cd7dd5073171ae3eca350eda618cbfbef4" translate="yes" xml:space="preserve">
          <source>So this way we can pass the data from one viewcontroller to another view controller...</source>
          <target state="translated">Таким образом,мы можем передавать данные с одного контроллера вида на другой...</target>
        </trans-unit>
        <trans-unit id="9fa353fb1913b923bef4e523da2474a47221935b" translate="yes" xml:space="preserve">
          <source>So to pass a &lt;code&gt;BOOL&lt;/code&gt; from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; we would do the following:</source>
          <target state="translated">Таким образом, чтобы передать &lt;code&gt;BOOL&lt;/code&gt; из &lt;code&gt;ViewControllerA&lt;/code&gt; в &lt;code&gt;ViewControllerB&lt;/code&gt; , мы должны сделать следующее:</target>
        </trans-unit>
        <trans-unit id="98d77a00cf4d2b88573bd271f511f0e79ed4f054" translate="yes" xml:space="preserve">
          <source>Solutions I recommend NOT to use:</source>
          <target state="translated">Решения,которые я НЕ рекомендую использовать:</target>
        </trans-unit>
        <trans-unit id="b08338f95aa0ad8470939d5e2faa60ab6d042c8f" translate="yes" xml:space="preserve">
          <source>Step 1. Declare block in ViewControllerB</source>
          <target state="translated">Шаг 1.Блок объявления в ViewControllerB</target>
        </trans-unit>
        <trans-unit id="b2e9b0649764d10cd7a0faf97a6596c1df79f36a" translate="yes" xml:space="preserve">
          <source>Step 1. Set and Post data in Notification observer in ViewControllerB</source>
          <target state="translated">Шаг 1.Установка и отправка данных в Наблюдатель уведомлений в ViewControllerB</target>
        </trans-unit>
        <trans-unit id="68b389f0cd09c0cdce9598cbf02e200602cae14b" translate="yes" xml:space="preserve">
          <source>Step 2. Add Notification Observer in ViewControllerA</source>
          <target state="translated">Шаг 2.Добавить Наблюдатель уведомлений в ViewControllerA</target>
        </trans-unit>
        <trans-unit id="0b56714eef4294da9118c9f272a4110e07a65e76" translate="yes" xml:space="preserve">
          <source>Step 2. Set data in block in ViewControllerB</source>
          <target state="translated">Шаг 2.Установите данные в блоке в ViewControllerB.</target>
        </trans-unit>
        <trans-unit id="a2546740685a30020fdf8994c5e6ec2f4358487b" translate="yes" xml:space="preserve">
          <source>Step 3. Receive Notification data value in ViewControllerA</source>
          <target state="translated">Шаг 3.Получить значение данных уведомления в ViewControllerA.</target>
        </trans-unit>
        <trans-unit id="8fc7fedaa6db88ca11b7a1de1f3aca654b50e838" translate="yes" xml:space="preserve">
          <source>Step 3. Receive block data in ViewControllerA</source>
          <target state="translated">Шаг 3.Получение блочных данных в ViewControllerA</target>
        </trans-unit>
        <trans-unit id="270b96d467cbf5437502201704dee28da77c95f4" translate="yes" xml:space="preserve">
          <source>Storyboard segues, ARC and LLVM blocks make this easier than ever for me.  Some answers above mentioned storyboards and segues already but still relied on delegation.  Defining delegates certainly works but some people may find it easier to pass pointers or code blocks.</source>
          <target state="translated">Сюжетная доска сегменты,ARC и LLVM блоки делают это легче,чем когда-либо для меня.Некоторые ответы,упомянутые выше раскадровки и сегменты уже даны,но все еще полагаются на делегацию.Определение делегатов,конечно,работает,но некоторым людям проще передать указатели или блоки кода.</target>
        </trans-unit>
        <trans-unit id="3b14c615ad076500bec6990bd3e8c11b39b908a7" translate="yes" xml:space="preserve">
          <source>Suppose in Controller1 class you want to create the Controller2 object and push it with a String value being passed. This can be done as this:-</source>
          <target state="translated">Предположим,что в классе Controller1 нужно создать объект Controller2 и нажать на него с переданным значением String.Это можно сделать следующим образом:-</target>
        </trans-unit>
        <trans-unit id="112ab020698e5fc0f4baecd7821a512d8c419a69" translate="yes" xml:space="preserve">
          <source>Swift</source>
          <target state="translated">Swift</target>
        </trans-unit>
        <trans-unit id="19d9195fc6303123e2881ef15e4a993bb8b3dec5" translate="yes" xml:space="preserve">
          <source>Synthesize str2 in ViewControllerTwo.m</source>
          <target state="translated">Синтезировать str2 в ViewControllerTwo.m</target>
        </trans-unit>
        <trans-unit id="0207a1f2edfc990bff7a614c26a4e4edee42239e" translate="yes" xml:space="preserve">
          <source>Take care for spelling mistakes.</source>
          <target state="translated">Позаботься о орфографических ошибках.</target>
        </trans-unit>
        <trans-unit id="09429d005a789be54befa1f80bc0eeaac578f2e8" translate="yes" xml:space="preserve">
          <source>Than in implementation file BViewController.m after we have desired values to return our callback should be called:</source>
          <target state="translated">Чем в реализационном файле BViewController.m после того,как у нас есть желаемые значения,чтобы вернуть наш обратный вызов должен быть вызван:</target>
        </trans-unit>
        <trans-unit id="03d7f840d11dff1bc5d8b6d191428b355e3aebb7" translate="yes" xml:space="preserve">
          <source>Thanks for all your help</source>
          <target state="translated">Спасибо за помощь</target>
        </trans-unit>
        <trans-unit id="8527cb919ee3a95cff65ca01028642d6226a89b6" translate="yes" xml:space="preserve">
          <source>That is how you can tackle it if you want to use a segue and you don't have your pages under a navigation controller.</source>
          <target state="translated">Вот как вы можете справиться с этим,если вы хотите использовать сегмент,а ваши страницы не находятся под навигационным контроллером.</target>
        </trans-unit>
        <trans-unit id="95e8fe02f9d9ffb578ba4e865a2725ad960d20a6" translate="yes" xml:space="preserve">
          <source>That's it for &lt;code&gt;ViewControllerB&lt;/code&gt;. Now in &lt;code&gt;ViewControllerA.h&lt;/code&gt;, tell &lt;code&gt;ViewControllerA&lt;/code&gt; to import &lt;code&gt;ViewControllerB&lt;/code&gt; and conform to its protocol.</source>
          <target state="translated">Вот и все для &lt;code&gt;ViewControllerB&lt;/code&gt; . Теперь в &lt;code&gt;ViewControllerA.h&lt;/code&gt; скажите &lt;code&gt;ViewControllerA&lt;/code&gt; , чтобы он импортировал &lt;code&gt;ViewControllerB&lt;/code&gt; и соответствовал его протоколу.</target>
        </trans-unit>
        <trans-unit id="56ac635adbb66b598268b04a53cefa274b67ac90" translate="yes" xml:space="preserve">
          <source>That's it. Running the app now you should be able to send data back from the second view controller to the first.</source>
          <target state="translated">Вот так.Запустив приложение,вы сможете отправлять данные со второго контроллера просмотра на первый.</target>
        </trans-unit>
        <trans-unit id="61f175a537a69568d4d36d5d1c44c51c042c2dc5" translate="yes" xml:space="preserve">
          <source>The M in MVC is for &quot;Model&quot; and in the MVC paradigm the role of model classes is to manage a program's data. A model is the opposite of a view -- a view knows how to display data, but it knows nothing about what to do with data, whereas a model knows everything about how to work with data, but nothing about how to display it. Models can be complicated, but they don't have to be -- the model for your app might be as simple as an array of strings or dictionaries.</source>
          <target state="translated">M в MVC-для &quot;Модели&quot;,а в парадигме MVC роль модельных классов заключается в управлении данными программы.Модель является противоположностью представления-представление знает,как отображать данные,но ничего не знает о том,что делать с данными,в то время как модель знает все о том,как работать с данными,но ничего о том,как их отображать.Модели могут быть сложными,но не обязательно-модель для вашего приложения может быть такой же простой,как массив строк или словари.</target>
        </trans-unit>
        <trans-unit id="de4d0fb8549c6a726ff58a67a687beaccbe06a26" translate="yes" xml:space="preserve">
          <source>The OP didn't mention view controllers but so many of the answers do, that I wanted to chime in with what some of the new features of the LLVM allow to make this easier when wanting to pass data from one view controller to another and then getting some results back.</source>
          <target state="translated">В ОП не упоминались контроллеры просмотра,но так много ответов было,что мне захотелось перекликнуться с тем,что некоторые из новых возможностей LLVM позволяют сделать это проще,когда нужно передать данные с одного контроллера просмотра на другой,а затем получить некоторые результаты обратно.</target>
        </trans-unit>
        <trans-unit id="c20529383e6407f57b3ff8211721c8adde0bba28" translate="yes" xml:space="preserve">
          <source>The Receiver</source>
          <target state="translated">Приемник</target>
        </trans-unit>
        <trans-unit id="4154dd7ff0aa610daf859664a9f5cdd415da28f3" translate="yes" xml:space="preserve">
          <source>The Segue</source>
          <target state="translated">Сег</target>
        </trans-unit>
        <trans-unit id="ebcf3ab1a842c17f7a5edda449755a002af952e2" translate="yes" xml:space="preserve">
          <source>The Sender</source>
          <target state="translated">Отправитель</target>
        </trans-unit>
        <trans-unit id="b93bdfec7ee7436d0d31a07d163e319c506ba2dd" translate="yes" xml:space="preserve">
          <source>The code for the First View Controller is</source>
          <target state="translated">Код для контроллера первого просмотра</target>
        </trans-unit>
        <trans-unit id="16d83b85f70f1ef1d672a4056bde27f526c1f3e4" translate="yes" xml:space="preserve">
          <source>The code for the second view controller is</source>
          <target state="translated">Код для контроллера второго вида</target>
        </trans-unit>
        <trans-unit id="1427436496c2ed01688bdba0dfac3d0163918947" translate="yes" xml:space="preserve">
          <source>The following is an example based on the video (with a few modifications).</source>
          <target state="translated">Ниже приведен пример,основанный на видео (с некоторыми изменениями).</target>
        </trans-unit>
        <trans-unit id="27168310b19624bfd7d1406057bd1581233f19b9" translate="yes" xml:space="preserve">
          <source>The following is an example based on the video. The idea is to pass a string from the text field in the First View Controller to the label in the Second View Controller.</source>
          <target state="translated">Ниже приведен пример,основанный на видео.Идея состоит в том,чтобы передать строку из текстового поля в первом контроллере просмотра в метку во втором контроллере просмотра.</target>
        </trans-unit>
        <trans-unit id="07cf6b0d487458fa179fc57899f7a0abf454ed14" translate="yes" xml:space="preserve">
          <source>The home inventory application would have a single instance of a class which is designed to manage a list of inventory items. The manager would manage a collection of household items. The following is a class definition for the data manager:</source>
          <target state="translated">Приложение для домашней инвентаризации будет иметь один экземпляр класса,который предназначен для управления списком инвентарных единиц.Менеджер будет управлять коллекцией предметов домашнего обихода.Ниже приводится определение класса для менеджера данных:</target>
        </trans-unit>
        <trans-unit id="3883ea5969f34a183a8fdf68d24a5c4df97e7e94" translate="yes" xml:space="preserve">
          <source>The idea is imitate Android's intent paradigm, using a global factory to manage which view you are looking at and using &quot;intents&quot; to switch and pass data between views. All the documentation is on the github page, but here are some highlights:</source>
          <target state="translated">Идея заключается в имитации парадигмы намерений Android,используя глобальную фабрику для управления тем,на какое представление вы смотрите,и используя &quot;намерения&quot; для переключения и передачи данных между представлениями.Вся документация находится на странице github,но вот некоторые основные моменты:</target>
        </trans-unit>
        <trans-unit id="f4deb3d745148fadb3c8578e557f0283203b359a" translate="yes" xml:space="preserve">
          <source>The most common way I've seen this done is a &lt;a href=&quot;http://koreyhinton.com/blog/singleton-pattern-in-swift.html&quot;&gt;singleton&lt;/a&gt; instance. So if your singleton object was &lt;code&gt;DataAccess&lt;/code&gt; you could do the following in the viewDidLoad method of UIViewController:</source>
          <target state="translated">Наиболее распространенный способ, которым я видел это, - &lt;a href=&quot;http://koreyhinton.com/blog/singleton-pattern-in-swift.html&quot;&gt;одноэлементный&lt;/a&gt; экземпляр. Поэтому, если ваш одноэлементный объект был &lt;code&gt;DataAccess&lt;/code&gt; , вы можете сделать следующее в методе viewDidLoad UIViewController:</target>
        </trans-unit>
        <trans-unit id="270c440ea6ee47f9a7fab1f1471c613f9ba1ab40" translate="yes" xml:space="preserve">
          <source>The nice thing about Core Data is that it has inverse relationships. So if you want to just give a NotesViewController the notes object you can because it'll have an inverse relationship to something else like the notebook. If you need data on the notebook in the NotesViewController you can walk back up the object graph by doing the following:</source>
          <target state="translated">Самое приятное в Core Data то,что у него обратные отношения.Так что если вы хотите просто дать NotesViewController объект notes,вы можете,потому что он будет иметь обратную связь с чем-то другим,например,ноутбуком.Если вам нужны данные на ноутбуке в NotesViewController,вы можете вернуться к объектной диаграмме,сделав следующее:</target>
        </trans-unit>
        <trans-unit id="014260d3b948862434b9fa2f84c8640f401e09aa" translate="yes" xml:space="preserve">
          <source>The original poster also asked about &lt;strong&gt;Singletons&lt;/strong&gt; and the use of the &lt;strong&gt;AppDelegate&lt;/strong&gt;. These questions need to be answered.</source>
          <target state="translated">Оригинальный постер также спрашивал о &lt;strong&gt;Singletons&lt;/strong&gt; и использовании &lt;strong&gt;AppDelegate&lt;/strong&gt; . На эти вопросы нужно ответить.</target>
        </trans-unit>
        <trans-unit id="4051bc4c8e14e8ba896618084a6ea2e97b0c1335" translate="yes" xml:space="preserve">
          <source>The question asks about passing information between view controllers. The specific example given asks about passing information between views, but given the self-stated newness to iOS, the original poster likely meant between viewControllers, not between views (without any involvement from the ViewControllers). It seems that all the answers focus on two view controllers, but what if the app evolves to need to involve more than two view controllers in the information exchange?</source>
          <target state="translated">Вопрос касается передачи информации между контроллерами просмотра.В конкретном примере задается вопрос о передаче информации между представлениями,но с учетом самодостаточной новизны iOS,оригинальный плакат,скорее всего,означает между контроллерами представлений,а не между представлениями (без какого-либо участия контроллеров представлений).Кажется,что все ответы сфокусированы на двух контроллерах представлений,но что,если приложение эволюционирует и ему понадобится вовлечь в обмен информацией более двух контроллеров представлений?</target>
        </trans-unit>
        <trans-unit id="63899f87ba40f61b456ad097f7880f169dadb468" translate="yes" xml:space="preserve">
          <source>The role of a controller is to mediate between view and model. Therefore, they need a reference to one or more view objects and one or more model objects. Let's say that your model is an array of dictionaries, with each dictionary representing one row in your table. The root view for your app displays that table, and it might be responsible for loading the array from a file. When the user decides to add a new row to the table, they tap some button and your controller creates a new (mutable) dictionary and adds it to the array. In order to fill in the row, the controller creates a detail view controller and gives it the new dictionary. The detail view controller fills in the dictionary and returns. The dictionary is already part of the model, so nothing else needs to happen.</source>
          <target state="translated">Роль контроллера заключается в посредничестве между представлением и моделью.Поэтому им нужна ссылка на один или несколько объектов представления и один или несколько объектов модели.Допустим,ваша модель представляет собой массив словарей,каждый из которых представляет одну строку в вашей таблице.Корневое представление для вашего приложения отображает эту таблицу,и оно может отвечать за загрузку массива из файла.Когда пользователь решает добавить новую строку в таблицу,он нажимает какую-нибудь кнопку,и ваш контроллер создает новый (mutable)словарь и добавляет его в массив.Для заполнения строки контроллер создает детальный контроллер представления и предоставляет ему новый словарь.Контроллер детального представления заполняет словарь и возвращает его.Словарь уже является частью модели,поэтому больше ничего не нужно делать.</target>
        </trans-unit>
        <trans-unit id="862d75bb0f5e8e1bf177a0884bd45d4099f46cae" translate="yes" xml:space="preserve">
          <source>Then where you want to load the view eg. &lt;code&gt;didSelectRowAtIndex&lt;/code&gt; or some &lt;code&gt;IBAction&lt;/code&gt; you need to set the property in &lt;code&gt;ViewControllerB&lt;/code&gt; before you push it onto nav stack.</source>
          <target state="translated">Тогда где вы хотите загрузить вид, например. &lt;code&gt;didSelectRowAtIndex&lt;/code&gt; или какой-либо &lt;code&gt;IBAction&lt;/code&gt; , вам нужно установить свойство в &lt;code&gt;ViewControllerB&lt;/code&gt; , прежде чем вы поместите его в стек навигации.</target>
        </trans-unit>
        <trans-unit id="5db5c8fd4b2f27895e7362cba1af3ede532b9753" translate="yes" xml:space="preserve">
          <source>There are addition tools that also help pass along data:</source>
          <target state="translated">Существуют дополнительные инструменты,которые также помогают передавать данные:</target>
        </trans-unit>
        <trans-unit id="31d86b3beff40f0926f74e37f90530611aeeffd6" translate="yes" xml:space="preserve">
          <source>There are four view controllers in the application. It is a tab-based application for managing home inventory. Three view controllers present differently filtered views of the same data:</source>
          <target state="translated">В приложении есть четыре контроллера просмотра.Это приложение на основе закладок для управления домашней инвентаризацией.Три контроллера представления представляют различные отфильтрованные представления одних и тех же данных:</target>
        </trans-unit>
        <trans-unit id="e97a58b0ba4425fd3070b8fbcc8e0520fcec97d9" translate="yes" xml:space="preserve">
          <source>There are many answers to this questions offering many different ways to perform view controller communication that would indeed work, but I don't see anywhere mentioned which one are actually best to use and which ones to avoid.</source>
          <target state="translated">Существует множество ответов на эти вопросы,предлагающих множество различных способов выполнения взаимодействия контроллера просмотра,которые действительно работали бы,но я не вижу нигде упоминания о том,какой из них лучше всего использовать,а какой следует избегать.</target>
        </trans-unit>
        <trans-unit id="dbd19e78c5369d7ba92070651ccf13b36f340393" translate="yes" xml:space="preserve">
          <source>There are multiple methods for sharing data.</source>
          <target state="translated">Существует несколько методов обмена данными.</target>
        </trans-unit>
        <trans-unit id="e8c21a80ff30368c9db68fd252bbe172753c326e" translate="yes" xml:space="preserve">
          <source>There are multiple options for Passing Data between View Controllers.</source>
          <target state="translated">Существует несколько вариантов передачи данных между контроллерами вида.</target>
        </trans-unit>
        <trans-unit id="6b070a9e49cdb6fb5eedc6805c49fc2267e7f279" translate="yes" xml:space="preserve">
          <source>There are three parts.</source>
          <target state="translated">Есть три части.</target>
        </trans-unit>
        <trans-unit id="960919526c1232c2ceccc14249d25e632af94356" translate="yes" xml:space="preserve">
          <source>There are tons and tons of explanations here and around StackOverflow, but if you are a beginner just trying to get something basic to work, try watching this YouTube tutorial (It's what helped me to finally understand how to do it).</source>
          <target state="translated">Здесь и вокруг StackOverflow есть тонны и тонны объяснений,но если вы новичок,просто пытающийся получить что-то базовое для работы,попробуйте посмотреть это учебное пособие на YouTube (Это то,что помогло мне,наконец,понять,как это сделать).</target>
        </trans-unit>
        <trans-unit id="e8afd6f06c1bbab721680e593a168e06c21f9e95" translate="yes" xml:space="preserve">
          <source>There are tons of ways to do this and it's important to pick the right one. Probably one of the biggest architectural decisions lies on how the model code will be shared or accessed throughout the app.</source>
          <target state="translated">Есть много способов сделать это,и важно выбрать правильный.Наверное,одно из самых больших архитектурных решений заключается в том,как код модели будет совместно использоваться или доступен в рамках всего приложения.</target>
        </trans-unit>
        <trans-unit id="add7b260a0c3a797d43225e8dd73c9d548468567" translate="yes" xml:space="preserve">
          <source>There are two view controllers in the application. There is a ViewControllerA (Data Entry Form), and View Controller B (Product List). The items selected in the product list must match the items displayed in the text box in the data entry form. In this scenario, ViewControllerA and ViewControllerB must communicate directly with each other and no other view controllers.</source>
          <target state="translated">В приложении есть два контроллера просмотра.Есть ViewControllerA (форма ввода данных)и View Controller B (список продуктов).Элементы,выбранные в списке продуктов,должны соответствовать элементам,отображаемым в текстовом поле формы ввода данных.В этом сценарии ViewControllerA и ViewControllerB должны взаимодействовать непосредственно друг с другом,а не с другими контроллерами просмотра.</target>
        </trans-unit>
        <trans-unit id="5ad48280e06634ee952854dfb7d646a39384f662" translate="yes" xml:space="preserve">
          <source>There are various ways by which a data can be received to a different class in iOS. For example -</source>
          <target state="translated">Существуют различные способы получения данных в iOS в другой класс.Например -</target>
        </trans-unit>
        <trans-unit id="6366268fa2a29045a4f2964c6049a44dee20ec43" translate="yes" xml:space="preserve">
          <source>There is some good information in many of the answers given, but none address the question fully.</source>
          <target state="translated">Во многих ответах есть хорошая информация,но ни в одном из них вопрос не рассматривается полностью.</target>
        </trans-unit>
        <trans-unit id="2244b353f7eacc064ac43be42125be2888874124" translate="yes" xml:space="preserve">
          <source>These solutions, although working in the short term, introduce too many dependencies that will garble the architecture of the app and create more problems later.</source>
          <target state="translated">Эти решения,хотя и работают в краткосрочной перспективе,но вводят слишком много зависимостей,которые будут искажать архитектуру приложения и создавать больше проблем в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="4feffb40e53daab15d1fd2a31b491d1a986d94e5" translate="yes" xml:space="preserve">
          <source>This example passes data from &lt;strong&gt;Controller B&lt;/strong&gt; to &lt;strong&gt;Controller A&lt;/strong&gt;</source>
          <target state="translated">В этом примере данные &lt;strong&gt;передаются&lt;/strong&gt; с &lt;strong&gt;контроллера B&lt;/strong&gt; на &lt;strong&gt;контроллер A&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72942e4d622ebca94f54d92fc991209dbbc62e1b" translate="yes" xml:space="preserve">
          <source>This is a very simple view layout with a segue between them.</source>
          <target state="translated">Это очень простая компоновка вида с сегментом между ними.</target>
        </trans-unit>
        <trans-unit id="dc585b46d7fdc70eda1e5bd71fce0fb21a21baaf" translate="yes" xml:space="preserve">
          <source>This is not the way to do it, you should use delegates, I'll assume we have two view controllers ViewController1 and ViewController2 and this check thing is in the first one and when its state changes, you want to do something in ViewController2, to achieve that in the proper way, you should do the below:</source>
          <target state="translated">Это не тот способ,нужно использовать делегатов,я предполагаю,что у нас есть два контроллера просмотра ViewController1 и ViewController2,и эта проверка находится в первом,и когда его состояние меняется,нужно что-то делать в ViewController2,чтобы добиться этого правильным способом,нужно сделать следующее:</target>
        </trans-unit>
        <trans-unit id="8073a2ecfc42ee7250cf1e560c182673934a6f7f" translate="yes" xml:space="preserve">
          <source>This page just sends the value of the variable to the console when it loads.  By this point, our favorite movie should be in that variable.</source>
          <target state="translated">Эта страница просто отправляет значение переменной в консоль при загрузке.К этому моменту наш любимый фильм должен быть в этой переменной.</target>
        </trans-unit>
        <trans-unit id="53aebdd79abe6d5b1bdd1f334b4ef03089ec8441" translate="yes" xml:space="preserve">
          <source>This page takes the initially loaded value and passes it along.</source>
          <target state="translated">Эта страница берет первоначально загруженное значение и передает его дальше.</target>
        </trans-unit>
        <trans-unit id="7c7f8bc26f34edac64e4f9e9a10d6758f2fd6803" translate="yes" xml:space="preserve">
          <source>This question seems to be very popular here on stackoverflow so I thought I would try and give a better answer to help out people starting in the world of iOS like me.</source>
          <target state="translated">Этот вопрос кажется очень популярным здесь на stackoverflow,так что я решил попробовать дать лучший ответ,чтобы помочь людям,начинающим в мире iOS,как я.</target>
        </trans-unit>
        <trans-unit id="17b7883c0d9c134005d8b98f4a635cdcdce103d0" translate="yes" xml:space="preserve">
          <source>This second example shows passing a callback block for the second argument.  I like using blocks because it keeps the relevant details close together in the source - the higher level source.</source>
          <target state="translated">Этот второй пример показывает передачу блока обратного вызова для второго аргумента.Мне нравится использовать блоки,потому что они держат соответствующие детали близко друг к другу в источнике-источнике более высокого уровня.</target>
        </trans-unit>
        <trans-unit id="5f05e53b88ac8f87becf055c72279b70a06d25c6" translate="yes" xml:space="preserve">
          <source>This will set &lt;code&gt;isSomethingEnabled&lt;/code&gt; in &lt;code&gt;ViewControllerB&lt;/code&gt; to &lt;code&gt;BOOL&lt;/code&gt; value &lt;code&gt;YES&lt;/code&gt;.</source>
          <target state="translated">Это установит &lt;code&gt;isSomethingEnabled&lt;/code&gt; в &lt;code&gt;ViewControllerB&lt;/code&gt; в значение &lt;code&gt;BOOL&lt;/code&gt; &lt;code&gt;YES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702efc9cba1bbd3afb5e2a9f9ce7d9ec865cbd29" translate="yes" xml:space="preserve">
          <source>Those were  discussed here already.</source>
          <target state="translated">Это уже обсуждалось здесь.</target>
        </trans-unit>
        <trans-unit id="83ec681c5928fb675fe4016bcba307422f910286" translate="yes" xml:space="preserve">
          <source>To do this we will make &lt;code&gt;ViewControllerA&lt;/code&gt; a delegate of &lt;code&gt;ViewControllerB&lt;/code&gt;. This allows &lt;code&gt;ViewControllerB&lt;/code&gt; to send a message back to &lt;code&gt;ViewControllerA&lt;/code&gt; enabling us to send data back.</source>
          <target state="translated">Для этого мы сделаем &lt;code&gt;ViewControllerA&lt;/code&gt; делегатом &lt;code&gt;ViewControllerB&lt;/code&gt; . Это позволяет &lt;code&gt;ViewControllerB&lt;/code&gt; отправлять сообщение обратно &lt;code&gt;ViewControllerA&lt;/code&gt; , что позволяет нам отправлять данные обратно.</target>
        </trans-unit>
        <trans-unit id="3555496de4df0b39a8ca1903be2fae52ab2bbaf3" translate="yes" xml:space="preserve">
          <source>To help anyone else looking at this question, who wants a full answer, I'm going to attempt to provide it.</source>
          <target state="translated">Чтобы помочь всем,кто смотрит на этот вопрос,кто хочет получить на него полный ответ,я постараюсь его предоставить.</target>
        </trans-unit>
        <trans-unit id="86f2cf886389b424cfb810b4716cc6f04bb3d86b" translate="yes" xml:space="preserve">
          <source>To pass a &lt;code&gt;BOOL&lt;/code&gt; value from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; we would do the following.</source>
          <target state="translated">Чтобы передать значение &lt;code&gt;BOOL&lt;/code&gt; из &lt;code&gt;ViewControllerA&lt;/code&gt; в &lt;code&gt;ViewControllerB&lt;/code&gt; , мы должны сделать следующее.</target>
        </trans-unit>
        <trans-unit id="76a9d2c2e66054b80996174e8affc8b1fb823ba9" translate="yes" xml:space="preserve">
          <source>To pass data back from &lt;code&gt;ViewControllerB&lt;/code&gt; to &lt;code&gt;ViewControllerA&lt;/code&gt; you need to use &lt;em&gt;Protocols and Delegates&lt;/em&gt; or &lt;em&gt;Blocks&lt;/em&gt;, the latter can be used as a loosely coupled mechanism for callbacks.</source>
          <target state="translated">Чтобы передать данные обратно из &lt;code&gt;ViewControllerB&lt;/code&gt; в &lt;code&gt;ViewControllerA&lt;/code&gt; , вам нужно использовать &lt;em&gt;протоколы и делегаты&lt;/em&gt; или &lt;em&gt;блоки&lt;/em&gt; , последние можно использовать как слабосвязанный механизм для обратных вызовов.</target>
        </trans-unit>
        <trans-unit id="e3d70b08f9dc80f74d10c82b4cd60670d8719e71" translate="yes" xml:space="preserve">
          <source>To pass data back from the second view controller to the first view controller, you use &lt;a href=&quot;https://stackoverflow.com/a/33549729/3681880&quot;&gt;a protocol and a delegate&lt;/a&gt;. This video is a very clear walk though of that process:</source>
          <target state="translated">Чтобы передать данные из второго контроллера представления в первый контроллер представления, вы используете &lt;a href=&quot;https://stackoverflow.com/a/33549729/3681880&quot;&gt;протокол и делегат&lt;/a&gt; . Это видео представляет собой очень четкое описание этого процесса:</target>
        </trans-unit>
        <trans-unit id="af916557c74c3f51d623fa988c413ad3e34f0d4f" translate="yes" xml:space="preserve">
          <source>To pass data backwards</source>
          <target state="translated">Для передачи данных в обратном направлении</target>
        </trans-unit>
        <trans-unit id="4441e2165a2cbe180a97d71650d577cbf837d6f0" translate="yes" xml:space="preserve">
          <source>To pass data forward:</source>
          <target state="translated">Для передачи данных вперёд:</target>
        </trans-unit>
        <trans-unit id="7c739773a6d176365e02604ef2ba8b5fd773295f" translate="yes" xml:space="preserve">
          <source>To pass multiple values you can use the multiple parameters like :-</source>
          <target state="translated">Для передачи нескольких значений можно использовать несколько параметров типа :-</target>
        </trans-unit>
        <trans-unit id="6f53c9cc79789d2d8364b25f78aa09dd33f52a64" translate="yes" xml:space="preserve">
          <source>Understanding the Core Architectural Principles of iOS Development with a Practical Example</source>
          <target state="translated">Понимание основных архитектурных принципов разработки iOS на практическом примере</target>
        </trans-unit>
        <trans-unit id="df0a8289feb92488ac5fae24f2db741969a2acff" translate="yes" xml:space="preserve">
          <source>User defaults</source>
          <target state="translated">Пользовательские настройки по умолчанию</target>
        </trans-unit>
        <trans-unit id="c2f8f14f958b77389a48a3fc1d929fbaf7455857" translate="yes" xml:space="preserve">
          <source>Using Block</source>
          <target state="translated">Блок использования</target>
        </trans-unit>
        <trans-unit id="35e87779d93205c9cdc86bc39ef7d0b7dce13230" translate="yes" xml:space="preserve">
          <source>Using Delegate</source>
          <target state="translated">Использование Делегата</target>
        </trans-unit>
        <trans-unit id="73cc3f60dc8287f62aa63d4644544e391cbe3bb3" translate="yes" xml:space="preserve">
          <source>Using Navigation Controller Push</source>
          <target state="translated">Использование Навигационный контроллер Нажатие</target>
        </trans-unit>
        <trans-unit id="52e7b3127ded3378ce3725c8ccc384212ac615ad" translate="yes" xml:space="preserve">
          <source>Using Notification Observer</source>
          <target state="translated">Использование Notification Observer</target>
        </trans-unit>
        <trans-unit id="02bbe182682f0bbed6aeec5deb6f00b94667bbc3" translate="yes" xml:space="preserve">
          <source>Using Segue</source>
          <target state="translated">Использование Segue</target>
        </trans-unit>
        <trans-unit id="0d6f7bc3f49a828edf12dd0581aaa92e4ef44e6e" translate="yes" xml:space="preserve">
          <source>ViewControllerA - Luxury Items</source>
          <target state="translated">ViewControllerA-предметы роскоши</target>
        </trans-unit>
        <trans-unit id="e5ffea5e8eb8d723ab0498aa5a4d88e881a60886" translate="yes" xml:space="preserve">
          <source>ViewControllerB - Non-insured Items</source>
          <target state="translated">ViewControllerB-Объекты,не являющиеся объектами страхования</target>
        </trans-unit>
        <trans-unit id="e7a39785336a96e44901846cba211ded9e0abc2e" translate="yes" xml:space="preserve">
          <source>ViewControllerC - Entire Home Inventory</source>
          <target state="translated">ViewControllerC-Вся домашняя инвентаризация</target>
        </trans-unit>
        <trans-unit id="135d305cf4a08db515d94b35f7f6f4250be7f807" translate="yes" xml:space="preserve">
          <source>ViewControllerD - Add New Item Form</source>
          <target state="translated">ViewControllerD-добавить форму нового элемента</target>
        </trans-unit>
        <trans-unit id="81942d9a4347a174680fafdd5ec8b8b344284237" translate="yes" xml:space="preserve">
          <source>We are keeping this simple so no buttons, not actions, we are simply moving data from the sender to the receiver when the application loads and then outputting the transmitted value to the console.</source>
          <target state="translated">Мы все упрощаем,поэтому никаких кнопок,никаких действий,мы просто перемещаем данные от отправителя к получателю,когда приложение загружается,а затем выводим переданное значение на консоль.</target>
        </trans-unit>
        <trans-unit id="ff03a716d90bbf29f516cac4b83abbaba194bc8c" translate="yes" xml:space="preserve">
          <source>We can understand it using two controllers - &lt;strong&gt;Controller1 and Controller2&lt;/strong&gt;</source>
          <target state="translated">Мы можем понять это, используя два контроллера - &lt;strong&gt;Controller1 и Controller2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f75d1fd3c3fa39412cf75f97e5bcfb258a2d5a9" translate="yes" xml:space="preserve">
          <source>Well &lt;a href=&quot;https://stackoverflow.com/a/9736559/1371853&quot;&gt;Matt Price's Answer&lt;/a&gt; is perfectly fine for passing data but I
  am going to rewrite it, in Latest Swift version because I believe new
  programmers find it quit challenging due to new Syntax and
  methods/frameworks, as original post is in Objective-C.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/9736559/1371853&quot;&gt;Ответ Мэтта Прайса&lt;/a&gt; отлично подходит для передачи данных, но я собираюсь переписать его, в последней версии Swift, потому что я верю, что новые программисты считают, что это перестает вызывать проблемы из-за нового синтаксиса и методов / фреймворков, как в оригинальном посте в Objective-C.</target>
        </trans-unit>
        <trans-unit id="95ed8045cbbb7af3a960ea88cfa49e1488ceac17" translate="yes" xml:space="preserve">
          <source>What would be the correct way of performing this and how would I go about it?</source>
          <target state="translated">Как бы правильно исполнить это и как бы я это сделал?</target>
        </trans-unit>
        <trans-unit id="8a4e940579167cf02a3ba46b206936601e18844d" translate="yes" xml:space="preserve">
          <source>When the collection of home inventory items changes, the view controllers need to be made aware of this change. The class definition above does not make it obvious how this will happen. We need to follow the observer pattern. The view controllers must formally observe the sharedManager. There are two ways to observe another object:</source>
          <target state="translated">При изменении коллекции предметов домашнего обихода необходимо обратить внимание контроллеров просмотра на это изменение.Определение класса,приведенное выше,не делает очевидным,как это произойдет.Нужно следовать шаблону наблюдателя.Контроллеры вида должны формально наблюдать за работой sharedManager.Есть два способа наблюдения за другим объектом:</target>
        </trans-unit>
        <trans-unit id="d89b94ecc160001694e602dfbde749a28101857f" translate="yes" xml:space="preserve">
          <source>With UINavigators and segues, there are easy ways of passing information to the subservient controller and getting the information back.  ARC makes passing pointers to things derived from NSObjects simple so if you want the subservient controller to add/change/modify some data for you, pass it a pointer to a mutable instance.  Blocks make passing actions easy so if you want the subservient controller to invoke an action on your higher level controller, pass it a block.  You define the block to accept any number of arguments that makes sense to you.  You can also design the API to use multiple blocks if that suits things better.</source>
          <target state="translated">С помощью UINavigators и сегментов можно легко передавать информацию подчиненному контроллеру и получать ее обратно.ARC делает передачу указателей на вещи,полученные из NSObjects простыми,так что если вы хотите,чтобы подчинённый контроллер модифицировал некоторые данные для вас,передайте ему указатель на мутируемый экземпляр.Блоки облегчают передачу экшенов,поэтому если вы хотите,чтобы подчинённый контроллер вызывал экшен на вашем контроллере более высокого уровня,передайте ему блок.Вы определяете блок,который будет принимать любое количество аргументов,имеющих для вас смысл.Вы также можете спроектировать API для использования нескольких блоков,если это подходит лучше.</target>
        </trans-unit>
        <trans-unit id="eb4193cf6b58cbdb5fa018799e8c3e460fd383dc" translate="yes" xml:space="preserve">
          <source>Worked fine and allowed me to pass a string and an array forward and back between my views.</source>
          <target state="translated">Прекрасно сработало и позволило мне передать строку и массив вперед и назад между моими представлениями.</target>
        </trans-unit>
        <trans-unit id="27deb3303dc171f62381c3af6e857bbf1acf83bb" translate="yes" xml:space="preserve">
          <source>You can also create custom delegates for this.</source>
          <target state="translated">Для этого вы также можете создать собственных делегатов.</target>
        </trans-unit>
        <trans-unit id="1a3ff3057c97981bf35a32f3b4007efceb28f6a3" translate="yes" xml:space="preserve">
          <source>You can also directly set the properties of the Controller2 class in the similar way as this:</source>
          <target state="translated">Также можно напрямую настроить свойства класса Controller2 аналогичным образом:</target>
        </trans-unit>
        <trans-unit id="e9e418ef389cb9594cfd0c613d54195e941dba88" translate="yes" xml:space="preserve">
          <source>You can always share data using &lt;code&gt;NSUserDefaults&lt;/code&gt;. Set the value you want to share with respect to a key of your choice and get the value from &lt;code&gt;NSUserDefault&lt;/code&gt; associated to that key in the next view controller.</source>
          <target state="translated">Вы всегда можете поделиться данными, используя &lt;code&gt;NSUserDefaults&lt;/code&gt; . Установите значение, которым вы хотите поделиться в отношении ключа по вашему выбору, и получите значение из &lt;code&gt;NSUserDefault&lt;/code&gt; , связанного с этим ключом в следующем контроллере представления.</target>
        </trans-unit>
        <trans-unit id="a7d7d2e500cdd3b21928259a0c992d9c6ea65145" translate="yes" xml:space="preserve">
          <source>You can just create a property in &lt;code&gt;viewcontrollerA&lt;/code&gt;. Create an object of &lt;code&gt;viewcontrollerA&lt;/code&gt; in &lt;code&gt;viewcontrollerB&lt;/code&gt; and assign the desired value to that property.</source>
          <target state="translated">Вы можете просто создать свойство в &lt;code&gt;viewcontrollerA&lt;/code&gt; . Создайте объект &lt;code&gt;viewcontrollerA&lt;/code&gt; в &lt;code&gt;viewcontrollerB&lt;/code&gt; и назначьте требуемое значение этому свойству.</target>
        </trans-unit>
        <trans-unit id="abfb49ee8dd0bcc5f71fa827feb6ceb49bd14bd1" translate="yes" xml:space="preserve">
          <source>You can save data in App delegate to access it across view controllers in your application. All you have to do is create a shared instance of app delegate</source>
          <target state="translated">Вы можете сохранить данные в папке &quot;Делегат App&quot;,чтобы получить доступ к ним на всех контроллерах просмотра в вашем приложении.Все,что вам нужно сделать,это создать разделяемый экземпляр делегата приложения.</target>
        </trans-unit>
        <trans-unit id="576941d1618435efb4e91b03c919b15afddc8a68" translate="yes" xml:space="preserve">
          <source>You setup all your views in .XIB files and register them in the app delegate, while initializing the factory.</source>
          <target state="translated">Вы настраиваете все свои представления в .XIB файлах и регистрируете их в приложении делегата,одновременно инициализируя завод.</target>
        </trans-unit>
        <trans-unit id="1e2fbc115bc2af08bed183bab4b31314c65a2dc1" translate="yes" xml:space="preserve">
          <source>YouTube tutorial: &lt;a href=&quot;https://www.youtube.com/watch?v=9LHDsSWc680&quot;&gt;iOS Swift Basics Tutorial: Protocols and Delegates&lt;/a&gt; But also read &lt;a href=&quot;http://krakendev.io/blog/weak-and-unowned-references-in-swift&quot;&gt;this post&lt;/a&gt; to make sure you don't get into a strong reference cycle.</source>
          <target state="translated">Учебник YouTube: &lt;a href=&quot;https://www.youtube.com/watch?v=9LHDsSWc680&quot;&gt;Учебник по основам iOS Swift: протоколы и делегаты&lt;/a&gt; Но также прочитайте &lt;a href=&quot;http://krakendev.io/blog/weak-and-unowned-references-in-swift&quot;&gt;этот пост,&lt;/a&gt; чтобы убедиться, что вы не попали в сильный справочный цикл.</target>
        </trans-unit>
        <trans-unit id="72d5f33455747500ff0e39389f26e2a366965ae1" translate="yes" xml:space="preserve">
          <source>YouTube tutorial: &lt;a href=&quot;https://www.youtube.com/watch?v=Kpwrc1PRDsg&quot;&gt;How to send data through segue (swift)&lt;/a&gt;</source>
          <target state="translated">Учебник YouTube: &lt;a href=&quot;https://www.youtube.com/watch?v=Kpwrc1PRDsg&quot;&gt;как отправить данные через segue (swift)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd92b6a59301aaf7df021b06434d7fd97281c993" translate="yes" xml:space="preserve">
          <source>and &quot;B&quot; view controller should declare callback property, BViewController.h:</source>
          <target state="translated">и контроллер вида &quot;B&quot; должны объявить свойство обратного вызова,BViewController.h:</target>
        </trans-unit>
        <trans-unit id="d22cdc632e153fe14ede39b227947423e9ef48b1" translate="yes" xml:space="preserve">
          <source>and in FirstViewController.h :</source>
          <target state="translated">и в FirstViewController.h :</target>
        </trans-unit>
        <trans-unit id="1303845f47ba68fca8499482aa29a0b1ca63c1c8" translate="yes" xml:space="preserve">
          <source>click on the button and drag over to the Second View Controller.</source>
          <target state="translated">нажмите на кнопку и перетащите на Второй просмотровый контроллер.</target>
        </trans-unit>
        <trans-unit id="edb401d8d776a314f5a6c4744d5c898beb932df9" translate="yes" xml:space="preserve">
          <source>delegates</source>
          <target state="translated">delegates</target>
        </trans-unit>
        <trans-unit id="071cd75033ae8e8688a44265cb1850670988a924" translate="yes" xml:space="preserve">
          <source>do these in ViewControlerOne.h</source>
          <target state="translated">делать это в ViewControlerOne.h</target>
        </trans-unit>
        <trans-unit id="d2c16f26c821a75d79d3c762d88ff8151b2cef90" translate="yes" xml:space="preserve">
          <source>do these in ViewControlerOne.m</source>
          <target state="translated">делать это в ViewControlerOne.m</target>
        </trans-unit>
        <trans-unit id="4ab7cc959e41e827a458876138723cac6658ff71" translate="yes" xml:space="preserve">
          <source>do these in ViewControllerTwo.h</source>
          <target state="translated">делать это в ViewControllerTwo.h</target>
        </trans-unit>
        <trans-unit id="537d8d6119fe77d8b87bdfec992c7335ce2c30a3" translate="yes" xml:space="preserve">
          <source>do these in ViewControllerTwo.m</source>
          <target state="translated">делать это в ViewControllerTwo.m</target>
        </trans-unit>
        <trans-unit id="78f6225c0a29d685123f4713fb8d64650c5d455a" translate="yes" xml:space="preserve">
          <source>drag from the button to the Second View Controller. Set the segue identifier to &lt;code&gt;showSecondViewController&lt;/code&gt;. Also, don't forget to hook up the outlets and actions using the names in the following code.</source>
          <target state="translated">перетащите с кнопки на контроллер второго вида. Установите идентификатор &lt;code&gt;showSecondViewController&lt;/code&gt; для showSecondViewController . Кроме того, не забудьте подключить розетки и действия, используя имена в следующем коде.</target>
        </trans-unit>
        <trans-unit id="e89c71751ece180f696d67c4cc55aff1a2e78a1b" translate="yes" xml:space="preserve">
          <source>expecting that your &lt;code&gt;CustomObject&lt;/code&gt; must have a setter function with it.</source>
          <target state="translated">ожидая, что ваш &lt;code&gt;CustomObject&lt;/code&gt; должен иметь функцию установки с ним.</target>
        </trans-unit>
        <trans-unit id="9a601619d63281ffad7a5e7742ff3e95493c069d" translate="yes" xml:space="preserve">
          <source>if you declare a &lt;code&gt;NSArray object *arrayXYZ&lt;/code&gt; then you can access it in any view controller by &lt;code&gt;appDelegate.arrayXYZ&lt;/code&gt;</source>
          <target state="translated">если вы объявляете &lt;code&gt;NSArray object *arrayXYZ&lt;/code&gt; то вы можете получить к нему доступ в любом контроллере представления с помощью &lt;code&gt;appDelegate.arrayXYZ&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="782fff5ac840ff68307a9fc122193c5707e4c512" translate="yes" xml:space="preserve">
          <source>if you wants to pass data from ViewControlerOne to ViewControllerTwo try these..</source>
          <target state="translated">если вы хотите передать данные из ViewControlerOne в ViewControllerTwo,попробуйте это...</target>
        </trans-unit>
        <trans-unit id="be71d332d065bfca5adcf4764b2e5dcf0067a681" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;ViewControllerA&lt;/code&gt; you need to tell it about &lt;code&gt;ViewControllerB&lt;/code&gt; so use an</source>
          <target state="translated">в &lt;code&gt;ViewControllerA&lt;/code&gt; вам нужно рассказать о &lt;code&gt;ViewControllerB&lt;/code&gt; , так что используйте</target>
        </trans-unit>
        <trans-unit id="65b58b2b8602f0dcd3e15e13e48c2cf1071404f5" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;ViewControllerB.h&lt;/code&gt; create a property for the &lt;code&gt;BOOL&lt;/code&gt;</source>
          <target state="translated">в &lt;code&gt;ViewControllerB.h&lt;/code&gt; создать свойство для &lt;code&gt;BOOL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99069faddac71d51fb4234f0748c9713172c03f9" translate="yes" xml:space="preserve">
          <source>in ViewController.h</source>
          <target state="translated">в ViewController.h</target>
        </trans-unit>
        <trans-unit id="131175d1468a88ef378a2491456c5cb0422143b7" translate="yes" xml:space="preserve">
          <source>in ViewController.m</source>
          <target state="translated">в ViewController.m</target>
        </trans-unit>
        <trans-unit id="be71d06d1de5c0a0fdb2be6af089b062df524e57" translate="yes" xml:space="preserve">
          <source>in implementation file you can implement the function</source>
          <target state="translated">в файле реализации можно реализовать функцию</target>
        </trans-unit>
        <trans-unit id="a4325deae2d4ec787216962c095e8ecd5c3486e6" translate="yes" xml:space="preserve">
          <source>next still in the &lt;code&gt;ViewControllerB.h&lt;/code&gt; you need to setup a &lt;code&gt;delegate&lt;/code&gt; property and synthesize in &lt;code&gt;ViewControllerB.m&lt;/code&gt;</source>
          <target state="translated">затем еще в &lt;code&gt;ViewControllerB.h&lt;/code&gt; вам нужно установить свойство &lt;code&gt;delegate&lt;/code&gt; и синтезировать в &lt;code&gt;ViewControllerB.m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="386cbb45fb634a4cc7cc5f0d2dd999b1d4e98035" translate="yes" xml:space="preserve">
          <source>now your basic work is done. go to the place where you want to push the &lt;code&gt;SecondViewController&lt;/code&gt; and do the following stuff</source>
          <target state="translated">Теперь ваша основная работа выполнена. перейдите в то место, куда вы хотите нажать &lt;code&gt;SecondViewController&lt;/code&gt; , и выполните следующие действия</target>
        </trans-unit>
        <trans-unit id="37f0c63aa5984813b557482775d277cd538c0cde" translate="yes" xml:space="preserve">
          <source>on the buttons click event do this..</source>
          <target state="translated">на кнопках нажмите событие сделать это...</target>
        </trans-unit>
        <trans-unit id="46a5e3a49371630a136eb9da775d08eb729e16f4" translate="yes" xml:space="preserve">
          <source>override the &lt;code&gt;prepare(for:sender:)&lt;/code&gt; method of &lt;code&gt;UIViewController&lt;/code&gt; when using a storyboard and segues</source>
          <target state="translated">переопределить метод &lt;code&gt;prepare(for:sender:)&lt;/code&gt; &lt;code&gt;UIViewController&lt;/code&gt; при использовании раскадровки и сегментов</target>
        </trans-unit>
        <trans-unit id="4d25f70727ad257203a7cb4eb327698d18e7aa99" translate="yes" xml:space="preserve">
          <source>pass data through an initializer or through properties when performing view controller transitions thtough code</source>
          <target state="translated">передавать данные через инициализатор или через свойства при выполнении переходов через контроллер представлений.</target>
        </trans-unit>
        <trans-unit id="7311cc1f0f20c0620db17343ab40307e824143ea" translate="yes" xml:space="preserve">
          <source>segues</source>
          <target state="translated">segues</target>
        </trans-unit>
        <trans-unit id="7f2d647110dc98a6cf4ef95feec7e141e6b5b5d7" translate="yes" xml:space="preserve">
          <source>setting properties on view controllers directly</source>
          <target state="translated">настройка свойств непосредственно на контроллерах просмотра</target>
        </trans-unit>
        <trans-unit id="9e37ace74b364d63001657a8ab63e157a0a748b9" translate="yes" xml:space="preserve">
          <source>so we can pass this value in second class using below step</source>
          <target state="translated">так что мы можем передать это значение во втором классе,используя следующий шаг.</target>
        </trans-unit>
        <trans-unit id="1b1760ac8cee45ff111cddcf3355ccffae7b6192" translate="yes" xml:space="preserve">
          <source>then change its definition to</source>
          <target state="translated">затем изменить его определение на</target>
        </trans-unit>
        <trans-unit id="e61eda4f8db1e4d3af098df52ca88723ae4b33e4" translate="yes" xml:space="preserve">
          <source>update the app shared state (which you can pass forward between view controllers with either one of the methods above)</source>
          <target state="translated">обновить разделяемое состояние приложения (которое можно передать между контроллерами просмотра любым из вышеперечисленных методов)</target>
        </trans-unit>
        <trans-unit id="5edd9def88440cf132c20a45c93726634b543a58" translate="yes" xml:space="preserve">
          <source>use an unwind segue</source>
          <target state="translated">использовать сегмент размотки</target>
        </trans-unit>
        <trans-unit id="1089f6b4bab9307f50a4d74cae6292d00032982e" translate="yes" xml:space="preserve">
          <source>use delegation</source>
          <target state="translated">делегирование полномочий</target>
        </trans-unit>
        <trans-unit id="4f77b4fd6e2ebd82da33ee94540fe10ea274781f" translate="yes" xml:space="preserve">
          <source>use it in the &lt;code&gt;prepareForSegue&lt;/code&gt; method in the VC1</source>
          <target state="translated">используйте его в методе &lt;code&gt;prepareForSegue&lt;/code&gt; в VC1</target>
        </trans-unit>
        <trans-unit id="3397791b6f7f7ea840ba49d831f7e5f45f3ad769" translate="yes" xml:space="preserve">
          <source>var authorizationCompletionBlock:((Bool)-&amp;gt;())? = {_ in}</source>
          <target state="translated">var authorizationCompletionBlock: ((Bool) -&amp;gt; ())? = {_ in}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
