<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/5210535">
    <body>
      <group id="5210535">
        <trans-unit id="5128e9d8380cba42898da6b0b4c094f182f31368" translate="yes" xml:space="preserve">
          <source>1&amp;gt;We need to crate string object in SecondViewController.h file</source>
          <target state="translated">1&amp;gt;我们需要在SecondViewController.h文件中创建字符串对象</target>
        </trans-unit>
        <trans-unit id="382568f3d5638e45d07eaa2ba4e79626c6e35495" translate="yes" xml:space="preserve">
          <source>2&amp;gt;Need to declare property as below below declaration in .h file</source>
          <target state="translated">2&amp;gt;需要在.h文件中声明以下属性</target>
        </trans-unit>
        <trans-unit id="ca8fae13e1609c64d729ca50adc43575fd915a5d" translate="yes" xml:space="preserve">
          <source>3&amp;gt;Need synthesize that value in FirstViewController.m file below header declaration</source>
          <target state="translated">3&amp;gt;需要在头声明下面的FirstViewController.m文件中合成该值</target>
        </trans-unit>
        <trans-unit id="7e6c2732929d97145ee56f3dbef06b5bd1d4b710" translate="yes" xml:space="preserve">
          <source>4 lines of code inside the method and you are done.</source>
          <target state="translated">在方法内4行代码,你就完成了。</target>
        </trans-unit>
        <trans-unit id="12af7e16d59d006e71a07aade88fd2f960f7d040" translate="yes" xml:space="preserve">
          <source>4&amp;gt;In FirstViewController,From which method we navigate to second view please write below code in that method.</source>
          <target state="translated">4&amp;gt;在FirstViewController中，我们从哪个方法导航到第二个视图，请在该方法中编写以下代码。</target>
        </trans-unit>
        <trans-unit id="8e9441a605f9f93f88f097003026bbcbdb4e55b8" translate="yes" xml:space="preserve">
          <source>:) Cheers.</source>
          <target state="translated">:)干杯。</target>
        </trans-unit>
        <trans-unit id="c7e0fd5894134e3a798732701f0ee5582c0e8363" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ManagingDataFlowBetweenViewControllers/ManagingDataFlowBetweenViewControllers.html#//apple_ref/doc/uid/TP40007457-CH8-SW9&quot;&gt;Using Delegation to Communicate With Other View Controllers&lt;/a&gt; in the &lt;em&gt;View Controller Programming Guide&lt;/em&gt;</source>
          <target state="translated">《 &lt;em&gt;View Controller编程指南》&lt;/em&gt;中的&lt;a href=&quot;http://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ManagingDataFlowBetweenViewControllers/ManagingDataFlowBetweenViewControllers.html#//apple_ref/doc/uid/TP40007457-CH8-SW9&quot;&gt;使用委派与其他View Controller通信&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9cddb9f240b7be5a6c0e6206779adba0c54ad320" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.iphonedevsdk.com/forum/iphone-sdk-development/54859-sharing-data-between-view-controllers-other-objects.html&quot;&gt;Sharing data between view controllers and other objects&lt;/a&gt; @ iPhone Dev SDK</source>
          <target state="translated">&lt;a href=&quot;http://www.iphonedevsdk.com/forum/iphone-sdk-development/54859-sharing-data-between-view-controllers-other-objects.html&quot;&gt;在视图控制器和其他对象之间共享数据&lt;/a&gt; @ iPhone Dev SDK</target>
        </trans-unit>
        <trans-unit id="a561b48e56f3bead23ac829c64c64003e3095e17" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/RamdhanChoudhary/A-Simple-iOS-App-for-Passing-Data-Between-Controllers-in-Swift&quot;&gt;You can find complete sample Application at my GitHub&lt;/a&gt; Please let me know if you have any question(s) on this.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/RamdhanChoudhary/A-Simple-iOS-App-for-Passing-Data-Between-Controllers-in-Swift&quot;&gt;您可以在我的GitHub上找到完整的示例应用程序。&lt;/a&gt;如果对此有任何疑问，请告诉我。</target>
        </trans-unit>
        <trans-unit id="4a01486c528ad5e980ae4089d498cd8c88f97fa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@synthesize  indexNumber;&lt;/code&gt;           in NextVC.m</source>
          <target state="translated">&lt;code&gt;@synthesize indexNumber;&lt;/code&gt; 在NextVC.m中</target>
        </trans-unit>
        <trans-unit id="b78c51f4a043a824f5e08ef6eaf7ecfb3f33270d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Blocks are anonymous functions.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;块是匿名函数。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1021f754895d902d9dddaf8f14272d74668e6de6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Using Block callbacks:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;-使用块回调：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c37f6c389f441f0686ad2157cb488b1e89332e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Using storyboards Unwind (Exit)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;-使用情节提要板展开（退出）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f6e3b19fd1dae9c65f2307816e0fe1c6c694e84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt; Create the instance of first View Controller in the second View Controller and make its property &lt;code&gt;@property (nonatomic,assign)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt;在第二个View Controller中创建第一个View Controller的实例， &lt;code&gt;@property (nonatomic,assign)&lt;/code&gt; 其属性设置为@property（nonatomic，assign） 。</target>
        </trans-unit>
        <trans-unit id="caa8b857bce2edcc30a0b3967af6102ff7c4e3cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt; Assign the &lt;code&gt;SecondviewController&lt;/code&gt; instance of this view controller.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt;分配此视图控制器的 &lt;code&gt;SecondviewController&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="c1ab9d883587e24a8d31adae458d2e6b60264d54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt; When you finish the selection operation copy the array to first View Controller,When u unload the SecondView ,FirstView will hold the Array Data.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt;完成选择操作后，将阵列复制到第一个View Controller，当您卸载SecondView时，FirstView将保存阵列数据。</target>
        </trans-unit>
        <trans-unit id="69324ef579d371a172a46ed3433537adafdd0323" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Application Scenarios&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;应用场景&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19d3c711e8278b4bcb9dc5b3925628e10a4961cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't forget&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;别忘了&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55779cd52cf0b0e46e2fe75e0ae7c25906301bd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First View Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;第一视图控制器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c0c0b273313e9e6e2211fefaab5837fd17c6153" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例如&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c300eb69852a39b53d39a423e83febc84bb7ecf5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Go to Controller B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;转到控制器B&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd3b42b839c0fa27211813e4f7a2b41b323efb59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NSNotification center&lt;/strong&gt;
It's another way to pass data.</source>
          <target state="translated">&lt;strong&gt;NSNotification中心&lt;/strong&gt;这是传递数据的另一种方法。</target>
        </trans-unit>
        <trans-unit id="f83086999fd5c7eccf89cda212980e525c8ee244" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsDetailViewController.h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsDetailViewController.h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2e498d6299003ee4bb995fd064cfff0f5031dd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsDetailViewController.m&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsDetailViewController.m&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="170aa6c3a45436cad64cb27754574f9f66c7007d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NewsViewController&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NewsViewController&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fcf13efd0f4fde8b8e30afec77961f30fe04bf16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Back&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;传回数据&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4056ba2648992080e38f34e858850a2675ff28c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Forward using Segues&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用Segues转发数据&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="806df0e91c6a17443dc044857cd2e12e700908c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data Forward&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;向前传递数据&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a823b2509776072df9c2f284478ab9d56976c87d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data back from one class to another&lt;/strong&gt; (A class can be any controller, Network/session manager, UIView subclass or any other class)</source>
          <target state="translated">&lt;strong&gt;将数据从一个类传递回另一个类&lt;/strong&gt; （一个类可以是任何控制器，网络/会话管理器，UIView子类或任何其他类）</target>
        </trans-unit>
        <trans-unit id="3a2d4f96ca3cdcbd2c5729cfeeddcfe8a83ef0da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data between FirstViewController to SecondViewController as below&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如下所示在FirstViewController和SecondViewController之间传递数据&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1633208f374584ce5b10f1cf78b22a2eeba7eee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Block&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;通过Block传递数据&lt;/strong&gt; ： &lt;em&gt;从ViewControllerB到ViewControllerA&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="024c5395573bc2998ff2187cbf90e249d2fd7f30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Delegate&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;通过委托传递数据&lt;/strong&gt; ： &lt;em&gt;从ViewControllerB到ViewControllerA&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c82eb764b54c062d5349bd59c7a3fb7fcbc641b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Navigation Controller Push&lt;/strong&gt; : &lt;em&gt;From ViewControllerA to ViewControllerB&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;通过导航控制器Push传递数据&lt;/strong&gt; ： &lt;em&gt;从ViewControllerA到ViewControllerB&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55db90aacfef6b7797ad7a5da078395659732e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Notification Observer&lt;/strong&gt; : &lt;em&gt;From ViewControllerB to ViewControllerA&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;通过Notification Observer传递数据&lt;/strong&gt; ： &lt;em&gt;从ViewControllerB到ViewControllerA&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0561e6d1d3b1f23d57d8291ca2684d08bcde0b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing Data through Segue&lt;/strong&gt; : &lt;em&gt;From ViewControllerA to ViewControllerB&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;通过Segue传递数据&lt;/strong&gt; ： &lt;em&gt;从ViewControllerA到ViewControllerB&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf80e7bc29bfca96a73722d3c8c419ee4f8a9df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scenario one:&lt;/strong&gt; maximum two view controllers ever need to share information.
See diagram one.</source>
          <target state="translated">&lt;strong&gt;方案1：&lt;/strong&gt;最多需要两个视图控制器共享信息。 参见图一。</target>
        </trans-unit>
        <trans-unit id="b5cb92a49a24b197803d86b1055b30b5711cba2a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scenario two&lt;/strong&gt;: more than two view controllers need to share the same information.
See diagram two.</source>
          <target state="translated">&lt;strong&gt;方案二&lt;/strong&gt; ： &lt;strong&gt;两个&lt;/strong&gt;以上的视图控制器需要共享相同的信息。 见图二。</target>
        </trans-unit>
        <trans-unit id="f945b9a41062fc17eb825c26426f171f0d86ed91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second View Controller and Protocol&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Second View控制器和协议&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ce77aea00bcbf439da1f87290ce172463ea140c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Second View Controller&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;第二视图控制器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bd48716ff2de9235461890349819ae353247ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setup The Storyboard&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;设置情节提要&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="089fc6cd09fa49635621f8cfa746223ca053b190" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Create Segue from ViewControllerA to ViewControllerB and give Identifier = showDetailSegue in Storyboard as shown below</source>
          <target state="translated">&lt;strong&gt;步骤1.&lt;/strong&gt;从ViewControllerA到ViewControllerB创建Segue，并在Storyboard中提供Identifier = showDetailSegue，如下所示</target>
        </trans-unit>
        <trans-unit id="02d6487d795d944e58f58e4366b35bc8d1b32dc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Declare Protocol &lt;strong&gt;&lt;em&gt;ViewControllerBDelegate&lt;/em&gt;&lt;/strong&gt; in ViewControllerB file but outside the class</source>
          <target state="translated">&lt;strong&gt;步骤1.&lt;/strong&gt;在ViewControllerB文件中但在类外部声明协议&lt;strong&gt;&lt;em&gt;ViewControllerBDelegate&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0cfd0efef879069214eec7da3b7a25e5918e36d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1.&lt;/strong&gt; Declare variable in ViewControllerB</source>
          <target state="translated">&lt;strong&gt;步骤1.&lt;/strong&gt;在ViewControllerB中声明变量</target>
        </trans-unit>
        <trans-unit id="63f0b24521041c6431c75964ba6cefcaea19944c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; Declare Delegate variable instance in ViewControllerB</source>
          <target state="translated">&lt;strong&gt;步骤2.&lt;/strong&gt;在ViewControllerB中声明委托变量实例</target>
        </trans-unit>
        <trans-unit id="cf2aa8929fa2c0c9c4a6b1ac4ca41b9ce1e5280a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; In ViewControllerB Declare a viable named &lt;strong&gt;isSomethingEnabled&lt;/strong&gt; and print its value.</source>
          <target state="translated">&lt;strong&gt;步骤2.&lt;/strong&gt;在ViewControllerB中，声明一个名为&lt;strong&gt;isSomethingEnabled&lt;/strong&gt;的可行&lt;strong&gt;对象&lt;/strong&gt;并打印其值。</target>
        </trans-unit>
        <trans-unit id="673106a11e8d268ad485367e76e5b7fe1a54be95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2.&lt;/strong&gt; Print Variable in ViewControllerB' ViewDidLoad method</source>
          <target state="translated">&lt;strong&gt;步骤2.&lt;/strong&gt;在ViewControllerB的ViewDidLoad方法中打印变量</target>
        </trans-unit>
        <trans-unit id="c79ecb62ba912afd27284dd7da413af362a92fe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; In ViewControllerA Pass Data while pushing through Navigation Controller</source>
          <target state="translated">&lt;strong&gt;步骤3.&lt;/strong&gt;在ViewControllerA中，在通过导航控制器时传递数据</target>
        </trans-unit>
        <trans-unit id="4b0af6a719a13383d29f0e86f0830773e5362336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; In ViewControllerA pass isSomethingEnabled's value while passing Segue</source>
          <target state="translated">&lt;strong&gt;步骤3.&lt;/strong&gt;在ViewControllerA中，在传递Segue时传递isSomethingEnabled的值</target>
        </trans-unit>
        <trans-unit id="e879cf49b95c873ff028951588aa65e4dc76e026" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3.&lt;/strong&gt; Send data for delegate inside viewDidLoad method of ViewControllerB</source>
          <target state="translated">&lt;strong&gt;步骤3.&lt;/strong&gt;在ViewControllerB的viewDidLoad方法内发送委托数据</target>
        </trans-unit>
        <trans-unit id="c0971f452794a6e92bcbbc194c9499089ede4379" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 4.&lt;/strong&gt; Confirm ViewControllerBDelegate in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;步骤4.&lt;/strong&gt;在ViewControllerA中确认ViewControllerBDelegate</target>
        </trans-unit>
        <trans-unit id="400cecca8d5ee34aed2e79bed634a5f6417ad26a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 5.&lt;/strong&gt; Confirm that you will implement delegate in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;步骤5.&lt;/strong&gt;确认您将在ViewControllerA中实现委托</target>
        </trans-unit>
        <trans-unit id="a6946e7fb9eb003efc11719f3b07f5e5dd24240e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 6.&lt;/strong&gt; Implement delegate method for receiving data in ViewControllerA</source>
          <target state="translated">&lt;strong&gt;步骤6.&lt;/strong&gt;在ViewControllerA中实现用于接收数据的委托方法</target>
        </trans-unit>
        <trans-unit id="dae0e54a74abfd074492d26eb16ee245aa1b2bad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Swift 5&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;迅捷5&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28379284774a4bc3f1d8c071ddb2db954d9799db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Solutions: Delegates and the Observer Pattern, and Singletons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;解决方案：代表和观察员模式以及单例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67f11916500f3f87c23f865722bfb004fcf67670" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The View Controllers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;视图控制器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4223100f431b368002a27fc7e5a1b02d95268402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is a very old answer and this is anti pattern, please use delegates. Do not use this Approach !!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这是一个非常古老的答案，这是反模式，请使用委托。&lt;/strong&gt; &lt;strong&gt;不要使用这种方法！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f90d261e0a84b99ac74b5c70573c76458761db1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ViewControllerA&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ViewControllerA&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="48b18e371bee61f8b3cc40f6098e6c3da05ba232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ViewControllerB&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ViewControllerB&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7695880e46c35fa27304925b1429e1f63dcc24f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;add block handler (listener)&lt;/strong&gt;
where you need a value (for example you need your API response in ControllerA or you need ContorllerB data on A)</source>
          <target state="translated">在需要值的地方&lt;strong&gt;添加块处理程序（侦听器）&lt;/strong&gt; （例如，您需要在ControllerA中的API响应或在A上需要ContorllerB数据）</target>
        </trans-unit>
        <trans-unit id="c5d2857c643c79b0380179ffbc7e423000f801e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;define a block&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;定义一个块&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93db5e336a184ed3fa5d32c57284bb8d6714d03a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fire block&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;火块&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3915169e39c880b6db82aad68f146c88205b079" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;singleton&lt;/strong&gt; is an instance of a class, that instance being the only instance in existence during its lifetime. A singleton gets its name from the fact that it is the single instance. Normally developers who use singletons have special class methods for accessing them.</source>
          <target state="translated">&lt;strong&gt;单例&lt;/strong&gt;是类的实例，该实例是其生命周期中唯一存在的实例。 单例的名称是因为它是单个实例。 通常，使用单例的开发人员具有特殊的类方法来访问它们。</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="f28e068fdcf0539a305afd3501e8a77424964acf" translate="yes" xml:space="preserve">
          <source>Add a new file to your project (Objective-C Protocol) File -&amp;gt; New, now name it ViewController1Delegate or whatever you want and write these between the @interface and @end directives</source>
          <target state="translated">将一个新文件添加到您的项目（Objective-C协议）File-&amp;gt; New，现在将其命名为ViewController1Delegate或您想要的任何名称，并将它们写入@interface和@end指令之间</target>
        </trans-unit>
        <trans-unit id="3f0eff45a4a19a3b442bc835b668a6a9ac78b01f" translate="yes" xml:space="preserve">
          <source>Add this &lt;code&gt;property&lt;/code&gt; in NextVC.h on nextVC</source>
          <target state="translated">在nextVC的NextVC.h中添加此 &lt;code&gt;property&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="804108390422b4e4ce16d7dd070e8cd51d8926e4" translate="yes" xml:space="preserve">
          <source>After more research it seemed that Protocols and Delegates is the correct/Apple prefered way of doing this.</source>
          <target state="translated">经过更多的研究,似乎协议和委托代理才是正确的Apple首选的方式。</target>
        </trans-unit>
        <trans-unit id="a12d91c7bf75162aeefa8045f7e5bc4e2c65ef2b" translate="yes" xml:space="preserve">
          <source>All of your views that conform to this need to be subclasses of MCViewController, which allow you to override the new onResume: method, allowing you access to the data you've passed in.</source>
          <target state="translated">所有符合这一点的视图都需要是MCViewController的子类,它允许你覆盖新的onResume:方法,允许你访问你传入的数据。</target>
        </trans-unit>
        <trans-unit id="0d8ab1246f6106fb56d5a9574573a871cd55050d" translate="yes" xml:space="preserve">
          <source>And in the prepareForSegue of VC1 you can change any property you want to share.</source>
          <target state="translated">而在VC1的prepareForSegue中,你可以改变任何你想分享的属性。</target>
        </trans-unit>
        <trans-unit id="bccdba78cf0a1ca896692cedf94279f07a532726" translate="yes" xml:space="preserve">
          <source>And last</source>
          <target state="translated">最后是</target>
        </trans-unit>
        <trans-unit id="b969e3b40597dea269830b21f5cd87d1fbd3744f" translate="yes" xml:space="preserve">
          <source>And the code for the Second View Controller is</source>
          <target state="translated">而第二视角控制器的代码是</target>
        </trans-unit>
        <trans-unit id="18cc65ab16292fba4c64e85d6cc81210aac335ef" translate="yes" xml:space="preserve">
          <source>Another Working Example for Blocks</source>
          <target state="translated">块的另一个工作实例</target>
        </trans-unit>
        <trans-unit id="118227ed38ee9d82b2542b27e2ded76929153d04" translate="yes" xml:space="preserve">
          <source>Another approach is to handle a screen full of data at a time and instead of coupling the view controllers to each other couple each view controller to single data source that they can get to independently.</source>
          <target state="translated">另一种方法是一次处理一个满屏的数据,而不是将每个视图控制器相互耦合,将每个视图控制器都耦合到单个数据源上,让它们独立地获取。</target>
        </trans-unit>
        <trans-unit id="24aa503d35146161367e2853117eb922f7c7e249" translate="yes" xml:space="preserve">
          <source>Another option of using storyboards Undwind (Exit)  - you can
use the method you wrote in VC1</source>
          <target state="translated">另一个使用故事板的选项 Undwind (Exit)-你可以使用你在VC1中写的方法</target>
        </trans-unit>
        <trans-unit id="0b6c72a6ce36ed0135ebc104f4837a0d4628e2ba" translate="yes" xml:space="preserve">
          <source>Another solution is use singleton class pattern initialize it once and use it in your entire app.</source>
          <target state="translated">另一个解决方案是使用单子类模式初始化一次,然后在整个APP中使用。</target>
        </trans-unit>
        <trans-unit id="485e9762fc4e98806a8bb291a5c98ca65cca0c5d" translate="yes" xml:space="preserve">
          <source>Any time an individual item is created or edited, it must also synchronize with the other view controllers. For example, if we add a boat in ViewControllerD, but it is not yet insured, then the boat must appear when the user goes to ViewControllerA (Luxury Items), and also ViewControllerC (Entire Home Inventory), but not when the user goes to ViewControllerB (Non-insured Items). We need be concerned with not only adding new items, but also deleting items (which may be allowed from any of the four view controllers), or editing existing items (which may be allowed from the &quot;Add New Item Form&quot;, repurposing the same for editing).</source>
          <target state="translated">任何一个单独的项目在创建或编辑时,也必须与其他视图控制器同步。例如,如果我们在ViewControllerD中添加了一艘船,但它还没有投保,那么当用户转到ViewControllerA(豪华物品)时,这艘船必须出现在ViewControllerA(豪华物品),同时也必须出现在ViewControllerC(整个家庭库存),但当用户转到ViewControllerB(非投保物品)时,这艘船就不存在。我们需要关注的不仅仅是添加新项目,还需要关注删除项目(可以从四个视图控制器中的任何一个视图控制器中删除),或者编辑现有的项目(可以从 &quot;添加新项目表单 &quot;中删除,重新使用同样的表单进行编辑)。</target>
        </trans-unit>
        <trans-unit id="64849ae90e58e40914c4de26bdae632804d0010e" translate="yes" xml:space="preserve">
          <source>Any time your Application Delegate starts to get bloated, start to remove functionality into singletons. For example, the Core Data Stack should not be left in the AppDelegate, but should instead be put in its own class, a coreDataManager class.</source>
          <target state="translated">任何时候,当你的Application Delegate开始变得臃肿的时候,就开始把功能删除到单子类中。例如,核心数据栈不应该留在AppDelegate中,而是应该放在自己的类--coreDataManager类中。</target>
        </trans-unit>
        <trans-unit id="3f40fedcce16e602b145be79b8076ddf17738736" translate="yes" xml:space="preserve">
          <source>Assuming we use Storyboard, first controller sets callback block, for example during segue preparation:</source>
          <target state="translated">假设我们使用Storyboard,首先控制器设置回调块,比如在segue准备过程中,首先控制器设置回调块。</target>
        </trans-unit>
        <trans-unit id="937c87dd061dc69a2f97f40ce08377952484a667" translate="yes" xml:space="preserve">
          <source>Asynchronous JSON Requests in Objective-C</source>
          <target state="translated">Objective-C中的异步JSON请求</target>
        </trans-unit>
        <trans-unit id="7a23b7a9d6d6baa93168423a429c497e0668b171" translate="yes" xml:space="preserve">
          <source>Before pushing &lt;code&gt;viewControllerB&lt;/code&gt; to navigation stack we need to tell  &lt;code&gt;ViewControllerB&lt;/code&gt; that &lt;code&gt;ViewControllerA&lt;/code&gt; is its delegate, otherwise we will get an error.</source>
          <target state="translated">在将 &lt;code&gt;viewControllerB&lt;/code&gt; 推到导航堆栈之前，我们需要告诉 &lt;code&gt;ViewControllerB&lt;/code&gt; &lt;code&gt;ViewControllerA&lt;/code&gt; 是它的委托，否则我们将得到一个错误。</target>
        </trans-unit>
        <trans-unit id="8eac8dd9c4975fc8c45b35fda8f1d46a26aaa269" translate="yes" xml:space="preserve">
          <source>Brute force iteration on view controllers (in Navigation or Tab Bar Controller) to set the data</source>
          <target state="translated">对视图控制器(在导航或标签栏控制器中)进行粗暴的强制迭代,以设置数据</target>
        </trans-unit>
        <trans-unit id="54b5e333081c3612757c1545a54070e785c64a95" translate="yes" xml:space="preserve">
          <source>But for the simple scenario of passing a value to a different class whose allocation is done in the current class, the most common and preferred method would be the direct setting of values after allocation. This is done as follows:-</source>
          <target state="translated">但对于简单的情况下,将值传递给不同的类,而这个类的分配是在当前类中完成的,最常见也是最喜欢的方法是分配后直接设置值。具体方法如下:--------</target>
        </trans-unit>
        <trans-unit id="ea1d3df298ca84104dbf8b2f6f916c02f6f77c6e" translate="yes" xml:space="preserve">
          <source>Control</source>
          <target state="translated">Control</target>
        </trans-unit>
        <trans-unit id="959abf1f5e9c99d137dc34e9bffd461476893b28" translate="yes" xml:space="preserve">
          <source>Core Data</source>
          <target state="translated">核心数据</target>
        </trans-unit>
        <trans-unit id="dec7ea0ef8ddc0be363fac5318ec6d035445e81a" translate="yes" xml:space="preserve">
          <source>Create a the segue from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; on the storyboard and give it an identifier, in this example we'll call it &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt;</source>
          <target state="translated">在情节 &lt;code&gt;ViewControllerB&lt;/code&gt; 上从 &lt;code&gt;ViewControllerA&lt;/code&gt; 到ViewControllerB创建一个序列，并为其指定一个标识符，在本示例中，我们将其称为 &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d6106a2b404bee4c3c16acfce805678171d2723" translate="yes" xml:space="preserve">
          <source>Create the property on next &lt;code&gt;view controller .h&lt;/code&gt; and define getter and setter.</source>
          <target state="translated">在下一个 &lt;code&gt;view controller .h&lt;/code&gt; 上创建属性，并定义getter和setter。</target>
        </trans-unit>
        <trans-unit id="3dd4a61a93a6d9b50322d5da189d9a661c072e48" translate="yes" xml:space="preserve">
          <source>Create the storyboard layout in the Interface Builder. Again, to make the segue, you just</source>
          <target state="translated">在界面生成器中创建故事板布局。同样,要做segue,你只需要</target>
        </trans-unit>
        <trans-unit id="2851431431fb0af8a145e641673ca993d6a20f60" translate="yes" xml:space="preserve">
          <source>Create the storyboard layout in the Interface Builder. To make the segue, you just</source>
          <target state="translated">在界面生成器中创建故事板布局。要做segue,你只要</target>
        </trans-unit>
        <trans-unit id="863b2164a4f2bf227ea1d1aef73ad8543480c495" translate="yes" xml:space="preserve">
          <source>Data Source</source>
          <target state="translated">数据来源</target>
        </trans-unit>
        <trans-unit id="2aac74bd52b9c492652ab12ed22c5b9514f39d8b" translate="yes" xml:space="preserve">
          <source>Databases and other storage mechanisms like plist, etc.</source>
          <target state="translated">数据库和其他存储机制,如plist等。</target>
        </trans-unit>
        <trans-unit id="12ab214df85e4910f7e4400eea924b9565854a9f" translate="yes" xml:space="preserve">
          <source>Delegate</source>
          <target state="translated">Delegate</target>
        </trans-unit>
        <trans-unit id="7dcb8a7fd6d2299b039ffb1a88ed98c93cfc5c8c" translate="yes" xml:space="preserve">
          <source>Delegate Pattern</source>
          <target state="translated">委托模式</target>
        </trans-unit>
        <trans-unit id="55f0774bd4a8ef9ee512f251043f191561770ae9" translate="yes" xml:space="preserve">
          <source>Delegation - for passing data back</source>
          <target state="translated">委托----用于传回数据</target>
        </trans-unit>
        <trans-unit id="4e3967fb23456a60f72119d5b28aa0e415a7f7e8" translate="yes" xml:space="preserve">
          <source>Delegation is the only one solution to perform such operations when you are using .xib files however all answers described above are for &lt;code&gt;storyboard&lt;/code&gt; for .xibs files you need to use delegation. that's only solution you can.</source>
          <target state="translated">当您使用.xib文件时，委派是执行此类操作的唯一解决方案，但是上述所有答案均适用于您需要使用委派的.xibs文件的 &lt;code&gt;storyboard&lt;/code&gt; 提要。 那是您唯一的解决方案。</target>
        </trans-unit>
        <trans-unit id="b4207fd5520139aa96bd6e9274602042b4534a20" translate="yes" xml:space="preserve">
          <source>Direct initialization after the allocation of another class.</source>
          <target state="translated">在分配到另一个类后直接进行初始化。</target>
        </trans-unit>
        <trans-unit id="bcfc557b28b79f1b85cc19619bb82e338660c8e4" translate="yes" xml:space="preserve">
          <source>FirstViewController String value as</source>
          <target state="translated">FirstViewController String值为</target>
        </trans-unit>
        <trans-unit id="57a94d454ba6c87c92cf93163d87c89f165d195a" translate="yes" xml:space="preserve">
          <source>FirstViewController.h</source>
          <target state="translated">FirstViewController.h</target>
        </trans-unit>
        <trans-unit id="f8e78f0e3c0970f488a281208ad26ef9f20bbdf0" translate="yes" xml:space="preserve">
          <source>FirstViewController.m</source>
          <target state="translated">FirstViewController.m</target>
        </trans-unit>
        <trans-unit id="9609a00b7fb972ff05c1431d4f283cdd084f76ce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;ViewControllerA&lt;/code&gt; to be a delegate of &lt;code&gt;ViewControllerB&lt;/code&gt; it must conform to &lt;code&gt;ViewControllerB&lt;/code&gt;'s protocol which we have to specify. This tells &lt;code&gt;ViewControllerA&lt;/code&gt; which methods it must implement.</source>
          <target state="translated">为了使 &lt;code&gt;ViewControllerA&lt;/code&gt; 成为ViewControllerB的委托，它必须符合我们必须指定的 &lt;code&gt;ViewControllerB&lt;/code&gt; 协议。 这告诉 &lt;code&gt;ViewControllerA&lt;/code&gt; 它必须实现哪些方法。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="ddb095a25c86563637fe3a13523173efa1d4bd90" translate="yes" xml:space="preserve">
          <source>For this example, we will have &lt;code&gt;ViewControllerA&lt;/code&gt; and &lt;code&gt;ViewControllerB&lt;/code&gt;</source>
          <target state="translated">对于此示例，我们将有 &lt;code&gt;ViewControllerA&lt;/code&gt; 和 &lt;code&gt;ViewControllerB&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fd567287999a459caadcea427cbafc09d8c04a6" translate="yes" xml:space="preserve">
          <source>For those interested, I wrote some articles that address these points more in depth and highlight the various drawbacks:</source>
          <target state="translated">对于有兴趣的朋友,我写了一些文章,更深入地阐述了这些观点,强调了各种弊端。</target>
        </trans-unit>
        <trans-unit id="32096c328bd65055c2650eb54a84201d94dbdd3e" translate="yes" xml:space="preserve">
          <source>Go to your SecondViewController.h and write two methods</source>
          <target state="translated">去你的SecondViewController.h中写两个方法</target>
        </trans-unit>
        <trans-unit id="66b1fbfc6e5394baafe61e59c041f14de3f8dfa2" translate="yes" xml:space="preserve">
          <source>Here are two trivial examples of the segue glue.  The first is straightforward showing one parameter passed for input, the second for output.</source>
          <target state="translated">这里有两个琐碎的segue胶葛的例子。第一个是直截了当地显示了一个参数为输入,第二个为输出。</target>
        </trans-unit>
        <trans-unit id="c503ca63bb5c748744204770c2f45a34800264da" translate="yes" xml:space="preserve">
          <source>Here is the setup for the receiver.</source>
          <target state="translated">下面是接收机的设置。</target>
        </trans-unit>
        <trans-unit id="27ec3a0713aa1a15fc2589ac80289f434c756874" translate="yes" xml:space="preserve">
          <source>Here is the setup for the sender</source>
          <target state="translated">以下是发送者的设置</target>
        </trans-unit>
        <trans-unit id="2ed131c901fbe28ddf0ce2cd8b65f252fbcb1bac" translate="yes" xml:space="preserve">
          <source>Hook up the outlets for the &lt;code&gt;UITextField&lt;/code&gt; and the &lt;code&gt;UILabel&lt;/code&gt;.</source>
          <target state="translated">连接 &lt;code&gt;UITextField&lt;/code&gt; 和 &lt;code&gt;UILabel&lt;/code&gt; 的出口。</target>
        </trans-unit>
        <trans-unit id="c858c878a55e6b91f549851d54d1a349d5effd3d" translate="yes" xml:space="preserve">
          <source>Hope This Helps.</source>
          <target state="translated">希望这对你有帮助。</target>
        </trans-unit>
        <trans-unit id="0f0122ee4a988027a9316eb9e7ae9f1f39324dd0" translate="yes" xml:space="preserve">
          <source>Hope i added something to the discussion.</source>
          <target state="translated">希望我在讨论中加入了一些东西。</target>
        </trans-unit>
        <trans-unit id="5a142ce919975d47656e09ab99d87f6db6c24f1b" translate="yes" xml:space="preserve">
          <source>Hope some of you find this solution useful/interesting.</source>
          <target state="translated">希望你们中的一些人觉得这个解决方案很有意义。</target>
        </trans-unit>
        <trans-unit id="3dde88ebb2cd0d70e69aeb2a7ef870a86f8e1b6f" translate="yes" xml:space="preserve">
          <source>Hope this helps</source>
          <target state="translated">希望对你有帮助</target>
        </trans-unit>
        <trans-unit id="2cdfefbe424649534d9db2ab8261c3eafbd9a6e9" translate="yes" xml:space="preserve">
          <source>How iOS View Controllers Communicate With Each Other</source>
          <target state="translated">iOS 视图控制器如何相互通信</target>
        </trans-unit>
        <trans-unit id="c7727df2be19971e8927f49141a1a5496f4054e8" translate="yes" xml:space="preserve">
          <source>How to Structure the Code of iOS Apps</source>
          <target state="translated">如何结构化iOS应用程序的代码</target>
        </trans-unit>
        <trans-unit id="a7486bddaa4b0348571f0d1a8a53e76566788cb0" translate="yes" xml:space="preserve">
          <source>I am currently contributing to an open source solution to this problem through a project called MCViewFactory, which may be found here:</source>
          <target state="translated">我目前正在通过一个名为MCViewFactory的项目为这个问题的开源解决方案做出贡献,可以在这里找到。</target>
        </trans-unit>
        <trans-unit id="f2d0ca81764b2c3a3e1f362cde1e9ab36322bd51" translate="yes" xml:space="preserve">
          <source>I am going to rewrite his logic in Swift with latest iOS Framework</source>
          <target state="translated">我准备用最新的iOS框架用Swift重写他的逻辑。</target>
        </trans-unit>
        <trans-unit id="32993e505110576861bf61a7774bb4e29093aa24" translate="yes" xml:space="preserve">
          <source>I ended up using this example</source>
          <target state="translated">我最后用的是这个例子</target>
        </trans-unit>
        <trans-unit id="fb06d1564152df661993e0e7090fe2a1f0d5b7e9" translate="yes" xml:space="preserve">
          <source>I find simplest and most elegant version with passing blocks.
Let's name view controller that waits for returned data as &quot;A&quot; and returning view controller as &quot;B&quot;. In this example we want to get 2 values: first of Type1 and second of Type2.</source>
          <target state="translated">我发现最简单、最优雅的版本是用传递块。让我们把等待返回数据的视图控制器命名为 &quot;A&quot;,返回的视图控制器命名为 &quot;B&quot;。在这个例子中,我们希望得到2个值:第一个是Type1,第二个是Type2。</target>
        </trans-unit>
        <trans-unit id="1333860eaa3d97443744ef9200f6a80fa125579a" translate="yes" xml:space="preserve">
          <source>I found there are more ways:</source>
          <target state="translated">我发现还有更多的方法。</target>
        </trans-unit>
        <trans-unit id="63c023c5a80422806d084a6c97842a45d00ed69c" translate="yes" xml:space="preserve">
          <source>I have a view that acts as a data entry form and I want to give the user the option to select multiple products. The products are listed on another view with a &lt;code&gt;UITableViewController&lt;/code&gt; and I have enabled multiple selections.</source>
          <target state="translated">我有一个充当数据输入表单的视图，我想给用户选择多个产品的选项。 这些产品在另一个带有 &lt;code&gt;UITableViewController&lt;/code&gt; 的视图中列出，并且我启用了多个选择。</target>
        </trans-unit>
        <trans-unit id="daab7a9e1660ea80bf746f2a7ffe137093641504" translate="yes" xml:space="preserve">
          <source>I have seen a lot of people over complicating this using the &lt;code&gt;didSelectRowAtPath&lt;/code&gt; method. I am using Core Data in my example.</source>
          <target state="translated">我已经看到很多人使用 &lt;code&gt;didSelectRowAtPath&lt;/code&gt; 方法将其复杂化。 我在示例中使用的是Core Data。</target>
        </trans-unit>
        <trans-unit id="16aeeef45f1fe8a16c172b0d0778c79a341461c5" translate="yes" xml:space="preserve">
          <source>I have surfed around and seen some people declare an array in the app delegate. I read something about Singletons but don't understand what these are and I read something about creating a data model.</source>
          <target state="translated">我在网上浏览了一下,看到有些人在app delegate中声明了一个数组。我看了一些关于Singletons的东西,但不明白这些是什么,我看了一些关于创建数据模型的东西。</target>
        </trans-unit>
        <trans-unit id="814549b2a629fcb2811c5678e6e7c5629c9fa79a" translate="yes" xml:space="preserve">
          <source>I hope this answer is clear enough for people to understand and that I have not missed anything.</source>
          <target state="translated">希望这个答案能让大家看得清楚,也希望我没有遗漏什么。</target>
        </trans-unit>
        <trans-unit id="15f9e48f7ce909c17212445d5661bf8a3c542dbc" translate="yes" xml:space="preserve">
          <source>I know this is a beaten subject but for those looking to answer this question with a SWIFT slant and want a bare-bones example, here my go-to method for passing data if you are using a segue to get around.</source>
          <target state="translated">我知道这是个热门话题,但对于那些想用SWIFT斜面回答这个问题并希望得到一个赤裸裸裸裸的例子的人来说,如果您使用segue来绕过这个问题,这里是我的传数据方法。</target>
        </trans-unit>
        <trans-unit id="81a9e22efbeff10a44db5b8cdb745bd06025c82b" translate="yes" xml:space="preserve">
          <source>I like the idea of Model objects and Mock objects based on NSProxy to commit or discard data if what user selects can be cancelled.</source>
          <target state="translated">我喜欢基于NSProxy的Model对象和Mock对象来提交或丢弃数据,如果用户选择的东西可以取消,我喜欢这样的想法。</target>
        </trans-unit>
        <trans-unit id="baaf8a3ca4379be9cd2bab483d766c8d34304728" translate="yes" xml:space="preserve">
          <source>I was searching this solution for long time, Atlast I found it. First of all declare all the objects in your SecondViewController.h file like</source>
          <target state="translated">我找了很久这个解决方案,Atlast我找到了。首先,在你的SecondViewController.h文件中声明所有的对象,例如</target>
        </trans-unit>
        <trans-unit id="62c982b0a0ffe5bca814c4394638faed462207da" translate="yes" xml:space="preserve">
          <source>I wrote a blog post about this a while back: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;Sharing Model Code&lt;/a&gt;. Here's a brief summary:</source>
          <target state="translated">不久前，我写了一篇关于此的博客文章： &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;共享模型代码&lt;/a&gt; 。 这是一个简短的摘要：</target>
        </trans-unit>
        <trans-unit id="f35d400cc0a2783a34596a1675a4eb5991195da1" translate="yes" xml:space="preserve">
          <source>I'm new to iOS and Objective-C and the whole MVC paradigm and I'm stuck with the following:</source>
          <target state="translated">我是iOS和Objective-C以及整个MVC范式的新手,我对iOS和Objective-C以及整个MVC范式都很陌生,我被下面的内容卡住了。</target>
        </trans-unit>
        <trans-unit id="df1f75720203e34b8f92760b6e05286c591390f8" translate="yes" xml:space="preserve">
          <source>If you are using Storyboards you are most likely using segues and will need this procedure to pass data forward. This is similar to the above but instead of passing the data before you push the view controller, you use a method called</source>
          <target state="translated">如果您使用的是Storyboards,那么您很可能使用的是segues,并且需要这个过程来传递数据转发。这与上面的方法类似,但在推送视图控制器之前,你将使用一个叫做</target>
        </trans-unit>
        <trans-unit id="09342e817a09bfb2e555b89afe5f0a71bebde6b8" translate="yes" xml:space="preserve">
          <source>If you have your views embedded in a navigation controller you need to change the method above slightly to the following</source>
          <target state="translated">如果你将视图嵌入到导航控制器中,你需要将上面的方法略微改变为以下方法</target>
        </trans-unit>
        <trans-unit id="c057436dcaf9858c8a465dcfbcf74653c62e56d3" translate="yes" xml:space="preserve">
          <source>If you want to pass data from one controller to other try this code</source>
          <target state="translated">如果你想把数据从一个控制器传给另一个控制器,可以试试这个代码</target>
        </trans-unit>
        <trans-unit id="5aaeee5260096b956e2adc18507a3dbdbd4de81b" translate="yes" xml:space="preserve">
          <source>If you want to send data from one to another viewController, here's a way to it:</source>
          <target state="translated">如果你想把数据从一个发送到另一个viewController,这里有一个方法。</target>
        </trans-unit>
        <trans-unit id="df625f6457413343ada0786d3f8df7e44cb409c4" translate="yes" xml:space="preserve">
          <source>Implement a method with a    UIStoryboardSegue argument in  VC 1,    like this one:</source>
          <target state="translated">在VC 1中实现一个带UIStoryboardSegue参数的方法,就像这样。</target>
        </trans-unit>
        <trans-unit id="d5bbe6ca201c4fe5dda1d1e053bb7f12a4edd65d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerA.m&lt;/code&gt; implement the following method from our protocol</source>
          <target state="translated">在 &lt;code&gt;ViewControllerA.m&lt;/code&gt; 中 ，从我们的协议中实现以下方法</target>
        </trans-unit>
        <trans-unit id="9d6547b304166959ffcc04dfdf16623cf62b971e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerB.h&lt;/code&gt;, below the &lt;code&gt;#import&lt;/code&gt;, but above &lt;code&gt;@interface&lt;/code&gt; you specify the protocol.</source>
          <target state="translated">在 &lt;code&gt;ViewControllerB.h&lt;/code&gt; 的 &lt;code&gt;#import&lt;/code&gt; 下方，但在 &lt;code&gt;@interface&lt;/code&gt; 上方，您可以指定协议。</target>
        </trans-unit>
        <trans-unit id="34f4b01f04c9ab50f1dc277e194a6c707b3ae757" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ViewControllerB&lt;/code&gt; we call a message on the &lt;code&gt;delegate&lt;/code&gt; when we pop the view controller.</source>
          <target state="translated">在 &lt;code&gt;ViewControllerB&lt;/code&gt; 中 ，当我们弹出视图控制器时，我们在 &lt;code&gt;delegate&lt;/code&gt; 上调用一条消息。</target>
        </trans-unit>
        <trans-unit id="d4cb986f06c8a358bb0ac401e2255be7435b3ec6" translate="yes" xml:space="preserve">
          <source>In NewViewController.h</source>
          <target state="translated">在NewViewController.h中</target>
        </trans-unit>
        <trans-unit id="ee25efeb34aea96a92caf4d24a919db9885aa93d" translate="yes" xml:space="preserve">
          <source>In NewViewController.m</source>
          <target state="translated">在NewViewController.m中</target>
        </trans-unit>
        <trans-unit id="fcfba25eeca43facefb5d34107096b545f63a8ea" translate="yes" xml:space="preserve">
          <source>In both unwind options you can set the tag property of the button and check it in
        the prepareForSegue.</source>
          <target state="translated">在这两个开卷选项中,你可以设置按钮的标签属性,并在prepareForSegue中检查它。</target>
        </trans-unit>
        <trans-unit id="61da207f2a6f23452f52382b7096f549ed3ae3a9" translate="yes" xml:space="preserve">
          <source>In my case I used a singleton class which can work as a global object allowing accesses to the data from almost everywhere in the app. First thing is to build a singleton class. Please refer to the page,&quot; &lt;a href=&quot;https://stackoverflow.com/questions/145154/what-does-your-objective-c-singleton-look-like&quot;&gt;What should my Objective-C singleton look like?&lt;/a&gt; &quot;
And what I did to make the object globally accessible was simply import it in &lt;code&gt;appName_Prefix.pch&lt;/code&gt; which is for applying import statement in every classes.
To access this object and to use, I simply implemented class method to return the shared instance, which contains its own variables</source>
          <target state="translated">就我而言，我使用了一个单例类，该类可以用作全局对象，从而允许从应用程序中的几乎所有位置访问数据。 第一件事是建立一个单例类。 请参阅页面，&amp;ldquo; &lt;a href=&quot;https://stackoverflow.com/questions/145154/what-does-your-objective-c-singleton-look-like&quot;&gt;我的Objective-C单例应该是什么样？&lt;/a&gt; &amp;rdquo;而我使对象可全局访问的操作只是将其导入 &lt;code&gt;appName_Prefix.pch&lt;/code&gt; 中 ，该appName_Prefix.pch用于在每个类中应用import语句。 为了访问和使用该对象，我仅实现了类方法以返回共享实例，该实例包含其自己的变量。</target>
        </trans-unit>
        <trans-unit id="4347c7d44969ad5ed12d4df451dd2631e4a3c195" translate="yes" xml:space="preserve">
          <source>In practice, in my opinion only a few solutions are recommended:</source>
          <target state="translated">在实践中,笔者认为只推荐几种解决方案。</target>
        </trans-unit>
        <trans-unit id="bf835249be3289308815771b6433af2277b90842" translate="yes" xml:space="preserve">
          <source>In scenario one, we have several viable solutions, as other answers have given</source>
          <target state="translated">在第一种情况下,我们有几个可行的解决方案,正如其他答案所给出的那样:</target>
        </trans-unit>
        <trans-unit id="24e6d5a69f4225a7a61ed046e01222766c16f892" translate="yes" xml:space="preserve">
          <source>In scenario two, we do not have a single property of the HouseholdInventoryManager which could be observed using KVO. Because we do not have a single property which is easily observable, the observer pattern, in this case, must be implemented using NSNotificationCenter. Each of the four view controllers would subscribe to notifications, and the sharedManager would send notifications to the notification center when appropriate. The inventory manager does not need to know anything about the view controllers or instances of any other classes which may be interested in knowing when the collection of inventory items changes; the NSNotificationCenter takes care of these implementation details. The View Controllers simply subscribe to notifications, and the data manager simply posts notifications.</source>
          <target state="translated">在方案二中,我们没有一个可以用KVO观察到的HouseholdInventoryManager的单个属性。因为我们没有一个可以轻易观察到的单一属性,所以在这种情况下,必须使用NSNotificationCenter来实现观察者模式。四个视图控制器中的每个视图控制器都会订阅通知,共享管理器会在适当的时候向通知中心发送通知。库存管理器不需要知道任何关于视图控制器的信息,也不需要知道任何其他可能有兴趣知道库存项集合何时发生变化的类的实例;NSNotificationCenter负责处理这些实现细节。视图控制器只需订阅通知,而数据管理器只需发布通知。</target>
        </trans-unit>
        <trans-unit id="e1379c7d385f5fd318471115c5d1d1f688e6b7f5" translate="yes" xml:space="preserve">
          <source>In scenario two, we have other viable solutions:</source>
          <target state="translated">在第二种情况下,我们有其他可行的解决方案。</target>
        </trans-unit>
        <trans-unit id="58156148d8f8b4168742db8860d1cd7839fb7ebe" translate="yes" xml:space="preserve">
          <source>In the implementation of the Controller2 class there will be this function as-</source>
          <target state="translated">在Controller2类的实现中,将有这样一个函数作为-</target>
        </trans-unit>
        <trans-unit id="5156e8c6be3a57c9fa8103860d77229d47cc7974" translate="yes" xml:space="preserve">
          <source>In the storyBoard hook the &quot;return&quot; button to the green Exit
button(Unwind) of the vc.
 Now you have a segue that &quot;goes back&quot; so u can use the
destinationViewController property in the prepareForSegue of VC2 and
change any property of VC1 before it goes back.</source>
          <target state="translated">在storyBoard中,将 &quot;return &quot;按钮与VC的绿色Exit按钮(Unwind)挂钩。现在你有了一个 &quot;返回 &quot;的segue,所以你可以使用VC2的prepareForSegue中的destinationViewController属性,在返回之前改变VC1的任何属性。</target>
        </trans-unit>
        <trans-unit id="4e86367af7272fc181fb5bcd8c70015239a60e37" translate="yes" xml:space="preserve">
          <source>In viewControllerA.m</source>
          <target state="translated">在viewControllerA.m中</target>
        </trans-unit>
        <trans-unit id="8a08c48c65d645ac979b803ebbf4f71b0159c9d9" translate="yes" xml:space="preserve">
          <source>In viewControllerB.m</source>
          <target state="translated">在viewControllerB.m中</target>
        </trans-unit>
        <trans-unit id="cb79757699a18236287e35ceb1f9e3b022bb1e91" translate="yes" xml:space="preserve">
          <source>Independent access</source>
          <target state="translated">独立访问</target>
        </trans-unit>
        <trans-unit id="3880381f94e658ae2233113129d0559225e916ff" translate="yes" xml:space="preserve">
          <source>It is similar to the above but without the buttons, labels and such.  Just simply passing data from one view to the next.</source>
          <target state="translated">它和上面的类似,但没有按钮、标签之类的东西。只是简单的将数据从一个视图传递到下一个视图。</target>
        </trans-unit>
        <trans-unit id="b906440f7eeb43644c0bf66e1e5221e013acae00" translate="yes" xml:space="preserve">
          <source>It's easy to pass data around since it's single object or couple of objects and if you have let's say UINavigationController controller, you can keep the reference to model inside and all pushed view controllers can access it directly from navigation controller.</source>
          <target state="translated">因为是单个对象或者是几个对象,所以很容易传递数据,如果你有UINavigationController控制器,你可以把模型的引用保留在里面,所有推送的视图控制器都可以直接从导航控制器中访问。</target>
        </trans-unit>
        <trans-unit id="0b5d7461b214a33821ecc10f031e0f6c05ecb915" translate="yes" xml:space="preserve">
          <source>Key-Value Observing</source>
          <target state="translated">关键值观察</target>
        </trans-unit>
        <trans-unit id="8d8b4106a4bbadd0d9b29b9a2e51f6ef83bfb01d" translate="yes" xml:space="preserve">
          <source>Key-Value-Observing (KVO)</source>
          <target state="translated">关键值观察(KVO)</target>
        </trans-unit>
        <trans-unit id="083eb368f20ff79cd32a80916799dbc06c14959b" translate="yes" xml:space="preserve">
          <source>Lastly, the setup for the segue.</source>
          <target state="translated">最后,设置的segue。</target>
        </trans-unit>
        <trans-unit id="f46a343ce085e475c030eeb1bc56e9b6d0820f1a" translate="yes" xml:space="preserve">
          <source>Managing Data Flow Between View Controllers</source>
          <target state="translated">管理视图控制器之间的数据流</target>
        </trans-unit>
        <trans-unit id="6261f4593d459846fc2f53486c547ab992d8a961" translate="yes" xml:space="preserve">
          <source>Many beginner programmers take advantage of the fact that there is always exactly one &lt;strong&gt;Application Delegate&lt;/strong&gt; in the lifetime of the application, which is globally accessible. Beginning programmers use this fact to stuff objects and functionality into the appDelegate as a convenience for access from anywhere else in the application. Just because the AppDelegate is a singleton doesn't mean it should replace all other singletons. This is a poor practice as it places too much burden on one class, breaking good object-oriented practices. Each class should have a clear role that is easily explained, often just by the name of the class.</source>
          <target state="translated">许多初学者都利用了这样一个事实，那就是在应用程序的生命周期中始终只有一个&lt;strong&gt;应用程序委托&lt;/strong&gt; ，该&lt;strong&gt;委托&lt;/strong&gt;可以全局访问。 入门程序员使用此事实将对象和功能填充到appDelegate中，以方便从应用程序中任何其他位置进行访问。 仅仅因为AppDelegate是一个单例并不意味着它应该替换所有其他单例。 这是一种糟糕的做法，因为它将过多的负担放在一个类上，破坏了良好的面向对象的做法。 每个类都应具有明确的角色，并且通常仅通过类名即可轻松解释。</target>
        </trans-unit>
        <trans-unit id="ee93bc5d4f01f7c4f087cb3eea0c1a1fa3b208c9" translate="yes" xml:space="preserve">
          <source>My question is, how do I transfer the data from one view to another? I will be holding the selections on the &lt;code&gt;UITableView&lt;/code&gt; in an array, but how do I then pass that back to the previous data entry form view so it can be saved along with the other data to Core Data on submission of the form?</source>
          <target state="translated">我的问题是，如何将数据从一个视图传输到另一个视图？ 我将在数组中的 &lt;code&gt;UITableView&lt;/code&gt; 上保留选择，但是如何将其传递回以前的数据输入表单视图，以便在提交表单时将其与其他数据一起保存到Core Data？</target>
        </trans-unit>
        <trans-unit id="a18e3f8bc52ea9a0b5de60e0fda22bd4b604ae4c" translate="yes" xml:space="preserve">
          <source>NSFetchedResultsController</source>
          <target state="translated">NSFetchedResultsController</target>
        </trans-unit>
        <trans-unit id="3f1be4da3d97e7743b4732f8a89228df11998162" translate="yes" xml:space="preserve">
          <source>NSNotification</source>
          <target state="translated">NSNotification</target>
        </trans-unit>
        <trans-unit id="703e1cf67303eac1ee399d96fe268f382746c5ae" translate="yes" xml:space="preserve">
          <source>NSNotificationCenter.</source>
          <target state="translated">NSNotificationCenter.</target>
        </trans-unit>
        <trans-unit id="433d340991507812dfa779c7f285cce0740b90aa" translate="yes" xml:space="preserve">
          <source>NSUserDefaults (actually a poor choice)</source>
          <target state="translated">NSUserDefaults(实际上是一个很差的选择。</target>
        </trans-unit>
        <trans-unit id="3ddf7238b6f7a09861615351dda77ab298ecd4c4" translate="yes" xml:space="preserve">
          <source>Next, we need to add the method to &lt;code&gt;ViewControllerA&lt;/code&gt; that is called when any segue is performed, because of this we need to detect which segue was called and then do something. In our example we will check for &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; and if that's performed we will pass our &lt;code&gt;BOOL&lt;/code&gt; value to &lt;code&gt;ViewControllerB&lt;/code&gt;</source>
          <target state="translated">接下来，我们需要将方法添加到执行任何segue时要调用的 &lt;code&gt;ViewControllerA&lt;/code&gt; ，因此，我们需要检测调用了哪个segue，然后执行某些操作。 在我们的示例中，我们将检查 &lt;code&gt;&quot;showDetailSegue&quot;&lt;/code&gt; ，如果执行了此操作，则将 &lt;code&gt;BOOL&lt;/code&gt; 值传递给 &lt;code&gt;ViewControllerB&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bae49983d331f8ba8153193a85e0fefdfdfa8445" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;protocol&lt;/code&gt; is outside of the View Controller class.</source>
          <target state="translated">请注意，该 &lt;code&gt;protocol&lt;/code&gt; 在View Controller类之外。</target>
        </trans-unit>
        <trans-unit id="7b5b766ef197bc7d0023a5f3e888401660c5170a" translate="yes" xml:space="preserve">
          <source>Note the use of our custom &lt;code&gt;DataEnteredDelegate&lt;/code&gt; protocol.</source>
          <target state="translated">请注意我们自定义的 &lt;code&gt;DataEnteredDelegate&lt;/code&gt; 协议的使用。</target>
        </trans-unit>
        <trans-unit id="c18f8f255ab9c208f23d0340eb9dff5a84efe311" translate="yes" xml:space="preserve">
          <source>Notification</source>
          <target state="translated">Notification</target>
        </trans-unit>
        <trans-unit id="01ae3c85aad097022aea128cd630e363a5a0b504" translate="yes" xml:space="preserve">
          <source>Notification - for broadcasting data to multiple classes at a single time</source>
          <target state="translated">通知----用于同时向多个班级广播数据。</target>
        </trans-unit>
        <trans-unit id="4b1ac88a12c84ad56cbb34ecd00cd8b11ad67ab8" translate="yes" xml:space="preserve">
          <source>Now go to ViewController1.h and add the following property:</source>
          <target state="translated">现在到ViewController1.h中添加以下属性。</target>
        </trans-unit>
        <trans-unit id="f4fdc026034f453314cb2b9feb3226cf19c866df" translate="yes" xml:space="preserve">
          <source>Now go to ViewController2.h and add</source>
          <target state="translated">现在转到ViewController2.h并添加</target>
        </trans-unit>
        <trans-unit id="07293e03847eaf2deb454753b5701dde56438146" translate="yes" xml:space="preserve">
          <source>Now go to ViewController2.m and inside the implementation add:</source>
          <target state="translated">现在进入ViewController2.m,在实现里面添加。</target>
        </trans-unit>
        <trans-unit id="1891d36db45cf91dbf1adab42bd7124ff5f7b4aa" translate="yes" xml:space="preserve">
          <source>Now if you are creating ViewController1 inside ViewController2 after some event, then you should do it this way using NIB files:</source>
          <target state="translated">现在,如果你是在ViewController2内部创建ViewController1,那么你应该使用NIB文件这样做。</target>
        </trans-unit>
        <trans-unit id="81718fed0b8059c2699c24b22f89672b462cced7" translate="yes" xml:space="preserve">
          <source>Now in viewControllerB.h</source>
          <target state="translated">现在在viewControllerB.h中</target>
        </trans-unit>
        <trans-unit id="066cfa98ab2af89a37dd0692de1da1e510da9279" translate="yes" xml:space="preserve">
          <source>Now in your implementation file allocate the memory for those objects like this</source>
          <target state="translated">现在在你的实现文件中为这些对象分配内存,就像这样分配内存</target>
        </trans-unit>
        <trans-unit id="25d28a372f3af29852f3a97a0f8b0fbc603109d9" translate="yes" xml:space="preserve">
          <source>Now that we understand what a singleton is, let's discuss how a singleton fits into the observer pattern. The observer pattern is used for one object to respond to changes by another object. In the second scenario, we have four different view controllers, who all want to know about changes to the underlying data. The &quot;underlying data&quot; should belong to a single instance, a singleton. The &quot;know about changes&quot; is accomplished by observing changes made to the singleton.</source>
          <target state="translated">现在我们明白了什么是单体,那么我们来讨论一下单体是如何融入观察者模式的。观察者模式用于一个对象响应另一个对象的变化。在第二个场景中,我们有四个不同的视图控制器,它们都想知道底层数据的变化。这个 &quot;底层数据 &quot;应该属于一个单一的实例,即一个单子。而 &quot;了解变化 &quot;是通过观察对单体的变化来实现的。</target>
        </trans-unit>
        <trans-unit id="810d6004f87bdd4f1aaf25235b9fc765e7454783" translate="yes" xml:space="preserve">
          <source>Now you are all set, whenever you detect the event of check changed in ViewController1, all you have to do is the below</source>
          <target state="translated">现在你已经准备好了,每当你检测到ViewController1中的检查事件发生变化时,你要做的就是下面的步骤</target>
        </trans-unit>
        <trans-unit id="b3a73828042eb03dcbae2c139bf92a09db907f20" translate="yes" xml:space="preserve">
          <source>Now you have allocated the memory for &lt;code&gt;Array&lt;/code&gt; and object. now you can fill that memory before pushing this &lt;code&gt;ViewController&lt;/code&gt;</source>
          <target state="translated">现在，您已经为 &lt;code&gt;Array&lt;/code&gt; 和对象分配了内存。 现在您可以在推送此 &lt;code&gt;ViewController&lt;/code&gt; 之前填充该内存</target>
        </trans-unit>
        <trans-unit id="9f65e68be86324bc6597c188e4d73418ae145285" translate="yes" xml:space="preserve">
          <source>Now, in your VC, anytime you want to move to a new VC and pass data, you create a new intent and add data to its dictionary (savedInstanceState). Then, just set the current intent of factory:</source>
          <target state="translated">现在,在你的VC中,每当你想移动到一个新的VC并传递数据时,你就会创建一个新的intent,并将数据添加到它的字典(saveInstanceState)中。然后,只需设置当前意图的工厂。</target>
        </trans-unit>
        <trans-unit id="bec1d95a6f86d7011a1b0191ad1cb2a79100a6f0" translate="yes" xml:space="preserve">
          <source>Observer Pattern</source>
          <target state="translated">观察者模式</target>
        </trans-unit>
        <trans-unit id="6869e328e00e68ce2087969b13da4a7500c52bc3" translate="yes" xml:space="preserve">
          <source>Once it is run it should switch to the receiver view automatically and pass the value from the sender to the receiver, displaying the value in the console.</source>
          <target state="translated">一旦运行后,它会自动切换到接收方视图,并将值从发送方传给接收方,在控制台中显示。</target>
        </trans-unit>
        <trans-unit id="1a8ee395cb2fe5ae68947c4ee9e43e6c00f1c91e" translate="yes" xml:space="preserve">
          <source>One approach is to share pointers to the model objects between view controllers.</source>
          <target state="translated">一种方法是在视图控制器之间共享模型对象的指针。</target>
        </trans-unit>
        <trans-unit id="c4076a44a136b6e3d1dde14cee2663da71d34347" translate="yes" xml:space="preserve">
          <source>One thing to remember is that using block often needs to manage strong and __weak references  like explained &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW16&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">要记住的一件事是，使用块通常需要管理强和弱的引用，如此处所述</target>
        </trans-unit>
        <trans-unit id="0e88c4b3dfd5e93f534f4bbe8851936f162bd94e" translate="yes" xml:space="preserve">
          <source>Or if you need to pass more than 3 parameters which are related to a common feature you can store the values to a Model class and pass that modelObject to the next class</source>
          <target state="translated">或者,如果你需要传递3个以上的参数,而这些参数是与一个共同的特征相关的,你可以将值存储到一个Model类中,然后将这个modelObject传递给下一个类</target>
        </trans-unit>
        <trans-unit id="ad245eca6b5201f4babe15b0ebc45f1a1101dc9c" translate="yes" xml:space="preserve">
          <source>Passing Data Between View Controllers</source>
          <target state="translated">视图控制器之间的数据传递</target>
        </trans-unit>
        <trans-unit id="06cd07cfe5ceeea538fa8519602b78db4a7a221b" translate="yes" xml:space="preserve">
          <source>Passing Data between View Controllers</source>
          <target state="translated">视图控制器之间的数据传递</target>
        </trans-unit>
        <trans-unit id="e969e4903b74ca67d170b3ed2c9867a31ea779e7" translate="yes" xml:space="preserve">
          <source>Passing data back from ViewController 2(destination) to viewController 1(Source) is the more interesting thing.
Assuming you use storyBoard those are all the ways i found out:</source>
          <target state="translated">将数据从ViewController 2(destination)传回viewController 1(Source)是比较有意思的事情。假设你使用的是storyBoard,这就是我发现的所有方法。</target>
        </trans-unit>
        <trans-unit id="90994a166764b8045c671701e6012101fbad1f99" translate="yes" xml:space="preserve">
          <source>Passing data back to the previous View Controller</source>
          <target state="translated">将数据传回上一个View Controller</target>
        </trans-unit>
        <trans-unit id="f34143ad2ab7c3261acf61c694d57262c6895d43" translate="yes" xml:space="preserve">
          <source>Passing data forward to a view controller from another view controller. You would use this method if you wanted to pass an object/value from one view controller to another view controller that you may be pushing on to a navigation stack.</source>
          <target state="translated">将数据从另一个视图控制器转发到另一个视图控制器。如果你想将一个对象值从一个视图控制器传递到另一个可能推送到导航堆栈的视图控制器,你会使用这个方法。</target>
        </trans-unit>
        <trans-unit id="72012e34fc1aeacc4018406263df2a50524a13b3" translate="yes" xml:space="preserve">
          <source>Passing data forward to the next View Controller</source>
          <target state="translated">将数据转发到下一个视图控制器</target>
        </trans-unit>
        <trans-unit id="7cbc262874edf29fb88c6eb2ae168aa523c5bed0" translate="yes" xml:space="preserve">
          <source>Passing data through notifications</source>
          <target state="translated">通过通知传递数据</target>
        </trans-unit>
        <trans-unit id="e73c1b3673eb3091a3411becb205b9ac61c3efb6" translate="yes" xml:space="preserve">
          <source>Passing data through the app delegate</source>
          <target state="translated">通过应用程序的委托人传递数据</target>
        </trans-unit>
        <trans-unit id="a915a260ebb52c58c5ddeb3943b28412a9cefd74" translate="yes" xml:space="preserve">
          <source>Please tell me if there's anything that's not clear of if I didn't understand your question properly.</source>
          <target state="translated">如果我没有正确理解你的问题,有什么不清楚的地方请告诉我。</target>
        </trans-unit>
        <trans-unit id="f176ff29bfb1c8e95257d7a079bef36426919bfd" translate="yes" xml:space="preserve">
          <source>Rather than having a highly hypothetical, abstract discussion, it helps to have concrete applications in mind. To help define a two-view-controller situation and a more-than-two-view-controller situation, I am going to define two concrete application scenarios.</source>
          <target state="translated">与其进行高度假设的、抽象的讨论,不如在脑海中形成一个具体的应用场景,这对我们有帮助。为了帮助定义双视图控制器的情况和更多的双视图控制器的情况,我将定义两个具体的应用场景。</target>
        </trans-unit>
        <trans-unit id="96723c17d633897e26d4e0d1557b30b3a18133db" translate="yes" xml:space="preserve">
          <source>Read more about this in my blog post: &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;Sharing Model Code&lt;/a&gt;</source>
          <target state="translated">在我的博客文章中了解有关此内容的更多信息： &lt;a href=&quot;http://koreyhinton.com/blog/sharing-model-code.html&quot;&gt;共享模型代码&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="a6171b282836b161fc897d0e7facdf82f4d8f378" translate="yes" xml:space="preserve">
          <source>Referencing the previous controller directly instead of using delegation</source>
          <target state="translated">直接引用上一个控制器,而不是使用委托代理的方式。</target>
        </trans-unit>
        <trans-unit id="47f40c97b581997edd1f3619ce23a4265e1431df" translate="yes" xml:space="preserve">
          <source>Saving in &lt;code&gt;NSUserDefaults&lt;/code&gt; - for accessing it later</source>
          <target state="translated">保存在 &lt;code&gt;NSUserDefaults&lt;/code&gt; 中 -以后访问</target>
        </trans-unit>
        <trans-unit id="0bcf73dc223ca8c4becbbceb7de2d7cdd2d55fd9" translate="yes" xml:space="preserve">
          <source>Say we have viewControllers: ViewController and NewViewController.</source>
          <target state="translated">假设我们有viewController.ViewController和NewViewController。ViewController和NewViewController。</target>
        </trans-unit>
        <trans-unit id="569d57f11dc5d61438be375ec49d9c3b862b507e" translate="yes" xml:space="preserve">
          <source>Say we have viewControllers: viewControllerA and viewControllerB</source>
          <target state="translated">假设我们有viewController:viewControllerA和viewControllerB。</target>
        </trans-unit>
        <trans-unit id="7995203d870462ca887f06daef0b98c3ee08ad6a" translate="yes" xml:space="preserve">
          <source>SecondViewController.h</source>
          <target state="translated">SecondViewController.h</target>
        </trans-unit>
        <trans-unit id="1915fd9b6120253558e8f5d765575ff18961657e" translate="yes" xml:space="preserve">
          <source>Set data in prepareForSegue (if storyboards) or init (if programmatic)</source>
          <target state="translated">在 prepareForSegue(如果是故事板)或init(如果是程序化)中设置数据</target>
        </trans-unit>
        <trans-unit id="9f9b397db477e0a2585ce2a75ed1b81d61e4549c" translate="yes" xml:space="preserve">
          <source>Set the first and second View Controllers to the appropriate Swift files in IB.</source>
          <target state="translated">将第一个和第二个视图控制器设置为 IB 中适当的 Swift 文件。</target>
        </trans-unit>
        <trans-unit id="ccfa21b36505d345ced6258f5060e6876076d7db" translate="yes" xml:space="preserve">
          <source>Shared data</source>
          <target state="translated">共享数据</target>
        </trans-unit>
        <trans-unit id="63b646be139048f00d5075927d5ac6aa1bc9e3fd" translate="yes" xml:space="preserve">
          <source>Sharing data through a singleton</source>
          <target state="translated">通过单子共享数据</target>
        </trans-unit>
        <trans-unit id="88026f64b6a3f47cdb4c499ea8d5bb82d8ae7191" translate="yes" xml:space="preserve">
          <source>Sharing data through the user defaults</source>
          <target state="translated">通过用户默认共享数据</target>
        </trans-unit>
        <trans-unit id="a81942be08afc02b07b690161fca39667b375b36" translate="yes" xml:space="preserve">
          <source>Since all the view controllers do need to share the same data, all four view controllers need to remain in synchronization, and therefore there needs to be some sort of communication to all other view controllers, whenever any single view controller changes the underlying data. It should be fairly obvious that we do not want each view controller communicating directly with each other view controller in this scenario. In case it is not obvious, consider if we had 20 different view controllers (rather than just 4). How difficult and error-prone would it be to notify each of the other 19 view controllers any time one view controller made a change?</source>
          <target state="translated">由于所有的视图控制器确实需要共享相同的数据,所以所有四个视图控制器都需要保持同步,因此,每当任何一个视图控制器改变底层数据时,都需要与所有其他视图控制器进行某种通信。在这种情况下,我们不希望每个视图控制器直接与其他视图控制器进行通信,这应该是相当明显的。如果不明显的话,可以考虑一下,如果我们有20个不同的视图控制器(而不是只有4个)。当一个视图控制器进行更改时,要通知其他19个视图控制器中的每个视图控制器,会有多难,多容易出错?</target>
        </trans-unit>
        <trans-unit id="956ba40003839a7f10984a661afb553e5a9a4ec6" translate="yes" xml:space="preserve">
          <source>Since prepare for segue is the most common here is an example:</source>
          <target state="translated">由于准备segue是最常见的,这里是一个例子。</target>
        </trans-unit>
        <trans-unit id="39892ce8d343b16aa782fc0cc427d7c5ce4bcd1d" translate="yes" xml:space="preserve">
          <source>Singleton</source>
          <target state="translated">Singleton</target>
        </trans-unit>
        <trans-unit id="5f4a7d1855bedb7eb4c08667076bebd6d20d2643" translate="yes" xml:space="preserve">
          <source>Singleton classes</source>
          <target state="translated">单人班</target>
        </trans-unit>
        <trans-unit id="f4952f106d9d3b4bccd6d238d2f11b71e55ecb4c" translate="yes" xml:space="preserve">
          <source>Singletons</source>
          <target state="translated">Singletons</target>
        </trans-unit>
        <trans-unit id="b57cd7bb78daf1f63929b88ccbd517476d4ae4d7" translate="yes" xml:space="preserve">
          <source>So Here is the complete code for :</source>
          <target state="translated">所以,以下是.NET的完整代码。</target>
        </trans-unit>
        <trans-unit id="067b41481717b1f69eb20355ee8195bf00f43e67" translate="yes" xml:space="preserve">
          <source>So in-short if you want to -</source>
          <target state="translated">所以,如果你愿意的话,在短短的时间内</target>
        </trans-unit>
        <trans-unit id="630e7f3acca48624176a82489c5a93d213da2351" translate="yes" xml:space="preserve">
          <source>So this is how you can pass data from viewControllerA to viewControllerB without setting any delegate. ;)</source>
          <target state="translated">所以这就是你如何从viewControllerA传递数据到viewControllerB,而不需要设置任何delegate。)</target>
        </trans-unit>
        <trans-unit id="156495cd7dd5073171ae3eca350eda618cbfbef4" translate="yes" xml:space="preserve">
          <source>So this way we can pass the data from one viewcontroller to another view controller...</source>
          <target state="translated">所以我们可以通过这种方式将数据从一个viewcontroller传递到另一个viewcontroller......</target>
        </trans-unit>
        <trans-unit id="9fa353fb1913b923bef4e523da2474a47221935b" translate="yes" xml:space="preserve">
          <source>So to pass a &lt;code&gt;BOOL&lt;/code&gt; from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; we would do the following:</source>
          <target state="translated">因此，要将 &lt;code&gt;BOOL&lt;/code&gt; 从 &lt;code&gt;ViewControllerA&lt;/code&gt; 传递到 &lt;code&gt;ViewControllerB&lt;/code&gt; ,我们需要执行以下操作：</target>
        </trans-unit>
        <trans-unit id="98d77a00cf4d2b88573bd271f511f0e79ed4f054" translate="yes" xml:space="preserve">
          <source>Solutions I recommend NOT to use:</source>
          <target state="translated">我建议不要使用的解决方案。</target>
        </trans-unit>
        <trans-unit id="b08338f95aa0ad8470939d5e2faa60ab6d042c8f" translate="yes" xml:space="preserve">
          <source>Step 1. Declare block in ViewControllerB</source>
          <target state="translated">第1步:在ViewControllerB中声明块。在ViewControllerB中声明块。</target>
        </trans-unit>
        <trans-unit id="b2e9b0649764d10cd7a0faf97a6596c1df79f36a" translate="yes" xml:space="preserve">
          <source>Step 1. Set and Post data in Notification observer in ViewControllerB</source>
          <target state="translated">步骤1.在ViewControllerB中设置并发布数据。在ViewControllerB中的Notification observer中设置和发布数据。</target>
        </trans-unit>
        <trans-unit id="68b389f0cd09c0cdce9598cbf02e200602cae14b" translate="yes" xml:space="preserve">
          <source>Step 2. Add Notification Observer in ViewControllerA</source>
          <target state="translated">第二步:在ViewControllerA中添加通知观察者 在ViewControllerA中添加通知观察者</target>
        </trans-unit>
        <trans-unit id="0b56714eef4294da9118c9f272a4110e07a65e76" translate="yes" xml:space="preserve">
          <source>Step 2. Set data in block in ViewControllerB</source>
          <target state="translated">第二步:在ViewControllerB中设置数据 在ViewControllerB中设置块中的数据。</target>
        </trans-unit>
        <trans-unit id="a2546740685a30020fdf8994c5e6ec2f4358487b" translate="yes" xml:space="preserve">
          <source>Step 3. Receive Notification data value in ViewControllerA</source>
          <target state="translated">步骤3:在ViewControllerA中接收通知数据值 接收ViewControllerA中的通知数据值。</target>
        </trans-unit>
        <trans-unit id="8fc7fedaa6db88ca11b7a1de1f3aca654b50e838" translate="yes" xml:space="preserve">
          <source>Step 3. Receive block data in ViewControllerA</source>
          <target state="translated">步骤3:在ViewControllerA中接收块数据 接收ViewControllerA中的块数据</target>
        </trans-unit>
        <trans-unit id="270b96d467cbf5437502201704dee28da77c95f4" translate="yes" xml:space="preserve">
          <source>Storyboard segues, ARC and LLVM blocks make this easier than ever for me.  Some answers above mentioned storyboards and segues already but still relied on delegation.  Defining delegates certainly works but some people may find it easier to pass pointers or code blocks.</source>
          <target state="translated">故事板segues、ARC和LLVM块,让我比以往任何时候都要容易。上面的一些答案已经提到了故事板和segues,但仍然依赖于委托代理。定义委派当然有效,但有些人可能会觉得传递指针或代码块更容易。</target>
        </trans-unit>
        <trans-unit id="3b14c615ad076500bec6990bd3e8c11b39b908a7" translate="yes" xml:space="preserve">
          <source>Suppose in Controller1 class you want to create the Controller2 object and push it with a String value being passed. This can be done as this:-</source>
          <target state="translated">假设在Controller1类中,你想创建Controller2对象,并通过传递一个String值来推送它。可以这样做:-</target>
        </trans-unit>
        <trans-unit id="112ab020698e5fc0f4baecd7821a512d8c419a69" translate="yes" xml:space="preserve">
          <source>Swift</source>
          <target state="translated">Swift</target>
        </trans-unit>
        <trans-unit id="19d9195fc6303123e2881ef15e4a993bb8b3dec5" translate="yes" xml:space="preserve">
          <source>Synthesize str2 in ViewControllerTwo.m</source>
          <target state="translated">在ViewControllerTwo.m中合成str2。</target>
        </trans-unit>
        <trans-unit id="0207a1f2edfc990bff7a614c26a4e4edee42239e" translate="yes" xml:space="preserve">
          <source>Take care for spelling mistakes.</source>
          <target state="translated">注意拼写错误。</target>
        </trans-unit>
        <trans-unit id="09429d005a789be54befa1f80bc0eeaac578f2e8" translate="yes" xml:space="preserve">
          <source>Than in implementation file BViewController.m after we have desired values to return our callback should be called:</source>
          <target state="translated">比在实现文件BViewController.m后,我们在实现文件BViewController.m中有了想要的值后,就应该调用我们的回调。</target>
        </trans-unit>
        <trans-unit id="03d7f840d11dff1bc5d8b6d191428b355e3aebb7" translate="yes" xml:space="preserve">
          <source>Thanks for all your help</source>
          <target state="translated">谢谢你的帮助</target>
        </trans-unit>
        <trans-unit id="8527cb919ee3a95cff65ca01028642d6226a89b6" translate="yes" xml:space="preserve">
          <source>That is how you can tackle it if you want to use a segue and you don't have your pages under a navigation controller.</source>
          <target state="translated">如果你想使用segue,而你的页面没有在导航控制器下,你可以这样处理。</target>
        </trans-unit>
        <trans-unit id="95e8fe02f9d9ffb578ba4e865a2725ad960d20a6" translate="yes" xml:space="preserve">
          <source>That's it for &lt;code&gt;ViewControllerB&lt;/code&gt;. Now in &lt;code&gt;ViewControllerA.h&lt;/code&gt;, tell &lt;code&gt;ViewControllerA&lt;/code&gt; to import &lt;code&gt;ViewControllerB&lt;/code&gt; and conform to its protocol.</source>
          <target state="translated">这就是 &lt;code&gt;ViewControllerB&lt;/code&gt; 。 现在在 &lt;code&gt;ViewControllerA.h&lt;/code&gt; 中 ，告诉 &lt;code&gt;ViewControllerA&lt;/code&gt; 导入 &lt;code&gt;ViewControllerB&lt;/code&gt; 并遵守其协议。</target>
        </trans-unit>
        <trans-unit id="56ac635adbb66b598268b04a53cefa274b67ac90" translate="yes" xml:space="preserve">
          <source>That's it. Running the app now you should be able to send data back from the second view controller to the first.</source>
          <target state="translated">就是这样了。现在运行应用程序,你应该可以将数据从第二个视图控制器传回第一个视图控制器。</target>
        </trans-unit>
        <trans-unit id="61f175a537a69568d4d36d5d1c44c51c042c2dc5" translate="yes" xml:space="preserve">
          <source>The M in MVC is for &quot;Model&quot; and in the MVC paradigm the role of model classes is to manage a program's data. A model is the opposite of a view -- a view knows how to display data, but it knows nothing about what to do with data, whereas a model knows everything about how to work with data, but nothing about how to display it. Models can be complicated, but they don't have to be -- the model for your app might be as simple as an array of strings or dictionaries.</source>
          <target state="translated">MVC中的M是 &quot;模型 &quot;的意思,在MVC范式中,模型类的作用是管理程序的数据。模型与视图相反----视图知道如何显示数据,但它不知道如何处理数据,而模型知道如何处理数据的一切,但对如何显示数据一无所知。模型可以很复杂,但不一定要复杂----你的应用程序的模型可能就像一个字符串或字典的数组一样简单。</target>
        </trans-unit>
        <trans-unit id="de4d0fb8549c6a726ff58a67a687beaccbe06a26" translate="yes" xml:space="preserve">
          <source>The OP didn't mention view controllers but so many of the answers do, that I wanted to chime in with what some of the new features of the LLVM allow to make this easier when wanting to pass data from one view controller to another and then getting some results back.</source>
          <target state="translated">OP没有提到视图控制器,但很多答案都提到了,所以我想告诉你LLVM的一些新功能,当你想把数据从一个视图控制器传到另一个视图控制器,然后再得到一些结果时,LLVM的一些新功能可以让你更容易地完成。</target>
        </trans-unit>
        <trans-unit id="c20529383e6407f57b3ff8211721c8adde0bba28" translate="yes" xml:space="preserve">
          <source>The Receiver</source>
          <target state="translated">接管员</target>
        </trans-unit>
        <trans-unit id="4154dd7ff0aa610daf859664a9f5cdd415da28f3" translate="yes" xml:space="preserve">
          <source>The Segue</source>
          <target state="translated">Segue</target>
        </trans-unit>
        <trans-unit id="ebcf3ab1a842c17f7a5edda449755a002af952e2" translate="yes" xml:space="preserve">
          <source>The Sender</source>
          <target state="translated">发送者</target>
        </trans-unit>
        <trans-unit id="b93bdfec7ee7436d0d31a07d163e319c506ba2dd" translate="yes" xml:space="preserve">
          <source>The code for the First View Controller is</source>
          <target state="translated">第一视图控制器的代码是</target>
        </trans-unit>
        <trans-unit id="16d83b85f70f1ef1d672a4056bde27f526c1f3e4" translate="yes" xml:space="preserve">
          <source>The code for the second view controller is</source>
          <target state="translated">第二个视图控制器的代码是</target>
        </trans-unit>
        <trans-unit id="1427436496c2ed01688bdba0dfac3d0163918947" translate="yes" xml:space="preserve">
          <source>The following is an example based on the video (with a few modifications).</source>
          <target state="translated">下面以视频为例(稍加修改)。</target>
        </trans-unit>
        <trans-unit id="27168310b19624bfd7d1406057bd1581233f19b9" translate="yes" xml:space="preserve">
          <source>The following is an example based on the video. The idea is to pass a string from the text field in the First View Controller to the label in the Second View Controller.</source>
          <target state="translated">下面是一个基于视频的例子。其思路是将第一个视图控制器中的文本字段的字符串传给第二个视图控制器中的标签。</target>
        </trans-unit>
        <trans-unit id="07cf6b0d487458fa179fc57899f7a0abf454ed14" translate="yes" xml:space="preserve">
          <source>The home inventory application would have a single instance of a class which is designed to manage a list of inventory items. The manager would manage a collection of household items. The following is a class definition for the data manager:</source>
          <target state="translated">家庭库存应用程序将有一个类的单一实例,其目的是管理库存物品清单。该管理器将管理一个家庭物品的集合。下面是数据管理器的类定义。</target>
        </trans-unit>
        <trans-unit id="3883ea5969f34a183a8fdf68d24a5c4df97e7e94" translate="yes" xml:space="preserve">
          <source>The idea is imitate Android's intent paradigm, using a global factory to manage which view you are looking at and using &quot;intents&quot; to switch and pass data between views. All the documentation is on the github page, but here are some highlights:</source>
          <target state="translated">这个想法是模仿Android的intent paradigm,使用全局工厂来管理你在看哪个视图,并使用 &quot;intents &quot;在视图之间切换和传递数据。所有的文档都在github页面上,但这里有一些亮点。</target>
        </trans-unit>
        <trans-unit id="f4deb3d745148fadb3c8578e557f0283203b359a" translate="yes" xml:space="preserve">
          <source>The most common way I've seen this done is a &lt;a href=&quot;http://koreyhinton.com/blog/singleton-pattern-in-swift.html&quot;&gt;singleton&lt;/a&gt; instance. So if your singleton object was &lt;code&gt;DataAccess&lt;/code&gt; you could do the following in the viewDidLoad method of UIViewController:</source>
          <target state="translated">我看到的最常见方式是&lt;a href=&quot;http://koreyhinton.com/blog/singleton-pattern-in-swift.html&quot;&gt;单例&lt;/a&gt;实例。 因此，如果您的单例对象是 &lt;code&gt;DataAccess&lt;/code&gt; ，则可以在UIViewController的viewDidLoad方法中执行以下操作：</target>
        </trans-unit>
        <trans-unit id="270c440ea6ee47f9a7fab1f1471c613f9ba1ab40" translate="yes" xml:space="preserve">
          <source>The nice thing about Core Data is that it has inverse relationships. So if you want to just give a NotesViewController the notes object you can because it'll have an inverse relationship to something else like the notebook. If you need data on the notebook in the NotesViewController you can walk back up the object graph by doing the following:</source>
          <target state="translated">Core Data的好处在于它有逆向关系。所以,如果你想只给NotesViewController的Notes对象,你可以这样做,因为它和其他的东西,比如说笔记本,会有一个反关系。如果你需要NotesViewController中的笔记本上的数据,你可以通过下面的操作回走对象图。</target>
        </trans-unit>
        <trans-unit id="014260d3b948862434b9fa2f84c8640f401e09aa" translate="yes" xml:space="preserve">
          <source>The original poster also asked about &lt;strong&gt;Singletons&lt;/strong&gt; and the use of the &lt;strong&gt;AppDelegate&lt;/strong&gt;. These questions need to be answered.</source>
          <target state="translated">原始海报还询问了&lt;strong&gt;Singletons&lt;/strong&gt;以及&lt;strong&gt;AppDelegate&lt;/strong&gt;的用法。 这些问题需要回答。</target>
        </trans-unit>
        <trans-unit id="4051bc4c8e14e8ba896618084a6ea2e97b0c1335" translate="yes" xml:space="preserve">
          <source>The question asks about passing information between view controllers. The specific example given asks about passing information between views, but given the self-stated newness to iOS, the original poster likely meant between viewControllers, not between views (without any involvement from the ViewControllers). It seems that all the answers focus on two view controllers, but what if the app evolves to need to involve more than two view controllers in the information exchange?</source>
          <target state="translated">这个问题问的是关于视图控制器之间的信息传递。给出的具体例子问的是视图之间的信息传递,但考虑到iOS自称的新奇性,最初的发帖者很可能是指viewControllers之间,而不是视图之间(没有ViewControllers的参与)。似乎所有的答案都集中在两个视图控制器上,但如果app发展到需要两个以上的视图控制器参与信息交换怎么办?</target>
        </trans-unit>
        <trans-unit id="63899f87ba40f61b456ad097f7880f169dadb468" translate="yes" xml:space="preserve">
          <source>The role of a controller is to mediate between view and model. Therefore, they need a reference to one or more view objects and one or more model objects. Let's say that your model is an array of dictionaries, with each dictionary representing one row in your table. The root view for your app displays that table, and it might be responsible for loading the array from a file. When the user decides to add a new row to the table, they tap some button and your controller creates a new (mutable) dictionary and adds it to the array. In order to fill in the row, the controller creates a detail view controller and gives it the new dictionary. The detail view controller fills in the dictionary and returns. The dictionary is already part of the model, so nothing else needs to happen.</source>
          <target state="translated">控制器的作用是在视图和模型之间进行调解。因此,它们需要一个或多个视图对象和一个或多个模型对象的引用。假设你的模型是一个由字典组成的数组,每个字典代表你的表中的一行。你的应用程序的根视图显示该表,它可能负责从文件中加载数组。当用户决定向表中添加新的行时,他们点击一些按钮,你的控制器就会创建一个新的(可突变的)字典并将其添加到数组中。为了填充该行,控制器创建了一个细节视图控制器,并将新的字典交给它。详细视图控制器填入字典并返回。字典已经是模型的一部分,所以不需要再发生其他任何事情。</target>
        </trans-unit>
        <trans-unit id="862d75bb0f5e8e1bf177a0884bd45d4099f46cae" translate="yes" xml:space="preserve">
          <source>Then where you want to load the view eg. &lt;code&gt;didSelectRowAtIndex&lt;/code&gt; or some &lt;code&gt;IBAction&lt;/code&gt; you need to set the property in &lt;code&gt;ViewControllerB&lt;/code&gt; before you push it onto nav stack.</source>
          <target state="translated">然后在你想加载视图的地方。 &lt;code&gt;didSelectRowAtIndex&lt;/code&gt; 或某些 &lt;code&gt;IBAction&lt;/code&gt; ，需要先在 &lt;code&gt;ViewControllerB&lt;/code&gt; 中设置该属性，然后再将其推入导航堆栈。</target>
        </trans-unit>
        <trans-unit id="5db5c8fd4b2f27895e7362cba1af3ede532b9753" translate="yes" xml:space="preserve">
          <source>There are addition tools that also help pass along data:</source>
          <target state="translated">还有一些额外的工具,也有助于数据的传递。</target>
        </trans-unit>
        <trans-unit id="31d86b3beff40f0926f74e37f90530611aeeffd6" translate="yes" xml:space="preserve">
          <source>There are four view controllers in the application. It is a tab-based application for managing home inventory. Three view controllers present differently filtered views of the same data:</source>
          <target state="translated">该应用程序有四个视图控制器。它是一个基于标签的应用程序,用于管理家庭库存。三个视图控制器以不同的方式显示了相同数据的过滤视图。</target>
        </trans-unit>
        <trans-unit id="e97a58b0ba4425fd3070b8fbcc8e0520fcec97d9" translate="yes" xml:space="preserve">
          <source>There are many answers to this questions offering many different ways to perform view controller communication that would indeed work, but I don't see anywhere mentioned which one are actually best to use and which ones to avoid.</source>
          <target state="translated">对于这个问题有很多答案,提供了很多不同的方法来执行视图控制器的通信,但我没有看到任何地方提到哪种方法是最好的,哪种方法要避免。</target>
        </trans-unit>
        <trans-unit id="dbd19e78c5369d7ba92070651ccf13b36f340393" translate="yes" xml:space="preserve">
          <source>There are multiple methods for sharing data.</source>
          <target state="translated">数据共享有多种方法。</target>
        </trans-unit>
        <trans-unit id="e8c21a80ff30368c9db68fd252bbe172753c326e" translate="yes" xml:space="preserve">
          <source>There are multiple options for Passing Data between View Controllers.</source>
          <target state="translated">在视图控制器之间传递数据有多个选项。</target>
        </trans-unit>
        <trans-unit id="6b070a9e49cdb6fb5eedc6805c49fc2267e7f279" translate="yes" xml:space="preserve">
          <source>There are three parts.</source>
          <target state="translated">有三个部分。</target>
        </trans-unit>
        <trans-unit id="960919526c1232c2ceccc14249d25e632af94356" translate="yes" xml:space="preserve">
          <source>There are tons and tons of explanations here and around StackOverflow, but if you are a beginner just trying to get something basic to work, try watching this YouTube tutorial (It's what helped me to finally understand how to do it).</source>
          <target state="translated">这里和StackOverflow周围有大量的解释,但如果你是一个初学者,只是想让一些基本的东西能够正常工作,请尝试观看这个YouTube教程(就是它帮助我最终理解了如何做这件事)。</target>
        </trans-unit>
        <trans-unit id="e8afd6f06c1bbab721680e593a168e06c21f9e95" translate="yes" xml:space="preserve">
          <source>There are tons of ways to do this and it's important to pick the right one. Probably one of the biggest architectural decisions lies on how the model code will be shared or accessed throughout the app.</source>
          <target state="translated">这样做的方法有很多,选择一个正确的方法很重要。可能最大的架构决定之一就是如何在整个应用中共享或访问模型代码。</target>
        </trans-unit>
        <trans-unit id="add7b260a0c3a797d43225e8dd73c9d548468567" translate="yes" xml:space="preserve">
          <source>There are two view controllers in the application. There is a ViewControllerA (Data Entry Form), and View Controller B (Product List). The items selected in the product list must match the items displayed in the text box in the data entry form. In this scenario, ViewControllerA and ViewControllerB must communicate directly with each other and no other view controllers.</source>
          <target state="translated">在应用程序中有两个视图控制器。有一个ViewControllerA(数据输入窗体)和ViewControllerB(产品列表)。产品列表中选择的项目必须与数据输入窗体中文本框中显示的项目相匹配。在这种情况下,ViewControllerA和ViewControllerB必须直接通信,不能与其他视图控制器进行通信。</target>
        </trans-unit>
        <trans-unit id="5ad48280e06634ee952854dfb7d646a39384f662" translate="yes" xml:space="preserve">
          <source>There are various ways by which a data can be received to a different class in iOS. For example -</source>
          <target state="translated">在iOS中,有多种方式可以将数据接收到不同的类。比如说 --</target>
        </trans-unit>
        <trans-unit id="6366268fa2a29045a4f2964c6049a44dee20ec43" translate="yes" xml:space="preserve">
          <source>There is some good information in many of the answers given, but none address the question fully.</source>
          <target state="translated">所给出的许多答案中都有一些好的信息,但没有一个能完全解决这个问题。</target>
        </trans-unit>
        <trans-unit id="2244b353f7eacc064ac43be42125be2888874124" translate="yes" xml:space="preserve">
          <source>These solutions, although working in the short term, introduce too many dependencies that will garble the architecture of the app and create more problems later.</source>
          <target state="translated">这些解决方案虽然在短期内可行,但引入了太多的依赖关系,会使APP的架构变得混乱,后期会产生更多的问题。</target>
        </trans-unit>
        <trans-unit id="4feffb40e53daab15d1fd2a31b491d1a986d94e5" translate="yes" xml:space="preserve">
          <source>This example passes data from &lt;strong&gt;Controller B&lt;/strong&gt; to &lt;strong&gt;Controller A&lt;/strong&gt;</source>
          <target state="translated">本示例将数据从&lt;strong&gt;控制器B&lt;/strong&gt;传递到&lt;strong&gt;控制器A&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72942e4d622ebca94f54d92fc991209dbbc62e1b" translate="yes" xml:space="preserve">
          <source>This is a very simple view layout with a segue between them.</source>
          <target state="translated">这是个非常简单的视图布局,中间有一个分隔线。</target>
        </trans-unit>
        <trans-unit id="dc585b46d7fdc70eda1e5bd71fce0fb21a21baaf" translate="yes" xml:space="preserve">
          <source>This is not the way to do it, you should use delegates, I'll assume we have two view controllers ViewController1 and ViewController2 and this check thing is in the first one and when its state changes, you want to do something in ViewController2, to achieve that in the proper way, you should do the below:</source>
          <target state="translated">这样做不是这样的,你应该使用委托代理,我假设我们有两个视图控制器ViewController1和ViewController2,而这个检查的东西是在第一个控制器中,当它的状态发生变化时,你想在ViewController2中做一些事情,要实现这个目的,应该按照下面的方法来做。</target>
        </trans-unit>
        <trans-unit id="8073a2ecfc42ee7250cf1e560c182673934a6f7f" translate="yes" xml:space="preserve">
          <source>This page just sends the value of the variable to the console when it loads.  By this point, our favorite movie should be in that variable.</source>
          <target state="translated">这个页面只是在加载时将变量的值发送到控制台。至此,我们最喜欢的电影应该就在那个变量中。</target>
        </trans-unit>
        <trans-unit id="53aebdd79abe6d5b1bdd1f334b4ef03089ec8441" translate="yes" xml:space="preserve">
          <source>This page takes the initially loaded value and passes it along.</source>
          <target state="translated">这个页面获取初始加载的值,并将其传递下去。</target>
        </trans-unit>
        <trans-unit id="7c7f8bc26f34edac64e4f9e9a10d6758f2fd6803" translate="yes" xml:space="preserve">
          <source>This question seems to be very popular here on stackoverflow so I thought I would try and give a better answer to help out people starting in the world of iOS like me.</source>
          <target state="translated">这个问题在stackoverflow上似乎很受欢迎,所以我想我会尝试着给出一个更好的答案,帮助像我这样初入iOS世界的人。</target>
        </trans-unit>
        <trans-unit id="17b7883c0d9c134005d8b98f4a635cdcdce103d0" translate="yes" xml:space="preserve">
          <source>This second example shows passing a callback block for the second argument.  I like using blocks because it keeps the relevant details close together in the source - the higher level source.</source>
          <target state="translated">第二个例子显示的是为第二个参数传递一个回调块。我喜欢使用区块,因为它可以将相关的细节保持在源头--更高层次的源头中。</target>
        </trans-unit>
        <trans-unit id="5f05e53b88ac8f87becf055c72279b70a06d25c6" translate="yes" xml:space="preserve">
          <source>This will set &lt;code&gt;isSomethingEnabled&lt;/code&gt; in &lt;code&gt;ViewControllerB&lt;/code&gt; to &lt;code&gt;BOOL&lt;/code&gt; value &lt;code&gt;YES&lt;/code&gt;.</source>
          <target state="translated">这会将 &lt;code&gt;ViewControllerB&lt;/code&gt; 中的 &lt;code&gt;isSomethingEnabled&lt;/code&gt; 设置为 &lt;code&gt;BOOL&lt;/code&gt; 值 &lt;code&gt;YES&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="702efc9cba1bbd3afb5e2a9f9ce7d9ec865cbd29" translate="yes" xml:space="preserve">
          <source>Those were  discussed here already.</source>
          <target state="translated">这些在这里已经讨论过了。</target>
        </trans-unit>
        <trans-unit id="83ec681c5928fb675fe4016bcba307422f910286" translate="yes" xml:space="preserve">
          <source>To do this we will make &lt;code&gt;ViewControllerA&lt;/code&gt; a delegate of &lt;code&gt;ViewControllerB&lt;/code&gt;. This allows &lt;code&gt;ViewControllerB&lt;/code&gt; to send a message back to &lt;code&gt;ViewControllerA&lt;/code&gt; enabling us to send data back.</source>
          <target state="translated">为此，我们将使 &lt;code&gt;ViewControllerA&lt;/code&gt; 成为ViewControllerB的委托。 这允许 &lt;code&gt;ViewControllerB&lt;/code&gt; 将消息发送回 &lt;code&gt;ViewControllerA&lt;/code&gt; ,使我们能够将数据发送回。</target>
        </trans-unit>
        <trans-unit id="3555496de4df0b39a8ca1903be2fae52ab2bbaf3" translate="yes" xml:space="preserve">
          <source>To help anyone else looking at this question, who wants a full answer, I'm going to attempt to provide it.</source>
          <target state="translated">为了帮助其他正在看这个问题的人,谁想要一个完整的答案,我将尝试着提供答案。</target>
        </trans-unit>
        <trans-unit id="86f2cf886389b424cfb810b4716cc6f04bb3d86b" translate="yes" xml:space="preserve">
          <source>To pass a &lt;code&gt;BOOL&lt;/code&gt; value from &lt;code&gt;ViewControllerA&lt;/code&gt; to &lt;code&gt;ViewControllerB&lt;/code&gt; we would do the following.</source>
          <target state="translated">要将 &lt;code&gt;BOOL&lt;/code&gt; 值从 &lt;code&gt;ViewControllerA&lt;/code&gt; 传递到 &lt;code&gt;ViewControllerB&lt;/code&gt; ,我们需要执行以下操作。</target>
        </trans-unit>
        <trans-unit id="76a9d2c2e66054b80996174e8affc8b1fb823ba9" translate="yes" xml:space="preserve">
          <source>To pass data back from &lt;code&gt;ViewControllerB&lt;/code&gt; to &lt;code&gt;ViewControllerA&lt;/code&gt; you need to use &lt;em&gt;Protocols and Delegates&lt;/em&gt; or &lt;em&gt;Blocks&lt;/em&gt;, the latter can be used as a loosely coupled mechanism for callbacks.</source>
          <target state="translated">要将数据从 &lt;code&gt;ViewControllerB&lt;/code&gt; 传递回ViewControllerA ，您需要使用&lt;em&gt;Protocols和Delegates&lt;/em&gt;或&lt;em&gt;Blocks&lt;/em&gt; ，后者可用作回调的松散耦合机制。</target>
        </trans-unit>
        <trans-unit id="e3d70b08f9dc80f74d10c82b4cd60670d8719e71" translate="yes" xml:space="preserve">
          <source>To pass data back from the second view controller to the first view controller, you use &lt;a href=&quot;https://stackoverflow.com/a/33549729/3681880&quot;&gt;a protocol and a delegate&lt;/a&gt;. This video is a very clear walk though of that process:</source>
          <target state="translated">要将数据从第二个视图控制器传递回第一个视图控制器，请使用&lt;a href=&quot;https://stackoverflow.com/a/33549729/3681880&quot;&gt;协议和委托&lt;/a&gt; 。 该视频非常清晰地介绍了该过程：</target>
        </trans-unit>
        <trans-unit id="af916557c74c3f51d623fa988c413ad3e34f0d4f" translate="yes" xml:space="preserve">
          <source>To pass data backwards</source>
          <target state="translated">向后传递数据</target>
        </trans-unit>
        <trans-unit id="4441e2165a2cbe180a97d71650d577cbf837d6f0" translate="yes" xml:space="preserve">
          <source>To pass data forward:</source>
          <target state="translated">要把数据传递到前台。</target>
        </trans-unit>
        <trans-unit id="7c739773a6d176365e02604ef2ba8b5fd773295f" translate="yes" xml:space="preserve">
          <source>To pass multiple values you can use the multiple parameters like :-</source>
          <target state="translated">要传递多个值,你可以使用多个参数,如:-</target>
        </trans-unit>
        <trans-unit id="6f53c9cc79789d2d8364b25f78aa09dd33f52a64" translate="yes" xml:space="preserve">
          <source>Understanding the Core Architectural Principles of iOS Development with a Practical Example</source>
          <target state="translated">以实际案例了解iOS开发的核心架构原则</target>
        </trans-unit>
        <trans-unit id="df0a8289feb92488ac5fae24f2db741969a2acff" translate="yes" xml:space="preserve">
          <source>User defaults</source>
          <target state="translated">用户默认值</target>
        </trans-unit>
        <trans-unit id="c2f8f14f958b77389a48a3fc1d929fbaf7455857" translate="yes" xml:space="preserve">
          <source>Using Block</source>
          <target state="translated">使用块</target>
        </trans-unit>
        <trans-unit id="35e87779d93205c9cdc86bc39ef7d0b7dce13230" translate="yes" xml:space="preserve">
          <source>Using Delegate</source>
          <target state="translated">使用委托人</target>
        </trans-unit>
        <trans-unit id="73cc3f60dc8287f62aa63d4644544e391cbe3bb3" translate="yes" xml:space="preserve">
          <source>Using Navigation Controller Push</source>
          <target state="translated">使用导航控制器推送</target>
        </trans-unit>
        <trans-unit id="52e7b3127ded3378ce3725c8ccc384212ac615ad" translate="yes" xml:space="preserve">
          <source>Using Notification Observer</source>
          <target state="translated">使用通知观察员</target>
        </trans-unit>
        <trans-unit id="02bbe182682f0bbed6aeec5deb6f00b94667bbc3" translate="yes" xml:space="preserve">
          <source>Using Segue</source>
          <target state="translated">使用Segue</target>
        </trans-unit>
        <trans-unit id="0d6f7bc3f49a828edf12dd0581aaa92e4ef44e6e" translate="yes" xml:space="preserve">
          <source>ViewControllerA - Luxury Items</source>
          <target state="translated">ViewControllerA-奢侈品项目</target>
        </trans-unit>
        <trans-unit id="e5ffea5e8eb8d723ab0498aa5a4d88e881a60886" translate="yes" xml:space="preserve">
          <source>ViewControllerB - Non-insured Items</source>
          <target state="translated">ViewControllerB-非保险项目</target>
        </trans-unit>
        <trans-unit id="e7a39785336a96e44901846cba211ded9e0abc2e" translate="yes" xml:space="preserve">
          <source>ViewControllerC - Entire Home Inventory</source>
          <target state="translated">ViewControllerC-整个家庭清单</target>
        </trans-unit>
        <trans-unit id="135d305cf4a08db515d94b35f7f6f4250be7f807" translate="yes" xml:space="preserve">
          <source>ViewControllerD - Add New Item Form</source>
          <target state="translated">ViewControllerD-添加新项目表单</target>
        </trans-unit>
        <trans-unit id="81942d9a4347a174680fafdd5ec8b8b344284237" translate="yes" xml:space="preserve">
          <source>We are keeping this simple so no buttons, not actions, we are simply moving data from the sender to the receiver when the application loads and then outputting the transmitted value to the console.</source>
          <target state="translated">我们保持简单,所以没有按钮,没有操作,我们只是在应用程序加载时将数据从发送方移动到接收方,然后将传输的值输出到控制台。</target>
        </trans-unit>
        <trans-unit id="ff03a716d90bbf29f516cac4b83abbaba194bc8c" translate="yes" xml:space="preserve">
          <source>We can understand it using two controllers - &lt;strong&gt;Controller1 and Controller2&lt;/strong&gt;</source>
          <target state="translated">我们可以使用两个控制器来理解它&lt;strong&gt;-Controller1和Controller2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f75d1fd3c3fa39412cf75f97e5bcfb258a2d5a9" translate="yes" xml:space="preserve">
          <source>Well &lt;a href=&quot;https://stackoverflow.com/a/9736559/1371853&quot;&gt;Matt Price's Answer&lt;/a&gt; is perfectly fine for passing data but I
  am going to rewrite it, in Latest Swift version because I believe new
  programmers find it quit challenging due to new Syntax and
  methods/frameworks, as original post is in Objective-C.</source>
          <target state="translated">好吧， &lt;a href=&quot;https://stackoverflow.com/a/9736559/1371853&quot;&gt;马特&amp;middot;普赖斯（Matt Price）的《答案》&lt;/a&gt;非常适合传递数据，但我将在最新的Swift版本中重写它，因为我相信新程序员会由于新的语法和方法/框架而面临挑战，因为原始文章在Objective-C中。</target>
        </trans-unit>
        <trans-unit id="95ed8045cbbb7af3a960ea88cfa49e1488ceac17" translate="yes" xml:space="preserve">
          <source>What would be the correct way of performing this and how would I go about it?</source>
          <target state="translated">正确的执行方式是什么,我将如何去做?</target>
        </trans-unit>
        <trans-unit id="8a4e940579167cf02a3ba46b206936601e18844d" translate="yes" xml:space="preserve">
          <source>When the collection of home inventory items changes, the view controllers need to be made aware of this change. The class definition above does not make it obvious how this will happen. We need to follow the observer pattern. The view controllers must formally observe the sharedManager. There are two ways to observe another object:</source>
          <target state="translated">当家庭库存物品的集合发生变化时,需要让视图控制器知道这个变化。上面的类定义并没有明确说明这个变化会如何发生。我们需要遵循观察者的模式。视图控制器必须正式观察到 sharedManager。有两种方式来观察另一个对象。</target>
        </trans-unit>
        <trans-unit id="d89b94ecc160001694e602dfbde749a28101857f" translate="yes" xml:space="preserve">
          <source>With UINavigators and segues, there are easy ways of passing information to the subservient controller and getting the information back.  ARC makes passing pointers to things derived from NSObjects simple so if you want the subservient controller to add/change/modify some data for you, pass it a pointer to a mutable instance.  Blocks make passing actions easy so if you want the subservient controller to invoke an action on your higher level controller, pass it a block.  You define the block to accept any number of arguments that makes sense to you.  You can also design the API to use multiple blocks if that suits things better.</source>
          <target state="translated">使用UINavigators和segues,有一些简单的方法可以将信息传递给子属控制器并获取回信息。ARC使传递指向NSObjects派生的东西的指针变得简单,所以如果你想让子隶属控制器为你添加changemodify一些数据,只需传递一个指向mutable实例的指针即可。块让传递动作变得简单,所以如果你想让子代理控制器在上一级控制器上调用一个动作,就传递一个块。你可以定义块来接受任何数量的参数。你也可以设计API来使用多个块,如果这样更适合的话。</target>
        </trans-unit>
        <trans-unit id="eb4193cf6b58cbdb5fa018799e8c3e460fd383dc" translate="yes" xml:space="preserve">
          <source>Worked fine and allowed me to pass a string and an array forward and back between my views.</source>
          <target state="translated">效果很好,允许我在视图之间传递一个字符串和一个数组向前和向后的视图。</target>
        </trans-unit>
        <trans-unit id="27deb3303dc171f62381c3af6e857bbf1acf83bb" translate="yes" xml:space="preserve">
          <source>You can also create custom delegates for this.</source>
          <target state="translated">你也可以为此创建自定义委托人。</target>
        </trans-unit>
        <trans-unit id="1a3ff3057c97981bf35a32f3b4007efceb28f6a3" translate="yes" xml:space="preserve">
          <source>You can also directly set the properties of the Controller2 class in the similar way as this:</source>
          <target state="translated">你也可以用类似的方法直接设置Controller2类的属性。</target>
        </trans-unit>
        <trans-unit id="e9e418ef389cb9594cfd0c613d54195e941dba88" translate="yes" xml:space="preserve">
          <source>You can always share data using &lt;code&gt;NSUserDefaults&lt;/code&gt;. Set the value you want to share with respect to a key of your choice and get the value from &lt;code&gt;NSUserDefault&lt;/code&gt; associated to that key in the next view controller.</source>
          <target state="translated">您始终可以使用 &lt;code&gt;NSUserDefaults&lt;/code&gt; 共享数据。 根据您选择的键设置要共享的值，并从下一个视图控制器中与该键关联的 &lt;code&gt;NSUserDefault&lt;/code&gt; 中获取值。</target>
        </trans-unit>
        <trans-unit id="a7d7d2e500cdd3b21928259a0c992d9c6ea65145" translate="yes" xml:space="preserve">
          <source>You can just create a property in &lt;code&gt;viewcontrollerA&lt;/code&gt;. Create an object of &lt;code&gt;viewcontrollerA&lt;/code&gt; in &lt;code&gt;viewcontrollerB&lt;/code&gt; and assign the desired value to that property.</source>
          <target state="translated">您可以只在 &lt;code&gt;viewcontrollerA&lt;/code&gt; 中创建一个属性。 在 &lt;code&gt;viewcontrollerB&lt;/code&gt; 中创建一个 &lt;code&gt;viewcontrollerA&lt;/code&gt; 对象，并将所需的值分配给该属性。</target>
        </trans-unit>
        <trans-unit id="abfb49ee8dd0bcc5f71fa827feb6ceb49bd14bd1" translate="yes" xml:space="preserve">
          <source>You can save data in App delegate to access it across view controllers in your application. All you have to do is create a shared instance of app delegate</source>
          <target state="translated">您可以将数据保存在App delegate中,以便在您的应用程序中跨视图控制器访问。你所要做的就是创建一个共享的App delegate实例</target>
        </trans-unit>
        <trans-unit id="576941d1618435efb4e91b03c919b15afddc8a68" translate="yes" xml:space="preserve">
          <source>You setup all your views in .XIB files and register them in the app delegate, while initializing the factory.</source>
          <target state="translated">在初始化工厂的同时,你在.XIB文件中设置了所有的视图,并在app委托代理中注册它们。</target>
        </trans-unit>
        <trans-unit id="1e2fbc115bc2af08bed183bab4b31314c65a2dc1" translate="yes" xml:space="preserve">
          <source>YouTube tutorial: &lt;a href=&quot;https://www.youtube.com/watch?v=9LHDsSWc680&quot;&gt;iOS Swift Basics Tutorial: Protocols and Delegates&lt;/a&gt; But also read &lt;a href=&quot;http://krakendev.io/blog/weak-and-unowned-references-in-swift&quot;&gt;this post&lt;/a&gt; to make sure you don't get into a strong reference cycle.</source>
          <target state="translated">YouTube教程： &lt;a href=&quot;https://www.youtube.com/watch?v=9LHDsSWc680&quot;&gt;iOS Swift基础知识教程：协议和代理&lt;/a&gt;但也请阅读&lt;a href=&quot;http://krakendev.io/blog/weak-and-unowned-references-in-swift&quot;&gt;这篇文章&lt;/a&gt; ，以确保您不会进入强力的参考周期。</target>
        </trans-unit>
        <trans-unit id="72d5f33455747500ff0e39389f26e2a366965ae1" translate="yes" xml:space="preserve">
          <source>YouTube tutorial: &lt;a href=&quot;https://www.youtube.com/watch?v=Kpwrc1PRDsg&quot;&gt;How to send data through segue (swift)&lt;/a&gt;</source>
          <target state="translated">YouTube教程： &lt;a href=&quot;https://www.youtube.com/watch?v=Kpwrc1PRDsg&quot;&gt;如何通过segue（swift）发送数据&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd92b6a59301aaf7df021b06434d7fd97281c993" translate="yes" xml:space="preserve">
          <source>and &quot;B&quot; view controller should declare callback property, BViewController.h:</source>
          <target state="translated">和 &quot;B &quot;视图控制器应该声明回调属性,BViewController.h。</target>
        </trans-unit>
        <trans-unit id="d22cdc632e153fe14ede39b227947423e9ef48b1" translate="yes" xml:space="preserve">
          <source>and in FirstViewController.h :</source>
          <target state="translated">和FirstViewController.h中。</target>
        </trans-unit>
        <trans-unit id="1303845f47ba68fca8499482aa29a0b1ca63c1c8" translate="yes" xml:space="preserve">
          <source>click on the button and drag over to the Second View Controller.</source>
          <target state="translated">点击按钮并拖动到第二个视图控制器。</target>
        </trans-unit>
        <trans-unit id="edb401d8d776a314f5a6c4744d5c898beb932df9" translate="yes" xml:space="preserve">
          <source>delegates</source>
          <target state="translated">delegates</target>
        </trans-unit>
        <trans-unit id="071cd75033ae8e8688a44265cb1850670988a924" translate="yes" xml:space="preserve">
          <source>do these in ViewControlerOne.h</source>
          <target state="translated">在ViewControlerOne.h中做这些</target>
        </trans-unit>
        <trans-unit id="d2c16f26c821a75d79d3c762d88ff8151b2cef90" translate="yes" xml:space="preserve">
          <source>do these in ViewControlerOne.m</source>
          <target state="translated">在ViewControlerOne.m中做这些</target>
        </trans-unit>
        <trans-unit id="4ab7cc959e41e827a458876138723cac6658ff71" translate="yes" xml:space="preserve">
          <source>do these in ViewControllerTwo.h</source>
          <target state="translated">在ViewControllerTwo.h中进行这些操作。</target>
        </trans-unit>
        <trans-unit id="537d8d6119fe77d8b87bdfec992c7335ce2c30a3" translate="yes" xml:space="preserve">
          <source>do these in ViewControllerTwo.m</source>
          <target state="translated">在ViewControllerTwo.m中进行这些操作。</target>
        </trans-unit>
        <trans-unit id="78f6225c0a29d685123f4713fb8d64650c5d455a" translate="yes" xml:space="preserve">
          <source>drag from the button to the Second View Controller. Set the segue identifier to &lt;code&gt;showSecondViewController&lt;/code&gt;. Also, don't forget to hook up the outlets and actions using the names in the following code.</source>
          <target state="translated">从按钮拖动到Second View Controller。 将segue标识符设置为 &lt;code&gt;showSecondViewController&lt;/code&gt; 。 另外，不要忘记使用以下代码中的名称来连接插座和操作。</target>
        </trans-unit>
        <trans-unit id="e89c71751ece180f696d67c4cc55aff1a2e78a1b" translate="yes" xml:space="preserve">
          <source>expecting that your &lt;code&gt;CustomObject&lt;/code&gt; must have a setter function with it.</source>
          <target state="translated">期望您的 &lt;code&gt;CustomObject&lt;/code&gt; 必须具有一个setter函数。</target>
        </trans-unit>
        <trans-unit id="9a601619d63281ffad7a5e7742ff3e95493c069d" translate="yes" xml:space="preserve">
          <source>if you declare a &lt;code&gt;NSArray object *arrayXYZ&lt;/code&gt; then you can access it in any view controller by &lt;code&gt;appDelegate.arrayXYZ&lt;/code&gt;</source>
          <target state="translated">如果声明了 &lt;code&gt;NSArray object *arrayXYZ&lt;/code&gt; 则可以通过appDelegate.arrayXYZ在任何视图控制器中访问它</target>
        </trans-unit>
        <trans-unit id="782fff5ac840ff68307a9fc122193c5707e4c512" translate="yes" xml:space="preserve">
          <source>if you wants to pass data from ViewControlerOne to ViewControllerTwo try these..</source>
          <target state="translated">如果你想把数据从ViewControlerOne传给ViewControllerTwo,可以试试这些......</target>
        </trans-unit>
        <trans-unit id="be71d332d065bfca5adcf4764b2e5dcf0067a681" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;ViewControllerA&lt;/code&gt; you need to tell it about &lt;code&gt;ViewControllerB&lt;/code&gt; so use an</source>
          <target state="translated">在 &lt;code&gt;ViewControllerA&lt;/code&gt; 中,您需要向其介绍 &lt;code&gt;ViewControllerB&lt;/code&gt; ,因此请使用</target>
        </trans-unit>
        <trans-unit id="65b58b2b8602f0dcd3e15e13e48c2cf1071404f5" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;ViewControllerB.h&lt;/code&gt; create a property for the &lt;code&gt;BOOL&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;ViewControllerB.h&lt;/code&gt; 中为 &lt;code&gt;BOOL&lt;/code&gt; 创建一个属性</target>
        </trans-unit>
        <trans-unit id="99069faddac71d51fb4234f0748c9713172c03f9" translate="yes" xml:space="preserve">
          <source>in ViewController.h</source>
          <target state="translated">在ViewController.h中</target>
        </trans-unit>
        <trans-unit id="131175d1468a88ef378a2491456c5cb0422143b7" translate="yes" xml:space="preserve">
          <source>in ViewController.m</source>
          <target state="translated">在ViewController.m中</target>
        </trans-unit>
        <trans-unit id="be71d06d1de5c0a0fdb2be6af089b062df524e57" translate="yes" xml:space="preserve">
          <source>in implementation file you can implement the function</source>
          <target state="translated">在实现文件中,你可以实现函数</target>
        </trans-unit>
        <trans-unit id="a4325deae2d4ec787216962c095e8ecd5c3486e6" translate="yes" xml:space="preserve">
          <source>next still in the &lt;code&gt;ViewControllerB.h&lt;/code&gt; you need to setup a &lt;code&gt;delegate&lt;/code&gt; property and synthesize in &lt;code&gt;ViewControllerB.m&lt;/code&gt;</source>
          <target state="translated">接下来仍然在 &lt;code&gt;ViewControllerB.h&lt;/code&gt; 中,您需要设置一个 &lt;code&gt;delegate&lt;/code&gt; 属性并在 &lt;code&gt;ViewControllerB.m&lt;/code&gt; 中进行合成</target>
        </trans-unit>
        <trans-unit id="386cbb45fb634a4cc7cc5f0d2dd999b1d4e98035" translate="yes" xml:space="preserve">
          <source>now your basic work is done. go to the place where you want to push the &lt;code&gt;SecondViewController&lt;/code&gt; and do the following stuff</source>
          <target state="translated">现在您的基本工作已经完成。 转到要推送 &lt;code&gt;SecondViewController&lt;/code&gt; 的地方，然后执行以下操作</target>
        </trans-unit>
        <trans-unit id="37f0c63aa5984813b557482775d277cd538c0cde" translate="yes" xml:space="preserve">
          <source>on the buttons click event do this..</source>
          <target state="translated">在按钮上点击事件做这个.....</target>
        </trans-unit>
        <trans-unit id="46a5e3a49371630a136eb9da775d08eb729e16f4" translate="yes" xml:space="preserve">
          <source>override the &lt;code&gt;prepare(for:sender:)&lt;/code&gt; method of &lt;code&gt;UIViewController&lt;/code&gt; when using a storyboard and segues</source>
          <target state="translated">使用情节提要和segues时重写 &lt;code&gt;UIViewController&lt;/code&gt; 的 &lt;code&gt;prepare(for:sender:)&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="4d25f70727ad257203a7cb4eb327698d18e7aa99" translate="yes" xml:space="preserve">
          <source>pass data through an initializer or through properties when performing view controller transitions thtough code</source>
          <target state="translated">在执行视图控制器转换时,通过初始化器或通过属性传递数据,通过代码进行视图控制器转换。</target>
        </trans-unit>
        <trans-unit id="7311cc1f0f20c0620db17343ab40307e824143ea" translate="yes" xml:space="preserve">
          <source>segues</source>
          <target state="translated">segues</target>
        </trans-unit>
        <trans-unit id="7f2d647110dc98a6cf4ef95feec7e141e6b5b5d7" translate="yes" xml:space="preserve">
          <source>setting properties on view controllers directly</source>
          <target state="translated">直接在视图控制器上设置属性</target>
        </trans-unit>
        <trans-unit id="9e37ace74b364d63001657a8ab63e157a0a748b9" translate="yes" xml:space="preserve">
          <source>so we can pass this value in second class using below step</source>
          <target state="translated">所以我们可以用下面的步骤在第二类中传递这个值</target>
        </trans-unit>
        <trans-unit id="1b1760ac8cee45ff111cddcf3355ccffae7b6192" translate="yes" xml:space="preserve">
          <source>then change its definition to</source>
          <target state="translated">然后将其定义改为</target>
        </trans-unit>
        <trans-unit id="e61eda4f8db1e4d3af098df52ca88723ae4b33e4" translate="yes" xml:space="preserve">
          <source>update the app shared state (which you can pass forward between view controllers with either one of the methods above)</source>
          <target state="translated">更新应用程序的共享状态(可以在视图控制器之间通过上述任何一种方法转发</target>
        </trans-unit>
        <trans-unit id="5edd9def88440cf132c20a45c93726634b543a58" translate="yes" xml:space="preserve">
          <source>use an unwind segue</source>
          <target state="translated">开场白</target>
        </trans-unit>
        <trans-unit id="1089f6b4bab9307f50a4d74cae6292d00032982e" translate="yes" xml:space="preserve">
          <source>use delegation</source>
          <target state="translated">委托</target>
        </trans-unit>
        <trans-unit id="4f77b4fd6e2ebd82da33ee94540fe10ea274781f" translate="yes" xml:space="preserve">
          <source>use it in the &lt;code&gt;prepareForSegue&lt;/code&gt; method in the VC1</source>
          <target state="translated">在VC1的 &lt;code&gt;prepareForSegue&lt;/code&gt; 方法中使用它</target>
        </trans-unit>
        <trans-unit id="3397791b6f7f7ea840ba49d831f7e5f45f3ad769" translate="yes" xml:space="preserve">
          <source>var authorizationCompletionBlock:((Bool)-&amp;gt;())? = {_ in}</source>
          <target state="translated">varauthorizationCompletionBlock：（（（Bool）-&amp;gt;（）））？ = {_ in}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
