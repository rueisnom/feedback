<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/5240789">
    <body>
      <group id="5240789">
        <trans-unit id="f933529d12a63f827169f14187c497d37d908102" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scanf&lt;/code&gt; will then read the next char (that is, the newline) but not assign it to any pointer.</source>
          <target state="translated">그런 다음 &lt;code&gt;scanf&lt;/code&gt; 는 다음 문자 (줄 바꿈)를 읽지 만 포인터에 할당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc7c3bf8e123d90d4454e06d240b02290f468268" translate="yes" xml:space="preserve">
          <source>Another option (that I got from &lt;a href=&quot;https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1352443831&amp;amp;id=1043284392&quot;&gt;here&lt;/a&gt;) is to read and discard the newline by using the &lt;em&gt;assignment-supression option&lt;/em&gt;. To do that, we just put a format to read a character with an asterisk between &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">또 다른 옵션 ( &lt;a href=&quot;https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1352443831&amp;amp;id=1043284392&quot;&gt;여기서&lt;/a&gt; 얻은 것 )은 &lt;em&gt;assignment-supression 옵션&lt;/em&gt; 을 사용하여 줄 바꿈을 읽고 버리는 &lt;em&gt;것&lt;/em&gt; 입니다. 이를 위해 &lt;code&gt;%&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 사이에 별표가있는 문자를 읽는 형식을 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="046b39dee7fbf35f062765618aa86395d876dcbb" translate="yes" xml:space="preserve">
          <source>As I read in the C book, the author says that &lt;code&gt;scanf()&lt;/code&gt; left a new line character in the buffer, therefore, the program does not stop at line 4 for user to enter the data, rather it stores the new line character in c2 and moves to line 5.</source>
          <target state="translated">C 책에서 읽은 것처럼 저자는 &lt;code&gt;scanf()&lt;/code&gt; 가 버퍼에 줄 바꿈 문자를 남겼으므로 프로그램은 사용자가 데이터를 입력하기 위해 줄 4에서 멈추지 않고 오히려 줄 바꿈 문자를 c2에 저장한다고 말합니다. 라인 5로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="825625d111b9b10f7717d1b26fd8039db163f2ee" translate="yes" xml:space="preserve">
          <source>However, does this only happen with &lt;code&gt;char&lt;/code&gt; data types? Because I did not see this problem with &lt;code&gt;int&lt;/code&gt; data types as in line 1, 2, 3. Is it right?</source>
          <target state="translated">그러나 이것은 &lt;code&gt;char&lt;/code&gt; 데이터 유형에서만 발생합니까? 1, 2, 3 줄과 같이 &lt;code&gt;int&lt;/code&gt; 데이터 형식 에서이 문제를 보지 못했기 때문에 맞습니까?</target>
        </trans-unit>
        <trans-unit id="5f974fb8b827999733ad10a4b6e99eac950a4dad" translate="yes" xml:space="preserve">
          <source>I have the following program:</source>
          <target state="translated">다음과 같은 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c9fee72c5f2cfd8616dd20d0d6e90683f071bfd" translate="yes" xml:space="preserve">
          <source>In the end, however, I would second &lt;a href=&quot;https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1352443831&amp;amp;id=1043284392&quot;&gt;the FAQ's last option&lt;/a&gt;:</source>
          <target state="translated">그러나 결국 &lt;a href=&quot;https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1352443831&amp;amp;id=1043284392&quot;&gt;FAQ의 마지막 옵션&lt;/a&gt; 은 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="761e1e531d5379ce8ff1bd64d090ba4983f59ccc" translate="yes" xml:space="preserve">
          <source>Is that right?</source>
          <target state="translated">맞습니까?</target>
        </trans-unit>
        <trans-unit id="4f94e199059b049ac1280e4330baba0b53592ad0" translate="yes" xml:space="preserve">
          <source>Note that non-whitespace &quot;directives&quot; (to use &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html&quot;&gt;POSIX scanf terminology&lt;/a&gt;) other than conversions, like the literal text in &lt;code&gt;scanf(&quot;order = %d&quot;, &amp;amp;order);&lt;/code&gt; doesn't skip whitespace either.  The literal &lt;code&gt;order&lt;/code&gt; has to match the next character to be read.</source>
          <target state="translated">&lt;code&gt;scanf(&quot;order = %d&quot;, &amp;amp;order);&lt;/code&gt; 의 리터럴 텍스트와 같이 변환 이외의 공백이 아닌 &quot;지시문&quot;( &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html&quot;&gt;POSIX scanf 용어&lt;/a&gt; 사용 ); 공백도 건너 뛰지 않습니다. 문자 &lt;code&gt;order&lt;/code&gt; 는 읽을 다음 문자와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="724e7966571c209b3e01084023429cabcc8f5ad9" translate="yes" xml:space="preserve">
          <source>Note that this still doesn't consume any trailing whitespace left in the input stream, not even to the end of a line, so beware of that if also using &lt;a href=&quot;http://en.cppreference.com/w/c/io/getchar&quot;&gt;&lt;code&gt;getchar()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt;&lt;code&gt;fgets()&lt;/code&gt;&lt;/a&gt; on the same input stream.  We're just getting scanf to skip over whitespace &lt;em&gt;before&lt;/em&gt; conversions, like it does for &lt;code&gt;%d&lt;/code&gt; and other non-character conversions.</source>
          <target state="translated">이것은 여전히 ​​줄 끝까지 입력 스트림에 남아있는 후행 공백을 소비하지 않으므로 동일한 입력 스트림에서 &lt;a href=&quot;http://en.cppreference.com/w/c/io/getchar&quot;&gt; &lt;code&gt;getchar()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt; &lt;code&gt;fgets()&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우에도주의하십시오. &lt;code&gt;%d&lt;/code&gt; 및 기타 문자 이외의 변환과 마찬가지로 변환 &lt;em&gt;전에&lt;/em&gt; 공백을 건너 뛰기 위해 scanf를 받고 있습니다.</target>
        </trans-unit>
        <trans-unit id="66a0938676e71d234343b452186d8c4dabcb624d" translate="yes" xml:space="preserve">
          <source>Or, depending on your requirements, you could also forget about scanf()/getchar(), use fgets() to get a line of text from the user and parse it yourself.</source>
          <target state="translated">또는 요구 사항에 따라 scanf () / getchar ()를 잊고 fgets ()를 사용하여 사용자로부터 텍스트 줄을 가져 와서 직접 구문 분석 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d7f898e9536b25b8fae927214a88358936787a1" translate="yes" xml:space="preserve">
          <source>So you probably want &lt;code&gt;&quot; order = %d&quot;&lt;/code&gt; there if you want to skip a newline from the previous line but still require a literal match on a fixed string, &lt;a href=&quot;https://stackoverflow.com/questions/49923312/scanf-run-twice-instead-of-one-time-at-assembly-x86-64&quot;&gt;like this question&lt;/a&gt;.</source>
          <target state="translated">따라서 이전 줄에서 줄 바꿈을 건너 뛰고이 &lt;a href=&quot;https://stackoverflow.com/questions/49923312/scanf-run-twice-instead-of-one-time-at-assembly-x86-64&quot;&gt;질문과 같은&lt;/a&gt; 고정 문자열에서 리터럴 일치가 필요한 경우 &lt;code&gt;&quot; order = %d&quot;&lt;/code&gt; 가 필요할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c00448b2e4fd712712cda090d3c14cda6d3142b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html&quot;&gt;&lt;code&gt;scanf()&lt;/code&gt;&lt;/a&gt; function skips leading whitespace automatically before trying to parse conversions other than characters.  The character formats (primarily &lt;code&gt;%c&lt;/code&gt;; also scan sets &lt;code&gt;%[&amp;hellip;]&lt;/code&gt; &amp;mdash; and &lt;code&gt;%n&lt;/code&gt;) are the exception; they don't skip whitespace.</source>
          <target state="translated">&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html&quot;&gt; &lt;code&gt;scanf()&lt;/code&gt; &lt;/a&gt; 함수는 문자 이외의 변환을 구문 분석하기 전에 선행 공백을 자동으로 건너 뜁니다. 문자 형식 (주로 &lt;code&gt;%c&lt;/code&gt; ; 스캔 세트 &lt;code&gt;%[&amp;hellip;]&lt;/code&gt; &amp;mdash; 및 &lt;code&gt;%n&lt;/code&gt; )은 예외입니다. 공백을 건너 뛰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="646a629b1c7bd53cfa549e3b4607aecb21fd6ab0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&quot; %c&quot;&lt;/code&gt; with a leading blank to skip optional white space.  Do not use a trailing blank in a &lt;code&gt;scanf()&lt;/code&gt; format string.</source>
          <target state="translated">선택적인 공백을 건너 뛰려면 선행 공백과 함께 &lt;code&gt;&quot; %c&quot;&lt;/code&gt; 를 사용하십시오. &lt;code&gt;scanf()&lt;/code&gt; 형식 문자열에서 후행 공백을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9b2af5c9e78f20f0c0b651f3c3b40d58f355fbbb" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;getchar()&lt;/code&gt; before calling second &lt;code&gt;scanf()&lt;/code&gt;.</source>
          <target state="translated">두 번째 &lt;code&gt;scanf()&lt;/code&gt; 호출하기 전에 &lt;code&gt;getchar()&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5bc4388c0d38b4213c63476101d6b199eab0366d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;scanf(&quot; %c&quot;, &amp;amp;c2);&lt;/code&gt;. This will solve your problem.</source>
          <target state="translated">&lt;code&gt;scanf(&quot; %c&quot;, &amp;amp;c2);&lt;/code&gt; . 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="a657963f850559de4877656311a7b69804613b50" translate="yes" xml:space="preserve">
          <source>scanf() leaves the new line char in the buffer</source>
          <target state="translated">scanf ()는 버퍼에 줄 바꿈 문자를 남깁니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
