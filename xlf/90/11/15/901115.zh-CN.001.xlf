<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/901115">
    <body>
      <group id="901115">
        <trans-unit id="e0d02f69bfab290bf1f501ff1a5082d271e75385" translate="yes" xml:space="preserve">
          <source>(URI.js also &quot;fixes&quot; bad querystrings like &lt;code&gt;?&amp;amp;foo&amp;amp;&amp;amp;bar=baz&amp;amp;&lt;/code&gt; to &lt;code&gt;?foo&amp;amp;bar=baz&lt;/code&gt;)</source>
          <target state="translated">（URI.js还&amp;ldquo;修复&amp;rdquo;了错误的查询字符串，例如 &lt;code&gt;?&amp;amp;foo&amp;amp;&amp;amp;bar=baz&amp;amp;&lt;/code&gt; 到 &lt;code&gt;?foo&amp;amp;bar=baz&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c33bf3988dc284bca985201a791bf293ac167541" translate="yes" xml:space="preserve">
          <source>...jQuery BBQ provides a full &lt;code&gt;.deparam()&lt;/code&gt; method, along with both hash state management, and fragment / query string parse and merge utility methods.</source>
          <target state="translated">... jQuery BBQ提供了完整的 &lt;code&gt;.deparam()&lt;/code&gt; 方法，以及哈希状态管理以及片段/查询字符串解析和合并实用程序方法。</target>
        </trans-unit>
        <trans-unit id="79c0e20f0a22c1356012c1d3381c34dd2e441471" translate="yes" xml:space="preserve">
          <source>...making it into an object that looks like...</source>
          <target state="translated">...把它变成一个看起来像.....</target>
        </trans-unit>
        <trans-unit id="11f6482ce9f388b216bfc419e445a6c77c8d7dbd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsperf.com/querystring-with-javascript&quot;&gt;Performance test (split method against regex method)&lt;/a&gt; (&lt;a href=&quot;http://jsperf.com/&quot;&gt;jsPerf&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://jsperf.com/querystring-with-javascript&quot;&gt;性能测试（针对正则表达式的拆分方法）&lt;/a&gt; （ &lt;a href=&quot;http://jsperf.com/&quot;&gt;jsPerf&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="47be74a6372dd1484c8ce49a9b412e5d8f655945" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;IMPORTANT!&lt;/b&gt; The parameter for that function in the last line is different. It's just an example of how one can pass an arbitrary URL to it. You can use last line from Bruno's answer to parse the current URL.</source>
          <target state="translated">&lt;b&gt;重要！&lt;/b&gt; 最后一行中该函数的参数不同。 这只是一个如何向其传递任意URL的示例。 您可以使用Bruno答案的最后一行来解析当前URL。</target>
        </trans-unit>
        <trans-unit id="d139bec92ab703c3930b72ed0bcca93c86a4a024" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/q/476436/985454&quot;&gt;&quot;null-coalescing&quot;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-Circuit_Evaluation&quot;&gt;short-circuit evaluation&lt;/a&gt;&lt;br/&gt;
ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Destructuring assignments&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;Arrow functions&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;Template strings&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/q/476436/985454&quot;&gt;&amp;ldquo; null-coalescing&amp;rdquo;&lt;/a&gt; ， &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-Circuit_Evaluation&quot;&gt;短路评估&lt;/a&gt;&lt;/em&gt; &lt;em&gt;&lt;br/&gt;&lt;/em&gt; &lt;em&gt;ES6解构&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;分配&lt;/a&gt; ， &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;箭头函数&lt;/a&gt; ， &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;模板字符串&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a25782e4816475a2a0901c6ec5632570b52f9639" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Or&lt;/em&gt; if you have control of the querystring and can guarantee that a value you are trying to get will never contain any URL encoded
  characters (having these in a value would be a bad idea) - you can use
  the following slightly more simplified and readable version of the 1st option:</source>
          <target state="translated">&lt;em&gt;或者，&lt;/em&gt;如果您可以控制查询字符串，并且可以保证您尝试获取的值永远不会包含任何URL编码的字符（将它们包含在值中将是一个坏主意）-您可以使用以下稍微简化且易读的版本第一个选项：</target>
        </trans-unit>
        <trans-unit id="fcdbaa597bdf669b6d3a9aadfd0cd07941c33e3f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To access different parts of a URL use &lt;code&gt;location.(search|hash)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;要访问URL的不同部分，请使用 &lt;code&gt;location.(search|hash)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f83b351211abc22c16148d75edebd637f29484a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tl;dr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tl;dr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd30aeb848f043e7bc0780ef8335c1edf1e6569c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;*!!!&lt;/strong&gt; Please note, that &lt;code&gt;decodeURIComponent(undefined)&lt;/code&gt; returns string &lt;code&gt;&quot;undefined&quot;&lt;/code&gt;. The solution lies in a simple usage of &lt;a href=&quot;https://stackoverflow.com/a/476445/985454&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, which ensures that &lt;code&gt;decodeURIComponent()&lt;/code&gt; is not called on undefined values. &lt;em&gt;(See the &quot;complete solution&quot; at the top.)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;* !!!&lt;/strong&gt; 请注意， &lt;code&gt;decodeURIComponent(undefined)&lt;/code&gt; 返回字符串 &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; 。 解决方案在于&lt;a href=&quot;https://stackoverflow.com/a/476445/985454&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt;的简单用法，它确保未对未定义的值调用 &lt;code&gt;decodeURIComponent()&lt;/code&gt; 。 &lt;em&gt;（请参见顶部的&amp;ldquo;完整解决方案&amp;rdquo;。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82c314ef57c4ae062d211ee17efada8e14fe8e6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; You can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL&quot;&gt;URL&lt;/a&gt; interface, its quite widely adopted in almost all the new browser and if the code is going to run on an old browser you can use a &lt;a href=&quot;https://github.com/lifaon74/url-polyfill&quot;&gt;polyfill like this one&lt;/a&gt;. Here's a code example on how to use URL interface to get query parameters (aka search parameters)</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;您可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL&quot;&gt;URL&lt;/a&gt;界面，它几乎在所有新浏览器中都被广泛采用，并且如果代码要在旧的浏览器上运行，则可以使用&lt;a href=&quot;https://github.com/lifaon74/url-polyfill&quot;&gt;像这样&lt;/a&gt;的polyfill 。 这是一个有关如何使用URL界面获取查询参数（又称为搜索参数）的代码示例</target>
        </trans-unit>
        <trans-unit id="37368c978ce40b2560ff00ceca4687bf96ce3bd6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Original&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecbafbd59fd4570e44f14117a16a5c61451c4624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Regex method&lt;/strong&gt;: 13,891 &amp;plusmn;0.85% | 90% slower</source>
          <target state="translated">&lt;strong&gt;正则表达式方法&lt;/strong&gt; ：13,891&amp;plusmn;0.85％| 慢90％</target>
        </trans-unit>
        <trans-unit id="8c4b9a8b2c4a548fd785efb0cd2f4af2a0428753" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Split method&lt;/strong&gt;: 144,780 &amp;plusmn;2.17% fastest</source>
          <target state="translated">&lt;strong&gt;拆分方法&lt;/strong&gt; ：最快144,780&amp;plusmn;2.17％</target>
        </trans-unit>
        <trans-unit id="ded3fa0b81b76721beedb6dd8bacd027baf396b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Testing in Firefox 4.0 x86 on Windows Server 2008 R2 / 7 x64&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在Windows Server 2008 R2 / 7 x64上的Firefox 4.0 x86中进行测试&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ce2743b8a6431574045a5cfe76049b2e91dcb70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;代码：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86ebb9137b90947e20c42d0c415e605c6404bfd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update: Sep-2018&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更新：2018年9月&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="010fef2051f010223d5ab89db7012657390a7a99" translate="yes" xml:space="preserve">
          <source>?test=Hello&amp;amp;person=neek&amp;amp;person[]=jeff&amp;amp;person[]=jim&amp;amp;person[extra]=john&amp;amp;test3&amp;amp;nocache=1398914891264</source>
          <target state="translated">?test=Hello&amp;amp;person=neek&amp;amp;person[]=jeff&amp;amp;person[]=jim&amp;amp;person[extra]=john&amp;amp;test3&amp;amp;nocache=1398914891264</target>
        </trans-unit>
        <trans-unit id="534cddb6555e003cb4cf2ec54774ae6f0433e539" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://trac.webkit.org/browser/trunk/Source/WebCore/platform/URLParser.cpp&quot;&gt;reference implementation&lt;/a&gt; and a &lt;a href=&quot;https://googlechrome.github.io/samples/urlsearchparams/&quot;&gt;sample page&lt;/a&gt; are available for auditing and testing.</source>
          <target state="translated">&lt;a href=&quot;https://trac.webkit.org/browser/trunk/Source/WebCore/platform/URLParser.cpp&quot;&gt;参考实现&lt;/a&gt;和&lt;a href=&quot;https://googlechrome.github.io/samples/urlsearchparams/&quot;&gt;示例页面&lt;/a&gt;可用于审核和测试。</target>
        </trans-unit>
        <trans-unit id="fb75f43caf20568ea5a54475c53588e0025cecd3" translate="yes" xml:space="preserve">
          <source>A URL like &lt;code&gt;this.htm?hello=world&amp;amp;foo=bar&lt;/code&gt; will create:</source>
          <target state="translated">像 &lt;code&gt;this.htm?hello=world&amp;amp;foo=bar&lt;/code&gt; 这样的URL将创建：</target>
        </trans-unit>
        <trans-unit id="8f5555c4a56365aa3ceeaecad41c3ccc587f60d8" translate="yes" xml:space="preserve">
          <source>A new capability would be to retrieve repeated params as following &lt;code&gt;myparam=1&amp;amp;myparam=2&lt;/code&gt;. There is not a &lt;em&gt;specification&lt;/em&gt;, however, most of the current approaches follow the generation of an array.</source>
          <target state="translated">一种新功能将是按照 &lt;code&gt;myparam=1&amp;amp;myparam=2&lt;/code&gt; 检索重复的参数。 没有&lt;em&gt;规范&lt;/em&gt; ，但是，大多数当前方法遵循数组的生成。</target>
        </trans-unit>
        <trans-unit id="ec6d389db41af6d8c6899bbe593461bce3cc1e03" translate="yes" xml:space="preserve">
          <source>A quick, &lt;strong&gt;complete solution&lt;/strong&gt;, which handles &lt;strong&gt;multivalued keys&lt;/strong&gt; and &lt;strong&gt;encoded characters&lt;/strong&gt;.</source>
          <target state="translated">一种快速， &lt;strong&gt;完整的解决方案&lt;/strong&gt; ，可以处理&lt;strong&gt;多值键&lt;/strong&gt;和&lt;strong&gt;编码字符&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae3d1e955993bf7fcabbb2a74e77168edf22f3bb" translate="yes" xml:space="preserve">
          <source>Access values by &lt;code&gt;qd.key[index]&lt;/code&gt; or &lt;code&gt;qd[key][index]&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;qd.key[index]&lt;/code&gt; 或 &lt;code&gt;qd[key][index]&lt;/code&gt; 访问值</target>
        </trans-unit>
        <trans-unit id="800134e33649d3e10c5322da5156cfc33ce3a91e" translate="yes" xml:space="preserve">
          <source>Also, as pointed out in the comments, &lt;code&gt;;&lt;/code&gt; is a legal delimiter for &lt;code&gt;key=value&lt;/code&gt; pairs.  It would require a more complicated regex to handle &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, which I think is unnecessary because it's rare that &lt;code&gt;;&lt;/code&gt; is used and I would say even more unlikely that both would be used.  If you need to support &lt;code&gt;;&lt;/code&gt; instead of &lt;code&gt;&amp;amp;&lt;/code&gt;, just swap them in the regex.</source>
          <target state="translated">另外，正如评论中指出的那样 &lt;code&gt;;&lt;/code&gt; 是 &lt;code&gt;key=value&lt;/code&gt; 对的合法分隔符。 这将需要更复杂的正则表达式来处理 &lt;code&gt;;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;&lt;/code&gt; ，我认为这是不必要的，因为这种情况很少见 &lt;code&gt;;&lt;/code&gt; 使用，我会说两者都不太可能使用。 如果需要支持 &lt;code&gt;;&lt;/code&gt; 而不是 &lt;code&gt;&amp;amp;&lt;/code&gt; ，只需在正则表达式中交换它们即可。</target>
        </trans-unit>
        <trans-unit id="9b1a5e46c3df8cde62fe9534b0b22f5e679a96f9" translate="yes" xml:space="preserve">
          <source>And this is how you can use this function assuming the URL is</source>
          <target state="translated">假设URL是这样的,你可以这样使用这个函数,假设URL是</target>
        </trans-unit>
        <trans-unit id="e4f0914b742d0ac7630df445c3d78b67b44b0c97" translate="yes" xml:space="preserve">
          <source>As you can see above, this version handles some measure of &quot;malformed&quot; arrays, i.e. - &lt;code&gt;person=neek&amp;amp;person[]=jeff&amp;amp;person[]=jim&lt;/code&gt; or &lt;code&gt;person=neek&amp;amp;person=jeff&amp;amp;person=jim&lt;/code&gt; as the key is identifiable and valid (at least in dotNet's &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xsc9a449.aspx&quot;&gt;NameValueCollection.Add&lt;/a&gt;):</source>
          <target state="translated">如您在上方所见，此版本处理了一些&amp;ldquo;格式错误&amp;rdquo;的数组，即 &lt;code&gt;person=neek&amp;amp;person[]=jeff&amp;amp;person[]=jim&lt;/code&gt; 或 &lt;code&gt;person=neek&amp;amp;person=jeff&amp;amp;person=jim&lt;/code&gt; ,因为密钥是可识别且有效的（至少在dotNet的&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xsc9a449.aspx&quot;&gt;NameValueCollection.Add&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="dec8ec77346ed7b7f3ff2bbef25f1a0c8db47ed4" translate="yes" xml:space="preserve">
          <source>Because of the new HTML History API and specifically &lt;code&gt;history.pushState()&lt;/code&gt; and &lt;code&gt;history.replaceState()&lt;/code&gt;, the URL can change which will invalidate the cache of parameters and their values.</source>
          <target state="translated">由于使用了新的HTML History API，特别是 &lt;code&gt;history.pushState()&lt;/code&gt; 和 &lt;code&gt;history.replaceState()&lt;/code&gt; ，因此URL可以更改，这将使参数及其值的缓存无效。</target>
        </trans-unit>
        <trans-unit id="c7601f69db91e2da68e2759e88ab4423df8b842b" translate="yes" xml:space="preserve">
          <source>Best of both worlds!</source>
          <target state="translated">两者都是世界上最好的!</target>
        </trans-unit>
        <trans-unit id="f6ef567d34982fb629b48eb155de70a91ca42847" translate="yes" xml:space="preserve">
          <source>Call it from anywhere in the JavaScript code:</source>
          <target state="translated">从JavaScript代码中的任何地方调用它。</target>
        </trans-unit>
        <trans-unit id="127bd0758aa89190daf4785aa8fd97c348d7c230" translate="yes" xml:space="preserve">
          <source>Chrome Announcement and details</source>
          <target state="translated">Chrome浏览器的公告及详情</target>
        </trans-unit>
        <trans-unit id="d620b778592cbeb4a5b4ac786c6c65d353236122" translate="yes" xml:space="preserve">
          <source>Code golf:</source>
          <target state="translated">代码高尔夫。</target>
        </trans-unit>
        <trans-unit id="9432d6874c07d2479fb03ed9dbee612f9529e8fd" translate="yes" xml:space="preserve">
          <source>Display it!</source>
          <target state="translated">显示它!</target>
        </trans-unit>
        <trans-unit id="e3af59b16940b2e81235ebbcb74c7f1a75b7e5e5" translate="yes" xml:space="preserve">
          <source>ES2015 (ES6)</source>
          <target state="translated">ES2015(ES6)</target>
        </trans-unit>
        <trans-unit id="7dd6c14524660a8e5e3f2fd6bd31287be3272a9e" translate="yes" xml:space="preserve">
          <source>Easiest (dummy) solution</source>
          <target state="translated">最简单的(假人)解决方案</target>
        </trans-unit>
        <trans-unit id="c57e24e3995bb2633119f0608031092da0dd2d9f" translate="yes" xml:space="preserve">
          <source>Edit: Adding Deparam Example:</source>
          <target state="translated">编辑:添加Deparam示例。</target>
        </trans-unit>
        <trans-unit id="18c8be8be42a7df2abdc4caecc8e7f222e85b9a8" translate="yes" xml:space="preserve">
          <source>Encoded characters?</source>
          <target state="translated">编码字符?</target>
        </trans-unit>
        <trans-unit id="ebccf9f9cb0a1762288f48f17418ac002bad85c9" translate="yes" xml:space="preserve">
          <source>Enjoy.</source>
          <target state="translated">Enjoy.</target>
        </trans-unit>
        <trans-unit id="d926fe0cd38e03484b26bb76cf16c4faacb42966" translate="yes" xml:space="preserve">
          <source>Example querystring:</source>
          <target state="translated">例子querystring。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="42fdd8556452808645f749a3a8ccd315a6af2bb6" translate="yes" xml:space="preserve">
          <source>Firefox 44+, Opera 36+, Edge 17+, Safari 10.3+ and Chrome 49+ support the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams&quot;&gt;URLSearchParams&lt;/a&gt; API:</source>
          <target state="translated">Firefox 44 +，Opera 36 +，Edge 17 +，Safari 10.3+和Chrome 49+支持URLSearchParams API：</target>
        </trans-unit>
        <trans-unit id="d9b7c07a3c5cfdfa9c5d333af605afc4ff1a78c7" translate="yes" xml:space="preserve">
          <source>Firefox Announcement and details</source>
          <target state="translated">Firefox公告及详情</target>
        </trans-unit>
        <trans-unit id="673187c6b35ad0483874d48860fc835cb81a3f10" translate="yes" xml:space="preserve">
          <source>For a URL like &lt;code&gt;http://domain.com?param1=val1&amp;amp;param2=val2&lt;/code&gt; you can get their value later in your code as &lt;code&gt;search.param1&lt;/code&gt; and &lt;code&gt;search.param2&lt;/code&gt;.</source>
          <target state="translated">对于像 &lt;code&gt;http://domain.com?param1=val1&amp;amp;param2=val2&lt;/code&gt; 之类的URL，您可以稍后在代码 &lt;code&gt;search.param1&lt;/code&gt; 它们的值作为search.param1和 &lt;code&gt;search.param2&lt;/code&gt; 获得 。</target>
        </trans-unit>
        <trans-unit id="c5726643ceb6991d5c7b82f8641d91a3dc21160e" translate="yes" xml:space="preserve">
          <source>For more information on improvement see: &lt;a href=&quot;http://james.padolsey.com/javascript/bujs-1-getparameterbyname/&quot;&gt;http://james.padolsey.com/javascript/bujs-1-getparameterbyname/&lt;/a&gt;</source>
          <target state="translated">有关改进的更多信息，请参见： &lt;a href=&quot;http://james.padolsey.com/javascript/bujs-1-getparameterbyname/&quot;&gt;http&lt;/a&gt; : //james.padolsey.com/javascript/bujs-1-getparameterbyname/</target>
        </trans-unit>
        <trans-unit id="4d35a0dbe25664b0c8564dcb259681703f89b719" translate="yes" xml:space="preserve">
          <source>For the query string &lt;code&gt;x=5&amp;amp;y&amp;amp;z=hello&amp;amp;x=6&lt;/code&gt; this returns the object:</source>
          <target state="translated">对于查询字符串 &lt;code&gt;x=5&amp;amp;y&amp;amp;z=hello&amp;amp;x=6&lt;/code&gt; ,这将返回对象：</target>
        </trans-unit>
        <trans-unit id="f99deb5ac65fb0c436f3dcae122f670bf5d9ffad" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/search#Get_the_value_of_a_single_search_param&quot;&gt;the MDN&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/search#Get_the_value_of_a_single_search_param&quot;&gt;MDN&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="45672054ed2b5911b360ccdb67dac8cdb4183687" translate="yes" xml:space="preserve">
          <source>From comments</source>
          <target state="translated">来自评论</target>
        </trans-unit>
        <trans-unit id="4d88cc2da8e2cd7a42dedeacdd26424dc86ef5aa" translate="yes" xml:space="preserve">
          <source>Further reading: &lt;a href=&quot;http://nodejs.org/api/url.html&quot;&gt;&lt;strong&gt;URL Node.js v0.12.2 Manual &amp;amp; Documentation&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">进一步阅读： &lt;a href=&quot;http://nodejs.org/api/url.html&quot;&gt;&lt;strong&gt;URL Node.js v0.12.2手册和文档&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d2adeea390c506ae0e2b890266a2fe434806983" translate="yes" xml:space="preserve">
          <source>Google method</source>
          <target state="translated">谷歌方法</target>
        </trans-unit>
        <trans-unit id="9f297fcf463a0430a0271e161a011ae8210e5605" translate="yes" xml:space="preserve">
          <source>Handles &lt;b&gt;empty keys&lt;/b&gt; correctly.</source>
          <target state="translated">正确处理&lt;b&gt;空键&lt;/b&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5551916943663f301e56840062b0bb752e1e600" translate="yes" xml:space="preserve">
          <source>Here is a fast way to get an object similar to the PHP &lt;a href=&quot;http://php.net/manual/en/reserved.variables.get.php&quot;&gt;$_GET&lt;/a&gt; array:</source>
          <target state="translated">这是获取类似于PHP &lt;a href=&quot;http://php.net/manual/en/reserved.variables.get.php&quot;&gt;$ _GET&lt;/a&gt;数组的对象的快速方法：</target>
        </trans-unit>
        <trans-unit id="122778d5e10d1916b1623e116cd8efae6700365a" translate="yes" xml:space="preserve">
          <source>Here's an extended version of Andy E's linked &quot;Handle array-style query strings&quot;-version. Fixed a bug (&lt;code&gt;?key=1&amp;amp;key[]=2&amp;amp;key[]=3&lt;/code&gt;; &lt;code&gt;1&lt;/code&gt; is lost and replaced with &lt;code&gt;[2,3]&lt;/code&gt;), made a few minor performance improvements (re-decoding of values, recalculating &quot;[&quot; position, etc.) and added a number of improvements (functionalized, support for &lt;code&gt;?key=1&amp;amp;key=2&lt;/code&gt;, support for &lt;code&gt;;&lt;/code&gt; delimiters). I left the variables annoyingly short, but added comments galore to make them readable (oh, and I reused &lt;code&gt;v&lt;/code&gt; within the local functions, sorry if that is confusing ;).</source>
          <target state="translated">这是Andy E链接的&amp;ldquo;处理数组样式的查询字符串&amp;rdquo;-版本的扩展版本。 修复了一个错误（ &lt;code&gt;?key=1&amp;amp;key[]=2&amp;amp;key[]=3&lt;/code&gt; ; &lt;code&gt;1&lt;/code&gt; 丢失并替换为 &lt;code&gt;[2,3]&lt;/code&gt; ），进行了一些小的性能改进（重新解码值，重新计算&amp;ldquo; [&amp;rdquo;位置等） ），并增加了许多改进（功能化，支持 &lt;code&gt;?key=1&amp;amp;key=2&lt;/code&gt; ；支持 &lt;code&gt;;&lt;/code&gt; 分隔符）。 我烦人地将变量简短地留了下来，但是添加了大量的注释以使它们易于阅读（哦，我在局部函数中重用了 &lt;code&gt;v&lt;/code&gt; ，如果这令人困惑;）。</target>
        </trans-unit>
        <trans-unit id="132d69cbab8386e3ea447358de1a826cd93d8b77" translate="yes" xml:space="preserve">
          <source>Here's my edit to &lt;a href=&quot;https://stackoverflow.com/questions/901115/get-query-string-values-in-javascript/3855394#3855394&quot;&gt;this excellent answer&lt;/a&gt; - with added ability to parse query strings with keys without values.</source>
          <target state="translated">这是我对&lt;a href=&quot;https://stackoverflow.com/questions/901115/get-query-string-values-in-javascript/3855394#3855394&quot;&gt;这个出色答案的&lt;/a&gt;编辑-增强了使用没有值的键解析查询字符串的功能。</target>
        </trans-unit>
        <trans-unit id="a2f72514d5af613c8a1343fa75d1ec41c2228bf1" translate="yes" xml:space="preserve">
          <source>Here's my stab at making Andy E's excellent solution into a full fledged jQuery plugin:</source>
          <target state="translated">以下是我将Andy E的优秀解决方案做成一个完整的jQuery插件的尝试。</target>
        </trans-unit>
        <trans-unit id="da311a8a6a1110d5a8a74129d07303d78a225d20" translate="yes" xml:space="preserve">
          <source>Here's the gist:</source>
          <target state="translated">大意是这样的。</target>
        </trans-unit>
        <trans-unit id="57d64c7cce2ed91ce4593b1967b05e88d8c4e52b" translate="yes" xml:space="preserve">
          <source>How can I get query string values in JavaScript</source>
          <target state="translated">如何在JavaScript中获取查询字符串值</target>
        </trans-unit>
        <trans-unit id="073e456c905ecba1929fe8e5a12e47b31e6e1796" translate="yes" xml:space="preserve">
          <source>However, as of Nov 11, 2014, Purl is no longer maintained and the author recommends using &lt;a href=&quot;https://github.com/medialize/URI.js&quot;&gt;URI.js&lt;/a&gt; instead.  The jQuery plugin is different in that it focuses on elements - for usage with strings, just use &lt;code&gt;URI&lt;/code&gt; directly, with or without jQuery.  Similar code would look as such, fuller docs &lt;a href=&quot;http://medialize.github.io/URI.js/docs.html&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">但是，自2014年11月11日起，不再维护&lt;a href=&quot;https://github.com/medialize/URI.js&quot;&gt;Purl&lt;/a&gt; ，作者建议改用URI.js。 jQuery插件的不同之处在于，它侧重于元素-与字符串一起使用，只需直接使用 &lt;code&gt;URI&lt;/code&gt; （带或不带jQuery）即可。 类似的代码看起来像这样，更完整的文档&lt;a href=&quot;http://medialize.github.io/URI.js/docs.html&quot;&gt;在这里&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="bd67f1c87683773cb062fb7cdf71a5ccf1913a73" translate="yes" xml:space="preserve">
          <source>I like &lt;a href=&quot;http://jquery-howto.blogspot.co.uk/2009/09/get-url-parameters-values-with-jquery.html&quot;&gt;this one&lt;/a&gt; (taken from jquery-howto.blogspot.co.uk):</source>
          <target state="translated">我喜欢&lt;a href=&quot;http://jquery-howto.blogspot.co.uk/2009/09/get-url-parameters-values-with-jquery.html&quot;&gt;这个&lt;/a&gt; （取自jquery-howto.blogspot.co.uk）：</target>
        </trans-unit>
        <trans-unit id="363bb9f49518fc8ecdacdffd5ca86ac45604b3df" translate="yes" xml:space="preserve">
          <source>I like &lt;a href=&quot;https://stackoverflow.com/a/3867610/632117&quot;&gt;Ryan Phelan's solution&lt;/a&gt;. But I don't see any point of extending jQuery for that? There is no usage of jQuery functionality.</source>
          <target state="translated">我喜欢&lt;a href=&quot;https://stackoverflow.com/a/3867610/632117&quot;&gt;Ryan Phelan的解决方案&lt;/a&gt; 。 但是我没有看到为此扩展jQuery的任何意义？ 没有使用jQuery功能。</target>
        </trans-unit>
        <trans-unit id="2ed3ababc0bcc06aaefdf15cc635cc6c6267e8ac" translate="yes" xml:space="preserve">
          <source>I modified the answer to let it parse a full query string with a hash sign also:</source>
          <target state="translated">我修改了答案,让它解析一个带哈希符号的完整查询字符串。</target>
        </trans-unit>
        <trans-unit id="f78977c2a64a76e65be51eb67323404b211ae0f6" translate="yes" xml:space="preserve">
          <source>I needed an object from the query string, and I hate lots of code. It may not be the most robust in the universe, but it's just a few lines of code.</source>
          <target state="translated">我需要一个查询字符串中的对象,我讨厌大量的代码。它可能不是宇宙中最健壮的,但也就几行代码而已。</target>
        </trans-unit>
        <trans-unit id="79c201c11a4f3050ad47703f2c293359df401745" translate="yes" xml:space="preserve">
          <source>I use a compressed version of this. I'm posting uncompressed for the novice types to better explain what's going on.</source>
          <target state="translated">我用的是压缩版的。为了更好的解释是怎么回事,我贴出未经压缩的,给新手们做个说明。</target>
        </trans-unit>
        <trans-unit id="fe807fc0749fd0c20c3a71dfe31c14bd36f7f7f4" translate="yes" xml:space="preserve">
          <source>I use regular expressions a lot, but not for that.</source>
          <target state="translated">我经常使用正则表达式,但不是为了这个。</target>
        </trans-unit>
        <trans-unit id="000fb25af51395f0a84800bb15d10c9c841933b1" translate="yes" xml:space="preserve">
          <source>I was reading all the previous and more complete answers. But I think that is the simplest and faster method. You can check in this jsPerf &lt;a href=&quot;http://jsperf.com/querystring-with-javascript/9&quot;&gt;benchmark&lt;/a&gt;</source>
          <target state="translated">我正在阅读所有以前的和更完整的答案。 但是我认为这是最简单，最快的方法。 您可以检查此jsPerf &lt;a href=&quot;http://jsperf.com/querystring-with-javascript/9&quot;&gt;基准测试&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81709ba36cdb825aca04763013dd5dda37e07d80" translate="yes" xml:space="preserve">
          <source>I'm sure this could be optimized or done differently to work faster, but it's always worked great for what I need.</source>
          <target state="translated">我相信这个可以优化或者用不同的方式来实现更快的工作速度,但对于我所需要的东西,它一直都很好用。</target>
        </trans-unit>
        <trans-unit id="7e323860901e9b0b914295e6322a313c21df6b2a" translate="yes" xml:space="preserve">
          <source>If so, how? If not, is there a plugin which can do so?</source>
          <target state="translated">如果有,请问是怎么做的?如果没有,是否有一个插件可以这样做?</target>
        </trans-unit>
        <trans-unit id="87aba79e8f11e4b4acd477862634759b75fb2167" translate="yes" xml:space="preserve">
          <source>If the querystring is empty (&lt;code&gt;location.search == &quot;&quot;&lt;/code&gt;), the result is somewhat misleading &lt;code&gt;qd == {&quot;&quot;: undefined}&lt;/code&gt;. It is suggested to check the querystring before launching the parsing function likeso:</source>
          <target state="translated">如果querystring为空（ &lt;code&gt;location.search == &quot;&quot;&lt;/code&gt; ），则结果在某种程度上会误导 &lt;code&gt;qd == {&quot;&quot;: undefined}&lt;/code&gt; 。 建议像下面这样启动解析功能之前检查查询字符串：</target>
        </trans-unit>
        <trans-unit id="5aca1f5b15e8c5d7b1cb2718573d533ad324f54f" translate="yes" xml:space="preserve">
          <source>If the specified key already exists in the target NameValueCollection
  instance, the specified value is added to the existing comma-separated
  list of values in the form &quot;value1,value2,value3&quot;.</source>
          <target state="translated">如果目标NameValueCollection实例中已经存在指定的键,那么指定的值将被添加到现有的以 &quot;value1,value2,value3 &quot;形式的逗号分隔的值列表中。</target>
        </trans-unit>
        <trans-unit id="0d0ec74a4bd389a70f2b8e1935ba62040b6af4fd" translate="yes" xml:space="preserve">
          <source>If you are using Browserify, you can use the &lt;code&gt;url&lt;/code&gt; module from &lt;em&gt;Node.js&lt;/em&gt;:</source>
          <target state="translated">如果使用Browserify，则可以使用&lt;em&gt;Node.js中&lt;/em&gt;的 &lt;code&gt;url&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="a08d83cae1fd213bd82c23598b693c45b55526ff" translate="yes" xml:space="preserve">
          <source>If you want to just use plain JavaScript, you could use...</source>
          <target state="translated">如果你想只用普通的JavaScript,你可以使用.....</target>
        </trans-unit>
        <trans-unit id="6f0ffeb6654f3a7ffee450af8c3ae2d36b6c0f96" translate="yes" xml:space="preserve">
          <source>If you're doing more URL manipulation than simply parsing the querystring, you may find &lt;a href=&quot;http://medialize.github.com/URI.js/&quot;&gt;URI.js&lt;/a&gt; helpful. It is a library for manipulating URLs - and comes with all the bells and whistles. (Sorry for self-advertising here)</source>
          <target state="translated">如果您要进行的URL操作不仅仅是简单地解析查询字符串，那么&lt;a href=&quot;http://medialize.github.com/URI.js/&quot;&gt;URI.js&lt;/a&gt;可能会有所帮助。 它是一个用于处理URL的库-带有所有的功能。 （很抱歉在这里进行自我广告）</target>
        </trans-unit>
        <trans-unit id="7996f9d8b0383e2d7a8670d2db775c6478909055" translate="yes" xml:space="preserve">
          <source>If you're using a server-side preprocessing language, you might want to use its native JSON functions to do the heavy lifting for you.  For example, in PHP you can write:</source>
          <target state="translated">如果你使用的是服务器端预处理语言,你可能会想用它的原生JSON函数来帮你完成重任。例如,在PHP中,你可以编写:</target>
        </trans-unit>
        <trans-unit id="39c12b406e4e97742d8a76681a2e11ac2c322406" translate="yes" xml:space="preserve">
          <source>If you're using jQuery, you can use a library, such as &lt;a href=&quot;http://benalman.com/projects/jquery-bbq-plugin/&quot;&gt;jQuery BBQ: Back Button &amp;amp; Query Library&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是jQuery，则可以使用一个库，例如&lt;a href=&quot;http://benalman.com/projects/jquery-bbq-plugin/&quot;&gt;jQuery BBQ：Back Button＆Query Library&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b9f279ab9b93c15e7732d7f6d0361b677684684" translate="yes" xml:space="preserve">
          <source>Improved version of &lt;a href=&quot;https://stackoverflow.com/questions/901115/get-querystring-values-with-jquery/901144#901144&quot;&gt;Artem Barger's answer&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/901115/get-querystring-values-with-jquery/901144#901144&quot;&gt;Artem Barger答案的&lt;/a&gt;改进版本：</target>
        </trans-unit>
        <trans-unit id="939c1360971f05361232aa1dfc51bcd0c83027a3" translate="yes" xml:space="preserve">
          <source>In the end the object &lt;code&gt;d&lt;/code&gt; is returned, handling escaping and the &lt;code&gt;+&lt;/code&gt; sign. This object is just like mine, it has the same behavior.</source>
          <target state="translated">最后，返回对象 &lt;code&gt;d&lt;/code&gt; ，处理转义和 &lt;code&gt;+&lt;/code&gt; 号。 这个对象就像我的一样，具有相同的行为。</target>
        </trans-unit>
        <trans-unit id="0a3a442417df5b0f3e26ff5302d80065b36fef84" translate="yes" xml:space="preserve">
          <source>Is there a plugin-less way of retrieving &lt;a href=&quot;http://en.wikipedia.org/wiki/Query_string&quot;&gt;query string&lt;/a&gt; values via jQuery (or without)?</source>
          <target state="translated">是否有通过jQuery（或不通过jQuery）检索&lt;a href=&quot;http://en.wikipedia.org/wiki/Query_string&quot;&gt;查询字符串&lt;/a&gt;值的无插件方法？</target>
        </trans-unit>
        <trans-unit id="c942434e52be1941f81f456d259d83650c2fc586" translate="yes" xml:space="preserve">
          <source>It can be used with or without jQuery.</source>
          <target state="translated">不管有没有jQuery,都可以使用它。</target>
        </trans-unit>
        <trans-unit id="06449a1fc73d65df535617b5ae6f0aea504907b9" translate="yes" xml:space="preserve">
          <source>It is a simple library method that does dissection and manipulation of URL parameters. The static method has the following sub methods that can be called on the subject URL:</source>
          <target state="translated">它是一个简单的库方法,可以对URL参数进行剖析和操纵。该静态方法有以下子方法,可以在主题URL上调用。</target>
        </trans-unit>
        <trans-unit id="e11c918dadbe3781578fcc20c66a0f1e853ea947" translate="yes" xml:space="preserve">
          <source>It is not standardized by &lt;a href=&quot;https://www.w3.org/TR/2014/WD-url-1-20141209/#interface-urlsearchparams&quot;&gt;W3C&lt;/a&gt;, but it is a living standard by &lt;a href=&quot;https://url.spec.whatwg.org&quot;&gt;WhatWG&lt;/a&gt;.</source>
          <target state="translated">它不是&lt;a href=&quot;https://www.w3.org/TR/2014/WD-url-1-20141209/#interface-urlsearchparams&quot;&gt;W3C&lt;/a&gt;标准化的，而是&lt;a href=&quot;https://url.spec.whatwg.org&quot;&gt;WhatWG&lt;/a&gt;的生活标准。</target>
        </trans-unit>
        <trans-unit id="11cddc7dd95111cd35e184f50fed79b8c617b9c9" translate="yes" xml:space="preserve">
          <source>It is obfuscated, but it is understandable. It does not work because some variables are undefined.</source>
          <target state="translated">虽然是模糊的,但也可以理解。因为有些变量是未定义的,所以不能用。</target>
        </trans-unit>
        <trans-unit id="8e5326ea293b648dfb498c4737b71c49593fa53a" translate="yes" xml:space="preserve">
          <source>It seems &lt;a href=&quot;https://stackoverflow.com/questions/1746507/authoritative-position-of-duplicate-http-get-query-keys&quot;&gt;the jury is somewhat out&lt;/a&gt; on repeated keys as there is no spec. In this case, multiple keys are stored as an (fake)array. But do note that I &lt;strong&gt;do not&lt;/strong&gt; process values based on commas into arrays.</source>
          <target state="translated">由于没有规范，似乎&lt;a href=&quot;https://stackoverflow.com/questions/1746507/authoritative-position-of-duplicate-http-get-query-keys&quot;&gt;陪审团&lt;/a&gt;在重复按键上有些失落。 在这种情况下，多个密钥存储为（伪）数组。 但是请注意，我&lt;strong&gt;不会将&lt;/strong&gt;基于逗号的值处理为数组。</target>
        </trans-unit>
        <trans-unit id="5bc0d0c64bbf99b1a4ec89d5518cf19ec4b55828" translate="yes" xml:space="preserve">
          <source>It seems easier and more efficient to me to read the query string once in my application, and build an object from all the key/value pairs like:</source>
          <target state="translated">在我看来,在我的应用程序中读取一次查询字符串,然后从所有的key-value对中建立一个对象,就像这样,更容易和更有效。</target>
        </trans-unit>
        <trans-unit id="0d9e0072af909d8f1dbe2a8be04403380e6913da" translate="yes" xml:space="preserve">
          <source>It will handle the following querystring...</source>
          <target state="translated">它将处理下面的querystring.....。</target>
        </trans-unit>
        <trans-unit id="e57f582326a196e279b0369debf208ce142e0c47" translate="yes" xml:space="preserve">
          <source>Just added that capability also while adding in  the return statement</source>
          <target state="translated">只是在返回语句中添加了这个功能,同时也添加了这个功能。</target>
        </trans-unit>
        <trans-unit id="5e57982a4f0bbf6468c5fe9a3ecd05a947ccd049" translate="yes" xml:space="preserve">
          <source>Just another recommendation. The plugin &lt;em&gt;&lt;a href=&quot;https://github.com/allmarkedup/jQuery-URL-Parser&quot;&gt;Purl&lt;/a&gt;&lt;/em&gt; allows to retrieve all parts of URL, including anchor, host, etc.</source>
          <target state="translated">只是另一个建议。 插件&lt;em&gt;&lt;a href=&quot;https://github.com/allmarkedup/jQuery-URL-Parser&quot;&gt;Purl&lt;/a&gt;&lt;/em&gt;允许检索URL的所有部分，包括锚点，主机等。</target>
        </trans-unit>
        <trans-unit id="39775219f019850e5b5d67c91544fdf0f2873408" translate="yes" xml:space="preserve">
          <source>Just call &lt;code&gt;var langval = $.urlParam('lang');&lt;/code&gt;, and you've got it.</source>
          <target state="translated">只需调用 &lt;code&gt;var langval = $.urlParam('lang');&lt;/code&gt; ，就可以了。</target>
        </trans-unit>
        <trans-unit id="f7157d509275674f6d5ecbec37fbd08893a281d2" translate="yes" xml:space="preserve">
          <source>Just use two &lt;strong&gt;splits&lt;/strong&gt;:</source>
          <target state="translated">只需使用两个&lt;strong&gt;拆分&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="f207b9e49068d57e814e520cfce9889714432e57" translate="yes" xml:space="preserve">
          <source>Keep it simple in plain JavaScript code:</source>
          <target state="translated">在普通的JavaScript代码中保持简单。</target>
        </trans-unit>
        <trans-unit id="41d3f0ba4eb4a4f6a8f2357e3f45a9724879b4b6" translate="yes" xml:space="preserve">
          <source>Much simpler!</source>
          <target state="translated">简单多了!</target>
        </trans-unit>
        <trans-unit id="c31c16bf28a87dd39c0cc7ceabf8f26f194b95d5" translate="yes" xml:space="preserve">
          <source>Multi-lined:</source>
          <target state="translated">Multi-lined:</target>
        </trans-unit>
        <trans-unit id="7a470436b960c7bdafbae4ddd2230b6507d78309" translate="yes" xml:space="preserve">
          <source>Multi-valued keys</source>
          <target state="translated">多值键</target>
        </trans-unit>
        <trans-unit id="1a2c48fe1b52e0d77aca5bf7ab544676b4a8ef74" translate="yes" xml:space="preserve">
          <source>My method as a &lt;strong&gt;jQuery plugin&lt;/strong&gt;</source>
          <target state="translated">我作为&lt;strong&gt;jQuery插件的&lt;/strong&gt;方法</target>
        </trans-unit>
        <trans-unit id="ffe0cab36ad398551d537199d563d31ff53d5e3b" translate="yes" xml:space="preserve">
          <source>NOTE: The function is case-sensitive. If you prefer case-insensitive parameter name, &lt;a href=&quot;https://stackoverflow.com/questions/3939715/case-insensitive-regex-in-javascript&quot;&gt;add 'i' modifier to RegExp&lt;/a&gt;</source>
          <target state="translated">注意：该功能区分大小写。 如果您希望使用不区分大小写的参数名称，请&lt;a href=&quot;https://stackoverflow.com/questions/3939715/case-insensitive-regex-in-javascript&quot;&gt;在RegExp中添加'i'修饰符&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e342d9ceee97455375446a33c725d14171eb5e6e" translate="yes" xml:space="preserve">
          <source>Note: If a parameter is present several times (&lt;code&gt;?foo=lorem&amp;amp;foo=ipsum&lt;/code&gt;), you will get the first value (&lt;code&gt;lorem&lt;/code&gt;). There is no standard about this and usages vary, see for example this question: &lt;a href=&quot;https://stackoverflow.com/questions/1746507/authoritative-position-of-duplicate-http-get-query-keys&quot;&gt;Authoritative position of duplicate HTTP GET query keys&lt;/a&gt;.</source>
          <target state="translated">注意：如果一个参数多次出现（ &lt;code&gt;?foo=lorem&amp;amp;foo=ipsum&lt;/code&gt; ），您将获得第一个值（ &lt;code&gt;lorem&lt;/code&gt; ）。 对此没有标准，用法也有所不同，例如参见以下问题： &lt;a href=&quot;https://stackoverflow.com/questions/1746507/authoritative-position-of-duplicate-http-get-query-keys&quot;&gt;重复的HTTP GET查询键的权威位置&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="43c7a3ea7253466a37057cb8334c7958806eb6df" translate="yes" xml:space="preserve">
          <source>Now returns &lt;b&gt;arrays&lt;/b&gt; instead.</source>
          <target state="translated">现在返回&lt;b&gt;数组&lt;/b&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2471f4da04fb01da16baeda4a33cd4ee040e3f0" translate="yes" xml:space="preserve">
          <source>Now you can find the updated gist:</source>
          <target state="translated">现在你可以找到更新的要点了。</target>
        </trans-unit>
        <trans-unit id="3c9422d5c4a86cebd5de145afc04796575bbd229" translate="yes" xml:space="preserve">
          <source>On my Mac: &lt;code&gt;test.htm?i=can&amp;amp;has=cheezburger&lt;/code&gt; displays</source>
          <target state="translated">在我的Mac上： &lt;code&gt;test.htm?i=can&amp;amp;has=cheezburger&lt;/code&gt; 显示</target>
        </trans-unit>
        <trans-unit id="537ef0f2a672534b79397686a0f2fa1d74fc14bd" translate="yes" xml:space="preserve">
          <source>On the other hand, I like the built-in function in Google Chrome: window.location.getParameter.</source>
          <target state="translated">另一方面,我喜欢Google Chrome中的内置函数:window.location.getParameter。</target>
        </trans-unit>
        <trans-unit id="c052a09c90643f5d3c0aaba27402c7eb0eada351" translate="yes" xml:space="preserve">
          <source>Opera Announcement and details</source>
          <target state="translated">戏曲公告和细节</target>
        </trans-unit>
        <trans-unit id="cca8e52d510a96977a45bd9f72c787c66c876e61" translate="yes" xml:space="preserve">
          <source>Or of course on any URL:</source>
          <target state="translated">当然也可以在任何URL上。</target>
        </trans-unit>
        <trans-unit id="10f363b735c302f44ed620411c0930ff6b35fe62" translate="yes" xml:space="preserve">
          <source>Overrides &lt;b&gt;multi-keys&lt;/b&gt; with &lt;b&gt;last&lt;/b&gt; value found.</source>
          <target state="translated">用找到的&lt;b&gt;最后一个&lt;/b&gt;值覆盖&lt;b&gt;多键&lt;/b&gt; 。</target>
        </trans-unit>
        <trans-unit id="7557ddf49eda41f29918181441555cb4d277e0a3" translate="yes" xml:space="preserve">
          <source>Preparation code: methods declaration</source>
          <target state="translated">准备代码:方法声明</target>
        </trans-unit>
        <trans-unit id="3c53c636d12f95e9beeb95725e1c43c7ac0031f3" translate="yes" xml:space="preserve">
          <source>Read more... about the Vanilla JavaScript solution.</source>
          <target state="translated">阅读更多.....关于Vanilla JavaScript解决方案。</target>
        </trans-unit>
        <trans-unit id="4752dd2f39ea7d253016f5d35abab9eaeb1d3de4" translate="yes" xml:space="preserve">
          <source>Regex test code</source>
          <target state="translated">编码测试</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="9be8504a8f678e5d59f7566150005d5cb3768376" translate="yes" xml:space="preserve">
          <source>Roshambo jQuery method wasn't taking care of decode URL</source>
          <target state="translated">Roshambo的jQuery方法没有照顾到URL的解码问题。</target>
        </trans-unit>
        <trans-unit id="8bb4d1b06e6b852b3d6f7e8520515eddd31556bc" translate="yes" xml:space="preserve">
          <source>Roshambo on snipplr.com has a simple script to achieve this described in &lt;em&gt;&lt;a href=&quot;http://snipplr.com/view/26662/get-url-parameters-with-jquery--improved/&quot;&gt;Get URL Parameters with jQuery | Improved&lt;/a&gt;&lt;/em&gt;. With his script you also easily get to pull out just the parameters you want.</source>
          <target state="translated">snipplr.com上的Roshambo有​​一个简单的脚本来实现此目的，如&lt;em&gt;&lt;a href=&quot;http://snipplr.com/view/26662/get-url-parameters-with-jquery--improved/&quot;&gt;使用jQuery |使用URL获取参数中&lt;/a&gt;&lt;/em&gt;所述。 &lt;em&gt;改进了&lt;/em&gt; 。 使用他的脚本，您还可以轻松提取所需的参数。</target>
        </trans-unit>
        <trans-unit id="08ac9fbbc9dc3ce88122248070ff14cced35c8d0" translate="yes" xml:space="preserve">
          <source>Simple key check &lt;code&gt;(item in dict) ? dict.item.push(val) : dict.item = [val]&lt;/code&gt;</source>
          <target state="translated">简单的密钥检查 &lt;code&gt;(item in dict) ? dict.item.push(val) : dict.item = [val]&lt;/code&gt; dict.item.push（val）：dict.item = [val]</target>
        </trans-unit>
        <trans-unit id="8aa02fb18be713e7da4cba6773249b7b4dff0f2d" translate="yes" xml:space="preserve">
          <source>So if the URL/query string was &lt;code&gt;xyz.com/index.html?lang=de&lt;/code&gt;.</source>
          <target state="translated">因此，如果URL /查询字符串是 &lt;code&gt;xyz.com/index.html?lang=de&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27c01f6d15e1f792a4740307f0513b452fa04ff4" translate="yes" xml:space="preserve">
          <source>So if you know you won't run into Rup's counter-case, this wins. Otherwise, regexp.</source>
          <target state="translated">所以,如果你知道你不会遇到Rup的反例,这个赢了。否则,再来一次</target>
        </trans-unit>
        <trans-unit id="8436af2669db42bebb74a68489289c5b91e668ca" translate="yes" xml:space="preserve">
          <source>So what exactly changed? With url &lt;code&gt;http://sb.com/reg/step1?param=&lt;/code&gt; results will be same. But with url &lt;code&gt;http://sb.com/reg/step1?param&lt;/code&gt; Bruno's solution returns an object without keys, while mine returns an object with key &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; value.</source>
          <target state="translated">那么到底发生了什么变化？ 如果使用网址 &lt;code&gt;http://sb.com/reg/step1?param=&lt;/code&gt; ,结果将相同。 但是，如果使用url &lt;code&gt;http://sb.com/reg/step1?param&lt;/code&gt; ,布鲁诺的解决方案将返回没有键的对象，而我的解决方案将返回具有键 &lt;code&gt;param&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 值的对象。</target>
        </trans-unit>
        <trans-unit id="9759c5e93ea70521574ed63522a86d62feb12cfd" translate="yes" xml:space="preserve">
          <source>So why not to use this? Okay, other browsers don't have. So let's create this function if it does not exist:</source>
          <target state="translated">那么为什么不用这个呢?好吧,其他浏览器没有。所以,如果没有这个功能,我们就创建这个功能吧。</target>
        </trans-unit>
        <trans-unit id="a0f08300b4e6c071a2da3c87dc7c8ab283896891" translate="yes" xml:space="preserve">
          <source>So, this is the approach to manage it:</source>
          <target state="translated">所以,这就是管理的方法。</target>
        </trans-unit>
        <trans-unit id="275598542ca0a399c37db60c2c8233f7564d0237" translate="yes" xml:space="preserve">
          <source>Some of the solutions posted here are inefficient. Repeating the regular expression search every time the script needs to access a parameter is completely unnecessary, one single function to split up the parameters into an associative-array style object is enough. If you're not working with the HTML 5 History API, this is only necessary once per page load.  The other suggestions here also fail to decode the URL correctly.</source>
          <target state="translated">这里发布的一些解决方案都是低效的。每次脚本需要访问一个参数的时候重复正则表达式搜索是完全没有必要的,只需要一个函数将参数分割成关联数组样式的对象就足够了。如果你不是在使用HTML 5历史API,每次加载页面时只需要这样做一次就可以了。这里的其他建议也无法正确解码URL。</target>
        </trans-unit>
        <trans-unit id="62669f1c0f3a400a1cdf3d2361e05585135d5429" translate="yes" xml:space="preserve">
          <source>Split test code</source>
          <target state="translated">拆分测试代码</target>
        </trans-unit>
        <trans-unit id="cae4ef2c7ff69f37950b90d84019dc33390b37e0" translate="yes" xml:space="preserve">
          <source>Tearing Google's code I found the method they use: &lt;code&gt;getUrlParameters&lt;/code&gt;</source>
          <target state="translated">撕裂Google的代码后，我找到了他们使用的方法： &lt;code&gt;getUrlParameters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49c72239751b2e412597c78b117d3a3b7483ac0c" translate="yes" xml:space="preserve">
          <source>The problem with the top answer on that question is that it's not-supported parameters placed after #, but sometimes it's needed to get this value also.</source>
          <target state="translated">这道题的顶部答案的问题是不支持的参数放在#后面,但有时也需要得到这个值。</target>
        </trans-unit>
        <trans-unit id="869d833f9b3336891a11a67fcd142e1caac2f566" translate="yes" xml:space="preserve">
          <source>The syntax is:</source>
          <target state="translated">其语法是:</target>
        </trans-unit>
        <trans-unit id="cf7022789844fe203ac43cfc1a2b12c5aefad738" translate="yes" xml:space="preserve">
          <source>Then just get your parameters from the query string.</source>
          <target state="translated">然后从查询字符串中获取参数就可以了。</target>
        </trans-unit>
        <trans-unit id="638840f34b22b5ae9b66bd9c24c447b9e15dd740" translate="yes" xml:space="preserve">
          <source>There is a google-suggested &lt;strong&gt;&lt;a href=&quot;https://github.com/WebReflection/url-search-params&quot;&gt;URLSearchParams polyfill&lt;/a&gt;&lt;/strong&gt; for the stable versions of IE.</source>
          <target state="translated">有google建议的&lt;strong&gt;&lt;a href=&quot;https://github.com/WebReflection/url-search-params&quot;&gt;URLSearchParams polyfill&lt;/a&gt;&lt;/strong&gt;用于IE的稳定版本。</target>
        </trans-unit>
        <trans-unit id="e886cc5a12cf11b6338ae8af68acdfe43fdead94" translate="yes" xml:space="preserve">
          <source>These are all great answers, but I needed something a bit more robust, and thought you all might like to have what I created.</source>
          <target state="translated">这些都是很好的答案,但我需要一些更稳健的东西,我想大家可能会喜欢我创造的东西。</target>
        </trans-unit>
        <trans-unit id="a843b1bdd4230f8b19e0d45e0269d3d8533abf96" translate="yes" xml:space="preserve">
          <source>They start to look for parameters on the url from &lt;code&gt;?&lt;/code&gt; and also from the hash &lt;code&gt;#&lt;/code&gt;. Then for each parameter they split in the equal sign &lt;code&gt;b[f][p](&quot;=&quot;)&lt;/code&gt; (which looks like &lt;code&gt;indexOf&lt;/code&gt;, they use the position of the char to get the key/value). Having it split they check whether the parameter has a value or not, if it has then they store the value of &lt;code&gt;d&lt;/code&gt;, otherwise they just continue.</source>
          <target state="translated">他们开始在URL上查找参数 &lt;code&gt;?&lt;/code&gt; 以及 &lt;code&gt;#&lt;/code&gt; 中的哈希值。 然后，对于每个参数，它们以等号 &lt;code&gt;b[f][p](&quot;=&quot;)&lt;/code&gt; 分割（看起来像 &lt;code&gt;indexOf&lt;/code&gt; ，他们使用char的位置来获取键/值）。 将其拆分后，他们将检查参数是否具有值，如果具有则存储参数 &lt;code&gt;d&lt;/code&gt; 的值，否则将继续执行。</target>
        </trans-unit>
        <trans-unit id="e5f177b7dc70f30062b86a2e4b48e1574fe4fe3b" translate="yes" xml:space="preserve">
          <source>This could easily be improved upon to handle array-style query strings too.  An example of this is &lt;a href=&quot;http://jsbin.com/adali3/2&quot;&gt;here&lt;/a&gt;, but since array-style parameters aren't defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; I won't pollute this answer with the source code. &lt;a href=&quot;https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/23401756#23401756&quot;&gt;For those interested in a &quot;polluted&quot; version, look at campbeln's answer below&lt;/a&gt;.</source>
          <target state="translated">这也可以轻松地改进以处理数组样式的查询字符串。 这是一个示例，但是由于&lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986中&lt;/a&gt;未定义数组样式参数，因此我不会用源代码来污染此答案。 &lt;a href=&quot;https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/23401756#23401756&quot;&gt;对于那些对&amp;ldquo;污染&amp;rdquo;版本感兴趣的人，请查看下面的Campbeln的答案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="785fbe088ab7b929831fb85238315c9b070e6dd2" translate="yes" xml:space="preserve">
          <source>This function is more or less from Ryan Phelan, but it is wrapped differently: clear name and no dependencies of other javascript libraries. &lt;a href=&quot;http://sharepointkunskap.wordpress.com/2012/01/11/get-url-parameters-with-javascript/&quot;&gt;More about this function on my blog&lt;/a&gt;.</source>
          <target state="translated">此功能或多或少与Ryan Phelan相同，但是它的包装方式有所不同：名称清晰且不依赖其他javascript库。 &lt;a href=&quot;http://sharepointkunskap.wordpress.com/2012/01/11/get-url-parameters-with-javascript/&quot;&gt;有关此功能的更多信息，请访问我的博客&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="70ce98195ff8aa37fd7abebc93e808753cb4ebbd" translate="yes" xml:space="preserve">
          <source>This is a function I created a while back and I'm quite happy with. It is not case sensitive - which is handy. Also, if the requested QS doesn't exist, it just returns an empty string.</source>
          <target state="translated">这是我不久前创建的一个功能,我很满意。它不区分大小写,这很方便。另外,如果请求的QS不存在,它只会返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="880f4163a15c8a19d4b57d0b69c2302c39bea48a" translate="yes" xml:space="preserve">
          <source>This is an update based on the new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams&quot;&gt;URLSearchParams specs&lt;/a&gt; to achieve the same result more succinctly. See answer titled &quot;&lt;a href=&quot;https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/901144#12151322&quot;&gt;URLSearchParams&lt;/a&gt;&quot; below.</source>
          <target state="translated">这是基于新的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams&quot;&gt;URLSearchParams规范&lt;/a&gt;的更新，目的是更简洁地达到相同的结果。 请参阅下面标题为&amp;ldquo; &lt;a href=&quot;https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/901144#12151322&quot;&gt;URLSearchParams&lt;/a&gt; &amp;rdquo;的答案。</target>
        </trans-unit>
        <trans-unit id="b9db0bc0a8c58c3017b8ec738697d3bd06ce2780" translate="yes" xml:space="preserve">
          <source>This version will update its internal cache of parameters each time the history changes.</source>
          <target state="translated">每当历史记录发生变化时,该版本将更新其内部缓存的参数。</target>
        </trans-unit>
        <trans-unit id="0e7fc00961b74dd24ca9653ed04641900be663c2" translate="yes" xml:space="preserve">
          <source>To solve the problem in Rup's comment, add a conditional split by changing the first line to the two below. But absolute accuracy means it's now slower than regexp (see &lt;a href=&quot;http://jsperf.com/querystring-with-javascript/10&quot;&gt;jsPerf&lt;/a&gt;).</source>
          <target state="translated">要解决Rup注释中的问题，请通过将第一行更改为下面的两行来添加条件拆分。 但是绝对精度意味着它现在比regexp慢（请参阅&lt;a href=&quot;http://jsperf.com/querystring-with-javascript/10&quot;&gt;jsPerf&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="47b23b39759a1908e680a0a3b5cb3c99d6de735e" translate="yes" xml:space="preserve">
          <source>UPDATED</source>
          <target state="translated">UPDATED</target>
        </trans-unit>
        <trans-unit id="b19e8d66e7f004e226c44a75766dadab7d09911a" translate="yes" xml:space="preserve">
          <source>URLSearchParams</source>
          <target state="translated">URLSearchParams</target>
        </trans-unit>
        <trans-unit id="5a8cd4a189f53053616ff5571c7cf39afe0885c1" translate="yes" xml:space="preserve">
          <source>UZBEKJON has a great blog post on this as well, &lt;em&gt;&lt;a href=&quot;http://jquery-howto.blogspot.com/2009/09/get-url-parameters-values-with-jquery.html&quot;&gt;Get URL parameters &amp;amp; values with jQuery&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">UZBEKJON对此也有很棒的博客文章， &lt;em&gt;&lt;a href=&quot;http://jquery-howto.blogspot.com/2009/09/get-url-parameters-values-with-jquery.html&quot;&gt;使用jQuery获取URL参数和值&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="b93fb7a6a3be201a9ffddb0c9abd27f858aee537" translate="yes" xml:space="preserve">
          <source>Usage is very simple and cool:</source>
          <target state="translated">使用方法很简单,也很炫酷。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="392df2a166f2f52393355ae22d0307f078b54728" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;decodeURIComponent()&lt;/code&gt; for the second &lt;em&gt;or both&lt;/em&gt; splits.</source>
          <target state="translated">对第二个拆分&lt;em&gt;或两个&lt;/em&gt;拆分&lt;em&gt;都&lt;/em&gt;使用 &lt;code&gt;decodeURIComponent()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff3e16b2ce3562cdd238525776f9c4ebc2eef93c" translate="yes" xml:space="preserve">
          <source>We've just released &lt;a href=&quot;https://github.com/stretchr/arg.js&quot;&gt;arg.js&lt;/a&gt;, a project aimed at solving this problem once and for all.  It's traditionally been so difficult but now you can do:</source>
          <target state="translated">我们刚刚发布了&lt;a href=&quot;https://github.com/stretchr/arg.js&quot;&gt;arg.js&lt;/a&gt; ，该项目旨在彻底解决此问题。 传统上这是如此困难，但是现在您可以：</target>
        </trans-unit>
        <trans-unit id="c3804ffce841dd1b7f21366c2ef0fdde6c5bf130" translate="yes" xml:space="preserve">
          <source>What is all this code...</source>
          <target state="translated">这都是什么代码.....</target>
        </trans-unit>
        <trans-unit id="e49acedde6c2da878b9e79c1a9d7df57c479b9c3" translate="yes" xml:space="preserve">
          <source>With an URL like &lt;code&gt;?topic=123&amp;amp;name=query+string&lt;/code&gt;, the following will return:</source>
          <target state="translated">使用类似 &lt;code&gt;?topic=123&amp;amp;name=query+string&lt;/code&gt; 的URL时，将返回以下内容：</target>
        </trans-unit>
        <trans-unit id="0c0a59fb074de0fc1fd7cee2f49870f337cc9102" translate="yes" xml:space="preserve">
          <source>Without jQuery</source>
          <target state="translated">没有jQuery的情况下</target>
        </trans-unit>
        <trans-unit id="3ae633fca7fc3cfcefb10e9095e623c1e577d05b" translate="yes" xml:space="preserve">
          <source>Works great for me.</source>
          <target state="translated">对我来说效果很好。</target>
        </trans-unit>
        <trans-unit id="dffd535ef0186fa22439ec59e86712413ad1b9a1" translate="yes" xml:space="preserve">
          <source>You can also use URLSearchParams for it, here's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#Example&quot;&gt;an example from MDN&lt;/a&gt; to do it with URLSearchParams:</source>
          <target state="translated">您也可以为其使用URLSearchParams，这&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#Example&quot;&gt;是MDN&lt;/a&gt;的一个示例，可以通过URLSearchParams来实现：</target>
        </trans-unit>
        <trans-unit id="4ede7842007a910025b46477a4c81da92b054e8c" translate="yes" xml:space="preserve">
          <source>You can get params also using a shorthand &lt;code&gt;.searchParams&lt;/code&gt; property on the URL object, like this:</source>
          <target state="translated">您还可以使用URL对象上的简写 &lt;code&gt;.searchParams&lt;/code&gt; 属性来获取参数，如下所示：</target>
        </trans-unit>
        <trans-unit id="bec4d2ce8c312b81ed4ea34a1fa6877786b84da0" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#Browser_compatibility&quot;&gt;URLSearchParams&lt;/a&gt; which is simple and has &lt;a href=&quot;https://caniuse.com/#feat=urlsearchparams&quot;&gt;decent (but not complete) browser support&lt;/a&gt;.</source>
          <target state="translated">您可以使用简单且具有&lt;a href=&quot;https://caniuse.com/#feat=urlsearchparams&quot;&gt;不错（但不完整）浏览器支持的&lt;/a&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#Browser_compatibility&quot;&gt;URLSearchParams&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a2e5e1b0d7dd97f755e9e72aa22014f827c6086" translate="yes" xml:space="preserve">
          <source>You can use it on &lt;code&gt;location&lt;/code&gt;:</source>
          <target state="translated">您可以在以下 &lt;code&gt;location&lt;/code&gt; 使用它：</target>
        </trans-unit>
        <trans-unit id="95636b19872bae2965f8a7b844f3b33edcc8ab4d" translate="yes" xml:space="preserve">
          <source>You don't need jQuery for that purpose. You can use just some pure JavaScript:</source>
          <target state="translated">你不需要jQuery来实现这个目的。你只需要使用一些纯JavaScript就可以了。</target>
        </trans-unit>
        <trans-unit id="a4deb33adf10380e08f4a933d326aeb7a6b90323" translate="yes" xml:space="preserve">
          <source>You read/set parameters through the &lt;code&gt;get(KEY)&lt;/code&gt;, &lt;code&gt;set(KEY, VALUE)&lt;/code&gt;, &lt;code&gt;append(KEY, VALUE)&lt;/code&gt; API. You can also iterate over all values &lt;code&gt;for (let p of params) {}&lt;/code&gt;.</source>
          <target state="translated">您可以通过 &lt;code&gt;get(KEY)&lt;/code&gt; ， &lt;code&gt;set(KEY, VALUE)&lt;/code&gt; ， &lt;code&gt;append(KEY, VALUE)&lt;/code&gt; API读取/设置参数。 您还可以遍历 &lt;code&gt;for (let p of params) {}&lt;/code&gt; 所有值。</target>
        </trans-unit>
        <trans-unit id="838bd1bcefa13f29010a286f1eadbaf9c144650a" translate="yes" xml:space="preserve">
          <source>and if you care about the difference between &lt;code&gt;?query=true&lt;/code&gt; and &lt;code&gt;#hash=true&lt;/code&gt; then you can use the &lt;code&gt;Arg.query()&lt;/code&gt; and &lt;code&gt;Arg.hash()&lt;/code&gt; methods.</source>
          <target state="translated">如果您关心 &lt;code&gt;?query=true&lt;/code&gt; 和 &lt;code&gt;Arg.query()&lt;/code&gt; = true之间的区别，那么可以使用Arg.query（）和 &lt;code&gt;Arg.hash()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="d063002e0b1cd2adbddcbf212619985781f96479" translate="yes" xml:space="preserve">
          <source>getHash</source>
          <target state="translated">getHash</target>
        </trans-unit>
        <trans-unit id="be7ccc1402c4ef7b03a97cb983978c3793e26812" translate="yes" xml:space="preserve">
          <source>getHost</source>
          <target state="translated">getHost</target>
        </trans-unit>
        <trans-unit id="b5a5fe44454826c283f4f56097f59524379aa727" translate="yes" xml:space="preserve">
          <source>getParam</source>
          <target state="translated">getParam</target>
        </trans-unit>
        <trans-unit id="403e8e0a2033d5412408c1b64b782d5f1c1d95be" translate="yes" xml:space="preserve">
          <source>getParams</source>
          <target state="translated">getParams</target>
        </trans-unit>
        <trans-unit id="bc119b82b82560bad5a3f6cf69db9444b34ebfb6" translate="yes" xml:space="preserve">
          <source>getPath</source>
          <target state="translated">getPath</target>
        </trans-unit>
        <trans-unit id="3bd6d0bd1635786a7175c813be113edac076e2e1" translate="yes" xml:space="preserve">
          <source>getQuery</source>
          <target state="translated">getQuery</target>
        </trans-unit>
        <trans-unit id="3fd57351e3f02a8a8053535c9bdee5b0fa524726" translate="yes" xml:space="preserve">
          <source>hasParam</source>
          <target state="translated">hasParam</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="e325bd97642094b3751758dabdc4840b6401c0ea" translate="yes" xml:space="preserve">
          <source>or getting the whole lot:</source>
          <target state="translated">或得到全部的东西。</target>
        </trans-unit>
        <trans-unit id="97a8e0547c911e89290749777617372f2ee2216a" translate="yes" xml:space="preserve">
          <source>removeParam</source>
          <target state="translated">removeParam</target>
        </trans-unit>
        <trans-unit id="2a01642660f3da69300df25564329261a463dac4" translate="yes" xml:space="preserve">
          <source>setHash</source>
          <target state="translated">setHash</target>
        </trans-unit>
        <trans-unit id="8abd850531e327fb74f340d4cef8d080c94e5580" translate="yes" xml:space="preserve">
          <source>setParam</source>
          <target state="translated">setParam</target>
        </trans-unit>
        <trans-unit id="b2407cb2215024ae653dbf5a158744f770da9e61" translate="yes" xml:space="preserve">
          <source>to convert your querystring into a map:</source>
          <target state="translated">将你的查询字符串转换为地图。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
