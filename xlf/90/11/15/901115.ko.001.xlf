<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/901115">
    <body>
      <group id="901115">
        <trans-unit id="e0d02f69bfab290bf1f501ff1a5082d271e75385" translate="yes" xml:space="preserve">
          <source>(URI.js also &quot;fixes&quot; bad querystrings like &lt;code&gt;?&amp;amp;foo&amp;amp;&amp;amp;bar=baz&amp;amp;&lt;/code&gt; to &lt;code&gt;?foo&amp;amp;bar=baz&lt;/code&gt;)</source>
          <target state="translated">(URI.js는 &lt;code&gt;?&amp;amp;foo&amp;amp;&amp;amp;bar=baz&amp;amp;&lt;/code&gt; 같은 ? query &amp;amp; bar = baz 와 같은 잘못된 쿼리 문자열을&amp;ldquo;수정&amp;rdquo;합니다)</target>
        </trans-unit>
        <trans-unit id="c33bf3988dc284bca985201a791bf293ac167541" translate="yes" xml:space="preserve">
          <source>...jQuery BBQ provides a full &lt;code&gt;.deparam()&lt;/code&gt; method, along with both hash state management, and fragment / query string parse and merge utility methods.</source>
          <target state="translated">... jQuery BBQ는 해시 상태 관리, 조각 / 쿼리 문자열 구문 분석 및 병합 유틸리티 메소드와 함께 전체 &lt;code&gt;.deparam()&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="79c0e20f0a22c1356012c1d3381c34dd2e441471" translate="yes" xml:space="preserve">
          <source>...making it into an object that looks like...</source>
          <target state="translated">... 이것처럼 보이는 물체로 만들기 ...</target>
        </trans-unit>
        <trans-unit id="11f6482ce9f388b216bfc419e445a6c77c8d7dbd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsperf.com/querystring-with-javascript&quot;&gt;Performance test (split method against regex method)&lt;/a&gt; (&lt;a href=&quot;http://jsperf.com/&quot;&gt;jsPerf&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://jsperf.com/querystring-with-javascript&quot;&gt;성능 테스트 (정규 방법에 대한 분리 방법)&lt;/a&gt; ( &lt;a href=&quot;http://jsperf.com/&quot;&gt;jsPerf&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="47be74a6372dd1484c8ce49a9b412e5d8f655945" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;IMPORTANT!&lt;/b&gt; The parameter for that function in the last line is different. It's just an example of how one can pass an arbitrary URL to it. You can use last line from Bruno's answer to parse the current URL.</source>
          <target state="translated">&lt;b&gt;중대한!&lt;/b&gt; 마지막 행에서 해당 기능의 매개 변수가 다릅니다. 임의의 URL을 전달할 수있는 방법에 대한 예일뿐입니다. Bruno의 답변에서 마지막 줄을 사용하여 현재 URL을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d139bec92ab703c3930b72ed0bcca93c86a4a024" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/q/476436/985454&quot;&gt;&quot;null-coalescing&quot;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-Circuit_Evaluation&quot;&gt;short-circuit evaluation&lt;/a&gt;&lt;br/&gt;
ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Destructuring assignments&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;Arrow functions&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;Template strings&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/q/476436/985454&quot;&gt;&quot;널 코 레싱&quot;&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-Circuit_Evaluation&quot;&gt;단락 평가&lt;/a&gt;&lt;/em&gt; &lt;em&gt;&lt;br/&gt;&lt;/em&gt; &lt;em&gt;ES6 구조화 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;할당&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 기능&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;템플릿 문자열&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a25782e4816475a2a0901c6ec5632570b52f9639" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Or&lt;/em&gt; if you have control of the querystring and can guarantee that a value you are trying to get will never contain any URL encoded
  characters (having these in a value would be a bad idea) - you can use
  the following slightly more simplified and readable version of the 1st option:</source>
          <target state="translated">&lt;em&gt;또는&lt;/em&gt; 쿼리 문자열을 제어하고 얻으려는 값에 URL로 인코딩 된 문자가 포함되지 않도록 보장 할 수있는 경우 (값에 이러한 문자를 사용하는 것은 좋지 않습니다)-다음과 같이 약간 더 간결하고 읽기 쉬운 버전을 사용할 수 있습니다 첫 번째 옵션 중</target>
        </trans-unit>
        <trans-unit id="fcdbaa597bdf669b6d3a9aadfd0cd07941c33e3f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;To access different parts of a URL use &lt;code&gt;location.(search|hash)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;URL의 다른 부분에 액세스하려면 &lt;code&gt;location.(search|hash)&lt;/code&gt; 사용하십시오 . (search | hash)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f83b351211abc22c16148d75edebd637f29484a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tl;dr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tl;dr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd30aeb848f043e7bc0780ef8335c1edf1e6569c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;*!!!&lt;/strong&gt; Please note, that &lt;code&gt;decodeURIComponent(undefined)&lt;/code&gt; returns string &lt;code&gt;&quot;undefined&quot;&lt;/code&gt;. The solution lies in a simple usage of &lt;a href=&quot;https://stackoverflow.com/a/476445/985454&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, which ensures that &lt;code&gt;decodeURIComponent()&lt;/code&gt; is not called on undefined values. &lt;em&gt;(See the &quot;complete solution&quot; at the top.)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;* !!!&lt;/strong&gt; &lt;code&gt;decodeURIComponent(undefined)&lt;/code&gt; 는 문자열 &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; 를 반환합니다. 이 솔루션은 &lt;a href=&quot;https://stackoverflow.com/a/476445/985454&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt; 의 간단한 사용법으로, 정의되지 않은 값에서 &lt;code&gt;decodeURIComponent()&lt;/code&gt; 가 호출되지 않도록합니다. &lt;em&gt;상단의 &quot;완벽한 솔루션&quot;을 참조하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82c314ef57c4ae062d211ee17efada8e14fe8e6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; You can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL&quot;&gt;URL&lt;/a&gt; interface, its quite widely adopted in almost all the new browser and if the code is going to run on an old browser you can use a &lt;a href=&quot;https://github.com/lifaon74/url-polyfill&quot;&gt;polyfill like this one&lt;/a&gt;. Here's a code example on how to use URL interface to get query parameters (aka search parameters)</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL&quot;&gt;URL&lt;/a&gt; 인터페이스를 사용할 수 있습니다 &lt;strong&gt;.&lt;/strong&gt; 거의 모든 새 브라우저에서 널리 채택되어 있으며 코드가 이전 브라우저에서 실행될 경우 &lt;a href=&quot;https://github.com/lifaon74/url-polyfill&quot;&gt;이와 같은 polyfill을&lt;/a&gt; 사용할 수 있습니다. 다음은 URL 인터페이스를 사용하여 검색어 매개 변수 (일명 검색 매개 변수)를 얻는 방법에 대한 코드 예입니다.</target>
        </trans-unit>
        <trans-unit id="37368c978ce40b2560ff00ceca4687bf96ce3bd6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Original&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecbafbd59fd4570e44f14117a16a5c61451c4624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Regex method&lt;/strong&gt;: 13,891 &amp;plusmn;0.85% | 90% slower</source>
          <target state="translated">&lt;strong&gt;정규 법&lt;/strong&gt; : 13,891 &amp;plusmn; 0.85 % | 90 % 느림</target>
        </trans-unit>
        <trans-unit id="8c4b9a8b2c4a548fd785efb0cd2f4af2a0428753" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Split method&lt;/strong&gt;: 144,780 &amp;plusmn;2.17% fastest</source>
          <target state="translated">&lt;strong&gt;스플릿 방식&lt;/strong&gt; : 144,780 &amp;plusmn; 2.17 % 빠름</target>
        </trans-unit>
        <trans-unit id="ded3fa0b81b76721beedb6dd8bacd027baf396b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Testing in Firefox 4.0 x86 on Windows Server 2008 R2 / 7 x64&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Windows Server 2008 R2 / 7 x64의 Firefox 4.0 x86에서 테스트&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ce2743b8a6431574045a5cfe76049b2e91dcb70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;코드:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86ebb9137b90947e20c42d0c415e605c6404bfd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update: Sep-2018&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;업데이트 : 2018 년 9 월&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="010fef2051f010223d5ab89db7012657390a7a99" translate="yes" xml:space="preserve">
          <source>?test=Hello&amp;amp;person=neek&amp;amp;person[]=jeff&amp;amp;person[]=jim&amp;amp;person[extra]=john&amp;amp;test3&amp;amp;nocache=1398914891264</source>
          <target state="translated">?test=Hello&amp;amp;person=neek&amp;amp;person[]=jeff&amp;amp;person[]=jim&amp;amp;person[extra]=john&amp;amp;test3&amp;amp;nocache=1398914891264</target>
        </trans-unit>
        <trans-unit id="534cddb6555e003cb4cf2ec54774ae6f0433e539" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://trac.webkit.org/browser/trunk/Source/WebCore/platform/URLParser.cpp&quot;&gt;reference implementation&lt;/a&gt; and a &lt;a href=&quot;https://googlechrome.github.io/samples/urlsearchparams/&quot;&gt;sample page&lt;/a&gt; are available for auditing and testing.</source>
          <target state="translated">감사 및 테스트를 위해 &lt;a href=&quot;https://trac.webkit.org/browser/trunk/Source/WebCore/platform/URLParser.cpp&quot;&gt;참조 구현&lt;/a&gt; 및 &lt;a href=&quot;https://googlechrome.github.io/samples/urlsearchparams/&quot;&gt;샘플 페이지&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb75f43caf20568ea5a54475c53588e0025cecd3" translate="yes" xml:space="preserve">
          <source>A URL like &lt;code&gt;this.htm?hello=world&amp;amp;foo=bar&lt;/code&gt; will create:</source>
          <target state="translated">&lt;code&gt;this.htm?hello=world&amp;amp;foo=bar&lt;/code&gt; 와 같은 URL은 다음을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8f5555c4a56365aa3ceeaecad41c3ccc587f60d8" translate="yes" xml:space="preserve">
          <source>A new capability would be to retrieve repeated params as following &lt;code&gt;myparam=1&amp;amp;myparam=2&lt;/code&gt;. There is not a &lt;em&gt;specification&lt;/em&gt;, however, most of the current approaches follow the generation of an array.</source>
          <target state="translated">새로운 기능은 &lt;code&gt;myparam=1&amp;amp;myparam=2&lt;/code&gt; 따라 반복되는 매개 변수를 검색하는 것입니다. &lt;em&gt;사양&lt;/em&gt; 은 없지만 현재 접근 방식의 대부분은 어레이 생성을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ec6d389db41af6d8c6899bbe593461bce3cc1e03" translate="yes" xml:space="preserve">
          <source>A quick, &lt;strong&gt;complete solution&lt;/strong&gt;, which handles &lt;strong&gt;multivalued keys&lt;/strong&gt; and &lt;strong&gt;encoded characters&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;다중 값 키&lt;/strong&gt; 및 &lt;strong&gt;인코딩 된 문자&lt;/strong&gt; 를 처리하는 빠르고 &lt;strong&gt;완벽한 솔루션&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ae3d1e955993bf7fcabbb2a74e77168edf22f3bb" translate="yes" xml:space="preserve">
          <source>Access values by &lt;code&gt;qd.key[index]&lt;/code&gt; or &lt;code&gt;qd[key][index]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;qd.key[index]&lt;/code&gt; 또는 &lt;code&gt;qd[key][index]&lt;/code&gt; 의한 액세스 값</target>
        </trans-unit>
        <trans-unit id="800134e33649d3e10c5322da5156cfc33ce3a91e" translate="yes" xml:space="preserve">
          <source>Also, as pointed out in the comments, &lt;code&gt;;&lt;/code&gt; is a legal delimiter for &lt;code&gt;key=value&lt;/code&gt; pairs.  It would require a more complicated regex to handle &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, which I think is unnecessary because it's rare that &lt;code&gt;;&lt;/code&gt; is used and I would say even more unlikely that both would be used.  If you need to support &lt;code&gt;;&lt;/code&gt; instead of &lt;code&gt;&amp;amp;&lt;/code&gt;, just swap them in the regex.</source>
          <target state="translated">또한 의견에서 지적한 바와 같이 &lt;code&gt;;&lt;/code&gt; &lt;code&gt;key=value&lt;/code&gt; 쌍의 올바른 분리 문자입니다. 처리하기 위해서는 더 복잡한 정규식이 필요합니다 &lt;code&gt;;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;&lt;/code&gt; 는 드물기 때문에 불필요하다고 생각합니다 &lt;code&gt;;&lt;/code&gt; 사용되며 둘 다 사용 될 가능성이 훨씬 적습니다. 당신이 지원 해야하는 경우 &lt;code&gt;;&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; 대신 정규식으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="9b1a5e46c3df8cde62fe9534b0b22f5e679a96f9" translate="yes" xml:space="preserve">
          <source>And this is how you can use this function assuming the URL is</source>
          <target state="translated">URL이 다음과 같다고 가정하면이 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4f0914b742d0ac7630df445c3d78b67b44b0c97" translate="yes" xml:space="preserve">
          <source>As you can see above, this version handles some measure of &quot;malformed&quot; arrays, i.e. - &lt;code&gt;person=neek&amp;amp;person[]=jeff&amp;amp;person[]=jim&lt;/code&gt; or &lt;code&gt;person=neek&amp;amp;person=jeff&amp;amp;person=jim&lt;/code&gt; as the key is identifiable and valid (at least in dotNet's &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xsc9a449.aspx&quot;&gt;NameValueCollection.Add&lt;/a&gt;):</source>
          <target state="translated">위에서 볼 수 있듯이,이 버전은 &quot;변형 된&quot;배열의 측정을 처리합니다 &lt;code&gt;person=neek&amp;amp;person[]=jeff&amp;amp;person[]=jim&lt;/code&gt; &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xsc9a449.aspx&quot;&gt;NameValueCollection.Add&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="dec8ec77346ed7b7f3ff2bbef25f1a0c8db47ed4" translate="yes" xml:space="preserve">
          <source>Because of the new HTML History API and specifically &lt;code&gt;history.pushState()&lt;/code&gt; and &lt;code&gt;history.replaceState()&lt;/code&gt;, the URL can change which will invalidate the cache of parameters and their values.</source>
          <target state="translated">새로운 HTML History API와 특히 &lt;code&gt;history.pushState()&lt;/code&gt; 및 &lt;code&gt;history.replaceState()&lt;/code&gt; 때문에 URL이 변경되어 매개 변수 및 해당 값의 캐시가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="c7601f69db91e2da68e2759e88ab4423df8b842b" translate="yes" xml:space="preserve">
          <source>Best of both worlds!</source>
          <target state="translated">두 세계의 최고!</target>
        </trans-unit>
        <trans-unit id="f6ef567d34982fb629b48eb155de70a91ca42847" translate="yes" xml:space="preserve">
          <source>Call it from anywhere in the JavaScript code:</source>
          <target state="translated">JavaScript 코드의 어느 곳에서나 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="127bd0758aa89190daf4785aa8fd97c348d7c230" translate="yes" xml:space="preserve">
          <source>Chrome Announcement and details</source>
          <target state="translated">크롬 발표 및 세부 사항</target>
        </trans-unit>
        <trans-unit id="d620b778592cbeb4a5b4ac786c6c65d353236122" translate="yes" xml:space="preserve">
          <source>Code golf:</source>
          <target state="translated">코드 골프 :</target>
        </trans-unit>
        <trans-unit id="9432d6874c07d2479fb03ed9dbee612f9529e8fd" translate="yes" xml:space="preserve">
          <source>Display it!</source>
          <target state="translated">그것을 표시하십시오!</target>
        </trans-unit>
        <trans-unit id="e3af59b16940b2e81235ebbcb74c7f1a75b7e5e5" translate="yes" xml:space="preserve">
          <source>ES2015 (ES6)</source>
          <target state="translated">ES2015 (ES6)</target>
        </trans-unit>
        <trans-unit id="7dd6c14524660a8e5e3f2fd6bd31287be3272a9e" translate="yes" xml:space="preserve">
          <source>Easiest (dummy) solution</source>
          <target state="translated">가장 쉬운 (더미) 솔루션</target>
        </trans-unit>
        <trans-unit id="c57e24e3995bb2633119f0608031092da0dd2d9f" translate="yes" xml:space="preserve">
          <source>Edit: Adding Deparam Example:</source>
          <target state="translated">편집 : Deparam 추가 예 :</target>
        </trans-unit>
        <trans-unit id="18c8be8be42a7df2abdc4caecc8e7f222e85b9a8" translate="yes" xml:space="preserve">
          <source>Encoded characters?</source>
          <target state="translated">인코딩 된 문자?</target>
        </trans-unit>
        <trans-unit id="ebccf9f9cb0a1762288f48f17418ac002bad85c9" translate="yes" xml:space="preserve">
          <source>Enjoy.</source>
          <target state="translated">Enjoy.</target>
        </trans-unit>
        <trans-unit id="d926fe0cd38e03484b26bb76cf16c4faacb42966" translate="yes" xml:space="preserve">
          <source>Example querystring:</source>
          <target state="translated">쿼리 문자열 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="42fdd8556452808645f749a3a8ccd315a6af2bb6" translate="yes" xml:space="preserve">
          <source>Firefox 44+, Opera 36+, Edge 17+, Safari 10.3+ and Chrome 49+ support the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams&quot;&gt;URLSearchParams&lt;/a&gt; API:</source>
          <target state="translated">Firefox 44 이상, Opera 36 이상, Edge 17 이상, Safari 10.3 이상 및 Chrome 49 이상은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams&quot;&gt;URLSearchParams&lt;/a&gt; API를 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="d9b7c07a3c5cfdfa9c5d333af605afc4ff1a78c7" translate="yes" xml:space="preserve">
          <source>Firefox Announcement and details</source>
          <target state="translated">Firefox 발표 및 세부 사항</target>
        </trans-unit>
        <trans-unit id="673187c6b35ad0483874d48860fc835cb81a3f10" translate="yes" xml:space="preserve">
          <source>For a URL like &lt;code&gt;http://domain.com?param1=val1&amp;amp;param2=val2&lt;/code&gt; you can get their value later in your code as &lt;code&gt;search.param1&lt;/code&gt; and &lt;code&gt;search.param2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;http://domain.com?param1=val1&amp;amp;param2=val2&lt;/code&gt; 와 같은 URL의 경우 나중에 코드에서 &lt;code&gt;search.param1&lt;/code&gt; 및 &lt;code&gt;search.param2&lt;/code&gt; 로 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5726643ceb6991d5c7b82f8641d91a3dc21160e" translate="yes" xml:space="preserve">
          <source>For more information on improvement see: &lt;a href=&quot;http://james.padolsey.com/javascript/bujs-1-getparameterbyname/&quot;&gt;http://james.padolsey.com/javascript/bujs-1-getparameterbyname/&lt;/a&gt;</source>
          <target state="translated">개선에 대한 자세한 정보는 &lt;a href=&quot;http://james.padolsey.com/javascript/bujs-1-getparameterbyname/&quot;&gt;http://james.padolsey.com/javascript/bujs-1-getparameterbyname/을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d35a0dbe25664b0c8564dcb259681703f89b719" translate="yes" xml:space="preserve">
          <source>For the query string &lt;code&gt;x=5&amp;amp;y&amp;amp;z=hello&amp;amp;x=6&lt;/code&gt; this returns the object:</source>
          <target state="translated">쿼리 문자열 &lt;code&gt;x=5&amp;amp;y&amp;amp;z=hello&amp;amp;x=6&lt;/code&gt; 경우 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f99deb5ac65fb0c436f3dcae122f670bf5d9ffad" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/search#Get_the_value_of_a_single_search_param&quot;&gt;the MDN&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/search#Get_the_value_of_a_single_search_param&quot;&gt;MDN에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="45672054ed2b5911b360ccdb67dac8cdb4183687" translate="yes" xml:space="preserve">
          <source>From comments</source>
          <target state="translated">의견에서</target>
        </trans-unit>
        <trans-unit id="4d88cc2da8e2cd7a42dedeacdd26424dc86ef5aa" translate="yes" xml:space="preserve">
          <source>Further reading: &lt;a href=&quot;http://nodejs.org/api/url.html&quot;&gt;&lt;strong&gt;URL Node.js v0.12.2 Manual &amp;amp; Documentation&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">추가 자료 : &lt;a href=&quot;http://nodejs.org/api/url.html&quot;&gt;&lt;strong&gt;URL Node.js v0.12.2 매뉴얼 및 문서&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d2adeea390c506ae0e2b890266a2fe434806983" translate="yes" xml:space="preserve">
          <source>Google method</source>
          <target state="translated">구글 방법</target>
        </trans-unit>
        <trans-unit id="9f297fcf463a0430a0271e161a011ae8210e5605" translate="yes" xml:space="preserve">
          <source>Handles &lt;b&gt;empty keys&lt;/b&gt; correctly.</source>
          <target state="translated">&lt;b&gt;빈 키를&lt;/b&gt; 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b5551916943663f301e56840062b0bb752e1e600" translate="yes" xml:space="preserve">
          <source>Here is a fast way to get an object similar to the PHP &lt;a href=&quot;http://php.net/manual/en/reserved.variables.get.php&quot;&gt;$_GET&lt;/a&gt; array:</source>
          <target state="translated">다음은 PHP &lt;a href=&quot;http://php.net/manual/en/reserved.variables.get.php&quot;&gt;$ _GET&lt;/a&gt; 배열과 유사한 객체를 얻는 빠른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="122778d5e10d1916b1623e116cd8efae6700365a" translate="yes" xml:space="preserve">
          <source>Here's an extended version of Andy E's linked &quot;Handle array-style query strings&quot;-version. Fixed a bug (&lt;code&gt;?key=1&amp;amp;key[]=2&amp;amp;key[]=3&lt;/code&gt;; &lt;code&gt;1&lt;/code&gt; is lost and replaced with &lt;code&gt;[2,3]&lt;/code&gt;), made a few minor performance improvements (re-decoding of values, recalculating &quot;[&quot; position, etc.) and added a number of improvements (functionalized, support for &lt;code&gt;?key=1&amp;amp;key=2&lt;/code&gt;, support for &lt;code&gt;;&lt;/code&gt; delimiters). I left the variables annoyingly short, but added comments galore to make them readable (oh, and I reused &lt;code&gt;v&lt;/code&gt; within the local functions, sorry if that is confusing ;).</source>
          <target state="translated">다음은 Andy E의 링크 된 &quot;핸들 배열 스타일 쿼리 문자열&quot;버전의 확장 버전입니다. 버그 수정 ( &lt;code&gt;?key=1&amp;amp;key[]=2&amp;amp;key[]=3&lt;/code&gt; ; &lt;code&gt;1&lt;/code&gt; 이 유실되고 &lt;code&gt;[2,3]&lt;/code&gt; 으로 대체 됨), 성능이 약간 향상되었습니다 (값 다시 디코딩, &quot;[&quot;위치 재 계산 등) .) 및 여러 가지 개선 사항 (기능화, &lt;code&gt;?key=1&amp;amp;key=2&lt;/code&gt; 지원, &lt;code&gt;;&lt;/code&gt; 구분 기호 지원)을 추가했습니다. 변수를 성가 시게 짧게 두었지만 주석을 추가하여 읽을 수있게했습니다 (오, 지역 함수 내에서 &lt;code&gt;v&lt;/code&gt; 를 재사용했습니다.</target>
        </trans-unit>
        <trans-unit id="132d69cbab8386e3ea447358de1a826cd93d8b77" translate="yes" xml:space="preserve">
          <source>Here's my edit to &lt;a href=&quot;https://stackoverflow.com/questions/901115/get-query-string-values-in-javascript/3855394#3855394&quot;&gt;this excellent answer&lt;/a&gt; - with added ability to parse query strings with keys without values.</source>
          <target state="translated">값이없는 키로 쿼리 문자열을 구문 분석하는 기능이 추가 되어이 &lt;a href=&quot;https://stackoverflow.com/questions/901115/get-query-string-values-in-javascript/3855394#3855394&quot;&gt;훌륭한 답변을&lt;/a&gt; 편집했습니다.</target>
        </trans-unit>
        <trans-unit id="a2f72514d5af613c8a1343fa75d1ec41c2228bf1" translate="yes" xml:space="preserve">
          <source>Here's my stab at making Andy E's excellent solution into a full fledged jQuery plugin:</source>
          <target state="translated">Andy E의 탁월한 솔루션을 본격적인 jQuery 플러그인으로 만드는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da311a8a6a1110d5a8a74129d07303d78a225d20" translate="yes" xml:space="preserve">
          <source>Here's the gist:</source>
          <target state="translated">요점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57d64c7cce2ed91ce4593b1967b05e88d8c4e52b" translate="yes" xml:space="preserve">
          <source>How can I get query string values in JavaScript</source>
          <target state="translated">JavaScript에서 쿼리 문자열 값을 얻는 방법</target>
        </trans-unit>
        <trans-unit id="073e456c905ecba1929fe8e5a12e47b31e6e1796" translate="yes" xml:space="preserve">
          <source>However, as of Nov 11, 2014, Purl is no longer maintained and the author recommends using &lt;a href=&quot;https://github.com/medialize/URI.js&quot;&gt;URI.js&lt;/a&gt; instead.  The jQuery plugin is different in that it focuses on elements - for usage with strings, just use &lt;code&gt;URI&lt;/code&gt; directly, with or without jQuery.  Similar code would look as such, fuller docs &lt;a href=&quot;http://medialize.github.io/URI.js/docs.html&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">그러나 2014 년 11 월 11 일부터 &lt;a href=&quot;https://github.com/medialize/URI.js&quot;&gt;Purl&lt;/a&gt; 은 더 이상 유지 관리되지 않으며 대신 URI.js 를 사용하는 것이 좋습니다. jQuery 플러그인은 요소에 중점을 둔다는 점에서 다릅니다. 문자열을 사용하려면 jQuery를 사용하거나 사용하지 않고 &lt;code&gt;URI&lt;/code&gt; 를 직접 사용하십시오. 비슷한 코드는 다음과 같이 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd67f1c87683773cb062fb7cdf71a5ccf1913a73" translate="yes" xml:space="preserve">
          <source>I like &lt;a href=&quot;http://jquery-howto.blogspot.co.uk/2009/09/get-url-parameters-values-with-jquery.html&quot;&gt;this one&lt;/a&gt; (taken from jquery-howto.blogspot.co.uk):</source>
          <target state="translated">나는 이것을 좋아 &lt;a href=&quot;http://jquery-howto.blogspot.co.uk/2009/09/get-url-parameters-values-with-jquery.html&quot;&gt;한다&lt;/a&gt; (jquery-howto.blogspot.co.uk에서 가져옴) :</target>
        </trans-unit>
        <trans-unit id="363bb9f49518fc8ecdacdffd5ca86ac45604b3df" translate="yes" xml:space="preserve">
          <source>I like &lt;a href=&quot;https://stackoverflow.com/a/3867610/632117&quot;&gt;Ryan Phelan's solution&lt;/a&gt;. But I don't see any point of extending jQuery for that? There is no usage of jQuery functionality.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/3867610/632117&quot;&gt;Ryan Phelan의 솔루션이&lt;/a&gt; 마음에 듭니다 . 그러나 jQuery를 확장 할 시점이 보이지 않습니까? jQuery 기능을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ed3ababc0bcc06aaefdf15cc635cc6c6267e8ac" translate="yes" xml:space="preserve">
          <source>I modified the answer to let it parse a full query string with a hash sign also:</source>
          <target state="translated">해시 기호로 전체 쿼리 문자열을 구문 분석 할 수 있도록 답변을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="f78977c2a64a76e65be51eb67323404b211ae0f6" translate="yes" xml:space="preserve">
          <source>I needed an object from the query string, and I hate lots of code. It may not be the most robust in the universe, but it's just a few lines of code.</source>
          <target state="translated">쿼리 문자열의 객체가 필요했고 많은 코드가 싫어요. 우주에서 가장 강력하지는 않지만 몇 줄의 코드 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="79c201c11a4f3050ad47703f2c293359df401745" translate="yes" xml:space="preserve">
          <source>I use a compressed version of this. I'm posting uncompressed for the novice types to better explain what's going on.</source>
          <target state="translated">압축 버전을 사용합니다. 초보자 유형에 대해 압축되지 않은 게시물을 게시하여 진행 상황을 더 잘 설명하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe807fc0749fd0c20c3a71dfe31c14bd36f7f7f4" translate="yes" xml:space="preserve">
          <source>I use regular expressions a lot, but not for that.</source>
          <target state="translated">나는 정규 표현식을 많이 사용하지만 그렇게하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="000fb25af51395f0a84800bb15d10c9c841933b1" translate="yes" xml:space="preserve">
          <source>I was reading all the previous and more complete answers. But I think that is the simplest and faster method. You can check in this jsPerf &lt;a href=&quot;http://jsperf.com/querystring-with-javascript/9&quot;&gt;benchmark&lt;/a&gt;</source>
          <target state="translated">나는 이전의 모든 더 완전한 답변을 읽고있었습니다. 그러나 나는 이것이 가장 간단하고 빠른 방법이라고 생각합니다. 이 jsPerf &lt;a href=&quot;http://jsperf.com/querystring-with-javascript/9&quot;&gt;벤치 마크&lt;/a&gt; 에서 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="81709ba36cdb825aca04763013dd5dda37e07d80" translate="yes" xml:space="preserve">
          <source>I'm sure this could be optimized or done differently to work faster, but it's always worked great for what I need.</source>
          <target state="translated">나는 이것이 더 빨리 작동하기 위해 최적화되거나 다르게 수행 될 수 있다고 확신하지만, 항상 내가 필요한 것을 위해 훌륭하게 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="7e323860901e9b0b914295e6322a313c21df6b2a" translate="yes" xml:space="preserve">
          <source>If so, how? If not, is there a plugin which can do so?</source>
          <target state="translated">그렇다면 어떻게? 그렇지 않다면 그렇게 할 수있는 플러그인이 있습니까?</target>
        </trans-unit>
        <trans-unit id="87aba79e8f11e4b4acd477862634759b75fb2167" translate="yes" xml:space="preserve">
          <source>If the querystring is empty (&lt;code&gt;location.search == &quot;&quot;&lt;/code&gt;), the result is somewhat misleading &lt;code&gt;qd == {&quot;&quot;: undefined}&lt;/code&gt;. It is suggested to check the querystring before launching the parsing function likeso:</source>
          <target state="translated">쿼리 문자열이 비어있는 경우 ( &lt;code&gt;location.search == &quot;&quot;&lt;/code&gt; ) 결과는 다소 잘못 될 수 있습니다. &lt;code&gt;qd == {&quot;&quot;: undefined}&lt;/code&gt; . 다음과 같이 구문 분석 기능을 시작하기 전에 쿼리 문자열을 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5aca1f5b15e8c5d7b1cb2718573d533ad324f54f" translate="yes" xml:space="preserve">
          <source>If the specified key already exists in the target NameValueCollection
  instance, the specified value is added to the existing comma-separated
  list of values in the form &quot;value1,value2,value3&quot;.</source>
          <target state="translated">지정된 키가 대상 NameValueCollection 인스턴스에 이미 존재하면 지정된 값이 &quot;value1, value2, value3&quot;형식으로 기존 쉼표로 구분 된 값 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0d0ec74a4bd389a70f2b8e1935ba62040b6af4fd" translate="yes" xml:space="preserve">
          <source>If you are using Browserify, you can use the &lt;code&gt;url&lt;/code&gt; module from &lt;em&gt;Node.js&lt;/em&gt;:</source>
          <target state="translated">Browserify를 사용하는 경우 &lt;em&gt;Node.js&lt;/em&gt; 의 &lt;code&gt;url&lt;/code&gt; 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a08d83cae1fd213bd82c23598b693c45b55526ff" translate="yes" xml:space="preserve">
          <source>If you want to just use plain JavaScript, you could use...</source>
          <target state="translated">일반 JavaScript 만 사용하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f0ffeb6654f3a7ffee450af8c3ae2d36b6c0f96" translate="yes" xml:space="preserve">
          <source>If you're doing more URL manipulation than simply parsing the querystring, you may find &lt;a href=&quot;http://medialize.github.com/URI.js/&quot;&gt;URI.js&lt;/a&gt; helpful. It is a library for manipulating URLs - and comes with all the bells and whistles. (Sorry for self-advertising here)</source>
          <target state="translated">단순히 쿼리 문자열을 구문 분석하는 것보다 더 많은 URL 조작을 수행하는 경우 &lt;a href=&quot;http://medialize.github.com/URI.js/&quot;&gt;URI.js가&lt;/a&gt; 도움이 될 수 있습니다. URL 조작을위한 라이브러리이며 모든 종과 휘파람이 함께 제공됩니다. (자기 광고는 죄송합니다)</target>
        </trans-unit>
        <trans-unit id="7996f9d8b0383e2d7a8670d2db775c6478909055" translate="yes" xml:space="preserve">
          <source>If you're using a server-side preprocessing language, you might want to use its native JSON functions to do the heavy lifting for you.  For example, in PHP you can write:</source>
          <target state="translated">서버 측 사전 처리 언어를 사용하는 경우 기본 JSON 기능을 사용하여 많은 작업을 수행 할 수 있습니다. 예를 들어, PHP에서는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39c12b406e4e97742d8a76681a2e11ac2c322406" translate="yes" xml:space="preserve">
          <source>If you're using jQuery, you can use a library, such as &lt;a href=&quot;http://benalman.com/projects/jquery-bbq-plugin/&quot;&gt;jQuery BBQ: Back Button &amp;amp; Query Library&lt;/a&gt;.</source>
          <target state="translated">jQuery를 사용하는 경우 &lt;a href=&quot;http://benalman.com/projects/jquery-bbq-plugin/&quot;&gt;jQuery BBQ : Back Button &amp;amp; Query Library&lt;/a&gt; 와 같은 라이브러리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b9f279ab9b93c15e7732d7f6d0361b677684684" translate="yes" xml:space="preserve">
          <source>Improved version of &lt;a href=&quot;https://stackoverflow.com/questions/901115/get-querystring-values-with-jquery/901144#901144&quot;&gt;Artem Barger's answer&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/901115/get-querystring-values-with-jquery/901144#901144&quot;&gt;Artem Barger의 답변&lt;/a&gt; 개선 버전 :</target>
        </trans-unit>
        <trans-unit id="939c1360971f05361232aa1dfc51bcd0c83027a3" translate="yes" xml:space="preserve">
          <source>In the end the object &lt;code&gt;d&lt;/code&gt; is returned, handling escaping and the &lt;code&gt;+&lt;/code&gt; sign. This object is just like mine, it has the same behavior.</source>
          <target state="translated">결국 이스케이프 처리와 &lt;code&gt;+&lt;/code&gt; 부호를 처리하여 객체 &lt;code&gt;d&lt;/code&gt; 가 반환됩니다. 이 개체는 내 것과 똑같습니다. 같은 동작을합니다.</target>
        </trans-unit>
        <trans-unit id="0a3a442417df5b0f3e26ff5302d80065b36fef84" translate="yes" xml:space="preserve">
          <source>Is there a plugin-less way of retrieving &lt;a href=&quot;http://en.wikipedia.org/wiki/Query_string&quot;&gt;query string&lt;/a&gt; values via jQuery (or without)?</source>
          <target state="translated">jQuery를 통해 (또는 제외) &lt;a href=&quot;http://en.wikipedia.org/wiki/Query_string&quot;&gt;쿼리 문자열&lt;/a&gt; 값을 검색하는 플러그인이없는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="c942434e52be1941f81f456d259d83650c2fc586" translate="yes" xml:space="preserve">
          <source>It can be used with or without jQuery.</source>
          <target state="translated">jQuery를 사용하거나 사용하지 않고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06449a1fc73d65df535617b5ae6f0aea504907b9" translate="yes" xml:space="preserve">
          <source>It is a simple library method that does dissection and manipulation of URL parameters. The static method has the following sub methods that can be called on the subject URL:</source>
          <target state="translated">URL 매개 변수의 해부 및 조작을 수행하는 간단한 라이브러리 메소드입니다. 정적 메소드에는 주제 URL에서 호출 할 수있는 다음과 같은 하위 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e11c918dadbe3781578fcc20c66a0f1e853ea947" translate="yes" xml:space="preserve">
          <source>It is not standardized by &lt;a href=&quot;https://www.w3.org/TR/2014/WD-url-1-20141209/#interface-urlsearchparams&quot;&gt;W3C&lt;/a&gt;, but it is a living standard by &lt;a href=&quot;https://url.spec.whatwg.org&quot;&gt;WhatWG&lt;/a&gt;.</source>
          <target state="translated">그것은 &lt;a href=&quot;https://www.w3.org/TR/2014/WD-url-1-20141209/#interface-urlsearchparams&quot;&gt;W3C&lt;/a&gt; 에 의해 표준화되지 않았지만, &lt;a href=&quot;https://url.spec.whatwg.org&quot;&gt;WhatWG에&lt;/a&gt; 의해 살아있는 표준입니다.</target>
        </trans-unit>
        <trans-unit id="11cddc7dd95111cd35e184f50fed79b8c617b9c9" translate="yes" xml:space="preserve">
          <source>It is obfuscated, but it is understandable. It does not work because some variables are undefined.</source>
          <target state="translated">난독 화되지만 이해할 수 있습니다. 일부 변수가 정의되지 않았기 때문에 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e5326ea293b648dfb498c4737b71c49593fa53a" translate="yes" xml:space="preserve">
          <source>It seems &lt;a href=&quot;https://stackoverflow.com/questions/1746507/authoritative-position-of-duplicate-http-get-query-keys&quot;&gt;the jury is somewhat out&lt;/a&gt; on repeated keys as there is no spec. In this case, multiple keys are stored as an (fake)array. But do note that I &lt;strong&gt;do not&lt;/strong&gt; process values based on commas into arrays.</source>
          <target state="translated">스펙이 없기 때문에 &lt;a href=&quot;https://stackoverflow.com/questions/1746507/authoritative-position-of-duplicate-http-get-query-keys&quot;&gt;배심원이&lt;/a&gt; 반복되는 키에 다소 빠져있는 것 같습니다. 이 경우 여러 키가 (가짜) 배열로 저장됩니다. 그러나 쉼표를 기준으로 값을 배열로 처리 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5bc0d0c64bbf99b1a4ec89d5518cf19ec4b55828" translate="yes" xml:space="preserve">
          <source>It seems easier and more efficient to me to read the query string once in my application, and build an object from all the key/value pairs like:</source>
          <target state="translated">내 응용 프로그램에서 쿼리 문자열을 한 번 읽고 다음과 같은 모든 키 / 값 쌍에서 객체를 작성하는 것이 더 쉽고 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="0d9e0072af909d8f1dbe2a8be04403380e6913da" translate="yes" xml:space="preserve">
          <source>It will handle the following querystring...</source>
          <target state="translated">다음 쿼리 문자열을 처리합니다 ...</target>
        </trans-unit>
        <trans-unit id="e57f582326a196e279b0369debf208ce142e0c47" translate="yes" xml:space="preserve">
          <source>Just added that capability also while adding in  the return statement</source>
          <target state="translated">return 문을 추가하면서 해당 기능을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="5e57982a4f0bbf6468c5fe9a3ecd05a947ccd049" translate="yes" xml:space="preserve">
          <source>Just another recommendation. The plugin &lt;em&gt;&lt;a href=&quot;https://github.com/allmarkedup/jQuery-URL-Parser&quot;&gt;Purl&lt;/a&gt;&lt;/em&gt; allows to retrieve all parts of URL, including anchor, host, etc.</source>
          <target state="translated">또 다른 권장 사항입니다. 플러그인 &lt;em&gt;&lt;a href=&quot;https://github.com/allmarkedup/jQuery-URL-Parser&quot;&gt;Purl을&lt;/a&gt;&lt;/em&gt; 사용하면 앵커, 호스트 등을 포함하여 URL의 모든 부분을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39775219f019850e5b5d67c91544fdf0f2873408" translate="yes" xml:space="preserve">
          <source>Just call &lt;code&gt;var langval = $.urlParam('lang');&lt;/code&gt;, and you've got it.</source>
          <target state="translated">&lt;code&gt;var langval = $.urlParam('lang');&lt;/code&gt; 그리고 당신은 그것을 얻었다.</target>
        </trans-unit>
        <trans-unit id="f7157d509275674f6d5ecbec37fbd08893a281d2" translate="yes" xml:space="preserve">
          <source>Just use two &lt;strong&gt;splits&lt;/strong&gt;:</source>
          <target state="translated">두 개의 &lt;strong&gt;분할을&lt;/strong&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f207b9e49068d57e814e520cfce9889714432e57" translate="yes" xml:space="preserve">
          <source>Keep it simple in plain JavaScript code:</source>
          <target state="translated">일반 JavaScript 코드로 간단하게 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="41d3f0ba4eb4a4f6a8f2357e3f45a9724879b4b6" translate="yes" xml:space="preserve">
          <source>Much simpler!</source>
          <target state="translated">훨씬 간단합니다!</target>
        </trans-unit>
        <trans-unit id="c31c16bf28a87dd39c0cc7ceabf8f26f194b95d5" translate="yes" xml:space="preserve">
          <source>Multi-lined:</source>
          <target state="translated">Multi-lined:</target>
        </trans-unit>
        <trans-unit id="7a470436b960c7bdafbae4ddd2230b6507d78309" translate="yes" xml:space="preserve">
          <source>Multi-valued keys</source>
          <target state="translated">다중 값 키</target>
        </trans-unit>
        <trans-unit id="1a2c48fe1b52e0d77aca5bf7ab544676b4a8ef74" translate="yes" xml:space="preserve">
          <source>My method as a &lt;strong&gt;jQuery plugin&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery 플러그인&lt;/strong&gt; 으로서의 방법</target>
        </trans-unit>
        <trans-unit id="ffe0cab36ad398551d537199d563d31ff53d5e3b" translate="yes" xml:space="preserve">
          <source>NOTE: The function is case-sensitive. If you prefer case-insensitive parameter name, &lt;a href=&quot;https://stackoverflow.com/questions/3939715/case-insensitive-regex-in-javascript&quot;&gt;add 'i' modifier to RegExp&lt;/a&gt;</source>
          <target state="translated">참고 :이 기능은 대소 문자를 구분합니다. 대소 문자를 구분하지 않는 매개 변수 이름을 선호하는 경우 &lt;a href=&quot;https://stackoverflow.com/questions/3939715/case-insensitive-regex-in-javascript&quot;&gt;RegExp에 'i'수정자를 추가하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e342d9ceee97455375446a33c725d14171eb5e6e" translate="yes" xml:space="preserve">
          <source>Note: If a parameter is present several times (&lt;code&gt;?foo=lorem&amp;amp;foo=ipsum&lt;/code&gt;), you will get the first value (&lt;code&gt;lorem&lt;/code&gt;). There is no standard about this and usages vary, see for example this question: &lt;a href=&quot;https://stackoverflow.com/questions/1746507/authoritative-position-of-duplicate-http-get-query-keys&quot;&gt;Authoritative position of duplicate HTTP GET query keys&lt;/a&gt;.</source>
          <target state="translated">참고 : 매개 변수가 여러 번있는 경우 ( &lt;code&gt;?foo=lorem&amp;amp;foo=ipsum&lt;/code&gt; ) 첫 번째 값 ( &lt;code&gt;lorem&lt;/code&gt; )을 얻습니다. 이에 대한 표준은 없으며 사용법은 다양합니다. 예를 들어 다음 질문을 참조하십시오. &lt;a href=&quot;https://stackoverflow.com/questions/1746507/authoritative-position-of-duplicate-http-get-query-keys&quot;&gt;중복 HTTP GET 쿼리 키의 신뢰할 수있는 위치&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43c7a3ea7253466a37057cb8334c7958806eb6df" translate="yes" xml:space="preserve">
          <source>Now returns &lt;b&gt;arrays&lt;/b&gt; instead.</source>
          <target state="translated">이제 대신 &lt;b&gt;배열&lt;/b&gt; 을 반환 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c2471f4da04fb01da16baeda4a33cd4ee040e3f0" translate="yes" xml:space="preserve">
          <source>Now you can find the updated gist:</source>
          <target state="translated">이제 업데이트 된 요점을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c9422d5c4a86cebd5de145afc04796575bbd229" translate="yes" xml:space="preserve">
          <source>On my Mac: &lt;code&gt;test.htm?i=can&amp;amp;has=cheezburger&lt;/code&gt; displays</source>
          <target state="translated">내 Mac : &lt;code&gt;test.htm?i=can&amp;amp;has=cheezburger&lt;/code&gt; 디스플레이</target>
        </trans-unit>
        <trans-unit id="537ef0f2a672534b79397686a0f2fa1d74fc14bd" translate="yes" xml:space="preserve">
          <source>On the other hand, I like the built-in function in Google Chrome: window.location.getParameter.</source>
          <target state="translated">반면에 Chrome의 내장 기능인 window.location.getParameter가 마음에 듭니다.</target>
        </trans-unit>
        <trans-unit id="c052a09c90643f5d3c0aaba27402c7eb0eada351" translate="yes" xml:space="preserve">
          <source>Opera Announcement and details</source>
          <target state="translated">오페라 발표 및 세부 사항</target>
        </trans-unit>
        <trans-unit id="cca8e52d510a96977a45bd9f72c787c66c876e61" translate="yes" xml:space="preserve">
          <source>Or of course on any URL:</source>
          <target state="translated">또는 물론 모든 URL에서 :</target>
        </trans-unit>
        <trans-unit id="10f363b735c302f44ed620411c0930ff6b35fe62" translate="yes" xml:space="preserve">
          <source>Overrides &lt;b&gt;multi-keys&lt;/b&gt; with &lt;b&gt;last&lt;/b&gt; value found.</source>
          <target state="translated">&lt;b&gt;마지막&lt;/b&gt; 값을 찾은 &lt;b&gt;다중 키&lt;/b&gt; 를 재 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7557ddf49eda41f29918181441555cb4d277e0a3" translate="yes" xml:space="preserve">
          <source>Preparation code: methods declaration</source>
          <target state="translated">준비 코드 : 메소드 선언</target>
        </trans-unit>
        <trans-unit id="3c53c636d12f95e9beeb95725e1c43c7ac0031f3" translate="yes" xml:space="preserve">
          <source>Read more... about the Vanilla JavaScript solution.</source>
          <target state="translated">Vanilla JavaScript 솔루션에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="4752dd2f39ea7d253016f5d35abab9eaeb1d3de4" translate="yes" xml:space="preserve">
          <source>Regex test code</source>
          <target state="translated">정규식 테스트 코드</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="9be8504a8f678e5d59f7566150005d5cb3768376" translate="yes" xml:space="preserve">
          <source>Roshambo jQuery method wasn't taking care of decode URL</source>
          <target state="translated">Roshambo jQuery 메소드가 URL 디코딩을 처리하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="8bb4d1b06e6b852b3d6f7e8520515eddd31556bc" translate="yes" xml:space="preserve">
          <source>Roshambo on snipplr.com has a simple script to achieve this described in &lt;em&gt;&lt;a href=&quot;http://snipplr.com/view/26662/get-url-parameters-with-jquery--improved/&quot;&gt;Get URL Parameters with jQuery | Improved&lt;/a&gt;&lt;/em&gt;. With his script you also easily get to pull out just the parameters you want.</source>
          <target state="translated">snipplr.com의 Roshambo &lt;em&gt;&lt;a href=&quot;http://snipplr.com/view/26662/get-url-parameters-with-jquery--improved/&quot;&gt;에는 jQuery를 사용하여 URL 매개 변수&lt;/a&gt;&lt;/em&gt; 가져 오기 &lt;em&gt;|&lt;/em&gt; &lt;em&gt;향상되었습니다&lt;/em&gt; . 그의 스크립트를 사용하면 원하는 매개 변수를 쉽게 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ac9fbbc9dc3ce88122248070ff14cced35c8d0" translate="yes" xml:space="preserve">
          <source>Simple key check &lt;code&gt;(item in dict) ? dict.item.push(val) : dict.item = [val]&lt;/code&gt;</source>
          <target state="translated">간단한 키 검사 &lt;code&gt;(item in dict) ? dict.item.push(val) : dict.item = [val]&lt;/code&gt; dict.item.push (val) : dict.item = [val]</target>
        </trans-unit>
        <trans-unit id="8aa02fb18be713e7da4cba6773249b7b4dff0f2d" translate="yes" xml:space="preserve">
          <source>So if the URL/query string was &lt;code&gt;xyz.com/index.html?lang=de&lt;/code&gt;.</source>
          <target state="translated">URL / 쿼리 문자열이 &lt;code&gt;xyz.com/index.html?lang=de&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="27c01f6d15e1f792a4740307f0513b452fa04ff4" translate="yes" xml:space="preserve">
          <source>So if you know you won't run into Rup's counter-case, this wins. Otherwise, regexp.</source>
          <target state="translated">당신이 Rup의 반대 사건에 부딪치지 않을 것이라는 것을 안다면, 이것이 이깁니다. 그렇지 않으면 regexp.</target>
        </trans-unit>
        <trans-unit id="8436af2669db42bebb74a68489289c5b91e668ca" translate="yes" xml:space="preserve">
          <source>So what exactly changed? With url &lt;code&gt;http://sb.com/reg/step1?param=&lt;/code&gt; results will be same. But with url &lt;code&gt;http://sb.com/reg/step1?param&lt;/code&gt; Bruno's solution returns an object without keys, while mine returns an object with key &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; value.</source>
          <target state="translated">정확히 무엇이 바뀌 었습니까? URL이 &lt;code&gt;http://sb.com/reg/step1?param=&lt;/code&gt; 인 경우 결과는 동일합니다. 그러나 URL이 &lt;code&gt;http://sb.com/reg/step1?param&lt;/code&gt; 인 브루노의 솔루션은 키가없는 객체를 반환하는 반면 광산은 키 &lt;code&gt;param&lt;/code&gt; 있고 &lt;code&gt;undefined&lt;/code&gt; 값을 가진 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9759c5e93ea70521574ed63522a86d62feb12cfd" translate="yes" xml:space="preserve">
          <source>So why not to use this? Okay, other browsers don't have. So let's create this function if it does not exist:</source>
          <target state="translated">왜 이것을 사용하지 않습니까? 다른 브라우저에는 없습니다. 이 함수가 존재하지 않으면 작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="a0f08300b4e6c071a2da3c87dc7c8ab283896891" translate="yes" xml:space="preserve">
          <source>So, this is the approach to manage it:</source>
          <target state="translated">따라서 이것이 관리하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="275598542ca0a399c37db60c2c8233f7564d0237" translate="yes" xml:space="preserve">
          <source>Some of the solutions posted here are inefficient. Repeating the regular expression search every time the script needs to access a parameter is completely unnecessary, one single function to split up the parameters into an associative-array style object is enough. If you're not working with the HTML 5 History API, this is only necessary once per page load.  The other suggestions here also fail to decode the URL correctly.</source>
          <target state="translated">여기에 게시 된 솔루션 중 일부는 비효율적입니다. 스크립트가 매개 변수에 액세스해야 할 때마다 정규 표현식 검색을 반복하는 것은 완전히 불필요합니다. 매개 변수를 연관 배열 스타일 오브젝트로 분할하는 단일 함수로는 충분합니다. HTML 5 히스토리 API로 작업하지 않는 경우 페이지로드 당 한 번만 필요합니다. 여기에있는 다른 제안은 URL을 올바르게 디코딩하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="62669f1c0f3a400a1cdf3d2361e05585135d5429" translate="yes" xml:space="preserve">
          <source>Split test code</source>
          <target state="translated">분할 테스트 코드</target>
        </trans-unit>
        <trans-unit id="cae4ef2c7ff69f37950b90d84019dc33390b37e0" translate="yes" xml:space="preserve">
          <source>Tearing Google's code I found the method they use: &lt;code&gt;getUrlParameters&lt;/code&gt;</source>
          <target state="translated">Google 코드를 찢어 나는 그들이 사용하는 방법을 찾았습니다 : &lt;code&gt;getUrlParameters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49c72239751b2e412597c78b117d3a3b7483ac0c" translate="yes" xml:space="preserve">
          <source>The problem with the top answer on that question is that it's not-supported parameters placed after #, but sometimes it's needed to get this value also.</source>
          <target state="translated">이 질문에 대한 가장 큰 대답은 # 뒤에 붙은 지원되지 않는 매개 변수이지만 때로는이 값을 가져와야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="869d833f9b3336891a11a67fcd142e1caac2f566" translate="yes" xml:space="preserve">
          <source>The syntax is:</source>
          <target state="translated">구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf7022789844fe203ac43cfc1a2b12c5aefad738" translate="yes" xml:space="preserve">
          <source>Then just get your parameters from the query string.</source>
          <target state="translated">그런 다음 쿼리 문자열에서 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="638840f34b22b5ae9b66bd9c24c447b9e15dd740" translate="yes" xml:space="preserve">
          <source>There is a google-suggested &lt;strong&gt;&lt;a href=&quot;https://github.com/WebReflection/url-search-params&quot;&gt;URLSearchParams polyfill&lt;/a&gt;&lt;/strong&gt; for the stable versions of IE.</source>
          <target state="translated">안정적인 버전의 IE를위한 Google 추천 &lt;strong&gt;&lt;a href=&quot;https://github.com/WebReflection/url-search-params&quot;&gt;URLSearchParams 폴리 필&lt;/a&gt;&lt;/strong&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e886cc5a12cf11b6338ae8af68acdfe43fdead94" translate="yes" xml:space="preserve">
          <source>These are all great answers, but I needed something a bit more robust, and thought you all might like to have what I created.</source>
          <target state="translated">이것들은 모두 훌륭한 답변이지만, 좀 더 강력한 것이 필요했고, 내가 만든 것을 갖고 싶을 수도 있다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="a843b1bdd4230f8b19e0d45e0269d3d8533abf96" translate="yes" xml:space="preserve">
          <source>They start to look for parameters on the url from &lt;code&gt;?&lt;/code&gt; and also from the hash &lt;code&gt;#&lt;/code&gt;. Then for each parameter they split in the equal sign &lt;code&gt;b[f][p](&quot;=&quot;)&lt;/code&gt; (which looks like &lt;code&gt;indexOf&lt;/code&gt;, they use the position of the char to get the key/value). Having it split they check whether the parameter has a value or not, if it has then they store the value of &lt;code&gt;d&lt;/code&gt;, otherwise they just continue.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 에서 URL의 매개 변수를 찾기 시작합니다 . 그리고 또한 해시 &lt;code&gt;#&lt;/code&gt; 에서 . 그런 다음 각 매개 변수에 대해 등호 &lt;code&gt;b[f][p](&quot;=&quot;)&lt;/code&gt; 분할됩니다 ( &lt;code&gt;indexOf&lt;/code&gt; 와 같이 문자의 위치를 ​​사용하여 키 / 값을 가져옵니다). 분할하면 매개 변수에 값이 있는지 여부를 확인하고 값이 있으면 &lt;code&gt;d&lt;/code&gt; 값을 저장합니다. 그렇지 않으면 계속 진행합니다.</target>
        </trans-unit>
        <trans-unit id="e5f177b7dc70f30062b86a2e4b48e1574fe4fe3b" translate="yes" xml:space="preserve">
          <source>This could easily be improved upon to handle array-style query strings too.  An example of this is &lt;a href=&quot;http://jsbin.com/adali3/2&quot;&gt;here&lt;/a&gt;, but since array-style parameters aren't defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; I won't pollute this answer with the source code. &lt;a href=&quot;https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/23401756#23401756&quot;&gt;For those interested in a &quot;polluted&quot; version, look at campbeln's answer below&lt;/a&gt;.</source>
          <target state="translated">배열 스타일 쿼리 문자열도 처리하도록 쉽게 개선 할 수 있습니다. 이것의 예는 &lt;a href=&quot;http://jsbin.com/adali3/2&quot;&gt;here&lt;/a&gt; 이지만 배열 스타일 매개 변수가 &lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986에&lt;/a&gt; 정의되어 있지 않으므로이 답변을 소스 코드로 오염시키지 않습니다. &lt;a href=&quot;https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/23401756#23401756&quot;&gt;&quot;오염 된&quot;버전에 관심이있는 사람들은 아래의 campbeln의 답변을보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="785fbe088ab7b929831fb85238315c9b070e6dd2" translate="yes" xml:space="preserve">
          <source>This function is more or less from Ryan Phelan, but it is wrapped differently: clear name and no dependencies of other javascript libraries. &lt;a href=&quot;http://sharepointkunskap.wordpress.com/2012/01/11/get-url-parameters-with-javascript/&quot;&gt;More about this function on my blog&lt;/a&gt;.</source>
          <target state="translated">이 함수는 Ryan Phelan과 다소 다르지만 다른 자바 스크립트 라이브러리의 명확한 이름과 종속성이 없습니다. &lt;a href=&quot;http://sharepointkunskap.wordpress.com/2012/01/11/get-url-parameters-with-javascript/&quot;&gt;내 블로그에서이 기능에 대해 자세히 알아보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70ce98195ff8aa37fd7abebc93e808753cb4ebbd" translate="yes" xml:space="preserve">
          <source>This is a function I created a while back and I'm quite happy with. It is not case sensitive - which is handy. Also, if the requested QS doesn't exist, it just returns an empty string.</source>
          <target state="translated">이것은 내가 옛날에 만든 기능이며 꽤 행복합니다. 대소 문자를 구분하지 않으므로 편리합니다. 또한 요청 된 QS가 존재하지 않으면 빈 문자열 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="880f4163a15c8a19d4b57d0b69c2302c39bea48a" translate="yes" xml:space="preserve">
          <source>This is an update based on the new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams&quot;&gt;URLSearchParams specs&lt;/a&gt; to achieve the same result more succinctly. See answer titled &quot;&lt;a href=&quot;https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/901144#12151322&quot;&gt;URLSearchParams&lt;/a&gt;&quot; below.</source>
          <target state="translated">새로운 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams&quot;&gt;URLSearchParams 사양&lt;/a&gt; 을 기반으로 한 업데이트로 더 간결하게 동일한 결과를 얻을 수 있습니다. 아래의 &quot; &lt;a href=&quot;https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/901144#12151322&quot;&gt;URLSearchParams&lt;/a&gt; &quot;라는 답변을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9db0bc0a8c58c3017b8ec738697d3bd06ce2780" translate="yes" xml:space="preserve">
          <source>This version will update its internal cache of parameters each time the history changes.</source>
          <target state="translated">이 버전은 기록이 변경 될 때마다 내부 매개 변수 캐시를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="0e7fc00961b74dd24ca9653ed04641900be663c2" translate="yes" xml:space="preserve">
          <source>To solve the problem in Rup's comment, add a conditional split by changing the first line to the two below. But absolute accuracy means it's now slower than regexp (see &lt;a href=&quot;http://jsperf.com/querystring-with-javascript/10&quot;&gt;jsPerf&lt;/a&gt;).</source>
          <target state="translated">Rup의 의견에서 문제를 해결하려면 첫 번째 줄을 아래 두 줄로 변경하여 조건부 분할을 추가하십시오. 그러나 절대 정확도는 이제 regexp보다 느립니다 ( &lt;a href=&quot;http://jsperf.com/querystring-with-javascript/10&quot;&gt;jsPerf&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="47b23b39759a1908e680a0a3b5cb3c99d6de735e" translate="yes" xml:space="preserve">
          <source>UPDATED</source>
          <target state="translated">UPDATED</target>
        </trans-unit>
        <trans-unit id="b19e8d66e7f004e226c44a75766dadab7d09911a" translate="yes" xml:space="preserve">
          <source>URLSearchParams</source>
          <target state="translated">URLSearchParams</target>
        </trans-unit>
        <trans-unit id="5a8cd4a189f53053616ff5571c7cf39afe0885c1" translate="yes" xml:space="preserve">
          <source>UZBEKJON has a great blog post on this as well, &lt;em&gt;&lt;a href=&quot;http://jquery-howto.blogspot.com/2009/09/get-url-parameters-values-with-jquery.html&quot;&gt;Get URL parameters &amp;amp; values with jQuery&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">UZBEKJON에는 이것에 대한 훌륭한 블로그 게시물이 있습니다. &lt;em&gt;&lt;a href=&quot;http://jquery-howto.blogspot.com/2009/09/get-url-parameters-values-with-jquery.html&quot;&gt;jQuery를 사용하여 URL 매개 변수 및 값을 가져옵니다&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="b93fb7a6a3be201a9ffddb0c9abd27f858aee537" translate="yes" xml:space="preserve">
          <source>Usage is very simple and cool:</source>
          <target state="translated">사용법은 매우 간단하고 시원합니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="392df2a166f2f52393355ae22d0307f078b54728" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;decodeURIComponent()&lt;/code&gt; for the second &lt;em&gt;or both&lt;/em&gt; splits.</source>
          <target state="translated">두 번째 &lt;em&gt;또는 두&lt;/em&gt; 스플릿 &lt;em&gt;모두에&lt;/em&gt; &lt;code&gt;decodeURIComponent()&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ff3e16b2ce3562cdd238525776f9c4ebc2eef93c" translate="yes" xml:space="preserve">
          <source>We've just released &lt;a href=&quot;https://github.com/stretchr/arg.js&quot;&gt;arg.js&lt;/a&gt;, a project aimed at solving this problem once and for all.  It's traditionally been so difficult but now you can do:</source>
          <target state="translated">우리는 방금이 문제를 해결하기위한 프로젝트 &lt;a href=&quot;https://github.com/stretchr/arg.js&quot;&gt;arg.js를&lt;/a&gt; 출시 했습니다 . 전통적으로 너무 어려웠지만 이제는 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3804ffce841dd1b7f21366c2ef0fdde6c5bf130" translate="yes" xml:space="preserve">
          <source>What is all this code...</source>
          <target state="translated">이 코드는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e49acedde6c2da878b9e79c1a9d7df57c479b9c3" translate="yes" xml:space="preserve">
          <source>With an URL like &lt;code&gt;?topic=123&amp;amp;name=query+string&lt;/code&gt;, the following will return:</source>
          <target state="translated">&lt;code&gt;?topic=123&amp;amp;name=query+string&lt;/code&gt; 과 같은 URL을 사용하면 다음이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0c0a59fb074de0fc1fd7cee2f49870f337cc9102" translate="yes" xml:space="preserve">
          <source>Without jQuery</source>
          <target state="translated">jQuery없이</target>
        </trans-unit>
        <trans-unit id="3ae633fca7fc3cfcefb10e9095e623c1e577d05b" translate="yes" xml:space="preserve">
          <source>Works great for me.</source>
          <target state="translated">나를 위해 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dffd535ef0186fa22439ec59e86712413ad1b9a1" translate="yes" xml:space="preserve">
          <source>You can also use URLSearchParams for it, here's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#Example&quot;&gt;an example from MDN&lt;/a&gt; to do it with URLSearchParams:</source>
          <target state="translated">URLSearchParams를 사용할 수도 있습니다. 다음은 URLSearchParams로 수행하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#Example&quot;&gt;MDN의 예입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ede7842007a910025b46477a4c81da92b054e8c" translate="yes" xml:space="preserve">
          <source>You can get params also using a shorthand &lt;code&gt;.searchParams&lt;/code&gt; property on the URL object, like this:</source>
          <target state="translated">URL 객체에서 속기 &lt;code&gt;.searchParams&lt;/code&gt; 속성을 사용하여 다음과 같이 매개 변수를 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bec4d2ce8c312b81ed4ea34a1fa6877786b84da0" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#Browser_compatibility&quot;&gt;URLSearchParams&lt;/a&gt; which is simple and has &lt;a href=&quot;https://caniuse.com/#feat=urlsearchparams&quot;&gt;decent (but not complete) browser support&lt;/a&gt;.</source>
          <target state="translated">간단하고 &lt;a href=&quot;https://caniuse.com/#feat=urlsearchparams&quot;&gt;완벽하지만 브라우저를 지원하지 않는&lt;/a&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#Browser_compatibility&quot;&gt;URLSearchParams&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a2e5e1b0d7dd97f755e9e72aa22014f827c6086" translate="yes" xml:space="preserve">
          <source>You can use it on &lt;code&gt;location&lt;/code&gt;:</source>
          <target state="translated">당신은 &lt;code&gt;location&lt;/code&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="95636b19872bae2965f8a7b844f3b33edcc8ab4d" translate="yes" xml:space="preserve">
          <source>You don't need jQuery for that purpose. You can use just some pure JavaScript:</source>
          <target state="translated">그런 목적으로 jQuery가 필요하지 않습니다. 순수한 JavaScript 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4deb33adf10380e08f4a933d326aeb7a6b90323" translate="yes" xml:space="preserve">
          <source>You read/set parameters through the &lt;code&gt;get(KEY)&lt;/code&gt;, &lt;code&gt;set(KEY, VALUE)&lt;/code&gt;, &lt;code&gt;append(KEY, VALUE)&lt;/code&gt; API. You can also iterate over all values &lt;code&gt;for (let p of params) {}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get(KEY)&lt;/code&gt; , &lt;code&gt;set(KEY, VALUE)&lt;/code&gt; , &lt;code&gt;append(KEY, VALUE)&lt;/code&gt; API를 통해 매개 변수를 읽거나 설정합니다. &lt;code&gt;for (let p of params) {}&lt;/code&gt; 모든 값 을 반복 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="838bd1bcefa13f29010a286f1eadbaf9c144650a" translate="yes" xml:space="preserve">
          <source>and if you care about the difference between &lt;code&gt;?query=true&lt;/code&gt; and &lt;code&gt;#hash=true&lt;/code&gt; then you can use the &lt;code&gt;Arg.query()&lt;/code&gt; and &lt;code&gt;Arg.hash()&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;?query=true&lt;/code&gt; 와 &lt;code&gt;#hash=true&lt;/code&gt; 의 차이점에 관심이 있다면 &lt;code&gt;Arg.query()&lt;/code&gt; 및 &lt;code&gt;Arg.hash()&lt;/code&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d063002e0b1cd2adbddcbf212619985781f96479" translate="yes" xml:space="preserve">
          <source>getHash</source>
          <target state="translated">getHash</target>
        </trans-unit>
        <trans-unit id="be7ccc1402c4ef7b03a97cb983978c3793e26812" translate="yes" xml:space="preserve">
          <source>getHost</source>
          <target state="translated">getHost</target>
        </trans-unit>
        <trans-unit id="b5a5fe44454826c283f4f56097f59524379aa727" translate="yes" xml:space="preserve">
          <source>getParam</source>
          <target state="translated">getParam</target>
        </trans-unit>
        <trans-unit id="403e8e0a2033d5412408c1b64b782d5f1c1d95be" translate="yes" xml:space="preserve">
          <source>getParams</source>
          <target state="translated">getParams</target>
        </trans-unit>
        <trans-unit id="bc119b82b82560bad5a3f6cf69db9444b34ebfb6" translate="yes" xml:space="preserve">
          <source>getPath</source>
          <target state="translated">getPath</target>
        </trans-unit>
        <trans-unit id="3bd6d0bd1635786a7175c813be113edac076e2e1" translate="yes" xml:space="preserve">
          <source>getQuery</source>
          <target state="translated">getQuery</target>
        </trans-unit>
        <trans-unit id="3fd57351e3f02a8a8053535c9bdee5b0fa524726" translate="yes" xml:space="preserve">
          <source>hasParam</source>
          <target state="translated">hasParam</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="e325bd97642094b3751758dabdc4840b6401c0ea" translate="yes" xml:space="preserve">
          <source>or getting the whole lot:</source>
          <target state="translated">또는 전체를 얻는 것 :</target>
        </trans-unit>
        <trans-unit id="97a8e0547c911e89290749777617372f2ee2216a" translate="yes" xml:space="preserve">
          <source>removeParam</source>
          <target state="translated">removeParam</target>
        </trans-unit>
        <trans-unit id="2a01642660f3da69300df25564329261a463dac4" translate="yes" xml:space="preserve">
          <source>setHash</source>
          <target state="translated">setHash</target>
        </trans-unit>
        <trans-unit id="8abd850531e327fb74f340d4cef8d080c94e5580" translate="yes" xml:space="preserve">
          <source>setParam</source>
          <target state="translated">setParam</target>
        </trans-unit>
        <trans-unit id="b2407cb2215024ae653dbf5a158744f770da9e61" translate="yes" xml:space="preserve">
          <source>to convert your querystring into a map:</source>
          <target state="translated">검색어를지도로 변환하는 방법 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
