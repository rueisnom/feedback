<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3730019">
    <body>
      <group id="3730019">
        <trans-unit id="09f0a3718fc85408fc3968cd3e73ec142bfdf8e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finally Java has a standard way to work with Currency And Money!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로 Java에는 Currency And Money를 사용하는 표준 방법이 있습니다!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="067ffcb87cbcca8f5deb07e1edf7236614c5c3f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Bloch, J., Effective Java, 2nd ed, Item 48:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bloch, J., Effective Java, 2nd ed, 항목 48에서 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5f6e9fc67eabeb616ef60d5d06c36cdfa7f7379" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSR 354: Money and Currency API&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354 : 화폐 및 통화 API&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f766b6007bcacd14501e3d6f2ddefc6012c887b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sample Examples of JSR 354: Money and Currency API:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354의 샘플 예 : Money and Currency API :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e2aae1a87e35a4fa14d5b8e07a14c874d3e8731" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The specification consists of the following things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사양은 다음과 같이 구성됩니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="279d8b6ec4347409e3a31f9d1293b292eba50459" translate="yes" xml:space="preserve">
          <source>A solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt; class, and C# has the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx&quot;&gt;&lt;code&gt;decimal&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;거의 모든 언어로 작동하는 솔루션은 정수를 대신 사용하고 센트를 계산하는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 1025는 $ 10.25입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 언어에는 돈을 처리하기위한 내장 유형이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무엇보다도 Java에는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스가 있고 C #에는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx&quot;&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="717c89d37aca9bbeaf61dacfbd6ecf66a6ac4cf6" translate="yes" xml:space="preserve">
          <source>APIs to support interchangeable implementations</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상호 교환 가능한 구현을 지원하는 API&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="764e3868719a642a94e9c1db3b2399ade06cc23d" translate="yes" xml:space="preserve">
          <source>All specification classes and interfaces are located in the javax.money.* package.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 사양 클래스와 인터페이스는 javax.money. * 패키지에 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf91636fa17ae4579edcdf37d35ebfd293f2b61f" translate="yes" xml:space="preserve">
          <source>Also, there might be situations when you're tempted to use Double wrappers as a map key with hash map being the implementation. It is very risky because Double.equals and hash code for example values &quot;0.5&quot; &amp;amp; &quot;0.6 - 0.1&quot; will cause a big mess.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 이중 래퍼를 해시 맵이 구현 된 맵 키로 사용하려는 경우가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Double.equals 및 해시 코드 (예 : 값 &quot;0.5&quot;및 &quot;0.6-0.1&quot;)가 큰 혼란을 초래하기 때문에 매우 위험합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf754cbdda51fd0330c49df312d2b9c5513b384b" translate="yes" xml:space="preserve">
          <source>An API for handling e. g. monetary amounts and currencies</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;화폐 금액 및 통화 처리를위한 API&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="47f68da097e3b1b2f17304cdd296e6c8b747eb0d" translate="yes" xml:space="preserve">
          <source>An example of creating a MonetaryAmount and printing it to the console looks like this::</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MonetaryAmount를 작성하여 콘솔에 인쇄하는 예는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c7ad5819035e16732c5be390d7fe2b3aaf867a68" translate="yes" xml:space="preserve">
          <source>Arbitrary precision won't help because there always can be numbers that has so many decimal places, or some results such as &lt;code&gt;0.6666666&lt;/code&gt;... No arbitrary representation will cover the last example. So you will have small errors in each step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소수점 이하 자릿수가 너무 많은 숫자 나 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.6666666&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 같은 결과가 항상있을 수 있기 때문에 임의 정밀도는 도움이되지 않습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 각 단계마다 작은 오류가 발생합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2e27a448c1442df8dbf814d07126dae13f3ba4b" translate="yes" xml:space="preserve">
          <source>As said earlier &quot;Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, you&amp;rsquo;ll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;앞서 언급했듯이 소프트웨어가 작은 오류를 반올림하면 돈을 이중 또는 부동으로 표시하는 것이 처음에는 좋아 보일 것입니다. 이로 인해 10 개의 기본 거듭 제곱의 배수에 대한 완벽한 정확도가 필요한 돈을 처리하기에는 플로트와 배가 부적절합니다. &quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b08a01dc6c5fc3334a18152f819d33b8eda77206" translate="yes" xml:space="preserve">
          <source>Assume you want to round something to the nearest penny.  So you take your final result, multiply by 100, add 0.5, truncate, then divide the result by 100 to get back to pennies.  If the internal number you stored was 3.46499999.... instead of 3.465, you are going to get 3.46 instead 3.47 when you round the number to the nearest penny.  But your base 10 calculations may have indicated that the answer should be 3.465 exactly, which clearly should round up to 3.47, not down to 3.46.  These kinds of things happen occasionally in real life when you use doubles for financial calculations.  It is rare, so it often goes unnoticed as an issue, but it happens.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가장 가까운 페니로 반올림한다고 가정하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 최종 결과에 100을 곱하고 0.5를 더한 다음 잘라낸 다음 결과를 100으로 나누어 페니로 돌아갑니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;저장 한 내부 번호가 3.465 대신 3.46499999 .... 인 경우 가장 가까운 페니로 반올림하면 3.47 대신 3.47이됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 기본 10 계산은 답이 정확히 3.465 여야하며, 3.46이 아닌 3.47로 올림해야한다는 것을 나타냅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 종류의 일은 재무 계산에 복식을 사용할 때 실제 생활에서 가끔 발생합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;드물기 때문에 종종 문제로 눈에 띄지 않지만 발생합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="686314d64dfd1b19bdb75704e3275be9ef46537d" translate="yes" xml:space="preserve">
          <source>Because floats and doubles cannot accurately represent the base 10 multiples that we use for money. This issue isn't just for Java, it's for any programming language that uses base 2 floating-point types.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;float와 double은 우리가 돈을 위해 사용하는 기본 10 배수를 정확하게 나타낼 수 없기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 문제는 Java만을위한 것이 아니라 기본 2 부동 소수점 유형을 사용하는 모든 프로그래밍 언어에 관한 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d774a91c3005dbfc9d51d54db8523611c0c80ee8" translate="yes" xml:space="preserve">
          <source>BigDecimal in Java is native to the Java language.
Apfloat is another arbitrary-precision library for Java.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java의 BigDecimal은 Java 언어에 고유합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Apfloat은 Java를위한 또 다른 임의 정밀도 라이브러리입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b94819d8ebaaf6c31dbcb3e0507caf9b63c974e0" translate="yes" xml:space="preserve">
          <source>Coming from a non-computer science background (physics and engineering), I tend to look at problems from a different perspective. For me, the reason why I wouldn't use a double or float in a mathematical calculation is that I would lose too much information.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴퓨터 과학이 아닌 배경 (물리 및 공학)에서 나온 문제를 다른 관점에서 보는 경향이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나에게 수학 계산에서 double 또는 float을 사용하지 않는 이유는 너무 많은 정보를 잃어 버릴 수 있기 때문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="677ba35d3f4b7ef97f05e8f12a39a698e653703d" translate="yes" xml:space="preserve">
          <source>Concluding, in my opinion the double is unsuitable mostly for its 16 digit precision, which can be insufficient, not because it is approximate.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결론적으로, 이중은 16 자리 정밀도에 부적합하며, 이는 대략적이기 때문에 충분하지 않을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0545f3890164845c72010b8e0ed6d58da24b6375" translate="yes" xml:space="preserve">
          <source>Consider the following output of the subsequent program. It shows that after rounding double give the same result as BigDecimal up to precision 16.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;후속 프로그램의 다음 출력을 고려하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;double 반올림 후 BigDecimal과 동일한 결과를 정밀도 16까지 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e5741882b583d222d3509526f6535f0aca560bcc" translate="yes" xml:space="preserve">
          <source>CurrencyUnit and MonetaryAmount</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;통화 단위 및 통화 금액&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a39fe455337c4b0e4fe8c05f871b35046753359b" translate="yes" xml:space="preserve">
          <source>Custom MonetaryAmount operations</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용자 정의 통화 금액 조작&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3332fa176aea702f236b003b8db2099175e7e9fe" translate="yes" xml:space="preserve">
          <source>Documentation:
  &lt;a href=&quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&quot;&gt;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문서 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="381e479c3588e94e6153168dcc0099a4c7380509" translate="yes" xml:space="preserve">
          <source>Even if you round off your results at the last minute before output, you can still occasionally get a result using doubles that does not match expectations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;출력 전 마지막 순간에 결과를 반올림하더라도 예상과 일치하지 않는 배가를 사용하여 결과를 얻을 수있는 경우가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="739138cb0e4f13fdb2a14bb54aa2436816c625fd" translate="yes" xml:space="preserve">
          <source>Even in base 10, this notation cannot accurately represent most simple fractions. For instance, you can't represent 1/3: the decimal representation is repeating (0.3333...), so there is no finite integer that you can multiply by a power of 10 to get 1/3. You could settle on a long sequence of 3's and a small exponent, like 333333333 * 10&lt;sup&gt;-10&lt;/sup&gt;, but it is not accurate: if you multiply that by 3, you won't get&amp;nbsp;1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;밑이 10 인 경우에도이 표기법은 가장 간단한 분수를 정확하게 나타낼 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 1/3을 표현할 수 없습니다. 10 진수 표현이 반복되고 (0.3333 ...), 10의 거듭 제곱에 곱하여 1/3을 구할 수있는 유한 정수는 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;333333333 * 10 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-10&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 같이 3의 긴 시퀀스와 작은 지수를 정할 수는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있지만 정확하지는 않습니다. 3을 곱하면 1을 얻지 못합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee1869b094937e9a8826f16f45c31d79373b5f4c" translate="yes" xml:space="preserve">
          <source>Examples of using Joda Money:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joda Money 사용 예 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b5072184cf44d5fe99ebc445de8723c52dba90a9" translate="yes" xml:space="preserve">
          <source>Factories for creating instances of the implementation classes</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현 클래스의 인스턴스를 작성하기위한 팩토리&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="40dd3f8de5b5b29b2f97def0749ce28de01e7855" translate="yes" xml:space="preserve">
          <source>Floats and doubles are approximate. If you create a BigDecimal and pass a float into the constructor you see what the float actually equals:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;플로트와 복식은 근사치입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigDecimal을 만들고 float를 생성자에 전달하면 float이 실제로 같은 것을 볼 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f91c4b87711bc72d9c507486005d248573dcd071" translate="yes" xml:space="preserve">
          <source>For example COBOL, historically used for financial calculations, has a maximum precision of 18 figures. So there is often an implicit rounding.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 역사적으로 재무 계산에 사용 된 COBOL의 최대 정밀도는 18입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 암시 적 반올림이 종종 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75c807d28a864927acb8b31d7d3c8ac580f2b9cc" translate="yes" xml:space="preserve">
          <source>For example, suppose you have $1.03
  and you spend 42c. How much money do
  you have left?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, $ 1.03이고 42c를 소비한다고 가정하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;돈이 얼마나 남았습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9de791eaf216bc3b590abee4d7754d4d8c9d03e5" translate="yes" xml:space="preserve">
          <source>For me, I like BigDecimal because of the methods it supports. C#'s decimal is very nice, but I haven't had the chance to work with it as much as I'd like. I do scientific calculations of interest to me in my spare time, and BigDecimal seems to work very well because I can set the precision of my floating point numbers. The disadvantage to BigDecimal? It can be slow at times, especially if you're using the divide method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;저에게는 BigDecimal이 지원하는 방법 때문에 BigDecimal을 좋아합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C #의 10 진수는 매우 좋지만 원하는만큼 사용할 수있는 기회가 없었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 여가 시간에 과학적으로 관심있는 계산을 수행하며 BigDecimal은 부동 소수점 숫자의 정밀도를 설정할 수 있기 때문에 잘 작동하는 것 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigDecimal의 단점은 무엇입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히 나누기 방법을 사용하는 경우 시간이 느려질 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1596c5466820636637e428d747fe6a6fbee306e" translate="yes" xml:space="preserve">
          <source>Functionality for calculations, conversion and formatting of monetary            amounts</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;금액 계산, 변환 및 서식 지정 기능&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b834495da73d80490ba3f5f0af039bcb1529bbb2" translate="yes" xml:space="preserve">
          <source>Handling money and currencies in Java with JSR 354</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354를 사용하여 Java에서 돈과 통화 처리&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a6c98689987bf69175f5b0dbd14419ab2e195b3" translate="yes" xml:space="preserve">
          <source>However, for the purpose of counting money, at least for countries whose money is valued within an order of magnitude of the US dollar, usually all you need is to be able to store multiples of 10&lt;sup&gt;-2&lt;/sup&gt;, so it doesn't really matter that 1/3 can't be represented.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 돈을 세는 목적으로, 적어도 돈이 미국 달러의 규모 내에서 가치가있는 국가의 경우 보통 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10-2의&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 배수를 저장할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있기 때문에 중요하지 않습니다. 1/3은 표현할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9545c9929da7e9a99ecf7b11d62ec5571358a4ac" translate="yes" xml:space="preserve">
          <source>I have worked on a number of projects with very low gc requirements, and having BigDecimal objects was a big contributor to that overhead.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 gc 요구 사항이 매우 낮은 많은 프로젝트를 수행했으며 BigDecimal 객체를 갖는 것이 그 오버 헤드에 큰 기여를했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="20bcc3b9e6b736283080cd8b942be6364f880be5" translate="yes" xml:space="preserve">
          <source>I'll risk being downvoted, but I think the unsuitability of floating point numbers for currency calculations is overrated. As long as you make sure you do the cent-rounding correctly and have enough significant digits to work with in order to counter the binary-decimal representation mismatch explained by zneak, there will be no problem.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하향 조정될 위험이 있지만 통화 계산에 부동 소수점 숫자가 부적당하다고 생각합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;zneak에 의해 설명 된 2 진법 표현 불일치를 해결하기 위해 센트 반올림을 올바르게 수행하고 작업하기에 충분한 유효 자릿수가있는 한 문제는 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3e4618f2467db822b69c46c1fea719a017d4735" translate="yes" xml:space="preserve">
          <source>I'm not a computer scientist by training. However, I tend to lean towards either BigDecimal in Java or decimal in C#. I haven't tried the other solutions I've listed, but they are probably very good as well.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;저는 훈련을받은 컴퓨터 과학자가 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 Java의 BigDecimal 또는 C #의 10 진수에 의존하는 경향이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 열거 한 다른 솔루션을 시도하지는 않았지만 아마도 매우 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="990e7012ab72470facd01fe2c1a1f5d51c224ba0" translate="yes" xml:space="preserve">
          <source>I'm sure there is a very good reason, I simply do not know what it is.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 아주 좋은 이유가 있다고 확신합니다. 나는 그것이 무엇인지 모릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0b640dfe453f9fe28f4de0716c715e5b4b78fa5a" translate="yes" xml:space="preserve">
          <source>I'm troubled by some of these responses.  I think doubles and floats have a place in financial calculations.  Certainly, when adding and subtracting non-fractional monetary amounts there will be no loss of precision when using integer classes or BigDecimal classes.  But when performing more complex operations, you often end up with results that go out several or many decimal places, no matter how you store the numbers.  The issue is how you present the result.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 이러한 응답 중 일부에 어려움을 겪고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 복식과 수레가 재무 계산에 자리를 잡고 있다고 생각합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;확실히, 분수가 아닌 화폐 금액을 더하고 뺄 때 정수 클래스 또는 BigDecimal 클래스를 사용할 때 정밀도가 손실되지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 더 복잡한 연산을 수행 할 때 숫자를 저장하는 방법에 관계없이 종종 소수 또는 소수 자릿수로 끝나는 결과가 나타납니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문제는 결과를 제시하는 방법입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="98375c7c8b2a2005748c2b911a76c4dfe8d20dc1" translate="yes" xml:space="preserve">
          <source>I've always been told &lt;em&gt;never&lt;/em&gt; to represent money with &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; types, and this time I pose the question to you: why?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 항상 &lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;돈을 대표 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 말라고 들었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이번에 나는 당신에게 질문을합니다. 왜?&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fcd023b4c00bf2e3b4db4e2b3bfa19a5930150d9" translate="yes" xml:space="preserve">
          <source>If you use base 10 for your internal calculations instead of doubles, the answers are always exactly what is expected by humans, assuming no other bugs in your code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;배가 아닌 내부 계산에 기수 10을 사용하면 코드에 다른 버그가 없다고 가정 할 때 항상 사람이 기대하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d316acf25caa86b6df1ed932c3fdc12985946bb" translate="yes" xml:space="preserve">
          <source>If your computation involves various steps, arbitrary precision arithmetic won't cover you 100%.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계산에 다양한 단계가 포함 된 경우 임의 정밀도 연산은 100 %를 포함하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7358b1f7336f90ad39312beb48de9d969908dbe0" translate="yes" xml:space="preserve">
          <source>If your result is on the borderline between being rounded up and rounded down, and that last penny really matters, you should be probably be telling the viewer that the answer is nearly in the middle - by displaying more decimal places.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결과가 반올림과 반올림 사이의 경계선에 있고 마지막 페니가 실제로 중요하다면, 소수 자릿수를 더 많이 표시하여 답변이 거의 중간에 있음을 시청자에게 알려 주어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89ee989c518fd96a85c276fbbcc76f3a0d201bc3" translate="yes" xml:space="preserve">
          <source>Implementation examples:
  &lt;a href=&quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&quot;&gt;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현 예 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80417b3d4f9b43eb6ff3dba9201d4b848e5acc31" translate="yes" xml:space="preserve">
          <source>In base 10, you can write 10.25 as 1025 * 10&lt;sup&gt;-2&lt;/sup&gt; (an integer times a power of 10). &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE-754 floating-point numbers&lt;/a&gt; are different, but a very simple way to think about them is to multiply by a power of two instead. For instance, you could be looking at 164 * 2&lt;sup&gt;-4&lt;/sup&gt; (an integer times a power of two), which is also equal to 10.25. That's not how the numbers are represented in memory, but the math implications are the same.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10 진법에서는 10.25를 1025 * &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10-2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (정수 곱하기 10의 거듭 제곱) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로 쓸 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IEEE-754 부동 소수점 숫자&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 다르지만이를 생각하는 매우 간단한 방법은 2의 거듭 제곱을 곱하는 것입니다. 예를 들어 164 * 2 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-4&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (정수 곱하기 2의 거듭 제곱)를 볼 수 있으며 10.25와 같습니다. 그것이 숫자가 메모리에 표현되는 방식은 아니지만 수학적인 의미는 동일합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f85da357aa1787e92299ea8764dc8f1081d232a" translate="yes" xml:space="preserve">
          <source>It doesn't mean though that doubles can never be used for that purpose.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복식을 절대 그 목적으로 사용할 수는 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="189a0c254a5f6366cf960591b4dcd1af6677fec2" translate="yes" xml:space="preserve">
          <source>It must be said that even if you use fixed point arithmetic you still have to round numbers, were it not for the fact that BigInteger and BigDecimal give errors if you obtain periodic decimal numbers. So there is an approximation also here.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고정 소수점 산술을 사용하더라도 여전히 숫자를 반올림해야하는데,주기적인 10 진수를 얻는 경우 BigInteger 및 BigDecimal에서 오류가 발생하지 않기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에도 근사치가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04b2d7d7bcbb29484271eba8aaf54f4b4bc5cc56" translate="yes" xml:space="preserve">
          <source>It requires Java SE 8 or later and has no dependencies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java SE 8 이상이 필요하며 종속성이 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24d35c472f26d6b1a31b545ab3b7165c01d595eb" translate="yes" xml:space="preserve">
          <source>It's not that the error isn't controllable if you round: &lt;a href=&quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html&quot;&gt;see this article by Peter Lawrey&lt;/a&gt;. It's just easier not to have to round in the first place. Most applications that handle money don't call for a lot of math, the operations consist of adding things or allocating amounts to different buckets. Introducing floating point and rounding just complicates things.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반올림하면 오류를 제어 할 수있는 것은 아닙니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Peter Lawrey의이 기사를 참조하십시오&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;처음에는 반올림하지 않아도 더 쉽습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;돈을 처리하는 대부분의 응용 프로그램은 많은 수학을 요구하지 않습니다. 작업은 물건을 추가하거나 다른 버킷에 금액을 할당하는 것으로 구성됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부동 소수점과 반올림을 도입하면 문제가 복잡해집니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bd1736b140bbc0f9b6f105c77291011f013e232" translate="yes" xml:space="preserve">
          <source>It's the lack of understanding about double representation and lack of experience in handling the accuracy and precision that brings about this wise suggestion.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이중 표현에 대한 이해 부족과이 현명한 제안을 제공하는 정확성과 정밀도 처리 경험이 부족합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2da89442de0564adb263d4b217cde992b04f1ff9" translate="yes" xml:space="preserve">
          <source>JSR 354 provides an API for representing, transporting, and performing comprehensive calculations with Money and Currency. You can download it from this link:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354는 Money and Currency를 사용하여 포괄적 인 계산을 표현, 전송 및 수행하기위한 API를 제공합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 링크에서 다운로드 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f51b176f17789e90549d24d66d084d0377ef75a" translate="yes" xml:space="preserve">
          <source>JSR 354: Money and Currency API Download</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354 : 화폐 및 통화 API 다운로드&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e355bd15d23282effb75249c47fc6278e186ca1e" translate="yes" xml:space="preserve">
          <source>Java API for working with Money and Currencies, which is planned to be included in Java 9.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 9에 포함될 예정인 Money and Currencies 작업을위한 Java API&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70d2f01c0479a64ac9a018a01053853a4ccc0a04" translate="yes" xml:space="preserve">
          <source>Looking into the Java 9 Money and Currency API (JSR 354)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 9 Money and Currency API 살펴보기 (JSR 354)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cbc716194c3421d45328f11b1ed734e714f9a899" translate="yes" xml:space="preserve">
          <source>Many of the answers posted to this question discuss IEEE and the standards surrounding floating-point arithmetic.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 질문에 게시 된 많은 답변은 IEEE와 부동 소수점 산술 관련 표준에 대해 설명합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cafddb4a8f868576fbd86b950274e809cab58f05" translate="yes" xml:space="preserve">
          <source>MonetaryAmount has various methods that allow accessing the assigned currency, the numeric amount, its precision and more:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MonetaryAmount에는 지정된 통화, 숫자 금액, 정밀도 등을 액세스 할 수있는 다양한 방법이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c047041987b7e92d7fd573c5e62c0f30a2b8bd4" translate="yes" xml:space="preserve">
          <source>MonetaryAmounts can be rounded using a rounding operator:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반올림 연산자를 사용하여 금액을 반올림 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0cd10f02a4e801b3f271ae2d36c791ac844e9895" translate="yes" xml:space="preserve">
          <source>Most answers have highlighted the reasons why one should not use doubles for money and currency calculations. And I totally agree with them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 답변은 돈과 통화 계산에 복식을 사용해서는 안되는 이유를 강조했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 나는 그들에게 완전히 동의합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c0a7d98a17c7e3d1315cdf1e4024b71e84be895" translate="yes" xml:space="preserve">
          <source>OUTPUT:</source>
          <target state="translated">OUTPUT:</target>
        </trans-unit>
        <trans-unit id="ab03dc913e6f18c3df668c4f3c27fc3d1b767a73" translate="yes" xml:space="preserve">
          <source>Of course, you have to stay within reason; e.g. a simple webshop would probably never experience any problem with double precision floats, but if you do e.g. accounting or anything else that requires adding a large (unrestricted) amount of numbers, you wouldn't want to touch floating point numbers with a ten foot pole.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론, 당신은 이성 안에 머물러 있어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 간단한 웹숍은 배정 밀도 부동 소수점에 문제가 발생하지 않지만 회계 또는 많은 양의 (제한되지 않은) 숫자를 추가 해야하는 다른 작업을 수행하는 경우 10 피트로 부동 소수점 숫자를 만지고 싶지 않습니다. 폴.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="893e9390628cf8793e980bd5c0bc3d738246634a" translate="yes" xml:space="preserve">
          <source>People calculating with currency in Excel have always used double precision floats (there is no currency type in Excel) and I have yet to see anyone complaining about rounding errors.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Excel에서 통화로 계산하는 사람들은 항상 배정 밀도 부동 소수점을 사용했으며 (Excel에는 통화 유형이 없습니다) 반올림 오류에 대해 불평하는 사람은 아직 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ce0f4ca9377352ec33a36acf2c838b95f364a475" translate="yes" xml:space="preserve">
          <source>Representing money as a &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, errors will compound and you'll end up with values that are visibly not accurate. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소프트웨어가 작은 오류를 반올림하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;돈을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 표현하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것이 처음에는 좋아 보일 것입니다. 정확하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이로 인해 10 개의 기본 거듭 제곱의 완벽한 정확도가 필요한 돈을 처리하기에 플로트와 배가 부적절합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90bdbcb63d1c58de798fcf3d27eefa22f192272c" translate="yes" xml:space="preserve">
          <source>Resources:</source>
          <target state="translated">Resources:</target>
        </trans-unit>
        <trans-unit id="7466c0c80238bbd71329492766d1f91a178140c9" translate="yes" xml:space="preserve">
          <source>SciPy (Scientific Python) can probably also handle financial calculations (I haven't tried, but I suspect so).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SciPy (Scientific Python)는 아마도 재무 계산을 처리 할 수도 있습니다 (시도하지는 않았지만 그렇게 생각합니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="72dd135113af4bb32b27d846ec53778eaebee82f" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;http://javamoney.github.io/&quot;&gt;JSR 354 - Currency and Money&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 사항도 참조 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://javamoney.github.io/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354-통화 및 돈&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f7a401d25dd853ca7105588312147327477a4a5" translate="yes" xml:space="preserve">
          <source>Some example... this works (actually don't work as expected), on almost any programming language... I've tried with Delphi, VBScript, Visual Basic, JavaScript and now with Java/Android:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;몇 가지 예 ... 이것은 거의 모든 프로그래밍 언어에서 작동합니다 (실제로 예상대로 작동하지 않습니다) ... 나는 Delphi, VBScript, Visual Basic, JavaScript로 시도했지만 이제는 Java / Android로 시도했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa9645f2ab1c2cb679f21b70df5c102fb0e3e6be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; types are
  particularly ill-suited for monetary
  calculations because it is impossible
  to represent 0.1 (or any other
  negative power of ten) as a &lt;code&gt;float&lt;/code&gt; or
  &lt;code&gt;double&lt;/code&gt; exactly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 종류가 특히 금전 계산에 부적당된다는 0.1를 표현하는 것은 불가능하다 (또는 임의의 다른 열 음극 전원)을 같은 때문에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 정확하게.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37a22ebd44711311bb4fb92a4282d607da8596f5" translate="yes" xml:space="preserve">
          <source>The API also supports calculations with MonetaryAmounts:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;API는 MonetaryAmounts를 사용한 계산도 지원합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="84a8cc07b8a6e7ce2ce3275b890a5f8a8f30b899" translate="yes" xml:space="preserve">
          <source>The GNU Multiple Precision Library (GMP) and the GNU MFPR Library are two free and open-source resources for C and C++.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GMP (GNU Multiple Precision Library) 및 GNU MFPR 라이브러리는 C 및 C ++를위한 2 개의 무료 오픈 소스 리소스입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdef8dba5555ec0beb2b9902e32847ed7611acbb" translate="yes" xml:space="preserve">
          <source>The decimal data type in C# is Microsoft's .NET alternative for 28 significant figures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C #의 10 진수 데이터 형식은 28 개의 유효 숫자에 대한 Microsoft의 .NET 대안입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5383c20d2d17e96881c2fda340145ff07c98074b" translate="yes" xml:space="preserve">
          <source>The only reliable way to use a perfect representation of results(Use a custom Fraction data type that will batch division operations to the last step) and only convert to decimal notation in the last step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완벽한 결과 표현을 사용하는 신뢰할 수있는 유일한 방법 (마지막 단계로 나누기 작업을 수행하는 사용자 지정 분수 데이터 형식 사용)은 마지막 단계에서 10 진수 표기법으로 만 변환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="197911d6c1e58965b7e6611a80d150d7ba686aac" translate="yes" xml:space="preserve">
          <source>The problem is that the IEEE spec doesn't have a way to exactly represent all fractions, some of them end up as repeating fractions so you end up with approximation errors. Since accountants like things to come out exactly to the penny, and customers will be annoyed if they pay their bill and after the payment is processed they owe .01 and they get charged a fee or can't close their account, it's better to use exact types like decimal (in C#) or java.math.BigDecimal in Java.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문제는 IEEE 사양에 모든 분수를 정확하게 표현할 수있는 방법이 없으며, 일부는 반복 분수로 끝나기 때문에 근사 오차가 발생한다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;회계사가 정확히 1 페니로 나올 것을 좋아하고 고객이 청구서를 지불하면 고객이 화가 나고 지불이 처리 된 후 .01을 지불해야하며 수수료가 부과되거나 계정을 폐쇄 할 수 없으므로 사용하는 것이 좋습니다 소수점 이하 자릿수 (C #) 또는 Java의 java.math.BigDecimal과 같은 정확한 유형&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b28f5a973c1343f529f0e63c534d0921c6ab0947" translate="yes" xml:space="preserve">
          <source>The problem with doubles, and more so with floats, is when they are used to combine large numbers and small numbers.  In java,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;복식의 문제, 그리고 수레의 문제는 큰 숫자와 작은 숫자를 결합하는 데 사용되는 경우입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자바에서는&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5b6a4d54cc02b1c3f15e40c24f65fff30e4810f1" translate="yes" xml:space="preserve">
          <source>The problem with floats and doubles is that the &lt;em&gt;vast majority&lt;/em&gt; of money-like numbers don't have an exact representation as an integer times a power of 2. In fact, the only multiples of 0.01 between 0 and 1 (which are significant when dealing with money because they're integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount. As an analogy to the 0.333333 example, if you take the floating-point value for 0.1 and you multiply it by&amp;nbsp;10, you won't get&amp;nbsp;1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;와 복식의 문제는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 돈과 같은 숫자가 정수 곱하기 2의 정수로 정확하게 표현되지 않는다는 것입니다. 실제로 0과 1 사이의 0.01의 배수는 (만약 다룰 때 중요합니다) IEEE-754 이진 부동 소수점 숫자로 정확하게 표현할 수있는 정수 센트이므로 돈으로) 0, 0.25, 0.5, 0.75 및 1입니다. 나머지는 모두 소량입니다. 0.333333 예제와 유사하게 0.1의 부동 소수점 값을 가져 와서 10을 곱하면 1이되지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e74e7a3acd980ae3a6baa90e220277c25718108" translate="yes" xml:space="preserve">
          <source>The result of floating point number is not exact, which makes them unsuitable for any financial calculation which requires exact result and not approximation. float and double are designed for engineering and scientific calculation and many times doesn&amp;rsquo;t produce exact result also result of floating point calculation may vary from JVM to JVM. Look at below example of BigDecimal and double primitive which is used to represent money value, its quite clear that floating point calculation may not be exact and one should use BigDecimal for financial calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부동 소수점 숫자의 결과는 정확하지 않으므로 정확한 결과가 필요하고 근사값이 아닌 재무 계산에 적합하지 않습니다. float 및 double은 공학 및 과학 계산 용으로 설계되었으며 여러 번 정확한 결과를 얻지 못하며 부동 소수점 계산 결과는 JVM마다 다를 수 있습니다. 돈 가치를 나타내는 데 사용되는 BigDecimal 및 double primitive의 예를 아래에서 살펴보십시오. 부동 소수점 계산이 정확하지 않을 수 있으며 재무 계산에 BigDecimal을 사용해야한다는 것이 분명합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24ddbedc3035313f2130f7d0cddfdf7f8cd294c6" translate="yes" xml:space="preserve">
          <source>The right way to solve this problem is
  to use &lt;code&gt;BigDecimal&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;
  for monetary calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 문제를 해결하는 올바른 방법 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 통화 계산에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;long&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 사용하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e52742575fd81008db5aa9d17b762ab92432faf" translate="yes" xml:space="preserve">
          <source>There are also numerical precision libraries for JavaScript(!) and I think PHP which can handle financial calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JavaScript (!)에 대한 수치 정밀도 라이브러리도 있으며 재무 계산을 처리 할 수있는 PHP라고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="371fa31f57b417924581fe94e899a89df47b64eb" translate="yes" xml:space="preserve">
          <source>There are also proprietary (particularly, I think, for Fortran) and open-source solutions as well for many computer languages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 컴퓨터 언어뿐만 아니라 독점적 인 (특히 Fortran의 경우) 공개 소스 솔루션도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21e4ce282247987b597c58e3c95cc0139b3c1a34" translate="yes" xml:space="preserve">
          <source>These errors will add-up, may eventually become not easy to ignore anymore. This is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;Error Propagation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 오류는 더해져 결국에는 더 이상 무시하기 쉽지 않을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오류 전파&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="606eb3e99c5273df8a7722244204e4492f80dd02" translate="yes" xml:space="preserve">
          <source>This is not a matter of accuracy, nor is it a matter of precision.  It is a matter of meeting the expectations of humans who use base 10 for calculations instead of base 2.  For example, using doubles for financial calculations does not produce answers that are &quot;wrong&quot; in a mathematical sense, but it can produce answers that are not what is expected in a financial sense.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 정확성의 문제가 아니며 정확성의 문제도 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기초 2 대신 계산에 기초 10을 사용하는 인간의 기대치를 충족시키는 것이 문제입니다. 예를 들어, 재무 계산에 복식을 사용하면 수학적으로 &quot;틀린&quot;답변이 나오지 않지만 다음과 같은 답변을 얻을 수 있습니다. 재정적 인 의미에서 기대되는 것이 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f56a8ad3c064083a6830f9e2e5c107de9737d8b" translate="yes" xml:space="preserve">
          <source>Though &lt;code&gt;BigDecimal&lt;/code&gt; has some caveats (please see currently accepted answer).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에는 몇 가지주의 사항이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있지만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;현재 허용되는 답변을 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1c094b2ad137115816f31659c9cfbf3826a1f48" translate="yes" xml:space="preserve">
          <source>To add on previous answers, there is also option of implementing &lt;strong&gt;Joda-Money&lt;/strong&gt; in Java, besides BigDecimal, when dealing with the problem addressed in the question. Java modul name is org.joda.money.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이전 답변을 추가하기 위해 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BigDecimal 외에도 Java에서 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joda-Money&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 구현 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 질문에서 해결 된 문제를 해결할 수있는 옵션이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 모듈 이름은 org.joda.money입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5b722d8c9d8a1489a2549458ee0e114ae99d0ae" translate="yes" xml:space="preserve">
          <source>To be more precise, there is compile-time dependency but it is not
  required.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보다 정확하게는 컴파일 타임 종속성이 있지만 필수는 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6ac20efd7111b356fc3ce5a15fb213b8f1231c05" translate="yes" xml:space="preserve">
          <source>Using a calculator, or calculating results by hand, 1.40 * 165 = 231 exactly.  However, internally using doubles, on my compiler / operating system environment, it is stored as a binary number close to 230.99999... so if you truncate the number, you get 230 instead of 231.  You may reason that rounding instead of truncating would have given the desired result of 231.  That is true, but rounding always involves truncation.  Whatever rounding technique you use, there are still boundary conditions like this one that will round down when you expect it to round up.  They are rare enough that they often will not be found through casual testing or observation.  You may have to write some code to search for examples that illustrate outcomes that do not behave as expected.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계산기를 사용하거나 직접 손으로 결과를 계산하면 1.40 * 165 = 231입니다. 그러나 컴파일러 / 운영 체제 환경에서 내부적으로 double을 사용하면 230.99999에 가까운 이진수로 저장됩니다. 따라서 숫자를 자르면 231 대신 230이됩니다. 잘라 내기 대신 반올림하는 이유는 다음과 같습니다. 231의 원하는 결과를 얻었습니다. 사실이지만 반올림은 항상 잘립니다. 어떤 반올림 기술을 사용하든 반올림을 기대할 때 반올림되는 경계 조건이 여전히 있습니다. 그들은 일상적인 테스트 또는 관찰을 통해 종종 발견되지 않을 정도로 희귀합니다. 예상대로 작동하지 않는 결과를 나타내는 예제를 검색하려면 코드를 작성해야 할 수도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89bf22cfb2377a37cc9d78f04b4c187a794fcdf9" translate="yes" xml:space="preserve">
          <source>Usually because the double type has a precision less than 16 figures. If you require better precision it's not a suitable type. Also approximations can accumulate.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 이중 유형의 정밀도는 16 자리 미만입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 나은 정밀도가 필요한 경우 적합한 유형이 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;근사치도 누적 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e817fc6c76f182bd2298f7ba72146b08ba8ec723" translate="yes" xml:space="preserve">
          <source>What are the alternatives? There are many (and many more of which I am not aware!).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대안은 무엇입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 것들이 있습니다 (그리고 더 많은 것을 알지 못합니다!).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e8f3327bd17bd0a003c3cc24469c1b88d03bfce8" translate="yes" xml:space="preserve">
          <source>When using the reference implementation API, the necessary code is much simpler:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 구현 API를 사용할 때 필요한 코드는 훨씬 간단합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9698e43da0a699e4fa5451fdd3c99a90f6671e68" translate="yes" xml:space="preserve">
          <source>When working with collections of MonetaryAmounts, some nice utility methods for filtering, sorting and grouping are available.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MonetaryAmount 콜렉션으로 작업 할 때 필터링, 정렬 및 그룹화를위한 유용한 유틸리티 메소드를 사용할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="27d553d0dc9a1bc2d96bb69efca899ee61467545" translate="yes" xml:space="preserve">
          <source>While it's true that floating point type can represent only approximatively decimal data, it's also true that if one rounds numbers to the necessary precision before presenting them, one obtains the correct result. Usually.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부동 소수점 유형은 근사 적으로 십진 데이터 만 나타낼 수 있지만 숫자를 제시하기 전에 필요한 정밀도로 반올림하면 올바른 결과를 얻는다는 것도 사실입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보통.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="259be95f8f96400b8780b6bd0febf8a17c39d59b" translate="yes" xml:space="preserve">
          <source>Why not use Double or Float to represent currency</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Double 또는 Float를 사용하여 통화를 나타내지 않는 이유&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d3e3ea709979f27b18302294b7096b2f742d51c" translate="yes" xml:space="preserve">
          <source>You can make it work if you are able to handle the precision and accuracy requirements of your project, which has to be done based on what range of double values is one dealing with.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로젝트의 정밀도 및 정확도 요구 사항을 처리 할 수 ​​있으면 처리 할 수 ​​있습니다.이 범위는 다루는 이중 값 범위를 기반으로 수행해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="022bc50d2cd71f6c2d95b26e226d38a8c5773922" translate="yes" xml:space="preserve">
          <source>You can refer to guava's FuzzyCompare method to get more idea. The parameter tolerance is the key. 
We dealt with this problem for a securities trading application and we did an exhaustive research on what tolerances to use for different numerical values in different ranges.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구아바의 FuzzyCompare 방법을 참조하여 더 많은 아이디어를 얻을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파라미터 공차가 핵심입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 증권 거래 애플리케이션에 대해이 문제를 다루었 고, 다른 범위의 다른 숫자 값에 사용할 공차를 철저히 조사했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="796c2136ddb0d07455d54486d96ceb9de93d5885" translate="yes" xml:space="preserve">
          <source>You might, for speed, look into the free and proprietary libraries in C, C++, and Fortran.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C, C ++ 및 Fortran의 무료 독점 라이브러리를 빠른 속도로 살펴볼 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c618e14e3f2a441848e8fc5e3abfc132b9f9dca1" translate="yes" xml:space="preserve">
          <source>prints out &lt;code&gt;0.6100000000000001&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;0.6100000000000001&lt;/code&gt; 을&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 출력합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea0d137fa0077ce0c7953f0dceb93af4ba0cb4fa" translate="yes" xml:space="preserve">
          <source>results in</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결과&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4a107da068492bff7b05f2935fa1bd052403861e" translate="yes" xml:space="preserve">
          <source>this probably isn't how you want to represent $1.01.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 아마도 당신이 $ 1.01을 표현하고 싶지 않은 방법 일 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
