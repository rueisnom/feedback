<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3730019">
    <body>
      <group id="3730019">
        <trans-unit id="09f0a3718fc85408fc3968cd3e73ec142bfdf8e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finally Java has a standard way to work with Currency And Money!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最终，Java具有使用Currency和Money的标准方式！&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="067ffcb87cbcca8f5deb07e1edf7236614c5c3f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Bloch, J., Effective Java, 2nd ed, Item 48:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;摘自Bloch，J.，《有效Java》，第二版，第48项：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5f6e9fc67eabeb616ef60d5d06c36cdfa7f7379" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSR 354: Money and Currency API&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354：货币和货币API&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f766b6007bcacd14501e3d6f2ddefc6012c887b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sample Examples of JSR 354: Money and Currency API:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354的示例示例：货币和货币API：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e2aae1a87e35a4fa14d5b8e07a14c874d3e8731" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The specification consists of the following things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该规范包含以下内容：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="279d8b6ec4347409e3a31f9d1293b292eba50459" translate="yes" xml:space="preserve">
          <source>A solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt; class, and C# has the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx&quot;&gt;&lt;code&gt;decimal&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;适用于几乎所有语言的解决方案是改用整数，然后计算分。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，1025为$ 10.25。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;几种语言还具有内置类型来处理金钱。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其中，Java具有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类，而C＃具有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx&quot;&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="717c89d37aca9bbeaf61dacfbd6ecf66a6ac4cf6" translate="yes" xml:space="preserve">
          <source>APIs to support interchangeable implementations</source>
          <target state="translated">支持可互换实施的API</target>
        </trans-unit>
        <trans-unit id="764e3868719a642a94e9c1db3b2399ade06cc23d" translate="yes" xml:space="preserve">
          <source>All specification classes and interfaces are located in the javax.money.* package.</source>
          <target state="translated">所有规范类和接口都位于javax.money.*包中。</target>
        </trans-unit>
        <trans-unit id="bf91636fa17ae4579edcdf37d35ebfd293f2b61f" translate="yes" xml:space="preserve">
          <source>Also, there might be situations when you're tempted to use Double wrappers as a map key with hash map being the implementation. It is very risky because Double.equals and hash code for example values &quot;0.5&quot; &amp;amp; &quot;0.6 - 0.1&quot; will cause a big mess.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另外，在某些情况下，您可能会尝试使用Double包装器作为映射键，而哈希映射是实现。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是非常危险的，因为Double.equals和哈希码（例如值&amp;ldquo; 0.5&amp;rdquo;和&amp;ldquo; 0.6-0.1&amp;rdquo;）会造成很大的混乱。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf754cbdda51fd0330c49df312d2b9c5513b384b" translate="yes" xml:space="preserve">
          <source>An API for handling e. g. monetary amounts and currencies</source>
          <target state="translated">用于处理货币金额和货币等的API。</target>
        </trans-unit>
        <trans-unit id="47f68da097e3b1b2f17304cdd296e6c8b747eb0d" translate="yes" xml:space="preserve">
          <source>An example of creating a MonetaryAmount and printing it to the console looks like this::</source>
          <target state="translated">创建一个MonetaryAmount并将其打印到控制台的例子是这样的:。</target>
        </trans-unit>
        <trans-unit id="c7ad5819035e16732c5be390d7fe2b3aaf867a68" translate="yes" xml:space="preserve">
          <source>Arbitrary precision won't help because there always can be numbers that has so many decimal places, or some results such as &lt;code&gt;0.6666666&lt;/code&gt;... No arbitrary representation will cover the last example. So you will have small errors in each step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任意精度将无济于事，因为总会有一些小数位数那么多的数字，或者诸如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.6666666&lt;/code&gt; 之类的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;结果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，您在每个步骤中都会有一些小错误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2e27a448c1442df8dbf814d07126dae13f3ba4b" translate="yes" xml:space="preserve">
          <source>As said earlier &quot;Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, you&amp;rsquo;ll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如前所述，&amp;ldquo;将钱表示为双精度或浮点数可能首先看起来不错，因为该软件会消除微小的错误，但是随着您对不精确的数字执行更多的加，减，乘和除运算，您将越来越失去精度。随着误差的加总，这使得浮点数和翻倍数不足以处理金钱，在这种情况下，需要十进制乘以10的幂的完美精度。&amp;rdquo;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b08a01dc6c5fc3334a18152f819d33b8eda77206" translate="yes" xml:space="preserve">
          <source>Assume you want to round something to the nearest penny.  So you take your final result, multiply by 100, add 0.5, truncate, then divide the result by 100 to get back to pennies.  If the internal number you stored was 3.46499999.... instead of 3.465, you are going to get 3.46 instead 3.47 when you round the number to the nearest penny.  But your base 10 calculations may have indicated that the answer should be 3.465 exactly, which clearly should round up to 3.47, not down to 3.46.  These kinds of things happen occasionally in real life when you use doubles for financial calculations.  It is rare, so it often goes unnoticed as an issue, but it happens.</source>
          <target state="translated">假设你想把一些东西四舍五入到最近的一分钱。所以,你把最后的结果,乘以100,加0.5,截断,然后把结果除以100,就可以得到一分钱。如果你存储的内部数字是3.46499999...........而不是3.465,当你把这个数字四舍五入到最接近的便士时,你会得到3.46而不是3.47。但你的基数10的计算可能表明答案应该是3.465,显然应该四舍五入到3.47,而不是3.46。这类事情在现实生活中偶尔会发生,当你用倍数来进行财务计算时。这种情况很少发生,所以经常被当作问题而不被注意,但它还是会发生。</target>
        </trans-unit>
        <trans-unit id="686314d64dfd1b19bdb75704e3275be9ef46537d" translate="yes" xml:space="preserve">
          <source>Because floats and doubles cannot accurately represent the base 10 multiples that we use for money. This issue isn't just for Java, it's for any programming language that uses base 2 floating-point types.</source>
          <target state="translated">因为浮点数和双倍数不能准确地表示基数10的倍数,而我们使用的是基数10的倍数。这个问题不仅仅是针对Java,对于任何使用基数为2的浮点类型的编程语言都是如此。</target>
        </trans-unit>
        <trans-unit id="d774a91c3005dbfc9d51d54db8523611c0c80ee8" translate="yes" xml:space="preserve">
          <source>BigDecimal in Java is native to the Java language.
Apfloat is another arbitrary-precision library for Java.</source>
          <target state="translated">Java中的BigDecimal是Java语言的原生库。Apfloat是Java的另一个任意精度库。</target>
        </trans-unit>
        <trans-unit id="b94819d8ebaaf6c31dbcb3e0507caf9b63c974e0" translate="yes" xml:space="preserve">
          <source>Coming from a non-computer science background (physics and engineering), I tend to look at problems from a different perspective. For me, the reason why I wouldn't use a double or float in a mathematical calculation is that I would lose too much information.</source>
          <target state="translated">来自非计算机科学背景(物理和工程),我倾向于从不同的角度看问题。对我来说,我不会在数学计算中使用双数或浮点数的原因是,我会损失太多信息。</target>
        </trans-unit>
        <trans-unit id="677ba35d3f4b7ef97f05e8f12a39a698e653703d" translate="yes" xml:space="preserve">
          <source>Concluding, in my opinion the double is unsuitable mostly for its 16 digit precision, which can be insufficient, not because it is approximate.</source>
          <target state="translated">总结一下,在我看来,替身不适合的主要原因是它的16位数的精度可能不足,而不是因为它是近似的。</target>
        </trans-unit>
        <trans-unit id="0545f3890164845c72010b8e0ed6d58da24b6375" translate="yes" xml:space="preserve">
          <source>Consider the following output of the subsequent program. It shows that after rounding double give the same result as BigDecimal up to precision 16.</source>
          <target state="translated">考虑一下下面这个程序的输出。它表明,经过四舍五入后的结果与BigDecimal相同,精度达到16。</target>
        </trans-unit>
        <trans-unit id="e5741882b583d222d3509526f6535f0aca560bcc" translate="yes" xml:space="preserve">
          <source>CurrencyUnit and MonetaryAmount</source>
          <target state="translated">货币单位和货币金额</target>
        </trans-unit>
        <trans-unit id="a39fe455337c4b0e4fe8c05f871b35046753359b" translate="yes" xml:space="preserve">
          <source>Custom MonetaryAmount operations</source>
          <target state="translated">自定义货币金额操作</target>
        </trans-unit>
        <trans-unit id="3332fa176aea702f236b003b8db2099175e7e9fe" translate="yes" xml:space="preserve">
          <source>Documentation:
  &lt;a href=&quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&quot;&gt;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文档：&lt;/font&gt;&lt;a href=&quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="381e479c3588e94e6153168dcc0099a4c7380509" translate="yes" xml:space="preserve">
          <source>Even if you round off your results at the last minute before output, you can still occasionally get a result using doubles that does not match expectations.</source>
          <target state="translated">即使你在输出前的最后一分钟把结果四舍五入,也会偶尔出现使用双打的结果与预期不符的情况。</target>
        </trans-unit>
        <trans-unit id="739138cb0e4f13fdb2a14bb54aa2436816c625fd" translate="yes" xml:space="preserve">
          <source>Even in base 10, this notation cannot accurately represent most simple fractions. For instance, you can't represent 1/3: the decimal representation is repeating (0.3333...), so there is no finite integer that you can multiply by a power of 10 to get 1/3. You could settle on a long sequence of 3's and a small exponent, like 333333333 * 10&lt;sup&gt;-10&lt;/sup&gt;, but it is not accurate: if you multiply that by 3, you won't get&amp;nbsp;1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使在基数10中，该符号也无法准确表示最简单的分数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，您不能表示1/3：十进制表示形式正在重复（0.3333 ...），因此没有可以乘以10的幂来获得1/3的有限整数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用3的长序列和较小的指数，例如333333333 * 10 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-10&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但这并不准确：如果将其乘以3，则不会得到1。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee1869b094937e9a8826f16f45c31d79373b5f4c" translate="yes" xml:space="preserve">
          <source>Examples of using Joda Money:</source>
          <target state="translated">使用Joda Money的例子。</target>
        </trans-unit>
        <trans-unit id="b5072184cf44d5fe99ebc445de8723c52dba90a9" translate="yes" xml:space="preserve">
          <source>Factories for creating instances of the implementation classes</source>
          <target state="translated">创建实施类实例的工厂</target>
        </trans-unit>
        <trans-unit id="40dd3f8de5b5b29b2f97def0749ce28de01e7855" translate="yes" xml:space="preserve">
          <source>Floats and doubles are approximate. If you create a BigDecimal and pass a float into the constructor you see what the float actually equals:</source>
          <target state="translated">浮点数和双倍数都是近似值。如果你创建一个BigDecimal并将一个float传递到构造函数中,你就会看到float实际等于什么。</target>
        </trans-unit>
        <trans-unit id="f91c4b87711bc72d9c507486005d248573dcd071" translate="yes" xml:space="preserve">
          <source>For example COBOL, historically used for financial calculations, has a maximum precision of 18 figures. So there is often an implicit rounding.</source>
          <target state="translated">例如COBOL,历史上用于财务计算的COBOL,其精度最高为18位数。所以往往会有一个隐含的四舍五入。</target>
        </trans-unit>
        <trans-unit id="75c807d28a864927acb8b31d7d3c8ac580f2b9cc" translate="yes" xml:space="preserve">
          <source>For example, suppose you have $1.03
  and you spend 42c. How much money do
  you have left?</source>
          <target state="translated">例如,假设你有1.03美元,你花了42C,你还有多少钱?你还有多少钱?</target>
        </trans-unit>
        <trans-unit id="9de791eaf216bc3b590abee4d7754d4d8c9d03e5" translate="yes" xml:space="preserve">
          <source>For me, I like BigDecimal because of the methods it supports. C#'s decimal is very nice, but I haven't had the chance to work with it as much as I'd like. I do scientific calculations of interest to me in my spare time, and BigDecimal seems to work very well because I can set the precision of my floating point numbers. The disadvantage to BigDecimal? It can be slow at times, especially if you're using the divide method.</source>
          <target state="translated">对我来说,我喜欢BigDecimal是因为它支持的方法。C#的十进制很不错,但我还没有机会像我想的那样用它来工作。我在业余时间做一些我感兴趣的科学计算,BigDecimal似乎很好用,因为我可以设置浮点数的精度。BigDecimal的缺点是什么?它有时会很慢,尤其是当你使用除法时。</target>
        </trans-unit>
        <trans-unit id="c1596c5466820636637e428d747fe6a6fbee306e" translate="yes" xml:space="preserve">
          <source>Functionality for calculations, conversion and formatting of monetary            amounts</source>
          <target state="translated">货币金额的计算、转换和格式化功能</target>
        </trans-unit>
        <trans-unit id="b834495da73d80490ba3f5f0af039bcb1529bbb2" translate="yes" xml:space="preserve">
          <source>Handling money and currencies in Java with JSR 354</source>
          <target state="translated">用JSR 354在Java中处理金钱和货币</target>
        </trans-unit>
        <trans-unit id="1a6c98689987bf69175f5b0dbd14419ab2e195b3" translate="yes" xml:space="preserve">
          <source>However, for the purpose of counting money, at least for countries whose money is valued within an order of magnitude of the US dollar, usually all you need is to be able to store multiples of 10&lt;sup&gt;-2&lt;/sup&gt;, so it doesn't really matter that 1/3 can't be represented.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，出于数钱的目的，至少对于货币价值在美元数量级以内的国家而言，通常您所需要的只是能够存储10 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-2的&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;倍数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此这并不重要不能代表1/3。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9545c9929da7e9a99ecf7b11d62ec5571358a4ac" translate="yes" xml:space="preserve">
          <source>I have worked on a number of projects with very low gc requirements, and having BigDecimal objects was a big contributor to that overhead.</source>
          <target state="translated">我曾在一些对GC要求很低的项目中工作过,拥有BigDecimal对象对开销的贡献很大。</target>
        </trans-unit>
        <trans-unit id="20bcc3b9e6b736283080cd8b942be6364f880be5" translate="yes" xml:space="preserve">
          <source>I'll risk being downvoted, but I think the unsuitability of floating point numbers for currency calculations is overrated. As long as you make sure you do the cent-rounding correctly and have enough significant digits to work with in order to counter the binary-decimal representation mismatch explained by zneak, there will be no problem.</source>
          <target state="translated">我会冒着被降级的风险,但我认为浮点数不适合货币计算的问题被高估了。只要你确保正确地进行分币四舍五入,并且有足够多的重要数字可以使用,以对抗zneak所解释的二进制与十进制的不匹配,就没有问题。</target>
        </trans-unit>
        <trans-unit id="f3e4618f2467db822b69c46c1fea719a017d4735" translate="yes" xml:space="preserve">
          <source>I'm not a computer scientist by training. However, I tend to lean towards either BigDecimal in Java or decimal in C#. I haven't tried the other solutions I've listed, but they are probably very good as well.</source>
          <target state="translated">我不是一个受过训练的计算机科学家。但是,我倾向于使用Java中的BigDecimal或者C#中的十进制。我没有尝试过我列出的其他解决方案,但它们可能也很不错。</target>
        </trans-unit>
        <trans-unit id="990e7012ab72470facd01fe2c1a1f5d51c224ba0" translate="yes" xml:space="preserve">
          <source>I'm sure there is a very good reason, I simply do not know what it is.</source>
          <target state="translated">我肯定有一个很好的理由,只是我不知道是什么理由。</target>
        </trans-unit>
        <trans-unit id="0b640dfe453f9fe28f4de0716c715e5b4b78fa5a" translate="yes" xml:space="preserve">
          <source>I'm troubled by some of these responses.  I think doubles and floats have a place in financial calculations.  Certainly, when adding and subtracting non-fractional monetary amounts there will be no loss of precision when using integer classes or BigDecimal classes.  But when performing more complex operations, you often end up with results that go out several or many decimal places, no matter how you store the numbers.  The issue is how you present the result.</source>
          <target state="translated">我对其中的一些回答感到困扰。我认为双数和浮点数在金融计算中是有一席之地的。当然,在加减非小数货币金额时,使用整数类或BigDecimal类时,精度不会有任何损失。但当执行更复杂的操作时,无论你如何存储数字,你往往会得到的结果都是小数点后几位或几位小数。问题在于你如何呈现结果。</target>
        </trans-unit>
        <trans-unit id="98375c7c8b2a2005748c2b911a76c4dfe8d20dc1" translate="yes" xml:space="preserve">
          <source>I've always been told &lt;em&gt;never&lt;/em&gt; to represent money with &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; types, and this time I pose the question to you: why?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一直有人告诉我，永远&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不要&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮点&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示货币&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这一次我向您提出一个问题：为什么？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fcd023b4c00bf2e3b4db4e2b3bfa19a5930150d9" translate="yes" xml:space="preserve">
          <source>If you use base 10 for your internal calculations instead of doubles, the answers are always exactly what is expected by humans, assuming no other bugs in your code.</source>
          <target state="translated">如果你用10为基数而不是双倍数来进行内部计算,假设你的代码中没有其他bug,答案总是和人类预期的一样。</target>
        </trans-unit>
        <trans-unit id="0d316acf25caa86b6df1ed932c3fdc12985946bb" translate="yes" xml:space="preserve">
          <source>If your computation involves various steps, arbitrary precision arithmetic won't cover you 100%.</source>
          <target state="translated">如果你的计算涉及到各种步骤,任意精度算术不会100%覆盖你。</target>
        </trans-unit>
        <trans-unit id="7358b1f7336f90ad39312beb48de9d969908dbe0" translate="yes" xml:space="preserve">
          <source>If your result is on the borderline between being rounded up and rounded down, and that last penny really matters, you should be probably be telling the viewer that the answer is nearly in the middle - by displaying more decimal places.</source>
          <target state="translated">如果你的结果是在四舍五入和四舍五入之间的边界线上,而最后一分钱真的很重要,你可能应该通过显示更多的小数位来告诉观众,答案几乎在中间--通过显示更多的小数位。</target>
        </trans-unit>
        <trans-unit id="89ee989c518fd96a85c276fbbcc76f3a0d201bc3" translate="yes" xml:space="preserve">
          <source>Implementation examples:
  &lt;a href=&quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&quot;&gt;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实施示例：&lt;/font&gt;&lt;a href=&quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//www.programcreek.com/java-api-examples/?api=org.joda.money.Money&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="80417b3d4f9b43eb6ff3dba9201d4b848e5acc31" translate="yes" xml:space="preserve">
          <source>In base 10, you can write 10.25 as 1025 * 10&lt;sup&gt;-2&lt;/sup&gt; (an integer times a power of 10). &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE-754 floating-point numbers&lt;/a&gt; are different, but a very simple way to think about them is to multiply by a power of two instead. For instance, you could be looking at 164 * 2&lt;sup&gt;-4&lt;/sup&gt; (an integer times a power of two), which is also equal to 10.25. That's not how the numbers are represented in memory, but the math implications are the same.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在基数10中，您可以将10.25编写为1025 * 10 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（整数乘以10的幂）。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IEEE-754浮点数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是不同的，但是考虑它们的一种非常简单的方法是乘以2的幂。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，您可能正在看164 * 2 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-4&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（整数乘以2的幂），它也等于10.25。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这不是数字在内存中的表示方式，但是数学含义是相同的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f85da357aa1787e92299ea8764dc8f1081d232a" translate="yes" xml:space="preserve">
          <source>It doesn't mean though that doubles can never be used for that purpose.</source>
          <target state="translated">但这并不意味着双打永远不能用于此目的。</target>
        </trans-unit>
        <trans-unit id="189a0c254a5f6366cf960591b4dcd1af6677fec2" translate="yes" xml:space="preserve">
          <source>It must be said that even if you use fixed point arithmetic you still have to round numbers, were it not for the fact that BigInteger and BigDecimal give errors if you obtain periodic decimal numbers. So there is an approximation also here.</source>
          <target state="translated">不得不说,即使你使用定点算术,你仍然需要对数字进行四舍五入,如果不是因为BigInteger和BigDecimal在得到周期性的小数时,会产生误差。所以,这里也有一个近似值。</target>
        </trans-unit>
        <trans-unit id="04b2d7d7bcbb29484271eba8aaf54f4b4bc5cc56" translate="yes" xml:space="preserve">
          <source>It requires Java SE 8 or later and has no dependencies.</source>
          <target state="translated">它需要Java SE 8或更高的版本,并且没有任何依赖性。</target>
        </trans-unit>
        <trans-unit id="24d35c472f26d6b1a31b545ab3b7165c01d595eb" translate="yes" xml:space="preserve">
          <source>It's not that the error isn't controllable if you round: &lt;a href=&quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html&quot;&gt;see this article by Peter Lawrey&lt;/a&gt;. It's just easier not to have to round in the first place. Most applications that handle money don't call for a lot of math, the operations consist of adding things or allocating amounts to different buckets. Introducing floating point and rounding just complicates things.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您四舍五入，并不是说错误是不可控制的：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅Peter Lawrey的本文&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。不必首先四舍五入就更容易了。大多数处理金钱的应用程序不需要很多数学运算，这些运算包括添加内容或将金额分配到不同的存储桶。引入浮点和舍入只会使事情复杂化。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bd1736b140bbc0f9b6f105c77291011f013e232" translate="yes" xml:space="preserve">
          <source>It's the lack of understanding about double representation and lack of experience in handling the accuracy and precision that brings about this wise suggestion.</source>
          <target state="translated">正是由于对双重表述的不理解,缺乏处理准确性和精确性的经验,才带来了这个明智的建议。</target>
        </trans-unit>
        <trans-unit id="2da89442de0564adb263d4b217cde992b04f1ff9" translate="yes" xml:space="preserve">
          <source>JSR 354 provides an API for representing, transporting, and performing comprehensive calculations with Money and Currency. You can download it from this link:</source>
          <target state="translated">JSR 354提供了一个API来表示、传输和执行货币和货币的综合计算。您可以从这个链接下载。</target>
        </trans-unit>
        <trans-unit id="8f51b176f17789e90549d24d66d084d0377ef75a" translate="yes" xml:space="preserve">
          <source>JSR 354: Money and Currency API Download</source>
          <target state="translated">JSR 354:货币和货币API下载</target>
        </trans-unit>
        <trans-unit id="e355bd15d23282effb75249c47fc6278e186ca1e" translate="yes" xml:space="preserve">
          <source>Java API for working with Money and Currencies, which is planned to be included in Java 9.</source>
          <target state="translated">计划在Java 9中纳入货币和货币工作的Java API。</target>
        </trans-unit>
        <trans-unit id="70d2f01c0479a64ac9a018a01053853a4ccc0a04" translate="yes" xml:space="preserve">
          <source>Looking into the Java 9 Money and Currency API (JSR 354)</source>
          <target state="translated">研究Java 9货币和货币API (JSR 354)</target>
        </trans-unit>
        <trans-unit id="cbc716194c3421d45328f11b1ed734e714f9a899" translate="yes" xml:space="preserve">
          <source>Many of the answers posted to this question discuss IEEE and the standards surrounding floating-point arithmetic.</source>
          <target state="translated">这个问题的许多答案都讨论了IEEE和浮点运算的标准。</target>
        </trans-unit>
        <trans-unit id="cafddb4a8f868576fbd86b950274e809cab58f05" translate="yes" xml:space="preserve">
          <source>MonetaryAmount has various methods that allow accessing the assigned currency, the numeric amount, its precision and more:</source>
          <target state="translated">货币金额(MonetaryAmount)有多种方法,可以访问指定的货币、数字金额、精度等。</target>
        </trans-unit>
        <trans-unit id="1c047041987b7e92d7fd573c5e62c0f30a2b8bd4" translate="yes" xml:space="preserve">
          <source>MonetaryAmounts can be rounded using a rounding operator:</source>
          <target state="translated">MonetaryAmounts可以使用四舍五入运算器进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="0cd10f02a4e801b3f271ae2d36c791ac844e9895" translate="yes" xml:space="preserve">
          <source>Most answers have highlighted the reasons why one should not use doubles for money and currency calculations. And I totally agree with them.</source>
          <target state="translated">大多数的回答都强调了不应该用双倍数来计算货币和货币的原因。而我完全同意他们的观点。</target>
        </trans-unit>
        <trans-unit id="8c0a7d98a17c7e3d1315cdf1e4024b71e84be895" translate="yes" xml:space="preserve">
          <source>OUTPUT:</source>
          <target state="translated">OUTPUT:</target>
        </trans-unit>
        <trans-unit id="ab03dc913e6f18c3df668c4f3c27fc3d1b767a73" translate="yes" xml:space="preserve">
          <source>Of course, you have to stay within reason; e.g. a simple webshop would probably never experience any problem with double precision floats, but if you do e.g. accounting or anything else that requires adding a large (unrestricted) amount of numbers, you wouldn't want to touch floating point numbers with a ten foot pole.</source>
          <target state="translated">当然,你必须保持在合理的范围内;例如,一个简单的网络商店可能永远不会遇到双精度浮点数的问题,但如果你做的是会计或其他需要添加大量(不受限制的)数字的事情,你就不会想用十英尺的杆子去碰浮点数。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="893e9390628cf8793e980bd5c0bc3d738246634a" translate="yes" xml:space="preserve">
          <source>People calculating with currency in Excel have always used double precision floats (there is no currency type in Excel) and I have yet to see anyone complaining about rounding errors.</source>
          <target state="translated">在Excel中使用货币计算的人一直都是用双精度的浮点数(Excel中没有货币类型),我还没有看到有人抱怨四舍五入错误。</target>
        </trans-unit>
        <trans-unit id="ce0f4ca9377352ec33a36acf2c838b95f364a475" translate="yes" xml:space="preserve">
          <source>Representing money as a &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, errors will compound and you'll end up with values that are visibly not accurate. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先，将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;钱表示为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮点型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能会很好，因为该软件会消除微小的误差，但是当您对不精确的数字执行更多的加法，减法，乘法和除法运算时，误差将加重，最终您会得到显然不准确。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这使得浮子和翻倍数不足以处理金钱，在这种情况下，要求十进制乘数的完美精度。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90bdbcb63d1c58de798fcf3d27eefa22f192272c" translate="yes" xml:space="preserve">
          <source>Resources:</source>
          <target state="translated">Resources:</target>
        </trans-unit>
        <trans-unit id="7466c0c80238bbd71329492766d1f91a178140c9" translate="yes" xml:space="preserve">
          <source>SciPy (Scientific Python) can probably also handle financial calculations (I haven't tried, but I suspect so).</source>
          <target state="translated">SciPy(SciPy)可能也可以处理财务计算(我没试过,但我怀疑是这样)。</target>
        </trans-unit>
        <trans-unit id="72dd135113af4bb32b27d846ec53778eaebee82f" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;http://javamoney.github.io/&quot;&gt;JSR 354 - Currency and Money&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另请参见：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://javamoney.github.io/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354-货币和货币&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f7a401d25dd853ca7105588312147327477a4a5" translate="yes" xml:space="preserve">
          <source>Some example... this works (actually don't work as expected), on almost any programming language... I've tried with Delphi, VBScript, Visual Basic, JavaScript and now with Java/Android:</source>
          <target state="translated">一些例子...........这在几乎所有的编程语言上都能正常工作(实际上并不像预期的那样)。我试过Delphi、VBScript、Visual Basic、JavaScript,现在又试过JavaAndroid。</target>
        </trans-unit>
        <trans-unit id="aa9645f2ab1c2cb679f21b70df5c102fb0e3e6be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; types are
  particularly ill-suited for monetary
  calculations because it is impossible
  to represent 0.1 (or any other
  negative power of ten) as a &lt;code&gt;float&lt;/code&gt; or
  &lt;code&gt;double&lt;/code&gt; exactly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所述&lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型是特别不适合用于货币计算，因为它是不可能代表0.1（或10中的任何其它负电源），为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;准确。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37a22ebd44711311bb4fb92a4282d607da8596f5" translate="yes" xml:space="preserve">
          <source>The API also supports calculations with MonetaryAmounts:</source>
          <target state="translated">API还支持使用MonetaryAmounts进行计算。</target>
        </trans-unit>
        <trans-unit id="84a8cc07b8a6e7ce2ce3275b890a5f8a8f30b899" translate="yes" xml:space="preserve">
          <source>The GNU Multiple Precision Library (GMP) and the GNU MFPR Library are two free and open-source resources for C and C++.</source>
          <target state="translated">GNU Multiple Precision Library (GMP)和GNU MFPR Library是C和C++的两个免费开源资源。</target>
        </trans-unit>
        <trans-unit id="cdef8dba5555ec0beb2b9902e32847ed7611acbb" translate="yes" xml:space="preserve">
          <source>The decimal data type in C# is Microsoft's .NET alternative for 28 significant figures.</source>
          <target state="translated">在C#中的十进制数据类型是微软的.NET中28个显著性数字的替代方案。</target>
        </trans-unit>
        <trans-unit id="5383c20d2d17e96881c2fda340145ff07c98074b" translate="yes" xml:space="preserve">
          <source>The only reliable way to use a perfect representation of results(Use a custom Fraction data type that will batch division operations to the last step) and only convert to decimal notation in the last step.</source>
          <target state="translated">唯一可靠的方法是使用完美的结果表示(使用自定义的分数数据类型,将除法操作批处理到最后一步),并且只在最后一步转换为十进制符号。</target>
        </trans-unit>
        <trans-unit id="197911d6c1e58965b7e6611a80d150d7ba686aac" translate="yes" xml:space="preserve">
          <source>The problem is that the IEEE spec doesn't have a way to exactly represent all fractions, some of them end up as repeating fractions so you end up with approximation errors. Since accountants like things to come out exactly to the penny, and customers will be annoyed if they pay their bill and after the payment is processed they owe .01 and they get charged a fee or can't close their account, it's better to use exact types like decimal (in C#) or java.math.BigDecimal in Java.</source>
          <target state="translated">问题是,IEEE标准没有办法精确地表示所有的分数,有些分数最终会变成重复的分数,所以你最终会出现近似误差。由于会计人员喜欢精确到一分钱,如果客户在支付账单时,在付款后欠了.01,并被收取费用或无法关闭账户,他们会很恼火,所以最好使用精确类型,如十进制(在C#中)或Java中的java.math.BigDecimal。</target>
        </trans-unit>
        <trans-unit id="b28f5a973c1343f529f0e63c534d0921c6ab0947" translate="yes" xml:space="preserve">
          <source>The problem with doubles, and more so with floats, is when they are used to combine large numbers and small numbers.  In java,</source>
          <target state="translated">双倍数的问题,更多的是在用双倍数来组合大数和小数时的问题。在java中。</target>
        </trans-unit>
        <trans-unit id="5b6a4d54cc02b1c3f15e40c24f65fff30e4810f1" translate="yes" xml:space="preserve">
          <source>The problem with floats and doubles is that the &lt;em&gt;vast majority&lt;/em&gt; of money-like numbers don't have an exact representation as an integer times a power of 2. In fact, the only multiples of 0.01 between 0 and 1 (which are significant when dealing with money because they're integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount. As an analogy to the 0.333333 example, if you take the floating-point value for 0.1 and you multiply it by&amp;nbsp;10, you won't get&amp;nbsp;1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮点数和双精度数的问题在于，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;绝大多数&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类似于货币的数字都不能精确表示为整数乘以2的幂。实际上，0和1之间只有0.01的倍数（在交易时很重要）可以用金钱来表示，因为它们是整数美分），可以完全表示为IEEE-754二进制浮点数，分别为0、0.25、0.5、0.75和1。所有其他值相差很小。类似于0.333333的示例，如果将浮点值设为0.1，然后将其乘以10，则不会得到1。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e74e7a3acd980ae3a6baa90e220277c25718108" translate="yes" xml:space="preserve">
          <source>The result of floating point number is not exact, which makes them unsuitable for any financial calculation which requires exact result and not approximation. float and double are designed for engineering and scientific calculation and many times doesn&amp;rsquo;t produce exact result also result of floating point calculation may vary from JVM to JVM. Look at below example of BigDecimal and double primitive which is used to represent money value, its quite clear that floating point calculation may not be exact and one should use BigDecimal for financial calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮点数的结果不准确，这使其不适用于需要精确结果而不是近似值的任何财务计算。 float和double是为工程和科学计算而设计的，很多时候都无法产生确切的结果，而且浮点计算的结果可能因JVM而异。在下面的示例BigDecimal和用于表示货币价值的double原语的示例中，非常清楚的是浮点计算可能并不精确，因此应该使用BigDecimal进行财务计算。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24ddbedc3035313f2130f7d0cddfdf7f8cd294c6" translate="yes" xml:space="preserve">
          <source>The right way to solve this problem is
  to use &lt;code&gt;BigDecimal&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;
  for monetary calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决此问题的正确方法是使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;long&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 进行货币计算。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e52742575fd81008db5aa9d17b762ab92432faf" translate="yes" xml:space="preserve">
          <source>There are also numerical precision libraries for JavaScript(!) and I think PHP which can handle financial calculations.</source>
          <target state="translated">还有JavaScript(!)的数值精度库,以及我认为可以处理财务计算的PHP。</target>
        </trans-unit>
        <trans-unit id="371fa31f57b417924581fe94e899a89df47b64eb" translate="yes" xml:space="preserve">
          <source>There are also proprietary (particularly, I think, for Fortran) and open-source solutions as well for many computer languages.</source>
          <target state="translated">对于许多计算机语言来说,也有专有的(特别是Fortran)和开源的解决方案。</target>
        </trans-unit>
        <trans-unit id="21e4ce282247987b597c58e3c95cc0139b3c1a34" translate="yes" xml:space="preserve">
          <source>These errors will add-up, may eventually become not easy to ignore anymore. This is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;Error Propagation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这些错误会累加，最终可能变得不容易被忽略。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这称为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;错误传播&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="606eb3e99c5273df8a7722244204e4492f80dd02" translate="yes" xml:space="preserve">
          <source>This is not a matter of accuracy, nor is it a matter of precision.  It is a matter of meeting the expectations of humans who use base 10 for calculations instead of base 2.  For example, using doubles for financial calculations does not produce answers that are &quot;wrong&quot; in a mathematical sense, but it can produce answers that are not what is expected in a financial sense.</source>
          <target state="translated">这不是准确度的问题,也不是精度的问题。它是一个符合人类的期望的问题,因为人类在计算中使用10为基数而不是2为基数的计算方式。比如说,用二进制进行财务计算,不会产生数学意义上的 &quot;错误 &quot;答案,但会产生与财务意义上的预期不符的答案。</target>
        </trans-unit>
        <trans-unit id="8f56a8ad3c064083a6830f9e2e5c107de9737d8b" translate="yes" xml:space="preserve">
          <source>Though &lt;code&gt;BigDecimal&lt;/code&gt; has some caveats (please see currently accepted answer).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尽管&lt;/font&gt;&lt;/font&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有一些警告（请参阅当前接受的答案）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1c094b2ad137115816f31659c9cfbf3826a1f48" translate="yes" xml:space="preserve">
          <source>To add on previous answers, there is also option of implementing &lt;strong&gt;Joda-Money&lt;/strong&gt; in Java, besides BigDecimal, when dealing with the problem addressed in the question. Java modul name is org.joda.money.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了补充以前的答案，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在处理问题中解决的问题时，除了BigDecimal之外，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还可以选择&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用Java &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joda-Money&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java模块名称为org.joda.money。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5b722d8c9d8a1489a2549458ee0e114ae99d0ae" translate="yes" xml:space="preserve">
          <source>To be more precise, there is compile-time dependency but it is not
  required.</source>
          <target state="translated">更准确地说,有编译时依赖性,但不是必须的。</target>
        </trans-unit>
        <trans-unit id="6ac20efd7111b356fc3ce5a15fb213b8f1231c05" translate="yes" xml:space="preserve">
          <source>Using a calculator, or calculating results by hand, 1.40 * 165 = 231 exactly.  However, internally using doubles, on my compiler / operating system environment, it is stored as a binary number close to 230.99999... so if you truncate the number, you get 230 instead of 231.  You may reason that rounding instead of truncating would have given the desired result of 231.  That is true, but rounding always involves truncation.  Whatever rounding technique you use, there are still boundary conditions like this one that will round down when you expect it to round up.  They are rare enough that they often will not be found through casual testing or observation.  You may have to write some code to search for examples that illustrate outcomes that do not behave as expected.</source>
          <target state="translated">使用计算器,或者用手计算结果,1.40*165=231正好是231。然而,在我的编译器操作系统环境中,内部使用双倍数,它被存储为接近230.9999999的二进制数..........所以如果你截断这个数字,你会得到230而不是231。你可能会认为四舍五入而不是截断会得到231的结果。这是事实,但四舍五入总是涉及到截断。无论你使用什么四舍五入技术,仍然有一些边界条件,比如这个,当你期望它四舍五入时,它就会被四舍五入。它们足够少见,通常不会通过偶然的测试或观察来发现。你可能需要写一些代码来搜索一些例子来说明结果不符合预期的结果。</target>
        </trans-unit>
        <trans-unit id="89bf22cfb2377a37cc9d78f04b4c187a794fcdf9" translate="yes" xml:space="preserve">
          <source>Usually because the double type has a precision less than 16 figures. If you require better precision it's not a suitable type. Also approximations can accumulate.</source>
          <target state="translated">通常是因为双倍型的精度小于16位数。如果你要求的精度比较高的话,那就不适合用这种类型。另外,近似值也会累积。</target>
        </trans-unit>
        <trans-unit id="e817fc6c76f182bd2298f7ba72146b08ba8ec723" translate="yes" xml:space="preserve">
          <source>What are the alternatives? There are many (and many more of which I am not aware!).</source>
          <target state="translated">有哪些选择?有很多(而且还有很多我不知道的!)。</target>
        </trans-unit>
        <trans-unit id="e8f3327bd17bd0a003c3cc24469c1b88d03bfce8" translate="yes" xml:space="preserve">
          <source>When using the reference implementation API, the necessary code is much simpler:</source>
          <target state="translated">当使用参考实现API时,必要的代码就简单多了。</target>
        </trans-unit>
        <trans-unit id="9698e43da0a699e4fa5451fdd3c99a90f6671e68" translate="yes" xml:space="preserve">
          <source>When working with collections of MonetaryAmounts, some nice utility methods for filtering, sorting and grouping are available.</source>
          <target state="translated">在处理MonetaryAmounts的集合时,可以使用一些很好的实用方法进行过滤、排序和分组。</target>
        </trans-unit>
        <trans-unit id="27d553d0dc9a1bc2d96bb69efca899ee61467545" translate="yes" xml:space="preserve">
          <source>While it's true that floating point type can represent only approximatively decimal data, it's also true that if one rounds numbers to the necessary precision before presenting them, one obtains the correct result. Usually.</source>
          <target state="translated">虽然浮点类型确实只能表示近似的小数,但如果在显示数字之前将数字四舍五入到必要的精度,就会得到正确的结果,这也是事实。通常情况下。</target>
        </trans-unit>
        <trans-unit id="259be95f8f96400b8780b6bd0febf8a17c39d59b" translate="yes" xml:space="preserve">
          <source>Why not use Double or Float to represent currency</source>
          <target state="translated">为什么不用Double或Float来表示货币?</target>
        </trans-unit>
        <trans-unit id="5d3e3ea709979f27b18302294b7096b2f742d51c" translate="yes" xml:space="preserve">
          <source>You can make it work if you are able to handle the precision and accuracy requirements of your project, which has to be done based on what range of double values is one dealing with.</source>
          <target state="translated">如果你能够处理好你的项目的精度和准确度要求,你就可以做到这一点,这就必须根据一个人处理的双值范围是什么范围来进行。</target>
        </trans-unit>
        <trans-unit id="022bc50d2cd71f6c2d95b26e226d38a8c5773922" translate="yes" xml:space="preserve">
          <source>You can refer to guava's FuzzyCompare method to get more idea. The parameter tolerance is the key. 
We dealt with this problem for a securities trading application and we did an exhaustive research on what tolerances to use for different numerical values in different ranges.</source>
          <target state="translated">大家可以参考guava的FuzzyCompare方法来了解一下。参数的容差是关键。我们在一个证券交易应用中处理这个问题,我们对不同的数值在不同的范围内用什么公差进行了详尽的研究。</target>
        </trans-unit>
        <trans-unit id="796c2136ddb0d07455d54486d96ceb9de93d5885" translate="yes" xml:space="preserve">
          <source>You might, for speed, look into the free and proprietary libraries in C, C++, and Fortran.</source>
          <target state="translated">为了提高速度,你可以看看C、C++和Fortran中的免费和专有库。</target>
        </trans-unit>
        <trans-unit id="c618e14e3f2a441848e8fc5e3abfc132b9f9dca1" translate="yes" xml:space="preserve">
          <source>prints out &lt;code&gt;0.6100000000000001&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;打印出&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.6100000000000001&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea0d137fa0077ce0c7953f0dceb93af4ba0cb4fa" translate="yes" xml:space="preserve">
          <source>results in</source>
          <target state="translated">结果是</target>
        </trans-unit>
        <trans-unit id="4a107da068492bff7b05f2935fa1bd052403861e" translate="yes" xml:space="preserve">
          <source>this probably isn't how you want to represent $1.01.</source>
          <target state="translated">这可能不是你想代表1.01美元的方式。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
