<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/3730019">
    <body>
      <group id="3730019">
        <trans-unit id="09f0a3718fc85408fc3968cd3e73ec142bfdf8e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finally Java has a standard way to work with Currency And Money!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Наконец, у Java есть стандартный способ работы с валютой и деньгами!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="067ffcb87cbcca8f5deb07e1edf7236614c5c3f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Bloch, J., Effective Java, 2nd ed, Item 48:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;От Блоха, Дж. Эффективная Ява, 2-е изд, пункт 48:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5f6e9fc67eabeb616ef60d5d06c36cdfa7f7379" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSR 354: Money and Currency API&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354: API денег и валюты&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f766b6007bcacd14501e3d6f2ddefc6012c887b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sample Examples of JSR 354: Money and Currency API:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примеры JSR 354: деньги и валюта API:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e2aae1a87e35a4fa14d5b8e07a14c874d3e8731" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The specification consists of the following things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Спецификация состоит из следующих вещей:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="279d8b6ec4347409e3a31f9d1293b292eba50459" translate="yes" xml:space="preserve">
          <source>A solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt; class, and C# has the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx&quot;&gt;&lt;code&gt;decimal&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Решение, которое работает практически на любом языке, состоит в использовании целых чисел и подсчете центов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, 1025 будет 10,25 долларов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Несколько языков также имеют встроенные типы для работы с деньгами. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Среди прочего, в Java есть &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;класс &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , а в C # - &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx&quot;&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; тип.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="717c89d37aca9bbeaf61dacfbd6ecf66a6ac4cf6" translate="yes" xml:space="preserve">
          <source>APIs to support interchangeable implementations</source>
          <target state="translated">API для поддержки взаимозаменяемых реализаций</target>
        </trans-unit>
        <trans-unit id="764e3868719a642a94e9c1db3b2399ade06cc23d" translate="yes" xml:space="preserve">
          <source>All specification classes and interfaces are located in the javax.money.* package.</source>
          <target state="translated">Все спецификационные классы и интерфейсы находятся в пакете javax.money.*.</target>
        </trans-unit>
        <trans-unit id="bf91636fa17ae4579edcdf37d35ebfd293f2b61f" translate="yes" xml:space="preserve">
          <source>Also, there might be situations when you're tempted to use Double wrappers as a map key with hash map being the implementation. It is very risky because Double.equals and hash code for example values &quot;0.5&quot; &amp;amp; &quot;0.6 - 0.1&quot; will cause a big mess.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, могут возникнуть ситуации, когда вы захотите использовать двойные обертки в качестве ключа карты, при этом хеш-карта является реализацией. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это очень рискованно, потому что Double.equals и хэш-код, например, значения &amp;laquo;0.5&amp;raquo; и &amp;laquo;0.6 - 0.1&amp;raquo;, вызовут большой беспорядок.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf754cbdda51fd0330c49df312d2b9c5513b384b" translate="yes" xml:space="preserve">
          <source>An API for handling e. g. monetary amounts and currencies</source>
          <target state="translated">API для работы,например,с денежными суммами и валютами.</target>
        </trans-unit>
        <trans-unit id="47f68da097e3b1b2f17304cdd296e6c8b747eb0d" translate="yes" xml:space="preserve">
          <source>An example of creating a MonetaryAmount and printing it to the console looks like this::</source>
          <target state="translated">Пример создания MonetaryAmount и его распечатки в консоли выглядит следующим образом::</target>
        </trans-unit>
        <trans-unit id="c7ad5819035e16732c5be390d7fe2b3aaf867a68" translate="yes" xml:space="preserve">
          <source>Arbitrary precision won't help because there always can be numbers that has so many decimal places, or some results such as &lt;code&gt;0.6666666&lt;/code&gt;... No arbitrary representation will cover the last example. So you will have small errors in each step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Произвольная точность не поможет, потому что всегда могут быть числа с таким количеством десятичных разрядов или некоторые результаты, например, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.6666666&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ... Никакое произвольное представление не будет охватывать последний пример. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, у вас будут небольшие ошибки на каждом этапе.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2e27a448c1442df8dbf814d07126dae13f3ba4b" translate="yes" xml:space="preserve">
          <source>As said earlier &quot;Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, you&amp;rsquo;ll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как говорилось ранее: &amp;laquo;Представление денег в виде двойного числа или числа с плавающей запятой, вероятно, будет хорошо выглядеть сначала, поскольку программное обеспечение округляет крошечные ошибки, но по мере того, как вы будете выполнять больше сложений, вычитаний, умножений и делений на неточных числах, вы потеряете все большую и большую точность по мере того, как ошибки складываются. Это делает поплавки и двойные неадекватными для работы с деньгами, где требуется идеальная точность для кратных степеням базовых 10 &amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b08a01dc6c5fc3334a18152f819d33b8eda77206" translate="yes" xml:space="preserve">
          <source>Assume you want to round something to the nearest penny.  So you take your final result, multiply by 100, add 0.5, truncate, then divide the result by 100 to get back to pennies.  If the internal number you stored was 3.46499999.... instead of 3.465, you are going to get 3.46 instead 3.47 when you round the number to the nearest penny.  But your base 10 calculations may have indicated that the answer should be 3.465 exactly, which clearly should round up to 3.47, not down to 3.46.  These kinds of things happen occasionally in real life when you use doubles for financial calculations.  It is rare, so it often goes unnoticed as an issue, but it happens.</source>
          <target state="translated">Предположим,ты хочешь округлить что-нибудь до ближайшего пенни.Итак,вы берете конечный результат,умножаете на 100,добавляете 0.5,усекаете,затем делите результат на 100,чтобы вернуться к пенни.Если внутреннее число,которое вы сохранили,было 3.46499999...вместо 3.465,вы получите 3.46 вместо 3.47,когда округлите число до ближайшего пенни.Но ваши базовые 10 вычислений,возможно,указали,что ответ должен быть точно 3.465,который явно должен округлить до 3.47,а не до 3.46.Такие вещи иногда случаются в реальной жизни,когда вы используете удвоения для финансовых расчетов.Это случается редко,поэтому часто остается незамеченным,как вопрос,но это случается.</target>
        </trans-unit>
        <trans-unit id="686314d64dfd1b19bdb75704e3275be9ef46537d" translate="yes" xml:space="preserve">
          <source>Because floats and doubles cannot accurately represent the base 10 multiples that we use for money. This issue isn't just for Java, it's for any programming language that uses base 2 floating-point types.</source>
          <target state="translated">Потому что поплавки и удвоения не могут точно представлять базовые 10 кратных чисел,которые мы используем для денег.Эта проблема не только для Java,но и для любого языка программирования,использующего базовые 2 типа с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="d774a91c3005dbfc9d51d54db8523611c0c80ee8" translate="yes" xml:space="preserve">
          <source>BigDecimal in Java is native to the Java language.
Apfloat is another arbitrary-precision library for Java.</source>
          <target state="translated">BigDecimal на Java является родным языком Java.Apfloat-еще одна библиотека произвольной точности для Java.</target>
        </trans-unit>
        <trans-unit id="b94819d8ebaaf6c31dbcb3e0507caf9b63c974e0" translate="yes" xml:space="preserve">
          <source>Coming from a non-computer science background (physics and engineering), I tend to look at problems from a different perspective. For me, the reason why I wouldn't use a double or float in a mathematical calculation is that I would lose too much information.</source>
          <target state="translated">Исходя из фундаментальных знаний в области некомпьютерных наук (физика и инженерия),я склонен смотреть на проблемы под другим углом зрения.Для меня причина,по которой я бы не использовал двойник или плавающий в математических вычислениях,заключается в том,что я бы потерял слишком много информации.</target>
        </trans-unit>
        <trans-unit id="677ba35d3f4b7ef97f05e8f12a39a698e653703d" translate="yes" xml:space="preserve">
          <source>Concluding, in my opinion the double is unsuitable mostly for its 16 digit precision, which can be insufficient, not because it is approximate.</source>
          <target state="translated">В заключение,на мой взгляд,дубль не годится в основном для своей 16-значной точности,которой может быть недостаточно,а не потому,что она приблизительна.</target>
        </trans-unit>
        <trans-unit id="0545f3890164845c72010b8e0ed6d58da24b6375" translate="yes" xml:space="preserve">
          <source>Consider the following output of the subsequent program. It shows that after rounding double give the same result as BigDecimal up to precision 16.</source>
          <target state="translated">Рассмотрим следующий вывод последующей программы.Он показывает,что после двойного округления дают тот же результат,что и BigDecimal с точностью до 16.</target>
        </trans-unit>
        <trans-unit id="e5741882b583d222d3509526f6535f0aca560bcc" translate="yes" xml:space="preserve">
          <source>CurrencyUnit and MonetaryAmount</source>
          <target state="translated">ВалютаПривязка и валютаСумма</target>
        </trans-unit>
        <trans-unit id="a39fe455337c4b0e4fe8c05f871b35046753359b" translate="yes" xml:space="preserve">
          <source>Custom MonetaryAmount operations</source>
          <target state="translated">Пользовательские MonetaryAmount операции</target>
        </trans-unit>
        <trans-unit id="3332fa176aea702f236b003b8db2099175e7e9fe" translate="yes" xml:space="preserve">
          <source>Documentation:
  &lt;a href=&quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&quot;&gt;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Документация: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="381e479c3588e94e6153168dcc0099a4c7380509" translate="yes" xml:space="preserve">
          <source>Even if you round off your results at the last minute before output, you can still occasionally get a result using doubles that does not match expectations.</source>
          <target state="translated">Даже если вы округлите результаты в последнюю минуту перед выходом,вы все равно иногда можете получить результат с помощью удвоений,которые не соответствуют ожиданиям.</target>
        </trans-unit>
        <trans-unit id="739138cb0e4f13fdb2a14bb54aa2436816c625fd" translate="yes" xml:space="preserve">
          <source>Even in base 10, this notation cannot accurately represent most simple fractions. For instance, you can't represent 1/3: the decimal representation is repeating (0.3333...), so there is no finite integer that you can multiply by a power of 10 to get 1/3. You could settle on a long sequence of 3's and a small exponent, like 333333333 * 10&lt;sup&gt;-10&lt;/sup&gt;, but it is not accurate: if you multiply that by 3, you won't get&amp;nbsp;1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Даже в базе 10 эта запись не может точно представлять самые простые дроби. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, вы не можете представить 1/3: десятичное представление повторяется (0.3333 ...), поэтому нет конечного целого числа, которое вы могли бы умножить на степень 10, чтобы получить 1/3. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете рассчитывать на длинную последовательность из 3 и небольшую экспоненту, например 333333333 * 10 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-10&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но это не совсем точно: если вы умножите это на 3, вы не получите 1.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee1869b094937e9a8826f16f45c31d79373b5f4c" translate="yes" xml:space="preserve">
          <source>Examples of using Joda Money:</source>
          <target state="translated">Примеры использования Joda Money:</target>
        </trans-unit>
        <trans-unit id="b5072184cf44d5fe99ebc445de8723c52dba90a9" translate="yes" xml:space="preserve">
          <source>Factories for creating instances of the implementation classes</source>
          <target state="translated">Фабрики по созданию экземпляров классов реализации</target>
        </trans-unit>
        <trans-unit id="40dd3f8de5b5b29b2f97def0749ce28de01e7855" translate="yes" xml:space="preserve">
          <source>Floats and doubles are approximate. If you create a BigDecimal and pass a float into the constructor you see what the float actually equals:</source>
          <target state="translated">Поплавки и двойники приблизительны.Если вы создадите BigDecimal и передадите поплавок в конструктор,то увидите,что на самом деле равно поплавку:</target>
        </trans-unit>
        <trans-unit id="f91c4b87711bc72d9c507486005d248573dcd071" translate="yes" xml:space="preserve">
          <source>For example COBOL, historically used for financial calculations, has a maximum precision of 18 figures. So there is often an implicit rounding.</source>
          <target state="translated">Например,КОБОЛ,исторически использовавшийся для финансовых расчетов,имеет максимальную точность в 18 цифр.Поэтому часто происходит неявное округление.</target>
        </trans-unit>
        <trans-unit id="75c807d28a864927acb8b31d7d3c8ac580f2b9cc" translate="yes" xml:space="preserve">
          <source>For example, suppose you have $1.03
  and you spend 42c. How much money do
  you have left?</source>
          <target state="translated">Например,предположим,что у вас есть 1,03 доллара и вы тратите 42 см.Сколько у вас осталось денег?</target>
        </trans-unit>
        <trans-unit id="9de791eaf216bc3b590abee4d7754d4d8c9d03e5" translate="yes" xml:space="preserve">
          <source>For me, I like BigDecimal because of the methods it supports. C#'s decimal is very nice, but I haven't had the chance to work with it as much as I'd like. I do scientific calculations of interest to me in my spare time, and BigDecimal seems to work very well because I can set the precision of my floating point numbers. The disadvantage to BigDecimal? It can be slow at times, especially if you're using the divide method.</source>
          <target state="translated">Для меня,мне нравится BigDecimal из-за методов,которые он поддерживает.Десятичная дробь на C#очень хороша,но у меня не было возможности работать с ней столько,сколько хотелось бы.В свободное время я занимаюсь научными вычислениями,представляющими для меня интерес,и BigDecimal,кажется,работает очень хорошо,потому что я могу задавать точность моих чисел с плавающей точкой.Недостаток BigDecimal? Время от времени он может быть медленным,особенно если вы используете метод деления.</target>
        </trans-unit>
        <trans-unit id="c1596c5466820636637e428d747fe6a6fbee306e" translate="yes" xml:space="preserve">
          <source>Functionality for calculations, conversion and formatting of monetary            amounts</source>
          <target state="translated">Функциональность для расчетов,конвертации и форматирования денежных сумм</target>
        </trans-unit>
        <trans-unit id="b834495da73d80490ba3f5f0af039bcb1529bbb2" translate="yes" xml:space="preserve">
          <source>Handling money and currencies in Java with JSR 354</source>
          <target state="translated">Обработка денег и валют на Java с помощью JSR 354</target>
        </trans-unit>
        <trans-unit id="1a6c98689987bf69175f5b0dbd14419ab2e195b3" translate="yes" xml:space="preserve">
          <source>However, for the purpose of counting money, at least for countries whose money is valued within an order of magnitude of the US dollar, usually all you need is to be able to store multiples of 10&lt;sup&gt;-2&lt;/sup&gt;, so it doesn't really matter that 1/3 can't be represented.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тем не менее, для подсчета денег, по крайней мере, для стран, чьи деньги оцениваются в пределах порядка доллара США, обычно все, что вам нужно, это иметь возможность хранить кратные числа 10 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , так что это не имеет большого значения эта 1/3 не может быть представлена.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9545c9929da7e9a99ecf7b11d62ec5571358a4ac" translate="yes" xml:space="preserve">
          <source>I have worked on a number of projects with very low gc requirements, and having BigDecimal objects was a big contributor to that overhead.</source>
          <target state="translated">Я работал над несколькими проектами с очень низкими требованиями к gc,и наличие BigDecimal объектов было большим вкладом в эти накладные расходы.</target>
        </trans-unit>
        <trans-unit id="20bcc3b9e6b736283080cd8b942be6364f880be5" translate="yes" xml:space="preserve">
          <source>I'll risk being downvoted, but I think the unsuitability of floating point numbers for currency calculations is overrated. As long as you make sure you do the cent-rounding correctly and have enough significant digits to work with in order to counter the binary-decimal representation mismatch explained by zneak, there will be no problem.</source>
          <target state="translated">Я рискну быть опущенным вниз,но я думаю,что непригодность чисел с плавающей точкой для валютных расчетов переоценена.До тех пор,пока вы убедитесь,что правильно делаете округление с запятой и имеете достаточно значащих цифр для работы с ними,чтобы противодействовать двоично-десятичному несоответствию в представлении,объясняемому zneak,проблем не возникнет.</target>
        </trans-unit>
        <trans-unit id="f3e4618f2467db822b69c46c1fea719a017d4735" translate="yes" xml:space="preserve">
          <source>I'm not a computer scientist by training. However, I tend to lean towards either BigDecimal in Java or decimal in C#. I haven't tried the other solutions I've listed, but they are probably very good as well.</source>
          <target state="translated">Я не компьютерщик по образованию.Тем не менее,я склоняюсь либо к BigDecimal на Java,либо к десятичной на C#.Я не пробовал другие решения,которые я перечислил,но они,вероятно,также очень хороши.</target>
        </trans-unit>
        <trans-unit id="990e7012ab72470facd01fe2c1a1f5d51c224ba0" translate="yes" xml:space="preserve">
          <source>I'm sure there is a very good reason, I simply do not know what it is.</source>
          <target state="translated">Я уверен,что есть очень веская причина,я просто не знаю,что это такое.</target>
        </trans-unit>
        <trans-unit id="0b640dfe453f9fe28f4de0716c715e5b4b78fa5a" translate="yes" xml:space="preserve">
          <source>I'm troubled by some of these responses.  I think doubles and floats have a place in financial calculations.  Certainly, when adding and subtracting non-fractional monetary amounts there will be no loss of precision when using integer classes or BigDecimal classes.  But when performing more complex operations, you often end up with results that go out several or many decimal places, no matter how you store the numbers.  The issue is how you present the result.</source>
          <target state="translated">Меня беспокоят некоторые из этих ответов.Я думаю,что двойные и плавающие имеют место в финансовых расчетах.Конечно,при сложении и вычитании недрагоценных денежных сумм не будет потери точности при использовании классов целочисленных или BigDecimal.Но при выполнении более сложных операций вы часто получаете результаты,которые заканчиваются несколькими или многими знаками после запятой,независимо от того,как вы храните числа.Проблема заключается в том,как представить результат.</target>
        </trans-unit>
        <trans-unit id="98375c7c8b2a2005748c2b911a76c4dfe8d20dc1" translate="yes" xml:space="preserve">
          <source>I've always been told &lt;em&gt;never&lt;/em&gt; to represent money with &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; types, and this time I pose the question to you: why?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мне всегда говорили &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;никогда не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; представлять деньги &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; типами, и на этот раз я задаю вам вопрос: почему?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fcd023b4c00bf2e3b4db4e2b3bfa19a5930150d9" translate="yes" xml:space="preserve">
          <source>If you use base 10 for your internal calculations instead of doubles, the answers are always exactly what is expected by humans, assuming no other bugs in your code.</source>
          <target state="translated">Если вы используете базу 10 для внутренних вычислений вместо дубликатов,то ответы всегда будут в точности такими,какими их ожидают люди,предполагая,что в вашем коде нет других ошибок.</target>
        </trans-unit>
        <trans-unit id="0d316acf25caa86b6df1ed932c3fdc12985946bb" translate="yes" xml:space="preserve">
          <source>If your computation involves various steps, arbitrary precision arithmetic won't cover you 100%.</source>
          <target state="translated">Если ваши вычисления включают в себя различные шаги,то произвольная точная арифметика не покроет вас на 100%.</target>
        </trans-unit>
        <trans-unit id="7358b1f7336f90ad39312beb48de9d969908dbe0" translate="yes" xml:space="preserve">
          <source>If your result is on the borderline between being rounded up and rounded down, and that last penny really matters, you should be probably be telling the viewer that the answer is nearly in the middle - by displaying more decimal places.</source>
          <target state="translated">Если ваш результат находится на границе между округлением вверх и вниз,и что последний пенни действительно имеет значение,вы,вероятно,должны сказать зрителю,что ответ почти посередине-отображая больше десятичных знаков.</target>
        </trans-unit>
        <trans-unit id="89ee989c518fd96a85c276fbbcc76f3a0d201bc3" translate="yes" xml:space="preserve">
          <source>Implementation examples:
  &lt;a href=&quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&quot;&gt;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примеры реализации: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80417b3d4f9b43eb6ff3dba9201d4b848e5acc31" translate="yes" xml:space="preserve">
          <source>In base 10, you can write 10.25 as 1025 * 10&lt;sup&gt;-2&lt;/sup&gt; (an integer times a power of 10). &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE-754 floating-point numbers&lt;/a&gt; are different, but a very simple way to think about them is to multiply by a power of two instead. For instance, you could be looking at 164 * 2&lt;sup&gt;-4&lt;/sup&gt; (an integer times a power of two), which is also equal to 10.25. That's not how the numbers are represented in memory, but the math implications are the same.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В базе 10 вы можете написать 10,25 как 1025 * 10 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (целое число, умноженное на 10). &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Числа с плавающей точкой IEEE-754&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; различны, но очень простой способ думать о них - вместо этого умножить на степень два. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, вы можете посмотреть на 164 * 2 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-4&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (целое число, умноженное на степень два), что также равно 10,25. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это не то, как числа представлены в памяти, но математические значения одинаковы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f85da357aa1787e92299ea8764dc8f1081d232a" translate="yes" xml:space="preserve">
          <source>It doesn't mean though that doubles can never be used for that purpose.</source>
          <target state="translated">Это не значит,что двойники никогда не могут быть использованы для этой цели.</target>
        </trans-unit>
        <trans-unit id="189a0c254a5f6366cf960591b4dcd1af6677fec2" translate="yes" xml:space="preserve">
          <source>It must be said that even if you use fixed point arithmetic you still have to round numbers, were it not for the fact that BigInteger and BigDecimal give errors if you obtain periodic decimal numbers. So there is an approximation also here.</source>
          <target state="translated">Надо сказать,что даже если вы используете арифметику с фиксированной точкой,вам все равно придется округлять числа,если бы не тот факт,что BigInteger и BigDecimal выдают ошибки при получении периодических десятичных чисел.Поэтому здесь также есть аппроксимация.</target>
        </trans-unit>
        <trans-unit id="04b2d7d7bcbb29484271eba8aaf54f4b4bc5cc56" translate="yes" xml:space="preserve">
          <source>It requires Java SE 8 or later and has no dependencies.</source>
          <target state="translated">Он требует Java SE 8 или более поздней версии и не имеет зависимостей.</target>
        </trans-unit>
        <trans-unit id="24d35c472f26d6b1a31b545ab3b7165c01d595eb" translate="yes" xml:space="preserve">
          <source>It's not that the error isn't controllable if you round: &lt;a href=&quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html&quot;&gt;see this article by Peter Lawrey&lt;/a&gt;. It's just easier not to have to round in the first place. Most applications that handle money don't call for a lot of math, the operations consist of adding things or allocating amounts to different buckets. Introducing floating point and rounding just complicates things.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Не то, чтобы ошибка не была управляемой, если вы &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;округлились&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;посмотрите эту статью Питера Лоури&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Просто проще не округлять в первую очередь. Большинство приложений, которые обрабатывают деньги, не требуют большого количества математики, операции состоят из добавления вещей или распределения сумм по разным корзинам. Введение с плавающей запятой и округление просто усложняют вещи.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bd1736b140bbc0f9b6f105c77291011f013e232" translate="yes" xml:space="preserve">
          <source>It's the lack of understanding about double representation and lack of experience in handling the accuracy and precision that brings about this wise suggestion.</source>
          <target state="translated">Именно недостаточное понимание двойного представительства и отсутствие опыта в обращении с точностью и аккуратностью приводят к этому мудрому предложению.</target>
        </trans-unit>
        <trans-unit id="2da89442de0564adb263d4b217cde992b04f1ff9" translate="yes" xml:space="preserve">
          <source>JSR 354 provides an API for representing, transporting, and performing comprehensive calculations with Money and Currency. You can download it from this link:</source>
          <target state="translated">JSR 354 предоставляет API для представления,транспортировки и выполнения комплексных расчетов с Деньгами и Валютой.Вы можете скачать его по этой ссылке:</target>
        </trans-unit>
        <trans-unit id="8f51b176f17789e90549d24d66d084d0377ef75a" translate="yes" xml:space="preserve">
          <source>JSR 354: Money and Currency API Download</source>
          <target state="translated">JSR 354:Деньги и валюта API Скачать</target>
        </trans-unit>
        <trans-unit id="e355bd15d23282effb75249c47fc6278e186ca1e" translate="yes" xml:space="preserve">
          <source>Java API for working with Money and Currencies, which is planned to be included in Java 9.</source>
          <target state="translated">Java API для работы с деньгами и валютами,который планируется включить в Java 9.</target>
        </trans-unit>
        <trans-unit id="70d2f01c0479a64ac9a018a01053853a4ccc0a04" translate="yes" xml:space="preserve">
          <source>Looking into the Java 9 Money and Currency API (JSR 354)</source>
          <target state="translated">Взгляд на Java 9 Денежно-валютный API (JSR 354)</target>
        </trans-unit>
        <trans-unit id="cbc716194c3421d45328f11b1ed734e714f9a899" translate="yes" xml:space="preserve">
          <source>Many of the answers posted to this question discuss IEEE and the standards surrounding floating-point arithmetic.</source>
          <target state="translated">Во многих ответах на этот вопрос обсуждается IEEE и стандарты,окружающие арифметику с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="cafddb4a8f868576fbd86b950274e809cab58f05" translate="yes" xml:space="preserve">
          <source>MonetaryAmount has various methods that allow accessing the assigned currency, the numeric amount, its precision and more:</source>
          <target state="translated">MonetaryAmount имеет различные методы,которые позволяют получить доступ к назначенной валюте,числовой сумме,ее точности и многому другому:</target>
        </trans-unit>
        <trans-unit id="1c047041987b7e92d7fd573c5e62c0f30a2b8bd4" translate="yes" xml:space="preserve">
          <source>MonetaryAmounts can be rounded using a rounding operator:</source>
          <target state="translated">Сумки MonetaryAmounts могут быть округлены с помощью оператора округления:</target>
        </trans-unit>
        <trans-unit id="0cd10f02a4e801b3f271ae2d36c791ac844e9895" translate="yes" xml:space="preserve">
          <source>Most answers have highlighted the reasons why one should not use doubles for money and currency calculations. And I totally agree with them.</source>
          <target state="translated">В большинстве ответов указываются причины,по которым не следует использовать удвоения для расчетов по деньгам и валютам.И я полностью с ними согласен.</target>
        </trans-unit>
        <trans-unit id="8c0a7d98a17c7e3d1315cdf1e4024b71e84be895" translate="yes" xml:space="preserve">
          <source>OUTPUT:</source>
          <target state="translated">OUTPUT:</target>
        </trans-unit>
        <trans-unit id="ab03dc913e6f18c3df668c4f3c27fc3d1b767a73" translate="yes" xml:space="preserve">
          <source>Of course, you have to stay within reason; e.g. a simple webshop would probably never experience any problem with double precision floats, but if you do e.g. accounting or anything else that requires adding a large (unrestricted) amount of numbers, you wouldn't want to touch floating point numbers with a ten foot pole.</source>
          <target state="translated">Конечно,вы должны оставаться в пределах разумного;например,в простом интернет-магазине,вероятно,никогда не возникнет проблем с плавающими числами двойной точности,но если вы делаете,например,учет или что-то еще,что требует добавления большого (неограниченного)количества чисел,вы не захотите касаться чисел с плавающей точкой с десятифутовым полюсом.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="893e9390628cf8793e980bd5c0bc3d738246634a" translate="yes" xml:space="preserve">
          <source>People calculating with currency in Excel have always used double precision floats (there is no currency type in Excel) and I have yet to see anyone complaining about rounding errors.</source>
          <target state="translated">Люди,производящие расчеты с валютой в Excel,всегда использовали floats двойной точности (в Excel нет типа валюты),и я еще не видел,чтобы кто-нибудь жаловался на ошибки округления.</target>
        </trans-unit>
        <trans-unit id="ce0f4ca9377352ec33a36acf2c838b95f364a475" translate="yes" xml:space="preserve">
          <source>Representing money as a &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, errors will compound and you'll end up with values that are visibly not accurate. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Представление денег в виде &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или числа с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , вероятно, сначала будет хорошо смотреться, поскольку программное обеспечение округляет крошечные ошибки, но по мере того, как вы выполняете больше сложений, вычитаний, умножений и делений на неточные числа, ошибки будут складываться, и вы получите значения, которые явно не точны. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это делает поплавки и удвоения неадекватными для работы с деньгами, где требуется идеальная точность для кратных степеням базовых 10.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90bdbcb63d1c58de798fcf3d27eefa22f192272c" translate="yes" xml:space="preserve">
          <source>Resources:</source>
          <target state="translated">Resources:</target>
        </trans-unit>
        <trans-unit id="7466c0c80238bbd71329492766d1f91a178140c9" translate="yes" xml:space="preserve">
          <source>SciPy (Scientific Python) can probably also handle financial calculations (I haven't tried, but I suspect so).</source>
          <target state="translated">SciPy (Научный Питон),вероятно,также может обрабатывать финансовые расчёты (я не пробовал,но подозреваю,что это так).</target>
        </trans-unit>
        <trans-unit id="72dd135113af4bb32b27d846ec53778eaebee82f" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;http://javamoney.github.io/&quot;&gt;JSR 354 - Currency and Money&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Смотрите также: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://javamoney.github.io/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354 - Валюта и деньги&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f7a401d25dd853ca7105588312147327477a4a5" translate="yes" xml:space="preserve">
          <source>Some example... this works (actually don't work as expected), on almost any programming language... I've tried with Delphi, VBScript, Visual Basic, JavaScript and now with Java/Android:</source>
          <target state="translated">Какой-то пример...это работает (на самом деле не работает,как ожидалось),практически на любом языке программирования...Я пробовал с Delphi,VBScript,Visual Basic,JavaScript,а теперь и с JavaAndroid:</target>
        </trans-unit>
        <trans-unit id="aa9645f2ab1c2cb679f21b70df5c102fb0e3e6be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; types are
  particularly ill-suited for monetary
  calculations because it is impossible
  to represent 0.1 (or any other
  negative power of ten) as a &lt;code&gt;float&lt;/code&gt; or
  &lt;code&gt;double&lt;/code&gt; exactly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; типы особенно плохо подходит для денежных расчетов , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;так как невозможно представить 0,1 (или любой другой отрицательной мощности десяти) в виде &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; точности.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37a22ebd44711311bb4fb92a4282d607da8596f5" translate="yes" xml:space="preserve">
          <source>The API also supports calculations with MonetaryAmounts:</source>
          <target state="translated">API также поддерживает расчеты с MonetaryAmounts:</target>
        </trans-unit>
        <trans-unit id="84a8cc07b8a6e7ce2ce3275b890a5f8a8f30b899" translate="yes" xml:space="preserve">
          <source>The GNU Multiple Precision Library (GMP) and the GNU MFPR Library are two free and open-source resources for C and C++.</source>
          <target state="translated">GNU Multiple Precision Library (GMP)и GNU MFPR Library-это два свободных ресурса с открытым исходным кодом для C и C++.</target>
        </trans-unit>
        <trans-unit id="cdef8dba5555ec0beb2b9902e32847ed7611acbb" translate="yes" xml:space="preserve">
          <source>The decimal data type in C# is Microsoft's .NET alternative for 28 significant figures.</source>
          <target state="translated">Десятичный тип данных на C#является альтернативой Microsoft .NET для 28 значащих цифр.</target>
        </trans-unit>
        <trans-unit id="5383c20d2d17e96881c2fda340145ff07c98074b" translate="yes" xml:space="preserve">
          <source>The only reliable way to use a perfect representation of results(Use a custom Fraction data type that will batch division operations to the last step) and only convert to decimal notation in the last step.</source>
          <target state="translated">Единственный надежный способ использовать идеальное представление результатов (Использовать пользовательский тип данных о дробях,который будет пакетно преобразовывать операции деления до последнего шага)и преобразовывать в десятичную нотацию только на последнем шаге.</target>
        </trans-unit>
        <trans-unit id="197911d6c1e58965b7e6611a80d150d7ba686aac" translate="yes" xml:space="preserve">
          <source>The problem is that the IEEE spec doesn't have a way to exactly represent all fractions, some of them end up as repeating fractions so you end up with approximation errors. Since accountants like things to come out exactly to the penny, and customers will be annoyed if they pay their bill and after the payment is processed they owe .01 and they get charged a fee or can't close their account, it's better to use exact types like decimal (in C#) or java.math.BigDecimal in Java.</source>
          <target state="translated">Проблема в том,что спецификация IEEE не имеет возможности точно представить все фракции,некоторые из них заканчиваются как повторяющиеся фракции,так что вы получаете ошибки аппроксимации.Так как бухгалтеры любят,чтобы вещи выходили точно до копейки,и клиенты будут раздражены,если они оплатят свой счет и после обработки платежа они должны .01 и они получают плату или не могут закрыть свой счет,лучше использовать точные типы,такие как десятичная (в C#)или java.math.BigDecimal в Java.</target>
        </trans-unit>
        <trans-unit id="b28f5a973c1343f529f0e63c534d0921c6ab0947" translate="yes" xml:space="preserve">
          <source>The problem with doubles, and more so with floats, is when they are used to combine large numbers and small numbers.  In java,</source>
          <target state="translated">Проблема с удвоениями,а тем более с поплавками,заключается в том,что они используются для объединения больших и малых чисел.На яве,</target>
        </trans-unit>
        <trans-unit id="5b6a4d54cc02b1c3f15e40c24f65fff30e4810f1" translate="yes" xml:space="preserve">
          <source>The problem with floats and doubles is that the &lt;em&gt;vast majority&lt;/em&gt; of money-like numbers don't have an exact representation as an integer times a power of 2. In fact, the only multiples of 0.01 between 0 and 1 (which are significant when dealing with money because they're integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount. As an analogy to the 0.333333 example, if you take the floating-point value for 0.1 and you multiply it by&amp;nbsp;10, you won't get&amp;nbsp;1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Проблема с плавающими и двойными &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;числами &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;состоит в том, что &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;подавляющее большинство&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чисел, подобных деньгам, не имеют точного представления в виде целого числа, умноженного на степень 2. Фактически, единственные кратные 0,01 между 0 и 1 (что важно при работе с с деньгами, потому что они являются целочисленными центами), которые могут быть представлены точно в виде двоичного числа IEEE-754 с плавающей запятой, равного 0, 0,25, 0,5, 0,75 и 1. Все остальные отклонены на небольшое количество. По аналогии с примером 0.333333, если вы возьмете значение с плавающей запятой за 0.1 и умножите его на 10, вы не получите 1.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e74e7a3acd980ae3a6baa90e220277c25718108" translate="yes" xml:space="preserve">
          <source>The result of floating point number is not exact, which makes them unsuitable for any financial calculation which requires exact result and not approximation. float and double are designed for engineering and scientific calculation and many times doesn&amp;rsquo;t produce exact result also result of floating point calculation may vary from JVM to JVM. Look at below example of BigDecimal and double primitive which is used to represent money value, its quite clear that floating point calculation may not be exact and one should use BigDecimal for financial calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Результат числа с плавающей запятой не является точным, что делает его непригодным для любого финансового расчета, который требует точного результата, а не приближения. float и double предназначены для инженерных и научных расчетов и много раз не дают точного результата, а результат вычисления с плавающей запятой может варьироваться от JVM до JVM. Посмотрите на приведенный ниже пример BigDecimal и двойного примитива, который используется для представления денежной стоимости, совершенно ясно, что вычисление с плавающей запятой может быть неточным, и для финансовых расчетов следует использовать BigDecimal.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24ddbedc3035313f2130f7d0cddfdf7f8cd294c6" translate="yes" xml:space="preserve">
          <source>The right way to solve this problem is
  to use &lt;code&gt;BigDecimal&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;
  for monetary calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Правильный способ решения этой проблемы - использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;long&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для денежных расчетов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e52742575fd81008db5aa9d17b762ab92432faf" translate="yes" xml:space="preserve">
          <source>There are also numerical precision libraries for JavaScript(!) and I think PHP which can handle financial calculations.</source>
          <target state="translated">Есть также библиотеки числовой точности для JavaScript(!)и я думаю,что PHP может обрабатывать финансовые вычисления.</target>
        </trans-unit>
        <trans-unit id="371fa31f57b417924581fe94e899a89df47b64eb" translate="yes" xml:space="preserve">
          <source>There are also proprietary (particularly, I think, for Fortran) and open-source solutions as well for many computer languages.</source>
          <target state="translated">Существуют также проприетарные (в частности,я думаю,для Fortran)и открытые решения для многих компьютерных языков.</target>
        </trans-unit>
        <trans-unit id="21e4ce282247987b597c58e3c95cc0139b3c1a34" translate="yes" xml:space="preserve">
          <source>These errors will add-up, may eventually become not easy to ignore anymore. This is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;Error Propagation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эти ошибки будут накапливаться, и в конечном итоге их будет не просто игнорировать. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это называется &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;распространением ошибок&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="606eb3e99c5273df8a7722244204e4492f80dd02" translate="yes" xml:space="preserve">
          <source>This is not a matter of accuracy, nor is it a matter of precision.  It is a matter of meeting the expectations of humans who use base 10 for calculations instead of base 2.  For example, using doubles for financial calculations does not produce answers that are &quot;wrong&quot; in a mathematical sense, but it can produce answers that are not what is expected in a financial sense.</source>
          <target state="translated">Это не вопрос точности и не вопрос точности.Речь идет о том,чтобы оправдать ожидания людей,которые используют для расчетов базу 10 вместо базы 2.Например,использование удвоений для финансовых вычислений не дает ответов,которые являются &quot;неправильными&quot; в математическом смысле,но может дать ответы,которые не являются тем,что ожидается в финансовом смысле.</target>
        </trans-unit>
        <trans-unit id="8f56a8ad3c064083a6830f9e2e5c107de9737d8b" translate="yes" xml:space="preserve">
          <source>Though &lt;code&gt;BigDecimal&lt;/code&gt; has some caveats (please see currently accepted answer).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хотя у &lt;/font&gt;&lt;/font&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; есть некоторые оговорки (см. В настоящее время принятый ответ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1c094b2ad137115816f31659c9cfbf3826a1f48" translate="yes" xml:space="preserve">
          <source>To add on previous answers, there is also option of implementing &lt;strong&gt;Joda-Money&lt;/strong&gt; in Java, besides BigDecimal, when dealing with the problem addressed in the question. Java modul name is org.joda.money.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы добавить к предыдущим ответам, есть также возможность реализации &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joda-Money&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на Java, помимо BigDecimal, при решении проблемы, рассматриваемой в вопросе. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java модуль называется org.joda.money.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5b722d8c9d8a1489a2549458ee0e114ae99d0ae" translate="yes" xml:space="preserve">
          <source>To be more precise, there is compile-time dependency but it is not
  required.</source>
          <target state="translated">Точнее,существует зависимость от времени компиляции,но она не требуется.</target>
        </trans-unit>
        <trans-unit id="6ac20efd7111b356fc3ce5a15fb213b8f1231c05" translate="yes" xml:space="preserve">
          <source>Using a calculator, or calculating results by hand, 1.40 * 165 = 231 exactly.  However, internally using doubles, on my compiler / operating system environment, it is stored as a binary number close to 230.99999... so if you truncate the number, you get 230 instead of 231.  You may reason that rounding instead of truncating would have given the desired result of 231.  That is true, but rounding always involves truncation.  Whatever rounding technique you use, there are still boundary conditions like this one that will round down when you expect it to round up.  They are rare enough that they often will not be found through casual testing or observation.  You may have to write some code to search for examples that illustrate outcomes that do not behave as expected.</source>
          <target state="translated">Используя калькулятор,или вычисляя результаты вручную,1,40*165=231 точно.Однако,при внутреннем использовании удвоений,в окружении моей компиляторной операционной системы,оно хранится как двоичное число,близкое к 230.99999...так что если вы усечёте число,то получите 230 вместо 231.Возможно,Вы можете объяснить,что округление вместо усечения дало бы желаемый результат 231.Это правда,но округление всегда включает в себя усечение.Какой бы метод округления вы ни использовали,существуют граничные условия,подобные этому,которые округляются вниз,когда вы ожидаете округления вверх.Они достаточно редки,и их часто не удается обнаружить с помощью случайного тестирования или наблюдения.Возможно,вам придется написать какой-нибудь код для поиска примеров,иллюстрирующих результаты,которые ведут себя не так,как ожидалось.</target>
        </trans-unit>
        <trans-unit id="89bf22cfb2377a37cc9d78f04b4c187a794fcdf9" translate="yes" xml:space="preserve">
          <source>Usually because the double type has a precision less than 16 figures. If you require better precision it's not a suitable type. Also approximations can accumulate.</source>
          <target state="translated">Обычно потому,что тип double имеет точность менее 16 цифр.Если требуется лучшая точность,то это не подходящий тип.Также могут накапливаться аппроксимации.</target>
        </trans-unit>
        <trans-unit id="e817fc6c76f182bd2298f7ba72146b08ba8ec723" translate="yes" xml:space="preserve">
          <source>What are the alternatives? There are many (and many more of which I am not aware!).</source>
          <target state="translated">Каковы альтернативы? Их много (и еще много,чего я не знаю!).</target>
        </trans-unit>
        <trans-unit id="e8f3327bd17bd0a003c3cc24469c1b88d03bfce8" translate="yes" xml:space="preserve">
          <source>When using the reference implementation API, the necessary code is much simpler:</source>
          <target state="translated">При использовании API реализации ссылок необходимый код намного проще:</target>
        </trans-unit>
        <trans-unit id="9698e43da0a699e4fa5451fdd3c99a90f6671e68" translate="yes" xml:space="preserve">
          <source>When working with collections of MonetaryAmounts, some nice utility methods for filtering, sorting and grouping are available.</source>
          <target state="translated">При работе с коллекциями MonetaryAmounts доступны некоторые приятные утилиты для фильтрации,сортировки и группировки.</target>
        </trans-unit>
        <trans-unit id="27d553d0dc9a1bc2d96bb69efca899ee61467545" translate="yes" xml:space="preserve">
          <source>While it's true that floating point type can represent only approximatively decimal data, it's also true that if one rounds numbers to the necessary precision before presenting them, one obtains the correct result. Usually.</source>
          <target state="translated">Правда,что тип с плавающей точкой может представлять только приблизительные десятичные данные,но верно и то,что если перед представлением числа округлить с нужной точностью,то получится правильный результат.Обычно.</target>
        </trans-unit>
        <trans-unit id="259be95f8f96400b8780b6bd0febf8a17c39d59b" translate="yes" xml:space="preserve">
          <source>Why not use Double or Float to represent currency</source>
          <target state="translated">Почему бы не использовать Double или Float для представления валюты.</target>
        </trans-unit>
        <trans-unit id="5d3e3ea709979f27b18302294b7096b2f742d51c" translate="yes" xml:space="preserve">
          <source>You can make it work if you are able to handle the precision and accuracy requirements of your project, which has to be done based on what range of double values is one dealing with.</source>
          <target state="translated">Вы можете заставить его работать,если вы в состоянии справиться с требованиями к точности и аккуратности вашего проекта,что должно быть сделано на основе того,с каким диапазоном двойных значений иметь дело.</target>
        </trans-unit>
        <trans-unit id="022bc50d2cd71f6c2d95b26e226d38a8c5773922" translate="yes" xml:space="preserve">
          <source>You can refer to guava's FuzzyCompare method to get more idea. The parameter tolerance is the key. 
We dealt with this problem for a securities trading application and we did an exhaustive research on what tolerances to use for different numerical values in different ranges.</source>
          <target state="translated">Вы можете обратиться к методу Гуавы FuzzyCompare,чтобы получить больше идей.Ключом к этому является допуск по параметрам.Мы рассмотрели эту проблему для применения в торговле ценными бумагами и провели исчерпывающее исследование того,какие допуски следует использовать для различных числовых значений в разных диапазонах.</target>
        </trans-unit>
        <trans-unit id="796c2136ddb0d07455d54486d96ceb9de93d5885" translate="yes" xml:space="preserve">
          <source>You might, for speed, look into the free and proprietary libraries in C, C++, and Fortran.</source>
          <target state="translated">Для скорости вы могли бы посмотреть на свободные и несвободные библиотеки на Си,Си++и Фортране.</target>
        </trans-unit>
        <trans-unit id="c618e14e3f2a441848e8fc5e3abfc132b9f9dca1" translate="yes" xml:space="preserve">
          <source>prints out &lt;code&gt;0.6100000000000001&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;распечатывает &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.6100000000000001&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea0d137fa0077ce0c7953f0dceb93af4ba0cb4fa" translate="yes" xml:space="preserve">
          <source>results in</source>
          <target state="translated">приводить к</target>
        </trans-unit>
        <trans-unit id="4a107da068492bff7b05f2935fa1bd052403861e" translate="yes" xml:space="preserve">
          <source>this probably isn't how you want to represent $1.01.</source>
          <target state="translated">возможно,ты не так хочешь представлять $1.01.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
