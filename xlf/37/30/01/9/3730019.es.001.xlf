<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/3730019">
    <body>
      <group id="3730019">
        <trans-unit id="09f0a3718fc85408fc3968cd3e73ec142bfdf8e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finally Java has a standard way to work with Currency And Money!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iexcl;Finalmente Java tiene una forma est&amp;aacute;ndar de trabajar con Currency And Money!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="067ffcb87cbcca8f5deb07e1edf7236614c5c3f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Bloch, J., Effective Java, 2nd ed, Item 48:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De Bloch, J., Effective Java, 2nd ed, Item 48:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5f6e9fc67eabeb616ef60d5d06c36cdfa7f7379" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSR 354: Money and Currency API&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354: API de dinero y divisas&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f766b6007bcacd14501e3d6f2ddefc6012c887b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sample Examples of JSR 354: Money and Currency API:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ejemplos de ejemplo de JSR 354: API de dinero y divisas:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e2aae1a87e35a4fa14d5b8e07a14c874d3e8731" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The specification consists of the following things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La especificaci&amp;oacute;n consta de lo siguiente:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="279d8b6ec4347409e3a31f9d1293b292eba50459" translate="yes" xml:space="preserve">
          <source>A solution that works in just about any language is to use integers instead, and count cents. For instance, 1025 would be $10.25. Several languages also have built-in types to deal with money. Among others, Java  has the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt; class, and C# has the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx&quot;&gt;&lt;code&gt;decimal&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una soluci&amp;oacute;n que funciona en casi cualquier idioma es usar enteros y contar centavos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, 1025 ser&amp;iacute;a $ 10.25. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Varios idiomas tambi&amp;eacute;n tienen tipos incorporados para lidiar con el dinero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entre otros, Java tiene la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;clase &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y C # tiene el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tipo &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/364x0z75.aspx&quot;&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="717c89d37aca9bbeaf61dacfbd6ecf66a6ac4cf6" translate="yes" xml:space="preserve">
          <source>APIs to support interchangeable implementations</source>
          <target state="translated">API para apoyar implementaciones intercambiables</target>
        </trans-unit>
        <trans-unit id="764e3868719a642a94e9c1db3b2399ade06cc23d" translate="yes" xml:space="preserve">
          <source>All specification classes and interfaces are located in the javax.money.* package.</source>
          <target state="translated">Todas las clases de especificaciones e interfaces se encuentran en el paquete javax.money.*</target>
        </trans-unit>
        <trans-unit id="bf91636fa17ae4579edcdf37d35ebfd293f2b61f" translate="yes" xml:space="preserve">
          <source>Also, there might be situations when you're tempted to use Double wrappers as a map key with hash map being the implementation. It is very risky because Double.equals and hash code for example values &quot;0.5&quot; &amp;amp; &quot;0.6 - 0.1&quot; will cause a big mess.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s, puede haber situaciones en las que tenga la tentaci&amp;oacute;n de usar envoltorios dobles como una clave de mapa con el mapa hash como implementaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es muy arriesgado porque Double.equals y el c&amp;oacute;digo hash, por ejemplo, los valores &quot;0.5&quot; y &quot;0.6 - 0.1&quot; causar&amp;aacute;n un gran desastre.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf754cbdda51fd0330c49df312d2b9c5513b384b" translate="yes" xml:space="preserve">
          <source>An API for handling e. g. monetary amounts and currencies</source>
          <target state="translated">Una API para manejar,por ejemplo,cantidades monetarias y monedas</target>
        </trans-unit>
        <trans-unit id="47f68da097e3b1b2f17304cdd296e6c8b747eb0d" translate="yes" xml:space="preserve">
          <source>An example of creating a MonetaryAmount and printing it to the console looks like this::</source>
          <target state="translated">Un ejemplo de la creación de un MonetaryAmount y su impresión en la consola se ve así::</target>
        </trans-unit>
        <trans-unit id="c7ad5819035e16732c5be390d7fe2b3aaf867a68" translate="yes" xml:space="preserve">
          <source>Arbitrary precision won't help because there always can be numbers that has so many decimal places, or some results such as &lt;code&gt;0.6666666&lt;/code&gt;... No arbitrary representation will cover the last example. So you will have small errors in each step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La precisi&amp;oacute;n arbitraria no ayudar&amp;aacute; porque siempre puede haber n&amp;uacute;meros que tengan tantos lugares decimales, o algunos resultados como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.6666666&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ... Ninguna representaci&amp;oacute;n arbitraria cubrir&amp;aacute; el &amp;uacute;ltimo ejemplo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces tendr&amp;aacute; peque&amp;ntilde;os errores en cada paso.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2e27a448c1442df8dbf814d07126dae13f3ba4b" translate="yes" xml:space="preserve">
          <source>As said earlier &quot;Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, you&amp;rsquo;ll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como se dijo anteriormente &quot;Representar el dinero como doble o flotante probablemente se ver&amp;aacute; bien al principio, ya que el software completa los peque&amp;ntilde;os errores, pero a medida que realiza m&amp;aacute;s sumas, restas, multiplicaciones y divisiones en n&amp;uacute;meros inexactos, perder&amp;aacute; m&amp;aacute;s y m&amp;aacute;s precisi&amp;oacute;n a medida que se acumulan los errores. Esto hace que los flotadores y los dobles sean inadecuados para tratar con dinero, donde se requiere una precisi&amp;oacute;n perfecta para m&amp;uacute;ltiplos de potencias de base 10 &quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b08a01dc6c5fc3334a18152f819d33b8eda77206" translate="yes" xml:space="preserve">
          <source>Assume you want to round something to the nearest penny.  So you take your final result, multiply by 100, add 0.5, truncate, then divide the result by 100 to get back to pennies.  If the internal number you stored was 3.46499999.... instead of 3.465, you are going to get 3.46 instead 3.47 when you round the number to the nearest penny.  But your base 10 calculations may have indicated that the answer should be 3.465 exactly, which clearly should round up to 3.47, not down to 3.46.  These kinds of things happen occasionally in real life when you use doubles for financial calculations.  It is rare, so it often goes unnoticed as an issue, but it happens.</source>
          <target state="translated">Supongamos que quieres redondear algo al centavo más cercano.Así que tomas el resultado final,lo multiplicas por 100,sumas 0,5,truncas y divides el resultado por 100 para volver a los centavos.Si el número interno que guardaste fue 3.46499999...en lugar de 3.465,obtendrás 3.46 en lugar de 3.47 cuando redondees el número al centavo más cercano.Pero tus cálculos de base 10 pueden haber indicado que la respuesta debe ser 3,465 exactamente,lo que claramente debe redondear al 3,47,no al 3,46.Este tipo de cosas suceden ocasionalmente en la vida real cuando usas dobles para los cálculos financieros.Es raro,por lo que a menudo pasa desapercibido como un problema,pero sucede.</target>
        </trans-unit>
        <trans-unit id="686314d64dfd1b19bdb75704e3275be9ef46537d" translate="yes" xml:space="preserve">
          <source>Because floats and doubles cannot accurately represent the base 10 multiples that we use for money. This issue isn't just for Java, it's for any programming language that uses base 2 floating-point types.</source>
          <target state="translated">Porque los flotadores y dobles no pueden representar con precisión los 10 múltiplos de base que usamos para el dinero.Esta cuestión no es sólo para Java,es para cualquier lenguaje de programación que utiliza tipos de base 2 de punto flotante.</target>
        </trans-unit>
        <trans-unit id="d774a91c3005dbfc9d51d54db8523611c0c80ee8" translate="yes" xml:space="preserve">
          <source>BigDecimal in Java is native to the Java language.
Apfloat is another arbitrary-precision library for Java.</source>
          <target state="translated">BigDecimal en Java es nativo del lenguaje Java.Apfloat es otra biblioteca de precisión arbitraria para Java.</target>
        </trans-unit>
        <trans-unit id="b94819d8ebaaf6c31dbcb3e0507caf9b63c974e0" translate="yes" xml:space="preserve">
          <source>Coming from a non-computer science background (physics and engineering), I tend to look at problems from a different perspective. For me, the reason why I wouldn't use a double or float in a mathematical calculation is that I would lose too much information.</source>
          <target state="translated">Viniendo de una formación en ciencias no computacionales (física e ingeniería),tiendo a mirar los problemas desde una perspectiva diferente.Para mí,la razón por la que no usaría un doble o un flotador en un cálculo matemático es que perdería demasiada información.</target>
        </trans-unit>
        <trans-unit id="677ba35d3f4b7ef97f05e8f12a39a698e653703d" translate="yes" xml:space="preserve">
          <source>Concluding, in my opinion the double is unsuitable mostly for its 16 digit precision, which can be insufficient, not because it is approximate.</source>
          <target state="translated">En conclusión,en mi opinión el doble es inadecuado sobre todo por su precisión de 16 dígitos,que puede ser insuficiente,no porque sea aproximada.</target>
        </trans-unit>
        <trans-unit id="0545f3890164845c72010b8e0ed6d58da24b6375" translate="yes" xml:space="preserve">
          <source>Consider the following output of the subsequent program. It shows that after rounding double give the same result as BigDecimal up to precision 16.</source>
          <target state="translated">Considere el siguiente resultado del programa subsiguiente.Muestra que después de redondear el doble da el mismo resultado que el BigDecimal hasta una precisión de 16.</target>
        </trans-unit>
        <trans-unit id="e5741882b583d222d3509526f6535f0aca560bcc" translate="yes" xml:space="preserve">
          <source>CurrencyUnit and MonetaryAmount</source>
          <target state="translated">Unidad monetaria y cantidad monetaria</target>
        </trans-unit>
        <trans-unit id="a39fe455337c4b0e4fe8c05f871b35046753359b" translate="yes" xml:space="preserve">
          <source>Custom MonetaryAmount operations</source>
          <target state="translated">Operaciones de Custom MonetaryAmount</target>
        </trans-unit>
        <trans-unit id="3332fa176aea702f236b003b8db2099175e7e9fe" translate="yes" xml:space="preserve">
          <source>Documentation:
  &lt;a href=&quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&quot;&gt;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Documentaci&amp;oacute;n: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://joda-money.sourceforge.net/apidocs/org/joda/money/Money.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="381e479c3588e94e6153168dcc0099a4c7380509" translate="yes" xml:space="preserve">
          <source>Even if you round off your results at the last minute before output, you can still occasionally get a result using doubles that does not match expectations.</source>
          <target state="translated">Incluso si redondea sus resultados en el último minuto antes de la salida,todavía puede obtener ocasionalmente un resultado usando dobles que no coinciden con las expectativas.</target>
        </trans-unit>
        <trans-unit id="739138cb0e4f13fdb2a14bb54aa2436816c625fd" translate="yes" xml:space="preserve">
          <source>Even in base 10, this notation cannot accurately represent most simple fractions. For instance, you can't represent 1/3: the decimal representation is repeating (0.3333...), so there is no finite integer that you can multiply by a power of 10 to get 1/3. You could settle on a long sequence of 3's and a small exponent, like 333333333 * 10&lt;sup&gt;-10&lt;/sup&gt;, but it is not accurate: if you multiply that by 3, you won't get&amp;nbsp;1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Incluso en la base 10, esta notaci&amp;oacute;n no puede representar con precisi&amp;oacute;n la mayor&amp;iacute;a de las fracciones simples. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, no puede representar 1/3: la representaci&amp;oacute;n decimal se repite (0.3333 ...), por lo que no hay un n&amp;uacute;mero entero finito que pueda multiplicar por una potencia de 10 para obtener 1/3. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Podr&amp;iacute;a conformarse con una secuencia larga de 3 y un peque&amp;ntilde;o exponente, como 333333333 * &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10-10&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero no es exacto: si multiplica eso por 3, no obtendr&amp;aacute; 1.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee1869b094937e9a8826f16f45c31d79373b5f4c" translate="yes" xml:space="preserve">
          <source>Examples of using Joda Money:</source>
          <target state="translated">Ejemplos de uso del dinero de Joda:</target>
        </trans-unit>
        <trans-unit id="b5072184cf44d5fe99ebc445de8723c52dba90a9" translate="yes" xml:space="preserve">
          <source>Factories for creating instances of the implementation classes</source>
          <target state="translated">Fábricas para crear instancias de las clases de implementación</target>
        </trans-unit>
        <trans-unit id="40dd3f8de5b5b29b2f97def0749ce28de01e7855" translate="yes" xml:space="preserve">
          <source>Floats and doubles are approximate. If you create a BigDecimal and pass a float into the constructor you see what the float actually equals:</source>
          <target state="translated">Los flotadores y los dobles son aproximados.Si creas un BigDecimal y le pasas un flotador al constructor verás lo que el flotador realmente equivale:</target>
        </trans-unit>
        <trans-unit id="f91c4b87711bc72d9c507486005d248573dcd071" translate="yes" xml:space="preserve">
          <source>For example COBOL, historically used for financial calculations, has a maximum precision of 18 figures. So there is often an implicit rounding.</source>
          <target state="translated">Por ejemplo,el COBOL,históricamente usado para cálculos financieros,tiene una precisión máxima de 18 cifras.Así que a menudo hay un redondeo implícito.</target>
        </trans-unit>
        <trans-unit id="75c807d28a864927acb8b31d7d3c8ac580f2b9cc" translate="yes" xml:space="preserve">
          <source>For example, suppose you have $1.03
  and you spend 42c. How much money do
  you have left?</source>
          <target state="translated">Por ejemplo,supongamos que tienes 1,03 dólares y te gastas 42 centavos.¿Cuánto dinero te queda?</target>
        </trans-unit>
        <trans-unit id="9de791eaf216bc3b590abee4d7754d4d8c9d03e5" translate="yes" xml:space="preserve">
          <source>For me, I like BigDecimal because of the methods it supports. C#'s decimal is very nice, but I haven't had the chance to work with it as much as I'd like. I do scientific calculations of interest to me in my spare time, and BigDecimal seems to work very well because I can set the precision of my floating point numbers. The disadvantage to BigDecimal? It can be slow at times, especially if you're using the divide method.</source>
          <target state="translated">Para mí,me gusta BigDecimal por los métodos que soporta.El decimal de la C#es muy bonito,pero no he tenido la oportunidad de trabajar con él tanto como me gustaría.Hago cálculos científicos de interés para mí en mi tiempo libre,y el BigDecimal parece funcionar muy bien porque puedo establecer la precisión de mis números en coma flotante.¿La desventaja de BigDecimal? Puede ser lento a veces,especialmente si se utiliza el método de división.</target>
        </trans-unit>
        <trans-unit id="c1596c5466820636637e428d747fe6a6fbee306e" translate="yes" xml:space="preserve">
          <source>Functionality for calculations, conversion and formatting of monetary            amounts</source>
          <target state="translated">Funcionalidad para el cálculo,la conversión y el formato de las cantidades monetarias</target>
        </trans-unit>
        <trans-unit id="b834495da73d80490ba3f5f0af039bcb1529bbb2" translate="yes" xml:space="preserve">
          <source>Handling money and currencies in Java with JSR 354</source>
          <target state="translated">Manejar dinero y monedas en Java con JSR 354</target>
        </trans-unit>
        <trans-unit id="1a6c98689987bf69175f5b0dbd14419ab2e195b3" translate="yes" xml:space="preserve">
          <source>However, for the purpose of counting money, at least for countries whose money is valued within an order of magnitude of the US dollar, usually all you need is to be able to store multiples of 10&lt;sup&gt;-2&lt;/sup&gt;, so it doesn't really matter that 1/3 can't be represented.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, con el fin de contar el dinero, al menos para los pa&amp;iacute;ses cuyo dinero est&amp;aacute; valorado dentro de un orden de magnitud del d&amp;oacute;lar estadounidense, generalmente todo lo que necesita es poder almacenar m&amp;uacute;ltiplos de 10 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por lo que realmente no importa ese 1/3 no puede ser representado.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9545c9929da7e9a99ecf7b11d62ec5571358a4ac" translate="yes" xml:space="preserve">
          <source>I have worked on a number of projects with very low gc requirements, and having BigDecimal objects was a big contributor to that overhead.</source>
          <target state="translated">He trabajado en varios proyectos con requisitos de GC muy bajos,y tener objetos BigDecimal ha contribuido en gran medida a esos gastos generales.</target>
        </trans-unit>
        <trans-unit id="20bcc3b9e6b736283080cd8b942be6364f880be5" translate="yes" xml:space="preserve">
          <source>I'll risk being downvoted, but I think the unsuitability of floating point numbers for currency calculations is overrated. As long as you make sure you do the cent-rounding correctly and have enough significant digits to work with in order to counter the binary-decimal representation mismatch explained by zneak, there will be no problem.</source>
          <target state="translated">Me arriesgaré a que me bajen la votación,pero creo que la inadecuación de los números de punto flotante para el cálculo de la moneda está sobrevalorada.Mientras te asegures de hacer el redondeo de centavos correctamente y tengas suficientes dígitos significativos para trabajar con el fin de contrarrestar el desajuste de la representación binaria-declaratoria explicada por zneak,no habrá ningún problema.</target>
        </trans-unit>
        <trans-unit id="f3e4618f2467db822b69c46c1fea719a017d4735" translate="yes" xml:space="preserve">
          <source>I'm not a computer scientist by training. However, I tend to lean towards either BigDecimal in Java or decimal in C#. I haven't tried the other solutions I've listed, but they are probably very good as well.</source>
          <target state="translated">No soy un informático de formación.Sin embargo,tiendo a inclinarme por el BigDecimal en Java o el decimal en C#.No he probado las otras soluciones que he enumerado,pero probablemente sean muy buenas también.</target>
        </trans-unit>
        <trans-unit id="990e7012ab72470facd01fe2c1a1f5d51c224ba0" translate="yes" xml:space="preserve">
          <source>I'm sure there is a very good reason, I simply do not know what it is.</source>
          <target state="translated">Estoy seguro de que hay una muy buena razón,simplemente no sé cuál es.</target>
        </trans-unit>
        <trans-unit id="0b640dfe453f9fe28f4de0716c715e5b4b78fa5a" translate="yes" xml:space="preserve">
          <source>I'm troubled by some of these responses.  I think doubles and floats have a place in financial calculations.  Certainly, when adding and subtracting non-fractional monetary amounts there will be no loss of precision when using integer classes or BigDecimal classes.  But when performing more complex operations, you often end up with results that go out several or many decimal places, no matter how you store the numbers.  The issue is how you present the result.</source>
          <target state="translated">Me preocupan algunas de estas respuestas.Creo que los dobles y las carrozas tienen un lugar en los cálculos financieros.Ciertamente,al sumar y restar cantidades monetarias no fraccionadas no habrá pérdida de precisión al usar clases enteras o clases BigDecimal.Pero cuando se realizan operaciones más complejas,a menudo se termina con resultados que salen con varios o muchos decimales,sin importar cómo se almacenan los números.La cuestión es cómo presentar el resultado.</target>
        </trans-unit>
        <trans-unit id="98375c7c8b2a2005748c2b911a76c4dfe8d20dc1" translate="yes" xml:space="preserve">
          <source>I've always been told &lt;em&gt;never&lt;/em&gt; to represent money with &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; types, and this time I pose the question to you: why?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Siempre me han dicho que &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;nunca&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; represente dinero con &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tipos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y esta vez le hago la pregunta: &amp;iquest;por qu&amp;eacute;?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fcd023b4c00bf2e3b4db4e2b3bfa19a5930150d9" translate="yes" xml:space="preserve">
          <source>If you use base 10 for your internal calculations instead of doubles, the answers are always exactly what is expected by humans, assuming no other bugs in your code.</source>
          <target state="translated">Si usas la base 10 para tus cálculos internos en vez de dobles,las respuestas son siempre exactamente lo que esperan los humanos,asumiendo que no hay otros errores en tu código.</target>
        </trans-unit>
        <trans-unit id="0d316acf25caa86b6df1ed932c3fdc12985946bb" translate="yes" xml:space="preserve">
          <source>If your computation involves various steps, arbitrary precision arithmetic won't cover you 100%.</source>
          <target state="translated">Si tu cálculo implica varios pasos,la aritmética de precisión arbitraria no te cubrirá al 100%.</target>
        </trans-unit>
        <trans-unit id="7358b1f7336f90ad39312beb48de9d969908dbe0" translate="yes" xml:space="preserve">
          <source>If your result is on the borderline between being rounded up and rounded down, and that last penny really matters, you should be probably be telling the viewer that the answer is nearly in the middle - by displaying more decimal places.</source>
          <target state="translated">Si tu resultado está en el límite entre ser redondeado hacia arriba y hacia abajo,y ese último centavo realmente importa,probablemente deberías decirle al espectador que la respuesta está casi en el medio,mostrando más decimales.</target>
        </trans-unit>
        <trans-unit id="89ee989c518fd96a85c276fbbcc76f3a0d201bc3" translate="yes" xml:space="preserve">
          <source>Implementation examples:
  &lt;a href=&quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&quot;&gt;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ejemplos de implementaci&amp;oacute;n: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.programcreek.com/java-api-examples/?api=org.joda.money.Money&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80417b3d4f9b43eb6ff3dba9201d4b848e5acc31" translate="yes" xml:space="preserve">
          <source>In base 10, you can write 10.25 as 1025 * 10&lt;sup&gt;-2&lt;/sup&gt; (an integer times a power of 10). &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE-754 floating-point numbers&lt;/a&gt; are different, but a very simple way to think about them is to multiply by a power of two instead. For instance, you could be looking at 164 * 2&lt;sup&gt;-4&lt;/sup&gt; (an integer times a power of two), which is also equal to 10.25. That's not how the numbers are represented in memory, but the math implications are the same.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En la base 10, puede escribir 10.25 como 1025 * 10 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (un entero multiplicado por una potencia de 10). &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los n&amp;uacute;meros de punto flotante IEEE-754&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; son diferentes, pero una forma muy simple de pensar en ellos es multiplicar por una potencia de dos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, podr&amp;iacute;a estar mirando 164 * 2 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-4&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (un n&amp;uacute;mero entero multiplicado por una potencia de dos), que tambi&amp;eacute;n es igual a 10.25. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;As&amp;iacute; no se representan los n&amp;uacute;meros en la memoria, pero las implicaciones matem&amp;aacute;ticas son las mismas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f85da357aa1787e92299ea8764dc8f1081d232a" translate="yes" xml:space="preserve">
          <source>It doesn't mean though that doubles can never be used for that purpose.</source>
          <target state="translated">Pero eso no significa que los dobles nunca puedan ser usados para ese propósito.</target>
        </trans-unit>
        <trans-unit id="189a0c254a5f6366cf960591b4dcd1af6677fec2" translate="yes" xml:space="preserve">
          <source>It must be said that even if you use fixed point arithmetic you still have to round numbers, were it not for the fact that BigInteger and BigDecimal give errors if you obtain periodic decimal numbers. So there is an approximation also here.</source>
          <target state="translated">Hay que decir que incluso si se utiliza la aritmética de punto fijo todavía hay que redondear los números,si no fuera porque el BigInteger y el BigDecimal dan errores si se obtienen números decimales periódicos.Así que también hay una aproximación aquí.</target>
        </trans-unit>
        <trans-unit id="04b2d7d7bcbb29484271eba8aaf54f4b4bc5cc56" translate="yes" xml:space="preserve">
          <source>It requires Java SE 8 or later and has no dependencies.</source>
          <target state="translated">Requiere Java SE 8 o posterior y no tiene dependencias.</target>
        </trans-unit>
        <trans-unit id="24d35c472f26d6b1a31b545ab3b7165c01d595eb" translate="yes" xml:space="preserve">
          <source>It's not that the error isn't controllable if you round: &lt;a href=&quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html&quot;&gt;see this article by Peter Lawrey&lt;/a&gt;. It's just easier not to have to round in the first place. Most applications that handle money don't call for a lot of math, the operations consist of adding things or allocating amounts to different buckets. Introducing floating point and rounding just complicates things.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No es que el error no sea controlable si redondeas: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://vanillajava.blogspot.com/2011/08/double-your-money-again.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mira este art&amp;iacute;culo de Peter Lawrey&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Es m&amp;aacute;s f&amp;aacute;cil no tener que redondear en primer lugar. La mayor&amp;iacute;a de las aplicaciones que manejan dinero no requieren muchas matem&amp;aacute;ticas, las operaciones consisten en agregar cosas o asignar cantidades a diferentes categor&amp;iacute;as. La introducci&amp;oacute;n de punto flotante y redondeo solo complica las cosas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bd1736b140bbc0f9b6f105c77291011f013e232" translate="yes" xml:space="preserve">
          <source>It's the lack of understanding about double representation and lack of experience in handling the accuracy and precision that brings about this wise suggestion.</source>
          <target state="translated">Es la falta de comprensión sobre la doble representación y la falta de experiencia en el manejo de la exactitud y la precisión lo que provoca esta sabia sugerencia.</target>
        </trans-unit>
        <trans-unit id="2da89442de0564adb263d4b217cde992b04f1ff9" translate="yes" xml:space="preserve">
          <source>JSR 354 provides an API for representing, transporting, and performing comprehensive calculations with Money and Currency. You can download it from this link:</source>
          <target state="translated">JSR 354 proporciona un API para representar,transportar y realizar cálculos completos con Dinero y Moneda.Puedes descargarlo desde este enlace:</target>
        </trans-unit>
        <trans-unit id="8f51b176f17789e90549d24d66d084d0377ef75a" translate="yes" xml:space="preserve">
          <source>JSR 354: Money and Currency API Download</source>
          <target state="translated">JSR 354:Descarga de la API de dinero y divisas</target>
        </trans-unit>
        <trans-unit id="e355bd15d23282effb75249c47fc6278e186ca1e" translate="yes" xml:space="preserve">
          <source>Java API for working with Money and Currencies, which is planned to be included in Java 9.</source>
          <target state="translated">Java API para trabajar con Dinero y Monedas,que se planea incluir en Java 9.</target>
        </trans-unit>
        <trans-unit id="70d2f01c0479a64ac9a018a01053853a4ccc0a04" translate="yes" xml:space="preserve">
          <source>Looking into the Java 9 Money and Currency API (JSR 354)</source>
          <target state="translated">Buscando en el Java 9 Money and Currency API (JSR 354)</target>
        </trans-unit>
        <trans-unit id="cbc716194c3421d45328f11b1ed734e714f9a899" translate="yes" xml:space="preserve">
          <source>Many of the answers posted to this question discuss IEEE and the standards surrounding floating-point arithmetic.</source>
          <target state="translated">Muchas de las respuestas a esta pregunta tratan sobre el IEEE y los estándares de la aritmética de punto flotante.</target>
        </trans-unit>
        <trans-unit id="cafddb4a8f868576fbd86b950274e809cab58f05" translate="yes" xml:space="preserve">
          <source>MonetaryAmount has various methods that allow accessing the assigned currency, the numeric amount, its precision and more:</source>
          <target state="translated">MonetaryAmount tiene varios métodos que permiten acceder a la moneda asignada,la cantidad numérica,su precisión y más:</target>
        </trans-unit>
        <trans-unit id="1c047041987b7e92d7fd573c5e62c0f30a2b8bd4" translate="yes" xml:space="preserve">
          <source>MonetaryAmounts can be rounded using a rounding operator:</source>
          <target state="translated">Los montos monetarios pueden ser redondeados usando un operador de redondeo:</target>
        </trans-unit>
        <trans-unit id="0cd10f02a4e801b3f271ae2d36c791ac844e9895" translate="yes" xml:space="preserve">
          <source>Most answers have highlighted the reasons why one should not use doubles for money and currency calculations. And I totally agree with them.</source>
          <target state="translated">La mayoría de las respuestas han destacado las razones por las que no se deben utilizar dobles para el cálculo del dinero y la moneda.Y estoy totalmente de acuerdo con ellas.</target>
        </trans-unit>
        <trans-unit id="8c0a7d98a17c7e3d1315cdf1e4024b71e84be895" translate="yes" xml:space="preserve">
          <source>OUTPUT:</source>
          <target state="translated">OUTPUT:</target>
        </trans-unit>
        <trans-unit id="ab03dc913e6f18c3df668c4f3c27fc3d1b767a73" translate="yes" xml:space="preserve">
          <source>Of course, you have to stay within reason; e.g. a simple webshop would probably never experience any problem with double precision floats, but if you do e.g. accounting or anything else that requires adding a large (unrestricted) amount of numbers, you wouldn't want to touch floating point numbers with a ten foot pole.</source>
          <target state="translated">Por supuesto,hay que mantenerse dentro de lo razonable;por ejemplo,una simple tienda virtual probablemente nunca experimentaría ningún problema con flotadores de doble precisión,pero si se hace,por ejemplo,contabilidad o cualquier otra cosa que requiera añadir una gran cantidad (no restringida)de números,no querrás tocar los números de punto flotante con un palo de diez pies.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="893e9390628cf8793e980bd5c0bc3d738246634a" translate="yes" xml:space="preserve">
          <source>People calculating with currency in Excel have always used double precision floats (there is no currency type in Excel) and I have yet to see anyone complaining about rounding errors.</source>
          <target state="translated">La gente que calcula con moneda en Excel siempre ha usado flotadores de doble precisión (no hay ningún tipo de moneda en Excel)y aún no he visto a nadie quejándose de errores de redondeo.</target>
        </trans-unit>
        <trans-unit id="ce0f4ca9377352ec33a36acf2c838b95f364a475" translate="yes" xml:space="preserve">
          <source>Representing money as a &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, errors will compound and you'll end up with values that are visibly not accurate. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Representar el dinero como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; probablemente se ver&amp;aacute; bien al principio, ya que el software completa los peque&amp;ntilde;os errores, pero a medida que realiza m&amp;aacute;s sumas, restas, multiplicaciones y divisiones en n&amp;uacute;meros inexactos, los errores se acumular&amp;aacute;n y terminar&amp;aacute; con valores que son visiblemente no precisos &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto hace que los flotadores y los dobles sean inadecuados para tratar con dinero, donde se requiere una precisi&amp;oacute;n perfecta para m&amp;uacute;ltiplos de potencias de base 10.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90bdbcb63d1c58de798fcf3d27eefa22f192272c" translate="yes" xml:space="preserve">
          <source>Resources:</source>
          <target state="translated">Resources:</target>
        </trans-unit>
        <trans-unit id="7466c0c80238bbd71329492766d1f91a178140c9" translate="yes" xml:space="preserve">
          <source>SciPy (Scientific Python) can probably also handle financial calculations (I haven't tried, but I suspect so).</source>
          <target state="translated">SciPy (Scientific Python)probablemente también puede manejar los cálculos financieros (no lo he intentado,pero lo sospecho).</target>
        </trans-unit>
        <trans-unit id="72dd135113af4bb32b27d846ec53778eaebee82f" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;http://javamoney.github.io/&quot;&gt;JSR 354 - Currency and Money&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ver tambi&amp;eacute;n: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://javamoney.github.io/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JSR 354 - Moneda y dinero&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f7a401d25dd853ca7105588312147327477a4a5" translate="yes" xml:space="preserve">
          <source>Some example... this works (actually don't work as expected), on almost any programming language... I've tried with Delphi, VBScript, Visual Basic, JavaScript and now with Java/Android:</source>
          <target state="translated">Algún ejemplo...esto funciona (en realidad no funciona como se esperaba),en casi cualquier lenguaje de programación...He probado con Delphi,VBScript,Visual Basic,JavaScript y ahora con JavaAndroid:</target>
        </trans-unit>
        <trans-unit id="aa9645f2ab1c2cb679f21b70df5c102fb0e3e6be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; types are
  particularly ill-suited for monetary
  calculations because it is impossible
  to represent 0.1 (or any other
  negative power of ten) as a &lt;code&gt;float&lt;/code&gt; or
  &lt;code&gt;double&lt;/code&gt; exactly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tipos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; son particularmente inadecuados para los c&amp;aacute;lculos monetarios porque es imposible representar 0.1 (o cualquier otra potencia negativa de diez) como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;float&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; exactamente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37a22ebd44711311bb4fb92a4282d607da8596f5" translate="yes" xml:space="preserve">
          <source>The API also supports calculations with MonetaryAmounts:</source>
          <target state="translated">El API también soporta cálculos con MonetaryAmounts:</target>
        </trans-unit>
        <trans-unit id="84a8cc07b8a6e7ce2ce3275b890a5f8a8f30b899" translate="yes" xml:space="preserve">
          <source>The GNU Multiple Precision Library (GMP) and the GNU MFPR Library are two free and open-source resources for C and C++.</source>
          <target state="translated">La Biblioteca de Precisión Múltiple de GNU (GMP)y la Biblioteca MFPR de GNU son dos recursos libres y de código abierto para C y C++.</target>
        </trans-unit>
        <trans-unit id="cdef8dba5555ec0beb2b9902e32847ed7611acbb" translate="yes" xml:space="preserve">
          <source>The decimal data type in C# is Microsoft's .NET alternative for 28 significant figures.</source>
          <target state="translated">El tipo de datos decimales en C#es la alternativa .NET de Microsoft para 28 cifras significativas.</target>
        </trans-unit>
        <trans-unit id="5383c20d2d17e96881c2fda340145ff07c98074b" translate="yes" xml:space="preserve">
          <source>The only reliable way to use a perfect representation of results(Use a custom Fraction data type that will batch division operations to the last step) and only convert to decimal notation in the last step.</source>
          <target state="translated">La única forma fiable de utilizar una representación perfecta de los resultados (utilizar un tipo de datos de fracción personalizado que agrupe las operaciones de división hasta el último paso)y sólo convertir a notación decimal en el último paso.</target>
        </trans-unit>
        <trans-unit id="197911d6c1e58965b7e6611a80d150d7ba686aac" translate="yes" xml:space="preserve">
          <source>The problem is that the IEEE spec doesn't have a way to exactly represent all fractions, some of them end up as repeating fractions so you end up with approximation errors. Since accountants like things to come out exactly to the penny, and customers will be annoyed if they pay their bill and after the payment is processed they owe .01 and they get charged a fee or can't close their account, it's better to use exact types like decimal (in C#) or java.math.BigDecimal in Java.</source>
          <target state="translated">El problema es que la especificación del IEEE no tiene una forma de representar exactamente todas las fracciones,algunas de ellas terminan como fracciones repetidas,por lo que terminan con errores de aproximación.Como a los contables les gusta que las cosas salgan exactamente al centavo,y los clientes se molestarán si pagan su factura y después de que el pago se procese deben .01 y se les cobra un cargo o no pueden cerrar su cuenta,es mejor usar tipos exactos como decimal (en C#)o java.math.BigDecimal en Java.</target>
        </trans-unit>
        <trans-unit id="b28f5a973c1343f529f0e63c534d0921c6ab0947" translate="yes" xml:space="preserve">
          <source>The problem with doubles, and more so with floats, is when they are used to combine large numbers and small numbers.  In java,</source>
          <target state="translated">El problema con los dobles,y más aún con los flotadores,es cuando se utilizan para combinar números grandes y pequeños.En Java,</target>
        </trans-unit>
        <trans-unit id="5b6a4d54cc02b1c3f15e40c24f65fff30e4810f1" translate="yes" xml:space="preserve">
          <source>The problem with floats and doubles is that the &lt;em&gt;vast majority&lt;/em&gt; of money-like numbers don't have an exact representation as an integer times a power of 2. In fact, the only multiples of 0.01 between 0 and 1 (which are significant when dealing with money because they're integer cents) that can be represented exactly as an IEEE-754 binary floating-point number are 0, 0.25, 0.5, 0.75 and 1. All the others are off by a small amount. As an analogy to the 0.333333 example, if you take the floating-point value for 0.1 and you multiply it by&amp;nbsp;10, you won't get&amp;nbsp;1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El problema con los flotadores y los dobles es que la &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;gran mayor&amp;iacute;a&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de los n&amp;uacute;meros similares al dinero no tienen una representaci&amp;oacute;n exacta como un n&amp;uacute;mero entero multiplicado por una potencia de 2. De hecho, los &amp;uacute;nicos m&amp;uacute;ltiplos de 0.01 entre 0 y 1 (que son significativos cuando se trata con dinero porque son centavos enteros) que se pueden representar exactamente como un n&amp;uacute;mero de punto flotante binario IEEE-754 son 0, 0.25, 0.5, 0.75 y 1. Todos los dem&amp;aacute;s est&amp;aacute;n apagados por una peque&amp;ntilde;a cantidad. Como analog&amp;iacute;a con el ejemplo de 0.333333, si toma el valor de coma flotante para 0.1 y lo multiplica por 10, no obtendr&amp;aacute; 1.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e74e7a3acd980ae3a6baa90e220277c25718108" translate="yes" xml:space="preserve">
          <source>The result of floating point number is not exact, which makes them unsuitable for any financial calculation which requires exact result and not approximation. float and double are designed for engineering and scientific calculation and many times doesn&amp;rsquo;t produce exact result also result of floating point calculation may vary from JVM to JVM. Look at below example of BigDecimal and double primitive which is used to represent money value, its quite clear that floating point calculation may not be exact and one should use BigDecimal for financial calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El resultado del n&amp;uacute;mero de coma flotante no es exacto, lo que los hace inadecuados para cualquier c&amp;aacute;lculo financiero que requiera un resultado exacto y no una aproximaci&amp;oacute;n. float y double est&amp;aacute;n dise&amp;ntilde;ados para c&amp;aacute;lculos de ingenier&amp;iacute;a y cient&amp;iacute;ficos y muchas veces no producen resultados exactos, tambi&amp;eacute;n el resultado del c&amp;aacute;lculo de coma flotante puede variar de JVM a JVM. Mire el siguiente ejemplo de BigDecimal y doble primitivo que se usa para representar el valor monetario, es bastante claro que el c&amp;aacute;lculo de coma flotante puede no ser exacto y uno debe usar BigDecimal para los c&amp;aacute;lculos financieros.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24ddbedc3035313f2130f7d0cddfdf7f8cd294c6" translate="yes" xml:space="preserve">
          <source>The right way to solve this problem is
  to use &lt;code&gt;BigDecimal&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;
  for monetary calculations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La forma correcta de resolver este problema es usar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;long&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para los c&amp;aacute;lculos monetarios.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e52742575fd81008db5aa9d17b762ab92432faf" translate="yes" xml:space="preserve">
          <source>There are also numerical precision libraries for JavaScript(!) and I think PHP which can handle financial calculations.</source>
          <target state="translated">También hay librerías de precisión numérica para JavaScript(!)y creo que PHP que puede manejar los cálculos financieros.</target>
        </trans-unit>
        <trans-unit id="371fa31f57b417924581fe94e899a89df47b64eb" translate="yes" xml:space="preserve">
          <source>There are also proprietary (particularly, I think, for Fortran) and open-source solutions as well for many computer languages.</source>
          <target state="translated">También hay soluciones propietarias (en particular,creo que para Fortran)y de código abierto,así como para muchos lenguajes informáticos.</target>
        </trans-unit>
        <trans-unit id="21e4ce282247987b597c58e3c95cc0139b3c1a34" translate="yes" xml:space="preserve">
          <source>These errors will add-up, may eventually become not easy to ignore anymore. This is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;Error Propagation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Estos errores se sumar&amp;aacute;n, y eventualmente ya no ser&amp;aacute; f&amp;aacute;cil ignorarlos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto se llama &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;propagaci&amp;oacute;n de error&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="606eb3e99c5273df8a7722244204e4492f80dd02" translate="yes" xml:space="preserve">
          <source>This is not a matter of accuracy, nor is it a matter of precision.  It is a matter of meeting the expectations of humans who use base 10 for calculations instead of base 2.  For example, using doubles for financial calculations does not produce answers that are &quot;wrong&quot; in a mathematical sense, but it can produce answers that are not what is expected in a financial sense.</source>
          <target state="translated">Esto no es una cuestión de precisión,ni tampoco de exactitud.Es cuestión de cumplir las expectativas de los humanos que usan la base 10 para los cálculos en lugar de la base 2.Por ejemplo,el uso de dobles para los cálculos financieros no produce respuestas &quot;erróneas&quot; en un sentido matemático,pero puede producir respuestas que no son lo que se espera en un sentido financiero.</target>
        </trans-unit>
        <trans-unit id="8f56a8ad3c064083a6830f9e2e5c107de9737d8b" translate="yes" xml:space="preserve">
          <source>Though &lt;code&gt;BigDecimal&lt;/code&gt; has some caveats (please see currently accepted answer).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aunque &lt;/font&gt;&lt;/font&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiene algunas advertencias (consulte la respuesta actualmente aceptada).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1c094b2ad137115816f31659c9cfbf3826a1f48" translate="yes" xml:space="preserve">
          <source>To add on previous answers, there is also option of implementing &lt;strong&gt;Joda-Money&lt;/strong&gt; in Java, besides BigDecimal, when dealing with the problem addressed in the question. Java modul name is org.joda.money.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para agregar respuestas anteriores, tambi&amp;eacute;n existe la opci&amp;oacute;n de implementar &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joda-Money&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en Java, adem&amp;aacute;s de BigDecimal, cuando se trata el problema abordado en la pregunta. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El nombre del m&amp;oacute;dulo Java es org.joda.money.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5b722d8c9d8a1489a2549458ee0e114ae99d0ae" translate="yes" xml:space="preserve">
          <source>To be more precise, there is compile-time dependency but it is not
  required.</source>
          <target state="translated">Para ser más precisos,existe una dependencia de tiempo de compilación pero no es necesaria.</target>
        </trans-unit>
        <trans-unit id="6ac20efd7111b356fc3ce5a15fb213b8f1231c05" translate="yes" xml:space="preserve">
          <source>Using a calculator, or calculating results by hand, 1.40 * 165 = 231 exactly.  However, internally using doubles, on my compiler / operating system environment, it is stored as a binary number close to 230.99999... so if you truncate the number, you get 230 instead of 231.  You may reason that rounding instead of truncating would have given the desired result of 231.  That is true, but rounding always involves truncation.  Whatever rounding technique you use, there are still boundary conditions like this one that will round down when you expect it to round up.  They are rare enough that they often will not be found through casual testing or observation.  You may have to write some code to search for examples that illustrate outcomes that do not behave as expected.</source>
          <target state="translated">Usando una calculadora,o calculando los resultados a mano,1.40*165=231 exactamente.Sin embargo,internamente usando dobles,en el entorno del sistema operativo de mi compilador,se almacena como un número binario cercano a 230.99999...así que si truncamos el número,obtenemos 230 en lugar de 231.Puedes razonar que redondear en lugar de truncar habría dado el resultado deseado de 231.Eso es cierto,pero el redondeo siempre implica el truncamiento.Sea cual sea la técnica de redondeo que uses,todavía hay condiciones de límites como ésta que se redondearán hacia abajo cuando esperes que se redondee hacia arriba.Son lo suficientemente raras como para que a menudo no se encuentren a través de pruebas u observaciones casuales.Es posible que tenga que escribir algún código para buscar ejemplos que ilustren resultados que no se comportan como se esperaba.</target>
        </trans-unit>
        <trans-unit id="89bf22cfb2377a37cc9d78f04b4c187a794fcdf9" translate="yes" xml:space="preserve">
          <source>Usually because the double type has a precision less than 16 figures. If you require better precision it's not a suitable type. Also approximations can accumulate.</source>
          <target state="translated">Normalmente porque el tipo doble tiene una precisión inferior a 16 cifras.Si se requiere una mayor precisión,no es un tipo adecuado.También las aproximaciones pueden acumularse.</target>
        </trans-unit>
        <trans-unit id="e817fc6c76f182bd2298f7ba72146b08ba8ec723" translate="yes" xml:space="preserve">
          <source>What are the alternatives? There are many (and many more of which I am not aware!).</source>
          <target state="translated">¿Cuáles son las alternativas? Hay muchas (¡y muchas más de las que no soy consciente!).</target>
        </trans-unit>
        <trans-unit id="e8f3327bd17bd0a003c3cc24469c1b88d03bfce8" translate="yes" xml:space="preserve">
          <source>When using the reference implementation API, the necessary code is much simpler:</source>
          <target state="translated">Cuando se utiliza la API de implementación de referencia,el código necesario es mucho más sencillo:</target>
        </trans-unit>
        <trans-unit id="9698e43da0a699e4fa5451fdd3c99a90f6671e68" translate="yes" xml:space="preserve">
          <source>When working with collections of MonetaryAmounts, some nice utility methods for filtering, sorting and grouping are available.</source>
          <target state="translated">Cuando se trabaja con colecciones de Montajes Monetarios,se dispone de algunos métodos útiles para filtrar,clasificar y agrupar.</target>
        </trans-unit>
        <trans-unit id="27d553d0dc9a1bc2d96bb69efca899ee61467545" translate="yes" xml:space="preserve">
          <source>While it's true that floating point type can represent only approximatively decimal data, it's also true that if one rounds numbers to the necessary precision before presenting them, one obtains the correct result. Usually.</source>
          <target state="translated">Si bien es cierto que el tipo de punto flotante puede representar sólo aproximadamente datos decimales,también es cierto que si se redondean los números con la precisión necesaria antes de presentarlos,se obtiene el resultado correcto.Normalmente.</target>
        </trans-unit>
        <trans-unit id="259be95f8f96400b8780b6bd0febf8a17c39d59b" translate="yes" xml:space="preserve">
          <source>Why not use Double or Float to represent currency</source>
          <target state="translated">¿Por qué no usar Doble o Flotante para representar la moneda</target>
        </trans-unit>
        <trans-unit id="5d3e3ea709979f27b18302294b7096b2f742d51c" translate="yes" xml:space="preserve">
          <source>You can make it work if you are able to handle the precision and accuracy requirements of your project, which has to be done based on what range of double values is one dealing with.</source>
          <target state="translated">Puede hacer que funcione si es capaz de manejar los requisitos de precisión y exactitud de su proyecto,lo cual tiene que hacerse en base a qué rango de valores dobles se trata.</target>
        </trans-unit>
        <trans-unit id="022bc50d2cd71f6c2d95b26e226d38a8c5773922" translate="yes" xml:space="preserve">
          <source>You can refer to guava's FuzzyCompare method to get more idea. The parameter tolerance is the key. 
We dealt with this problem for a securities trading application and we did an exhaustive research on what tolerances to use for different numerical values in different ranges.</source>
          <target state="translated">Puedes referirte al método FuzzyCompare de la guayaba para hacerte una idea.La tolerancia del parámetro es la clave.Tratamos este problema para una aplicación de comercio de valores e hicimos una investigación exhaustiva sobre qué tolerancias usar para diferentes valores numéricos en diferentes rangos.</target>
        </trans-unit>
        <trans-unit id="796c2136ddb0d07455d54486d96ceb9de93d5885" translate="yes" xml:space="preserve">
          <source>You might, for speed, look into the free and proprietary libraries in C, C++, and Fortran.</source>
          <target state="translated">Podrías,para mayor velocidad,buscar en las librerías libres y propietarias en C,C++y Fortran.</target>
        </trans-unit>
        <trans-unit id="c618e14e3f2a441848e8fc5e3abfc132b9f9dca1" translate="yes" xml:space="preserve">
          <source>prints out &lt;code&gt;0.6100000000000001&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;imprime &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0.6100000000000001&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea0d137fa0077ce0c7953f0dceb93af4ba0cb4fa" translate="yes" xml:space="preserve">
          <source>results in</source>
          <target state="translated">resulta en</target>
        </trans-unit>
        <trans-unit id="4a107da068492bff7b05f2935fa1bd052403861e" translate="yes" xml:space="preserve">
          <source>this probably isn't how you want to represent $1.01.</source>
          <target state="translated">probablemente no es así como quieres representar 1,01 dólares.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
