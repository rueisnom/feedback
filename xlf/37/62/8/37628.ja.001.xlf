<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/37628">
    <body>
      <group id="37628">
        <trans-unit id="76e6755cb5cf7ea2a882d92a0160c1d456f7a307" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AccessibleObject&lt;/code&gt; allows suppression of access checks if the necessary &lt;code&gt;ReflectPermission&lt;/code&gt; is available.</source>
          <target state="translated">&lt;code&gt;AccessibleObject&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用すると、必要な&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ReflectPermission&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が使用可能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;な場合にアクセスチェックを抑制&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="39efd8e310f8ce4c0f2d605df069aa7f3af1100c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hibernate&lt;/code&gt; chose &lt;code&gt;reflection&lt;/code&gt; because it has minimal impact on the build process for an application.</source>
          <target state="translated">&lt;code&gt;Hibernate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アプリケーションのビルドプロセスへの影響が最小限であるため、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hibernate&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;reflection&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;選択&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しまし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;た。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1abe26519d6d02eee7c63f5db0048f72effe89e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Reflection&lt;/code&gt; has many &lt;strong&gt;uses&lt;/strong&gt;. The one I am more familiar with, is to be able to create code on the fly.</source>
          <target state="translated">&lt;code&gt;Reflection&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は多くの&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用途&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;があり&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私がよく知っているのは、その場でコードを作成できることです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2cce7d499ca058a2437bf7339a31236939770c77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;java.lang.reflect&lt;/code&gt; package provides classes and interfaces for obtaining reflective information about classes and objects. Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</source>
          <target state="translated">&lt;code&gt;java.lang.reflect&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パッケージは、クラスとオブジェクトに関するリフレクト情報を取得するためのクラスとインターフェースを提供します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションを使用すると、読み込まれたクラスのフィールド、メソッド、コンストラクターに関する情報にプログラムからアクセスでき、リフレクトされたフィールド、メソッド、コンストラクターを使用して、セキュリティ制限内で対応するフィールドを操作できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3263b2c8e5e8dad3181f60ed7d5ff3ad1e0d372f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Debugging and testing tools:&lt;/em&gt; Debuggers use the property of reflection to examine private members on classes.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;デバッグおよびテストツール：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;デバッガーはリフレクションのプロパティを使用して、クラスのプライベートメンバーを調べます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="267dc8219745212321ac176413d4c94adca30a05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Exposure of Internals:&lt;/em&gt; Reflective code breaks abstractions and therefore may change behaviour with upgrades of the platform.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内部の露出：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクティブコードは抽象化を破壊するため、プラットフォームのアップグレードによって動作が変わる可能性があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cbfa1487aca6a5660de89dd102bde0c1c17545e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Extensibility Features:&lt;/em&gt; An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;拡張機能：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アプリケーションは、完全修飾名を使用して拡張オブジェクトのインスタンスを作成することにより、外部のユーザー定義クラスを利用できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7e35d05e9225bc40318edb029e92b9221cf09f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Insecure use of its functions conducted from within a system code can also easily lead to the compromise of a Java security mode&lt;/em&gt;l. &lt;strong&gt;&lt;em&gt;So use this feature sparingly&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;システムコード内から実行されるその機能の安全でない使用も、Javaセキュリティモードの侵害につながる可能性があります&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、この機能は慎重に使用してください&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d41e8a8fba94b4d81b8d5bd6e7cf8bdf1eefc8d9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Performance Overhead:&lt;/em&gt; Reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パフォーマンスのオーバーヘッド：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクティブ操作は、非リフレクティブ操作よりもパフォーマンスが遅いため、パフォーマンスに敏感なアプリケーションで頻繁に呼び出されるコードのセクションでは避けてください。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c915f0bd00f8e6b012946d1f700aaa3ed64dbd3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Drawbacks of Reflection:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションの欠点：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87c6e54c26e0d51710b1bde8afda98446607c4ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;General abuses:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一般的な虐待：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f3e691ba1d34f66cf36e41a992eab2a9d5d408b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;User of Reflection:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションのユーザー：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa9a74fe5b677cca7bf44297e356b2ac51b61601" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A quick Java Reflection example to show you what using reflection looks like:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションの使用がどのように見えるかを示す簡単なJavaリフレクションの例：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c1a08dcc59d69c190a602baff7d91a19e330e4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages of Using Reflection:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションを使用する利点：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f397612a47bec94ad695255d033038d2522a78f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Class&lt;/strong&gt; The &lt;code&gt;getClass()&lt;/code&gt; method is used to get the name of the class to which an object belongs.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラス&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ザ・&lt;/font&gt;&lt;/font&gt; &lt;code&gt;getClass()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドは、オブジェクトが属するクラスの名前を取得するために使用されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c7588922df25af8ae3e7d84556122b47c9788b7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructors&lt;/strong&gt; The &lt;code&gt;getConstructors()&lt;/code&gt; method is used to get the public constructors of the class to which an object belongs.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンストラクタ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getConstructors()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドは、オブジェクトが属するクラスのパブリックコンストラクタを取得するために使用されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5b6eed8acc664104c3f5ddf8eb8ffc72c0b4ea7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Drawbacks of Reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションの欠点&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c418adcde6dca33f2113e643b3cf7aa3e0d8fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Drawbacks:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Drawbacks:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d38ebd5c771c17c46c4d33de4e05fd33d6ac45f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: After almost 1 year I am editing this answer as while reading about reflection I got few more uses of Reflection.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;編集&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：ほぼ1年後、私はこの回答を編集しています。リフレクションについて読みながら、リフレクションのいくつかの使用法を得ました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d9e8fd103683e9aa854d2eeed4c37db80eb4ede" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Exposure of Internals&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内部の暴露&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61df392d4c2c65b0d121e33ddf25034ec22b3e90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensibility Features&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;拡張機能&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67f058ae58b2f7815f80d243b58b2301bdcc1f70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Methods&lt;/strong&gt; The &lt;code&gt;getMethods()&lt;/code&gt; method is used to get the public methods of the class to which an objects belongs.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッド&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getMethods()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドは、オブジェクトが属するクラスのpublicメソッドを取得するために使用されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bee72a5bdb9095800c3ce5443e8515bcb89c5a64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance Overhead&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パフォーマンスのオーバーヘッド&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b38d24c2f6248a08d1e522f5d9bfb4c0ff3b9e2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflection&lt;/strong&gt; can be used to get information about &amp;ndash;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクション&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用して、次の情報を取得できます&amp;ndash;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="800b9231b7f82f8ae67b04bb2964d334fdd281c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflection&lt;/strong&gt; is a language's ability to inspect and dynamically call classes, methods, attributes, etc. at runtime.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクション&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、実行時にクラス、メソッド、属性などを検査して動的に呼び出す言語の機能です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1552193a224a7dc7dc501a889de6a813238c8a6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflection&lt;/strong&gt; is an API which is used to examine or modify the behaviour of &lt;em&gt;methods, classes, interfaces&lt;/em&gt; at runtime.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクション&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実行時&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッド、クラス、インターフェースの&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;動作を検査または変更するために使用されるAPI &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5bd8a53de58e1ef9ec971b35d223f86ba6d6212a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Security Restrictions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;セキュリティ制限&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="778b38d2a4a2b95315242cc54697e20caf993e63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update from a comment:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コメントから更新：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f35f58f37b1538bdfd364dbe78010cac8348c35a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Uses of Reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションの使用&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c9ce074852cbddff495458254730c1017607102" translate="yes" xml:space="preserve">
          <source>A different example would be a unit-test of a private method. One way to do so is to create a reflection and change the method's scope to public in the test's set-up phase. Of course one can argue private methods shouldn't be tested directly but that's not the point.</source>
          <target state="translated">別の例として、プライベートメソッドのユニットテストがあります。これを行う1つの方法は、テストのセットアップ段階でリフレクトを作成し、メソッドのスコープをpublicに変更することです。もちろん、プライベートメソッドを直接テストすべきではないと主張することもできますが、それは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="bca38910ed77d521afc94527effc9909183faece" translate="yes" xml:space="preserve">
          <source>A practical example of using reflections would be a Java Language Server written in Java or a PHP Language Server written in PHP, etc. Language Server gives your IDE abilities like autocomplete, jump to definition, context help, hinting types and more. In order to have all tag names (words that can be autocompleted) to show all the possible matches as you type the Language Server has to inspect everything about the class including doc blocks and private members. For that it needs a reflection of said class.</source>
          <target state="translated">リフレクションを使用する実用的な例としては、Java で書かれた Java 言語サーバや PHP で書かれた PHP 言語サーバなどがあります。Language Server は、オートコンプリート、定義へのジャンプ、コンテキストヘルプ、ヒント型などの機能を IDE に提供します。すべてのタグ名 (オートコンプリート可能な単語)を使用して、入力時に一致する可能性のあるすべてのタグを表示するために、言語サーバは、doc ブロックやプライベートメンバを含むクラスに関するすべての情報を検査する必要があります。そのためには、クラスの反映が必要です。</target>
        </trans-unit>
        <trans-unit id="f712e1ab9f7444585d3113d90a826187db60eb20" translate="yes" xml:space="preserve">
          <source>Alternatively works &lt;code&gt;Lombok Project&lt;/code&gt;. It just injects code at compile time, result in code being inserted into your domain classes. (I think it is OK for getters and setters)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Lombok Project&lt;/code&gt; で動作し&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイル時にコードを挿入するだけで、ドメインクラスにコードが挿入されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（ゲッターとセッターは問題ないと思います）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d85b2f6bdd2e23adc756e771b97a67cb296aa3b" translate="yes" xml:space="preserve">
          <source>An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.
Class Browsers and Visual Development Environments
A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.
Debuggers and Test Tools
Debuggers need to be able to examine private members in classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to ensure a high level of code coverage in a test suite.</source>
          <target state="translated">アプリケーションは、完全修飾名を使用して拡張性オブジェクトのインスタンスを作成することで、外部のユーザ定義クラスを利用することができます。クラス・ブラウザと視覚的な開発環境 クラス・ブラウザは、クラスのメンバを列挙できる必要があります。視覚的な開発環境では、リフレクションで利用可能な型情報を利用することで、正しいコードを書くために開発者を支援することができます。デバッガとテストツール デバッガは、クラスのプライベートメンバを調べることができる必要があります。テストハーネスは、テストスイートで高いレベルのコードカバレッジを保証するために、クラスに定義された発見可能なAPIのセットを体系的に呼び出すためにリフレクションを利用することができます。</target>
        </trans-unit>
        <trans-unit id="cc45f1793412faaa4a56959b5f8838af9b2c8ec5" translate="yes" xml:space="preserve">
          <source>And finally, the most comprehensive example is &lt;a href=&quot;http://www.springframework.org/&quot;&gt;Spring&lt;/a&gt; which uses reflection to create its beans, and for its heavy use of proxies</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして最後に、最も包括的な例は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、Beanを作成するためにリフレクションを使用し、プロキシを多用する&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.springframework.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Springです&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c9a5c4733b5d39d0014e51ebae4c5efb4c65d7c" translate="yes" xml:space="preserve">
          <source>And finally, yes, the concepts are pretty much similar in other statically typed languages which support reflection (like C#). In dynamically typed languages, the use case described above is less necessary (since the compiler will allow any method to be called on any object, failing at runtime if it does not exist), but the second case of looking for methods which are marked or work in a certain way is still common.</source>
          <target state="translated">そして最後に、(C#のような)リフレクションをサポートしている他の静的型付け言語でも、この概念は非常によく似ています。動的型付けされた言語では、上記の使用例はあまり必要ありません(コンパイラは任意のオブジェクトに対して任意のメソッドを呼び出すことを許可し、それが存在しない場合は実行時に失敗するからです)。</target>
        </trans-unit>
        <trans-unit id="0b518e10771b9253bdd4fc733405e465373ffaf4" translate="yes" xml:space="preserve">
          <source>And from Java 7 we have &lt;code&gt;MethodHandles&lt;/code&gt;, which works as &lt;code&gt;Reflection API&lt;/code&gt;. In projects, to work with loggers we just copy-paste the next code:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、Java 7以降には&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt; &lt;code&gt;Reflection API&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;として機能する&lt;/font&gt;&lt;/font&gt; &lt;code&gt;MethodHandles&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;があり&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プロジェクトでは、ロガーを操作するために、次のコードをコピーして貼り付けます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="98106d65797a34619f72a02cb51b7d2dc74338bf" translate="yes" xml:space="preserve">
          <source>Another example would be the Java API for XML Parsing &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_API_for_XML_Processing&quot;&gt;(JAXP)&lt;/a&gt;. Where an XML parser provider is 'plugged-in' via well-known system properties, which are used to construct new instances through reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もう1つの例は、Java API for XML Parsing &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_API_for_XML_Processing&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（JAXP）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;XMLパーサープロバイダーが、リフレクションを通じて新しいインスタンスを構築するために使用される既知のシステムプロパティを介して「プラグイン」されている場合。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2677ff031c51b9e6180e8fe1a179c64f0a10160" translate="yes" xml:space="preserve">
          <source>As I find it best to explain by example and none of the answers seem to do that...</source>
          <target state="translated">例を挙げて説明するのが一番だと思いますが、どの答えもそれをしていないようです...</target>
        </trans-unit>
        <trans-unit id="f002a793bb200d428bfb3a57f359de8a68a61d85" translate="yes" xml:space="preserve">
          <source>As name itself suggest it reflects what it holds for example class method,etc apart from providing feature to invoke method creating instance dynamically at runtime.</source>
          <target state="translated">名前からも分かるように、実行時に動的にインスタンスを生成するメソッドを呼び出す機能とは別に、クラスメソッドなどを保持している内容を反映しています。</target>
        </trans-unit>
        <trans-unit id="ca04a01c15dacb15e63a42b4719d12252a2f8fc8" translate="yes" xml:space="preserve">
          <source>As per my understanding:</source>
          <target state="translated">私の理解では</target>
        </trans-unit>
        <trans-unit id="4a30e97f958985a613983df7e9a9f4147937428e" translate="yes" xml:space="preserve">
          <source>Because it is hard to make typo-error in this case.</source>
          <target state="translated">この場合、誤字脱字が起きにくいからです。</target>
        </trans-unit>
        <trans-unit id="d2fd967478b11175693c52637e16182d67678925" translate="yes" xml:space="preserve">
          <source>Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations cannot be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts and should be avoided in sections of code which are called frequently in performance-sensitive applications.</source>
          <target state="translated">反射は動的に解決される型を含むため、特定の Java 仮想マシン最適化は実行できません。その結果、反射操作は非反射操作に比べてパフォーマンスが低下するため、パフォーマンスが重視されるアプリケーションで頻繁に呼び出されるコードのセクションでは避けた方がよいでしょう。</target>
        </trans-unit>
        <trans-unit id="75cec77203d8a3c3bbb133724432d2b16ed9c414" translate="yes" xml:space="preserve">
          <source>Classes in this package, along with &lt;code&gt;java.lang.Class&lt;/code&gt; accommodate applications such as debuggers, interpreters, object inspectors, class browsers, and services such as &lt;code&gt;Object Serialization&lt;/code&gt; and &lt;code&gt;JavaBeans&lt;/code&gt; that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このパッケージのクラスは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.Class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とともに、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;デバッガー、インタープリター、オブジェクトインスペクター、クラスブラウザー、および&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Object Serialization&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;や&lt;/font&gt;&lt;/font&gt; &lt;code&gt;JavaBeans&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などのサービス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に対応します。ランタイムクラス）または特定のクラスによって宣言されたメンバー&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cabd73d2b2f6bec7dcefa96fbed5523c29e5e5fa" translate="yes" xml:space="preserve">
          <source>Creating new instances of objects.</source>
          <target state="translated">オブジェクトの新しいインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="f5b464b3897b8c535381e2d8a17e39881cec6f04" translate="yes" xml:space="preserve">
          <source>Creation of new object instances, methods invocation, getting or setting field values of a restricted class.</source>
          <target state="translated">新規オブジェクトインスタンスの作成、メソッドの呼び出し、制限されたクラスのフィールド値の取得・設定</target>
        </trans-unit>
        <trans-unit id="984fe3ba3e70d02a7d3335b8bfb0d79f0b528af1" translate="yes" xml:space="preserve">
          <source>Debugger and Test Tools etc.</source>
          <target state="translated">デバッガ、テストツールなど</target>
        </trans-unit>
        <trans-unit id="310d3e06116a3c41ab7d32a30a08a2f122bcb2f3" translate="yes" xml:space="preserve">
          <source>Exactly how all this works is explained here</source>
          <target state="translated">これがどのように機能するかは、ここで説明されています。</target>
        </trans-unit>
        <trans-unit id="c175f05d7eb96cebecf6a41d3073e0e90c3ed97d" translate="yes" xml:space="preserve">
          <source>Examining properties of a class (fields, methods, constructors),</source>
          <target state="translated">クラスのプロパティ(フィールド、メソッド、コンストラクタ)を調べる。</target>
        </trans-unit>
        <trans-unit id="5594aeaa90d29ada020371584fb08ffe991ec816" translate="yes" xml:space="preserve">
          <source>For Private methods,</source>
          <target state="translated">プライベートメソッドの場合。</target>
        </trans-unit>
        <trans-unit id="693196b805e9eefa4595e0678693d6606e5c3833" translate="yes" xml:space="preserve">
          <source>For example, all objects in Java have the method &lt;code&gt;getClass()&lt;/code&gt;, which lets you determine the object's class even if you don't know it at compile time (e.g. if you declared it as an &lt;code&gt;Object&lt;/code&gt;) - this might seem trivial, but such reflection is not possible in less dynamic languages such as &lt;code&gt;C++&lt;/code&gt;. More advanced uses lets you list and call methods, constructors, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、Javaのすべてのオブジェクトにはメソッド&lt;/font&gt;&lt;/font&gt; &lt;code&gt;getClass()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;があります。これにより、コンパイル時にオブジェクトのクラスがわからない場合でも（たとえば、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Object&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;として宣言した場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）、これは簡単に思えるかもしれませんが、そのようなリフレクションは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などの動的でない言語では不可能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;より高度な使用法では、メソッドやコンストラクターなどをリストして呼び出すことができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6fb9254fbf60efc7b954b5ba670c968e6ee3a01e" translate="yes" xml:space="preserve">
          <source>For example, say you have an object of an unknown type in Java, and you would like to call a 'doSomething' method on it if one exists. Java's static typing system isn't really designed to support this unless the object conforms to a known interface, but using reflection, your code can look at the object and find out if it has a method called 'doSomething' and then call it if you want to.</source>
          <target state="translated">例えば、Javaに未知の型のオブジェクトがあり、そのオブジェクトに 'doSomething' メソッドがあればそれを呼び出したいとします。Javaの静的型付けシステムは、オブジェクトが既知のインターフェイスに準拠していない限り、これをサポートするように設計されていませんが、リフレクションを使用すると、コードはオブジェクトを見て、'doSomething'と呼ばれるメソッドがあるかどうかを見つけ、必要に応じてそれを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="7fdc810374fe9dfa3045213c9b7a12737ef416f6" translate="yes" xml:space="preserve">
          <source>For inspection of classes (also know as introspection) you don't need to import the reflection package (&lt;code&gt;java.lang.reflect&lt;/code&gt;). Class metadata can be accessed through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラスのインスペクション（イントロスペクションとも呼ばれ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.reflect&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）では&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、リフレクションパッケージ（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;java.lang.reflect&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をインポートする必要はありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラスのメタデータには、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.Class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;からアクセスでき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e00d01d41832cb3c81dfdf9609e05666593eb6a8" translate="yes" xml:space="preserve">
          <source>For private fields,</source>
          <target state="translated">プライベートフィールド用。</target>
        </trans-unit>
        <trans-unit id="850912486e2e27fec1a678a7817806ccd05f4f34" translate="yes" xml:space="preserve">
          <source>From java documentation &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html&quot;&gt;page&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Javaドキュメント&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ページ&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b57123908782edab0f9d5315a27bbbc06bd9567" translate="yes" xml:space="preserve">
          <source>From this &lt;a href=&quot;http://www.ibm.com/developerworks/library/j-dyn0603/&quot;&gt;article&lt;/a&gt; (by Dennis Sosnoski, President, Sosnoski Software Solutions, Inc)  and this &lt;a href=&quot;http://www.security-explorations.com/materials/se-2012-01-report.pdf&quot;&gt;article&lt;/a&gt; (security-explorations pdf):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/library/j-dyn0603/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;記事&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（Sosnoski Software Solutions、Inc、社長、Dennis Sosnoski）とこの&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.security-explorations.com/materials/se-2012-01-report.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;記事&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（security-explorations pdf）から：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="973d454cb269a335664d77c5a64d777b1349ce93" translate="yes" xml:space="preserve">
          <source>Have a look at this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;documentation&lt;/a&gt; link for the methods exposed by &lt;strong&gt;&lt;em&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;strong&gt;&lt;em&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;によって公開されているメソッドについては、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ドキュメント&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リンクを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ご覧&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34deaa41eea028ce9992343bd939a2b019e0bfbf" translate="yes" xml:space="preserve">
          <source>Have a look at this SE question regarding abuse of reflection feature:</source>
          <target state="translated">反射機能の乱用に関するSEの質問を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c60cc8d0b33ec9707ca888b5d0cc96c2d441df1b" translate="yes" xml:space="preserve">
          <source>Here is some example:</source>
          <target state="translated">ここではその一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="eea4d3e68f79645621537952d7885a21a986a764" translate="yes" xml:space="preserve">
          <source>How do I read a private field in Java?</source>
          <target state="translated">Javaでプライベートフィールドを読むには?</target>
        </trans-unit>
        <trans-unit id="f5dcee71779b03aaff859733ff309c6577746074" translate="yes" xml:space="preserve">
          <source>I can see considerable drawbacks than uses of using Reflection</source>
          <target state="translated">リフレクションの使い方よりも、かなりの欠点があると思います。</target>
        </trans-unit>
        <trans-unit id="254f8a9369907f42f3509935f7f7c87622baa519" translate="yes" xml:space="preserve">
          <source>I just want to add some point to all that was listed.</source>
          <target state="translated">挙げられていたすべてのことに、何点か付け加えたいと思います。</target>
        </trans-unit>
        <trans-unit id="0f9631de6c8595f344b280ad2df45d2bdc6cb1b9" translate="yes" xml:space="preserve">
          <source>I want to answer this question by example. First of all &lt;code&gt;Hibernate&lt;/code&gt; project uses &lt;code&gt;Reflection API&lt;/code&gt; to generate &lt;code&gt;CRUD&lt;/code&gt; statements to bridge the chasm between the running application and the persistence store. When things change in the domain, the &lt;code&gt;Hibernate&lt;/code&gt; has to know about them to persist them to the data store and vice versa.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この質問に例を挙げて答えたいと思います。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;まず、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Hibernate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プロジェクトは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Reflection API&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用して&lt;/font&gt;&lt;/font&gt; &lt;code&gt;CRUD&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ステートメントを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;生成し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、実行中のアプリケーションと永続ストアの間のギャップを埋めます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ドメインで変更があった場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Hibernate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はそれらをデータストアに永続化するためにそれらについて知る必要があり、その逆も同様です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59ea7d8a60e63123865790fbb39afca4b577dbbe" translate="yes" xml:space="preserve">
          <source>I'm particularly interested in Java, but I assume the principles are the same in any language.</source>
          <target state="translated">私は特にJavaに興味がありますが、原理はどの言語でも同じだと思います。</target>
        </trans-unit>
        <trans-unit id="4e63bac98f2a6938d9fab00930c2876281232d32" translate="yes" xml:space="preserve">
          <source>IDE (Integrated Development Environment) e.g. Eclipse, MyEclipse, NetBeans etc.</source>
          <target state="translated">IDE (統合開発環境)Eclipse、MyEclipse、NetBeansなど。</target>
        </trans-unit>
        <trans-unit id="0adeb6df453a9aaf352a57864918b02b12305438" translate="yes" xml:space="preserve">
          <source>IE: dynamic classes, functions, constructors - based on any data
  (xml/array/sql results/hardcoded/etc..)</source>
          <target state="translated">IE:動的なクラス、関数、コンストラクタ-任意のデータ (xmlarraysql の結果ハードコードされたものなど)に基づいています。</target>
        </trans-unit>
        <trans-unit id="589a59e1de357ac295cf54fd7d57ea897e25f5a4" translate="yes" xml:space="preserve">
          <source>In C# for example you can load an assembly (a .dll) in runtime an examine it, navigating through the classes and taking actions according to what you found. It also let you create an instance of a class on runtime, invoke its method, etc.</source>
          <target state="translated">例えばC#では、ランタイムにアセンブリ(.dll)をロードして、それを調べ、クラスをナビゲートして、見つけたものに応じてアクションを取ることができます。また、実行時にクラスのインスタンスを作成したり、メソッドを呼び出したりすることもできます。</target>
        </trans-unit>
        <trans-unit id="e2c488cd992bbd3e18da0edfcfb16bdc9c8d6e3e" translate="yes" xml:space="preserve">
          <source>In above example the null parameter is the object you want to invoke the method on. If the method is static you supply null. If the method is not static, then while invoking you need to supply a valid MyObject instance instead of null.</source>
          <target state="translated">上の例では、nullパラメータにはメソッドを呼び出したいオブジェクトを指定しています。メソッドが静的な場合は null を指定します。メソッドが静的でない場合は、メソッドを呼び出す際に null の代わりに有効な MyObject インスタンスを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="823d0c56e8aa92cf5babf3278a56092f4ee027c9" translate="yes" xml:space="preserve">
          <source>Instead, by using reflection, there is need to worry about a possibly changing class name.</source>
          <target state="translated">その代わりにリフレクションを利用することで、クラス名が変更される可能性を心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="f66396f7168221b2bf84c5dcc35135d1e55d77e3" translate="yes" xml:space="preserve">
          <source>Invoking methods,</source>
          <target state="translated">メソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="ffda05e922f9a6bcf056ba767a3e49ccdf042dbd" translate="yes" xml:space="preserve">
          <source>It  allows violation of key Java security constraints such
as data access protection and type safety</source>
          <target state="translated">データアクセス保護や型の安全性など、主要なJavaセキュリティ制約の違反を可能にします。</target>
        </trans-unit>
        <trans-unit id="542d0b30181db440cde9bf0e2ad31c763156bc7b" translate="yes" xml:space="preserve">
          <source>It bypasses the source code can create maintenance problems</source>
          <target state="translated">それは、ソースコードをバイパスしてメンテナンスの問題を作成することができます。</target>
        </trans-unit>
        <trans-unit id="a23ed20b481cccd78ea2932605cc56e463dd42e8" translate="yes" xml:space="preserve">
          <source>It can obscure what's actually going on inside your code</source>
          <target state="translated">コードの中で実際に何が起こっているのかが不明瞭になることがあります。</target>
        </trans-unit>
        <trans-unit id="bf0127f8da675ab2d8ff724e917268c8d041e581" translate="yes" xml:space="preserve">
          <source>It includes following functionality.</source>
          <target state="translated">以下の機能が含まれています。</target>
        </trans-unit>
        <trans-unit id="6aa0dcbeeb964726e2fdcf8fed08463e02aa3b69" translate="yes" xml:space="preserve">
          <source>It is frequently used in scenarios where a class name changes frequently. If such a situation arises, then it is complicated for the programmer to rewrite the application and change the name of the class again and again.</source>
          <target state="translated">クラス名が頻繁に変更されるシナリオで頻繁に使用されます。このような状況が発生した場合、プログラマーはアプリケーションを書き換えたり、クラス名を何度も変更したりする必要があり、煩雑です。</target>
        </trans-unit>
        <trans-unit id="bd269443759350e48ed7bdc11388a81f11912bc4" translate="yes" xml:space="preserve">
          <source>It is used by many frameworks and application under the wood to invoke services without actually knowing the code.</source>
          <target state="translated">実際にはコードを知らなくてもサービスを呼び出せるように、多くのフレームワークや木の下のアプリケーションで利用されています。</target>
        </trans-unit>
        <trans-unit id="8bc170fa614d477d4ecf0a540e8a358361ec7d71" translate="yes" xml:space="preserve">
          <source>It is useful at debugging.</source>
          <target state="translated">デバッグ時に便利です。</target>
        </trans-unit>
        <trans-unit id="cdcb9f4cc5e879ab063042e5b93d78cf2a07fdc9" translate="yes" xml:space="preserve">
          <source>It is useful for creating libraries that work with objects in very general ways</source>
          <target state="translated">非常に一般的な方法でオブジェクトを扱うライブラリを作成するのに便利です。</target>
        </trans-unit>
        <trans-unit id="7f230118147515166a5ef34dfbd9f3ebe67b3e4c" translate="yes" xml:space="preserve">
          <source>It provides very versatile way of dynamically linking program components</source>
          <target state="translated">プログラムコンポーネントを動的にリンクする非常に汎用性の高い方法を提供します。</target>
        </trans-unit>
        <trans-unit id="1f33d88e3b05279f20e9d11df744b730f18886fd" translate="yes" xml:space="preserve">
          <source>It will then again use reflection to get the appropriate setter for the &amp;lt; property &amp;gt; element and set its value to the specified value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次に、再びリフレクションを使用して&amp;lt;property&amp;gt;要素の適切なセッターを取得し、その値を指定された値に設定します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1faa80fe2d86f9a33996d2c1b07db9ecff718f1" translate="yes" xml:space="preserve">
          <source>It's useful because it allows you to change the runtime behavior depending on the meta information of your program, that is, you can check the return type of a function and change the way you handle the situation.</source>
          <target state="translated">プログラムのメタ情報に応じて実行時の挙動を変えられる、つまり関数の戻り値の型を確認して対処法を変えることができるので便利です。</target>
        </trans-unit>
        <trans-unit id="9529d68eae9b702b42f4214bdc3e902aa6e05c92" translate="yes" xml:space="preserve">
          <source>It's usefull in a lot of situations. Everywhere you want to be able to dynamically plug in classes into your code. Lot's of object relational mappers use reflection to be able to instantiate objects from databases without knowing in advance what objects they're going to use. Plug-in architectures is another place where reflection is usefull. Being able to dynamically load code and determine if there are types there that implement the right interface to use as a plugin is important in those situations.</source>
          <target state="translated">これは多くの状況で有用です。コードの中にクラスを動的にプラグインできるようにしたい場合はどこでもそうです。多くのオブジェクトリレーショナルマッパーは、どのオブジェクトを使用するかを事前に知らなくても、 データベースからオブジェクトをインスタンス化できるようにリフレクションを使用しています。プラグインアーキテクチャは、リフレクションが有用な別の場所です。動的にコードをロードして、プラグインとして使用するのに適したインターフェイスを実装した型があるかどうかを判断できることは、このような状況では重要です。</target>
        </trans-unit>
        <trans-unit id="e3c24576ba302c22f5da6c285a19a92312766907" translate="yes" xml:space="preserve">
          <source>Java Reflection is quite powerful and can be very useful.
Java Reflection makes it possible &lt;strong&gt;to inspect classes, interfaces, fields and methods at runtime,&lt;/strong&gt; without knowing the names of the classes, methods etc. at compile time.
It is also possible to &lt;strong&gt;instantiate new objects, invoke methods and get/set field values using reflection.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Javaリフレクションは非常に強力であり、非常に便利です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Javaリフレクションを使用すると&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、コンパイル時にクラス、メソッドなどの名前を知らなくても、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実行時にクラス、インターフェース、フィールド、およびメソッドを検査&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でき&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションを使用して、新しいオブジェクト&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インスタンス化し、メソッドを呼び出し、フィールド値を取得/設定する&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;こともでき&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec6f30c063fcb9ef481489312513588e235d3aa2" translate="yes" xml:space="preserve">
          <source>Junit uses Reflection especially for testing Private/Protected methods.</source>
          <target state="translated">Junitは特にPrivateProtectedメソッドのテストにReflectionを使用しています。</target>
        </trans-unit>
        <trans-unit id="477383916e2dc5b2c68531150a4c99e526ed2157" translate="yes" xml:space="preserve">
          <source>Loading of restricted classes,</source>
          <target state="translated">制限されたクラスの読み込み。</target>
        </trans-unit>
        <trans-unit id="9ed06bc60874c9e75502a47786ce6dd86d5cfb34" translate="yes" xml:space="preserve">
          <source>Lots of modern frameworks use reflection extensively for this very reason. Most other modern languages use reflection as well, and in scripting languages (such as Python) they are even more tightly integrated, since it feels more natural within the general programming model of those languages.</source>
          <target state="translated">最近の多くのフレームワークでは、このような理由からリフレクションが広く使われています。他のほとんどの近代的な言語でもリフレクションを使用していますが、スクリプト言語(Pythonなど)では、それらの言語の一般的なプログラミングモデルの中でより自然に感じられるため、より緊密に統合されています。</target>
        </trans-unit>
        <trans-unit id="ea201fad47b1868a8fe0ee11adbb17073d6da9de" translate="yes" xml:space="preserve">
          <source>Not every language supports reflection but the principles are usually the same in languages that support it.</source>
          <target state="translated">すべての言語がリフレクションをサポートしているわけではありませんが、リフレクションをサポートしている言語では原則は通常同じです。</target>
        </trans-unit>
        <trans-unit id="8645ecdcb4e899cc6ecd81759dd0741f6c8d8473" translate="yes" xml:space="preserve">
          <source>Obtaining Class objects,</source>
          <target state="translated">クラスオブジェクトの取得</target>
        </trans-unit>
        <trans-unit id="e59ff890fe3bc21bd9694e61ab7c233ef689ffdc" translate="yes" xml:space="preserve">
          <source>Obtaining references to constructors, methods or fields of a restricted class,</source>
          <target state="translated">制限されたクラスのコンストラクタ、メソッド、フィールドへの参照を取得します。</target>
        </trans-unit>
        <trans-unit id="697ea410e74a0eb90c777be04cc0855e87705cdb" translate="yes" xml:space="preserve">
          <source>One of my favorite uses of reflection is the below Java dump method. It takes any object as a parameter and uses the Java reflection API to print out every field name and value.</source>
          <target state="translated">リフレクションの私のお気に入りの使用法の1つは、以下のJavaダンプメソッドです。これは任意のオブジェクトをパラメータとして受け取り、JavaのリフレクションAPIを使用して、すべてのフィールド名と値を出力します。</target>
        </trans-unit>
        <trans-unit id="3b834c56b8aa4817757e501cdca629ca4aad60ce" translate="yes" xml:space="preserve">
          <source>One very common use case in Java is the usage with annotations. JUnit 4, for example, will use reflection to look through your classes for methods tagged with the @Test annotation, and will then call them when running the unit test.</source>
          <target state="translated">Java での非常に一般的な使用例として、アノテーションの使用があります。たとえば JUnit 4 は、リフレクションを使って @Test アノテーションでタグ付けされたメソッドをクラス内で探し、 ユニットテストを実行するときにそれらを呼び出します。</target>
        </trans-unit>
        <trans-unit id="7b7691de77ab4ac4bbc3b9109372d29db5e3ecba" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;http://www.geeksforgeeks.org/reflection-in-java/&quot;&gt;Java Reflection&lt;/a&gt;&lt;a href=&quot;http://javarevisited.blogspot.in/2012/05/how-to-access-private-field-and-method.html&quot;&gt;javarevisited.blogspot.in&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/reflection-in-java/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Javaリフレクション&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;http://javarevisited.blogspot.in/2012/05/how-to-access-private-field-and-method.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;javarevisited.blogspot.in&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc2346f09e6a5ef2803272b9e4b34b2ec156b429" translate="yes" xml:space="preserve">
          <source>Reflection allows instantiation of new objects, invocation of methods, and get/set operations on class variables dynamically at run time without having prior knowledge of its implementation.</source>
          <target state="translated">リフレクションでは、新しいオブジェクトのインスタンス化、メソッドの呼び出し、クラス変数へのgetet操作を、実装について事前に知ることなく、実行時に動的に行うことができます。</target>
        </trans-unit>
        <trans-unit id="d8acc7c746ded76a918047280fbbb3333490d6ee" translate="yes" xml:space="preserve">
          <source>Reflection allows programmer to access entities in program dynamically. i.e. while coding an application if programmer is unaware about a class or its methods, he can make use of such class dynamically (at run time) by using reflection.</source>
          <target state="translated">つまり、プログラマーがクラスやそのメソッドを知らない場合、アプリケーションをコーディングしている間に、リフレクションを使用することで、そのようなクラスを(実行時に)動的に利用することができます。</target>
        </trans-unit>
        <trans-unit id="f37357014c003a54ec493246687a7444440fcd2a" translate="yes" xml:space="preserve">
          <source>Reflection also allows you to access private member/methods of a class:</source>
          <target state="translated">Reflection では、クラスのプライベートなメンバメソッドにアクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="a217aec8f01d9275c05ea95b02480164f9f45d6b" translate="yes" xml:space="preserve">
          <source>Reflection code is also more complex than the corresponding direct code</source>
          <target state="translated">反射コードも、対応する直接コードよりも複雑です。</target>
        </trans-unit>
        <trans-unit id="68f6c9c71d88215dda226271549652ed9dbb6af3" translate="yes" xml:space="preserve">
          <source>Reflection gives us information about the class to which an object belongs and also the methods of that class which can be executed by using the object.</source>
          <target state="translated">Reflection は、オブジェクトが属するクラスや、オブジェクトを使用して実行できるそのクラスのメソッドに関する情報を提供してくれます。</target>
        </trans-unit>
        <trans-unit id="db38284702d4de4debeccce6b221673af3d2314a" translate="yes" xml:space="preserve">
          <source>Reflection gives you the ability to write more generic code. It allows you to create an object at runtime and call its method at runtime. Hence the program can be made highly parameterized. It also allows introspecting the object and class to detect its variables and method exposed to the outer world.</source>
          <target state="translated">Reflection を使用すると、より汎用的なコードを書くことができます。これにより、実行時にオブジェクトを作成し、そのメソッドを実行時に呼び出すことができます。そのため、プログラムを高度にパラメータ化することができます。また、オブジェクトやクラスをイントロスペクトして、外界に露出している変数やメソッドを検出することができます。</target>
        </trans-unit>
        <trans-unit id="5efe0f8d4b975ae78ef2cfa6918c6502f062b7e5" translate="yes" xml:space="preserve">
          <source>Reflection is a key mechanism to allow an application or framework to work with code that might not have even been written yet!</source>
          <target state="translated">リフレクションは、アプリケーションやフレームワークが、まだ書かれていないかもしれないコードを使って作業できるようにするための重要なメカニズムです。</target>
        </trans-unit>
        <trans-unit id="5219115cc863bf20388caf98ef604a4d4c4b9a31" translate="yes" xml:space="preserve">
          <source>Reflection is a set of functions which allows you to access the runtime information of your program and modify it behavior (with some limitations).</source>
          <target state="translated">Reflection は、プログラムの実行時情報にアクセスし、プログラムの動作を変更できるようにする関数のセットです (いくつかの制限はありますが)。</target>
        </trans-unit>
        <trans-unit id="8f4224bf21b4ff6caa7248cbb7fdfd34031ed536" translate="yes" xml:space="preserve">
          <source>Reflection is a very powerful API but it may slow down the application if used in excess, as it resolves all the types at runtime.</source>
          <target state="translated">Reflection は非常に強力な API ですが、実行時にすべての型を解決するため、過剰に使用するとアプリケーションの動作が遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="47750829f34b52f1a4d7eb0bfa90de280fa1357f" translate="yes" xml:space="preserve">
          <source>Reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible.</source>
          <target state="translated">Reflection は、Java 仮想マシンで実行されているアプリケーションの実行時の動作を調べたり変更したりする機能を必要とするプログラムで一般的に使用されます。これは比較的高度な機能であり、言語の基礎を十分に理解している開発者のみが使用すべきです。リフレクションは強力なテクニックであり、そうでなければ不可能な操作をアプリケーションで実行できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="a996a95ce6377941641fdade6f5ccdc15836006a" translate="yes" xml:space="preserve">
          <source>Reflection is important since it lets you write programs that do not have to &quot;know&quot; everything at compile time, making them more dynamic, since they can be tied together at runtime. The code can be written against known interfaces, but the actual classes to be used can be instantiated using reflection from configuration files.</source>
          <target state="translated">リフレクションが重要なのは、コンパイル時にすべてを「知っている」必要のないプログラムを書くことができるため、実行時に結びつけることができるため、より動的なものになります。コードは既知のインタフェースに対して書くことができますが、実際に使用するクラスは設定ファイルからリフレクションを使用してインスタンス化することができます。</target>
        </trans-unit>
        <trans-unit id="377c299d76a416cc7636903bb8fb907815a92340" translate="yes" xml:space="preserve">
          <source>Reflection is much slower than direct code when used for field and method access.</source>
          <target state="translated">フィールドやメソッドへのアクセスに使用する場合、リフレクションはダイレクトコードよりもはるかに遅くなります。</target>
        </trans-unit>
        <trans-unit id="39ed6d7dc105535550cdc170f9710f2089167435" translate="yes" xml:space="preserve">
          <source>Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.</source>
          <target state="translated">反射は強力ですが、無差別に使用すべきではありません。リフレクションを使用せずに操作を実行できる場合は、使用しない方が良いでしょう。リフレクションを使用してコードにアクセスする際には、以下の点に注意してください。</target>
        </trans-unit>
        <trans-unit id="ac26492de916ca7697ea01aee13539fdda84f0a4" translate="yes" xml:space="preserve">
          <source>Reflection is the ability to &quot;reflect&quot; on the structure of your program. Or more concrete. To look at the objects and classes you have and programmatically get back information on the methods, fields, and interfaces they implement. You can also look at things like annotations.</source>
          <target state="translated">リフレクションとは、プログラムの構成を「反省」する能力のことです。というか、より具体的に。自分が持っているオブジェクトやクラスを見て、それらが実装しているメソッドやフィールド、インターフェイスの情報をプログラム的に返すことです。また、注釈のようなものを見ることもできます。</target>
        </trans-unit>
        <trans-unit id="c3069b249454a7521079ef23974c9cab83670986" translate="yes" xml:space="preserve">
          <source>Reflection is to let object to see their appearance. This argument seems nothing to do with reflection. In fact, this is the &quot;self-identify&quot; ability.</source>
          <target state="translated">反射とは、対象物に自分の姿を見せることである。この主張は、反射とは何の関係もないように思える。実はこれは「自己同一化」の能力である。</target>
        </trans-unit>
        <trans-unit id="4a5e2b549ed93f324cf7bab644f028cfa8ce1528" translate="yes" xml:space="preserve">
          <source>Reflection itself is a word for such languages that lack the capability of self-knowledge and self-sensing as Java and C#. Because they do not have the capability of self-knowledge, when we want to observe how it looks like, we must have another thing to reflect on how it looks like. Excellent dynamic languages such as Ruby and Python can perceive the reflection of their own without the help of other individuals. We can say that the object of Java cannot perceive how it looks like without a mirror, which is an object of the reflection class, but an object in Python can perceive it without a mirror. So that's why we need reflection in Java.</source>
          <target state="translated">リフレクション自体は、JavaやC#のような自己認識能力や自己感知能力を欠いた言語のことを指す言葉である。彼らには自己認識能力がないので、どのように見えるかを観察したいときには、それがどのように見えるかを反射する別のものを用意しなければなりません。RubyやPythonのような優れた動的言語は、他の個体の助けを借りなくても、自分の反射を知覚することができます。Javaのオブジェクトは反射クラスのオブジェクトである鏡がないとどのように見えるか知覚できないと言えますが、Pythonのオブジェクトは鏡がなくても知覚できます。だからこそ、Javaにはリフレクションが必要なのです。</target>
        </trans-unit>
        <trans-unit id="fc3e348e092fed72b69acabc88a3e9231891d8df" translate="yes" xml:space="preserve">
          <source>Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.</source>
          <target state="translated">Reflection は、セキュリティマネージャの下で実行している場合には存在しない可能性のあるランタイムパーミッションを必要とします。これは、アプレットなどの制限されたセキュリティコンテキストで実行しなければならないコードにとって重要な考慮事項です。</target>
        </trans-unit>
        <trans-unit id="f04529f40ec32d7f346acf314474d6101993e2d0" translate="yes" xml:space="preserve">
          <source>Setting and getting field values,</source>
          <target state="translated">フィールドの値を設定したり、取得したりします。</target>
        </trans-unit>
        <trans-unit id="c9fbf65523bc453e10a3d5104969528d78e85a62" translate="yes" xml:space="preserve">
          <source>Simple example for reflection.
In a chess game, you do not know what will be moved by the user at run time. reflection can be used to call methods which are already implemented at run time:</source>
          <target state="translated">リフレクションの簡単な例。チェスゲームでは、実行時にユーザが何を動かすかはわかりません。</target>
        </trans-unit>
        <trans-unit id="e8bfe093287c98e51f95e42feee3bae8ebc51cc2" translate="yes" xml:space="preserve">
          <source>Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.</source>
          <target state="translated">反射は、プライベートフィールドやメソッドへのアクセスなど、非反射コードでは違法となる操作をコードで実行できるようにするため、反射を使用すると予期せぬ副作用が発生し、コードが機能不全に陥ったり、移植性が損なわれたりする可能性があります。反射的なコードは抽象化を破るため、プラットフォームのアップグレードによって挙動が変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="8724c4153e380659fdd217d8eba7f1cb0a1dcaf4" translate="yes" xml:space="preserve">
          <source>So we might implement in 3 classes each containing a different logic .Obviously the object  information is available in runtime so you cannot statically code to perform computation hence reflection is used to instantiate the object of the class that you require to perform the computation based on the object received from the provider .</source>
          <target state="translated">明らかに、オブジェクト情報は実行時に利用可能なので、静的に計算を実行するためにコードを記述することはできませんので、リフレクションは、プロバイダから受信したオブジェクトに基づいて計算を実行するために必要なクラスのオブジェクトをインスタンス化するために使用されます .</target>
        </trans-unit>
        <trans-unit id="635afd63b9273f7fdaee3a02919e369f61f1a6e3" translate="yes" xml:space="preserve">
          <source>So, to give you a code example of this in Java (imagine the object in question is foo) :</source>
          <target state="translated">だから、Javaでこれのコード例を与えるために(問題のオブジェクトがfooであると想像してください).</target>
        </trans-unit>
        <trans-unit id="2d6febcf15152d8de02fe3348451d82daeec0ac2" translate="yes" xml:space="preserve">
          <source>Spring uses bean configuration such as:</source>
          <target state="translated">SpringではBeanのような設定を使用します。</target>
        </trans-unit>
        <trans-unit id="f61183eaff1df22c443b6f8bde3959781f43b8fe" translate="yes" xml:space="preserve">
          <source>Take for example a remote application which gives your application an object which you obtain using their API Methods . Now based on the object you might need to perform some sort of computation .</source>
          <target state="translated">例えば、あなたのアプリケーションにオブジェクトを与えるリモートアプリケーションの API メソッドを使用して取得したとします。さて、そのオブジェクトに基づいて、ある種の計算を実行する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5d4297d76e89658b1926871e00e1ecb1c986af2b" translate="yes" xml:space="preserve">
          <source>Take for example your typical web.xml file. This will contain a list of servlet elements, which contain nested servlet-class elements. The servlet container will process the web.xml file, and create new a new instance of each servlet class through reflection.</source>
          <target state="translated">典型的な web.xml ファイルを例に考えてみましょう。このファイルにはサーブレット要素のリストが含まれており、その中には入れ子になったサーブレットクラス要素が含まれています。サーブレットコンテナは web.xml ファイルを処理し、反射によって各サーブレットクラスの新しいインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="a5441cc3e68def23311ae3069c5213a79fb6d793" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.lang&lt;/code&gt; and &lt;code&gt;java.lang.reflect&lt;/code&gt; packages provide classes for java reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;java.lang&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.reflect&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パッケージはJavaのリフレクションのためのクラスを提供します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b95bfd9602344297040acb8417c536c25721f0a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Reflection API&lt;/strong&gt; is mainly used in:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションAPIは&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、主に使用されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04d7c78236ee89824542d56ba549b24aeeb3ce91" translate="yes" xml:space="preserve">
          <source>The ability to inspect the code in the system and see object types is
  not reflection, but rather Type Introspection. Reflection is then the
  ability to make modifications at runtime by making use of
  introspection. The distinction is necessary here as some languages
  support introspection, but do not support reflection. One such example
  is C++</source>
          <target state="translated">システム内のコードを検査してオブジェクトの型を見る機能は、Reflectionではなく、Type Introspectionです。リフレクションとは、イントロスペクションを利用して実行時に変更を加える機能のことです。いくつかの言語はイントロスペクションをサポートしていますが、リフレクションをサポートしていないので、ここでは区別が必要です。そのような例の一つがC++です。</target>
        </trans-unit>
        <trans-unit id="64826090e45abc29b52ec33aee4fd3a8935d1153" translate="yes" xml:space="preserve">
          <source>The name reflection is used to describe code which is able to inspect other code in the same system (or itself).</source>
          <target state="translated">リフレクションという名前は、同じシステム内の他のコード(またはそれ自身)を検査することができるコードを記述するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d8bd80d3aa3030e4b8f6a6f74cf091bd7474e02c" translate="yes" xml:space="preserve">
          <source>The provider guarantees that object can be of 3 types and we need to perform computation based on what type of object .</source>
          <target state="translated">プロバイダはオブジェクトが3つのタイプになることを保証しているので、どのタイプのオブジェクトかに基づいて計算を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="24832444ab515d4459764d90fef06d4a35a14894" translate="yes" xml:space="preserve">
          <source>The required classes for reflection are provided under &lt;code&gt;java.lang.reflect package&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションに必要なクラスは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.reflect package&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cee64e47e968ebdb3bf6f36dfb55711ed80943bc" translate="yes" xml:space="preserve">
          <source>There are some good reflection examples to get you started at &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/reflect/index.html&quot;&gt;http://docs.oracle.com/javase/tutorial/reflect/index.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/reflect/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://docs.oracle.com/javase/tutorial/reflect/index.htmlで&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;開始するための良いリフレクションの例がいくつかあり&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="15848ed19daf91dc599a9ff7594b0b3d522f11cf" translate="yes" xml:space="preserve">
          <source>This example obtains the Class object from the class called MyObject. Using the class object the example gets a list of the methods in that class, iterates the methods and print out their names.</source>
          <target state="translated">この例では、MyObject というクラスから Class オブジェクトを取得します。この例では、クラスオブジェクトを使用して、そのクラスのメソッドのリストを取得し、メソッドをイテレートして、その名前を出力しています。</target>
        </trans-unit>
        <trans-unit id="b81690f4b4757a81fe7b4c08dda32ca5cad7198e" translate="yes" xml:space="preserve">
          <source>Through reflection we can invoke methods at runtime irrespective of the access specifier used with them.</source>
          <target state="translated">リフレクションによって、それらのメソッドで使用されているアクセス指定子に関係なく、実行時にメソッドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="a561e326da9ebe21a8e13536d31808cf84879d80" translate="yes" xml:space="preserve">
          <source>What is reflection and why is it useful</source>
          <target state="translated">リフレクションとは何か、なぜそれが役に立つのか</target>
        </trans-unit>
        <trans-unit id="d5e2c197bd1e64c01b4c7886ec8b0ee3ecc2474b" translate="yes" xml:space="preserve">
          <source>What is reflection, and why is it useful?</source>
          <target state="translated">リフレクションとは何か、なぜそれが役に立つのか?</target>
        </trans-unit>
        <trans-unit id="3ed9422a2ea0d1d0fefd2a8439979ee5b364d653" translate="yes" xml:space="preserve">
          <source>When the Spring context processes this &amp;lt; bean &amp;gt; element, it will use Class.forName(String) with the argument &quot;com.example.Foo&quot; to instantiate that Class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Springコンテキストがこの&amp;lt;bean&amp;gt;要素を処理するとき、引数「com.example.Foo」を指定してClass.forName（String）を使用し、そのクラスをインスタンス化します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="af1158d1d64999cdcf645b618eba9c9d3b13e77a" translate="yes" xml:space="preserve">
          <source>Where can it be useful? Is not useful every time but for concrete situations. For example you can use it to get the name of the class for logging purposes, to dynamically create handlers for events according to what's specified on a configuration file and so on...</source>
          <target state="translated">どこで役に立つのか?毎回使えるわけではありませんが、具体的な場面では使えます。例えば、ロギング目的でクラス名を取得したり、設定ファイルで指定した内容に応じてイベント用のハンドラを動的に作成したり...といった使い方ができます。</target>
        </trans-unit>
        <trans-unit id="37f86593e132b343b87b879e0fa055158365feb1" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;Reflection API&lt;/strong&gt; you can write universal &lt;code&gt;toString()&lt;/code&gt; method for any object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションAPI&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あなたは、ユニバーサル書くことができる&lt;/font&gt;&lt;/font&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任意のオブジェクトのための方法を。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90a0cd0782edde2787574165e7afdae56b562e70" translate="yes" xml:space="preserve">
          <source>source: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/reflect/&quot;&gt;The Reflection API&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソース：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/reflect/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リフレクションAPI&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
