<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/37628">
    <body>
      <group id="37628">
        <trans-unit id="76e6755cb5cf7ea2a882d92a0160c1d456f7a307" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AccessibleObject&lt;/code&gt; allows suppression of access checks if the necessary &lt;code&gt;ReflectPermission&lt;/code&gt; is available.</source>
          <target state="translated">&lt;code&gt;AccessibleObject&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果必要的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ReflectPermission&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可用，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AccessibleObject&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;允许禁止访问检查&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="39efd8e310f8ce4c0f2d605df069aa7f3af1100c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hibernate&lt;/code&gt; chose &lt;code&gt;reflection&lt;/code&gt; because it has minimal impact on the build process for an application.</source>
          <target state="translated">&lt;code&gt;Hibernate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之所以选择&lt;/font&gt;&lt;/font&gt; &lt;code&gt;reflection&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是因为它对应用程序的构建过程影响很小。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1abe26519d6d02eee7c63f5db0048f72effe89e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Reflection&lt;/code&gt; has many &lt;strong&gt;uses&lt;/strong&gt;. The one I am more familiar with, is to be able to create code on the fly.</source>
          <target state="translated">&lt;code&gt;Reflection&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有很多&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用途&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我比较熟悉的一种功能是能够即时创建代码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2cce7d499ca058a2437bf7339a31236939770c77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;java.lang.reflect&lt;/code&gt; package provides classes and interfaces for obtaining reflective information about classes and objects. Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</source>
          <target state="translated">&lt;code&gt;java.lang.reflect&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包提供用于获取有关类和对象的反射信息的类和接口。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射允许以编程方式访问有关已加载类的字段，方法和构造函数的信息，并允许在安全性限制内使用反射的字段，方法和构造函数对其基础副本进行操作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3263b2c8e5e8dad3181f60ed7d5ff3ad1e0d372f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Debugging and testing tools:&lt;/em&gt; Debuggers use the property of reflection to examine private members on classes.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调试和测试工具：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调试器使用反射的属性检查类的私有成员。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="267dc8219745212321ac176413d4c94adca30a05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Exposure of Internals:&lt;/em&gt; Reflective code breaks abstractions and therefore may change behaviour with upgrades of the platform.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内部曝光：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射代码破坏了抽象，因此可能会随着平台升级而改变行为。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cbfa1487aca6a5660de89dd102bde0c1c17545e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Extensibility Features:&lt;/em&gt; An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可扩展性功能：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应用程序可以通过使用其完全限定的名称创建可扩展性对象的实例来使用外部的用户定义类。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7e35d05e9225bc40318edb029e92b9221cf09f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Insecure use of its functions conducted from within a system code can also easily lead to the compromise of a Java security mode&lt;/em&gt;l. &lt;strong&gt;&lt;em&gt;So use this feature sparingly&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从系统代码内部对其功能的不安全使用也很容易导致Java安全模式的妥协&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，请谨慎使用此功能&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d41e8a8fba94b4d81b8d5bd6e7cf8bdf1eefc8d9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Performance Overhead:&lt;/em&gt; Reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;性能开销：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射性操作的性能比非反射性操作慢，因此应避免在对性能敏感的应用程序中经常调用的代码部分中。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c915f0bd00f8e6b012946d1f700aaa3ed64dbd3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Drawbacks of Reflection:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反思的缺点：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87c6e54c26e0d51710b1bde8afda98446607c4ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;General abuses:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一般滥用行为：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f3e691ba1d34f66cf36e41a992eab2a9d5d408b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;User of Reflection:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射用户：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa9a74fe5b677cca7bf44297e356b2ac51b61601" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A quick Java Reflection example to show you what using reflection looks like:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个简单的Java反射示例向您展示如何使用反射：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c1a08dcc59d69c190a602baff7d91a19e330e4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages of Using Reflection:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用反射的优势：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f397612a47bec94ad695255d033038d2522a78f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Class&lt;/strong&gt; The &lt;code&gt;getClass()&lt;/code&gt; method is used to get the name of the class to which an object belongs.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;getClass()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法被用来获得到其中对象所属的类的名字。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c7588922df25af8ae3e7d84556122b47c9788b7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructors&lt;/strong&gt; The &lt;code&gt;getConstructors()&lt;/code&gt; method is used to get the public constructors of the class to which an object belongs.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;构造&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;getConstructors()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法被用来获得到一个物体所属的类的公共构造。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5b6eed8acc664104c3f5ddf8eb8ffc72c0b4ea7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Drawbacks of Reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反思的缺点&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c418adcde6dca33f2113e643b3cf7aa3e0d8fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Drawbacks:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Drawbacks:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d38ebd5c771c17c46c4d33de4e05fd33d6ac45f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: After almost 1 year I am editing this answer as while reading about reflection I got few more uses of Reflection.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编辑&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：将近一年后，我正在编辑此答案，因为在阅读有关反射的内容时，我对反射的使用很少。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d9e8fd103683e9aa854d2eeed4c37db80eb4ede" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Exposure of Internals&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内部暴露&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61df392d4c2c65b0d121e33ddf25034ec22b3e90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensibility Features&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;扩展功能&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67f058ae58b2f7815f80d243b58b2301bdcc1f70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Methods&lt;/strong&gt; The &lt;code&gt;getMethods()&lt;/code&gt; method is used to get the public methods of the class to which an objects belongs.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;getMethods()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法被用来获得到某个对象所属的类的公共方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bee72a5bdb9095800c3ce5443e8515bcb89c5a64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance Overhead&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;绩效开销&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b38d24c2f6248a08d1e522f5d9bfb4c0ff3b9e2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflection&lt;/strong&gt; can be used to get information about &amp;ndash;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可用于获取有关&amp;ndash;的信息&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="800b9231b7f82f8ae67b04bb2964d334fdd281c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflection&lt;/strong&gt; is a language's ability to inspect and dynamically call classes, methods, attributes, etc. at runtime.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是语言在运行时检查和动态调用类，方法，属性等的能力。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1552193a224a7dc7dc501a889de6a813238c8a6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflection&lt;/strong&gt; is an API which is used to examine or modify the behaviour of &lt;em&gt;methods, classes, interfaces&lt;/em&gt; at runtime.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一种API，用于&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在运行时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;检查或修改&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法，类，接口&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的行为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5bd8a53de58e1ef9ec971b35d223f86ba6d6212a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Security Restrictions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;安全限制&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="778b38d2a4a2b95315242cc54697e20caf993e63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update from a comment:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来自评论的更新：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f35f58f37b1538bdfd364dbe78010cac8348c35a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Uses of Reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射的用途&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c9ce074852cbddff495458254730c1017607102" translate="yes" xml:space="preserve">
          <source>A different example would be a unit-test of a private method. One way to do so is to create a reflection and change the method's scope to public in the test's set-up phase. Of course one can argue private methods shouldn't be tested directly but that's not the point.</source>
          <target state="translated">另一个例子是一个私有方法的单元测试。一种方法是在测试的设置阶段创建一个反射,并将方法的范围改为公共。当然,人们可以认为私有方法不应该直接测试,但这不是重点。</target>
        </trans-unit>
        <trans-unit id="bca38910ed77d521afc94527effc9909183faece" translate="yes" xml:space="preserve">
          <source>A practical example of using reflections would be a Java Language Server written in Java or a PHP Language Server written in PHP, etc. Language Server gives your IDE abilities like autocomplete, jump to definition, context help, hinting types and more. In order to have all tag names (words that can be autocompleted) to show all the possible matches as you type the Language Server has to inspect everything about the class including doc blocks and private members. For that it needs a reflection of said class.</source>
          <target state="translated">使用反射的一个实际例子是用Java编写的Java语言服务器或用PHP编写的PHP语言服务器等。语言服务器给你的IDE提供了自动完成、跳转到定义、上下文帮助、提示类型等能力。为了让所有的标签名(可以自动完成的单词)在你输入时显示所有可能的匹配,Language Server必须检查关于类的一切,包括doc块和私有成员。为此,它需要一个类的反映。</target>
        </trans-unit>
        <trans-unit id="f712e1ab9f7444585d3113d90a826187db60eb20" translate="yes" xml:space="preserve">
          <source>Alternatively works &lt;code&gt;Lombok Project&lt;/code&gt;. It just injects code at compile time, result in code being inserted into your domain classes. (I think it is OK for getters and setters)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;替代工程&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Lombok Project&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它只是在编译时注入代码，导致代码被插入到您的域类中。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（我认为对getter和setter来说还可以）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d85b2f6bdd2e23adc756e771b97a67cb296aa3b" translate="yes" xml:space="preserve">
          <source>An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.
Class Browsers and Visual Development Environments
A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.
Debuggers and Test Tools
Debuggers need to be able to examine private members in classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to ensure a high level of code coverage in a test suite.</source>
          <target state="translated">一个应用程序可以通过使用用户定义的类的全称名称创建可扩展性对象的实例来利用外部的、用户定义的类。类浏览器和可视化开发环境 一个类浏览器需要能够枚举类的成员。可视化开发环境可以利用反射中的类型信息来帮助开发者编写正确的代码。调试器和测试工具 调试器需要能够检查类中的私有成员。测试工具可以利用反射来系统地调用类上定义的可发现的API集,以确保测试套件中的代码覆盖率高。</target>
        </trans-unit>
        <trans-unit id="cc45f1793412faaa4a56959b5f8838af9b2c8ec5" translate="yes" xml:space="preserve">
          <source>And finally, the most comprehensive example is &lt;a href=&quot;http://www.springframework.org/&quot;&gt;Spring&lt;/a&gt; which uses reflection to create its beans, and for its heavy use of proxies</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最后，最全面的示例是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.springframework.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它使用反射来创建其bean，并大量使用代理&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c9a5c4733b5d39d0014e51ebae4c5efb4c65d7c" translate="yes" xml:space="preserve">
          <source>And finally, yes, the concepts are pretty much similar in other statically typed languages which support reflection (like C#). In dynamically typed languages, the use case described above is less necessary (since the compiler will allow any method to be called on any object, failing at runtime if it does not exist), but the second case of looking for methods which are marked or work in a certain way is still common.</source>
          <target state="translated">最后,是的,在其他支持反射的静态类型化语言中(比如C#),这些概念基本相似。在动态类型化的语言中,上面描述的用例就没有那么必要了(因为编译器会允许在任何对象上调用任何方法,如果不存在,则在运行时失败),但第二种情况下,寻找被标记或以某种方式工作的方法仍然很常见。</target>
        </trans-unit>
        <trans-unit id="0b518e10771b9253bdd4fc733405e465373ffaf4" translate="yes" xml:space="preserve">
          <source>And from Java 7 we have &lt;code&gt;MethodHandles&lt;/code&gt;, which works as &lt;code&gt;Reflection API&lt;/code&gt;. In projects, to work with loggers we just copy-paste the next code:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从Java 7开始，我们有了&lt;/font&gt;&lt;/font&gt; &lt;code&gt;MethodHandles&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它可以用作&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Reflection API&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在项目中，要与记录器一起使用，我们只需复制粘贴以下代码：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="98106d65797a34619f72a02cb51b7d2dc74338bf" translate="yes" xml:space="preserve">
          <source>Another example would be the Java API for XML Parsing &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_API_for_XML_Processing&quot;&gt;(JAXP)&lt;/a&gt;. Where an XML parser provider is 'plugged-in' via well-known system properties, which are used to construct new instances through reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一个示例是用于XML解析的Java API &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_API_for_XML_Processing&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（JAXP）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过众所周知的系统属性&amp;ldquo;插入&amp;rdquo; XML解析器提供程序的位置，该属性用于通过反射构造新实例。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2677ff031c51b9e6180e8fe1a179c64f0a10160" translate="yes" xml:space="preserve">
          <source>As I find it best to explain by example and none of the answers seem to do that...</source>
          <target state="translated">因为我觉得最好的办法是举例说明,而且似乎没有一个答案能做到这一点。</target>
        </trans-unit>
        <trans-unit id="f002a793bb200d428bfb3a57f359de8a68a61d85" translate="yes" xml:space="preserve">
          <source>As name itself suggest it reflects what it holds for example class method,etc apart from providing feature to invoke method creating instance dynamically at runtime.</source>
          <target state="translated">顾名思义,它除了提供了在运行时动态调用方法创建实例的功能外,还反映了它所持有的东西,例如类方法等。</target>
        </trans-unit>
        <trans-unit id="ca04a01c15dacb15e63a42b4719d12252a2f8fc8" translate="yes" xml:space="preserve">
          <source>As per my understanding:</source>
          <target state="translated">根据我的理解。</target>
        </trans-unit>
        <trans-unit id="4a30e97f958985a613983df7e9a9f4147937428e" translate="yes" xml:space="preserve">
          <source>Because it is hard to make typo-error in this case.</source>
          <target state="translated">因为这种情况下,很难出现打字错误。</target>
        </trans-unit>
        <trans-unit id="d2fd967478b11175693c52637e16182d67678925" translate="yes" xml:space="preserve">
          <source>Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations cannot be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts and should be avoided in sections of code which are called frequently in performance-sensitive applications.</source>
          <target state="translated">由于反射涉及的类型是动态解析的,因此某些Java虚拟机优化操作无法执行。因此,反射式操作的性能比非反射式操作的性能要慢,应该避免在性能敏感的应用程序中频繁调用的代码章节中使用。</target>
        </trans-unit>
        <trans-unit id="75cec77203d8a3c3bbb133724432d2b16ed9c414" translate="yes" xml:space="preserve">
          <source>Classes in this package, along with &lt;code&gt;java.lang.Class&lt;/code&gt; accommodate applications such as debuggers, interpreters, object inspectors, class browsers, and services such as &lt;code&gt;Object Serialization&lt;/code&gt; and &lt;code&gt;JavaBeans&lt;/code&gt; that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此软件包中的类以及&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.Class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;容纳&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;需要访问目标对象的公共成员（基于其对象）的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应用程序，例如调试器，解释器，对象检查器，类浏览器以及服务，例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Object Serialization&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;JavaBeans&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。运行时类）或给定类声明的成员&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cabd73d2b2f6bec7dcefa96fbed5523c29e5e5fa" translate="yes" xml:space="preserve">
          <source>Creating new instances of objects.</source>
          <target state="translated">创建对象的新实例。</target>
        </trans-unit>
        <trans-unit id="f5b464b3897b8c535381e2d8a17e39881cec6f04" translate="yes" xml:space="preserve">
          <source>Creation of new object instances, methods invocation, getting or setting field values of a restricted class.</source>
          <target state="translated">创建新对象实例、方法调用、获取或设置限制类的字段值。</target>
        </trans-unit>
        <trans-unit id="984fe3ba3e70d02a7d3335b8bfb0d79f0b528af1" translate="yes" xml:space="preserve">
          <source>Debugger and Test Tools etc.</source>
          <target state="translated">调试器和测试工具等。</target>
        </trans-unit>
        <trans-unit id="310d3e06116a3c41ab7d32a30a08a2f122bcb2f3" translate="yes" xml:space="preserve">
          <source>Exactly how all this works is explained here</source>
          <target state="translated">确切的说,这一切是如何运作的</target>
        </trans-unit>
        <trans-unit id="c175f05d7eb96cebecf6a41d3073e0e90c3ed97d" translate="yes" xml:space="preserve">
          <source>Examining properties of a class (fields, methods, constructors),</source>
          <target state="translated">考察类的属性(字段、方法、构造函数)。</target>
        </trans-unit>
        <trans-unit id="5594aeaa90d29ada020371584fb08ffe991ec816" translate="yes" xml:space="preserve">
          <source>For Private methods,</source>
          <target state="translated">对于私人的方法:</target>
        </trans-unit>
        <trans-unit id="693196b805e9eefa4595e0678693d6606e5c3833" translate="yes" xml:space="preserve">
          <source>For example, all objects in Java have the method &lt;code&gt;getClass()&lt;/code&gt;, which lets you determine the object's class even if you don't know it at compile time (e.g. if you declared it as an &lt;code&gt;Object&lt;/code&gt;) - this might seem trivial, but such reflection is not possible in less dynamic languages such as &lt;code&gt;C++&lt;/code&gt;. More advanced uses lets you list and call methods, constructors, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，Java中的所有对象都具有方法&lt;/font&gt;&lt;/font&gt; &lt;code&gt;getClass()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，即使您在编译时不知道该对象的类（例如，如果您将其声明为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Object&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，也可以使用它来确定该对象的类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-这似乎很简单，但是这样在不太动态的语言（例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）中无法进行反射&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更高级的用法可让您列出和调用方法，构造函数等。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6fb9254fbf60efc7b954b5ba670c968e6ee3a01e" translate="yes" xml:space="preserve">
          <source>For example, say you have an object of an unknown type in Java, and you would like to call a 'doSomething' method on it if one exists. Java's static typing system isn't really designed to support this unless the object conforms to a known interface, but using reflection, your code can look at the object and find out if it has a method called 'doSomething' and then call it if you want to.</source>
          <target state="translated">例如,假设在Java中你有一个未知类型的对象,你想在其上调用一个'doSomething'方法,如果有的话。Java的静态键入系统并不真正支持这个功能,除非对象符合一个已知的接口,但使用反射,你的代码可以查看对象并找出它是否有一个叫'doSomething'的方法,然后如果你想的话就调用它。</target>
        </trans-unit>
        <trans-unit id="7fdc810374fe9dfa3045213c9b7a12737ef416f6" translate="yes" xml:space="preserve">
          <source>For inspection of classes (also know as introspection) you don't need to import the reflection package (&lt;code&gt;java.lang.reflect&lt;/code&gt;). Class metadata can be accessed through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了检查类（也称为自省），您不需要导入反射包（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.reflect&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.Class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;访问类元数据&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e00d01d41832cb3c81dfdf9609e05666593eb6a8" translate="yes" xml:space="preserve">
          <source>For private fields,</source>
          <target state="translated">对于私人领域:</target>
        </trans-unit>
        <trans-unit id="850912486e2e27fec1a678a7817806ccd05f4f34" translate="yes" xml:space="preserve">
          <source>From java documentation &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html&quot;&gt;page&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从Java文档&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;页面&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9b57123908782edab0f9d5315a27bbbc06bd9567" translate="yes" xml:space="preserve">
          <source>From this &lt;a href=&quot;http://www.ibm.com/developerworks/library/j-dyn0603/&quot;&gt;article&lt;/a&gt; (by Dennis Sosnoski, President, Sosnoski Software Solutions, Inc)  and this &lt;a href=&quot;http://www.security-explorations.com/materials/se-2012-01-report.pdf&quot;&gt;article&lt;/a&gt; (security-explorations pdf):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/library/j-dyn0603/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本文&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（Sosnoski Software Solutions，Inc.总裁Dennis Sosnoski）和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.security-explorations.com/materials/se-2012-01-report.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本文&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（安全性探索pdf）开始：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="973d454cb269a335664d77c5a64d777b1349ce93" translate="yes" xml:space="preserve">
          <source>Have a look at this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;documentation&lt;/a&gt; link for the methods exposed by &lt;strong&gt;&lt;em&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;查看此&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文档&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;链接，了解&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;公开的方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34deaa41eea028ce9992343bd939a2b019e0bfbf" translate="yes" xml:space="preserve">
          <source>Have a look at this SE question regarding abuse of reflection feature:</source>
          <target state="translated">看一看这个关于滥用反射功能的SE问题。</target>
        </trans-unit>
        <trans-unit id="c60cc8d0b33ec9707ca888b5d0cc96c2d441df1b" translate="yes" xml:space="preserve">
          <source>Here is some example:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="eea4d3e68f79645621537952d7885a21a986a764" translate="yes" xml:space="preserve">
          <source>How do I read a private field in Java?</source>
          <target state="translated">如何在Java中读取一个私有字段?</target>
        </trans-unit>
        <trans-unit id="f5dcee71779b03aaff859733ff309c6577746074" translate="yes" xml:space="preserve">
          <source>I can see considerable drawbacks than uses of using Reflection</source>
          <target state="translated">我可以看到使用Reflection的弊端比使用Reflection有相当多的缺点。</target>
        </trans-unit>
        <trans-unit id="254f8a9369907f42f3509935f7f7c87622baa519" translate="yes" xml:space="preserve">
          <source>I just want to add some point to all that was listed.</source>
          <target state="translated">我只想在此基础上补充说明一下。</target>
        </trans-unit>
        <trans-unit id="0f9631de6c8595f344b280ad2df45d2bdc6cb1b9" translate="yes" xml:space="preserve">
          <source>I want to answer this question by example. First of all &lt;code&gt;Hibernate&lt;/code&gt; project uses &lt;code&gt;Reflection API&lt;/code&gt; to generate &lt;code&gt;CRUD&lt;/code&gt; statements to bridge the chasm between the running application and the persistence store. When things change in the domain, the &lt;code&gt;Hibernate&lt;/code&gt; has to know about them to persist them to the data store and vice versa.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我想举例说明这个问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Hibernate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;项目使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Reflection API&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;生成&lt;/font&gt;&lt;/font&gt; &lt;code&gt;CRUD&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语句，以桥接正在运行的应用程序和持久性存储之间的鸿沟。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当域中的事物发生变化时，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Hibernate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须了解它们，以将其持久化到数据存储中，反之亦然。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59ea7d8a60e63123865790fbb39afca4b577dbbe" translate="yes" xml:space="preserve">
          <source>I'm particularly interested in Java, but I assume the principles are the same in any language.</source>
          <target state="translated">我对Java特别感兴趣,但我假设任何语言的原理都是一样的。</target>
        </trans-unit>
        <trans-unit id="4e63bac98f2a6938d9fab00930c2876281232d32" translate="yes" xml:space="preserve">
          <source>IDE (Integrated Development Environment) e.g. Eclipse, MyEclipse, NetBeans etc.</source>
          <target state="translated">IDE(集成开发环境),如Eclipse、MyEclipse、NetBeans等。</target>
        </trans-unit>
        <trans-unit id="0adeb6df453a9aaf352a57864918b02b12305438" translate="yes" xml:space="preserve">
          <source>IE: dynamic classes, functions, constructors - based on any data
  (xml/array/sql results/hardcoded/etc..)</source>
          <target state="translated">IE:动态类、函数、构造函数--基于任何数据(xmlarraysql结果hardcoded等)的动态类、函数、构造函数</target>
        </trans-unit>
        <trans-unit id="589a59e1de357ac295cf54fd7d57ea897e25f5a4" translate="yes" xml:space="preserve">
          <source>In C# for example you can load an assembly (a .dll) in runtime an examine it, navigating through the classes and taking actions according to what you found. It also let you create an instance of a class on runtime, invoke its method, etc.</source>
          <target state="translated">例如,在C#中,你可以在运行时加载一个汇编(一个.dll),然后检查它,在类中进行导航,并根据你发现的内容进行操作。它还可以让你在运行时创建一个类的实例,调用它的方法等。</target>
        </trans-unit>
        <trans-unit id="e2c488cd992bbd3e18da0edfcfb16bdc9c8d6e3e" translate="yes" xml:space="preserve">
          <source>In above example the null parameter is the object you want to invoke the method on. If the method is static you supply null. If the method is not static, then while invoking you need to supply a valid MyObject instance instead of null.</source>
          <target state="translated">在上面的例子中,null参数是你要调用方法的对象。如果该方法是静态的,那么你就提供null参数。如果该方法不是静态的,那么在调用时需要提供一个有效的MyObject实例来代替null。</target>
        </trans-unit>
        <trans-unit id="823d0c56e8aa92cf5babf3278a56092f4ee027c9" translate="yes" xml:space="preserve">
          <source>Instead, by using reflection, there is need to worry about a possibly changing class name.</source>
          <target state="translated">相反,通过使用反思,有必要担心可能改变班级名称。</target>
        </trans-unit>
        <trans-unit id="f66396f7168221b2bf84c5dcc35135d1e55d77e3" translate="yes" xml:space="preserve">
          <source>Invoking methods,</source>
          <target state="translated">援引方法:</target>
        </trans-unit>
        <trans-unit id="ffda05e922f9a6bcf056ba767a3e49ccdf042dbd" translate="yes" xml:space="preserve">
          <source>It  allows violation of key Java security constraints such
as data access protection and type safety</source>
          <target state="translated">它允许违反关键的Java安全约束,如数据访问保护和类型安全等关键的Java安全约束。</target>
        </trans-unit>
        <trans-unit id="542d0b30181db440cde9bf0e2ad31c763156bc7b" translate="yes" xml:space="preserve">
          <source>It bypasses the source code can create maintenance problems</source>
          <target state="translated">绕过源码就会产生维护问题。</target>
        </trans-unit>
        <trans-unit id="a23ed20b481cccd78ea2932605cc56e463dd42e8" translate="yes" xml:space="preserve">
          <source>It can obscure what's actually going on inside your code</source>
          <target state="translated">它可以掩盖你的代码内部的实际情况</target>
        </trans-unit>
        <trans-unit id="bf0127f8da675ab2d8ff724e917268c8d041e581" translate="yes" xml:space="preserve">
          <source>It includes following functionality.</source>
          <target state="translated">它包括以下功能:</target>
        </trans-unit>
        <trans-unit id="6aa0dcbeeb964726e2fdcf8fed08463e02aa3b69" translate="yes" xml:space="preserve">
          <source>It is frequently used in scenarios where a class name changes frequently. If such a situation arises, then it is complicated for the programmer to rewrite the application and change the name of the class again and again.</source>
          <target state="translated">它经常被用于类名频繁变更的场景中。如果出现这样的情况,那么程序员要重写程序,反复修改类的名称,就会很麻烦。</target>
        </trans-unit>
        <trans-unit id="bd269443759350e48ed7bdc11388a81f11912bc4" translate="yes" xml:space="preserve">
          <source>It is used by many frameworks and application under the wood to invoke services without actually knowing the code.</source>
          <target state="translated">它被很多框架和木头下的应用所使用,可以在实际不知道代码的情况下调用服务。</target>
        </trans-unit>
        <trans-unit id="8bc170fa614d477d4ecf0a540e8a358361ec7d71" translate="yes" xml:space="preserve">
          <source>It is useful at debugging.</source>
          <target state="translated">它在调试时很有用。</target>
        </trans-unit>
        <trans-unit id="cdcb9f4cc5e879ab063042e5b93d78cf2a07fdc9" translate="yes" xml:space="preserve">
          <source>It is useful for creating libraries that work with objects in very general ways</source>
          <target state="translated">它对于创建以非常一般的方式处理对象的库是非常有用的。</target>
        </trans-unit>
        <trans-unit id="7f230118147515166a5ef34dfbd9f3ebe67b3e4c" translate="yes" xml:space="preserve">
          <source>It provides very versatile way of dynamically linking program components</source>
          <target state="translated">它提供了非常通用的动态链接程序组件的方式。</target>
        </trans-unit>
        <trans-unit id="1f33d88e3b05279f20e9d11df744b730f18886fd" translate="yes" xml:space="preserve">
          <source>It will then again use reflection to get the appropriate setter for the &amp;lt; property &amp;gt; element and set its value to the specified value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，它将再次使用反射来获取&amp;lt;property&amp;gt;元素的适当的setter，并将其值设置为指定的值。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1faa80fe2d86f9a33996d2c1b07db9ecff718f1" translate="yes" xml:space="preserve">
          <source>It's useful because it allows you to change the runtime behavior depending on the meta information of your program, that is, you can check the return type of a function and change the way you handle the situation.</source>
          <target state="translated">它很有用,因为它允许你根据程序的元信息改变运行时的行为,也就是说,你可以检查一个函数的返回类型,改变处理方式。</target>
        </trans-unit>
        <trans-unit id="9529d68eae9b702b42f4214bdc3e902aa6e05c92" translate="yes" xml:space="preserve">
          <source>It's usefull in a lot of situations. Everywhere you want to be able to dynamically plug in classes into your code. Lot's of object relational mappers use reflection to be able to instantiate objects from databases without knowing in advance what objects they're going to use. Plug-in architectures is another place where reflection is usefull. Being able to dynamically load code and determine if there are types there that implement the right interface to use as a plugin is important in those situations.</source>
          <target state="translated">它在很多情况下都很有用。在任何地方,你都希望能够在你的代码中动态地插入类。很多对象关系映射器使用反射来从数据库中实例化对象,而不知道他们要使用什么对象。插件架构是另一个可以使用反射的地方。在这种情况下,能够动态地加载代码,并确定那里是否有实现正确接口的类型作为插件使用,这一点非常重要。</target>
        </trans-unit>
        <trans-unit id="e3c24576ba302c22f5da6c285a19a92312766907" translate="yes" xml:space="preserve">
          <source>Java Reflection is quite powerful and can be very useful.
Java Reflection makes it possible &lt;strong&gt;to inspect classes, interfaces, fields and methods at runtime,&lt;/strong&gt; without knowing the names of the classes, methods etc. at compile time.
It is also possible to &lt;strong&gt;instantiate new objects, invoke methods and get/set field values using reflection.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java反射功能非常强大，非常有用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Reflection使得&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在运行时检查类，接口，字段和方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成为可能&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而无需在编译时知道类，方法等的名称。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还可以&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用反射实例化新对象，调用方法并获取/设置字段值。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec6f30c063fcb9ef481489312513588e235d3aa2" translate="yes" xml:space="preserve">
          <source>Junit uses Reflection especially for testing Private/Protected methods.</source>
          <target state="translated">Junit特别使用Reflection来测试PrivateProtected方法。</target>
        </trans-unit>
        <trans-unit id="477383916e2dc5b2c68531150a4c99e526ed2157" translate="yes" xml:space="preserve">
          <source>Loading of restricted classes,</source>
          <target state="translated">限制类的加载。</target>
        </trans-unit>
        <trans-unit id="9ed06bc60874c9e75502a47786ce6dd86d5cfb34" translate="yes" xml:space="preserve">
          <source>Lots of modern frameworks use reflection extensively for this very reason. Most other modern languages use reflection as well, and in scripting languages (such as Python) they are even more tightly integrated, since it feels more natural within the general programming model of those languages.</source>
          <target state="translated">很多现代框架都是出于这个原因而广泛使用反射。大多数其他现代语言也使用了反射,在脚本语言(如Python)中,它们甚至被更紧密地整合在一起,因为在这些语言的一般编程模型中,反射感觉更自然。</target>
        </trans-unit>
        <trans-unit id="ea201fad47b1868a8fe0ee11adbb17073d6da9de" translate="yes" xml:space="preserve">
          <source>Not every language supports reflection but the principles are usually the same in languages that support it.</source>
          <target state="translated">并非每一种语言都支持反思,但在支持反思的语言中,其原则通常都是一样的。</target>
        </trans-unit>
        <trans-unit id="8645ecdcb4e899cc6ecd81759dd0741f6c8d8473" translate="yes" xml:space="preserve">
          <source>Obtaining Class objects,</source>
          <target state="translated">获得类对象。</target>
        </trans-unit>
        <trans-unit id="e59ff890fe3bc21bd9694e61ab7c233ef689ffdc" translate="yes" xml:space="preserve">
          <source>Obtaining references to constructors, methods or fields of a restricted class,</source>
          <target state="translated">获取对受限类的构造函数、方法或字段的引用。</target>
        </trans-unit>
        <trans-unit id="697ea410e74a0eb90c777be04cc0855e87705cdb" translate="yes" xml:space="preserve">
          <source>One of my favorite uses of reflection is the below Java dump method. It takes any object as a parameter and uses the Java reflection API to print out every field name and value.</source>
          <target state="translated">我最喜欢使用反射的一个方法是下面的Java dump方法。它把任何对象作为参数,并使用Java reflection API打印出每个字段的名称和值。</target>
        </trans-unit>
        <trans-unit id="3b834c56b8aa4817757e501cdca629ca4aad60ce" translate="yes" xml:space="preserve">
          <source>One very common use case in Java is the usage with annotations. JUnit 4, for example, will use reflection to look through your classes for methods tagged with the @Test annotation, and will then call them when running the unit test.</source>
          <target state="translated">在Java中,有一个非常常见的用例是使用注解。例如,JUnit 4会使用反射来查找带有@Test注释的方法,然后在运行单元测试时调用它们。</target>
        </trans-unit>
        <trans-unit id="7b7691de77ab4ac4bbc3b9109372d29db5e3ecba" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;http://www.geeksforgeeks.org/reflection-in-java/&quot;&gt;Java Reflection&lt;/a&gt;&lt;a href=&quot;http://javarevisited.blogspot.in/2012/05/how-to-access-private-field-and-method.html&quot;&gt;javarevisited.blogspot.in&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参考：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/reflection-in-java/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Reflection &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;http://javarevisited.blogspot.in/2012/05/how-to-access-private-field-and-method.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;javarevisited.blogspot.in&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc2346f09e6a5ef2803272b9e4b34b2ec156b429" translate="yes" xml:space="preserve">
          <source>Reflection allows instantiation of new objects, invocation of methods, and get/set operations on class variables dynamically at run time without having prior knowledge of its implementation.</source>
          <target state="translated">反思允许在运行时动态地对新对象进行实例化,调用方法,以及对类变量进行getset操作,而不需要事先知道它的实现。</target>
        </trans-unit>
        <trans-unit id="d8acc7c746ded76a918047280fbbb3333490d6ee" translate="yes" xml:space="preserve">
          <source>Reflection allows programmer to access entities in program dynamically. i.e. while coding an application if programmer is unaware about a class or its methods, he can make use of such class dynamically (at run time) by using reflection.</source>
          <target state="translated">反思允许程序员动态地访问程序中的实体,即在编写程序时,如果程序员不知道一个类或它的方法,他可以通过使用反思来动态地(在运行时)利用这些类。</target>
        </trans-unit>
        <trans-unit id="f37357014c003a54ec493246687a7444440fcd2a" translate="yes" xml:space="preserve">
          <source>Reflection also allows you to access private member/methods of a class:</source>
          <target state="translated">反思也允许你访问类的私有成员方法。</target>
        </trans-unit>
        <trans-unit id="a217aec8f01d9275c05ea95b02480164f9f45d6b" translate="yes" xml:space="preserve">
          <source>Reflection code is also more complex than the corresponding direct code</source>
          <target state="translated">反思代码也比相应的直接代码更复杂</target>
        </trans-unit>
        <trans-unit id="68f6c9c71d88215dda226271549652ed9dbb6af3" translate="yes" xml:space="preserve">
          <source>Reflection gives us information about the class to which an object belongs and also the methods of that class which can be executed by using the object.</source>
          <target state="translated">反思给了我们关于对象所属类的信息,也给了我们关于该类的方法的信息,这些方法可以通过使用对象来执行。</target>
        </trans-unit>
        <trans-unit id="db38284702d4de4debeccce6b221673af3d2314a" translate="yes" xml:space="preserve">
          <source>Reflection gives you the ability to write more generic code. It allows you to create an object at runtime and call its method at runtime. Hence the program can be made highly parameterized. It also allows introspecting the object and class to detect its variables and method exposed to the outer world.</source>
          <target state="translated">反思让你能够写出更多的通用代码。它允许你在运行时创建一个对象并在运行时调用它的方法。因此,程序可以被高度参数化。它还可以对对象和类进行反思,以检测它的变量和暴露在外部世界的方法。</target>
        </trans-unit>
        <trans-unit id="5efe0f8d4b975ae78ef2cfa6918c6502f062b7e5" translate="yes" xml:space="preserve">
          <source>Reflection is a key mechanism to allow an application or framework to work with code that might not have even been written yet!</source>
          <target state="translated">反思是一个关键的机制,让应用程序或框架能够与可能还没有写好的代码一起工作!</target>
        </trans-unit>
        <trans-unit id="5219115cc863bf20388caf98ef604a4d4c4b9a31" translate="yes" xml:space="preserve">
          <source>Reflection is a set of functions which allows you to access the runtime information of your program and modify it behavior (with some limitations).</source>
          <target state="translated">反思是一组函数,它允许你访问程序的运行时信息并修改程序的行为(有一定的限制)。</target>
        </trans-unit>
        <trans-unit id="8f4224bf21b4ff6caa7248cbb7fdfd34031ed536" translate="yes" xml:space="preserve">
          <source>Reflection is a very powerful API but it may slow down the application if used in excess, as it resolves all the types at runtime.</source>
          <target state="translated">反思是一个非常强大的API,但如果使用过量,可能会拖慢应用的速度,因为它在运行时解析了所有类型。</target>
        </trans-unit>
        <trans-unit id="47750829f34b52f1a4d7eb0bfa90de280fa1357f" translate="yes" xml:space="preserve">
          <source>Reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible.</source>
          <target state="translated">反思常用于需要检查或修改在Java虚拟机中运行的应用程序的运行时行为的程序。这是一个相对高级的功能,只有对Java语言的基础知识有很强的把握的开发人员才能使用。考虑到这一点,反思是一种强大的技术,它可以使应用程序执行否则不可能完成的操作。</target>
        </trans-unit>
        <trans-unit id="a996a95ce6377941641fdade6f5ccdc15836006a" translate="yes" xml:space="preserve">
          <source>Reflection is important since it lets you write programs that do not have to &quot;know&quot; everything at compile time, making them more dynamic, since they can be tied together at runtime. The code can be written against known interfaces, but the actual classes to be used can be instantiated using reflection from configuration files.</source>
          <target state="translated">反思很重要,因为它可以让你在编写程序时不需要在编译时 &quot;知道 &quot;所有的东西,使程序更有活力,因为它们可以在运行时绑定在一起。代码可以根据已知的接口来写,但实际要使用的类可以通过配置文件中的反思来实例化。</target>
        </trans-unit>
        <trans-unit id="377c299d76a416cc7636903bb8fb907815a92340" translate="yes" xml:space="preserve">
          <source>Reflection is much slower than direct code when used for field and method access.</source>
          <target state="translated">当用于字段和方法访问时,反思比直接代码要慢得多。</target>
        </trans-unit>
        <trans-unit id="39ed6d7dc105535550cdc170f9710f2089167435" translate="yes" xml:space="preserve">
          <source>Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.</source>
          <target state="translated">反射的功能很强大,但不能乱用。如果可以不使用反射来执行一个操作,那么最好避免使用反射。在通过反思访问代码时,应注意以下几个方面的问题。</target>
        </trans-unit>
        <trans-unit id="ac26492de916ca7697ea01aee13539fdda84f0a4" translate="yes" xml:space="preserve">
          <source>Reflection is the ability to &quot;reflect&quot; on the structure of your program. Or more concrete. To look at the objects and classes you have and programmatically get back information on the methods, fields, and interfaces they implement. You can also look at things like annotations.</source>
          <target state="translated">反思是对自己的程序结构进行 &quot;反思 &quot;的能力。或者说得更具体一些。查看你所拥有的对象和类,并通过程序化的方式获得它们所实现的方法、字段和接口的信息。你也可以看一下注释之类的东西。</target>
        </trans-unit>
        <trans-unit id="c3069b249454a7521079ef23974c9cab83670986" translate="yes" xml:space="preserve">
          <source>Reflection is to let object to see their appearance. This argument seems nothing to do with reflection. In fact, this is the &quot;self-identify&quot; ability.</source>
          <target state="translated">反思就是让对象看清自己的样子。这种说法,似乎与反思没有关系。其实,这就是 &quot;自我鉴别 &quot;的能力。</target>
        </trans-unit>
        <trans-unit id="4a5e2b549ed93f324cf7bab644f028cfa8ce1528" translate="yes" xml:space="preserve">
          <source>Reflection itself is a word for such languages that lack the capability of self-knowledge and self-sensing as Java and C#. Because they do not have the capability of self-knowledge, when we want to observe how it looks like, we must have another thing to reflect on how it looks like. Excellent dynamic languages such as Ruby and Python can perceive the reflection of their own without the help of other individuals. We can say that the object of Java cannot perceive how it looks like without a mirror, which is an object of the reflection class, but an object in Python can perceive it without a mirror. So that's why we need reflection in Java.</source>
          <target state="translated">反思本身就是对像Java和C#这样缺乏自知自觉能力的语言的一种说法。因为它们不具备自知能力,所以当我们想观察它的样子时,必须有另一个东西来反思它的样子。优秀的动态语言,如Ruby和Python等,在没有其他个体的帮助下,可以感知到自己的反思。我们可以说,Java中的对象在没有镜子的情况下是无法感知到自己的样子的,这是反射类的对象,但是Python中的对象在没有镜子的情况下也能感知到自己的样子。所以这就是我们在Java中需要反射类的原因。</target>
        </trans-unit>
        <trans-unit id="fc3e348e092fed72b69acabc88a3e9231891d8df" translate="yes" xml:space="preserve">
          <source>Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.</source>
          <target state="translated">反思需要一个运行时的权限,而在安全管理器下运行时,这个权限可能不存在。这对于必须在受限制的安全环境下运行的代码来说是一个重要的考虑因素,比如在Applet中。</target>
        </trans-unit>
        <trans-unit id="f04529f40ec32d7f346acf314474d6101993e2d0" translate="yes" xml:space="preserve">
          <source>Setting and getting field values,</source>
          <target state="translated">设置和获取字段值。</target>
        </trans-unit>
        <trans-unit id="c9fbf65523bc453e10a3d5104969528d78e85a62" translate="yes" xml:space="preserve">
          <source>Simple example for reflection.
In a chess game, you do not know what will be moved by the user at run time. reflection can be used to call methods which are already implemented at run time:</source>
          <target state="translated">反射的简单例子。在棋牌游戏中,你不知道用户在运行时将会移动什么,反思可以用来调用运行时已经实现的方法。</target>
        </trans-unit>
        <trans-unit id="e8bfe093287c98e51f95e42feee3bae8ebc51cc2" translate="yes" xml:space="preserve">
          <source>Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.</source>
          <target state="translated">由于反思允许代码执行在非反思代码中不合法的操作,如访问私有字段和方法,因此使用反思可能会产生意想不到的副作用,可能会使代码功能失调,并可能破坏可移植性。反射代码会破坏抽象,因此可能会随着平台的升级而改变行为。</target>
        </trans-unit>
        <trans-unit id="8724c4153e380659fdd217d8eba7f1cb0a1dcaf4" translate="yes" xml:space="preserve">
          <source>So we might implement in 3 classes each containing a different logic .Obviously the object  information is available in runtime so you cannot statically code to perform computation hence reflection is used to instantiate the object of the class that you require to perform the computation based on the object received from the provider .</source>
          <target state="translated">所以我们可以用3个类来实现,每个类都包含不同的逻辑,显然,对象信息在运行时是可用的,所以你不能静态地编写代码来执行计算,因此反射被用来实例化你需要的类的对象,根据从提供者那里接收到的对象来执行计算。</target>
        </trans-unit>
        <trans-unit id="635afd63b9273f7fdaee3a02919e369f61f1a6e3" translate="yes" xml:space="preserve">
          <source>So, to give you a code example of this in Java (imagine the object in question is foo) :</source>
          <target state="translated">所以,给你一个Java中的代码示例(想象一下,问题对象是foo)。</target>
        </trans-unit>
        <trans-unit id="2d6febcf15152d8de02fe3348451d82daeec0ac2" translate="yes" xml:space="preserve">
          <source>Spring uses bean configuration such as:</source>
          <target state="translated">Spring使用Bean配置,如。</target>
        </trans-unit>
        <trans-unit id="f61183eaff1df22c443b6f8bde3959781f43b8fe" translate="yes" xml:space="preserve">
          <source>Take for example a remote application which gives your application an object which you obtain using their API Methods . Now based on the object you might need to perform some sort of computation .</source>
          <target state="translated">以一个远程应用程序为例,它给你的应用程序提供了一个对象,你使用它们的API方法来获取这个对象。现在基于这个对象,你可能需要执行某种计算。</target>
        </trans-unit>
        <trans-unit id="5d4297d76e89658b1926871e00e1ecb1c986af2b" translate="yes" xml:space="preserve">
          <source>Take for example your typical web.xml file. This will contain a list of servlet elements, which contain nested servlet-class elements. The servlet container will process the web.xml file, and create new a new instance of each servlet class through reflection.</source>
          <target state="translated">以典型的web.xml文件为例。这将包含一个servlet元素的列表,其中包含嵌套的servlet类元素。servlet容器将处理web.xml文件,并通过反思为每个servlet类创建一个新的实例。</target>
        </trans-unit>
        <trans-unit id="a5441cc3e68def23311ae3069c5213a79fb6d793" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.lang&lt;/code&gt; and &lt;code&gt;java.lang.reflect&lt;/code&gt; packages provide classes for java reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.reflect&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包Java反射提供类。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b95bfd9602344297040acb8417c536c25721f0a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Reflection API&lt;/strong&gt; is mainly used in:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射API&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;主要用于：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04d7c78236ee89824542d56ba549b24aeeb3ce91" translate="yes" xml:space="preserve">
          <source>The ability to inspect the code in the system and see object types is
  not reflection, but rather Type Introspection. Reflection is then the
  ability to make modifications at runtime by making use of
  introspection. The distinction is necessary here as some languages
  support introspection, but do not support reflection. One such example
  is C++</source>
          <target state="translated">在系统中检查代码并看到对象类型的能力不是反省,而是类型自省。那么反省就是在运行时利用反省来进行修改的能力。这里的区分是必要的,因为有些语言支持反省,但不支持反省。C++就是这样的一个例子。</target>
        </trans-unit>
        <trans-unit id="64826090e45abc29b52ec33aee4fd3a8935d1153" translate="yes" xml:space="preserve">
          <source>The name reflection is used to describe code which is able to inspect other code in the same system (or itself).</source>
          <target state="translated">反射这个名字是用来描述能够检查同一系统中其他代码(或自身)的代码。</target>
        </trans-unit>
        <trans-unit id="d8bd80d3aa3030e4b8f6a6f74cf091bd7474e02c" translate="yes" xml:space="preserve">
          <source>The provider guarantees that object can be of 3 types and we need to perform computation based on what type of object .</source>
          <target state="translated">提供器保证对象可以有3种类型,我们需要根据对象的类型进行计算。</target>
        </trans-unit>
        <trans-unit id="24832444ab515d4459764d90fef06d4a35a14894" translate="yes" xml:space="preserve">
          <source>The required classes for reflection are provided under &lt;code&gt;java.lang.reflect package&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所需的反射类在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.reflect package&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下提供&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cee64e47e968ebdb3bf6f36dfb55711ed80943bc" translate="yes" xml:space="preserve">
          <source>There are some good reflection examples to get you started at &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/reflect/index.html&quot;&gt;http://docs.oracle.com/javase/tutorial/reflect/index.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有一些不错的反思示例，可帮助您入门：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/reflect/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://docs.oracle.com/javase/tutorial/reflect/index.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15848ed19daf91dc599a9ff7594b0b3d522f11cf" translate="yes" xml:space="preserve">
          <source>This example obtains the Class object from the class called MyObject. Using the class object the example gets a list of the methods in that class, iterates the methods and print out their names.</source>
          <target state="translated">这个例子从名为MyObject的类中获取Class对象。使用该类对象,本例获得该类中的方法列表,迭代这些方法并打印出它们的名称。</target>
        </trans-unit>
        <trans-unit id="b81690f4b4757a81fe7b4c08dda32ca5cad7198e" translate="yes" xml:space="preserve">
          <source>Through reflection we can invoke methods at runtime irrespective of the access specifier used with them.</source>
          <target state="translated">通过反射,我们可以在运行时调用方法,而不考虑与它们一起使用的访问指定器。</target>
        </trans-unit>
        <trans-unit id="a561e326da9ebe21a8e13536d31808cf84879d80" translate="yes" xml:space="preserve">
          <source>What is reflection and why is it useful</source>
          <target state="translated">什么是反思,为什么它有用</target>
        </trans-unit>
        <trans-unit id="d5e2c197bd1e64c01b4c7886ec8b0ee3ecc2474b" translate="yes" xml:space="preserve">
          <source>What is reflection, and why is it useful?</source>
          <target state="translated">什么是反思,为什么会有作用?</target>
        </trans-unit>
        <trans-unit id="3ed9422a2ea0d1d0fefd2a8439979ee5b364d653" translate="yes" xml:space="preserve">
          <source>When the Spring context processes this &amp;lt; bean &amp;gt; element, it will use Class.forName(String) with the argument &quot;com.example.Foo&quot; to instantiate that Class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当Spring上下文处理此&amp;lt;bean&amp;gt;元素时，它将使用带有参数&amp;ldquo; com.example.Foo&amp;rdquo;的Class.forName（String）实例化该Class。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="af1158d1d64999cdcf645b618eba9c9d3b13e77a" translate="yes" xml:space="preserve">
          <source>Where can it be useful? Is not useful every time but for concrete situations. For example you can use it to get the name of the class for logging purposes, to dynamically create handlers for events according to what's specified on a configuration file and so on...</source>
          <target state="translated">它能在哪里用得上?不是每次都有用,但在具体的情况下有用。例如,你可以用它来获取类的名称以进行日志记录,根据配置文件中指定的内容动态创建事件处理程序等等。</target>
        </trans-unit>
        <trans-unit id="37f86593e132b343b87b879e0fa055158365feb1" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;Reflection API&lt;/strong&gt; you can write universal &lt;code&gt;toString()&lt;/code&gt; method for any object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Reflection API，&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为任何对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编写通用的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90a0cd0782edde2787574165e7afdae56b562e70" translate="yes" xml:space="preserve">
          <source>source: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/reflect/&quot;&gt;The Reflection API&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来源：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/reflect/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Reflection API&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
