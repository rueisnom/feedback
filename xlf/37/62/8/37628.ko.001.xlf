<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/37628">
    <body>
      <group id="37628">
        <trans-unit id="76e6755cb5cf7ea2a882d92a0160c1d456f7a307" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AccessibleObject&lt;/code&gt; allows suppression of access checks if the necessary &lt;code&gt;ReflectPermission&lt;/code&gt; is available.</source>
          <target state="translated">&lt;code&gt;AccessibleObject&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하면 필요한 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ReflectPermission&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 사용 가능한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 액세스 검사를 억제 할 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="39efd8e310f8ce4c0f2d605df069aa7f3af1100c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hibernate&lt;/code&gt; chose &lt;code&gt;reflection&lt;/code&gt; because it has minimal impact on the build process for an application.</source>
          <target state="translated">&lt;code&gt;Hibernate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;애플리케이션의 빌드 프로세스에 최소한의 영향을 미치기 때문에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;reflection&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 선택했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1abe26519d6d02eee7c63f5db0048f72effe89e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Reflection&lt;/code&gt; has many &lt;strong&gt;uses&lt;/strong&gt;. The one I am more familiar with, is to be able to create code on the fly.</source>
          <target state="translated">&lt;code&gt;Reflection&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에는 많은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;용도가&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 더 익숙한 것은 즉석에서 코드를 만들 수 있다는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2cce7d499ca058a2437bf7339a31236939770c77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;java.lang.reflect&lt;/code&gt; package provides classes and interfaces for obtaining reflective information about classes and objects. Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</source>
          <target state="translated">&lt;code&gt;java.lang.reflect&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 패키지는 클래스와 객체에 대한 반사 정보를 얻기위한 클래스와 인터페이스를 제공합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 사용하면로드 된 클래스의 필드, 메서드 및 생성자에 대한 정보에 프로그래밍 방식으로 액세스하고 보안 제한 내에서 기본 필드에서 작동하는 반사 된 필드, 메서드 및 생성자를 사용할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3263b2c8e5e8dad3181f60ed7d5ff3ad1e0d372f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Debugging and testing tools:&lt;/em&gt; Debuggers use the property of reflection to examine private members on classes.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;디버깅 및 테스트 도구 :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 디버거는 리플렉션 속성을 사용하여 클래스의 개인 멤버를 검사합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="267dc8219745212321ac176413d4c94adca30a05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Exposure of Internals:&lt;/em&gt; Reflective code breaks abstractions and therefore may change behaviour with upgrades of the platform.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부 노출 :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 반사 코드는 추상화를 손상 시키므로 플랫폼 업그레이드에 따라 동작이 변경 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cbfa1487aca6a5660de89dd102bde0c1c17545e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Extensibility Features:&lt;/em&gt; An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;확장 성 기능 :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 응용 프로그램은 정규화 된 이름을 사용하여 확장 성 개체 인스턴스를 만들어 외부 사용자 정의 클래스를 사용할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7e35d05e9225bc40318edb029e92b9221cf09f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Insecure use of its functions conducted from within a system code can also easily lead to the compromise of a Java security mode&lt;/em&gt;l. &lt;strong&gt;&lt;em&gt;So use this feature sparingly&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시스템 코드 내에서 수행 된 기능을 안전하지 않게 사용하면 Java 보안 모드가 손상 될 수 있습니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 기능을 조금만 사용하십시오&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d41e8a8fba94b4d81b8d5bd6e7cf8bdf1eefc8d9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Performance Overhead:&lt;/em&gt; Reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;성능 오버 헤드 :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 반사 작업은 비 반사 작업보다 성능이 느리므로 성능에 민감한 응용 프로그램에서 자주 호출되는 코드 섹션에서는 피해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c915f0bd00f8e6b012946d1f700aaa3ed64dbd3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Drawbacks of Reflection:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사의 단점 :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87c6e54c26e0d51710b1bde8afda98446607c4ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;General abuses:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적인 학대 :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f3e691ba1d34f66cf36e41a992eab2a9d5d408b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;User of Reflection:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션 사용자 :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa9a74fe5b677cca7bf44297e356b2ac51b61601" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A quick Java Reflection example to show you what using reflection looks like:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션 사용의 모습을 보여주는 빠른 Java 리플렉션 예제 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c1a08dcc59d69c190a602baff7d91a19e330e4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages of Using Reflection:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션 사용의 장점 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f397612a47bec94ad695255d033038d2522a78f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Class&lt;/strong&gt; The &lt;code&gt;getClass()&lt;/code&gt; method is used to get the name of the class to which an object belongs.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getClass()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드는 객체가 속한 클래스의 이름을 가져 오는 데 사용됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c7588922df25af8ae3e7d84556122b47c9788b7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructors&lt;/strong&gt; The &lt;code&gt;getConstructors()&lt;/code&gt; method is used to get the public constructors of the class to which an object belongs.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성자 &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getConstructors()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드는 객체가 속한 클래스의 public 생성자를 가져 오는 데 사용됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5b6eed8acc664104c3f5ddf8eb8ffc72c0b4ea7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Drawbacks of Reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사의 단점&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c418adcde6dca33f2113e643b3cf7aa3e0d8fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Drawbacks:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Drawbacks:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d38ebd5c771c17c46c4d33de4e05fd33d6ac45f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: After almost 1 year I am editing this answer as while reading about reflection I got few more uses of Reflection.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편집&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : 거의 1 년 후 리플렉션에 대해 읽는 동안 리플렉션을 더 많이 사용하지 않으므로이 답변을 편집하고 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d9e8fd103683e9aa854d2eeed4c37db80eb4ede" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Exposure of Internals&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부 노출&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61df392d4c2c65b0d121e33ddf25034ec22b3e90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensibility Features&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;확장 성 기능&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67f058ae58b2f7815f80d243b58b2301bdcc1f70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Methods&lt;/strong&gt; The &lt;code&gt;getMethods()&lt;/code&gt; method is used to get the public methods of the class to which an objects belongs.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;방법 &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getMethods()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드는 객체가 속하는 클래스의 퍼블릭 메소드를 얻기 위해 사용된다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bee72a5bdb9095800c3ce5443e8515bcb89c5a64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance Overhead&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;성능 오버 헤드&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b38d24c2f6248a08d1e522f5d9bfb4c0ff3b9e2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflection&lt;/strong&gt; can be used to get information about &amp;ndash;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 사용하여 다음에 대한 정보를 얻을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="800b9231b7f82f8ae67b04bb2964d334fdd281c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflection&lt;/strong&gt; is a language's ability to inspect and dynamically call classes, methods, attributes, etc. at runtime.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 런타임에 클래스, 메소드, 속성 등을 검사하고 동적으로 호출하는 언어의 기능입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1552193a224a7dc7dc501a889de6a813238c8a6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflection&lt;/strong&gt; is an API which is used to examine or modify the behaviour of &lt;em&gt;methods, classes, interfaces&lt;/em&gt; at runtime.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런타임 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메서드, 클래스, 인터페이스&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 동작을 검사하거나 수정하는 데 사용되는 API입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5bd8a53de58e1ef9ec971b35d223f86ba6d6212a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Security Restrictions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보안 제한&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="778b38d2a4a2b95315242cc54697e20caf993e63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update from a comment:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;댓글에서 업데이트 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f35f58f37b1538bdfd364dbe78010cac8348c35a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Uses of Reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사의 사용&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c9ce074852cbddff495458254730c1017607102" translate="yes" xml:space="preserve">
          <source>A different example would be a unit-test of a private method. One way to do so is to create a reflection and change the method's scope to public in the test's set-up phase. Of course one can argue private methods shouldn't be tested directly but that's not the point.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 예는 개인용 메소드의 단위 테스트입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 수행하는 한 가지 방법은 테스트 설정 단계에서 리플렉션을 작성하고 메소드 범위를 공용으로 변경하는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 개인 메소드는 직접 테스트해서는 안되지만 요점은 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bca38910ed77d521afc94527effc9909183faece" translate="yes" xml:space="preserve">
          <source>A practical example of using reflections would be a Java Language Server written in Java or a PHP Language Server written in PHP, etc. Language Server gives your IDE abilities like autocomplete, jump to definition, context help, hinting types and more. In order to have all tag names (words that can be autocompleted) to show all the possible matches as you type the Language Server has to inspect everything about the class including doc blocks and private members. For that it needs a reflection of said class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션 사용의 실제 예는 Java로 작성된 Java Language Server 또는 PHP로 작성된 PHP Language Server입니다. Language Server는 자동 완성, 정의로 이동, 컨텍스트 도움말, 힌트 유형 등과 같은 IDE 기능을 제공합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입력 할 때 가능한 모든 일치 항목을 표시하기 위해 모든 태그 이름 (자동 완성 할 수있는 단어)을 갖기 위해 언어 서버는 문서 블록 및 개인 멤버를 포함하여 클래스에 대한 모든 것을 검사해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 위해서는 상기 클래스의 반영이 필요하다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f712e1ab9f7444585d3113d90a826187db60eb20" translate="yes" xml:space="preserve">
          <source>Alternatively works &lt;code&gt;Lombok Project&lt;/code&gt;. It just injects code at compile time, result in code being inserted into your domain classes. (I think it is OK for getters and setters)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Lombok Project&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 작동합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일 타임에 코드를 삽입하여 도메인 클래스에 코드를 삽입합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(게터와 세터에게는 괜찮다고 생각합니다)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d85b2f6bdd2e23adc756e771b97a67cb296aa3b" translate="yes" xml:space="preserve">
          <source>An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.
Class Browsers and Visual Development Environments
A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.
Debuggers and Test Tools
Debuggers need to be able to examine private members in classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to ensure a high level of code coverage in a test suite.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;응용 프로그램은 정규화 된 이름을 사용하여 확장 성 개체 인스턴스를 만들어 외부 사용자 정의 클래스를 사용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 브라우저 및 비주얼 개발 환경 클래스 브라우저는 클래스 멤버를 열거 할 수 있어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비주얼 개발 환경은 개발자가 올바른 코드를 작성하는 데 도움이되도록 유형 정보를 반영하여 활용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;디버거 및 테스트 도구 디버거는 클래스의 개인 멤버를 검사 할 수 있어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;테스트 하네스는 리플렉션을 사용하여 클래스에 정의 된 검색 가능한 세트 API를 체계적으로 호출하여 테스트 스위트에서 높은 수준의 코드 커버리지를 보장 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc45f1793412faaa4a56959b5f8838af9b2c8ec5" translate="yes" xml:space="preserve">
          <source>And finally, the most comprehensive example is &lt;a href=&quot;http://www.springframework.org/&quot;&gt;Spring&lt;/a&gt; which uses reflection to create its beans, and for its heavy use of proxies</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로 가장 포괄적 인 예는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 사용하여 Bean을 작성하고 프록시를 많이 사용하는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.springframework.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c9a5c4733b5d39d0014e51ebae4c5efb4c65d7c" translate="yes" xml:space="preserve">
          <source>And finally, yes, the concepts are pretty much similar in other statically typed languages which support reflection (like C#). In dynamically typed languages, the use case described above is less necessary (since the compiler will allow any method to be called on any object, failing at runtime if it does not exist), but the second case of looking for methods which are marked or work in a certain way is still common.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로, 개념은 C #과 같이 리플렉션을 지원하는 다른 정적으로 유형이 지정된 언어와 거의 유사합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동적으로 유형이 지정된 언어에서는 위에서 설명한 유스 케이스가 덜 필요합니다 (컴파일러는 객체에서 메소드를 호출 할 수 있기 때문에 객체가 없을 경우 런타임에 실패 함). 또는 두 번째로 표시된 메소드를 찾는 경우 특정 방식으로 작업하는 것은 여전히 ​​흔합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0b518e10771b9253bdd4fc733405e465373ffaf4" translate="yes" xml:space="preserve">
          <source>And from Java 7 we have &lt;code&gt;MethodHandles&lt;/code&gt;, which works as &lt;code&gt;Reflection API&lt;/code&gt;. In projects, to work with loggers we just copy-paste the next code:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 7부터는 &lt;/font&gt; &lt;code&gt;Reflection API&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 작동하는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;MethodHandles&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로젝트에서 로거와 함께 작업하기 위해 다음 코드를 복사하여 붙여 넣습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="98106d65797a34619f72a02cb51b7d2dc74338bf" translate="yes" xml:space="preserve">
          <source>Another example would be the Java API for XML Parsing &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_API_for_XML_Processing&quot;&gt;(JAXP)&lt;/a&gt;. Where an XML parser provider is 'plugged-in' via well-known system properties, which are used to construct new instances through reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또 다른 예는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_API_for_XML_Processing&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JAXP (&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Java API for XML Parsing &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;XML 파서 공급자가 잘 알려진 시스템 속성을 통해 '플러그인'되는 경우 리플렉션을 통해 새 인스턴스를 구성하는 데 사용됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2677ff031c51b9e6180e8fe1a179c64f0a10160" translate="yes" xml:space="preserve">
          <source>As I find it best to explain by example and none of the answers seem to do that...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 설명하는 것이 가장 좋았지 만 그 대답 중 어느 것도 그렇게하지 않는 것 같습니다 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f002a793bb200d428bfb3a57f359de8a68a61d85" translate="yes" xml:space="preserve">
          <source>As name itself suggest it reflects what it holds for example class method,etc apart from providing feature to invoke method creating instance dynamically at runtime.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이름 자체가 제안하는 것처럼 런타임에 인스턴스를 동적으로 생성하는 메소드를 호출하는 기능을 제공하는 것 외에도 클래스 메소드 등의 예를 반영합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ca04a01c15dacb15e63a42b4719d12252a2f8fc8" translate="yes" xml:space="preserve">
          <source>As per my understanding:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 이해에 따라 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4a30e97f958985a613983df7e9a9f4147937428e" translate="yes" xml:space="preserve">
          <source>Because it is hard to make typo-error in this case.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 경우 오타를 만들기가 어렵 기 때문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2fd967478b11175693c52637e16182d67678925" translate="yes" xml:space="preserve">
          <source>Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations cannot be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts and should be avoided in sections of code which are called frequently in performance-sensitive applications.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션에는 동적으로 해결되는 유형이 포함되므로 특정 Java 가상 머신 최적화를 수행 할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결과적으로, 반사 작업은 비 반사에 비해 성능이 느리므로 성능에 민감한 응용 프로그램에서 자주 호출되는 코드 섹션에서는 피해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75cec77203d8a3c3bbb133724432d2b16ed9c414" translate="yes" xml:space="preserve">
          <source>Classes in this package, along with &lt;code&gt;java.lang.Class&lt;/code&gt; accommodate applications such as debuggers, interpreters, object inspectors, class browsers, and services such as &lt;code&gt;Object Serialization&lt;/code&gt; and &lt;code&gt;JavaBeans&lt;/code&gt; that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;java.lang.Class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 함께이 패키지의 클래스는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;디버거, 인터프리터, 객체 검사기, 클래스 브라우저 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Object Serialization&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;JavaBeans&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은 응용 프로그램 (예 : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대상 객체의 공용 멤버에 액세스해야하는 서비스)을 수용합니다. 런타임 클래스) 또는 주어진 클래스에 의해 선언 된 멤버&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cabd73d2b2f6bec7dcefa96fbed5523c29e5e5fa" translate="yes" xml:space="preserve">
          <source>Creating new instances of objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체의 새 인스턴스를 만듭니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5b464b3897b8c535381e2d8a17e39881cec6f04" translate="yes" xml:space="preserve">
          <source>Creation of new object instances, methods invocation, getting or setting field values of a restricted class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새로운 객체 인스턴스 생성, 메소드 호출, 제한된 클래스의 필드 값 가져 오기 또는 설정&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="984fe3ba3e70d02a7d3335b8bfb0d79f0b528af1" translate="yes" xml:space="preserve">
          <source>Debugger and Test Tools etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;디버거 및 테스트 도구 등&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="310d3e06116a3c41ab7d32a30a08a2f122bcb2f3" translate="yes" xml:space="preserve">
          <source>Exactly how all this works is explained here</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 모든 것이 어떻게 작동하는지 정확히 여기에 설명되어 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c175f05d7eb96cebecf6a41d3073e0e90c3ed97d" translate="yes" xml:space="preserve">
          <source>Examining properties of a class (fields, methods, constructors),</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스의 속성 (필드, 메소드, 생성자) 검사&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5594aeaa90d29ada020371584fb08ffe991ec816" translate="yes" xml:space="preserve">
          <source>For Private methods,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개인 메소드의 경우&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="693196b805e9eefa4595e0678693d6606e5c3833" translate="yes" xml:space="preserve">
          <source>For example, all objects in Java have the method &lt;code&gt;getClass()&lt;/code&gt;, which lets you determine the object's class even if you don't know it at compile time (e.g. if you declared it as an &lt;code&gt;Object&lt;/code&gt;) - this might seem trivial, but such reflection is not possible in less dynamic languages such as &lt;code&gt;C++&lt;/code&gt;. More advanced uses lets you list and call methods, constructors, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 자바의 모든 객체는 방법이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;getClass()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 컴파일시에 그것을 모르더라도 (예를 들어, 당신이로 선언 된 경우 객체의 클래스를 결정할 수 있습니다, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Object&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) -이 사소한 보일 수 있습니다,하지만 같은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;C++&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같이 덜 동적 인 언어에서는 리플렉션이 불가능합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보다 고급으로 사용하면 메소드, 생성자 등을 나열하고 호출 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6fb9254fbf60efc7b954b5ba670c968e6ee3a01e" translate="yes" xml:space="preserve">
          <source>For example, say you have an object of an unknown type in Java, and you would like to call a 'doSomething' method on it if one exists. Java's static typing system isn't really designed to support this unless the object conforms to a known interface, but using reflection, your code can look at the object and find out if it has a method called 'doSomething' and then call it if you want to.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, Java에 알 수없는 유형의 객체가 있고 'doSomething'메소드가 있으면이를 호출하려고한다고 가정하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java의 정적 타이핑 시스템은 객체가 알려진 인터페이스를 준수하지 않는 한 실제로 이것을 지원하도록 설계되지 않았지만 리플렉션을 사용하면 코드에서 객체를보고 'doSomething'이라는 메소드가 있는지 확인한 다음 호출하면 호출 할 수 있습니다 고 싶어요.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7fdc810374fe9dfa3045213c9b7a12737ef416f6" translate="yes" xml:space="preserve">
          <source>For inspection of classes (also know as introspection) you don't need to import the reflection package (&lt;code&gt;java.lang.reflect&lt;/code&gt;). Class metadata can be accessed through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 검사 (내장으로도 알려짐)를 위해 리플렉션 패키지 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.reflect&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 가져올 필요가 없습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 메타 데이터는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.Class&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 통해 액세스 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e00d01d41832cb3c81dfdf9609e05666593eb6a8" translate="yes" xml:space="preserve">
          <source>For private fields,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개인 필드의 경우&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="850912486e2e27fec1a678a7817806ccd05f4f34" translate="yes" xml:space="preserve">
          <source>From java documentation &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html&quot;&gt;page&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자바 문서 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;페이지에서&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9b57123908782edab0f9d5315a27bbbc06bd9567" translate="yes" xml:space="preserve">
          <source>From this &lt;a href=&quot;http://www.ibm.com/developerworks/library/j-dyn0603/&quot;&gt;article&lt;/a&gt; (by Dennis Sosnoski, President, Sosnoski Software Solutions, Inc)  and this &lt;a href=&quot;http://www.security-explorations.com/materials/se-2012-01-report.pdf&quot;&gt;article&lt;/a&gt; (security-explorations pdf):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/library/j-dyn0603/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기사&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (Dennis Sosnoski, Sosnoski Software Solutions, Inc. 사장) 및이 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.security-explorations.com/materials/se-2012-01-report.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기사&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (security-explorations pdf)에서 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="973d454cb269a335664d77c5a64d777b1349ce93" translate="yes" xml:space="preserve">
          <source>Have a look at this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;documentation&lt;/a&gt; link for the methods exposed by &lt;strong&gt;&lt;em&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;strong&gt;&lt;em&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 클래스에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의해 노출 된 메소드에 대한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문서&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 링크를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34deaa41eea028ce9992343bd939a2b019e0bfbf" translate="yes" xml:space="preserve">
          <source>Have a look at this SE question regarding abuse of reflection feature:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션 기능 남용에 관한이 SE 질문을 살펴보십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c60cc8d0b33ec9707ca888b5d0cc96c2d441df1b" translate="yes" xml:space="preserve">
          <source>Here is some example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 몇 가지 예입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eea4d3e68f79645621537952d7885a21a986a764" translate="yes" xml:space="preserve">
          <source>How do I read a private field in Java?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java에서 개인 필드를 읽으려면 어떻게합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5dcee71779b03aaff859733ff309c6577746074" translate="yes" xml:space="preserve">
          <source>I can see considerable drawbacks than uses of using Reflection</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Reflection을 사용하는 것보다 상당한 단점이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="254f8a9369907f42f3509935f7f7c87622baa519" translate="yes" xml:space="preserve">
          <source>I just want to add some point to all that was listed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나열된 모든 항목에 포인트를 추가하고 싶습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f9631de6c8595f344b280ad2df45d2bdc6cb1b9" translate="yes" xml:space="preserve">
          <source>I want to answer this question by example. First of all &lt;code&gt;Hibernate&lt;/code&gt; project uses &lt;code&gt;Reflection API&lt;/code&gt; to generate &lt;code&gt;CRUD&lt;/code&gt; statements to bridge the chasm between the running application and the persistence store. When things change in the domain, the &lt;code&gt;Hibernate&lt;/code&gt; has to know about them to persist them to the data store and vice versa.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 질문에 예를 들어 대답하고 싶습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우선 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Hibernate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 프로젝트는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Reflection API&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 사용하여 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;CRUD&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 문을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 실행중인 애플리케이션과 지속성 저장소 사이의 틈을 메 웁니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;도메인에서 상황이 변경 될 때, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Hibernate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 데이터를 데이터 저장소에 유지하거나 그 반대로 유지해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59ea7d8a60e63123865790fbb39afca4b577dbbe" translate="yes" xml:space="preserve">
          <source>I'm particularly interested in Java, but I assume the principles are the same in any language.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히 Java에 관심이 있지만 원칙이 모든 언어에서 동일하다고 가정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e63bac98f2a6938d9fab00930c2876281232d32" translate="yes" xml:space="preserve">
          <source>IDE (Integrated Development Environment) e.g. Eclipse, MyEclipse, NetBeans etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IDE (Integrated Development Environment) 예 : Eclipse, MyEclipse, NetBeans 등&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0adeb6df453a9aaf352a57864918b02b12305438" translate="yes" xml:space="preserve">
          <source>IE: dynamic classes, functions, constructors - based on any data
  (xml/array/sql results/hardcoded/etc..)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;IE : 동적 클래스, 함수, 생성자-모든 데이터 기반 (xml / array / sql results / hardcoded / etc.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="589a59e1de357ac295cf54fd7d57ea897e25f5a4" translate="yes" xml:space="preserve">
          <source>In C# for example you can load an assembly (a .dll) in runtime an examine it, navigating through the classes and taking actions according to what you found. It also let you create an instance of a class on runtime, invoke its method, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 C #에서는 런타임에 어셈블리 (.dll)를로드하여 클래스를 탐색하고 찾은 내용에 따라 작업을 수행 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 런타임에 클래스의 인스턴스를 만들고 메소드 등을 호출 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2c488cd992bbd3e18da0edfcfb16bdc9c8d6e3e" translate="yes" xml:space="preserve">
          <source>In above example the null parameter is the object you want to invoke the method on. If the method is static you supply null. If the method is not static, then while invoking you need to supply a valid MyObject instance instead of null.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 예에서 null 매개 변수는 메서드를 호출하려는 객체입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메소드가 정적이면 널을 제공합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메소드가 정적이 아닌 경우, 호출하는 동안 널 대신 유효한 MyObject 인스턴스를 제공해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="823d0c56e8aa92cf5babf3278a56092f4ee027c9" translate="yes" xml:space="preserve">
          <source>Instead, by using reflection, there is need to worry about a possibly changing class name.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대신 리플렉션을 사용하면 클래스 이름 변경 가능성에 대해 걱정할 필요가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f66396f7168221b2bf84c5dcc35135d1e55d77e3" translate="yes" xml:space="preserve">
          <source>Invoking methods,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메소드 호출&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ffda05e922f9a6bcf056ba767a3e49ccdf042dbd" translate="yes" xml:space="preserve">
          <source>It  allows violation of key Java security constraints such
as data access protection and type safety</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터 액세스 보호 및 유형 안전과 같은 주요 Java 보안 제약 조건을 위반할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="542d0b30181db440cde9bf0e2ad31c763156bc7b" translate="yes" xml:space="preserve">
          <source>It bypasses the source code can create maintenance problems</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;유지 보수 문제를 일으킬 수있는 소스 코드를 무시&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a23ed20b481cccd78ea2932605cc56e463dd42e8" translate="yes" xml:space="preserve">
          <source>It can obscure what's actually going on inside your code</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 코드 내부에서 일어나는 일을 모호하게 할 수 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf0127f8da675ab2d8ff724e917268c8d041e581" translate="yes" xml:space="preserve">
          <source>It includes following functionality.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같은 기능이 포함되어 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6aa0dcbeeb964726e2fdcf8fed08463e02aa3b69" translate="yes" xml:space="preserve">
          <source>It is frequently used in scenarios where a class name changes frequently. If such a situation arises, then it is complicated for the programmer to rewrite the application and change the name of the class again and again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 이름이 자주 변경되는 시나리오에서 자주 사용됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 상황이 발생하면 프로그래머가 응용 프로그램을 다시 작성하고 클래스 이름을 반복해서 변경하기가 복잡합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd269443759350e48ed7bdc11388a81f11912bc4" translate="yes" xml:space="preserve">
          <source>It is used by many frameworks and application under the wood to invoke services without actually knowing the code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 코드를 몰라도 서비스를 호출하기 위해 많은 프레임 워크와 응용 프로그램에서 사용됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8bc170fa614d477d4ecf0a540e8a358361ec7d71" translate="yes" xml:space="preserve">
          <source>It is useful at debugging.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;디버깅에 유용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdcb9f4cc5e879ab063042e5b93d78cf2a07fdc9" translate="yes" xml:space="preserve">
          <source>It is useful for creating libraries that work with objects in very general ways</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;매우 일반적인 방식으로 객체와 함께 작동하는 라이브러리를 만드는 데 유용합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7f230118147515166a5ef34dfbd9f3ebe67b3e4c" translate="yes" xml:space="preserve">
          <source>It provides very versatile way of dynamically linking program components</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램 구성 요소를 동적으로 연결하는 매우 다양한 방법을 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1f33d88e3b05279f20e9d11df744b730f18886fd" translate="yes" xml:space="preserve">
          <source>It will then again use reflection to get the appropriate setter for the &amp;lt; property &amp;gt; element and set its value to the specified value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 다시 반사를 사용하여 &amp;lt;property&amp;gt; 요소에 대한 적절한 설정자를 가져오고 해당 값을 지정된 값으로 설정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1faa80fe2d86f9a33996d2c1b07db9ecff718f1" translate="yes" xml:space="preserve">
          <source>It's useful because it allows you to change the runtime behavior depending on the meta information of your program, that is, you can check the return type of a function and change the way you handle the situation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램의 메타 정보에 따라 런타임 동작을 변경할 수 있으므로 함수의 반환 유형을 확인하고 상황 처리 방법을 변경할 수 있기 때문에 유용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9529d68eae9b702b42f4214bdc3e902aa6e05c92" translate="yes" xml:space="preserve">
          <source>It's usefull in a lot of situations. Everywhere you want to be able to dynamically plug in classes into your code. Lot's of object relational mappers use reflection to be able to instantiate objects from databases without knowing in advance what objects they're going to use. Plug-in architectures is another place where reflection is usefull. Being able to dynamically load code and determine if there are types there that implement the right interface to use as a plugin is important in those situations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 상황에서 유용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어디서나 코드에 클래스를 동적으로 연결할 수 있기를 원합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 객체 관계형 맵퍼는 리플렉션을 사용하여 어떤 객체를 사용할지 미리 알지 않고도 데이터베이스에서 객체를 인스턴스화 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;플러그인 아키텍처는 리플렉션이 유용한 또 다른 장소입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동적으로 코드를로드하고 플러그인으로 사용하기에 적합한 인터페이스를 구현하는 유형이 있는지 판별하는 것이 이러한 상황에서 중요합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3c24576ba302c22f5da6c285a19a92312766907" translate="yes" xml:space="preserve">
          <source>Java Reflection is quite powerful and can be very useful.
Java Reflection makes it possible &lt;strong&gt;to inspect classes, interfaces, fields and methods at runtime,&lt;/strong&gt; without knowing the names of the classes, methods etc. at compile time.
It is also possible to &lt;strong&gt;instantiate new objects, invoke methods and get/set field values using reflection.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Reflection은 매우 강력하며 매우 유용 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Reflection을 사용하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일 타임에 클래스, 메서드 등의 이름을 몰라도 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런타임에 클래스, 인터페이스, 필드 및 메서드를 검사&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다. &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 사용하여 새 객체&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인스턴스화하고 메소드를 호출하며 필드 값을 가져 오거나 설정할 수도 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec6f30c063fcb9ef481489312513588e235d3aa2" translate="yes" xml:space="preserve">
          <source>Junit uses Reflection especially for testing Private/Protected methods.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Junit은 특히 Private / Protected 메소드 테스트에 Reflection을 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="477383916e2dc5b2c68531150a4c99e526ed2157" translate="yes" xml:space="preserve">
          <source>Loading of restricted classes,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;제한된 클래스 로딩&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ed06bc60874c9e75502a47786ce6dd86d5cfb34" translate="yes" xml:space="preserve">
          <source>Lots of modern frameworks use reflection extensively for this very reason. Most other modern languages use reflection as well, and in scripting languages (such as Python) they are even more tightly integrated, since it feels more natural within the general programming model of those languages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 현대 프레임 워크가 바로 이런 이유로 반사를 광범위하게 사용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 다른 현대 언어도 리플렉션을 사용하며, 스크립트 언어 (예 : Python)에서는 언어의 일반적인 프로그래밍 모델에서보다 자연스럽게 느껴지므로 훨씬 더 밀접하게 통합되어 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea201fad47b1868a8fe0ee11adbb17073d6da9de" translate="yes" xml:space="preserve">
          <source>Not every language supports reflection but the principles are usually the same in languages that support it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 언어가 리플렉션을 지원하는 것은 아니지만 원칙을 지원하는 언어는 원칙이 동일합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8645ecdcb4e899cc6ecd81759dd0741f6c8d8473" translate="yes" xml:space="preserve">
          <source>Obtaining Class objects,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 객체 얻기&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e59ff890fe3bc21bd9694e61ab7c233ef689ffdc" translate="yes" xml:space="preserve">
          <source>Obtaining references to constructors, methods or fields of a restricted class,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;제한된 클래스의 생성자, 메소드 또는 필드에 대한 참조 얻기&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="697ea410e74a0eb90c777be04cc0855e87705cdb" translate="yes" xml:space="preserve">
          <source>One of my favorite uses of reflection is the below Java dump method. It takes any object as a parameter and uses the Java reflection API to print out every field name and value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 가장 좋아하는 용도 중 하나는 아래 Java 덤프 방법입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 객체를 매개 변수로 사용하고 Java 리플렉션 API를 사용하여 모든 필드 이름과 값을 인쇄합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b834c56b8aa4817757e501cdca629ca4aad60ce" translate="yes" xml:space="preserve">
          <source>One very common use case in Java is the usage with annotations. JUnit 4, for example, will use reflection to look through your classes for methods tagged with the @Test annotation, and will then call them when running the unit test.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java에서 가장 일반적인 사용 사례는 주석 사용입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, JUnit 4는 리플렉션을 사용하여 @Test 주석으로 태그가 지정된 메소드를 클래스에서 살펴본 다음 단위 테스트를 실행할 때이를 호출합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7b7691de77ab4ac4bbc3b9109372d29db5e3ecba" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;http://www.geeksforgeeks.org/reflection-in-java/&quot;&gt;Java Reflection&lt;/a&gt;&lt;a href=&quot;http://javarevisited.blogspot.in/2012/05/how-to-access-private-field-and-method.html&quot;&gt;javarevisited.blogspot.in&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/reflection-in-java/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자바 리플렉션 &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;http://javarevisited.blogspot.in/2012/05/how-to-access-private-field-and-method.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;javarevisited.blogspot.in&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc2346f09e6a5ef2803272b9e4b34b2ec156b429" translate="yes" xml:space="preserve">
          <source>Reflection allows instantiation of new objects, invocation of methods, and get/set operations on class variables dynamically at run time without having prior knowledge of its implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 구현에 대한 사전 지식없이 런타임에 새로운 객체의 인스턴스화, 메소드 호출 및 클래스 변수에 대한 작업 가져 오기 / 설정을 동적으로 허용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8acc7c746ded76a918047280fbbb3333490d6ee" translate="yes" xml:space="preserve">
          <source>Reflection allows programmer to access entities in program dynamically. i.e. while coding an application if programmer is unaware about a class or its methods, he can make use of such class dynamically (at run time) by using reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 통해 프로그래머는 프로그램의 엔터티에 동적으로 액세스 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 프로그래머가 클래스 나 클래스의 메서드를 모르는 경우 응용 프로그램을 코딩하는 동안 리플렉션을 사용하여 런타임에 이러한 클래스를 동적으로 사용할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f37357014c003a54ec493246687a7444440fcd2a" translate="yes" xml:space="preserve">
          <source>Reflection also allows you to access private member/methods of a class:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 사용하면 클래스의 비공개 멤버 / 방법에 액세스 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a217aec8f01d9275c05ea95b02480164f9f45d6b" translate="yes" xml:space="preserve">
          <source>Reflection code is also more complex than the corresponding direct code</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션 코드는 해당 직접 코드보다 복잡합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68f6c9c71d88215dda226271549652ed9dbb6af3" translate="yes" xml:space="preserve">
          <source>Reflection gives us information about the class to which an object belongs and also the methods of that class which can be executed by using the object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 객체가 속한 클래스와 객체를 사용하여 실행할 수있는 클래스의 메소드에 대한 정보를 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db38284702d4de4debeccce6b221673af3d2314a" translate="yes" xml:space="preserve">
          <source>Reflection gives you the ability to write more generic code. It allows you to create an object at runtime and call its method at runtime. Hence the program can be made highly parameterized. It also allows introspecting the object and class to detect its variables and method exposed to the outer world.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 사용하면보다 일반적인 코드를 작성할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런타임에 객체를 생성하고 런타임에 메소드를 호출 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 프로그램을 고도로 매개 변수화 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 객체와 클래스를 조사하여 외부 세계에 노출 된 변수와 메소드를 감지 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5efe0f8d4b975ae78ef2cfa6918c6502f062b7e5" translate="yes" xml:space="preserve">
          <source>Reflection is a key mechanism to allow an application or framework to work with code that might not have even been written yet!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 응용 프로그램이나 프레임 워크가 아직 작성되지 않았을 수도있는 코드로 작동 할 수 있도록하는 핵심 메커니즘입니다!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5219115cc863bf20388caf98ef604a4d4c4b9a31" translate="yes" xml:space="preserve">
          <source>Reflection is a set of functions which allows you to access the runtime information of your program and modify it behavior (with some limitations).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 프로그램의 런타임 정보에 액세스하여 동작을 수정할 수있는 기능 세트입니다 (일부 제한 사항이 있음).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f4224bf21b4ff6caa7248cbb7fdfd34031ed536" translate="yes" xml:space="preserve">
          <source>Reflection is a very powerful API but it may slow down the application if used in excess, as it resolves all the types at runtime.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 매우 강력한 API이지만 런타임에 모든 유형을 확인하므로 초과 사용하면 응용 프로그램 속도가 느려질 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="47750829f34b52f1a4d7eb0bfa90de280fa1357f" translate="yes" xml:space="preserve">
          <source>Reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 일반적으로 Java 가상 머신에서 실행되는 애플리케이션의 런타임 동작을 검사하거나 수정해야하는 프로그램에서 사용됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 비교적 고급 기능이며 언어의 기본 사항을 잘 알고있는 개발자 만 사용해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 경고를 염두에두고 리플렉션은 강력한 기술이므로 응용 프로그램에서 불가능한 작업을 수행 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a996a95ce6377941641fdade6f5ccdc15836006a" translate="yes" xml:space="preserve">
          <source>Reflection is important since it lets you write programs that do not have to &quot;know&quot; everything at compile time, making them more dynamic, since they can be tied together at runtime. The code can be written against known interfaces, but the actual classes to be used can be instantiated using reflection from configuration files.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 컴파일 타임에 모든 것을 &quot;알지&quot;않아도되는 프로그램을 작성하여 런타임에 서로 묶을 수 있기 때문에보다 동적으로 만들 수 있기 때문에 중요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알려진 인터페이스에 대해 코드를 작성할 수 있지만 사용되는 실제 클래스는 구성 파일에서 리플렉션을 사용하여 인스턴스화 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="377c299d76a416cc7636903bb8fb907815a92340" translate="yes" xml:space="preserve">
          <source>Reflection is much slower than direct code when used for field and method access.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필드 및 메소드 액세스에 사용될 때 리플렉션은 직접 코드보다 훨씬 느립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="39ed6d7dc105535550cdc170f9710f2089167435" translate="yes" xml:space="preserve">
          <source>Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사는 강력하지만 무차별 적으로 사용해서는 안됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사를 사용하지 않고 작업을 수행 할 수 있으면 사용을 피하는 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 통해 코드에 액세스 할 때는 다음 사항을 염두에 두어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac26492de916ca7697ea01aee13539fdda84f0a4" translate="yes" xml:space="preserve">
          <source>Reflection is the ability to &quot;reflect&quot; on the structure of your program. Or more concrete. To look at the objects and classes you have and programmatically get back information on the methods, fields, and interfaces they implement. You can also look at things like annotations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 프로그램 구조를 &quot;반영&quot;하는 능력입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는 더 구체적인. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가지고있는 객체와 클래스를보고 프로그래밍 방식으로 메소드, 필드 및 인터페이스에 대한 정보를 얻습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주석과 같은 것을 볼 수도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3069b249454a7521079ef23974c9cab83670986" translate="yes" xml:space="preserve">
          <source>Reflection is to let object to see their appearance. This argument seems nothing to do with reflection. In fact, this is the &quot;self-identify&quot; ability.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사는 물체가 자신의 모습을 볼 수있게하는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 주장은 성찰과 관련이없는 것 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 이것은 &quot;자가 식별&quot;기능입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4a5e2b549ed93f324cf7bab644f028cfa8ce1528" translate="yes" xml:space="preserve">
          <source>Reflection itself is a word for such languages that lack the capability of self-knowledge and self-sensing as Java and C#. Because they do not have the capability of self-knowledge, when we want to observe how it looks like, we must have another thing to reflect on how it looks like. Excellent dynamic languages such as Ruby and Python can perceive the reflection of their own without the help of other individuals. We can say that the object of Java cannot perceive how it looks like without a mirror, which is an object of the reflection class, but an object in Python can perceive it without a mirror. So that's why we need reflection in Java.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션 자체는 Java 및 C #과 같은 자체 지식 및 자체 감지 기능이없는 언어의 단어입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그들에게는 자기 지식의 능력이 없기 때문에, 그것이 어떻게 보이는지 관찰하고 싶을 때, 우리는 그것이 어떻게 보이는지에 대해 또 다른 것을 고려해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ruby 및 Python과 같은 탁월한 동적 언어는 다른 개인의 도움 없이도 자신의 언어를 반영 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java의 객체는 리플렉션 클래스의 객체 인 미러가없는 경우의 모습을 인식 할 수 없지만 Python의 객체는 미러없이이를 인식 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서 우리는 Java로 리플렉션해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc3e348e092fed72b69acabc88a3e9231891d8df" translate="yes" xml:space="preserve">
          <source>Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Reflection에는 보안 관리자에서 실행할 때 존재하지 않는 런타임 권한이 필요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 애플릿과 같이 제한된 보안 컨텍스트에서 실행되어야하는 코드에있어 중요한 고려 사항입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f04529f40ec32d7f346acf314474d6101993e2d0" translate="yes" xml:space="preserve">
          <source>Setting and getting field values,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필드 값 설정 및 가져 오기&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9fbf65523bc453e10a3d5104969528d78e85a62" translate="yes" xml:space="preserve">
          <source>Simple example for reflection.
In a chess game, you do not know what will be moved by the user at run time. reflection can be used to call methods which are already implemented at run time:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사에 대한 간단한 예. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;체스 게임에서는 런타임에 사용자가 무엇을 움직 일지 알 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 런타임에 이미 구현 된 메소드를 호출하는 데 사용할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e8bfe093287c98e51f95e42feee3bae8ebc51cc2" translate="yes" xml:space="preserve">
          <source>Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 사용하면 개인 필드 및 메서드에 액세스하는 것과 같이 비 반사 코드에서 불법적 인 작업을 코드에서 수행 할 수 있으므로 리플렉션을 사용하면 예기치 않은 부작용이 발생하여 코드가 제대로 작동하지 않아 이식성이 떨어질 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사 코드는 추상화를 손상 시키므로 플랫폼을 업그레이드하면 동작이 변경 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8724c4153e380659fdd217d8eba7f1cb0a1dcaf4" translate="yes" xml:space="preserve">
          <source>So we might implement in 3 classes each containing a different logic .Obviously the object  information is available in runtime so you cannot statically code to perform computation hence reflection is used to instantiate the object of the class that you require to perform the computation based on the object received from the provider .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 각각 다른 로직을 포함하는 3 개의 클래스로 구현할 수 있습니다. 물론 런타임에 객체 정보를 사용할 수 있으므로 정적으로 코드를 작성하여 계산을 수행 할 수 없으므로 리플렉션을 사용하여 계산을 수행하는 데 필요한 클래스의 객체를 인스턴스화 할 수 있습니다. 공급자로부터받은 개체입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="635afd63b9273f7fdaee3a02919e369f61f1a6e3" translate="yes" xml:space="preserve">
          <source>So, to give you a code example of this in Java (imagine the object in question is foo) :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 Java로 코드 예제를 제공하려면 (문제의 객체가 foo라고 상상하십시오.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d6febcf15152d8de02fe3348451d82daeec0ac2" translate="yes" xml:space="preserve">
          <source>Spring uses bean configuration such as:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring은 다음과 같은 Bean 구성을 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f61183eaff1df22c443b6f8bde3959781f43b8fe" translate="yes" xml:space="preserve">
          <source>Take for example a remote application which gives your application an object which you obtain using their API Methods . Now based on the object you might need to perform some sort of computation .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;API 메소드를 사용하여 얻은 객체를 애플리케이션에 제공하는 원격 애플리케이션을 예로 들어 보겠습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 객체를 기반으로 일종의 계산을 수행해야 할 수도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d4297d76e89658b1926871e00e1ecb1c986af2b" translate="yes" xml:space="preserve">
          <source>Take for example your typical web.xml file. This will contain a list of servlet elements, which contain nested servlet-class elements. The servlet container will process the web.xml file, and create new a new instance of each servlet class through reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적인 web.xml 파일을 예로 들어 보겠습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에는 중첩 된 서블릿 클래스 요소가 포함 된 서블릿 요소 목록이 포함됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서블릿 컨테이너는 web.xml 파일을 처리하고 리플렉션을 통해 각 서블릿 클래스의 새 인스턴스를 새로 만듭니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5441cc3e68def23311ae3069c5213a79fb6d793" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;java.lang&lt;/code&gt; and &lt;code&gt;java.lang.reflect&lt;/code&gt; packages provide classes for java reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;java.lang&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.reflect&lt;/code&gt; 의&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 패키지는 자바 반사하기위한 클래스를 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b95bfd9602344297040acb8417c536c25721f0a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Reflection API&lt;/strong&gt; is mainly used in:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사 API는&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 주로 사용된다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04d7c78236ee89824542d56ba549b24aeeb3ce91" translate="yes" xml:space="preserve">
          <source>The ability to inspect the code in the system and see object types is
  not reflection, but rather Type Introspection. Reflection is then the
  ability to make modifications at runtime by making use of
  introspection. The distinction is necessary here as some languages
  support introspection, but do not support reflection. One such example
  is C++</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시스템에서 코드를 검사하고 객체 유형을 볼 수있는 기능은 반영이 아니라 유형 검사입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션은 런타임에 내부 검사를 사용하여 수정하는 기능입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 언어는 내부 검사를 지원하지만 리플렉션은 지원하지 않으므로 구별이 필요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러한 예 중 하나는 C ++입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64826090e45abc29b52ec33aee4fd3a8935d1153" translate="yes" xml:space="preserve">
          <source>The name reflection is used to describe code which is able to inspect other code in the same system (or itself).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이름 반영은 동일한 시스템 (또는 자체)에서 다른 코드를 검사 할 수있는 코드를 설명하는 데 사용됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8bd80d3aa3030e4b8f6a6f74cf091bd7474e02c" translate="yes" xml:space="preserve">
          <source>The provider guarantees that object can be of 3 types and we need to perform computation based on what type of object .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공급자는 객체가 3 가지 유형일 수 있으며 어떤 유형의 객체를 기반으로 계산을 수행해야하는지 보장합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24832444ab515d4459764d90fef06d4a35a14894" translate="yes" xml:space="preserve">
          <source>The required classes for reflection are provided under &lt;code&gt;java.lang.reflect package&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션에 필요한 클래스는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;java.lang.reflect package&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 제공됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cee64e47e968ebdb3bf6f36dfb55711ed80943bc" translate="yes" xml:space="preserve">
          <source>There are some good reflection examples to get you started at &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/reflect/index.html&quot;&gt;http://docs.oracle.com/javase/tutorial/reflect/index.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/reflect/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://docs.oracle.com/javase/tutorial/reflect/index.html&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 시작할 수있는 몇 가지 좋은 예가 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="15848ed19daf91dc599a9ff7594b0b3d522f11cf" translate="yes" xml:space="preserve">
          <source>This example obtains the Class object from the class called MyObject. Using the class object the example gets a list of the methods in that class, iterates the methods and print out their names.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 예제는 MyObject라는 클래스에서 Class 객체를 가져옵니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 예제에서는 클래스 객체를 사용하여 해당 클래스의 메소드 목록을 가져 와서 메소드를 반복하고 이름을 인쇄합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b81690f4b4757a81fe7b4c08dda32ca5cad7198e" translate="yes" xml:space="preserve">
          <source>Through reflection we can invoke methods at runtime irrespective of the access specifier used with them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션을 통해 사용 된 액세스 지정자와 상관없이 런타임에 메소드를 호출 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a561e326da9ebe21a8e13536d31808cf84879d80" translate="yes" xml:space="preserve">
          <source>What is reflection and why is it useful</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반사 란 무엇이며 왜 유용합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5e2c197bd1e64c01b4c7886ec8b0ee3ecc2474b" translate="yes" xml:space="preserve">
          <source>What is reflection, and why is it useful?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리플렉션이란 무엇이며 왜 유용합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ed9422a2ea0d1d0fefd2a8439979ee5b364d653" translate="yes" xml:space="preserve">
          <source>When the Spring context processes this &amp;lt; bean &amp;gt; element, it will use Class.forName(String) with the argument &quot;com.example.Foo&quot; to instantiate that Class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring 컨텍스트가이 &amp;lt;bean&amp;gt; 요소를 처리 할 때 &quot;com.example.Foo&quot;인수와 함께 Class.forName (String)을 사용하여 해당 클래스를 인스턴스화합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="af1158d1d64999cdcf645b618eba9c9d3b13e77a" translate="yes" xml:space="preserve">
          <source>Where can it be useful? Is not useful every time but for concrete situations. For example you can use it to get the name of the class for logging purposes, to dynamically create handlers for events according to what's specified on a configuration file and so on...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어디에서 유용 할 수 있습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;매번 유용하지는 않지만 구체적인 상황에 유용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 로깅 목적으로 클래스 이름을 가져오고 구성 파일에 지정된 내용에 따라 이벤트 처리기를 동적으로 만들 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37f86593e132b343b87b879e0fa055158365feb1" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;Reflection API&lt;/strong&gt; you can write universal &lt;code&gt;toString()&lt;/code&gt; method for any object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Reflection API&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 객체에 대해 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;범용 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메서드를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작성할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90a0cd0782edde2787574165e7afdae56b562e70" translate="yes" xml:space="preserve">
          <source>source: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/reflect/&quot;&gt;The Reflection API&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;출처 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/reflect/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Reflection API&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
