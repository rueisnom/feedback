<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3748">
    <body>
      <group id="3748">
        <trans-unit id="47c3aaa77395e894593329e3bdb56a462542e81a" translate="yes" xml:space="preserve">
          <source>+ves:</source>
          <target state="translated">+ves:</target>
        </trans-unit>
        <trans-unit id="5dcc67d3b3974bde67a1dfbe489b0bf1470ca12c" translate="yes" xml:space="preserve">
          <source>-ves:</source>
          <target state="translated">-ves:</target>
        </trans-unit>
        <trans-unit id="df2eb94a6b01c34ef601502e19e10d652b46439d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;This thread&lt;/a&gt; explains why you should use a 3rd party hosting provider.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;이 스레드&lt;/a&gt; 는 왜 타사 호스팅 제공 업체를 사용해야하는지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b616c405d40078118403f0f28e9e2f410c4eb6eb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Assumption: Application is web enabled/web based&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;가정 : 응용 프로그램은 웹 사용 가능 / 웹 기반&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a68ce6032c3740fd013d6c9b66b882246d9cf06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e3161fd669d07159e3a7475c999f77628c85246" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c202eefcc3c874230f5d8c6563173cba8693635" translate="yes" xml:space="preserve">
          <source>A. You don't need FS structure to hold your images</source>
          <target state="translated">A. 이미지를 담기 위해 FS 구조가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="270426116340bdc0cd86224583f5d3877de93a8b" translate="yes" xml:space="preserve">
          <source>Ability to easily implement a document versioning system</source>
          <target state="translated">문서 버전 관리 시스템을 쉽게 구현할 수있는 기능</target>
        </trans-unit>
        <trans-unit id="c7b27ed64e40c36b897240dcbfc2315467a72a1a" translate="yes" xml:space="preserve">
          <source>Also, you could decide to save with some structure or elements that allow you to browse the raw images in your filesystem without any db hits, or transfer the files in bulk to another system, hard drive, S3 or another scenario - updating the location in your program, but keep the structure, again without much of a hit trying to bring the images out of your db when trying to increase storage.</source>
          <target state="translated">또한 db 적중없이 파일 시스템의 원시 이미지를 탐색하거나 파일을 다른 시스템, 하드 드라이브, S3 또는 다른 시나리오로 대량 전송하여 위치를 업데이트 할 수있는 구조 또는 요소를 저장하기로 결정할 수 있습니다 저장 공간을 늘리려 고 할 때 이미지를 DB에서 가져 오려고 시도하지 않고 다시 구조를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="7b11a4234011e35a6c31048c3a964862b6e69ee8" translate="yes" xml:space="preserve">
          <source>Amazon S3</source>
          <target state="translated">아마존 S3</target>
        </trans-unit>
        <trans-unit id="806863a20fd9521591c93b6ce2c193c0342f405d" translate="yes" xml:space="preserve">
          <source>Another StackOverflow threads talking about this &lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이것에 대해 이야기하는 또 다른 StackOverflow 스레드가 &lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4137b28bbb9fcf80d76df94dcc9ea52f9b414a06" translate="yes" xml:space="preserve">
          <source>Another reason to go for file system is when you have to share your images data (or sounds, video, whatever) with third party access: in this days I'm developing a web app that uses images that have to be accessed from &quot;outside&quot; my web farm in such a way that a database access to retrieve binary data is simply impossible. So sometimes there are also design considerations that will drive you to a choice.</source>
          <target state="translated">파일 시스템을 사용해야하는 또 다른 이유는 이미지 데이터 (또는 사운드, 비디오 등)를 타사 액세스와 공유해야 할 때입니다. 요즘에는 &quot;외부에서 액세스해야하는 이미지를 사용하는 웹 앱을 개발하고 있습니다. 이진 데이터를 검색하기위한 데이터베이스 액세스가 불가능한 방식의 웹 팜입니다. 따라서 때로는 선택을 유도하는 디자인 고려 사항도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e76a3d1c0a59c96f4904844811645326c89b249" translate="yes" xml:space="preserve">
          <source>As others have said SQL 2008 comes with a Filestream type that allows you to store a filename or identifier as a pointer in the db and automatically stores the image on your filesystem which is a great scenario.</source>
          <target state="translated">다른 사람들이 말했듯이 SQL 2008에는 파일 스트림 유형이 제공되어 파일 이름 또는 식별자를 db에 포인터로 저장하고 파일 시스템에 이미지를 자동으로 저장할 수 있습니다. 이는 훌륭한 시나리오입니다.</target>
        </trans-unit>
        <trans-unit id="9b2634f0ec6106d9f9147e4cd3dff1615adeba37" translate="yes" xml:space="preserve">
          <source>As with most issues, it's not as simple as it sounds. There are cases where it would make sense to store the images in the database.</source>
          <target state="translated">대부분의 문제와 마찬가지로 간단하지 않습니다. 데이터베이스에 이미지를 저장하는 것이 적합한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a35d366d9a1eb88fd629e03b09b4bdd7c8a046d" translate="yes" xml:space="preserve">
          <source>At a company where I used to work we stored 155 million images in an Oracle 8i (then 9i) database. 7.5TB worth.</source>
          <target state="translated">내가 일하던 회사에서 Oracle 8i (the 9i) 데이터베이스에 1 억 5,500 만 개의 이미지를 저장했습니다. 7.5TB 가치.</target>
        </trans-unit>
        <trans-unit id="687370ce64f7e2dd0384ee8f207a893b7096ffc1" translate="yes" xml:space="preserve">
          <source>B. Database indexes perform better than FS trees when more number of items are to be stored</source>
          <target state="translated">B. 더 많은 수의 항목을 저장해야 할 경우 데이터베이스 색인이 FS 트리보다 성능이 우수합니다</target>
        </trans-unit>
        <trans-unit id="848d820eb3eab4f745688973041d4a9d217d5075" translate="yes" xml:space="preserve">
          <source>Backups are integrated.</source>
          <target state="translated">백업이 통합되었습니다.</target>
        </trans-unit>
        <trans-unit id="c8dd18981a74439309d7966c8a027a8cc858d9b3" translate="yes" xml:space="preserve">
          <source>Both methods are common and practiced. Have a look at the advantages and disadvantages. Either way, you'll have to think about how to overcome the disadvantages. Storing in database usually means tweaking database parameters and implement some kind of caching. Using filesystem requires you to find some way of keeping filesystem+database in sync.</source>
          <target state="translated">두 방법 모두 일반적이며 실용적입니다. 장단점을 살펴보십시오. 어느 쪽이든 단점을 극복하는 방법에 대해 생각해야합니다. 데이터베이스에 저장하는 것은 일반적으로 데이터베이스 매개 변수를 조정하고 일종의 캐싱을 구현하는 것을 의미합니다. 파일 시스템을 사용하려면 파일 시스템 + 데이터베이스를 동기화 상태로 유지하는 방법을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="6b99be15334afb0e1fb922b7dd040aa5dd83e1d3" translate="yes" xml:space="preserve">
          <source>C. Smartly tuned database perform good job at caching the query results</source>
          <target state="translated">C. 지능적으로 조정 된 데이터베이스는 쿼리 결과를 캐싱 할 때 좋은 작업을 수행</target>
        </trans-unit>
        <trans-unit id="a9fa41cd24ffd5f1e44c7dadd97884e69eb206be" translate="yes" xml:space="preserve">
          <source>Consider also, when making this choice, if you have to deal with permission and authentication when accessing binary objects: these requisites normally can be solved in an easier way when data are stored in db.</source>
          <target state="translated">또한 이진 객체에 액세스 할 때 권한 및 인증을 처리해야하는 경우이 선택을 고려하십시오. 이러한 필수 조건은 일반적으로 데이터가 db에 저장 될 때 더 쉬운 방법으로 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb124dc6fc8752f003971d881d4cc87007a2d3f" translate="yes" xml:space="preserve">
          <source>D. Backups are simple. It also works well if you have replication set up and content is delivered from a server near to user. In such cases, explicit synchronization is not required.</source>
          <target state="translated">D. 백업은 간단합니다. 복제가 설정되어 있고 컨텐츠가 사용자 근처의 서버에서 제공되는 경우에도 잘 작동합니다. 이러한 경우 명시적인 동기화가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1a5dae551b12236616319e0bb35a5bf5f6335cf" translate="yes" xml:space="preserve">
          <source>Ease of Replication and Backup</source>
          <target state="translated">간편한 복제 및 백업</target>
        </trans-unit>
        <trans-unit id="e22bfbeb8bec5e7cafa254beae090269060a8e07" translate="yes" xml:space="preserve">
          <source>FILESTREAM uses the NT system cache for caching file data. This helps reduce any effect that FILESTREAM data might have on Database Engine performance. The SQL Server buffer pool is not used; therefore, this memory is available for query processing.</source>
          <target state="translated">FILESTREAM은 파일 시스템을 캐싱하기 위해 NT 시스템 캐시를 사용합니다. 이는 FILESTREAM 데이터가 데이터베이스 엔진 성능에 미칠 수있는 영향을 줄이는 데 도움이됩니다. SQL Server 버퍼 풀이 사용되지 않습니다. 따라서이 메모리는 조회 처리에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4154c203e6cd021be2b375052abd91fd364f29f1" translate="yes" xml:space="preserve">
          <source>File paths in the DB is &lt;strong&gt;definitely&lt;/strong&gt; the way to go - I've heard story after story from customers with TB of images that it became a nightmare trying to store any significant amount of images in a DB - the performance hit alone is too much.</source>
          <target state="translated">DB의 파일 경로는 &lt;strong&gt;분명히&lt;/strong&gt; 갈 길입니다-TB 이미지를 가진 고객으로부터 많은 이야기를 들었습니다. DB에 많은 양의 이미지를 저장하려고하는 것은 악몽이되었습니다. 성능만으로는 너무 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="6b58164fc134ce748db8ca4b2d2da4a94bd28c0b" translate="yes" xml:space="preserve">
          <source>File store.  Facebook engineers had a great talk about it.  One take away was to know the practical limit of files in a directory.</source>
          <target state="translated">파일 저장소. 페이스 북 엔지니어들은 그것에 대해 큰 이야기를했습니다. 한 가지 중요한 것은 디렉토리에있는 파일의 실제 한계를 아는 것이 었습니다.</target>
        </trans-unit>
        <trans-unit id="f506183fe93fe32acd9c9e9fa5b2e25dae72a188" translate="yes" xml:space="preserve">
          <source>FileStream solves most of the problems around storing the files in the DB:</source>
          <target state="translated">FileStream은 파일을 DB에 저장하는 것과 관련된 대부분의 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="775382eda387b2f309209bbe52ea023bc8423554" translate="yes" xml:space="preserve">
          <source>For example, your business logic can check if an image file exists on disc before serving it up, retrieving from the database when necessary. This buys you the capability of multiple web servers and fewer sync issues.</source>
          <target state="translated">예를 들어, 비즈니스 로직은 이미지 파일을 제공하기 전에 디스크에 이미지 파일이 있는지 확인하고 필요할 때 데이터베이스에서 검색 할 수 있습니다. 이를 통해 여러 웹 서버의 기능을 사용하고 동기화 문제를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b7110a6687a3b55c76c2091298794787912727c" translate="yes" xml:space="preserve">
          <source>From the MSDN Article:</source>
          <target state="translated">MSDN 기사에서 :</target>
        </trans-unit>
        <trans-unit id="7ec65d66d8967edd541ee0ea7f4da0f56133cc62" translate="yes" xml:space="preserve">
          <source>Given that the images are the actual data being sought after, and that they can be managed easier (the images won't suddenly disappear) in one integrated database rather than having to interface with some kind of filesystem (if the filesystem is independently accessed, the images MIGHT suddenly &quot;disappear&quot;), I'd go for storing them directly as a BLOB or such.</source>
          <target state="translated">이미지가 실제로 검색되는 데이터이고 어떤 종류의 파일 시스템 (파일 시스템에 독립적으로 액세스하는 경우)과 인터페이스하지 않고 하나의 통합 데이터베이스에서 더 쉽게 관리 (이미지가 갑자기 사라지지 않음) 될 수 있다고 가정하면, 이미지가 갑자기 &quot;사라질 수 있습니다&quot;), BLOB 등으로 직접 저장하려고합니다.</target>
        </trans-unit>
        <trans-unit id="50318af368b2cfc31a1990457660c45811f1519a" translate="yes" xml:space="preserve">
          <source>Heavier load on the database server</source>
          <target state="translated">데이터베이스 서버에 더 많은로드</target>
        </trans-unit>
        <trans-unit id="2476f13c8544e6adef83fe4356b9351e0dd56bf9" translate="yes" xml:space="preserve">
          <source>Here's an additional point to keep in mind.  One of the reasons supporting the use of a database to store the blobs is ACID compliance.  However, the approach that the testers used in the white paper, (Bulk Logged option of SQL Server,) which doubled SQL Server throughput, effectively changed the 'D' in ACID to a 'd,' as the blob data was not logged with the initial writes for the transaction.   Therefore, if full ACID compliance is an important requirement for your system, halve the SQL Server throughput figures for database writes when comparing file I/O to database blob I/O.</source>
          <target state="translated">명심해야 할 추가 사항이 있습니다. Blob을 저장하기 위해 데이터베이스 사용을 지원하는 이유 중 하나는 ACID 준수입니다. 그러나 SQL Server 처리량을 두 배로 늘리는 백서 (SQL Server의 대량 로그 옵션)에서 테스터가 사용한 접근 방식은 BLOB 데이터가 기록되지 않았기 때문에 ACID의 'D'를 'd'로 효과적으로 변경했습니다. 트랜잭션의 초기 쓰기 따라서 전체 ACID 준수가 시스템에 중요한 요구 사항 인 경우 파일 I / O를 데이터베이스 Blob I / O와 비교할 때 데이터베이스 쓰기에 대한 SQL Server 처리량 수치를 절반으로 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="3328bee09e8c09e8968eeed0a2f9b66d9200e6cb" translate="yes" xml:space="preserve">
          <source>Here's an interesting white paper on the topic.</source>
          <target state="translated">주제에 대한 흥미로운 백서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="62412dfc10888fe41ebeaad0772496979a681afc" translate="yes" xml:space="preserve">
          <source>Hopefully this isn't too much babble, but I saw the topic and wanted to provide some my insights from a relatively successful small/medium scale application.</source>
          <target state="translated">바라건대이 주제가 너무 많지는 않지만 주제를보고 비교적 성공적인 소규모 / 중규모 응용 프로그램에서 내 통찰력을 제공하고자했습니다.</target>
        </trans-unit>
        <trans-unit id="1262cc4767f7bf18f546e1d6a4826b8fd28f94b6" translate="yes" xml:space="preserve">
          <source>However SQL's &quot;Transparent Data Encryption&quot; does not encrypt FileStream objects, so if that is a consideration, you may be better off just storing them as varbinary.</source>
          <target state="translated">그러나 SQL의 &quot;투명한 데이터 암호화&quot;는 FileStream 객체를 암호화하지 않으므로 고려해야 할 경우이를 varbinary로 저장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5450e7c1ad84e657a64129b1d482f97873657e65" translate="yes" xml:space="preserve">
          <source>I get to use transactions for edits to improve data integrity - I don't have to worry about orphaned and missing files</source>
          <target state="translated">데이터 무결성을 개선하기 위해 편집을 위해 트랜잭션을 사용하게됩니다. 고아 파일이 없거나 누락 된 것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbd2819c808f7d8174170eae9048a48026eae2e0" translate="yes" xml:space="preserve">
          <source>I have recently created a PHP/MySQL app which stores PDFs/Word files in a MySQL table (as big as 40MB per file so far).</source>
          <target state="translated">최근에 PDF / Word 파일을 MySQL 테이블에 저장하는 PHP / MySQL 앱을 만들었습니다 (지금까지 파일 당 최대 40MB).</target>
        </trans-unit>
        <trans-unit id="9d8548824f49d9a78947c14fec692cc06bb03454" translate="yes" xml:space="preserve">
          <source>I once worked on an image processing application. We stored the uploaded images in a directory that was something like /images/[today's date]/[id number]. But we also extracted the metadata (exif data) from the images and stored that in the database, along with a timestamp and such.</source>
          <target state="translated">한 번 이미지 처리 응용 프로그램에서 일했습니다. 업로드 된 이미지를 / images / [오늘 날짜] / [ID 번호]와 같은 디렉토리에 저장했습니다. 그러나 이미지에서 메타 데이터 (exif 데이터)를 추출하여 타임 스탬프 등과 함께 데이터베이스에 저장했습니다.</target>
        </trans-unit>
        <trans-unit id="1a2a80f9309a684b0d97bad75e984f23663555da" translate="yes" xml:space="preserve">
          <source>I'd call my implementation a success, it takes care of backup requirements and simplifies the layout of the project. The performance is fine for the 20-30 people who use the app.</source>
          <target state="translated">구현을 성공이라고 부르고 백업 요구 사항을 처리하고 프로젝트 레이아웃을 단순화합니다. 앱을 사용하는 20-30 명의 사용자에게는 성능이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="29fa93b28f6e28a031496c25f93f96335b65852e" translate="yes" xml:space="preserve">
          <source>I'm in charge of some applications that manage many TB of images.  We've found that storing &lt;strong&gt;file paths&lt;/strong&gt; in the database to be best.</source>
          <target state="translated">많은 TB 이미지를 관리하는 일부 응용 프로그램을 담당하고 있습니다. 데이터베이스에 &lt;strong&gt;파일 경로&lt;/strong&gt; 를 저장하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2fecdc2255f2695e73f6dba95fc3e73d0bcd8d78" translate="yes" xml:space="preserve">
          <source>I'm not sure how much of a &quot;real world&quot; example this is, but I currently have an application out there that stores details for a trading card game, including the images for the cards. Granted the record count for the database is only 2851 records to date, but given the fact that certain cards have are released multiple times and have alternate artwork, it was actually more efficient sizewise to scan the &quot;primary square&quot; of the artwork and then dynamically generate the border and miscellaneous effects for the card when requested.</source>
          <target state="translated">나는 이것이 &quot;실제 세계&quot;의 예가 어느 정도인지 잘 모르겠지만, 현재 카드 이미지를 포함하여 트레이딩 카드 게임에 대한 세부 정보를 저장하는 응용 프로그램이 있습니다. 데이터베이스의 레코드 수는 현재까지 2851 개 레코드이지만, 특정 카드가 여러 번 릴리스되고 대체 아트 워크가 있다는 사실을 고려하면 아트 워크의 &quot;1 차 사각형&quot;을 스캔 한 다음 동적으로 크기를 효율적으로 계산할 수있었습니다. 요청시 카드에 대한 테두리 및 기타 효과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d25f4f7e4e4f9284bbb7f7af179d8762a4fab0e8" translate="yes" xml:space="preserve">
          <source>I'm surprised no one has really mentioned this ... delegate it out to others who are specialists -&amp;gt; &lt;strong&gt;use a 3rd party image/file hosting provider&lt;/strong&gt;.</source>
          <target state="translated">아무도 이것을 실제로 언급하지 않은 것에 놀랐습니다 ... 전문가 인 다른 사람들에게 위임하십시오-&amp;gt; &lt;strong&gt;타사 이미지 / 파일 호스팅 공급자를 사용하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb19e735abac3d85de5cc543122acd3955a7a44" translate="yes" xml:space="preserve">
          <source>IMO, Pros of using database to store images are,</source>
          <target state="translated">IMO, 데이터베이스를 사용하여 이미지를 저장하는 전문가는</target>
        </trans-unit>
        <trans-unit id="67789d0ecde7d5223b48e5c0fd30688658e8dad1" translate="yes" xml:space="preserve">
          <source>If the actual image pointed to by the filepath becomes unavailable, the database unwittingly has an integrity error.</source>
          <target state="translated">파일 경로가 가리키는 실제 이미지를 사용할 수 없게되면 데이터베이스에 무심코 무결성 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="503989532211253730df23717fe63bd466c6f952" translate="yes" xml:space="preserve">
          <source>If this is web-based application then there could be advantages to storing the images on a third-party storage delivery network, such as Amazon's S3 or the Nirvanix platform.</source>
          <target state="translated">이것이 웹 기반 애플리케이션 인 경우, Amazon S3 또는 Nirvanix 플랫폼과 같은 타사 스토리지 전송 네트워크에 이미지를 저장하면 이점이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3797548f46dc91bf7279b13b078981dc7232924" translate="yes" xml:space="preserve">
          <source>If you have your images in a file-system and someone is reading the file as you're writing a new version or even deleting the file - what happens?</source>
          <target state="translated">파일 시스템에 이미지가 있고 새 버전을 작성하거나 파일을 삭제할 때 누군가 파일을 읽고있는 경우 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="bbcc47c06384c94a6e71cd3ed29e7578f9b54e84" translate="yes" xml:space="preserve">
          <source>If you're not on SQL Server 2008 and you have some solid reasons for putting specific image files in the database, then you could take the &quot;both&quot; approach and use the file system as a temporary cache and use the database as the master repository.</source>
          <target state="translated">SQL Server 2008을 사용하지 않고 특정 이미지 파일을 데이터베이스에 배치해야하는 확실한 이유가있는 경우 &quot;두 가지&quot;방식을 모두 사용하여 파일 시스템을 임시 캐시로 사용하고 데이터베이스를 마스터 리포지토리로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="104f4bfbbe4ba01a18a339e2ce0dee05761e7192" translate="yes" xml:space="preserve">
          <source>If you're on an older database, then I'd say that if you're storing it as blob data, then you're really not going to get anything out of the database in the way of searching features, so it's probably best to store an address on a filesystem, and store the image that way.</source>
          <target state="translated">오래된 데이터베이스를 사용하는 경우 BLOB 데이터로 저장하면 기능을 검색하는 방식으로 데이터베이스에서 아무것도 얻지 못할 것이므로 아마도 가장 좋습니다. 파일 시스템에 주소를 저장하고 이미지를 그런 식으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d3db3c02ef9c8ebaf43fb00a808ca6373d64cf93" translate="yes" xml:space="preserve">
          <source>If your images are going to be small (say &amp;lt; 64k) and the storage engine of your db supports inline (in record) BLOBs, it improves performance further as no indirection is required (Locality of reference is achieved).</source>
          <target state="translated">이미지가 작을 경우 (예 : &amp;lt;64k) db의 스토리지 엔진이 인라인 (레코드) BLOB를 지원하는 경우 간접적 인 참조가 필요하지 않으므로 성능이 더 향상됩니다 (참조 지역화).</target>
        </trans-unit>
        <trans-unit id="1367543dc2e57b8ae191b7f517c89168e8563b8d" translate="yes" xml:space="preserve">
          <source>Im my experience I had to manage both situations: images stored in database and images on the file system with path stored in db.</source>
          <target state="translated">내 경험상 나는 데이터베이스에 저장된 이미지와 db에 저장된 경로가있는 파일 시스템의 이미지를 모두 관리해야했습니다.</target>
        </trans-unit>
        <trans-unit id="9403681db30c32ac40b3bcb94b6983848198b3a1" translate="yes" xml:space="preserve">
          <source>Images stored in the database do not require a different backup strategy. Images stored on filesystem do</source>
          <target state="translated">데이터베이스에 저장된 이미지에는 다른 백업 전략이 필요하지 않습니다. 파일 시스템에 저장된 이미지는</target>
        </trans-unit>
        <trans-unit id="d798c2480179e1f2ec28ad71a0ad5dd2ca9635ca" translate="yes" xml:space="preserve">
          <source>In a previous project i stored images on the filesystem, and that caused a lot of headaches with backups, replication, and the filesystem getting out of sync with the database.</source>
          <target state="translated">이전 프로젝트에서 파일 시스템에 이미지를 저장했는데 백업, 복제 및 파일 시스템이 데이터베이스와 동기화되지 않아 많은 골치 거리가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="09863ac503085043491d30bf4f9111c47daca621" translate="yes" xml:space="preserve">
          <source>In my experience, sometimes the simplest solution is to &lt;strong&gt;name the images according to the primary key&lt;/strong&gt;. So it's easy to find the image that belongs to a particular record, and vice versa. But at the same time you're not storing &lt;em&gt;anything&lt;/em&gt; about the image in the database.</source>
          <target state="translated">내 경험상 때로는 가장 간단한 해결책은 &lt;strong&gt;기본 키에 따라 이미지 이름&lt;/strong&gt; 을 &lt;strong&gt;지정하는 것&lt;/strong&gt; 입니다. 따라서 특정 레코드에 속하는 이미지를 쉽게 찾을 수 있으며 그 반대도 마찬가지입니다. 그러나 동시에 데이터베이스의 이미지에 대해서는 &lt;em&gt;아무것도&lt;/em&gt; 저장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f531513cb377ad06aa76b61e2ea34b52b9a15fdd" translate="yes" xml:space="preserve">
          <source>In my latest project i'm storing images in the database, and caching them on the filesystem, and it works really well. I've had no problems so far.</source>
          <target state="translated">내 최신 프로젝트에서 데이터베이스에 이미지를 저장하고 파일 시스템에 이미지를 캐싱하고 실제로 잘 작동합니다. 지금까지 아무런 문제가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="09691af22dcb0a5e64c5ef4a1a4629569c883e0c" translate="yes" xml:space="preserve">
          <source>In places where you MUST guarantee referential integrity and ACID compliance, storing images in the database is required.</source>
          <target state="translated">참조 무결성 및 ACID 준수를 보장해야하는 장소에서는 데이터베이스에 이미지를 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea18a136284e24daa6223fb84ba253dcbfbee5f6" translate="yes" xml:space="preserve">
          <source>It depends on the number of images you are going to store and also their sizes. I have used databases to store images in the past and my experience has been fairly good.</source>
          <target state="translated">저장하려는 이미지 수와 크기에 따라 다릅니다. 과거에 데이터베이스를 사용하여 이미지를 저장했으며 내 경험이 상당히 좋았습니다.</target>
        </trans-unit>
        <trans-unit id="9283765c13db752b531235978b65c8824a43fa27" translate="yes" xml:space="preserve">
          <source>It is easier to control access to the images if they are in a database. Idle admins can access any folder on disk. It takes a really determined admin to go snooping in a database to extract the images</source>
          <target state="translated">이미지가 데이터베이스에있는 경우 이미지에 대한 액세스를 제어하기가 더 쉽습니다. 유휴 관리자는 디스크의 모든 폴더에 액세스 할 수 있습니다. 이미지를 추출하기 위해 데이터베이스에서 스누핑을 수행하려면 실제로 결정된 관리자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="86a122c21eed2b290e44b53668135ef815601820" translate="yes" xml:space="preserve">
          <source>It's so worth it. They store it efficiently. No bandwith getting uploaded from your servers to client requests, etc.</source>
          <target state="translated">그만한 가치가 있습니다. 그들은 그것을 효율적으로 저장합니다. 서버에서 클라이언트 요청 등에 업로드되는 대역폭이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1251f454e24d7233f5c1fa0583852723b715eb7" translate="yes" xml:space="preserve">
          <source>Latency may be
    slower than direct file access</source>
          <target state="translated">대기 시간은 파일 직접 액세스보다 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="725eb7fb053ccc585c879ae0da4b122f6a9f14bc" translate="yes" xml:space="preserve">
          <source>Like most other things, It depends on the expected size and Budget.</source>
          <target state="translated">다른 것들과 마찬가지로 예상 크기와 예산에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8545dec1f4c27acaa5353a4c97f59593c52fe97e" translate="yes" xml:space="preserve">
          <source>Manage it like a regular table and have the performance of the file system.</source>
          <target state="translated">일반 테이블처럼 관리하고 파일 시스템의 성능을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f658bc08163a361b68ecdcd9080d547dfa019aed" translate="yes" xml:space="preserve">
          <source>Migration &quot;just works&quot;.</source>
          <target state="translated">마이그레이션은 &quot;그냥 작동합니다&quot;.</target>
        </trans-unit>
        <trans-unit id="6968d452a081adacc8b53c63e98bbe9c46f66820" translate="yes" xml:space="preserve">
          <source>Moso Cloud Storage</source>
          <target state="translated">모소 클라우드 스토리지</target>
        </trans-unit>
        <trans-unit id="8351a5f7f60b713223687b5b9fb0f91f10e65233" translate="yes" xml:space="preserve">
          <source>Needle in a Haystack: Efficient Storage of Billions of Photos</source>
          <target state="translated">건초 더미의 바늘 : 수십억 장의 사진을 효율적으로 저장</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="f06cb0fe589979c389e198338ded5e8a7b144557" translate="yes" xml:space="preserve">
          <source>Normally, I'm storngly against taking the most expensive and hardest to scale part of your infrastructure (the database) and putting all load into it. On the other hand: It greatly simplifies backup strategy, especially when you have multiple web servers and need to somehow keep the data synchronized.</source>
          <target state="translated">일반적으로 인프라 (데이터베이스)의 일부를 확장하기 위해 가장 비싸고 가장 어려운 작업을 수행하고 모든로드를 처리하는 것에 대해 엄청나게 반대합니다. 반면에 : 특히 여러 웹 서버가 있고 데이터 동기화를 유지해야하는 경우 백업 전략을 크게 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="09f177c20b3e429783e2b3893764c0d0da902bd2" translate="yes" xml:space="preserve">
          <source>Obviously database access performance when you deal with binary large objects is degrading, and the database dimensions will grow a lot, causing again performance loss... and normally database space is much more expensive than file system space.</source>
          <target state="translated">이진 대형 개체를 처리 할 때 데이터베이스 액세스 성능이 저하되고 데이터베이스 크기가 커져서 성능 손실이 다시 발생합니다. 일반적으로 데이터베이스 공간은 파일 시스템 공간보다 훨씬 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="9287d0bca2c5656d1b260627af121123dac33b33" translate="yes" xml:space="preserve">
          <source>On the other hand having large binary objects stored in file system will cause you to have backup plans that have to consider both database and file system, and this can be an issue for some systems.</source>
          <target state="translated">반면에 파일 시스템에 큰 이진 객체를 저장하면 데이터베이스와 파일 시스템을 모두 고려해야하는 백업 계획이 생길 수 있으며 이는 일부 시스템에서 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e750b8bf3af0d850d7b1c3e5f654ec6d86914f3b" translate="yes" xml:space="preserve">
          <source>On the other hand there are problems associated</source>
          <target state="translated">반면에 관련된 문제가 있습니다</target>
        </trans-unit>
        <trans-unit id="69d4c2a1a3cd8e2dc76d590ad7bcca2c66fa2e3a" translate="yes" xml:space="preserve">
          <source>Once common solution to this is to hash them out into a balanced tree of subdirectories.</source>
          <target state="translated">이것에 대한 일반적인 해결책은 그것들을 균형 잡힌 하위 디렉토리로 해시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dffe608d3ed114e8a78297264f0fe42a01be2bdc" translate="yes" xml:space="preserve">
          <source>One thing that I haven't seen anyone mention yet but is definitely worth noting is that there are issues associated with storing large amounts of images in most filesystems too.  For example if you take the approach mentioned above and name each image file after the primary key, on most filesystems you will run into issues if you try to put all of the images in one big directory once you reach a very large number of images (e.g. in the hundreds of thousands or millions).</source>
          <target state="translated">아직 아무도 언급하지 않았지만 주목할 가치가있는 한 가지는 대부분의 파일 시스템에 많은 양의 이미지를 저장하는 것과 관련된 문제가 있다는 것입니다. 예를 들어 위에서 언급 한 접근 방식을 취하고 기본 키 다음에 각 이미지 파일의 이름을 지정하는 경우 대부분의 파일 시스템에서 매우 많은 수의 이미지에 도달하면 모든 이미지를 하나의 큰 디렉토리에 넣으려고하면 문제가 발생합니다 ( 예를 들어 수십만 또는 수백만에서).</target>
        </trans-unit>
        <trans-unit id="d9a64c001c7d6c4d98225996f8dd95ddc6b72319" translate="yes" xml:space="preserve">
          <source>One thing to note here is that no one in the pro file system camp has listed a particular file system. Does this mean that everything from FAT16 to ZFS handily beats every database?</source>
          <target state="translated">여기서 주목해야 할 것은 프로 파일 시스템 캠프에 아무도 특정 파일 시스템을 나열하지 않았다는 것입니다. 이것은 FAT16에서 ZFS에 이르는 모든 것이 모든 데이터베이스를 능가한다는 것을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="daca8adfb2ce1f5899bcf3cc5dc33091198be70b" translate="yes" xml:space="preserve">
          <source>Overall not very memory/cpu efficient when compared to filesystem</source>
          <target state="translated">파일 시스템과 비교할 때 전반적으로 메모리 / CPU 효율성이 떨어짐</target>
        </trans-unit>
        <trans-unit id="dc155c121b565754897ed082c978712827881b44" translate="yes" xml:space="preserve">
          <source>Probably, it would also allow you to throw some caching element, based on commonly hit image urls into your web engine/program, so you're saving yourself there as well.</source>
          <target state="translated">아마도 일반적으로 인기있는 이미지 URL을 기반으로 일부 캐싱 요소를 웹 엔진 / 프로그램에 넣을 수 있으므로 자신도 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54b393721169f11c627d23e95f4e0bce01dc79eb" translate="yes" xml:space="preserve">
          <source>Require additional code to extract
and stream the images</source>
          <target state="translated">이미지를 추출하고 스트리밍하려면 추가 코드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bdd88b7d31c47d46b3476e67aa360525526c3160" translate="yes" xml:space="preserve">
          <source>SQL Server 2008 offers a solution that has the best of both worlds : &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;The filestream data type&lt;/a&gt;.</source>
          <target state="translated">SQL Server 2008은 두 가지 장점을 모두 갖춘 솔루션을 제공합니다. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;파일 스트림 데이터 형식&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec236495b04b446b59d809893ff3e4466ca3fd51" translate="yes" xml:space="preserve">
          <source>Second the recommendation on file paths. I've worked on a couple of projects that needed to manage large-ish asset collections, and any attempts to store things directly in the DB resulted in pain and frustration long-term.</source>
          <target state="translated">둘째, 파일 경로에 대한 권장 사항입니다. 대규모 자산 수집을 관리하는 데 필요한 몇 가지 프로젝트를 수행했으며 DB에 직접 저장하려고 시도하면 장기적으로 고통과 좌절이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="7ecb8d1b499802e07c066d2d9c3ceee7493e96ab" translate="yes" xml:space="preserve">
          <source>Serving up images from a database is easy, just implement an http handler that serves the byte array returned from the DB server as a binary stream.</source>
          <target state="translated">데이터베이스에서 이미지를 제공하는 것은 쉽습니다. DB 서버에서 반환 된 바이트 배열을 이진 스트림으로 제공하는 http 핸들러를 구현하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="99962b21785a235b5e93d806ae6c3d7e37e621ce" translate="yes" xml:space="preserve">
          <source>Setting up the web server is slightly simpler because I don't need to have an uploads/ folder and tell all my applications where it is.</source>
          <target state="translated">업로드 / 폴더가 없어도 모든 응용 프로그램의 위치를 ​​알 필요가 없기 때문에 웹 서버 설정이 약간 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="e9b806b728121ce126b464af0bd80ee2afdf68c9" translate="yes" xml:space="preserve">
          <source>Small static images (not more than a couple of megs) that are not frequently edited, should be stored in the database. This method has several benefits including easier portability (images are transferred with the database), easier backup/restore (images are backed up with the database) and better scalability (a file system folder with thousands of little thumbnail files sounds like a scalability nightmare to me).</source>
          <target state="translated">자주 편집되지 않는 작은 정적 이미지 (2 메가 이하)는 데이터베이스에 저장해야합니다. 이 방법에는 이식성 (이미지가 데이터베이스와 함께 전송 됨), 백업 / 복원 (이미지가 데이터베이스와 함께 백업 됨), 확장 성 (수천 개의 작은 썸네일 파일이있는 파일 시스템 폴더가 확장 성 악몽처럼 들리는)을 포함하여 몇 가지 이점이 있습니다. 나를).</target>
        </trans-unit>
        <trans-unit id="c77302484315f43d1b8825352fad38163e655d07" translate="yes" xml:space="preserve">
          <source>Smaller sized files can be efficiently stored and delivered using the database as the storage mechanism.  Larger files would probably be best stored using the file system, especially if they will be modified/updated often.  (blob fragmentation becomes an issue in regards to performance.)</source>
          <target state="translated">데이터베이스를 스토리지 메커니즘으로 사용하여 더 작은 크기의 파일을 효율적으로 저장하고 전달할 수 있습니다. 더 큰 파일은 파일 시스템을 사용하여 저장하는 것이 좋으며, 특히 자주 수정 / 업데이트되는 경우 더욱 그렇습니다. (블로 브 조각화는 성능과 관련하여 문제가됩니다.)</target>
        </trans-unit>
        <trans-unit id="714b035f21ed87fb37883666dfce0caea714ccc8" translate="yes" xml:space="preserve">
          <source>So I'm using an app that stores images heavily in the DB. What's your outlook on this? I'm more of a type to store the location in the filesystem, than store it directly in the DB.</source>
          <target state="translated">그래서 DB에 이미지를 많이 저장하는 앱을 사용하고 있습니다. 이것에 대한 당신의 전망은 무엇입니까? 위치를 DB에 직접 저장하는 것보다 파일 시스템에 위치를 저장하는 유형에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="6dccf67eb0ddd77e8bfbc72fb16de2a45d5b6cae" translate="yes" xml:space="preserve">
          <source>Something nobody has mentioned is that the DB guarantees atomic actions, transactional integrity and deals with concurrency. Even referentially integrity is out of the window with a filesystem - so how do you know your file names are really still correct?</source>
          <target state="translated">아무도 언급하지 않은 것은 DB가 원자 적 행동, 트랜잭션 무결성을 보장하고 동시성을 처리한다는 것입니다. 참조 적으로도 무결성은 파일 시스템과는 다릅니다. 파일 이름이 여전히 올바른지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8af055bdbe7670239d44aa860e0890dd569e962b" translate="yes" xml:space="preserve">
          <source>Store your files on a paid online service like</source>
          <target state="translated">유료 온라인 서비스에 파일을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="1a3781484823414d3725393bd2bf249b5bee6d6c" translate="yes" xml:space="preserve">
          <source>Storing Images in DB - Yea or Nay</source>
          <target state="translated">DB에 이미지 저장-Yea 또는 Nay</target>
        </trans-unit>
        <trans-unit id="d5edc6aeda738e7a8d9506f8a9a0366272625476" translate="yes" xml:space="preserve">
          <source>Storing an image in the database still means that the image data ends up somewhere in the file system but obscured so that you cannot access it directly.</source>
          <target state="translated">데이터베이스에 이미지를 저장한다는 것은 이미지 데이터가 파일 시스템 어딘가에 있지만 가려져서 직접 액세스 할 수 없도록하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="83e9a8f9902db2ab45aab8a68857232f91f8f817" translate="yes" xml:space="preserve">
          <source>Storing images may be a bad idea when you are dealing with small number of huge sized images. Another problem with storing images in db is that, metadata like creation, modification dates must handled by your application.</source>
          <target state="translated">적은 수의 거대한 크기의 이미지를 처리 ​​할 때는 이미지 저장이 좋지 않을 수 있습니다. 이미지를 db에 저장하는 데 따른 또 다른 문제는 생성, 수정 날짜와 같은 메타 데이터가 응용 프로그램에서 처리되어야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc7ebe3f5c8fa7bb3211919a811fe054ebec3fde" translate="yes" xml:space="preserve">
          <source>That seems like it would be better solved with an intermediary script pulling data from a web-inaccessible file store, though. So the DB storage isn't REALLY necessary.</source>
          <target state="translated">그래도 웹 액세스 할 수없는 파일 저장소에서 데이터를 가져 오는 중개 스크립트로 더 잘 해결되는 것처럼 보입니다. 따라서 DB 스토리지가 꼭 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e507594d631333c78e791861af1df08eda58c6dd" translate="yes" xml:space="preserve">
          <source>That way you also save space on your filesystem, as you are only going to save the exact amount of space, or even compacted space on the filesystem.</source>
          <target state="translated">이렇게하면 파일 시스템의 공간 또는 압축 된 공간 만 절약하므로 파일 시스템의 공간도 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa8930f1feae478f1bcc7944864a710d55955741" translate="yes" xml:space="preserve">
          <source>The Blobs are actually stored as files in a folder.</source>
          <target state="translated">Blob은 실제로 폴더에 파일로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="dac8ad2eb459eb9d8f5d901be3595fff1497aa53" translate="yes" xml:space="preserve">
          <source>The Blobs can be accessed using &lt;em&gt;either&lt;/em&gt; a database connection &lt;em&gt;or&lt;/em&gt; over the filesystem.</source>
          <target state="translated">Blob은 데이터베이스 연결 &lt;em&gt;또는&lt;/em&gt; 파일 시스템을 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26f263ae32cfbdb323507d0b4a4dbcc181aa7185" translate="yes" xml:space="preserve">
          <source>The answer is &quot;It depends.&quot;  Certainly it would depend upon the database server and its approach to blob storage.  It also depends on the type of data being stored in blobs, as well as how that data is to be accessed.</source>
          <target state="translated">대답은 &quot;그것은 달려있다&quot;입니다. 확실히 그것은 데이터베이스 서버와 Blob Storage에 대한 접근 방식에 달려 있습니다. 또한 Blob에 저장되는 데이터 유형과 해당 데이터에 액세스하는 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="398e9d6490298e990e2ac82498c6a4997352591a" translate="yes" xml:space="preserve">
          <source>The correct course of action is to make the right decision for your precise scenario, and to do that, you'll need some numbers and some use case estimates.</source>
          <target state="translated">올바른 행동 과정은 정확한 시나리오에 대한 올바른 결정을 내리는 것이며,이를 위해서는 몇 가지 숫자와 유스 케이스 추정치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a3ff707b3146ba5858644a13add5404689ca1dac" translate="yes" xml:space="preserve">
          <source>The first solution, images in database, is somewhat &quot;cleaner&quot; as your data access layer will have to deal only with database objects; but this is good only when you have to deal with low numbers.</source>
          <target state="translated">데이터베이스의 이미지 인 첫 번째 솔루션은 데이터 액세스 계층이 데이터베이스 개체 만 처리해야하기 때문에 다소 &quot;깨끗합니다&quot;. 그러나 이것은 낮은 숫자를 처리해야 할 때만 좋습니다.</target>
        </trans-unit>
        <trans-unit id="99b1b7fb03c27b12dd7a97fbe5cba9dedbf6f7d3" translate="yes" xml:space="preserve">
          <source>The government wants you to maintain 6 years of history</source>
          <target state="translated">정부는 당신이 6 년의 역사를 유지하기를 원합니다</target>
        </trans-unit>
        <trans-unit id="be8c1d64425fb81ddff96737d2195647616aeedb" translate="yes" xml:space="preserve">
          <source>The only real &quot;pro&quot; I can think of regarding storing them in the DB is the potential for easy of individual image assets. If there are no file paths to use, and all images are streamed straight out of the DB, there's no danger of a user finding files they shouldn't have access to.</source>
          <target state="translated">DB에 저장하는 것과 관련하여 내가 생각할 수있는 유일한 &quot;프로&quot;는 개별 이미지 자산을 쉽게 만들 수있는 가능성입니다. 사용할 파일 경로가없고 모든 이미지가 DB에서 바로 스트리밍되는 경우 사용자가 액세스 할 수없는 파일을 찾을 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6df983ec2f8655d79d2d357cb2d842ac9c202c5" translate="yes" xml:space="preserve">
          <source>The original creator of this image library created a data access class that renders the image based on the request, and it does it quite fast for viewing and individual card.</source>
          <target state="translated">이 이미지 라이브러리의 최초 제작자는 요청에 따라 이미지를 렌더링하는 데이터 액세스 클래스를 만들었으며보기 및 개별 카드에 매우 빠르게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="21e9b5d795f89df6924b68d2e63f969592671fda" translate="yes" xml:space="preserve">
          <source>The problem with storing only filepaths to images in a database is that the database's integrity can no longer be forced.</source>
          <target state="translated">데이터베이스의 이미지에 대한 파일 경로 만 저장하는 문제는 데이터베이스의 무결성을 더 이상 강요 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f33c90f1fc426daa04efefb0038c1e8f22a9e375" translate="yes" xml:space="preserve">
          <source>The trick here is to not become a zealot.</source>
          <target state="translated">여기서 속임수는 열성적이지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8f59a378f87933d06e892653ff4a82c884cf319" translate="yes" xml:space="preserve">
          <source>The truth is that many databases beat many files systems, even when we're only talking about raw speed.</source>
          <target state="translated">진실은 우리가 원시 속도에 대해서만 이야기 할 때조차도 많은 데이터베이스가 많은 파일 시스템을 능가한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c2d423a32b108506f0bfd6455f1f96019a07f538" translate="yes" xml:space="preserve">
          <source>The word on the street is that unless you are a database vendor trying to prove that your database can do it (like, let's say Microsoft boasting about Terraserver storing a bajillion images in SQL Server) it's not a very good idea. When the alternative - storing images on file servers and paths in the database is so much easier, why bother? Blob fields are kind of like the off-road capabilities of SUVs - most people don't use them, those who do usually get in trouble, and then there are those who do, but only for the fun of it.</source>
          <target state="translated">길거리의 말은 당신이 당신의 데이터베이스가 그것을 할 수 있다는 것을 증명하려고 노력하는 데이터베이스 벤더가 아니라면 (예를 들어, Microsoft가 SQL Server에 bajillion 이미지를 저장하는 Terraserver에 대해 자랑한다고 가정 해 보자) 그것은 좋은 생각이 아니라는 것입니다. 대안-데이터베이스의 파일 서버 및 경로에 이미지를 저장하는 것이 훨씬 쉬운 경우 왜 귀찮습니까? Blob 필드는 SUV의 오프로드 기능과 비슷합니다. 대부분의 사람들은 SUV를 사용하지 않으며, 보통 문제가있는 사람들은 사용하지만 재미는 있습니다.</target>
        </trans-unit>
        <trans-unit id="36730b9cc2f305e81fe3cdc4abe7056400f5a97f" translate="yes" xml:space="preserve">
          <source>There are a couple of issues:</source>
          <target state="translated">몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29edf34e1917d1906a7773ea48427778e05cd8a" translate="yes" xml:space="preserve">
          <source>This also eases deployment/updates when new cards are released, instead of zipping up an entire folder of images and sending those down the pipe and ensuring the proper folder structure is created, I simply update the database and have the user download it again. This currently sizes up to 56MB, which isn't great, but I'm working on an incremental update feature for future releases. In addition, there is a &quot;no images&quot; version of the application that allows those over dial-up to get the application without the download delay.</source>
          <target state="translated">이것은 또한 새로운 카드가 출시 될 때 배포 / 업데이트를 용이하게합니다. 이미지의 전체 폴더를 압축하여 파이프로 전송하고 적절한 폴더 구조가 생성되도록하는 대신 데이터베이스를 업데이트하고 사용자가 다시 다운로드하도록합니다. 현재 최대 56MB 크기는 좋지 않지만 향후 릴리스의 증분 업데이트 기능을 개발 중입니다. 또한 전화 접속 사용자가 다운로드 지연없이 응용 프로그램을 가져올 수 있도록하는 &quot;이미지 없음&quot;버전의 응용 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2559b6884c2c3166252cf8317c08d9d7192227f" translate="yes" xml:space="preserve">
          <source>This might be a bit of a long shot, but if you're using (or planning on using) SQL Server 2008 I'd recommend having a look at the new &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;FileStream&lt;/a&gt; data type.</source>
          <target state="translated">약간 긴 시간이 걸릴 수 있지만 SQL Server 2008을 사용하거나 사용하려는 경우 새로운 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;FileStream&lt;/a&gt; 데이터 형식을 살펴 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5de5ed2ad95580ae9860ae51bb53fb858569f0c9" translate="yes" xml:space="preserve">
          <source>This solution has worked great to date since the application itself is targeted as a single instance on the desktop. There is a web site where all of this data is archived for online access, but I would in no way use the same solution for this. I agree the file access would be preferable because it would scale better to the frequency and volume of requests being made for the images.</source>
          <target state="translated">이 솔루션은 응용 프로그램 자체가 데스크톱에서 단일 인스턴스를 대상으로하기 때문에 현재까지 효과적이었습니다. 이 모든 데이터가 온라인 액세스를 위해 보관되는 웹 사이트가 있지만이 방법으로 동일한 솔루션을 사용하지는 않습니다. 파일 액세스는 이미지에 대한 요청 빈도 및 볼륨에 따라 더 잘 확장되므로 파일 액세스가 바람직하다는 데 동의합니다.</target>
        </trans-unit>
        <trans-unit id="7a9f42b006e68507b2bf93c3dc35393a93370b8e" translate="yes" xml:space="preserve">
          <source>To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem</source>
          <target state="translated">BLOB로 또는 BLOB으로 : 데이터베이스 또는 파일 시스템의 대형 객체 저장소</target>
        </trans-unit>
        <trans-unit id="115c5ce402f46dd63900f8651dbc2e3d209abf85" translate="yes" xml:space="preserve">
          <source>Transact-SQL statements can insert, update, query, search, and back up FILESTREAM data. Win32 file system interfaces provide streaming access to the data.</source>
          <target state="translated">Transact-SQL 문은 FILESTREAM 데이터를 삽입, 업데이트, 쿼리, 검색 및 백업 할 수 있습니다. Win32 파일 시스템 인터페이스는 데이터에 대한 스트리밍 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c939e193a50e38ae5295ae364bae62a85fc25476" translate="yes" xml:space="preserve">
          <source>Uploaded files are replicated to backup server along with everything else, no separate backup strategy is needed (peace of mind).</source>
          <target state="translated">업로드 된 파일은 다른 모든 것들과 함께 백업 서버에 복제되므로 별도의 백업 전략이 필요하지 않습니다 (안심).</target>
        </trans-unit>
        <trans-unit id="8fb23687e4739bac5fa4b49b3b6e933f9284f922" translate="yes" xml:space="preserve">
          <source>We have implemented a document imaging system that stores all it's images in SQL2005 blob fields.  There are several hundred GB at the moment and we are seeing excellent response times and little or no performance degradation. In addition, fr regulatory compliance, we have a middleware layer that archives newly posted documents to an optical jukebox system which exposes them as a standard NTFS file system.</source>
          <target state="translated">모든 이미지를 SQL2005 BLOB 필드에 저장하는 문서 이미징 시스템을 구현했습니다. 현재 수백 GB가 있으며 우수한 응답 시간과 성능 저하가 거의 또는 전혀 없습니다. 또한 규정 준수를 위해 새로 게시 된 문서를 광학 주크 박스 시스템에 보관하여 표준 NTFS 파일 시스템으로 공개하는 미들웨어 계층을 갖추고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdbbc258fb96a990b2231e7642581c54c943bfea" translate="yes" xml:space="preserve">
          <source>We use blobs because they're easier to manage (backup, replication, transfer) too. They work well for us.</source>
          <target state="translated">Blob도 관리 (백업, 복제, 전송)가 더 쉽기 때문에 사용합니다. 그들은 우리를 위해 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="92bec75ea6ee7bd3cc26a274361ce400ab17e448" translate="yes" xml:space="preserve">
          <source>We've been very pleased with the results, particularly with respect to:</source>
          <target state="translated">우리는 특히 다음과 관련하여 결과에 매우 만족했습니다.</target>
        </trans-unit>
        <trans-unit id="7ef90e6354471827cade517de2c173b8991b7175" translate="yes" xml:space="preserve">
          <source>What do you think are the pros/cons?</source>
          <target state="translated">장단점은 무엇이라고 생각하십니까?</target>
        </trans-unit>
        <trans-unit id="87de9781c77b14deca711032ac785da434dcb2f0" translate="yes" xml:space="preserve">
          <source>You are storing images that are
changing dynamically, say invoices and you wanted
to get an invoice as it was on 1 Jan
2007?</source>
          <target state="translated">인보이스와 같이 동적으로 변경되는 이미지를 저장하고 있고 2007 년 1 월 1 일과 같이 인보이스를 받으려고하십니까?</target>
        </trans-unit>
        <trans-unit id="95453050e6c680a8686d784628d69b7341319e48" translate="yes" xml:space="preserve">
          <source>You cannot transactionaly guarantee that the image and the meta-data about that image stored in the database refer to the same file. In other words, it is impossible to guarantee that the file on the filesystem is only ever altered at the same time and in the same transaction as the metadata.</source>
          <target state="translated">데이터베이스에 저장된 해당 이미지의 이미지와 메타 데이터가 동일한 파일을 참조한다는 것을 트랜잭션 분석적으로 보증 할 수 없습니다. 다시 말해, 파일 시스템의 파일이 메타 데이터와 동일한 트랜잭션에서 동시에 변경되는 것을 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="44ac3e04ec087585e18c01c02894782e6ec3abfb" translate="yes" xml:space="preserve">
          <source>database integrity</source>
          <target state="translated">데이터베이스 무결성</target>
        </trans-unit>
        <trans-unit id="4b227f33a30575522e0591fdc96075df02b8e35c" translate="yes" xml:space="preserve">
          <source>database storage is usually more expensive than file system storage</source>
          <target state="translated">데이터베이스 스토리지는 일반적으로 파일 시스템 스토리지보다 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="ddbdd288dca0200556d991307329fa940b415ca3" translate="yes" xml:space="preserve">
          <source>databases win out where transactional integrity between the image and metadata are important.</source>
          <target state="translated">데이터베이스는 이미지와 메타 데이터 간의 트랜잭션 무결성이 중요한 곳에서 승리합니다.</target>
        </trans-unit>
        <trans-unit id="7bb6a86f7fb04a200fe53244cac70f7908c2d1b9" translate="yes" xml:space="preserve">
          <source>for example, many web servers use the operating system's &lt;strong&gt;sendfile()&lt;/strong&gt; system call to asynchronously send a file directly from the file system to the network interface. Images stored in a database don't benefit from this optimization.</source>
          <target state="translated">예를 들어, 많은 웹 서버는 운영 체제의 &lt;strong&gt;sendfile ()&lt;/strong&gt; 시스템 호출을 사용하여 파일을 파일 시스템에서 네트워크 인터페이스로 비동기식으로 직접 보냅니다. 데이터베이스에 저장된 이미지는이 최적화의 이점을 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="f66131dba234d08d3eccc828f035e8d23ef4236f" translate="yes" xml:space="preserve">
          <source>it is difficult (within the context of a web application) to guarantee data has been flushed to disk on the filesystem</source>
          <target state="translated">데이터가 파일 시스템의 디스크로 플러시되는 것을 보장하는 것은 (웹 응용 프로그램의 컨텍스트 내에서) 어렵다</target>
        </trans-unit>
        <trans-unit id="539156605d769e1ec2dfda3fa9f1f2a30afd98dd" translate="yes" xml:space="preserve">
          <source>it is more complex to manage integrity between db metadata and file system data</source>
          <target state="translated">db 메타 데이터와 파일 시스템 데이터 간의 무결성을 관리하는 것이 더 복잡합니다</target>
        </trans-unit>
        <trans-unit id="273eb3dac5c5806c6a187bffbf5eafcde1e5c03f" translate="yes" xml:space="preserve">
          <source>its easy to manage since you don't have to worry about keeping the filesystem in sync when an image is added or deleted</source>
          <target state="translated">이미지를 추가하거나 삭제할 때 파일 시스템을 동기화하는 것에 대해 걱정할 필요가 없으므로 관리가 용이</target>
        </trans-unit>
        <trans-unit id="0645e0631b812e6d0a5b9edfab265477559eae84" translate="yes" xml:space="preserve">
          <source>mysqldump now takes a looooong time because there is 500MB of file data in one of the tables.</source>
          <target state="translated">테이블 중 하나에 500MB의 파일 데이터가 있으므로 mysqldump는 이제 looooong 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="eec549ffab2d7fa439d6d8ec4a58c0aaba832e68" translate="yes" xml:space="preserve">
          <source>performance penalty -- a database lookup is usually slower that a filesystem lookup</source>
          <target state="translated">성능 저하-데이터베이스 조회는 일반적으로 파일 시스템 조회보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="537460e5682fdff5f1d8e31539381c0231a54a01" translate="yes" xml:space="preserve">
          <source>things like web servers, etc, need no special coding or processing to access images in the file system</source>
          <target state="translated">웹 서버 등과 같은 것들은 파일 시스템의 이미지에 액세스하기 위해 특별한 코딩이나 처리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf4a731866ccbf17f3e091f10fb7389e8354afe9" translate="yes" xml:space="preserve">
          <source>you can super-accelerate file system access with standard off the shelf products</source>
          <target state="translated">표준 제품에서 파일 시스템 액세스를 가속화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4db94e2f04aaa1263e7013679bcdf21bbcf8d6f6" translate="yes" xml:space="preserve">
          <source>you cannot edit the image directly (crop, resize)</source>
          <target state="translated">이미지를 직접 편집 할 수 없습니다 (자르기, 크기 조정)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
