<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3748">
    <body>
      <group id="3748">
        <trans-unit id="47c3aaa77395e894593329e3bdb56a462542e81a" translate="yes" xml:space="preserve">
          <source>+ves:</source>
          <target state="translated">+ves:</target>
        </trans-unit>
        <trans-unit id="5dcc67d3b3974bde67a1dfbe489b0bf1470ca12c" translate="yes" xml:space="preserve">
          <source>-ves:</source>
          <target state="translated">-ves:</target>
        </trans-unit>
        <trans-unit id="df2eb94a6b01c34ef601502e19e10d652b46439d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;This thread&lt;/a&gt; explains why you should use a 3rd party hosting provider.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;此主题&lt;/a&gt;说明了为什么您应该使用第三方托管服务提供商。</target>
        </trans-unit>
        <trans-unit id="b616c405d40078118403f0f28e9e2f410c4eb6eb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Assumption: Application is web enabled/web based&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;假设：应用程序已启用网络/基于网络&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a68ce6032c3740fd013d6c9b66b882246d9cf06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e3161fd669d07159e3a7475c999f77628c85246" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c202eefcc3c874230f5d8c6563173cba8693635" translate="yes" xml:space="preserve">
          <source>A. You don't need FS structure to hold your images</source>
          <target state="translated">A.你不需要FS结构来保存你的图像</target>
        </trans-unit>
        <trans-unit id="270426116340bdc0cd86224583f5d3877de93a8b" translate="yes" xml:space="preserve">
          <source>Ability to easily implement a document versioning system</source>
          <target state="translated">轻松实施文件版本系统的能力</target>
        </trans-unit>
        <trans-unit id="c7b27ed64e40c36b897240dcbfc2315467a72a1a" translate="yes" xml:space="preserve">
          <source>Also, you could decide to save with some structure or elements that allow you to browse the raw images in your filesystem without any db hits, or transfer the files in bulk to another system, hard drive, S3 or another scenario - updating the location in your program, but keep the structure, again without much of a hit trying to bring the images out of your db when trying to increase storage.</source>
          <target state="translated">另外,你可以决定用一些结构或元素来保存,让你浏览文件系统中的原始图像,而不需要任何db命中,或者将文件批量转移到另一个系统、硬盘、S3或另一种情况下--更新程序中的位置,但保持结构,再次不需要太多的命中,尝试增加存储时将图像从你的db中带出来。</target>
        </trans-unit>
        <trans-unit id="7b11a4234011e35a6c31048c3a964862b6e69ee8" translate="yes" xml:space="preserve">
          <source>Amazon S3</source>
          <target state="translated">亚马逊S3</target>
        </trans-unit>
        <trans-unit id="806863a20fd9521591c93b6ce2c193c0342f405d" translate="yes" xml:space="preserve">
          <source>Another StackOverflow threads talking about this &lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">另一个StackOverflow线程在&lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;这里&lt;/a&gt;谈论这个问题 。</target>
        </trans-unit>
        <trans-unit id="4137b28bbb9fcf80d76df94dcc9ea52f9b414a06" translate="yes" xml:space="preserve">
          <source>Another reason to go for file system is when you have to share your images data (or sounds, video, whatever) with third party access: in this days I'm developing a web app that uses images that have to be accessed from &quot;outside&quot; my web farm in such a way that a database access to retrieve binary data is simply impossible. So sometimes there are also design considerations that will drive you to a choice.</source>
          <target state="translated">去文件系统的另一个原因是当你必须与第三方访问共享你的图片数据(或声音、视频等)时:这几天我正在开发一个Web应用,使用的图片必须从 &quot;外部 &quot;访问我的Web农场,这样的方式,通过数据库访问来检索二进制数据是根本不可能的。所以有时候也有设计上的考虑,会促使你做出选择。</target>
        </trans-unit>
        <trans-unit id="6e76a3d1c0a59c96f4904844811645326c89b249" translate="yes" xml:space="preserve">
          <source>As others have said SQL 2008 comes with a Filestream type that allows you to store a filename or identifier as a pointer in the db and automatically stores the image on your filesystem which is a great scenario.</source>
          <target state="translated">正如其他人所说的那样,SQL 2008自带一个Filestream类型,它允许你将文件名或标识符作为指针存储在数据库中,并自动将图像存储在你的文件系统中,这是一个很好的场景。</target>
        </trans-unit>
        <trans-unit id="9b2634f0ec6106d9f9147e4cd3dff1615adeba37" translate="yes" xml:space="preserve">
          <source>As with most issues, it's not as simple as it sounds. There are cases where it would make sense to store the images in the database.</source>
          <target state="translated">和大多数问题一样,这并不像听起来那么简单。有些情况下,将图像存储在数据库中是有意义的。</target>
        </trans-unit>
        <trans-unit id="2a35d366d9a1eb88fd629e03b09b4bdd7c8a046d" translate="yes" xml:space="preserve">
          <source>At a company where I used to work we stored 155 million images in an Oracle 8i (then 9i) database. 7.5TB worth.</source>
          <target state="translated">在我以前工作的公司,我们在Oracle 8i(当时是9i)数据库中存储了1.55亿张图片。价值7.5TB。</target>
        </trans-unit>
        <trans-unit id="687370ce64f7e2dd0384ee8f207a893b7096ffc1" translate="yes" xml:space="preserve">
          <source>B. Database indexes perform better than FS trees when more number of items are to be stored</source>
          <target state="translated">B.当需要存储更多的项目数量时,数据库索引的性能要好于FS树。</target>
        </trans-unit>
        <trans-unit id="848d820eb3eab4f745688973041d4a9d217d5075" translate="yes" xml:space="preserve">
          <source>Backups are integrated.</source>
          <target state="translated">备份是一体化的。</target>
        </trans-unit>
        <trans-unit id="c8dd18981a74439309d7966c8a027a8cc858d9b3" translate="yes" xml:space="preserve">
          <source>Both methods are common and practiced. Have a look at the advantages and disadvantages. Either way, you'll have to think about how to overcome the disadvantages. Storing in database usually means tweaking database parameters and implement some kind of caching. Using filesystem requires you to find some way of keeping filesystem+database in sync.</source>
          <target state="translated">这两种方法都是常用的,也是实践的。一起来看看利与弊。无论哪种方法,你都要考虑一下如何克服缺点。存储在数据库中,通常意味着要调整数据库参数,并实现某种缓存。使用文件系统需要你找到一些保持文件系统+数据库同步的方法。</target>
        </trans-unit>
        <trans-unit id="6b99be15334afb0e1fb922b7dd040aa5dd83e1d3" translate="yes" xml:space="preserve">
          <source>C. Smartly tuned database perform good job at caching the query results</source>
          <target state="translated">C.聪明的数据库在缓存查询结果方面表现良好</target>
        </trans-unit>
        <trans-unit id="a9fa41cd24ffd5f1e44c7dadd97884e69eb206be" translate="yes" xml:space="preserve">
          <source>Consider also, when making this choice, if you have to deal with permission and authentication when accessing binary objects: these requisites normally can be solved in an easier way when data are stored in db.</source>
          <target state="translated">在做这个选择时,还要考虑到,如果你在访问二进制对象时需要处理权限和认证问题:当数据存储在数据库中时,这些要求通常可以用更简单的方式解决。</target>
        </trans-unit>
        <trans-unit id="bfb124dc6fc8752f003971d881d4cc87007a2d3f" translate="yes" xml:space="preserve">
          <source>D. Backups are simple. It also works well if you have replication set up and content is delivered from a server near to user. In such cases, explicit synchronization is not required.</source>
          <target state="translated">D.备份很简单。如果你设置了复制,并且内容从用户附近的服务器上传递,那么它的效果也很好。在这种情况下,不需要显式同步。</target>
        </trans-unit>
        <trans-unit id="b1a5dae551b12236616319e0bb35a5bf5f6335cf" translate="yes" xml:space="preserve">
          <source>Ease of Replication and Backup</source>
          <target state="translated">易于复制和备份</target>
        </trans-unit>
        <trans-unit id="e22bfbeb8bec5e7cafa254beae090269060a8e07" translate="yes" xml:space="preserve">
          <source>FILESTREAM uses the NT system cache for caching file data. This helps reduce any effect that FILESTREAM data might have on Database Engine performance. The SQL Server buffer pool is not used; therefore, this memory is available for query processing.</source>
          <target state="translated">FILESTREAM使用NT系统缓存来缓存文件数据。这有助于减少FILESTREAM数据对数据库引擎性能的任何影响。不使用SQL Server缓冲池;因此,这个内存可用于查询处理。</target>
        </trans-unit>
        <trans-unit id="4154c203e6cd021be2b375052abd91fd364f29f1" translate="yes" xml:space="preserve">
          <source>File paths in the DB is &lt;strong&gt;definitely&lt;/strong&gt; the way to go - I've heard story after story from customers with TB of images that it became a nightmare trying to store any significant amount of images in a DB - the performance hit alone is too much.</source>
          <target state="translated">数据库中的文件路径&lt;strong&gt;绝对&lt;/strong&gt;是必经之路-我听过有大量图像的客户的一个又一个故事，即试图在数据库中存储任何数量的图像已成为噩梦-仅性能方面的影响就太大了。</target>
        </trans-unit>
        <trans-unit id="6b58164fc134ce748db8ca4b2d2da4a94bd28c0b" translate="yes" xml:space="preserve">
          <source>File store.  Facebook engineers had a great talk about it.  One take away was to know the practical limit of files in a directory.</source>
          <target state="translated">文件商店。Facebook的工程师们对此进行了很好的讨论。其中的一个收获是,要知道目录中文件的实用极限。</target>
        </trans-unit>
        <trans-unit id="f506183fe93fe32acd9c9e9fa5b2e25dae72a188" translate="yes" xml:space="preserve">
          <source>FileStream solves most of the problems around storing the files in the DB:</source>
          <target state="translated">FileStream解决了大多数围绕在DB中存储文件的问题。</target>
        </trans-unit>
        <trans-unit id="775382eda387b2f309209bbe52ea023bc8423554" translate="yes" xml:space="preserve">
          <source>For example, your business logic can check if an image file exists on disc before serving it up, retrieving from the database when necessary. This buys you the capability of multiple web servers and fewer sync issues.</source>
          <target state="translated">例如,您的业务逻辑可以在提供图像文件之前检查光盘上是否存在图像文件,必要时从数据库中检索。这为您购买了多个Web服务器的能力和更少的同步问题。</target>
        </trans-unit>
        <trans-unit id="2b7110a6687a3b55c76c2091298794787912727c" translate="yes" xml:space="preserve">
          <source>From the MSDN Article:</source>
          <target state="translated">来自MSDN的文章。</target>
        </trans-unit>
        <trans-unit id="7ec65d66d8967edd541ee0ea7f4da0f56133cc62" translate="yes" xml:space="preserve">
          <source>Given that the images are the actual data being sought after, and that they can be managed easier (the images won't suddenly disappear) in one integrated database rather than having to interface with some kind of filesystem (if the filesystem is independently accessed, the images MIGHT suddenly &quot;disappear&quot;), I'd go for storing them directly as a BLOB or such.</source>
          <target state="translated">考虑到图像是实际的数据,而且它们可以更容易管理(图像不会突然消失)在一个集成的数据库中,而不是必须与某种文件系统对接(如果文件系统被独立访问,图像可能会突然 &quot;消失&quot;),所以我选择直接以BLOB之类的形式存储。</target>
        </trans-unit>
        <trans-unit id="50318af368b2cfc31a1990457660c45811f1519a" translate="yes" xml:space="preserve">
          <source>Heavier load on the database server</source>
          <target state="translated">数据库服务器上的负载较重</target>
        </trans-unit>
        <trans-unit id="2476f13c8544e6adef83fe4356b9351e0dd56bf9" translate="yes" xml:space="preserve">
          <source>Here's an additional point to keep in mind.  One of the reasons supporting the use of a database to store the blobs is ACID compliance.  However, the approach that the testers used in the white paper, (Bulk Logged option of SQL Server,) which doubled SQL Server throughput, effectively changed the 'D' in ACID to a 'd,' as the blob data was not logged with the initial writes for the transaction.   Therefore, if full ACID compliance is an important requirement for your system, halve the SQL Server throughput figures for database writes when comparing file I/O to database blob I/O.</source>
          <target state="translated">这里还有一点要注意。支持使用数据库来存储blob的原因之一是ACID的合规性。然而,测试人员在白皮书中使用的方法,(SQL Server的Bulk Logged选项)使SQL Server的吞吐量增加了一倍,有效地将ACID中的 &quot;D &quot;变成了 &quot;d&quot;,因为blob数据并没有与事务的初始写入一起记录。因此,如果完全符合ACID的要求是你的系统的重要要求,那么在比较文件IO和数据库blob IO时,将SQL Server的数据库写入吞吐量数字减半。</target>
        </trans-unit>
        <trans-unit id="3328bee09e8c09e8968eeed0a2f9b66d9200e6cb" translate="yes" xml:space="preserve">
          <source>Here's an interesting white paper on the topic.</source>
          <target state="translated">下面是一篇有趣的白皮书,关于这个话题。</target>
        </trans-unit>
        <trans-unit id="62412dfc10888fe41ebeaad0772496979a681afc" translate="yes" xml:space="preserve">
          <source>Hopefully this isn't too much babble, but I saw the topic and wanted to provide some my insights from a relatively successful small/medium scale application.</source>
          <target state="translated">希望这不是太多废话,但我看到这个话题,想从一个相对成功的小规模应用中提供一些我的见解。</target>
        </trans-unit>
        <trans-unit id="1262cc4767f7bf18f546e1d6a4826b8fd28f94b6" translate="yes" xml:space="preserve">
          <source>However SQL's &quot;Transparent Data Encryption&quot; does not encrypt FileStream objects, so if that is a consideration, you may be better off just storing them as varbinary.</source>
          <target state="translated">然而,SQL的 &quot;透明数据加密 &quot;并没有对FileStream对象进行加密,所以如果考虑到这一点,你可能会把它们存储为varbinary。</target>
        </trans-unit>
        <trans-unit id="5450e7c1ad84e657a64129b1d482f97873657e65" translate="yes" xml:space="preserve">
          <source>I get to use transactions for edits to improve data integrity - I don't have to worry about orphaned and missing files</source>
          <target state="translated">我可以使用事务进行编辑,以提高数据的完整性----我不必担心文件被遗失和丢失的问题。</target>
        </trans-unit>
        <trans-unit id="cbd2819c808f7d8174170eae9048a48026eae2e0" translate="yes" xml:space="preserve">
          <source>I have recently created a PHP/MySQL app which stores PDFs/Word files in a MySQL table (as big as 40MB per file so far).</source>
          <target state="translated">我最近创建了一个PHPMySQL应用程序,它将PDFsWord文件存储在一个MySQL表中(到目前为止,每个文件高达40MB)。</target>
        </trans-unit>
        <trans-unit id="9d8548824f49d9a78947c14fec692cc06bb03454" translate="yes" xml:space="preserve">
          <source>I once worked on an image processing application. We stored the uploaded images in a directory that was something like /images/[today's date]/[id number]. But we also extracted the metadata (exif data) from the images and stored that in the database, along with a timestamp and such.</source>
          <target state="translated">我曾经在一个图像处理应用程序中工作过。我们将上传的图片存储在一个目录中,这个目录是像images[今天的日期][id号]这样的目录。但我们还从图片中提取了元数据(exif数据),并将其与时间戳等一起存储在数据库中。</target>
        </trans-unit>
        <trans-unit id="1a2a80f9309a684b0d97bad75e984f23663555da" translate="yes" xml:space="preserve">
          <source>I'd call my implementation a success, it takes care of backup requirements and simplifies the layout of the project. The performance is fine for the 20-30 people who use the app.</source>
          <target state="translated">我会说我的实施是成功的,它照顾到了备份需求,简化了项目的布局。对于使用APP的20-30人来说,性能还算可以。</target>
        </trans-unit>
        <trans-unit id="29fa93b28f6e28a031496c25f93f96335b65852e" translate="yes" xml:space="preserve">
          <source>I'm in charge of some applications that manage many TB of images.  We've found that storing &lt;strong&gt;file paths&lt;/strong&gt; in the database to be best.</source>
          <target state="translated">我负责一些管理许多TB图像的应用程序。 我们发现最好将&lt;strong&gt;文件路径&lt;/strong&gt;存储在数据库中。</target>
        </trans-unit>
        <trans-unit id="2fecdc2255f2695e73f6dba95fc3e73d0bcd8d78" translate="yes" xml:space="preserve">
          <source>I'm not sure how much of a &quot;real world&quot; example this is, but I currently have an application out there that stores details for a trading card game, including the images for the cards. Granted the record count for the database is only 2851 records to date, but given the fact that certain cards have are released multiple times and have alternate artwork, it was actually more efficient sizewise to scan the &quot;primary square&quot; of the artwork and then dynamically generate the border and miscellaneous effects for the card when requested.</source>
          <target state="translated">我不知道这是个 &quot;现实世界 &quot;的例子,但我目前有一个应用,它存储了一个卡牌游戏的详细信息,包括卡牌的图片。迄今为止,数据库中的记录数只有2851条,但考虑到某些卡牌有多次发行,并且有不同的图案,因此,扫描图案的 &quot;主方&quot;,然后在请求时动态生成卡牌的边框和杂项效果,实际上在尺寸上更有效率。</target>
        </trans-unit>
        <trans-unit id="d25f4f7e4e4f9284bbb7f7af179d8762a4fab0e8" translate="yes" xml:space="preserve">
          <source>I'm surprised no one has really mentioned this ... delegate it out to others who are specialists -&amp;gt; &lt;strong&gt;use a 3rd party image/file hosting provider&lt;/strong&gt;.</source>
          <target state="translated">令我惊讶的是，没有人真正提到这一点&amp;hellip;&amp;hellip;将其委托给其他专家-&amp;gt; &lt;strong&gt;使用3rd party图像/文件托管服务提供商&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bb19e735abac3d85de5cc543122acd3955a7a44" translate="yes" xml:space="preserve">
          <source>IMO, Pros of using database to store images are,</source>
          <target state="translated">IMO,使用数据库存储图像的好处是:</target>
        </trans-unit>
        <trans-unit id="67789d0ecde7d5223b48e5c0fd30688658e8dad1" translate="yes" xml:space="preserve">
          <source>If the actual image pointed to by the filepath becomes unavailable, the database unwittingly has an integrity error.</source>
          <target state="translated">如果文件路径所指向的实际图像变得不可用,则数据库在不知不觉中出现了完整性错误。</target>
        </trans-unit>
        <trans-unit id="503989532211253730df23717fe63bd466c6f952" translate="yes" xml:space="preserve">
          <source>If this is web-based application then there could be advantages to storing the images on a third-party storage delivery network, such as Amazon's S3 or the Nirvanix platform.</source>
          <target state="translated">如果这是基于网络的应用,那么在第三方存储交付网络上存储图像可能会有优势,比如亚马逊的S3或Nirvanix平台。</target>
        </trans-unit>
        <trans-unit id="c3797548f46dc91bf7279b13b078981dc7232924" translate="yes" xml:space="preserve">
          <source>If you have your images in a file-system and someone is reading the file as you're writing a new version or even deleting the file - what happens?</source>
          <target state="translated">如果你把你的图片保存在一个文件系统中,而有人在你写新版本的时候读取文件,甚至删除文件,会发生什么情况?</target>
        </trans-unit>
        <trans-unit id="bbcc47c06384c94a6e71cd3ed29e7578f9b54e84" translate="yes" xml:space="preserve">
          <source>If you're not on SQL Server 2008 and you have some solid reasons for putting specific image files in the database, then you could take the &quot;both&quot; approach and use the file system as a temporary cache and use the database as the master repository.</source>
          <target state="translated">如果你不在SQL Server 2008上,而且你有一些可靠的理由将特定的映像文件放在数据库中,那么你可以采取 &quot;两全其美 &quot;的方法,将文件系统作为临时缓存,将数据库作为主存储库。</target>
        </trans-unit>
        <trans-unit id="104f4bfbbe4ba01a18a339e2ce0dee05761e7192" translate="yes" xml:space="preserve">
          <source>If you're on an older database, then I'd say that if you're storing it as blob data, then you're really not going to get anything out of the database in the way of searching features, so it's probably best to store an address on a filesystem, and store the image that way.</source>
          <target state="translated">如果你是在一个比较老的数据库上,那么我想说的是,如果你是以blob数据的形式存储,那么你真的无法从数据库中获得任何搜索功能,所以可能最好是在文件系统中存储一个地址,并以这种方式存储图像。</target>
        </trans-unit>
        <trans-unit id="d3db3c02ef9c8ebaf43fb00a808ca6373d64cf93" translate="yes" xml:space="preserve">
          <source>If your images are going to be small (say &amp;lt; 64k) and the storage engine of your db supports inline (in record) BLOBs, it improves performance further as no indirection is required (Locality of reference is achieved).</source>
          <target state="translated">如果您的映像很小（例如&amp;lt;64k），并且数据库的存储引擎支持内联（记录中）BLOB，则由于不需要进行间接调用，因此可以进一步提高性能（实现了引用局部性）。</target>
        </trans-unit>
        <trans-unit id="1367543dc2e57b8ae191b7f517c89168e8563b8d" translate="yes" xml:space="preserve">
          <source>Im my experience I had to manage both situations: images stored in database and images on the file system with path stored in db.</source>
          <target state="translated">根据我的经验,我不得不管理这两种情况:图像存储在数据库中,而图像在文件系统中的路径存储在数据库中。</target>
        </trans-unit>
        <trans-unit id="9403681db30c32ac40b3bcb94b6983848198b3a1" translate="yes" xml:space="preserve">
          <source>Images stored in the database do not require a different backup strategy. Images stored on filesystem do</source>
          <target state="translated">存储在数据库中的图像不需要不同的备份策略。存储在文件系统中的图像不需要</target>
        </trans-unit>
        <trans-unit id="d798c2480179e1f2ec28ad71a0ad5dd2ca9635ca" translate="yes" xml:space="preserve">
          <source>In a previous project i stored images on the filesystem, and that caused a lot of headaches with backups, replication, and the filesystem getting out of sync with the database.</source>
          <target state="translated">在之前的一个项目中,我在文件系统上存储图像,这给备份、复制和文件系统与数据库脱节带来了很多麻烦。</target>
        </trans-unit>
        <trans-unit id="09863ac503085043491d30bf4f9111c47daca621" translate="yes" xml:space="preserve">
          <source>In my experience, sometimes the simplest solution is to &lt;strong&gt;name the images according to the primary key&lt;/strong&gt;. So it's easy to find the image that belongs to a particular record, and vice versa. But at the same time you're not storing &lt;em&gt;anything&lt;/em&gt; about the image in the database.</source>
          <target state="translated">以我的经验，有时最简单的解决方案是&lt;strong&gt;根据主键命名图像&lt;/strong&gt; 。 因此，很容易找到属于特定记录的图像，反之亦然。 但是同时，您不会在数据库中存储有关图像的&lt;em&gt;任何&lt;/em&gt;内容。</target>
        </trans-unit>
        <trans-unit id="f531513cb377ad06aa76b61e2ea34b52b9a15fdd" translate="yes" xml:space="preserve">
          <source>In my latest project i'm storing images in the database, and caching them on the filesystem, and it works really well. I've had no problems so far.</source>
          <target state="translated">在我最新的项目中,我将图片存储在数据库中,并将其缓存在文件系统中,效果非常好。到目前为止,我没有遇到任何问题。</target>
        </trans-unit>
        <trans-unit id="09691af22dcb0a5e64c5ef4a1a4629569c883e0c" translate="yes" xml:space="preserve">
          <source>In places where you MUST guarantee referential integrity and ACID compliance, storing images in the database is required.</source>
          <target state="translated">在必须保证引用完整性和ACID合规性的地方,需要在数据库中存储图像。</target>
        </trans-unit>
        <trans-unit id="ea18a136284e24daa6223fb84ba253dcbfbee5f6" translate="yes" xml:space="preserve">
          <source>It depends on the number of images you are going to store and also their sizes. I have used databases to store images in the past and my experience has been fairly good.</source>
          <target state="translated">这取决于你要存储的图片数量以及图片的大小。我过去曾使用过数据库来存储图片,我的经验相当不错。</target>
        </trans-unit>
        <trans-unit id="9283765c13db752b531235978b65c8824a43fa27" translate="yes" xml:space="preserve">
          <source>It is easier to control access to the images if they are in a database. Idle admins can access any folder on disk. It takes a really determined admin to go snooping in a database to extract the images</source>
          <target state="translated">如果图像是在数据库中,控制对图像的访问比较容易。闲置的管理员可以访问磁盘上的任何文件夹。这需要一个真正有决心的管理员去数据库中窥探,才能提取图像</target>
        </trans-unit>
        <trans-unit id="86a122c21eed2b290e44b53668135ef815601820" translate="yes" xml:space="preserve">
          <source>It's so worth it. They store it efficiently. No bandwith getting uploaded from your servers to client requests, etc.</source>
          <target state="translated">真是太值得了。他们的存储效率很高。没有bandwith从你的服务器上传到客户端请求等。</target>
        </trans-unit>
        <trans-unit id="d1251f454e24d7233f5c1fa0583852723b715eb7" translate="yes" xml:space="preserve">
          <source>Latency may be
    slower than direct file access</source>
          <target state="translated">延迟可能比直接访问文件的速度慢</target>
        </trans-unit>
        <trans-unit id="725eb7fb053ccc585c879ae0da4b122f6a9f14bc" translate="yes" xml:space="preserve">
          <source>Like most other things, It depends on the expected size and Budget.</source>
          <target state="translated">和大多数其他事情一样,这取决于预期的规模和预算。</target>
        </trans-unit>
        <trans-unit id="8545dec1f4c27acaa5353a4c97f59593c52fe97e" translate="yes" xml:space="preserve">
          <source>Manage it like a regular table and have the performance of the file system.</source>
          <target state="translated">像普通的表格一样管理它,拥有文件系统的性能。</target>
        </trans-unit>
        <trans-unit id="f658bc08163a361b68ecdcd9080d547dfa019aed" translate="yes" xml:space="preserve">
          <source>Migration &quot;just works&quot;.</source>
          <target state="translated">迁移 &quot;只管用&quot;。</target>
        </trans-unit>
        <trans-unit id="6968d452a081adacc8b53c63e98bbe9c46f66820" translate="yes" xml:space="preserve">
          <source>Moso Cloud Storage</source>
          <target state="translated">云存储</target>
        </trans-unit>
        <trans-unit id="8351a5f7f60b713223687b5b9fb0f91f10e65233" translate="yes" xml:space="preserve">
          <source>Needle in a Haystack: Efficient Storage of Billions of Photos</source>
          <target state="translated">针在干草堆里。高效存储数十亿张照片</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="f06cb0fe589979c389e198338ded5e8a7b144557" translate="yes" xml:space="preserve">
          <source>Normally, I'm storngly against taking the most expensive and hardest to scale part of your infrastructure (the database) and putting all load into it. On the other hand: It greatly simplifies backup strategy, especially when you have multiple web servers and need to somehow keep the data synchronized.</source>
          <target state="translated">通常情况下,我是反对把最昂贵、最难扩展的基础架构(数据库)的一部分,并把所有的负载都放在其中。在另一方面。它大大简化了备份策略,特别是当你有多个Web服务器,需要以某种方式保持数据同步的时候。</target>
        </trans-unit>
        <trans-unit id="09f177c20b3e429783e2b3893764c0d0da902bd2" translate="yes" xml:space="preserve">
          <source>Obviously database access performance when you deal with binary large objects is degrading, and the database dimensions will grow a lot, causing again performance loss... and normally database space is much more expensive than file system space.</source>
          <target state="translated">显然数据库访问性能在处理二进制的大对象时,数据库访问性能会下降,数据库维度会增长很多,造成性能再次下降...........而通常情况下,数据库空间比文件系统空间要贵得多。</target>
        </trans-unit>
        <trans-unit id="9287d0bca2c5656d1b260627af121123dac33b33" translate="yes" xml:space="preserve">
          <source>On the other hand having large binary objects stored in file system will cause you to have backup plans that have to consider both database and file system, and this can be an issue for some systems.</source>
          <target state="translated">另一方面,将大型二进制对象存储在文件系统中会导致你的备份计划必须同时考虑数据库和文件系统,这对某些系统来说可能是个问题。</target>
        </trans-unit>
        <trans-unit id="e750b8bf3af0d850d7b1c3e5f654ec6d86914f3b" translate="yes" xml:space="preserve">
          <source>On the other hand there are problems associated</source>
          <target state="translated">另一方面,也有相关的问题</target>
        </trans-unit>
        <trans-unit id="69d4c2a1a3cd8e2dc76d590ad7bcca2c66fa2e3a" translate="yes" xml:space="preserve">
          <source>Once common solution to this is to hash them out into a balanced tree of subdirectories.</source>
          <target state="translated">曾经常见的解决方法是将它们混合成一个平衡的子目录树。</target>
        </trans-unit>
        <trans-unit id="dffe608d3ed114e8a78297264f0fe42a01be2bdc" translate="yes" xml:space="preserve">
          <source>One thing that I haven't seen anyone mention yet but is definitely worth noting is that there are issues associated with storing large amounts of images in most filesystems too.  For example if you take the approach mentioned above and name each image file after the primary key, on most filesystems you will run into issues if you try to put all of the images in one big directory once you reach a very large number of images (e.g. in the hundreds of thousands or millions).</source>
          <target state="translated">有一件事我还没有看到有人提到,但绝对值得注意的是,在大多数文件系统中存储大量的图片也会有问题。例如,如果你采取上面提到的方法,以主键命名每个图像文件,在大多数文件系统中,如果你试图把所有的图像都放在一个大目录中,一旦你的图像数量非常多(例如,几十万或几百万),你就会遇到问题。</target>
        </trans-unit>
        <trans-unit id="d9a64c001c7d6c4d98225996f8dd95ddc6b72319" translate="yes" xml:space="preserve">
          <source>One thing to note here is that no one in the pro file system camp has listed a particular file system. Does this mean that everything from FAT16 to ZFS handily beats every database?</source>
          <target state="translated">这里需要注意的一点是,在专业文件系统阵营中没有人列出一个特定的文件系统。这是否意味着从FAT16到ZFS的所有文件系统都能轻松击败所有数据库?</target>
        </trans-unit>
        <trans-unit id="daca8adfb2ce1f5899bcf3cc5dc33091198be70b" translate="yes" xml:space="preserve">
          <source>Overall not very memory/cpu efficient when compared to filesystem</source>
          <target state="translated">总的来说,与文件系统相比,内存CPU效率不是很高。</target>
        </trans-unit>
        <trans-unit id="dc155c121b565754897ed082c978712827881b44" translate="yes" xml:space="preserve">
          <source>Probably, it would also allow you to throw some caching element, based on commonly hit image urls into your web engine/program, so you're saving yourself there as well.</source>
          <target state="translated">可能,这也会让你把一些缓存元素,基于常用的图片urls扔到你的web engineprogram中,所以你也是在那里节省自己。</target>
        </trans-unit>
        <trans-unit id="54b393721169f11c627d23e95f4e0bce01dc79eb" translate="yes" xml:space="preserve">
          <source>Require additional code to extract
and stream the images</source>
          <target state="translated">需要额外的代码来提取和串流图像</target>
        </trans-unit>
        <trans-unit id="bdd88b7d31c47d46b3476e67aa360525526c3160" translate="yes" xml:space="preserve">
          <source>SQL Server 2008 offers a solution that has the best of both worlds : &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;The filestream data type&lt;/a&gt;.</source>
          <target state="translated">SQL Server 2008提供了一个兼具两全其美的解决方案：文件&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;流数据类型&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec236495b04b446b59d809893ff3e4466ca3fd51" translate="yes" xml:space="preserve">
          <source>Second the recommendation on file paths. I've worked on a couple of projects that needed to manage large-ish asset collections, and any attempts to store things directly in the DB resulted in pain and frustration long-term.</source>
          <target state="translated">第二点是关于文件路径的建议。我曾经做过几个项目,需要管理大型的资产集合,任何试图直接在DB中存储东西的尝试都会导致长期的痛苦和沮丧。</target>
        </trans-unit>
        <trans-unit id="7ecb8d1b499802e07c066d2d9c3ceee7493e96ab" translate="yes" xml:space="preserve">
          <source>Serving up images from a database is easy, just implement an http handler that serves the byte array returned from the DB server as a binary stream.</source>
          <target state="translated">服务于数据库中的图像很容易,只需实现一个http处理程序,将DB服务器返回的字节数组以二进制流的形式服务于数据库。</target>
        </trans-unit>
        <trans-unit id="99962b21785a235b5e93d806ae6c3d7e37e621ce" translate="yes" xml:space="preserve">
          <source>Setting up the web server is slightly simpler because I don't need to have an uploads/ folder and tell all my applications where it is.</source>
          <target state="translated">设置Web服务器稍微简单一些,因为我不需要有一个上传文件夹并告诉我所有的应用程序在哪里。</target>
        </trans-unit>
        <trans-unit id="e9b806b728121ce126b464af0bd80ee2afdf68c9" translate="yes" xml:space="preserve">
          <source>Small static images (not more than a couple of megs) that are not frequently edited, should be stored in the database. This method has several benefits including easier portability (images are transferred with the database), easier backup/restore (images are backed up with the database) and better scalability (a file system folder with thousands of little thumbnail files sounds like a scalability nightmare to me).</source>
          <target state="translated">不经常编辑的小型静态图像(不超过几兆),应该存储在数据库中。这种方法有几个好处,包括更容易移植(图像随数据库一起传输)、更容易备份恢复(图像随数据库一起备份)和更好的可扩展性(一个文件系统文件夹里有成千上万的小缩略图文件,听起来就像一个可扩展性的噩梦)。</target>
        </trans-unit>
        <trans-unit id="c77302484315f43d1b8825352fad38163e655d07" translate="yes" xml:space="preserve">
          <source>Smaller sized files can be efficiently stored and delivered using the database as the storage mechanism.  Larger files would probably be best stored using the file system, especially if they will be modified/updated often.  (blob fragmentation becomes an issue in regards to performance.)</source>
          <target state="translated">较小的文件可以使用数据库作为存储机制有效地存储和传递。较大的文件最好使用文件系统来存储,特别是当它们经常被修改更新的时候。(blob碎片化会成为性能方面的问题。)</target>
        </trans-unit>
        <trans-unit id="714b035f21ed87fb37883666dfce0caea714ccc8" translate="yes" xml:space="preserve">
          <source>So I'm using an app that stores images heavily in the DB. What's your outlook on this? I'm more of a type to store the location in the filesystem, than store it directly in the DB.</source>
          <target state="translated">所以我使用的是一个在DB中大量存储图片的APP。你对这个问题有什么看法?我更倾向于将位置存储在文件系统中,而不是直接存储在DB中。</target>
        </trans-unit>
        <trans-unit id="6dccf67eb0ddd77e8bfbc72fb16de2a45d5b6cae" translate="yes" xml:space="preserve">
          <source>Something nobody has mentioned is that the DB guarantees atomic actions, transactional integrity and deals with concurrency. Even referentially integrity is out of the window with a filesystem - so how do you know your file names are really still correct?</source>
          <target state="translated">没有人提到的东西是,DB保证了原子动作、事务完整性和处理并发性。即使是引用的完整性在文件系统中也是不可能的--所以你怎么知道你的文件名真的还是正确的?</target>
        </trans-unit>
        <trans-unit id="8af055bdbe7670239d44aa860e0890dd569e962b" translate="yes" xml:space="preserve">
          <source>Store your files on a paid online service like</source>
          <target state="translated">将您的文件存储在付费的在线服务上,如</target>
        </trans-unit>
        <trans-unit id="1a3781484823414d3725393bd2bf249b5bee6d6c" translate="yes" xml:space="preserve">
          <source>Storing Images in DB - Yea or Nay</source>
          <target state="translated">在数据库中存储图像----同意还是不同意</target>
        </trans-unit>
        <trans-unit id="d5edc6aeda738e7a8d9506f8a9a0366272625476" translate="yes" xml:space="preserve">
          <source>Storing an image in the database still means that the image data ends up somewhere in the file system but obscured so that you cannot access it directly.</source>
          <target state="translated">将图像存储在数据库中仍然意味着图像数据最终会在文件系统中的某个地方结束,但会被遮蔽,因此无法直接访问。</target>
        </trans-unit>
        <trans-unit id="83e9a8f9902db2ab45aab8a68857232f91f8f817" translate="yes" xml:space="preserve">
          <source>Storing images may be a bad idea when you are dealing with small number of huge sized images. Another problem with storing images in db is that, metadata like creation, modification dates must handled by your application.</source>
          <target state="translated">当你处理的是少量的巨量图片时,存储图片可能是个坏主意。在数据库中存储图片的另一个问题是,元数据如创建、修改日期等必须由你的应用程序处理。</target>
        </trans-unit>
        <trans-unit id="fc7ebe3f5c8fa7bb3211919a811fe054ebec3fde" translate="yes" xml:space="preserve">
          <source>That seems like it would be better solved with an intermediary script pulling data from a web-inaccessible file store, though. So the DB storage isn't REALLY necessary.</source>
          <target state="translated">这个问题似乎可以通过一个中间脚本从网络可访问的文件存储中提取数据来解决。所以,DB存储并不是真正必要的。</target>
        </trans-unit>
        <trans-unit id="e507594d631333c78e791861af1df08eda58c6dd" translate="yes" xml:space="preserve">
          <source>That way you also save space on your filesystem, as you are only going to save the exact amount of space, or even compacted space on the filesystem.</source>
          <target state="translated">这样一来,你也可以在文件系统中节省空间,因为你只需要在文件系统中保存确切的空间,甚至是压缩后的空间。</target>
        </trans-unit>
        <trans-unit id="aa8930f1feae478f1bcc7944864a710d55955741" translate="yes" xml:space="preserve">
          <source>The Blobs are actually stored as files in a folder.</source>
          <target state="translated">Blobs实际上是以文件的形式存储在一个文件夹中。</target>
        </trans-unit>
        <trans-unit id="dac8ad2eb459eb9d8f5d901be3595fff1497aa53" translate="yes" xml:space="preserve">
          <source>The Blobs can be accessed using &lt;em&gt;either&lt;/em&gt; a database connection &lt;em&gt;or&lt;/em&gt; over the filesystem.</source>
          <target state="translated">可以使用数据库连接&lt;em&gt;或&lt;/em&gt;通过文件系统来访问Blob。</target>
        </trans-unit>
        <trans-unit id="26f263ae32cfbdb323507d0b4a4dbcc181aa7185" translate="yes" xml:space="preserve">
          <source>The answer is &quot;It depends.&quot;  Certainly it would depend upon the database server and its approach to blob storage.  It also depends on the type of data being stored in blobs, as well as how that data is to be accessed.</source>
          <target state="translated">答案是 &quot;这要看情况&quot;。当然,这取决于数据库服务器及其对blob存储的方法。这也取决于blob中存储的数据类型,以及如何访问这些数据。</target>
        </trans-unit>
        <trans-unit id="398e9d6490298e990e2ac82498c6a4997352591a" translate="yes" xml:space="preserve">
          <source>The correct course of action is to make the right decision for your precise scenario, and to do that, you'll need some numbers and some use case estimates.</source>
          <target state="translated">正确的行动方针是针对你的精确场景做出正确的决策,而要做到这一点,你需要一些数字和一些用例估算。</target>
        </trans-unit>
        <trans-unit id="a3ff707b3146ba5858644a13add5404689ca1dac" translate="yes" xml:space="preserve">
          <source>The first solution, images in database, is somewhat &quot;cleaner&quot; as your data access layer will have to deal only with database objects; but this is good only when you have to deal with low numbers.</source>
          <target state="translated">第一种方案,在数据库中的图像,有点 &quot;干净&quot;,因为你的数据访问层将不得不只处理数据库对象;但这只有在你必须处理低数量的时候才是好的。</target>
        </trans-unit>
        <trans-unit id="99b1b7fb03c27b12dd7a97fbe5cba9dedbf6f7d3" translate="yes" xml:space="preserve">
          <source>The government wants you to maintain 6 years of history</source>
          <target state="translated">政府要你保持6年的历史记录</target>
        </trans-unit>
        <trans-unit id="be8c1d64425fb81ddff96737d2195647616aeedb" translate="yes" xml:space="preserve">
          <source>The only real &quot;pro&quot; I can think of regarding storing them in the DB is the potential for easy of individual image assets. If there are no file paths to use, and all images are streamed straight out of the DB, there's no danger of a user finding files they shouldn't have access to.</source>
          <target state="translated">我能想到的唯一真正 &quot;专业 &quot;的是,在DB中存储它们的好处是可以方便地存储单个图像资产。如果没有文件路径,而且所有的图片都是从DB中直接流转出来的,那么用户就不会有发现他们不应该访问的文件的危险。</target>
        </trans-unit>
        <trans-unit id="b6df983ec2f8655d79d2d357cb2d842ac9c202c5" translate="yes" xml:space="preserve">
          <source>The original creator of this image library created a data access class that renders the image based on the request, and it does it quite fast for viewing and individual card.</source>
          <target state="translated">这个图像库的原始创建者创建了一个数据访问类,它根据请求渲染了图像,在查看和单独的卡片上做得相当快。</target>
        </trans-unit>
        <trans-unit id="21e9b5d795f89df6924b68d2e63f969592671fda" translate="yes" xml:space="preserve">
          <source>The problem with storing only filepaths to images in a database is that the database's integrity can no longer be forced.</source>
          <target state="translated">在数据库中只存储图像的文件路径的问题是,数据库的完整性不能再强求。</target>
        </trans-unit>
        <trans-unit id="f33c90f1fc426daa04efefb0038c1e8f22a9e375" translate="yes" xml:space="preserve">
          <source>The trick here is to not become a zealot.</source>
          <target state="translated">这里的诀窍是不要成为一个热心人。</target>
        </trans-unit>
        <trans-unit id="d8f59a378f87933d06e892653ff4a82c884cf319" translate="yes" xml:space="preserve">
          <source>The truth is that many databases beat many files systems, even when we're only talking about raw speed.</source>
          <target state="translated">事实是,很多数据库打败了很多文件系统,即使我们只谈原始速度,也是如此。</target>
        </trans-unit>
        <trans-unit id="c2d423a32b108506f0bfd6455f1f96019a07f538" translate="yes" xml:space="preserve">
          <source>The word on the street is that unless you are a database vendor trying to prove that your database can do it (like, let's say Microsoft boasting about Terraserver storing a bajillion images in SQL Server) it's not a very good idea. When the alternative - storing images on file servers and paths in the database is so much easier, why bother? Blob fields are kind of like the off-road capabilities of SUVs - most people don't use them, those who do usually get in trouble, and then there are those who do, but only for the fun of it.</source>
          <target state="translated">街头上的说法是,除非你是数据库厂商试图证明你的数据库可以做到这一点(比如说微软吹嘘说Terraserver在SQL Server中存储了几十亿张图片),否则这不是一个很好的主意。当替代方案--将图像存储在文件服务器和数据库中的路径上,就会变得简单得多,何必费心呢?Blob字段有点像SUV的越野能力--大多数人不会使用它们,那些使用的人通常会遇到麻烦,而那些使用的人通常会遇到麻烦,但也有一些人使用,只是为了好玩。</target>
        </trans-unit>
        <trans-unit id="36730b9cc2f305e81fe3cdc4abe7056400f5a97f" translate="yes" xml:space="preserve">
          <source>There are a couple of issues:</source>
          <target state="translated">有几个问题。</target>
        </trans-unit>
        <trans-unit id="f29edf34e1917d1906a7773ea48427778e05cd8a" translate="yes" xml:space="preserve">
          <source>This also eases deployment/updates when new cards are released, instead of zipping up an entire folder of images and sending those down the pipe and ensuring the proper folder structure is created, I simply update the database and have the user download it again. This currently sizes up to 56MB, which isn't great, but I'm working on an incremental update feature for future releases. In addition, there is a &quot;no images&quot; version of the application that allows those over dial-up to get the application without the download delay.</source>
          <target state="translated">这也简化了新卡发布时的部署更新,而不是把整个文件夹中的图片压缩起来,然后把这些图片发到管道中,并确保创建正确的文件夹结构,我只需更新数据库,然后让用户再次下载。目前,这个功能的大小高达56MB,这并不是很好,但我正在为未来的版本开发一个增量更新功能。此外,该应用还有一个 &quot;无图像 &quot;版本,允许那些通过拨号上网的用户在没有下载延迟的情况下获得该应用。</target>
        </trans-unit>
        <trans-unit id="d2559b6884c2c3166252cf8317c08d9d7192227f" translate="yes" xml:space="preserve">
          <source>This might be a bit of a long shot, but if you're using (or planning on using) SQL Server 2008 I'd recommend having a look at the new &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;FileStream&lt;/a&gt; data type.</source>
          <target state="translated">这可能会花费很多时间，但是如果您正在使用（或计划使用）SQL Server 2008，则建议您查看一下新的&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;FileStream&lt;/a&gt;数据类型。</target>
        </trans-unit>
        <trans-unit id="5de5ed2ad95580ae9860ae51bb53fb858569f0c9" translate="yes" xml:space="preserve">
          <source>This solution has worked great to date since the application itself is targeted as a single instance on the desktop. There is a web site where all of this data is archived for online access, but I would in no way use the same solution for this. I agree the file access would be preferable because it would scale better to the frequency and volume of requests being made for the images.</source>
          <target state="translated">迄今为止,这个解决方案的效果很好,因为该应用程序本身是作为桌面上的一个单一实例。有一个网站可以将所有这些数据存档供在线访问,但我决不会为此使用同样的解决方案。我同意文件访问更可取,因为它能更好地适应图像请求的频率和数量。</target>
        </trans-unit>
        <trans-unit id="7a9f42b006e68507b2bf93c3dc35393a93370b8e" translate="yes" xml:space="preserve">
          <source>To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem</source>
          <target state="translated">要不要BLOB:数据库或文件系统中的大型对象存储</target>
        </trans-unit>
        <trans-unit id="115c5ce402f46dd63900f8651dbc2e3d209abf85" translate="yes" xml:space="preserve">
          <source>Transact-SQL statements can insert, update, query, search, and back up FILESTREAM data. Win32 file system interfaces provide streaming access to the data.</source>
          <target state="translated">Transact-SQL语句可以插入、更新、查询、搜索和备份FILESTREAM数据。Win32文件系统接口提供了对数据的流式访问。</target>
        </trans-unit>
        <trans-unit id="c939e193a50e38ae5295ae364bae62a85fc25476" translate="yes" xml:space="preserve">
          <source>Uploaded files are replicated to backup server along with everything else, no separate backup strategy is needed (peace of mind).</source>
          <target state="translated">上载的文件会和其他文件一起复制到备份服务器,不需要单独的备份策略(放心)。</target>
        </trans-unit>
        <trans-unit id="8fb23687e4739bac5fa4b49b3b6e933f9284f922" translate="yes" xml:space="preserve">
          <source>We have implemented a document imaging system that stores all it's images in SQL2005 blob fields.  There are several hundred GB at the moment and we are seeing excellent response times and little or no performance degradation. In addition, fr regulatory compliance, we have a middleware layer that archives newly posted documents to an optical jukebox system which exposes them as a standard NTFS file system.</source>
          <target state="translated">我们实施了一个文档成像系统,将所有的图像存储在SQL2005的blob字段中。目前有几百个GB,我们看到的响应时间非常好,而且几乎没有性能下降。此外,为了符合监管要求,我们有一个中间件层,将新发布的文档归档到光学点唱机系统中,并将其作为标准的NTFS文件系统公开。</target>
        </trans-unit>
        <trans-unit id="fdbbc258fb96a990b2231e7642581c54c943bfea" translate="yes" xml:space="preserve">
          <source>We use blobs because they're easier to manage (backup, replication, transfer) too. They work well for us.</source>
          <target state="translated">我们使用 blobs,因为它们也更容易管理(备份、复制、传输)。它们对我们来说效果很好。</target>
        </trans-unit>
        <trans-unit id="92bec75ea6ee7bd3cc26a274361ce400ab17e448" translate="yes" xml:space="preserve">
          <source>We've been very pleased with the results, particularly with respect to:</source>
          <target state="translated">我们对这个结果非常满意,尤其是关于。</target>
        </trans-unit>
        <trans-unit id="7ef90e6354471827cade517de2c173b8991b7175" translate="yes" xml:space="preserve">
          <source>What do you think are the pros/cons?</source>
          <target state="translated">你认为有哪些亲信?</target>
        </trans-unit>
        <trans-unit id="87de9781c77b14deca711032ac785da434dcb2f0" translate="yes" xml:space="preserve">
          <source>You are storing images that are
changing dynamically, say invoices and you wanted
to get an invoice as it was on 1 Jan
2007?</source>
          <target state="translated">你存储的图像是动态变化的,比如说发票,你想得到的是2007年1月1日的发票?</target>
        </trans-unit>
        <trans-unit id="95453050e6c680a8686d784628d69b7341319e48" translate="yes" xml:space="preserve">
          <source>You cannot transactionaly guarantee that the image and the meta-data about that image stored in the database refer to the same file. In other words, it is impossible to guarantee that the file on the filesystem is only ever altered at the same time and in the same transaction as the metadata.</source>
          <target state="translated">你不能保证存储在数据库中的图像和关于该图像的元数据指的是同一个文件。换句话说,无法保证文件系统中的文件与元数据在同一时间和同一事务中被更改。</target>
        </trans-unit>
        <trans-unit id="44ac3e04ec087585e18c01c02894782e6ec3abfb" translate="yes" xml:space="preserve">
          <source>database integrity</source>
          <target state="translated">数据库的完整性</target>
        </trans-unit>
        <trans-unit id="4b227f33a30575522e0591fdc96075df02b8e35c" translate="yes" xml:space="preserve">
          <source>database storage is usually more expensive than file system storage</source>
          <target state="translated">数据库存储通常比文件系统存储更昂贵</target>
        </trans-unit>
        <trans-unit id="ddbdd288dca0200556d991307329fa940b415ca3" translate="yes" xml:space="preserve">
          <source>databases win out where transactional integrity between the image and metadata are important.</source>
          <target state="translated">数据库在图像和元数据之间的交易完整性很重要的地方胜出。</target>
        </trans-unit>
        <trans-unit id="7bb6a86f7fb04a200fe53244cac70f7908c2d1b9" translate="yes" xml:space="preserve">
          <source>for example, many web servers use the operating system's &lt;strong&gt;sendfile()&lt;/strong&gt; system call to asynchronously send a file directly from the file system to the network interface. Images stored in a database don't benefit from this optimization.</source>
          <target state="translated">例如，许多Web服务器使用操作系统的&lt;strong&gt;sendfile（）&lt;/strong&gt;系统调用将文件直接从文件系统异步发送到网络接口。 存储在数据库中的图像无法从此优化中受益。</target>
        </trans-unit>
        <trans-unit id="f66131dba234d08d3eccc828f035e8d23ef4236f" translate="yes" xml:space="preserve">
          <source>it is difficult (within the context of a web application) to guarantee data has been flushed to disk on the filesystem</source>
          <target state="translated">很难保证数据已经被冲到磁盘上的文件系统中(在Web应用程序的上下文中)。</target>
        </trans-unit>
        <trans-unit id="539156605d769e1ec2dfda3fa9f1f2a30afd98dd" translate="yes" xml:space="preserve">
          <source>it is more complex to manage integrity between db metadata and file system data</source>
          <target state="translated">管理数据库元数据和文件系统数据之间的完整性比较复杂。</target>
        </trans-unit>
        <trans-unit id="273eb3dac5c5806c6a187bffbf5eafcde1e5c03f" translate="yes" xml:space="preserve">
          <source>its easy to manage since you don't have to worry about keeping the filesystem in sync when an image is added or deleted</source>
          <target state="translated">易于管理,因为当添加或删除图像时,您不必担心保持文件系统的同步性。</target>
        </trans-unit>
        <trans-unit id="0645e0631b812e6d0a5b9edfab265477559eae84" translate="yes" xml:space="preserve">
          <source>mysqldump now takes a looooong time because there is 500MB of file data in one of the tables.</source>
          <target state="translated">mysqldump现在需要很长的时间,因为其中一个表里有500MB的文件数据。</target>
        </trans-unit>
        <trans-unit id="eec549ffab2d7fa439d6d8ec4a58c0aaba832e68" translate="yes" xml:space="preserve">
          <source>performance penalty -- a database lookup is usually slower that a filesystem lookup</source>
          <target state="translated">性能惩罚----数据库查询通常比文件系统查询慢。</target>
        </trans-unit>
        <trans-unit id="537460e5682fdff5f1d8e31539381c0231a54a01" translate="yes" xml:space="preserve">
          <source>things like web servers, etc, need no special coding or processing to access images in the file system</source>
          <target state="translated">像网络服务器等,不需要特殊的编码或处理就可以访问文件系统中的图像。</target>
        </trans-unit>
        <trans-unit id="bf4a731866ccbf17f3e091f10fb7389e8354afe9" translate="yes" xml:space="preserve">
          <source>you can super-accelerate file system access with standard off the shelf products</source>
          <target state="translated">您可以使用标准的现成产品来超速访问文件系统。</target>
        </trans-unit>
        <trans-unit id="4db94e2f04aaa1263e7013679bcdf21bbcf8d6f6" translate="yes" xml:space="preserve">
          <source>you cannot edit the image directly (crop, resize)</source>
          <target state="translated">不能直接编辑图像(裁剪、调整大小)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
