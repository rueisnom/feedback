<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/3748">
    <body>
      <group id="3748">
        <trans-unit id="47c3aaa77395e894593329e3bdb56a462542e81a" translate="yes" xml:space="preserve">
          <source>+ves:</source>
          <target state="translated">+ves:</target>
        </trans-unit>
        <trans-unit id="5dcc67d3b3974bde67a1dfbe489b0bf1470ca12c" translate="yes" xml:space="preserve">
          <source>-ves:</source>
          <target state="translated">-ves:</target>
        </trans-unit>
        <trans-unit id="df2eb94a6b01c34ef601502e19e10d652b46439d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;This thread&lt;/a&gt; explains why you should use a 3rd party hosting provider.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Este hilo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; explica por qu&amp;eacute; deber&amp;iacute;a utilizar un proveedor de alojamiento de terceros.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b616c405d40078118403f0f28e9e2f410c4eb6eb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Assumption: Application is web enabled/web based&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Supuesto: la aplicaci&amp;oacute;n est&amp;aacute; habilitada para web / basada en web&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a68ce6032c3740fd013d6c9b66b882246d9cf06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e3161fd669d07159e3a7475c999f77628c85246" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c202eefcc3c874230f5d8c6563173cba8693635" translate="yes" xml:space="preserve">
          <source>A. You don't need FS structure to hold your images</source>
          <target state="translated">A.No necesitas la estructura FS para mantener tus imágenes</target>
        </trans-unit>
        <trans-unit id="270426116340bdc0cd86224583f5d3877de93a8b" translate="yes" xml:space="preserve">
          <source>Ability to easily implement a document versioning system</source>
          <target state="translated">Capacidad de implementar fácilmente un sistema de versiones de documentos</target>
        </trans-unit>
        <trans-unit id="c7b27ed64e40c36b897240dcbfc2315467a72a1a" translate="yes" xml:space="preserve">
          <source>Also, you could decide to save with some structure or elements that allow you to browse the raw images in your filesystem without any db hits, or transfer the files in bulk to another system, hard drive, S3 or another scenario - updating the location in your program, but keep the structure, again without much of a hit trying to bring the images out of your db when trying to increase storage.</source>
          <target state="translated">También podría decidir guardar con alguna estructura o elementos que le permitan explorar las imágenes en bruto en su sistema de archivos sin ningún golpe de la db,o transferir los archivos en masa a otro sistema,disco duro,S3 u otro escenario-actualizando la ubicación en su programa,pero manteniendo la estructura,de nuevo sin mucho golpe tratando de sacar las imágenes de su db al tratar de aumentar el almacenamiento.</target>
        </trans-unit>
        <trans-unit id="7b11a4234011e35a6c31048c3a964862b6e69ee8" translate="yes" xml:space="preserve">
          <source>Amazon S3</source>
          <target state="translated">Amazon S3</target>
        </trans-unit>
        <trans-unit id="806863a20fd9521591c93b6ce2c193c0342f405d" translate="yes" xml:space="preserve">
          <source>Another StackOverflow threads talking about this &lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otros hilos de StackOverflow que hablan de esto &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4137b28bbb9fcf80d76df94dcc9ea52f9b414a06" translate="yes" xml:space="preserve">
          <source>Another reason to go for file system is when you have to share your images data (or sounds, video, whatever) with third party access: in this days I'm developing a web app that uses images that have to be accessed from &quot;outside&quot; my web farm in such a way that a database access to retrieve binary data is simply impossible. So sometimes there are also design considerations that will drive you to a choice.</source>
          <target state="translated">Otra razón para optar por el sistema de archivos es cuando hay que compartir los datos de las imágenes (o los sonidos,el vídeo,lo que sea)con el acceso de terceros:en estos días estoy desarrollando una aplicación web que utiliza imágenes a las que hay que acceder desde &quot;fuera&quot; de mi granja web de tal manera que el acceso a una base de datos para recuperar datos binarios es simplemente imposible.Así que a veces también hay consideraciones de diseño que te llevarán a una elección.</target>
        </trans-unit>
        <trans-unit id="6e76a3d1c0a59c96f4904844811645326c89b249" translate="yes" xml:space="preserve">
          <source>As others have said SQL 2008 comes with a Filestream type that allows you to store a filename or identifier as a pointer in the db and automatically stores the image on your filesystem which is a great scenario.</source>
          <target state="translated">Como otros han dicho,SQL 2008 viene con un tipo de Filestream que le permite almacenar un nombre de archivo o identificador como un puntero en la db y almacena automáticamente la imagen en su sistema de archivos,lo cual es un gran escenario.</target>
        </trans-unit>
        <trans-unit id="9b2634f0ec6106d9f9147e4cd3dff1615adeba37" translate="yes" xml:space="preserve">
          <source>As with most issues, it's not as simple as it sounds. There are cases where it would make sense to store the images in the database.</source>
          <target state="translated">Como con la mayoría de los problemas,no es tan simple como parece.Hay casos en los que tendría sentido almacenar las imágenes en la base de datos.</target>
        </trans-unit>
        <trans-unit id="2a35d366d9a1eb88fd629e03b09b4bdd7c8a046d" translate="yes" xml:space="preserve">
          <source>At a company where I used to work we stored 155 million images in an Oracle 8i (then 9i) database. 7.5TB worth.</source>
          <target state="translated">En una empresa donde yo trabajaba,almacenamos 155 millones de imágenes en una base de datos Oracle 8i (entonces 9i).Por valor de 7,5 TB.</target>
        </trans-unit>
        <trans-unit id="687370ce64f7e2dd0384ee8f207a893b7096ffc1" translate="yes" xml:space="preserve">
          <source>B. Database indexes perform better than FS trees when more number of items are to be stored</source>
          <target state="translated">B.Los índices de las bases de datos funcionan mejor que los árboles genealógicos cuando se debe almacenar un mayor número de elementos</target>
        </trans-unit>
        <trans-unit id="848d820eb3eab4f745688973041d4a9d217d5075" translate="yes" xml:space="preserve">
          <source>Backups are integrated.</source>
          <target state="translated">Las copias de seguridad están integradas.</target>
        </trans-unit>
        <trans-unit id="c8dd18981a74439309d7966c8a027a8cc858d9b3" translate="yes" xml:space="preserve">
          <source>Both methods are common and practiced. Have a look at the advantages and disadvantages. Either way, you'll have to think about how to overcome the disadvantages. Storing in database usually means tweaking database parameters and implement some kind of caching. Using filesystem requires you to find some way of keeping filesystem+database in sync.</source>
          <target state="translated">Ambos métodos son comunes y se practican.Echa un vistazo a las ventajas y desventajas.De cualquier manera,tendrás que pensar en cómo superar las desventajas.Almacenar en la base de datos suele significar ajustar los parámetros de la base de datos e implementar algún tipo de caché.El uso del sistema de archivos requiere que encuentres alguna forma de mantener sincronizados el sistema de archivos y la base de datos.</target>
        </trans-unit>
        <trans-unit id="6b99be15334afb0e1fb922b7dd040aa5dd83e1d3" translate="yes" xml:space="preserve">
          <source>C. Smartly tuned database perform good job at caching the query results</source>
          <target state="translated">C.La base de datos inteligentemente ajustada hace un buen trabajo al almacenar los resultados de la consulta</target>
        </trans-unit>
        <trans-unit id="a9fa41cd24ffd5f1e44c7dadd97884e69eb206be" translate="yes" xml:space="preserve">
          <source>Consider also, when making this choice, if you have to deal with permission and authentication when accessing binary objects: these requisites normally can be solved in an easier way when data are stored in db.</source>
          <target state="translated">Considere también,al hacer esta elección,si tiene que lidiar con el permiso y la autenticación al acceder a los objetos binarios:estos requisitos normalmente pueden resolverse de manera más fácil cuando los datos se almacenan en la db.</target>
        </trans-unit>
        <trans-unit id="bfb124dc6fc8752f003971d881d4cc87007a2d3f" translate="yes" xml:space="preserve">
          <source>D. Backups are simple. It also works well if you have replication set up and content is delivered from a server near to user. In such cases, explicit synchronization is not required.</source>
          <target state="translated">D.Las copias de seguridad son simples.También funciona bien si se ha configurado la replicación y el contenido se entrega desde un servidor cercano al usuario.En tales casos,no se requiere una sincronización explícita.</target>
        </trans-unit>
        <trans-unit id="b1a5dae551b12236616319e0bb35a5bf5f6335cf" translate="yes" xml:space="preserve">
          <source>Ease of Replication and Backup</source>
          <target state="translated">Facilidad de replicación y respaldo</target>
        </trans-unit>
        <trans-unit id="e22bfbeb8bec5e7cafa254beae090269060a8e07" translate="yes" xml:space="preserve">
          <source>FILESTREAM uses the NT system cache for caching file data. This helps reduce any effect that FILESTREAM data might have on Database Engine performance. The SQL Server buffer pool is not used; therefore, this memory is available for query processing.</source>
          <target state="translated">FILESTREAM utiliza la caché del sistema NT para almacenar datos de archivos.Esto ayuda a reducir cualquier efecto que los datos de FILESTREAM puedan tener en el rendimiento del motor de la base de datos.No se utiliza la reserva de memoria intermedia del servidor SQL;por lo tanto,esta memoria está disponible para el procesamiento de consultas.</target>
        </trans-unit>
        <trans-unit id="4154c203e6cd021be2b375052abd91fd364f29f1" translate="yes" xml:space="preserve">
          <source>File paths in the DB is &lt;strong&gt;definitely&lt;/strong&gt; the way to go - I've heard story after story from customers with TB of images that it became a nightmare trying to store any significant amount of images in a DB - the performance hit alone is too much.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las rutas de archivos en la base de datos son &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;definitivamente&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; el camino a seguir: he escuchado una historia tras otra de clientes con TB de im&amp;aacute;genes que se convirti&amp;oacute; en una pesadilla al tratar de almacenar una cantidad significativa de im&amp;aacute;genes en una base de datos: el rendimiento solo es demasiado.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b58164fc134ce748db8ca4b2d2da4a94bd28c0b" translate="yes" xml:space="preserve">
          <source>File store.  Facebook engineers had a great talk about it.  One take away was to know the practical limit of files in a directory.</source>
          <target state="translated">Tienda de archivos.Los ingenieros de Facebook tuvieron una gran charla al respecto.Una de las cosas que se llevaron a cabo fue conocer el límite práctico de los archivos en un directorio.</target>
        </trans-unit>
        <trans-unit id="f506183fe93fe32acd9c9e9fa5b2e25dae72a188" translate="yes" xml:space="preserve">
          <source>FileStream solves most of the problems around storing the files in the DB:</source>
          <target state="translated">FileStream resuelve la mayoría de los problemas relacionados con el almacenamiento de los archivos en la base de datos:</target>
        </trans-unit>
        <trans-unit id="775382eda387b2f309209bbe52ea023bc8423554" translate="yes" xml:space="preserve">
          <source>For example, your business logic can check if an image file exists on disc before serving it up, retrieving from the database when necessary. This buys you the capability of multiple web servers and fewer sync issues.</source>
          <target state="translated">Por ejemplo,la lógica de su empresa puede comprobar si un archivo de imagen existe en el disco antes de servirlo,recuperándolo de la base de datos cuando sea necesario.Esto le da la capacidad de tener múltiples servidores web y menos problemas de sincronización.</target>
        </trans-unit>
        <trans-unit id="2b7110a6687a3b55c76c2091298794787912727c" translate="yes" xml:space="preserve">
          <source>From the MSDN Article:</source>
          <target state="translated">Del artículo de MSDN:</target>
        </trans-unit>
        <trans-unit id="7ec65d66d8967edd541ee0ea7f4da0f56133cc62" translate="yes" xml:space="preserve">
          <source>Given that the images are the actual data being sought after, and that they can be managed easier (the images won't suddenly disappear) in one integrated database rather than having to interface with some kind of filesystem (if the filesystem is independently accessed, the images MIGHT suddenly &quot;disappear&quot;), I'd go for storing them directly as a BLOB or such.</source>
          <target state="translated">Dado que las imágenes son los datos reales que se buscan,y que pueden ser manejados más fácilmente (las imágenes no desaparecerán repentinamente)en una base de datos integrada en lugar de tener que interactuar con algún tipo de sistema de archivos (si se accede al sistema de archivos de forma independiente,las imágenes PODRÍAN &quot;desaparecer&quot; repentinamente),yo optaría por almacenarlas directamente como un BLOB o algo así.</target>
        </trans-unit>
        <trans-unit id="50318af368b2cfc31a1990457660c45811f1519a" translate="yes" xml:space="preserve">
          <source>Heavier load on the database server</source>
          <target state="translated">Una carga más pesada en el servidor de la base de datos</target>
        </trans-unit>
        <trans-unit id="2476f13c8544e6adef83fe4356b9351e0dd56bf9" translate="yes" xml:space="preserve">
          <source>Here's an additional point to keep in mind.  One of the reasons supporting the use of a database to store the blobs is ACID compliance.  However, the approach that the testers used in the white paper, (Bulk Logged option of SQL Server,) which doubled SQL Server throughput, effectively changed the 'D' in ACID to a 'd,' as the blob data was not logged with the initial writes for the transaction.   Therefore, if full ACID compliance is an important requirement for your system, halve the SQL Server throughput figures for database writes when comparing file I/O to database blob I/O.</source>
          <target state="translated">Aquí hay un punto adicional a tener en cuenta.Una de las razones que apoyan el uso de una base de datos para almacenar los glóbulos es el cumplimiento del ACID.Sin embargo,el enfoque que los probadores utilizaron en el libro blanco,(Bulk Logged option of SQL Server,)que duplicó el rendimiento de SQL Server,efectivamente cambió la &quot;D&quot; en ACID a una &quot;d&quot;,ya que los datos de las manchas no se registraron con las escrituras iniciales de la transacción.Por lo tanto,si el cumplimiento total del ACID es un requisito importante para su sistema,reduzca a la mitad las cifras de rendimiento de SQL Server para las escrituras de la base de datos cuando compare la IO del archivo con la IO del blob de la base de datos.</target>
        </trans-unit>
        <trans-unit id="3328bee09e8c09e8968eeed0a2f9b66d9200e6cb" translate="yes" xml:space="preserve">
          <source>Here's an interesting white paper on the topic.</source>
          <target state="translated">Aquí hay un interesante libro blanco sobre el tema.</target>
        </trans-unit>
        <trans-unit id="62412dfc10888fe41ebeaad0772496979a681afc" translate="yes" xml:space="preserve">
          <source>Hopefully this isn't too much babble, but I saw the topic and wanted to provide some my insights from a relatively successful small/medium scale application.</source>
          <target state="translated">Espero que no sea demasiado balbuceo,pero vi el tema y quise proporcionar algunos de mis conocimientos de una aplicación relativamente exitosa a pequeña y mediana escala.</target>
        </trans-unit>
        <trans-unit id="1262cc4767f7bf18f546e1d6a4826b8fd28f94b6" translate="yes" xml:space="preserve">
          <source>However SQL's &quot;Transparent Data Encryption&quot; does not encrypt FileStream objects, so if that is a consideration, you may be better off just storing them as varbinary.</source>
          <target state="translated">Sin embargo,el &quot;Cifrado de datos transparente&quot; de SQL no cifra los objetos de FileStream,así que si eso es una consideración,puede que sea mejor almacenarlos como varbinarios.</target>
        </trans-unit>
        <trans-unit id="5450e7c1ad84e657a64129b1d482f97873657e65" translate="yes" xml:space="preserve">
          <source>I get to use transactions for edits to improve data integrity - I don't have to worry about orphaned and missing files</source>
          <target state="translated">Puedo usar las transacciones para editar y mejorar la integridad de los datos.No tengo que preocuparme por los archivos huérfanos y perdidos.</target>
        </trans-unit>
        <trans-unit id="cbd2819c808f7d8174170eae9048a48026eae2e0" translate="yes" xml:space="preserve">
          <source>I have recently created a PHP/MySQL app which stores PDFs/Word files in a MySQL table (as big as 40MB per file so far).</source>
          <target state="translated">Recientemente he creado una aplicación PHPMySQL que almacena archivos PDFsWord en una tabla MySQL (tan grande como 40MB por archivo hasta ahora).</target>
        </trans-unit>
        <trans-unit id="9d8548824f49d9a78947c14fec692cc06bb03454" translate="yes" xml:space="preserve">
          <source>I once worked on an image processing application. We stored the uploaded images in a directory that was something like /images/[today's date]/[id number]. But we also extracted the metadata (exif data) from the images and stored that in the database, along with a timestamp and such.</source>
          <target state="translated">Una vez trabajé en una aplicación de procesamiento de imágenes.Almacenamos las imágenes subidas en un directorio que era algo así como imágenes[fecha de hoy][número de identificación].Pero también extrajimos los metadatos (datos exif)de las imágenes y los almacenamos en la base de datos,junto con una marca de tiempo y demás.</target>
        </trans-unit>
        <trans-unit id="1a2a80f9309a684b0d97bad75e984f23663555da" translate="yes" xml:space="preserve">
          <source>I'd call my implementation a success, it takes care of backup requirements and simplifies the layout of the project. The performance is fine for the 20-30 people who use the app.</source>
          <target state="translated">Yo diría que mi implementación es un éxito,se ocupa de los requisitos de copia de seguridad y simplifica el diseño del proyecto.El rendimiento está bien para las 20-30 personas que usan la aplicación.</target>
        </trans-unit>
        <trans-unit id="29fa93b28f6e28a031496c25f93f96335b65852e" translate="yes" xml:space="preserve">
          <source>I'm in charge of some applications that manage many TB of images.  We've found that storing &lt;strong&gt;file paths&lt;/strong&gt; in the database to be best.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Estoy a cargo de algunas aplicaciones que manejan muchas TB de im&amp;aacute;genes. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Descubrimos que almacenar las &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;rutas de los archivos&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en la base de datos es lo mejor.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fecdc2255f2695e73f6dba95fc3e73d0bcd8d78" translate="yes" xml:space="preserve">
          <source>I'm not sure how much of a &quot;real world&quot; example this is, but I currently have an application out there that stores details for a trading card game, including the images for the cards. Granted the record count for the database is only 2851 records to date, but given the fact that certain cards have are released multiple times and have alternate artwork, it was actually more efficient sizewise to scan the &quot;primary square&quot; of the artwork and then dynamically generate the border and miscellaneous effects for the card when requested.</source>
          <target state="translated">No estoy seguro de que esto sea un ejemplo del &quot;mundo real&quot;,pero actualmente tengo una aplicación que almacena los detalles de un juego de cartas,incluyendo las imágenes de las cartas.Es cierto que el número de registros de la base de datos es sólo de 2851 registros hasta la fecha,pero dado el hecho de que ciertas cartas han sido lanzadas varias veces y tienen obras de arte alternativas,era realmente más eficiente en cuanto al tamaño escanear el &quot;cuadrado primario&quot; de la obra de arte y luego generar dinámicamente el borde y los efectos varios para la carta cuando se solicite.</target>
        </trans-unit>
        <trans-unit id="d25f4f7e4e4f9284bbb7f7af179d8762a4fab0e8" translate="yes" xml:space="preserve">
          <source>I'm surprised no one has really mentioned this ... delegate it out to others who are specialists -&amp;gt; &lt;strong&gt;use a 3rd party image/file hosting provider&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Me sorprende que nadie haya mencionado esto realmente ... delegarlo a otros especialistas -&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;usar un proveedor de alojamiento de im&amp;aacute;genes / archivos de terceros&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0bb19e735abac3d85de5cc543122acd3955a7a44" translate="yes" xml:space="preserve">
          <source>IMO, Pros of using database to store images are,</source>
          <target state="translated">OMI,las ventajas de usar la base de datos para almacenar imágenes son,</target>
        </trans-unit>
        <trans-unit id="67789d0ecde7d5223b48e5c0fd30688658e8dad1" translate="yes" xml:space="preserve">
          <source>If the actual image pointed to by the filepath becomes unavailable, the database unwittingly has an integrity error.</source>
          <target state="translated">Si la imagen real apuntada por la ruta de archivo no está disponible,la base de datos,sin saberlo,tiene un error de integridad.</target>
        </trans-unit>
        <trans-unit id="503989532211253730df23717fe63bd466c6f952" translate="yes" xml:space="preserve">
          <source>If this is web-based application then there could be advantages to storing the images on a third-party storage delivery network, such as Amazon's S3 or the Nirvanix platform.</source>
          <target state="translated">Si se trata de una aplicación basada en la web,entonces podría ser ventajoso almacenar las imágenes en una red de entrega de almacenamiento de terceros,como el S3 de Amazon o la plataforma Nirvanix.</target>
        </trans-unit>
        <trans-unit id="c3797548f46dc91bf7279b13b078981dc7232924" translate="yes" xml:space="preserve">
          <source>If you have your images in a file-system and someone is reading the file as you're writing a new version or even deleting the file - what happens?</source>
          <target state="translated">Si tienes tus imágenes en un sistema de archivos y alguien está leyendo el archivo mientras escribes una nueva versión o incluso lo borra,¿qué sucede?</target>
        </trans-unit>
        <trans-unit id="bbcc47c06384c94a6e71cd3ed29e7578f9b54e84" translate="yes" xml:space="preserve">
          <source>If you're not on SQL Server 2008 and you have some solid reasons for putting specific image files in the database, then you could take the &quot;both&quot; approach and use the file system as a temporary cache and use the database as the master repository.</source>
          <target state="translated">Si no está en SQL Server 2008 y tiene algunas razones sólidas para poner archivos de imagen específicos en la base de datos,entonces podría adoptar el enfoque de &quot;ambos&quot; y utilizar el sistema de archivos como un caché temporal y usar la base de datos como el repositorio maestro.</target>
        </trans-unit>
        <trans-unit id="104f4bfbbe4ba01a18a339e2ce0dee05761e7192" translate="yes" xml:space="preserve">
          <source>If you're on an older database, then I'd say that if you're storing it as blob data, then you're really not going to get anything out of the database in the way of searching features, so it's probably best to store an address on a filesystem, and store the image that way.</source>
          <target state="translated">Si estás en una base de datos más antigua,entonces diría que si la almacenas como datos blob,entonces realmente no vas a obtener nada de la base de datos en cuanto a las características de búsqueda,así que probablemente sea mejor almacenar una dirección en un sistema de archivos,y almacenar la imagen de esa manera.</target>
        </trans-unit>
        <trans-unit id="d3db3c02ef9c8ebaf43fb00a808ca6373d64cf93" translate="yes" xml:space="preserve">
          <source>If your images are going to be small (say &amp;lt; 64k) and the storage engine of your db supports inline (in record) BLOBs, it improves performance further as no indirection is required (Locality of reference is achieved).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si sus im&amp;aacute;genes van a ser peque&amp;ntilde;as (digamos &amp;lt;64k) y el motor de almacenamiento de su base de datos admite BLOB en l&amp;iacute;nea (en el registro), mejora a&amp;uacute;n m&amp;aacute;s el rendimiento ya que no se requiere indirecci&amp;oacute;n (se logra la localidad de referencia).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1367543dc2e57b8ae191b7f517c89168e8563b8d" translate="yes" xml:space="preserve">
          <source>Im my experience I had to manage both situations: images stored in database and images on the file system with path stored in db.</source>
          <target state="translated">Según mi experiencia,tuve que manejar ambas situaciones:imágenes almacenadas en la base de datos e imágenes en el sistema de archivos con la ruta almacenada en db.</target>
        </trans-unit>
        <trans-unit id="9403681db30c32ac40b3bcb94b6983848198b3a1" translate="yes" xml:space="preserve">
          <source>Images stored in the database do not require a different backup strategy. Images stored on filesystem do</source>
          <target state="translated">Las imágenes almacenadas en la base de datos no requieren una estrategia de respaldo diferente.Las imágenes almacenadas en el sistema de archivos sí</target>
        </trans-unit>
        <trans-unit id="d798c2480179e1f2ec28ad71a0ad5dd2ca9635ca" translate="yes" xml:space="preserve">
          <source>In a previous project i stored images on the filesystem, and that caused a lot of headaches with backups, replication, and the filesystem getting out of sync with the database.</source>
          <target state="translated">En un proyecto anterior almacené imágenes en el sistema de archivos,y eso causó muchos dolores de cabeza con las copias de seguridad,la replicación y el sistema de archivos desincronizándose con la base de datos.</target>
        </trans-unit>
        <trans-unit id="09863ac503085043491d30bf4f9111c47daca621" translate="yes" xml:space="preserve">
          <source>In my experience, sometimes the simplest solution is to &lt;strong&gt;name the images according to the primary key&lt;/strong&gt;. So it's easy to find the image that belongs to a particular record, and vice versa. But at the same time you're not storing &lt;em&gt;anything&lt;/em&gt; about the image in the database.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En mi experiencia, a veces la soluci&amp;oacute;n m&amp;aacute;s simple es &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;nombrar las im&amp;aacute;genes de acuerdo con la clave principal&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, es f&amp;aacute;cil encontrar la imagen que pertenece a un registro en particular, y viceversa. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero al mismo tiempo no est&amp;aacute; almacenando &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;nada&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sobre la imagen en la base de datos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f531513cb377ad06aa76b61e2ea34b52b9a15fdd" translate="yes" xml:space="preserve">
          <source>In my latest project i'm storing images in the database, and caching them on the filesystem, and it works really well. I've had no problems so far.</source>
          <target state="translated">En mi último proyecto estoy almacenando imágenes en la base de datos,y las almaceno en el sistema de archivos,y funciona muy bien.No he tenido problemas hasta ahora.</target>
        </trans-unit>
        <trans-unit id="09691af22dcb0a5e64c5ef4a1a4629569c883e0c" translate="yes" xml:space="preserve">
          <source>In places where you MUST guarantee referential integrity and ACID compliance, storing images in the database is required.</source>
          <target state="translated">En los lugares donde DEBE garantizar la integridad referencial y el cumplimiento del ACID,es necesario almacenar las imágenes en la base de datos.</target>
        </trans-unit>
        <trans-unit id="ea18a136284e24daa6223fb84ba253dcbfbee5f6" translate="yes" xml:space="preserve">
          <source>It depends on the number of images you are going to store and also their sizes. I have used databases to store images in the past and my experience has been fairly good.</source>
          <target state="translated">Depende del número de imágenes que vayas a almacenar y también de su tamaño.He usado bases de datos para almacenar imágenes en el pasado y mi experiencia ha sido bastante buena.</target>
        </trans-unit>
        <trans-unit id="9283765c13db752b531235978b65c8824a43fa27" translate="yes" xml:space="preserve">
          <source>It is easier to control access to the images if they are in a database. Idle admins can access any folder on disk. It takes a really determined admin to go snooping in a database to extract the images</source>
          <target state="translated">Es más fácil controlar el acceso a las imágenes si están en una base de datos.Los administradores ociosos pueden acceder a cualquier carpeta del disco.Se necesita un administrador realmente determinado para ir a husmear en una base de datos para extraer las imágenes</target>
        </trans-unit>
        <trans-unit id="86a122c21eed2b290e44b53668135ef815601820" translate="yes" xml:space="preserve">
          <source>It's so worth it. They store it efficiently. No bandwith getting uploaded from your servers to client requests, etc.</source>
          <target state="translated">Vale la pena.Lo almacenan eficientemente.No se sube el ancho de banda de sus servidores a las solicitudes de los clientes,etc.</target>
        </trans-unit>
        <trans-unit id="d1251f454e24d7233f5c1fa0583852723b715eb7" translate="yes" xml:space="preserve">
          <source>Latency may be
    slower than direct file access</source>
          <target state="translated">La latencia puede ser más lenta que el acceso directo a los archivos</target>
        </trans-unit>
        <trans-unit id="725eb7fb053ccc585c879ae0da4b122f6a9f14bc" translate="yes" xml:space="preserve">
          <source>Like most other things, It depends on the expected size and Budget.</source>
          <target state="translated">Como la mayoría de las otras cosas,depende del tamaño y el presupuesto esperado.</target>
        </trans-unit>
        <trans-unit id="8545dec1f4c27acaa5353a4c97f59593c52fe97e" translate="yes" xml:space="preserve">
          <source>Manage it like a regular table and have the performance of the file system.</source>
          <target state="translated">Gestionarlo como una mesa normal y tener el rendimiento del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="f658bc08163a361b68ecdcd9080d547dfa019aed" translate="yes" xml:space="preserve">
          <source>Migration &quot;just works&quot;.</source>
          <target state="translated">La migración &quot;sólo funciona&quot;.</target>
        </trans-unit>
        <trans-unit id="6968d452a081adacc8b53c63e98bbe9c46f66820" translate="yes" xml:space="preserve">
          <source>Moso Cloud Storage</source>
          <target state="translated">Almacenamiento en la nube</target>
        </trans-unit>
        <trans-unit id="8351a5f7f60b713223687b5b9fb0f91f10e65233" translate="yes" xml:space="preserve">
          <source>Needle in a Haystack: Efficient Storage of Billions of Photos</source>
          <target state="translated">Aguja en un pajar:Almacenamiento eficiente de miles de millones de fotos</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="f06cb0fe589979c389e198338ded5e8a7b144557" translate="yes" xml:space="preserve">
          <source>Normally, I'm storngly against taking the most expensive and hardest to scale part of your infrastructure (the database) and putting all load into it. On the other hand: It greatly simplifies backup strategy, especially when you have multiple web servers and need to somehow keep the data synchronized.</source>
          <target state="translated">Normalmente,estoy en contra de tomar la parte más cara y difícil de escalar de su infraestructura (la base de datos)y poner toda la carga en ella.Por otro lado:Simplifica enormemente la estrategia de copia de seguridad,especialmente cuando tienes múltiples servidores web y necesitas de alguna manera mantener los datos sincronizados.</target>
        </trans-unit>
        <trans-unit id="09f177c20b3e429783e2b3893764c0d0da902bd2" translate="yes" xml:space="preserve">
          <source>Obviously database access performance when you deal with binary large objects is degrading, and the database dimensions will grow a lot, causing again performance loss... and normally database space is much more expensive than file system space.</source>
          <target state="translated">Obviamente el rendimiento del acceso a la base de datos cuando se trata de objetos binarios grandes se está degradando,y las dimensiones de la base de datos crecerán mucho,causando de nuevo la pérdida de rendimiento...y normalmente el espacio de la base de datos es mucho más caro que el espacio del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="9287d0bca2c5656d1b260627af121123dac33b33" translate="yes" xml:space="preserve">
          <source>On the other hand having large binary objects stored in file system will cause you to have backup plans that have to consider both database and file system, and this can be an issue for some systems.</source>
          <target state="translated">Por otro lado,el hecho de tener grandes objetos binarios almacenados en el sistema de archivos hará que tenga planes de respaldo que deben considerar tanto la base de datos como el sistema de archivos,y esto puede ser un problema para algunos sistemas.</target>
        </trans-unit>
        <trans-unit id="e750b8bf3af0d850d7b1c3e5f654ec6d86914f3b" translate="yes" xml:space="preserve">
          <source>On the other hand there are problems associated</source>
          <target state="translated">Por otro lado,hay problemas asociados</target>
        </trans-unit>
        <trans-unit id="69d4c2a1a3cd8e2dc76d590ad7bcca2c66fa2e3a" translate="yes" xml:space="preserve">
          <source>Once common solution to this is to hash them out into a balanced tree of subdirectories.</source>
          <target state="translated">Una vez que la solución común a esto es hacerlos salir en un árbol equilibrado de subdirectorios.</target>
        </trans-unit>
        <trans-unit id="dffe608d3ed114e8a78297264f0fe42a01be2bdc" translate="yes" xml:space="preserve">
          <source>One thing that I haven't seen anyone mention yet but is definitely worth noting is that there are issues associated with storing large amounts of images in most filesystems too.  For example if you take the approach mentioned above and name each image file after the primary key, on most filesystems you will run into issues if you try to put all of the images in one big directory once you reach a very large number of images (e.g. in the hundreds of thousands or millions).</source>
          <target state="translated">Una cosa que no he visto a nadie mencionar todavía,pero que definitivamente vale la pena señalar,es que también hay problemas asociados con el almacenamiento de grandes cantidades de imágenes en la mayoría de los sistemas de archivos.Por ejemplo,si se toma el enfoque mencionado anteriormente y se nombra cada archivo de imagen con el nombre de la clave primaria,en la mayoría de los sistemas de archivos se encontrarán problemas si se intenta poner todas las imágenes en un gran directorio una vez que se llega a un número muy grande de imágenes (por ejemplo,en los cientos de miles o millones).</target>
        </trans-unit>
        <trans-unit id="d9a64c001c7d6c4d98225996f8dd95ddc6b72319" translate="yes" xml:space="preserve">
          <source>One thing to note here is that no one in the pro file system camp has listed a particular file system. Does this mean that everything from FAT16 to ZFS handily beats every database?</source>
          <target state="translated">Una cosa a tener en cuenta es que nadie en el campo de los sistemas de archivos profesionales ha enumerado un sistema de archivos en particular.¿Significa esto que todo,desde FAT16 hasta ZFS,supera a todas las bases de datos?</target>
        </trans-unit>
        <trans-unit id="daca8adfb2ce1f5899bcf3cc5dc33091198be70b" translate="yes" xml:space="preserve">
          <source>Overall not very memory/cpu efficient when compared to filesystem</source>
          <target state="translated">En general,no es muy eficiente en cuanto a la memorización en comparación con el sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="dc155c121b565754897ed082c978712827881b44" translate="yes" xml:space="preserve">
          <source>Probably, it would also allow you to throw some caching element, based on commonly hit image urls into your web engine/program, so you're saving yourself there as well.</source>
          <target state="translated">Probablemente,también le permitiría lanzar algún elemento de caché,basado en urls de imágenes comúnmente utilizadas en su programa de ingeniería web,por lo que se está salvando allí también.</target>
        </trans-unit>
        <trans-unit id="54b393721169f11c627d23e95f4e0bce01dc79eb" translate="yes" xml:space="preserve">
          <source>Require additional code to extract
and stream the images</source>
          <target state="translated">Requiere un código adicional para extraer y transmitir las imágenes</target>
        </trans-unit>
        <trans-unit id="bdd88b7d31c47d46b3476e67aa360525526c3160" translate="yes" xml:space="preserve">
          <source>SQL Server 2008 offers a solution that has the best of both worlds : &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;The filestream data type&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008 ofrece una soluci&amp;oacute;n que tiene lo mejor de ambos mundos: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el tipo de datos de flujo de archivos&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec236495b04b446b59d809893ff3e4466ca3fd51" translate="yes" xml:space="preserve">
          <source>Second the recommendation on file paths. I've worked on a couple of projects that needed to manage large-ish asset collections, and any attempts to store things directly in the DB resulted in pain and frustration long-term.</source>
          <target state="translated">Secundo la recomendación sobre las rutas de los archivos.He trabajado en un par de proyectos que necesitaban gestionar colecciones de activos de gran tamaño,y cualquier intento de almacenar cosas directamente en la base de datos resultó en dolor y frustración a largo plazo.</target>
        </trans-unit>
        <trans-unit id="7ecb8d1b499802e07c066d2d9c3ceee7493e96ab" translate="yes" xml:space="preserve">
          <source>Serving up images from a database is easy, just implement an http handler that serves the byte array returned from the DB server as a binary stream.</source>
          <target state="translated">Servir imágenes de una base de datos es fácil,sólo hay que implementar un manejador http que sirva la matriz de bytes devuelta por el servidor de la base de datos como un flujo binario.</target>
        </trans-unit>
        <trans-unit id="99962b21785a235b5e93d806ae6c3d7e37e621ce" translate="yes" xml:space="preserve">
          <source>Setting up the web server is slightly simpler because I don't need to have an uploads/ folder and tell all my applications where it is.</source>
          <target state="translated">Configurar el servidor web es un poco más simple porque no necesito tener una carpeta de subida y decirle a todas mis aplicaciones dónde está.</target>
        </trans-unit>
        <trans-unit id="e9b806b728121ce126b464af0bd80ee2afdf68c9" translate="yes" xml:space="preserve">
          <source>Small static images (not more than a couple of megs) that are not frequently edited, should be stored in the database. This method has several benefits including easier portability (images are transferred with the database), easier backup/restore (images are backed up with the database) and better scalability (a file system folder with thousands of little thumbnail files sounds like a scalability nightmare to me).</source>
          <target state="translated">En la base de datos se deben almacenar pequeñas imágenes estáticas (no más de un par de megas)que no se editan con frecuencia.Este método tiene varias ventajas,entre ellas una portabilidad más fácil (las imágenes se transfieren con la base de datos),una restauración de respaldo más fácil (las imágenes se respaldan con la base de datos)y una mejor escalabilidad (una carpeta del sistema de archivos con miles de pequeños archivos de miniaturas me suena como una pesadilla de escalabilidad).</target>
        </trans-unit>
        <trans-unit id="c77302484315f43d1b8825352fad38163e655d07" translate="yes" xml:space="preserve">
          <source>Smaller sized files can be efficiently stored and delivered using the database as the storage mechanism.  Larger files would probably be best stored using the file system, especially if they will be modified/updated often.  (blob fragmentation becomes an issue in regards to performance.)</source>
          <target state="translated">Los archivos de menor tamaño pueden almacenarse y entregarse eficientemente utilizando la base de datos como mecanismo de almacenamiento.Los archivos de mayor tamaño probablemente se almacenarán mejor utilizando el sistema de archivos,especialmente si se modifican y actualizan con frecuencia.(La fragmentación de los blob se convierte en un problema en lo que respecta al rendimiento).</target>
        </trans-unit>
        <trans-unit id="714b035f21ed87fb37883666dfce0caea714ccc8" translate="yes" xml:space="preserve">
          <source>So I'm using an app that stores images heavily in the DB. What's your outlook on this? I'm more of a type to store the location in the filesystem, than store it directly in the DB.</source>
          <target state="translated">Así que estoy usando una aplicación que almacena muchas imágenes en la base de datos.¿Qué opinas de esto? Soy más del tipo que almacena la ubicación en el sistema de archivos,que la almacena directamente en la BD.</target>
        </trans-unit>
        <trans-unit id="6dccf67eb0ddd77e8bfbc72fb16de2a45d5b6cae" translate="yes" xml:space="preserve">
          <source>Something nobody has mentioned is that the DB guarantees atomic actions, transactional integrity and deals with concurrency. Even referentially integrity is out of the window with a filesystem - so how do you know your file names are really still correct?</source>
          <target state="translated">Algo que nadie ha mencionado es que la DB garantiza las acciones atómicas,la integridad de las transacciones y se ocupa de la concurrencia.Incluso la integridad referencial está fuera de la ventana con un sistema de archivos,así que ¿cómo sabes que los nombres de tus archivos siguen siendo correctos?</target>
        </trans-unit>
        <trans-unit id="8af055bdbe7670239d44aa860e0890dd569e962b" translate="yes" xml:space="preserve">
          <source>Store your files on a paid online service like</source>
          <target state="translated">Almacena tus archivos en un servicio online de pago como</target>
        </trans-unit>
        <trans-unit id="1a3781484823414d3725393bd2bf249b5bee6d6c" translate="yes" xml:space="preserve">
          <source>Storing Images in DB - Yea or Nay</source>
          <target state="translated">Almacenamiento de imágenes en la BD-Sí o no</target>
        </trans-unit>
        <trans-unit id="d5edc6aeda738e7a8d9506f8a9a0366272625476" translate="yes" xml:space="preserve">
          <source>Storing an image in the database still means that the image data ends up somewhere in the file system but obscured so that you cannot access it directly.</source>
          <target state="translated">Almacenar una imagen en la base de datos sigue significando que los datos de la imagen terminan en algún lugar del sistema de archivos pero oscurecidos para que no se pueda acceder a ellos directamente.</target>
        </trans-unit>
        <trans-unit id="83e9a8f9902db2ab45aab8a68857232f91f8f817" translate="yes" xml:space="preserve">
          <source>Storing images may be a bad idea when you are dealing with small number of huge sized images. Another problem with storing images in db is that, metadata like creation, modification dates must handled by your application.</source>
          <target state="translated">Almacenar imágenes puede ser una mala idea cuando se trata de un pequeño número de imágenes de gran tamaño.Otro problema con el almacenamiento de imágenes en db es que,los metadatos como la creación,las fechas de modificación deben ser manejadas por su aplicación.</target>
        </trans-unit>
        <trans-unit id="fc7ebe3f5c8fa7bb3211919a811fe054ebec3fde" translate="yes" xml:space="preserve">
          <source>That seems like it would be better solved with an intermediary script pulling data from a web-inaccessible file store, though. So the DB storage isn't REALLY necessary.</source>
          <target state="translated">Sin embargo,parece que se resolvería mejor con un guión intermediario que extraiga los datos de un almacén de archivos accesible a través de la web.Así que el almacenamiento de la base de datos no es REALMENTE necesario.</target>
        </trans-unit>
        <trans-unit id="e507594d631333c78e791861af1df08eda58c6dd" translate="yes" xml:space="preserve">
          <source>That way you also save space on your filesystem, as you are only going to save the exact amount of space, or even compacted space on the filesystem.</source>
          <target state="translated">De esta manera también se ahorra espacio en el sistema de archivos,ya que sólo se va a ahorrar la cantidad exacta de espacio,o incluso espacio compactado en el sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="aa8930f1feae478f1bcc7944864a710d55955741" translate="yes" xml:space="preserve">
          <source>The Blobs are actually stored as files in a folder.</source>
          <target state="translated">Los Blobs se almacenan en realidad como archivos en una carpeta.</target>
        </trans-unit>
        <trans-unit id="dac8ad2eb459eb9d8f5d901be3595fff1497aa53" translate="yes" xml:space="preserve">
          <source>The Blobs can be accessed using &lt;em&gt;either&lt;/em&gt; a database connection &lt;em&gt;or&lt;/em&gt; over the filesystem.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las burbujas se puede acceder usando &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ya sea&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; una conexi&amp;oacute;n de base &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;o&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sobre el sistema de ficheros.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26f263ae32cfbdb323507d0b4a4dbcc181aa7185" translate="yes" xml:space="preserve">
          <source>The answer is &quot;It depends.&quot;  Certainly it would depend upon the database server and its approach to blob storage.  It also depends on the type of data being stored in blobs, as well as how that data is to be accessed.</source>
          <target state="translated">La respuesta es &quot;depende&quot;.Ciertamente dependería del servidor de la base de datos y su enfoque del almacenamiento de blob.También depende del tipo de datos que se almacenan en los blob,así como de cómo se va a acceder a esos datos.</target>
        </trans-unit>
        <trans-unit id="398e9d6490298e990e2ac82498c6a4997352591a" translate="yes" xml:space="preserve">
          <source>The correct course of action is to make the right decision for your precise scenario, and to do that, you'll need some numbers and some use case estimates.</source>
          <target state="translated">El curso de acción correcto es tomar la decisión correcta para su escenario preciso,y para hacerlo,necesitará algunos números y algunas estimaciones de casos de uso.</target>
        </trans-unit>
        <trans-unit id="a3ff707b3146ba5858644a13add5404689ca1dac" translate="yes" xml:space="preserve">
          <source>The first solution, images in database, is somewhat &quot;cleaner&quot; as your data access layer will have to deal only with database objects; but this is good only when you have to deal with low numbers.</source>
          <target state="translated">La primera solución,las imágenes en la base de datos,es algo &quot;más limpia&quot; ya que su capa de acceso a los datos tendrá que ocuparse sólo de los objetos de la base de datos;pero esto sólo es bueno cuando se trata de números bajos.</target>
        </trans-unit>
        <trans-unit id="99b1b7fb03c27b12dd7a97fbe5cba9dedbf6f7d3" translate="yes" xml:space="preserve">
          <source>The government wants you to maintain 6 years of history</source>
          <target state="translated">El gobierno quiere que mantengas 6 años de historia</target>
        </trans-unit>
        <trans-unit id="be8c1d64425fb81ddff96737d2195647616aeedb" translate="yes" xml:space="preserve">
          <source>The only real &quot;pro&quot; I can think of regarding storing them in the DB is the potential for easy of individual image assets. If there are no file paths to use, and all images are streamed straight out of the DB, there's no danger of a user finding files they shouldn't have access to.</source>
          <target state="translated">El único &quot;pro&quot; real que se me ocurre en relación con el almacenamiento en la base de datos es el potencial de los activos de imagen individual fácil.Si no hay rutas de archivo que usar,y todas las imágenes se transmiten directamente de la DB,no hay peligro de que un usuario encuentre archivos a los que no debería tener acceso.</target>
        </trans-unit>
        <trans-unit id="b6df983ec2f8655d79d2d357cb2d842ac9c202c5" translate="yes" xml:space="preserve">
          <source>The original creator of this image library created a data access class that renders the image based on the request, and it does it quite fast for viewing and individual card.</source>
          <target state="translated">El creador original de esta biblioteca de imágenes creó una clase de acceso a los datos que renderiza la imagen en base a la solicitud,y lo hace bastante rápido para la visualización y la tarjeta individual.</target>
        </trans-unit>
        <trans-unit id="21e9b5d795f89df6924b68d2e63f969592671fda" translate="yes" xml:space="preserve">
          <source>The problem with storing only filepaths to images in a database is that the database's integrity can no longer be forced.</source>
          <target state="translated">El problema de almacenar sólo las rutas de acceso a las imágenes en una base de datos es que la integridad de la base de datos ya no puede ser forzada.</target>
        </trans-unit>
        <trans-unit id="f33c90f1fc426daa04efefb0038c1e8f22a9e375" translate="yes" xml:space="preserve">
          <source>The trick here is to not become a zealot.</source>
          <target state="translated">El truco aquí es no convertirse en un fanático.</target>
        </trans-unit>
        <trans-unit id="d8f59a378f87933d06e892653ff4a82c884cf319" translate="yes" xml:space="preserve">
          <source>The truth is that many databases beat many files systems, even when we're only talking about raw speed.</source>
          <target state="translated">La verdad es que muchas bases de datos superan a muchos sistemas de archivos,incluso cuando sólo hablamos de velocidad bruta.</target>
        </trans-unit>
        <trans-unit id="c2d423a32b108506f0bfd6455f1f96019a07f538" translate="yes" xml:space="preserve">
          <source>The word on the street is that unless you are a database vendor trying to prove that your database can do it (like, let's say Microsoft boasting about Terraserver storing a bajillion images in SQL Server) it's not a very good idea. When the alternative - storing images on file servers and paths in the database is so much easier, why bother? Blob fields are kind of like the off-road capabilities of SUVs - most people don't use them, those who do usually get in trouble, and then there are those who do, but only for the fun of it.</source>
          <target state="translated">Se dice que a menos que seas un vendedor de bases de datos tratando de probar que tu base de datos puede hacerlo (como,digamos que Microsoft se jacta de que Terraserver almacena un billón de imágenes en SQL Server)no es una muy buena idea.Cuando la alternativa-almacenar imágenes en servidores de archivos y rutas en la base de datos es mucho más fácil,¿por qué molestarse? Los campos de manchas son como las capacidades de los todoterreno,la mayoría de la gente no los usa,los que lo hacen suelen tener problemas,y luego están los que lo hacen,pero sólo por diversión.</target>
        </trans-unit>
        <trans-unit id="36730b9cc2f305e81fe3cdc4abe7056400f5a97f" translate="yes" xml:space="preserve">
          <source>There are a couple of issues:</source>
          <target state="translated">Hay un par de problemas:</target>
        </trans-unit>
        <trans-unit id="f29edf34e1917d1906a7773ea48427778e05cd8a" translate="yes" xml:space="preserve">
          <source>This also eases deployment/updates when new cards are released, instead of zipping up an entire folder of images and sending those down the pipe and ensuring the proper folder structure is created, I simply update the database and have the user download it again. This currently sizes up to 56MB, which isn't great, but I'm working on an incremental update feature for future releases. In addition, there is a &quot;no images&quot; version of the application that allows those over dial-up to get the application without the download delay.</source>
          <target state="translated">Esto también facilita las actualizaciones de despliegue cuando se liberan nuevas tarjetas,en lugar de cerrar una carpeta entera de imágenes y enviarlas por el caño y asegurar que se cree la estructura de carpetas adecuada,simplemente actualizo la base de datos y hago que el usuario la descargue de nuevo.Esto actualmente tiene un tamaño de hasta 56MB,lo cual no es genial,pero estoy trabajando en una característica de actualización incremental para futuros lanzamientos.Además,hay una versión &quot;sin imágenes&quot; de la aplicación que permite a los que llaman por teléfono obtener la aplicación sin el retraso de la descarga.</target>
        </trans-unit>
        <trans-unit id="d2559b6884c2c3166252cf8317c08d9d7192227f" translate="yes" xml:space="preserve">
          <source>This might be a bit of a long shot, but if you're using (or planning on using) SQL Server 2008 I'd recommend having a look at the new &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;FileStream&lt;/a&gt; data type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto podr&amp;iacute;a ser un poco arriesgado, pero si est&amp;aacute; utilizando (o planea utilizar) SQL Server 2008, le recomendar&amp;iacute;a que eche un vistazo al nuevo &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tipo de datos &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FileStream&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5de5ed2ad95580ae9860ae51bb53fb858569f0c9" translate="yes" xml:space="preserve">
          <source>This solution has worked great to date since the application itself is targeted as a single instance on the desktop. There is a web site where all of this data is archived for online access, but I would in no way use the same solution for this. I agree the file access would be preferable because it would scale better to the frequency and volume of requests being made for the images.</source>
          <target state="translated">Esta solución ha funcionado muy bien hasta la fecha,ya que la aplicación en sí misma está orientada a una sola instancia en el escritorio.Hay un sitio web donde todos estos datos se archivan para el acceso en línea,pero de ninguna manera usaría la misma solución para esto.Estoy de acuerdo en que el acceso al archivo sería preferible porque se escalaría mejor a la frecuencia y el volumen de las solicitudes que se hacen para las imágenes.</target>
        </trans-unit>
        <trans-unit id="7a9f42b006e68507b2bf93c3dc35393a93370b8e" translate="yes" xml:space="preserve">
          <source>To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem</source>
          <target state="translated">BLOBAR o no BLOBAR:Almacenamiento de objetos grandes en una base de datos o un sistema de archivos</target>
        </trans-unit>
        <trans-unit id="115c5ce402f46dd63900f8651dbc2e3d209abf85" translate="yes" xml:space="preserve">
          <source>Transact-SQL statements can insert, update, query, search, and back up FILESTREAM data. Win32 file system interfaces provide streaming access to the data.</source>
          <target state="translated">Las declaraciones Transact-SQL pueden insertar,actualizar,consultar,buscar y hacer copias de seguridad de los datos de FILESTREAM.Las interfaces del sistema de archivos Win32 proporcionan un acceso en flujo a los datos.</target>
        </trans-unit>
        <trans-unit id="c939e193a50e38ae5295ae364bae62a85fc25476" translate="yes" xml:space="preserve">
          <source>Uploaded files are replicated to backup server along with everything else, no separate backup strategy is needed (peace of mind).</source>
          <target state="translated">Los archivos cargados se replican en el servidor de respaldo junto con todo lo demás,no se necesita una estrategia de respaldo por separado (tranquilidad).</target>
        </trans-unit>
        <trans-unit id="8fb23687e4739bac5fa4b49b3b6e933f9284f922" translate="yes" xml:space="preserve">
          <source>We have implemented a document imaging system that stores all it's images in SQL2005 blob fields.  There are several hundred GB at the moment and we are seeing excellent response times and little or no performance degradation. In addition, fr regulatory compliance, we have a middleware layer that archives newly posted documents to an optical jukebox system which exposes them as a standard NTFS file system.</source>
          <target state="translated">Hemos implementado un sistema de imágenes de documentos que almacena todas sus imágenes en los campos de blob de SQL2005.Hay varios cientos de GB en este momento y estamos viendo excelentes tiempos de respuesta y poca o ninguna degradación del rendimiento.Además,en cumplimiento de la normativa de fr,tenemos una capa de middleware que archiva los documentos recién publicados en un sistema de jukebox óptico que los expone como un sistema de archivos NTFS estándar.</target>
        </trans-unit>
        <trans-unit id="fdbbc258fb96a990b2231e7642581c54c943bfea" translate="yes" xml:space="preserve">
          <source>We use blobs because they're easier to manage (backup, replication, transfer) too. They work well for us.</source>
          <target state="translated">Usamos los blobs porque son más fáciles de manejar (copia de seguridad,replicación,transferencia)también.Funcionan bien para nosotros.</target>
        </trans-unit>
        <trans-unit id="92bec75ea6ee7bd3cc26a274361ce400ab17e448" translate="yes" xml:space="preserve">
          <source>We've been very pleased with the results, particularly with respect to:</source>
          <target state="translated">Estamos muy contentos con los resultados,en particular con respecto a..:</target>
        </trans-unit>
        <trans-unit id="7ef90e6354471827cade517de2c173b8991b7175" translate="yes" xml:space="preserve">
          <source>What do you think are the pros/cons?</source>
          <target state="translated">¿Qué crees que son los proscones?</target>
        </trans-unit>
        <trans-unit id="87de9781c77b14deca711032ac785da434dcb2f0" translate="yes" xml:space="preserve">
          <source>You are storing images that are
changing dynamically, say invoices and you wanted
to get an invoice as it was on 1 Jan
2007?</source>
          <target state="translated">¿Estás almacenando imágenes que cambian dinámicamente,por ejemplo,facturas y querías obtener una factura como la del 1 de enero de 2007?</target>
        </trans-unit>
        <trans-unit id="95453050e6c680a8686d784628d69b7341319e48" translate="yes" xml:space="preserve">
          <source>You cannot transactionaly guarantee that the image and the meta-data about that image stored in the database refer to the same file. In other words, it is impossible to guarantee that the file on the filesystem is only ever altered at the same time and in the same transaction as the metadata.</source>
          <target state="translated">No se puede garantizar transaccionalmente que la imagen y los metadatos sobre esa imagen almacenados en la base de datos se refieran al mismo archivo.En otras palabras,es imposible garantizar que el archivo del sistema de archivos sólo se modifique al mismo tiempo y en la misma transacción que los metadatos.</target>
        </trans-unit>
        <trans-unit id="44ac3e04ec087585e18c01c02894782e6ec3abfb" translate="yes" xml:space="preserve">
          <source>database integrity</source>
          <target state="translated">integridad de la base de datos</target>
        </trans-unit>
        <trans-unit id="4b227f33a30575522e0591fdc96075df02b8e35c" translate="yes" xml:space="preserve">
          <source>database storage is usually more expensive than file system storage</source>
          <target state="translated">el almacenamiento de la base de datos suele ser más caro que el almacenamiento del sistema de archivos</target>
        </trans-unit>
        <trans-unit id="ddbdd288dca0200556d991307329fa940b415ca3" translate="yes" xml:space="preserve">
          <source>databases win out where transactional integrity between the image and metadata are important.</source>
          <target state="translated">las bases de datos ganan cuando la integridad de las transacciones entre la imagen y los metadatos son importantes.</target>
        </trans-unit>
        <trans-unit id="7bb6a86f7fb04a200fe53244cac70f7908c2d1b9" translate="yes" xml:space="preserve">
          <source>for example, many web servers use the operating system's &lt;strong&gt;sendfile()&lt;/strong&gt; system call to asynchronously send a file directly from the file system to the network interface. Images stored in a database don't benefit from this optimization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;por ejemplo, muchos servidores web usan la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;llamada al &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sistema &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sendfile () del&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sistema &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;operativo &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;para enviar un archivo de forma as&amp;iacute;ncrona directamente desde el sistema de archivos a la interfaz de red. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las im&amp;aacute;genes almacenadas en una base de datos no se benefician de esta optimizaci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f66131dba234d08d3eccc828f035e8d23ef4236f" translate="yes" xml:space="preserve">
          <source>it is difficult (within the context of a web application) to guarantee data has been flushed to disk on the filesystem</source>
          <target state="translated">es difícil (en el contexto de una aplicación web)garantizar que los datos se han volcado al disco en el sistema de archivos</target>
        </trans-unit>
        <trans-unit id="539156605d769e1ec2dfda3fa9f1f2a30afd98dd" translate="yes" xml:space="preserve">
          <source>it is more complex to manage integrity between db metadata and file system data</source>
          <target state="translated">es más complejo gestionar la integridad entre los metadatos de la db y los datos del sistema de archivos</target>
        </trans-unit>
        <trans-unit id="273eb3dac5c5806c6a187bffbf5eafcde1e5c03f" translate="yes" xml:space="preserve">
          <source>its easy to manage since you don't have to worry about keeping the filesystem in sync when an image is added or deleted</source>
          <target state="translated">es fácil de manejar ya que no tienes que preocuparte por mantener el sistema de archivos sincronizado cuando se añade o elimina una imagen</target>
        </trans-unit>
        <trans-unit id="0645e0631b812e6d0a5b9edfab265477559eae84" translate="yes" xml:space="preserve">
          <source>mysqldump now takes a looooong time because there is 500MB of file data in one of the tables.</source>
          <target state="translated">mysqldump ahora tarda mucho tiempo porque hay 500MB de datos de archivo en una de las tablas.</target>
        </trans-unit>
        <trans-unit id="eec549ffab2d7fa439d6d8ec4a58c0aaba832e68" translate="yes" xml:space="preserve">
          <source>performance penalty -- a database lookup is usually slower that a filesystem lookup</source>
          <target state="translated">penalización de rendimiento:una búsqueda en la base de datos suele ser más lenta que una búsqueda en el sistema de archivos</target>
        </trans-unit>
        <trans-unit id="537460e5682fdff5f1d8e31539381c0231a54a01" translate="yes" xml:space="preserve">
          <source>things like web servers, etc, need no special coding or processing to access images in the file system</source>
          <target state="translated">cosas como servidores web,etc,no necesitan una codificación o procesamiento especial para acceder a las imágenes en el sistema de archivos</target>
        </trans-unit>
        <trans-unit id="bf4a731866ccbf17f3e091f10fb7389e8354afe9" translate="yes" xml:space="preserve">
          <source>you can super-accelerate file system access with standard off the shelf products</source>
          <target state="translated">puedes acelerar el acceso al sistema de archivos con productos estándar.</target>
        </trans-unit>
        <trans-unit id="4db94e2f04aaa1263e7013679bcdf21bbcf8d6f6" translate="yes" xml:space="preserve">
          <source>you cannot edit the image directly (crop, resize)</source>
          <target state="translated">no se puede editar la imagen directamente (recortar,redimensionar)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
