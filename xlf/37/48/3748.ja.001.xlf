<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3748">
    <body>
      <group id="3748">
        <trans-unit id="47c3aaa77395e894593329e3bdb56a462542e81a" translate="yes" xml:space="preserve">
          <source>+ves:</source>
          <target state="translated">+ves:</target>
        </trans-unit>
        <trans-unit id="5dcc67d3b3974bde67a1dfbe489b0bf1470ca12c" translate="yes" xml:space="preserve">
          <source>-ves:</source>
          <target state="translated">-ves:</target>
        </trans-unit>
        <trans-unit id="df2eb94a6b01c34ef601502e19e10d652b46439d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;This thread&lt;/a&gt; explains why you should use a 3rd party hosting provider.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;このスレッドで&lt;/a&gt;は、サードパーティのホスティングプロバイダーを使用する理由について説明します。</target>
        </trans-unit>
        <trans-unit id="b616c405d40078118403f0f28e9e2f410c4eb6eb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Assumption: Application is web enabled/web based&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;前提：アプリケーションはWeb対応/ Webベースである&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a68ce6032c3740fd013d6c9b66b882246d9cf06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e3161fd669d07159e3a7475c999f77628c85246" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c202eefcc3c874230f5d8c6563173cba8693635" translate="yes" xml:space="preserve">
          <source>A. You don't need FS structure to hold your images</source>
          <target state="translated">A.画像を保持するためのFS構造体は必要ありません。</target>
        </trans-unit>
        <trans-unit id="270426116340bdc0cd86224583f5d3877de93a8b" translate="yes" xml:space="preserve">
          <source>Ability to easily implement a document versioning system</source>
          <target state="translated">文書のバージョン管理システムを簡単に導入できる能力</target>
        </trans-unit>
        <trans-unit id="c7b27ed64e40c36b897240dcbfc2315467a72a1a" translate="yes" xml:space="preserve">
          <source>Also, you could decide to save with some structure or elements that allow you to browse the raw images in your filesystem without any db hits, or transfer the files in bulk to another system, hard drive, S3 or another scenario - updating the location in your program, but keep the structure, again without much of a hit trying to bring the images out of your db when trying to increase storage.</source>
          <target state="translated">また、ファイルシステム内の生の画像をdbにヒットせずに閲覧できるような構造や要素で保存することもできますし、別のシステム、ハードドライブ、S3や別のシナリオに一括でファイルを転送することもできます-あなたのプログラム内の場所を更新しますが、構造は維持します。</target>
        </trans-unit>
        <trans-unit id="7b11a4234011e35a6c31048c3a964862b6e69ee8" translate="yes" xml:space="preserve">
          <source>Amazon S3</source>
          <target state="translated">アマゾンS3</target>
        </trans-unit>
        <trans-unit id="806863a20fd9521591c93b6ce2c193c0342f405d" translate="yes" xml:space="preserve">
          <source>Another StackOverflow threads talking about this &lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">これについて&lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;ここで&lt;/a&gt;話している別のStackOverflowスレッド。</target>
        </trans-unit>
        <trans-unit id="4137b28bbb9fcf80d76df94dcc9ea52f9b414a06" translate="yes" xml:space="preserve">
          <source>Another reason to go for file system is when you have to share your images data (or sounds, video, whatever) with third party access: in this days I'm developing a web app that uses images that have to be accessed from &quot;outside&quot; my web farm in such a way that a database access to retrieve binary data is simply impossible. So sometimes there are also design considerations that will drive you to a choice.</source>
          <target state="translated">ファイルシステムを選択するもう一つの理由は、画像データ(またはサウンド、ビデオなど)をサードパーティのアクセスと共有しなければならない場合です。だから時々、選択に駆り立てるようなデザイン上の配慮もあります。</target>
        </trans-unit>
        <trans-unit id="6e76a3d1c0a59c96f4904844811645326c89b249" translate="yes" xml:space="preserve">
          <source>As others have said SQL 2008 comes with a Filestream type that allows you to store a filename or identifier as a pointer in the db and automatically stores the image on your filesystem which is a great scenario.</source>
          <target state="translated">他の人も言っていますが、SQL 2008にはFilestreamタイプがあり、ファイル名や識別子をポインターとしてデータベースに保存することができ、自動的にファイルシステムにイメージを保存することができます。</target>
        </trans-unit>
        <trans-unit id="9b2634f0ec6106d9f9147e4cd3dff1615adeba37" translate="yes" xml:space="preserve">
          <source>As with most issues, it's not as simple as it sounds. There are cases where it would make sense to store the images in the database.</source>
          <target state="translated">ほとんどの問題と同様に、これは思ったほど単純なことではありません。データベースに画像を保存することが理にかなっている場合もあります。</target>
        </trans-unit>
        <trans-unit id="2a35d366d9a1eb88fd629e03b09b4bdd7c8a046d" translate="yes" xml:space="preserve">
          <source>At a company where I used to work we stored 155 million images in an Oracle 8i (then 9i) database. 7.5TB worth.</source>
          <target state="translated">私が以前働いていた会社では、Oracle 8i(当時は9i)のデータベースに1億5500万枚の画像を保存していました。7.5TBの価値がありました。</target>
        </trans-unit>
        <trans-unit id="687370ce64f7e2dd0384ee8f207a893b7096ffc1" translate="yes" xml:space="preserve">
          <source>B. Database indexes perform better than FS trees when more number of items are to be stored</source>
          <target state="translated">B.データベースインデックスは,格納する項目数が多い場合には,FS木よりも性能が良い.</target>
        </trans-unit>
        <trans-unit id="848d820eb3eab4f745688973041d4a9d217d5075" translate="yes" xml:space="preserve">
          <source>Backups are integrated.</source>
          <target state="translated">バックアップは統合されています。</target>
        </trans-unit>
        <trans-unit id="c8dd18981a74439309d7966c8a027a8cc858d9b3" translate="yes" xml:space="preserve">
          <source>Both methods are common and practiced. Have a look at the advantages and disadvantages. Either way, you'll have to think about how to overcome the disadvantages. Storing in database usually means tweaking database parameters and implement some kind of caching. Using filesystem requires you to find some way of keeping filesystem+database in sync.</source>
          <target state="translated">どちらの方法も一般的で実践されている方法です。メリットとデメリットを見てみましょう。どちらにしても、デメリットを克服する方法を考えなければなりません。データベースに格納するということは、通常、データベースのパラメータをいじったり、何らかのキャッシングを実装したりすることを意味します。ファイルシステムを使うには、ファイルシステムとデータベースを同期させる方法を見つける必要があります。</target>
        </trans-unit>
        <trans-unit id="6b99be15334afb0e1fb922b7dd040aa5dd83e1d3" translate="yes" xml:space="preserve">
          <source>C. Smartly tuned database perform good job at caching the query results</source>
          <target state="translated">C.賢く調整されたデータベースは、クエリの結果をキャッシュする際に良い仕事を実行します。</target>
        </trans-unit>
        <trans-unit id="a9fa41cd24ffd5f1e44c7dadd97884e69eb206be" translate="yes" xml:space="preserve">
          <source>Consider also, when making this choice, if you have to deal with permission and authentication when accessing binary objects: these requisites normally can be solved in an easier way when data are stored in db.</source>
          <target state="translated">バイナリオブジェクトにアクセスする際にパーミッションと認証を処理しなければならない場合も、この選択をする際に考慮してください。</target>
        </trans-unit>
        <trans-unit id="bfb124dc6fc8752f003971d881d4cc87007a2d3f" translate="yes" xml:space="preserve">
          <source>D. Backups are simple. It also works well if you have replication set up and content is delivered from a server near to user. In such cases, explicit synchronization is not required.</source>
          <target state="translated">D.バックアップは簡単です。また、レプリケーションが設定されていて、ユーザーに近いサーバーからコンテンツが配信されている場合もうまく機能します。このような場合、明示的な同期は必要ありません。</target>
        </trans-unit>
        <trans-unit id="b1a5dae551b12236616319e0bb35a5bf5f6335cf" translate="yes" xml:space="preserve">
          <source>Ease of Replication and Backup</source>
          <target state="translated">レプリケーションとバックアップの容易さ</target>
        </trans-unit>
        <trans-unit id="e22bfbeb8bec5e7cafa254beae090269060a8e07" translate="yes" xml:space="preserve">
          <source>FILESTREAM uses the NT system cache for caching file data. This helps reduce any effect that FILESTREAM data might have on Database Engine performance. The SQL Server buffer pool is not used; therefore, this memory is available for query processing.</source>
          <target state="translated">FILESTREAM はファイルデータをキャッシュするために NT システムキャッシュを使用します。これは、FILESTREAM データがデータベースエンジンのパフォーマンスに与える影響を軽減するのに役立ちます。SQL Server バッファプールは使用されませんので、このメモリはクエリ処理に使用できます。</target>
        </trans-unit>
        <trans-unit id="4154c203e6cd021be2b375052abd91fd364f29f1" translate="yes" xml:space="preserve">
          <source>File paths in the DB is &lt;strong&gt;definitely&lt;/strong&gt; the way to go - I've heard story after story from customers with TB of images that it became a nightmare trying to store any significant amount of images in a DB - the performance hit alone is too much.</source>
          <target state="translated">DB内のファイルパスは&lt;strong&gt;間違いなく&lt;/strong&gt;進むべき道です。TBの画像を使用しているお客様から、DBに大量の画像を保存しようとすると悪夢になるという話を次々に聞きました。パフォーマンスヒットだけでは大きすぎます。</target>
        </trans-unit>
        <trans-unit id="6b58164fc134ce748db8ca4b2d2da4a94bd28c0b" translate="yes" xml:space="preserve">
          <source>File store.  Facebook engineers had a great talk about it.  One take away was to know the practical limit of files in a directory.</source>
          <target state="translated">ファイルストア。Facebookのエンジニアがすごい話をしていました。テイクアウトの一つは、ディレクトリ内のファイルの実用的な限界を知ることでした。</target>
        </trans-unit>
        <trans-unit id="f506183fe93fe32acd9c9e9fa5b2e25dae72a188" translate="yes" xml:space="preserve">
          <source>FileStream solves most of the problems around storing the files in the DB:</source>
          <target state="translated">FileStreamは、DBにファイルを格納する際の問題点のほとんどを解決します。</target>
        </trans-unit>
        <trans-unit id="775382eda387b2f309209bbe52ea023bc8423554" translate="yes" xml:space="preserve">
          <source>For example, your business logic can check if an image file exists on disc before serving it up, retrieving from the database when necessary. This buys you the capability of multiple web servers and fewer sync issues.</source>
          <target state="translated">例えば、ビジネスロジックでは、画像ファイルがディスク上に存在するかどうかをチェックしてから提供し、必要に応じてデータベースから取得することができます。これにより、複数のウェブサーバーの機能が得られ、同期の問題が少なくなります。</target>
        </trans-unit>
        <trans-unit id="2b7110a6687a3b55c76c2091298794787912727c" translate="yes" xml:space="preserve">
          <source>From the MSDN Article:</source>
          <target state="translated">MSDNの記事より。</target>
        </trans-unit>
        <trans-unit id="7ec65d66d8967edd541ee0ea7f4da0f56133cc62" translate="yes" xml:space="preserve">
          <source>Given that the images are the actual data being sought after, and that they can be managed easier (the images won't suddenly disappear) in one integrated database rather than having to interface with some kind of filesystem (if the filesystem is independently accessed, the images MIGHT suddenly &quot;disappear&quot;), I'd go for storing them directly as a BLOB or such.</source>
          <target state="translated">画像は実際に求められているデータであり、ある種のファイルシステムとのインターフェースを必要とするよりも(ファイルシステムが独立してアクセスされた場合、画像は突然「消える」可能性があります)、統合されたデータベースで管理する方が簡単です(画像は突然消えることはありません)。</target>
        </trans-unit>
        <trans-unit id="50318af368b2cfc31a1990457660c45811f1519a" translate="yes" xml:space="preserve">
          <source>Heavier load on the database server</source>
          <target state="translated">データベースサーバーの負荷が高くなる</target>
        </trans-unit>
        <trans-unit id="2476f13c8544e6adef83fe4356b9351e0dd56bf9" translate="yes" xml:space="preserve">
          <source>Here's an additional point to keep in mind.  One of the reasons supporting the use of a database to store the blobs is ACID compliance.  However, the approach that the testers used in the white paper, (Bulk Logged option of SQL Server,) which doubled SQL Server throughput, effectively changed the 'D' in ACID to a 'd,' as the blob data was not logged with the initial writes for the transaction.   Therefore, if full ACID compliance is an important requirement for your system, halve the SQL Server throughput figures for database writes when comparing file I/O to database blob I/O.</source>
          <target state="translated">ここでもう一つ注意すべき点があります。ブロブを格納するためのデータベースの使用をサポートする理由の1つは、ACID準拠です。しかし、ホワイトペーパーでテスターが使用したアプローチ(SQL ServerのBulk Loggedオプション)では、SQL Serverのスループットが2倍になりましたが、トランザクションの最初の書き込みではブロブデータがログに記録されないため、ACIDの「D」を事実上「d」に変更してしまいました。したがって、ACIDの完全な遵守がシステムにとって重要な要件である場合、ファイルIOとデータベースのブロブIOを比較する際には、データベース書き込みのSQL Serverスループットの数値を半分にしてください。</target>
        </trans-unit>
        <trans-unit id="3328bee09e8c09e8968eeed0a2f9b66d9200e6cb" translate="yes" xml:space="preserve">
          <source>Here's an interesting white paper on the topic.</source>
          <target state="translated">興味深い白書をご紹介します。</target>
        </trans-unit>
        <trans-unit id="62412dfc10888fe41ebeaad0772496979a681afc" translate="yes" xml:space="preserve">
          <source>Hopefully this isn't too much babble, but I saw the topic and wanted to provide some my insights from a relatively successful small/medium scale application.</source>
          <target state="translated">願わくば、これがあまりお喋りではないことを願っていますが、このトピックを見て、比較的成功している中小規模のアプリケーションから私の洞察をいくつか提供したいと思いました。</target>
        </trans-unit>
        <trans-unit id="1262cc4767f7bf18f546e1d6a4826b8fd28f94b6" translate="yes" xml:space="preserve">
          <source>However SQL's &quot;Transparent Data Encryption&quot; does not encrypt FileStream objects, so if that is a consideration, you may be better off just storing them as varbinary.</source>
          <target state="translated">しかし、SQL の &quot;Transparent Data Encryption&quot; は FileStream オブジェクトを暗号化しません。</target>
        </trans-unit>
        <trans-unit id="5450e7c1ad84e657a64129b1d482f97873657e65" translate="yes" xml:space="preserve">
          <source>I get to use transactions for edits to improve data integrity - I don't have to worry about orphaned and missing files</source>
          <target state="translated">データの整合性を向上させるために、編集にトランザクションを使用するようになりました-孤児や行方不明のファイルを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="cbd2819c808f7d8174170eae9048a48026eae2e0" translate="yes" xml:space="preserve">
          <source>I have recently created a PHP/MySQL app which stores PDFs/Word files in a MySQL table (as big as 40MB per file so far).</source>
          <target state="translated">最近、PHPMySQLのアプリを作って、PDFsWordのファイルをMySQLのテーブルに保存しています(今のところ1ファイルあたり40MBほどの大きさです)。</target>
        </trans-unit>
        <trans-unit id="9d8548824f49d9a78947c14fec692cc06bb03454" translate="yes" xml:space="preserve">
          <source>I once worked on an image processing application. We stored the uploaded images in a directory that was something like /images/[today's date]/[id number]. But we also extracted the metadata (exif data) from the images and stored that in the database, along with a timestamp and such.</source>
          <target state="translated">私は以前、画像処理アプリケーションで仕事をしたことがあります。アップロードされた画像をimages[今日の日付][id番号]のようなディレクトリに保存していました。しかし、画像からメタデータ(exifデータ)を抽出して、タイムスタンプなどと一緒にデータベースに保存していました。</target>
        </trans-unit>
        <trans-unit id="1a2a80f9309a684b0d97bad75e984f23663555da" translate="yes" xml:space="preserve">
          <source>I'd call my implementation a success, it takes care of backup requirements and simplifies the layout of the project. The performance is fine for the 20-30 people who use the app.</source>
          <target state="translated">私は私の実装を成功と呼んでいます、それはバックアップの要件をケアし、プロジェクトのレイアウトを簡素化します。アプリを使用する20〜30人のためのパフォーマンスは問題ありません。</target>
        </trans-unit>
        <trans-unit id="29fa93b28f6e28a031496c25f93f96335b65852e" translate="yes" xml:space="preserve">
          <source>I'm in charge of some applications that manage many TB of images.  We've found that storing &lt;strong&gt;file paths&lt;/strong&gt; in the database to be best.</source>
          <target state="translated">何TBもの画像を管理するいくつかのアプリケーションを担当しています。 データベースへの&lt;strong&gt;ファイルパスの&lt;/strong&gt;保存が最適であることがわかりました。</target>
        </trans-unit>
        <trans-unit id="2fecdc2255f2695e73f6dba95fc3e73d0bcd8d78" translate="yes" xml:space="preserve">
          <source>I'm not sure how much of a &quot;real world&quot; example this is, but I currently have an application out there that stores details for a trading card game, including the images for the cards. Granted the record count for the database is only 2851 records to date, but given the fact that certain cards have are released multiple times and have alternate artwork, it was actually more efficient sizewise to scan the &quot;primary square&quot; of the artwork and then dynamically generate the border and miscellaneous effects for the card when requested.</source>
          <target state="translated">これがどの程度の「現実世界」の例なのかは分かりませんが、私は現在、トレーディングカードゲームの詳細を保存するアプリケーションを持っています。データベースのレコード数はわずか2851レコードですが、特定のカードが複数回リリースされ、代替のアートワークを持っているという事実を考えると、アートワークの「プライマリスクエア」をスキャンして、要求されたときにカードのボーダーや雑多な効果を動的に生成する方が、サイズ的には効率的でした。</target>
        </trans-unit>
        <trans-unit id="d25f4f7e4e4f9284bbb7f7af179d8762a4fab0e8" translate="yes" xml:space="preserve">
          <source>I'm surprised no one has really mentioned this ... delegate it out to others who are specialists -&amp;gt; &lt;strong&gt;use a 3rd party image/file hosting provider&lt;/strong&gt;.</source>
          <target state="translated">誰も本当にこれについて言及していないことに驚いています...専門家である他の人にそれを委任してください-&amp;gt; &lt;strong&gt;サードパーティのイメージ/ファイルホスティングプロバイダーを使用してください&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bb19e735abac3d85de5cc543122acd3955a7a44" translate="yes" xml:space="preserve">
          <source>IMO, Pros of using database to store images are,</source>
          <target state="translated">IMO、データベースを使って画像を保存することのProsは。</target>
        </trans-unit>
        <trans-unit id="67789d0ecde7d5223b48e5c0fd30688658e8dad1" translate="yes" xml:space="preserve">
          <source>If the actual image pointed to by the filepath becomes unavailable, the database unwittingly has an integrity error.</source>
          <target state="translated">ファイルパスによって指し示された実際の画像が利用できなくなると、データベースは知らず知らずのうちに完全性エラーを起こしています。</target>
        </trans-unit>
        <trans-unit id="503989532211253730df23717fe63bd466c6f952" translate="yes" xml:space="preserve">
          <source>If this is web-based application then there could be advantages to storing the images on a third-party storage delivery network, such as Amazon's S3 or the Nirvanix platform.</source>
          <target state="translated">これがウェブベースのアプリケーションであれば、AmazonのS3やNirvanixプラットフォームのようなサードパーティのストレージ配信ネットワークに画像を保存するメリットがあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c3797548f46dc91bf7279b13b078981dc7232924" translate="yes" xml:space="preserve">
          <source>If you have your images in a file-system and someone is reading the file as you're writing a new version or even deleting the file - what happens?</source>
          <target state="translated">ファイルシステムに画像を保存していて、新しいバージョンを書いたり、ファイルを削除したりしているときに、誰かがファイルを読んでしまった場合、どうなるでしょうか?</target>
        </trans-unit>
        <trans-unit id="bbcc47c06384c94a6e71cd3ed29e7578f9b54e84" translate="yes" xml:space="preserve">
          <source>If you're not on SQL Server 2008 and you have some solid reasons for putting specific image files in the database, then you could take the &quot;both&quot; approach and use the file system as a temporary cache and use the database as the master repository.</source>
          <target state="translated">SQL Server 2008 を使用しておらず、特定の画像ファイルをデータベースに保存する確かな理由がある場合は、「両方」のアプローチをとり、ファイルシステムを一時的なキャッシュとして使用し、データベースをマスターリポジトリとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="104f4bfbbe4ba01a18a339e2ce0dee05761e7192" translate="yes" xml:space="preserve">
          <source>If you're on an older database, then I'd say that if you're storing it as blob data, then you're really not going to get anything out of the database in the way of searching features, so it's probably best to store an address on a filesystem, and store the image that way.</source>
          <target state="translated">古いデータベースを使っているのであれば、ブロブデータとして保存しているのであれば、検索機能の面でデータベースから何も得られないので、ファイルシステム上にアドレスを保存して、その方法で画像を保存するのがベストだと思います。</target>
        </trans-unit>
        <trans-unit id="d3db3c02ef9c8ebaf43fb00a808ca6373d64cf93" translate="yes" xml:space="preserve">
          <source>If your images are going to be small (say &amp;lt; 64k) and the storage engine of your db supports inline (in record) BLOBs, it improves performance further as no indirection is required (Locality of reference is achieved).</source>
          <target state="translated">画像が小さくなり（たとえば64k未満）、dbのストレージエンジンがインライン（レコード内）BLOBをサポートする場合、間接参照が不要なため、パフォーマンスがさらに向上します（参照の局所性が実現されます）。</target>
        </trans-unit>
        <trans-unit id="1367543dc2e57b8ae191b7f517c89168e8563b8d" translate="yes" xml:space="preserve">
          <source>Im my experience I had to manage both situations: images stored in database and images on the file system with path stored in db.</source>
          <target state="translated">私の経験では、データベースに保存されている画像と、ファイルシステムに保存されている画像の両方の状況を管理しなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="9403681db30c32ac40b3bcb94b6983848198b3a1" translate="yes" xml:space="preserve">
          <source>Images stored in the database do not require a different backup strategy. Images stored on filesystem do</source>
          <target state="translated">データベースに保存された画像は、別のバックアップ戦略を必要としません。ファイルシステムに保存されている画像は</target>
        </trans-unit>
        <trans-unit id="d798c2480179e1f2ec28ad71a0ad5dd2ca9635ca" translate="yes" xml:space="preserve">
          <source>In a previous project i stored images on the filesystem, and that caused a lot of headaches with backups, replication, and the filesystem getting out of sync with the database.</source>
          <target state="translated">以前のプロジェクトでは、ファイルシステムに画像を保存していましたが、バックアップやレプリケーション、ファイルシステムがデータベースと同期しなくなるなど、多くの頭痛の種になっていました。</target>
        </trans-unit>
        <trans-unit id="09863ac503085043491d30bf4f9111c47daca621" translate="yes" xml:space="preserve">
          <source>In my experience, sometimes the simplest solution is to &lt;strong&gt;name the images according to the primary key&lt;/strong&gt;. So it's easy to find the image that belongs to a particular record, and vice versa. But at the same time you're not storing &lt;em&gt;anything&lt;/em&gt; about the image in the database.</source>
          <target state="translated">私の経験では、最も簡単な解決策は&lt;strong&gt;、主キーに従って画像に名前&lt;/strong&gt;を&lt;strong&gt;付けること&lt;/strong&gt;です。 そのため、特定のレコードに属する画像を簡単に見つけることができ、その逆も同様です。 しかし、同時に、画像については&lt;em&gt;何も&lt;/em&gt;データベースに保存していません。</target>
        </trans-unit>
        <trans-unit id="f531513cb377ad06aa76b61e2ea34b52b9a15fdd" translate="yes" xml:space="preserve">
          <source>In my latest project i'm storing images in the database, and caching them on the filesystem, and it works really well. I've had no problems so far.</source>
          <target state="translated">私の最新のプロジェクトでは、画像をデータベースに保存し、ファイルシステム上にキャッシュしていますが、とてもうまく機能しています。今のところ問題はありません。</target>
        </trans-unit>
        <trans-unit id="09691af22dcb0a5e64c5ef4a1a4629569c883e0c" translate="yes" xml:space="preserve">
          <source>In places where you MUST guarantee referential integrity and ACID compliance, storing images in the database is required.</source>
          <target state="translated">参照整合性と ACID コンプライアンスを保証しなければならない場所では、データベースに画像を保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea18a136284e24daa6223fb84ba253dcbfbee5f6" translate="yes" xml:space="preserve">
          <source>It depends on the number of images you are going to store and also their sizes. I have used databases to store images in the past and my experience has been fairly good.</source>
          <target state="translated">それはあなたが保存しようとしている画像の数とそのサイズに依存します。私は過去にデータベースを使って画像を保存したことがありますが、その経験はかなり良いものでした。</target>
        </trans-unit>
        <trans-unit id="9283765c13db752b531235978b65c8824a43fa27" translate="yes" xml:space="preserve">
          <source>It is easier to control access to the images if they are in a database. Idle admins can access any folder on disk. It takes a really determined admin to go snooping in a database to extract the images</source>
          <target state="translated">画像がデータベースにある場合は、画像へのアクセス制御が容易になります。アイドル状態の管理者はディスク上のどのフォルダにもアクセスできます。画像を抽出するためにデータベースをスヌーピングするには、本当に根性のある管理者でなければなりません。</target>
        </trans-unit>
        <trans-unit id="86a122c21eed2b290e44b53668135ef815601820" translate="yes" xml:space="preserve">
          <source>It's so worth it. They store it efficiently. No bandwith getting uploaded from your servers to client requests, etc.</source>
          <target state="translated">その甲斐あって 効率よく保管してくれる。あなたのサーバーからクライアントの要求などにアップロードされるバンドウィズはありません。</target>
        </trans-unit>
        <trans-unit id="d1251f454e24d7233f5c1fa0583852723b715eb7" translate="yes" xml:space="preserve">
          <source>Latency may be
    slower than direct file access</source>
          <target state="translated">レイテンシは、直接ファイルアクセスよりも遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="725eb7fb053ccc585c879ae0da4b122f6a9f14bc" translate="yes" xml:space="preserve">
          <source>Like most other things, It depends on the expected size and Budget.</source>
          <target state="translated">他のほとんどのものと同じように、それは予想されるサイズと予算に依存します。</target>
        </trans-unit>
        <trans-unit id="8545dec1f4c27acaa5353a4c97f59593c52fe97e" translate="yes" xml:space="preserve">
          <source>Manage it like a regular table and have the performance of the file system.</source>
          <target state="translated">通常のテーブルのように管理し、ファイルシステムのパフォーマンスを発揮します。</target>
        </trans-unit>
        <trans-unit id="f658bc08163a361b68ecdcd9080d547dfa019aed" translate="yes" xml:space="preserve">
          <source>Migration &quot;just works&quot;.</source>
          <target state="translated">移行は「うまくいくだけ」です。</target>
        </trans-unit>
        <trans-unit id="6968d452a081adacc8b53c63e98bbe9c46f66820" translate="yes" xml:space="preserve">
          <source>Moso Cloud Storage</source>
          <target state="translated">クラウドストレージ</target>
        </trans-unit>
        <trans-unit id="8351a5f7f60b713223687b5b9fb0f91f10e65233" translate="yes" xml:space="preserve">
          <source>Needle in a Haystack: Efficient Storage of Billions of Photos</source>
          <target state="translated">ニードル・イン・ア・ヘイスタック 数十億枚の写真を効率的に保存</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="f06cb0fe589979c389e198338ded5e8a7b144557" translate="yes" xml:space="preserve">
          <source>Normally, I'm storngly against taking the most expensive and hardest to scale part of your infrastructure (the database) and putting all load into it. On the other hand: It greatly simplifies backup strategy, especially when you have multiple web servers and need to somehow keep the data synchronized.</source>
          <target state="translated">通常、私はインフラストラクチャの中で最もコストが高く、スケールするのが難しい部分(データベース)を利用して、すべての負荷をそこにかけることには反対です。一方では。特に複数のウェブサーバを持っていて、データをどうにかして同期させておく必要がある場合には、バックアップ戦略を大幅に簡素化することができます。</target>
        </trans-unit>
        <trans-unit id="09f177c20b3e429783e2b3893764c0d0da902bd2" translate="yes" xml:space="preserve">
          <source>Obviously database access performance when you deal with binary large objects is degrading, and the database dimensions will grow a lot, causing again performance loss... and normally database space is much more expensive than file system space.</source>
          <target state="translated">バイナリの大きなオブジェクトを扱う場合、明らかにデータベースアクセスのパフォーマンスが低下し、データベースの次元が大きくなり、再びパフォーマンスの低下を引き起こします...そして通常、データベース空間はファイルシステム空間よりもはるかに高価です。</target>
        </trans-unit>
        <trans-unit id="9287d0bca2c5656d1b260627af121123dac33b33" translate="yes" xml:space="preserve">
          <source>On the other hand having large binary objects stored in file system will cause you to have backup plans that have to consider both database and file system, and this can be an issue for some systems.</source>
          <target state="translated">一方、ファイルシステムに保存されている大きなバイナリオブジェクトを持つことは、データベースとファイルシステムの両方を考慮しなければならないバックアップ計画を持つことになり、これはシステムによっては問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e750b8bf3af0d850d7b1c3e5f654ec6d86914f3b" translate="yes" xml:space="preserve">
          <source>On the other hand there are problems associated</source>
          <target state="translated">一方で、関連する問題もあります。</target>
        </trans-unit>
        <trans-unit id="69d4c2a1a3cd8e2dc76d590ad7bcca2c66fa2e3a" translate="yes" xml:space="preserve">
          <source>Once common solution to this is to hash them out into a balanced tree of subdirectories.</source>
          <target state="translated">これに対する一度の一般的な解決策は、サブディレクトリのバランスのとれたツリーにそれらをハッシュアウトすることです。</target>
        </trans-unit>
        <trans-unit id="dffe608d3ed114e8a78297264f0fe42a01be2bdc" translate="yes" xml:space="preserve">
          <source>One thing that I haven't seen anyone mention yet but is definitely worth noting is that there are issues associated with storing large amounts of images in most filesystems too.  For example if you take the approach mentioned above and name each image file after the primary key, on most filesystems you will run into issues if you try to put all of the images in one big directory once you reach a very large number of images (e.g. in the hundreds of thousands or millions).</source>
          <target state="translated">まだ誰も言及していませんが、多くのファイルシステムでは大量の画像を保存する際に問題が発生することがあります。例えば、上記の方法で各画像ファイルにプライマリキーの名前を付けた場合、ほとんどのファイルシステムでは、非常に多くの画像(例えば数十万から数百万枚)に達すると、すべての画像を一つの大きなディレクトリにまとめようとすると、問題が発生するでしょう。</target>
        </trans-unit>
        <trans-unit id="d9a64c001c7d6c4d98225996f8dd95ddc6b72319" translate="yes" xml:space="preserve">
          <source>One thing to note here is that no one in the pro file system camp has listed a particular file system. Does this mean that everything from FAT16 to ZFS handily beats every database?</source>
          <target state="translated">ここで注意すべきことは、プロのファイルシステム陣営の誰も特定のファイルシステムをリストアップしていないということです。これはFAT16からZFSまでのすべてのものがすべてのデータベースを打ち負かすことを意味しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="daca8adfb2ce1f5899bcf3cc5dc33091198be70b" translate="yes" xml:space="preserve">
          <source>Overall not very memory/cpu efficient when compared to filesystem</source>
          <target state="translated">ファイルシステムと比較すると、全体的にメモリCPUの効率はあまり良くありません。</target>
        </trans-unit>
        <trans-unit id="dc155c121b565754897ed082c978712827881b44" translate="yes" xml:space="preserve">
          <source>Probably, it would also allow you to throw some caching element, based on commonly hit image urls into your web engine/program, so you're saving yourself there as well.</source>
          <target state="translated">おそらく、それはまた、一般的にヒットする画像のURLに基づいて、あなたのウェブエンジンプログラムにキャッシュ要素を投げることができますので、あなたは自分自身を節約しています。</target>
        </trans-unit>
        <trans-unit id="54b393721169f11c627d23e95f4e0bce01dc79eb" translate="yes" xml:space="preserve">
          <source>Require additional code to extract
and stream the images</source>
          <target state="translated">画像を抽出してストリームするための追加コードが必要</target>
        </trans-unit>
        <trans-unit id="bdd88b7d31c47d46b3476e67aa360525526c3160" translate="yes" xml:space="preserve">
          <source>SQL Server 2008 offers a solution that has the best of both worlds : &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;The filestream data type&lt;/a&gt;.</source>
          <target state="translated">SQL Server 2008は、両方&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;の長所を兼ね備え&lt;/a&gt;たソリューションを提供します。 ファイルストリームデータタイプ 。</target>
        </trans-unit>
        <trans-unit id="ec236495b04b446b59d809893ff3e4466ca3fd51" translate="yes" xml:space="preserve">
          <source>Second the recommendation on file paths. I've worked on a couple of projects that needed to manage large-ish asset collections, and any attempts to store things directly in the DB resulted in pain and frustration long-term.</source>
          <target state="translated">ファイルパスに関する推奨事項の2つ目です。私は、大規模なアセットコレクションを管理する必要があるいくつかのプロジェクトで働いてきましたが、DBに直接物事を保存しようとする試みは、長期的な苦痛と不満をもたらしました。</target>
        </trans-unit>
        <trans-unit id="7ecb8d1b499802e07c066d2d9c3ceee7493e96ab" translate="yes" xml:space="preserve">
          <source>Serving up images from a database is easy, just implement an http handler that serves the byte array returned from the DB server as a binary stream.</source>
          <target state="translated">DB サーバから返されたバイト配列をバイナリストリームとして提供する http ハンドラを実装するだけです。</target>
        </trans-unit>
        <trans-unit id="99962b21785a235b5e93d806ae6c3d7e37e621ce" translate="yes" xml:space="preserve">
          <source>Setting up the web server is slightly simpler because I don't need to have an uploads/ folder and tell all my applications where it is.</source>
          <target state="translated">アップロード用のフォルダを持っていて、それがどこにあるかをすべてのアプリケーションに教える必要がないので、ウェブサーバの設定は少し簡単です。</target>
        </trans-unit>
        <trans-unit id="e9b806b728121ce126b464af0bd80ee2afdf68c9" translate="yes" xml:space="preserve">
          <source>Small static images (not more than a couple of megs) that are not frequently edited, should be stored in the database. This method has several benefits including easier portability (images are transferred with the database), easier backup/restore (images are backed up with the database) and better scalability (a file system folder with thousands of little thumbnail files sounds like a scalability nightmare to me).</source>
          <target state="translated">頻繁に編集する必要のない小さな静止画像(数メガグラム以下)は、データベースに保存しておくべきです。この方法には、移植性(画像はデータベースと一緒に転送されます)、バックアップリストア(画像はデータベースと一緒にバックアップされます)、スケーラビリティ(何千もの小さなサムネイルファイルを持つファイルシステムフォルダはスケーラビリティの悪夢のように聞こえます)などの利点があります。</target>
        </trans-unit>
        <trans-unit id="c77302484315f43d1b8825352fad38163e655d07" translate="yes" xml:space="preserve">
          <source>Smaller sized files can be efficiently stored and delivered using the database as the storage mechanism.  Larger files would probably be best stored using the file system, especially if they will be modified/updated often.  (blob fragmentation becomes an issue in regards to performance.)</source>
          <target state="translated">小さいサイズのファイルは、効率的に格納され、ストレージメカニズムとしてデータベースを使用して配信することができます。大きなファイルは、ファイルシステムを使用して保存するのがベストでしょう。(ブロブの断片化はパフォーマンスに関して問題になります)</target>
        </trans-unit>
        <trans-unit id="714b035f21ed87fb37883666dfce0caea714ccc8" translate="yes" xml:space="preserve">
          <source>So I'm using an app that stores images heavily in the DB. What's your outlook on this? I'm more of a type to store the location in the filesystem, than store it directly in the DB.</source>
          <target state="translated">そこで、DBに重く画像を保存するアプリを使っています。これについての見解を教えてください。私はDBに直接保存するよりも、ファイルシステムに場所を保存するタイプです。</target>
        </trans-unit>
        <trans-unit id="6dccf67eb0ddd77e8bfbc72fb16de2a45d5b6cae" translate="yes" xml:space="preserve">
          <source>Something nobody has mentioned is that the DB guarantees atomic actions, transactional integrity and deals with concurrency. Even referentially integrity is out of the window with a filesystem - so how do you know your file names are really still correct?</source>
          <target state="translated">誰も言及していないことですが、DB はアトミックアクションやトランザクションの完全性を保証しています。ファイルシステムでは、参照の整合性さえも窓の外にあります。</target>
        </trans-unit>
        <trans-unit id="8af055bdbe7670239d44aa860e0890dd569e962b" translate="yes" xml:space="preserve">
          <source>Store your files on a paid online service like</source>
          <target state="translated">のような有料オンラインサービスにファイルを保存します。</target>
        </trans-unit>
        <trans-unit id="1a3781484823414d3725393bd2bf249b5bee6d6c" translate="yes" xml:space="preserve">
          <source>Storing Images in DB - Yea or Nay</source>
          <target state="translated">DBへの画像の保存-賛成か反対か</target>
        </trans-unit>
        <trans-unit id="d5edc6aeda738e7a8d9506f8a9a0366272625476" translate="yes" xml:space="preserve">
          <source>Storing an image in the database still means that the image data ends up somewhere in the file system but obscured so that you cannot access it directly.</source>
          <target state="translated">画像をデータベースに保存しても、画像データはファイルシステムのどこかに保存されてしまいますが、直接アクセスできないように見えないようになっています。</target>
        </trans-unit>
        <trans-unit id="83e9a8f9902db2ab45aab8a68857232f91f8f817" translate="yes" xml:space="preserve">
          <source>Storing images may be a bad idea when you are dealing with small number of huge sized images. Another problem with storing images in db is that, metadata like creation, modification dates must handled by your application.</source>
          <target state="translated">画像を保存することは、少数の巨大なサイズの画像を扱う場合には良い考えではないかもしれません。また、画像をdbに保存する場合のもう一つの問題点は、作成日や修正日などのメタデータはアプリケーションで処理しなければならないということです。</target>
        </trans-unit>
        <trans-unit id="fc7ebe3f5c8fa7bb3211919a811fe054ebec3fde" translate="yes" xml:space="preserve">
          <source>That seems like it would be better solved with an intermediary script pulling data from a web-inaccessible file store, though. So the DB storage isn't REALLY necessary.</source>
          <target state="translated">これは、ウェブにアクセスできないファイルストアからデータを引っ張ってくる中間スクリプトで解決したほうがよさそうですが。つまり、DBストレージは本当に必要ないということですね。</target>
        </trans-unit>
        <trans-unit id="e507594d631333c78e791861af1df08eda58c6dd" translate="yes" xml:space="preserve">
          <source>That way you also save space on your filesystem, as you are only going to save the exact amount of space, or even compacted space on the filesystem.</source>
          <target state="translated">この方法では、ファイルシステム上のスペースを節約することができ、正確な量のスペースを節約することができます。</target>
        </trans-unit>
        <trans-unit id="aa8930f1feae478f1bcc7944864a710d55955741" translate="yes" xml:space="preserve">
          <source>The Blobs are actually stored as files in a folder.</source>
          <target state="translated">Blobは実際にはフォルダ内のファイルとして保存されています。</target>
        </trans-unit>
        <trans-unit id="dac8ad2eb459eb9d8f5d901be3595fff1497aa53" translate="yes" xml:space="preserve">
          <source>The Blobs can be accessed using &lt;em&gt;either&lt;/em&gt; a database connection &lt;em&gt;or&lt;/em&gt; over the filesystem.</source>
          <target state="translated">Blobには、データベース接続&lt;em&gt;または&lt;/em&gt;ファイルシステムを使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="26f263ae32cfbdb323507d0b4a4dbcc181aa7185" translate="yes" xml:space="preserve">
          <source>The answer is &quot;It depends.&quot;  Certainly it would depend upon the database server and its approach to blob storage.  It also depends on the type of data being stored in blobs, as well as how that data is to be accessed.</source>
          <target state="translated">答えは &quot;次第 &quot;です。確かに、データベースサーバーとそのブロブストレージへのアプローチに依存します。また、ブロブに格納されているデータの種類や、そのデータをどのようにアクセスするかにも依存します。</target>
        </trans-unit>
        <trans-unit id="398e9d6490298e990e2ac82498c6a4997352591a" translate="yes" xml:space="preserve">
          <source>The correct course of action is to make the right decision for your precise scenario, and to do that, you'll need some numbers and some use case estimates.</source>
          <target state="translated">正確なシナリオに合わせて正しい判断をすること、そのためにはいくつかの数字といくつかのユースケースの見積もりが必要になります。</target>
        </trans-unit>
        <trans-unit id="a3ff707b3146ba5858644a13add5404689ca1dac" translate="yes" xml:space="preserve">
          <source>The first solution, images in database, is somewhat &quot;cleaner&quot; as your data access layer will have to deal only with database objects; but this is good only when you have to deal with low numbers.</source>
          <target state="translated">最初の解決策であるデータベース内の画像は、データアクセスレイヤーがデータベースオブジェクトのみを扱う必要があるため、多少「クリーン」になりますが、これは数が少ない場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="99b1b7fb03c27b12dd7a97fbe5cba9dedbf6f7d3" translate="yes" xml:space="preserve">
          <source>The government wants you to maintain 6 years of history</source>
          <target state="translated">政府は6年の歴史を維持してほしいと思っている</target>
        </trans-unit>
        <trans-unit id="be8c1d64425fb81ddff96737d2195647616aeedb" translate="yes" xml:space="preserve">
          <source>The only real &quot;pro&quot; I can think of regarding storing them in the DB is the potential for easy of individual image assets. If there are no file paths to use, and all images are streamed straight out of the DB, there's no danger of a user finding files they shouldn't have access to.</source>
          <target state="translated">画像をDBに保存することに関して、私が考えられる唯一の「プロ」は、個々の画像資産を簡単に利用できる可能性があることです。使用するファイルパスがなく、すべての画像がDBから直接ストリーミングされていれば、ユーザーがアクセスできないファイルを見つける危険性はありません。</target>
        </trans-unit>
        <trans-unit id="b6df983ec2f8655d79d2d357cb2d842ac9c202c5" translate="yes" xml:space="preserve">
          <source>The original creator of this image library created a data access class that renders the image based on the request, and it does it quite fast for viewing and individual card.</source>
          <target state="translated">この画像ライブラリの原案者は、リクエストに応じて画像をレンダリングするデータアクセスクラスを作成し、それを閲覧や個別カードのためにかなり高速に実行しています。</target>
        </trans-unit>
        <trans-unit id="21e9b5d795f89df6924b68d2e63f969592671fda" translate="yes" xml:space="preserve">
          <source>The problem with storing only filepaths to images in a database is that the database's integrity can no longer be forced.</source>
          <target state="translated">画像へのファイルパスのみをデータベースに格納することの問題点は、データベースの整合性を強制できなくなってしまうことです。</target>
        </trans-unit>
        <trans-unit id="f33c90f1fc426daa04efefb0038c1e8f22a9e375" translate="yes" xml:space="preserve">
          <source>The trick here is to not become a zealot.</source>
          <target state="translated">ここでのコツは、狂信者にならないことです。</target>
        </trans-unit>
        <trans-unit id="d8f59a378f87933d06e892653ff4a82c884cf319" translate="yes" xml:space="preserve">
          <source>The truth is that many databases beat many files systems, even when we're only talking about raw speed.</source>
          <target state="translated">生の速度だけの話でも、多くのデータベースが多くのファイルシステムに勝っているというのが真実です。</target>
        </trans-unit>
        <trans-unit id="c2d423a32b108506f0bfd6455f1f96019a07f538" translate="yes" xml:space="preserve">
          <source>The word on the street is that unless you are a database vendor trying to prove that your database can do it (like, let's say Microsoft boasting about Terraserver storing a bajillion images in SQL Server) it's not a very good idea. When the alternative - storing images on file servers and paths in the database is so much easier, why bother? Blob fields are kind of like the off-road capabilities of SUVs - most people don't use them, those who do usually get in trouble, and then there are those who do, but only for the fun of it.</source>
          <target state="translated">巷で言われているのは、データベースベンダーがデータベースができることを証明しようとしているのでなければ(例えば、MicrosoftがTerraserverがSQL Serverに何十億ものイメージを保存していると自慢しているように)、あまり良いアイデアとは言えないということです。ファイルサーバやパスをデータベースに保存する方がはるかに簡単なのに、なぜわざわざそんなことをするのでしょうか?BlobフィールドはSUVのオフロード性能のようなもので、ほとんどの人は使わず、使う人はトラブルに巻き込まれ、使う人もいますが、それは楽しいからです。</target>
        </trans-unit>
        <trans-unit id="36730b9cc2f305e81fe3cdc4abe7056400f5a97f" translate="yes" xml:space="preserve">
          <source>There are a couple of issues:</source>
          <target state="translated">いくつかの問題があります。</target>
        </trans-unit>
        <trans-unit id="f29edf34e1917d1906a7773ea48427778e05cd8a" translate="yes" xml:space="preserve">
          <source>This also eases deployment/updates when new cards are released, instead of zipping up an entire folder of images and sending those down the pipe and ensuring the proper folder structure is created, I simply update the database and have the user download it again. This currently sizes up to 56MB, which isn't great, but I'm working on an incremental update feature for future releases. In addition, there is a &quot;no images&quot; version of the application that allows those over dial-up to get the application without the download delay.</source>
          <target state="translated">これはまた、新しいカードがリリースされたときのデプロイメントアップデートを容易にします。イメージのフォルダ全体を圧縮してパイプに送り、適切なフォルダ構造が作成されていることを確認する代わりに、私は単にデータベースを更新して、ユーザーに再度ダウンロードしてもらうだけです。これは現在のところ56MBにもなりますが、将来のリリースに向けて増分更新機能に取り組んでいます。さらに、ダイヤルアップを利用している人がダウンロードの遅延なしにアプリケーションを入手できるようにするための「画像なし」バージョンもあります。</target>
        </trans-unit>
        <trans-unit id="d2559b6884c2c3166252cf8317c08d9d7192227f" translate="yes" xml:space="preserve">
          <source>This might be a bit of a long shot, but if you're using (or planning on using) SQL Server 2008 I'd recommend having a look at the new &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;FileStream&lt;/a&gt; data type.</source>
          <target state="translated">これは少し長いショットかもしれませんが、SQL Server 2008を使用している（または使用を計画している）場合は、新しい&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;FileStream&lt;/a&gt;データ型を確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5de5ed2ad95580ae9860ae51bb53fb858569f0c9" translate="yes" xml:space="preserve">
          <source>This solution has worked great to date since the application itself is targeted as a single instance on the desktop. There is a web site where all of this data is archived for online access, but I would in no way use the same solution for this. I agree the file access would be preferable because it would scale better to the frequency and volume of requests being made for the images.</source>
          <target state="translated">このソリューションは、アプリケーション自体がデスクトップ上の単一のインスタンスとしてターゲットにされているので、これまでのところうまく機能しています。このデータはすべてオンラインアクセス用にアーカイブされているウェブサイトがありますが、私はこれと同じソリューションを使うことはありません。画像へのリクエストの頻度や量に合わせて、ファイルアクセスが望ましいという点には同意します。</target>
        </trans-unit>
        <trans-unit id="7a9f42b006e68507b2bf93c3dc35393a93370b8e" translate="yes" xml:space="preserve">
          <source>To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem</source>
          <target state="translated">BLOBにするかしないか BLOBにするか:データベースやファイルシステムの大規模オブジェクトストレージ</target>
        </trans-unit>
        <trans-unit id="115c5ce402f46dd63900f8651dbc2e3d209abf85" translate="yes" xml:space="preserve">
          <source>Transact-SQL statements can insert, update, query, search, and back up FILESTREAM data. Win32 file system interfaces provide streaming access to the data.</source>
          <target state="translated">Transact-SQL ステートメントは、FILESTREAM データの挿入、更新、クエリ、検索、およびバックアップを行うことができます。Win32ファイルシステムインタフェースは、データへのストリーミングアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="c939e193a50e38ae5295ae364bae62a85fc25476" translate="yes" xml:space="preserve">
          <source>Uploaded files are replicated to backup server along with everything else, no separate backup strategy is needed (peace of mind).</source>
          <target state="translated">アップロードされたファイルは、他のすべてのファイルと一緒にバックアップサーバーにレプリケートされるため、個別のバックアップ戦略は必要ありません(安心してください)。</target>
        </trans-unit>
        <trans-unit id="8fb23687e4739bac5fa4b49b3b6e933f9284f922" translate="yes" xml:space="preserve">
          <source>We have implemented a document imaging system that stores all it's images in SQL2005 blob fields.  There are several hundred GB at the moment and we are seeing excellent response times and little or no performance degradation. In addition, fr regulatory compliance, we have a middleware layer that archives newly posted documents to an optical jukebox system which exposes them as a standard NTFS file system.</source>
          <target state="translated">私たちは、すべての画像を SQL2005 の blob フィールドに保存するドキュメント・イメージング・システムを実装しました。現在、数百GBの容量がありますが、優れたレスポンスタイムとパフォーマンスの低下はほとんどありません。さらに、規制遵守のために、新たに投稿されたドキュメントを光学ジュークボックスシステムにアーカイブし、標準のNTFSファイルシステムとして公開するミドルウェアレイヤーを用意しています。</target>
        </trans-unit>
        <trans-unit id="fdbbc258fb96a990b2231e7642581c54c943bfea" translate="yes" xml:space="preserve">
          <source>We use blobs because they're easier to manage (backup, replication, transfer) too. They work well for us.</source>
          <target state="translated">ブロブを使用しているのは、管理(バックアップ、レプリケーション、転送)も簡単だからです。私たちにとってはうまく機能しています。</target>
        </trans-unit>
        <trans-unit id="92bec75ea6ee7bd3cc26a274361ce400ab17e448" translate="yes" xml:space="preserve">
          <source>We've been very pleased with the results, particularly with respect to:</source>
          <target state="translated">特に結果にはとても満足しています。</target>
        </trans-unit>
        <trans-unit id="7ef90e6354471827cade517de2c173b8991b7175" translate="yes" xml:space="preserve">
          <source>What do you think are the pros/cons?</source>
          <target state="translated">プロコンって何だと思いますか?</target>
        </trans-unit>
        <trans-unit id="87de9781c77b14deca711032ac785da434dcb2f0" translate="yes" xml:space="preserve">
          <source>You are storing images that are
changing dynamically, say invoices and you wanted
to get an invoice as it was on 1 Jan
2007?</source>
          <target state="translated">請求書のように動的に変化する画像を保存していて、2007年1月1日の請求書を取得したいと思っていませんか?</target>
        </trans-unit>
        <trans-unit id="95453050e6c680a8686d784628d69b7341319e48" translate="yes" xml:space="preserve">
          <source>You cannot transactionaly guarantee that the image and the meta-data about that image stored in the database refer to the same file. In other words, it is impossible to guarantee that the file on the filesystem is only ever altered at the same time and in the same transaction as the metadata.</source>
          <target state="translated">データベースに格納されている画像とその画像に関するメタデータが同じファイルを参照していることをトランザクション的に保証することはできません。言い換えれば、ファイルシステム上のファイルが、メタデータと同じ時間に、同じトランザクションでのみ変更されることを保証することは不可能です。</target>
        </trans-unit>
        <trans-unit id="44ac3e04ec087585e18c01c02894782e6ec3abfb" translate="yes" xml:space="preserve">
          <source>database integrity</source>
          <target state="translated">データベースの完全性</target>
        </trans-unit>
        <trans-unit id="4b227f33a30575522e0591fdc96075df02b8e35c" translate="yes" xml:space="preserve">
          <source>database storage is usually more expensive than file system storage</source>
          <target state="translated">データベースストレージは、通常、ファイルシステムストレージよりも高価です。</target>
        </trans-unit>
        <trans-unit id="ddbdd288dca0200556d991307329fa940b415ca3" translate="yes" xml:space="preserve">
          <source>databases win out where transactional integrity between the image and metadata are important.</source>
          <target state="translated">データベースは、画像とメタデータの間のトランザクションの整合性が重要なところでは、勝利を収めています。</target>
        </trans-unit>
        <trans-unit id="7bb6a86f7fb04a200fe53244cac70f7908c2d1b9" translate="yes" xml:space="preserve">
          <source>for example, many web servers use the operating system's &lt;strong&gt;sendfile()&lt;/strong&gt; system call to asynchronously send a file directly from the file system to the network interface. Images stored in a database don't benefit from this optimization.</source>
          <target state="translated">たとえば、多くのWebサーバーは、オペレーティングシステムの&lt;strong&gt;sendfile（）&lt;/strong&gt;システムコールを使用して、ファイルシステムからネットワークインターフェースに直接非同期でファイルを送信します。 データベースに保存された画像は、この最適化の恩恵を受けていません。</target>
        </trans-unit>
        <trans-unit id="f66131dba234d08d3eccc828f035e8d23ef4236f" translate="yes" xml:space="preserve">
          <source>it is difficult (within the context of a web application) to guarantee data has been flushed to disk on the filesystem</source>
          <target state="translated">ファイルシステム上のディスクにデータがフラッシュされたことを保証するのが難しい</target>
        </trans-unit>
        <trans-unit id="539156605d769e1ec2dfda3fa9f1f2a30afd98dd" translate="yes" xml:space="preserve">
          <source>it is more complex to manage integrity between db metadata and file system data</source>
          <target state="translated">dbのメタデータとファイルシステムのデータの整合性を管理するのは、より複雑です。</target>
        </trans-unit>
        <trans-unit id="273eb3dac5c5806c6a187bffbf5eafcde1e5c03f" translate="yes" xml:space="preserve">
          <source>its easy to manage since you don't have to worry about keeping the filesystem in sync when an image is added or deleted</source>
          <target state="translated">画像の追加や削除時にファイルシステムを同期させることを気にする必要がないので、管理が簡単です。</target>
        </trans-unit>
        <trans-unit id="0645e0631b812e6d0a5b9edfab265477559eae84" translate="yes" xml:space="preserve">
          <source>mysqldump now takes a looooong time because there is 500MB of file data in one of the tables.</source>
          <target state="translated">mysqldumpは、テーブルの1つに500MBのファイルデータがあるため、非常に長い時間がかかるようになりました。</target>
        </trans-unit>
        <trans-unit id="eec549ffab2d7fa439d6d8ec4a58c0aaba832e68" translate="yes" xml:space="preserve">
          <source>performance penalty -- a database lookup is usually slower that a filesystem lookup</source>
          <target state="translated">パフォーマンスペナルティ --データベースの検索は通常ファイルシステムの検索よりも遅くなります。</target>
        </trans-unit>
        <trans-unit id="537460e5682fdff5f1d8e31539381c0231a54a01" translate="yes" xml:space="preserve">
          <source>things like web servers, etc, need no special coding or processing to access images in the file system</source>
          <target state="translated">ウェブサーバーなどのようなものは、ファイルシステム内の画像にアクセスするために特別なコーディングや処理を必要としません。</target>
        </trans-unit>
        <trans-unit id="bf4a731866ccbf17f3e091f10fb7389e8354afe9" translate="yes" xml:space="preserve">
          <source>you can super-accelerate file system access with standard off the shelf products</source>
          <target state="translated">標準的な既製品を使用してファイルシステムへのアクセスを超高速化することができます。</target>
        </trans-unit>
        <trans-unit id="4db94e2f04aaa1263e7013679bcdf21bbcf8d6f6" translate="yes" xml:space="preserve">
          <source>you cannot edit the image directly (crop, resize)</source>
          <target state="translated">画像を直接編集することはできません (クロップ、リサイズ)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
