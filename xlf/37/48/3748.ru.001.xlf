<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/3748">
    <body>
      <group id="3748">
        <trans-unit id="47c3aaa77395e894593329e3bdb56a462542e81a" translate="yes" xml:space="preserve">
          <source>+ves:</source>
          <target state="translated">+ves:</target>
        </trans-unit>
        <trans-unit id="5dcc67d3b3974bde67a1dfbe489b0bf1470ca12c" translate="yes" xml:space="preserve">
          <source>-ves:</source>
          <target state="translated">-ves:</target>
        </trans-unit>
        <trans-unit id="df2eb94a6b01c34ef601502e19e10d652b46439d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;This thread&lt;/a&gt; explains why you should use a 3rd party hosting provider.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/731526/amazon-s3-when-why&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этой теме&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; объясняется, почему вы должны использовать сторонний хостинг-провайдер.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b616c405d40078118403f0f28e9e2f410c4eb6eb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Assumption: Application is web enabled/web based&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предположение: приложение доступно через Интернет&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a68ce6032c3740fd013d6c9b66b882246d9cf06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e3161fd669d07159e3a7475c999f77628c85246" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c202eefcc3c874230f5d8c6563173cba8693635" translate="yes" xml:space="preserve">
          <source>A. You don't need FS structure to hold your images</source>
          <target state="translated">A.Вам не нужна структура FS,чтобы удерживать изображения.</target>
        </trans-unit>
        <trans-unit id="270426116340bdc0cd86224583f5d3877de93a8b" translate="yes" xml:space="preserve">
          <source>Ability to easily implement a document versioning system</source>
          <target state="translated">Возможность легко реализовать систему версионирования документов</target>
        </trans-unit>
        <trans-unit id="c7b27ed64e40c36b897240dcbfc2315467a72a1a" translate="yes" xml:space="preserve">
          <source>Also, you could decide to save with some structure or elements that allow you to browse the raw images in your filesystem without any db hits, or transfer the files in bulk to another system, hard drive, S3 or another scenario - updating the location in your program, but keep the structure, again without much of a hit trying to bring the images out of your db when trying to increase storage.</source>
          <target state="translated">Также,вы можете решить сохранить с некоторой структурой или элементами,которые позволят вам просматривать необработанные образы в вашей файловой системе без каких-либо db хитов,или передать файлы массово на другую систему,жесткий диск,S3 или другой сценарий-обновление местоположения в вашей программе,но сохранить структуру,опять же без особого хита,пытаясь вывести образы из db,когда пытаетесь увеличить объем памяти.</target>
        </trans-unit>
        <trans-unit id="7b11a4234011e35a6c31048c3a964862b6e69ee8" translate="yes" xml:space="preserve">
          <source>Amazon S3</source>
          <target state="translated">Амазонка S3</target>
        </trans-unit>
        <trans-unit id="806863a20fd9521591c93b6ce2c193c0342f405d" translate="yes" xml:space="preserve">
          <source>Another StackOverflow threads talking about this &lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другие потоки StackOverflow говорят об этом &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/792134/alternative-to-amazon-s3-for-the-data-center&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4137b28bbb9fcf80d76df94dcc9ea52f9b414a06" translate="yes" xml:space="preserve">
          <source>Another reason to go for file system is when you have to share your images data (or sounds, video, whatever) with third party access: in this days I'm developing a web app that uses images that have to be accessed from &quot;outside&quot; my web farm in such a way that a database access to retrieve binary data is simply impossible. So sometimes there are also design considerations that will drive you to a choice.</source>
          <target state="translated">Еще одной причиной для перехода на файловую систему является то,что вам приходится предоставлять доступ к своим изображениям (или звукам,видео,чему угодно)третьим лицам:в настоящее время я разрабатываю веб-приложение,которое использует образы,доступ к которым должен быть получен &quot;извне&quot; моей веб фермы таким образом,что доступ к базе данных для получения двоичных данных просто невозможен.Поэтому иногда возникают и конструктивные соображения,которые подтолкнут вас к выбору.</target>
        </trans-unit>
        <trans-unit id="6e76a3d1c0a59c96f4904844811645326c89b249" translate="yes" xml:space="preserve">
          <source>As others have said SQL 2008 comes with a Filestream type that allows you to store a filename or identifier as a pointer in the db and automatically stores the image on your filesystem which is a great scenario.</source>
          <target state="translated">Как говорили другие,SQL 2008 поставляется с типом Filestream,который позволяет хранить имя файла или идентификатор в качестве указателя в db и автоматически сохраняет изображение в файловой системе,что является отличным сценарием.</target>
        </trans-unit>
        <trans-unit id="9b2634f0ec6106d9f9147e4cd3dff1615adeba37" translate="yes" xml:space="preserve">
          <source>As with most issues, it's not as simple as it sounds. There are cases where it would make sense to store the images in the database.</source>
          <target state="translated">Как и в большинстве случаев,все не так просто,как кажется.Есть случаи,когда имеет смысл хранить изображения в базе данных.</target>
        </trans-unit>
        <trans-unit id="2a35d366d9a1eb88fd629e03b09b4bdd7c8a046d" translate="yes" xml:space="preserve">
          <source>At a company where I used to work we stored 155 million images in an Oracle 8i (then 9i) database. 7.5TB worth.</source>
          <target state="translated">В компании,где я работал,мы хранили 155 миллионов изображений в базе данных Oracle 8i (тогда 9i).7,5 ТБ.</target>
        </trans-unit>
        <trans-unit id="687370ce64f7e2dd0384ee8f207a893b7096ffc1" translate="yes" xml:space="preserve">
          <source>B. Database indexes perform better than FS trees when more number of items are to be stored</source>
          <target state="translated">B.Индексы базы данных работают лучше,чем FS-деревья,когда необходимо хранить больше элементов</target>
        </trans-unit>
        <trans-unit id="848d820eb3eab4f745688973041d4a9d217d5075" translate="yes" xml:space="preserve">
          <source>Backups are integrated.</source>
          <target state="translated">Резервные копии интегрированы.</target>
        </trans-unit>
        <trans-unit id="c8dd18981a74439309d7966c8a027a8cc858d9b3" translate="yes" xml:space="preserve">
          <source>Both methods are common and practiced. Have a look at the advantages and disadvantages. Either way, you'll have to think about how to overcome the disadvantages. Storing in database usually means tweaking database parameters and implement some kind of caching. Using filesystem requires you to find some way of keeping filesystem+database in sync.</source>
          <target state="translated">Оба метода являются общепринятыми и практикуются.Обратите внимание на преимущества и недостатки.В любом случае,вы должны подумать о том,как преодолеть недостатки.Хранение в базе данных обычно означает подстройку параметров базы данных и реализацию некоего кэширования.Использование файловой системы требует найти какой-то способ синхронизации файловой системы+базы данных.</target>
        </trans-unit>
        <trans-unit id="6b99be15334afb0e1fb922b7dd040aa5dd83e1d3" translate="yes" xml:space="preserve">
          <source>C. Smartly tuned database perform good job at caching the query results</source>
          <target state="translated">C.Интеллектуально настроенная база данных выполняет хорошую работу по кэшированию результатов запроса.</target>
        </trans-unit>
        <trans-unit id="a9fa41cd24ffd5f1e44c7dadd97884e69eb206be" translate="yes" xml:space="preserve">
          <source>Consider also, when making this choice, if you have to deal with permission and authentication when accessing binary objects: these requisites normally can be solved in an easier way when data are stored in db.</source>
          <target state="translated">Подумайте также,при принятии этого решения,если вам приходится иметь дело с разрешениями и аутентификацией при доступе к двоичным объектам:эти реквизиты,как правило,могут быть решены более простым способом,когда данные хранятся в db.</target>
        </trans-unit>
        <trans-unit id="bfb124dc6fc8752f003971d881d4cc87007a2d3f" translate="yes" xml:space="preserve">
          <source>D. Backups are simple. It also works well if you have replication set up and content is delivered from a server near to user. In such cases, explicit synchronization is not required.</source>
          <target state="translated">D.Резервные копии просты.Она также хорошо работает,если у вас настроена репликация и содержимое доставляется с сервера,расположенного рядом с пользователем.В таких случаях явной синхронизации не требуется.</target>
        </trans-unit>
        <trans-unit id="b1a5dae551b12236616319e0bb35a5bf5f6335cf" translate="yes" xml:space="preserve">
          <source>Ease of Replication and Backup</source>
          <target state="translated">Простота репликации и резервного копирования</target>
        </trans-unit>
        <trans-unit id="e22bfbeb8bec5e7cafa254beae090269060a8e07" translate="yes" xml:space="preserve">
          <source>FILESTREAM uses the NT system cache for caching file data. This helps reduce any effect that FILESTREAM data might have on Database Engine performance. The SQL Server buffer pool is not used; therefore, this memory is available for query processing.</source>
          <target state="translated">FILESTREAM использует системный кэш NT для кэширования файловых данных.Это помогает уменьшить любое влияние,которое данные FILESTREAM могут оказывать на производительность Database Engine.Буферный пул SQL Server не используется,поэтому эта память доступна для обработки запросов.</target>
        </trans-unit>
        <trans-unit id="4154c203e6cd021be2b375052abd91fd364f29f1" translate="yes" xml:space="preserve">
          <source>File paths in the DB is &lt;strong&gt;definitely&lt;/strong&gt; the way to go - I've heard story after story from customers with TB of images that it became a nightmare trying to store any significant amount of images in a DB - the performance hit alone is too much.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Путь к &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;файлам в БД - это, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;безусловно&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , правильный путь - я слышал историю за историей от клиентов с ТБ изображений, которые превратились в настоящий кошмар, пытаясь сохранить сколько-нибудь значительное количество изображений в БД - одной только производительности слишком много.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b58164fc134ce748db8ca4b2d2da4a94bd28c0b" translate="yes" xml:space="preserve">
          <source>File store.  Facebook engineers had a great talk about it.  One take away was to know the practical limit of files in a directory.</source>
          <target state="translated">Файловый магазин.Инженеры Фейсбука отлично поговорили об этом.Один из них-знать практический предел файлов в каталоге.</target>
        </trans-unit>
        <trans-unit id="f506183fe93fe32acd9c9e9fa5b2e25dae72a188" translate="yes" xml:space="preserve">
          <source>FileStream solves most of the problems around storing the files in the DB:</source>
          <target state="translated">FileStream решает большинство проблем,связанных с хранением файлов в БД:</target>
        </trans-unit>
        <trans-unit id="775382eda387b2f309209bbe52ea023bc8423554" translate="yes" xml:space="preserve">
          <source>For example, your business logic can check if an image file exists on disc before serving it up, retrieving from the database when necessary. This buys you the capability of multiple web servers and fewer sync issues.</source>
          <target state="translated">Например,ваша бизнес-логика может проверить,существует ли файл образа на диске,прежде чем обслуживать его,извлекая из базы данных,когда это необходимо.Это дает вам возможность использовать несколько веб-серверов и уменьшить количество проблем с синхронизацией.</target>
        </trans-unit>
        <trans-unit id="2b7110a6687a3b55c76c2091298794787912727c" translate="yes" xml:space="preserve">
          <source>From the MSDN Article:</source>
          <target state="translated">Из статьи MSDN:</target>
        </trans-unit>
        <trans-unit id="7ec65d66d8967edd541ee0ea7f4da0f56133cc62" translate="yes" xml:space="preserve">
          <source>Given that the images are the actual data being sought after, and that they can be managed easier (the images won't suddenly disappear) in one integrated database rather than having to interface with some kind of filesystem (if the filesystem is independently accessed, the images MIGHT suddenly &quot;disappear&quot;), I'd go for storing them directly as a BLOB or such.</source>
          <target state="translated">Учитывая,что образы являются искомыми данными,и что ими легче управлять (образы не исчезнут внезапно)в одной интегрированной базе данных,вместо того,чтобы взаимодействовать с какой-то файловой системой (если к файловой системе есть независимый доступ,то образы внезапно &quot;исчезают&quot;),я бы пошел на их непосредственное хранение в виде BLOB или типа того.</target>
        </trans-unit>
        <trans-unit id="50318af368b2cfc31a1990457660c45811f1519a" translate="yes" xml:space="preserve">
          <source>Heavier load on the database server</source>
          <target state="translated">большая нагрузка на сервер базы данных</target>
        </trans-unit>
        <trans-unit id="2476f13c8544e6adef83fe4356b9351e0dd56bf9" translate="yes" xml:space="preserve">
          <source>Here's an additional point to keep in mind.  One of the reasons supporting the use of a database to store the blobs is ACID compliance.  However, the approach that the testers used in the white paper, (Bulk Logged option of SQL Server,) which doubled SQL Server throughput, effectively changed the 'D' in ACID to a 'd,' as the blob data was not logged with the initial writes for the transaction.   Therefore, if full ACID compliance is an important requirement for your system, halve the SQL Server throughput figures for database writes when comparing file I/O to database blob I/O.</source>
          <target state="translated">Вот еще одно очко,которое нужно иметь в виду.Одной из причин,поддерживающих использование базы данных для хранения блоков,является соответствие ACID.Однако подход,использованный тестерами в официальном документе (опция Bulk Logged в SQL Server),которая удвоила пропускную способность SQL Server,фактически изменил 'D' в ACID на 'd',так как данные блобов не записывались в журнал с исходными записями для транзакции.Поэтому,если полное соответствие ACID является важным требованием для вашей системы,уменьшите вдвое пропускную способность SQL-сервера для данных,записываемых в базу данных при сравнении файлового IO с блочным IO базы данных.</target>
        </trans-unit>
        <trans-unit id="3328bee09e8c09e8968eeed0a2f9b66d9200e6cb" translate="yes" xml:space="preserve">
          <source>Here's an interesting white paper on the topic.</source>
          <target state="translated">Вот интересная белая книга на эту тему.</target>
        </trans-unit>
        <trans-unit id="62412dfc10888fe41ebeaad0772496979a681afc" translate="yes" xml:space="preserve">
          <source>Hopefully this isn't too much babble, but I saw the topic and wanted to provide some my insights from a relatively successful small/medium scale application.</source>
          <target state="translated">Надеюсь,что это не слишком много болтовни,но я увидел тему и хотел поделиться некоторыми своими соображениями из относительно успешного применения смаллмедиумной шкалы.</target>
        </trans-unit>
        <trans-unit id="1262cc4767f7bf18f546e1d6a4826b8fd28f94b6" translate="yes" xml:space="preserve">
          <source>However SQL's &quot;Transparent Data Encryption&quot; does not encrypt FileStream objects, so if that is a consideration, you may be better off just storing them as varbinary.</source>
          <target state="translated">Однако SQL &quot;Transparent Data Encryption&quot; не шифрует объекты FileStream,так что если это так,то,возможно,лучше просто хранить их как разновидность.</target>
        </trans-unit>
        <trans-unit id="5450e7c1ad84e657a64129b1d482f97873657e65" translate="yes" xml:space="preserve">
          <source>I get to use transactions for edits to improve data integrity - I don't have to worry about orphaned and missing files</source>
          <target state="translated">Я могу использовать транзакции для правок для улучшения целостности данных-мне не нужно беспокоиться о осиротевших и отсутствующих файлах.</target>
        </trans-unit>
        <trans-unit id="cbd2819c808f7d8174170eae9048a48026eae2e0" translate="yes" xml:space="preserve">
          <source>I have recently created a PHP/MySQL app which stores PDFs/Word files in a MySQL table (as big as 40MB per file so far).</source>
          <target state="translated">Недавно я создал приложение PHPMySQL,которое хранит файлы PDFsWord в таблице MySQL (до сих пор 40 МБ на файл).</target>
        </trans-unit>
        <trans-unit id="9d8548824f49d9a78947c14fec692cc06bb03454" translate="yes" xml:space="preserve">
          <source>I once worked on an image processing application. We stored the uploaded images in a directory that was something like /images/[today's date]/[id number]. But we also extracted the metadata (exif data) from the images and stored that in the database, along with a timestamp and such.</source>
          <target state="translated">Однажды я работал над приложением по обработке изображений.Мы хранили загруженные изображения в каталоге,который был чем-то вроде изображения[сегодняшняя дата][идентификационный номер].Но мы также извлекали метаданные (exif-данные)из изображений и хранили их в базе данных вместе с отметкой времени и так далее.</target>
        </trans-unit>
        <trans-unit id="1a2a80f9309a684b0d97bad75e984f23663555da" translate="yes" xml:space="preserve">
          <source>I'd call my implementation a success, it takes care of backup requirements and simplifies the layout of the project. The performance is fine for the 20-30 people who use the app.</source>
          <target state="translated">Я бы назвал свою реализацию успешной,она заботится о требованиях к резервному копированию и упрощает компоновку проекта.Производительность подойдет для 20-30 человек,пользующихся приложением.</target>
        </trans-unit>
        <trans-unit id="29fa93b28f6e28a031496c25f93f96335b65852e" translate="yes" xml:space="preserve">
          <source>I'm in charge of some applications that manage many TB of images.  We've found that storing &lt;strong&gt;file paths&lt;/strong&gt; in the database to be best.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я отвечаю за некоторые приложения, которые управляют многими изображениями ТБ. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мы обнаружили, что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;лучше всего &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;хранить &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;пути к файлам&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в базе данных.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fecdc2255f2695e73f6dba95fc3e73d0bcd8d78" translate="yes" xml:space="preserve">
          <source>I'm not sure how much of a &quot;real world&quot; example this is, but I currently have an application out there that stores details for a trading card game, including the images for the cards. Granted the record count for the database is only 2851 records to date, but given the fact that certain cards have are released multiple times and have alternate artwork, it was actually more efficient sizewise to scan the &quot;primary square&quot; of the artwork and then dynamically generate the border and miscellaneous effects for the card when requested.</source>
          <target state="translated">Я не уверен,что это пример &quot;реального мира&quot;,но в настоящее время у меня есть приложение,в котором хранятся детали для карточной игры,в том числе изображения для карт.На сегодняшний день количество записей в базе данных составляет всего 2851,но,учитывая тот факт,что некоторые карточки были выпущены несколько раз и имеют альтернативные рисунки,на самом деле было более эффективным отсканировать &quot;первичный квадрат&quot; рисунка,а затем динамически генерировать границы и различные эффекты для карточки по запросу.</target>
        </trans-unit>
        <trans-unit id="d25f4f7e4e4f9284bbb7f7af179d8762a4fab0e8" translate="yes" xml:space="preserve">
          <source>I'm surprised no one has really mentioned this ... delegate it out to others who are specialists -&amp;gt; &lt;strong&gt;use a 3rd party image/file hosting provider&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я удивлен, что никто на самом деле не упомянул об этом ... делегировать это другим специалистам -&amp;gt; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;использовать сторонний провайдер изображений / файловых хостингов&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0bb19e735abac3d85de5cc543122acd3955a7a44" translate="yes" xml:space="preserve">
          <source>IMO, Pros of using database to store images are,</source>
          <target state="translated">IMO,Плюсы использования базы данных для хранения изображений,</target>
        </trans-unit>
        <trans-unit id="67789d0ecde7d5223b48e5c0fd30688658e8dad1" translate="yes" xml:space="preserve">
          <source>If the actual image pointed to by the filepath becomes unavailable, the database unwittingly has an integrity error.</source>
          <target state="translated">Если фактическое изображение,на которое указывает путь к файлу,становится недоступным,то в базе данных невольно возникает ошибка целостности.</target>
        </trans-unit>
        <trans-unit id="503989532211253730df23717fe63bd466c6f952" translate="yes" xml:space="preserve">
          <source>If this is web-based application then there could be advantages to storing the images on a third-party storage delivery network, such as Amazon's S3 or the Nirvanix platform.</source>
          <target state="translated">Если речь идет о веб-приложении,то хранение изображений в сторонней сети хранения данных,например,в Amazon S3 или на платформе Nirvanix,может иметь свои преимущества.</target>
        </trans-unit>
        <trans-unit id="c3797548f46dc91bf7279b13b078981dc7232924" translate="yes" xml:space="preserve">
          <source>If you have your images in a file-system and someone is reading the file as you're writing a new version or even deleting the file - what happens?</source>
          <target state="translated">Если у вас есть изображения в файловой системе,и кто-то читает файл,когда вы пишете новую версию или даже удаляете файл-что произойдет?</target>
        </trans-unit>
        <trans-unit id="bbcc47c06384c94a6e71cd3ed29e7578f9b54e84" translate="yes" xml:space="preserve">
          <source>If you're not on SQL Server 2008 and you have some solid reasons for putting specific image files in the database, then you could take the &quot;both&quot; approach and use the file system as a temporary cache and use the database as the master repository.</source>
          <target state="translated">Если вы не работаете на SQL Server 2008 и у вас есть веские причины для размещения определенных файлов образов в базе данных,то вы можете воспользоваться подходом &quot;оба&quot; и использовать файловую систему в качестве временного кэша,а базу данных использовать в качестве основного репозитория.</target>
        </trans-unit>
        <trans-unit id="104f4bfbbe4ba01a18a339e2ce0dee05761e7192" translate="yes" xml:space="preserve">
          <source>If you're on an older database, then I'd say that if you're storing it as blob data, then you're really not going to get anything out of the database in the way of searching features, so it's probably best to store an address on a filesystem, and store the image that way.</source>
          <target state="translated">Если вы находитесь в старой базе данных,то я бы сказал,что если вы храните ее как блочные данные,то вы на самом деле ничего не получите из базы данных с помощью функций поиска,поэтому,наверное,лучше всего хранить адрес в файловой системе,и хранить образ таким образом.</target>
        </trans-unit>
        <trans-unit id="d3db3c02ef9c8ebaf43fb00a808ca6373d64cf93" translate="yes" xml:space="preserve">
          <source>If your images are going to be small (say &amp;lt; 64k) and the storage engine of your db supports inline (in record) BLOBs, it improves performance further as no indirection is required (Locality of reference is achieved).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если ваши изображения будут маленькими (скажем, &amp;lt;64 КБ), и механизм хранения вашей базы данных поддерживает встроенные (в записи) большие двоичные объекты, это еще больше повышает производительность, поскольку не требуется никакого косвенного обращения (достигается локальность ссылки).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1367543dc2e57b8ae191b7f517c89168e8563b8d" translate="yes" xml:space="preserve">
          <source>Im my experience I had to manage both situations: images stored in database and images on the file system with path stored in db.</source>
          <target state="translated">По моему опыту,мне приходилось управлять обеими ситуациями:изображениями,хранящимися в базе данных,и изображениями в файловой системе,путь к которым хранится в db.</target>
        </trans-unit>
        <trans-unit id="9403681db30c32ac40b3bcb94b6983848198b3a1" translate="yes" xml:space="preserve">
          <source>Images stored in the database do not require a different backup strategy. Images stored on filesystem do</source>
          <target state="translated">Изображения,хранящиеся в базе данных,не требуют иной стратегии резервного копирования.Изображения,хранящиеся на файловой системе,делают</target>
        </trans-unit>
        <trans-unit id="d798c2480179e1f2ec28ad71a0ad5dd2ca9635ca" translate="yes" xml:space="preserve">
          <source>In a previous project i stored images on the filesystem, and that caused a lot of headaches with backups, replication, and the filesystem getting out of sync with the database.</source>
          <target state="translated">В предыдущем проекте я хранил изображения на файловой системе,что вызывало много головной боли при резервном копировании,репликации и выходе файловой системы из синхронизации с базой данных.</target>
        </trans-unit>
        <trans-unit id="09863ac503085043491d30bf4f9111c47daca621" translate="yes" xml:space="preserve">
          <source>In my experience, sometimes the simplest solution is to &lt;strong&gt;name the images according to the primary key&lt;/strong&gt;. So it's easy to find the image that belongs to a particular record, and vice versa. But at the same time you're not storing &lt;em&gt;anything&lt;/em&gt; about the image in the database.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По моему опыту, иногда самое простое решение - &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;назвать изображения в соответствии с первичным ключом&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, легко найти изображение, которое принадлежит определенной записи, и наоборот. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но в то же время вы не хранить &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;либо&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; об изображении в базе данных.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f531513cb377ad06aa76b61e2ea34b52b9a15fdd" translate="yes" xml:space="preserve">
          <source>In my latest project i'm storing images in the database, and caching them on the filesystem, and it works really well. I've had no problems so far.</source>
          <target state="translated">В моем последнем проекте я храню изображения в базе данных и кэширую их на файловой системе,и это действительно хорошо работает.До сих пор у меня не было никаких проблем.</target>
        </trans-unit>
        <trans-unit id="09691af22dcb0a5e64c5ef4a1a4629569c883e0c" translate="yes" xml:space="preserve">
          <source>In places where you MUST guarantee referential integrity and ACID compliance, storing images in the database is required.</source>
          <target state="translated">В местах,где Вы ДОЛЖНЫ гарантировать целостность ссылок и соответствие ACID,хранение изображений в базе данных является обязательным.</target>
        </trans-unit>
        <trans-unit id="ea18a136284e24daa6223fb84ba253dcbfbee5f6" translate="yes" xml:space="preserve">
          <source>It depends on the number of images you are going to store and also their sizes. I have used databases to store images in the past and my experience has been fairly good.</source>
          <target state="translated">Это зависит от количества изображений,которые вы собираетесь хранить,а также от их размеров.В прошлом я использовал базы данных для хранения изображений,и мой опыт был довольно хорош.</target>
        </trans-unit>
        <trans-unit id="9283765c13db752b531235978b65c8824a43fa27" translate="yes" xml:space="preserve">
          <source>It is easier to control access to the images if they are in a database. Idle admins can access any folder on disk. It takes a really determined admin to go snooping in a database to extract the images</source>
          <target state="translated">Проще контролировать доступ к изображениям,если они находятся в базе данных.Простаивающие администраторы могут получить доступ к любой папке на диске.Потребуется действительно решительный администратор,чтобы просмотреть базу данных для извлечения образов.</target>
        </trans-unit>
        <trans-unit id="86a122c21eed2b290e44b53668135ef815601820" translate="yes" xml:space="preserve">
          <source>It's so worth it. They store it efficiently. No bandwith getting uploaded from your servers to client requests, etc.</source>
          <target state="translated">Оно того стоит.Они хранят его эффективно.Никакой связи с загрузкой с ваших серверов на клиентские запросы и т.п.</target>
        </trans-unit>
        <trans-unit id="d1251f454e24d7233f5c1fa0583852723b715eb7" translate="yes" xml:space="preserve">
          <source>Latency may be
    slower than direct file access</source>
          <target state="translated">Задержка может быть медленнее,чем прямой доступ к файлам.</target>
        </trans-unit>
        <trans-unit id="725eb7fb053ccc585c879ae0da4b122f6a9f14bc" translate="yes" xml:space="preserve">
          <source>Like most other things, It depends on the expected size and Budget.</source>
          <target state="translated">Как и большинство других вещей,это зависит от ожидаемого размера и бюджета.</target>
        </trans-unit>
        <trans-unit id="8545dec1f4c27acaa5353a4c97f59593c52fe97e" translate="yes" xml:space="preserve">
          <source>Manage it like a regular table and have the performance of the file system.</source>
          <target state="translated">Управляйте им,как обычной таблицей,и имейте производительность файловой системы.</target>
        </trans-unit>
        <trans-unit id="f658bc08163a361b68ecdcd9080d547dfa019aed" translate="yes" xml:space="preserve">
          <source>Migration &quot;just works&quot;.</source>
          <target state="translated">Миграция &quot;просто работает&quot;.</target>
        </trans-unit>
        <trans-unit id="6968d452a081adacc8b53c63e98bbe9c46f66820" translate="yes" xml:space="preserve">
          <source>Moso Cloud Storage</source>
          <target state="translated">Хранение в облаке</target>
        </trans-unit>
        <trans-unit id="8351a5f7f60b713223687b5b9fb0f91f10e65233" translate="yes" xml:space="preserve">
          <source>Needle in a Haystack: Efficient Storage of Billions of Photos</source>
          <target state="translated">Игла в стоге сена:Эффективное хранение миллиардов фотографий</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="f06cb0fe589979c389e198338ded5e8a7b144557" translate="yes" xml:space="preserve">
          <source>Normally, I'm storngly against taking the most expensive and hardest to scale part of your infrastructure (the database) and putting all load into it. On the other hand: It greatly simplifies backup strategy, especially when you have multiple web servers and need to somehow keep the data synchronized.</source>
          <target state="translated">Обычно я не собираюсь брать самую дорогую и сложную для масштабирования часть вашей инфраструктуры (базы данных)и загружать в нее всю нагрузку.С другой стороны:Это значительно упрощает стратегию резервного копирования,особенно когда у вас несколько веб-серверов и вам нужно как-то синхронизировать данные.</target>
        </trans-unit>
        <trans-unit id="09f177c20b3e429783e2b3893764c0d0da902bd2" translate="yes" xml:space="preserve">
          <source>Obviously database access performance when you deal with binary large objects is degrading, and the database dimensions will grow a lot, causing again performance loss... and normally database space is much more expensive than file system space.</source>
          <target state="translated">Очевидно,что производительность доступа к базам данных,когда вы имеете дело с бинарными большими объектами,ухудшается,и размеры базы данных будут сильно расти,что опять же приведет к потере производительности...и обычно пространство базы данных намного дороже,чем пространство файловой системы.</target>
        </trans-unit>
        <trans-unit id="9287d0bca2c5656d1b260627af121123dac33b33" translate="yes" xml:space="preserve">
          <source>On the other hand having large binary objects stored in file system will cause you to have backup plans that have to consider both database and file system, and this can be an issue for some systems.</source>
          <target state="translated">С другой стороны,наличие больших двоичных объектов,хранящихся в файловой системе,приведет к тому,что у вас будут планы резервного копирования,которые должны учитывать как базу данных,так и файловую систему,и это может быть проблемой для некоторых систем.</target>
        </trans-unit>
        <trans-unit id="e750b8bf3af0d850d7b1c3e5f654ec6d86914f3b" translate="yes" xml:space="preserve">
          <source>On the other hand there are problems associated</source>
          <target state="translated">С другой стороны,есть проблемы,связанные с</target>
        </trans-unit>
        <trans-unit id="69d4c2a1a3cd8e2dc76d590ad7bcca2c66fa2e3a" translate="yes" xml:space="preserve">
          <source>Once common solution to this is to hash them out into a balanced tree of subdirectories.</source>
          <target state="translated">Обычным решением этой проблемы является их хэширование в сбалансированное дерево подкаталогов.</target>
        </trans-unit>
        <trans-unit id="dffe608d3ed114e8a78297264f0fe42a01be2bdc" translate="yes" xml:space="preserve">
          <source>One thing that I haven't seen anyone mention yet but is definitely worth noting is that there are issues associated with storing large amounts of images in most filesystems too.  For example if you take the approach mentioned above and name each image file after the primary key, on most filesystems you will run into issues if you try to put all of the images in one big directory once you reach a very large number of images (e.g. in the hundreds of thousands or millions).</source>
          <target state="translated">Одна вещь,о которой я еще ни разу не упоминал,но которая определенно заслуживает внимания,это то,что существуют проблемы,связанные с хранением больших объемов образов и в большинстве файловых систем.Например,если вы воспользуетесь описанным выше подходом и назовёте каждый файл образа в честь основного ключа,то в большинстве файловых систем вы столкнётесь с проблемами,если попытаетесь поместить все образы в один большой каталог,как только достигнете очень большого количества образов (например,в сотнях тысяч или миллионах).</target>
        </trans-unit>
        <trans-unit id="d9a64c001c7d6c4d98225996f8dd95ddc6b72319" translate="yes" xml:space="preserve">
          <source>One thing to note here is that no one in the pro file system camp has listed a particular file system. Does this mean that everything from FAT16 to ZFS handily beats every database?</source>
          <target state="translated">Здесь следует отметить,что никто в лагере файловой системы Pro не перечислил конкретную файловую систему.Означает ли это,что все от FAT16 до ZFS удобно бьет каждую базу данных?</target>
        </trans-unit>
        <trans-unit id="daca8adfb2ce1f5899bcf3cc5dc33091198be70b" translate="yes" xml:space="preserve">
          <source>Overall not very memory/cpu efficient when compared to filesystem</source>
          <target state="translated">В целом не очень эффективное запоминающее устройство по сравнению с файловой системой</target>
        </trans-unit>
        <trans-unit id="dc155c121b565754897ed082c978712827881b44" translate="yes" xml:space="preserve">
          <source>Probably, it would also allow you to throw some caching element, based on commonly hit image urls into your web engine/program, so you're saving yourself there as well.</source>
          <target state="translated">Вероятно,это также позволит вам бросить некоторый элемент кэширования,основанный на обычно хитовых изображений urls в вашу веб-инжинипрограмму,так что вы сохраняете себя там также.</target>
        </trans-unit>
        <trans-unit id="54b393721169f11c627d23e95f4e0bce01dc79eb" translate="yes" xml:space="preserve">
          <source>Require additional code to extract
and stream the images</source>
          <target state="translated">Требуется дополнительный код для извлечения и потоковой передачи изображений.</target>
        </trans-unit>
        <trans-unit id="bdd88b7d31c47d46b3476e67aa360525526c3160" translate="yes" xml:space="preserve">
          <source>SQL Server 2008 offers a solution that has the best of both worlds : &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;The filestream data type&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008 предлагает решение, которое имеет лучшее из обоих миров: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc716724.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;тип данных файлового потока&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec236495b04b446b59d809893ff3e4466ca3fd51" translate="yes" xml:space="preserve">
          <source>Second the recommendation on file paths. I've worked on a couple of projects that needed to manage large-ish asset collections, and any attempts to store things directly in the DB resulted in pain and frustration long-term.</source>
          <target state="translated">Во-вторых,рекомендация по путям к файлам.Я работал над парой проектов,которые нуждались в управлении большими коллекциями активов,и любые попытки хранить вещи непосредственно в БД приводили к длительной боли и разочарованию.</target>
        </trans-unit>
        <trans-unit id="7ecb8d1b499802e07c066d2d9c3ceee7493e96ab" translate="yes" xml:space="preserve">
          <source>Serving up images from a database is easy, just implement an http handler that serves the byte array returned from the DB server as a binary stream.</source>
          <target state="translated">Обслуживание образов из базы данных простое,достаточно реализовать http обработчик,который обслуживает массив байт,возвращаемый с сервера БД,в виде бинарного потока.</target>
        </trans-unit>
        <trans-unit id="99962b21785a235b5e93d806ae6c3d7e37e621ce" translate="yes" xml:space="preserve">
          <source>Setting up the web server is slightly simpler because I don't need to have an uploads/ folder and tell all my applications where it is.</source>
          <target state="translated">Настройка веб сервера немного проще,потому что мне не нужно иметь папку для закачек и сообщать всем своим приложениям,где она находится.</target>
        </trans-unit>
        <trans-unit id="e9b806b728121ce126b464af0bd80ee2afdf68c9" translate="yes" xml:space="preserve">
          <source>Small static images (not more than a couple of megs) that are not frequently edited, should be stored in the database. This method has several benefits including easier portability (images are transferred with the database), easier backup/restore (images are backed up with the database) and better scalability (a file system folder with thousands of little thumbnail files sounds like a scalability nightmare to me).</source>
          <target state="translated">Небольшие статические изображения (не более пары мега),которые не часто редактируются,должны храниться в базе данных.Этот метод имеет ряд преимуществ,включая более легкую переносимость (изображения передаются вместе с базой данных),более легкое резервное копирование (изображения копируются вместе с базой данных)и лучшую масштабируемость (папка файловой системы с тысячами маленьких миниатюрных файлов кажется мне кошмаром масштабируемости).</target>
        </trans-unit>
        <trans-unit id="c77302484315f43d1b8825352fad38163e655d07" translate="yes" xml:space="preserve">
          <source>Smaller sized files can be efficiently stored and delivered using the database as the storage mechanism.  Larger files would probably be best stored using the file system, especially if they will be modified/updated often.  (blob fragmentation becomes an issue in regards to performance.)</source>
          <target state="translated">Файлы меньшего размера можно эффективно хранить и доставлять,используя базу данных в качестве механизма хранения.Большие файлы,вероятно,лучше всего хранить с помощью файловой системы,особенно если они будут часто обновляться.(фрагментация блоков становится проблемой с точки зрения производительности).</target>
        </trans-unit>
        <trans-unit id="714b035f21ed87fb37883666dfce0caea714ccc8" translate="yes" xml:space="preserve">
          <source>So I'm using an app that stores images heavily in the DB. What's your outlook on this? I'm more of a type to store the location in the filesystem, than store it directly in the DB.</source>
          <target state="translated">Так что я использую приложение,которое хранит изображения в большом количестве в БД.Как ты на это смотришь? Я больше похож на человека,который хранит изображение в файловой системе,чем хранит его непосредственно в БД.</target>
        </trans-unit>
        <trans-unit id="6dccf67eb0ddd77e8bfbc72fb16de2a45d5b6cae" translate="yes" xml:space="preserve">
          <source>Something nobody has mentioned is that the DB guarantees atomic actions, transactional integrity and deals with concurrency. Even referentially integrity is out of the window with a filesystem - so how do you know your file names are really still correct?</source>
          <target state="translated">Никто не упоминал о том,что БД гарантирует атомные действия,операционную целостность и сделки с параллельными сделками.Даже условная целостность с файловой системой-откуда вы знаете,что ваши имена файлов все еще верны?</target>
        </trans-unit>
        <trans-unit id="8af055bdbe7670239d44aa860e0890dd569e962b" translate="yes" xml:space="preserve">
          <source>Store your files on a paid online service like</source>
          <target state="translated">Храните свои файлы в платном онлайн-сервисе,например</target>
        </trans-unit>
        <trans-unit id="1a3781484823414d3725393bd2bf249b5bee6d6c" translate="yes" xml:space="preserve">
          <source>Storing Images in DB - Yea or Nay</source>
          <target state="translated">Хранение изображений в ДБ-Да или Нет</target>
        </trans-unit>
        <trans-unit id="d5edc6aeda738e7a8d9506f8a9a0366272625476" translate="yes" xml:space="preserve">
          <source>Storing an image in the database still means that the image data ends up somewhere in the file system but obscured so that you cannot access it directly.</source>
          <target state="translated">Хранение образа в базе данных по-прежнему означает,что данные образа заканчиваются где-то в файловой системе,но затемняются,так что вы не можете получить к ним прямой доступ.</target>
        </trans-unit>
        <trans-unit id="83e9a8f9902db2ab45aab8a68857232f91f8f817" translate="yes" xml:space="preserve">
          <source>Storing images may be a bad idea when you are dealing with small number of huge sized images. Another problem with storing images in db is that, metadata like creation, modification dates must handled by your application.</source>
          <target state="translated">Хранение изображений может быть плохой идеей,когда вы имеете дело с небольшим количеством изображений большого размера.Другая проблема с хранением образов в db заключается в том,что такие метаданные,как создание,даты модификаций должны обрабатываться вашим приложением.</target>
        </trans-unit>
        <trans-unit id="fc7ebe3f5c8fa7bb3211919a811fe054ebec3fde" translate="yes" xml:space="preserve">
          <source>That seems like it would be better solved with an intermediary script pulling data from a web-inaccessible file store, though. So the DB storage isn't REALLY necessary.</source>
          <target state="translated">Однако,похоже,что лучше решить эту проблему с помощью промежуточного скрипта,вытаскивающего данные из доступного через Интернет файлового хранилища.Так что хранилище БД не является РЕАЛЬНО необходимым.</target>
        </trans-unit>
        <trans-unit id="e507594d631333c78e791861af1df08eda58c6dd" translate="yes" xml:space="preserve">
          <source>That way you also save space on your filesystem, as you are only going to save the exact amount of space, or even compacted space on the filesystem.</source>
          <target state="translated">Таким образом,вы также сэкономите место в файловой системе,так как вы сохраните только точное количество места,или даже сжатое пространство в файловой системе.</target>
        </trans-unit>
        <trans-unit id="aa8930f1feae478f1bcc7944864a710d55955741" translate="yes" xml:space="preserve">
          <source>The Blobs are actually stored as files in a folder.</source>
          <target state="translated">Капли на самом деле хранятся как файлы в папке.</target>
        </trans-unit>
        <trans-unit id="dac8ad2eb459eb9d8f5d901be3595fff1497aa53" translate="yes" xml:space="preserve">
          <source>The Blobs can be accessed using &lt;em&gt;either&lt;/em&gt; a database connection &lt;em&gt;or&lt;/em&gt; over the filesystem.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В Blobs можно получить с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;помощью &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;либо&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; соединения с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;базой данных &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;или&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; через файловую систему.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26f263ae32cfbdb323507d0b4a4dbcc181aa7185" translate="yes" xml:space="preserve">
          <source>The answer is &quot;It depends.&quot;  Certainly it would depend upon the database server and its approach to blob storage.  It also depends on the type of data being stored in blobs, as well as how that data is to be accessed.</source>
          <target state="translated">Ответ:&quot;Зависит&quot;.Конечно,это будет зависеть от сервера баз данных и его подхода к хранению блоков.Это также зависит от типа данных,которые хранятся в блобах,а также от того,как эти данные будут доступны.</target>
        </trans-unit>
        <trans-unit id="398e9d6490298e990e2ac82498c6a4997352591a" translate="yes" xml:space="preserve">
          <source>The correct course of action is to make the right decision for your precise scenario, and to do that, you'll need some numbers and some use case estimates.</source>
          <target state="translated">Правильный курс действий заключается в принятии правильного решения для вашего точного сценария,и для этого вам понадобятся некоторые цифры и некоторые оценки использования конкретного случая.</target>
        </trans-unit>
        <trans-unit id="a3ff707b3146ba5858644a13add5404689ca1dac" translate="yes" xml:space="preserve">
          <source>The first solution, images in database, is somewhat &quot;cleaner&quot; as your data access layer will have to deal only with database objects; but this is good only when you have to deal with low numbers.</source>
          <target state="translated">Первое решение,образы в базе данных,несколько &quot;чище&quot;,так как ваш уровень доступа к данным будет иметь дело только с объектами базы данных;но это хорошо только тогда,когда вам приходится иметь дело с небольшими числами.</target>
        </trans-unit>
        <trans-unit id="99b1b7fb03c27b12dd7a97fbe5cba9dedbf6f7d3" translate="yes" xml:space="preserve">
          <source>The government wants you to maintain 6 years of history</source>
          <target state="translated">Правительство хочет,чтобы вы сохранили 6-летнюю историю...</target>
        </trans-unit>
        <trans-unit id="be8c1d64425fb81ddff96737d2195647616aeedb" translate="yes" xml:space="preserve">
          <source>The only real &quot;pro&quot; I can think of regarding storing them in the DB is the potential for easy of individual image assets. If there are no file paths to use, and all images are streamed straight out of the DB, there's no danger of a user finding files they shouldn't have access to.</source>
          <target state="translated">Единственный реальный &quot;профи&quot;,о котором я могу думать в отношении хранения их в БД,-это потенциал легкодоступных индивидуальных имиджевых активов.Если пути к файлам отсутствуют,а все образы поступают прямо из БД,то нет опасности,что пользователь найдет файлы,к которым у него не должно быть доступа.</target>
        </trans-unit>
        <trans-unit id="b6df983ec2f8655d79d2d357cb2d842ac9c202c5" translate="yes" xml:space="preserve">
          <source>The original creator of this image library created a data access class that renders the image based on the request, and it does it quite fast for viewing and individual card.</source>
          <target state="translated">Первоначальный создатель этой библиотеки изображений создал класс доступа к данным,который выводит изображение на основании запроса,и делает это достаточно быстро для просмотра и индивидуальной карточки.</target>
        </trans-unit>
        <trans-unit id="21e9b5d795f89df6924b68d2e63f969592671fda" translate="yes" xml:space="preserve">
          <source>The problem with storing only filepaths to images in a database is that the database's integrity can no longer be forced.</source>
          <target state="translated">Проблема с хранением в базе данных только файловых путей к изображениям заключается в том,что целостность базы данных больше не может быть принудительной.</target>
        </trans-unit>
        <trans-unit id="f33c90f1fc426daa04efefb0038c1e8f22a9e375" translate="yes" xml:space="preserve">
          <source>The trick here is to not become a zealot.</source>
          <target state="translated">Фокус в том,чтобы не стать фанатиком.</target>
        </trans-unit>
        <trans-unit id="d8f59a378f87933d06e892653ff4a82c884cf319" translate="yes" xml:space="preserve">
          <source>The truth is that many databases beat many files systems, even when we're only talking about raw speed.</source>
          <target state="translated">Правда в том,что многие базы данных бьют многие файловые системы,даже когда мы говорим только о сырой скорости.</target>
        </trans-unit>
        <trans-unit id="c2d423a32b108506f0bfd6455f1f96019a07f538" translate="yes" xml:space="preserve">
          <source>The word on the street is that unless you are a database vendor trying to prove that your database can do it (like, let's say Microsoft boasting about Terraserver storing a bajillion images in SQL Server) it's not a very good idea. When the alternative - storing images on file servers and paths in the database is so much easier, why bother? Blob fields are kind of like the off-road capabilities of SUVs - most people don't use them, those who do usually get in trouble, and then there are those who do, but only for the fun of it.</source>
          <target state="translated">На улице говорят,что если вы не являетесь продавцом баз данных,пытающимся доказать,что ваша база данных может это сделать (например,скажем,Microsoft может похвастаться тем,что Terraserver хранит миллиард образов в SQL Server),то это не очень хорошая идея.Когда альтернатива-хранение образов на файловых серверах и путях в базе данных намного проще,зачем беспокоиться? Поля Blob похожи на внедорожные возможности внедорожников-большинство людей их не используют,те,кто обычно попадают в неприятности,а потом есть те,кто это делает,но только ради удовольствия от этого.</target>
        </trans-unit>
        <trans-unit id="36730b9cc2f305e81fe3cdc4abe7056400f5a97f" translate="yes" xml:space="preserve">
          <source>There are a couple of issues:</source>
          <target state="translated">Есть пара проблем:</target>
        </trans-unit>
        <trans-unit id="f29edf34e1917d1906a7773ea48427778e05cd8a" translate="yes" xml:space="preserve">
          <source>This also eases deployment/updates when new cards are released, instead of zipping up an entire folder of images and sending those down the pipe and ensuring the proper folder structure is created, I simply update the database and have the user download it again. This currently sizes up to 56MB, which isn't great, but I'm working on an incremental update feature for future releases. In addition, there is a &quot;no images&quot; version of the application that allows those over dial-up to get the application without the download delay.</source>
          <target state="translated">Это также упрощает установку обновлений при выпуске новых карт,вместо того,чтобы архивировать целую папку образов и отправлять их вниз по трубе,а также обеспечивать правильную структуру папок,я просто обновляю базу данных и заставляю пользователя загружать ее снова.В настоящее время размер базы данных достигает 56MB,что не очень хорошо,но я работаю над функцией инкрементального обновления для будущих выпусков.Кроме того,существует версия приложения &quot;без образов&quot;,которая позволяет тем,кто работает по коммутируемому каналу,получить приложение без задержки загрузки.</target>
        </trans-unit>
        <trans-unit id="d2559b6884c2c3166252cf8317c08d9d7192227f" translate="yes" xml:space="preserve">
          <source>This might be a bit of a long shot, but if you're using (or planning on using) SQL Server 2008 I'd recommend having a look at the new &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;FileStream&lt;/a&gt; data type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это может показаться чем-то большим, но если вы используете (или планируете использовать) SQL Server 2008, я бы рекомендовал взглянуть на новый &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;тип данных &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb933993(SQL.100).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FileStream&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5de5ed2ad95580ae9860ae51bb53fb858569f0c9" translate="yes" xml:space="preserve">
          <source>This solution has worked great to date since the application itself is targeted as a single instance on the desktop. There is a web site where all of this data is archived for online access, but I would in no way use the same solution for this. I agree the file access would be preferable because it would scale better to the frequency and volume of requests being made for the images.</source>
          <target state="translated">На сегодняшний день это решение отлично работает,так как само приложение предназначено для работы в качестве единственного экземпляра на рабочем столе.Есть веб-сайт,где все эти данные архивируются для онлайн доступа,но я бы ни в коем случае не стал использовать для этого одно и то же решение.Я согласен,что доступ к файлам был бы предпочтительнее,так как он бы лучше масштабировался в соответствии с частотой и объемом запросов к изображениям.</target>
        </trans-unit>
        <trans-unit id="7a9f42b006e68507b2bf93c3dc35393a93370b8e" translate="yes" xml:space="preserve">
          <source>To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem</source>
          <target state="translated">В BLOB или не в BLOB:Хранение больших объектов в базе данных или файловой системе</target>
        </trans-unit>
        <trans-unit id="115c5ce402f46dd63900f8651dbc2e3d209abf85" translate="yes" xml:space="preserve">
          <source>Transact-SQL statements can insert, update, query, search, and back up FILESTREAM data. Win32 file system interfaces provide streaming access to the data.</source>
          <target state="translated">Операторы Transact-SQL могут вставлять,обновлять,запрашивать,искать и создавать резервные копии данных FILESTREAM.Интерфейсы файловой системы Win32 обеспечивают потоковый доступ к данным.</target>
        </trans-unit>
        <trans-unit id="c939e193a50e38ae5295ae364bae62a85fc25476" translate="yes" xml:space="preserve">
          <source>Uploaded files are replicated to backup server along with everything else, no separate backup strategy is needed (peace of mind).</source>
          <target state="translated">Загруженные файлы реплицируются на сервер резервного копирования вместе со всем остальным,отдельной стратегии резервного копирования не требуется (спокойствие).</target>
        </trans-unit>
        <trans-unit id="8fb23687e4739bac5fa4b49b3b6e933f9284f922" translate="yes" xml:space="preserve">
          <source>We have implemented a document imaging system that stores all it's images in SQL2005 blob fields.  There are several hundred GB at the moment and we are seeing excellent response times and little or no performance degradation. In addition, fr regulatory compliance, we have a middleware layer that archives newly posted documents to an optical jukebox system which exposes them as a standard NTFS file system.</source>
          <target state="translated">Мы реализовали систему визуализации документов,которая хранит все свои изображения в полях блоба SQL2005.На данный момент их несколько сотен GB,и мы видим отличное время отклика и небольшое снижение производительности или ее отсутствие.Кроме того,в соответствии с нормативами,у нас есть промежуточный уровень программного обеспечения,который архивирует недавно размещенные документы в оптической музыкальной системе,которая подвергает их воздействию как стандартную файловую систему NTFS.</target>
        </trans-unit>
        <trans-unit id="fdbbc258fb96a990b2231e7642581c54c943bfea" translate="yes" xml:space="preserve">
          <source>We use blobs because they're easier to manage (backup, replication, transfer) too. They work well for us.</source>
          <target state="translated">Мы используем капли,потому что ими проще управлять (резервное копирование,репликация,передача)тоже.Они хорошо работают на нас.</target>
        </trans-unit>
        <trans-unit id="92bec75ea6ee7bd3cc26a274361ce400ab17e448" translate="yes" xml:space="preserve">
          <source>We've been very pleased with the results, particularly with respect to:</source>
          <target state="translated">Мы были очень довольны результатами,особенно в том,что касается:</target>
        </trans-unit>
        <trans-unit id="7ef90e6354471827cade517de2c173b8991b7175" translate="yes" xml:space="preserve">
          <source>What do you think are the pros/cons?</source>
          <target state="translated">Как ты думаешь,что такое просконы?</target>
        </trans-unit>
        <trans-unit id="87de9781c77b14deca711032ac785da434dcb2f0" translate="yes" xml:space="preserve">
          <source>You are storing images that are
changing dynamically, say invoices and you wanted
to get an invoice as it was on 1 Jan
2007?</source>
          <target state="translated">Вы храните изображения,которые динамически изменяются,скажем,счета-фактуры,и хотели получить счет-фактуру,как это было 1 января 2007 года?</target>
        </trans-unit>
        <trans-unit id="95453050e6c680a8686d784628d69b7341319e48" translate="yes" xml:space="preserve">
          <source>You cannot transactionaly guarantee that the image and the meta-data about that image stored in the database refer to the same file. In other words, it is impossible to guarantee that the file on the filesystem is only ever altered at the same time and in the same transaction as the metadata.</source>
          <target state="translated">Вы не можете гарантировать,что изображение и мета-данные об этом изображении,хранящиеся в базе данных,относятся к одному и тому же файлу.Другими словами,невозможно гарантировать,что файл в файловой системе будет изменен только в одно и то же время и в одной и той же транзакции с метаданными.</target>
        </trans-unit>
        <trans-unit id="44ac3e04ec087585e18c01c02894782e6ec3abfb" translate="yes" xml:space="preserve">
          <source>database integrity</source>
          <target state="translated">целостность базы данных</target>
        </trans-unit>
        <trans-unit id="4b227f33a30575522e0591fdc96075df02b8e35c" translate="yes" xml:space="preserve">
          <source>database storage is usually more expensive than file system storage</source>
          <target state="translated">хранение базы данных обычно дороже,чем хранение файловой системы.</target>
        </trans-unit>
        <trans-unit id="ddbdd288dca0200556d991307329fa940b415ca3" translate="yes" xml:space="preserve">
          <source>databases win out where transactional integrity between the image and metadata are important.</source>
          <target state="translated">базы данных выигрывают там,где важна транзакционная целостность между изображением и метаданными.</target>
        </trans-unit>
        <trans-unit id="7bb6a86f7fb04a200fe53244cac70f7908c2d1b9" translate="yes" xml:space="preserve">
          <source>for example, many web servers use the operating system's &lt;strong&gt;sendfile()&lt;/strong&gt; system call to asynchronously send a file directly from the file system to the network interface. Images stored in a database don't benefit from this optimization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, многие веб-серверы используют системный &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вызов sendfile ()&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; операционной системы &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;для асинхронной отправки файла непосредственно из файловой системы в сетевой интерфейс. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Изображения, хранящиеся в базе данных, не выигрывают от этой оптимизации.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f66131dba234d08d3eccc828f035e8d23ef4236f" translate="yes" xml:space="preserve">
          <source>it is difficult (within the context of a web application) to guarantee data has been flushed to disk on the filesystem</source>
          <target state="translated">трудно (в контексте веб-приложения)гарантировать,что данные были прошиты на диск в файловой системе</target>
        </trans-unit>
        <trans-unit id="539156605d769e1ec2dfda3fa9f1f2a30afd98dd" translate="yes" xml:space="preserve">
          <source>it is more complex to manage integrity between db metadata and file system data</source>
          <target state="translated">сложнее управлять целостностью между метаданными db и данными файловой системы.</target>
        </trans-unit>
        <trans-unit id="273eb3dac5c5806c6a187bffbf5eafcde1e5c03f" translate="yes" xml:space="preserve">
          <source>its easy to manage since you don't have to worry about keeping the filesystem in sync when an image is added or deleted</source>
          <target state="translated">им легко управлять,так как вам не нужно беспокоиться о синхронизации файловой системы при добавлении или удалении образа.</target>
        </trans-unit>
        <trans-unit id="0645e0631b812e6d0a5b9edfab265477559eae84" translate="yes" xml:space="preserve">
          <source>mysqldump now takes a looooong time because there is 500MB of file data in one of the tables.</source>
          <target state="translated">mysqldump теперь занимает слишком много времени,потому что в одной из таблиц находится 500 МБ файловых данных.</target>
        </trans-unit>
        <trans-unit id="eec549ffab2d7fa439d6d8ec4a58c0aaba832e68" translate="yes" xml:space="preserve">
          <source>performance penalty -- a database lookup is usually slower that a filesystem lookup</source>
          <target state="translated">штраф за производительность --поиск базы данных обычно медленнее,чем поиск файловой системы.</target>
        </trans-unit>
        <trans-unit id="537460e5682fdff5f1d8e31539381c0231a54a01" translate="yes" xml:space="preserve">
          <source>things like web servers, etc, need no special coding or processing to access images in the file system</source>
          <target state="translated">такие вещи,как веб-серверы и т.д.,не нуждаются в специальном кодировании или обработке для доступа к изображениям в файловой системе</target>
        </trans-unit>
        <trans-unit id="bf4a731866ccbf17f3e091f10fb7389e8354afe9" translate="yes" xml:space="preserve">
          <source>you can super-accelerate file system access with standard off the shelf products</source>
          <target state="translated">вы можете супер-ускорить доступ к файловой системе с помощью стандартных готовых продуктов.</target>
        </trans-unit>
        <trans-unit id="4db94e2f04aaa1263e7013679bcdf21bbcf8d6f6" translate="yes" xml:space="preserve">
          <source>you cannot edit the image directly (crop, resize)</source>
          <target state="translated">вы не можете редактировать изображение напрямую (обрезать,изменить размер).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
