<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1986896">
    <body>
      <group id="1986896">
        <trans-unit id="6a6e1f6bba7be766351d79af2c0144878d9e5b0b" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;A for array and C for comma&amp;rdquo; is a handy mnemonic.</source>
          <target state="translated">&quot;A para matriz y C para coma&quot; es una pr&amp;aacute;ctica mnem&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="073092991cddd6d87b6774cbd67a486dc6a12a34" translate="yes" xml:space="preserve">
          <source>**details: &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http://es5.github.io/#x15.4.4.7&lt;/a&gt;*</source>
          <target state="translated">** detalles: &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http://es5.github.io/#x15.4.4.7&lt;/a&gt; *</target>
        </trans-unit>
        <trans-unit id="2627567f32b8adbe0cee5ec161a0a5d3e23d84d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func.apply();&lt;/code&gt; vs &lt;code&gt;func.call();&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;func.apply();&lt;/code&gt; vs &lt;code&gt;func.call();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516a2e912059b0fa8868493150af5bbad99c0fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A small code example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Un peque&amp;ntilde;o ejemplo de c&amp;oacute;digo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06609c98c8d0351c2cdce0383962f34e0421d30c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Apply:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Apply:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b4d5526e7322d3829a9925f60260e3d2f15826d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Call:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbd3e95548b7020e64ae03b229a1444a868c3a07" translate="yes" xml:space="preserve">
          <source>APPLY : Call a function with argument provided as an array. You can use apply if you don't know how many argument are going to pass to the function.</source>
          <target state="translated">APLICAR:Llamar a una función con argumento proporcionado como una matriz.Puedes usar &quot;apply&quot; si no sabes cuántos argumentos van a pasar a la función.</target>
        </trans-unit>
        <trans-unit id="c00657a448f4711f76278443d96c86de31acb2df" translate="yes" xml:space="preserve">
          <source>And for objects that are both &lt;em&gt;iterable&lt;/em&gt; and &lt;em&gt;array-like&lt;/em&gt;, like a real array, we technically could use any of them, but &lt;strong&gt;&lt;em&gt;apply&lt;/em&gt;&lt;/strong&gt; will probably be &lt;strong&gt;faster&lt;/strong&gt; because most JavaScript engines internally optimize it better.</source>
          <target state="translated">Y para los objetos que son &lt;em&gt;iterables&lt;/em&gt; y similares a una matriz, como una matriz real, t&amp;eacute;cnicamente podr&amp;iacute;amos usar cualquiera de ellos, pero la &lt;strong&gt;&lt;em&gt;aplicaci&amp;oacute;n&lt;/em&gt;&lt;/strong&gt; probablemente ser&amp;aacute; &lt;strong&gt;m&amp;aacute;s r&amp;aacute;pida&lt;/strong&gt; porque la mayor&amp;iacute;a de los motores JavaScript lo optimizan internamente mejor.</target>
        </trans-unit>
        <trans-unit id="5c9ecb4ae5137755d8f716322b21d78969c95d9d" translate="yes" xml:space="preserve">
          <source>Another example with Call, Apply and Bind.
The difference between Call and Apply is evident, but &lt;strong&gt;Bind&lt;/strong&gt; works like this:</source>
          <target state="translated">Otro ejemplo con Call, Apply y Bind. La diferencia entre Call y Apply es evidente, pero &lt;strong&gt;Bind&lt;/strong&gt; funciona as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="e0664236e12ed01e6900c7d9cb8ffb41e962a4de" translate="yes" xml:space="preserve">
          <source>Apply takes an array of arguments, while Call takes zero or more individual parameters! Ah hah!</source>
          <target state="translated">Aplicar toma una serie de argumentos,mientras que Llamar toma cero o más parámetros individuales! ¡Ah hah!</target>
        </trans-unit>
        <trans-unit id="ff9c2b698e62e669161a993499cb291ae88ffa2d" translate="yes" xml:space="preserve">
          <source>Are there performance differences between the two aforementioned methods? When is it best to use &lt;code&gt;call&lt;/code&gt; over &lt;code&gt;apply&lt;/code&gt; and vice versa?</source>
          <target state="translated">&amp;iquest;Existen diferencias de rendimiento entre los dos m&amp;eacute;todos antes mencionados? &amp;iquest;Cu&amp;aacute;ndo es mejor usar &lt;code&gt;call&lt;/code&gt; over &lt;code&gt;apply&lt;/code&gt; y viceversa?</target>
        </trans-unit>
        <trans-unit id="bd06993ea011e8d1b377551096b54f21460ca6ef" translate="yes" xml:space="preserve">
          <source>Basically, they differ on how they handle function arguments.</source>
          <target state="translated">Básicamente,difieren en cómo manejan los argumentos de la función.</target>
        </trans-unit>
        <trans-unit id="6691472c714089786101ef2e15dc2184a94f6836" translate="yes" xml:space="preserve">
          <source>Because functions are first-class objects in JavaScript, they can have their own methods. All functions have the methods &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; which make it possible to redefine the receiver (i.e., the object that &lt;code&gt;this&lt;/code&gt; refers to) when calling the function. The method signatures are as follows:</source>
          <target state="translated">Como las funciones son objetos de primera clase en JavaScript, pueden tener sus propios m&amp;eacute;todos. Todas las funciones tienen los m&amp;eacute;todos &lt;code&gt;call()&lt;/code&gt; y &lt;code&gt;apply()&lt;/code&gt; que permiten redefinir el receptor (es decir, el objeto al que se refiere) al llamar a la funci&amp;oacute;n. Las firmas del m&amp;eacute;todo son las siguientes:</target>
        </trans-unit>
        <trans-unit id="0f08f437360dac1640a51eb913a901ace0e1c309" translate="yes" xml:space="preserve">
          <source>Bind returns an instance of a function that can be executed</source>
          <target state="translated">Bind devuelve una instancia de una función que puede ser ejecutada</target>
        </trans-unit>
        <trans-unit id="ed70176671e52914281d5006df38717fa96fa92a" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; are methods which are located on &lt;code&gt;Function.prototype&lt;/code&gt;. Therefore they are available on every function object via the prototype chain. Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; can execute a function with a specified value of the &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Tanto &lt;code&gt;call()&lt;/code&gt; como &lt;code&gt;apply()&lt;/code&gt; son m&amp;eacute;todos que se encuentran en &lt;code&gt;Function.prototype&lt;/code&gt; . Por lo tanto, est&amp;aacute;n disponibles en cada objeto de funci&amp;oacute;n a trav&amp;eacute;s de la cadena de prototipo. Tanto &lt;code&gt;call()&lt;/code&gt; como &lt;code&gt;apply()&lt;/code&gt; pueden ejecutar una funci&amp;oacute;n con un valor especificado de &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43fad9d50904f98023f5b5618af1a58a2e54e88b" translate="yes" xml:space="preserve">
          <source>CALL : A function with argument provide individually.
If you know the arguments to be passed or there are no argument to pass you can use call.</source>
          <target state="translated">LLAMADA:Una función con argumento proporcionar individualmente.Si conoces los argumentos a pasar o no hay argumentos a pasar puedes usar call.</target>
        </trans-unit>
        <trans-unit id="af5f158c4f3a19a2c844e241715bb0c6ede21a92" translate="yes" xml:space="preserve">
          <source>Call and apply both are used to force the &lt;code&gt;this&lt;/code&gt; value when a function is executed. The only difference is that &lt;code&gt;call&lt;/code&gt; takes &lt;code&gt;n+1&lt;/code&gt; arguments where 1 is &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;'n' arguments&lt;/code&gt;. &lt;code&gt;apply&lt;/code&gt; takes only two arguments, one is &lt;code&gt;this&lt;/code&gt; the other is argument array.</source>
          <target state="translated">Llamar y aplicar ambos se utilizan para forzar &lt;code&gt;this&lt;/code&gt; valor cuando se ejecuta una funci&amp;oacute;n. La &amp;uacute;nica diferencia es que la &lt;code&gt;call&lt;/code&gt; toma &lt;code&gt;n+1&lt;/code&gt; argumentos donde 1 es &lt;code&gt;this&lt;/code&gt; y &lt;code&gt;'n' arguments&lt;/code&gt; . &lt;code&gt;apply&lt;/code&gt; solo toma dos argumentos, uno es &lt;code&gt;this&lt;/code&gt; el otro es una matriz de argumentos.</target>
        </trans-unit>
        <trans-unit id="2c5f0501fc2b6f1924d35819be6e0f772b696be1" translate="yes" xml:space="preserve">
          <source>Call() takes comma-separated arguments, ex:</source>
          <target state="translated">Call()toma argumentos separados por comas,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6be24a97cdca9d9739d2f77bbc3f540977649073" translate="yes" xml:space="preserve">
          <source>Code example :</source>
          <target state="translated">Ejemplo de código :</target>
        </trans-unit>
        <trans-unit id="2e84f30b198ef7d854811359c47bddf90fa3a603" translate="yes" xml:space="preserve">
          <source>Difference between these to methods are, how you want to pass the parameters.</source>
          <target state="translated">La diferencia entre estos a los métodos es,cómo quieres pasar los parámetros.</target>
        </trans-unit>
        <trans-unit id="20751e1ac2443cd0bb58e1d765835240c2c0aa16" translate="yes" xml:space="preserve">
          <source>Douglas Crockford mentions briefly the difference between the two, which may help explain the performance difference... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</source>
          <target state="translated">Douglas Crockford menciona brevemente la diferencia entre los dos, lo que puede ayudar a explicar la diferencia de rendimiento ... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42a6de742cb9fd5f887fa14b79df4fb670c8ac43" translate="yes" xml:space="preserve">
          <source>End of extract.</source>
          <target state="translated">Fin de la extracción.</target>
        </trans-unit>
        <trans-unit id="e54fcc4e07d4859ffb15960ee0fc1a09971d3f34" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; achive the same thing, I think there is atleast one place where you cannot use &lt;code&gt;call&lt;/code&gt; but can only use &lt;code&gt;apply&lt;/code&gt;. That is when you want to support inheritance and want to call the constructor.</source>
          <target state="translated">Aunque &lt;code&gt;call&lt;/code&gt; y &lt;code&gt;apply&lt;/code&gt; logran lo mismo, creo que hay al menos un lugar donde no puede usar la &lt;code&gt;call&lt;/code&gt; pero solo puede usar &lt;code&gt;apply&lt;/code&gt; . Es entonces cuando desea admitir la herencia y desea llamar al constructor.</target>
        </trans-unit>
        <trans-unit id="cf723110c4d2bbc5c861b13982508ba988c39761" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;obj.addValues&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; refer to the same function, they behave differently when called because the value of the receiver is different in each call. For this reason, when calling a function that refers to &lt;code&gt;this&lt;/code&gt;, it is important to ensure that &lt;code&gt;this&lt;/code&gt; will have the correct value when it is called. To be clear, if &lt;code&gt;this&lt;/code&gt; were not referenced in the function body, then the behavior of &lt;code&gt;f(20)&lt;/code&gt; and &lt;code&gt;obj.addValues(20)&lt;/code&gt; would be the same.</source>
          <target state="translated">Aunque &lt;code&gt;obj.addValues&lt;/code&gt; &lt;code&gt;f&lt;/code&gt; refieren a la misma funci&amp;oacute;n, se comportan de manera diferente cuando se les llama porque el valor del receptor es diferente en cada llamada. Por esta raz&amp;oacute;n, cuando se llama a una funci&amp;oacute;n que se refiere a &lt;code&gt;this&lt;/code&gt; , es importante asegurarse de que tendr&amp;aacute; el valor correcto cuando se llame. Para ser claros, si &lt;code&gt;this&lt;/code&gt; no fuera referenciado en el cuerpo de la funci&amp;oacute;n, entonces el comportamiento de &lt;code&gt;f(20)&lt;/code&gt; y &lt;code&gt;obj.addValues(20)&lt;/code&gt; ser&amp;iacute;a el mismo.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="7e3d4b30db26a1e1dfba2fd2e16fc8ff0be1049d" translate="yes" xml:space="preserve">
          <source>First Parameter is '&lt;em&gt;this&lt;/em&gt;'</source>
          <target state="translated">El primer par&amp;aacute;metro es ' &lt;em&gt;esto&lt;/em&gt; '</target>
        </trans-unit>
        <trans-unit id="fbe6ab2ec20f25874154873020df4d336159bf55" translate="yes" xml:space="preserve">
          <source>Follows an extract from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;Closure: The Definitive Guide by Michael Bolin&lt;/a&gt;. It might look a bit lengthy, but it's saturated with a lot of insight. From &quot;Appendix B. Frequently Misunderstood JavaScript Concepts&quot;:</source>
          <target state="translated">Sigue un extracto de &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;Cierre: la gu&amp;iacute;a definitiva de Michael Bolin&lt;/a&gt; . Puede parecer un poco largo, pero est&amp;aacute; saturado con mucha informaci&amp;oacute;n. Del &quot;Ap&amp;eacute;ndice B. Conceptos de JavaScript frecuentemente malentendidos&quot;:</target>
        </trans-unit>
        <trans-unit id="14bde64cb771ba8e53f5e9a31e2a05f0cce773ef" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;Function.apply and Function.call in JavaScript&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">Desde &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;Function.apply y Function.call en JavaScript&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3add287d0cdcf70c3bf59b8bfe8c9a82d0d57d3f" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.apply()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">De &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;los documentos de MDN en Function.prototype.apply ()&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bd3a5577932f71a488767615582f0be99c3f9de9" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.call()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">De &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;los documentos de MDN en Function.prototype.call ()&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8a6d61910a41263d03dd96132c5abac9fae4f766" translate="yes" xml:space="preserve">
          <source>Fundamental difference is that &lt;code&gt;call()&lt;/code&gt; accepts an &lt;strong&gt;&lt;em&gt;argument list&lt;/em&gt;&lt;/strong&gt;, while &lt;code&gt;apply()&lt;/code&gt; accepts a &lt;strong&gt;&lt;em&gt;single array of arguments&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">La diferencia fundamental es que &lt;code&gt;call()&lt;/code&gt; acepta una &lt;strong&gt;&lt;em&gt;lista de argumentos&lt;/em&gt;&lt;/strong&gt; , mientras que &lt;code&gt;apply()&lt;/code&gt; acepta una &lt;strong&gt;&lt;em&gt;sola matriz de argumentos&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="942187b5d738457fccb4945d671c6c7f377dcc51" translate="yes" xml:space="preserve">
          <source>Here is a function allows you to create classes which also supports creating classes by extending other classes.</source>
          <target state="translated">Aquí hay una función que le permite crear clases que también apoya la creación de clases mediante la ampliación de otras clases.</target>
        </trans-unit>
        <trans-unit id="1323fd7ca757679d28a1f40534bf1a963305d403" translate="yes" xml:space="preserve">
          <source>Here's a good mnemonic.  &lt;b&gt;A&lt;/b&gt;pply uses &lt;b&gt;A&lt;/b&gt;rrays and &lt;b&gt;A&lt;/b&gt;lways takes one or two Arguments.  When you use &lt;b&gt;C&lt;/b&gt;all you have to &lt;b&gt;C&lt;/b&gt;ount the number of arguments.</source>
          <target state="translated">Aqu&amp;iacute; hay una buena mnem&amp;oacute;nica. &lt;b&gt;Una&lt;/b&gt; aplicaci&amp;oacute;n utiliza las matrices &lt;b&gt;A&lt;/b&gt; y &lt;b&gt;A siempre&lt;/b&gt; toma uno o dos argumentos. Cuando usa &lt;b&gt;C&lt;/b&gt; todo lo que tiene que hacer es contar la cantidad de argumentos.</target>
        </trans-unit>
        <trans-unit id="1e4389b4f2ebcb96347afd69578f2cd813e746b1" translate="yes" xml:space="preserve">
          <source>Here's a small-ish post, I wrote on this:</source>
          <target state="translated">Aquí hay un pequeño mensaje,que escribí en esto:</target>
        </trans-unit>
        <trans-unit id="ea15e06e4ebe329e80df768918f039ef391ead73" translate="yes" xml:space="preserve">
          <source>However, since neither &lt;code&gt;call()&lt;/code&gt; nor &lt;code&gt;apply()&lt;/code&gt; uses the value of its own receiver to substitute for the receiver argument when it is unspecified, the following will not work:</source>
          <target state="translated">Sin embargo, dado que ni &lt;code&gt;call()&lt;/code&gt; ni &lt;code&gt;apply()&lt;/code&gt; usan el valor de su propio receptor para sustituir el argumento del receptor cuando no est&amp;aacute; especificado, lo siguiente no funcionar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="1a3f8283d118d63985fb2ebf791c5a4dafe8d145" translate="yes" xml:space="preserve">
          <source>I'd like to show an example, where the 'valueForThis' argument is used:</source>
          <target state="translated">Me gustaría mostrar un ejemplo,en el que se utiliza el argumento 'valueForThis':</target>
        </trans-unit>
        <trans-unit id="31e7f36d4dd440ce5b9553f367da59ad9ead4375" translate="yes" xml:space="preserve">
          <source>If there is no explicit receiver when a function is called, then the global object becomes the receiver. As explained in &quot;goog.global&quot; on page 47, window is the global object when JavaScript is executed in a web browser. This leads to some surprising behavior:</source>
          <target state="translated">Si no hay un receptor explícito cuando se llama una función,entonces el objeto global se convierte en el receptor.Como se explica en &quot;goog.global&quot; en la página 47,la ventana es el objeto global cuando se ejecuta JavaScript en un navegador web.Esto lleva a un comportamiento sorprendente:</target>
        </trans-unit>
        <trans-unit id="f1f6c1d060169b5d72622cdaaae1407c94783e9a" translate="yes" xml:space="preserve">
          <source>It is useful at times for one object to borrow the function of another object, meaning that the borrowing object simply executes the lent function as if it were its own.</source>
          <target state="translated">A veces es útil que un objeto tome prestada la función de otro objeto,lo que significa que el objeto que toma prestado simplemente ejecuta la función prestada como si fuera propio.</target>
        </trans-unit>
        <trans-unit id="8634e981817686925fe0622fba7cbd2c9648ac2e" translate="yes" xml:space="preserve">
          <source>It may be helpful to think of a function as having no knowledge of the variable to which it is assigned. This helps reinforce the idea that the value of this will be bound when the function is called rather than when it is defined.</source>
          <target state="translated">Puede ser útil pensar que una función no tiene conocimiento de la variable a la que está asignada.Esto ayuda a reforzar la idea de que el valor de ésta estará ligado cuando se llame la función en lugar de cuando se defina.</target>
        </trans-unit>
        <trans-unit id="05d22044f701339e803a1cf0357dfbd48f69bdf0" translate="yes" xml:space="preserve">
          <source>K. Scott Allen has &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;a nice writeup&lt;/a&gt; on the matter.</source>
          <target state="translated">K. Scott Allen tiene &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;un buen art&amp;iacute;culo&lt;/a&gt; sobre el asunto.</target>
        </trans-unit>
        <trans-unit id="64eeed73ae33ab9543f5408d00eef328a4369714" translate="yes" xml:space="preserve">
          <source>Let me add a little detail to this.</source>
          <target state="translated">Déjame añadir un pequeño detalle a esto.</target>
        </trans-unit>
        <trans-unit id="6c5e9642f5ab0e0c0d894c77677a6ea6e20d683d" translate="yes" xml:space="preserve">
          <source>Note that the only difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is that &lt;code&gt;call()&lt;/code&gt; receives the function parameters as individual arguments, whereas &lt;code&gt;apply()&lt;/code&gt; receives them as a single array:</source>
          <target state="translated">Tenga en cuenta que la &amp;uacute;nica diferencia entre &lt;code&gt;call()&lt;/code&gt; y &lt;code&gt;apply()&lt;/code&gt; es que &lt;code&gt;call()&lt;/code&gt; recibe los par&amp;aacute;metros de la funci&amp;oacute;n como argumentos individuales, mientras que &lt;code&gt;apply()&lt;/code&gt; recibe como una sola matriz:</target>
        </trans-unit>
        <trans-unit id="50e6db257aa52978fbc08ee3e8da73cab00da33d" translate="yes" xml:space="preserve">
          <source>Observe how easily we delegated &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;sayHello&lt;/code&gt; using &lt;code&gt;apply&lt;/code&gt;, but with &lt;code&gt;call&lt;/code&gt; this is very difficult to achieve.</source>
          <target state="translated">Observe cu&amp;aacute;n f&amp;aacute;cilmente &lt;code&gt;sayHello&lt;/code&gt; &lt;code&gt;hello&lt;/code&gt; para decir hola usando &lt;code&gt;apply&lt;/code&gt; , pero con &lt;code&gt;call&lt;/code&gt; esto es muy dif&amp;iacute;cil de lograr.</target>
        </trans-unit>
        <trans-unit id="77fa40c42a69e7f8ac62aa570ce4ef4d599f5c92" translate="yes" xml:space="preserve">
          <source>Pseudo syntax:</source>
          <target state="translated">Pseudo sintaxis:</target>
        </trans-unit>
        <trans-unit id="bbd19d7653cc08e0948d447b0d060fac147cb4d7" translate="yes" xml:space="preserve">
          <source>Sample code:</source>
          <target state="translated">Código de muestra:</target>
        </trans-unit>
        <trans-unit id="c84cd0c805d087dfbf9ecd21a7b1bfe6fa40d2e0" translate="yes" xml:space="preserve">
          <source>Second parameter is a &lt;em&gt;Comma separated&lt;/em&gt; list of arguments (like &lt;em&gt;Call&lt;/em&gt;)</source>
          <target state="translated">El segundo par&amp;aacute;metro es una lista de argumentos &lt;em&gt;separados por comas&lt;/em&gt; (como &lt;em&gt;Llamada&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="6b5735e5c5f630760d9c6e70d4e262a3200a328b" translate="yes" xml:space="preserve">
          <source>See MDN's documentation on &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;apply&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;call&lt;/a&gt;.</source>
          <target state="translated">Consulte la documentaci&amp;oacute;n de MDN sobre &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;solicitud&lt;/a&gt; y &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;llamada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e3d090ce9e430e68be2e30177b06f2f38f52993" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Ver tambi&amp;eacute;n &lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;este viol&amp;iacute;n&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1726ded9a72315ef008837f9d84562b75cee30" translate="yes" xml:space="preserve">
          <source>See jsPerf, &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http://jsperf.com/test-call-vs-apply/3&lt;/a&gt;</source>
          <target state="translated">Ver jsPerf, &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http://jsperf.com/test-call-vs-apply/3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0021096d114de3a15392deed57a113bebd8414ff" translate="yes" xml:space="preserve">
          <source>So as you see, there is not a big difference, but still, there are cases we prefer using call() or apply(). For example, look at the code below, which finding the smallest and largest number in an array from MDN, using the apply method:</source>
          <target state="translated">Así que como ves,no hay una gran diferencia,pero aún así,hay casos en los que preferimos usar call()o apply().Por ejemplo,mira el código de abajo,que encuentra el número más pequeño y más grande en un array de MDN,usando el método apply:</target>
        </trans-unit>
        <trans-unit id="4b4525ba87ef2378d7872f06cb3f28507fba74e0" translate="yes" xml:space="preserve">
          <source>So the main difference is just the way we passing the arguments:</source>
          <target state="translated">Así que la principal diferencia es la forma en que pasamos los argumentos:</target>
        </trans-unit>
        <trans-unit id="427d1bd4c30d3818b0111b3da1b759634b43dba6" translate="yes" xml:space="preserve">
          <source>So, these calls complement each other. Where we expect an &lt;em&gt;iterable&lt;/em&gt;, &lt;code&gt;call&lt;/code&gt; works, where we expect an &lt;em&gt;array-like&lt;/em&gt;, &lt;code&gt;apply&lt;/code&gt; works.</source>
          <target state="translated">Entonces, estas llamadas se complementan entre s&amp;iacute;. Donde esperamos un &lt;em&gt;iterable&lt;/em&gt; , &lt;code&gt;call&lt;/code&gt; works, donde esperamos un &lt;em&gt;array-like&lt;/em&gt; , &lt;code&gt;apply&lt;/code&gt; trabajos.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="be3fe9f7c34a24b31d73676e6fcbab70ec9d2a9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apply&lt;/code&gt; accepts only &lt;strong&gt;&lt;em&gt;array-like&lt;/em&gt;&lt;/strong&gt; args.</source>
          <target state="translated">La &lt;code&gt;apply&lt;/code&gt; solo acepta &lt;strong&gt;&lt;em&gt;argumentos tipo matriz&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="800a7e8f32a2fc52d2a1ccad0b5fec64b6a8b77b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spread&lt;/code&gt; operator ... allows passing &lt;strong&gt;&lt;em&gt;iterable&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;args&lt;/code&gt; as the list to call.</source>
          <target state="translated">El operador de &lt;code&gt;spread&lt;/code&gt; ... permite pasar &lt;strong&gt;&lt;em&gt;argumentos iterables&lt;/em&gt;&lt;/strong&gt; como la lista para llamar.</target>
        </trans-unit>
        <trans-unit id="0adb79677cbacc2d4b026e0c984ae067a1f6a94a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; value can be tricky sometimes in javascript. The value of &lt;code&gt;this&lt;/code&gt; determined &lt;strong&gt;when a function is executed not when a function is defined.&lt;/strong&gt; If our function is dependend on a right &lt;code&gt;this&lt;/code&gt; binding we can use &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; to enforce this behaviour. For example:</source>
          <target state="translated">El valor de &lt;code&gt;this&lt;/code&gt; puede ser complicado a veces en javascript. El valor de &lt;code&gt;this&lt;/code&gt; determina &lt;strong&gt;cuando se ejecuta una funci&amp;oacute;n, no cuando se define una funci&amp;oacute;n.&lt;/strong&gt; Si nuestra funci&amp;oacute;n depende de un derecho de &lt;code&gt;this&lt;/code&gt; enlace, podemos usar &lt;code&gt;call()&lt;/code&gt; y &lt;code&gt;apply()&lt;/code&gt; para hacer cumplir este comportamiento. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="3deb699655f4906c5622205ca34014605769b7c7" translate="yes" xml:space="preserve">
          <source>The advantage I see in &lt;code&gt;apply&lt;/code&gt; over &lt;code&gt;call&lt;/code&gt; is that we can easily delegate a function call to other function without much effort;</source>
          <target state="translated">La ventaja que veo en &lt;code&gt;apply&lt;/code&gt; over &lt;code&gt;call&lt;/code&gt; es que podemos delegar f&amp;aacute;cilmente una llamada de funci&amp;oacute;n a otra funci&amp;oacute;n sin mucho esfuerzo;</target>
        </trans-unit>
        <trans-unit id="1edd355e36cac3e90aaa04f0fb88d78354ce5e11" translate="yes" xml:space="preserve">
          <source>The apply() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and
  arguments provided as an array (or an array-like object).</source>
          <target state="translated">El m&amp;eacute;todo apply () llama a una funci&amp;oacute;n con un valor dado y argumentos proporcionados como una matriz (o un objeto similar a una matriz).</target>
        </trans-unit>
        <trans-unit id="7ae8a2679fdcb09c537bfd9049c438ea47444d0c" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an
  array as the second parameter. The array represents the arguments for
  the target method.</source>
          <target state="translated">El método apply()es idéntico a call(),excepto que apply()requiere un array como segundo parámetro.El array representa los argumentos del método de destino.</target>
        </trans-unit>
        <trans-unit id="2d71d5ac49d58c30c32daad2d08ca0fd85341768" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an array as the second parameter. The array represents the arguments for the target method.&quot;</source>
          <target state="translated">El método apply()es idéntico a call(),excepto que apply()requiere un array como segundo parámetro.El array representa los argumentos del método de destino&quot;.</target>
        </trans-unit>
        <trans-unit id="98794248b75b56ec7704f02512ba3bee87f4290d" translate="yes" xml:space="preserve">
          <source>The call() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and arguments provided individually.</source>
          <target state="translated">El m&amp;eacute;todo call () llama a una funci&amp;oacute;n con un valor dado y argumentos proporcionados individualmente.</target>
        </trans-unit>
        <trans-unit id="0a0bb30e70de7ca8796f52e8fe26e16be5ab1adf" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;apply&lt;/code&gt; lets you invoke the function with &lt;code&gt;arguments&lt;/code&gt; as an array; &lt;code&gt;call&lt;/code&gt; requires the parameters be listed explicitly. A useful mnemonic is &lt;em&gt;&quot;&lt;strong&gt;A&lt;/strong&gt; for &lt;strong&gt;a&lt;/strong&gt;rray and &lt;strong&gt;C&lt;/strong&gt; for &lt;strong&gt;c&lt;/strong&gt;omma.&quot;&lt;/em&gt;</source>
          <target state="translated">La diferencia es que &lt;code&gt;apply&lt;/code&gt; permite invocar la funci&amp;oacute;n con &lt;code&gt;arguments&lt;/code&gt; como una matriz; &lt;code&gt;call&lt;/code&gt; requiere que los par&amp;aacute;metros se enumeren expl&amp;iacute;citamente. Un mnem&amp;oacute;nico &amp;uacute;til es &lt;em&gt;&quot; &lt;strong&gt;A&lt;/strong&gt; para &lt;strong&gt;una&lt;/strong&gt; matriz y &lt;strong&gt;C&lt;/strong&gt; para &lt;strong&gt;c&lt;/strong&gt; omma&quot;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="077cae04437beb54a5bf21b695d814008b99d489" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;call()&lt;/code&gt; takes the function arguments separately, and &lt;code&gt;apply()&lt;/code&gt; takes the function arguments in an array.</source>
          <target state="translated">La diferencia es que &lt;code&gt;call()&lt;/code&gt; toma los argumentos de la funci&amp;oacute;n por separado, y &lt;code&gt;apply()&lt;/code&gt; toma los argumentos de la funci&amp;oacute;n en una matriz.</target>
        </trans-unit>
        <trans-unit id="a2b670f55f2b2c65b072b1a94d61900f6d19c14f" translate="yes" xml:space="preserve">
          <source>The following calls are equivalent, as &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;obj.addValues&lt;/code&gt; refer to the same function:</source>
          <target state="translated">Las siguientes llamadas son equivalentes, ya que &lt;code&gt;f&lt;/code&gt; y &lt;code&gt;obj.addValues&lt;/code&gt; ​​se refieren a la misma funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="87e4cb2170c64eb87630ac2666ef22a7dec2032f" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is the way you have to pass in arguments into it. In both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; you pass as a first argument the object you want to be the value as &lt;code&gt;this&lt;/code&gt;. The other arguments differ in the following way:</source>
          <target state="translated">La principal diferencia entre &lt;code&gt;call()&lt;/code&gt; y &lt;code&gt;apply()&lt;/code&gt; es la forma en que tiene que pasarle argumentos. Tanto en &lt;code&gt;call()&lt;/code&gt; como en &lt;code&gt;apply()&lt;/code&gt; pasas como primer argumento el objeto que quieres que sea el valor como &lt;code&gt;this&lt;/code&gt; . Los otros argumentos difieren de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="596402989f831c546d2c32187093fca3be37cf23" translate="yes" xml:space="preserve">
          <source>The main difference is, using call, we can change the scope and pass arguments as normal, but apply lets you call it using arguments as an Array (pass them as an array). But in terms of what they to do in your code, they are pretty similar.</source>
          <target state="translated">La principal diferencia es que,usando la llamada,podemos cambiar el alcance y pasar los argumentos como normal,pero la aplicación te permite llamarla usando los argumentos como un Array (pasarlos como un array).Pero en términos de lo que deben hacer en tu código,son bastante similares.</target>
        </trans-unit>
        <trans-unit id="8d7fedd9b4da5ac143da38dbb316677883876482" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; can never be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; when a function is called. When &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; is supplied as the receiver to &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;apply()&lt;/code&gt;, the global object is used as the value for receiver instead. Therefore, the previous code has the same undesirable side effect of adding a property named &lt;code&gt;value&lt;/code&gt; to the global object.</source>
          <target state="translated">El valor de &lt;code&gt;this&lt;/code&gt; nunca puede ser &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; cuando se llama a una funci&amp;oacute;n. Cuando se proporciona &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; como el receptor para &lt;code&gt;call()&lt;/code&gt; o &lt;code&gt;apply()&lt;/code&gt; , el objeto global se usa como el valor para el receptor. Por lo tanto, el c&amp;oacute;digo anterior tiene el mismo efecto secundario no deseado de agregar una propiedad denominada &lt;code&gt;value&lt;/code&gt; al objeto global.</target>
        </trans-unit>
        <trans-unit id="705c96c2c38793b778f0b5c5706f6eeac05a0e3b" translate="yes" xml:space="preserve">
          <source>There is a advantage of using apply over call, we don't need to change the number of argument only we can change a array that is passed.</source>
          <target state="translated">Hay una ventaja de usar &quot;apply&quot; sobre &quot;call&quot;,no necesitamos cambiar el número de argumentos,sólo podemos cambiar una matriz que se pasa.</target>
        </trans-unit>
        <trans-unit id="2eb392d7966c258ea07940d00f4031c57a4537db" translate="yes" xml:space="preserve">
          <source>There is also, as of ES6, the possibility to &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/a&gt; the array for use with the &lt;code&gt;call&lt;/code&gt; function, you can see the compatibilities &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n existe, a partir de ES6, la posibilidad de &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt; &lt;code&gt;spread&lt;/code&gt; &lt;/a&gt; la matriz para su uso con la funci&amp;oacute;n de &lt;code&gt;call&lt;/code&gt; , puede ver las compatibilidades &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7c4bd1cb3d884ddea34c2bec769bb8d87d43918" translate="yes" xml:space="preserve">
          <source>There is not big difference in performance. But we can say call is bit faster as compare to apply because an array need to evaluate in apply method.</source>
          <target state="translated">No hay una gran diferencia en el rendimiento.Pero podemos decir que la llamada es un poco más rápida en comparación con la aplicación,porque una matriz necesita evaluar en el método de aplicación.</target>
        </trans-unit>
        <trans-unit id="038a8e5aedf1905dbd61b29a8291e8d5ad2624fd" translate="yes" xml:space="preserve">
          <source>There shouldn't be any performance differences, except maybe if you use &lt;code&gt;apply&lt;/code&gt; and wrap the arguments in an array (e.g. &lt;code&gt;f.apply(thisObject, [a, b, c])&lt;/code&gt; instead of &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt;). I haven't tested it, so there could be differences, but it would be very browser specific. It's likely that &lt;code&gt;call&lt;/code&gt; is faster if you don't already have the arguments in an array and &lt;code&gt;apply&lt;/code&gt; is faster if you do.</source>
          <target state="translated">No deber&amp;iacute;a haber ninguna diferencia de rendimiento, excepto tal vez si usa &lt;code&gt;apply&lt;/code&gt; y ajusta los argumentos en una matriz (por ejemplo, &lt;code&gt;f.apply(thisObject, [a, b, c])&lt;/code&gt; lugar de &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt; ). No lo he probado, por lo que podr&amp;iacute;a haber diferencias, pero ser&amp;iacute;a muy espec&amp;iacute;fico del navegador. Es probable que la &lt;code&gt;call&lt;/code&gt; sea ​​m&amp;aacute;s r&amp;aacute;pida si a&amp;uacute;n no tiene los argumentos en una matriz y la &lt;code&gt;apply&lt;/code&gt; es m&amp;aacute;s r&amp;aacute;pida si la tiene.</target>
        </trans-unit>
        <trans-unit id="01bd227613d09b74c9ae24ff8c1baf0d8a862f46" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s only a minor difference:</source>
          <target state="translated">Solo hay una peque&amp;ntilde;a diferencia:</target>
        </trans-unit>
        <trans-unit id="c7d9da52bcfc783e04a55a3022fc3c5ed5cfd9c2" translate="yes" xml:space="preserve">
          <source>These methods are very useful for giving objects temporary functionality.</source>
          <target state="translated">Estos métodos son muy útiles para dar a los objetos una funcionalidad temporal.</target>
        </trans-unit>
        <trans-unit id="e515be0593425c897d57b3bcf9bf116da6b34796" translate="yes" xml:space="preserve">
          <source>To answer the part about when to use each function, use &lt;code&gt;apply&lt;/code&gt; if you don't know the number of arguments you will be passing, or if they are already in an array or array-like object (like the &lt;code&gt;arguments&lt;/code&gt; object to forward your own arguments. Use &lt;code&gt;call&lt;/code&gt; otherwise, since there's no need to wrap the arguments in an array.</source>
          <target state="translated">Para responder a la parte sobre cu&amp;aacute;ndo usar cada funci&amp;oacute;n, use &lt;code&gt;apply&lt;/code&gt; si no sabe la cantidad de argumentos que pasar&amp;aacute;, o si ya est&amp;aacute;n en una matriz o en un objeto similar a una matriz (como el objeto de &lt;code&gt;arguments&lt;/code&gt; para reenviar sus propios argumentos) Utilice &lt;code&gt;call&lt;/code&gt; de lo contrario, ya que no es necesario ajustar los argumentos en una matriz.</target>
        </trans-unit>
        <trans-unit id="459d31f484cba8ff55a14c2b6a8caed822cccbb3" translate="yes" xml:space="preserve">
          <source>We can differentiate call and apply methods as below</source>
          <target state="translated">Podemos diferenciar los métodos de llamada y aplicación de la siguiente manera</target>
        </trans-unit>
        <trans-unit id="ef483139bf3063f7265084c4928da48c3e58d003" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;this&lt;/code&gt; Refers to When a Function is Called</source>
          <target state="translated">A qu&amp;eacute; se refiere &lt;code&gt;this&lt;/code&gt; cuando se llama a una funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="817a1f3c7afd39e9d3dc253e082d14edca07f774" translate="yes" xml:space="preserve">
          <source>What is the difference between call and apply</source>
          <target state="translated">¿Cuál es la diferencia entre llamar y aplicar</target>
        </trans-unit>
        <trans-unit id="8dc03d9498368a753500ba7c0e3c07e5ad163085" translate="yes" xml:space="preserve">
          <source>What is the difference between using &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; to invoke a function?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la diferencia entre usar &lt;code&gt;call&lt;/code&gt; y &lt;code&gt;apply&lt;/code&gt; para invocar una funci&amp;oacute;n?</target>
        </trans-unit>
        <trans-unit id="b8bcd29c1c651d5d8282a5ee2cb6ec09bb376610" translate="yes" xml:space="preserve">
          <source>When I'm not passing any arguments (like your example), I prefer &lt;code&gt;call&lt;/code&gt; since I'm &lt;em&gt;calling&lt;/em&gt; the function. &lt;code&gt;apply&lt;/code&gt; would imply you are &lt;em&gt;applying&lt;/em&gt; the function to the (non-existent) arguments.</source>
          <target state="translated">Cuando no estoy pasando ning&amp;uacute;n argumento (como su ejemplo), prefiero &lt;code&gt;call&lt;/code&gt; ya que estoy &lt;em&gt;llamando a&lt;/em&gt; la funci&amp;oacute;n. &lt;code&gt;apply&lt;/code&gt; implicar&amp;iacute;a que est&amp;aacute; &lt;em&gt;aplicando&lt;/em&gt; la funci&amp;oacute;n a los argumentos (inexistentes).</target>
        </trans-unit>
        <trans-unit id="5a16bf745c4863e0508e7d91383d2e774866cde3" translate="yes" xml:space="preserve">
          <source>When calling a function of the form &lt;code&gt;foo.bar.baz()&lt;/code&gt;, the object &lt;code&gt;foo.bar&lt;/code&gt; is referred to as the receiver. When the function is called, it is the receiver that is used as the value for &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Cuando se llama a una funci&amp;oacute;n de la forma &lt;code&gt;foo.bar.baz()&lt;/code&gt; , el objeto &lt;code&gt;foo.bar&lt;/code&gt; se denomina receptor. Cuando se llama a la funci&amp;oacute;n, se utiliza el receptor como valor para &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="19f7d47da63f1ec3a5a607ab70ef2cd71438073d" translate="yes" xml:space="preserve">
          <source>While the syntax of this function is almost identical to that of
  apply(), the fundamental difference is that call() accepts an argument
  list, while apply() accepts a single array of arguments.</source>
          <target state="translated">Mientras que la sintaxis de esta función es casi idéntica a la de apply(),la diferencia fundamental es que call()acepta una lista de argumentos,mientras que apply()acepta una única matriz de argumentos.</target>
        </trans-unit>
        <trans-unit id="a29c055ff6868d5e2dd5a25b5d8f44e7374c60f7" translate="yes" xml:space="preserve">
          <source>While this is an old topic, I just wanted to point out that .call is slightly faster than .apply. I can't tell you exactly why.</source>
          <target state="translated">Aunque este es un tema antiguo,sólo quería señalar que .call es un poco más rápido que .apply.No puedo decirte exactamente por qué.</target>
        </trans-unit>
        <trans-unit id="3d7f8b6f8472e1bf79cfbd6e21fd3463d34684e8" translate="yes" xml:space="preserve">
          <source>Why would I need to use these functions?</source>
          <target state="translated">¿Por qué necesitaría usar estas funciones?</target>
        </trans-unit>
        <trans-unit id="c992b9a520f2bac4efd1704b5aa357812b16b9b7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;apply()&lt;/code&gt; you have to pass in array of arguments.</source>
          <target state="translated">Con &lt;code&gt;apply()&lt;/code&gt; tienes que pasar una variedad de argumentos.</target>
        </trans-unit>
        <trans-unit id="26eff599b0938eced4e28336770d2c95e3f85671" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;call()&lt;/code&gt; you have to put in the arguments normally (starting from the second argument)</source>
          <target state="translated">Con &lt;code&gt;call()&lt;/code&gt; tienes que poner los argumentos normalmente (comenzando desde el segundo argumento)</target>
        </trans-unit>
        <trans-unit id="107c1ad078b8e5fd09a8cade0ac071ada14ec050" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;UPDATE!&lt;/code&gt;]</source>
          <target state="translated">[&lt;code&gt;UPDATE!&lt;/code&gt;]</target>
        </trans-unit>
        <trans-unit id="52205160ec0710bc4b4b11af5b7768320b679b63" translate="yes" xml:space="preserve">
          <source>and apply() takes an array of arguments, ex:</source>
          <target state="translated">y aplicar()toma una serie de argumentos,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6d388c62f51244c2e2efe98118e8338e8667bfbc" translate="yes" xml:space="preserve">
          <source>here are few more usage examples: 
&lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&lt;/a&gt;</source>
          <target state="translated">Aqu&amp;iacute; hay algunos ejemplos de uso m&amp;aacute;s: &lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1746639d3e223680fd2af4999668bb34d143203" translate="yes" xml:space="preserve">
          <source>these two calls are almost equivalent:</source>
          <target state="translated">estas dos llamadas son casi equivalentes:</target>
        </trans-unit>
        <trans-unit id="c2b7df6201fdd3362399091f0a29550df3505b6a" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
