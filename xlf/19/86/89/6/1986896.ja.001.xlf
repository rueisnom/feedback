<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1986896">
    <body>
      <group id="1986896">
        <trans-unit id="6a6e1f6bba7be766351d79af2c0144878d9e5b0b" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;A for array and C for comma&amp;rdquo; is a handy mnemonic.</source>
          <target state="translated">「配列の場合はA、コンマの場合はC」は便利なニーモニックです。</target>
        </trans-unit>
        <trans-unit id="073092991cddd6d87b6774cbd67a486dc6a12a34" translate="yes" xml:space="preserve">
          <source>**details: &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http://es5.github.io/#x15.4.4.7&lt;/a&gt;*</source>
          <target state="translated">**詳細： &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http&lt;/a&gt; : //es5.github.io/#x15.4.4.7 *</target>
        </trans-unit>
        <trans-unit id="2627567f32b8adbe0cee5ec161a0a5d3e23d84d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func.apply();&lt;/code&gt; vs &lt;code&gt;func.call();&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;func.apply();&lt;/code&gt; vs &lt;code&gt;func.call();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516a2e912059b0fa8868493150af5bbad99c0fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A small code example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;小さなコード例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06609c98c8d0351c2cdce0383962f34e0421d30c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Apply:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Apply:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b4d5526e7322d3829a9925f60260e3d2f15826d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Call:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbd3e95548b7020e64ae03b229a1444a868c3a07" translate="yes" xml:space="preserve">
          <source>APPLY : Call a function with argument provided as an array. You can use apply if you don't know how many argument are going to pass to the function.</source>
          <target state="translated">APPLY:引数に配列を与えて関数を呼び出します。関数に渡される引数の数がわからない場合に使用することができます。</target>
        </trans-unit>
        <trans-unit id="c00657a448f4711f76278443d96c86de31acb2df" translate="yes" xml:space="preserve">
          <source>And for objects that are both &lt;em&gt;iterable&lt;/em&gt; and &lt;em&gt;array-like&lt;/em&gt;, like a real array, we technically could use any of them, but &lt;strong&gt;&lt;em&gt;apply&lt;/em&gt;&lt;/strong&gt; will probably be &lt;strong&gt;faster&lt;/strong&gt; because most JavaScript engines internally optimize it better.</source>
          <target state="translated">そして、実際の配列の&lt;em&gt;ように&lt;/em&gt; 、 &lt;em&gt;反復可能&lt;/em&gt;で&lt;em&gt;配列のような&lt;/em&gt;オブジェクトの場合、技術的にはそれらのいずれかを使用でき&lt;strong&gt;&lt;em&gt;ます&lt;/em&gt;&lt;/strong&gt;が、ほとんどのJavaScriptエンジンは内部でより適切に最適化するため、 &lt;strong&gt;&lt;em&gt;適用&lt;/em&gt;&lt;/strong&gt;はおそらく&lt;strong&gt;高速に&lt;/strong&gt;なります。</target>
        </trans-unit>
        <trans-unit id="5c9ecb4ae5137755d8f716322b21d78969c95d9d" translate="yes" xml:space="preserve">
          <source>Another example with Call, Apply and Bind.
The difference between Call and Apply is evident, but &lt;strong&gt;Bind&lt;/strong&gt; works like this:</source>
          <target state="translated">呼び出し、適用、バインドの別の例。 呼び出しと適用の違いは明らかですが、 &lt;strong&gt;バインド&lt;/strong&gt;は次のように機能します。</target>
        </trans-unit>
        <trans-unit id="e0664236e12ed01e6900c7d9cb8ffb41e962a4de" translate="yes" xml:space="preserve">
          <source>Apply takes an array of arguments, while Call takes zero or more individual parameters! Ah hah!</source>
          <target state="translated">適用は引数の配列を取りますが、呼び出しは0個以上の個別のパラメータを取ります! アハハ!</target>
        </trans-unit>
        <trans-unit id="ff9c2b698e62e669161a993499cb291ae88ffa2d" translate="yes" xml:space="preserve">
          <source>Are there performance differences between the two aforementioned methods? When is it best to use &lt;code&gt;call&lt;/code&gt; over &lt;code&gt;apply&lt;/code&gt; and vice versa?</source>
          <target state="translated">前述の2つの方法の間にパフォーマンスの違いはありますか？ &lt;code&gt;call&lt;/code&gt; オーバーの &lt;code&gt;apply&lt;/code&gt; とその逆の使用が最適なのはいつですか？</target>
        </trans-unit>
        <trans-unit id="bd06993ea011e8d1b377551096b54f21460ca6ef" translate="yes" xml:space="preserve">
          <source>Basically, they differ on how they handle function arguments.</source>
          <target state="translated">基本的には、関数の引数の扱い方で違いがあります。</target>
        </trans-unit>
        <trans-unit id="6691472c714089786101ef2e15dc2184a94f6836" translate="yes" xml:space="preserve">
          <source>Because functions are first-class objects in JavaScript, they can have their own methods. All functions have the methods &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; which make it possible to redefine the receiver (i.e., the object that &lt;code&gt;this&lt;/code&gt; refers to) when calling the function. The method signatures are as follows:</source>
          <target state="translated">関数はJavaScriptではファーストクラスのオブジェクトであるため、独自のメソッドを持つことができます。 すべての関数にはメソッド &lt;code&gt;call()&lt;/code&gt; と &lt;code&gt;apply()&lt;/code&gt; があり、関数を呼び出すときにレシーバー（つまり、 &lt;code&gt;this&lt;/code&gt; 参照するオブジェクト）を再定義できます。 メソッドのシグネチャは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0f08f437360dac1640a51eb913a901ace0e1c309" translate="yes" xml:space="preserve">
          <source>Bind returns an instance of a function that can be executed</source>
          <target state="translated">Bind は、実行可能な関数のインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="ed70176671e52914281d5006df38717fa96fa92a" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; are methods which are located on &lt;code&gt;Function.prototype&lt;/code&gt;. Therefore they are available on every function object via the prototype chain. Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; can execute a function with a specified value of the &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; と &lt;code&gt;apply()&lt;/code&gt; はどちらも &lt;code&gt;Function.prototype&lt;/code&gt; にあるメソッドです。 したがって、これらはプロトタイプチェーンを介してすべての関数オブジェクトで使用できます。 &lt;code&gt;call()&lt;/code&gt; と &lt;code&gt;apply()&lt;/code&gt; はどちらも、 &lt;code&gt;this&lt;/code&gt; の値を指定して関数を実行できます 。</target>
        </trans-unit>
        <trans-unit id="43fad9d50904f98023f5b5618af1a58a2e54e88b" translate="yes" xml:space="preserve">
          <source>CALL : A function with argument provide individually.
If you know the arguments to be passed or there are no argument to pass you can use call.</source>
          <target state="translated">CALL:引数を個別に提供する関数です。渡すべき引数が決まっている場合や、渡すべき引数がない場合にはCALLを使うことができます。</target>
        </trans-unit>
        <trans-unit id="af5f158c4f3a19a2c844e241715bb0c6ede21a92" translate="yes" xml:space="preserve">
          <source>Call and apply both are used to force the &lt;code&gt;this&lt;/code&gt; value when a function is executed. The only difference is that &lt;code&gt;call&lt;/code&gt; takes &lt;code&gt;n+1&lt;/code&gt; arguments where 1 is &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;'n' arguments&lt;/code&gt;. &lt;code&gt;apply&lt;/code&gt; takes only two arguments, one is &lt;code&gt;this&lt;/code&gt; the other is argument array.</source>
          <target state="translated">呼び出しと適用の両方を使用して、関数の実行時に &lt;code&gt;this&lt;/code&gt; 値を強制します。 唯一の違いは、 &lt;code&gt;call&lt;/code&gt; は &lt;code&gt;n+1&lt;/code&gt; 個の引数を取る &lt;code&gt;'n' arguments&lt;/code&gt; です。ここで、1は &lt;code&gt;this&lt;/code&gt; と「n」個の引数です。 &lt;code&gt;apply&lt;/code&gt; は2つの引数しか取りません。1つは &lt;code&gt;this&lt;/code&gt; 、もう1つは引数の配列です。</target>
        </trans-unit>
        <trans-unit id="2c5f0501fc2b6f1924d35819be6e0f772b696be1" translate="yes" xml:space="preserve">
          <source>Call() takes comma-separated arguments, ex:</source>
          <target state="translated">Call()はカンマで区切られた引数を取ります。</target>
        </trans-unit>
        <trans-unit id="6be24a97cdca9d9739d2f77bbc3f540977649073" translate="yes" xml:space="preserve">
          <source>Code example :</source>
          <target state="translated">コード例 .</target>
        </trans-unit>
        <trans-unit id="2e84f30b198ef7d854811359c47bddf90fa3a603" translate="yes" xml:space="preserve">
          <source>Difference between these to methods are, how you want to pass the parameters.</source>
          <target state="translated">これらのメソッドとの違いは、パラメータをどのように渡すかということです。</target>
        </trans-unit>
        <trans-unit id="20751e1ac2443cd0bb58e1d765835240c2c0aa16" translate="yes" xml:space="preserve">
          <source>Douglas Crockford mentions briefly the difference between the two, which may help explain the performance difference... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</source>
          <target state="translated">Douglas Crockfordが2つの違いを簡単に述べていますが、これはパフォーマンスの違いを説明するのに役立ちます... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42a6de742cb9fd5f887fa14b79df4fb670c8ac43" translate="yes" xml:space="preserve">
          <source>End of extract.</source>
          <target state="translated">抽出終了。</target>
        </trans-unit>
        <trans-unit id="e54fcc4e07d4859ffb15960ee0fc1a09971d3f34" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; achive the same thing, I think there is atleast one place where you cannot use &lt;code&gt;call&lt;/code&gt; but can only use &lt;code&gt;apply&lt;/code&gt;. That is when you want to support inheritance and want to call the constructor.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; と &lt;code&gt;apply&lt;/code&gt; は同じことですが、 &lt;code&gt;call&lt;/code&gt; を使用できず、 &lt;code&gt;apply&lt;/code&gt; しか使用できない場所が少なくとも1つあると思います 。 これは、継承をサポートし、コンストラクターを呼び出したい場合です。</target>
        </trans-unit>
        <trans-unit id="cf723110c4d2bbc5c861b13982508ba988c39761" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;obj.addValues&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; refer to the same function, they behave differently when called because the value of the receiver is different in each call. For this reason, when calling a function that refers to &lt;code&gt;this&lt;/code&gt;, it is important to ensure that &lt;code&gt;this&lt;/code&gt; will have the correct value when it is called. To be clear, if &lt;code&gt;this&lt;/code&gt; were not referenced in the function body, then the behavior of &lt;code&gt;f(20)&lt;/code&gt; and &lt;code&gt;obj.addValues(20)&lt;/code&gt; would be the same.</source>
          <target state="translated">&lt;code&gt;obj.addValues&lt;/code&gt; と &lt;code&gt;f&lt;/code&gt; が同じ関数を参照していても、レシーバーの値は呼び出しごとに異なるため、呼び出されたときの動作は異なります。 このため、thisを参照する関数を呼び出すときは、これが呼び出されたときに正しい値になるようにすることが重要です。 明確にするために、 &lt;code&gt;this&lt;/code&gt; が関数本体で参照されていない場合、 &lt;code&gt;f(20)&lt;/code&gt; と &lt;code&gt;obj.addValues(20)&lt;/code&gt; の動作は同じになります。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="7e3d4b30db26a1e1dfba2fd2e16fc8ff0be1049d" translate="yes" xml:space="preserve">
          <source>First Parameter is '&lt;em&gt;this&lt;/em&gt;'</source>
          <target state="translated">最初のパラメータは「 &lt;em&gt;これ&lt;/em&gt; 」です</target>
        </trans-unit>
        <trans-unit id="fbe6ab2ec20f25874154873020df4d336159bf55" translate="yes" xml:space="preserve">
          <source>Follows an extract from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;Closure: The Definitive Guide by Michael Bolin&lt;/a&gt;. It might look a bit lengthy, but it's saturated with a lot of insight. From &quot;Appendix B. Frequently Misunderstood JavaScript Concepts&quot;:</source>
          <target state="translated">&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;Closure：Michael BolinによるThe Definitive Guideの&lt;/a&gt;抜粋に従います。 少し長く見えるかもしれませんが、多くの洞察で飽和しています。 「付録B.よく誤解されているJavaScriptの概念」から：</target>
        </trans-unit>
        <trans-unit id="14bde64cb771ba8e53f5e9a31e2a05f0cce773ef" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;Function.apply and Function.call in JavaScript&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">&lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;JavaScriptのFunction.applyおよびFunction.call&lt;/strong&gt;&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="3add287d0cdcf70c3bf59b8bfe8c9a82d0d57d3f" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.apply()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;Function.prototype.apply（）のMDNドキュメント&lt;/strong&gt;&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="bd3a5577932f71a488767615582f0be99c3f9de9" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.call()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;Function.prototype.call（）のMDNドキュメント&lt;/strong&gt;&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="8a6d61910a41263d03dd96132c5abac9fae4f766" translate="yes" xml:space="preserve">
          <source>Fundamental difference is that &lt;code&gt;call()&lt;/code&gt; accepts an &lt;strong&gt;&lt;em&gt;argument list&lt;/em&gt;&lt;/strong&gt;, while &lt;code&gt;apply()&lt;/code&gt; accepts a &lt;strong&gt;&lt;em&gt;single array of arguments&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">基本的な違いは、 &lt;code&gt;call()&lt;/code&gt; が&lt;strong&gt;&lt;em&gt;引数リストを&lt;/em&gt;&lt;/strong&gt;受け入れるのに対し、 &lt;code&gt;apply()&lt;/code&gt; は&lt;strong&gt;&lt;em&gt;引数の単一配列を&lt;/em&gt;&lt;/strong&gt;受け入れる&lt;strong&gt;&lt;em&gt;こと&lt;/em&gt;&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="942187b5d738457fccb4945d671c6c7f377dcc51" translate="yes" xml:space="preserve">
          <source>Here is a function allows you to create classes which also supports creating classes by extending other classes.</source>
          <target state="translated">ここでは、他のクラスを拡張してクラスを作成することもサポートしているクラス作成機能を紹介します。</target>
        </trans-unit>
        <trans-unit id="1323fd7ca757679d28a1f40534bf1a963305d403" translate="yes" xml:space="preserve">
          <source>Here's a good mnemonic.  &lt;b&gt;A&lt;/b&gt;pply uses &lt;b&gt;A&lt;/b&gt;rrays and &lt;b&gt;A&lt;/b&gt;lways takes one or two Arguments.  When you use &lt;b&gt;C&lt;/b&gt;all you have to &lt;b&gt;C&lt;/b&gt;ount the number of arguments.</source>
          <target state="translated">ここに良いニーモニックがあります。 プライは&lt;b&gt;A&lt;/b&gt;レイを使用し、 &lt;b&gt;A&lt;/b&gt;ウェイは1つまたは2つの引数を取ります。 &lt;b&gt;C&lt;/b&gt;を使用する場合、必要なのは引数の数だけです。</target>
        </trans-unit>
        <trans-unit id="1e4389b4f2ebcb96347afd69578f2cd813e746b1" translate="yes" xml:space="preserve">
          <source>Here's a small-ish post, I wrote on this:</source>
          <target state="translated">ここに書いた小ネタです。</target>
        </trans-unit>
        <trans-unit id="ea15e06e4ebe329e80df768918f039ef391ead73" translate="yes" xml:space="preserve">
          <source>However, since neither &lt;code&gt;call()&lt;/code&gt; nor &lt;code&gt;apply()&lt;/code&gt; uses the value of its own receiver to substitute for the receiver argument when it is unspecified, the following will not work:</source>
          <target state="translated">ただし、 &lt;code&gt;call()&lt;/code&gt; も &lt;code&gt;apply()&lt;/code&gt; （）も指定されていない場合、レシーバー引数の代わりに独自のレシーバーの値を使用しないため、以下は機能しません。</target>
        </trans-unit>
        <trans-unit id="1a3f8283d118d63985fb2ebf791c5a4dafe8d145" translate="yes" xml:space="preserve">
          <source>I'd like to show an example, where the 'valueForThis' argument is used:</source>
          <target state="translated">引数'valueForThis'を使用した例を紹介したいと思います。</target>
        </trans-unit>
        <trans-unit id="31e7f36d4dd440ce5b9553f367da59ad9ead4375" translate="yes" xml:space="preserve">
          <source>If there is no explicit receiver when a function is called, then the global object becomes the receiver. As explained in &quot;goog.global&quot; on page 47, window is the global object when JavaScript is executed in a web browser. This leads to some surprising behavior:</source>
          <target state="translated">関数が呼ばれたときに明示的な受け手がいない場合は、グローバルオブジェクトが受け手になります。47ページの「goog.global」で説明したように、WebブラウザでJavaScriptを実行すると、windowがグローバルオブジェクトになります。これは、いくつかの驚くべき動作につながります。</target>
        </trans-unit>
        <trans-unit id="f1f6c1d060169b5d72622cdaaae1407c94783e9a" translate="yes" xml:space="preserve">
          <source>It is useful at times for one object to borrow the function of another object, meaning that the borrowing object simply executes the lent function as if it were its own.</source>
          <target state="translated">あるオブジェクトが別のオブジェクトの関数を借りることができる場合がありますが、これは、借りているオブジェクトが自分自身の関数であるかのように、単に貸し出された関数を実行することを意味します。</target>
        </trans-unit>
        <trans-unit id="8634e981817686925fe0622fba7cbd2c9648ac2e" translate="yes" xml:space="preserve">
          <source>It may be helpful to think of a function as having no knowledge of the variable to which it is assigned. This helps reinforce the idea that the value of this will be bound when the function is called rather than when it is defined.</source>
          <target state="translated">関数は代入された変数を知らないと考えると便利かもしれません。これは、関数が定義されたときではなく、関数が呼び出されたときにこの値が拘束されるという考えを強化するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="05d22044f701339e803a1cf0357dfbd48f69bdf0" translate="yes" xml:space="preserve">
          <source>K. Scott Allen has &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;a nice writeup&lt;/a&gt; on the matter.</source>
          <target state="translated">K.スコットアレンは&lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;、&lt;/a&gt;この問題について素晴らしい記事を書いています。</target>
        </trans-unit>
        <trans-unit id="64eeed73ae33ab9543f5408d00eef328a4369714" translate="yes" xml:space="preserve">
          <source>Let me add a little detail to this.</source>
          <target state="translated">少しだけ補足させてください。</target>
        </trans-unit>
        <trans-unit id="6c5e9642f5ab0e0c0d894c77677a6ea6e20d683d" translate="yes" xml:space="preserve">
          <source>Note that the only difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is that &lt;code&gt;call()&lt;/code&gt; receives the function parameters as individual arguments, whereas &lt;code&gt;apply()&lt;/code&gt; receives them as a single array:</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; と &lt;code&gt;apply()&lt;/code&gt; の唯一の違いは、 &lt;code&gt;call()&lt;/code&gt; が関数パラメーターを個別の引数として受け取るのに対し、 &lt;code&gt;apply()&lt;/code&gt; はそれらを単一の配列として受け取ることです。</target>
        </trans-unit>
        <trans-unit id="50e6db257aa52978fbc08ee3e8da73cab00da33d" translate="yes" xml:space="preserve">
          <source>Observe how easily we delegated &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;sayHello&lt;/code&gt; using &lt;code&gt;apply&lt;/code&gt;, but with &lt;code&gt;call&lt;/code&gt; this is very difficult to achieve.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; を使用して &lt;code&gt;hello&lt;/code&gt; を &lt;code&gt;sayHello&lt;/code&gt; に委任するのがいかに簡単かを確認しますが、 &lt;code&gt;call&lt;/code&gt; これを達成するのは非常に困難です。</target>
        </trans-unit>
        <trans-unit id="77fa40c42a69e7f8ac62aa570ce4ef4d599f5c92" translate="yes" xml:space="preserve">
          <source>Pseudo syntax:</source>
          <target state="translated">疑似構文。</target>
        </trans-unit>
        <trans-unit id="bbd19d7653cc08e0948d447b0d060fac147cb4d7" translate="yes" xml:space="preserve">
          <source>Sample code:</source>
          <target state="translated">サンプルコード。</target>
        </trans-unit>
        <trans-unit id="c84cd0c805d087dfbf9ecd21a7b1bfe6fa40d2e0" translate="yes" xml:space="preserve">
          <source>Second parameter is a &lt;em&gt;Comma separated&lt;/em&gt; list of arguments (like &lt;em&gt;Call&lt;/em&gt;)</source>
          <target state="translated">2番目のパラメータは、 &lt;em&gt;カンマで区切られた&lt;/em&gt;引数のリストです（ &lt;em&gt;Callなど&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b5735e5c5f630760d9c6e70d4e262a3200a328b" translate="yes" xml:space="preserve">
          <source>See MDN's documentation on &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;apply&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;call&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;適用&lt;/a&gt;と&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;呼び出し&lt;/a&gt;については、MDNのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0e3d090ce9e430e68be2e30177b06f2f38f52993" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;このフィドル&lt;/strong&gt;&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="6d1726ded9a72315ef008837f9d84562b75cee30" translate="yes" xml:space="preserve">
          <source>See jsPerf, &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http://jsperf.com/test-call-vs-apply/3&lt;/a&gt;</source>
          <target state="translated">jsPerf、 &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http：&lt;/a&gt; //jsperf.com/test-call-vs-apply/3を参照してください</target>
        </trans-unit>
        <trans-unit id="0021096d114de3a15392deed57a113bebd8414ff" translate="yes" xml:space="preserve">
          <source>So as you see, there is not a big difference, but still, there are cases we prefer using call() or apply(). For example, look at the code below, which finding the smallest and largest number in an array from MDN, using the apply method:</source>
          <target state="translated">ご覧のように、大きな違いはありませんが、それでも call()または apply()を使用することを好むケースがあります。例えば、以下のコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4b4525ba87ef2378d7872f06cb3f28507fba74e0" translate="yes" xml:space="preserve">
          <source>So the main difference is just the way we passing the arguments:</source>
          <target state="translated">主な違いは引数の渡し方だけです。</target>
        </trans-unit>
        <trans-unit id="427d1bd4c30d3818b0111b3da1b759634b43dba6" translate="yes" xml:space="preserve">
          <source>So, these calls complement each other. Where we expect an &lt;em&gt;iterable&lt;/em&gt;, &lt;code&gt;call&lt;/code&gt; works, where we expect an &lt;em&gt;array-like&lt;/em&gt;, &lt;code&gt;apply&lt;/code&gt; works.</source>
          <target state="translated">したがって、これらの呼び出しはお互いを補完します。 &lt;em&gt;反復可能な&lt;/em&gt; 、 &lt;code&gt;call&lt;/code&gt; の動作が予想される場合、 &lt;em&gt;配列のような&lt;/em&gt; &lt;code&gt;apply&lt;/code&gt; の動作が予想される場合 。</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="be3fe9f7c34a24b31d73676e6fcbab70ec9d2a9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apply&lt;/code&gt; accepts only &lt;strong&gt;&lt;em&gt;array-like&lt;/em&gt;&lt;/strong&gt; args.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; は、 &lt;strong&gt;&lt;em&gt;配列のような&lt;/em&gt;&lt;/strong&gt;引数のみを受け入れます 。</target>
        </trans-unit>
        <trans-unit id="800a7e8f32a2fc52d2a1ccad0b5fec64b6a8b77b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spread&lt;/code&gt; operator ... allows passing &lt;strong&gt;&lt;em&gt;iterable&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;args&lt;/code&gt; as the list to call.</source>
          <target state="translated">&lt;code&gt;spread&lt;/code&gt; 演算子...は、呼び出すリストとして&lt;strong&gt;&lt;em&gt;反復可能な&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;args&lt;/code&gt; を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="0adb79677cbacc2d4b026e0c984ae067a1f6a94a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; value can be tricky sometimes in javascript. The value of &lt;code&gt;this&lt;/code&gt; determined &lt;strong&gt;when a function is executed not when a function is defined.&lt;/strong&gt; If our function is dependend on a right &lt;code&gt;this&lt;/code&gt; binding we can use &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; to enforce this behaviour. For example:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 値は、JavaScriptでときどきトリッキーになることがあります。 この値は&lt;strong&gt;、関数が定義されたときではなく、関数が実行されたときに&lt;/strong&gt;決定&lt;strong&gt;されます。&lt;/strong&gt; 関数が &lt;code&gt;this&lt;/code&gt; バインディングに依存している場合、 &lt;code&gt;call()&lt;/code&gt; と &lt;code&gt;apply()&lt;/code&gt; を使用してこの動作を強制できます 。 例えば：</target>
        </trans-unit>
        <trans-unit id="3deb699655f4906c5622205ca34014605769b7c7" translate="yes" xml:space="preserve">
          <source>The advantage I see in &lt;code&gt;apply&lt;/code&gt; over &lt;code&gt;call&lt;/code&gt; is that we can easily delegate a function call to other function without much effort;</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; の &lt;code&gt;call&lt;/code&gt; も優れている点は、関数呼び出しを他の関数に簡単に委任できることです。</target>
        </trans-unit>
        <trans-unit id="1edd355e36cac3e90aaa04f0fb88d78354ce5e11" translate="yes" xml:space="preserve">
          <source>The apply() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and
  arguments provided as an array (or an array-like object).</source>
          <target state="translated">apply（）メソッドは、指定された &lt;code&gt;this&lt;/code&gt; 値と配列（または配列のようなオブジェクト）として提供された引数を使用して関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="7ae8a2679fdcb09c537bfd9049c438ea47444d0c" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an
  array as the second parameter. The array represents the arguments for
  the target method.</source>
          <target state="translated">apply()メソッドは call()と同じですが、 apply()は 2 番目のパラメータとして配列を必要とします。配列は、ターゲットメソッドの引数を表します。</target>
        </trans-unit>
        <trans-unit id="2d71d5ac49d58c30c32daad2d08ca0fd85341768" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an array as the second parameter. The array represents the arguments for the target method.&quot;</source>
          <target state="translated">apply()メソッドは call()と同じですが、 apply()は 2 番目のパラメータとして配列を必要とします。配列はターゲットメソッドの引数を表します。&quot;</target>
        </trans-unit>
        <trans-unit id="98794248b75b56ec7704f02512ba3bee87f4290d" translate="yes" xml:space="preserve">
          <source>The call() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and arguments provided individually.</source>
          <target state="translated">call（）メソッドは、指定された &lt;code&gt;this&lt;/code&gt; 値と個別に提供された引数を使用して関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="0a0bb30e70de7ca8796f52e8fe26e16be5ab1adf" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;apply&lt;/code&gt; lets you invoke the function with &lt;code&gt;arguments&lt;/code&gt; as an array; &lt;code&gt;call&lt;/code&gt; requires the parameters be listed explicitly. A useful mnemonic is &lt;em&gt;&quot;&lt;strong&gt;A&lt;/strong&gt; for &lt;strong&gt;a&lt;/strong&gt;rray and &lt;strong&gt;C&lt;/strong&gt; for &lt;strong&gt;c&lt;/strong&gt;omma.&quot;&lt;/em&gt;</source>
          <target state="translated">違いは、 &lt;code&gt;apply&lt;/code&gt; を使用すると、 &lt;code&gt;arguments&lt;/code&gt; を配列として使用して関数を呼び出すことができることです。 &lt;code&gt;call&lt;/code&gt; は、パラメーターを明示的にリストする必要があります。 便利なニーモニックは、 &lt;em&gt;「レイ&lt;strong&gt;の&lt;/strong&gt;場合&lt;/em&gt;は&lt;em&gt;&lt;strong&gt;A&lt;/strong&gt; &lt;strong&gt;、&lt;/strong&gt;コンマ&lt;strong&gt;の&lt;/strong&gt;場合&lt;strong&gt;は&lt;/strong&gt; &lt;strong&gt;C&lt;/strong&gt; 」です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="077cae04437beb54a5bf21b695d814008b99d489" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;call()&lt;/code&gt; takes the function arguments separately, and &lt;code&gt;apply()&lt;/code&gt; takes the function arguments in an array.</source>
          <target state="translated">違いは、 &lt;code&gt;call()&lt;/code&gt; は関数の引数を個別に受け取り、 &lt;code&gt;apply()&lt;/code&gt; は関数の引数を配列で受け取ることです。</target>
        </trans-unit>
        <trans-unit id="a2b670f55f2b2c65b072b1a94d61900f6d19c14f" translate="yes" xml:space="preserve">
          <source>The following calls are equivalent, as &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;obj.addValues&lt;/code&gt; refer to the same function:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; と &lt;code&gt;obj.addValues&lt;/code&gt; は同じ関数を参照するため、次の呼び出しは同等です。</target>
        </trans-unit>
        <trans-unit id="87e4cb2170c64eb87630ac2666ef22a7dec2032f" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is the way you have to pass in arguments into it. In both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; you pass as a first argument the object you want to be the value as &lt;code&gt;this&lt;/code&gt;. The other arguments differ in the following way:</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; と &lt;code&gt;apply()&lt;/code&gt; の主な違いは、引数をそれに渡す方法です。 &lt;code&gt;call()&lt;/code&gt; と &lt;code&gt;apply()&lt;/code&gt; の両方で、 &lt;code&gt;this&lt;/code&gt; として値にしたいオブジェクトを最初の引数として渡します。 他の引数は次のように異なります。</target>
        </trans-unit>
        <trans-unit id="596402989f831c546d2c32187093fca3be37cf23" translate="yes" xml:space="preserve">
          <source>The main difference is, using call, we can change the scope and pass arguments as normal, but apply lets you call it using arguments as an Array (pass them as an array). But in terms of what they to do in your code, they are pretty similar.</source>
          <target state="translated">主な違いは、callを使うと通常通りにスコープを変更して引数を渡すことができますが、applyを使うと引数を配列(配列として渡す)にして呼び出すことができます。しかし、あなたのコードで何をするかという点では、彼らはかなり似ています。</target>
        </trans-unit>
        <trans-unit id="8d7fedd9b4da5ac143da38dbb316677883876482" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; can never be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; when a function is called. When &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; is supplied as the receiver to &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;apply()&lt;/code&gt;, the global object is used as the value for receiver instead. Therefore, the previous code has the same undesirable side effect of adding a property named &lt;code&gt;value&lt;/code&gt; to the global object.</source>
          <target state="translated">この値は、関数が呼び出されたときに &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; になることはありません。 &lt;code&gt;call()&lt;/code&gt; または &lt;code&gt;apply()&lt;/code&gt; のレシーバーとして &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; が指定されている場合、代わりにグローバルオブジェクトがレシーバーの値として使用されます。 したがって、前のコードには、 &lt;code&gt;value&lt;/code&gt; という名前のプロパティをグローバルオブジェクトに追加するのと同じ望ましくない副作用があります。</target>
        </trans-unit>
        <trans-unit id="705c96c2c38793b778f0b5c5706f6eeac05a0e3b" translate="yes" xml:space="preserve">
          <source>There is a advantage of using apply over call, we don't need to change the number of argument only we can change a array that is passed.</source>
          <target state="translated">呼び出しよりも適用を使うことの利点は、引数の数を変更する必要がなく、渡された配列を変更することができることです。</target>
        </trans-unit>
        <trans-unit id="2eb392d7966c258ea07940d00f4031c57a4537db" translate="yes" xml:space="preserve">
          <source>There is also, as of ES6, the possibility to &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/a&gt; the array for use with the &lt;code&gt;call&lt;/code&gt; function, you can see the compatibilities &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">ES6では、 &lt;code&gt;call&lt;/code&gt; 関数で使用するために配列を拡張する可能性もあり&lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;ます&lt;/a&gt; 。互換性については、 こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="c7c4bd1cb3d884ddea34c2bec769bb8d87d43918" translate="yes" xml:space="preserve">
          <source>There is not big difference in performance. But we can say call is bit faster as compare to apply because an array need to evaluate in apply method.</source>
          <target state="translated">性能に大きな差はありません。しかし、 apply メソッドでは配列を評価する必要があるため、 apply メソッドに比べて call の方が少し速いと言えます。</target>
        </trans-unit>
        <trans-unit id="038a8e5aedf1905dbd61b29a8291e8d5ad2624fd" translate="yes" xml:space="preserve">
          <source>There shouldn't be any performance differences, except maybe if you use &lt;code&gt;apply&lt;/code&gt; and wrap the arguments in an array (e.g. &lt;code&gt;f.apply(thisObject, [a, b, c])&lt;/code&gt; instead of &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt;). I haven't tested it, so there could be differences, but it would be very browser specific. It's likely that &lt;code&gt;call&lt;/code&gt; is faster if you don't already have the arguments in an array and &lt;code&gt;apply&lt;/code&gt; is faster if you do.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; を使用して引数を配列にラップする場合（ &lt;code&gt;f.apply(thisObject, [a, b, c])&lt;/code&gt; を &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt; ではなく）使用する場合を除いて、パフォーマンスに違いはありません。 c）） ）。 私はそれをテストしていません、それで違いがあるかもしれません、しかしそれは非常にブラウザ特有です。 配列に引数がない場合は &lt;code&gt;call&lt;/code&gt; が速くなり、ある場合は &lt;code&gt;apply&lt;/code&gt; が速くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="01bd227613d09b74c9ae24ff8c1baf0d8a862f46" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s only a minor difference:</source>
          <target state="translated">わずかな違いがあります：</target>
        </trans-unit>
        <trans-unit id="c7d9da52bcfc783e04a55a3022fc3c5ed5cfd9c2" translate="yes" xml:space="preserve">
          <source>These methods are very useful for giving objects temporary functionality.</source>
          <target state="translated">これらのメソッドは、オブジェクトに一時的な機能を与えるのに非常に便利です。</target>
        </trans-unit>
        <trans-unit id="e515be0593425c897d57b3bcf9bf116da6b34796" translate="yes" xml:space="preserve">
          <source>To answer the part about when to use each function, use &lt;code&gt;apply&lt;/code&gt; if you don't know the number of arguments you will be passing, or if they are already in an array or array-like object (like the &lt;code&gt;arguments&lt;/code&gt; object to forward your own arguments. Use &lt;code&gt;call&lt;/code&gt; otherwise, since there's no need to wrap the arguments in an array.</source>
          <target state="translated">各関数をいつ使用 &lt;code&gt;apply&lt;/code&gt; かという部分に答えるには、渡す引数の数がわからない場合、またはそれらがすでに配列または配列のようなオブジェクト（独自のオブジェクトを転送する &lt;code&gt;arguments&lt;/code&gt; オブジェクトのように）にある場合は、 applyを使用します。 arguments。引数を配列でラップする必要がないため、それ以外の場合は &lt;code&gt;call&lt;/code&gt; を使用します 。</target>
        </trans-unit>
        <trans-unit id="459d31f484cba8ff55a14c2b6a8caed822cccbb3" translate="yes" xml:space="preserve">
          <source>We can differentiate call and apply methods as below</source>
          <target state="translated">呼び出しメソッドと適用メソッドを以下のように区別することができます。</target>
        </trans-unit>
        <trans-unit id="ef483139bf3063f7265084c4928da48c3e58d003" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;this&lt;/code&gt; Refers to When a Function is Called</source>
          <target state="translated">関数が呼び出されたときの意味</target>
        </trans-unit>
        <trans-unit id="817a1f3c7afd39e9d3dc253e082d14edca07f774" translate="yes" xml:space="preserve">
          <source>What is the difference between call and apply</source>
          <target state="translated">呼び出しと適用の違いは?</target>
        </trans-unit>
        <trans-unit id="8dc03d9498368a753500ba7c0e3c07e5ad163085" translate="yes" xml:space="preserve">
          <source>What is the difference between using &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; to invoke a function?</source>
          <target state="translated">関数を呼び出すための &lt;code&gt;call&lt;/code&gt; と &lt;code&gt;apply&lt;/code&gt; 違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="b8bcd29c1c651d5d8282a5ee2cb6ec09bb376610" translate="yes" xml:space="preserve">
          <source>When I'm not passing any arguments (like your example), I prefer &lt;code&gt;call&lt;/code&gt; since I'm &lt;em&gt;calling&lt;/em&gt; the function. &lt;code&gt;apply&lt;/code&gt; would imply you are &lt;em&gt;applying&lt;/em&gt; the function to the (non-existent) arguments.</source>
          <target state="translated">（例のように）引数を渡さない場合は、関数を &lt;code&gt;call&lt;/code&gt; ため、 call &lt;em&gt;を使用&lt;/em&gt;します。 &lt;code&gt;apply&lt;/code&gt; は、関数を（存在しない）引数に適用していることを意味します。</target>
        </trans-unit>
        <trans-unit id="5a16bf745c4863e0508e7d91383d2e774866cde3" translate="yes" xml:space="preserve">
          <source>When calling a function of the form &lt;code&gt;foo.bar.baz()&lt;/code&gt;, the object &lt;code&gt;foo.bar&lt;/code&gt; is referred to as the receiver. When the function is called, it is the receiver that is used as the value for &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;foo.bar.baz()&lt;/code&gt; という形式の関数を呼び出す場合、オブジェクト &lt;code&gt;foo.bar&lt;/code&gt; はレシーバーと呼ばれます。 関数が呼び出されると、これの値として使用されるのはレシーバーです。</target>
        </trans-unit>
        <trans-unit id="19f7d47da63f1ec3a5a607ab70ef2cd71438073d" translate="yes" xml:space="preserve">
          <source>While the syntax of this function is almost identical to that of
  apply(), the fundamental difference is that call() accepts an argument
  list, while apply() accepts a single array of arguments.</source>
          <target state="translated">この関数の構文は apply()とほぼ同じですが、基本的な違いは call()が引数のリストを受け付けるのに対し、 apply()は引数の単一の配列を受け付けることです。</target>
        </trans-unit>
        <trans-unit id="a29c055ff6868d5e2dd5a25b5d8f44e7374c60f7" translate="yes" xml:space="preserve">
          <source>While this is an old topic, I just wanted to point out that .call is slightly faster than .apply. I can't tell you exactly why.</source>
          <target state="translated">これは古い話題ですが、.callは.applyよりもわずかに速いということを指摘しておきたいと思います。正確な理由はわかりませんが、.callは.applyよりも若干速いです。</target>
        </trans-unit>
        <trans-unit id="3d7f8b6f8472e1bf79cfbd6e21fd3463d34684e8" translate="yes" xml:space="preserve">
          <source>Why would I need to use these functions?</source>
          <target state="translated">なぜこれらの機能を使う必要があるのか?</target>
        </trans-unit>
        <trans-unit id="c992b9a520f2bac4efd1704b5aa357812b16b9b7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;apply()&lt;/code&gt; you have to pass in array of arguments.</source>
          <target state="translated">&lt;code&gt;apply()&lt;/code&gt; では 、引数の配列を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="26eff599b0938eced4e28336770d2c95e3f85671" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;call()&lt;/code&gt; you have to put in the arguments normally (starting from the second argument)</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; を使用して、引数を通常どおりに入力する必要があります（2番目の引数から開始）</target>
        </trans-unit>
        <trans-unit id="107c1ad078b8e5fd09a8cade0ac071ada14ec050" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;UPDATE!&lt;/code&gt;]</source>
          <target state="translated">[&lt;code&gt;UPDATE!&lt;/code&gt;]</target>
        </trans-unit>
        <trans-unit id="52205160ec0710bc4b4b11af5b7768320b679b63" translate="yes" xml:space="preserve">
          <source>and apply() takes an array of arguments, ex:</source>
          <target state="translated">は引数の配列を取ります。</target>
        </trans-unit>
        <trans-unit id="6d388c62f51244c2e2efe98118e8338e8667bfbc" translate="yes" xml:space="preserve">
          <source>here are few more usage examples: 
&lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&lt;/a&gt;</source>
          <target state="translated">ここにいくつかの使用例があります： &lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http&lt;/a&gt; : //blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/</target>
        </trans-unit>
        <trans-unit id="d1746639d3e223680fd2af4999668bb34d143203" translate="yes" xml:space="preserve">
          <source>these two calls are almost equivalent:</source>
          <target state="translated">この2つの呼び出しはほぼ同等です。</target>
        </trans-unit>
        <trans-unit id="c2b7df6201fdd3362399091f0a29550df3505b6a" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
