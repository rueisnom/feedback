<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1986896">
    <body>
      <group id="1986896">
        <trans-unit id="6a6e1f6bba7be766351d79af2c0144878d9e5b0b" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;A for array and C for comma&amp;rdquo; is a handy mnemonic.</source>
          <target state="translated">&amp;ldquo;배열의 경우 A와 쉼표의 경우 C&amp;rdquo;는 편리한 니모닉입니다.</target>
        </trans-unit>
        <trans-unit id="073092991cddd6d87b6774cbd67a486dc6a12a34" translate="yes" xml:space="preserve">
          <source>**details: &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http://es5.github.io/#x15.4.4.7&lt;/a&gt;*</source>
          <target state="translated">** 세부 사항 : &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http://es5.github.io/#x15.4.4.7&lt;/a&gt; *</target>
        </trans-unit>
        <trans-unit id="2627567f32b8adbe0cee5ec161a0a5d3e23d84d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func.apply();&lt;/code&gt; vs &lt;code&gt;func.call();&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;func.apply();&lt;/code&gt; vs &lt;code&gt;func.call();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516a2e912059b0fa8868493150af5bbad99c0fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A small code example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;작은 코드 예 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06609c98c8d0351c2cdce0383962f34e0421d30c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Apply:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Apply:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b4d5526e7322d3829a9925f60260e3d2f15826d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Call:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbd3e95548b7020e64ae03b229a1444a868c3a07" translate="yes" xml:space="preserve">
          <source>APPLY : Call a function with argument provided as an array. You can use apply if you don't know how many argument are going to pass to the function.</source>
          <target state="translated">적용 : 배열로 제공된 인수로 함수를 호출합니다. 함수에 몇 개의 인수가 전달되는지 모르는 경우 apply를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00657a448f4711f76278443d96c86de31acb2df" translate="yes" xml:space="preserve">
          <source>And for objects that are both &lt;em&gt;iterable&lt;/em&gt; and &lt;em&gt;array-like&lt;/em&gt;, like a real array, we technically could use any of them, but &lt;strong&gt;&lt;em&gt;apply&lt;/em&gt;&lt;/strong&gt; will probably be &lt;strong&gt;faster&lt;/strong&gt; because most JavaScript engines internally optimize it better.</source>
          <target state="translated">실제 배열 &lt;em&gt;처럼&lt;/em&gt; &lt;em&gt;반복 가능&lt;/em&gt; 하고 &lt;em&gt;배열과 같은&lt;/em&gt; 객체의 경우 기술적으로 사용할 수 있지만 대부분의 JavaScript 엔진은 내부적으로 더 잘 최적화하기 때문에 &lt;strong&gt;&lt;em&gt;적용&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;속도&lt;/strong&gt; 가 &lt;strong&gt;더 빠를&lt;/strong&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c9ecb4ae5137755d8f716322b21d78969c95d9d" translate="yes" xml:space="preserve">
          <source>Another example with Call, Apply and Bind.
The difference between Call and Apply is evident, but &lt;strong&gt;Bind&lt;/strong&gt; works like this:</source>
          <target state="translated">Call, Apply 및 Bind의 또 다른 예입니다. Call과 Apply의 차이점은 분명하지만 &lt;strong&gt;Bind&lt;/strong&gt; 는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e0664236e12ed01e6900c7d9cb8ffb41e962a4de" translate="yes" xml:space="preserve">
          <source>Apply takes an array of arguments, while Call takes zero or more individual parameters! Ah hah!</source>
          <target state="translated">Apply는 인수의 배열을 취하지 만 Call은 0 개 이상의 개별 매개 변수를 사용합니다! 아하!</target>
        </trans-unit>
        <trans-unit id="ff9c2b698e62e669161a993499cb291ae88ffa2d" translate="yes" xml:space="preserve">
          <source>Are there performance differences between the two aforementioned methods? When is it best to use &lt;code&gt;call&lt;/code&gt; over &lt;code&gt;apply&lt;/code&gt; and vice versa?</source>
          <target state="translated">위에서 언급 한 두 가지 방법간에 성능 차이가 있습니까? &lt;code&gt;call&lt;/code&gt; 오버 &lt;code&gt;apply&lt;/code&gt; 을 사용하는 것이 가장 좋은 방법은 언제입니까?</target>
        </trans-unit>
        <trans-unit id="bd06993ea011e8d1b377551096b54f21460ca6ef" translate="yes" xml:space="preserve">
          <source>Basically, they differ on how they handle function arguments.</source>
          <target state="translated">기본적으로 함수 인수를 처리하는 방법이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6691472c714089786101ef2e15dc2184a94f6836" translate="yes" xml:space="preserve">
          <source>Because functions are first-class objects in JavaScript, they can have their own methods. All functions have the methods &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; which make it possible to redefine the receiver (i.e., the object that &lt;code&gt;this&lt;/code&gt; refers to) when calling the function. The method signatures are as follows:</source>
          <target state="translated">함수는 JavaScript에서 일류 객체이므로 자체 메서드를 가질 수 있습니다. 모든 함수에는 &lt;code&gt;call()&lt;/code&gt; 및 &lt;code&gt;apply()&lt;/code&gt; 메소드가있어 함수를 호출 할 때 수신자 (즉,이 오브젝트가 참조하는 오브젝트)를 재정의 할 수 있습니다. 메소드 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f08f437360dac1640a51eb913a901ace0e1c309" translate="yes" xml:space="preserve">
          <source>Bind returns an instance of a function that can be executed</source>
          <target state="translated">바인드는 실행될 수있는 함수의 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed70176671e52914281d5006df38717fa96fa92a" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; are methods which are located on &lt;code&gt;Function.prototype&lt;/code&gt;. Therefore they are available on every function object via the prototype chain. Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; can execute a function with a specified value of the &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; 과 &lt;code&gt;apply()&lt;/code&gt; 는 &lt;code&gt;Function.prototype&lt;/code&gt; 에있는 메소드입니다. 따라서 프로토 타입 체인을 통해 모든 함수 객체에서 사용할 수 있습니다. &lt;code&gt;call()&lt;/code&gt; 과 &lt;code&gt;apply()&lt;/code&gt; 모두 &lt;code&gt;this&lt;/code&gt; 의 지정된 값으로 함수를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43fad9d50904f98023f5b5618af1a58a2e54e88b" translate="yes" xml:space="preserve">
          <source>CALL : A function with argument provide individually.
If you know the arguments to be passed or there are no argument to pass you can use call.</source>
          <target state="translated">CALL : 인수가있는 함수는 개별적으로 제공합니다. 전달할 인수를 알고 있거나 전달할 인수가 없으면 call을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af5f158c4f3a19a2c844e241715bb0c6ede21a92" translate="yes" xml:space="preserve">
          <source>Call and apply both are used to force the &lt;code&gt;this&lt;/code&gt; value when a function is executed. The only difference is that &lt;code&gt;call&lt;/code&gt; takes &lt;code&gt;n+1&lt;/code&gt; arguments where 1 is &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;'n' arguments&lt;/code&gt;. &lt;code&gt;apply&lt;/code&gt; takes only two arguments, one is &lt;code&gt;this&lt;/code&gt; the other is argument array.</source>
          <target state="translated">함수가 실행될 &lt;code&gt;this&lt;/code&gt; 값을 강제하기 위해 호출 및 적용 둘 다 사용됩니다. 유일한 차이점은 &lt;code&gt;call&lt;/code&gt; 은 &lt;code&gt;n+1&lt;/code&gt; 인수를 취한다는 것입니다. 여기서 1은 &lt;code&gt;this&lt;/code&gt; 및 &lt;code&gt;'n' arguments&lt;/code&gt; 입니다. &lt;code&gt;apply&lt;/code&gt; 는 두 개의 인수 만 사용합니다. 하나는 다른 하나는 인수 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2c5f0501fc2b6f1924d35819be6e0f772b696be1" translate="yes" xml:space="preserve">
          <source>Call() takes comma-separated arguments, ex:</source>
          <target state="translated">Call ()은 쉼표로 구분 된 인수를 사용합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="6be24a97cdca9d9739d2f77bbc3f540977649073" translate="yes" xml:space="preserve">
          <source>Code example :</source>
          <target state="translated">코드 예 :</target>
        </trans-unit>
        <trans-unit id="2e84f30b198ef7d854811359c47bddf90fa3a603" translate="yes" xml:space="preserve">
          <source>Difference between these to methods are, how you want to pass the parameters.</source>
          <target state="translated">이들과 메소드의 차이점은 매개 변수 전달 방법입니다.</target>
        </trans-unit>
        <trans-unit id="20751e1ac2443cd0bb58e1d765835240c2c0aa16" translate="yes" xml:space="preserve">
          <source>Douglas Crockford mentions briefly the difference between the two, which may help explain the performance difference... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</source>
          <target state="translated">Douglas Crockford는 성능 차이를 설명하는 데 도움이되는 두 가지 차이점을 간단히 언급합니다 ... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42a6de742cb9fd5f887fa14b79df4fb670c8ac43" translate="yes" xml:space="preserve">
          <source>End of extract.</source>
          <target state="translated">추출물의 끝.</target>
        </trans-unit>
        <trans-unit id="e54fcc4e07d4859ffb15960ee0fc1a09971d3f34" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; achive the same thing, I think there is atleast one place where you cannot use &lt;code&gt;call&lt;/code&gt; but can only use &lt;code&gt;apply&lt;/code&gt;. That is when you want to support inheritance and want to call the constructor.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 와 &lt;code&gt;apply&lt;/code&gt; 이 같은 것을 달성하더라도 전화를 사용할 수 없지만 &lt;code&gt;apply&lt;/code&gt; 만 사용할 수있는 곳이 적어도 하나는 있다고 생각 합니다 . 상속을 지원하고 생성자를 호출하려고 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="cf723110c4d2bbc5c861b13982508ba988c39761" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;obj.addValues&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; refer to the same function, they behave differently when called because the value of the receiver is different in each call. For this reason, when calling a function that refers to &lt;code&gt;this&lt;/code&gt;, it is important to ensure that &lt;code&gt;this&lt;/code&gt; will have the correct value when it is called. To be clear, if &lt;code&gt;this&lt;/code&gt; were not referenced in the function body, then the behavior of &lt;code&gt;f(20)&lt;/code&gt; and &lt;code&gt;obj.addValues(20)&lt;/code&gt; would be the same.</source>
          <target state="translated">&lt;code&gt;obj.addValues&lt;/code&gt; 와 &lt;code&gt;f&lt;/code&gt; 는 같은 함수를 참조하지만 호출 할 때마다 수신자의 값이 다르므로 호출 될 때 다르게 동작합니다. 이러한 이유로 this를 참조하는 함수를 호출 할 때 이것이 호출 될 때 올바른 값을 갖도록하는 것이 중요합니다. 분명히, &lt;code&gt;this&lt;/code&gt; 함수 본문에서 참조되지 않은 경우 &lt;code&gt;f(20)&lt;/code&gt; 및 &lt;code&gt;obj.addValues(20)&lt;/code&gt; 의 동작은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="7e3d4b30db26a1e1dfba2fd2e16fc8ff0be1049d" translate="yes" xml:space="preserve">
          <source>First Parameter is '&lt;em&gt;this&lt;/em&gt;'</source>
          <target state="translated">첫 번째 매개 변수는 ' &lt;em&gt;this&lt;/em&gt; '입니다</target>
        </trans-unit>
        <trans-unit id="fbe6ab2ec20f25874154873020df4d336159bf55" translate="yes" xml:space="preserve">
          <source>Follows an extract from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;Closure: The Definitive Guide by Michael Bolin&lt;/a&gt;. It might look a bit lengthy, but it's saturated with a lot of insight. From &quot;Appendix B. Frequently Misunderstood JavaScript Concepts&quot;:</source>
          <target state="translated">&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;Michael Bolin의 Closure : The Definitive Guide&lt;/a&gt; 에서 발췌 한 내용입니다. 약간 길어 보일 수 있지만 통찰력이 풍부합니다. &quot;부록 B. 자주 JavaScript 개념을 오해&quot;:</target>
        </trans-unit>
        <trans-unit id="14bde64cb771ba8e53f5e9a31e2a05f0cce773ef" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;Function.apply and Function.call in JavaScript&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">&lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;JavaScript의 Function.apply 및 Function.call에서&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3add287d0cdcf70c3bf59b8bfe8c9a82d0d57d3f" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.apply()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;Function.prototype.apply ()의 MDN 문서에서&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bd3a5577932f71a488767615582f0be99c3f9de9" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.call()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;Function.prototype.call ()의 MDN 문서에서&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8a6d61910a41263d03dd96132c5abac9fae4f766" translate="yes" xml:space="preserve">
          <source>Fundamental difference is that &lt;code&gt;call()&lt;/code&gt; accepts an &lt;strong&gt;&lt;em&gt;argument list&lt;/em&gt;&lt;/strong&gt;, while &lt;code&gt;apply()&lt;/code&gt; accepts a &lt;strong&gt;&lt;em&gt;single array of arguments&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">근본적인 차이점은 &lt;code&gt;call()&lt;/code&gt; 은 &lt;strong&gt;&lt;em&gt;인수 list를&lt;/em&gt;&lt;/strong&gt; 허용하고 &lt;code&gt;apply()&lt;/code&gt; 는 &lt;strong&gt;&lt;em&gt;단일 인수 배열을&lt;/em&gt;&lt;/strong&gt; 허용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="942187b5d738457fccb4945d671c6c7f377dcc51" translate="yes" xml:space="preserve">
          <source>Here is a function allows you to create classes which also supports creating classes by extending other classes.</source>
          <target state="translated">다음은 다른 클래스를 확장하여 클래스 작성을 지원하는 클래스를 작성할 수있는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1323fd7ca757679d28a1f40534bf1a963305d403" translate="yes" xml:space="preserve">
          <source>Here's a good mnemonic.  &lt;b&gt;A&lt;/b&gt;pply uses &lt;b&gt;A&lt;/b&gt;rrays and &lt;b&gt;A&lt;/b&gt;lways takes one or two Arguments.  When you use &lt;b&gt;C&lt;/b&gt;all you have to &lt;b&gt;C&lt;/b&gt;ount the number of arguments.</source>
          <target state="translated">좋은 니모닉이 있습니다. pply는 &lt;b&gt;A&lt;/b&gt; rray를 사용하고 &lt;b&gt;A&lt;/b&gt; lway는 하나 또는 두 개의 인수를 사용합니다. &lt;b&gt;C&lt;/b&gt; 를 사용할 때는 인수 개수를 모두 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e4389b4f2ebcb96347afd69578f2cd813e746b1" translate="yes" xml:space="preserve">
          <source>Here's a small-ish post, I wrote on this:</source>
          <target state="translated">여기에 작은 글이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea15e06e4ebe329e80df768918f039ef391ead73" translate="yes" xml:space="preserve">
          <source>However, since neither &lt;code&gt;call()&lt;/code&gt; nor &lt;code&gt;apply()&lt;/code&gt; uses the value of its own receiver to substitute for the receiver argument when it is unspecified, the following will not work:</source>
          <target state="translated">그러나 &lt;code&gt;call()&lt;/code&gt; 이나 &lt;code&gt;apply()&lt;/code&gt; 는 수신자 인수가 지정되지 않은 경우 수신자 인수를 대신하기 위해 자체 수신자 값을 사용하지 않으므로 다음과 같이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a3f8283d118d63985fb2ebf791c5a4dafe8d145" translate="yes" xml:space="preserve">
          <source>I'd like to show an example, where the 'valueForThis' argument is used:</source>
          <target state="translated">'valueForThis'인수가 사용되는 예제를 보여주고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="31e7f36d4dd440ce5b9553f367da59ad9ead4375" translate="yes" xml:space="preserve">
          <source>If there is no explicit receiver when a function is called, then the global object becomes the receiver. As explained in &quot;goog.global&quot; on page 47, window is the global object when JavaScript is executed in a web browser. This leads to some surprising behavior:</source>
          <target state="translated">함수가 호출 될 때 명시적인 수신자가 없으면 전역 오브젝트가 수신자가됩니다. 47 페이지의 &quot;goog.global&quot;에 설명 된대로 window는 웹 브라우저에서 JavaScript가 실행될 때 전역 객체입니다. 이것은 놀라운 행동으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="f1f6c1d060169b5d72622cdaaae1407c94783e9a" translate="yes" xml:space="preserve">
          <source>It is useful at times for one object to borrow the function of another object, meaning that the borrowing object simply executes the lent function as if it were its own.</source>
          <target state="translated">때로는 한 객체가 다른 객체의 기능을 빌리는 것이 유용합니다. 즉, 빌린 객체는 빌려 진 함수를 마치 마치 마치 마치 마치 마치 마치 마치 마치 마치 마치 자신의 함수처럼 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8634e981817686925fe0622fba7cbd2c9648ac2e" translate="yes" xml:space="preserve">
          <source>It may be helpful to think of a function as having no knowledge of the variable to which it is assigned. This helps reinforce the idea that the value of this will be bound when the function is called rather than when it is defined.</source>
          <target state="translated">함수가 할당 된 변수에 대한 지식이없는 것으로 생각하면 도움이 될 수 있습니다. 이는 함수가 정의 될 때가 아니라 함수가 호출 될 때이 값이 바인드 될 것이라는 아이디어를 강화하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="05d22044f701339e803a1cf0357dfbd48f69bdf0" translate="yes" xml:space="preserve">
          <source>K. Scott Allen has &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;a nice writeup&lt;/a&gt; on the matter.</source>
          <target state="translated">K. Scott Allen &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;은이&lt;/a&gt; 문제에 대해 좋은 글 을 남겼 습니다.</target>
        </trans-unit>
        <trans-unit id="64eeed73ae33ab9543f5408d00eef328a4369714" translate="yes" xml:space="preserve">
          <source>Let me add a little detail to this.</source>
          <target state="translated">이것에 약간의 세부 사항을 추가하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6c5e9642f5ab0e0c0d894c77677a6ea6e20d683d" translate="yes" xml:space="preserve">
          <source>Note that the only difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is that &lt;code&gt;call()&lt;/code&gt; receives the function parameters as individual arguments, whereas &lt;code&gt;apply()&lt;/code&gt; receives them as a single array:</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; 과 &lt;code&gt;apply()&lt;/code&gt; 의 유일한 차이점은 call () 은 함수 매개 변수를 개별 인수로 수신하는 반면 &lt;code&gt;apply()&lt;/code&gt; 는 단일 배열로 수신한다는 점입니다.</target>
        </trans-unit>
        <trans-unit id="50e6db257aa52978fbc08ee3e8da73cab00da33d" translate="yes" xml:space="preserve">
          <source>Observe how easily we delegated &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;sayHello&lt;/code&gt; using &lt;code&gt;apply&lt;/code&gt;, but with &lt;code&gt;call&lt;/code&gt; this is very difficult to achieve.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 를 사용하여 &lt;code&gt;hello&lt;/code&gt; 를 &lt;code&gt;sayHello&lt;/code&gt; 에 얼마나 쉽게 위임했는지 관찰하십시오. 그러나 &lt;code&gt;call&lt;/code&gt; 는 달성하기가 매우 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="77fa40c42a69e7f8ac62aa570ce4ef4d599f5c92" translate="yes" xml:space="preserve">
          <source>Pseudo syntax:</source>
          <target state="translated">의사 구문 :</target>
        </trans-unit>
        <trans-unit id="bbd19d7653cc08e0948d447b0d060fac147cb4d7" translate="yes" xml:space="preserve">
          <source>Sample code:</source>
          <target state="translated">샘플 코드 :</target>
        </trans-unit>
        <trans-unit id="c84cd0c805d087dfbf9ecd21a7b1bfe6fa40d2e0" translate="yes" xml:space="preserve">
          <source>Second parameter is a &lt;em&gt;Comma separated&lt;/em&gt; list of arguments (like &lt;em&gt;Call&lt;/em&gt;)</source>
          <target state="translated">두 번째 매개 변수는 &lt;em&gt;쉼표로 구분 된&lt;/em&gt; 인수 목록입니다 (예 : &lt;em&gt;Call&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="6b5735e5c5f630760d9c6e70d4e262a3200a328b" translate="yes" xml:space="preserve">
          <source>See MDN's documentation on &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;apply&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;call&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;apply&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;call&lt;/a&gt; 에 대한 MDN 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e3d090ce9e430e68be2e30177b06f2f38f52993" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;이 바이올린을&lt;/strong&gt;&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d1726ded9a72315ef008837f9d84562b75cee30" translate="yes" xml:space="preserve">
          <source>See jsPerf, &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http://jsperf.com/test-call-vs-apply/3&lt;/a&gt;</source>
          <target state="translated">jsPerf, &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http://jsperf.com/test-call-vs-apply/3&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="0021096d114de3a15392deed57a113bebd8414ff" translate="yes" xml:space="preserve">
          <source>So as you see, there is not a big difference, but still, there are cases we prefer using call() or apply(). For example, look at the code below, which finding the smallest and largest number in an array from MDN, using the apply method:</source>
          <target state="translated">보시다시피 큰 차이는 없지만 call () 또는 apply ()를 선호하는 경우가 있습니다. 예를 들어 apply 메소드를 사용하여 MDN에서 배열에서 가장 작은 숫자와 가장 큰 숫자를 찾는 아래 코드를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="4b4525ba87ef2378d7872f06cb3f28507fba74e0" translate="yes" xml:space="preserve">
          <source>So the main difference is just the way we passing the arguments:</source>
          <target state="translated">따라서 주요 차이점은 인수를 전달하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="427d1bd4c30d3818b0111b3da1b759634b43dba6" translate="yes" xml:space="preserve">
          <source>So, these calls complement each other. Where we expect an &lt;em&gt;iterable&lt;/em&gt;, &lt;code&gt;call&lt;/code&gt; works, where we expect an &lt;em&gt;array-like&lt;/em&gt;, &lt;code&gt;apply&lt;/code&gt; works.</source>
          <target state="translated">따라서 이러한 호출은 서로를 보완합니다. &lt;em&gt;iterable&lt;/em&gt; 을 &lt;code&gt;call&lt;/code&gt; 하는 곳에서는 call works, &lt;em&gt;배열과 같은&lt;/em&gt; &lt;code&gt;apply&lt;/code&gt; 작품을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="be3fe9f7c34a24b31d73676e6fcbab70ec9d2a9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apply&lt;/code&gt; accepts only &lt;strong&gt;&lt;em&gt;array-like&lt;/em&gt;&lt;/strong&gt; args.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 은 &lt;strong&gt;&lt;em&gt;배열과 같은&lt;/em&gt;&lt;/strong&gt; 인수 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="800a7e8f32a2fc52d2a1ccad0b5fec64b6a8b77b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spread&lt;/code&gt; operator ... allows passing &lt;strong&gt;&lt;em&gt;iterable&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;args&lt;/code&gt; as the list to call.</source>
          <target state="translated">&lt;code&gt;spread&lt;/code&gt; 연산자는 &lt;strong&gt;&lt;em&gt;반복 가능한&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;args&lt;/code&gt; 를 호출 할 목록으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0adb79677cbacc2d4b026e0c984ae067a1f6a94a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; value can be tricky sometimes in javascript. The value of &lt;code&gt;this&lt;/code&gt; determined &lt;strong&gt;when a function is executed not when a function is defined.&lt;/strong&gt; If our function is dependend on a right &lt;code&gt;this&lt;/code&gt; binding we can use &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; to enforce this behaviour. For example:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 값은 때때로 자바 스크립트에서 까다로울 수 있습니다. 이것의 값은 &lt;strong&gt;함수가 정의 될 때가 아니라 함수가 실행될 때&lt;/strong&gt; 결정 &lt;strong&gt;됩니다.&lt;/strong&gt; 함수 &lt;code&gt;this&lt;/code&gt; 바인딩에 의존하는 경우 &lt;code&gt;call()&lt;/code&gt; 및 &lt;code&gt;apply()&lt;/code&gt; 를 사용하여이 동작을 시행 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3deb699655f4906c5622205ca34014605769b7c7" translate="yes" xml:space="preserve">
          <source>The advantage I see in &lt;code&gt;apply&lt;/code&gt; over &lt;code&gt;call&lt;/code&gt; is that we can easily delegate a function call to other function without much effort;</source>
          <target state="translated">over over &lt;code&gt;call&lt;/code&gt; 에서 볼 수있는 이점은 많은 노력없이 다른 함수에 함수 호출을 쉽게 위임 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1edd355e36cac3e90aaa04f0fb88d78354ce5e11" translate="yes" xml:space="preserve">
          <source>The apply() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and
  arguments provided as an array (or an array-like object).</source>
          <target state="translated">apply () 메소드는 주어진 &lt;code&gt;this&lt;/code&gt; 값과 배열 (또는 배열과 같은 객체)로 제공된 인수로 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7ae8a2679fdcb09c537bfd9049c438ea47444d0c" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an
  array as the second parameter. The array represents the arguments for
  the target method.</source>
          <target state="translated">apply () 메서드는 call ()과 동일하지만 apply ()에는 두 번째 매개 변수로 배열이 필요합니다. 배열은 대상 메소드의 인수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d71d5ac49d58c30c32daad2d08ca0fd85341768" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an array as the second parameter. The array represents the arguments for the target method.&quot;</source>
          <target state="translated">apply () 메서드는 call ()과 동일하지만 apply ()에는 두 번째 매개 변수로 배열이 필요합니다. 배열은 대상 메소드의 인수를 나타냅니다. &quot;</target>
        </trans-unit>
        <trans-unit id="98794248b75b56ec7704f02512ba3bee87f4290d" translate="yes" xml:space="preserve">
          <source>The call() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and arguments provided individually.</source>
          <target state="translated">call () 메소드는 주어진 &lt;code&gt;this&lt;/code&gt; 값과 인수가 개별적으로 제공되는 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0a0bb30e70de7ca8796f52e8fe26e16be5ab1adf" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;apply&lt;/code&gt; lets you invoke the function with &lt;code&gt;arguments&lt;/code&gt; as an array; &lt;code&gt;call&lt;/code&gt; requires the parameters be listed explicitly. A useful mnemonic is &lt;em&gt;&quot;&lt;strong&gt;A&lt;/strong&gt; for &lt;strong&gt;a&lt;/strong&gt;rray and &lt;strong&gt;C&lt;/strong&gt; for &lt;strong&gt;c&lt;/strong&gt;omma.&quot;&lt;/em&gt;</source>
          <target state="translated">차이점은 &lt;code&gt;apply&lt;/code&gt; 는 &lt;code&gt;arguments&lt;/code&gt; 를 배열로 사용하여 함수를 호출 할 수 있다는 것입니다. &lt;code&gt;call&lt;/code&gt; 은 매개 변수가 명시 적으로 나열되어야합니다. 유용한 니모닉은 &lt;em&gt;&quot;레이의 경우 &lt;strong&gt;A&lt;/strong&gt; &lt;strong&gt;,&lt;/strong&gt; &lt;strong&gt;c&lt;/strong&gt; omma의 경우 &lt;strong&gt;C&lt;/strong&gt; &quot;입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="077cae04437beb54a5bf21b695d814008b99d489" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;call()&lt;/code&gt; takes the function arguments separately, and &lt;code&gt;apply()&lt;/code&gt; takes the function arguments in an array.</source>
          <target state="translated">차이점은 &lt;code&gt;call()&lt;/code&gt; 은 함수 인수를 개별적으로 취하고 &lt;code&gt;apply()&lt;/code&gt; 는 함수 인수를 배열로 취한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2b670f55f2b2c65b072b1a94d61900f6d19c14f" translate="yes" xml:space="preserve">
          <source>The following calls are equivalent, as &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;obj.addValues&lt;/code&gt; refer to the same function:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;obj.addValues&lt;/code&gt; 가 동일한 함수를 참조하므로 다음 호출은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="87e4cb2170c64eb87630ac2666ef22a7dec2032f" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is the way you have to pass in arguments into it. In both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; you pass as a first argument the object you want to be the value as &lt;code&gt;this&lt;/code&gt;. The other arguments differ in the following way:</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; 과 &lt;code&gt;apply()&lt;/code&gt; 의 주요 차이점은 인수를 전달해야하는 방법입니다. &lt;code&gt;call()&lt;/code&gt; 과 &lt;code&gt;apply()&lt;/code&gt; 모두에서 첫 번째 인수로 값 &lt;code&gt;this&lt;/code&gt; 될 객체를 this 로 전달 합니다 . 다른 주장은 다음과 같이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="596402989f831c546d2c32187093fca3be37cf23" translate="yes" xml:space="preserve">
          <source>The main difference is, using call, we can change the scope and pass arguments as normal, but apply lets you call it using arguments as an Array (pass them as an array). But in terms of what they to do in your code, they are pretty similar.</source>
          <target state="translated">주요 차이점은 호출을 사용하여 범위를 변경하고 인수를 정상적으로 전달할 수 있지만 apply를 사용하면 인수를 배열로 사용하여 호출 할 수 있습니다 (배열로 전달). 그러나 코드에서 수행 할 작업의 측면에서 보면 매우 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="8d7fedd9b4da5ac143da38dbb316677883876482" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; can never be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; when a function is called. When &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; is supplied as the receiver to &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;apply()&lt;/code&gt;, the global object is used as the value for receiver instead. Therefore, the previous code has the same undesirable side effect of adding a property named &lt;code&gt;value&lt;/code&gt; to the global object.</source>
          <target state="translated">함수가 호출 될 때이 값은 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;undefined&lt;/code&gt; 않아야합니다. &lt;code&gt;call()&lt;/code&gt; 또는 &lt;code&gt;apply()&lt;/code&gt; 의 수신자로 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 가 제공되면 전역 오브젝트가 수신자의 값으로 대신 사용됩니다. 따라서 앞의 코드는 전역 객체에 &lt;code&gt;value&lt;/code&gt; 라는 속성을 추가 할 때와 같은 바람직하지 않은 부작용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="705c96c2c38793b778f0b5c5706f6eeac05a0e3b" translate="yes" xml:space="preserve">
          <source>There is a advantage of using apply over call, we don't need to change the number of argument only we can change a array that is passed.</source>
          <target state="translated">apply over call을 사용하면 이점이 있습니다. 전달 된 배열 만 변경할 수있는 인수 수만 변경할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2eb392d7966c258ea07940d00f4031c57a4537db" translate="yes" xml:space="preserve">
          <source>There is also, as of ES6, the possibility to &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/a&gt; the array for use with the &lt;code&gt;call&lt;/code&gt; function, you can see the compatibilities &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">ES6부터 &lt;code&gt;call&lt;/code&gt; 함수와 함께 사용하기 위해 배열을 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt; &lt;code&gt;spread&lt;/code&gt; &lt;/a&gt; 시킬 가능성도 &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;있습니다&lt;/a&gt; . 여기 에서 호환성을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7c4bd1cb3d884ddea34c2bec769bb8d87d43918" translate="yes" xml:space="preserve">
          <source>There is not big difference in performance. But we can say call is bit faster as compare to apply because an array need to evaluate in apply method.</source>
          <target state="translated">성능에는 큰 차이가 없습니다. 그러나 배열이 apply 메소드에서 평가되어야하기 때문에 적용에 비해 호출이 조금 더 빠르다고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038a8e5aedf1905dbd61b29a8291e8d5ad2624fd" translate="yes" xml:space="preserve">
          <source>There shouldn't be any performance differences, except maybe if you use &lt;code&gt;apply&lt;/code&gt; and wrap the arguments in an array (e.g. &lt;code&gt;f.apply(thisObject, [a, b, c])&lt;/code&gt; instead of &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt;). I haven't tested it, so there could be differences, but it would be very browser specific. It's likely that &lt;code&gt;call&lt;/code&gt; is faster if you don't already have the arguments in an array and &lt;code&gt;apply&lt;/code&gt; is faster if you do.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 을 사용하고 &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt; ). 나는 그것을 테스트하지 않았으므로 차이가있을 수 있지만 브라우저마다 매우 다를 수 있습니다. 배열에 인수가 없으면 &lt;code&gt;call&lt;/code&gt; 이 더 빠를 수 있으며 &lt;code&gt;apply&lt;/code&gt; 하면 적용 이 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01bd227613d09b74c9ae24ff8c1baf0d8a862f46" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s only a minor difference:</source>
          <target state="translated">사소한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7d9da52bcfc783e04a55a3022fc3c5ed5cfd9c2" translate="yes" xml:space="preserve">
          <source>These methods are very useful for giving objects temporary functionality.</source>
          <target state="translated">이 메소드는 객체에 임시 기능을 제공하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e515be0593425c897d57b3bcf9bf116da6b34796" translate="yes" xml:space="preserve">
          <source>To answer the part about when to use each function, use &lt;code&gt;apply&lt;/code&gt; if you don't know the number of arguments you will be passing, or if they are already in an array or array-like object (like the &lt;code&gt;arguments&lt;/code&gt; object to forward your own arguments. Use &lt;code&gt;call&lt;/code&gt; otherwise, since there's no need to wrap the arguments in an array.</source>
          <target state="translated">각 함수의 사용시기에 대한 부분에 대답하려면 전달할 인수의 수를 모르거나 인수가 이미 배열 또는 배열과 같은 오브젝트에있는 경우 (자체를 전달하는 &lt;code&gt;arguments&lt;/code&gt; 오브젝트와 같이) 적용을 사용하십시오. 인수를 배열로 랩핑 할 필요가 없으므로 &lt;code&gt;call&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="459d31f484cba8ff55a14c2b6a8caed822cccbb3" translate="yes" xml:space="preserve">
          <source>We can differentiate call and apply methods as below</source>
          <target state="translated">다음과 같이 통화 및 적용 방법을 차별화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ef483139bf3063f7265084c4928da48c3e58d003" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;this&lt;/code&gt; Refers to When a Function is Called</source>
          <target state="translated">함수가 호출 될 때 &lt;code&gt;this&lt;/code&gt; 참조하는 것</target>
        </trans-unit>
        <trans-unit id="817a1f3c7afd39e9d3dc253e082d14edca07f774" translate="yes" xml:space="preserve">
          <source>What is the difference between call and apply</source>
          <target state="translated">통화와 적용의 차이점은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="8dc03d9498368a753500ba7c0e3c07e5ad163085" translate="yes" xml:space="preserve">
          <source>What is the difference between using &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; to invoke a function?</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 과 &lt;code&gt;apply&lt;/code&gt; 를 사용하여 함수를 호출하는 것의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b8bcd29c1c651d5d8282a5ee2cb6ec09bb376610" translate="yes" xml:space="preserve">
          <source>When I'm not passing any arguments (like your example), I prefer &lt;code&gt;call&lt;/code&gt; since I'm &lt;em&gt;calling&lt;/em&gt; the function. &lt;code&gt;apply&lt;/code&gt; would imply you are &lt;em&gt;applying&lt;/em&gt; the function to the (non-existent) arguments.</source>
          <target state="translated">예를 들어 인수를 전달하지 않으면 함수를 &lt;em&gt;호출&lt;/em&gt; 하기 때문에 &lt;code&gt;call&lt;/code&gt; 선호합니다. &lt;code&gt;apply&lt;/code&gt; 는 존재하지 않는 인수에 함수를 &lt;em&gt;적용&lt;/em&gt; 한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5a16bf745c4863e0508e7d91383d2e774866cde3" translate="yes" xml:space="preserve">
          <source>When calling a function of the form &lt;code&gt;foo.bar.baz()&lt;/code&gt;, the object &lt;code&gt;foo.bar&lt;/code&gt; is referred to as the receiver. When the function is called, it is the receiver that is used as the value for &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;foo.bar.baz()&lt;/code&gt; 형식의 함수를 호출 할 때 &lt;code&gt;foo.bar&lt;/code&gt; 객체를 수신자라고합니다. 함수가 호출되면 다음 값으로 사용되는 수신자입니다.</target>
        </trans-unit>
        <trans-unit id="19f7d47da63f1ec3a5a607ab70ef2cd71438073d" translate="yes" xml:space="preserve">
          <source>While the syntax of this function is almost identical to that of
  apply(), the fundamental difference is that call() accepts an argument
  list, while apply() accepts a single array of arguments.</source>
          <target state="translated">이 함수의 구문은 apply ()의 구문과 거의 동일하지만 근본적인 차이점은 call ()은 인수 목록을 허용하고 apply ()는 단일 인수 배열을 허용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a29c055ff6868d5e2dd5a25b5d8f44e7374c60f7" translate="yes" xml:space="preserve">
          <source>While this is an old topic, I just wanted to point out that .call is slightly faster than .apply. I can't tell you exactly why.</source>
          <target state="translated">이것은 오래된 주제이지만 .call이 .apply보다 약간 빠르다는 것을 지적하고 싶었습니다. 왜 그런지 정확히 말할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d7f8b6f8472e1bf79cfbd6e21fd3463d34684e8" translate="yes" xml:space="preserve">
          <source>Why would I need to use these functions?</source>
          <target state="translated">왜이 기능들을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="c992b9a520f2bac4efd1704b5aa357812b16b9b7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;apply()&lt;/code&gt; you have to pass in array of arguments.</source>
          <target state="translated">&lt;code&gt;apply()&lt;/code&gt; 를 사용하면 인수 배열을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="26eff599b0938eced4e28336770d2c95e3f85671" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;call()&lt;/code&gt; you have to put in the arguments normally (starting from the second argument)</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; 을 사용하면 인수를 정상적으로 입력해야합니다 (두 번째 인수부터 시작)</target>
        </trans-unit>
        <trans-unit id="107c1ad078b8e5fd09a8cade0ac071ada14ec050" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;UPDATE!&lt;/code&gt;]</source>
          <target state="translated">[&lt;code&gt;UPDATE!&lt;/code&gt;]</target>
        </trans-unit>
        <trans-unit id="52205160ec0710bc4b4b11af5b7768320b679b63" translate="yes" xml:space="preserve">
          <source>and apply() takes an array of arguments, ex:</source>
          <target state="translated">apply ()는 인수의 배열을 취합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="6d388c62f51244c2e2efe98118e8338e8667bfbc" translate="yes" xml:space="preserve">
          <source>here are few more usage examples: 
&lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&lt;/a&gt;</source>
          <target state="translated">몇 가지 사용 예는 다음과 같습니다. &lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1746639d3e223680fd2af4999668bb34d143203" translate="yes" xml:space="preserve">
          <source>these two calls are almost equivalent:</source>
          <target state="translated">이 두 통화는 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2b7df6201fdd3362399091f0a29550df3505b6a" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
