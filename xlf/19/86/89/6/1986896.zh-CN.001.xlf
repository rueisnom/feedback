<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1986896">
    <body>
      <group id="1986896">
        <trans-unit id="6a6e1f6bba7be766351d79af2c0144878d9e5b0b" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;A for array and C for comma&amp;rdquo; is a handy mnemonic.</source>
          <target state="translated">&amp;ldquo; A用于数组，C用于逗号&amp;rdquo;是一个方便的助记符。</target>
        </trans-unit>
        <trans-unit id="073092991cddd6d87b6774cbd67a486dc6a12a34" translate="yes" xml:space="preserve">
          <source>**details: &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http://es5.github.io/#x15.4.4.7&lt;/a&gt;*</source>
          <target state="translated">**详细信息： &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http&lt;/a&gt; ： //es5.github.io/#x15.4.4.7 *</target>
        </trans-unit>
        <trans-unit id="2627567f32b8adbe0cee5ec161a0a5d3e23d84d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func.apply();&lt;/code&gt; vs &lt;code&gt;func.call();&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;func.apply();&lt;/code&gt; vs &lt;code&gt;func.call();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516a2e912059b0fa8868493150af5bbad99c0fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A small code example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一个小代码示例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06609c98c8d0351c2cdce0383962f34e0421d30c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Apply:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Apply:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b4d5526e7322d3829a9925f60260e3d2f15826d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Call:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbd3e95548b7020e64ae03b229a1444a868c3a07" translate="yes" xml:space="preserve">
          <source>APPLY : Call a function with argument provided as an array. You can use apply if you don't know how many argument are going to pass to the function.</source>
          <target state="translated">APPLY:调用一个参数为数组的函数。如果你不知道要传递多少个参数给函数,你可以使用apply。</target>
        </trans-unit>
        <trans-unit id="c00657a448f4711f76278443d96c86de31acb2df" translate="yes" xml:space="preserve">
          <source>And for objects that are both &lt;em&gt;iterable&lt;/em&gt; and &lt;em&gt;array-like&lt;/em&gt;, like a real array, we technically could use any of them, but &lt;strong&gt;&lt;em&gt;apply&lt;/em&gt;&lt;/strong&gt; will probably be &lt;strong&gt;faster&lt;/strong&gt; because most JavaScript engines internally optimize it better.</source>
          <target state="translated">对于既可&lt;em&gt;迭代&lt;/em&gt;又&lt;em&gt;类似于数组的&lt;/em&gt;对象（如真实数组），从技术上讲我们可以使用它们中的任何一个，但是&lt;strong&gt;&lt;em&gt;应用&lt;/em&gt;&lt;/strong&gt;可能会&lt;strong&gt;更快，&lt;/strong&gt;因为大多数JavaScript引擎在内部对其进行了优化。</target>
        </trans-unit>
        <trans-unit id="5c9ecb4ae5137755d8f716322b21d78969c95d9d" translate="yes" xml:space="preserve">
          <source>Another example with Call, Apply and Bind.
The difference between Call and Apply is evident, but &lt;strong&gt;Bind&lt;/strong&gt; works like this:</source>
          <target state="translated">调用，应用和绑定的另一个示例。 Call和Apply之间的区别很明显，但是&lt;strong&gt;Bind的&lt;/strong&gt;工作方式如下：</target>
        </trans-unit>
        <trans-unit id="e0664236e12ed01e6900c7d9cb8ffb41e962a4de" translate="yes" xml:space="preserve">
          <source>Apply takes an array of arguments, while Call takes zero or more individual parameters! Ah hah!</source>
          <target state="translated">Apply需要一个参数数组,而Call需要零或更多的单独参数! 啊哈!</target>
        </trans-unit>
        <trans-unit id="ff9c2b698e62e669161a993499cb291ae88ffa2d" translate="yes" xml:space="preserve">
          <source>Are there performance differences between the two aforementioned methods? When is it best to use &lt;code&gt;call&lt;/code&gt; over &lt;code&gt;apply&lt;/code&gt; and vice versa?</source>
          <target state="translated">前述两种方法之间是否存在性能差异？ 什么时候最好使用 &lt;code&gt;call&lt;/code&gt; &lt;code&gt;apply&lt;/code&gt; ，反之亦然？</target>
        </trans-unit>
        <trans-unit id="bd06993ea011e8d1b377551096b54f21460ca6ef" translate="yes" xml:space="preserve">
          <source>Basically, they differ on how they handle function arguments.</source>
          <target state="translated">基本上,它们在处理函数参数的方式上是不同的。</target>
        </trans-unit>
        <trans-unit id="6691472c714089786101ef2e15dc2184a94f6836" translate="yes" xml:space="preserve">
          <source>Because functions are first-class objects in JavaScript, they can have their own methods. All functions have the methods &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; which make it possible to redefine the receiver (i.e., the object that &lt;code&gt;this&lt;/code&gt; refers to) when calling the function. The method signatures are as follows:</source>
          <target state="translated">因为函数是JavaScript中的一流对象，所以它们可以拥有自己的方法。 所有函数都具有方法 &lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; ，这使得在调用函数时可以重新定义接收者（即该对象所指的对象）。 方法签名如下：</target>
        </trans-unit>
        <trans-unit id="0f08f437360dac1640a51eb913a901ace0e1c309" translate="yes" xml:space="preserve">
          <source>Bind returns an instance of a function that can be executed</source>
          <target state="translated">Bind返回一个可以执行的函数的实例</target>
        </trans-unit>
        <trans-unit id="ed70176671e52914281d5006df38717fa96fa92a" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; are methods which are located on &lt;code&gt;Function.prototype&lt;/code&gt;. Therefore they are available on every function object via the prototype chain. Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; can execute a function with a specified value of the &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 都是位于 &lt;code&gt;Function.prototype&lt;/code&gt; 上的方法 。 因此，它们可通过原型链在每个功能对象上使用。 &lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 都可以执行带有 &lt;code&gt;this&lt;/code&gt; 的指定值的函数。</target>
        </trans-unit>
        <trans-unit id="43fad9d50904f98023f5b5618af1a58a2e54e88b" translate="yes" xml:space="preserve">
          <source>CALL : A function with argument provide individually.
If you know the arguments to be passed or there are no argument to pass you can use call.</source>
          <target state="translated">CALL:一个单独提供参数的函数。如果你知道要传递的参数或者没有参数要传递,你可以使用call。</target>
        </trans-unit>
        <trans-unit id="af5f158c4f3a19a2c844e241715bb0c6ede21a92" translate="yes" xml:space="preserve">
          <source>Call and apply both are used to force the &lt;code&gt;this&lt;/code&gt; value when a function is executed. The only difference is that &lt;code&gt;call&lt;/code&gt; takes &lt;code&gt;n+1&lt;/code&gt; arguments where 1 is &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;'n' arguments&lt;/code&gt;. &lt;code&gt;apply&lt;/code&gt; takes only two arguments, one is &lt;code&gt;this&lt;/code&gt; the other is argument array.</source>
          <target state="translated">执行函数时，调用和应用都用于强制 &lt;code&gt;this&lt;/code&gt; 值。 唯一的区别是 &lt;code&gt;call&lt;/code&gt; &lt;code&gt;n+1&lt;/code&gt; 个参数，其中1是 &lt;code&gt;this&lt;/code&gt; 和 &lt;code&gt;'n' arguments&lt;/code&gt; 。 &lt;code&gt;apply&lt;/code&gt; 只需要两个参数，一个是 &lt;code&gt;this&lt;/code&gt; ，另一个是参数数组。</target>
        </trans-unit>
        <trans-unit id="2c5f0501fc2b6f1924d35819be6e0f772b696be1" translate="yes" xml:space="preserve">
          <source>Call() takes comma-separated arguments, ex:</source>
          <target state="translated">Call()取用逗号分隔的参数,例如:&quot;CALL()&quot;。</target>
        </trans-unit>
        <trans-unit id="6be24a97cdca9d9739d2f77bbc3f540977649073" translate="yes" xml:space="preserve">
          <source>Code example :</source>
          <target state="translated">代码示例。</target>
        </trans-unit>
        <trans-unit id="2e84f30b198ef7d854811359c47bddf90fa3a603" translate="yes" xml:space="preserve">
          <source>Difference between these to methods are, how you want to pass the parameters.</source>
          <target state="translated">这些到方法的区别在于,你要如何传递参数。</target>
        </trans-unit>
        <trans-unit id="20751e1ac2443cd0bb58e1d765835240c2c0aa16" translate="yes" xml:space="preserve">
          <source>Douglas Crockford mentions briefly the difference between the two, which may help explain the performance difference... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</source>
          <target state="translated">道格拉斯&amp;middot;克罗克福德（Douglas Crockford）简要提到了两者之间的区别，这可能有助于解释性能差异... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42a6de742cb9fd5f887fa14b79df4fb670c8ac43" translate="yes" xml:space="preserve">
          <source>End of extract.</source>
          <target state="translated">摘录结束。</target>
        </trans-unit>
        <trans-unit id="e54fcc4e07d4859ffb15960ee0fc1a09971d3f34" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; achive the same thing, I think there is atleast one place where you cannot use &lt;code&gt;call&lt;/code&gt; but can only use &lt;code&gt;apply&lt;/code&gt;. That is when you want to support inheritance and want to call the constructor.</source>
          <target state="translated">即使 &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 实现相同的事情，我也认为至少有一个地方不能使用 &lt;code&gt;call&lt;/code&gt; ,而只能使用 &lt;code&gt;apply&lt;/code&gt; 。 那就是您想要支持继承并想要调用构造函数的时候。</target>
        </trans-unit>
        <trans-unit id="cf723110c4d2bbc5c861b13982508ba988c39761" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;obj.addValues&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; refer to the same function, they behave differently when called because the value of the receiver is different in each call. For this reason, when calling a function that refers to &lt;code&gt;this&lt;/code&gt;, it is important to ensure that &lt;code&gt;this&lt;/code&gt; will have the correct value when it is called. To be clear, if &lt;code&gt;this&lt;/code&gt; were not referenced in the function body, then the behavior of &lt;code&gt;f(20)&lt;/code&gt; and &lt;code&gt;obj.addValues(20)&lt;/code&gt; would be the same.</source>
          <target state="translated">即使 &lt;code&gt;obj.addValues&lt;/code&gt; 和 &lt;code&gt;f&lt;/code&gt; 引用相同的函数，但它们在调用时的行为也有所不同，因为在每次调用中接收器的值都不同。 因此，在调用引用 &lt;code&gt;this&lt;/code&gt; 函数的函数时，务必确保在调用该函数时具有正确的值。 需要明确的是，如果未在函数主体中引用此函数，则 &lt;code&gt;f(20)&lt;/code&gt; 和 &lt;code&gt;obj.addValues(20)&lt;/code&gt; 的行为将相同。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="7e3d4b30db26a1e1dfba2fd2e16fc8ff0be1049d" translate="yes" xml:space="preserve">
          <source>First Parameter is '&lt;em&gt;this&lt;/em&gt;'</source>
          <target state="translated">第一个参数是&amp;ldquo; &lt;em&gt;this&lt;/em&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="fbe6ab2ec20f25874154873020df4d336159bf55" translate="yes" xml:space="preserve">
          <source>Follows an extract from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;Closure: The Definitive Guide by Michael Bolin&lt;/a&gt;. It might look a bit lengthy, but it's saturated with a lot of insight. From &quot;Appendix B. Frequently Misunderstood JavaScript Concepts&quot;:</source>
          <target state="translated">摘录自&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;Michael Bolin的《闭幕：权威指南》&lt;/a&gt;的摘录。 它可能看起来有些冗长，但是它充满了很多见识。 摘自&amp;ldquo;附录B.经常被误解的JavaScript概念&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="14bde64cb771ba8e53f5e9a31e2a05f0cce773ef" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;Function.apply and Function.call in JavaScript&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">从&lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;JavaScript中的Function.apply和Function.call&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="3add287d0cdcf70c3bf59b8bfe8c9a82d0d57d3f" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.apply()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">从&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;Function.prototype.apply（）的MDN文档中&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="bd3a5577932f71a488767615582f0be99c3f9de9" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.call()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">从&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;Function.prototype.call（）的MDN文档中&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="8a6d61910a41263d03dd96132c5abac9fae4f766" translate="yes" xml:space="preserve">
          <source>Fundamental difference is that &lt;code&gt;call()&lt;/code&gt; accepts an &lt;strong&gt;&lt;em&gt;argument list&lt;/em&gt;&lt;/strong&gt;, while &lt;code&gt;apply()&lt;/code&gt; accepts a &lt;strong&gt;&lt;em&gt;single array of arguments&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">基本区别在于 &lt;code&gt;call()&lt;/code&gt; 接受&lt;strong&gt;&lt;em&gt;参数列表&lt;/em&gt;&lt;/strong&gt; ，而 &lt;code&gt;apply()&lt;/code&gt; 接受&lt;strong&gt;&lt;em&gt;单个参数数组&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="942187b5d738457fccb4945d671c6c7f377dcc51" translate="yes" xml:space="preserve">
          <source>Here is a function allows you to create classes which also supports creating classes by extending other classes.</source>
          <target state="translated">这里有一个功能允许你创建类,它还支持通过扩展其他类来创建类。</target>
        </trans-unit>
        <trans-unit id="1323fd7ca757679d28a1f40534bf1a963305d403" translate="yes" xml:space="preserve">
          <source>Here's a good mnemonic.  &lt;b&gt;A&lt;/b&gt;pply uses &lt;b&gt;A&lt;/b&gt;rrays and &lt;b&gt;A&lt;/b&gt;lways takes one or two Arguments.  When you use &lt;b&gt;C&lt;/b&gt;all you have to &lt;b&gt;C&lt;/b&gt;ount the number of arguments.</source>
          <target state="translated">这是一个很好的助记符。 &lt;b&gt;一个人&lt;/b&gt;使用&lt;b&gt;A&lt;/b&gt; rays， &lt;b&gt;一个人&lt;/b&gt;使用一或两个参数。 当您使用&lt;b&gt;C时，&lt;/b&gt;您必须忽略参数的数量。</target>
        </trans-unit>
        <trans-unit id="1e4389b4f2ebcb96347afd69578f2cd813e746b1" translate="yes" xml:space="preserve">
          <source>Here's a small-ish post, I wrote on this:</source>
          <target state="translated">下面是一个小编的帖子,我在这上面写的。</target>
        </trans-unit>
        <trans-unit id="ea15e06e4ebe329e80df768918f039ef391ead73" translate="yes" xml:space="preserve">
          <source>However, since neither &lt;code&gt;call()&lt;/code&gt; nor &lt;code&gt;apply()&lt;/code&gt; uses the value of its own receiver to substitute for the receiver argument when it is unspecified, the following will not work:</source>
          <target state="translated">但是，由于未指定 &lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 时都未使用其自身接收方的值来代替接收方参数，因此以下操作将无效：</target>
        </trans-unit>
        <trans-unit id="1a3f8283d118d63985fb2ebf791c5a4dafe8d145" translate="yes" xml:space="preserve">
          <source>I'd like to show an example, where the 'valueForThis' argument is used:</source>
          <target state="translated">我想展示一个例子,其中使用了 &quot;valueForThis &quot;参数。</target>
        </trans-unit>
        <trans-unit id="31e7f36d4dd440ce5b9553f367da59ad9ead4375" translate="yes" xml:space="preserve">
          <source>If there is no explicit receiver when a function is called, then the global object becomes the receiver. As explained in &quot;goog.global&quot; on page 47, window is the global object when JavaScript is executed in a web browser. This leads to some surprising behavior:</source>
          <target state="translated">如果函数被调用时没有显式接收器,那么全局对象就成为了接收器。正如第47页的 &quot;goog.global &quot;中所解释的那样,当JavaScript在web浏览器中执行时,window就是全局对象。这导致了一些令人惊讶的行为。</target>
        </trans-unit>
        <trans-unit id="f1f6c1d060169b5d72622cdaaae1407c94783e9a" translate="yes" xml:space="preserve">
          <source>It is useful at times for one object to borrow the function of another object, meaning that the borrowing object simply executes the lent function as if it were its own.</source>
          <target state="translated">有时,一个对象借用另一个对象的功能是有用的,这意味着借用的对象只需执行借出的功能,就像它自己的功能一样。</target>
        </trans-unit>
        <trans-unit id="8634e981817686925fe0622fba7cbd2c9648ac2e" translate="yes" xml:space="preserve">
          <source>It may be helpful to think of a function as having no knowledge of the variable to which it is assigned. This helps reinforce the idea that the value of this will be bound when the function is called rather than when it is defined.</source>
          <target state="translated">把一个函数看成是不知道被分配给它的变量,这可能是有帮助的。这有助于强化这样的想法,即当函数被调用时,其值将被约束,而不是当它被定义时。</target>
        </trans-unit>
        <trans-unit id="05d22044f701339e803a1cf0357dfbd48f69bdf0" translate="yes" xml:space="preserve">
          <source>K. Scott Allen has &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;a nice writeup&lt;/a&gt; on the matter.</source>
          <target state="translated">斯科特&amp;middot;艾伦（K. Scott Allen）在这件事上&lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;写得很好&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="64eeed73ae33ab9543f5408d00eef328a4369714" translate="yes" xml:space="preserve">
          <source>Let me add a little detail to this.</source>
          <target state="translated">让我在此补充一点细节。</target>
        </trans-unit>
        <trans-unit id="6c5e9642f5ab0e0c0d894c77677a6ea6e20d683d" translate="yes" xml:space="preserve">
          <source>Note that the only difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is that &lt;code&gt;call()&lt;/code&gt; receives the function parameters as individual arguments, whereas &lt;code&gt;apply()&lt;/code&gt; receives them as a single array:</source>
          <target state="translated">请注意， &lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 之间的唯一区别是 &lt;code&gt;call()&lt;/code&gt; 将函数参数作为单独的参数接收，而 &lt;code&gt;apply()&lt;/code&gt; 将它们作为单个数组接收：</target>
        </trans-unit>
        <trans-unit id="50e6db257aa52978fbc08ee3e8da73cab00da33d" translate="yes" xml:space="preserve">
          <source>Observe how easily we delegated &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;sayHello&lt;/code&gt; using &lt;code&gt;apply&lt;/code&gt;, but with &lt;code&gt;call&lt;/code&gt; this is very difficult to achieve.</source>
          <target state="translated">观察我们使用 &lt;code&gt;apply&lt;/code&gt; 多么容易地将 &lt;code&gt;hello&lt;/code&gt; 委托给 &lt;code&gt;sayHello&lt;/code&gt; ，但是通过 &lt;code&gt;call&lt;/code&gt; 很难实现。</target>
        </trans-unit>
        <trans-unit id="77fa40c42a69e7f8ac62aa570ce4ef4d599f5c92" translate="yes" xml:space="preserve">
          <source>Pseudo syntax:</source>
          <target state="translated">伪语法。</target>
        </trans-unit>
        <trans-unit id="bbd19d7653cc08e0948d447b0d060fac147cb4d7" translate="yes" xml:space="preserve">
          <source>Sample code:</source>
          <target state="translated">样本代码:</target>
        </trans-unit>
        <trans-unit id="c84cd0c805d087dfbf9ecd21a7b1bfe6fa40d2e0" translate="yes" xml:space="preserve">
          <source>Second parameter is a &lt;em&gt;Comma separated&lt;/em&gt; list of arguments (like &lt;em&gt;Call&lt;/em&gt;)</source>
          <target state="translated">第二个参数是&lt;em&gt;逗号分隔&lt;/em&gt;的参数列表（如&lt;em&gt;Call&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="6b5735e5c5f630760d9c6e70d4e262a3200a328b" translate="yes" xml:space="preserve">
          <source>See MDN's documentation on &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;apply&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;call&lt;/a&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;apply&lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;call&lt;/a&gt;的信息，请参见MDN的文档。</target>
        </trans-unit>
        <trans-unit id="0e3d090ce9e430e68be2e30177b06f2f38f52993" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;此小提琴&lt;/strong&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d1726ded9a72315ef008837f9d84562b75cee30" translate="yes" xml:space="preserve">
          <source>See jsPerf, &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http://jsperf.com/test-call-vs-apply/3&lt;/a&gt;</source>
          <target state="translated">参见jsPerf， &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http：&lt;/a&gt; //jsperf.com/test-call-vs-apply/3</target>
        </trans-unit>
        <trans-unit id="0021096d114de3a15392deed57a113bebd8414ff" translate="yes" xml:space="preserve">
          <source>So as you see, there is not a big difference, but still, there are cases we prefer using call() or apply(). For example, look at the code below, which finding the smallest and largest number in an array from MDN, using the apply method:</source>
          <target state="translated">所以大家可以看到,两者的区别并不大,但还是有的情况下,我们更喜欢使用call()或apply()。例如,看看下面的代码,从MDN中找到一个数组中最小和最大的数,使用apply方法。</target>
        </trans-unit>
        <trans-unit id="4b4525ba87ef2378d7872f06cb3f28507fba74e0" translate="yes" xml:space="preserve">
          <source>So the main difference is just the way we passing the arguments:</source>
          <target state="translated">所以,主要的区别只是我们通过论证的方式。</target>
        </trans-unit>
        <trans-unit id="427d1bd4c30d3818b0111b3da1b759634b43dba6" translate="yes" xml:space="preserve">
          <source>So, these calls complement each other. Where we expect an &lt;em&gt;iterable&lt;/em&gt;, &lt;code&gt;call&lt;/code&gt; works, where we expect an &lt;em&gt;array-like&lt;/em&gt;, &lt;code&gt;apply&lt;/code&gt; works.</source>
          <target state="translated">因此，这些调用相互补充。 我们希望有一个&lt;em&gt;可迭代的&lt;/em&gt; &lt;code&gt;call&lt;/code&gt; 工作，我们希望有一个&lt;em&gt;类似数组的&lt;/em&gt; 调用工作。</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="be3fe9f7c34a24b31d73676e6fcbab70ec9d2a9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apply&lt;/code&gt; accepts only &lt;strong&gt;&lt;em&gt;array-like&lt;/em&gt;&lt;/strong&gt; args.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 仅接受&lt;strong&gt;&lt;em&gt;类似数组的&lt;/em&gt;&lt;/strong&gt;参数。</target>
        </trans-unit>
        <trans-unit id="800a7e8f32a2fc52d2a1ccad0b5fec64b6a8b77b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spread&lt;/code&gt; operator ... allows passing &lt;strong&gt;&lt;em&gt;iterable&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;args&lt;/code&gt; as the list to call.</source>
          <target state="translated">&lt;code&gt;spread&lt;/code&gt; 运算符...允许传递&lt;strong&gt;&lt;em&gt;可迭代的&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;args&lt;/code&gt; 作为要调用的列表。</target>
        </trans-unit>
        <trans-unit id="0adb79677cbacc2d4b026e0c984ae067a1f6a94a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; value can be tricky sometimes in javascript. The value of &lt;code&gt;this&lt;/code&gt; determined &lt;strong&gt;when a function is executed not when a function is defined.&lt;/strong&gt; If our function is dependend on a right &lt;code&gt;this&lt;/code&gt; binding we can use &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; to enforce this behaviour. For example:</source>
          <target state="translated">有时在javascript中， &lt;code&gt;this&lt;/code&gt; 值可能很棘手。 此值确定&lt;strong&gt;何时执行功能而不是定义功能时。&lt;/strong&gt; 如果我们的功能是依赖 &lt;code&gt;this&lt;/code&gt; 绑定的权限，则可以使用 &lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 强制执行此行为。 例如：</target>
        </trans-unit>
        <trans-unit id="3deb699655f4906c5622205ca34014605769b7c7" translate="yes" xml:space="preserve">
          <source>The advantage I see in &lt;code&gt;apply&lt;/code&gt; over &lt;code&gt;call&lt;/code&gt; is that we can easily delegate a function call to other function without much effort;</source>
          <target state="translated">我在 &lt;code&gt;apply&lt;/code&gt; 覆盖 &lt;code&gt;call&lt;/code&gt; 看到的优点是，我们可以轻松地将一个函数调用委派给其他函数，而无需付出太多努力。</target>
        </trans-unit>
        <trans-unit id="1edd355e36cac3e90aaa04f0fb88d78354ce5e11" translate="yes" xml:space="preserve">
          <source>The apply() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and
  arguments provided as an array (or an array-like object).</source>
          <target state="translated">apply（）方法调用具有给定值的函数，并以数组（或类似数组的对象）形式提供参数。</target>
        </trans-unit>
        <trans-unit id="7ae8a2679fdcb09c537bfd9049c438ea47444d0c" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an
  array as the second parameter. The array represents the arguments for
  the target method.</source>
          <target state="translated">application()方法与call()方法相同,只是apply()需要一个数组作为第二个参数。这个数组代表目标方法的参数。</target>
        </trans-unit>
        <trans-unit id="2d71d5ac49d58c30c32daad2d08ca0fd85341768" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an array as the second parameter. The array represents the arguments for the target method.&quot;</source>
          <target state="translated">apply()方法与call()方法相同,只是 apply()需要一个数组作为第二个参数。这个数组代表目标方法的参数。&quot;</target>
        </trans-unit>
        <trans-unit id="98794248b75b56ec7704f02512ba3bee87f4290d" translate="yes" xml:space="preserve">
          <source>The call() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and arguments provided individually.</source>
          <target state="translated">call（）方法调用具有给定值和单独提供的参数的函数。</target>
        </trans-unit>
        <trans-unit id="0a0bb30e70de7ca8796f52e8fe26e16be5ab1adf" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;apply&lt;/code&gt; lets you invoke the function with &lt;code&gt;arguments&lt;/code&gt; as an array; &lt;code&gt;call&lt;/code&gt; requires the parameters be listed explicitly. A useful mnemonic is &lt;em&gt;&quot;&lt;strong&gt;A&lt;/strong&gt; for &lt;strong&gt;a&lt;/strong&gt;rray and &lt;strong&gt;C&lt;/strong&gt; for &lt;strong&gt;c&lt;/strong&gt;omma.&quot;&lt;/em&gt;</source>
          <target state="translated">区别在于 &lt;code&gt;apply&lt;/code&gt; 允许您将 &lt;code&gt;arguments&lt;/code&gt; 作为数组调用函数； &lt;code&gt;call&lt;/code&gt; 需要显式列出参数。 有用的助记符是&lt;em&gt;&amp;ldquo; &lt;strong&gt;A&lt;/strong&gt;代表行列， &lt;strong&gt;C&lt;/strong&gt;代表命令集&amp;rdquo;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="077cae04437beb54a5bf21b695d814008b99d489" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;call()&lt;/code&gt; takes the function arguments separately, and &lt;code&gt;apply()&lt;/code&gt; takes the function arguments in an array.</source>
          <target state="translated">不同之处在于 &lt;code&gt;call()&lt;/code&gt; 分别接受函数参数，而 &lt;code&gt;apply()&lt;/code&gt; 接受数组中的函数参数。</target>
        </trans-unit>
        <trans-unit id="a2b670f55f2b2c65b072b1a94d61900f6d19c14f" translate="yes" xml:space="preserve">
          <source>The following calls are equivalent, as &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;obj.addValues&lt;/code&gt; refer to the same function:</source>
          <target state="translated">以下调用是等效的，因为 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;obj.addValues&lt;/code&gt; 引用相同的函数：</target>
        </trans-unit>
        <trans-unit id="87e4cb2170c64eb87630ac2666ef22a7dec2032f" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is the way you have to pass in arguments into it. In both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; you pass as a first argument the object you want to be the value as &lt;code&gt;this&lt;/code&gt;. The other arguments differ in the following way:</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 之间的主要区别是必须将参数传递给它的方式。 在 &lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 中,都将您想成为其值的对象作为第一个参数传递。 其他参数在以下方面有所不同：</target>
        </trans-unit>
        <trans-unit id="596402989f831c546d2c32187093fca3be37cf23" translate="yes" xml:space="preserve">
          <source>The main difference is, using call, we can change the scope and pass arguments as normal, but apply lets you call it using arguments as an Array (pass them as an array). But in terms of what they to do in your code, they are pretty similar.</source>
          <target state="translated">主要的区别在于,使用call,我们可以像正常的那样改变作用域和传递参数,但是application可以让你用参数作为数组来调用(传递参数作为数组)。但就它们在你的代码中要做什么而言,它们是非常相似的。</target>
        </trans-unit>
        <trans-unit id="8d7fedd9b4da5ac143da38dbb316677883876482" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; can never be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; when a function is called. When &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; is supplied as the receiver to &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;apply()&lt;/code&gt;, the global object is used as the value for receiver instead. Therefore, the previous code has the same undesirable side effect of adding a property named &lt;code&gt;value&lt;/code&gt; to the global object.</source>
          <target state="translated">调用函数时， &lt;code&gt;this&lt;/code&gt; 值不能为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 。 如果将 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 提供为 &lt;code&gt;call()&lt;/code&gt; 或 &lt;code&gt;apply()&lt;/code&gt; 的接收者，则将全局对象用作接收器的值。 因此，先前的代码具有将名为 &lt;code&gt;value&lt;/code&gt; 的属性添加到全局对象的相同的不良副作用。</target>
        </trans-unit>
        <trans-unit id="705c96c2c38793b778f0b5c5706f6eeac05a0e3b" translate="yes" xml:space="preserve">
          <source>There is a advantage of using apply over call, we don't need to change the number of argument only we can change a array that is passed.</source>
          <target state="translated">使用应用比调用有一个好处,我们不需要改变参数的数量,只需要改变传递的数组就可以了。</target>
        </trans-unit>
        <trans-unit id="2eb392d7966c258ea07940d00f4031c57a4537db" translate="yes" xml:space="preserve">
          <source>There is also, as of ES6, the possibility to &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/a&gt; the array for use with the &lt;code&gt;call&lt;/code&gt; function, you can see the compatibilities &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">从ES6开始，还可以&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt; &lt;code&gt;spread&lt;/code&gt; &lt;/a&gt;数组以供 &lt;code&gt;call&lt;/code&gt; 函数使用，您可以在&lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;此处&lt;/a&gt;看到兼容性。</target>
        </trans-unit>
        <trans-unit id="c7c4bd1cb3d884ddea34c2bec769bb8d87d43918" translate="yes" xml:space="preserve">
          <source>There is not big difference in performance. But we can say call is bit faster as compare to apply because an array need to evaluate in apply method.</source>
          <target state="translated">性能上没有太大的区别。但我们可以说调用比应用方法快一点,因为在应用方法中需要对数组进行评估。</target>
        </trans-unit>
        <trans-unit id="038a8e5aedf1905dbd61b29a8291e8d5ad2624fd" translate="yes" xml:space="preserve">
          <source>There shouldn't be any performance differences, except maybe if you use &lt;code&gt;apply&lt;/code&gt; and wrap the arguments in an array (e.g. &lt;code&gt;f.apply(thisObject, [a, b, c])&lt;/code&gt; instead of &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt;). I haven't tested it, so there could be differences, but it would be very browser specific. It's likely that &lt;code&gt;call&lt;/code&gt; is faster if you don't already have the arguments in an array and &lt;code&gt;apply&lt;/code&gt; is faster if you do.</source>
          <target state="translated">应该没有任何性能差异，除非您使用 &lt;code&gt;apply&lt;/code&gt; 并将参数包装在数组中（例如 &lt;code&gt;f.apply(thisObject, [a, b, c])&lt;/code&gt; 而不是 &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt; ）。 我尚未对其进行测试，因此可能会有差异，但这将取决于浏览器。 如果您尚未在数组中包含参数，则 &lt;code&gt;call&lt;/code&gt; 速度可能会更快，而如果这样做则 &lt;code&gt;apply&lt;/code&gt; 速度会更快。</target>
        </trans-unit>
        <trans-unit id="01bd227613d09b74c9ae24ff8c1baf0d8a862f46" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s only a minor difference:</source>
          <target state="translated">仅有很小的区别：</target>
        </trans-unit>
        <trans-unit id="c7d9da52bcfc783e04a55a3022fc3c5ed5cfd9c2" translate="yes" xml:space="preserve">
          <source>These methods are very useful for giving objects temporary functionality.</source>
          <target state="translated">这些方法对于赋予对象临时功能非常有用。</target>
        </trans-unit>
        <trans-unit id="e515be0593425c897d57b3bcf9bf116da6b34796" translate="yes" xml:space="preserve">
          <source>To answer the part about when to use each function, use &lt;code&gt;apply&lt;/code&gt; if you don't know the number of arguments you will be passing, or if they are already in an array or array-like object (like the &lt;code&gt;arguments&lt;/code&gt; object to forward your own arguments. Use &lt;code&gt;call&lt;/code&gt; otherwise, since there's no need to wrap the arguments in an array.</source>
          <target state="translated">要回答有关何时使用每个函数的部分，如果您不知道要传递的参数数量，或者它们已经存在于数组或类似数组的对象中（例如 &lt;code&gt;arguments&lt;/code&gt; 对象可以转发自己的参数） ，请使用 &lt;code&gt;apply&lt;/code&gt; 参数，否则请使用 &lt;code&gt;call&lt;/code&gt; ，因为不需要将参数包装在数组中。</target>
        </trans-unit>
        <trans-unit id="459d31f484cba8ff55a14c2b6a8caed822cccbb3" translate="yes" xml:space="preserve">
          <source>We can differentiate call and apply methods as below</source>
          <target state="translated">我们可以将调用和应用方法区分如下</target>
        </trans-unit>
        <trans-unit id="ef483139bf3063f7265084c4928da48c3e58d003" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;this&lt;/code&gt; Refers to When a Function is Called</source>
          <target state="translated">调用函数时指的是什么</target>
        </trans-unit>
        <trans-unit id="817a1f3c7afd39e9d3dc253e082d14edca07f774" translate="yes" xml:space="preserve">
          <source>What is the difference between call and apply</source>
          <target state="translated">呼叫和申请的区别是什么</target>
        </trans-unit>
        <trans-unit id="8dc03d9498368a753500ba7c0e3c07e5ad163085" translate="yes" xml:space="preserve">
          <source>What is the difference between using &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; to invoke a function?</source>
          <target state="translated">使用 &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 来调用函数有什么区别？</target>
        </trans-unit>
        <trans-unit id="b8bcd29c1c651d5d8282a5ee2cb6ec09bb376610" translate="yes" xml:space="preserve">
          <source>When I'm not passing any arguments (like your example), I prefer &lt;code&gt;call&lt;/code&gt; since I'm &lt;em&gt;calling&lt;/em&gt; the function. &lt;code&gt;apply&lt;/code&gt; would imply you are &lt;em&gt;applying&lt;/em&gt; the function to the (non-existent) arguments.</source>
          <target state="translated">当我不传递任何参数时（例如您的示例），我更喜欢 &lt;code&gt;call&lt;/code&gt; 因为我正在&lt;em&gt;调用&lt;/em&gt;函数。 &lt;code&gt;apply&lt;/code&gt; 表示您&lt;em&gt;将&lt;/em&gt;函数&lt;em&gt;应用&lt;/em&gt;到（不存在的）参数。</target>
        </trans-unit>
        <trans-unit id="5a16bf745c4863e0508e7d91383d2e774866cde3" translate="yes" xml:space="preserve">
          <source>When calling a function of the form &lt;code&gt;foo.bar.baz()&lt;/code&gt;, the object &lt;code&gt;foo.bar&lt;/code&gt; is referred to as the receiver. When the function is called, it is the receiver that is used as the value for &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">当调用形式为 &lt;code&gt;foo.bar.baz()&lt;/code&gt; 的函数时，对象 &lt;code&gt;foo.bar&lt;/code&gt; 被称为接收器。 调用此函数时，将使用接收方作为此值：</target>
        </trans-unit>
        <trans-unit id="19f7d47da63f1ec3a5a607ab70ef2cd71438073d" translate="yes" xml:space="preserve">
          <source>While the syntax of this function is almost identical to that of
  apply(), the fundamental difference is that call() accepts an argument
  list, while apply() accepts a single array of arguments.</source>
          <target state="translated">虽然这个函数的语法与apply()的语法几乎相同,但根本的区别在于call()接受一个参数列表,而apply()接受一个单一的参数数组。</target>
        </trans-unit>
        <trans-unit id="a29c055ff6868d5e2dd5a25b5d8f44e7374c60f7" translate="yes" xml:space="preserve">
          <source>While this is an old topic, I just wanted to point out that .call is slightly faster than .apply. I can't tell you exactly why.</source>
          <target state="translated">虽然这是个老话题,但我只想指出,.call比.application略快。我不能告诉你确切的原因。</target>
        </trans-unit>
        <trans-unit id="3d7f8b6f8472e1bf79cfbd6e21fd3463d34684e8" translate="yes" xml:space="preserve">
          <source>Why would I need to use these functions?</source>
          <target state="translated">我为什么要用这些功能?</target>
        </trans-unit>
        <trans-unit id="c992b9a520f2bac4efd1704b5aa357812b16b9b7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;apply()&lt;/code&gt; you have to pass in array of arguments.</source>
          <target state="translated">使用 &lt;code&gt;apply()&lt;/code&gt; ,您必须传递参数数组。</target>
        </trans-unit>
        <trans-unit id="26eff599b0938eced4e28336770d2c95e3f85671" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;call()&lt;/code&gt; you have to put in the arguments normally (starting from the second argument)</source>
          <target state="translated">使用 &lt;code&gt;call()&lt;/code&gt; 时,您必须正常输入参数（从第二个参数开始）</target>
        </trans-unit>
        <trans-unit id="107c1ad078b8e5fd09a8cade0ac071ada14ec050" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;UPDATE!&lt;/code&gt;]</source>
          <target state="translated">[&lt;code&gt;UPDATE!&lt;/code&gt;]</target>
        </trans-unit>
        <trans-unit id="52205160ec0710bc4b4b11af5b7768320b679b63" translate="yes" xml:space="preserve">
          <source>and apply() takes an array of arguments, ex:</source>
          <target state="translated">和 apply()取一个数组的参数,例如:</target>
        </trans-unit>
        <trans-unit id="6d388c62f51244c2e2efe98118e8338e8667bfbc" translate="yes" xml:space="preserve">
          <source>here are few more usage examples: 
&lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&lt;/a&gt;</source>
          <target state="translated">以下是一些其他用法示例： &lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http&lt;/a&gt; : //blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/</target>
        </trans-unit>
        <trans-unit id="d1746639d3e223680fd2af4999668bb34d143203" translate="yes" xml:space="preserve">
          <source>these two calls are almost equivalent:</source>
          <target state="translated">这两个电话几乎是等价的。</target>
        </trans-unit>
        <trans-unit id="c2b7df6201fdd3362399091f0a29550df3505b6a" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
