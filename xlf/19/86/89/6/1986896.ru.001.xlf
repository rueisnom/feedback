<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1986896">
    <body>
      <group id="1986896">
        <trans-unit id="6a6e1f6bba7be766351d79af2c0144878d9e5b0b" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;A for array and C for comma&amp;rdquo; is a handy mnemonic.</source>
          <target state="translated">&amp;laquo;A для массива и C для запятой&amp;raquo; - это удобная мнемоника.</target>
        </trans-unit>
        <trans-unit id="073092991cddd6d87b6774cbd67a486dc6a12a34" translate="yes" xml:space="preserve">
          <source>**details: &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http://es5.github.io/#x15.4.4.7&lt;/a&gt;*</source>
          <target state="translated">** подробности: &lt;a href=&quot;http://es5.github.io/#x15.4.4.7&quot;&gt;http://es5.github.io/#x15.4.4.7&lt;/a&gt; *</target>
        </trans-unit>
        <trans-unit id="2627567f32b8adbe0cee5ec161a0a5d3e23d84d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func.apply();&lt;/code&gt; vs &lt;code&gt;func.call();&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;func.apply();&lt;/code&gt; против &lt;code&gt;func.call();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516a2e912059b0fa8868493150af5bbad99c0fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A small code example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Небольшой пример кода:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06609c98c8d0351c2cdce0383962f34e0421d30c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Apply:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Apply:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b4d5526e7322d3829a9925f60260e3d2f15826d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Call:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Call:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbd3e95548b7020e64ae03b229a1444a868c3a07" translate="yes" xml:space="preserve">
          <source>APPLY : Call a function with argument provided as an array. You can use apply if you don't know how many argument are going to pass to the function.</source>
          <target state="translated">APPLY:Вызов функции с аргументом в виде массива.Вы можете использовать приложение,если не знаете,сколько аргументов будет передано в функцию.</target>
        </trans-unit>
        <trans-unit id="c00657a448f4711f76278443d96c86de31acb2df" translate="yes" xml:space="preserve">
          <source>And for objects that are both &lt;em&gt;iterable&lt;/em&gt; and &lt;em&gt;array-like&lt;/em&gt;, like a real array, we technically could use any of them, but &lt;strong&gt;&lt;em&gt;apply&lt;/em&gt;&lt;/strong&gt; will probably be &lt;strong&gt;faster&lt;/strong&gt; because most JavaScript engines internally optimize it better.</source>
          <target state="translated">А для объектов, которые являются &lt;em&gt;итеративными&lt;/em&gt; и &lt;em&gt;похожими на&lt;/em&gt; &lt;em&gt;массивы&lt;/em&gt; , например реальный массив, мы технически могли бы использовать любой из них, но &lt;strong&gt;&lt;em&gt;применение&lt;/em&gt;&lt;/strong&gt; , вероятно, будет &lt;strong&gt;быстрее,&lt;/strong&gt; потому что большинство движков JavaScript внутренне оптимизируют его лучше.</target>
        </trans-unit>
        <trans-unit id="5c9ecb4ae5137755d8f716322b21d78969c95d9d" translate="yes" xml:space="preserve">
          <source>Another example with Call, Apply and Bind.
The difference between Call and Apply is evident, but &lt;strong&gt;Bind&lt;/strong&gt; works like this:</source>
          <target state="translated">Еще один пример с Call, Apply и Bind. Разница между Call и Apply очевидна, но &lt;strong&gt;Bind&lt;/strong&gt; работает так:</target>
        </trans-unit>
        <trans-unit id="e0664236e12ed01e6900c7d9cb8ffb41e962a4de" translate="yes" xml:space="preserve">
          <source>Apply takes an array of arguments, while Call takes zero or more individual parameters! Ah hah!</source>
          <target state="translated">Apply принимает массив аргументов,в то время как Call принимает ноль или более отдельных параметров! А-ха-ха!</target>
        </trans-unit>
        <trans-unit id="ff9c2b698e62e669161a993499cb291ae88ffa2d" translate="yes" xml:space="preserve">
          <source>Are there performance differences between the two aforementioned methods? When is it best to use &lt;code&gt;call&lt;/code&gt; over &lt;code&gt;apply&lt;/code&gt; and vice versa?</source>
          <target state="translated">Есть ли различия в производительности между двумя вышеупомянутыми методами? Когда лучше использовать &lt;code&gt;call&lt;/code&gt; over &lt;code&gt;apply&lt;/code&gt; и наоборот?</target>
        </trans-unit>
        <trans-unit id="bd06993ea011e8d1b377551096b54f21460ca6ef" translate="yes" xml:space="preserve">
          <source>Basically, they differ on how they handle function arguments.</source>
          <target state="translated">В основном,они отличаются тем,как они обрабатывают аргументы функций.</target>
        </trans-unit>
        <trans-unit id="6691472c714089786101ef2e15dc2184a94f6836" translate="yes" xml:space="preserve">
          <source>Because functions are first-class objects in JavaScript, they can have their own methods. All functions have the methods &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; which make it possible to redefine the receiver (i.e., the object that &lt;code&gt;this&lt;/code&gt; refers to) when calling the function. The method signatures are as follows:</source>
          <target state="translated">Поскольку функции являются первоклассными объектами в JavaScript, они могут иметь свои собственные методы. Все функции имеют методы &lt;code&gt;call()&lt;/code&gt; и &lt;code&gt;apply()&lt;/code&gt; которые позволяют переопределить получатель (т. Е. Объект, к которому &lt;code&gt;this&lt;/code&gt; относится) при вызове функции. Подписи метода следующие:</target>
        </trans-unit>
        <trans-unit id="0f08f437360dac1640a51eb913a901ace0e1c309" translate="yes" xml:space="preserve">
          <source>Bind returns an instance of a function that can be executed</source>
          <target state="translated">Bind возвращает экземпляр функции,которая может быть выполнена</target>
        </trans-unit>
        <trans-unit id="ed70176671e52914281d5006df38717fa96fa92a" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; are methods which are located on &lt;code&gt;Function.prototype&lt;/code&gt;. Therefore they are available on every function object via the prototype chain. Both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; can execute a function with a specified value of the &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Оба метода &lt;code&gt;call()&lt;/code&gt; и &lt;code&gt;apply()&lt;/code&gt; являются методами, которые находятся в &lt;code&gt;Function.prototype&lt;/code&gt; . Поэтому они доступны для каждого объекта функции через цепочку прототипов. И &lt;code&gt;call()&lt;/code&gt; и &lt;code&gt;apply()&lt;/code&gt; могут выполнять функцию с указанным значением &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43fad9d50904f98023f5b5618af1a58a2e54e88b" translate="yes" xml:space="preserve">
          <source>CALL : A function with argument provide individually.
If you know the arguments to be passed or there are no argument to pass you can use call.</source>
          <target state="translated">CALL:Функция с аргументом предоставить индивидуально.Если вы знаете передаваемые аргументы или аргументы отсутствуют,вы можете воспользоваться вызовом.</target>
        </trans-unit>
        <trans-unit id="af5f158c4f3a19a2c844e241715bb0c6ede21a92" translate="yes" xml:space="preserve">
          <source>Call and apply both are used to force the &lt;code&gt;this&lt;/code&gt; value when a function is executed. The only difference is that &lt;code&gt;call&lt;/code&gt; takes &lt;code&gt;n+1&lt;/code&gt; arguments where 1 is &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;'n' arguments&lt;/code&gt;. &lt;code&gt;apply&lt;/code&gt; takes only two arguments, one is &lt;code&gt;this&lt;/code&gt; the other is argument array.</source>
          <target state="translated">Вызов и применение обоих используются для принудительного вызова значения &lt;code&gt;this&lt;/code&gt; при выполнении функции. Единственное отличие состоит в том, что &lt;code&gt;call&lt;/code&gt; принимает &lt;code&gt;n+1&lt;/code&gt; аргументов, где 1 - &lt;code&gt;this&lt;/code&gt; и &lt;code&gt;'n' arguments&lt;/code&gt; . &lt;code&gt;apply&lt;/code&gt; принимает только два аргумента, один из которых &lt;code&gt;this&lt;/code&gt; массив аргументов.</target>
        </trans-unit>
        <trans-unit id="2c5f0501fc2b6f1924d35819be6e0f772b696be1" translate="yes" xml:space="preserve">
          <source>Call() takes comma-separated arguments, ex:</source>
          <target state="translated">Call()принимает аргументы,разделенные запятыми,например:</target>
        </trans-unit>
        <trans-unit id="6be24a97cdca9d9739d2f77bbc3f540977649073" translate="yes" xml:space="preserve">
          <source>Code example :</source>
          <target state="translated">Пример кода :</target>
        </trans-unit>
        <trans-unit id="2e84f30b198ef7d854811359c47bddf90fa3a603" translate="yes" xml:space="preserve">
          <source>Difference between these to methods are, how you want to pass the parameters.</source>
          <target state="translated">Разница между ними и методами заключается в том,как вы хотите передать параметры.</target>
        </trans-unit>
        <trans-unit id="20751e1ac2443cd0bb58e1d765835240c2c0aa16" translate="yes" xml:space="preserve">
          <source>Douglas Crockford mentions briefly the difference between the two, which may help explain the performance difference... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</source>
          <target state="translated">Дуглас Крокфорд кратко упоминает разницу между ними, что может помочь объяснить разницу в производительности ... &lt;a href=&quot;http://youtu.be/ya4UHuXNygM?t=15m52s&quot;&gt;http://youtu.be/ya4UHuXNygM?t=15m52s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42a6de742cb9fd5f887fa14b79df4fb670c8ac43" translate="yes" xml:space="preserve">
          <source>End of extract.</source>
          <target state="translated">Конец экстракта.</target>
        </trans-unit>
        <trans-unit id="e54fcc4e07d4859ffb15960ee0fc1a09971d3f34" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; achive the same thing, I think there is atleast one place where you cannot use &lt;code&gt;call&lt;/code&gt; but can only use &lt;code&gt;apply&lt;/code&gt;. That is when you want to support inheritance and want to call the constructor.</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; достигают одного и того же, я думаю, что есть хотя бы одно место, где вы не можете использовать &lt;code&gt;call&lt;/code&gt; , но можете использовать только &lt;code&gt;apply&lt;/code&gt; . Это когда вы хотите поддерживать наследование и хотите вызвать конструктор.</target>
        </trans-unit>
        <trans-unit id="cf723110c4d2bbc5c861b13982508ba988c39761" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;obj.addValues&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; refer to the same function, they behave differently when called because the value of the receiver is different in each call. For this reason, when calling a function that refers to &lt;code&gt;this&lt;/code&gt;, it is important to ensure that &lt;code&gt;this&lt;/code&gt; will have the correct value when it is called. To be clear, if &lt;code&gt;this&lt;/code&gt; were not referenced in the function body, then the behavior of &lt;code&gt;f(20)&lt;/code&gt; and &lt;code&gt;obj.addValues(20)&lt;/code&gt; would be the same.</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;obj.addValues&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; ссылаются на одну и ту же функцию, при вызове они ведут себя по-разному, поскольку значение получателя в каждом вызове различается. По этой причине при вызове функции, которая ссылается на &lt;code&gt;this&lt;/code&gt; , важно убедиться, что &lt;code&gt;this&lt;/code&gt; будет иметь правильное значение при вызове. Для ясности, если бы на &lt;code&gt;this&lt;/code&gt; не ссылались в теле функции, то поведение &lt;code&gt;f(20)&lt;/code&gt; и &lt;code&gt;obj.addValues(20)&lt;/code&gt; было бы одинаковым.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="7e3d4b30db26a1e1dfba2fd2e16fc8ff0be1049d" translate="yes" xml:space="preserve">
          <source>First Parameter is '&lt;em&gt;this&lt;/em&gt;'</source>
          <target state="translated">Первый параметр - &lt;em&gt;это&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fbe6ab2ec20f25874154873020df4d336159bf55" translate="yes" xml:space="preserve">
          <source>Follows an extract from &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;Closure: The Definitive Guide by Michael Bolin&lt;/a&gt;. It might look a bit lengthy, but it's saturated with a lot of insight. From &quot;Appendix B. Frequently Misunderstood JavaScript Concepts&quot;:</source>
          <target state="translated">Далее следует выдержка из &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/1449381871&quot;&gt;книги &amp;laquo;Закрытие: полное руководство&amp;raquo; Майкла Болина&lt;/a&gt; . Это может выглядеть немного длинным, но оно насыщено глубоким пониманием. Из &amp;laquo;Приложения Б. Часто неверно понимаемые концепции JavaScript&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="14bde64cb771ba8e53f5e9a31e2a05f0cce773ef" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;Function.apply and Function.call in JavaScript&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">Из &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;&lt;strong&gt;Function.apply и Function.call в JavaScript&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3add287d0cdcf70c3bf59b8bfe8c9a82d0d57d3f" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.apply()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">Из &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;&lt;strong&gt;документов MDN на Function.prototype.apply ()&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bd3a5577932f71a488767615582f0be99c3f9de9" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;the MDN docs on Function.prototype.call()&lt;/strong&gt;&lt;/a&gt; :</source>
          <target state="translated">Из &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;strong&gt;документов MDN на Function.prototype.call ()&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8a6d61910a41263d03dd96132c5abac9fae4f766" translate="yes" xml:space="preserve">
          <source>Fundamental difference is that &lt;code&gt;call()&lt;/code&gt; accepts an &lt;strong&gt;&lt;em&gt;argument list&lt;/em&gt;&lt;/strong&gt;, while &lt;code&gt;apply()&lt;/code&gt; accepts a &lt;strong&gt;&lt;em&gt;single array of arguments&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">Принципиальное отличие состоит в том, что &lt;code&gt;call()&lt;/code&gt; принимает &lt;strong&gt;&lt;em&gt;список аргументов&lt;/em&gt;&lt;/strong&gt; , а &lt;code&gt;apply()&lt;/code&gt; принимает &lt;strong&gt;&lt;em&gt;один массив аргументов&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="942187b5d738457fccb4945d671c6c7f377dcc51" translate="yes" xml:space="preserve">
          <source>Here is a function allows you to create classes which also supports creating classes by extending other classes.</source>
          <target state="translated">Здесь имеется функция,позволяющая создавать классы,которая также поддерживает создание классов путем расширения других классов.</target>
        </trans-unit>
        <trans-unit id="1323fd7ca757679d28a1f40534bf1a963305d403" translate="yes" xml:space="preserve">
          <source>Here's a good mnemonic.  &lt;b&gt;A&lt;/b&gt;pply uses &lt;b&gt;A&lt;/b&gt;rrays and &lt;b&gt;A&lt;/b&gt;lways takes one or two Arguments.  When you use &lt;b&gt;C&lt;/b&gt;all you have to &lt;b&gt;C&lt;/b&gt;ount the number of arguments.</source>
          <target state="translated">Вот хорошая мнемоника. Pply использует &lt;b&gt;A&lt;/b&gt; rrays, а &lt;b&gt;A&lt;/b&gt; lways &lt;b&gt;-&lt;/b&gt; один или два аргумента. Когда вы используете &lt;b&gt;C&lt;/b&gt; все, что вам нужно, &lt;b&gt;C&lt;/b&gt; Count количество аргументов.</target>
        </trans-unit>
        <trans-unit id="1e4389b4f2ebcb96347afd69578f2cd813e746b1" translate="yes" xml:space="preserve">
          <source>Here's a small-ish post, I wrote on this:</source>
          <target state="translated">Вот маленький пост,я написал на нем:</target>
        </trans-unit>
        <trans-unit id="ea15e06e4ebe329e80df768918f039ef391ead73" translate="yes" xml:space="preserve">
          <source>However, since neither &lt;code&gt;call()&lt;/code&gt; nor &lt;code&gt;apply()&lt;/code&gt; uses the value of its own receiver to substitute for the receiver argument when it is unspecified, the following will not work:</source>
          <target state="translated">Однако, поскольку ни &lt;code&gt;call()&lt;/code&gt; ни &lt;code&gt;apply()&lt;/code&gt; используют значение своего собственного получателя для замены аргумента получателя, когда он не указан, следующее не будет работать:</target>
        </trans-unit>
        <trans-unit id="1a3f8283d118d63985fb2ebf791c5a4dafe8d145" translate="yes" xml:space="preserve">
          <source>I'd like to show an example, where the 'valueForThis' argument is used:</source>
          <target state="translated">Я хотел бы показать пример,где используется аргумент 'valueForThis':</target>
        </trans-unit>
        <trans-unit id="31e7f36d4dd440ce5b9553f367da59ad9ead4375" translate="yes" xml:space="preserve">
          <source>If there is no explicit receiver when a function is called, then the global object becomes the receiver. As explained in &quot;goog.global&quot; on page 47, window is the global object when JavaScript is executed in a web browser. This leads to some surprising behavior:</source>
          <target state="translated">Если при вызове функции нет явного приемника,то глобальным объектом становится приемник.Как поясняется в разделе &quot;goog.global&quot; на странице 47,окно-это глобальный объект,когда в веб-браузере выполняется JavaScript.Это приводит к некоторому удивительному поведению:</target>
        </trans-unit>
        <trans-unit id="f1f6c1d060169b5d72622cdaaae1407c94783e9a" translate="yes" xml:space="preserve">
          <source>It is useful at times for one object to borrow the function of another object, meaning that the borrowing object simply executes the lent function as if it were its own.</source>
          <target state="translated">Иногда одному объекту полезно заимствовать функцию другого объекта,то есть объект заимствования просто выполняет функцию заимствования так,как если бы он был его собственным.</target>
        </trans-unit>
        <trans-unit id="8634e981817686925fe0622fba7cbd2c9648ac2e" translate="yes" xml:space="preserve">
          <source>It may be helpful to think of a function as having no knowledge of the variable to which it is assigned. This helps reinforce the idea that the value of this will be bound when the function is called rather than when it is defined.</source>
          <target state="translated">Может быть полезно думать о функции,не имеющей представления о переменной,которой она присваивается.Это помогает подкрепить мысль о том,что значение этой переменной будет привязано при вызове функции,а не при ее определении.</target>
        </trans-unit>
        <trans-unit id="05d22044f701339e803a1cf0357dfbd48f69bdf0" translate="yes" xml:space="preserve">
          <source>K. Scott Allen has &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;a nice writeup&lt;/a&gt; on the matter.</source>
          <target state="translated">У К. Скотта Аллена &lt;a href=&quot;http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;хорошая статья&lt;/a&gt; по этому вопросу.</target>
        </trans-unit>
        <trans-unit id="64eeed73ae33ab9543f5408d00eef328a4369714" translate="yes" xml:space="preserve">
          <source>Let me add a little detail to this.</source>
          <target state="translated">Позвольте мне добавить к этому маленькую деталь.</target>
        </trans-unit>
        <trans-unit id="6c5e9642f5ab0e0c0d894c77677a6ea6e20d683d" translate="yes" xml:space="preserve">
          <source>Note that the only difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is that &lt;code&gt;call()&lt;/code&gt; receives the function parameters as individual arguments, whereas &lt;code&gt;apply()&lt;/code&gt; receives them as a single array:</source>
          <target state="translated">Обратите внимание, что единственная разница между &lt;code&gt;call()&lt;/code&gt; и &lt;code&gt;apply()&lt;/code&gt; состоит в том, что &lt;code&gt;call()&lt;/code&gt; получает параметры функции в виде отдельных аргументов, тогда как &lt;code&gt;apply()&lt;/code&gt; получает их как один массив:</target>
        </trans-unit>
        <trans-unit id="50e6db257aa52978fbc08ee3e8da73cab00da33d" translate="yes" xml:space="preserve">
          <source>Observe how easily we delegated &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;sayHello&lt;/code&gt; using &lt;code&gt;apply&lt;/code&gt;, but with &lt;code&gt;call&lt;/code&gt; this is very difficult to achieve.</source>
          <target state="translated">Обратите внимание, как легко мы делегировали &lt;code&gt;hello&lt;/code&gt; &lt;code&gt;sayHello&lt;/code&gt; Hello, используя &lt;code&gt;apply&lt;/code&gt; , но с &lt;code&gt;call&lt;/code&gt; это очень трудно достичь.</target>
        </trans-unit>
        <trans-unit id="77fa40c42a69e7f8ac62aa570ce4ef4d599f5c92" translate="yes" xml:space="preserve">
          <source>Pseudo syntax:</source>
          <target state="translated">Псевдосинтаксис:</target>
        </trans-unit>
        <trans-unit id="bbd19d7653cc08e0948d447b0d060fac147cb4d7" translate="yes" xml:space="preserve">
          <source>Sample code:</source>
          <target state="translated">Образец кода:</target>
        </trans-unit>
        <trans-unit id="c84cd0c805d087dfbf9ecd21a7b1bfe6fa40d2e0" translate="yes" xml:space="preserve">
          <source>Second parameter is a &lt;em&gt;Comma separated&lt;/em&gt; list of arguments (like &lt;em&gt;Call&lt;/em&gt;)</source>
          <target state="translated">Второй параметр - это список аргументов через &lt;em&gt;запятую&lt;/em&gt; (например, &lt;em&gt;Call&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b5735e5c5f630760d9c6e70d4e262a3200a328b" translate="yes" xml:space="preserve">
          <source>See MDN's documentation on &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;apply&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;call&lt;/a&gt;.</source>
          <target state="translated">Смотрите документацию MDN о том, как &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;подать заявку&lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;позвонить&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e3d090ce9e430e68be2e30177b06f2f38f52993" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Смотрите также &lt;a href=&quot;https://jsfiddle.net/k7y5o0d6/9/&quot;&gt;&lt;strong&gt;эту скрипку&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1726ded9a72315ef008837f9d84562b75cee30" translate="yes" xml:space="preserve">
          <source>See jsPerf, &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http://jsperf.com/test-call-vs-apply/3&lt;/a&gt;</source>
          <target state="translated">Смотрите jsPerf, &lt;a href=&quot;http://jsperf.com/test-call-vs-apply/3&quot;&gt;http://jsperf.com/test-call-vs-apply/3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0021096d114de3a15392deed57a113bebd8414ff" translate="yes" xml:space="preserve">
          <source>So as you see, there is not a big difference, but still, there are cases we prefer using call() or apply(). For example, look at the code below, which finding the smallest and largest number in an array from MDN, using the apply method:</source>
          <target state="translated">Так что,как видите,большой разницы нет,но все же есть случаи,когда мы предпочитаем использовать call()или apply().Например,посмотрите на код ниже,который находит наименьшее и наибольшее число в массиве из MDN,используя метод application:</target>
        </trans-unit>
        <trans-unit id="4b4525ba87ef2378d7872f06cb3f28507fba74e0" translate="yes" xml:space="preserve">
          <source>So the main difference is just the way we passing the arguments:</source>
          <target state="translated">Так что главное отличие в том,как мы передаем аргументы:</target>
        </trans-unit>
        <trans-unit id="427d1bd4c30d3818b0111b3da1b759634b43dba6" translate="yes" xml:space="preserve">
          <source>So, these calls complement each other. Where we expect an &lt;em&gt;iterable&lt;/em&gt;, &lt;code&gt;call&lt;/code&gt; works, where we expect an &lt;em&gt;array-like&lt;/em&gt;, &lt;code&gt;apply&lt;/code&gt; works.</source>
          <target state="translated">Итак, эти звонки дополняют друг друга. Там, где мы ожидаем &lt;em&gt;итеративность&lt;/em&gt; , &lt;code&gt;call&lt;/code&gt; работает, где мы ожидаем, что &lt;em&gt;массив будет&lt;/em&gt; работать.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="be3fe9f7c34a24b31d73676e6fcbab70ec9d2a9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apply&lt;/code&gt; accepts only &lt;strong&gt;&lt;em&gt;array-like&lt;/em&gt;&lt;/strong&gt; args.</source>
          <target state="translated">Приложение принимает только аргументы, &lt;strong&gt;&lt;em&gt;похожие на массивы&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="800a7e8f32a2fc52d2a1ccad0b5fec64b6a8b77b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spread&lt;/code&gt; operator ... allows passing &lt;strong&gt;&lt;em&gt;iterable&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;args&lt;/code&gt; as the list to call.</source>
          <target state="translated">Оператор &lt;code&gt;spread&lt;/code&gt; ... позволяет передавать &lt;strong&gt;&lt;em&gt;итерируемые&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;args&lt;/code&gt; в качестве списка для вызова.</target>
        </trans-unit>
        <trans-unit id="0adb79677cbacc2d4b026e0c984ae067a1f6a94a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; value can be tricky sometimes in javascript. The value of &lt;code&gt;this&lt;/code&gt; determined &lt;strong&gt;when a function is executed not when a function is defined.&lt;/strong&gt; If our function is dependend on a right &lt;code&gt;this&lt;/code&gt; binding we can use &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; to enforce this behaviour. For example:</source>
          <target state="translated">Это значение может быть сложно иногда в JavaScript. Значение &lt;code&gt;this&lt;/code&gt; определяется, &lt;strong&gt;когда функция выполняется, а не когда функция определена.&lt;/strong&gt; Если наша функция зависит от права на &lt;code&gt;this&lt;/code&gt; привязку, мы можем использовать &lt;code&gt;call()&lt;/code&gt; и &lt;code&gt;apply()&lt;/code&gt; для реализации этого поведения. Например:</target>
        </trans-unit>
        <trans-unit id="3deb699655f4906c5622205ca34014605769b7c7" translate="yes" xml:space="preserve">
          <source>The advantage I see in &lt;code&gt;apply&lt;/code&gt; over &lt;code&gt;call&lt;/code&gt; is that we can easily delegate a function call to other function without much effort;</source>
          <target state="translated">Преимущество, которое я вижу в &lt;code&gt;apply&lt;/code&gt; перед &lt;code&gt;call&lt;/code&gt; состоит в том, что мы можем легко делегировать вызов функции другой функции без особых усилий;</target>
        </trans-unit>
        <trans-unit id="1edd355e36cac3e90aaa04f0fb88d78354ce5e11" translate="yes" xml:space="preserve">
          <source>The apply() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and
  arguments provided as an array (or an array-like object).</source>
          <target state="translated">Метод apply () вызывает функцию с заданным значением &lt;code&gt;this&lt;/code&gt; и аргументами, представленными в виде массива (или объекта, подобного массиву).</target>
        </trans-unit>
        <trans-unit id="7ae8a2679fdcb09c537bfd9049c438ea47444d0c" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an
  array as the second parameter. The array represents the arguments for
  the target method.</source>
          <target state="translated">Метод applied()идентичен методу call(),за исключением того,что метод apply()требует массив в качестве второго параметра.Массив представляет собой аргументы для целевого метода.</target>
        </trans-unit>
        <trans-unit id="2d71d5ac49d58c30c32daad2d08ca0fd85341768" translate="yes" xml:space="preserve">
          <source>The apply() method is identical to call(), except apply() requires an array as the second parameter. The array represents the arguments for the target method.&quot;</source>
          <target state="translated">Метод applied()идентичен методу call(),за исключением того,что метод apply()требует массив в качестве второго параметра.Массив представляет собой аргументы для целевого метода&quot;.</target>
        </trans-unit>
        <trans-unit id="98794248b75b56ec7704f02512ba3bee87f4290d" translate="yes" xml:space="preserve">
          <source>The call() method calls a function with a given &lt;code&gt;this&lt;/code&gt; value and arguments provided individually.</source>
          <target state="translated">Метод call () вызывает функцию с заданным значением &lt;code&gt;this&lt;/code&gt; и аргументами, предоставляемыми индивидуально.</target>
        </trans-unit>
        <trans-unit id="0a0bb30e70de7ca8796f52e8fe26e16be5ab1adf" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;apply&lt;/code&gt; lets you invoke the function with &lt;code&gt;arguments&lt;/code&gt; as an array; &lt;code&gt;call&lt;/code&gt; requires the parameters be listed explicitly. A useful mnemonic is &lt;em&gt;&quot;&lt;strong&gt;A&lt;/strong&gt; for &lt;strong&gt;a&lt;/strong&gt;rray and &lt;strong&gt;C&lt;/strong&gt; for &lt;strong&gt;c&lt;/strong&gt;omma.&quot;&lt;/em&gt;</source>
          <target state="translated">Разница в том, что &lt;code&gt;apply&lt;/code&gt; позволяет вам вызывать функцию с &lt;code&gt;arguments&lt;/code&gt; в виде массива; &lt;code&gt;call&lt;/code&gt; требует, чтобы параметры были перечислены явно. Полезной мнемоникой является &lt;em&gt;&amp;laquo; &lt;strong&gt;A&lt;/strong&gt; для Rray и &lt;strong&gt;C&lt;/strong&gt; для &lt;strong&gt;C&lt;/strong&gt; omma&amp;raquo;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="077cae04437beb54a5bf21b695d814008b99d489" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;call()&lt;/code&gt; takes the function arguments separately, and &lt;code&gt;apply()&lt;/code&gt; takes the function arguments in an array.</source>
          <target state="translated">Разница в том, что &lt;code&gt;call()&lt;/code&gt; принимает аргументы функции отдельно, а &lt;code&gt;apply()&lt;/code&gt; принимает аргументы функции в массиве.</target>
        </trans-unit>
        <trans-unit id="a2b670f55f2b2c65b072b1a94d61900f6d19c14f" translate="yes" xml:space="preserve">
          <source>The following calls are equivalent, as &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;obj.addValues&lt;/code&gt; refer to the same function:</source>
          <target state="translated">Следующие вызовы эквивалентны, так как &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;obj.addValues&lt;/code&gt; ссылаются на одну и ту же функцию:</target>
        </trans-unit>
        <trans-unit id="87e4cb2170c64eb87630ac2666ef22a7dec2032f" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; is the way you have to pass in arguments into it. In both &lt;code&gt;call()&lt;/code&gt; and &lt;code&gt;apply()&lt;/code&gt; you pass as a first argument the object you want to be the value as &lt;code&gt;this&lt;/code&gt;. The other arguments differ in the following way:</source>
          <target state="translated">Основное различие между &lt;code&gt;call()&lt;/code&gt; и &lt;code&gt;apply()&lt;/code&gt; заключается в способе передачи аргументов в него. В обоих &lt;code&gt;call()&lt;/code&gt; и &lt;code&gt;apply()&lt;/code&gt; в качестве первого аргумента вы передаете объект, значением которого вы хотите быть. Другие аргументы отличаются следующим образом:</target>
        </trans-unit>
        <trans-unit id="596402989f831c546d2c32187093fca3be37cf23" translate="yes" xml:space="preserve">
          <source>The main difference is, using call, we can change the scope and pass arguments as normal, but apply lets you call it using arguments as an Array (pass them as an array). But in terms of what they to do in your code, they are pretty similar.</source>
          <target state="translated">Основное отличие заключается в том,что с помощью вызова мы можем изменять границы видимости и передавать аргументы как обычно,но применение позволяет вызывать их,используя аргументы в качестве массива (передавать их как массив).Но с точки зрения того,что они должны делать в вашем коде,они довольно похожи.</target>
        </trans-unit>
        <trans-unit id="8d7fedd9b4da5ac143da38dbb316677883876482" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; can never be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; when a function is called. When &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; is supplied as the receiver to &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;apply()&lt;/code&gt;, the global object is used as the value for receiver instead. Therefore, the previous code has the same undesirable side effect of adding a property named &lt;code&gt;value&lt;/code&gt; to the global object.</source>
          <target state="translated">Значение &lt;code&gt;this&lt;/code&gt; никогда не может быть &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; при вызове функции. Когда в качестве получателя для &lt;code&gt;call()&lt;/code&gt; или &lt;code&gt;apply()&lt;/code&gt; предоставляется значение &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; , вместо него используется глобальный объект. Поэтому предыдущий код имеет тот же нежелательный побочный эффект, что и добавление свойства с именем &lt;code&gt;value&lt;/code&gt; к глобальному объекту.</target>
        </trans-unit>
        <trans-unit id="705c96c2c38793b778f0b5c5706f6eeac05a0e3b" translate="yes" xml:space="preserve">
          <source>There is a advantage of using apply over call, we don't need to change the number of argument only we can change a array that is passed.</source>
          <target state="translated">Есть преимущество использования apply перед call,нам не нужно изменять количество аргументов,только мы можем изменить переданный массив.</target>
        </trans-unit>
        <trans-unit id="2eb392d7966c258ea07940d00f4031c57a4537db" translate="yes" xml:space="preserve">
          <source>There is also, as of ES6, the possibility to &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/a&gt; the array for use with the &lt;code&gt;call&lt;/code&gt; function, you can see the compatibilities &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Начиная с ES6, есть возможность &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt; &lt;code&gt;spread&lt;/code&gt; &lt;/a&gt; массива для использования с функцией &lt;code&gt;call&lt;/code&gt; , здесь вы можете увидеть совместимость.</target>
        </trans-unit>
        <trans-unit id="c7c4bd1cb3d884ddea34c2bec769bb8d87d43918" translate="yes" xml:space="preserve">
          <source>There is not big difference in performance. But we can say call is bit faster as compare to apply because an array need to evaluate in apply method.</source>
          <target state="translated">Нет большой разницы в производительности.Но можно сказать,что вызов происходит немного быстрее по сравнению с применением,так как массив должен быть оценен в методе применения.</target>
        </trans-unit>
        <trans-unit id="038a8e5aedf1905dbd61b29a8291e8d5ad2624fd" translate="yes" xml:space="preserve">
          <source>There shouldn't be any performance differences, except maybe if you use &lt;code&gt;apply&lt;/code&gt; and wrap the arguments in an array (e.g. &lt;code&gt;f.apply(thisObject, [a, b, c])&lt;/code&gt; instead of &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt;). I haven't tested it, so there could be differences, but it would be very browser specific. It's likely that &lt;code&gt;call&lt;/code&gt; is faster if you don't already have the arguments in an array and &lt;code&gt;apply&lt;/code&gt; is faster if you do.</source>
          <target state="translated">Не должно быть никаких различий в производительности, за исключением, может быть, если вы используете &lt;code&gt;apply&lt;/code&gt; и &lt;code&gt;f.apply(thisObject, [a, b, c])&lt;/code&gt; аргументы в массив (например, f.apply (thisObject, [a, b, c]) вместо &lt;code&gt;f.call(thisObject, a, b, c)&lt;/code&gt; ) Я не проверял это, поэтому могут быть различия, но это будет зависеть от браузера. Вполне вероятно, что &lt;code&gt;call&lt;/code&gt; будет быстрее, если у вас еще нет аргументов в массиве, и &lt;code&gt;apply&lt;/code&gt; будет быстрее, если вы это сделаете.</target>
        </trans-unit>
        <trans-unit id="01bd227613d09b74c9ae24ff8c1baf0d8a862f46" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s only a minor difference:</source>
          <target state="translated">Там только небольшая разница:</target>
        </trans-unit>
        <trans-unit id="c7d9da52bcfc783e04a55a3022fc3c5ed5cfd9c2" translate="yes" xml:space="preserve">
          <source>These methods are very useful for giving objects temporary functionality.</source>
          <target state="translated">Эти методы очень полезны для придания объектам временной функциональности.</target>
        </trans-unit>
        <trans-unit id="e515be0593425c897d57b3bcf9bf116da6b34796" translate="yes" xml:space="preserve">
          <source>To answer the part about when to use each function, use &lt;code&gt;apply&lt;/code&gt; if you don't know the number of arguments you will be passing, or if they are already in an array or array-like object (like the &lt;code&gt;arguments&lt;/code&gt; object to forward your own arguments. Use &lt;code&gt;call&lt;/code&gt; otherwise, since there's no need to wrap the arguments in an array.</source>
          <target state="translated">Чтобы ответить на часть о том, когда использовать каждую функцию, используйте &lt;code&gt;apply&lt;/code&gt; , если вы не знаете, сколько аргументов вы будете передавать, или если они уже находятся в массиве или массивоподобном объекте (например, объект &lt;code&gt;arguments&lt;/code&gt; для пересылки ваших собственных). аргументы. Используйте &lt;code&gt;call&lt;/code&gt; иначе, так как нет необходимости заключать аргументы в массив.</target>
        </trans-unit>
        <trans-unit id="459d31f484cba8ff55a14c2b6a8caed822cccbb3" translate="yes" xml:space="preserve">
          <source>We can differentiate call and apply methods as below</source>
          <target state="translated">Мы можем различать вызовы и применять методы,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="ef483139bf3063f7265084c4928da48c3e58d003" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;this&lt;/code&gt; Refers to When a Function is Called</source>
          <target state="translated">К чему &lt;code&gt;this&lt;/code&gt; относится, когда вызывается функция</target>
        </trans-unit>
        <trans-unit id="817a1f3c7afd39e9d3dc253e082d14edca07f774" translate="yes" xml:space="preserve">
          <source>What is the difference between call and apply</source>
          <target state="translated">В чем разница между звонком и применением</target>
        </trans-unit>
        <trans-unit id="8dc03d9498368a753500ba7c0e3c07e5ad163085" translate="yes" xml:space="preserve">
          <source>What is the difference between using &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; to invoke a function?</source>
          <target state="translated">В чем разница между использованием &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; для вызова функции?</target>
        </trans-unit>
        <trans-unit id="b8bcd29c1c651d5d8282a5ee2cb6ec09bb376610" translate="yes" xml:space="preserve">
          <source>When I'm not passing any arguments (like your example), I prefer &lt;code&gt;call&lt;/code&gt; since I'm &lt;em&gt;calling&lt;/em&gt; the function. &lt;code&gt;apply&lt;/code&gt; would imply you are &lt;em&gt;applying&lt;/em&gt; the function to the (non-existent) arguments.</source>
          <target state="translated">Когда я не передаю никаких аргументов (например, ваш пример), я предпочитаю &lt;code&gt;call&lt;/code&gt; так как вызываю функцию. &lt;em&gt;Применение&lt;/em&gt; означает, что вы &lt;em&gt;применяете&lt;/em&gt; функцию к (несуществующим) аргументам.</target>
        </trans-unit>
        <trans-unit id="5a16bf745c4863e0508e7d91383d2e774866cde3" translate="yes" xml:space="preserve">
          <source>When calling a function of the form &lt;code&gt;foo.bar.baz()&lt;/code&gt;, the object &lt;code&gt;foo.bar&lt;/code&gt; is referred to as the receiver. When the function is called, it is the receiver that is used as the value for &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">При вызове функции вида &lt;code&gt;foo.bar.baz()&lt;/code&gt; объект &lt;code&gt;foo.bar&lt;/code&gt; называется получателем. Когда функция вызывается, это получатель, который используется в качестве значения для &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="19f7d47da63f1ec3a5a607ab70ef2cd71438073d" translate="yes" xml:space="preserve">
          <source>While the syntax of this function is almost identical to that of
  apply(), the fundamental difference is that call() accepts an argument
  list, while apply() accepts a single array of arguments.</source>
          <target state="translated">Хотя синтаксис этой функции почти идентичен синтаксису функции apply(),фундаментальное различие заключается в том,что call()принимает список аргументов,в то время как apply()принимает один массив аргументов.</target>
        </trans-unit>
        <trans-unit id="a29c055ff6868d5e2dd5a25b5d8f44e7374c60f7" translate="yes" xml:space="preserve">
          <source>While this is an old topic, I just wanted to point out that .call is slightly faster than .apply. I can't tell you exactly why.</source>
          <target state="translated">Хотя это старая тема,я просто хотел отметить,что .call немного быстрее,чем .apply.Я не могу точно сказать,почему.</target>
        </trans-unit>
        <trans-unit id="3d7f8b6f8472e1bf79cfbd6e21fd3463d34684e8" translate="yes" xml:space="preserve">
          <source>Why would I need to use these functions?</source>
          <target state="translated">Зачем мне эти функции?</target>
        </trans-unit>
        <trans-unit id="c992b9a520f2bac4efd1704b5aa357812b16b9b7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;apply()&lt;/code&gt; you have to pass in array of arguments.</source>
          <target state="translated">С &lt;code&gt;apply()&lt;/code&gt; вы должны передать массив аргументов.</target>
        </trans-unit>
        <trans-unit id="26eff599b0938eced4e28336770d2c95e3f85671" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;call()&lt;/code&gt; you have to put in the arguments normally (starting from the second argument)</source>
          <target state="translated">С помощью &lt;code&gt;call()&lt;/code&gt; вы должны вводить аргументы как обычно (начиная со второго аргумента)</target>
        </trans-unit>
        <trans-unit id="107c1ad078b8e5fd09a8cade0ac071ada14ec050" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;UPDATE!&lt;/code&gt;]</source>
          <target state="translated">[&lt;code&gt;UPDATE!&lt;/code&gt;]</target>
        </trans-unit>
        <trans-unit id="52205160ec0710bc4b4b11af5b7768320b679b63" translate="yes" xml:space="preserve">
          <source>and apply() takes an array of arguments, ex:</source>
          <target state="translated">и apply()принимает массив аргументов,например:</target>
        </trans-unit>
        <trans-unit id="6d388c62f51244c2e2efe98118e8338e8667bfbc" translate="yes" xml:space="preserve">
          <source>here are few more usage examples: 
&lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&lt;/a&gt;</source>
          <target state="translated">Вот еще несколько примеров использования: &lt;a href=&quot;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&quot;&gt;http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1746639d3e223680fd2af4999668bb34d143203" translate="yes" xml:space="preserve">
          <source>these two calls are almost equivalent:</source>
          <target state="translated">эти два звонка почти эквивалентны:</target>
        </trans-unit>
        <trans-unit id="c2b7df6201fdd3362399091f0a29550df3505b6a" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
