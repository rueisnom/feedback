<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/19896870">
    <body>
      <group id="19896870">
        <trans-unit id="394b57ab44493bad9e13375faca2da97306afe8c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;The Spring Inversion of Control (IoC) container&lt;/a&gt; has three main logical components: a registry (called the &lt;code&gt;ApplicationContext&lt;/code&gt;) of components (beans) that are available to be used by the application, a configurer system that injects objects' dependencies into them by matching up the dependencies with beans in the context, and a dependency solver that can look at a configuration of many different beans and determine how to instantiate and configure them in the necessary order.</source>
          <target state="translated">&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;Spring Inversion of Control（IoC）コンテナに&lt;/a&gt;は、3つの主要な論理コンポーネントがあります。アプリケーションで使用できるコンポーネント（beans）のレジストリ（ &lt;code&gt;ApplicationContext&lt;/code&gt; と呼ばれます ）、マッチングによってオブジェクトの依存関係をそれらに注入する構成システムコンテキスト内のBeanの依存関係、および多くの異なるBeanの構成を調べ、必要な順序でそれらをインスタンス化および構成する方法を決定できる依存関係ソルバー。</target>
        </trans-unit>
        <trans-unit id="1ae06b30b6d1c782656a2208ccb72d7333701bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@Service, @Component&lt;/code&gt; etc annotations add meta description.</source>
          <target state="translated">&lt;code&gt;@Service, @Component&lt;/code&gt; などのアノテーションはメタ記述を追加します。</target>
        </trans-unit>
        <trans-unit id="a70bff0ba394cef82c27ca682d50f21c90605937" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I'm new to Spring, but I discovered this working solution. Please tell me if it's a deprecable way.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;私はSpringを初めて使用しましたが、この実用的な解決策を見つけました。&lt;/em&gt; &lt;em&gt;それが非難すべき方法かどうか教えてください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac07e8cc2813a62fa38fad476b41fdaaca46ef7a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is intended to be a canonical answer for a common problem.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注：これは、一般的な問題に対する標準的な回答となることを目的としています。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b7fb549b54ec58659fd74cbdd78e77c0e0493806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ORIGINAL ANSWER:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;元の回答：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f981fb4e08e95e60895db03be2fe27045a89932" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE FIELD IS NOT A BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;フィールドは豆ではありません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c63b5f6bebe122bb768741b030b15d8683140f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by injecting the &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt;&lt;code&gt;working-inject-bean&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; サービスオブジェクトを挿入することで機能するタグ： &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt; &lt;code&gt;working-inject-bean&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ece2ffe683fc87cb97657a6c77b083b990d1adf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by manually looking up the service object in the Spring context: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt;&lt;code&gt;working-manual-lookup&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Springコンテキストでサービスオブジェクトを&lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt; &lt;code&gt;working-manual-lookup&lt;/code&gt; &lt;/a&gt;ことによって機能するタグ： working-manual-lookup&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ee91e9a00165f2f5a170963a6a33b134695cf84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by using &lt;code&gt;@Configurable&lt;/code&gt; on the service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt;&lt;code&gt;working-configurable&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;サービスオブジェクトで &lt;code&gt;@Configurable&lt;/code&gt; を使用して機能するタグ： &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt; &lt;code&gt;working-configurable&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="774dd712670d211631d8f90f0cee69e58e4015a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; Really smart people were quick to point on &lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;this&lt;/a&gt; answer, which explains the weirdness, described below</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;本当に賢い人はすぐに&lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;この&lt;/a&gt;答えを指摘しました、それは以下で説明される奇妙さを説明しています</target>
        </trans-unit>
        <trans-unit id="343f2555b3fe8817306d09a16f4d9c002d898197" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YOUR CLASS IS NOT A  SPRING BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;あなたのクラスは春の豆ではありません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="013573a8c9d74642d1e8e6d7631446a204fef372" translate="yes" xml:space="preserve">
          <source>Actually, you should use either JVM managed Objects or Spring-managed Object to invoke methods.
from your above code in your controller class, you are creating a new object to call your service class which has an auto-wired object.</source>
          <target state="translated">実際には、メソッドを呼び出すには、JVM管理オブジェクトまたはスプリング管理オブジェクトを使用する必要があります。上記のコントローラクラスのコードから、自動配線されたオブジェクトを持つサービスクラスを呼び出すための新しいオブジェクトを作成しています。</target>
        </trans-unit>
        <trans-unit id="17e5fa0456b0b310229eb43f4b0714169ea19cff" translate="yes" xml:space="preserve">
          <source>Adding annotation only, does not fix or facilitate the dependency injection, Spring needs to know where to look for.</source>
          <target state="translated">アノテーションだけを追加しても、依存性インジェクションを修正したり、容易にしたりすることはできません。</target>
        </trans-unit>
        <trans-unit id="57be7d302f1b2ff8eef279015d9880539858b846" translate="yes" xml:space="preserve">
          <source>After &quot;learning&quot; that I had to annotate a class with @Component or the derivatives @Service or @Repository (I guess there are more), to autowire other components inside them, it struck me that these other components still were null inside the constructor of the parent component.</source>
          <target state="translated">クラスに@Componentや派生の@Serviceや@Repository(他にもあると思います)をアノテーションして、その中の他のコンポーネントを自動配線する必要があることを「学習」した後、これらの他のコンポーネントが親コンポーネントのコンストラクタの中ではまだNULLであることに気付きました。</target>
        </trans-unit>
        <trans-unit id="41fc58409cda1816c0d86da0328ade7c51269de3" translate="yes" xml:space="preserve">
          <source>Also note that if, for whatever reason, you make a method in a &lt;code&gt;@Service&lt;/code&gt; as &lt;code&gt;final&lt;/code&gt;, the autowired beans you will access from it will always be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">また、何らかの理由で &lt;code&gt;@Service&lt;/code&gt; に &lt;code&gt;final&lt;/code&gt; としてメソッドを作成した場合、そこからアクセスするオートワイヤードBeanは常に &lt;code&gt;null&lt;/code&gt; になります 。</target>
        </trans-unit>
        <trans-unit id="0e62f46e6b944ff55852b8bd59d0add7902a8d67" translate="yes" xml:space="preserve">
          <source>And after that, NPE started coming in. In a &lt;code&gt;pep-config.xml&lt;/code&gt; I had just 2 beans:</source>
          <target state="translated">その後、NPEが登場し始めました &lt;code&gt;pep-config.xml&lt;/code&gt; には、2つのBeanしかありませんでした。</target>
        </trans-unit>
        <trans-unit id="ec68cc24f685999a1deb5d39824c5936e0df4e7d" translate="yes" xml:space="preserve">
          <source>Another solution would be putting call:
&lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;</source>
          <target state="translated">別の解決策は、呼び出しを置くことです： &lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f41f414dfb43d22eb44abecd6879c5950ea1c" translate="yes" xml:space="preserve">
          <source>At last we found that the error was that we (actually, the Eclipse auto complete feature) imported &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; instead of &lt;code&gt;javax.inject.Inject&lt;/code&gt; !</source>
          <target state="translated">ついにエラーが見つかりました。私たち（実際にはEclipseのオートコンプリート機能）が &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; 代わりにcom.opensymphony.xwork2.Injectをインポートしたことです。</target>
        </trans-unit>
        <trans-unit id="d94d761d0a782bc648563729db0ab5861e158fd2" translate="yes" xml:space="preserve">
          <source>Change your Controller class like below.</source>
          <target state="translated">以下のようにControllerクラスを変更します。</target>
        </trans-unit>
        <trans-unit id="7ba406818c8f1055e3ce7bbdb75cfb6882131af8" translate="yes" xml:space="preserve">
          <source>Check this out:</source>
          <target state="translated">これをチェックしてみてください。</target>
        </trans-unit>
        <trans-unit id="d230873b60b53c384e2144ccb234383174838a29" translate="yes" xml:space="preserve">
          <source>Classes marked with annotation need to be identified by spring before injecting, &lt;code&gt;@ComponentScan&lt;/code&gt; instruct spring look for the classes marked with annotation. When Spring finds &lt;code&gt;@Autowired&lt;/code&gt; it searches for the related bean, and injects the required instance.</source>
          <target state="translated">アノテーションでマークされたクラスは、注入する前にスプリングで識別される必要があります。 &lt;code&gt;@ComponentScan&lt;/code&gt; は、アノテーションでマークされたクラスをスプリングルックに指示します。 Springが &lt;code&gt;@Autowired&lt;/code&gt; を見つけると、関連するBeanを検索し、必要なインスタンスを挿入します。</target>
        </trans-unit>
        <trans-unit id="b83c98c8abe52ca04318bc946ddb1f41bf28da5e" translate="yes" xml:space="preserve">
          <source>Controller class:</source>
          <target state="translated">コントローラクラス。</target>
        </trans-unit>
        <trans-unit id="72e876a8da98d0fdec73e4e6b97838b88035189f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;@SpringBootTest&lt;/code&gt; to work stand alone, you need to use &lt;code&gt;@Test&lt;/code&gt; from &lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit5 instead of JUnit4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@SpringBootTest&lt;/code&gt; がスタンドアロンで&lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;動作するには&lt;/a&gt; 、 JUnit4ではなくJUnit5から &lt;code&gt;@Test&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ac65d99b8c551d6eafac33e561e4dde92e51d8d7" translate="yes" xml:space="preserve">
          <source>For example, in &lt;strong&gt;Spring Boot&lt;/strong&gt;:</source>
          <target state="translated">たとえば、 &lt;strong&gt;Spring Bootでは&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="f6ca09ba5cd1826f082b5fb7aab89b84c2c8faa7" translate="yes" xml:space="preserve">
          <source>I don't know if it helps anyone, but I was stuck with the same problem even while doing things seemingly right. In my Main method, I have a code like this:</source>
          <target state="translated">誰かの助けになるかどうかはわかりませんが、私は一見正しいように見えることをしていても同じ問題に悩まされていました。私のMainメソッドの中には、次のようなコードがあります。</target>
        </trans-unit>
        <trans-unit id="290aab609060c87e3330711b7a475560a5a08290" translate="yes" xml:space="preserve">
          <source>I have a Spring &lt;code&gt;@Service&lt;/code&gt; class (&lt;code&gt;MileageFeeCalculator&lt;/code&gt;) that has an &lt;code&gt;@Autowired&lt;/code&gt; field (&lt;code&gt;rateService&lt;/code&gt;), but the field is &lt;code&gt;null&lt;/code&gt; when I try to use it. The logs show that both the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; bean and the &lt;code&gt;MileageRateService&lt;/code&gt; bean are being created, but I get a &lt;code&gt;NullPointerException&lt;/code&gt; whenever I try to call the &lt;code&gt;mileageCharge&lt;/code&gt; method on my service bean. Why isn't Spring autowiring the field?</source>
          <target state="translated">&lt;code&gt;@Autowired&lt;/code&gt; フィールド（ &lt;code&gt;rateService&lt;/code&gt; ）を持つSpring &lt;code&gt;@Service&lt;/code&gt; クラス（ &lt;code&gt;MileageFeeCalculator&lt;/code&gt; ）がありますが、使用しようとするとフィールドが &lt;code&gt;null&lt;/code&gt; になります。 ログには、 &lt;code&gt;MileageFeeCalculator&lt;/code&gt; Beanと &lt;code&gt;MileageRateService&lt;/code&gt; Beanの両方が作成されていることが &lt;code&gt;mileageCharge&lt;/code&gt; れていますが、サービスBeanでmileageChargeメソッドを呼び出そうとすると、 &lt;code&gt;NullPointerException&lt;/code&gt; が発生します。 Springがフィールドを自動配線しないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="4d81e527154a800d280587cbded9d3aad6e0b819" translate="yes" xml:space="preserve">
          <source>I have posted all of this code, using Spring Boot to launch, at &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;this GitHub project&lt;/a&gt;; you can look at a full running project for each approach to see everything you need to make it work. &lt;strong&gt;Tag with the &lt;code&gt;NullPointerException&lt;/code&gt;: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt;&lt;code&gt;nonworking&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;このGitHubプロジェクトで&lt;/a&gt; 、Spring Bootを使用してこのコードをすべて投稿しました 。 各アプローチの完全に実行中のプロジェクトを見て、それを機能させるために必要なすべてを確認できます。 &lt;strong&gt; &lt;code&gt;NullPointerException&lt;/code&gt; のタグ：機能し&lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt; &lt;code&gt;nonworking&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a28c8ad27d6ac9d92801b7c7616da199741fee8" translate="yes" xml:space="preserve">
          <source>I make Spring inject &lt;code&gt;applicationContext&lt;/code&gt; in this bean:</source>
          <target state="translated">このBeanにSpringに &lt;code&gt;applicationContext&lt;/code&gt; を挿入します 。</target>
        </trans-unit>
        <trans-unit id="9d7deec7709d1e237f060b3e6cae162dde1f065a" translate="yes" xml:space="preserve">
          <source>I noticed that the package.path does no longer exist, so I've just dropped the line for good.</source>
          <target state="translated">package.pathが存在しなくなっていることに気づいたので、とりあえず一行だけ落としておきました。</target>
        </trans-unit>
        <trans-unit id="acaef4085e64a02688aad3db5d1923dfe9e86ead" translate="yes" xml:space="preserve">
          <source>I once encountered the same issue when I was not quite used to &lt;code&gt;the life in the IoC world&lt;/code&gt;. The &lt;code&gt;@Autowired&lt;/code&gt; field of one of my beans is null at runtime.</source>
          <target state="translated">&lt;code&gt;the life in the IoC world&lt;/code&gt; 慣れていないときに、同じ問題にかつて遭遇しました。 いずれかのBeanの &lt;code&gt;@Autowired&lt;/code&gt; フィールドが実行時にnullになります。</target>
        </trans-unit>
        <trans-unit id="d4f5aca2a7ed0b7166b5ed31cd0d48496a56e4c5" translate="yes" xml:space="preserve">
          <source>I think you have missed to instruct spring to scan classes with annotation.</source>
          <target state="translated">春にアノテーションでクラスをスキャンするように指示するのは失敗したと思います。</target>
        </trans-unit>
        <trans-unit id="e6f1ec927b26cd65fdaaa4ddf91e84e5652ed241" translate="yes" xml:space="preserve">
          <source>If this is happening in a test class, make sure you haven't forgotten to annotate the class.</source>
          <target state="translated">これがテストクラスで発生している場合は、クラスへのアノテーションを忘れていないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="f517ef786825d3bc62a16f6307b66a8ef2849b27" translate="yes" xml:space="preserve">
          <source>If you are not coding a web application, make sure your class in which @Autowiring is done is a spring bean. Typically, spring container won't be aware of the class which we might think of as a spring bean. We have to tell the Spring container about our spring classes.</source>
          <target state="translated">Webアプリケーションをコーディングしていない場合は、@Autowiringが行われているクラスがspring beanであることを確認してください。通常、春のコンテナは春の豆と思われるようなクラスを意識しません。私たちは、スプリングコンテナに私たちのスプリングクラスを伝えなければなりません。</target>
        </trans-unit>
        <trans-unit id="4210a615a7a8e9cf17363c2ebfcc8af5476ec05a" translate="yes" xml:space="preserve">
          <source>If you are writing unit test make sure you are not creating object using &lt;code&gt;new object()&lt;/code&gt;. Use instead injectMock.</source>
          <target state="translated">単体テストを作成している場合は、 &lt;code&gt;new object()&lt;/code&gt; を使用してオブジェクトを作成していないことを確認してください。 代わりにinjectMockを使用してください。</target>
        </trans-unit>
        <trans-unit id="e1b2ce47c7a4f14dbdd6d84b8fe65d5309868f7e" translate="yes" xml:space="preserve">
          <source>If you get this configuration wrong your tests will compile, but &lt;code&gt;@Autowired&lt;/code&gt; and &lt;code&gt;@Value&lt;/code&gt; fields (for example) will be &lt;code&gt;null&lt;/code&gt;.  Since Spring Boot operates by magic, you may have few avenues for directly debugging this failure.</source>
          <target state="translated">この設定を間違って取得すると、テストはコンパイルされますが、 &lt;code&gt;@Autowired&lt;/code&gt; および &lt;code&gt;@Value&lt;/code&gt; フィールド（たとえば）は &lt;code&gt;null&lt;/code&gt; になります 。 Spring Bootは魔法のように動作するため、この障害を直接デバッグする手段がほとんどない場合があります。</target>
        </trans-unit>
        <trans-unit id="6c1b72872b08c510fda6dfeaed1dcb63e25fcc5d" translate="yes" xml:space="preserve">
          <source>If you need to create a new instance of your service object for different requests, you can still use injection by using &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;the Spring bean scopes&lt;/a&gt;.</source>
          <target state="translated">さまざまなリクエストに対してサービスオブジェクトの新しいインスタンスを作成する必要がある場合でも&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;、Spring Beanスコープ&lt;/a&gt;を使用してインジェクションを使用できます。</target>
        </trans-unit>
        <trans-unit id="1f44484492dfecd22e18b5bd83804f19ec3019b8" translate="yes" xml:space="preserve">
          <source>If you really need objects created with &lt;code&gt;new&lt;/code&gt; to be autowired, you can &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;use the Spring &lt;code&gt;@Configurable&lt;/code&gt; annotation along with AspectJ compile-time weaving&lt;/a&gt; to inject your objects. This approach inserts code into your object's constructor that alerts Spring that it's being created so that Spring can configure the new instance. This requires a bit of configuration in your build (such as compiling with &lt;code&gt;ajc&lt;/code&gt;) and turning on Spring's runtime configuration handlers (&lt;code&gt;@EnableSpringConfigured&lt;/code&gt; with the JavaConfig syntax). This approach is used by the Roo Active Record system to allow &lt;code&gt;new&lt;/code&gt; instances of your entities to get the necessary persistence information injected.</source>
          <target state="translated">自動でワイヤリングされる &lt;code&gt;new&lt;/code&gt; で作成されたオブジェクトが本当に必要な場合&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;は、Spring &lt;code&gt;@Configurable&lt;/code&gt; アノテーションをAspectJコンパイル時ウィービングとともに使用して&lt;/a&gt; 、オブジェクトを挿入できます。 このアプローチでは、オブジェクトのコンストラクターにコードが挿入され、Springが新しいインスタンスを構成できるように、作成されていることがSpringに通知されます。 これには、ビルドでの設定（ &lt;code&gt;@EnableSpringConfigured&lt;/code&gt; を使用したコンパイルなど）と、Springの実行時設定ハンドラー（JavaConfig構文による &lt;code&gt;ajc&lt;/code&gt; ）を有効にする必要があります。 このアプローチはRoo Active Recordシステムで使用され、エンティティの &lt;code&gt;new&lt;/code&gt; インスタンスが必要な永続性情報を注入できるようにします。</target>
        </trans-unit>
        <trans-unit id="8dc718c58fb367fa7f99b778de29f6511c238cfc" translate="yes" xml:space="preserve">
          <source>In simple words there are mainly two reasons for an &lt;code&gt;@Autowired&lt;/code&gt; field to be &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">簡単に言えば、 &lt;code&gt;@Autowired&lt;/code&gt; フィールドが &lt;code&gt;null&lt;/code&gt; になる理由は主に2つあります。</target>
        </trans-unit>
        <trans-unit id="c1fa06015977d4bb62501850a732d535c515f902" translate="yes" xml:space="preserve">
          <source>In this way &lt;strong&gt;any bean can be obtained by any object in the application&lt;/strong&gt; (also intantiated with &lt;code&gt;new&lt;/code&gt;) and &lt;strong&gt;in a static way&lt;/strong&gt;.</source>
          <target state="translated">このようにして&lt;strong&gt;、任意のBeanは、アプリケーション内の任意のオブジェクト&lt;/strong&gt; （ &lt;code&gt;new&lt;/code&gt; でもインスタンス化）と&lt;strong&gt;静的な方法&lt;/strong&gt; &lt;strong&gt;で取得できます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="fee4af12fa524c1a7940448312eebdd0a757e15d" translate="yes" xml:space="preserve">
          <source>Inject your beans</source>
          <target state="translated">あなたの豆を注入する</target>
        </trans-unit>
        <trans-unit id="c56453903ed805219ab7d905bfb3d9194b146484" translate="yes" xml:space="preserve">
          <source>It seems to be rare case but here is what happened to me:</source>
          <target state="translated">レアケースのようですが、私の場合はこんな感じでした。</target>
        </trans-unit>
        <trans-unit id="81362fff4d639337528a9b83ac93d07b4c8831f8" translate="yes" xml:space="preserve">
          <source>Manual bean lookup: not recommended</source>
          <target state="translated">手動での豆の検索:推奨されません</target>
        </trans-unit>
        <trans-unit id="15d38dff68d219829bee6302f049d493d93ad283" translate="yes" xml:space="preserve">
          <source>My Service class had an annotation of service and it was &lt;code&gt;@autowired&lt;/code&gt; another component class. When I tested the component class was coming null. Because for service class I was creating the object using &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">私のサービスクラスにはサービスの注釈があり、それは別のコンポーネントクラスである &lt;code&gt;@autowired&lt;/code&gt; でした 。 テストしたとき、コンポーネントクラスはnullになりました。 サービスクラスのために、私は &lt;code&gt;new&lt;/code&gt; を使用してオブジェクトを作成していたので</target>
        </trans-unit>
        <trans-unit id="4163f897a2b6918d5bcba8024e27a75a21262caa" translate="yes" xml:space="preserve">
          <source>Other classes can use it like this:</source>
          <target state="translated">他のクラスではこんな感じで使えます。</target>
        </trans-unit>
        <trans-unit id="d7a7cfd642fc22c1d2461573908ac9a588902de4" translate="yes" xml:space="preserve">
          <source>Service bean that should be autowired in &lt;code&gt;MileageFeeCalculator&lt;/code&gt; but it isn't:</source>
          <target state="translated">MileageFeeCalculatorで &lt;code&gt;MileageFeeCalculator&lt;/code&gt; 配線されるべきサービスBeanですが、そうではありません：</target>
        </trans-unit>
        <trans-unit id="8a5f1e0fe0b1effd67db55ae23df2f6cc081647a" translate="yes" xml:space="preserve">
          <source>Service class:</source>
          <target state="translated">サービスクラス。</target>
        </trans-unit>
        <trans-unit id="b45858b98095f901fc99c8338155a5faac0efb3c" translate="yes" xml:space="preserve">
          <source>So to summarize, make sure that your annotations (&lt;code&gt;@Autowired&lt;/code&gt;, &lt;code&gt;@Inject&lt;/code&gt;, &lt;code&gt;@Service&lt;/code&gt; ,... ) have correct packages!</source>
          <target state="translated">要約すると、アノテーション（ &lt;code&gt;@Autowired&lt;/code&gt; 、 @Inject 、 @Service 、...）に正しいパッケージがあることを確認してください！</target>
        </trans-unit>
        <trans-unit id="3239365d583a95875a43f9f065681b250601c3cc" translate="yes" xml:space="preserve">
          <source>Some time elapses...</source>
          <target state="translated">時間が経つと...</target>
        </trans-unit>
        <trans-unit id="185f0371245faa8bbe1b174c71c3c16fe0b0cf16" translate="yes" xml:space="preserve">
          <source>Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;continues to evolve&lt;/a&gt;.  It is no longer required to use &lt;code&gt;@RunWith&lt;/code&gt;&lt;em&gt;if you use the correct version of JUnit&lt;/em&gt;.</source>
          <target state="translated">Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;は進化を続けています&lt;/a&gt; 。 &lt;em&gt;正しいバージョンのJUnitを使用している場合は、&lt;/em&gt; &lt;code&gt;@RunWith&lt;/code&gt; を使用する必要はなくなりました。</target>
        </trans-unit>
        <trans-unit id="859e7a96ec1ad84e49569265bcd589ac37498e71" translate="yes" xml:space="preserve">
          <source>Spring only injects instances of those classes which are either created as bean or marked with annotation.</source>
          <target state="translated">Springは、Beanとして作成されるか、アノテーションでマークされたクラスのインスタンスのみを注入します。</target>
        </trans-unit>
        <trans-unit id="b198e9188ffed25cac4c321fdc9e545886b5c39f" translate="yes" xml:space="preserve">
          <source>The IoC container isn't magic, and it has no way of knowing about Java objects unless you somehow inform it of them. When you call &lt;code&gt;new&lt;/code&gt;, the JVM instantiates a copy of the new object and hands it straight to you--it never goes through the configuration process. There are three ways that you can get your beans configured.</source>
          <target state="translated">IoCコンテナは魔法ではなく、何らかの形で通知しない限り、Javaオブジェクトについて知る方法はありません。 &lt;code&gt;new&lt;/code&gt; を呼び出すと、JVMは新しいオブジェクトのコピーをインスタンス化し、それを直接渡します。構成プロセスは行われません。 Beanを構成するには、3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="289f38a4a85aa5b9a3c5b59180313674628783cd" translate="yes" xml:space="preserve">
          <source>The field annotated &lt;code&gt;@Autowired&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; because Spring doesn't know about the copy of &lt;code&gt;MileageFeeCalculator&lt;/code&gt; that you created with &lt;code&gt;new&lt;/code&gt; and didn't know to autowire it.</source>
          <target state="translated">アノテーション付きのフィールド &lt;code&gt;@Autowired&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; です。 これは、Springが &lt;code&gt;new&lt;/code&gt; で作成した &lt;code&gt;MileageFeeCalculator&lt;/code&gt; のコピーを認識しておらず、自動配線することを知らなかったためです。</target>
        </trans-unit>
        <trans-unit id="17cafeacf0e3808d318c6c7dab584d668bff3de5" translate="yes" xml:space="preserve">
          <source>The most preferable option is to let Spring autowire all of your beans; this requires the least amount of code and is the most maintainable. To make the autowiring work like you wanted, also autowire the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; like this:</source>
          <target state="translated">最も好ましいオプションは、SpringにすべてのBeanを自動ワイヤリングさせることです。 これは、必要なコードの量が最も少なく、最も保守しやすいコードです。 自動配線を希望どおりに &lt;code&gt;MileageFeeCalculator&lt;/code&gt; せるには、 次のようにMileageFeeCalculatorを自動配線します。</target>
        </trans-unit>
        <trans-unit id="7525865b1f3cf4afe5b64057e41c714903c82bb4" translate="yes" xml:space="preserve">
          <source>The root cause is, instead of using the auto-created bean maintained by the Spring IoC container (whose &lt;code&gt;@Autowired&lt;/code&gt; field is &lt;code&gt;indeed&lt;/code&gt; properly injected), I am &lt;code&gt;newing&lt;/code&gt; my own instance of that bean type and using it. Of course this one's &lt;code&gt;@Autowired&lt;/code&gt; field is null because Spring has no chance to inject it.</source>
          <target state="translated">根本的な原因は、Spring IoCコンテナ（ &lt;code&gt;@Autowired&lt;/code&gt; フィールドが &lt;code&gt;indeed&lt;/code&gt; 適切に挿入されている）によって維持されている自動作成Beanを使用する代わりに、そのBeanタイプの独自のインスタンスを &lt;code&gt;newing&lt;/code&gt; て使用していることです。 もちろん、このフィールドの &lt;code&gt;@Autowired&lt;/code&gt; フィールドはnullです。これは、Springがそれを挿入する機会がないためです。</target>
        </trans-unit>
        <trans-unit id="5ab338c160a06915539afb8ea6a40782d023e2a0" translate="yes" xml:space="preserve">
          <source>The solution makes this MileageFeeCalculator as an auto-wired object in the Controller itself.</source>
          <target state="translated">このソリューションでは、このMileageFeeCalculatorをコントローラ自体の自動配線オブジェクトにしています。</target>
        </trans-unit>
        <trans-unit id="a918b75229c39b7362467ef9574f8a999ad37470" translate="yes" xml:space="preserve">
          <source>Then your legacy code can call &lt;code&gt;getContext()&lt;/code&gt; and retrieve the beans it needs:</source>
          <target state="translated">次に、レガシーコードは &lt;code&gt;getContext()&lt;/code&gt; を呼び出して、必要なBeanを取得できます。</target>
        </trans-unit>
        <trans-unit id="ed5445ba25a7eb16ffe83bc73d081a07998d9071" translate="yes" xml:space="preserve">
          <source>This approach is suitable only for interfacing with legacy code in special situations. It is nearly always preferable to create a singleton adapter class that Spring can autowire and the legacy code can call, but it is possible to directly ask the Spring application context for a bean.</source>
          <target state="translated">このアプローチは、特殊な状況でレガシーコードとのインターフェイスにのみ適しています。Springが自動配線し、レガシーコードが呼び出すことができるシングルトンアダプタクラスを作成することが望ましいですが、Springアプリケーションのコンテキストに直接ビーンを要求することも可能です。</target>
        </trans-unit>
        <trans-unit id="a2564b58e68e65ff5e059a30fb59c75588cf998f" translate="yes" xml:space="preserve">
          <source>This can be achieved by configuring in appln-contxt or &lt;strong&gt;the better way&lt;/strong&gt; is to annotate class as &lt;strong&gt;@Component&lt;/strong&gt; and please do not create the annotated class using new operator.
Make sure you get it from Appln-context as below.</source>
          <target state="translated">これは、appln-contxtで設定することで実現できます。または&lt;strong&gt;、より良い方法&lt;/strong&gt;は、クラスに&lt;strong&gt;@Component&lt;/strong&gt;として注釈を付けることです。新しい演算子を使用して注釈付きクラスを作成しないでください。 以下のようにAppln-contextから取得してください。</target>
        </trans-unit>
        <trans-unit id="cba84fb3a576f1982a7a4e89a35adfcdcd86b573" translate="yes" xml:space="preserve">
          <source>This fixed my issue. Here is a useful &lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;link&lt;/a&gt;</source>
          <target state="translated">これで問題が解決しました。 ここに便利な&lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;リンクがあります&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd42e9c07834066aba16496cc46ca18618d98be0" translate="yes" xml:space="preserve">
          <source>This is only valid in case of Unit test.</source>
          <target state="translated">ユニットテストの場合のみ有効です。</target>
        </trans-unit>
        <trans-unit id="c3bf31c57b1da3cd7be0fd57b9c4bbbf09272a68" translate="yes" xml:space="preserve">
          <source>This is the culprit of giving NullPointerException &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; We are using Spring - don't need to create object manually. Object creation will be taken care of by IoC container.</source>
          <target state="translated">これがNullPointerExceptionを与える原因です &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; Springを使用しています-オブジェクトを手動で作成する必要はありません。 オブジェクトの作成はIoCコンテナーによって処理されます。</target>
        </trans-unit>
        <trans-unit id="f056c0834db33a952b9af4a4a12e11c7ce780a22" translate="yes" xml:space="preserve">
          <source>To MileageFeeCalculator constructor like this:</source>
          <target state="translated">このようなMileageFeeCalculatorのコンストラクタへ。</target>
        </trans-unit>
        <trans-unit id="a415fb8c7eebe85e5542348eaa6368fe99ef4ebd" translate="yes" xml:space="preserve">
          <source>To do this, you need a class to which Spring can give a reference to the &lt;code&gt;ApplicationContext&lt;/code&gt; object:</source>
          <target state="translated">これを行うには、Springが &lt;code&gt;ApplicationContext&lt;/code&gt; オブジェクトへの参照を提供できるクラスが必要です。</target>
        </trans-unit>
        <trans-unit id="712bd4ea7182b2392287b9cba31f1c58a4f995c7" translate="yes" xml:space="preserve">
          <source>Use @Configurable</source>
          <target state="translated">コンフィギュラブルを使用します。</target>
        </trans-unit>
        <trans-unit id="b4de62676a8e2ba66f6e67603bb1ab327f963c2d" translate="yes" xml:space="preserve">
          <source>Using @PostConstruct solves that:</source>
          <target state="translated">PostConstructを使うことで解決します。</target>
        </trans-unit>
        <trans-unit id="814e53b54fffcd1ab97e69af5ec501e8ca6cd377" translate="yes" xml:space="preserve">
          <source>We used &lt;code&gt;@Inject&lt;/code&gt; instead of &lt;code&gt;@Autowired&lt;/code&gt; which is javaee standard supported by Spring. Every places it worked fine and the beans injected correctly, instead of one place. The bean injection seems the same</source>
          <target state="translated">Springでサポートされているjavaee標準である@Autowiredの代わりに &lt;code&gt;@Inject&lt;/code&gt; を使用しました。 1つの場所ではなく、すべての場所で問題なく動作し、豆が正しく注入されました。 豆の注入は同じようです</target>
        </trans-unit>
        <trans-unit id="a22a650a6695b1cb52df04c214890311d5d9f32b" translate="yes" xml:space="preserve">
          <source>What hasn't been mentioned here is described in &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot;&gt;this&lt;/a&gt; article in the paragraph &quot;Order of execution&quot;.</source>
          <target state="translated">ここで言及されていないことは、 &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot;&gt;この&lt;/a&gt;記事の「実行の順序」の段落で説明されています。</target>
        </trans-unit>
        <trans-unit id="c9351769f2d3fc8aed37c27cfba4d601a5fd919c" translate="yes" xml:space="preserve">
          <source>When I try to &lt;code&gt;GET /mileage/3&lt;/code&gt;, I get this exception:</source>
          <target state="translated">&lt;code&gt;GET /mileage/3&lt;/code&gt; を取得しようとすると、次の例外が発生します。</target>
        </trans-unit>
        <trans-unit id="4a94711b9930ced50218f0105a49745e4e697dd7" translate="yes" xml:space="preserve">
          <source>Why is my Spring @Autowired field null</source>
          <target state="translated">なぜ私の Spring @Autowired フィールドは null になるのか?</target>
        </trans-unit>
        <trans-unit id="0355cb07b2fa9677429e730cb275eac228744309" translate="yes" xml:space="preserve">
          <source>With annotation &lt;code&gt;@Service&lt;/code&gt;, &lt;code&gt;@Component&lt;/code&gt;, &lt;code&gt;@Configuration&lt;/code&gt; beans are created in the</source>
          <target state="translated">アノテーション &lt;code&gt;@Component&lt;/code&gt; 、 &lt;code&gt;@Configuration&lt;/code&gt; Component 、 @Configuration Beanを使用して、</target>
        </trans-unit>
        <trans-unit id="e646deb97792a6ade92069b79676e29df55b56d7" translate="yes" xml:space="preserve">
          <source>You can also fix this issue using @Service annotation on service class and passing the required bean classA as a parameter to the other beans classB constructor and annotate the constructor of classB with @Autowired. Sample snippet here :</source>
          <target state="translated">また、サービスクラスの@Serviceアノテーションを使用して、必要なビーンclassAを他のビーンclassBのコンストラクタのパラメータとして渡し、classBのコンストラクタに@Autowiredをアノテーションすることで、この問題を解決することができます。サンプルスニペットはこちらです。</target>
        </trans-unit>
        <trans-unit id="9d2bd3f9fbf79e8c120c81a56d52d033b5a518c7" translate="yes" xml:space="preserve">
          <source>You can put this code also in the main application class if you want.</source>
          <target state="translated">このコードをメインのアプリケーションクラスにも配置することができます。</target>
        </trans-unit>
        <trans-unit id="ca489fbd0a1b9070d098e10dcb1d2193bc0465c8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; on the configuration class of your spring application to instruct spring to scan.</source>
          <target state="translated">&lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; アプリケーションの構成クラスで@ComponentScan（ &quot;packageToScan&quot;）を使用して、 Springにスキャンを指示することができます。</target>
        </trans-unit>
        <trans-unit id="748d434e98b06abd0eecc728bee5795a1ecdb8c5" translate="yes" xml:space="preserve">
          <source>Your problem is new (object creation in java style)</source>
          <target state="translated">あなたの問題は新しいものです(javaスタイルでのオブジェクト作成)</target>
        </trans-unit>
        <trans-unit id="6097ca49faf78ea33ebe49e2de5a90e831a070dc" translate="yes" xml:space="preserve">
          <source>and SomeAbac class has a property declared as</source>
          <target state="translated">と宣言されているプロパティがあり、SomeAbacクラスは</target>
        </trans-unit>
        <trans-unit id="fe045fcc475b2ed5785570e3bf62d2af03225740" translate="yes" xml:space="preserve">
          <source>and in a &lt;code&gt;token.xml&lt;/code&gt; file I've had a line</source>
          <target state="translated">そして &lt;code&gt;token.xml&lt;/code&gt; ファイルに私は行を入れました</target>
        </trans-unit>
        <trans-unit id="8f184f10becfd5255e7dd174b71f596e5ed826d2" translate="yes" xml:space="preserve">
          <source>and it works. May be someone can provide an explanation, but for me it's enough right now )</source>
          <target state="translated">と、それは動作します。誰かが説明を提供することができるかもしれませんが、私にとっては今はそれだけで十分です)</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="83e983915573bdd6a6a5428e20d4237c9b28e9f9" translate="yes" xml:space="preserve">
          <source>application context of Spring when server is started. But when we create objects 
    using new operator the object is not registered in  application context which  is already created. For Example Employee.java class i have used.</source>
          <target state="translated">のアプリケーションコンテキストに登録されます。しかし、new演算子を使ってオブジェクトを作成しても、既に作成されているアプリケーションコンテキストには登録されません。例Employee.javaクラスの場合、私は使用しています。</target>
        </trans-unit>
        <trans-unit id="8f777ca7518e37a243e3d63d7566fe9cd2f615f1" translate="yes" xml:space="preserve">
          <source>for some unknown reason, settings is &lt;em&gt;null&lt;/em&gt; in init(), when &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; element is not present at all, but when it's present and has some bs as a basePackage, everything works well. This line now looks like this:</source>
          <target state="translated">不明な理由により、 &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; 要素がまったく存在しない場合、init（）の設定は&lt;em&gt;null&lt;/em&gt;ですが、それが存在し、basePackageとしていくつかのbsがある場合、すべてが正常に機能します。 この行は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d5db4151b6088246e47fd7448b54cae44fc44c85" translate="yes" xml:space="preserve">
          <source>so it won't work that way.</source>
          <target state="translated">ということで、そのようにはいかないでしょう。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
