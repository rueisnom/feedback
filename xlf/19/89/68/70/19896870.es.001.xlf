<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/19896870">
    <body>
      <group id="19896870">
        <trans-unit id="394b57ab44493bad9e13375faca2da97306afe8c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;The Spring Inversion of Control (IoC) container&lt;/a&gt; has three main logical components: a registry (called the &lt;code&gt;ApplicationContext&lt;/code&gt;) of components (beans) that are available to be used by the application, a configurer system that injects objects' dependencies into them by matching up the dependencies with beans in the context, and a dependency solver that can look at a configuration of many different beans and determine how to instantiate and configure them in the necessary order.</source>
          <target state="translated">&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;El contenedor Spring Inversion of Control (IoC)&lt;/a&gt; tiene tres componentes l&amp;oacute;gicos principales: un registro (llamado &lt;code&gt;ApplicationContext&lt;/code&gt; ) de componentes (beans) que est&amp;aacute;n disponibles para ser utilizados por la aplicaci&amp;oacute;n, un sistema configurador que inyecta las dependencias de los objetos haciendo coincidirlos las dependencias con beans en el contexto, y un solucionador de dependencias que puede ver una configuraci&amp;oacute;n de muchos beans diferentes y determinar c&amp;oacute;mo instanciarlos y configurarlos en el orden necesario.</target>
        </trans-unit>
        <trans-unit id="1ae06b30b6d1c782656a2208ccb72d7333701bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@Service, @Component&lt;/code&gt; etc annotations add meta description.</source>
          <target state="translated">&lt;code&gt;@Service, @Component&lt;/code&gt; anotaciones @Service, @Component, etc. a&amp;ntilde;aden una meta descripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a70bff0ba394cef82c27ca682d50f21c90605937" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I'm new to Spring, but I discovered this working solution. Please tell me if it's a deprecable way.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Soy nuevo en Spring, pero descubr&amp;iacute; esta soluci&amp;oacute;n de trabajo.&lt;/em&gt; &lt;em&gt;Por favor dime si es una manera despreciable.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac07e8cc2813a62fa38fad476b41fdaaca46ef7a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is intended to be a canonical answer for a common problem.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nota: Esto pretende ser una respuesta can&amp;oacute;nica para un problema com&amp;uacute;n.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b7fb549b54ec58659fd74cbdd78e77c0e0493806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ORIGINAL ANSWER:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESPUESTA ORIGINAL:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f981fb4e08e95e60895db03be2fe27045a89932" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE FIELD IS NOT A BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El campo no es un frijol.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c63b5f6bebe122bb768741b030b15d8683140f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by injecting the &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt;&lt;code&gt;working-inject-bean&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Etiqueta que funciona inyectando el objeto de servicio &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; : &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt; &lt;code&gt;working-inject-bean&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ece2ffe683fc87cb97657a6c77b083b990d1adf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by manually looking up the service object in the Spring context: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt;&lt;code&gt;working-manual-lookup&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Etiqueta que funciona al buscar manualmente el objeto de servicio en el contexto de Spring: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt; &lt;code&gt;working-manual-lookup&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ee91e9a00165f2f5a170963a6a33b134695cf84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by using &lt;code&gt;@Configurable&lt;/code&gt; on the service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt;&lt;code&gt;working-configurable&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Etiqueta que funciona utilizando &lt;code&gt;@Configurable&lt;/code&gt; en el objeto de servicio: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt; &lt;code&gt;working-configurable&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="774dd712670d211631d8f90f0cee69e58e4015a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; Really smart people were quick to point on &lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;this&lt;/a&gt; answer, which explains the weirdness, described below</source>
          <target state="translated">&lt;strong&gt;ACTUALIZACI&amp;Oacute;N:&lt;/strong&gt; las personas realmente inteligentes se apresuraron a se&amp;ntilde;alar &lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;esta&lt;/a&gt; respuesta, que explica la rareza, que se describe a continuaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="343f2555b3fe8817306d09a16f4d9c002d898197" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YOUR CLASS IS NOT A  SPRING BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tu clase no es un frijol de primavera.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="013573a8c9d74642d1e8e6d7631446a204fef372" translate="yes" xml:space="preserve">
          <source>Actually, you should use either JVM managed Objects or Spring-managed Object to invoke methods.
from your above code in your controller class, you are creating a new object to call your service class which has an auto-wired object.</source>
          <target state="translated">En realidad,deberías usar tanto los objetos gestionados por la JVM como los gestionados por Spring para invocar métodos.Desde el código anterior en tu clase de controlador,estás creando un nuevo objeto para llamar a tu clase de servicio que tiene un objeto auto-cableado.</target>
        </trans-unit>
        <trans-unit id="17e5fa0456b0b310229eb43f4b0714169ea19cff" translate="yes" xml:space="preserve">
          <source>Adding annotation only, does not fix or facilitate the dependency injection, Spring needs to know where to look for.</source>
          <target state="translated">Añadiendo sólo la anotación,no arregla ni facilita la inyección de la dependencia,Spring necesita saber dónde buscar.</target>
        </trans-unit>
        <trans-unit id="57be7d302f1b2ff8eef279015d9880539858b846" translate="yes" xml:space="preserve">
          <source>After &quot;learning&quot; that I had to annotate a class with @Component or the derivatives @Service or @Repository (I guess there are more), to autowire other components inside them, it struck me that these other components still were null inside the constructor of the parent component.</source>
          <target state="translated">Después de &quot;aprender&quot; que tenía que anotar una clase con @Componente o los derivados @Servicio o @Repositorio (supongo que hay más),para autocablear otros componentes dentro de ellos,me di cuenta de que estos otros componentes todavía eran nulos dentro del constructor del componente padre.</target>
        </trans-unit>
        <trans-unit id="41fc58409cda1816c0d86da0328ade7c51269de3" translate="yes" xml:space="preserve">
          <source>Also note that if, for whatever reason, you make a method in a &lt;code&gt;@Service&lt;/code&gt; as &lt;code&gt;final&lt;/code&gt;, the autowired beans you will access from it will always be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n tenga en cuenta que si, por cualquier raz&amp;oacute;n, realiza un m&amp;eacute;todo en un &lt;code&gt;@Service&lt;/code&gt; como &lt;code&gt;final&lt;/code&gt; , los beans con conexi&amp;oacute;n autom&amp;aacute;tica a los que acceder&amp;aacute; siempre ser&amp;aacute;n &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e62f46e6b944ff55852b8bd59d0add7902a8d67" translate="yes" xml:space="preserve">
          <source>And after that, NPE started coming in. In a &lt;code&gt;pep-config.xml&lt;/code&gt; I had just 2 beans:</source>
          <target state="translated">Y despu&amp;eacute;s de eso, NPE comenz&amp;oacute; a entrar. En un &lt;code&gt;pep-config.xml&lt;/code&gt; solo ten&amp;iacute;a 2 beans:</target>
        </trans-unit>
        <trans-unit id="ec68cc24f685999a1deb5d39824c5936e0df4e7d" translate="yes" xml:space="preserve">
          <source>Another solution would be putting call:
&lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;</source>
          <target state="translated">Otra soluci&amp;oacute;n ser&amp;iacute;a poner call: &lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f41f414dfb43d22eb44abecd6879c5950ea1c" translate="yes" xml:space="preserve">
          <source>At last we found that the error was that we (actually, the Eclipse auto complete feature) imported &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; instead of &lt;code&gt;javax.inject.Inject&lt;/code&gt; !</source>
          <target state="translated">Finalmente, encontramos que el error fue que nosotros (en realidad, la funci&amp;oacute;n de autocompletar de Eclipse) &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; lugar de &lt;code&gt;javax.inject.Inject&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="d94d761d0a782bc648563729db0ab5861e158fd2" translate="yes" xml:space="preserve">
          <source>Change your Controller class like below.</source>
          <target state="translated">Cambie su clase de Controlador como abajo.</target>
        </trans-unit>
        <trans-unit id="7ba406818c8f1055e3ce7bbdb75cfb6882131af8" translate="yes" xml:space="preserve">
          <source>Check this out:</source>
          <target state="translated">Mira esto:</target>
        </trans-unit>
        <trans-unit id="d230873b60b53c384e2144ccb234383174838a29" translate="yes" xml:space="preserve">
          <source>Classes marked with annotation need to be identified by spring before injecting, &lt;code&gt;@ComponentScan&lt;/code&gt; instruct spring look for the classes marked with annotation. When Spring finds &lt;code&gt;@Autowired&lt;/code&gt; it searches for the related bean, and injects the required instance.</source>
          <target state="translated">Las clases marcadas con anotaci&amp;oacute;n deben identificarse por resorte antes de inyectar, &lt;code&gt;@ComponentScan&lt;/code&gt; le indica a Spring que busque las clases marcadas con anotaci&amp;oacute;n. Cuando Spring encuentra &lt;code&gt;@Autowired&lt;/code&gt; , busca el bean relacionado e inyecta la instancia requerida.</target>
        </trans-unit>
        <trans-unit id="b83c98c8abe52ca04318bc946ddb1f41bf28da5e" translate="yes" xml:space="preserve">
          <source>Controller class:</source>
          <target state="translated">Clase de controlador:</target>
        </trans-unit>
        <trans-unit id="72e876a8da98d0fdec73e4e6b97838b88035189f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;@SpringBootTest&lt;/code&gt; to work stand alone, you need to use &lt;code&gt;@Test&lt;/code&gt; from &lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit5 instead of JUnit4&lt;/a&gt;.</source>
          <target state="translated">Para que &lt;code&gt;@SpringBootTest&lt;/code&gt; funcione de forma independiente, debe usar &lt;code&gt;@Test&lt;/code&gt; de &lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit5 en lugar de JUnit4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac65d99b8c551d6eafac33e561e4dde92e51d8d7" translate="yes" xml:space="preserve">
          <source>For example, in &lt;strong&gt;Spring Boot&lt;/strong&gt;:</source>
          <target state="translated">Por ejemplo, en &lt;strong&gt;Spring Boot&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f6ca09ba5cd1826f082b5fb7aab89b84c2c8faa7" translate="yes" xml:space="preserve">
          <source>I don't know if it helps anyone, but I was stuck with the same problem even while doing things seemingly right. In my Main method, I have a code like this:</source>
          <target state="translated">No sé si ayuda a alguien,pero yo estaba atascado con el mismo problema,incluso mientras hacía las cosas aparentemente bien.En mi método principal,tengo un código como este:</target>
        </trans-unit>
        <trans-unit id="290aab609060c87e3330711b7a475560a5a08290" translate="yes" xml:space="preserve">
          <source>I have a Spring &lt;code&gt;@Service&lt;/code&gt; class (&lt;code&gt;MileageFeeCalculator&lt;/code&gt;) that has an &lt;code&gt;@Autowired&lt;/code&gt; field (&lt;code&gt;rateService&lt;/code&gt;), but the field is &lt;code&gt;null&lt;/code&gt; when I try to use it. The logs show that both the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; bean and the &lt;code&gt;MileageRateService&lt;/code&gt; bean are being created, but I get a &lt;code&gt;NullPointerException&lt;/code&gt; whenever I try to call the &lt;code&gt;mileageCharge&lt;/code&gt; method on my service bean. Why isn't Spring autowiring the field?</source>
          <target state="translated">Tengo una clase Spring &lt;code&gt;@Service&lt;/code&gt; ( &lt;code&gt;MileageFeeCalculator&lt;/code&gt; ) que tiene un campo &lt;code&gt;rateService&lt;/code&gt; ( rateService ), pero el campo es &lt;code&gt;null&lt;/code&gt; cuando intento usarlo. Los registros muestran que se est&amp;aacute;n creando tanto el bean &lt;code&gt;MileageFeeCalculator&lt;/code&gt; como el bean &lt;code&gt;MileageRateService&lt;/code&gt; , pero obtengo una &lt;code&gt;NullPointerException&lt;/code&gt; cada vez que intento llamar al m&amp;eacute;todo &lt;code&gt;mileageCharge&lt;/code&gt; en mi bean de servicio. &amp;iquest;Por qu&amp;eacute; no se Spring autowiring el campo?</target>
        </trans-unit>
        <trans-unit id="4d81e527154a800d280587cbded9d3aad6e0b819" translate="yes" xml:space="preserve">
          <source>I have posted all of this code, using Spring Boot to launch, at &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;this GitHub project&lt;/a&gt;; you can look at a full running project for each approach to see everything you need to make it work. &lt;strong&gt;Tag with the &lt;code&gt;NullPointerException&lt;/code&gt;: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt;&lt;code&gt;nonworking&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">He publicado todo este c&amp;oacute;digo, usando Spring Boot para el lanzamiento, en &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;este proyecto de GitHub&lt;/a&gt; ; puede ver un proyecto en ejecuci&amp;oacute;n completo para cada enfoque para ver todo lo que necesita para que funcione. &lt;strong&gt;Etiqueta con la &lt;code&gt;NullPointerException&lt;/code&gt; : &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt; &lt;code&gt;nonworking&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a28c8ad27d6ac9d92801b7c7616da199741fee8" translate="yes" xml:space="preserve">
          <source>I make Spring inject &lt;code&gt;applicationContext&lt;/code&gt; in this bean:</source>
          <target state="translated">Hago Spring inject &lt;code&gt;applicationContext&lt;/code&gt; en este bean:</target>
        </trans-unit>
        <trans-unit id="9d7deec7709d1e237f060b3e6cae162dde1f065a" translate="yes" xml:space="preserve">
          <source>I noticed that the package.path does no longer exist, so I've just dropped the line for good.</source>
          <target state="translated">Me di cuenta de que el paquete.path ya no existe,así que he dejado la línea para siempre.</target>
        </trans-unit>
        <trans-unit id="acaef4085e64a02688aad3db5d1923dfe9e86ead" translate="yes" xml:space="preserve">
          <source>I once encountered the same issue when I was not quite used to &lt;code&gt;the life in the IoC world&lt;/code&gt;. The &lt;code&gt;@Autowired&lt;/code&gt; field of one of my beans is null at runtime.</source>
          <target state="translated">Una vez me encontr&amp;eacute; con el mismo problema cuando no estaba acostumbrado a &lt;code&gt;the life in the IoC world&lt;/code&gt; . El campo &lt;code&gt;@Autowired&lt;/code&gt; de uno de mis beans es nulo en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d4f5aca2a7ed0b7166b5ed31cd0d48496a56e4c5" translate="yes" xml:space="preserve">
          <source>I think you have missed to instruct spring to scan classes with annotation.</source>
          <target state="translated">Creo que has faltado a las clases de primavera de escaneo con anotación.</target>
        </trans-unit>
        <trans-unit id="e6f1ec927b26cd65fdaaa4ddf91e84e5652ed241" translate="yes" xml:space="preserve">
          <source>If this is happening in a test class, make sure you haven't forgotten to annotate the class.</source>
          <target state="translated">Si esto sucede en una clase de prueba,asegúrate de no haber olvidado anotar la clase.</target>
        </trans-unit>
        <trans-unit id="f517ef786825d3bc62a16f6307b66a8ef2849b27" translate="yes" xml:space="preserve">
          <source>If you are not coding a web application, make sure your class in which @Autowiring is done is a spring bean. Typically, spring container won't be aware of the class which we might think of as a spring bean. We have to tell the Spring container about our spring classes.</source>
          <target state="translated">Si no estás codificando una aplicación web,asegúrate de que tu clase en la que se hace el @Autocableado es un frijolito.Típicamente,el contenedor de resortes no será consciente de la clase que podríamos pensar como un frijol de primavera.Tenemos que decirle al contenedor de primavera sobre nuestras clases de primavera.</target>
        </trans-unit>
        <trans-unit id="4210a615a7a8e9cf17363c2ebfcc8af5476ec05a" translate="yes" xml:space="preserve">
          <source>If you are writing unit test make sure you are not creating object using &lt;code&gt;new object()&lt;/code&gt;. Use instead injectMock.</source>
          <target state="translated">Si est&amp;aacute; escribiendo una prueba unitaria, aseg&amp;uacute;rese de no crear un objeto con un &lt;code&gt;new object()&lt;/code&gt; . Utilice en su lugar injectMock.</target>
        </trans-unit>
        <trans-unit id="e1b2ce47c7a4f14dbdd6d84b8fe65d5309868f7e" translate="yes" xml:space="preserve">
          <source>If you get this configuration wrong your tests will compile, but &lt;code&gt;@Autowired&lt;/code&gt; and &lt;code&gt;@Value&lt;/code&gt; fields (for example) will be &lt;code&gt;null&lt;/code&gt;.  Since Spring Boot operates by magic, you may have few avenues for directly debugging this failure.</source>
          <target state="translated">Si obtiene esta configuraci&amp;oacute;n incorrecta, sus pruebas se compilar&amp;aacute;n, pero los campos &lt;code&gt;@Autowired&lt;/code&gt; y &lt;code&gt;@Value&lt;/code&gt; (por ejemplo) ser&amp;aacute;n &lt;code&gt;null&lt;/code&gt; . Dado que Spring Boot funciona por arte de magia, es posible que tenga pocas v&amp;iacute;as para depurar directamente este error.</target>
        </trans-unit>
        <trans-unit id="6c1b72872b08c510fda6dfeaed1dcb63e25fcc5d" translate="yes" xml:space="preserve">
          <source>If you need to create a new instance of your service object for different requests, you can still use injection by using &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;the Spring bean scopes&lt;/a&gt;.</source>
          <target state="translated">Si necesita crear una nueva instancia de su objeto de servicio para diferentes solicitudes, a&amp;uacute;n puede usar la inyecci&amp;oacute;n usando &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;los &amp;aacute;mbitos de Spring Bean&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f44484492dfecd22e18b5bd83804f19ec3019b8" translate="yes" xml:space="preserve">
          <source>If you really need objects created with &lt;code&gt;new&lt;/code&gt; to be autowired, you can &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;use the Spring &lt;code&gt;@Configurable&lt;/code&gt; annotation along with AspectJ compile-time weaving&lt;/a&gt; to inject your objects. This approach inserts code into your object's constructor that alerts Spring that it's being created so that Spring can configure the new instance. This requires a bit of configuration in your build (such as compiling with &lt;code&gt;ajc&lt;/code&gt;) and turning on Spring's runtime configuration handlers (&lt;code&gt;@EnableSpringConfigured&lt;/code&gt; with the JavaConfig syntax). This approach is used by the Roo Active Record system to allow &lt;code&gt;new&lt;/code&gt; instances of your entities to get the necessary persistence information injected.</source>
          <target state="translated">Si realmente necesita que los objetos creados con &lt;code&gt;new&lt;/code&gt; se conecten autom&amp;aacute;ticamente, puede &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;usar la anotaci&amp;oacute;n Spring &lt;code&gt;@Configurable&lt;/code&gt; junto con el tejido de tiempo de compilaci&amp;oacute;n AspectJ&lt;/a&gt; para inyectar sus objetos. Este enfoque inserta c&amp;oacute;digo en el constructor de su objeto que alerta a Spring de que est&amp;aacute; siendo creado para que Spring pueda configurar la nueva instancia. Esto requiere un poco de configuraci&amp;oacute;n en su compilaci&amp;oacute;n (como compilar con &lt;code&gt;ajc&lt;/code&gt; ) y activar los controladores de configuraci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n de Spring ( &lt;code&gt;@EnableSpringConfigured&lt;/code&gt; con la sintaxis JavaConfig). El sistema Roo Active Record utiliza este enfoque para permitir que &lt;code&gt;new&lt;/code&gt; instancias de sus entidades obtengan la informaci&amp;oacute;n de persistencia necesaria inyectada.</target>
        </trans-unit>
        <trans-unit id="8dc718c58fb367fa7f99b778de29f6511c238cfc" translate="yes" xml:space="preserve">
          <source>In simple words there are mainly two reasons for an &lt;code&gt;@Autowired&lt;/code&gt; field to be &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">En palabras simples, existen principalmente dos razones para que un campo &lt;code&gt;@Autowired&lt;/code&gt; sea &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1fa06015977d4bb62501850a732d535c515f902" translate="yes" xml:space="preserve">
          <source>In this way &lt;strong&gt;any bean can be obtained by any object in the application&lt;/strong&gt; (also intantiated with &lt;code&gt;new&lt;/code&gt;) and &lt;strong&gt;in a static way&lt;/strong&gt;.</source>
          <target state="translated">De esta forma, &lt;strong&gt;cualquier objeto de la aplicaci&amp;oacute;n puede obtener cualquier bean&lt;/strong&gt; (tambi&amp;eacute;n se puede ver como &lt;code&gt;new&lt;/code&gt; ) y &lt;strong&gt;de forma est&amp;aacute;tica&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fee4af12fa524c1a7940448312eebdd0a757e15d" translate="yes" xml:space="preserve">
          <source>Inject your beans</source>
          <target state="translated">Inyecta tus frijoles</target>
        </trans-unit>
        <trans-unit id="c56453903ed805219ab7d905bfb3d9194b146484" translate="yes" xml:space="preserve">
          <source>It seems to be rare case but here is what happened to me:</source>
          <target state="translated">Parece ser un caso raro,pero esto es lo que me pasó:</target>
        </trans-unit>
        <trans-unit id="81362fff4d639337528a9b83ac93d07b4c8831f8" translate="yes" xml:space="preserve">
          <source>Manual bean lookup: not recommended</source>
          <target state="translated">Búsqueda manual de frijoles:no se recomienda</target>
        </trans-unit>
        <trans-unit id="15d38dff68d219829bee6302f049d493d93ad283" translate="yes" xml:space="preserve">
          <source>My Service class had an annotation of service and it was &lt;code&gt;@autowired&lt;/code&gt; another component class. When I tested the component class was coming null. Because for service class I was creating the object using &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">Mi clase de servicio ten&amp;iacute;a una anotaci&amp;oacute;n de servicio y era &lt;code&gt;@autowired&lt;/code&gt; otra clase de componente. Cuando prob&amp;eacute;, la clase de componente se estaba volviendo nula. Porque para la clase de servicio estaba creando el objeto usando &lt;code&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4163f897a2b6918d5bcba8024e27a75a21262caa" translate="yes" xml:space="preserve">
          <source>Other classes can use it like this:</source>
          <target state="translated">Otras clases pueden usarlo así:</target>
        </trans-unit>
        <trans-unit id="d7a7cfd642fc22c1d2461573908ac9a588902de4" translate="yes" xml:space="preserve">
          <source>Service bean that should be autowired in &lt;code&gt;MileageFeeCalculator&lt;/code&gt; but it isn't:</source>
          <target state="translated">Service bean que debe conectarse autom&amp;aacute;ticamente en &lt;code&gt;MileageFeeCalculator&lt;/code&gt; pero no lo es:</target>
        </trans-unit>
        <trans-unit id="8a5f1e0fe0b1effd67db55ae23df2f6cc081647a" translate="yes" xml:space="preserve">
          <source>Service class:</source>
          <target state="translated">Clase de servicio:</target>
        </trans-unit>
        <trans-unit id="b45858b98095f901fc99c8338155a5faac0efb3c" translate="yes" xml:space="preserve">
          <source>So to summarize, make sure that your annotations (&lt;code&gt;@Autowired&lt;/code&gt;, &lt;code&gt;@Inject&lt;/code&gt;, &lt;code&gt;@Service&lt;/code&gt; ,... ) have correct packages!</source>
          <target state="translated">Para resumir, aseg&amp;uacute;rese de que sus anotaciones ( &lt;code&gt;@Autowired&lt;/code&gt; , &lt;code&gt;@Inject&lt;/code&gt; , &lt;code&gt;@Service&lt;/code&gt; , ...) tengan los paquetes correctos.</target>
        </trans-unit>
        <trans-unit id="3239365d583a95875a43f9f065681b250601c3cc" translate="yes" xml:space="preserve">
          <source>Some time elapses...</source>
          <target state="translated">Pasa un tiempo...</target>
        </trans-unit>
        <trans-unit id="185f0371245faa8bbe1b174c71c3c16fe0b0cf16" translate="yes" xml:space="preserve">
          <source>Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;continues to evolve&lt;/a&gt;.  It is no longer required to use &lt;code&gt;@RunWith&lt;/code&gt;&lt;em&gt;if you use the correct version of JUnit&lt;/em&gt;.</source>
          <target state="translated">Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;contin&amp;uacute;a evolucionando&lt;/a&gt; . Ya no es necesario usar &lt;code&gt;@RunWith&lt;/code&gt; &lt;em&gt;si usa la versi&amp;oacute;n correcta de JUnit&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="859e7a96ec1ad84e49569265bcd589ac37498e71" translate="yes" xml:space="preserve">
          <source>Spring only injects instances of those classes which are either created as bean or marked with annotation.</source>
          <target state="translated">La primavera sólo inyecta instancias de esas clases que son creadas como frijoles o marcadas con anotaciones.</target>
        </trans-unit>
        <trans-unit id="b198e9188ffed25cac4c321fdc9e545886b5c39f" translate="yes" xml:space="preserve">
          <source>The IoC container isn't magic, and it has no way of knowing about Java objects unless you somehow inform it of them. When you call &lt;code&gt;new&lt;/code&gt;, the JVM instantiates a copy of the new object and hands it straight to you--it never goes through the configuration process. There are three ways that you can get your beans configured.</source>
          <target state="translated">El contenedor de IoC no es m&amp;aacute;gico, y no tiene forma de conocer los objetos de Java a menos que de alguna manera le informe de ellos. Cuando llama a &lt;code&gt;new&lt;/code&gt; , la JVM crea una copia del nuevo objeto y se lo entrega directamente; nunca pasa por el proceso de configuraci&amp;oacute;n. Hay tres formas de configurar los beans.</target>
        </trans-unit>
        <trans-unit id="289f38a4a85aa5b9a3c5b59180313674628783cd" translate="yes" xml:space="preserve">
          <source>The field annotated &lt;code&gt;@Autowired&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; because Spring doesn't know about the copy of &lt;code&gt;MileageFeeCalculator&lt;/code&gt; that you created with &lt;code&gt;new&lt;/code&gt; and didn't know to autowire it.</source>
          <target state="translated">El campo anotado &lt;code&gt;@Autowired&lt;/code&gt; es &lt;code&gt;null&lt;/code&gt; porque Spring no sabe acerca de la copia de &lt;code&gt;MileageFeeCalculator&lt;/code&gt; que cre&amp;oacute; con &lt;code&gt;new&lt;/code&gt; y no sab&amp;iacute;a c&amp;oacute;mo conectarlo autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="17cafeacf0e3808d318c6c7dab584d668bff3de5" translate="yes" xml:space="preserve">
          <source>The most preferable option is to let Spring autowire all of your beans; this requires the least amount of code and is the most maintainable. To make the autowiring work like you wanted, also autowire the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; like this:</source>
          <target state="translated">La opci&amp;oacute;n m&amp;aacute;s preferible es dejar que Spring conecte autom&amp;aacute;ticamente todos sus frijoles; Esto requiere la menor cantidad de c&amp;oacute;digo y es el m&amp;aacute;s f&amp;aacute;cil de mantener. Para que el cableado autom&amp;aacute;tico funcione como usted desea, tambi&amp;eacute;n conecte autom&amp;aacute;ticamente el &lt;code&gt;MileageFeeCalculator&lt;/code&gt; de esta manera:</target>
        </trans-unit>
        <trans-unit id="7525865b1f3cf4afe5b64057e41c714903c82bb4" translate="yes" xml:space="preserve">
          <source>The root cause is, instead of using the auto-created bean maintained by the Spring IoC container (whose &lt;code&gt;@Autowired&lt;/code&gt; field is &lt;code&gt;indeed&lt;/code&gt; properly injected), I am &lt;code&gt;newing&lt;/code&gt; my own instance of that bean type and using it. Of course this one's &lt;code&gt;@Autowired&lt;/code&gt; field is null because Spring has no chance to inject it.</source>
          <target state="translated">La causa ra&amp;iacute;z es que, en lugar de usar el bean creado autom&amp;aacute;ticamente mantenido por el contenedor Spring IoC (cuyo campo &lt;code&gt;@Autowired&lt;/code&gt; se inyecta correctamente), estoy &lt;code&gt;newing&lt;/code&gt; mi propia instancia de ese tipo de bean y us&amp;aacute;ndolo. Por supuesto, este campo &lt;code&gt;@Autowired&lt;/code&gt; es nulo porque Spring no tiene oportunidad de inyectarlo.</target>
        </trans-unit>
        <trans-unit id="5ab338c160a06915539afb8ea6a40782d023e2a0" translate="yes" xml:space="preserve">
          <source>The solution makes this MileageFeeCalculator as an auto-wired object in the Controller itself.</source>
          <target state="translated">La solución hace que esta MileageFeeCalculator como un objeto auto-cableado en el propio Controlador.</target>
        </trans-unit>
        <trans-unit id="a918b75229c39b7362467ef9574f8a999ad37470" translate="yes" xml:space="preserve">
          <source>Then your legacy code can call &lt;code&gt;getContext()&lt;/code&gt; and retrieve the beans it needs:</source>
          <target state="translated">Luego, su c&amp;oacute;digo heredado puede llamar a &lt;code&gt;getContext()&lt;/code&gt; y recuperar los beans que necesita:</target>
        </trans-unit>
        <trans-unit id="ed5445ba25a7eb16ffe83bc73d081a07998d9071" translate="yes" xml:space="preserve">
          <source>This approach is suitable only for interfacing with legacy code in special situations. It is nearly always preferable to create a singleton adapter class that Spring can autowire and the legacy code can call, but it is possible to directly ask the Spring application context for a bean.</source>
          <target state="translated">Este enfoque sólo es adecuado para la interfaz con el código heredado en situaciones especiales.Casi siempre es preferible crear una clase de adaptador simple que Spring pueda autocablear y que el código heredado pueda llamar,pero es posible pedir directamente al contexto de la aplicación de Spring un frijol.</target>
        </trans-unit>
        <trans-unit id="a2564b58e68e65ff5e059a30fb59c75588cf998f" translate="yes" xml:space="preserve">
          <source>This can be achieved by configuring in appln-contxt or &lt;strong&gt;the better way&lt;/strong&gt; is to annotate class as &lt;strong&gt;@Component&lt;/strong&gt; and please do not create the annotated class using new operator.
Make sure you get it from Appln-context as below.</source>
          <target state="translated">Esto se puede lograr configurando en appln-contxt o &lt;strong&gt;la mejor manera&lt;/strong&gt; es anotar la clase como &lt;strong&gt;@Component&lt;/strong&gt; y no crear la clase anotada con un nuevo operador. Aseg&amp;uacute;rese de obtenerlo de Appln-context como se muestra a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cba84fb3a576f1982a7a4e89a35adfcdcd86b573" translate="yes" xml:space="preserve">
          <source>This fixed my issue. Here is a useful &lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;link&lt;/a&gt;</source>
          <target state="translated">Esto solucion&amp;oacute; mi problema. Aqu&amp;iacute; hay un &lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;enlace&lt;/a&gt; &amp;uacute;til</target>
        </trans-unit>
        <trans-unit id="fd42e9c07834066aba16496cc46ca18618d98be0" translate="yes" xml:space="preserve">
          <source>This is only valid in case of Unit test.</source>
          <target state="translated">Esto sólo es válido en el caso de la prueba de la Unidad.</target>
        </trans-unit>
        <trans-unit id="c3bf31c57b1da3cd7be0fd57b9c4bbbf09272a68" translate="yes" xml:space="preserve">
          <source>This is the culprit of giving NullPointerException &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; We are using Spring - don't need to create object manually. Object creation will be taken care of by IoC container.</source>
          <target state="translated">Este es el culpable de dar NullPointerException &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; Estamos utilizando Spring, no es necesario crear objetos manualmente. La creaci&amp;oacute;n de objetos ser&amp;aacute; atendida por el contenedor IoC.</target>
        </trans-unit>
        <trans-unit id="f056c0834db33a952b9af4a4a12e11c7ce780a22" translate="yes" xml:space="preserve">
          <source>To MileageFeeCalculator constructor like this:</source>
          <target state="translated">Para el constructor de MileageFeeCalculator así:</target>
        </trans-unit>
        <trans-unit id="a415fb8c7eebe85e5542348eaa6368fe99ef4ebd" translate="yes" xml:space="preserve">
          <source>To do this, you need a class to which Spring can give a reference to the &lt;code&gt;ApplicationContext&lt;/code&gt; object:</source>
          <target state="translated">Para hacer esto, necesita una clase a la que Spring pueda dar una referencia al objeto &lt;code&gt;ApplicationContext&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="712bd4ea7182b2392287b9cba31f1c58a4f995c7" translate="yes" xml:space="preserve">
          <source>Use @Configurable</source>
          <target state="translated">Usar @Configurable</target>
        </trans-unit>
        <trans-unit id="b4de62676a8e2ba66f6e67603bb1ab327f963c2d" translate="yes" xml:space="preserve">
          <source>Using @PostConstruct solves that:</source>
          <target state="translated">El uso de @PostConstruct resuelve eso:</target>
        </trans-unit>
        <trans-unit id="814e53b54fffcd1ab97e69af5ec501e8ca6cd377" translate="yes" xml:space="preserve">
          <source>We used &lt;code&gt;@Inject&lt;/code&gt; instead of &lt;code&gt;@Autowired&lt;/code&gt; which is javaee standard supported by Spring. Every places it worked fine and the beans injected correctly, instead of one place. The bean injection seems the same</source>
          <target state="translated">Usamos &lt;code&gt;@Inject&lt;/code&gt; en lugar de &lt;code&gt;@Autowired&lt;/code&gt; , que es el est&amp;aacute;ndar Java compatible con Spring. Todos los lugares funcionaron bien y los frijoles se inyectaron correctamente, en lugar de un solo lugar. La inyecci&amp;oacute;n de frijol parece igual</target>
        </trans-unit>
        <trans-unit id="a22a650a6695b1cb52df04c214890311d5d9f32b" translate="yes" xml:space="preserve">
          <source>What hasn't been mentioned here is described in &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot;&gt;this&lt;/a&gt; article in the paragraph &quot;Order of execution&quot;.</source>
          <target state="translated">Lo que no se ha mencionado aqu&amp;iacute; se describe en &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot;&gt;este&lt;/a&gt; art&amp;iacute;culo en el p&amp;aacute;rrafo &quot;Orden de ejecuci&amp;oacute;n&quot;.</target>
        </trans-unit>
        <trans-unit id="c9351769f2d3fc8aed37c27cfba4d601a5fd919c" translate="yes" xml:space="preserve">
          <source>When I try to &lt;code&gt;GET /mileage/3&lt;/code&gt;, I get this exception:</source>
          <target state="translated">Cuando intento &lt;code&gt;GET /mileage/3&lt;/code&gt; , obtengo esta excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="4a94711b9930ced50218f0105a49745e4e697dd7" translate="yes" xml:space="preserve">
          <source>Why is my Spring @Autowired field null</source>
          <target state="translated">¿Por qué es mi campo de primavera con cableado automático nulo</target>
        </trans-unit>
        <trans-unit id="0355cb07b2fa9677429e730cb275eac228744309" translate="yes" xml:space="preserve">
          <source>With annotation &lt;code&gt;@Service&lt;/code&gt;, &lt;code&gt;@Component&lt;/code&gt;, &lt;code&gt;@Configuration&lt;/code&gt; beans are created in the</source>
          <target state="translated">Con la anotaci&amp;oacute;n &lt;code&gt;@Service&lt;/code&gt; , &lt;code&gt;@Component&lt;/code&gt; , los beans de &lt;code&gt;@Configuration&lt;/code&gt; se crean en el</target>
        </trans-unit>
        <trans-unit id="e646deb97792a6ade92069b79676e29df55b56d7" translate="yes" xml:space="preserve">
          <source>You can also fix this issue using @Service annotation on service class and passing the required bean classA as a parameter to the other beans classB constructor and annotate the constructor of classB with @Autowired. Sample snippet here :</source>
          <target state="translated">También puedes arreglar este problema usando la anotación @Servicio en la clase de servicio y pasando el frijol requerido claseA como parámetro al otro constructor de frijoles claseB y anotar el constructor de claseB con @Autocableado.Un fragmento de muestra aquí :</target>
        </trans-unit>
        <trans-unit id="9d2bd3f9fbf79e8c120c81a56d52d033b5a518c7" translate="yes" xml:space="preserve">
          <source>You can put this code also in the main application class if you want.</source>
          <target state="translated">Puedes poner este código también en la clase de aplicación principal si quieres.</target>
        </trans-unit>
        <trans-unit id="ca489fbd0a1b9070d098e10dcb1d2193bc0465c8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; on the configuration class of your spring application to instruct spring to scan.</source>
          <target state="translated">Puede usar &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; en la clase de configuraci&amp;oacute;n de su aplicaci&amp;oacute;n Spring para indicarle a Spring que escanee.</target>
        </trans-unit>
        <trans-unit id="748d434e98b06abd0eecc728bee5795a1ecdb8c5" translate="yes" xml:space="preserve">
          <source>Your problem is new (object creation in java style)</source>
          <target state="translated">Su problema es nuevo (creación de objetos en estilo java)</target>
        </trans-unit>
        <trans-unit id="6097ca49faf78ea33ebe49e2de5a90e831a070dc" translate="yes" xml:space="preserve">
          <source>and SomeAbac class has a property declared as</source>
          <target state="translated">y la clase SomeAbac tiene una propiedad declarada como</target>
        </trans-unit>
        <trans-unit id="fe045fcc475b2ed5785570e3bf62d2af03225740" translate="yes" xml:space="preserve">
          <source>and in a &lt;code&gt;token.xml&lt;/code&gt; file I've had a line</source>
          <target state="translated">y en un archivo &lt;code&gt;token.xml&lt;/code&gt; he tenido una l&amp;iacute;nea</target>
        </trans-unit>
        <trans-unit id="8f184f10becfd5255e7dd174b71f596e5ed826d2" translate="yes" xml:space="preserve">
          <source>and it works. May be someone can provide an explanation, but for me it's enough right now )</source>
          <target state="translated">y funciona.Puede ser que alguien pueda dar una explicación,pero para mí es suficiente por ahora.)</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="83e983915573bdd6a6a5428e20d4237c9b28e9f9" translate="yes" xml:space="preserve">
          <source>application context of Spring when server is started. But when we create objects 
    using new operator the object is not registered in  application context which  is already created. For Example Employee.java class i have used.</source>
          <target state="translated">contexto de la aplicación de Spring cuando se inicia el servidor.Pero cuando creamos objetos usando un nuevo operador,el objeto no se registra en el contexto de la aplicación que ya está creado.Por ejemplo Employee.java clase que he utilizado.</target>
        </trans-unit>
        <trans-unit id="8f777ca7518e37a243e3d63d7566fe9cd2f615f1" translate="yes" xml:space="preserve">
          <source>for some unknown reason, settings is &lt;em&gt;null&lt;/em&gt; in init(), when &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; element is not present at all, but when it's present and has some bs as a basePackage, everything works well. This line now looks like this:</source>
          <target state="translated">por alguna raz&amp;oacute;n desconocida, la configuraci&amp;oacute;n es &lt;em&gt;nula&lt;/em&gt; en init (), cuando el elemento &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; no est&amp;aacute; presente en absoluto, pero cuando est&amp;aacute; presente y tiene algunos bs como basePackage, todo funciona bien. Esta l&amp;iacute;nea ahora se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="d5db4151b6088246e47fd7448b54cae44fc44c85" translate="yes" xml:space="preserve">
          <source>so it won't work that way.</source>
          <target state="translated">así que no funcionará de esa manera.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
