<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/19896870">
    <body>
      <group id="19896870">
        <trans-unit id="394b57ab44493bad9e13375faca2da97306afe8c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;The Spring Inversion of Control (IoC) container&lt;/a&gt; has three main logical components: a registry (called the &lt;code&gt;ApplicationContext&lt;/code&gt;) of components (beans) that are available to be used by the application, a configurer system that injects objects' dependencies into them by matching up the dependencies with beans in the context, and a dependency solver that can look at a configuration of many different beans and determine how to instantiate and configure them in the necessary order.</source>
          <target state="translated">&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;Контейнер Spring Inversion of Control (IoC)&lt;/a&gt; имеет три основных логических компонента: реестр (называемый &lt;code&gt;ApplicationContext&lt;/code&gt; ) компонентов (компонентов), доступных для использования приложением, система конфигуратора, которая внедряет в них зависимости объектов путем сопоставления зависимости с bean-компонентами в контексте и средство решения зависимостей, которое может просматривать конфигурацию множества различных bean-компонентов и определять, как создавать экземпляры и настраивать их в необходимом порядке.</target>
        </trans-unit>
        <trans-unit id="1ae06b30b6d1c782656a2208ccb72d7333701bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@Service, @Component&lt;/code&gt; etc annotations add meta description.</source>
          <target state="translated">&lt;code&gt;@Service, @Component&lt;/code&gt; т. Д. Добавляют мета-описание.</target>
        </trans-unit>
        <trans-unit id="a70bff0ba394cef82c27ca682d50f21c90605937" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I'm new to Spring, but I discovered this working solution. Please tell me if it's a deprecable way.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Я новичок в Spring, но я обнаружил это рабочее решение.&lt;/em&gt; &lt;em&gt;Пожалуйста, скажите мне, если это осуждаемый способ.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac07e8cc2813a62fa38fad476b41fdaaca46ef7a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is intended to be a canonical answer for a common problem.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Примечание: это должно быть каноническим ответом на общую проблему.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b7fb549b54ec58659fd74cbdd78e77c0e0493806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ORIGINAL ANSWER:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ОРИГИНАЛЬНЫЙ ОТВЕТ:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f981fb4e08e95e60895db03be2fe27045a89932" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE FIELD IS NOT A BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ПОЛЕ НЕ БИН.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c63b5f6bebe122bb768741b030b15d8683140f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by injecting the &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt;&lt;code&gt;working-inject-bean&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Тег, который работает путем внедрения служебного объекта &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; : &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt; &lt;code&gt;working-inject-bean&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ece2ffe683fc87cb97657a6c77b083b990d1adf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by manually looking up the service object in the Spring context: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt;&lt;code&gt;working-manual-lookup&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Тег, который работает путем ручного поиска объекта службы в контексте Spring: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt; &lt;code&gt;working-manual-lookup&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ee91e9a00165f2f5a170963a6a33b134695cf84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by using &lt;code&gt;@Configurable&lt;/code&gt; on the service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt;&lt;code&gt;working-configurable&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Тег, который работает с помощью &lt;code&gt;@Configurable&lt;/code&gt; на объекте службы: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt; &lt;code&gt;working-configurable&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="774dd712670d211631d8f90f0cee69e58e4015a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; Really smart people were quick to point on &lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;this&lt;/a&gt; answer, which explains the weirdness, described below</source>
          <target state="translated">&lt;strong&gt;ОБНОВЛЕНИЕ:&lt;/strong&gt; действительно умные люди быстро указали на &lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;этот&lt;/a&gt; ответ, который объясняет странность, описанную ниже</target>
        </trans-unit>
        <trans-unit id="343f2555b3fe8817306d09a16f4d9c002d898197" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YOUR CLASS IS NOT A  SPRING BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ВАШ КЛАСС НЕ ВЕСНА.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="013573a8c9d74642d1e8e6d7631446a204fef372" translate="yes" xml:space="preserve">
          <source>Actually, you should use either JVM managed Objects or Spring-managed Object to invoke methods.
from your above code in your controller class, you are creating a new object to call your service class which has an auto-wired object.</source>
          <target state="translated">На самом деле,вы должны использовать либо JVM управляемые объекты или Spring управляемые объекты для вызова методов.из вашего вышеуказанного кода в вашем классе контроллера,вы создаете новый объект для вызова вашего класса обслуживания,который имеет объект с автоматической проводкой.</target>
        </trans-unit>
        <trans-unit id="17e5fa0456b0b310229eb43f4b0714169ea19cff" translate="yes" xml:space="preserve">
          <source>Adding annotation only, does not fix or facilitate the dependency injection, Spring needs to know where to look for.</source>
          <target state="translated">Добавление только аннотации,не исправляет и не облегчает впрыск зависимости,Пружина должна знать,где искать.</target>
        </trans-unit>
        <trans-unit id="57be7d302f1b2ff8eef279015d9880539858b846" translate="yes" xml:space="preserve">
          <source>After &quot;learning&quot; that I had to annotate a class with @Component or the derivatives @Service or @Repository (I guess there are more), to autowire other components inside them, it struck me that these other components still were null inside the constructor of the parent component.</source>
          <target state="translated">После &quot;изучения&quot; того,что мне пришлось аннотировать класс @Component или производные @Service или @Repository (думаю,их больше),для автозапуска других компонентов внутри них,меня поразило,что эти компоненты все равно были нулевыми внутри конструктора родительского компонента.</target>
        </trans-unit>
        <trans-unit id="41fc58409cda1816c0d86da0328ade7c51269de3" translate="yes" xml:space="preserve">
          <source>Also note that if, for whatever reason, you make a method in a &lt;code&gt;@Service&lt;/code&gt; as &lt;code&gt;final&lt;/code&gt;, the autowired beans you will access from it will always be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание, что если по какой-либо причине вы сделаете метод в &lt;code&gt;@Service&lt;/code&gt; в качестве &lt;code&gt;final&lt;/code&gt; , то автоматически настроенные bean-компоненты будут иметь значение &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e62f46e6b944ff55852b8bd59d0add7902a8d67" translate="yes" xml:space="preserve">
          <source>And after that, NPE started coming in. In a &lt;code&gt;pep-config.xml&lt;/code&gt; I had just 2 beans:</source>
          <target state="translated">И после этого начал входить NPE. В &lt;code&gt;pep-config.xml&lt;/code&gt; у меня было только 2 компонента:</target>
        </trans-unit>
        <trans-unit id="ec68cc24f685999a1deb5d39824c5936e0df4e7d" translate="yes" xml:space="preserve">
          <source>Another solution would be putting call:
&lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;</source>
          <target state="translated">Другое решение было бы поместить вызов: &lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f41f414dfb43d22eb44abecd6879c5950ea1c" translate="yes" xml:space="preserve">
          <source>At last we found that the error was that we (actually, the Eclipse auto complete feature) imported &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; instead of &lt;code&gt;javax.inject.Inject&lt;/code&gt; !</source>
          <target state="translated">Наконец, мы обнаружили, что ошибка заключалась в том, что мы (на самом деле, функция автоматического завершения Eclipse) импортировали &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; вместо &lt;code&gt;javax.inject.Inject&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="d94d761d0a782bc648563729db0ab5861e158fd2" translate="yes" xml:space="preserve">
          <source>Change your Controller class like below.</source>
          <target state="translated">Смените класс контроллера,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="7ba406818c8f1055e3ce7bbdb75cfb6882131af8" translate="yes" xml:space="preserve">
          <source>Check this out:</source>
          <target state="translated">Зацени:</target>
        </trans-unit>
        <trans-unit id="d230873b60b53c384e2144ccb234383174838a29" translate="yes" xml:space="preserve">
          <source>Classes marked with annotation need to be identified by spring before injecting, &lt;code&gt;@ComponentScan&lt;/code&gt; instruct spring look for the classes marked with annotation. When Spring finds &lt;code&gt;@Autowired&lt;/code&gt; it searches for the related bean, and injects the required instance.</source>
          <target state="translated">Классы, помеченные аннотацией, должны быть идентифицированы весной перед введением, &lt;code&gt;@ComponentScan&lt;/code&gt; дает указание пружине искать классы, помеченные аннотацией. Когда Spring находит &lt;code&gt;@Autowired&lt;/code&gt; , он ищет связанный компонент и внедряет требуемый экземпляр.</target>
        </trans-unit>
        <trans-unit id="b83c98c8abe52ca04318bc946ddb1f41bf28da5e" translate="yes" xml:space="preserve">
          <source>Controller class:</source>
          <target state="translated">Класс контроллера:</target>
        </trans-unit>
        <trans-unit id="72e876a8da98d0fdec73e4e6b97838b88035189f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;@SpringBootTest&lt;/code&gt; to work stand alone, you need to use &lt;code&gt;@Test&lt;/code&gt; from &lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit5 instead of JUnit4&lt;/a&gt;.</source>
          <target state="translated">Чтобы &lt;code&gt;@SpringBootTest&lt;/code&gt; работал автономно, вам нужно использовать &lt;code&gt;@Test&lt;/code&gt; из &lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit5 вместо JUnit4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac65d99b8c551d6eafac33e561e4dde92e51d8d7" translate="yes" xml:space="preserve">
          <source>For example, in &lt;strong&gt;Spring Boot&lt;/strong&gt;:</source>
          <target state="translated">Например, в &lt;strong&gt;Spring Boot&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f6ca09ba5cd1826f082b5fb7aab89b84c2c8faa7" translate="yes" xml:space="preserve">
          <source>I don't know if it helps anyone, but I was stuck with the same problem even while doing things seemingly right. In my Main method, I have a code like this:</source>
          <target state="translated">Не знаю,помогает ли это кому-нибудь,но я застрял с той же проблемой,даже когда делал все,казалось бы,правильно.В моем основном методе,у меня есть такой код:</target>
        </trans-unit>
        <trans-unit id="290aab609060c87e3330711b7a475560a5a08290" translate="yes" xml:space="preserve">
          <source>I have a Spring &lt;code&gt;@Service&lt;/code&gt; class (&lt;code&gt;MileageFeeCalculator&lt;/code&gt;) that has an &lt;code&gt;@Autowired&lt;/code&gt; field (&lt;code&gt;rateService&lt;/code&gt;), but the field is &lt;code&gt;null&lt;/code&gt; when I try to use it. The logs show that both the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; bean and the &lt;code&gt;MileageRateService&lt;/code&gt; bean are being created, but I get a &lt;code&gt;NullPointerException&lt;/code&gt; whenever I try to call the &lt;code&gt;mileageCharge&lt;/code&gt; method on my service bean. Why isn't Spring autowiring the field?</source>
          <target state="translated">У меня есть класс Spring &lt;code&gt;@Service&lt;/code&gt; ( &lt;code&gt;MileageFeeCalculator&lt;/code&gt; ), который имеет поле &lt;code&gt;@Autowired&lt;/code&gt; ( &lt;code&gt;rateService&lt;/code&gt; ), но при попытке его использования поле становится &lt;code&gt;null&lt;/code&gt; . Журналы показывают, что &lt;code&gt;MileageFeeCalculator&lt;/code&gt; компонент BeanfileCalculator, и компонент &lt;code&gt;MileageRateService&lt;/code&gt; , но я получаю &lt;code&gt;mileageCharge&lt;/code&gt; &lt;code&gt;NullPointerException&lt;/code&gt; всякий раз, когда пытаюсь вызвать метод m&amp;lsaquo;Charge для моего служебного компонента. Почему Spring не подключается автоматически?</target>
        </trans-unit>
        <trans-unit id="4d81e527154a800d280587cbded9d3aad6e0b819" translate="yes" xml:space="preserve">
          <source>I have posted all of this code, using Spring Boot to launch, at &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;this GitHub project&lt;/a&gt;; you can look at a full running project for each approach to see everything you need to make it work. &lt;strong&gt;Tag with the &lt;code&gt;NullPointerException&lt;/code&gt;: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt;&lt;code&gt;nonworking&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">Я разместил весь этот код, используя Spring Boot для запуска, в &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;этом проекте GitHub&lt;/a&gt; ; вы можете посмотреть на полностью работающий проект для каждого подхода, чтобы увидеть все, что вам нужно для его работы. &lt;strong&gt;Тег с &lt;code&gt;NullPointerException&lt;/code&gt; : &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt; &lt;code&gt;nonworking&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a28c8ad27d6ac9d92801b7c7616da199741fee8" translate="yes" xml:space="preserve">
          <source>I make Spring inject &lt;code&gt;applicationContext&lt;/code&gt; in this bean:</source>
          <target state="translated">Я делаю Spring для вставки &lt;code&gt;applicationContext&lt;/code&gt; в этот компонент:</target>
        </trans-unit>
        <trans-unit id="9d7deec7709d1e237f060b3e6cae162dde1f065a" translate="yes" xml:space="preserve">
          <source>I noticed that the package.path does no longer exist, so I've just dropped the line for good.</source>
          <target state="translated">Я заметил,что package.path больше не существует,так что я просто навсегда бросил строку.</target>
        </trans-unit>
        <trans-unit id="acaef4085e64a02688aad3db5d1923dfe9e86ead" translate="yes" xml:space="preserve">
          <source>I once encountered the same issue when I was not quite used to &lt;code&gt;the life in the IoC world&lt;/code&gt;. The &lt;code&gt;@Autowired&lt;/code&gt; field of one of my beans is null at runtime.</source>
          <target state="translated">Однажды я столкнулся с той же проблемой, когда не совсем привык к &lt;code&gt;the life in the IoC world&lt;/code&gt; . Поле &lt;code&gt;@Autowired&lt;/code&gt; одного из моих компонентов имеет значение null во время выполнения.</target>
        </trans-unit>
        <trans-unit id="d4f5aca2a7ed0b7166b5ed31cd0d48496a56e4c5" translate="yes" xml:space="preserve">
          <source>I think you have missed to instruct spring to scan classes with annotation.</source>
          <target state="translated">Я думаю,вы пропустили инструктаж весны,чтобы просканировать классы с аннотацией.</target>
        </trans-unit>
        <trans-unit id="e6f1ec927b26cd65fdaaa4ddf91e84e5652ed241" translate="yes" xml:space="preserve">
          <source>If this is happening in a test class, make sure you haven't forgotten to annotate the class.</source>
          <target state="translated">Если это происходит в тестовом классе,убедитесь,что вы не забыли аннотировать класс.</target>
        </trans-unit>
        <trans-unit id="f517ef786825d3bc62a16f6307b66a8ef2849b27" translate="yes" xml:space="preserve">
          <source>If you are not coding a web application, make sure your class in which @Autowiring is done is a spring bean. Typically, spring container won't be aware of the class which we might think of as a spring bean. We have to tell the Spring container about our spring classes.</source>
          <target state="translated">Если вы не кодируете веб-приложение,убедитесь,что ваш класс,в котором @Autowiring делается,является пружинной фасолью.Обычно,весенний контейнер не будет знать о классе,который мы можем считать весенней фасолью.Мы должны рассказать весеннему контейнеру о наших весенних классах.</target>
        </trans-unit>
        <trans-unit id="4210a615a7a8e9cf17363c2ebfcc8af5476ec05a" translate="yes" xml:space="preserve">
          <source>If you are writing unit test make sure you are not creating object using &lt;code&gt;new object()&lt;/code&gt;. Use instead injectMock.</source>
          <target state="translated">Если вы пишете модульный тест, убедитесь, что вы не создаете объект с помощью &lt;code&gt;new object()&lt;/code&gt; . Используйте вместо этого injectMock.</target>
        </trans-unit>
        <trans-unit id="e1b2ce47c7a4f14dbdd6d84b8fe65d5309868f7e" translate="yes" xml:space="preserve">
          <source>If you get this configuration wrong your tests will compile, but &lt;code&gt;@Autowired&lt;/code&gt; and &lt;code&gt;@Value&lt;/code&gt; fields (for example) will be &lt;code&gt;null&lt;/code&gt;.  Since Spring Boot operates by magic, you may have few avenues for directly debugging this failure.</source>
          <target state="translated">Если вы ошиблись в этой конфигурации, ваши тесты будут скомпилированы, но &lt;code&gt;@Autowired&lt;/code&gt; и &lt;code&gt;@Value&lt;/code&gt; (например) будут &lt;code&gt;null&lt;/code&gt; . Поскольку Spring Boot работает по волшебству, у вас может быть немного возможностей для прямой отладки этого сбоя.</target>
        </trans-unit>
        <trans-unit id="6c1b72872b08c510fda6dfeaed1dcb63e25fcc5d" translate="yes" xml:space="preserve">
          <source>If you need to create a new instance of your service object for different requests, you can still use injection by using &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;the Spring bean scopes&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно создать новый экземпляр объекта службы для разных запросов, вы все равно можете использовать инъекцию с помощью &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;областей действия Spring&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f44484492dfecd22e18b5bd83804f19ec3019b8" translate="yes" xml:space="preserve">
          <source>If you really need objects created with &lt;code&gt;new&lt;/code&gt; to be autowired, you can &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;use the Spring &lt;code&gt;@Configurable&lt;/code&gt; annotation along with AspectJ compile-time weaving&lt;/a&gt; to inject your objects. This approach inserts code into your object's constructor that alerts Spring that it's being created so that Spring can configure the new instance. This requires a bit of configuration in your build (such as compiling with &lt;code&gt;ajc&lt;/code&gt;) and turning on Spring's runtime configuration handlers (&lt;code&gt;@EnableSpringConfigured&lt;/code&gt; with the JavaConfig syntax). This approach is used by the Roo Active Record system to allow &lt;code&gt;new&lt;/code&gt; instances of your entities to get the necessary persistence information injected.</source>
          <target state="translated">Если вам действительно нужны объекты, созданные с помощью &lt;code&gt;new&lt;/code&gt; , для автоматического подключения, вы можете &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;использовать аннотацию Spring &lt;code&gt;@Configurable&lt;/code&gt; вместе с переплетением&lt;/a&gt; во время компиляции AspectJ, чтобы внедрить ваши объекты. Этот подход вставляет код в конструктор вашего объекта, который сообщает Spring, что он создается, чтобы Spring мог сконфигурировать новый экземпляр. Это требует небольшой настройки в вашей сборке (такой как компиляция с помощью &lt;code&gt;ajc&lt;/code&gt; ) и включение обработчиков конфигурации среды выполнения Spring ( &lt;code&gt;@EnableSpringConfigured&lt;/code&gt; с синтаксисом JavaConfig). Этот подход используется системой Roo Active Record, чтобы позволить &lt;code&gt;new&lt;/code&gt; экземплярам ваших сущностей получать необходимую информацию о постоянстве.</target>
        </trans-unit>
        <trans-unit id="8dc718c58fb367fa7f99b778de29f6511c238cfc" translate="yes" xml:space="preserve">
          <source>In simple words there are mainly two reasons for an &lt;code&gt;@Autowired&lt;/code&gt; field to be &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">Проще говоря, есть две причины, по &lt;code&gt;@Autowired&lt;/code&gt; поле @Autowired должно быть &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1fa06015977d4bb62501850a732d535c515f902" translate="yes" xml:space="preserve">
          <source>In this way &lt;strong&gt;any bean can be obtained by any object in the application&lt;/strong&gt; (also intantiated with &lt;code&gt;new&lt;/code&gt;) and &lt;strong&gt;in a static way&lt;/strong&gt;.</source>
          <target state="translated">Таким образом, &lt;strong&gt;любой компонент может быть получен любым объектом в приложении&lt;/strong&gt; (также созданным с помощью &lt;code&gt;new&lt;/code&gt; ) и &lt;strong&gt;статическим способом&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fee4af12fa524c1a7940448312eebdd0a757e15d" translate="yes" xml:space="preserve">
          <source>Inject your beans</source>
          <target state="translated">Впрыскивайте ваши бобы</target>
        </trans-unit>
        <trans-unit id="c56453903ed805219ab7d905bfb3d9194b146484" translate="yes" xml:space="preserve">
          <source>It seems to be rare case but here is what happened to me:</source>
          <target state="translated">Похоже,это редкий случай,но вот что со мной случилось:</target>
        </trans-unit>
        <trans-unit id="81362fff4d639337528a9b83ac93d07b4c8831f8" translate="yes" xml:space="preserve">
          <source>Manual bean lookup: not recommended</source>
          <target state="translated">Ручной поиск бобов:не рекомендуется</target>
        </trans-unit>
        <trans-unit id="15d38dff68d219829bee6302f049d493d93ad283" translate="yes" xml:space="preserve">
          <source>My Service class had an annotation of service and it was &lt;code&gt;@autowired&lt;/code&gt; another component class. When I tested the component class was coming null. Because for service class I was creating the object using &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">В моем классе Service была аннотация службы, и это был &lt;code&gt;@autowired&lt;/code&gt; другой класс компонентов. Когда я тестировал класс компонента, он становился нулевым. Потому что для класса обслуживания я создавал объект, используя &lt;code&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4163f897a2b6918d5bcba8024e27a75a21262caa" translate="yes" xml:space="preserve">
          <source>Other classes can use it like this:</source>
          <target state="translated">Другие классы могут использовать его таким образом:</target>
        </trans-unit>
        <trans-unit id="d7a7cfd642fc22c1d2461573908ac9a588902de4" translate="yes" xml:space="preserve">
          <source>Service bean that should be autowired in &lt;code&gt;MileageFeeCalculator&lt;/code&gt; but it isn't:</source>
          <target state="translated">Служебный компонент, который должен быть автоматически подключен в &lt;code&gt;MileageFeeCalculator&lt;/code&gt; но это не так:</target>
        </trans-unit>
        <trans-unit id="8a5f1e0fe0b1effd67db55ae23df2f6cc081647a" translate="yes" xml:space="preserve">
          <source>Service class:</source>
          <target state="translated">Класс обслуживания:</target>
        </trans-unit>
        <trans-unit id="b45858b98095f901fc99c8338155a5faac0efb3c" translate="yes" xml:space="preserve">
          <source>So to summarize, make sure that your annotations (&lt;code&gt;@Autowired&lt;/code&gt;, &lt;code&gt;@Inject&lt;/code&gt;, &lt;code&gt;@Service&lt;/code&gt; ,... ) have correct packages!</source>
          <target state="translated">&lt;code&gt;@Autowired&lt;/code&gt; итог, убедитесь, что ваши аннотации ( @Autowired , &lt;code&gt;@Inject&lt;/code&gt; , &lt;code&gt;@Service&lt;/code&gt; , ...) содержат правильные пакеты!</target>
        </trans-unit>
        <trans-unit id="3239365d583a95875a43f9f065681b250601c3cc" translate="yes" xml:space="preserve">
          <source>Some time elapses...</source>
          <target state="translated">Проходит некоторое время...</target>
        </trans-unit>
        <trans-unit id="185f0371245faa8bbe1b174c71c3c16fe0b0cf16" translate="yes" xml:space="preserve">
          <source>Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;continues to evolve&lt;/a&gt;.  It is no longer required to use &lt;code&gt;@RunWith&lt;/code&gt;&lt;em&gt;if you use the correct version of JUnit&lt;/em&gt;.</source>
          <target state="translated">Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;продолжает развиваться&lt;/a&gt; . Больше не требуется использовать &lt;code&gt;@RunWith&lt;/code&gt; , &lt;em&gt;если вы используете правильную версию JUnit&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="859e7a96ec1ad84e49569265bcd589ac37498e71" translate="yes" xml:space="preserve">
          <source>Spring only injects instances of those classes which are either created as bean or marked with annotation.</source>
          <target state="translated">Весна вводит только те классы,которые либо созданы как бобы,либо помечены примечаниями.</target>
        </trans-unit>
        <trans-unit id="b198e9188ffed25cac4c321fdc9e545886b5c39f" translate="yes" xml:space="preserve">
          <source>The IoC container isn't magic, and it has no way of knowing about Java objects unless you somehow inform it of them. When you call &lt;code&gt;new&lt;/code&gt;, the JVM instantiates a copy of the new object and hands it straight to you--it never goes through the configuration process. There are three ways that you can get your beans configured.</source>
          <target state="translated">Контейнер IoC не волшебен, и у него нет возможности узнать об объектах Java, если вы не сообщите ему о них. Когда вы вызываете &lt;code&gt;new&lt;/code&gt; , JVM создает экземпляр нового объекта и передает его прямо вам - он никогда не проходит через процесс настройки. Есть три способа настроить ваши bean-компоненты.</target>
        </trans-unit>
        <trans-unit id="289f38a4a85aa5b9a3c5b59180313674628783cd" translate="yes" xml:space="preserve">
          <source>The field annotated &lt;code&gt;@Autowired&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; because Spring doesn't know about the copy of &lt;code&gt;MileageFeeCalculator&lt;/code&gt; that you created with &lt;code&gt;new&lt;/code&gt; and didn't know to autowire it.</source>
          <target state="translated">Поле &lt;code&gt;@Autowired&lt;/code&gt; с комментариями имеет значение &lt;code&gt;null&lt;/code&gt; , потому что Spring не знает о копии &lt;code&gt;MileageFeeCalculator&lt;/code&gt; которую вы создали с &lt;code&gt;new&lt;/code&gt; версией , и не знал, как ее автоматически связать.</target>
        </trans-unit>
        <trans-unit id="17cafeacf0e3808d318c6c7dab584d668bff3de5" translate="yes" xml:space="preserve">
          <source>The most preferable option is to let Spring autowire all of your beans; this requires the least amount of code and is the most maintainable. To make the autowiring work like you wanted, also autowire the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; like this:</source>
          <target state="translated">Наиболее предпочтительный вариант - позволить Spring автоматически связывать все ваши компоненты; это требует наименьшего количества кода и является наиболее поддерживаемым. Для того, чтобы автопроводка работала так, как вы хотели, также подключите автодвигатель к &lt;code&gt;MileageFeeCalculator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7525865b1f3cf4afe5b64057e41c714903c82bb4" translate="yes" xml:space="preserve">
          <source>The root cause is, instead of using the auto-created bean maintained by the Spring IoC container (whose &lt;code&gt;@Autowired&lt;/code&gt; field is &lt;code&gt;indeed&lt;/code&gt; properly injected), I am &lt;code&gt;newing&lt;/code&gt; my own instance of that bean type and using it. Of course this one's &lt;code&gt;@Autowired&lt;/code&gt; field is null because Spring has no chance to inject it.</source>
          <target state="translated">Основная причина заключается в том, что вместо использования автоматически созданного компонента, поддерживаемого контейнером Spring IoC (чье поле &lt;code&gt;@Autowired&lt;/code&gt; &lt;code&gt;indeed&lt;/code&gt; правильно введено), я &lt;code&gt;newing&lt;/code&gt; свой собственный экземпляр этого типа компонента и использую его. Конечно, поле &lt;code&gt;@Autowired&lt;/code&gt; этого поля равно нулю, потому что у Spring нет шансов ввести его.</target>
        </trans-unit>
        <trans-unit id="5ab338c160a06915539afb8ea6a40782d023e2a0" translate="yes" xml:space="preserve">
          <source>The solution makes this MileageFeeCalculator as an auto-wired object in the Controller itself.</source>
          <target state="translated">Решение делает этот MileageFeeCalculator автоматически подключаемым объектом в самом контроллере.</target>
        </trans-unit>
        <trans-unit id="a918b75229c39b7362467ef9574f8a999ad37470" translate="yes" xml:space="preserve">
          <source>Then your legacy code can call &lt;code&gt;getContext()&lt;/code&gt; and retrieve the beans it needs:</source>
          <target state="translated">Тогда ваш унаследованный код может вызвать &lt;code&gt;getContext()&lt;/code&gt; и получить нужные ему bean-компоненты:</target>
        </trans-unit>
        <trans-unit id="ed5445ba25a7eb16ffe83bc73d081a07998d9071" translate="yes" xml:space="preserve">
          <source>This approach is suitable only for interfacing with legacy code in special situations. It is nearly always preferable to create a singleton adapter class that Spring can autowire and the legacy code can call, but it is possible to directly ask the Spring application context for a bean.</source>
          <target state="translated">Такой подход подходит только для взаимодействия с устаревшим кодом в особых ситуациях.Почти всегда предпочтительно создавать однокнопочный класс-адаптер,который Spring может автоустанавливать,и наследственный код может вызывать,но можно напрямую спросить контекст приложения Spring для боба.</target>
        </trans-unit>
        <trans-unit id="a2564b58e68e65ff5e059a30fb59c75588cf998f" translate="yes" xml:space="preserve">
          <source>This can be achieved by configuring in appln-contxt or &lt;strong&gt;the better way&lt;/strong&gt; is to annotate class as &lt;strong&gt;@Component&lt;/strong&gt; and please do not create the annotated class using new operator.
Make sure you get it from Appln-context as below.</source>
          <target state="translated">Это может быть достигнуто путем настройки в appln-contxt или &lt;strong&gt;лучше&lt;/strong&gt; &lt;strong&gt;пометить&lt;/strong&gt; класс как &lt;strong&gt;@Component,&lt;/strong&gt; и, пожалуйста, не создавайте аннотированный класс с помощью оператора new. Убедитесь, что вы получаете его из Appln-context, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="cba84fb3a576f1982a7a4e89a35adfcdcd86b573" translate="yes" xml:space="preserve">
          <source>This fixed my issue. Here is a useful &lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;link&lt;/a&gt;</source>
          <target state="translated">Это исправило мою проблему. Вот полезная &lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;ссылка&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd42e9c07834066aba16496cc46ca18618d98be0" translate="yes" xml:space="preserve">
          <source>This is only valid in case of Unit test.</source>
          <target state="translated">Это действительно только в случае единичного теста.</target>
        </trans-unit>
        <trans-unit id="c3bf31c57b1da3cd7be0fd57b9c4bbbf09272a68" translate="yes" xml:space="preserve">
          <source>This is the culprit of giving NullPointerException &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; We are using Spring - don't need to create object manually. Object creation will be taken care of by IoC container.</source>
          <target state="translated">Это является &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; предоставления NullPointerException ПробегFFeCalculator calc = новый ПробегFeeCalculator (); Мы используем Spring - не нужно создавать объекты вручную. За созданием объекта позаботится контейнер IoC.</target>
        </trans-unit>
        <trans-unit id="f056c0834db33a952b9af4a4a12e11c7ce780a22" translate="yes" xml:space="preserve">
          <source>To MileageFeeCalculator constructor like this:</source>
          <target state="translated">К конструктору MileageFeeCalculator вот так:</target>
        </trans-unit>
        <trans-unit id="a415fb8c7eebe85e5542348eaa6368fe99ef4ebd" translate="yes" xml:space="preserve">
          <source>To do this, you need a class to which Spring can give a reference to the &lt;code&gt;ApplicationContext&lt;/code&gt; object:</source>
          <target state="translated">Для этого вам нужен класс, на который Spring может дать ссылку на объект &lt;code&gt;ApplicationContext&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="712bd4ea7182b2392287b9cba31f1c58a4f995c7" translate="yes" xml:space="preserve">
          <source>Use @Configurable</source>
          <target state="translated">Использовать @ Настраиваемый</target>
        </trans-unit>
        <trans-unit id="b4de62676a8e2ba66f6e67603bb1ab327f963c2d" translate="yes" xml:space="preserve">
          <source>Using @PostConstruct solves that:</source>
          <target state="translated">Использование @PostConstruct решает эту проблему:</target>
        </trans-unit>
        <trans-unit id="814e53b54fffcd1ab97e69af5ec501e8ca6cd377" translate="yes" xml:space="preserve">
          <source>We used &lt;code&gt;@Inject&lt;/code&gt; instead of &lt;code&gt;@Autowired&lt;/code&gt; which is javaee standard supported by Spring. Every places it worked fine and the beans injected correctly, instead of one place. The bean injection seems the same</source>
          <target state="translated">Мы использовали &lt;code&gt;@Inject&lt;/code&gt; вместо &lt;code&gt;@Autowired&lt;/code&gt; , который является стандартом javaee, поддерживаемым Spring. Во всех местах он работал нормально, и бобы вводили правильно, вместо одного места. Инъекция бобов кажется такой же</target>
        </trans-unit>
        <trans-unit id="a22a650a6695b1cb52df04c214890311d5d9f32b" translate="yes" xml:space="preserve">
          <source>What hasn't been mentioned here is described in &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot;&gt;this&lt;/a&gt; article in the paragraph &quot;Order of execution&quot;.</source>
          <target state="translated">То, что не было упомянуто здесь, описано в &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot;&gt;этой&lt;/a&gt; статье в параграфе &amp;laquo;Порядок исполнения&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c9351769f2d3fc8aed37c27cfba4d601a5fd919c" translate="yes" xml:space="preserve">
          <source>When I try to &lt;code&gt;GET /mileage/3&lt;/code&gt;, I get this exception:</source>
          <target state="translated">Когда я пытаюсь получить &lt;code&gt;GET /mileage/3&lt;/code&gt; , я получаю это исключение:</target>
        </trans-unit>
        <trans-unit id="4a94711b9930ced50218f0105a49745e4e697dd7" translate="yes" xml:space="preserve">
          <source>Why is my Spring @Autowired field null</source>
          <target state="translated">Почему мое весеннее @Автоустановленное поле нулевое.</target>
        </trans-unit>
        <trans-unit id="0355cb07b2fa9677429e730cb275eac228744309" translate="yes" xml:space="preserve">
          <source>With annotation &lt;code&gt;@Service&lt;/code&gt;, &lt;code&gt;@Component&lt;/code&gt;, &lt;code&gt;@Configuration&lt;/code&gt; beans are created in the</source>
          <target state="translated">С аннотацией &lt;code&gt;@Service&lt;/code&gt; , &lt;code&gt;@Component&lt;/code&gt; , &lt;code&gt;@Configuration&lt;/code&gt; создаются в</target>
        </trans-unit>
        <trans-unit id="e646deb97792a6ade92069b79676e29df55b56d7" translate="yes" xml:space="preserve">
          <source>You can also fix this issue using @Service annotation on service class and passing the required bean classA as a parameter to the other beans classB constructor and annotate the constructor of classB with @Autowired. Sample snippet here :</source>
          <target state="translated">Вы также можете исправить эту проблему,используя @Service annotation on service class и передав требуемый боб classA в качестве параметра другому конструктору бобов classB и аннотировать конструктор classB с помощью @Autowired.Пример фрагмента здесь :</target>
        </trans-unit>
        <trans-unit id="9d2bd3f9fbf79e8c120c81a56d52d033b5a518c7" translate="yes" xml:space="preserve">
          <source>You can put this code also in the main application class if you want.</source>
          <target state="translated">При желании этот код можно поместить и в основной класс приложения.</target>
        </trans-unit>
        <trans-unit id="ca489fbd0a1b9070d098e10dcb1d2193bc0465c8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; on the configuration class of your spring application to instruct spring to scan.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; в классе конфигурации вашего приложения Spring, чтобы дать команду Spring для сканирования.</target>
        </trans-unit>
        <trans-unit id="748d434e98b06abd0eecc728bee5795a1ecdb8c5" translate="yes" xml:space="preserve">
          <source>Your problem is new (object creation in java style)</source>
          <target state="translated">Ваша проблема новая (создание объектов в стиле java).</target>
        </trans-unit>
        <trans-unit id="6097ca49faf78ea33ebe49e2de5a90e831a070dc" translate="yes" xml:space="preserve">
          <source>and SomeAbac class has a property declared as</source>
          <target state="translated">и у класса SomeAbac есть собственность,заявленная как</target>
        </trans-unit>
        <trans-unit id="fe045fcc475b2ed5785570e3bf62d2af03225740" translate="yes" xml:space="preserve">
          <source>and in a &lt;code&gt;token.xml&lt;/code&gt; file I've had a line</source>
          <target state="translated">и в файле &lt;code&gt;token.xml&lt;/code&gt; у меня была строка</target>
        </trans-unit>
        <trans-unit id="8f184f10becfd5255e7dd174b71f596e5ed826d2" translate="yes" xml:space="preserve">
          <source>and it works. May be someone can provide an explanation, but for me it's enough right now )</source>
          <target state="translated">и это работает.Может быть,кто-то и может дать объяснение,но для меня сейчас этого достаточно.)</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="83e983915573bdd6a6a5428e20d4237c9b28e9f9" translate="yes" xml:space="preserve">
          <source>application context of Spring when server is started. But when we create objects 
    using new operator the object is not registered in  application context which  is already created. For Example Employee.java class i have used.</source>
          <target state="translated">контекст приложения Весна при запуске сервера.Но когда мы создаем объекты с помощью оператора new,объект не регистрируется в уже созданном контексте приложения.Для примера использовался класс Employee.java.</target>
        </trans-unit>
        <trans-unit id="8f777ca7518e37a243e3d63d7566fe9cd2f615f1" translate="yes" xml:space="preserve">
          <source>for some unknown reason, settings is &lt;em&gt;null&lt;/em&gt; in init(), when &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; element is not present at all, but when it's present and has some bs as a basePackage, everything works well. This line now looks like this:</source>
          <target state="translated">по какой-то неизвестной причине, настройки &lt;em&gt;равны нулю&lt;/em&gt; в init (), когда элемент &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; вообще отсутствует, но когда он присутствует и имеет несколько bs в качестве basePackage, все работает хорошо. Эта строка теперь выглядит так:</target>
        </trans-unit>
        <trans-unit id="d5db4151b6088246e47fd7448b54cae44fc44c85" translate="yes" xml:space="preserve">
          <source>so it won't work that way.</source>
          <target state="translated">так что так не пойдет.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
