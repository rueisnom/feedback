<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/19896870">
    <body>
      <group id="19896870">
        <trans-unit id="394b57ab44493bad9e13375faca2da97306afe8c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;The Spring Inversion of Control (IoC) container&lt;/a&gt; has three main logical components: a registry (called the &lt;code&gt;ApplicationContext&lt;/code&gt;) of components (beans) that are available to be used by the application, a configurer system that injects objects' dependencies into them by matching up the dependencies with beans in the context, and a dependency solver that can look at a configuration of many different beans and determine how to instantiate and configure them in the necessary order.</source>
          <target state="translated">&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;Spring Inversion of Control（IoC）容器&lt;/a&gt;具有三个主要逻辑组件：组件（bean）的注册表（称为 &lt;code&gt;ApplicationContext&lt;/code&gt; ），可供应用程序使用；配置程序系统，通过匹配将对象的依赖项注入对象上下文中具有bean的依赖关系，以及一个依赖关系求解程序，它可以查看许多不同bean的配置并确定如何以必要的顺序实例化和配置它们。</target>
        </trans-unit>
        <trans-unit id="1ae06b30b6d1c782656a2208ccb72d7333701bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@Service, @Component&lt;/code&gt; etc annotations add meta description.</source>
          <target state="translated">&lt;code&gt;@Service, @Component&lt;/code&gt; 等注释添加了元描述。</target>
        </trans-unit>
        <trans-unit id="a70bff0ba394cef82c27ca682d50f21c90605937" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I'm new to Spring, but I discovered this working solution. Please tell me if it's a deprecable way.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;我是Spring的新手，但是我发现了这个可行的解决方案。&lt;/em&gt; &lt;em&gt;请告诉我这是否是可弃的方法。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac07e8cc2813a62fa38fad476b41fdaaca46ef7a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is intended to be a canonical answer for a common problem.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：这旨在作为常见问题的规范答案。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b7fb549b54ec58659fd74cbdd78e77c0e0493806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ORIGINAL ANSWER:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;原始答案：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f981fb4e08e95e60895db03be2fe27045a89932" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE FIELD IS NOT A BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;田野不是豆类。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c63b5f6bebe122bb768741b030b15d8683140f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by injecting the &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt;&lt;code&gt;working-inject-bean&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通过注入 &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; 服务对象而起作用的标记： &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt; &lt;code&gt;working-inject-bean&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ece2ffe683fc87cb97657a6c77b083b990d1adf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by manually looking up the service object in the Spring context: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt;&lt;code&gt;working-manual-lookup&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通过在Spring上下文中&lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt; &lt;code&gt;working-manual-lookup&lt;/code&gt; &lt;/a&gt;服务对象而起作用的标记： working-manual-lookup&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ee91e9a00165f2f5a170963a6a33b134695cf84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by using &lt;code&gt;@Configurable&lt;/code&gt; on the service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt;&lt;code&gt;working-configurable&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通过在服务对象上使用 &lt;code&gt;@Configurable&lt;/code&gt; 起作用的标记： &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt; &lt;code&gt;working-configurable&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="774dd712670d211631d8f90f0cee69e58e4015a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; Really smart people were quick to point on &lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;this&lt;/a&gt; answer, which explains the weirdness, described below</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;真正聪明的人很快就指出了&lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;这个&lt;/a&gt;答案，这解释了怪异现象，如下所述</target>
        </trans-unit>
        <trans-unit id="343f2555b3fe8817306d09a16f4d9c002d898197" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YOUR CLASS IS NOT A  SPRING BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;您的班级不是春天。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="013573a8c9d74642d1e8e6d7631446a204fef372" translate="yes" xml:space="preserve">
          <source>Actually, you should use either JVM managed Objects or Spring-managed Object to invoke methods.
from your above code in your controller class, you are creating a new object to call your service class which has an auto-wired object.</source>
          <target state="translated">实际上,你应该使用JVM管理的对象或Spring管理的对象来调用方法,从你的控制器类中的上述代码来看,你是在创建一个新的对象来调用你的服务类,而这个服务类有一个自动连接的对象。</target>
        </trans-unit>
        <trans-unit id="17e5fa0456b0b310229eb43f4b0714169ea19cff" translate="yes" xml:space="preserve">
          <source>Adding annotation only, does not fix or facilitate the dependency injection, Spring needs to know where to look for.</source>
          <target state="translated">只添加注释,并不能修复或促进依赖注入,Spring需要知道从哪里找。</target>
        </trans-unit>
        <trans-unit id="57be7d302f1b2ff8eef279015d9880539858b846" translate="yes" xml:space="preserve">
          <source>After &quot;learning&quot; that I had to annotate a class with @Component or the derivatives @Service or @Repository (I guess there are more), to autowire other components inside them, it struck me that these other components still were null inside the constructor of the parent component.</source>
          <target state="translated">在 &quot;了解到 &quot;我必须用@Component或派生的@Service或@Repository(我想还有更多)来注释一个类之后,我突然发现,这些其他的组件在父组件的构造函数里面仍然是空的。</target>
        </trans-unit>
        <trans-unit id="41fc58409cda1816c0d86da0328ade7c51269de3" translate="yes" xml:space="preserve">
          <source>Also note that if, for whatever reason, you make a method in a &lt;code&gt;@Service&lt;/code&gt; as &lt;code&gt;final&lt;/code&gt;, the autowired beans you will access from it will always be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">还要注意，如果出于某种原因，如果您在 &lt;code&gt;@Service&lt;/code&gt; 中创建一个 &lt;code&gt;final&lt;/code&gt; 方法，那么从中访问的自动装配bean将始终为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e62f46e6b944ff55852b8bd59d0add7902a8d67" translate="yes" xml:space="preserve">
          <source>And after that, NPE started coming in. In a &lt;code&gt;pep-config.xml&lt;/code&gt; I had just 2 beans:</source>
          <target state="translated">之后，NPE开始出现。在 &lt;code&gt;pep-config.xml&lt;/code&gt; 中,我只有2个bean：</target>
        </trans-unit>
        <trans-unit id="ec68cc24f685999a1deb5d39824c5936e0df4e7d" translate="yes" xml:space="preserve">
          <source>Another solution would be putting call:
&lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;</source>
          <target state="translated">另一个解决方案是调用： &lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f41f414dfb43d22eb44abecd6879c5950ea1c" translate="yes" xml:space="preserve">
          <source>At last we found that the error was that we (actually, the Eclipse auto complete feature) imported &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; instead of &lt;code&gt;javax.inject.Inject&lt;/code&gt; !</source>
          <target state="translated">最后，我们发现错误是我们（实际上是Eclipse自动完成功能）导入了 &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; 而不是 &lt;code&gt;javax.inject.Inject&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="d94d761d0a782bc648563729db0ab5861e158fd2" translate="yes" xml:space="preserve">
          <source>Change your Controller class like below.</source>
          <target state="translated">改变你的控制器类,如下图所示。</target>
        </trans-unit>
        <trans-unit id="7ba406818c8f1055e3ce7bbdb75cfb6882131af8" translate="yes" xml:space="preserve">
          <source>Check this out:</source>
          <target state="translated">看看这个。</target>
        </trans-unit>
        <trans-unit id="d230873b60b53c384e2144ccb234383174838a29" translate="yes" xml:space="preserve">
          <source>Classes marked with annotation need to be identified by spring before injecting, &lt;code&gt;@ComponentScan&lt;/code&gt; instruct spring look for the classes marked with annotation. When Spring finds &lt;code&gt;@Autowired&lt;/code&gt; it searches for the related bean, and injects the required instance.</source>
          <target state="translated">带有注解的类需要在注入之前通过spring进行标识， &lt;code&gt;@ComponentScan&lt;/code&gt; 指示spring查找带有注解的类。 当Spring找到 &lt;code&gt;@Autowired&lt;/code&gt; 时,它将搜索相关的bean，并注入所需的实例。</target>
        </trans-unit>
        <trans-unit id="b83c98c8abe52ca04318bc946ddb1f41bf28da5e" translate="yes" xml:space="preserve">
          <source>Controller class:</source>
          <target state="translated">控制器类:</target>
        </trans-unit>
        <trans-unit id="72e876a8da98d0fdec73e4e6b97838b88035189f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;@SpringBootTest&lt;/code&gt; to work stand alone, you need to use &lt;code&gt;@Test&lt;/code&gt; from &lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit5 instead of JUnit4&lt;/a&gt;.</source>
          <target state="translated">为了使 &lt;code&gt;@SpringBootTest&lt;/code&gt; 独立运行，您需要使用&lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit5中的&lt;/a&gt; &lt;code&gt;@Test&lt;/code&gt; 而不是JUnit4 。</target>
        </trans-unit>
        <trans-unit id="ac65d99b8c551d6eafac33e561e4dde92e51d8d7" translate="yes" xml:space="preserve">
          <source>For example, in &lt;strong&gt;Spring Boot&lt;/strong&gt;:</source>
          <target state="translated">例如，在&lt;strong&gt;Spring Boot中&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="f6ca09ba5cd1826f082b5fb7aab89b84c2c8faa7" translate="yes" xml:space="preserve">
          <source>I don't know if it helps anyone, but I was stuck with the same problem even while doing things seemingly right. In my Main method, I have a code like this:</source>
          <target state="translated">我不知道这是否对大家有帮助,但我在做看似正确的事情时,也遇到了同样的问题。在我的Main方法中,我的代码是这样的。</target>
        </trans-unit>
        <trans-unit id="290aab609060c87e3330711b7a475560a5a08290" translate="yes" xml:space="preserve">
          <source>I have a Spring &lt;code&gt;@Service&lt;/code&gt; class (&lt;code&gt;MileageFeeCalculator&lt;/code&gt;) that has an &lt;code&gt;@Autowired&lt;/code&gt; field (&lt;code&gt;rateService&lt;/code&gt;), but the field is &lt;code&gt;null&lt;/code&gt; when I try to use it. The logs show that both the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; bean and the &lt;code&gt;MileageRateService&lt;/code&gt; bean are being created, but I get a &lt;code&gt;NullPointerException&lt;/code&gt; whenever I try to call the &lt;code&gt;mileageCharge&lt;/code&gt; method on my service bean. Why isn't Spring autowiring the field?</source>
          <target state="translated">我有一个Spring &lt;code&gt;@Service&lt;/code&gt; 类（ &lt;code&gt;MileageFeeCalculator&lt;/code&gt; ），它具有一个 &lt;code&gt;@Autowired&lt;/code&gt; 字段（ &lt;code&gt;rateService&lt;/code&gt; ），但是当我尝试使用它时，该字段为 &lt;code&gt;null&lt;/code&gt; 。 日志显示同时创建了 &lt;code&gt;MileageFeeCalculator&lt;/code&gt; Bean和 &lt;code&gt;MileageRateService&lt;/code&gt; Bean，但是每当尝试在服务Bean上调用 &lt;code&gt;mileageCharge&lt;/code&gt; 方法时，都会收到 &lt;code&gt;NullPointerException&lt;/code&gt; 。 Spring为什么不自动接线该领域？</target>
        </trans-unit>
        <trans-unit id="4d81e527154a800d280587cbded9d3aad6e0b819" translate="yes" xml:space="preserve">
          <source>I have posted all of this code, using Spring Boot to launch, at &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;this GitHub project&lt;/a&gt;; you can look at a full running project for each approach to see everything you need to make it work. &lt;strong&gt;Tag with the &lt;code&gt;NullPointerException&lt;/code&gt;: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt;&lt;code&gt;nonworking&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">我已经在&lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;GitHub项目上&lt;/a&gt;使用Spring Boot启动了所有这些代码； 您可以针对每种方法查看一个正在运行的项目，以查看使其工作所需的一切。 &lt;strong&gt;带有 &lt;code&gt;NullPointerException&lt;/code&gt; 的标记： &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt; &lt;code&gt;nonworking&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a28c8ad27d6ac9d92801b7c7616da199741fee8" translate="yes" xml:space="preserve">
          <source>I make Spring inject &lt;code&gt;applicationContext&lt;/code&gt; in this bean:</source>
          <target state="translated">我在这个bean中注入Spring &lt;code&gt;applicationContext&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9d7deec7709d1e237f060b3e6cae162dde1f065a" translate="yes" xml:space="preserve">
          <source>I noticed that the package.path does no longer exist, so I've just dropped the line for good.</source>
          <target state="translated">我注意到package.path已经不存在了,所以我就把这句话永远地丢掉了。</target>
        </trans-unit>
        <trans-unit id="acaef4085e64a02688aad3db5d1923dfe9e86ead" translate="yes" xml:space="preserve">
          <source>I once encountered the same issue when I was not quite used to &lt;code&gt;the life in the IoC world&lt;/code&gt;. The &lt;code&gt;@Autowired&lt;/code&gt; field of one of my beans is null at runtime.</source>
          <target state="translated">当我不习惯 &lt;code&gt;the life in the IoC world&lt;/code&gt; 时，我曾经遇到过同样的问题。 我的其中一个bean的 &lt;code&gt;@Autowired&lt;/code&gt; 字段在运行时为null。</target>
        </trans-unit>
        <trans-unit id="d4f5aca2a7ed0b7166b5ed31cd0d48496a56e4c5" translate="yes" xml:space="preserve">
          <source>I think you have missed to instruct spring to scan classes with annotation.</source>
          <target state="translated">我想,你已经错过指导春天用注解扫描类的班级了。</target>
        </trans-unit>
        <trans-unit id="e6f1ec927b26cd65fdaaa4ddf91e84e5652ed241" translate="yes" xml:space="preserve">
          <source>If this is happening in a test class, make sure you haven't forgotten to annotate the class.</source>
          <target state="translated">如果是在测试类中出现这种情况,请确保你没有忘记对该类进行注释。</target>
        </trans-unit>
        <trans-unit id="f517ef786825d3bc62a16f6307b66a8ef2849b27" translate="yes" xml:space="preserve">
          <source>If you are not coding a web application, make sure your class in which @Autowiring is done is a spring bean. Typically, spring container won't be aware of the class which we might think of as a spring bean. We have to tell the Spring container about our spring classes.</source>
          <target state="translated">如果你不是在编写一个web应用程序,请确保你的@Autowiring所做的类是一个spring bean。通常情况下,spring容器不会意识到我们可能认为是spring bean的类。我们必须告诉Spring容器我们的spring类。</target>
        </trans-unit>
        <trans-unit id="4210a615a7a8e9cf17363c2ebfcc8af5476ec05a" translate="yes" xml:space="preserve">
          <source>If you are writing unit test make sure you are not creating object using &lt;code&gt;new object()&lt;/code&gt;. Use instead injectMock.</source>
          <target state="translated">如果要编写单元测试，请确保未使用 &lt;code&gt;new object()&lt;/code&gt; 创建对象。 改用injectMock。</target>
        </trans-unit>
        <trans-unit id="e1b2ce47c7a4f14dbdd6d84b8fe65d5309868f7e" translate="yes" xml:space="preserve">
          <source>If you get this configuration wrong your tests will compile, but &lt;code&gt;@Autowired&lt;/code&gt; and &lt;code&gt;@Value&lt;/code&gt; fields (for example) will be &lt;code&gt;null&lt;/code&gt;.  Since Spring Boot operates by magic, you may have few avenues for directly debugging this failure.</source>
          <target state="translated">如果配置错误，将编译测试，但是 &lt;code&gt;@Autowired&lt;/code&gt; 和 &lt;code&gt;@Value&lt;/code&gt; 字段将为 &lt;code&gt;null&lt;/code&gt; 。 由于Spring Boot是靠魔术操作的，因此您可能没有几种直接调试此故障的途径。</target>
        </trans-unit>
        <trans-unit id="6c1b72872b08c510fda6dfeaed1dcb63e25fcc5d" translate="yes" xml:space="preserve">
          <source>If you need to create a new instance of your service object for different requests, you can still use injection by using &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;the Spring bean scopes&lt;/a&gt;.</source>
          <target state="translated">如果您需要为不同的请求创建服务对象的新实例，仍然可以通过&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;Spring bean scopes&lt;/a&gt;使用注入。</target>
        </trans-unit>
        <trans-unit id="1f44484492dfecd22e18b5bd83804f19ec3019b8" translate="yes" xml:space="preserve">
          <source>If you really need objects created with &lt;code&gt;new&lt;/code&gt; to be autowired, you can &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;use the Spring &lt;code&gt;@Configurable&lt;/code&gt; annotation along with AspectJ compile-time weaving&lt;/a&gt; to inject your objects. This approach inserts code into your object's constructor that alerts Spring that it's being created so that Spring can configure the new instance. This requires a bit of configuration in your build (such as compiling with &lt;code&gt;ajc&lt;/code&gt;) and turning on Spring's runtime configuration handlers (&lt;code&gt;@EnableSpringConfigured&lt;/code&gt; with the JavaConfig syntax). This approach is used by the Roo Active Record system to allow &lt;code&gt;new&lt;/code&gt; instances of your entities to get the necessary persistence information injected.</source>
          <target state="translated">如果确实需要自动创建使用 &lt;code&gt;new&lt;/code&gt; 创建的对象，则可以&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;使用Spring &lt;code&gt;@Configurable&lt;/code&gt; 批注以及AspectJ编译时编织&lt;/a&gt;来注入对象。 这种方法将代码插入到对象的构造函数中，以警告Spring正在创建它，以便Spring可以配置新实例。 这需要在构建中进行一些配置（例如，使用 &lt;code&gt;ajc&lt;/code&gt; 进行编译）并打开Spring的运行时配置处理程序（使用JavaConfig语法的 &lt;code&gt;@EnableSpringConfigured&lt;/code&gt; ）。 Roo Active Record系统使用此方法来允许您实体的 &lt;code&gt;new&lt;/code&gt; 实例获取注入的必要持久性信息。</target>
        </trans-unit>
        <trans-unit id="8dc718c58fb367fa7f99b778de29f6511c238cfc" translate="yes" xml:space="preserve">
          <source>In simple words there are mainly two reasons for an &lt;code&gt;@Autowired&lt;/code&gt; field to be &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">用简单的话来说，@ &lt;code&gt;@Autowired&lt;/code&gt; 字段为 &lt;code&gt;null&lt;/code&gt; 主要原因有两个</target>
        </trans-unit>
        <trans-unit id="c1fa06015977d4bb62501850a732d535c515f902" translate="yes" xml:space="preserve">
          <source>In this way &lt;strong&gt;any bean can be obtained by any object in the application&lt;/strong&gt; (also intantiated with &lt;code&gt;new&lt;/code&gt;) and &lt;strong&gt;in a static way&lt;/strong&gt;.</source>
          <target state="translated">这样&lt;strong&gt;，应用程序中的任何对象&lt;/strong&gt; （也可以通过 &lt;code&gt;new&lt;/code&gt; 实例化） &lt;strong&gt;都可以以静态方式&lt;/strong&gt; &lt;strong&gt;获取任何bean&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="fee4af12fa524c1a7940448312eebdd0a757e15d" translate="yes" xml:space="preserve">
          <source>Inject your beans</source>
          <target state="translated">注入你的豆子</target>
        </trans-unit>
        <trans-unit id="c56453903ed805219ab7d905bfb3d9194b146484" translate="yes" xml:space="preserve">
          <source>It seems to be rare case but here is what happened to me:</source>
          <target state="translated">这似乎是很罕见的情况,但我的情况是这样的。</target>
        </trans-unit>
        <trans-unit id="81362fff4d639337528a9b83ac93d07b4c8831f8" translate="yes" xml:space="preserve">
          <source>Manual bean lookup: not recommended</source>
          <target state="translated">手动豆子查询:不推荐</target>
        </trans-unit>
        <trans-unit id="15d38dff68d219829bee6302f049d493d93ad283" translate="yes" xml:space="preserve">
          <source>My Service class had an annotation of service and it was &lt;code&gt;@autowired&lt;/code&gt; another component class. When I tested the component class was coming null. Because for service class I was creating the object using &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">我的Service类具有服务注释，并且 &lt;code&gt;@autowired&lt;/code&gt; 是另一个组件类。 当我测试组件类为空时。 因为对于服务类，我正在使用 &lt;code&gt;new&lt;/code&gt; 创建对象</target>
        </trans-unit>
        <trans-unit id="4163f897a2b6918d5bcba8024e27a75a21262caa" translate="yes" xml:space="preserve">
          <source>Other classes can use it like this:</source>
          <target state="translated">其他类可以这样使用。</target>
        </trans-unit>
        <trans-unit id="d7a7cfd642fc22c1d2461573908ac9a588902de4" translate="yes" xml:space="preserve">
          <source>Service bean that should be autowired in &lt;code&gt;MileageFeeCalculator&lt;/code&gt; but it isn't:</source>
          <target state="translated">应该在 &lt;code&gt;MileageFeeCalculator&lt;/code&gt; 中自动接线的服务bean，但不是：</target>
        </trans-unit>
        <trans-unit id="8a5f1e0fe0b1effd67db55ae23df2f6cc081647a" translate="yes" xml:space="preserve">
          <source>Service class:</source>
          <target state="translated">服务类:</target>
        </trans-unit>
        <trans-unit id="b45858b98095f901fc99c8338155a5faac0efb3c" translate="yes" xml:space="preserve">
          <source>So to summarize, make sure that your annotations (&lt;code&gt;@Autowired&lt;/code&gt;, &lt;code&gt;@Inject&lt;/code&gt;, &lt;code&gt;@Service&lt;/code&gt; ,... ) have correct packages!</source>
          <target state="translated">因此，总而言之，请确保您的注释（ &lt;code&gt;@Service&lt;/code&gt; &lt;code&gt;@Autowired&lt;/code&gt; ， @ &lt;code&gt;@Inject&lt;/code&gt; ， @Service ，...）具有正确的包！</target>
        </trans-unit>
        <trans-unit id="3239365d583a95875a43f9f065681b250601c3cc" translate="yes" xml:space="preserve">
          <source>Some time elapses...</source>
          <target state="translated">时间过去了.....</target>
        </trans-unit>
        <trans-unit id="185f0371245faa8bbe1b174c71c3c16fe0b0cf16" translate="yes" xml:space="preserve">
          <source>Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;continues to evolve&lt;/a&gt;.  It is no longer required to use &lt;code&gt;@RunWith&lt;/code&gt;&lt;em&gt;if you use the correct version of JUnit&lt;/em&gt;.</source>
          <target state="translated">Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;继续发展&lt;/a&gt; 。 &lt;em&gt;如果使用正确的JUnit版本，则&lt;/em&gt;不再需要使用 &lt;code&gt;@RunWith&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="859e7a96ec1ad84e49569265bcd589ac37498e71" translate="yes" xml:space="preserve">
          <source>Spring only injects instances of those classes which are either created as bean or marked with annotation.</source>
          <target state="translated">Spring只注入那些被创建为Bean或被标记为注释的类的实例。</target>
        </trans-unit>
        <trans-unit id="b198e9188ffed25cac4c321fdc9e545886b5c39f" translate="yes" xml:space="preserve">
          <source>The IoC container isn't magic, and it has no way of knowing about Java objects unless you somehow inform it of them. When you call &lt;code&gt;new&lt;/code&gt;, the JVM instantiates a copy of the new object and hands it straight to you--it never goes through the configuration process. There are three ways that you can get your beans configured.</source>
          <target state="translated">IoC容器不是魔术，除非您以某种方式告知Java对象，否则它无法了解Java对象。 当您调用 &lt;code&gt;new&lt;/code&gt; 时 ，JVM会实例化新对象的副本并将其直接交给您-它从未经历配置过程。 您可以通过三种方式配置bean。</target>
        </trans-unit>
        <trans-unit id="289f38a4a85aa5b9a3c5b59180313674628783cd" translate="yes" xml:space="preserve">
          <source>The field annotated &lt;code&gt;@Autowired&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; because Spring doesn't know about the copy of &lt;code&gt;MileageFeeCalculator&lt;/code&gt; that you created with &lt;code&gt;new&lt;/code&gt; and didn't know to autowire it.</source>
          <target state="translated">注释为 &lt;code&gt;@Autowired&lt;/code&gt; 的字段为 &lt;code&gt;null&lt;/code&gt; ,因为Spring不知道您使用 &lt;code&gt;new&lt;/code&gt; 创建的 &lt;code&gt;MileageFeeCalculator&lt;/code&gt; 的副本，也不知道自动对其进行接线 。</target>
        </trans-unit>
        <trans-unit id="17cafeacf0e3808d318c6c7dab584d668bff3de5" translate="yes" xml:space="preserve">
          <source>The most preferable option is to let Spring autowire all of your beans; this requires the least amount of code and is the most maintainable. To make the autowiring work like you wanted, also autowire the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; like this:</source>
          <target state="translated">最可取的选择是让Spring自动连接所有bean。 这需要最少的代码量，并且最易于维护。 要使自动装配工作如您所愿，还可以如下方式自动连接 &lt;code&gt;MileageFeeCalculator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7525865b1f3cf4afe5b64057e41c714903c82bb4" translate="yes" xml:space="preserve">
          <source>The root cause is, instead of using the auto-created bean maintained by the Spring IoC container (whose &lt;code&gt;@Autowired&lt;/code&gt; field is &lt;code&gt;indeed&lt;/code&gt; properly injected), I am &lt;code&gt;newing&lt;/code&gt; my own instance of that bean type and using it. Of course this one's &lt;code&gt;@Autowired&lt;/code&gt; field is null because Spring has no chance to inject it.</source>
          <target state="translated">根本原因是，我不是在使用Spring IoC容器维护的自动创建的bean（ &lt;code&gt;indeed&lt;/code&gt; 正确注入了 &lt;code&gt;@Autowired&lt;/code&gt; 字段），而是在 &lt;code&gt;newing&lt;/code&gt; 自己的bean类型实例并使用它。 当然，这个人的 &lt;code&gt;@Autowired&lt;/code&gt; 字段为null，因为Spring没有机会注入它。</target>
        </trans-unit>
        <trans-unit id="5ab338c160a06915539afb8ea6a40782d023e2a0" translate="yes" xml:space="preserve">
          <source>The solution makes this MileageFeeCalculator as an auto-wired object in the Controller itself.</source>
          <target state="translated">该解决方案使这个MileageFeeCalculator作为控制器本身的自动接线对象。</target>
        </trans-unit>
        <trans-unit id="a918b75229c39b7362467ef9574f8a999ad37470" translate="yes" xml:space="preserve">
          <source>Then your legacy code can call &lt;code&gt;getContext()&lt;/code&gt; and retrieve the beans it needs:</source>
          <target state="translated">然后，您的旧代码可以调用 &lt;code&gt;getContext()&lt;/code&gt; 并检索所需的bean：</target>
        </trans-unit>
        <trans-unit id="ed5445ba25a7eb16ffe83bc73d081a07998d9071" translate="yes" xml:space="preserve">
          <source>This approach is suitable only for interfacing with legacy code in special situations. It is nearly always preferable to create a singleton adapter class that Spring can autowire and the legacy code can call, but it is possible to directly ask the Spring application context for a bean.</source>
          <target state="translated">这种方法只适合在特殊情况下与遗留代码进行接口。几乎所有的方法都是创建一个单子适配器类,Spring可以自动触发,遗留代码可以调用,但也可以直接向Spring应用上下文请求一个Bean。</target>
        </trans-unit>
        <trans-unit id="a2564b58e68e65ff5e059a30fb59c75588cf998f" translate="yes" xml:space="preserve">
          <source>This can be achieved by configuring in appln-contxt or &lt;strong&gt;the better way&lt;/strong&gt; is to annotate class as &lt;strong&gt;@Component&lt;/strong&gt; and please do not create the annotated class using new operator.
Make sure you get it from Appln-context as below.</source>
          <target state="translated">这可以通过在appln-contxt中配置来实现，或者&lt;strong&gt;更好的方法&lt;/strong&gt;是将类注释为&lt;strong&gt;@Component&lt;/strong&gt; ，请不要使用new运算符创建带注释的类。 确保从Appln上下文中获取它，如下所示。</target>
        </trans-unit>
        <trans-unit id="cba84fb3a576f1982a7a4e89a35adfcdcd86b573" translate="yes" xml:space="preserve">
          <source>This fixed my issue. Here is a useful &lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;link&lt;/a&gt;</source>
          <target state="translated">这解决了我的问题。 这是一个有用的&lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;链接&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd42e9c07834066aba16496cc46ca18618d98be0" translate="yes" xml:space="preserve">
          <source>This is only valid in case of Unit test.</source>
          <target state="translated">这只在单元测试的情况下有效。</target>
        </trans-unit>
        <trans-unit id="c3bf31c57b1da3cd7be0fd57b9c4bbbf09272a68" translate="yes" xml:space="preserve">
          <source>This is the culprit of giving NullPointerException &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; We are using Spring - don't need to create object manually. Object creation will be taken care of by IoC container.</source>
          <target state="translated">这是给NullPointerException &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; 的罪魁祸首。 我们正在使用Spring-不需要手动创建对象。 IoC容器将负责对象的创建。</target>
        </trans-unit>
        <trans-unit id="f056c0834db33a952b9af4a4a12e11c7ce780a22" translate="yes" xml:space="preserve">
          <source>To MileageFeeCalculator constructor like this:</source>
          <target state="translated">像这样的MileageFeeCalculator构造函数。</target>
        </trans-unit>
        <trans-unit id="a415fb8c7eebe85e5542348eaa6368fe99ef4ebd" translate="yes" xml:space="preserve">
          <source>To do this, you need a class to which Spring can give a reference to the &lt;code&gt;ApplicationContext&lt;/code&gt; object:</source>
          <target state="translated">为此，您需要一个Spring可以引用 &lt;code&gt;ApplicationContext&lt;/code&gt; 对象的类：</target>
        </trans-unit>
        <trans-unit id="712bd4ea7182b2392287b9cba31f1c58a4f995c7" translate="yes" xml:space="preserve">
          <source>Use @Configurable</source>
          <target state="translated">使用@Configurable</target>
        </trans-unit>
        <trans-unit id="b4de62676a8e2ba66f6e67603bb1ab327f963c2d" translate="yes" xml:space="preserve">
          <source>Using @PostConstruct solves that:</source>
          <target state="translated">使用@PostConstruct就可以解决这个问题。</target>
        </trans-unit>
        <trans-unit id="814e53b54fffcd1ab97e69af5ec501e8ca6cd377" translate="yes" xml:space="preserve">
          <source>We used &lt;code&gt;@Inject&lt;/code&gt; instead of &lt;code&gt;@Autowired&lt;/code&gt; which is javaee standard supported by Spring. Every places it worked fine and the beans injected correctly, instead of one place. The bean injection seems the same</source>
          <target state="translated">我们使用 &lt;code&gt;@Inject&lt;/code&gt; 而不是Spring支持的Javaee标准 &lt;code&gt;@Autowired&lt;/code&gt; 。 每个地方都能正常工作，并且bean正确注入，而不是一个地方。 豆子注射似乎一样</target>
        </trans-unit>
        <trans-unit id="a22a650a6695b1cb52df04c214890311d5d9f32b" translate="yes" xml:space="preserve">
          <source>What hasn't been mentioned here is described in &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot;&gt;this&lt;/a&gt; article in the paragraph &quot;Order of execution&quot;.</source>
          <target state="translated">本文在&amp;ldquo;执行顺序&amp;rdquo;段落中描述了此处未提及的内容。</target>
        </trans-unit>
        <trans-unit id="c9351769f2d3fc8aed37c27cfba4d601a5fd919c" translate="yes" xml:space="preserve">
          <source>When I try to &lt;code&gt;GET /mileage/3&lt;/code&gt;, I get this exception:</source>
          <target state="translated">当我尝试 &lt;code&gt;GET /mileage/3&lt;/code&gt; ，出现以下异常：</target>
        </trans-unit>
        <trans-unit id="4a94711b9930ced50218f0105a49745e4e697dd7" translate="yes" xml:space="preserve">
          <source>Why is my Spring @Autowired field null</source>
          <target state="translated">为什么我的Spring @Autowired字段是空的?</target>
        </trans-unit>
        <trans-unit id="0355cb07b2fa9677429e730cb275eac228744309" translate="yes" xml:space="preserve">
          <source>With annotation &lt;code&gt;@Service&lt;/code&gt;, &lt;code&gt;@Component&lt;/code&gt;, &lt;code&gt;@Configuration&lt;/code&gt; beans are created in the</source>
          <target state="translated">使用注解 &lt;code&gt;@Service&lt;/code&gt; &lt;code&gt;@Component&lt;/code&gt; ， @Component ， @ &lt;code&gt;@Configuration&lt;/code&gt; Bean在</target>
        </trans-unit>
        <trans-unit id="e646deb97792a6ade92069b79676e29df55b56d7" translate="yes" xml:space="preserve">
          <source>You can also fix this issue using @Service annotation on service class and passing the required bean classA as a parameter to the other beans classB constructor and annotate the constructor of classB with @Autowired. Sample snippet here :</source>
          <target state="translated">你也可以在服务类上使用 @Service 注释来解决这个问题,并将所需的 bean classA 作为参数传递给其他 bean classB 构造函数,然后用 @Autowired 注释 classB 的构造函数。这里的示例片段。</target>
        </trans-unit>
        <trans-unit id="9d2bd3f9fbf79e8c120c81a56d52d033b5a518c7" translate="yes" xml:space="preserve">
          <source>You can put this code also in the main application class if you want.</source>
          <target state="translated">如果你愿意,你可以把这个代码也放在主程序类中。</target>
        </trans-unit>
        <trans-unit id="ca489fbd0a1b9070d098e10dcb1d2193bc0465c8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; on the configuration class of your spring application to instruct spring to scan.</source>
          <target state="translated">您可以在spring应用程序的配置类上使用 &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; 指示spring进行扫描。</target>
        </trans-unit>
        <trans-unit id="748d434e98b06abd0eecc728bee5795a1ecdb8c5" translate="yes" xml:space="preserve">
          <source>Your problem is new (object creation in java style)</source>
          <target state="translated">你的问题是新的(java风格的对象创建)。</target>
        </trans-unit>
        <trans-unit id="6097ca49faf78ea33ebe49e2de5a90e831a070dc" translate="yes" xml:space="preserve">
          <source>and SomeAbac class has a property declared as</source>
          <target state="translated">和SomeAbac类有一个属性声明为</target>
        </trans-unit>
        <trans-unit id="fe045fcc475b2ed5785570e3bf62d2af03225740" translate="yes" xml:space="preserve">
          <source>and in a &lt;code&gt;token.xml&lt;/code&gt; file I've had a line</source>
          <target state="translated">在 &lt;code&gt;token.xml&lt;/code&gt; 文件中，我有一行</target>
        </trans-unit>
        <trans-unit id="8f184f10becfd5255e7dd174b71f596e5ed826d2" translate="yes" xml:space="preserve">
          <source>and it works. May be someone can provide an explanation, but for me it's enough right now )</source>
          <target state="translated">和它的工作。也许有人可以提供一个解释,但对我来说,现在已经足够了)</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="83e983915573bdd6a6a5428e20d4237c9b28e9f9" translate="yes" xml:space="preserve">
          <source>application context of Spring when server is started. But when we create objects 
    using new operator the object is not registered in  application context which  is already created. For Example Employee.java class i have used.</source>
          <target state="translated">当服务器启动时,Spring的应用程序上下文中注册了一个对象。但是,当我们使用new操作符创建对象时,对象没有在已经创建的应用上下文中注册。例如,我使用了Employee.java类。</target>
        </trans-unit>
        <trans-unit id="8f777ca7518e37a243e3d63d7566fe9cd2f615f1" translate="yes" xml:space="preserve">
          <source>for some unknown reason, settings is &lt;em&gt;null&lt;/em&gt; in init(), when &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; element is not present at all, but when it's present and has some bs as a basePackage, everything works well. This line now looks like this:</source>
          <target state="translated">由于某些未知的原因，当 &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; 元素根本不存在时，init（）中的设置为&lt;em&gt;null&lt;/em&gt; ，但是当它存在并且具有b作为basePackage时，一切正常。 这行现在看起来像这样：</target>
        </trans-unit>
        <trans-unit id="d5db4151b6088246e47fd7448b54cae44fc44c85" translate="yes" xml:space="preserve">
          <source>so it won't work that way.</source>
          <target state="translated">所以,它不会这样工作。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
