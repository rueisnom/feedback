<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/19896870">
    <body>
      <group id="19896870">
        <trans-unit id="394b57ab44493bad9e13375faca2da97306afe8c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;The Spring Inversion of Control (IoC) container&lt;/a&gt; has three main logical components: a registry (called the &lt;code&gt;ApplicationContext&lt;/code&gt;) of components (beans) that are available to be used by the application, a configurer system that injects objects' dependencies into them by matching up the dependencies with beans in the context, and a dependency solver that can look at a configuration of many different beans and determine how to instantiate and configure them in the necessary order.</source>
          <target state="translated">&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html&quot;&gt;IoC (Spring Inversion of Control) 컨테이너&lt;/a&gt; 에는 3 가지 주요 논리 구성 요소가 있습니다. 응용 프로그램에서 사용할 수있는 구성 요소 (beans)의 레지스트리 ( &lt;code&gt;ApplicationContext&lt;/code&gt; 라고 함), 일치하여 오브젝트의 종속성을 주입하는 구성자 시스템 컨텍스트에서 Bean과의 종속성 및 여러 다른 Bean의 구성을보고 필요한 순서로 인스턴스화하고 구성하는 방법을 결정할 수있는 종속성 솔버.</target>
        </trans-unit>
        <trans-unit id="1ae06b30b6d1c782656a2208ccb72d7333701bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@Service, @Component&lt;/code&gt; etc annotations add meta description.</source>
          <target state="translated">&lt;code&gt;@Service, @Component&lt;/code&gt; 등의 주석은 메타 설명을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a70bff0ba394cef82c27ca682d50f21c90605937" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I'm new to Spring, but I discovered this working solution. Please tell me if it's a deprecable way.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;나는 Spring을 처음 사용하지만이 작업 솔루션을 발견했습니다.&lt;/em&gt; &lt;em&gt;그것이 혐오스러운 방법인지 알려주세요.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac07e8cc2813a62fa38fad476b41fdaaca46ef7a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is intended to be a canonical answer for a common problem.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 이것은 일반적인 문제에 대한 정식 답변입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b7fb549b54ec58659fd74cbdd78e77c0e0493806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ORIGINAL ANSWER:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;원래 답변 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f981fb4e08e95e60895db03be2fe27045a89932" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE FIELD IS NOT A BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 분야는 독이 아닙니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c63b5f6bebe122bb768741b030b15d8683140f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by injecting the &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt;&lt;code&gt;working-inject-bean&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;@MileageFeeCalculator&lt;/code&gt; 서비스 객체를 주입하여 작동하는 태그 : &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-inject-bean&quot;&gt; &lt;code&gt;working-inject-bean&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ece2ffe683fc87cb97657a6c77b083b990d1adf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by manually looking up the service object in the Spring context: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt;&lt;code&gt;working-manual-lookup&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Spring 컨텍스트에서 서비스 오브젝트를 수동으로 조회하여 작동하는 태그 : &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-manual-lookup&quot;&gt; &lt;code&gt;working-manual-lookup&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ee91e9a00165f2f5a170963a6a33b134695cf84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tag that works by using &lt;code&gt;@Configurable&lt;/code&gt; on the service object: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt;&lt;code&gt;working-configurable&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;서비스 객체에서 &lt;code&gt;@Configurable&lt;/code&gt; 을 사용하여 작동하는 태그 : &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/working-configurable&quot;&gt; &lt;code&gt;working-configurable&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="774dd712670d211631d8f90f0cee69e58e4015a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt; Really smart people were quick to point on &lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;this&lt;/a&gt; answer, which explains the weirdness, described below</source>
          <target state="translated">&lt;strong&gt;업데이트 :&lt;/strong&gt; 실제로 똑똑한 사람들은 &lt;a href=&quot;https://stackoverflow.com/a/13177782/2583044&quot;&gt;이&lt;/a&gt; 답변을 신속하게 지적하여 아래 설명 된 이상한 점을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="343f2555b3fe8817306d09a16f4d9c002d898197" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YOUR CLASS IS NOT A  SPRING BEAN.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;수업은 봄이 아닙니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="013573a8c9d74642d1e8e6d7631446a204fef372" translate="yes" xml:space="preserve">
          <source>Actually, you should use either JVM managed Objects or Spring-managed Object to invoke methods.
from your above code in your controller class, you are creating a new object to call your service class which has an auto-wired object.</source>
          <target state="translated">실제로 JVM 관리 객체 또는 스프링 관리 객체를 사용하여 메소드를 호출해야합니다. 컨트롤러 클래스의 위 코드에서 자동 유선 객체가있는 서비스 클래스를 호출하는 새 객체를 만들고 있습니다.</target>
        </trans-unit>
        <trans-unit id="17e5fa0456b0b310229eb43f4b0714169ea19cff" translate="yes" xml:space="preserve">
          <source>Adding annotation only, does not fix or facilitate the dependency injection, Spring needs to know where to look for.</source>
          <target state="translated">주석 만 추가하고 의존성 주입을 수정하거나 촉진하지는 않습니다. Spring은 어디를 찾아야하는지 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="57be7d302f1b2ff8eef279015d9880539858b846" translate="yes" xml:space="preserve">
          <source>After &quot;learning&quot; that I had to annotate a class with @Component or the derivatives @Service or @Repository (I guess there are more), to autowire other components inside them, it struck me that these other components still were null inside the constructor of the parent component.</source>
          <target state="translated">@Component 또는 파생 된 @Service 또는 @Repository 클래스에 주석을 달아야한다는 &quot;학습&quot;후에 (더 많은 것이있을 것 같음) 그 안에 다른 컴포넌트를 자동 와이어 링하기 위해 이러한 다른 컴포넌트가 여전히 생성자 내부에 널 (null) 인 것을 발견했습니다. 부모 구성 요소의</target>
        </trans-unit>
        <trans-unit id="41fc58409cda1816c0d86da0328ade7c51269de3" translate="yes" xml:space="preserve">
          <source>Also note that if, for whatever reason, you make a method in a &lt;code&gt;@Service&lt;/code&gt; as &lt;code&gt;final&lt;/code&gt;, the autowired beans you will access from it will always be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">또한 어떤 이유로 든 &lt;code&gt;@Service&lt;/code&gt; 에서 &lt;code&gt;final&lt;/code&gt; 로 메소드를 작성하면 액세스하는 자동 유선 Bean은 항상 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e62f46e6b944ff55852b8bd59d0add7902a8d67" translate="yes" xml:space="preserve">
          <source>And after that, NPE started coming in. In a &lt;code&gt;pep-config.xml&lt;/code&gt; I had just 2 beans:</source>
          <target state="translated">그리고 나서 NPE가 들어 오기 시작했습니다. &lt;code&gt;pep-config.xml&lt;/code&gt; 에는 2 개의 빈만 있었습니다.</target>
        </trans-unit>
        <trans-unit id="ec68cc24f685999a1deb5d39824c5936e0df4e7d" translate="yes" xml:space="preserve">
          <source>Another solution would be putting call:
&lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt;</source>
          <target state="translated">또 다른 해결책은 &lt;code&gt;SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this)&lt;/code&gt; 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5c2f41f414dfb43d22eb44abecd6879c5950ea1c" translate="yes" xml:space="preserve">
          <source>At last we found that the error was that we (actually, the Eclipse auto complete feature) imported &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; instead of &lt;code&gt;javax.inject.Inject&lt;/code&gt; !</source>
          <target state="translated">마침내 우리는 (실제로는 Eclipse 자동 완성 기능) &lt;code&gt;javax.inject.Inject&lt;/code&gt; 대신 &lt;code&gt;com.opensymphony.xwork2.Inject&lt;/code&gt; 를 가져 왔다는 오류가 발견 되었습니다 !</target>
        </trans-unit>
        <trans-unit id="d94d761d0a782bc648563729db0ab5861e158fd2" translate="yes" xml:space="preserve">
          <source>Change your Controller class like below.</source>
          <target state="translated">아래와 같이 컨트롤러 클래스를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="7ba406818c8f1055e3ce7bbdb75cfb6882131af8" translate="yes" xml:space="preserve">
          <source>Check this out:</source>
          <target state="translated">이것 좀 봐:</target>
        </trans-unit>
        <trans-unit id="d230873b60b53c384e2144ccb234383174838a29" translate="yes" xml:space="preserve">
          <source>Classes marked with annotation need to be identified by spring before injecting, &lt;code&gt;@ComponentScan&lt;/code&gt; instruct spring look for the classes marked with annotation. When Spring finds &lt;code&gt;@Autowired&lt;/code&gt; it searches for the related bean, and injects the required instance.</source>
          <target state="translated">&lt;code&gt;@ComponentScan&lt;/code&gt; 은 스프링이 주석으로 표시된 클래스를 찾도록 지시하기 위해 주석이 표시된 클래스를 주입하기 전에 스프링으로 식별해야합니다. Spring이 &lt;code&gt;@Autowired&lt;/code&gt; 를 찾으면 관련 Bean을 검색하고 필요한 인스턴스를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="b83c98c8abe52ca04318bc946ddb1f41bf28da5e" translate="yes" xml:space="preserve">
          <source>Controller class:</source>
          <target state="translated">컨트롤러 클래스 :</target>
        </trans-unit>
        <trans-unit id="72e876a8da98d0fdec73e4e6b97838b88035189f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;@SpringBootTest&lt;/code&gt; to work stand alone, you need to use &lt;code&gt;@Test&lt;/code&gt; from &lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit5 instead of JUnit4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@SpringBootTest&lt;/code&gt; 가 독립적 으로 작동하려면 &lt;a href=&quot;https://stackoverflow.com/q/48853312&quot;&gt;JUnit4 대신 JUnit5의&lt;/a&gt; &lt;code&gt;@Test&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac65d99b8c551d6eafac33e561e4dde92e51d8d7" translate="yes" xml:space="preserve">
          <source>For example, in &lt;strong&gt;Spring Boot&lt;/strong&gt;:</source>
          <target state="translated">예를 들어 &lt;strong&gt;Spring Boot에서&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f6ca09ba5cd1826f082b5fb7aab89b84c2c8faa7" translate="yes" xml:space="preserve">
          <source>I don't know if it helps anyone, but I was stuck with the same problem even while doing things seemingly right. In my Main method, I have a code like this:</source>
          <target state="translated">그것이 누군가에게 도움이되는지 모르겠지만, 겉보기에는 옳은 일을하는 동안에도 같은 문제가 발생했습니다. 내 Main 메서드에는 다음과 같은 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="290aab609060c87e3330711b7a475560a5a08290" translate="yes" xml:space="preserve">
          <source>I have a Spring &lt;code&gt;@Service&lt;/code&gt; class (&lt;code&gt;MileageFeeCalculator&lt;/code&gt;) that has an &lt;code&gt;@Autowired&lt;/code&gt; field (&lt;code&gt;rateService&lt;/code&gt;), but the field is &lt;code&gt;null&lt;/code&gt; when I try to use it. The logs show that both the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; bean and the &lt;code&gt;MileageRateService&lt;/code&gt; bean are being created, but I get a &lt;code&gt;NullPointerException&lt;/code&gt; whenever I try to call the &lt;code&gt;mileageCharge&lt;/code&gt; method on my service bean. Why isn't Spring autowiring the field?</source>
          <target state="translated">&lt;code&gt;@Autowired&lt;/code&gt; 필드 ( &lt;code&gt;rateService&lt;/code&gt; )가있는 Spring &lt;code&gt;@Service&lt;/code&gt; 클래스 ( &lt;code&gt;MileageFeeCalculator&lt;/code&gt; )가 있지만 사용하려고하면 필드가 &lt;code&gt;null&lt;/code&gt; 입니다. 로그는 &lt;code&gt;MileageFeeCalculator&lt;/code&gt; Bean과 &lt;code&gt;MileageRateService&lt;/code&gt; Bean이 모두 작성되고 있음을 보여 주지만 서비스 Bean에서 &lt;code&gt;mileageCharge&lt;/code&gt; 메소드를 호출하려고 할 때마다 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다. Spring이 왜 필드를 자동 배선하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="4d81e527154a800d280587cbded9d3aad6e0b819" translate="yes" xml:space="preserve">
          <source>I have posted all of this code, using Spring Boot to launch, at &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;this GitHub project&lt;/a&gt;; you can look at a full running project for each approach to see everything you need to make it work. &lt;strong&gt;Tag with the &lt;code&gt;NullPointerException&lt;/code&gt;: &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt;&lt;code&gt;nonworking&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example&quot;&gt;이 GitHub 프로젝트&lt;/a&gt; 에서 Spring Boot를 사용하여이 코드를 모두 게시 했습니다 . 각 접근 방식에 대해 전체 실행 프로젝트를보고 작동에 필요한 모든 것을 볼 수 있습니다. &lt;strong&gt; &lt;code&gt;NullPointerException&lt;/code&gt; 이있는 태그 : &lt;a href=&quot;https://github.com/chrylis/spring_autowired_npe_example/tree/nonworking&quot;&gt; &lt;code&gt;nonworking&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a28c8ad27d6ac9d92801b7c7616da199741fee8" translate="yes" xml:space="preserve">
          <source>I make Spring inject &lt;code&gt;applicationContext&lt;/code&gt; in this bean:</source>
          <target state="translated">이 빈에 Spring 주입 &lt;code&gt;applicationContext&lt;/code&gt; 를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9d7deec7709d1e237f060b3e6cae162dde1f065a" translate="yes" xml:space="preserve">
          <source>I noticed that the package.path does no longer exist, so I've just dropped the line for good.</source>
          <target state="translated">package.path가 더 이상 존재하지 않음을 알았으므로 방금 줄을 삭제했습니다.</target>
        </trans-unit>
        <trans-unit id="acaef4085e64a02688aad3db5d1923dfe9e86ead" translate="yes" xml:space="preserve">
          <source>I once encountered the same issue when I was not quite used to &lt;code&gt;the life in the IoC world&lt;/code&gt;. The &lt;code&gt;@Autowired&lt;/code&gt; field of one of my beans is null at runtime.</source>
          <target state="translated">나는 &lt;code&gt;the life in the IoC world&lt;/code&gt; 익숙하지 않을 때 같은 문제에 직면했다. 내 Bean 중 하나의 &lt;code&gt;@Autowired&lt;/code&gt; 필드가 런타임에 널입니다.</target>
        </trans-unit>
        <trans-unit id="d4f5aca2a7ed0b7166b5ed31cd0d48496a56e4c5" translate="yes" xml:space="preserve">
          <source>I think you have missed to instruct spring to scan classes with annotation.</source>
          <target state="translated">봄에 주석이있는 클래스를 스캔하도록 지시하는 것을 놓친 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6f1ec927b26cd65fdaaa4ddf91e84e5652ed241" translate="yes" xml:space="preserve">
          <source>If this is happening in a test class, make sure you haven't forgotten to annotate the class.</source>
          <target state="translated">테스트 수업에서 이런 일이 발생하면 수업에 주석을 달지 않은 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f517ef786825d3bc62a16f6307b66a8ef2849b27" translate="yes" xml:space="preserve">
          <source>If you are not coding a web application, make sure your class in which @Autowiring is done is a spring bean. Typically, spring container won't be aware of the class which we might think of as a spring bean. We have to tell the Spring container about our spring classes.</source>
          <target state="translated">웹 애플리케이션을 코딩하지 않는 경우 @Autowiring이 수행되는 클래스가 스프링 빈인지 확인하십시오. 일반적으로 스프링 컨테이너는 우리가 스프링 빈으로 생각할 수있는 클래스를 인식하지 못합니다. 스프링 클래스에 대해 스프링 컨테이너에 알려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="4210a615a7a8e9cf17363c2ebfcc8af5476ec05a" translate="yes" xml:space="preserve">
          <source>If you are writing unit test make sure you are not creating object using &lt;code&gt;new object()&lt;/code&gt;. Use instead injectMock.</source>
          <target state="translated">단위 테스트를 작성하는 경우 &lt;code&gt;new object()&lt;/code&gt; 사용하여 객체를 작성하지 않아야합니다. 대신 injectMock을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e1b2ce47c7a4f14dbdd6d84b8fe65d5309868f7e" translate="yes" xml:space="preserve">
          <source>If you get this configuration wrong your tests will compile, but &lt;code&gt;@Autowired&lt;/code&gt; and &lt;code&gt;@Value&lt;/code&gt; fields (for example) will be &lt;code&gt;null&lt;/code&gt;.  Since Spring Boot operates by magic, you may have few avenues for directly debugging this failure.</source>
          <target state="translated">이 구성이 잘못되면 테스트가 컴파일되지만 &lt;code&gt;@Autowired&lt;/code&gt; 및 &lt;code&gt;@Value&lt;/code&gt; 필드 (예 :) 는 &lt;code&gt;null&lt;/code&gt; 입니다. Spring Boot는 마술로 작동하기 때문에이 오류를 직접 디버깅 할 수있는 방법이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c1b72872b08c510fda6dfeaed1dcb63e25fcc5d" translate="yes" xml:space="preserve">
          <source>If you need to create a new instance of your service object for different requests, you can still use injection by using &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;the Spring bean scopes&lt;/a&gt;.</source>
          <target state="translated">다른 요청에 대해 서비스 오브젝트의 새 인스턴스를 작성해야하는 경우 &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes&quot;&gt;Spring Bean 범위를&lt;/a&gt; 사용하여 여전히 주입을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f44484492dfecd22e18b5bd83804f19ec3019b8" translate="yes" xml:space="preserve">
          <source>If you really need objects created with &lt;code&gt;new&lt;/code&gt; to be autowired, you can &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;use the Spring &lt;code&gt;@Configurable&lt;/code&gt; annotation along with AspectJ compile-time weaving&lt;/a&gt; to inject your objects. This approach inserts code into your object's constructor that alerts Spring that it's being created so that Spring can configure the new instance. This requires a bit of configuration in your build (such as compiling with &lt;code&gt;ajc&lt;/code&gt;) and turning on Spring's runtime configuration handlers (&lt;code&gt;@EnableSpringConfigured&lt;/code&gt; with the JavaConfig syntax). This approach is used by the Roo Active Record system to allow &lt;code&gt;new&lt;/code&gt; instances of your entities to get the necessary persistence information injected.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 로 작성된 객체를 자동으로 와이어 링해야하는 경우 &lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-atconfigurable&quot;&gt;AspectJ 컴파일 타임 위빙과 함께 Spring &lt;code&gt;@Configurable&lt;/code&gt; 주석을 사용&lt;/a&gt; 하여 객체를 주입 할 수 있습니다. 이 접근법은 Spring이 새 인스턴스를 구성 할 수 있도록 Spring이 작성되고 있음을 경고하는 코드를 객체의 생성자에 삽입합니다. 이것은 빌드에서 약간의 구성 (예 : &lt;code&gt;ajc&lt;/code&gt; 로 컴파일)과 Spring의 런타임 구성 핸들러 (JavaConfig 구문으로 &lt;code&gt;@EnableSpringConfigured&lt;/code&gt; ) 를 켜야 합니다. 이 접근법은 Roo Active Record 시스템에서 사용되어 엔티티의 &lt;code&gt;new&lt;/code&gt; 인스턴스가 필요한 지속성 정보를 주입 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="8dc718c58fb367fa7f99b778de29f6511c238cfc" translate="yes" xml:space="preserve">
          <source>In simple words there are mainly two reasons for an &lt;code&gt;@Autowired&lt;/code&gt; field to be &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">간단히 말해서 &lt;code&gt;@Autowired&lt;/code&gt; 필드가 &lt;code&gt;null&lt;/code&gt; 인 이유는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1fa06015977d4bb62501850a732d535c515f902" translate="yes" xml:space="preserve">
          <source>In this way &lt;strong&gt;any bean can be obtained by any object in the application&lt;/strong&gt; (also intantiated with &lt;code&gt;new&lt;/code&gt;) and &lt;strong&gt;in a static way&lt;/strong&gt;.</source>
          <target state="translated">이런 식으로 &lt;strong&gt;응용 프로그램의 모든 객체&lt;/strong&gt; ( &lt;code&gt;new&lt;/code&gt; &lt;strong&gt;객체로&lt;/strong&gt; 도 구현 됨)와 &lt;strong&gt;정적 방식으로&lt;/strong&gt; &lt;strong&gt;Bean을 얻을 수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fee4af12fa524c1a7940448312eebdd0a757e15d" translate="yes" xml:space="preserve">
          <source>Inject your beans</source>
          <target state="translated">콩을 주입</target>
        </trans-unit>
        <trans-unit id="c56453903ed805219ab7d905bfb3d9194b146484" translate="yes" xml:space="preserve">
          <source>It seems to be rare case but here is what happened to me:</source>
          <target state="translated">드문 경우이지만 여기에 나에게 일어난 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="81362fff4d639337528a9b83ac93d07b4c8831f8" translate="yes" xml:space="preserve">
          <source>Manual bean lookup: not recommended</source>
          <target state="translated">수동 Bean 조회 : 권장하지 않음</target>
        </trans-unit>
        <trans-unit id="15d38dff68d219829bee6302f049d493d93ad283" translate="yes" xml:space="preserve">
          <source>My Service class had an annotation of service and it was &lt;code&gt;@autowired&lt;/code&gt; another component class. When I tested the component class was coming null. Because for service class I was creating the object using &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">내 서비스 클래스에 서비스 주석이 &lt;code&gt;@autowired&lt;/code&gt; 다른 구성 요소 클래스를 @autowired 했습니다. 테스트 할 때 구성 요소 클래스가 null이되었습니다. 서비스 클래스의 경우 &lt;code&gt;new&lt;/code&gt; 를 사용하여 객체를 만들고 있었기 때문에</target>
        </trans-unit>
        <trans-unit id="4163f897a2b6918d5bcba8024e27a75a21262caa" translate="yes" xml:space="preserve">
          <source>Other classes can use it like this:</source>
          <target state="translated">다른 클래스는 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a7cfd642fc22c1d2461573908ac9a588902de4" translate="yes" xml:space="preserve">
          <source>Service bean that should be autowired in &lt;code&gt;MileageFeeCalculator&lt;/code&gt; but it isn't:</source>
          <target state="translated">&lt;code&gt;MileageFeeCalculator&lt;/code&gt; 에서 자동 연결되어야 하지만 그렇지 않은 서비스 Bean :</target>
        </trans-unit>
        <trans-unit id="8a5f1e0fe0b1effd67db55ae23df2f6cc081647a" translate="yes" xml:space="preserve">
          <source>Service class:</source>
          <target state="translated">서비스 클래스 :</target>
        </trans-unit>
        <trans-unit id="b45858b98095f901fc99c8338155a5faac0efb3c" translate="yes" xml:space="preserve">
          <source>So to summarize, make sure that your annotations (&lt;code&gt;@Autowired&lt;/code&gt;, &lt;code&gt;@Inject&lt;/code&gt;, &lt;code&gt;@Service&lt;/code&gt; ,... ) have correct packages!</source>
          <target state="translated">요약하면 주석 ( &lt;code&gt;@Autowired&lt;/code&gt; , &lt;code&gt;@Inject&lt;/code&gt; , &lt;code&gt;@Service&lt;/code&gt; , ...)에 올바른 패키지가 있는지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="3239365d583a95875a43f9f065681b250601c3cc" translate="yes" xml:space="preserve">
          <source>Some time elapses...</source>
          <target state="translated">시간이 지나면 ...</target>
        </trans-unit>
        <trans-unit id="185f0371245faa8bbe1b174c71c3c16fe0b0cf16" translate="yes" xml:space="preserve">
          <source>Spring Boot &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;continues to evolve&lt;/a&gt;.  It is no longer required to use &lt;code&gt;@RunWith&lt;/code&gt;&lt;em&gt;if you use the correct version of JUnit&lt;/em&gt;.</source>
          <target state="translated">스프링 부트 &lt;a href=&quot;https://spring.io/blog/2016/04/15/testing-improvements-in-spring-boot-1-4&quot;&gt;는 계속 발전하고&lt;/a&gt; 있습니다. &lt;em&gt;올바른 JUnit 버전을 사용하는 경우&lt;/em&gt; 더 이상 &lt;code&gt;@RunWith&lt;/code&gt; 를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="859e7a96ec1ad84e49569265bcd589ac37498e71" translate="yes" xml:space="preserve">
          <source>Spring only injects instances of those classes which are either created as bean or marked with annotation.</source>
          <target state="translated">Spring은 Bean으로 작성되거나 주석으로 표시된 클래스의 인스턴스 만 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="b198e9188ffed25cac4c321fdc9e545886b5c39f" translate="yes" xml:space="preserve">
          <source>The IoC container isn't magic, and it has no way of knowing about Java objects unless you somehow inform it of them. When you call &lt;code&gt;new&lt;/code&gt;, the JVM instantiates a copy of the new object and hands it straight to you--it never goes through the configuration process. There are three ways that you can get your beans configured.</source>
          <target state="translated">IoC 컨테이너는 마법이 아니며 Java 객체에 대해 알려주지 않는 한 Java 객체를 알 수있는 방법이 없습니다. &lt;code&gt;new&lt;/code&gt; 를 호출하면 JVM이 새 객체의 사본을 인스턴스화하여 바로 전달합니다. 구성 프로세스를 거치지 않습니다. Bean을 구성 할 수있는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="289f38a4a85aa5b9a3c5b59180313674628783cd" translate="yes" xml:space="preserve">
          <source>The field annotated &lt;code&gt;@Autowired&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; because Spring doesn't know about the copy of &lt;code&gt;MileageFeeCalculator&lt;/code&gt; that you created with &lt;code&gt;new&lt;/code&gt; and didn't know to autowire it.</source>
          <target state="translated">Spring이 &lt;code&gt;new&lt;/code&gt; 로 작성한 &lt;code&gt;MileageFeeCalculator&lt;/code&gt; 의 사본을 알지 못하기 때문에 &lt;code&gt;@Autowired&lt;/code&gt; 로 주석이 달린 필드는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17cafeacf0e3808d318c6c7dab584d668bff3de5" translate="yes" xml:space="preserve">
          <source>The most preferable option is to let Spring autowire all of your beans; this requires the least amount of code and is the most maintainable. To make the autowiring work like you wanted, also autowire the &lt;code&gt;MileageFeeCalculator&lt;/code&gt; like this:</source>
          <target state="translated">가장 바람직한 옵션은 Spring이 모든 빈을 자동으로 연결하도록하는 것입니다. 이것은 가장 적은 양의 코드를 요구하며 가장 유지 보수가 용이합니다. 원하는대로 &lt;code&gt;MileageFeeCalculator&lt;/code&gt; 하려면 다음 과 같이 MileageFeeCalculator를 자동 연결 하십시오.</target>
        </trans-unit>
        <trans-unit id="7525865b1f3cf4afe5b64057e41c714903c82bb4" translate="yes" xml:space="preserve">
          <source>The root cause is, instead of using the auto-created bean maintained by the Spring IoC container (whose &lt;code&gt;@Autowired&lt;/code&gt; field is &lt;code&gt;indeed&lt;/code&gt; properly injected), I am &lt;code&gt;newing&lt;/code&gt; my own instance of that bean type and using it. Of course this one's &lt;code&gt;@Autowired&lt;/code&gt; field is null because Spring has no chance to inject it.</source>
          <target state="translated">근본적인 원인은 Spring IoC 컨테이너에 의해 유지 관리되는 자동 생성 된 Bean ( &lt;code&gt;@Autowired&lt;/code&gt; 필드가 &lt;code&gt;indeed&lt;/code&gt; 올바르게 주입 됨)을 사용하는 대신 해당 Bean 유형의 자체 인스턴스를 &lt;code&gt;newing&lt;/code&gt; 하여 사용하는 것입니다. 물론 이것은 Spring이 그것을 주입 할 기회가 없기 때문에 &lt;code&gt;@Autowired&lt;/code&gt; 필드는 null입니다.</target>
        </trans-unit>
        <trans-unit id="5ab338c160a06915539afb8ea6a40782d023e2a0" translate="yes" xml:space="preserve">
          <source>The solution makes this MileageFeeCalculator as an auto-wired object in the Controller itself.</source>
          <target state="translated">이 솔루션은이 MileageFeeCalculator를 컨트롤러 자체의 자동 유선 객체로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a918b75229c39b7362467ef9574f8a999ad37470" translate="yes" xml:space="preserve">
          <source>Then your legacy code can call &lt;code&gt;getContext()&lt;/code&gt; and retrieve the beans it needs:</source>
          <target state="translated">그런 다음 레거시 코드는 &lt;code&gt;getContext()&lt;/code&gt; 호출하고 필요한 Bean을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5445ba25a7eb16ffe83bc73d081a07998d9071" translate="yes" xml:space="preserve">
          <source>This approach is suitable only for interfacing with legacy code in special situations. It is nearly always preferable to create a singleton adapter class that Spring can autowire and the legacy code can call, but it is possible to directly ask the Spring application context for a bean.</source>
          <target state="translated">이 방법은 특별한 상황에서 레거시 코드와의 인터페이스에만 적합합니다. Spring이 자동 와이어 링하고 레거시 코드가 호출 할 수있는 싱글 톤 어댑터 클래스를 작성하는 것이 거의 항상 바람직하지만 Spring 애플리케이션 컨텍스트에 Bean을 직접 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2564b58e68e65ff5e059a30fb59c75588cf998f" translate="yes" xml:space="preserve">
          <source>This can be achieved by configuring in appln-contxt or &lt;strong&gt;the better way&lt;/strong&gt; is to annotate class as &lt;strong&gt;@Component&lt;/strong&gt; and please do not create the annotated class using new operator.
Make sure you get it from Appln-context as below.</source>
          <target state="translated">appln-contxt에서 구성하여 얻을 수 있거나 클래스에 &lt;strong&gt;@Component&lt;/strong&gt; 로 주석을 달고 &lt;strong&gt;더 나은 방법&lt;/strong&gt; 은 새 연산자를 사용하여 주석이 달린 클래스를 만들지 마십시오. 아래와 같이 Appln-context에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="cba84fb3a576f1982a7a4e89a35adfcdcd86b573" translate="yes" xml:space="preserve">
          <source>This fixed my issue. Here is a useful &lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;link&lt;/a&gt;</source>
          <target state="translated">이것은 내 문제를 해결했습니다. 유용한 &lt;a href=&quot;https://www.moreofless.co.uk/spring-mvc-java-autowired-component-null-repository-service/&quot;&gt;링크&lt;/a&gt; 는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="fd42e9c07834066aba16496cc46ca18618d98be0" translate="yes" xml:space="preserve">
          <source>This is only valid in case of Unit test.</source>
          <target state="translated">이것은 유닛 테스트의 경우에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c3bf31c57b1da3cd7be0fd57b9c4bbbf09272a68" translate="yes" xml:space="preserve">
          <source>This is the culprit of giving NullPointerException &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; We are using Spring - don't need to create object manually. Object creation will be taken care of by IoC container.</source>
          <target state="translated">이것은 NullPointerException을주는 원인입니다 &lt;code&gt;MileageFeeCalculator calc = new MileageFeeCalculator();&lt;/code&gt; 우리는 Spring을 사용하고 있습니다-수동으로 객체를 만들 필요가 없습니다. 객체 생성은 IoC 컨테이너에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f056c0834db33a952b9af4a4a12e11c7ce780a22" translate="yes" xml:space="preserve">
          <source>To MileageFeeCalculator constructor like this:</source>
          <target state="translated">MileageFeeCalculator 생성자에게 다음과 같이 :</target>
        </trans-unit>
        <trans-unit id="a415fb8c7eebe85e5542348eaa6368fe99ef4ebd" translate="yes" xml:space="preserve">
          <source>To do this, you need a class to which Spring can give a reference to the &lt;code&gt;ApplicationContext&lt;/code&gt; object:</source>
          <target state="translated">이를 위해서는 Spring이 &lt;code&gt;ApplicationContext&lt;/code&gt; 객체에 대한 참조를 제공 할 수있는 클래스가 필요하다.</target>
        </trans-unit>
        <trans-unit id="712bd4ea7182b2392287b9cba31f1c58a4f995c7" translate="yes" xml:space="preserve">
          <source>Use @Configurable</source>
          <target state="translated">@Configurable 사용</target>
        </trans-unit>
        <trans-unit id="b4de62676a8e2ba66f6e67603bb1ab327f963c2d" translate="yes" xml:space="preserve">
          <source>Using @PostConstruct solves that:</source>
          <target state="translated">@PostConstruct를 사용하면 다음을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="814e53b54fffcd1ab97e69af5ec501e8ca6cd377" translate="yes" xml:space="preserve">
          <source>We used &lt;code&gt;@Inject&lt;/code&gt; instead of &lt;code&gt;@Autowired&lt;/code&gt; which is javaee standard supported by Spring. Every places it worked fine and the beans injected correctly, instead of one place. The bean injection seems the same</source>
          <target state="translated">Spring이 지원하는 javaee 표준 인 &lt;code&gt;@Autowired&lt;/code&gt; 대신 &lt;code&gt;@Inject&lt;/code&gt; 를 사용했습니다. 모든 장소는 잘 작동했고 콩은 한곳이 아닌 올바르게 주입되었습니다. 콩 주입은 같은 것</target>
        </trans-unit>
        <trans-unit id="a22a650a6695b1cb52df04c214890311d5d9f32b" translate="yes" xml:space="preserve">
          <source>What hasn't been mentioned here is described in &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot;&gt;this&lt;/a&gt; article in the paragraph &quot;Order of execution&quot;.</source>
          <target state="translated">여기에 언급되지 않은 내용은 &lt;a href=&quot;https://technology.amis.nl/2018/02/22/java-how-to-fix-spring-autowired-annotation-not-working-issues/&quot;&gt;이&lt;/a&gt; 기사에서 &quot;실행 명령&quot;단락에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9351769f2d3fc8aed37c27cfba4d601a5fd919c" translate="yes" xml:space="preserve">
          <source>When I try to &lt;code&gt;GET /mileage/3&lt;/code&gt;, I get this exception:</source>
          <target state="translated">&lt;code&gt;GET /mileage/3&lt;/code&gt; 얻으려고 할 때이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4a94711b9930ced50218f0105a49745e4e697dd7" translate="yes" xml:space="preserve">
          <source>Why is my Spring @Autowired field null</source>
          <target state="translated">Spring @Autowired 필드가 왜 null입니까?</target>
        </trans-unit>
        <trans-unit id="0355cb07b2fa9677429e730cb275eac228744309" translate="yes" xml:space="preserve">
          <source>With annotation &lt;code&gt;@Service&lt;/code&gt;, &lt;code&gt;@Component&lt;/code&gt;, &lt;code&gt;@Configuration&lt;/code&gt; beans are created in the</source>
          <target state="translated">&lt;code&gt;@Service&lt;/code&gt; , &lt;code&gt;@Component&lt;/code&gt; 주석을 사용하면 &lt;code&gt;@Configuration&lt;/code&gt; Bean이</target>
        </trans-unit>
        <trans-unit id="e646deb97792a6ade92069b79676e29df55b56d7" translate="yes" xml:space="preserve">
          <source>You can also fix this issue using @Service annotation on service class and passing the required bean classA as a parameter to the other beans classB constructor and annotate the constructor of classB with @Autowired. Sample snippet here :</source>
          <target state="translated">서비스 클래스에서 @Service 어노테이션을 사용하고 필요한 Bean classA를 다른 Bean classB 생성자에 매개 변수로 전달하고 @Autowired로 classB의 생성자에 주석을 달 수도 있습니다. 샘플 스 니펫은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d2bd3f9fbf79e8c120c81a56d52d033b5a518c7" translate="yes" xml:space="preserve">
          <source>You can put this code also in the main application class if you want.</source>
          <target state="translated">원하는 경우이 코드를 기본 응용 프로그램 클래스에도 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca489fbd0a1b9070d098e10dcb1d2193bc0465c8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; on the configuration class of your spring application to instruct spring to scan.</source>
          <target state="translated">스프링 애플리케이션의 구성 클래스에서 &lt;code&gt;@ComponentScan(&quot;packageToScan&quot;)&lt;/code&gt; 을 사용하여 스프링이 스캔하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="748d434e98b06abd0eecc728bee5795a1ecdb8c5" translate="yes" xml:space="preserve">
          <source>Your problem is new (object creation in java style)</source>
          <target state="translated">당신의 문제는 새로운 것입니다 (자바 스타일의 객체 생성)</target>
        </trans-unit>
        <trans-unit id="6097ca49faf78ea33ebe49e2de5a90e831a070dc" translate="yes" xml:space="preserve">
          <source>and SomeAbac class has a property declared as</source>
          <target state="translated">SomeAbac 클래스에는 다음과 같이 선언 된 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe045fcc475b2ed5785570e3bf62d2af03225740" translate="yes" xml:space="preserve">
          <source>and in a &lt;code&gt;token.xml&lt;/code&gt; file I've had a line</source>
          <target state="translated">&lt;code&gt;token.xml&lt;/code&gt; 파일에는 줄이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f184f10becfd5255e7dd174b71f596e5ed826d2" translate="yes" xml:space="preserve">
          <source>and it works. May be someone can provide an explanation, but for me it's enough right now )</source>
          <target state="translated">작동합니다. 누군가가 설명을 제공 할 수는 있지만 지금은 충분합니다.)</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="83e983915573bdd6a6a5428e20d4237c9b28e9f9" translate="yes" xml:space="preserve">
          <source>application context of Spring when server is started. But when we create objects 
    using new operator the object is not registered in  application context which  is already created. For Example Employee.java class i have used.</source>
          <target state="translated">서버가 시작될 때 Spring의 애플리케이션 컨텍스트. 그러나 new 연산자를 사용하여 객체를 만들면 이미 만들어진 응용 프로그램 컨텍스트에 객체가 등록되지 않습니다. 예를 들어 Employee.java 클래스를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="8f777ca7518e37a243e3d63d7566fe9cd2f615f1" translate="yes" xml:space="preserve">
          <source>for some unknown reason, settings is &lt;em&gt;null&lt;/em&gt; in init(), when &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; element is not present at all, but when it's present and has some bs as a basePackage, everything works well. This line now looks like this:</source>
          <target state="translated">알 수없는 이유로 &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; 요소가 전혀없는 경우 init ()에서 설정이 &lt;em&gt;null&lt;/em&gt; 이지만, 존재하고 basePackage로 bs가 있으면 모든 것이 잘 작동합니다. 이 줄은 이제 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="d5db4151b6088246e47fd7448b54cae44fc44c85" translate="yes" xml:space="preserve">
          <source>so it won't work that way.</source>
          <target state="translated">그렇게 작동하지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
