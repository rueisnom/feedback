<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/40471">
    <body>
      <group id="40471">
        <trans-unit id="1ffa479b2bc81d3a4bfacc7ab2a3c758037edec2" translate="yes" xml:space="preserve">
          <source>*The aforementioned improvement has not been applied to &lt;code&gt;Hashtable&lt;/code&gt; yet, but only to &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;LinkedHashMap&lt;/code&gt;, and &lt;code&gt;ConcurrentHashMap&lt;/code&gt;.</source>
          <target state="translated">* La mejora antes mencionada a&amp;uacute;n no se ha aplicado a &lt;code&gt;Hashtable&lt;/code&gt; , sino solo a &lt;code&gt;HashMap&lt;/code&gt; , &lt;code&gt;LinkedHashMap&lt;/code&gt; y &lt;code&gt;ConcurrentHashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bebecfc307c9e1b712693d3b764211b8ed5cfb2" translate="yes" xml:space="preserve">
          <source>1) First difference is HashMap is not thread safe While HashTable is ThreadSafe</source>
          <target state="translated">1)La primera diferencia es que HashMap no es seguro para los hilos mientras que HashTable es seguro para los hilos</target>
        </trans-unit>
        <trans-unit id="e93948b799e95b7508984d1cffb6e8a3f9844579" translate="yes" xml:space="preserve">
          <source>1) Hashtable and Hashmap implement the java.util.Map interface
2) Both Hashmap and Hashtable is the hash based collection. and working on hashing.
so these are similarity of HashMap and HashTable.</source>
          <target state="translated">1)Hashtable y Hashmap implementan la interfaz java.util.Map 2)Tanto Hashmap como Hashtable es la colección basada en el hash.y trabajando en el hash.así que son similares a HashMap y HashTable.</target>
        </trans-unit>
        <trans-unit id="ce8ad15ae4892952ca56baaa8baaa429494f2e53" translate="yes" xml:space="preserve">
          <source>1.&lt;code&gt;Hashmap&lt;/code&gt; and &lt;code&gt;HashTable&lt;/code&gt; both store key and value.</source>
          <target state="translated">1. &lt;code&gt;Hashmap&lt;/code&gt; y &lt;code&gt;HashTable&lt;/code&gt; almacenan clave y valor.</target>
        </trans-unit>
        <trans-unit id="ea022165e8aaef91c12ccef2e5123b0265799db7" translate="yes" xml:space="preserve">
          <source>2) HashMap is performance wise better because it is not thread safe. while Hashtable performance wise is not better because it is thread safe. so multiple thread can not access Hashtable at the same time.</source>
          <target state="translated">2)HashMap es mejor en cuanto al rendimiento porque no es seguro para los hilos.mientras que el rendimiento de Hashtable no es mejor porque es seguro para los hilos.así que varios hilos no pueden acceder a Hashtable al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="2a896733be888d07b7cbb8186abb374063e45bdd" translate="yes" xml:space="preserve">
          <source>2.&lt;code&gt;Hashmap&lt;/code&gt; can store one key as &lt;code&gt;null&lt;/code&gt;. &lt;code&gt;Hashtable&lt;/code&gt; can't store &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">2. &lt;code&gt;Hashmap&lt;/code&gt; puede almacenar una clave como &lt;code&gt;null&lt;/code&gt; . &lt;code&gt;Hashtable&lt;/code&gt; no puede almacenar &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02a8a35731189356741a2efc879bda9c331af5d6" translate="yes" xml:space="preserve">
          <source>3.&lt;code&gt;HashMap&lt;/code&gt; is not synchronized but &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">3. &lt;code&gt;HashMap&lt;/code&gt; no est&amp;aacute; sincronizado pero &lt;code&gt;Hashtable&lt;/code&gt; est&amp;aacute; sincronizado.</target>
        </trans-unit>
        <trans-unit id="7edecd9abb3471db7df504cd6c5936311ca4fa46" translate="yes" xml:space="preserve">
          <source>4.&lt;code&gt;HashMap&lt;/code&gt; can be synchronized with &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt;</source>
          <target state="translated">4. &lt;code&gt;HashMap&lt;/code&gt; se puede sincronizar con &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8772653c67ec1de6492448fff19367167e54b515" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is a legacy class in the jdk that shouldn't be used anymore. Replace usages of it with &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt;. If you don't require thread safety, use &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; which isn't &lt;a href=&quot;http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/concurrent/ThreadSafe.html&quot;&gt;threadsafe&lt;/a&gt; but faster and uses less memory.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; es una clase heredada en el jdk que ya no deber&amp;iacute;a usarse. Reemplace sus usos con &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; . Si no necesita seguridad para subprocesos, use &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap,&lt;/a&gt; que no es &lt;a href=&quot;http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/concurrent/ThreadSafe.html&quot;&gt;seguro para subprocesos&lt;/a&gt; pero es m&amp;aacute;s r&amp;aacute;pido y usa menos memoria.</target>
        </trans-unit>
        <trans-unit id="a8212855afbfdfadf4f72d52f3fd51313aab01da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is synchronized, if you are using it in a single thread you can use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, which is an unsynchronized version. Unsynchronized objects are often a little more performant. By the way if multiple threads access a HashMap concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. 
Youn can wrap a unsynchronized map in a synchronized one using :</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; est&amp;aacute; sincronizado, si lo est&amp;aacute; usando en un solo hilo, puede usar &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; , que es una versi&amp;oacute;n no sincronizada. Los objetos no sincronizados son a menudo un poco m&amp;aacute;s efectivos. Por cierto, si varios subprocesos acceden a un HashMap simult&amp;aacute;neamente, y al menos uno de los subprocesos modifica el mapa estructuralmente, debe sincronizarse externamente. Youn puede envolver un mapa no sincronizado en uno sincronizado usando:</target>
        </trans-unit>
        <trans-unit id="35825761ff3e0e6aae7c813dc0f469fe68798cf4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; is a fail-fast in nature. i.e it throws ConcurrentModificationException if a collection is modified while iterating other than it&amp;rsquo;s own remove() method. Where as &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt;&lt;code&gt;Enumeration&lt;/code&gt;&lt;/a&gt; is fail-safe in nature. It doesn&amp;rsquo;t throw any exceptions if a collection is modified while iterating.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; es de naturaleza r&amp;aacute;pida. es decir, arroja ConcurrentModificationException si una colecci&amp;oacute;n se modifica mientras itera de otra manera que no sea su propio m&amp;eacute;todo remove (). Donde como &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt; &lt;code&gt;Enumeration&lt;/code&gt; &lt;/a&gt; es a prueba de fallas en la naturaleza. No arroja ninguna excepci&amp;oacute;n si una colecci&amp;oacute;n se modifica durante la iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6f5224599c22155916dabf87bba49566ddaa6261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows maximum one null key and any number of null values. Where as &lt;code&gt;Hashtable&lt;/code&gt; doesn&amp;rsquo;t allow even a single null key and null value, if the key or value null is then it throws NullPointerException. &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;Example&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; permite un m&amp;aacute;ximo de una clave nula y cualquier n&amp;uacute;mero de valores nulos. Donde como &lt;code&gt;Hashtable&lt;/code&gt; no permite ni una sola clave nula y un valor nulo, si la clave o el valor nulo es entonces arroja NullPointerException. &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;Ejemplo&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a5083b226eeb51dc40cc10003425a58b158f81eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows one null key and multiple null values.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; permite una clave nula y m&amp;uacute;ltiples valores nulos.</target>
        </trans-unit>
        <trans-unit id="669df6fbbd3ba9c388deaba3fc0849ca8f6f2ff6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; both are used to store &lt;em&gt;data in key and value form&lt;/em&gt;. Both are using hashing technique to store unique keys.
But there are many differences between HashMap and Hashtable classes that are given below.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; y &lt;code&gt;Hashtable&lt;/code&gt; se usan para almacenar &lt;em&gt;datos en forma de clave y valor&lt;/em&gt; . Ambos utilizan la t&amp;eacute;cnica de hashing para almacenar claves &amp;uacute;nicas. Pero hay muchas diferencias entre las clases HashMap y Hashtable que se dan a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0ac053a124fba70f26ef444ee7553d0c4785af36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; have significant algorithmic differences as well. No one has mentioned this before so that's why I am bringing it up. &lt;code&gt;HashMap&lt;/code&gt; will construct a hash table with power of two size, increase it dynamically such that you have at most about eight elements (collisions) in any bucket and will stir the elements very well for general element types. However, the &lt;code&gt;Hashtable&lt;/code&gt; implementation provides better and finer control over the hashing if you know what you are doing, namely you can fix the table size using e.g. the closest prime number to your values domain size and this will result in better performance than HashMap i.e. less collisions for some cases.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; y &lt;code&gt;Hashtable&lt;/code&gt; tambi&amp;eacute;n tienen diferencias algor&amp;iacute;tmicas significativas. Nadie ha mencionado esto antes, por eso lo menciono. &lt;code&gt;HashMap&lt;/code&gt; construir&amp;aacute; una tabla hash con una potencia de dos tama&amp;ntilde;os, la aumentar&amp;aacute; din&amp;aacute;micamente de modo que tenga como m&amp;aacute;ximo unos ocho elementos (colisiones) en cualquier dep&amp;oacute;sito y agitar&amp;aacute; los elementos muy bien para los tipos de elementos generales. Sin embargo, la implementaci&amp;oacute;n de &lt;code&gt;Hashtable&lt;/code&gt; proporciona un control mejor y m&amp;aacute;s fino sobre el hash si sabe lo que est&amp;aacute; haciendo, es decir, puede arreglar el tama&amp;ntilde;o de la tabla utilizando, por ejemplo, el n&amp;uacute;mero primo m&amp;aacute;s cercano al tama&amp;ntilde;o de su dominio de valores y esto dar&amp;aacute; como resultado un mejor rendimiento que HashMap, es decir, menos colisiones para algunos casos.</target>
        </trans-unit>
        <trans-unit id="64a17134b1046d668dd05ac2bc4f97f06a63e76e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; can be synchronized by</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; puede ser sincronizado por</target>
        </trans-unit>
        <trans-unit id="d500b59660957bd4381ff369b93e82d00b9b1f70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; no garantiza que el orden del mapa se mantendr&amp;aacute; constante a lo largo del tiempo.</target>
        </trans-unit>
        <trans-unit id="a8747ab7f19811c92ec840fe23f10d94ab4b3af3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; inherits AbstractMap class.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; hereda la clase AbstractMap.</target>
        </trans-unit>
        <trans-unit id="51fbe655ee9bcf724b8cabf41a90881d14820a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is a new class introduced in JDK 1.2.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; es una nueva clase introducida en JDK 1.2.</target>
        </trans-unit>
        <trans-unit id="b63a85d53f021a1ae8dd8bdd08fdc18c2b28c4cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is emulated and therefore usable in &lt;code&gt;GWT client code&lt;/code&gt; whereas &lt;code&gt;Hashtable&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; se emula y, por lo tanto, se puede usar en el &lt;code&gt;GWT client code&lt;/code&gt; mientras que &lt;code&gt;Hashtable&lt;/code&gt; no.</target>
        </trans-unit>
        <trans-unit id="8910e4452555bc0eb462a108515a97d9c3f5b62a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is fast.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; es r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="0ac323b983cb93bfa96d446a6acf3e0739d49b02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized whereas &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; no est&amp;aacute; sincronizado, mientras que &lt;code&gt;Hashtable&lt;/code&gt; est&amp;aacute; sincronizado.</target>
        </trans-unit>
        <trans-unit id="15bf5350ece84dd8e38bde89e4f666c4333d494b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized. It is not-thread safe and can't be shared between many threads without proper synchronization code.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; no est&amp;aacute; sincronizado. No es seguro para subprocesos y no se puede compartir entre muchos subprocesos sin un c&amp;oacute;digo de sincronizaci&amp;oacute;n adecuado.</target>
        </trans-unit>
        <trans-unit id="7eecfc386a9ddceaa10ba8c78194cc8417a8cc62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is traversed by Iterator.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; es atravesado por Iterator.</target>
        </trans-unit>
        <trans-unit id="8697ca59be21a2145ac021e93da6593a2e482b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; permits null values in it, while &lt;code&gt;Hashtable&lt;/code&gt; doesn't.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; permite valores nulos en &amp;eacute;l, mientras que &lt;code&gt;Hashtable&lt;/code&gt; no.</target>
        </trans-unit>
        <trans-unit id="ce244b309892513fef48b0c0adb960eea745a513" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt;: An implementation of the &lt;code&gt;Map&lt;/code&gt; interface that uses hash codes to index an array.
&lt;code&gt;Hashtable&lt;/code&gt;: Hi, 1998 called. They want their collections API back.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; : una implementaci&amp;oacute;n de la interfaz de &lt;code&gt;Map&lt;/code&gt; que utiliza c&amp;oacute;digos hash para indexar una matriz. &lt;code&gt;Hashtable&lt;/code&gt; : Hola, 1998 llamado. Quieren recuperar sus API de colecciones.</target>
        </trans-unit>
        <trans-unit id="aea1fdd84192f7fc2e196adf40609942cb1285de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; does not allow &lt;code&gt;null&lt;/code&gt; keys or values.  &lt;code&gt;HashMap&lt;/code&gt; allows one &lt;code&gt;null&lt;/code&gt; key and any number of &lt;code&gt;null&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; no permite claves o valores &lt;code&gt;null&lt;/code&gt; . &lt;code&gt;HashMap&lt;/code&gt; permite una clave &lt;code&gt;null&lt;/code&gt; y cualquier n&amp;uacute;mero de valores &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da40767d527c7d8ee16fe1095a3c28313aaec00a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; doesn't allow any null key or value.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; no permite ninguna clave o valor nulo.</target>
        </trans-unit>
        <trans-unit id="e82d9c21537b4430e511e19537f8747613296279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; inherits Dictionary class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; hereda la clase Dictionary.</target>
        </trans-unit>
        <trans-unit id="473a8e23134d11e4c9e6a5a24f60baccffe8cd5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is &lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;synchronized&lt;/a&gt;, whereas &lt;code&gt;HashMap&lt;/code&gt; is not. This makes &lt;code&gt;HashMap&lt;/code&gt; better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; est&amp;aacute; &lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;sincronizado&lt;/a&gt; , mientras que &lt;code&gt;HashMap&lt;/code&gt; no. Esto hace que &lt;code&gt;HashMap&lt;/code&gt; sea ​​mejor para aplicaciones sin subprocesos, ya que los Objetos no sincronizados generalmente funcionan mejor que los sincronizados.</target>
        </trans-unit>
        <trans-unit id="5f3b80ed3c8119e05343a43fa58d178aa8c248fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is a legacy class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; es una clase heredada.</target>
        </trans-unit>
        <trans-unit id="74522ed93d3ffc34a0d85038cae726b8c4697227" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is considered legacy code. There's nothing about &lt;code&gt;Hashtable&lt;/code&gt; that can't be done using &lt;code&gt;HashMap&lt;/code&gt; or derivations of &lt;code&gt;HashMap&lt;/code&gt;, so for new code, I don't see any justification for going back to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; se considera c&amp;oacute;digo heredado. No hay nada sobre &lt;code&gt;Hashtable&lt;/code&gt; que no se pueda hacer usando &lt;code&gt;HashMap&lt;/code&gt; o derivaciones de &lt;code&gt;HashMap&lt;/code&gt; , as&amp;iacute; que para el nuevo c&amp;oacute;digo, no veo ninguna justificaci&amp;oacute;n para volver a &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="582981ade6fd1fb874a7cbaa7d7f669287851433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized and can't be unsynchronized.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; se sincroniza internamente y no se puede desincronizar.</target>
        </trans-unit>
        <trans-unit id="5b50d2071547d1d8f01971f3564947ceb026e758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized. Therefore, it is very much safe to use &lt;code&gt;Hashtable&lt;/code&gt; in multi threaded applications. Where as &lt;code&gt;HashMap&lt;/code&gt; is not internally synchronized. Therefore, it is not safe to use &lt;code&gt;HashMap&lt;/code&gt; in multi threaded applications without external synchronization. You can externally synchronize &lt;code&gt;HashMap&lt;/code&gt; using &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; est&amp;aacute; sincronizado internamente. Por lo tanto, es muy seguro usar &lt;code&gt;Hashtable&lt;/code&gt; en aplicaciones de subprocesos m&amp;uacute;ltiples. Donde como &lt;code&gt;HashMap&lt;/code&gt; no est&amp;aacute; sincronizado internamente. Por lo tanto, no es seguro usar &lt;code&gt;HashMap&lt;/code&gt; en aplicaciones multiproceso sin sincronizaci&amp;oacute;n externa. Puede sincronizar externamente &lt;code&gt;HashMap&lt;/code&gt; utilizando el m&amp;eacute;todo &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e63c856b660603f278bb16d5b114de8a3272ed31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is similar to the &lt;code&gt;HashMap&lt;/code&gt; and has a similar interface. It is recommended that you use &lt;code&gt;HashMap&lt;/code&gt;, unless you require support for legacy applications or you need synchronisation, as the &lt;code&gt;Hashtables&lt;/code&gt; methods are synchronised. So in your case as you are not multi-threading, &lt;code&gt;HashMaps&lt;/code&gt; are your best bet.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; es similar a &lt;code&gt;HashMap&lt;/code&gt; y tiene una interfaz similar. Se recomienda que use &lt;code&gt;HashMap&lt;/code&gt; , a menos que necesite soporte para aplicaciones heredadas o necesite sincronizaci&amp;oacute;n, ya que los m&amp;eacute;todos de &lt;code&gt;Hashtables&lt;/code&gt; est&amp;aacute;n sincronizados. Entonces, en su caso, ya que no es multihilo, &lt;code&gt;HashMaps&lt;/code&gt; es su mejor opci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="6eaefd6be9ca644fb4dceef1106f715e6f13ce69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is slow.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; es lento.</target>
        </trans-unit>
        <trans-unit id="ad27eec131dd51571006c484e66faa0226c0bffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized whereas &lt;code&gt;HashMap&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; est&amp;aacute; sincronizado, mientras que &lt;code&gt;HashMap&lt;/code&gt; no lo est&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="25f83877d4ac62b168713576f58b2770a86b5aad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized, whereas &lt;code&gt;HashMap&lt;/code&gt; isn't. That makes &lt;code&gt;Hashtable&lt;/code&gt; slower than &lt;code&gt;Hashmap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; est&amp;aacute; sincronizado, mientras que &lt;code&gt;HashMap&lt;/code&gt; no lo est&amp;aacute;. Eso hace que &lt;code&gt;Hashtable&lt;/code&gt; sea ​​m&amp;aacute;s lento que &lt;code&gt;Hashmap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c596268109b66bf2934f50af140575b7246bd11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized. It is thread-safe and can be shared with many threads.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; est&amp;aacute; sincronizado. Es seguro para subprocesos y se puede compartir con muchos subprocesos.</target>
        </trans-unit>
        <trans-unit id="7e53d6f6599341af744cd74547e079fc1d2c838b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is traversed by Enumerator and Iterator.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; es atravesado por Enumerator e Iterator.</target>
        </trans-unit>
        <trans-unit id="006d1c181f3c98522a669dc0abea34770eb93435" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; : if a bucket contains more than 8 nodes, the linked list is transformed into a balanced tree.</source>
          <target state="translated">&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; : si un dep&amp;oacute;sito contiene m&amp;aacute;s de 8 nodos, la lista vinculada se transforma en un &amp;aacute;rbol equilibrado.</target>
        </trans-unit>
        <trans-unit id="f9177115bae6161497db808e68ed7cd40b2d6acf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; : when a bucket becomes too small (due to removal or resizing) the tree is converted back to linked list.</source>
          <target state="translated">&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; : cuando un dep&amp;oacute;sito se vuelve demasiado peque&amp;ntilde;o (debido a la eliminaci&amp;oacute;n o al cambio de tama&amp;ntilde;o), el &amp;aacute;rbol se convierte nuevamente en una lista vinculada.</target>
        </trans-unit>
        <trans-unit id="1000b8e627d741fb5080e9ad2ab05068f01c96cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;Hashtable&lt;/code&gt; in case of hash collisions they store the map entries in linked lists. &lt;strong&gt;From Java8 for &lt;code&gt;HashMap&lt;/code&gt;&lt;/strong&gt; if hash bucket grows beyond a certain threshold, that bucket will switch from &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt;&lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt;&lt;/a&gt;. which improve worst-case performance from O(n) to O(log n). While converting the list to binary tree, hashcode is used as a branching variable. If there are two different hashcodes in the same bucket, one is considered bigger and goes to the right of the tree and other one to the left. But when both the hashcodes are equal, &lt;code&gt;HashMap&lt;/code&gt; assumes that the keys are comparable, and compares the key to determine the direction so that some order can be maintained. It is a good practice to make the keys of &lt;code&gt;HashMap&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;comparable&lt;/a&gt;. On adding entries if bucket size reaches &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; convert linked list of entries to a balanced tree, on removing entries less than &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt;  and at most &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; will reconvert  balanced tree to linked list of entries. &lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;stackpost&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;HashMap&lt;/code&gt; , &lt;code&gt;Hashtable&lt;/code&gt; en caso de colisiones hash, almacenan las entradas del mapa en listas vinculadas.&lt;/em&gt; &lt;em&gt;&lt;strong&gt;Desde Java8 para &lt;code&gt;HashMap&lt;/code&gt; ,&lt;/strong&gt; si el dep&amp;oacute;sito de hash crece m&amp;aacute;s all&amp;aacute; de cierto umbral, ese dep&amp;oacute;sito cambiar&amp;aacute; de una &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt; &lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt; &lt;/a&gt; .&lt;/em&gt; &lt;em&gt;que mejoran el rendimiento en el peor de los casos de O (n) a O (log n).&lt;/em&gt; &lt;em&gt;Al convertir la lista a &amp;aacute;rbol binario, el c&amp;oacute;digo hash se usa como una variable de ramificaci&amp;oacute;n.&lt;/em&gt; &lt;em&gt;Si hay dos c&amp;oacute;digos hash diferentes en el mismo cubo, uno se considera m&amp;aacute;s grande y va a la derecha del &amp;aacute;rbol y el otro a la izquierda.&lt;/em&gt; &lt;em&gt;Pero cuando ambos c&amp;oacute;digos hash son iguales, &lt;code&gt;HashMap&lt;/code&gt; asume que las claves son comparables y compara la clave para determinar la direcci&amp;oacute;n para que se pueda mantener un cierto orden.&lt;/em&gt; &lt;em&gt;Es una buena pr&amp;aacute;ctica hacer que las claves de &lt;code&gt;HashMap&lt;/code&gt; sean &lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;comparables&lt;/a&gt; .&lt;/em&gt; &lt;em&gt;Al agregar entradas si el tama&amp;ntilde;o de la cubeta alcanza &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; convierta la lista vinculada de entradas en un &amp;aacute;rbol equilibrado, al eliminar entradas inferiores a &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; y como m&amp;aacute;ximo &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; reconvertir&amp;aacute; el &amp;aacute;rbol equilibrado en una lista vinculada de entradas.&lt;/em&gt; &lt;em&gt;&lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;stackpost&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0126875eb118b7807444c7f8bd52e3d668a20cba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; &amp;mdash; sometimes called a container &amp;mdash; is simply an object that groups multiple elements into a single unit. &lt;code&gt;Collection&lt;/code&gt;s are used to store, retrieve, manipulate, and communicate aggregate data. A collections framework &lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt; is a unified architecture for representing and manipulating collections.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Una &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; , a veces llamada contenedor, es simplemente un objeto que agrupa m&amp;uacute;ltiples elementos en una sola unidad.&lt;/em&gt; &lt;em&gt; &lt;code&gt;Collection&lt;/code&gt; se utilizan para almacenar, recuperar, manipular y comunicar datos agregados.&lt;/em&gt; &lt;em&gt;Un marco de colecciones &lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt; es una arquitectura unificada para representar y manipular colecciones.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5371f8fa97eb824eece2c3e1f791dbb0a968b11d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HashMap constructs an empty hash table with the default initial capacity &lt;strong&gt;(16)&lt;/strong&gt; and the default load factor (0.75). Where as Hashtable constructs empty hashtable with a default initial capacity &lt;strong&gt;(11)&lt;/strong&gt; and load factor/fill ratio (0.75).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HashMap construye una tabla hash vac&amp;iacute;a con la capacidad inicial predeterminada &lt;strong&gt;(16)&lt;/strong&gt; y el factor de carga predeterminado (0.75).&lt;/em&gt; &lt;em&gt;Donde como Hashtable construye una tabla hash vac&amp;iacute;a con una capacidad inicial predeterminada &lt;strong&gt;(11)&lt;/strong&gt; y una relaci&amp;oacute;n factor de carga / llenado (0.75).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8dd40f98b719540fa3ef0929171c1d3bc9907016" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hashtable is a legacy class introduced in &lt;code&gt;JDK1.0&lt;/code&gt;, which is a subclass of Dictionary class. From &lt;code&gt;JDK1.2&lt;/code&gt; Hashtable is re-engineered to implement the &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;Map interface&lt;/a&gt; to make a member of collection framework. HashMap is a member of Java Collection Framework right from the beginning of its introduction in &lt;code&gt;JDK1.2&lt;/code&gt;. HashMap is the subclass of the AbstractMap class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Hashtable es una clase heredada introducida en &lt;code&gt;JDK1.0&lt;/code&gt; , que es una subclase de la clase Diccionario.&lt;/em&gt; &lt;em&gt;A partir de &lt;code&gt;JDK1.2&lt;/code&gt; , Hashtable se redise&amp;ntilde;&amp;oacute; para implementar la &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;interfaz de Mapa&lt;/a&gt; para que sea miembro del marco de recopilaci&amp;oacute;n.&lt;/em&gt; &lt;em&gt;HashMap es miembro de Java Collection Framework desde el comienzo de su introducci&amp;oacute;n en &lt;code&gt;JDK1.2&lt;/code&gt; .&lt;/em&gt; &lt;em&gt;HashMap es la subclase de la clase AbstractMap.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="500218975390156875accb6dbe2f354e3173f3e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a &quot;&lt;code&gt;hash&lt;/code&gt;&lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt;&lt;code&gt;collision&lt;/code&gt;&lt;/a&gt;&quot;, a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;La capacidad es el n&amp;uacute;mero de cubos en la tabla hash, y la capacidad inicial es simplemente la capacidad en el momento en que se crea la tabla hash.&lt;/em&gt; &lt;em&gt;Tenga en cuenta que la tabla hash est&amp;aacute; abierta: en el caso de una &quot; &lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt; &lt;code&gt;collision&lt;/code&gt; &lt;/a&gt; &lt;code&gt;hash&lt;/code&gt; &quot;, un &amp;uacute;nico dep&amp;oacute;sito almacena m&amp;uacute;ltiples entradas, que deben buscarse secuencialmente.&lt;/em&gt; &lt;em&gt;El factor de carga es una medida de cu&amp;aacute;n llena se permite que llegue la tabla hash antes de que su capacidad aumente autom&amp;aacute;ticamente.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b2906198844595f36fc6fa0dd97c9082d03f289b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Collection-view iteration, Fail-Fast and Fail-Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Repetici&amp;oacute;n de vista de colecci&amp;oacute;n, Fail-Fast y Fail-Safe&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7914abd8212625a168b15acf6950ab3c15a2effa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Initial capacity and Load factor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Capacidad inicial y factor de carga&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6993db023d391ae7cbb4cf066cfcb7e989bc8404" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Null Keys And Null Values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Claves nulas y valores nulos&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c20ec51a8964581feeee1ad7fb05fa002cf9687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7511967863d20bb8b4fe1260a05e4cb1bab41336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Structural modification in case of hash collision&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Modificaci&amp;oacute;n estructural en caso de colisi&amp;oacute;n de hash&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fe1bf3045a21d6736352a953873017484a6bc5ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Superclass, Legacy and Collection Framework member&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Miembro de Superclass, Legacy y Collection Framework&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="185ecb719c3e2e537438ec956fe6478e08b5fe09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Synchronized, Thread Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Sincronizado, hilo seguro&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ce5fccec3d4c3a9b001c5a415252b106c57db67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32a8a99aed109def0e75d162d6deb196e91238da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Like &lt;code&gt;Hashtable&lt;/code&gt; but unlike &lt;code&gt;HashMap&lt;/code&gt;, this class does not allow null to be used as a key or value.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Al igual que &lt;code&gt;Hashtable&lt;/code&gt; pero a diferencia de &lt;code&gt;HashMap&lt;/code&gt; , esta clase no permite que se use nulo como clave o valor.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8218937231a3c47bf14d75f244f490d51f3b93e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;Ejemplo&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="cebcd49ebbc8d28ef3e1865793fbff6f09d04c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap and HashTable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap y HashTable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c22768d0fd9bc69987104948fcbbae61922d34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46e9a015b499fca6a53da3a15919c4913909cfae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad1ee7e22808c3a788f0a1f004a79a0d59da5d9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt; is like &lt;strong&gt;Hashtable&lt;/strong&gt; but it also accepts key value pair. It allows null for both the keys and the values. Its performance better is better than &lt;code&gt;HashTable&lt;/code&gt;, because it is &lt;code&gt;unsynchronized&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt; es como &lt;strong&gt;Hashtable&lt;/strong&gt; pero tambi&amp;eacute;n acepta pares de valores clave. Permite nulo tanto para las claves como para los valores. Su rendimiento mejor es mejor que &lt;code&gt;HashTable&lt;/code&gt; , porque no est&amp;aacute; &lt;code&gt;unsynchronized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a8219969622a494e81fa636ffe2146fe95d705f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hashtable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3df875dc7fbdad1a94f31dde139d3c47b9695e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt; is a data structure that retains values of key-value pair. It doesn&amp;rsquo;t allow null for both the keys and the values. You will get a &lt;code&gt;NullPointerException&lt;/code&gt; if you add null value. It is synchronized. So it comes with its cost. Only one thread can access &lt;strong&gt;HashTable&lt;/strong&gt; at a particular time.</source>
          <target state="translated">&lt;strong&gt;Hashtable&lt;/strong&gt; es una estructura de datos que retiene los valores del par clave-valor. No permite nulo tanto para las claves como para los valores. Obtendr&amp;aacute; una &lt;code&gt;NullPointerException&lt;/code&gt; si agrega un valor nulo. Est&amp;aacute; sincronizado Entonces viene con su costo. Solo un hilo puede acceder a &lt;strong&gt;HashTable&lt;/strong&gt; en un momento particular.</target>
        </trans-unit>
        <trans-unit id="87f9eccd26b220f3fffdcc16c43e989775ffb9b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Therefore, always stay away from them in new code since there always better alternative in the JCF&lt;/strong&gt; as others had pointed out.</source>
          <target state="translated">&lt;strong&gt;Por lo tanto, siempre mant&amp;eacute;ngase alejado de ellos en el nuevo c&amp;oacute;digo, ya que siempre hay una mejor alternativa en el JCF&lt;/strong&gt; como otros han se&amp;ntilde;alado.</target>
        </trans-unit>
        <trans-unit id="25d50188019a6203506db4eaf255be67c2575b4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; No, they won't land in 1.8... :(</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n:&lt;/strong&gt; No, no aterrizar&amp;aacute;n en 1.8 ... :(</target>
        </trans-unit>
        <trans-unit id="dfb42b9b02e91bb8174c286bcbc7e89091ed670e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;b&gt;NOTE:&lt;/b&gt; The functionality of Enumeration interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;b&gt;NOTA:&lt;/b&gt; La funcionalidad de la interfaz Enumeration est&amp;aacute; duplicada por la interfaz Iterator.&lt;/sub&gt; &lt;sub&gt;Adem&amp;aacute;s, Iterator agrega una operaci&amp;oacute;n de eliminaci&amp;oacute;n opcional y tiene nombres de m&amp;eacute;todo m&amp;aacute;s cortos.&lt;/sub&gt; &lt;sub&gt;Las nuevas implementaciones deber&amp;iacute;an considerar usar Iterator en lugar de Enumeration.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="ac2433b57b2a782b71863cba68f09953ec4c0263" translate="yes" xml:space="preserve">
          <source>@See</source>
          <target state="translated">@See</target>
        </trans-unit>
        <trans-unit id="6b37ea03133b5dc642ccd5644d5b2ef41cc8ea38" translate="yes" xml:space="preserve">
          <source>A red&amp;ndash;black tree is a kind of self-balancing binary search tree</source>
          <target state="translated">Un &amp;aacute;rbol rojo-negro es una especie de &amp;aacute;rbol de b&amp;uacute;squeda binaria con equilibrio autom&amp;aacute;tico</target>
        </trans-unit>
        <trans-unit id="084f214b26afe2233736dea659b6712cd361bbee" translate="yes" xml:space="preserve">
          <source>A very common idiom is to &quot;check then put&quot; &amp;mdash; i.e. look for an entry in the &lt;code&gt;Map&lt;/code&gt;, and add it if it does not already exist. This is not in any way an atomic operation whether you use &lt;code&gt;Hashtable&lt;/code&gt; or &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Un modismo muy com&amp;uacute;n es &quot;verificar luego poner&quot;, es decir, buscar una entrada en el &lt;code&gt;Map&lt;/code&gt; a y agregarla si a&amp;uacute;n no existe. Esto no es de ninguna manera una operaci&amp;oacute;n at&amp;oacute;mica, ya sea que use &lt;code&gt;Hashtable&lt;/code&gt; o &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ef3449d808edb36ce53bb89ce36fe2cd8e8058d" translate="yes" xml:space="preserve">
          <source>According to Java API Docs, Iterator is always preferred over the Enumeration.</source>
          <target state="translated">De acuerdo con los documentos de la API de Java,siempre se prefiere el Iterator a la Enumeración.</target>
        </trans-unit>
        <trans-unit id="7b526b4ffbef0a933328ce463df2d1cd68dd7c44" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Hashtable&lt;/code&gt; extends the &lt;code&gt;Dictionary&lt;/code&gt; class, which as the &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocs&lt;/a&gt; state, is obsolete and has been replaced by the &lt;code&gt;Map&lt;/code&gt; interface.</source>
          <target state="translated">Tambi&amp;eacute;n tenga en cuenta que &lt;code&gt;Hashtable&lt;/code&gt; extiende la clase &lt;code&gt;Dictionary&lt;/code&gt; , que como el estado de &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocs&lt;/a&gt; , est&amp;aacute; obsoleta y ha sido reemplazada por la interfaz &lt;code&gt;Map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f187c58c90f9a43256314abab97119abc44122e" translate="yes" xml:space="preserve">
          <source>An equivalently synchronised &lt;code&gt;HashMap&lt;/code&gt; can be obtained by:</source>
          <target state="translated">Se puede obtener un &lt;code&gt;HashMap&lt;/code&gt; sincronizado de manera equivalente mediante:</target>
        </trans-unit>
        <trans-unit id="e9103e37fff0521b7c39be1ecc0df1aeeea1dd2b" translate="yes" xml:space="preserve">
          <source>Another difference is that iterator in the &lt;code&gt;HashMap&lt;/code&gt; is fail-safe
while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; isn't. If you change the map
while iterating, you'll know.</source>
          <target state="translated">Otra diferencia es que el iterador en &lt;code&gt;HashMap&lt;/code&gt; es a prueba de fallas mientras que el enumerador para &lt;code&gt;Hashtable&lt;/code&gt; no lo es. Si cambia el mapa mientras itera, lo sabr&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="acee8a439f9e4944ad00c1a48c53ef2a93e9d1fe" translate="yes" xml:space="preserve">
          <source>Another key difference between hashtable and hashmap is that Iterator in the HashMap is  fail-fast  while the enumerator for the Hashtable is not and throw ConcurrentModificationException if any other Thread modifies the map structurally  by adding or removing any element except Iterator's own remove()  method. But this is not a guaranteed behavior and will be done by JVM on best effort.&quot;</source>
          <target state="translated">Otra diferencia clave entre hashtable y hashmap es que Iterator en el HashMap es rápido en fallar mientras que el enumerador para el Hashtable no lo es y lanza ConcurrentModificationException si cualquier otro Thread modifica el mapa estructuralmente añadiendo o quitando cualquier elemento excepto el propio método remove()de Iterator.Pero este no es un comportamiento garantizado y será hecho por la JVM con el mejor esfuerzo.&quot;</target>
        </trans-unit>
        <trans-unit id="9a3708be3084838c9add3ab49ecf14e2a1b70039" translate="yes" xml:space="preserve">
          <source>Apart from the differences already mentioned, it should be noted that since Java 8, &lt;code&gt;HashMap&lt;/code&gt; dynamically replaces the Nodes (linked list) used in each bucket with TreeNodes (red-black tree), so that even if high hash collisions exist, the worst case &lt;em&gt;when searching&lt;/em&gt; is</source>
          <target state="translated">Adem&amp;aacute;s de las diferencias ya mencionadas, debe tenerse en cuenta que desde Java 8, &lt;code&gt;HashMap&lt;/code&gt; reemplaza din&amp;aacute;micamente los nodos (lista vinculada) utilizados en cada cubo con TreeNodes (&amp;aacute;rbol rojo-negro), de modo que incluso si existen colisiones de hash altas, el peor de los casos &lt;em&gt;cuando la b&amp;uacute;squeda&lt;/em&gt; es</target>
        </trans-unit>
        <trans-unit id="835ac593a034529b8d59e5594146aeee9100a895" translate="yes" xml:space="preserve">
          <source>Are Project Coin's collection enhancements going to be in JDK8?</source>
          <target state="translated">¿Las mejoras de la colección del Proyecto Moneda van a estar en JDK8?</target>
        </trans-unit>
        <trans-unit id="91975686e2264b305fe313101bec221ece54fee0" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized, this makes &lt;code&gt;Hashtable&lt;/code&gt; slightly slower than the &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Como &lt;code&gt;Hashtable&lt;/code&gt; est&amp;aacute; sincronizado internamente, esto hace que &lt;code&gt;Hashtable&lt;/code&gt; sea ​​un poco m&amp;aacute;s lento que &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86480f222192a446b1ab808c5920c537dfc97134" translate="yes" xml:space="preserve">
          <source>Based on the info &lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;here&lt;/a&gt;, I'd recommend going with HashMap.  I think the biggest advantage is that Java will prevent you from modifying it while you are iterating over it, unless you do it through the iterator.</source>
          <target state="translated">Seg&amp;uacute;n la informaci&amp;oacute;n &lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;aqu&amp;iacute;&lt;/a&gt; , recomiendo ir con HashMap. Creo que la mayor ventaja es que Java evitar&amp;aacute; que lo modifiques mientras lo iteras, a menos que lo hagas a trav&amp;eacute;s del iterador.</target>
        </trans-unit>
        <trans-unit id="d0a56f41ce29c24403b973ae8e801eead605fafd" translate="yes" xml:space="preserve">
          <source>Beside all the other important aspects already mentioned here, Collections API (e.g. Map interface) is being modified all the time to conform to the &quot;latest and greatest&quot; additions to Java spec.</source>
          <target state="translated">Además de todos los demás aspectos importantes ya mencionados aquí,la API de las colecciones (por ejemplo,la interfaz de los mapas)se está modificando todo el tiempo para ajustarse a las &quot;últimas y mayores&quot; adiciones a las especificaciones de Java.</target>
        </trans-unit>
        <trans-unit id="883db36727c6fc674b9af62ca03268fec3a2fc5d" translate="yes" xml:space="preserve">
          <source>Blog by Manish Chhabra</source>
          <target state="translated">Blog de Manish Chhabra</target>
        </trans-unit>
        <trans-unit id="161ee3e5332fc7ada8de95c3e13e87513aefb405" translate="yes" xml:space="preserve">
          <source>But to correctly implement this logic you need &lt;strong&gt;additional synchronisation&lt;/strong&gt; of the form:</source>
          <target state="translated">Pero para implementar correctamente esta l&amp;oacute;gica, necesita &lt;strong&gt;sincronizaci&amp;oacute;n adicional&lt;/strong&gt; del formulario:</target>
        </trans-unit>
        <trans-unit id="701dc0240892c2e16f792b706d048825cd15ef02" translate="yes" xml:space="preserve">
          <source>Differences between HashMap and Hashtable</source>
          <target state="translated">Diferencias entre HashMap y Hashtable</target>
        </trans-unit>
        <trans-unit id="3df089853d91c18fa4e328324d91b136000d4c1a" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;HashMapEntry&lt;/code&gt;s value is &lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;volatile&lt;/a&gt; thereby ensuring fine grain consistency for contended modifications and subsequent reads; each read reflects the most recently completed update</source>
          <target state="translated">El valor de cada &lt;code&gt;HashMapEntry&lt;/code&gt; es &lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;vol&amp;aacute;til,&lt;/a&gt; lo que garantiza una consistencia de grano fino para modificaciones contenidas y lecturas posteriores; cada lectura refleja la actualizaci&amp;oacute;n completada m&amp;aacute;s recientemente</target>
        </trans-unit>
        <trans-unit id="74b2e0a75cd7cb287224f128b35087ba9f24b35c" translate="yes" xml:space="preserve">
          <source>Enumerator in &lt;code&gt;Hashtable&lt;/code&gt; is not fail-fast.</source>
          <target state="translated">El enumerador en &lt;code&gt;Hashtable&lt;/code&gt; no es r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="ada4c28c6e7bcc1c37b1f37cd28e11b4c21a0d85" translate="yes" xml:space="preserve">
          <source>Even iterating over a &lt;code&gt;Hashtable&lt;/code&gt;'s entries (or a &lt;code&gt;HashMap&lt;/code&gt; obtained by &lt;code&gt;Collections.synchronizedMap&lt;/code&gt;) is not thread safe unless you also guard the &lt;code&gt;Map&lt;/code&gt; from being modified through additional synchronization.</source>
          <target state="translated">Incluso iterar sobre las entradas de un &lt;code&gt;Hashtable&lt;/code&gt; (o un &lt;code&gt;HashMap&lt;/code&gt; obtenido por &lt;code&gt;Collections.synchronizedMap&lt;/code&gt; ) no es seguro para subprocesos a menos que tambi&amp;eacute;n evite que el &lt;code&gt;Map&lt;/code&gt; a se modifique mediante una sincronizaci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="aef57bb24b9645fae322828e390476f8cb44301e" translate="yes" xml:space="preserve">
          <source>FYI, currently,</source>
          <target state="translated">Para tu información,actualmente,</target>
        </trans-unit>
        <trans-unit id="65e3d605f886f039cefd6fcaa6b0600199f9e6cb" translate="yes" xml:space="preserve">
          <source>Fail-safe is relevant within the context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object &quot;structurally&quot;, a concurrent modification exception will be thrown. It is possible for other threads though to invoke &lt;code&gt;set&lt;/code&gt; method since it doesn't modify the collection &quot;structurally&quot;. However, if prior to calling &lt;code&gt;set&lt;/code&gt;, the collection has been modified structurally, &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">Fail-safe es relevante dentro del contexto de los iteradores. Si se ha creado un iterador en un objeto de colecci&amp;oacute;n y alg&amp;uacute;n otro hilo intenta modificar el objeto de colecci&amp;oacute;n &quot;estructuralmente&quot;, se lanzar&amp;aacute; una excepci&amp;oacute;n de modificaci&amp;oacute;n concurrente. Sin embargo, es posible que otros subprocesos invoquen el m&amp;eacute;todo &lt;code&gt;set&lt;/code&gt; ya que no modifica la colecci&amp;oacute;n &quot;estructuralmente&quot;. Sin embargo, si antes de llamar al &lt;code&gt;set&lt;/code&gt; , la colecci&amp;oacute;n se ha modificado estructuralmente, se &lt;code&gt;IllegalArgumentException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e195bfdae28c7dbd825f2b0cfa215fcc4514276c" translate="yes" xml:space="preserve">
          <source>First and most significant different between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is that, &lt;code&gt;HashMap&lt;/code&gt; is not thread-safe  while &lt;code&gt;Hashtable&lt;/code&gt; is a thread-safe collection.</source>
          <target state="translated">La primera diferencia m&amp;aacute;s significativa entre &lt;code&gt;Hashtable&lt;/code&gt; y &lt;code&gt;HashMap&lt;/code&gt; es que &lt;code&gt;HashMap&lt;/code&gt; no es seguro para subprocesos, mientras que &lt;code&gt;Hashtable&lt;/code&gt; es una colecci&amp;oacute;n segura para subprocesos.</target>
        </trans-unit>
        <trans-unit id="4c2940247e674a032904e85951f08703d55f1e27" translate="yes" xml:space="preserve">
          <source>For example, compare Java 5 Map iterating:</source>
          <target state="translated">Por ejemplo,compara la iteración del mapa de Java 5:</target>
        </trans-unit>
        <trans-unit id="97aba7dc3fa8453988dd3eaad09f2bfffab2858d" translate="yes" xml:space="preserve">
          <source>For non-threaded apps, use &lt;code&gt;HashMap&lt;/code&gt; since they are otherwise the same in terms of functionality.</source>
          <target state="translated">Para las aplicaciones sin subprocesos, use &lt;code&gt;HashMap&lt;/code&gt; ya que de lo contrario son las mismas en t&amp;eacute;rminos de funcionalidad.</target>
        </trans-unit>
        <trans-unit id="a864fbe79b123e5b3781c7606dbae5a3c23396a8" translate="yes" xml:space="preserve">
          <source>For threaded apps, you can often get away with ConcurrentHashMap- depends on your performance requirements.</source>
          <target state="translated">En el caso de las aplicaciones con hilos,a menudo puedes salirte con el ConcurrentHashMap,dependiendo de tus requisitos de rendimiento.</target>
        </trans-unit>
        <trans-unit id="3df9160472a36ae89d781b3c6ab26022d5640f0e" translate="yes" xml:space="preserve">
          <source>Further reading &lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;What is difference between HashMap and Hashtable in Java?&lt;/a&gt;</source>
          <target state="translated">Lecturas adicionales &lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;&amp;iquest;Cu&amp;aacute;l es la diferencia entre HashMap y Hashtable en Java?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf8d0414df57d55121993c998babc6dc951ab933" translate="yes" xml:space="preserve">
          <source>HashMap and Hashtable both implement java.util.Map interface but there
  are some differences that Java developers must understand to write
  more efficient code. As of the Java 2 platform v1.2, Hashtable class
  was retrofitted to implement the Map interface, making it a member of
  the Java Collections Framework.</source>
          <target state="translated">Tanto HashMap como Hashtable implementan la interfaz java.util.Map pero hay algunas diferencias que los desarrolladores de Java deben entender para escribir código más eficiente.A partir de la plataforma Java 2 v1.2,la clase Hashtable fue actualizada para implementar la interfaz de Map,haciéndola miembro del Java Collections Framework.</target>
        </trans-unit>
        <trans-unit id="ddadac488e5ff532483d1a91068404f62fc5a825" translate="yes" xml:space="preserve">
          <source>HashMap does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">HashMap no garantiza que el orden del mapa se mantenga constante en el tiempo.</target>
        </trans-unit>
        <trans-unit id="eadebb7419f0310830aa9293de3df75d77865879" translate="yes" xml:space="preserve">
          <source>HashMap doesn't guarantee the order in which elements are returned. For HashTable I guess it's the same but I'm not entirely sure, I don't find ressource that clearly state that.</source>
          <target state="translated">HashMap no garantiza el orden en que los elementos son devueltos.Para HashTable supongo que es lo mismo,pero no estoy del todo seguro,no encuentro recursos que lo establezcan claramente.</target>
        </trans-unit>
        <trans-unit id="6aedc41f6a22926e230616147632602f9650712c" translate="yes" xml:space="preserve">
          <source>HashMap: It is a class available inside java.util package and it is used to store the element in key and value format.</source>
          <target state="translated">HashMap:Es una clase disponible dentro del paquete java.util y se utiliza para almacenar el elemento en formato de clave y valor.</target>
        </trans-unit>
        <trans-unit id="a46f2ebc98dcc8b75520890a511e99f853ea5a9c" translate="yes" xml:space="preserve">
          <source>HashMaps gives you freedom of synchronization and debugging is lot more easier</source>
          <target state="translated">HashMaps te da libertad de sincronización y la depuración es mucho más fácil</target>
        </trans-unit>
        <trans-unit id="78c9bd228fbd8c5d46c4bce0592c89eff91a7d49" translate="yes" xml:space="preserve">
          <source>HashTable and HashMap are member of the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; (since Java 2 platform v1.2, HashTable was retrofitted to implement the Map interface).</source>
          <target state="translated">HashTable y HashMap son miembros de &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; (desde la plataforma Java 2 v1.2, HashTable se actualiz&amp;oacute; para implementar la interfaz Map).</target>
        </trans-unit>
        <trans-unit id="df229e5af731d7fbb0555f5de0920510f2c0df41" translate="yes" xml:space="preserve">
          <source>HashTable can only contain non-null object as a key or as a value. HashMap can contain one null key and null values.</source>
          <target state="translated">HashTable sólo puede contener un objeto no nulo como una clave o un valor.HashMap puede contener una clave nula y valores nulos.</target>
        </trans-unit>
        <trans-unit id="58a95549c3436ee60ecd7871e7ce42d8ae786e25" translate="yes" xml:space="preserve">
          <source>HashTable is considered legacy code, the documentation advise to use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; in place of Hashtable if a thread-safe highly-concurrent implementation is desired.</source>
          <target state="translated">HashTable se considera c&amp;oacute;digo heredado, la documentaci&amp;oacute;n aconseja utilizar &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; en lugar de Hashtable si se desea una implementaci&amp;oacute;n altamente concurrente segura para subprocesos.</target>
        </trans-unit>
        <trans-unit id="660b9dcb49d86a9b0d8ca2dbc507dfa2ac01bd00" translate="yes" xml:space="preserve">
          <source>HashTable won't allow null keys or null values. Where as HashMap allows one null key, and multiple null values.</source>
          <target state="translated">HashTable no permite claves o valores nulos.Donde como HashMap permite una clave nula,y múltiples valores nulos.</target>
        </trans-unit>
        <trans-unit id="22474fbd1e3d38434c362a687e63aec30ae3ab68" translate="yes" xml:space="preserve">
          <source>HashTables are by default synchronized, so it can be used with multiple threads easily. Where as HashMaps are not synchronized by default, so can be used with only single thread.  But you can still convert HashMap to synchronized by using Collections util class's synchronizedMap(Map m) function.</source>
          <target state="translated">Las HashTables están sincronizadas por defecto,por lo que se pueden usar con múltiples hilos fácilmente.Como los HashMaps no están sincronizados por defecto,así que pueden ser usados con un solo hilo.Pero aún puedes convertir HashMap a sincronizado usando la función de la clase de utilidades de Collections synchronizedMap(Map m).</target>
        </trans-unit>
        <trans-unit id="3739cd326e022a0ec2d5f895c0053c82658a5ec3" translate="yes" xml:space="preserve">
          <source>Hashtable: It is a legacy class which is being recognized inside collection framework.</source>
          <target state="translated">Hashtable:Es una clase de legado que está siendo reconocida dentro del marco de la colección.</target>
        </trans-unit>
        <trans-unit id="3c394da10080138b6474986dd183541c34fb7fc8" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;Java collection cheat sheet&lt;/a&gt; that you will find useful. Notice the gray block contains the legacy class HashTable,Vector and Stack.</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la &lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;hoja de trucos de la colecci&amp;oacute;n Java&lt;/a&gt; que le resultar&amp;aacute; &amp;uacute;til. Observe que el bloque gris contiene la clase heredada HashTable, Vector y Stack.</target>
        </trans-unit>
        <trans-unit id="0e897a22091a5c72367aa2c68491be56a91daa38" translate="yes" xml:space="preserve">
          <source>Implementations of the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt;&lt;code&gt;ConcurrentMap&lt;/code&gt;&lt;/a&gt; interface (for example &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;) solve some of this by including &lt;strong&gt;thread safe check-then-act semantics&lt;/strong&gt; such as:</source>
          <target state="translated">Las implementaciones de la interfaz &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt; &lt;code&gt;ConcurrentMap&lt;/code&gt; &lt;/a&gt; (por ejemplo, &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; ) resuelven algo de esto mediante la inclusi&amp;oacute;n de &lt;strong&gt;sem&amp;aacute;nticas seguras de comprobaci&amp;oacute;n y acci&amp;oacute;n de subprocesos&lt;/strong&gt; como:</target>
        </trans-unit>
        <trans-unit id="ef247363dca7947ce18807b023f807375513e571" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5 introduced ConcurrentMap Interface&lt;/a&gt;: &lt;code&gt;ConcurrentHashMap&lt;/code&gt; - a highly concurrent, high-performance &lt;code&gt;ConcurrentMap&lt;/code&gt; implementation backed by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for &lt;code&gt;Hashtable&lt;/code&gt;: in addition to implementing &lt;code&gt;ConcurrentMap&lt;/code&gt;, it supports all of the &quot;legacy&quot; methods peculiar to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">En &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5, se introdujo la interfaz ConcurrentMap&lt;/a&gt; : &lt;code&gt;ConcurrentHashMap&lt;/code&gt; , una implementaci&amp;oacute;n de &lt;code&gt;ConcurrentMap&lt;/code&gt; altamente concurrente y de alto rendimiento respaldada por una tabla hash. Esta implementaci&amp;oacute;n nunca se bloquea al realizar recuperaciones y permite al cliente seleccionar el nivel de concurrencia para las actualizaciones. Est&amp;aacute; pensado como un reemplazo &lt;code&gt;Hashtable&lt;/code&gt; para Hashtable : adem&amp;aacute;s de implementar &lt;code&gt;ConcurrentMap&lt;/code&gt; , admite todos los m&amp;eacute;todos &quot;heredados&quot; propios de &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147cebda6bdb73c5d51fbf40ab2e08956d0ec790" translate="yes" xml:space="preserve">
          <source>In Hashtable there is a function contains(), which is very confusing to use. Because the meaning of contains is slightly deviating. Whether it means contains key or contains  value? tough to understand. Same thing in Maps we have ContainsKey() and ContainsValue() functions, which are very easy to understand.</source>
          <target state="translated">En Hashtable hay una función contains(),que es muy confusa de usar.Porque el significado de &quot;contains&quot; se desvía ligeramente.Si significa contiene clave o contiene valor...es difícil de entender.Lo mismo en Mapas tenemos las funciones ContainsKey()y ContainsValue(),que son muy fáciles de entender.</target>
        </trans-unit>
        <trans-unit id="6b511ed6e04d77fc78318a00b4ae9f36a4f5fa39" translate="yes" xml:space="preserve">
          <source>In Java 1.8 we are also promised to be able to construct and access HashMaps like in good old scripting languages:</source>
          <target state="translated">En Java 1.8 también se nos promete poder construir y acceder a HashMaps como en los viejos y buenos lenguajes de programación:</target>
        </trans-unit>
        <trans-unit id="cd8c0f0e029d8fe772c617136311a3f6576de97f" translate="yes" xml:space="preserve">
          <source>In Summary there are significant differences between Hashtable and
  HashMap in Java e.g. thread-safety and speed and based upon that only
  use Hashtable if you absolutely need thread-safety, if you are running
  Java 5 consider using ConcurrentHashMap in Java.</source>
          <target state="translated">En resumen,hay diferencias significativas entre Hashtable y HashMap en Java,por ejemplo,la seguridad de los hilos y la velocidad,y en base a ello,usa Hashtable sólo si necesitas seguridad de los hilos,si estás ejecutando Java 5 considera usar ConcurrentHashMap en Java.</target>
        </trans-unit>
        <trans-unit id="554d6863c43fc3f761b7ff10daaee4fc3bc6661c" translate="yes" xml:space="preserve">
          <source>In addition to what izb said, &lt;code&gt;HashMap&lt;/code&gt; allows null values, whereas the &lt;code&gt;Hashtable&lt;/code&gt; does not.</source>
          <target state="translated">Adem&amp;aacute;s de lo que dijo izb, &lt;code&gt;HashMap&lt;/code&gt; permite valores nulos, mientras que &lt;code&gt;Hashtable&lt;/code&gt; no.</target>
        </trans-unit>
        <trans-unit id="0ecd0ae571aba4721ee2996a4fe36a3db474af69" translate="yes" xml:space="preserve">
          <source>In hashmap you can remove element while iterating, safely. where as it is not possible in hashtables.</source>
          <target state="translated">En el mapa de hachís se puede eliminar el elemento mientras se itera,de forma segura.donde como no es posible en los hachís.</target>
        </trans-unit>
        <trans-unit id="7fbd74b62c43cd195aee64e1d4b3f8da3aba383f" translate="yes" xml:space="preserve">
          <source>Iterator in &lt;code&gt;HashMap&lt;/code&gt; is fail-fast.</source>
          <target state="translated">Iterator en &lt;code&gt;HashMap&lt;/code&gt; es a prueba de fallos.</target>
        </trans-unit>
        <trans-unit id="3481f252a01b24865e53a0d403077fe7c2bfb108" translate="yes" xml:space="preserve">
          <source>Iterator in the &lt;code&gt;HashMap&lt;/code&gt; is  fail-safe while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; is not and throw &lt;code&gt;ConcurrentModificationException&lt;/code&gt; if any other Thread modifies the map structurally  by adding or removing any element except &lt;code&gt;Iterator&lt;/code&gt;'s own &lt;code&gt;remove()&lt;/code&gt;  method. But this is not a guaranteed behavior and will be done by JVM on best effort.</source>
          <target state="translated">Iterator en &lt;code&gt;HashMap&lt;/code&gt; es a prueba de fallas, mientras que el enumerador para &lt;code&gt;Hashtable&lt;/code&gt; no lo es y lanza &lt;code&gt;ConcurrentModificationException&lt;/code&gt; si cualquier otro Thread modifica estructuralmente el mapa agregando o eliminando cualquier elemento, excepto el m&amp;eacute;todo &lt;code&gt;remove()&lt;/code&gt; Iterator. Pero este no es un comportamiento garantizado y JVM lo har&amp;aacute; con el mejor esfuerzo.</target>
        </trans-unit>
        <trans-unit id="1a2f20d9e57bdf5adc94c3751cd34e64ab8a2d4c" translate="yes" xml:space="preserve">
          <source>Iterators and Enumerations are Fail Safe - reflecting the state at some point since the creation of iterator/enumeration; this allows for simultaneous reads and modifications at the cost of reduced consistency. They do not throw ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time.</source>
          <target state="translated">Los iteradores y las enumeraciones son a prueba de fallos-reflejando el estado en algún momento desde la creación de la iteratorenumeración;esto permite lecturas y modificaciones simultáneas a costa de una menor consistencia.No lanzan la excepción de la modificación simultánea.Sin embargo,los iteradores están diseñados para ser usados por un solo hilo a la vez.</target>
        </trans-unit>
        <trans-unit id="254d25f74e4ed95d90db28daea166a6ffd3dd1ff" translate="yes" xml:space="preserve">
          <source>Java Collection Matrix</source>
          <target state="translated">Matriz de la colección de Java</target>
        </trans-unit>
        <trans-unit id="93f74b798b3d08e2f768288051abb39a0bc5939a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;HashTable&lt;/code&gt; was legacy class before Java Collections Framework (JCF) was introduced and was later retrofitted to implement the &lt;code&gt;Map&lt;/code&gt; interface. So was &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Stack&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;HashTable&lt;/code&gt; era una clase heredada antes de que se introdujera Java Collections Framework (JCF) y que luego se modific&amp;oacute; para implementar la interfaz &lt;code&gt;Map&lt;/code&gt; . As&amp;iacute; fue &lt;code&gt;Vector&lt;/code&gt; y &lt;code&gt;Stack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0449de243fc290a860ccfdc65f8437c895fd81b6" translate="yes" xml:space="preserve">
          <source>Map provides Collection views instead of direct support for iteration
 via Enumeration objects. Collection views greatly enhance the
 expressiveness of the interface, as discussed later in this section.
 Map allows you to iterate over keys, values, or key-value pairs;
 &lt;code&gt;Hashtable&lt;/code&gt; does not provide the third option. Map provides a safe way
 to remove entries in the midst of iteration; &lt;code&gt;Hashtable&lt;/code&gt; did not.
 Finally, Map fixes a minor deficiency in the &lt;code&gt;Hashtable&lt;/code&gt; interface.
 &lt;code&gt;Hashtable&lt;/code&gt; has a method called contains, which returns true if the
 &lt;code&gt;Hashtable&lt;/code&gt; contains a given value. Given its name, you'd expect this
 method to return true if the &lt;code&gt;Hashtable&lt;/code&gt; contained a given key, because
 the key is the primary access mechanism for a &lt;code&gt;Hashtable&lt;/code&gt;. The Map
 interface eliminates this source of confusion by renaming the method
 &lt;code&gt;containsValue&lt;/code&gt;. Also, this improves the interface's consistency &amp;mdash;
 &lt;code&gt;containsValue&lt;/code&gt; parallels &lt;code&gt;containsKey&lt;/code&gt;.</source>
          <target state="translated">El mapa proporciona vistas de colecci&amp;oacute;n en lugar de soporte directo para la iteraci&amp;oacute;n a trav&amp;eacute;s de objetos de enumeraci&amp;oacute;n. Las vistas de colecci&amp;oacute;n mejoran en gran medida la expresividad de la interfaz, como se describe m&amp;aacute;s adelante en esta secci&amp;oacute;n. Map le permite iterar sobre claves, valores o pares clave-valor; &lt;code&gt;Hashtable&lt;/code&gt; no proporciona la tercera opci&amp;oacute;n. Map proporciona una forma segura de eliminar entradas en medio de la iteraci&amp;oacute;n; &lt;code&gt;Hashtable&lt;/code&gt; no lo hizo. Finalmente, Map corrige una deficiencia menor en la interfaz &lt;code&gt;Hashtable&lt;/code&gt; . &lt;code&gt;Hashtable&lt;/code&gt; tiene un m&amp;eacute;todo llamado contiene, que devuelve verdadero si &lt;code&gt;Hashtable&lt;/code&gt; contiene un valor dado. Dado su nombre, esperar&amp;iacute;a que este m&amp;eacute;todo devuelva verdadero si &lt;code&gt;Hashtable&lt;/code&gt; conten&amp;iacute;a una clave dada, porque la clave es el mecanismo de acceso principal para una &lt;code&gt;Hashtable&lt;/code&gt; . La interfaz de Map elimina esta fuente de confusi&amp;oacute;n al renombrar el m&amp;eacute;todo &lt;code&gt;containsValue&lt;/code&gt; . Adem&amp;aacute;s, esto mejora la coherencia de la interfaz: &lt;code&gt;containsValue&lt;/code&gt; paralelos &lt;code&gt;containsKey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09cfe8513ef9f55ce5353dca09be872682455571" translate="yes" xml:space="preserve">
          <source>Maps allows you to iterate and retrieve keys, values, and both key-value pairs as well, Where HashTable don't have all this capability.</source>
          <target state="translated">Mapas te permite iterar y recuperar claves,valores,y ambos pares clave-valor también,donde HashTable no tiene toda esta capacidad.</target>
        </trans-unit>
        <trans-unit id="75a03fb098b6bc659568b1e29783c07476696b21" translate="yes" xml:space="preserve">
          <source>My small contribution :</source>
          <target state="translated">Mi pequeña contribución :</target>
        </trans-unit>
        <trans-unit id="cdb51b953f61763ed033a4d76f1f625c07fe774b" translate="yes" xml:space="preserve">
          <source>My source: &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&lt;/a&gt;</source>
          <target state="translated">Mi fuente: &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcd6c2b779cd4727bdfc8b82c43e554e848868f9" translate="yes" xml:space="preserve">
          <source>Note on Some Important Terms:</source>
          <target state="translated">Nota sobre algunos términos importantes:</target>
        </trans-unit>
        <trans-unit id="cc43492870882f3478ca9bc8edfbda8462e1df06" translate="yes" xml:space="preserve">
          <source>Note that HashMap can be synchronized by</source>
          <target state="translated">Tengan en cuenta que HashMap puede ser sincronizado por</target>
        </trans-unit>
        <trans-unit id="4918d4974fe3cd4755ebe0e20277ccd382fa12f2" translate="yes" xml:space="preserve">
          <source>Note, that a lot of the answers state that Hashtable is synchronised.  &lt;strong&gt;In practice this buys you very little.&lt;/strong&gt;  The synchronization is on the accessor / mutator methods will stop two threads adding or removing from the map concurrently, but in the real world you will often need additional synchronisation.</source>
          <target state="translated">Tenga en cuenta que muchas de las respuestas indican que Hashtable est&amp;aacute; sincronizado. &lt;strong&gt;En la pr&amp;aacute;ctica esto te compra muy poco.&lt;/strong&gt; La sincronizaci&amp;oacute;n est&amp;aacute; en los m&amp;eacute;todos de acceso / mutaci&amp;oacute;n para que dos hilos se agreguen o se eliminen del mapa simult&amp;aacute;neamente, pero en el mundo real a menudo necesitar&amp;aacute; una sincronizaci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="f180d9cd9c023ba8ad54546958cad221aff4883c" translate="yes" xml:space="preserve">
          <source>O(log(n)) for &lt;code&gt;HashMap&lt;/code&gt;&lt;strong&gt;Vs&lt;/strong&gt; O(n) in &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">O (log (n)) para &lt;code&gt;HashMap&lt;/code&gt; &lt;strong&gt;Vs&lt;/strong&gt; O (n) en &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2600125966cb5ea97c2b8c54e0758c7e46ca74a1" translate="yes" xml:space="preserve">
          <source>Old and classic topic, just want to add this helpful blog that explains this:</source>
          <target state="translated">Tema antiguo y clásico,sólo quiero añadir este útil blog que explica esto:</target>
        </trans-unit>
        <trans-unit id="249a3a46c2e86414c5539f13f4f1a0225a7d5a6f" translate="yes" xml:space="preserve">
          <source>One more notable difference between Hashtable and HashMap is that because of thread-safety and synchronization Hashtable is much slower
  than HashMap if used in Single threaded environment. So if you don&amp;rsquo;t
  need synchronization and HashMap is only used by one thread, it out
  perform Hashtable in Java.</source>
          <target state="translated">Una diferencia notable m&amp;aacute;s entre Hashtable y HashMap es que, debido a la seguridad y la sincronizaci&amp;oacute;n de subprocesos, Hashtable es mucho m&amp;aacute;s lento que HashMap si se usa en un entorno de subprocesamiento &amp;uacute;nico. Entonces, si no necesita sincronizaci&amp;oacute;n y HashMap solo lo usa un subproceso, superar&amp;aacute; a Hashtable en Java.</target>
        </trans-unit>
        <trans-unit id="179c0a918e92d97127e98c73349a42a66aa21bd6" translate="yes" xml:space="preserve">
          <source>One of HashMap's subclasses is &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt;, so in the event that you'd want predictable iteration order (which is insertion order by default), you could easily swap out the &lt;code&gt;HashMap&lt;/code&gt; for a &lt;code&gt;LinkedHashMap&lt;/code&gt;.  This wouldn't be as easy if you were using &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">Una de las subclases de HashMap es &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt; , por lo que en el caso de que desee un orden de iteraci&amp;oacute;n predecible (que es el orden de inserci&amp;oacute;n por defecto), puede cambiar f&amp;aacute;cilmente el &lt;code&gt;HashMap&lt;/code&gt; por un &lt;code&gt;LinkedHashMap&lt;/code&gt; . Esto no ser&amp;iacute;a tan f&amp;aacute;cil si estuviera usando &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1525943ae6179c4dbbe03560c257ffac662fb828" translate="yes" xml:space="preserve">
          <source>One of the major differences between HashMap and Hashtable is that HashMap is non-synchronized whereas Hashtable is synchronized, which
  means Hashtable is thread-safe and can be shared between multiple
  threads but HashMap cannot be shared between multiple threads without
  proper synchronization. Java 5 introduced ConcurrentHashMap which is
  an alternative of Hashtable and provides better scalability than
  Hashtable in Java.Synchronized means only one thread can modify a hash
  table at one point of time. Basically, it means that any thread before
  performing an update on a hashtable will have to acquire a lock on the
  object while others will wait for lock to be released.</source>
          <target state="translated">Una de las principales diferencias entre HashMap y Hashtable es que HashMap no está sincronizado mientras que Hashtable está sincronizado,lo que significa que Hashtable es seguro para los hilos y puede ser compartido entre múltiples hilos,pero HashMap no puede ser compartido entre múltiples hilos sin una sincronización adecuada.Java 5 introdujo ConcurrentHashMap,que es una alternativa de Hashtable y proporciona una mejor escalabilidad que Hashtable en Java.Sincronizado significa que sólo un hilo puede modificar una tabla de hash en un momento dado.Básicamente,significa que cualquier hilo antes de realizar una actualización en un hashtable tendrá que adquirir un bloqueo en el objeto mientras que otros esperarán a que el bloqueo sea liberado.</target>
        </trans-unit>
        <trans-unit id="95781641174af3b5c28daa7afb4c768668074452" translate="yes" xml:space="preserve">
          <source>Performance Improvement for &lt;code&gt;HashMap&lt;/code&gt; in Java 8</source>
          <target state="translated">Mejora de rendimiento para &lt;code&gt;HashMap&lt;/code&gt; en Java 8</target>
        </trans-unit>
        <trans-unit id="fee29654ce34b086768db65a4b25fcd54f9ed463" translate="yes" xml:space="preserve">
          <source>Second important difference between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is performance, since &lt;code&gt;HashMap&lt;/code&gt; is not synchronized it perform better than &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">La segunda diferencia importante entre &lt;code&gt;Hashtable&lt;/code&gt; y &lt;code&gt;HashMap&lt;/code&gt; es el rendimiento, ya que &lt;code&gt;HashMap&lt;/code&gt; no est&amp;aacute; sincronizado, funciona mejor que &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b55e592836fe1e61392790c1a6fce30f1803ceb3" translate="yes" xml:space="preserve">
          <source>Separate from the obvious differences discussed extensively in this question, I see the Hashtable as a &quot;manual drive&quot; car where you have better control over the hashing and the HashMap as the &quot;automatic drive&quot; counterpart that will generally perform well.</source>
          <target state="translated">Aparte de las diferencias obvias discutidas extensamente en esta pregunta,veo el Hashtable como un coche de &quot;conducción manual&quot; en el que tienes un mejor control sobre el hashing y el HashMap como la contraparte de &quot;conducción automática&quot; que generalmente funcionará bien.</target>
        </trans-unit>
        <trans-unit id="b3a738203d70f6090dfcdd1764cf29833f51bb9d" translate="yes" xml:space="preserve">
          <source>Seriously though, you're better off staying away from &lt;code&gt;Hashtable&lt;/code&gt; altogether. For single-threaded apps, you don't need the extra overhead of synchronisation. For highly concurrent apps, the paranoid synchronisation might lead to starvation, deadlocks, or unnecessary garbage collection pauses. Like Tim Howland pointed out, you might use &lt;code&gt;ConcurrentHashMap&lt;/code&gt; instead.</source>
          <target state="translated">En serio, es mejor que te mantengas alejado de &lt;code&gt;Hashtable&lt;/code&gt; por completo. Para aplicaciones de un solo subproceso, no necesita la sobrecarga adicional de sincronizaci&amp;oacute;n. Para aplicaciones altamente concurrentes, la sincronizaci&amp;oacute;n paranoica puede conducir a la inanici&amp;oacute;n, puntos muertos o pausas innecesarias de recolecci&amp;oacute;n de basura. Como se&amp;ntilde;al&amp;oacute; Tim Howland, puede usar &lt;code&gt;ConcurrentHashMap&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="3bdf790b2b1c9d6025dcbecb5bdb37ab2f60d7b4" translate="yes" xml:space="preserve">
          <source>Since synchronization is not an issue for you, I'd recommend &lt;code&gt;HashMap&lt;/code&gt;. If synchronization becomes an issue, you may also look at &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Dado que la sincronizaci&amp;oacute;n no es un problema para usted, le recomendar&amp;iacute;a &lt;code&gt;HashMap&lt;/code&gt; . Si la sincronizaci&amp;oacute;n se convierte en un problema, tambi&amp;eacute;n puede consultar &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bcb97fa6763fbfe1f0ff48e9f6a9c4dd72d057b" translate="yes" xml:space="preserve">
          <source>Some important points about HashMap and HashTable.
   please read below details.</source>
          <target state="translated">Algunos puntos importantes sobre HashMap y HashTable.Por favor,lea los siguientes detalles.</target>
        </trans-unit>
        <trans-unit id="2773856ae2356cf0a8e12035c63973404b5e1bef" translate="yes" xml:space="preserve">
          <source>Structurally modification means deleting or inserting element which could effectively change the structure of map.</source>
          <target state="translated">La modificación estructural significa eliminar o insertar elementos que podrían cambiar efectivamente la estructura del mapa.</target>
        </trans-unit>
        <trans-unit id="9ac0930f0753d909c7591e062bf09758da70879f" translate="yes" xml:space="preserve">
          <source>Synchronized means only one thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a &lt;code&gt;Hashtable&lt;/code&gt; will have to acquire a lock on the object while others will wait for lock to be released.</source>
          <target state="translated">Sincronizado significa que solo un subproceso puede modificar una tabla hash en un punto del tiempo. B&amp;aacute;sicamente, significa que cualquier subproceso antes de realizar una actualizaci&amp;oacute;n en un &lt;code&gt;Hashtable&lt;/code&gt; tendr&amp;aacute; que adquirir un bloqueo en el objeto, mientras que otros esperar&amp;aacute;n a que se libere el bloqueo.</target>
        </trans-unit>
        <trans-unit id="70e8f2a076a2a427c74c96d2d6f12fe9436a1288" translate="yes" xml:space="preserve">
          <source>Take a look at this chart. It provides comparisons between different data structures along with &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. The comparison is precise, clear and easy to understand.</source>
          <target state="translated">Echa un vistazo a este cuadro. Proporciona comparaciones entre diferentes estructuras de datos junto con &lt;code&gt;HashMap&lt;/code&gt; y &lt;code&gt;Hashtable&lt;/code&gt; . La comparaci&amp;oacute;n es precisa, clara y f&amp;aacute;cil de entender.</target>
        </trans-unit>
        <trans-unit id="9b64a19c6daf91779b3938d649152906ab363b0e" translate="yes" xml:space="preserve">
          <source>The 5 main differences betwen HashMap and Hashtable</source>
          <target state="translated">Las 5 principales diferencias entre HashMap y Hashtable</target>
        </trans-unit>
        <trans-unit id="072d0888e52948dbd09f33a229cca91be253355a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt; class is roughly equivalent to &lt;code&gt;Hashtable&lt;/code&gt;, except that it is non synchronized and permits nulls. (&lt;code&gt;HashMap&lt;/code&gt; allows null values as key and value whereas &lt;code&gt;Hashtable&lt;/code&gt; doesn't allow &lt;code&gt;null&lt;/code&gt;s).</source>
          <target state="translated">La clase &lt;code&gt;HashMap&lt;/code&gt; es m&amp;aacute;s o menos equivalente a &lt;code&gt;Hashtable&lt;/code&gt; , excepto que no est&amp;aacute; sincronizada y permite valores nulos. ( &lt;code&gt;HashMap&lt;/code&gt; permite valores nulos como clave y valor, mientras que &lt;code&gt;Hashtable&lt;/code&gt; no permite valores &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0aeaae4475437892ad0e711f1d770aca667a7fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.2&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; and Hashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.0&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt;, both are used to represent a group of objects that are represented in &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair. Each &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair is called &lt;code&gt;Entry&lt;/code&gt; object. The collection of Entries is referred by the object of &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. Keys in a collection must be unique or distinctive. [as they are used to retrieve a mapped value a particular key. values in a collection can be duplicated.]</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.2&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; y Hashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.0&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; , ambos se utilizan para representar un grupo de objetos que se representan en el par &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; . Cada par &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; se llama objeto &lt;code&gt;Entry&lt;/code&gt; . La colecci&amp;oacute;n de entradas se refiere por el objeto de &lt;code&gt;HashMap&lt;/code&gt; y &lt;code&gt;Hashtable&lt;/code&gt; . Las claves de una colecci&amp;oacute;n deben ser &amp;uacute;nicas o distintivas. [ya que se utilizan para recuperar un valor mapeado de una clave en particular. los valores en una colecci&amp;oacute;n se pueden duplicar.]</target>
        </trans-unit>
        <trans-unit id="00dc41b113291633c52fd58000a80e068e3e22e0" translate="yes" xml:space="preserve">
          <source>The HashMap class is roughly equivalent to Hashtable, except that it permits nulls. (HashMap allows null values as key and value whereas
  Hashtable doesn&amp;rsquo;t allow nulls).</source>
          <target state="translated">La clase HashMap es m&amp;aacute;s o menos equivalente a Hashtable, excepto que permite valores nulos. (HashMap permite valores nulos como clave y valor, mientras que Hashtable no permite valores nulos).</target>
        </trans-unit>
        <trans-unit id="f7ecf1afa5b4c9630d2b5dcfbe61d5b627ebd286" translate="yes" xml:space="preserve">
          <source>The Map Interface</source>
          <target state="translated">La interfaz del mapa</target>
        </trans-unit>
        <trans-unit id="3676c70892d7c609193fc43d310096bd0df0c6be" translate="yes" xml:space="preserve">
          <source>The iterators returned by Map are fail-fast, if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. &lt;strong&gt;Whereas&lt;/strong&gt; the Enumerations returned by Hashtable's keys and elements methods are not fail-fast.</source>
          <target state="translated">Los iteradores devueltos por Map son a prueba de fallas, si el mapa se modifica estructuralmente en cualquier momento despu&amp;eacute;s de que se crea el iterador, de cualquier manera, excepto a trav&amp;eacute;s del m&amp;eacute;todo remove del propio iterador, el iterador arrojar&amp;aacute; una &lt;code&gt;ConcurrentModificationException&lt;/code&gt; . Por lo tanto, frente a la modificaci&amp;oacute;n concurrente, el iterador falla de manera r&amp;aacute;pida y limpia, en lugar de arriesgarse a un comportamiento arbitrario, no determinista en un momento indeterminado en el futuro. &lt;strong&gt;Mientras que&lt;/strong&gt; las enumeraciones devueltas por los m&amp;eacute;todos de elementos y claves de Hashtable no son a prueba de fallas.</target>
        </trans-unit>
        <trans-unit id="e573df66450873c1ddfa83005b4aa24d831fd978" translate="yes" xml:space="preserve">
          <source>The third significant difference between HashMap vs Hashtable is that Iterator in the HashMap is a fail-fast iterator while the
  enumerator for the Hashtable is not and throw
  ConcurrentModificationException if any other Thread modifies the map
  structurally by adding or removing any element except Iterator&amp;rsquo;s own
  remove() method. But this is not a guaranteed behavior and will be
  done by JVM on best effort. This is also an important difference
  between Enumeration and Iterator in Java.</source>
          <target state="translated">La tercera diferencia significativa entre HashMap frente a Hashtable es que Iterator en HashMap es un iterador r&amp;aacute;pido a prueba de fallas, mientras que el enumerador para Hashtable no lo es y lanza ConcurrentModificationException si cualquier otro Thread modifica el mapa estructuralmente agregando o eliminando cualquier elemento, excepto el propio removedor de Iterator ( ) m&amp;eacute;todo. Pero este no es un comportamiento garantizado y JVM lo har&amp;aacute; con el mejor esfuerzo. Esta tambi&amp;eacute;n es una diferencia importante entre Enumeration e Iterator en Java.</target>
        </trans-unit>
        <trans-unit id="f56383732ea0646c1b6ccc4780205710d6c51198" translate="yes" xml:space="preserve">
          <source>There are 5 basic differentiations with HashTable and HashMaps.</source>
          <target state="translated">Hay 5 diferenciaciones básicas con HashTable y HashMaps.</target>
        </trans-unit>
        <trans-unit id="bb1f8a6f6840706e60372d6f2420a010dbd1ffca" translate="yes" xml:space="preserve">
          <source>There are several differences between &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java:</source>
          <target state="translated">Hay varias diferencias entre &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt; en Java:</target>
        </trans-unit>
        <trans-unit id="5800ffe299a96231836db81f351c861e03ed3697" translate="yes" xml:space="preserve">
          <source>There is many good answer already posted. I'm adding few new points and summarizing it.</source>
          <target state="translated">Hay muchas buenas respuestas ya publicadas.Estoy añadiendo algunos puntos nuevos y resumiéndolos.</target>
        </trans-unit>
        <trans-unit id="df9315b5c785f8ab9f27801657f7477146067793" translate="yes" xml:space="preserve">
          <source>Third difference on &lt;code&gt;Hashtable&lt;/code&gt; vs &lt;code&gt;HashMap&lt;/code&gt; is that &lt;code&gt;Hashtable&lt;/code&gt; is obsolete class and you should be using &lt;code&gt;ConcurrentHashMap&lt;/code&gt; in place of &lt;code&gt;Hashtable&lt;/code&gt; in Java.</source>
          <target state="translated">La tercera diferencia en &lt;code&gt;Hashtable&lt;/code&gt; vs &lt;code&gt;HashMap&lt;/code&gt; es que &lt;code&gt;Hashtable&lt;/code&gt; es una clase obsoleta y deber&amp;iacute;a usar &lt;code&gt;ConcurrentHashMap&lt;/code&gt; en lugar de &lt;code&gt;Hashtable&lt;/code&gt; en Java.</target>
        </trans-unit>
        <trans-unit id="ee9376793d9967bcbf5a7a8c815e756c9c9ccb2c" translate="yes" xml:space="preserve">
          <source>This question is often asked in interview to check whether candidate understands correct usage of collection classes and is aware of alternative solutions available.</source>
          <target state="translated">Esta pregunta se hace a menudo en la entrevista para comprobar si el candidato entiende el uso correcto de las clases de colección y es consciente de las soluciones alternativas disponibles.</target>
        </trans-unit>
        <trans-unit id="247c0322284eae1d1388216cd3162f7e2cc8e631" translate="yes" xml:space="preserve">
          <source>We can make the &lt;code&gt;HashMap&lt;/code&gt; as synchronized by calling this code</source>
          <target state="translated">Podemos hacer que el &lt;code&gt;HashMap&lt;/code&gt; est&amp;eacute; sincronizado llamando a este c&amp;oacute;digo</target>
        </trans-unit>
        <trans-unit id="c81f8280687b9700ca5bb68ae586570fb7c23f46" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;les son las diferencias entre un &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; y un &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt; en Java?</target>
        </trans-unit>
        <trans-unit id="2c8e95a3c2ffb57733e53c253ed60a5636be3523" translate="yes" xml:space="preserve">
          <source>What is the difference between HashMap and HashTable?</source>
          <target state="translated">¿Cuál es la diferencia entre HashMap y HashTable?</target>
        </trans-unit>
        <trans-unit id="ce3ce0552d057e3c8f06c38c4e4073b98a6a4ac5" translate="yes" xml:space="preserve">
          <source>Which is more efficient for non-threaded applications?</source>
          <target state="translated">¿Qué es más eficiente para las aplicaciones no roscadas?</target>
        </trans-unit>
        <trans-unit id="2641089043a1d4d281fa1d792f1ac52e385d9822" translate="yes" xml:space="preserve">
          <source>versus the old Hashtable approach:</source>
          <target state="translated">contra el viejo enfoque de Hashtable:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
