<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/40471">
    <body>
      <group id="40471">
        <trans-unit id="1ffa479b2bc81d3a4bfacc7ab2a3c758037edec2" translate="yes" xml:space="preserve">
          <source>*The aforementioned improvement has not been applied to &lt;code&gt;Hashtable&lt;/code&gt; yet, but only to &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;LinkedHashMap&lt;/code&gt;, and &lt;code&gt;ConcurrentHashMap&lt;/code&gt;.</source>
          <target state="translated">*前述の改善はまだ &lt;code&gt;Hashtable&lt;/code&gt; には適用されていませんが、 &lt;code&gt;HashMap&lt;/code&gt; 、 &lt;code&gt;LinkedHashMap&lt;/code&gt; 、および &lt;code&gt;ConcurrentHashMap&lt;/code&gt; にのみ適用されています。</target>
        </trans-unit>
        <trans-unit id="0bebecfc307c9e1b712693d3b764211b8ed5cfb2" translate="yes" xml:space="preserve">
          <source>1) First difference is HashMap is not thread safe While HashTable is ThreadSafe</source>
          <target state="translated">1)最初の違いは、HashMapがスレッドセーフではないのに対し、HashTableはスレッドセーフであることです。</target>
        </trans-unit>
        <trans-unit id="e93948b799e95b7508984d1cffb6e8a3f9844579" translate="yes" xml:space="preserve">
          <source>1) Hashtable and Hashmap implement the java.util.Map interface
2) Both Hashmap and Hashtable is the hash based collection. and working on hashing.
so these are similarity of HashMap and HashTable.</source>
          <target state="translated">1)HashtableとHashmapはjava.util.Mapインターフェースを実装しています。)ハッシュマップもハッシュテーブルもハッシュベースのコレクションです。</target>
        </trans-unit>
        <trans-unit id="ce8ad15ae4892952ca56baaa8baaa429494f2e53" translate="yes" xml:space="preserve">
          <source>1.&lt;code&gt;Hashmap&lt;/code&gt; and &lt;code&gt;HashTable&lt;/code&gt; both store key and value.</source>
          <target state="translated">1. &lt;code&gt;Hashmap&lt;/code&gt; と &lt;code&gt;HashTable&lt;/code&gt; はどちらもキーと値を格納します。</target>
        </trans-unit>
        <trans-unit id="ea022165e8aaef91c12ccef2e5123b0265799db7" translate="yes" xml:space="preserve">
          <source>2) HashMap is performance wise better because it is not thread safe. while Hashtable performance wise is not better because it is thread safe. so multiple thread can not access Hashtable at the same time.</source>
          <target state="translated">2)HashMapはスレッドセーフではないので、Hashtableはスレッドセーフなので性能的には良くないが、HashMapはスレッドセーフなので性能的には良い。</target>
        </trans-unit>
        <trans-unit id="2a896733be888d07b7cbb8186abb374063e45bdd" translate="yes" xml:space="preserve">
          <source>2.&lt;code&gt;Hashmap&lt;/code&gt; can store one key as &lt;code&gt;null&lt;/code&gt;. &lt;code&gt;Hashtable&lt;/code&gt; can't store &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">2. &lt;code&gt;Hashmap&lt;/code&gt; は1つのキーを &lt;code&gt;null&lt;/code&gt; として保存できます 。 &lt;code&gt;Hashtable&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; を格納できません。</target>
        </trans-unit>
        <trans-unit id="02a8a35731189356741a2efc879bda9c331af5d6" translate="yes" xml:space="preserve">
          <source>3.&lt;code&gt;HashMap&lt;/code&gt; is not synchronized but &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">3. &lt;code&gt;HashMap&lt;/code&gt; は同期されませんが、 &lt;code&gt;Hashtable&lt;/code&gt; は同期されます。</target>
        </trans-unit>
        <trans-unit id="7edecd9abb3471db7df504cd6c5936311ca4fa46" translate="yes" xml:space="preserve">
          <source>4.&lt;code&gt;HashMap&lt;/code&gt; can be synchronized with &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt;</source>
          <target state="translated">4. &lt;code&gt;HashMap&lt;/code&gt; は &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt; と同期できます</target>
        </trans-unit>
        <trans-unit id="8772653c67ec1de6492448fff19367167e54b515" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is a legacy class in the jdk that shouldn't be used anymore. Replace usages of it with &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt;. If you don't require thread safety, use &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; which isn't &lt;a href=&quot;http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/concurrent/ThreadSafe.html&quot;&gt;threadsafe&lt;/a&gt; but faster and uses less memory.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt;はjdkのレガシークラスであり、もう使用されません。 使用法を&lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMapに&lt;/a&gt;置き換えます。 スレッドセーフを必要としない場合は、 &lt;a href=&quot;http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/concurrent/ThreadSafe.html&quot;&gt;スレッドセーフ&lt;/a&gt;ではありませんが高速でメモリ使用量が少ない&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="a8212855afbfdfadf4f72d52f3fd51313aab01da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is synchronized, if you are using it in a single thread you can use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, which is an unsynchronized version. Unsynchronized objects are often a little more performant. By the way if multiple threads access a HashMap concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. 
Youn can wrap a unsynchronized map in a synchronized one using :</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt;は同期されます。シングルスレッドで使用している場合は、非同期バージョンである&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;を使用できます。 非同期のオブジェクトは、多くの場合、パフォーマンスが少し向上します。 ちなみに、複数のスレッドがHashMapに同時にアクセスし、少なくとも1つのスレッドがマップを構造的に変更する場合、外部で同期する必要があります。 Younは、以下を使用して、非同期マップを同期マップにラップできます。</target>
        </trans-unit>
        <trans-unit id="35825761ff3e0e6aae7c813dc0f469fe68798cf4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; is a fail-fast in nature. i.e it throws ConcurrentModificationException if a collection is modified while iterating other than it&amp;rsquo;s own remove() method. Where as &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt;&lt;code&gt;Enumeration&lt;/code&gt;&lt;/a&gt; is fail-safe in nature. It doesn&amp;rsquo;t throw any exceptions if a collection is modified while iterating.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;は本質的にフェイルファストです。 つまり、独自のremove（）メソッド以外の反復中にコレクションが変更されると、ConcurrentModificationExceptionがスローされます。 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt; &lt;code&gt;Enumeration&lt;/code&gt; &lt;/a&gt;は本質的にフェイルセーフですが。 反復中にコレクションが変更されても、例外はスローされません。</target>
        </trans-unit>
        <trans-unit id="6f5224599c22155916dabf87bba49566ddaa6261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows maximum one null key and any number of null values. Where as &lt;code&gt;Hashtable&lt;/code&gt; doesn&amp;rsquo;t allow even a single null key and null value, if the key or value null is then it throws NullPointerException. &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;Example&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; では、最大1つのnullキーと任意の数のnull値を使用できます。 &lt;code&gt;Hashtable&lt;/code&gt; は単一のnullキーとnull値さえも許可しないのに対し、キーまたは値nullがその場合、NullPointerExceptionをスローします。 &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;例&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a5083b226eeb51dc40cc10003425a58b158f81eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows one null key and multiple null values.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; では、1つのnullキーと複数のnull値を使用できます。</target>
        </trans-unit>
        <trans-unit id="669df6fbbd3ba9c388deaba3fc0849ca8f6f2ff6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; both are used to store &lt;em&gt;data in key and value form&lt;/em&gt;. Both are using hashing technique to store unique keys.
But there are many differences between HashMap and Hashtable classes that are given below.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; と &lt;code&gt;Hashtable&lt;/code&gt; はどちらも&lt;em&gt;、キーと値の形式でデータ&lt;/em&gt;を格納&lt;em&gt;する&lt;/em&gt;ために使用さ&lt;em&gt;れます&lt;/em&gt; 。 どちらもハッシュ技術を使用して一意のキーを格納しています。 ただし、以下に示すHashMapクラスとHashtableクラスの間には多くの違いがあります。</target>
        </trans-unit>
        <trans-unit id="0ac053a124fba70f26ef444ee7553d0c4785af36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; have significant algorithmic differences as well. No one has mentioned this before so that's why I am bringing it up. &lt;code&gt;HashMap&lt;/code&gt; will construct a hash table with power of two size, increase it dynamically such that you have at most about eight elements (collisions) in any bucket and will stir the elements very well for general element types. However, the &lt;code&gt;Hashtable&lt;/code&gt; implementation provides better and finer control over the hashing if you know what you are doing, namely you can fix the table size using e.g. the closest prime number to your values domain size and this will result in better performance than HashMap i.e. less collisions for some cases.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; と &lt;code&gt;Hashtable&lt;/code&gt; には、アルゴリズムにも大きな違いがあります。 誰もこれについて以前に言及したことがないので、私がそれを取り上げるのはそのためです。 &lt;code&gt;HashMap&lt;/code&gt; は2の累乗のサイズのハッシュテーブルを作成し、バケット内に最大で約8つの要素（衝突）が存在するように動的に増やし、一般的な要素タイプの要素を非常によく攪拌します。 ただし、 &lt;code&gt;Hashtable&lt;/code&gt; 実装は、何をしているのかがわかっている場合、ハッシュをより細かく制御できます。たとえば、値のドメインサイズに最も近い素数を使用してテーブルサイズを修正できます。これにより、HashMapよりもパフォーマンスが向上します。一部のケースでは衝突。</target>
        </trans-unit>
        <trans-unit id="64a17134b1046d668dd05ac2bc4f97f06a63e76e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; can be synchronized by</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="d500b59660957bd4381ff369b93e82d00b9b1f70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; は、マップの順序が長期にわたって一定であることを保証しません。</target>
        </trans-unit>
        <trans-unit id="a8747ab7f19811c92ec840fe23f10d94ab4b3af3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; inherits AbstractMap class.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; は AbstractMapクラスを継承します。</target>
        </trans-unit>
        <trans-unit id="51fbe655ee9bcf724b8cabf41a90881d14820a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is a new class introduced in JDK 1.2.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; は、JDK 1.2で導入された新しいクラスです。</target>
        </trans-unit>
        <trans-unit id="b63a85d53f021a1ae8dd8bdd08fdc18c2b28c4cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is emulated and therefore usable in &lt;code&gt;GWT client code&lt;/code&gt; whereas &lt;code&gt;Hashtable&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; はエミュレートされているため、 &lt;code&gt;GWT client code&lt;/code&gt; 使用できますが 、 &lt;code&gt;Hashtable&lt;/code&gt; は使用できません。</target>
        </trans-unit>
        <trans-unit id="8910e4452555bc0eb462a108515a97d9c3f5b62a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is fast.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; は高速です。</target>
        </trans-unit>
        <trans-unit id="0ac323b983cb93bfa96d446a6acf3e0739d49b02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized whereas &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; は同期されていませんが、 &lt;code&gt;Hashtable&lt;/code&gt; は同期されています。</target>
        </trans-unit>
        <trans-unit id="15bf5350ece84dd8e38bde89e4f666c4333d494b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized. It is not-thread safe and can't be shared between many threads without proper synchronization code.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; は同期されていません。 これはスレッドセーフではなく、適切な同期コードがないと多くのスレッド間で共有できません。</target>
        </trans-unit>
        <trans-unit id="7eecfc386a9ddceaa10ba8c78194cc8417a8cc62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is traversed by Iterator.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; はIteratorによってトラバースされます。</target>
        </trans-unit>
        <trans-unit id="8697ca59be21a2145ac021e93da6593a2e482b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; permits null values in it, while &lt;code&gt;Hashtable&lt;/code&gt; doesn't.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; はnull値を許可しますが、 &lt;code&gt;Hashtable&lt;/code&gt; は許可しません。</target>
        </trans-unit>
        <trans-unit id="ce244b309892513fef48b0c0adb960eea745a513" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt;: An implementation of the &lt;code&gt;Map&lt;/code&gt; interface that uses hash codes to index an array.
&lt;code&gt;Hashtable&lt;/code&gt;: Hi, 1998 called. They want their collections API back.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; ：ハッシュコードを使用して配列のインデックスを作成する &lt;code&gt;Map&lt;/code&gt; インターフェースの実装。 &lt;code&gt;Hashtable&lt;/code&gt; ：こんにちは、1998年に呼ばれました。 コレクションAPIを元に戻したいと考えています。</target>
        </trans-unit>
        <trans-unit id="aea1fdd84192f7fc2e196adf40609942cb1285de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; does not allow &lt;code&gt;null&lt;/code&gt; keys or values.  &lt;code&gt;HashMap&lt;/code&gt; allows one &lt;code&gt;null&lt;/code&gt; key and any number of &lt;code&gt;null&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; キーまたは値を許可しません。 &lt;code&gt;HashMap&lt;/code&gt; では、1つの &lt;code&gt;null&lt;/code&gt; キーと任意の数の &lt;code&gt;null&lt;/code&gt; 値を使用できます。</target>
        </trans-unit>
        <trans-unit id="da40767d527c7d8ee16fe1095a3c28313aaec00a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; doesn't allow any null key or value.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は、nullキーまたは値は許可されません。</target>
        </trans-unit>
        <trans-unit id="e82d9c21537b4430e511e19537f8747613296279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; inherits Dictionary class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は Dictionaryクラスを継承します。</target>
        </trans-unit>
        <trans-unit id="473a8e23134d11e4c9e6a5a24f60baccffe8cd5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is &lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;synchronized&lt;/a&gt;, whereas &lt;code&gt;HashMap&lt;/code&gt; is not. This makes &lt;code&gt;HashMap&lt;/code&gt; better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は&lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;同期されます&lt;/a&gt;が、 &lt;code&gt;HashMap&lt;/code&gt; は同期されません。 非同期のオブジェクトは通常、同期されたオブジェクトよりもパフォーマンスが高いため、これにより、 &lt;code&gt;HashMap&lt;/code&gt; はスレッド化されていないアプリケーションに適しています。</target>
        </trans-unit>
        <trans-unit id="5f3b80ed3c8119e05343a43fa58d178aa8c248fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is a legacy class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; はレガシークラスです。</target>
        </trans-unit>
        <trans-unit id="74522ed93d3ffc34a0d85038cae726b8c4697227" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is considered legacy code. There's nothing about &lt;code&gt;Hashtable&lt;/code&gt; that can't be done using &lt;code&gt;HashMap&lt;/code&gt; or derivations of &lt;code&gt;HashMap&lt;/code&gt;, so for new code, I don't see any justification for going back to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; はレガシーコードと見なされます。 &lt;code&gt;HashMap&lt;/code&gt; やHashMapの派生を使用して実行できない &lt;code&gt;Hashtable&lt;/code&gt; については何もないので、新しいコードの場合、 &lt;code&gt;Hashtable&lt;/code&gt; に戻る正当性はありません。</target>
        </trans-unit>
        <trans-unit id="582981ade6fd1fb874a7cbaa7d7f669287851433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized and can't be unsynchronized.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は内部で同期されており、非同期にすることはできません。</target>
        </trans-unit>
        <trans-unit id="5b50d2071547d1d8f01971f3564947ceb026e758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized. Therefore, it is very much safe to use &lt;code&gt;Hashtable&lt;/code&gt; in multi threaded applications. Where as &lt;code&gt;HashMap&lt;/code&gt; is not internally synchronized. Therefore, it is not safe to use &lt;code&gt;HashMap&lt;/code&gt; in multi threaded applications without external synchronization. You can externally synchronize &lt;code&gt;HashMap&lt;/code&gt; using &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は内部で同期されています。 したがって、マルチスレッドアプリケーションで &lt;code&gt;Hashtable&lt;/code&gt; を使用することは非常に安全です。 &lt;code&gt;HashMap&lt;/code&gt; が内部的に同期されていない場合。 したがって、外部同期のないマルチスレッドアプリケーションで &lt;code&gt;HashMap&lt;/code&gt; を使用するのは安全ではありません。 &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; メソッドを使用して、外部で &lt;code&gt;HashMap&lt;/code&gt; を同期できます。</target>
        </trans-unit>
        <trans-unit id="e63c856b660603f278bb16d5b114de8a3272ed31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is similar to the &lt;code&gt;HashMap&lt;/code&gt; and has a similar interface. It is recommended that you use &lt;code&gt;HashMap&lt;/code&gt;, unless you require support for legacy applications or you need synchronisation, as the &lt;code&gt;Hashtables&lt;/code&gt; methods are synchronised. So in your case as you are not multi-threading, &lt;code&gt;HashMaps&lt;/code&gt; are your best bet.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は &lt;code&gt;HashMap&lt;/code&gt; に似ており、同様のインターフェースを持っています。 レガシーアプリケーションのサポートが必要な場合や同期が必要な場合を除いて、 &lt;code&gt;Hashtables&lt;/code&gt; メソッドが同期されるため、 &lt;code&gt;HashMap&lt;/code&gt; を使用することをお勧めします。 したがって、あなたの場合、マルチスレッドではないので、 &lt;code&gt;HashMaps&lt;/code&gt; が最善の策です。</target>
        </trans-unit>
        <trans-unit id="6eaefd6be9ca644fb4dceef1106f715e6f13ce69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is slow.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は遅いです。</target>
        </trans-unit>
        <trans-unit id="ad27eec131dd51571006c484e66faa0226c0bffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized whereas &lt;code&gt;HashMap&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は同期されますが、 &lt;code&gt;HashMap&lt;/code&gt; は同期されません。</target>
        </trans-unit>
        <trans-unit id="25f83877d4ac62b168713576f58b2770a86b5aad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized, whereas &lt;code&gt;HashMap&lt;/code&gt; isn't. That makes &lt;code&gt;Hashtable&lt;/code&gt; slower than &lt;code&gt;Hashmap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は同期されますが、 &lt;code&gt;HashMap&lt;/code&gt; は同期されません。 そのため、 &lt;code&gt;Hashtable&lt;/code&gt; は &lt;code&gt;Hashmap&lt;/code&gt; よりも遅くなります 。</target>
        </trans-unit>
        <trans-unit id="1c596268109b66bf2934f50af140575b7246bd11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized. It is thread-safe and can be shared with many threads.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は同期されます。 スレッドセーフであり、多くのスレッドで共有できます。</target>
        </trans-unit>
        <trans-unit id="7e53d6f6599341af744cd74547e079fc1d2c838b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is traversed by Enumerator and Iterator.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; はEnumeratorとIteratorによってトラバースされます。</target>
        </trans-unit>
        <trans-unit id="006d1c181f3c98522a669dc0abea34770eb93435" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; : if a bucket contains more than 8 nodes, the linked list is transformed into a balanced tree.</source>
          <target state="translated">&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; ：バケットに8個を超えるノードが含まれる場合、リンクリストはバランスの取れたツリーに変換されます。</target>
        </trans-unit>
        <trans-unit id="f9177115bae6161497db808e68ed7cd40b2d6acf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; : when a bucket becomes too small (due to removal or resizing) the tree is converted back to linked list.</source>
          <target state="translated">&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; ：バケットが小さくなった場合（削除またはサイズ変更により）、ツリーはリンクリストに変換されます。</target>
        </trans-unit>
        <trans-unit id="1000b8e627d741fb5080e9ad2ab05068f01c96cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;Hashtable&lt;/code&gt; in case of hash collisions they store the map entries in linked lists. &lt;strong&gt;From Java8 for &lt;code&gt;HashMap&lt;/code&gt;&lt;/strong&gt; if hash bucket grows beyond a certain threshold, that bucket will switch from &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt;&lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt;&lt;/a&gt;. which improve worst-case performance from O(n) to O(log n). While converting the list to binary tree, hashcode is used as a branching variable. If there are two different hashcodes in the same bucket, one is considered bigger and goes to the right of the tree and other one to the left. But when both the hashcodes are equal, &lt;code&gt;HashMap&lt;/code&gt; assumes that the keys are comparable, and compares the key to determine the direction so that some order can be maintained. It is a good practice to make the keys of &lt;code&gt;HashMap&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;comparable&lt;/a&gt;. On adding entries if bucket size reaches &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; convert linked list of entries to a balanced tree, on removing entries less than &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt;  and at most &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; will reconvert  balanced tree to linked list of entries. &lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;stackpost&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;HashMap&lt;/code&gt; 、ハッシュ衝突の場合の &lt;code&gt;Hashtable&lt;/code&gt; は、マップエントリをリンクリストに格納します。&lt;/em&gt; &lt;em&gt;&lt;strong&gt;Java8 for &lt;code&gt;HashMap&lt;/code&gt; から&lt;/strong&gt; 、ハッシュバケットが特定のしきい値を超えた場合、そのバケットは、 &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt; &lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt; &lt;/a&gt;からバランスツリーに切り替わります 。&lt;/em&gt; &lt;em&gt;最悪の場合のパフォーマンスをO（n）からO（log n）に改善します。&lt;/em&gt; &lt;em&gt;リストをバイナリツリーに変換する際、ハッシュコードは分岐変数として使用されます。&lt;/em&gt; &lt;em&gt;同じバケットに2つの異なるハッシュコードがある場合、1つはより大きく、ツリーの右側に移動し、もう1つは左側に移動すると見なされます。&lt;/em&gt; &lt;em&gt;ただし、両方のハッシュコードが等しい場合、 &lt;code&gt;HashMap&lt;/code&gt; はキーが比較可能であると想定し、キーを比較して方向を決定し、何らかの順序を維持できるようにします。&lt;/em&gt; &lt;em&gt; &lt;code&gt;HashMap&lt;/code&gt; のキーを&lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;比較&lt;/a&gt;できるようにすることをお勧めします。&lt;/em&gt; &lt;em&gt;バケットサイズが &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; 達した場合にエントリを追加すると、リンクされたエントリのリストがバランスツリーに変換されます &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; 未満のエントリを削除すると、最大で &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; なると、バランスツリーがリンクされたエントリリストに再変換されます。&lt;/em&gt; &lt;em&gt;&lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt; 、 &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;スタックポスト&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0126875eb118b7807444c7f8bd52e3d668a20cba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; &amp;mdash; sometimes called a container &amp;mdash; is simply an object that groups multiple elements into a single unit. &lt;code&gt;Collection&lt;/code&gt;s are used to store, retrieve, manipulate, and communicate aggregate data. A collections framework &lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt; is a unified architecture for representing and manipulating collections.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt;コンテナーとも呼ばれます）は、複数の要素を1つの単位にグループ化するオブジェクトです。&lt;/em&gt; &lt;em&gt; &lt;code&gt;Collection&lt;/code&gt; は、集計データの保存、取得、操作、通信に使用されます。&lt;/em&gt; &lt;em&gt;コレクションフレームワーク&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt;は、コレクションを表現および操作するための統合アーキテクチャです。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5371f8fa97eb824eece2c3e1f791dbb0a968b11d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HashMap constructs an empty hash table with the default initial capacity &lt;strong&gt;(16)&lt;/strong&gt; and the default load factor (0.75). Where as Hashtable constructs empty hashtable with a default initial capacity &lt;strong&gt;(11)&lt;/strong&gt; and load factor/fill ratio (0.75).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HashMapは、デフォルトの初期容量&lt;strong&gt;（16）&lt;/strong&gt;とデフォルトの負荷係数（0.75）で空のハッシュテーブルを作成します。&lt;/em&gt; &lt;em&gt;Hashtableは、デフォルトの初期容量&lt;strong&gt;（11）&lt;/strong&gt;と負荷係数/充填率（0.75）で空のハッシュテーブルを作成します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8dd40f98b719540fa3ef0929171c1d3bc9907016" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hashtable is a legacy class introduced in &lt;code&gt;JDK1.0&lt;/code&gt;, which is a subclass of Dictionary class. From &lt;code&gt;JDK1.2&lt;/code&gt; Hashtable is re-engineered to implement the &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;Map interface&lt;/a&gt; to make a member of collection framework. HashMap is a member of Java Collection Framework right from the beginning of its introduction in &lt;code&gt;JDK1.2&lt;/code&gt;. HashMap is the subclass of the AbstractMap class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Hashtableは &lt;code&gt;JDK1.0&lt;/code&gt; で導入されたレガシークラスで、Dictionaryクラスのサブクラスです。&lt;/em&gt; &lt;em&gt; &lt;code&gt;JDK1.2&lt;/code&gt; 以降、 Hashtableは、 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;Mapインターフェース&lt;/a&gt;を実装してコレクションフレームワークのメンバーを作成するように再設計されています 。&lt;/em&gt; &lt;em&gt;HashMapは、 &lt;code&gt;JDK1.2&lt;/code&gt; での導入当初からJava Collection Frameworkのメンバーです。&lt;/em&gt; &lt;em&gt;HashMapは、AbstractMapクラスのサブクラスです。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="500218975390156875accb6dbe2f354e3173f3e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a &quot;&lt;code&gt;hash&lt;/code&gt;&lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt;&lt;code&gt;collision&lt;/code&gt;&lt;/a&gt;&quot;, a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;容量はハッシュテーブル内のバケットの数であり、初期容量はハッシュテーブルが作成されたときの容量です。&lt;/em&gt; &lt;em&gt;ハッシュテーブルが開いていることに注意してください。「 &lt;code&gt;hash&lt;/code&gt; &lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt; &lt;code&gt;collision&lt;/code&gt; &lt;/a&gt; 」の場合、単一のバケットに複数のエントリが格納されます。これらのエントリは順番に検索する必要があります。&lt;/em&gt; &lt;em&gt;負荷係数は、ハッシュテーブルの容量が自動的に増加する前に、ハッシュテーブルがどの程度いっぱいになるかを示す尺度です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b2906198844595f36fc6fa0dd97c9082d03f289b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Collection-view iteration, Fail-Fast and Fail-Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;コレクションビューの反復、Fail-FastおよびFail-Safe&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7914abd8212625a168b15acf6950ab3c15a2effa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Initial capacity and Load factor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;初期容量と負荷係数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6993db023d391ae7cbb4cf066cfcb7e989bc8404" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Null Keys And Null Values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;NullキーとNull値&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c20ec51a8964581feeee1ad7fb05fa002cf9687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7511967863d20bb8b4fe1260a05e4cb1bab41336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Structural modification in case of hash collision&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;ハッシュ衝突の場合の構造変更&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fe1bf3045a21d6736352a953873017484a6bc5ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Superclass, Legacy and Collection Framework member&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;スーパークラス、レガシー、コレクションフレームワークメンバー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="185ecb719c3e2e537438ec956fe6478e08b5fe09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Synchronized, Thread Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;同期、スレッドセーフ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ce5fccec3d4c3a9b001c5a415252b106c57db67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32a8a99aed109def0e75d162d6deb196e91238da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Like &lt;code&gt;Hashtable&lt;/code&gt; but unlike &lt;code&gt;HashMap&lt;/code&gt;, this class does not allow null to be used as a key or value.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;Hashtable&lt;/code&gt; と同様ですが、 &lt;code&gt;HashMap&lt;/code&gt; とは異なり、このクラスではnullをキーまたは値として使用できません。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8218937231a3c47bf14d75f244f490d51f3b93e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;例&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="cebcd49ebbc8d28ef3e1865793fbff6f09d04c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap and HashTable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMapとHashTable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c22768d0fd9bc69987104948fcbbae61922d34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46e9a015b499fca6a53da3a15919c4913909cfae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad1ee7e22808c3a788f0a1f004a79a0d59da5d9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt; is like &lt;strong&gt;Hashtable&lt;/strong&gt; but it also accepts key value pair. It allows null for both the keys and the values. Its performance better is better than &lt;code&gt;HashTable&lt;/code&gt;, because it is &lt;code&gt;unsynchronized&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt;は&lt;strong&gt;Hashtableに&lt;/strong&gt;似ていますが、キーと値のペアも受け入れます。 キーと値の両方にnullを許可します。 &lt;code&gt;unsynchronized&lt;/code&gt; であるため、パフォーマンスは &lt;code&gt;HashTable&lt;/code&gt; よりも優れています。</target>
        </trans-unit>
        <trans-unit id="9a8219969622a494e81fa636ffe2146fe95d705f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hashtable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3df875dc7fbdad1a94f31dde139d3c47b9695e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt; is a data structure that retains values of key-value pair. It doesn&amp;rsquo;t allow null for both the keys and the values. You will get a &lt;code&gt;NullPointerException&lt;/code&gt; if you add null value. It is synchronized. So it comes with its cost. Only one thread can access &lt;strong&gt;HashTable&lt;/strong&gt; at a particular time.</source>
          <target state="translated">&lt;strong&gt;ハッシュテーブル&lt;/strong&gt;は、キーと値のペアの値を保持するデータ構造です。 キーと値の両方にnullは許可されません。 null値を追加すると、 &lt;code&gt;NullPointerException&lt;/code&gt; が発生します。 同期されます。 したがって、そのコストが伴います。 特定の時間に1つのスレッドのみが&lt;strong&gt;HashTable&lt;/strong&gt;にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="87f9eccd26b220f3fffdcc16c43e989775ffb9b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Therefore, always stay away from them in new code since there always better alternative in the JCF&lt;/strong&gt; as others had pointed out.</source>
          <target state="translated">&lt;strong&gt;したがって、&lt;/strong&gt;他の人が指摘したよう&lt;strong&gt;に、JCFには常により良い代替手段があるため、新しいコードでは常にそれらから離れてください&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="25d50188019a6203506db4eaf255be67c2575b4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; No, they won't land in 1.8... :(</source>
          <target state="translated">&lt;strong&gt;アップデート：&lt;/strong&gt;いいえ、彼らは1.8に着陸しません... :(</target>
        </trans-unit>
        <trans-unit id="dfb42b9b02e91bb8174c286bcbc7e89091ed670e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;b&gt;NOTE:&lt;/b&gt; The functionality of Enumeration interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;b&gt;注：&lt;/b&gt; Enumerationインターフェースの機能は、Iteratorインターフェースと同じです。&lt;/sub&gt; &lt;sub&gt;さらに、Iteratorはオプションの削除操作を追加し、メソッド名が短くなっています。&lt;/sub&gt; &lt;sub&gt;新しい実装では、列挙型ではなくイテレーターの使用を検討する必要があります。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="ac2433b57b2a782b71863cba68f09953ec4c0263" translate="yes" xml:space="preserve">
          <source>@See</source>
          <target state="translated">@See</target>
        </trans-unit>
        <trans-unit id="6b37ea03133b5dc642ccd5644d5b2ef41cc8ea38" translate="yes" xml:space="preserve">
          <source>A red&amp;ndash;black tree is a kind of self-balancing binary search tree</source>
          <target state="translated">赤黒木は一種の自己均衡二分探索木です</target>
        </trans-unit>
        <trans-unit id="084f214b26afe2233736dea659b6712cd361bbee" translate="yes" xml:space="preserve">
          <source>A very common idiom is to &quot;check then put&quot; &amp;mdash; i.e. look for an entry in the &lt;code&gt;Map&lt;/code&gt;, and add it if it does not already exist. This is not in any way an atomic operation whether you use &lt;code&gt;Hashtable&lt;/code&gt; or &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">非常に一般的なイディオムは「チェックしてから置く」ことです。つまり、 &lt;code&gt;Map&lt;/code&gt; でエントリを探し、まだ存在しない場合は追加します。 &lt;code&gt;Hashtable&lt;/code&gt; と &lt;code&gt;HashMap&lt;/code&gt; のどちらを使用しても、これは決してアトミック操作ではありません。</target>
        </trans-unit>
        <trans-unit id="1ef3449d808edb36ce53bb89ce36fe2cd8e8058d" translate="yes" xml:space="preserve">
          <source>According to Java API Docs, Iterator is always preferred over the Enumeration.</source>
          <target state="translated">Java API ドキュメントによると、列挙よりも常に Iterator が優先されるとのことです。</target>
        </trans-unit>
        <trans-unit id="7b526b4ffbef0a933328ce463df2d1cd68dd7c44" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Hashtable&lt;/code&gt; extends the &lt;code&gt;Dictionary&lt;/code&gt; class, which as the &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocs&lt;/a&gt; state, is obsolete and has been replaced by the &lt;code&gt;Map&lt;/code&gt; interface.</source>
          <target state="translated">また、 &lt;code&gt;Hashtable&lt;/code&gt; は、 &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocの&lt;/a&gt;状態として廃止され、 &lt;code&gt;Map&lt;/code&gt; インターフェースに置き換えられた &lt;code&gt;Dictionary&lt;/code&gt; クラスを拡張することに注意してください。</target>
        </trans-unit>
        <trans-unit id="0f187c58c90f9a43256314abab97119abc44122e" translate="yes" xml:space="preserve">
          <source>An equivalently synchronised &lt;code&gt;HashMap&lt;/code&gt; can be obtained by:</source>
          <target state="translated">同等に同期された &lt;code&gt;HashMap&lt;/code&gt; は、次の方法で取得できます。</target>
        </trans-unit>
        <trans-unit id="e9103e37fff0521b7c39be1ecc0df1aeeea1dd2b" translate="yes" xml:space="preserve">
          <source>Another difference is that iterator in the &lt;code&gt;HashMap&lt;/code&gt; is fail-safe
while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; isn't. If you change the map
while iterating, you'll know.</source>
          <target state="translated">別の違いは、 &lt;code&gt;HashMap&lt;/code&gt; のイテレータはフェイルセーフですが、 &lt;code&gt;Hashtable&lt;/code&gt; の列挙子はフェールセーフではないということです。 反復中にマップを変更すると、わかります。</target>
        </trans-unit>
        <trans-unit id="acee8a439f9e4944ad00c1a48c53ef2a93e9d1fe" translate="yes" xml:space="preserve">
          <source>Another key difference between hashtable and hashmap is that Iterator in the HashMap is  fail-fast  while the enumerator for the Hashtable is not and throw ConcurrentModificationException if any other Thread modifies the map structurally  by adding or removing any element except Iterator's own remove()  method. But this is not a guaranteed behavior and will be done by JVM on best effort.&quot;</source>
          <target state="translated">ハッシュテーブルとハッシュマップのもう一つの重要な違いは、ハッシュマップの Iterator はフェイルファストであるのに対し、ハッシュテーブルの列挙子はフェイルファストではなく、他のスレッドが Iterator 自身の remove()メソッド以外の要素を追加または削除することでマップを構造的に変更した場合に ConcurrentModificationException をスローするという点です。しかし、これは動作を保証するものではなく、JVMがベストエフォートで行うことになります。&quot;</target>
        </trans-unit>
        <trans-unit id="9a3708be3084838c9add3ab49ecf14e2a1b70039" translate="yes" xml:space="preserve">
          <source>Apart from the differences already mentioned, it should be noted that since Java 8, &lt;code&gt;HashMap&lt;/code&gt; dynamically replaces the Nodes (linked list) used in each bucket with TreeNodes (red-black tree), so that even if high hash collisions exist, the worst case &lt;em&gt;when searching&lt;/em&gt; is</source>
          <target state="translated">既に述べた違いは別として、Java 8以降、 &lt;code&gt;HashMap&lt;/code&gt; は各バケットで使用されるノード（リンクされたリスト）を動的にTreeNodes（赤黒ツリー）に置き換えるため、ハッシュの衝突が高い場合でも最悪のケースになることに注意してください。 &lt;em&gt;検索するとき&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="835ac593a034529b8d59e5594146aeee9100a895" translate="yes" xml:space="preserve">
          <source>Are Project Coin's collection enhancements going to be in JDK8?</source>
          <target state="translated">Project Coinのコレクション機能強化はJDK8に搭載されるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="91975686e2264b305fe313101bec221ece54fee0" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized, this makes &lt;code&gt;Hashtable&lt;/code&gt; slightly slower than the &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; は内部的に同期されているため、 Hashtableは &lt;code&gt;HashMap&lt;/code&gt; よりも少し遅くなります。</target>
        </trans-unit>
        <trans-unit id="86480f222192a446b1ab808c5920c537dfc97134" translate="yes" xml:space="preserve">
          <source>Based on the info &lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;here&lt;/a&gt;, I'd recommend going with HashMap.  I think the biggest advantage is that Java will prevent you from modifying it while you are iterating over it, unless you do it through the iterator.</source>
          <target state="translated">&lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;ここ&lt;/a&gt;の情報に基づいて、私はHashMapを使用することをお勧めします。 最大の利点は、イテレータを介して行わない限り、Javaは、反復中に変更できないようにすることです。</target>
        </trans-unit>
        <trans-unit id="d0a56f41ce29c24403b973ae8e801eead605fafd" translate="yes" xml:space="preserve">
          <source>Beside all the other important aspects already mentioned here, Collections API (e.g. Map interface) is being modified all the time to conform to the &quot;latest and greatest&quot; additions to Java spec.</source>
          <target state="translated">ここですでに述べた他の重要な側面に加えて、コレクションAPI(例:マップインターフェース)は、Java仕様の「最新かつ最大の」追加事項に適合するように、常に修正されています。</target>
        </trans-unit>
        <trans-unit id="883db36727c6fc674b9af62ca03268fec3a2fc5d" translate="yes" xml:space="preserve">
          <source>Blog by Manish Chhabra</source>
          <target state="translated">マニッシュ・チャブラのブログ</target>
        </trans-unit>
        <trans-unit id="161ee3e5332fc7ada8de95c3e13e87513aefb405" translate="yes" xml:space="preserve">
          <source>But to correctly implement this logic you need &lt;strong&gt;additional synchronisation&lt;/strong&gt; of the form:</source>
          <target state="translated">ただし、このロジックを正しく実装するには、フォームの&lt;strong&gt;追加の同期&lt;/strong&gt;が必要です。</target>
        </trans-unit>
        <trans-unit id="701dc0240892c2e16f792b706d048825cd15ef02" translate="yes" xml:space="preserve">
          <source>Differences between HashMap and Hashtable</source>
          <target state="translated">ハッシュマップとハッシュテーブルの違い</target>
        </trans-unit>
        <trans-unit id="3df089853d91c18fa4e328324d91b136000d4c1a" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;HashMapEntry&lt;/code&gt;s value is &lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;volatile&lt;/a&gt; thereby ensuring fine grain consistency for contended modifications and subsequent reads; each read reflects the most recently completed update</source>
          <target state="translated">各 &lt;code&gt;HashMapEntry&lt;/code&gt; の値は&lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;揮発&lt;/a&gt;性であるため、競合する変更と後続の読み取りに対して細粒度の一貫性が保証されます。 各読み取りは、最後に完了した更新を反映しています</target>
        </trans-unit>
        <trans-unit id="74b2e0a75cd7cb287224f128b35087ba9f24b35c" translate="yes" xml:space="preserve">
          <source>Enumerator in &lt;code&gt;Hashtable&lt;/code&gt; is not fail-fast.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; の列挙子はフェイルファストではありません。</target>
        </trans-unit>
        <trans-unit id="ada4c28c6e7bcc1c37b1f37cd28e11b4c21a0d85" translate="yes" xml:space="preserve">
          <source>Even iterating over a &lt;code&gt;Hashtable&lt;/code&gt;'s entries (or a &lt;code&gt;HashMap&lt;/code&gt; obtained by &lt;code&gt;Collections.synchronizedMap&lt;/code&gt;) is not thread safe unless you also guard the &lt;code&gt;Map&lt;/code&gt; from being modified through additional synchronization.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; のエントリ（または &lt;code&gt;Collections.synchronizedMap&lt;/code&gt; によって取得された &lt;code&gt;HashMap&lt;/code&gt; ）を繰り返し処理しても、追加の同期によって &lt;code&gt;Map&lt;/code&gt; が変更されないように保護しない限り、スレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="aef57bb24b9645fae322828e390476f8cb44301e" translate="yes" xml:space="preserve">
          <source>FYI, currently,</source>
          <target state="translated">FYI、現在。</target>
        </trans-unit>
        <trans-unit id="65e3d605f886f039cefd6fcaa6b0600199f9e6cb" translate="yes" xml:space="preserve">
          <source>Fail-safe is relevant within the context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object &quot;structurally&quot;, a concurrent modification exception will be thrown. It is possible for other threads though to invoke &lt;code&gt;set&lt;/code&gt; method since it doesn't modify the collection &quot;structurally&quot;. However, if prior to calling &lt;code&gt;set&lt;/code&gt;, the collection has been modified structurally, &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">フェイルセーフは、イテレータのコンテキスト内で関連しています。 イテレータがコレクションオブジェクトで作成されていて、他のスレッドがコレクションオブジェクトを「構造的に」変更しようとすると、同時変更例外がスローされます。 コレクションを「構造的に」変更しないため、他のスレッドが &lt;code&gt;set&lt;/code&gt; メソッドを呼び出すことは可能です。 ただし、 &lt;code&gt;set&lt;/code&gt; を呼び出す前にコレクションが構造的に変更されている場合は、 &lt;code&gt;IllegalArgumentException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="e195bfdae28c7dbd825f2b0cfa215fcc4514276c" translate="yes" xml:space="preserve">
          <source>First and most significant different between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is that, &lt;code&gt;HashMap&lt;/code&gt; is not thread-safe  while &lt;code&gt;Hashtable&lt;/code&gt; is a thread-safe collection.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; と &lt;code&gt;HashMap&lt;/code&gt; の最初で最も重要な違いは、 &lt;code&gt;HashMap&lt;/code&gt; はスレッドセーフではないが、 &lt;code&gt;Hashtable&lt;/code&gt; はスレッドセーフなコレクションであるということです。</target>
        </trans-unit>
        <trans-unit id="4c2940247e674a032904e85951f08703d55f1e27" translate="yes" xml:space="preserve">
          <source>For example, compare Java 5 Map iterating:</source>
          <target state="translated">例えば、Java 5 Mapの反復処理を比較してみましょう。</target>
        </trans-unit>
        <trans-unit id="97aba7dc3fa8453988dd3eaad09f2bfffab2858d" translate="yes" xml:space="preserve">
          <source>For non-threaded apps, use &lt;code&gt;HashMap&lt;/code&gt; since they are otherwise the same in terms of functionality.</source>
          <target state="translated">スレッド化されていないアプリの場合は、機能的には同じなので、 &lt;code&gt;HashMap&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a864fbe79b123e5b3781c7606dbae5a3c23396a8" translate="yes" xml:space="preserve">
          <source>For threaded apps, you can often get away with ConcurrentHashMap- depends on your performance requirements.</source>
          <target state="translated">スレッド型アプリでは、パフォーマンス要件に応じて ConcurrentHashMap を使用することができます。</target>
        </trans-unit>
        <trans-unit id="3df9160472a36ae89d781b3c6ab26022d5640f0e" translate="yes" xml:space="preserve">
          <source>Further reading &lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;What is difference between HashMap and Hashtable in Java?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;参考資料JavaでのHashMapとHashtableの違いは何ですか？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf8d0414df57d55121993c998babc6dc951ab933" translate="yes" xml:space="preserve">
          <source>HashMap and Hashtable both implement java.util.Map interface but there
  are some differences that Java developers must understand to write
  more efficient code. As of the Java 2 platform v1.2, Hashtable class
  was retrofitted to implement the Map interface, making it a member of
  the Java Collections Framework.</source>
          <target state="translated">HashMapとHashtableはどちらもjava.util.Mapインターフェイスを実装していますが、Java開発者がより効率的なコードを書くために理解しなければならないいくつかの違いがあります。Java 2プラットフォームv1.2では、HashtableクラスはMapインターフェースを実装するように改造され、Java Collections Frameworkのメンバーになりました。</target>
        </trans-unit>
        <trans-unit id="ddadac488e5ff532483d1a91068404f62fc5a825" translate="yes" xml:space="preserve">
          <source>HashMap does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">HashMapは、マップの順序が時間の経過とともに一定になることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="eadebb7419f0310830aa9293de3df75d77865879" translate="yes" xml:space="preserve">
          <source>HashMap doesn't guarantee the order in which elements are returned. For HashTable I guess it's the same but I'm not entirely sure, I don't find ressource that clearly state that.</source>
          <target state="translated">HashMap は要素が返される順番を保証していません。HashTable の場合も同じだと思いますが、はっきりとしたソースが見当たらないので完全にはわかりません。</target>
        </trans-unit>
        <trans-unit id="6aedc41f6a22926e230616147632602f9650712c" translate="yes" xml:space="preserve">
          <source>HashMap: It is a class available inside java.util package and it is used to store the element in key and value format.</source>
          <target state="translated">HashMap(ハッシュマップ)のことです。java.utilパッケージ内で利用可能なクラスで、要素をキーと値の形式で格納するために使用されます。</target>
        </trans-unit>
        <trans-unit id="a46f2ebc98dcc8b75520890a511e99f853ea5a9c" translate="yes" xml:space="preserve">
          <source>HashMaps gives you freedom of synchronization and debugging is lot more easier</source>
          <target state="translated">HashMaps は同期の自由度を与え、デバッグがより簡単になります。</target>
        </trans-unit>
        <trans-unit id="78c9bd228fbd8c5d46c4bce0592c89eff91a7d49" translate="yes" xml:space="preserve">
          <source>HashTable and HashMap are member of the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; (since Java 2 platform v1.2, HashTable was retrofitted to implement the Map interface).</source>
          <target state="translated">HashTableとHashMapは、 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Frameworkの&lt;/a&gt;メンバーです（Java 2プラットフォームv1.2以降、HashTableはMapインターフェースを実装するために改良されました）。</target>
        </trans-unit>
        <trans-unit id="df229e5af731d7fbb0555f5de0920510f2c0df41" translate="yes" xml:space="preserve">
          <source>HashTable can only contain non-null object as a key or as a value. HashMap can contain one null key and null values.</source>
          <target state="translated">HashTableは、キーまたは値としてNULL以外のオブジェクトのみを含むことができます。HashMapは、1つのNULLキーとNULL値を含むことができます。</target>
        </trans-unit>
        <trans-unit id="58a95549c3436ee60ecd7871e7ce42d8ae786e25" translate="yes" xml:space="preserve">
          <source>HashTable is considered legacy code, the documentation advise to use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; in place of Hashtable if a thread-safe highly-concurrent implementation is desired.</source>
          <target state="translated">HashTableはレガシーコードと見なされます。ドキュメントでは、スレッドセーフの高度な並行実装が必要な場合は、Hashtableの代わりに&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt;を使用することをお勧めしています。</target>
        </trans-unit>
        <trans-unit id="660b9dcb49d86a9b0d8ca2dbc507dfa2ac01bd00" translate="yes" xml:space="preserve">
          <source>HashTable won't allow null keys or null values. Where as HashMap allows one null key, and multiple null values.</source>
          <target state="translated">HashTableは、NullキーやNull値を許可しません。一方、HashMapは1つのNullキーと複数のNull値を許可します。</target>
        </trans-unit>
        <trans-unit id="22474fbd1e3d38434c362a687e63aec30ae3ab68" translate="yes" xml:space="preserve">
          <source>HashTables are by default synchronized, so it can be used with multiple threads easily. Where as HashMaps are not synchronized by default, so can be used with only single thread.  But you can still convert HashMap to synchronized by using Collections util class's synchronizedMap(Map m) function.</source>
          <target state="translated">ハッシュテーブルはデフォルトでは同期化されているので、複数のスレッドで簡単に利用できます。一方、ハッシュマップはデフォルトでは同期化されていないので、シングルスレッドでしか使用できません。しかし、Collections util classのsynchronizedMap(Map m)関数を使えば、HashMapを同期化することができます。</target>
        </trans-unit>
        <trans-unit id="3739cd326e022a0ec2d5f895c0053c82658a5ec3" translate="yes" xml:space="preserve">
          <source>Hashtable: It is a legacy class which is being recognized inside collection framework.</source>
          <target state="translated">Hashtableのこと。コレクションフレームワークの中で認識されているレガシークラスです。</target>
        </trans-unit>
        <trans-unit id="3c394da10080138b6474986dd183541c34fb7fc8" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;Java collection cheat sheet&lt;/a&gt; that you will find useful. Notice the gray block contains the legacy class HashTable,Vector and Stack.</source>
          <target state="translated">以下は、 &lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;Javaコレクションのチートシート&lt;/a&gt;です。 灰色のブロックには、従来のクラスHashTable、Vector、Stackが含まれています。</target>
        </trans-unit>
        <trans-unit id="0e897a22091a5c72367aa2c68491be56a91daa38" translate="yes" xml:space="preserve">
          <source>Implementations of the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt;&lt;code&gt;ConcurrentMap&lt;/code&gt;&lt;/a&gt; interface (for example &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;) solve some of this by including &lt;strong&gt;thread safe check-then-act semantics&lt;/strong&gt; such as:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt; &lt;code&gt;ConcurrentMap&lt;/code&gt; &lt;/a&gt;インターフェースの実装（たとえば、 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; ）は、次のよう&lt;strong&gt;なスレッドセーフなチェックザントアクトセマンティクス&lt;/strong&gt;を含めることで、この問題の一部を解決し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef247363dca7947ce18807b023f807375513e571" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5 introduced ConcurrentMap Interface&lt;/a&gt;: &lt;code&gt;ConcurrentHashMap&lt;/code&gt; - a highly concurrent, high-performance &lt;code&gt;ConcurrentMap&lt;/code&gt; implementation backed by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for &lt;code&gt;Hashtable&lt;/code&gt;: in addition to implementing &lt;code&gt;ConcurrentMap&lt;/code&gt;, it supports all of the &quot;legacy&quot; methods peculiar to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5で導入されたConcurrentMapインターフェース&lt;/a&gt; ： &lt;code&gt;ConcurrentHashMap&lt;/code&gt; -ハッシュテーブルを &lt;code&gt;ConcurrentMap&lt;/code&gt; する、高度な並行性とパフォーマンスを備えたConcurrentMapの実装。 この実装は、取得の実行時にブロックすることはなく、クライアントは更新の同時実行レベルを選択できます。 これは &lt;code&gt;Hashtable&lt;/code&gt; のドロップイン置換として意図されています。ConcurrentMapの実装に加えて、 &lt;code&gt;Hashtable&lt;/code&gt; に固有の「レガシー」メソッドのすべてをサポートします。</target>
        </trans-unit>
        <trans-unit id="147cebda6bdb73c5d51fbf40ab2e08956d0ec790" translate="yes" xml:space="preserve">
          <source>In Hashtable there is a function contains(), which is very confusing to use. Because the meaning of contains is slightly deviating. Whether it means contains key or contains  value? tough to understand. Same thing in Maps we have ContainsKey() and ContainsValue() functions, which are very easy to understand.</source>
          <target state="translated">Hashtableにはcontains()という関数がありますが、これが非常に紛らわしいです。なぜなら、containsの意味が微妙にずれているからです。それはキーが含まれているか、値が含まれていることを意味するかどうか? 理解するのは難しいです。Mapsでも同じようにContainsKey()とContainsValue()という関数がありますが、これは非常にわかりやすいです。</target>
        </trans-unit>
        <trans-unit id="6b511ed6e04d77fc78318a00b4ae9f36a4f5fa39" translate="yes" xml:space="preserve">
          <source>In Java 1.8 we are also promised to be able to construct and access HashMaps like in good old scripting languages:</source>
          <target state="translated">Java 1.8では、古き良きスクリプト言語のようにHashMapsを構築してアクセスできるようになることも約束されています。</target>
        </trans-unit>
        <trans-unit id="cd8c0f0e029d8fe772c617136311a3f6576de97f" translate="yes" xml:space="preserve">
          <source>In Summary there are significant differences between Hashtable and
  HashMap in Java e.g. thread-safety and speed and based upon that only
  use Hashtable if you absolutely need thread-safety, if you are running
  Java 5 consider using ConcurrentHashMap in Java.</source>
          <target state="translated">要約すると、JavaのHashtableとHashMapの間には、スレッドの安全性や速度などの大きな違いがあり、どうしてもスレッドの安全性が必要な場合にのみHashtableを使用してください。</target>
        </trans-unit>
        <trans-unit id="554d6863c43fc3f761b7ff10daaee4fc3bc6661c" translate="yes" xml:space="preserve">
          <source>In addition to what izb said, &lt;code&gt;HashMap&lt;/code&gt; allows null values, whereas the &lt;code&gt;Hashtable&lt;/code&gt; does not.</source>
          <target state="translated">izbが言ったことに加えて、 &lt;code&gt;HashMap&lt;/code&gt; はnull値を許可しますが、 &lt;code&gt;Hashtable&lt;/code&gt; は許可しません。</target>
        </trans-unit>
        <trans-unit id="0ecd0ae571aba4721ee2996a4fe36a3db474af69" translate="yes" xml:space="preserve">
          <source>In hashmap you can remove element while iterating, safely. where as it is not possible in hashtables.</source>
          <target state="translated">ハッシュマップでは、反復処理中に安全に要素を削除することができます。</target>
        </trans-unit>
        <trans-unit id="7fbd74b62c43cd195aee64e1d4b3f8da3aba383f" translate="yes" xml:space="preserve">
          <source>Iterator in &lt;code&gt;HashMap&lt;/code&gt; is fail-fast.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のイテレーターはフェイルファストです。</target>
        </trans-unit>
        <trans-unit id="3481f252a01b24865e53a0d403077fe7c2bfb108" translate="yes" xml:space="preserve">
          <source>Iterator in the &lt;code&gt;HashMap&lt;/code&gt; is  fail-safe while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; is not and throw &lt;code&gt;ConcurrentModificationException&lt;/code&gt; if any other Thread modifies the map structurally  by adding or removing any element except &lt;code&gt;Iterator&lt;/code&gt;'s own &lt;code&gt;remove()&lt;/code&gt;  method. But this is not a guaranteed behavior and will be done by JVM on best effort.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の Iteratorはフェイルセーフですが、 &lt;code&gt;Hashtable&lt;/code&gt; の列挙子はフェイルセーフではなく、 &lt;code&gt;Iterator&lt;/code&gt; の独自の &lt;code&gt;remove()&lt;/code&gt; メソッド以外の要素を追加または削除して他のスレッドがマップを構造的に変更すると、 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; をスローします。 しかし、これは保証された動作ではなく、JVMによって最善の努力で行われます。</target>
        </trans-unit>
        <trans-unit id="1a2f20d9e57bdf5adc94c3751cd34e64ab8a2d4c" translate="yes" xml:space="preserve">
          <source>Iterators and Enumerations are Fail Safe - reflecting the state at some point since the creation of iterator/enumeration; this allows for simultaneous reads and modifications at the cost of reduced consistency. They do not throw ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time.</source>
          <target state="translated">イテレータと列挙型はフェイルセーフ-イテレータ列挙型が作成されてからのある時点での状態を反映しているため、整合性が低下しますが、同時に読み込みと変更を行うことができます。また、ConcurrentModificationExceptionは発生しません。しかし、イテレータは一度に一つのスレッドでしか使用できないように設計されています。</target>
        </trans-unit>
        <trans-unit id="254d25f74e4ed95d90db28daea166a6ffd3dd1ff" translate="yes" xml:space="preserve">
          <source>Java Collection Matrix</source>
          <target state="translated">ジャワコレクションマトリックス</target>
        </trans-unit>
        <trans-unit id="93f74b798b3d08e2f768288051abb39a0bc5939a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;HashTable&lt;/code&gt; was legacy class before Java Collections Framework (JCF) was introduced and was later retrofitted to implement the &lt;code&gt;Map&lt;/code&gt; interface. So was &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Stack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashTable&lt;/code&gt; は、Java Collections Framework（JCF）が導入される前はレガシークラスであり、後で &lt;code&gt;Map&lt;/code&gt; インターフェースを実装するために改良されたことに留意してください。 &lt;code&gt;Vector&lt;/code&gt; と &lt;code&gt;Stack&lt;/code&gt; もそうだった。</target>
        </trans-unit>
        <trans-unit id="0449de243fc290a860ccfdc65f8437c895fd81b6" translate="yes" xml:space="preserve">
          <source>Map provides Collection views instead of direct support for iteration
 via Enumeration objects. Collection views greatly enhance the
 expressiveness of the interface, as discussed later in this section.
 Map allows you to iterate over keys, values, or key-value pairs;
 &lt;code&gt;Hashtable&lt;/code&gt; does not provide the third option. Map provides a safe way
 to remove entries in the midst of iteration; &lt;code&gt;Hashtable&lt;/code&gt; did not.
 Finally, Map fixes a minor deficiency in the &lt;code&gt;Hashtable&lt;/code&gt; interface.
 &lt;code&gt;Hashtable&lt;/code&gt; has a method called contains, which returns true if the
 &lt;code&gt;Hashtable&lt;/code&gt; contains a given value. Given its name, you'd expect this
 method to return true if the &lt;code&gt;Hashtable&lt;/code&gt; contained a given key, because
 the key is the primary access mechanism for a &lt;code&gt;Hashtable&lt;/code&gt;. The Map
 interface eliminates this source of confusion by renaming the method
 &lt;code&gt;containsValue&lt;/code&gt;. Also, this improves the interface's consistency &amp;mdash;
 &lt;code&gt;containsValue&lt;/code&gt; parallels &lt;code&gt;containsKey&lt;/code&gt;.</source>
          <target state="translated">マップは、列挙オブジェクトを介した反復を直接サポートする代わりに、コレクションビューを提供します。 このセクションで後述するように、コレクションビューはインターフェイスの表現力を大幅に向上させます。 マップを使用すると、キー、値、またはキーと値のペアを反復できます。 &lt;code&gt;Hashtable&lt;/code&gt; には3番目のオプションはありません。 Mapは、反復の途中でエントリを削除する安全な方法を提供します。 &lt;code&gt;Hashtable&lt;/code&gt; はしませんでした。 最後に、マップは &lt;code&gt;Hashtable&lt;/code&gt; インターフェースのマイナーな欠陥を修正します。 &lt;code&gt;Hashtable&lt;/code&gt; にはcontainsというメソッドがあり、 &lt;code&gt;Hashtable&lt;/code&gt; に特定の値が含まれている場合にtrueを返します。 その名前を考えると、キーが &lt;code&gt;Hashtable&lt;/code&gt; の主要なアクセスメカニズムであるため、 Hashtableに特定のキーが含まれている場合、このメソッドはtrueを返すと予想されます。 Mapインターフェースは、メソッド &lt;code&gt;containsValue&lt;/code&gt; の名前を変更することにより、この混乱の原因を排除します 。 また、これによりインターフェースの一貫性が向上します&amp;mdash; &lt;code&gt;containsValue&lt;/code&gt; はcontainsKeysに対応し &lt;code&gt;containsKey&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09cfe8513ef9f55ce5353dca09be872682455571" translate="yes" xml:space="preserve">
          <source>Maps allows you to iterate and retrieve keys, values, and both key-value pairs as well, Where HashTable don't have all this capability.</source>
          <target state="translated">マップでは、キー、値、キーと値のペアを反復して取得することができますが、ハッシュテーブルにはこのような機能がありません。</target>
        </trans-unit>
        <trans-unit id="75a03fb098b6bc659568b1e29783c07476696b21" translate="yes" xml:space="preserve">
          <source>My small contribution :</source>
          <target state="translated">私のささやかな貢献...</target>
        </trans-unit>
        <trans-unit id="cdb51b953f61763ed033a4d76f1f625c07fe774b" translate="yes" xml:space="preserve">
          <source>My source: &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&lt;/a&gt;</source>
          <target state="translated">私のソース： &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http&lt;/a&gt; : //javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html</target>
        </trans-unit>
        <trans-unit id="bcd6c2b779cd4727bdfc8b82c43e554e848868f9" translate="yes" xml:space="preserve">
          <source>Note on Some Important Terms:</source>
          <target state="translated">いくつかの重要な用語についての注意事項。</target>
        </trans-unit>
        <trans-unit id="cc43492870882f3478ca9bc8edfbda8462e1df06" translate="yes" xml:space="preserve">
          <source>Note that HashMap can be synchronized by</source>
          <target state="translated">HashMapは</target>
        </trans-unit>
        <trans-unit id="4918d4974fe3cd4755ebe0e20277ccd382fa12f2" translate="yes" xml:space="preserve">
          <source>Note, that a lot of the answers state that Hashtable is synchronised.  &lt;strong&gt;In practice this buys you very little.&lt;/strong&gt;  The synchronization is on the accessor / mutator methods will stop two threads adding or removing from the map concurrently, but in the real world you will often need additional synchronisation.</source>
          <target state="translated">回答の多くはHashtableが同期されていると述べていることに注意してください。 &lt;strong&gt;実際には、これはほとんどあなたを買いません。&lt;/strong&gt; 同期はaccessor / mutatorメソッドで行われ、2つのスレッドが同時にマップに追加またはマップから削除するのを停止しますが、実際には追加の同期が必要になることがよくあります。</target>
        </trans-unit>
        <trans-unit id="f180d9cd9c023ba8ad54546958cad221aff4883c" translate="yes" xml:space="preserve">
          <source>O(log(n)) for &lt;code&gt;HashMap&lt;/code&gt;&lt;strong&gt;Vs&lt;/strong&gt; O(n) in &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">O（log（n））for &lt;code&gt;HashMap&lt;/code&gt; &lt;strong&gt;Vs&lt;/strong&gt; O（n）in &lt;code&gt;Hashtable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2600125966cb5ea97c2b8c54e0758c7e46ca74a1" translate="yes" xml:space="preserve">
          <source>Old and classic topic, just want to add this helpful blog that explains this:</source>
          <target state="translated">古いと古典的なトピックは、ちょうどこれを説明するこの有用なブログを追加したい。</target>
        </trans-unit>
        <trans-unit id="249a3a46c2e86414c5539f13f4f1a0225a7d5a6f" translate="yes" xml:space="preserve">
          <source>One more notable difference between Hashtable and HashMap is that because of thread-safety and synchronization Hashtable is much slower
  than HashMap if used in Single threaded environment. So if you don&amp;rsquo;t
  need synchronization and HashMap is only used by one thread, it out
  perform Hashtable in Java.</source>
          <target state="translated">HashtableとHashMapのもう1つの注目すべき違いは、スレッドセーフと同期のため、シングルスレッド環境で使用した場合、HashtableはHashMapよりもはるかに遅いということです。 したがって、同期が必要なく、HashMapが1つのスレッドでのみ使用されている場合は、JavaでHashtableを実行します。</target>
        </trans-unit>
        <trans-unit id="179c0a918e92d97127e98c73349a42a66aa21bd6" translate="yes" xml:space="preserve">
          <source>One of HashMap's subclasses is &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt;, so in the event that you'd want predictable iteration order (which is insertion order by default), you could easily swap out the &lt;code&gt;HashMap&lt;/code&gt; for a &lt;code&gt;LinkedHashMap&lt;/code&gt;.  This wouldn't be as easy if you were using &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">HashMapのサブクラスの1つは&lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt;であるため、予測可能な反復順序（デフォルトでは挿入順序）が必要な場合は、 &lt;code&gt;HashMap&lt;/code&gt; を &lt;code&gt;LinkedHashMap&lt;/code&gt; に簡単に交換できます。 &lt;code&gt;Hashtable&lt;/code&gt; を使用している場合、これは簡単ではありません。</target>
        </trans-unit>
        <trans-unit id="1525943ae6179c4dbbe03560c257ffac662fb828" translate="yes" xml:space="preserve">
          <source>One of the major differences between HashMap and Hashtable is that HashMap is non-synchronized whereas Hashtable is synchronized, which
  means Hashtable is thread-safe and can be shared between multiple
  threads but HashMap cannot be shared between multiple threads without
  proper synchronization. Java 5 introduced ConcurrentHashMap which is
  an alternative of Hashtable and provides better scalability than
  Hashtable in Java.Synchronized means only one thread can modify a hash
  table at one point of time. Basically, it means that any thread before
  performing an update on a hashtable will have to acquire a lock on the
  object while others will wait for lock to be released.</source>
          <target state="translated">HashMapとHashtableの大きな違いの一つは、HashMapが非同期であるのに対し、Hashtableは同期化されており、Hashtableはスレッドセーフで複数のスレッド間で共有することができますが、HashMapは適切な同期がないと複数のスレッド間で共有することができません。Java 5では、Hashtableの代替となるConcurrentHashMapが導入され、JavaではHashtableよりも優れたスケーラビリティを提供します。基本的には、ハッシュテーブルの更新を行う前に、他のスレッドがロックが解除されるのを待つ間に、どのスレッドもオブジェクトのロックを取得しなければならないことを意味します。</target>
        </trans-unit>
        <trans-unit id="95781641174af3b5c28daa7afb4c768668074452" translate="yes" xml:space="preserve">
          <source>Performance Improvement for &lt;code&gt;HashMap&lt;/code&gt; in Java 8</source>
          <target state="translated">Java 8の &lt;code&gt;HashMap&lt;/code&gt; のパフォーマンス改善</target>
        </trans-unit>
        <trans-unit id="fee29654ce34b086768db65a4b25fcd54f9ed463" translate="yes" xml:space="preserve">
          <source>Second important difference between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is performance, since &lt;code&gt;HashMap&lt;/code&gt; is not synchronized it perform better than &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; と &lt;code&gt;HashMap&lt;/code&gt; の 2つ目の重要な違いはパフォーマンスです &lt;code&gt;HashMap&lt;/code&gt; は同期されないため、 &lt;code&gt;Hashtable&lt;/code&gt; よりもパフォーマンスが優れています。</target>
        </trans-unit>
        <trans-unit id="b55e592836fe1e61392790c1a6fce30f1803ceb3" translate="yes" xml:space="preserve">
          <source>Separate from the obvious differences discussed extensively in this question, I see the Hashtable as a &quot;manual drive&quot; car where you have better control over the hashing and the HashMap as the &quot;automatic drive&quot; counterpart that will generally perform well.</source>
          <target state="translated">この質問で広範囲に議論されている明らかな違いとは別に、私はHashtableを、ハッシュをよりよくコントロールできる「手動駆動」の車として、HashMapを「自動駆動」の車として、一般的には良いパフォーマンスを発揮すると考えています。</target>
        </trans-unit>
        <trans-unit id="b3a738203d70f6090dfcdd1764cf29833f51bb9d" translate="yes" xml:space="preserve">
          <source>Seriously though, you're better off staying away from &lt;code&gt;Hashtable&lt;/code&gt; altogether. For single-threaded apps, you don't need the extra overhead of synchronisation. For highly concurrent apps, the paranoid synchronisation might lead to starvation, deadlocks, or unnecessary garbage collection pauses. Like Tim Howland pointed out, you might use &lt;code&gt;ConcurrentHashMap&lt;/code&gt; instead.</source>
          <target state="translated">しかし真剣に、あなたは &lt;code&gt;Hashtable&lt;/code&gt; から完全に離れたほうがいいです。 シングルスレッドアプリの場合、同期の追加のオーバーヘッドは必要ありません。 並行性の高いアプリの場合、偏執的な同期により、飢餓、デッドロック、または不要なガベージコレクションの一時停止が発生する可能性があります。 Tim Howlandが指摘したように、代わりに &lt;code&gt;ConcurrentHashMap&lt;/code&gt; を使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="3bdf790b2b1c9d6025dcbecb5bdb37ab2f60d7b4" translate="yes" xml:space="preserve">
          <source>Since synchronization is not an issue for you, I'd recommend &lt;code&gt;HashMap&lt;/code&gt;. If synchronization becomes an issue, you may also look at &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">同期は問題ではないので、 &lt;code&gt;HashMap&lt;/code&gt; をお勧めします。 同期が問題になる場合は、 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt;も確認できます。</target>
        </trans-unit>
        <trans-unit id="7bcb97fa6763fbfe1f0ff48e9f6a9c4dd72d057b" translate="yes" xml:space="preserve">
          <source>Some important points about HashMap and HashTable.
   please read below details.</source>
          <target state="translated">ハッシュマップとハッシュテーブルについて、いくつかの重要なポイントがあります。</target>
        </trans-unit>
        <trans-unit id="2773856ae2356cf0a8e12035c63973404b5e1bef" translate="yes" xml:space="preserve">
          <source>Structurally modification means deleting or inserting element which could effectively change the structure of map.</source>
          <target state="translated">構造的に変更するとは、マップの構造を実質的に変更する可能性のある要素を削除したり挿入したりすることを意味します。</target>
        </trans-unit>
        <trans-unit id="9ac0930f0753d909c7591e062bf09758da70879f" translate="yes" xml:space="preserve">
          <source>Synchronized means only one thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a &lt;code&gt;Hashtable&lt;/code&gt; will have to acquire a lock on the object while others will wait for lock to be released.</source>
          <target state="translated">同期とは、一度に1つのスレッドのみがハッシュテーブルを変更できることを意味します。 基本的に、 &lt;code&gt;Hashtable&lt;/code&gt; で更新を実行する前に、スレッドはオブジェクトのロックを取得する必要がある一方で、他のスレッドはロックが解放されるのを待つことを意味します。</target>
        </trans-unit>
        <trans-unit id="70e8f2a076a2a427c74c96d2d6f12fe9436a1288" translate="yes" xml:space="preserve">
          <source>Take a look at this chart. It provides comparisons between different data structures along with &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. The comparison is precise, clear and easy to understand.</source>
          <target state="translated">このチャートを見てください。 &lt;code&gt;HashMap&lt;/code&gt; と &lt;code&gt;Hashtable&lt;/code&gt; とともに、異なるデータ構造間の比較を提供します。 比較は正確で、明確で、理解しやすいです。</target>
        </trans-unit>
        <trans-unit id="9b64a19c6daf91779b3938d649152906ab363b0e" translate="yes" xml:space="preserve">
          <source>The 5 main differences betwen HashMap and Hashtable</source>
          <target state="translated">HashMapとHashtableの5つの主な違い</target>
        </trans-unit>
        <trans-unit id="072d0888e52948dbd09f33a229cca91be253355a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt; class is roughly equivalent to &lt;code&gt;Hashtable&lt;/code&gt;, except that it is non synchronized and permits nulls. (&lt;code&gt;HashMap&lt;/code&gt; allows null values as key and value whereas &lt;code&gt;Hashtable&lt;/code&gt; doesn't allow &lt;code&gt;null&lt;/code&gt;s).</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; クラスは、非同期でnullを許可することを除いて、 &lt;code&gt;Hashtable&lt;/code&gt; とほぼ同じです。 （ &lt;code&gt;HashMap&lt;/code&gt; ではnull値をキーと値として使用できますが、 &lt;code&gt;Hashtable&lt;/code&gt; では &lt;code&gt;null&lt;/code&gt; を使用できません）。</target>
        </trans-unit>
        <trans-unit id="0aeaae4475437892ad0e711f1d770aca667a7fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.2&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; and Hashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.0&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt;, both are used to represent a group of objects that are represented in &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair. Each &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair is called &lt;code&gt;Entry&lt;/code&gt; object. The collection of Entries is referred by the object of &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. Keys in a collection must be unique or distinctive. [as they are used to retrieve a mapped value a particular key. values in a collection can be duplicated.]</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.2&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt;とHashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.0&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt;はどちらも、 &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; ペアで表されるオブジェクトのグループを表すために使用されます。 &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; 各ペアは、 &lt;code&gt;Entry&lt;/code&gt; オブジェクトと呼ばれます。 エントリのコレクションは、 &lt;code&gt;HashMap&lt;/code&gt; および &lt;code&gt;Hashtable&lt;/code&gt; のオブジェクトによって参照されます。 コレクション内のキーは、一意または一意である必要があります。 [マップされた値、特定のキーを取得するために使用されるため。 コレクション内の値は複製できます。]</target>
        </trans-unit>
        <trans-unit id="00dc41b113291633c52fd58000a80e068e3e22e0" translate="yes" xml:space="preserve">
          <source>The HashMap class is roughly equivalent to Hashtable, except that it permits nulls. (HashMap allows null values as key and value whereas
  Hashtable doesn&amp;rsquo;t allow nulls).</source>
          <target state="translated">HashMapクラスは、nullを許可することを除いて、Hashtableとほぼ同じです。 （HashMapではnull値をキーと値として使用できますが、Hashtableではnullを使用できません）。</target>
        </trans-unit>
        <trans-unit id="f7ecf1afa5b4c9630d2b5dcfbe61d5b627ebd286" translate="yes" xml:space="preserve">
          <source>The Map Interface</source>
          <target state="translated">マップインターフェース</target>
        </trans-unit>
        <trans-unit id="3676c70892d7c609193fc43d310096bd0df0c6be" translate="yes" xml:space="preserve">
          <source>The iterators returned by Map are fail-fast, if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. &lt;strong&gt;Whereas&lt;/strong&gt; the Enumerations returned by Hashtable's keys and elements methods are not fail-fast.</source>
          <target state="translated">Mapによって返されるイテレータはフェイルファストです。イテレータの作成後、マップが構造的にいつでも変更された場合、イテレータ自身のremoveメソッド以外の方法で、イテレータは &lt;code&gt;ConcurrentModificationException&lt;/code&gt; をスローします。 したがって、同時変更に直面した場合、イテレーターは、将来の未確定の時点で恣意的な非決定論的な動作のリスクを冒すのではなく、迅速かつ完全に失敗します。 &lt;strong&gt;一方&lt;/strong&gt; 、Hashtableのキーと要素のメソッドによって返される列挙型はフェイルファストではありません。</target>
        </trans-unit>
        <trans-unit id="e573df66450873c1ddfa83005b4aa24d831fd978" translate="yes" xml:space="preserve">
          <source>The third significant difference between HashMap vs Hashtable is that Iterator in the HashMap is a fail-fast iterator while the
  enumerator for the Hashtable is not and throw
  ConcurrentModificationException if any other Thread modifies the map
  structurally by adding or removing any element except Iterator&amp;rsquo;s own
  remove() method. But this is not a guaranteed behavior and will be
  done by JVM on best effort. This is also an important difference
  between Enumeration and Iterator in Java.</source>
          <target state="translated">HashMapとHashtableの3番目の重要な違いは、HashMapのイテレーターがフェイルファストイテレーターであるのに対し、Hashtableの列挙子はそうではなく、他のスレッドがイテレーター自身のremove（ ） 方法。 しかし、これは保証された動作ではなく、JVMによって最善の努力で行われます。 これは、Javaの列挙とイテレータの重要な違いでもあります。</target>
        </trans-unit>
        <trans-unit id="f56383732ea0646c1b6ccc4780205710d6c51198" translate="yes" xml:space="preserve">
          <source>There are 5 basic differentiations with HashTable and HashMaps.</source>
          <target state="translated">HashTableとHashMapsとの基本的な違いは5つあります。</target>
        </trans-unit>
        <trans-unit id="bb1f8a6f6840706e60372d6f2420a010dbd1ffca" translate="yes" xml:space="preserve">
          <source>There are several differences between &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java:</source>
          <target state="translated">Javaの&lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt;にはいくつかの違いがあります。</target>
        </trans-unit>
        <trans-unit id="5800ffe299a96231836db81f351c861e03ed3697" translate="yes" xml:space="preserve">
          <source>There is many good answer already posted. I'm adding few new points and summarizing it.</source>
          <target state="translated">すでに多くの良い回答が投稿されています。その中で、新たなポイントをいくつか追加してまとめてみました。</target>
        </trans-unit>
        <trans-unit id="df9315b5c785f8ab9f27801657f7477146067793" translate="yes" xml:space="preserve">
          <source>Third difference on &lt;code&gt;Hashtable&lt;/code&gt; vs &lt;code&gt;HashMap&lt;/code&gt; is that &lt;code&gt;Hashtable&lt;/code&gt; is obsolete class and you should be using &lt;code&gt;ConcurrentHashMap&lt;/code&gt; in place of &lt;code&gt;Hashtable&lt;/code&gt; in Java.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; と &lt;code&gt;HashMap&lt;/code&gt; の 3つ目の違いは、 &lt;code&gt;Hashtable&lt;/code&gt; は廃止されたクラスであり、Javaの &lt;code&gt;Hashtable&lt;/code&gt; の代わりに &lt;code&gt;ConcurrentHashMap&lt;/code&gt; を使用する必要があることです。</target>
        </trans-unit>
        <trans-unit id="ee9376793d9967bcbf5a7a8c815e756c9c9ccb2c" translate="yes" xml:space="preserve">
          <source>This question is often asked in interview to check whether candidate understands correct usage of collection classes and is aware of alternative solutions available.</source>
          <target state="translated">この質問は、候補者がコレクションクラスの正しい使い方を理解しているかどうか、代替案を知っているかどうかを確認するために面接でよく聞かれます。</target>
        </trans-unit>
        <trans-unit id="247c0322284eae1d1388216cd3162f7e2cc8e631" translate="yes" xml:space="preserve">
          <source>We can make the &lt;code&gt;HashMap&lt;/code&gt; as synchronized by calling this code</source>
          <target state="translated">このコードを呼び出すことにより、 &lt;code&gt;HashMap&lt;/code&gt; を同期化することができます</target>
        </trans-unit>
        <trans-unit id="c81f8280687b9700ca5bb68ae586570fb7c23f46" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java?</source>
          <target state="translated">Javaの&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt;の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="2c8e95a3c2ffb57733e53c253ed60a5636be3523" translate="yes" xml:space="preserve">
          <source>What is the difference between HashMap and HashTable?</source>
          <target state="translated">HashMapとHashTableの違いは?</target>
        </trans-unit>
        <trans-unit id="ce3ce0552d057e3c8f06c38c4e4073b98a6a4ac5" translate="yes" xml:space="preserve">
          <source>Which is more efficient for non-threaded applications?</source>
          <target state="translated">スレッド化されていないアプリケーションでは、どちらが効率的ですか?</target>
        </trans-unit>
        <trans-unit id="2641089043a1d4d281fa1d792f1ac52e385d9822" translate="yes" xml:space="preserve">
          <source>versus the old Hashtable approach:</source>
          <target state="translated">対して、旧来のHashtableアプローチ。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
