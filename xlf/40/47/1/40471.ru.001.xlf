<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/40471">
    <body>
      <group id="40471">
        <trans-unit id="1ffa479b2bc81d3a4bfacc7ab2a3c758037edec2" translate="yes" xml:space="preserve">
          <source>*The aforementioned improvement has not been applied to &lt;code&gt;Hashtable&lt;/code&gt; yet, but only to &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;LinkedHashMap&lt;/code&gt;, and &lt;code&gt;ConcurrentHashMap&lt;/code&gt;.</source>
          <target state="translated">* Вышеупомянутое улучшение еще не применено к &lt;code&gt;Hashtable&lt;/code&gt; , но только к &lt;code&gt;HashMap&lt;/code&gt; , &lt;code&gt;LinkedHashMap&lt;/code&gt; и &lt;code&gt;ConcurrentHashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bebecfc307c9e1b712693d3b764211b8ed5cfb2" translate="yes" xml:space="preserve">
          <source>1) First difference is HashMap is not thread safe While HashTable is ThreadSafe</source>
          <target state="translated">1)Первое отличие состоит в том,что HashMap не является безопасным для потоков,в то время как HashTable является ThreadSafe.</target>
        </trans-unit>
        <trans-unit id="e93948b799e95b7508984d1cffb6e8a3f9844579" translate="yes" xml:space="preserve">
          <source>1) Hashtable and Hashmap implement the java.util.Map interface
2) Both Hashmap and Hashtable is the hash based collection. and working on hashing.
so these are similarity of HashMap and HashTable.</source>
          <target state="translated">1)Hashtable и Hashmap реализуют интерфейс java.util.map 2)И Hashmap,и Hashtable-это коллекция,основанная на хэше.и работающая на хэше.так что это сходство HashMap и HashTable.</target>
        </trans-unit>
        <trans-unit id="ce8ad15ae4892952ca56baaa8baaa429494f2e53" translate="yes" xml:space="preserve">
          <source>1.&lt;code&gt;Hashmap&lt;/code&gt; and &lt;code&gt;HashTable&lt;/code&gt; both store key and value.</source>
          <target state="translated">1. &lt;code&gt;Hashmap&lt;/code&gt; и HashTable хранят ключ и значение.</target>
        </trans-unit>
        <trans-unit id="ea022165e8aaef91c12ccef2e5123b0265799db7" translate="yes" xml:space="preserve">
          <source>2) HashMap is performance wise better because it is not thread safe. while Hashtable performance wise is not better because it is thread safe. so multiple thread can not access Hashtable at the same time.</source>
          <target state="translated">2)HashMap является мудрым производительности лучше,потому что это не поток безопасной.в то время как Hashtable производительности мудрым не лучше,потому что это поток безопасной.поэтому несколько потоков не может получить доступ к Hashtable в то же время.</target>
        </trans-unit>
        <trans-unit id="2a896733be888d07b7cbb8186abb374063e45bdd" translate="yes" xml:space="preserve">
          <source>2.&lt;code&gt;Hashmap&lt;/code&gt; can store one key as &lt;code&gt;null&lt;/code&gt;. &lt;code&gt;Hashtable&lt;/code&gt; can't store &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">2. &lt;code&gt;Hashmap&lt;/code&gt; может хранить один ключ как ноль . &lt;code&gt;Hashtable&lt;/code&gt; не может хранить &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02a8a35731189356741a2efc879bda9c331af5d6" translate="yes" xml:space="preserve">
          <source>3.&lt;code&gt;HashMap&lt;/code&gt; is not synchronized but &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">3. &lt;code&gt;HashMap&lt;/code&gt; не синхронизируется, но &lt;code&gt;Hashtable&lt;/code&gt; синхронизируется.</target>
        </trans-unit>
        <trans-unit id="7edecd9abb3471db7df504cd6c5936311ca4fa46" translate="yes" xml:space="preserve">
          <source>4.&lt;code&gt;HashMap&lt;/code&gt; can be synchronized with &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt;</source>
          <target state="translated">4. &lt;code&gt;HashMap&lt;/code&gt; можно синхронизировать с &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8772653c67ec1de6492448fff19367167e54b515" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is a legacy class in the jdk that shouldn't be used anymore. Replace usages of it with &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt;. If you don't require thread safety, use &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; which isn't &lt;a href=&quot;http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/concurrent/ThreadSafe.html&quot;&gt;threadsafe&lt;/a&gt; but faster and uses less memory.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; - это устаревший класс в jdk, который больше не должен использоваться. Замените его использование &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; . Если вам не требуется безопасность потоков, используйте &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap,&lt;/a&gt; который не является &lt;a href=&quot;http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/concurrent/ThreadSafe.html&quot;&gt;потокобезопасным,&lt;/a&gt; но быстрее и использует меньше памяти.</target>
        </trans-unit>
        <trans-unit id="a8212855afbfdfadf4f72d52f3fd51313aab01da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is synchronized, if you are using it in a single thread you can use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, which is an unsynchronized version. Unsynchronized objects are often a little more performant. By the way if multiple threads access a HashMap concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. 
Youn can wrap a unsynchronized map in a synchronized one using :</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; синхронизируется, если вы используете его в одном потоке, вы можете использовать &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; , который является несинхронизированной версией. Несинхронизированные объекты часто немного более производительны. Кстати, если несколько потоков одновременно обращаются к HashMap, и хотя бы один из потоков структурно изменяет карту, она должна быть синхронизирована извне. Вы можете обернуть несинхронизированную карту в синхронизированную, используя:</target>
        </trans-unit>
        <trans-unit id="35825761ff3e0e6aae7c813dc0f469fe68798cf4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; is a fail-fast in nature. i.e it throws ConcurrentModificationException if a collection is modified while iterating other than it&amp;rsquo;s own remove() method. Where as &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt;&lt;code&gt;Enumeration&lt;/code&gt;&lt;/a&gt; is fail-safe in nature. It doesn&amp;rsquo;t throw any exceptions if a collection is modified while iterating.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; по своей природе безотказен. то есть он генерирует исключение ConcurrentModificationException, если коллекция изменяется при выполнении итерации, отличной от собственного метода remove (). Где, как &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt; &lt;code&gt;Enumeration&lt;/code&gt; &lt;/a&gt; является отказоустойчивым по своей природе. Он не выдает никаких исключений, если коллекция изменяется во время итерации.</target>
        </trans-unit>
        <trans-unit id="6f5224599c22155916dabf87bba49566ddaa6261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows maximum one null key and any number of null values. Where as &lt;code&gt;Hashtable&lt;/code&gt; doesn&amp;rsquo;t allow even a single null key and null value, if the key or value null is then it throws NullPointerException. &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;Example&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; допускает максимум один нулевой ключ и любое количество нулевых значений. Где, поскольку &lt;code&gt;Hashtable&lt;/code&gt; не допускает даже один нулевой ключ и нулевое значение, если ключ или значение null, то он генерирует исключение NullPointerException. &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;пример&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a5083b226eeb51dc40cc10003425a58b158f81eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows one null key and multiple null values.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; допускает один нулевой ключ и несколько нулевых значений.</target>
        </trans-unit>
        <trans-unit id="669df6fbbd3ba9c388deaba3fc0849ca8f6f2ff6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; both are used to store &lt;em&gt;data in key and value form&lt;/em&gt;. Both are using hashing technique to store unique keys.
But there are many differences between HashMap and Hashtable classes that are given below.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; и &lt;code&gt;Hashtable&lt;/code&gt; оба используются для хранения &lt;em&gt;данных в форме ключа и значения&lt;/em&gt; . Оба используют технику хеширования для хранения уникальных ключей. Но есть много различий между классами HashMap и Hashtable, которые приведены ниже.</target>
        </trans-unit>
        <trans-unit id="0ac053a124fba70f26ef444ee7553d0c4785af36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; have significant algorithmic differences as well. No one has mentioned this before so that's why I am bringing it up. &lt;code&gt;HashMap&lt;/code&gt; will construct a hash table with power of two size, increase it dynamically such that you have at most about eight elements (collisions) in any bucket and will stir the elements very well for general element types. However, the &lt;code&gt;Hashtable&lt;/code&gt; implementation provides better and finer control over the hashing if you know what you are doing, namely you can fix the table size using e.g. the closest prime number to your values domain size and this will result in better performance than HashMap i.e. less collisions for some cases.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; и &lt;code&gt;Hashtable&lt;/code&gt; также имеют значительные алгоритмические различия. Никто не упоминал об этом раньше, поэтому я поднимаю это. &lt;code&gt;HashMap&lt;/code&gt; создаст хэш-таблицу со степенью двойного размера, динамически увеличит ее так, чтобы в каждом сегменте было не более восьми элементов (столкновений), и будет очень хорошо перемешивать элементы для общих типов элементов. Тем не менее, реализация &lt;code&gt;Hashtable&lt;/code&gt; обеспечивает лучший и более точный контроль над хэшированием, если вы знаете, что делаете, а именно, вы можете фиксировать размер таблицы, используя, например, ближайший простое число к размеру домена ваших значений, и это приведет к лучшей производительности, чем HashMap, т.е. меньше столкновения для некоторых случаев.</target>
        </trans-unit>
        <trans-unit id="64a17134b1046d668dd05ac2bc4f97f06a63e76e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; can be synchronized by</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; может быть синхронизирован</target>
        </trans-unit>
        <trans-unit id="d500b59660957bd4381ff369b93e82d00b9b1f70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; не гарантирует, что порядок карты будет оставаться постоянным во времени.</target>
        </trans-unit>
        <trans-unit id="a8747ab7f19811c92ec840fe23f10d94ab4b3af3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; inherits AbstractMap class.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; наследует класс AbstractMap.</target>
        </trans-unit>
        <trans-unit id="51fbe655ee9bcf724b8cabf41a90881d14820a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is a new class introduced in JDK 1.2.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; - это новый класс, представленный в JDK 1.2.</target>
        </trans-unit>
        <trans-unit id="b63a85d53f021a1ae8dd8bdd08fdc18c2b28c4cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is emulated and therefore usable in &lt;code&gt;GWT client code&lt;/code&gt; whereas &lt;code&gt;Hashtable&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; эмулируется и, следовательно, может использоваться в &lt;code&gt;GWT client code&lt;/code&gt; а &lt;code&gt;Hashtable&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="8910e4452555bc0eb462a108515a97d9c3f5b62a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is fast.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; это быстро.</target>
        </trans-unit>
        <trans-unit id="0ac323b983cb93bfa96d446a6acf3e0739d49b02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized whereas &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; не синхронизируется, тогда как &lt;code&gt;Hashtable&lt;/code&gt; синхронизируется.</target>
        </trans-unit>
        <trans-unit id="15bf5350ece84dd8e38bde89e4f666c4333d494b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized. It is not-thread safe and can't be shared between many threads without proper synchronization code.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; не синхронизирован. Он не является потокобезопасным и не может использоваться несколькими потоками без надлежащего кода синхронизации.</target>
        </trans-unit>
        <trans-unit id="7eecfc386a9ddceaa10ba8c78194cc8417a8cc62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is traversed by Iterator.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; просматривается итератором.</target>
        </trans-unit>
        <trans-unit id="8697ca59be21a2145ac021e93da6593a2e482b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; permits null values in it, while &lt;code&gt;Hashtable&lt;/code&gt; doesn't.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; разрешает нулевые значения в нем, а &lt;code&gt;Hashtable&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="ce244b309892513fef48b0c0adb960eea745a513" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt;: An implementation of the &lt;code&gt;Map&lt;/code&gt; interface that uses hash codes to index an array.
&lt;code&gt;Hashtable&lt;/code&gt;: Hi, 1998 called. They want their collections API back.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; : реализация интерфейса &lt;code&gt;Map&lt;/code&gt; , использующая хеш-коды для индексации массива. &lt;code&gt;Hashtable&lt;/code&gt; : Привет, 1998 год называется. Они хотят вернуть свои коллекции API.</target>
        </trans-unit>
        <trans-unit id="aea1fdd84192f7fc2e196adf40609942cb1285de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; does not allow &lt;code&gt;null&lt;/code&gt; keys or values.  &lt;code&gt;HashMap&lt;/code&gt; allows one &lt;code&gt;null&lt;/code&gt; key and any number of &lt;code&gt;null&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; не допускает &lt;code&gt;null&lt;/code&gt; ключи или значения. &lt;code&gt;HashMap&lt;/code&gt; допускает один &lt;code&gt;null&lt;/code&gt; ключ и любое количество &lt;code&gt;null&lt;/code&gt; значений.</target>
        </trans-unit>
        <trans-unit id="da40767d527c7d8ee16fe1095a3c28313aaec00a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; doesn't allow any null key or value.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; не допускает нулевой ключ или значение.</target>
        </trans-unit>
        <trans-unit id="e82d9c21537b4430e511e19537f8747613296279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; inherits Dictionary class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; наследует словарь класса.</target>
        </trans-unit>
        <trans-unit id="473a8e23134d11e4c9e6a5a24f60baccffe8cd5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is &lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;synchronized&lt;/a&gt;, whereas &lt;code&gt;HashMap&lt;/code&gt; is not. This makes &lt;code&gt;HashMap&lt;/code&gt; better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;синхронизируется&lt;/a&gt; , а &lt;code&gt;HashMap&lt;/code&gt; - нет. Это делает &lt;code&gt;HashMap&lt;/code&gt; лучше для непоточных приложений, поскольку несинхронизированные объекты обычно работают лучше, чем синхронизированные.</target>
        </trans-unit>
        <trans-unit id="5f3b80ed3c8119e05343a43fa58d178aa8c248fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is a legacy class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; - это унаследованный класс.</target>
        </trans-unit>
        <trans-unit id="74522ed93d3ffc34a0d85038cae726b8c4697227" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is considered legacy code. There's nothing about &lt;code&gt;Hashtable&lt;/code&gt; that can't be done using &lt;code&gt;HashMap&lt;/code&gt; or derivations of &lt;code&gt;HashMap&lt;/code&gt;, so for new code, I don't see any justification for going back to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; считается устаревшим кодом. В &lt;code&gt;Hashtable&lt;/code&gt; нет ничего такого, что нельзя было бы сделать с помощью &lt;code&gt;HashMap&lt;/code&gt; или производных &lt;code&gt;HashMap&lt;/code&gt; , поэтому для нового кода я не вижу никакого оправдания возвращению в &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="582981ade6fd1fb874a7cbaa7d7f669287851433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized and can't be unsynchronized.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; внутренне синхронизирован и не может быть несинхронизирован.</target>
        </trans-unit>
        <trans-unit id="5b50d2071547d1d8f01971f3564947ceb026e758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized. Therefore, it is very much safe to use &lt;code&gt;Hashtable&lt;/code&gt; in multi threaded applications. Where as &lt;code&gt;HashMap&lt;/code&gt; is not internally synchronized. Therefore, it is not safe to use &lt;code&gt;HashMap&lt;/code&gt; in multi threaded applications without external synchronization. You can externally synchronize &lt;code&gt;HashMap&lt;/code&gt; using &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; внутренне синхронизирован. Поэтому очень безопасно использовать &lt;code&gt;Hashtable&lt;/code&gt; в многопоточных приложениях. Где, поскольку &lt;code&gt;HashMap&lt;/code&gt; не внутренне синхронизирован. Поэтому использование &lt;code&gt;HashMap&lt;/code&gt; в многопоточных приложениях без внешней синхронизации небезопасно. Вы можете внешне синхронизировать &lt;code&gt;HashMap&lt;/code&gt; , используя метод &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e63c856b660603f278bb16d5b114de8a3272ed31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is similar to the &lt;code&gt;HashMap&lt;/code&gt; and has a similar interface. It is recommended that you use &lt;code&gt;HashMap&lt;/code&gt;, unless you require support for legacy applications or you need synchronisation, as the &lt;code&gt;Hashtables&lt;/code&gt; methods are synchronised. So in your case as you are not multi-threading, &lt;code&gt;HashMaps&lt;/code&gt; are your best bet.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; похож на &lt;code&gt;HashMap&lt;/code&gt; и имеет аналогичный интерфейс. Рекомендуется использовать &lt;code&gt;HashMap&lt;/code&gt; , если вам не требуется поддержка устаревших приложений или вам нужна синхронизация, поскольку методы &lt;code&gt;Hashtables&lt;/code&gt; синхронизируются. Так что в вашем случае, поскольку вы не многопоточны, &lt;code&gt;HashMaps&lt;/code&gt; - ваш лучший выбор .</target>
        </trans-unit>
        <trans-unit id="6eaefd6be9ca644fb4dceef1106f715e6f13ce69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is slow.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; медленный.</target>
        </trans-unit>
        <trans-unit id="ad27eec131dd51571006c484e66faa0226c0bffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized whereas &lt;code&gt;HashMap&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; синхронизируется, а &lt;code&gt;HashMap&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="25f83877d4ac62b168713576f58b2770a86b5aad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized, whereas &lt;code&gt;HashMap&lt;/code&gt; isn't. That makes &lt;code&gt;Hashtable&lt;/code&gt; slower than &lt;code&gt;Hashmap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; синхронизируется, а &lt;code&gt;HashMap&lt;/code&gt; - нет. Это делает &lt;code&gt;Hashtable&lt;/code&gt; медленнее, чем &lt;code&gt;Hashmap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c596268109b66bf2934f50af140575b7246bd11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized. It is thread-safe and can be shared with many threads.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; синхронизирован. Это потокобезопасный и может использоваться многими потоками.</target>
        </trans-unit>
        <trans-unit id="7e53d6f6599341af744cd74547e079fc1d2c838b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is traversed by Enumerator and Iterator.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; перебирается перечислителем и итератором.</target>
        </trans-unit>
        <trans-unit id="006d1c181f3c98522a669dc0abea34770eb93435" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; : if a bucket contains more than 8 nodes, the linked list is transformed into a balanced tree.</source>
          <target state="translated">&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; : если корзина содержит более 8 узлов, связанный список преобразуется в сбалансированное дерево.</target>
        </trans-unit>
        <trans-unit id="f9177115bae6161497db808e68ed7cd40b2d6acf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; : when a bucket becomes too small (due to removal or resizing) the tree is converted back to linked list.</source>
          <target state="translated">&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; : когда корзина становится слишком маленькой (из-за удаления или изменения размера), дерево преобразуется обратно в связанный список.</target>
        </trans-unit>
        <trans-unit id="1000b8e627d741fb5080e9ad2ab05068f01c96cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;Hashtable&lt;/code&gt; in case of hash collisions they store the map entries in linked lists. &lt;strong&gt;From Java8 for &lt;code&gt;HashMap&lt;/code&gt;&lt;/strong&gt; if hash bucket grows beyond a certain threshold, that bucket will switch from &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt;&lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt;&lt;/a&gt;. which improve worst-case performance from O(n) to O(log n). While converting the list to binary tree, hashcode is used as a branching variable. If there are two different hashcodes in the same bucket, one is considered bigger and goes to the right of the tree and other one to the left. But when both the hashcodes are equal, &lt;code&gt;HashMap&lt;/code&gt; assumes that the keys are comparable, and compares the key to determine the direction so that some order can be maintained. It is a good practice to make the keys of &lt;code&gt;HashMap&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;comparable&lt;/a&gt;. On adding entries if bucket size reaches &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; convert linked list of entries to a balanced tree, on removing entries less than &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt;  and at most &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; will reconvert  balanced tree to linked list of entries. &lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;stackpost&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;HashMap&lt;/code&gt; , &lt;code&gt;Hashtable&lt;/code&gt; в случае коллизий хешей они хранят записи карты в связанных списках.&lt;/em&gt; &lt;em&gt;&lt;strong&gt;От Java8 для &lt;code&gt;HashMap&lt;/code&gt; ,&lt;/strong&gt; если &lt;strong&gt;объем&lt;/strong&gt; хеш- &lt;strong&gt;памяти&lt;/strong&gt; превышает определенный порог, этот сегмент переключится из &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt; &lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt; &lt;/a&gt; .&lt;/em&gt; &lt;em&gt;которые улучшают производительность в худшем случае с O (n) до O (log n).&lt;/em&gt; &lt;em&gt;При преобразовании списка в двоичное дерево хеш-код используется как переменная ветвления.&lt;/em&gt; &lt;em&gt;Если в одном ведре есть два разных хэш-кода, один считается больше и идет справа от дерева, а другой - слева.&lt;/em&gt; &lt;em&gt;Но когда оба хеш-кода равны, &lt;code&gt;HashMap&lt;/code&gt; предполагает, что ключи сравнимы, и сравнивает ключ для определения направления, чтобы можно было поддерживать некоторый порядок.&lt;/em&gt; &lt;em&gt;Хорошей практикой является &lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;сопоставление&lt;/a&gt; ключей &lt;code&gt;HashMap&lt;/code&gt; .&lt;/em&gt; &lt;em&gt;При добавлении записей, если размер &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; достигает TREEIFY_THRESHOLD = 8, преобразовать связанный список записей в сбалансированное дерево, при удалении записей, меньших &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; и не более &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; , преобразует сбалансированное дерево в связанный список записей.&lt;/em&gt; &lt;em&gt;&lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;стека&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0126875eb118b7807444c7f8bd52e3d668a20cba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; &amp;mdash; sometimes called a container &amp;mdash; is simply an object that groups multiple elements into a single unit. &lt;code&gt;Collection&lt;/code&gt;s are used to store, retrieve, manipulate, and communicate aggregate data. A collections framework &lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt; is a unified architecture for representing and manipulating collections.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; иногда называемая контейнером, - это просто объект, который группирует несколько элементов в одну единицу.&lt;/em&gt; &lt;em&gt; &lt;code&gt;Collection&lt;/code&gt; используются для хранения, извлечения, обработки и передачи агрегированных данных.&lt;/em&gt; &lt;em&gt;Структура коллекций &lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt; представляет собой унифицированную архитектуру для представления и управления коллекциями.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5371f8fa97eb824eece2c3e1f791dbb0a968b11d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HashMap constructs an empty hash table with the default initial capacity &lt;strong&gt;(16)&lt;/strong&gt; and the default load factor (0.75). Where as Hashtable constructs empty hashtable with a default initial capacity &lt;strong&gt;(11)&lt;/strong&gt; and load factor/fill ratio (0.75).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HashMap создает пустую хеш-таблицу с начальной емкостью по умолчанию &lt;strong&gt;(16)&lt;/strong&gt; и коэффициентом загрузки по умолчанию (0,75).&lt;/em&gt; &lt;em&gt;Где as Hashtable создает пустой хеш-таблицу с начальной емкостью по умолчанию &lt;strong&gt;(11)&lt;/strong&gt; и коэффициентом загрузки / коэффициентом заполнения (0,75).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8dd40f98b719540fa3ef0929171c1d3bc9907016" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hashtable is a legacy class introduced in &lt;code&gt;JDK1.0&lt;/code&gt;, which is a subclass of Dictionary class. From &lt;code&gt;JDK1.2&lt;/code&gt; Hashtable is re-engineered to implement the &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;Map interface&lt;/a&gt; to make a member of collection framework. HashMap is a member of Java Collection Framework right from the beginning of its introduction in &lt;code&gt;JDK1.2&lt;/code&gt;. HashMap is the subclass of the AbstractMap class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Hashtable - это устаревший класс, представленный в &lt;code&gt;JDK1.0&lt;/code&gt; , который является подклассом класса Dictionary.&lt;/em&gt; &lt;em&gt;Начиная с &lt;code&gt;JDK1.2&lt;/code&gt; , Hashtable переработан для реализации &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;интерфейса Map,&lt;/a&gt; чтобы сделать его частью структуры коллекции.&lt;/em&gt; &lt;em&gt;HashMap является членом Java Collection Framework с самого начала его появления в &lt;code&gt;JDK1.2&lt;/code&gt; .&lt;/em&gt; &lt;em&gt;HashMap является подклассом класса AbstractMap.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="500218975390156875accb6dbe2f354e3173f3e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a &quot;&lt;code&gt;hash&lt;/code&gt;&lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt;&lt;code&gt;collision&lt;/code&gt;&lt;/a&gt;&quot;, a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Емкость - это количество сегментов в хэш-таблице, а начальная емкость - это просто емкость на момент создания хеш-таблицы.&lt;/em&gt; &lt;em&gt;Обратите внимание, что хеш-таблица открыта: в случае &amp;laquo; &lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt; &lt;code&gt;collision&lt;/code&gt; &lt;/a&gt; &lt;code&gt;hash&lt;/code&gt; &amp;raquo; в одном сегменте хранится несколько записей, которые необходимо искать последовательно.&lt;/em&gt; &lt;em&gt;Коэффициент загрузки - это мера того, насколько полной хеш-таблице разрешено получать до того, как ее емкость будет автоматически увеличена.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b2906198844595f36fc6fa0dd97c9082d03f289b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Collection-view iteration, Fail-Fast and Fail-Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Итерация с использованием коллекции, Fail-Fast и Fail-Safe&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7914abd8212625a168b15acf6950ab3c15a2effa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Initial capacity and Load factor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Начальная емкость и коэффициент загрузки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6993db023d391ae7cbb4cf066cfcb7e989bc8404" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Null Keys And Null Values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Нулевые ключи и нулевые значения&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c20ec51a8964581feeee1ad7fb05fa002cf9687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7511967863d20bb8b4fe1260a05e4cb1bab41336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Structural modification in case of hash collision&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Структурная модификация при столкновении хэшей&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fe1bf3045a21d6736352a953873017484a6bc5ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Superclass, Legacy and Collection Framework member&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Член суперкласса, Legacy и Collection Framework&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="185ecb719c3e2e537438ec956fe6478e08b5fe09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Synchronized, Thread Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;Синхронизировано, Thread Safe&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ce5fccec3d4c3a9b001c5a415252b106c57db67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32a8a99aed109def0e75d162d6deb196e91238da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Like &lt;code&gt;Hashtable&lt;/code&gt; but unlike &lt;code&gt;HashMap&lt;/code&gt;, this class does not allow null to be used as a key or value.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Как и &lt;code&gt;Hashtable&lt;/code&gt; , но в отличие от &lt;code&gt;HashMap&lt;/code&gt; , этот класс не позволяет использовать null в качестве ключа или значения.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8218937231a3c47bf14d75f244f490d51f3b93e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;Пример&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="cebcd49ebbc8d28ef3e1865793fbff6f09d04c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap and HashTable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap и HashTable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c22768d0fd9bc69987104948fcbbae61922d34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46e9a015b499fca6a53da3a15919c4913909cfae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad1ee7e22808c3a788f0a1f004a79a0d59da5d9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt; is like &lt;strong&gt;Hashtable&lt;/strong&gt; but it also accepts key value pair. It allows null for both the keys and the values. Its performance better is better than &lt;code&gt;HashTable&lt;/code&gt;, because it is &lt;code&gt;unsynchronized&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt; похож на &lt;strong&gt;Hashtable,&lt;/strong&gt; но он также принимает пару ключ-значение. Это позволяет null для ключей и значений. Его производительность лучше, чем у &lt;code&gt;HashTable&lt;/code&gt; , потому что он не &lt;code&gt;unsynchronized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a8219969622a494e81fa636ffe2146fe95d705f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hashtable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3df875dc7fbdad1a94f31dde139d3c47b9695e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt; is a data structure that retains values of key-value pair. It doesn&amp;rsquo;t allow null for both the keys and the values. You will get a &lt;code&gt;NullPointerException&lt;/code&gt; if you add null value. It is synchronized. So it comes with its cost. Only one thread can access &lt;strong&gt;HashTable&lt;/strong&gt; at a particular time.</source>
          <target state="translated">&lt;strong&gt;Hashtable&lt;/strong&gt; - это структура данных, которая сохраняет значения пары ключ-значение. Это не позволяет null для ключей и значений. Вы получите &lt;code&gt;NullPointerException&lt;/code&gt; , если добавите нулевое значение. Это синхронизировано. Так что это идет с его стоимостью. Только один поток может получить доступ к &lt;strong&gt;HashTable&lt;/strong&gt; в определенное время.</target>
        </trans-unit>
        <trans-unit id="87f9eccd26b220f3fffdcc16c43e989775ffb9b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Therefore, always stay away from them in new code since there always better alternative in the JCF&lt;/strong&gt; as others had pointed out.</source>
          <target state="translated">&lt;strong&gt;Поэтому всегда избегайте их в новом коде, поскольку в JCF всегда есть лучшая альтернатива,&lt;/strong&gt; как указывали другие.</target>
        </trans-unit>
        <trans-unit id="25d50188019a6203506db4eaf255be67c2575b4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; No, they won't land in 1.8... :(</source>
          <target state="translated">&lt;strong&gt;Обновление:&lt;/strong&gt; нет, они не будут приземляться в 1.8 ... :(</target>
        </trans-unit>
        <trans-unit id="dfb42b9b02e91bb8174c286bcbc7e89091ed670e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;b&gt;NOTE:&lt;/b&gt; The functionality of Enumeration interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;b&gt;ПРИМЕЧАНИЕ&lt;/b&gt; . Функциональность интерфейса перечисления дублируется интерфейсом итератора.&lt;/sub&gt; &lt;sub&gt;Кроме того, Iterator добавляет необязательную операцию удаления и имеет более короткие имена методов.&lt;/sub&gt; &lt;sub&gt;Новые реализации должны рассмотреть возможность использования Iterator вместо Enumeration.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="ac2433b57b2a782b71863cba68f09953ec4c0263" translate="yes" xml:space="preserve">
          <source>@See</source>
          <target state="translated">@See</target>
        </trans-unit>
        <trans-unit id="6b37ea03133b5dc642ccd5644d5b2ef41cc8ea38" translate="yes" xml:space="preserve">
          <source>A red&amp;ndash;black tree is a kind of self-balancing binary search tree</source>
          <target state="translated">Красно-черное дерево - это своего рода самобалансирующееся дерево бинарного поиска</target>
        </trans-unit>
        <trans-unit id="084f214b26afe2233736dea659b6712cd361bbee" translate="yes" xml:space="preserve">
          <source>A very common idiom is to &quot;check then put&quot; &amp;mdash; i.e. look for an entry in the &lt;code&gt;Map&lt;/code&gt;, and add it if it does not already exist. This is not in any way an atomic operation whether you use &lt;code&gt;Hashtable&lt;/code&gt; or &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Очень распространенная идиома - &amp;laquo;проверить, затем положить&amp;raquo; - то есть найти запись на &lt;code&gt;Map&lt;/code&gt; и добавить ее, если она еще не существует. Это ни в коем случае не атомарная операция, используете ли вы &lt;code&gt;Hashtable&lt;/code&gt; или &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ef3449d808edb36ce53bb89ce36fe2cd8e8058d" translate="yes" xml:space="preserve">
          <source>According to Java API Docs, Iterator is always preferred over the Enumeration.</source>
          <target state="translated">Согласно Java API Docs,итератор всегда предпочтительнее перечисления.</target>
        </trans-unit>
        <trans-unit id="7b526b4ffbef0a933328ce463df2d1cd68dd7c44" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Hashtable&lt;/code&gt; extends the &lt;code&gt;Dictionary&lt;/code&gt; class, which as the &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocs&lt;/a&gt; state, is obsolete and has been replaced by the &lt;code&gt;Map&lt;/code&gt; interface.</source>
          <target state="translated">Также обратите внимание, что &lt;code&gt;Hashtable&lt;/code&gt; расширяет класс &lt;code&gt;Dictionary&lt;/code&gt; , который как состояние &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocs&lt;/a&gt; устарел и был заменен интерфейсом &lt;code&gt;Map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f187c58c90f9a43256314abab97119abc44122e" translate="yes" xml:space="preserve">
          <source>An equivalently synchronised &lt;code&gt;HashMap&lt;/code&gt; can be obtained by:</source>
          <target state="translated">Эквивалентно синхронизированный &lt;code&gt;HashMap&lt;/code&gt; можно получить:</target>
        </trans-unit>
        <trans-unit id="e9103e37fff0521b7c39be1ecc0df1aeeea1dd2b" translate="yes" xml:space="preserve">
          <source>Another difference is that iterator in the &lt;code&gt;HashMap&lt;/code&gt; is fail-safe
while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; isn't. If you change the map
while iterating, you'll know.</source>
          <target state="translated">Другое отличие состоит в том, что итератор в &lt;code&gt;HashMap&lt;/code&gt; является отказоустойчивым, а перечислитель для &lt;code&gt;Hashtable&lt;/code&gt; - нет. Если вы измените карту во время итерации, вы будете знать.</target>
        </trans-unit>
        <trans-unit id="acee8a439f9e4944ad00c1a48c53ef2a93e9d1fe" translate="yes" xml:space="preserve">
          <source>Another key difference between hashtable and hashmap is that Iterator in the HashMap is  fail-fast  while the enumerator for the Hashtable is not and throw ConcurrentModificationException if any other Thread modifies the map structurally  by adding or removing any element except Iterator's own remove()  method. But this is not a guaranteed behavior and will be done by JVM on best effort.&quot;</source>
          <target state="translated">Другое ключевое различие между hashtable и hashmap заключается в том,что Iterator в HashMap является отказоустойчивым,в то время как enumerator для Hashtable не является и бросает ConcurrentModificationException,если любая другая Thread изменяет карту структурно путем добавления или удаления любого элемента,за исключением собственного метода удалить (remove())Iterator.Но это не является гарантированным поведением и будет сделано JVM с максимальными усилиями&quot;.</target>
        </trans-unit>
        <trans-unit id="9a3708be3084838c9add3ab49ecf14e2a1b70039" translate="yes" xml:space="preserve">
          <source>Apart from the differences already mentioned, it should be noted that since Java 8, &lt;code&gt;HashMap&lt;/code&gt; dynamically replaces the Nodes (linked list) used in each bucket with TreeNodes (red-black tree), so that even if high hash collisions exist, the worst case &lt;em&gt;when searching&lt;/em&gt; is</source>
          <target state="translated">Помимо уже упомянутых различий, следует отметить, что, начиная с Java 8, &lt;code&gt;HashMap&lt;/code&gt; динамически заменяет узлы (связанный список), используемые в каждом сегменте, на TreeNodes (красно-черное дерево), так что даже если существуют коллизии с высоким хешем, наихудший случай &lt;em&gt;когда поиск&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="835ac593a034529b8d59e5594146aeee9100a895" translate="yes" xml:space="preserve">
          <source>Are Project Coin's collection enhancements going to be in JDK8?</source>
          <target state="translated">Будут ли усовершенствования коллекции Project Coin в JDK8?</target>
        </trans-unit>
        <trans-unit id="91975686e2264b305fe313101bec221ece54fee0" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized, this makes &lt;code&gt;Hashtable&lt;/code&gt; slightly slower than the &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;Hashtable&lt;/code&gt; внутренне синхронизирован, это делает &lt;code&gt;Hashtable&lt;/code&gt; немного медленнее, чем &lt;code&gt;HashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86480f222192a446b1ab808c5920c537dfc97134" translate="yes" xml:space="preserve">
          <source>Based on the info &lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;here&lt;/a&gt;, I'd recommend going with HashMap.  I think the biggest advantage is that Java will prevent you from modifying it while you are iterating over it, unless you do it through the iterator.</source>
          <target state="translated">Основываясь на информации &lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;здесь&lt;/a&gt; , я бы порекомендовал перейти с HashMap. Я думаю, что наибольшим преимуществом является то, что Java не позволит вам изменять его, пока вы выполняете итерацию, если вы не делаете это через итератор.</target>
        </trans-unit>
        <trans-unit id="d0a56f41ce29c24403b973ae8e801eead605fafd" translate="yes" xml:space="preserve">
          <source>Beside all the other important aspects already mentioned here, Collections API (e.g. Map interface) is being modified all the time to conform to the &quot;latest and greatest&quot; additions to Java spec.</source>
          <target state="translated">Наряду со всеми другими важными аспектами,уже упомянутыми здесь,Collections API (например,интерфейс карты)постоянно модифицируется,чтобы соответствовать &quot;последним и самым большим&quot; дополнениям к спецификации Java.</target>
        </trans-unit>
        <trans-unit id="883db36727c6fc674b9af62ca03268fec3a2fc5d" translate="yes" xml:space="preserve">
          <source>Blog by Manish Chhabra</source>
          <target state="translated">Блог Маниша Чхабры</target>
        </trans-unit>
        <trans-unit id="161ee3e5332fc7ada8de95c3e13e87513aefb405" translate="yes" xml:space="preserve">
          <source>But to correctly implement this logic you need &lt;strong&gt;additional synchronisation&lt;/strong&gt; of the form:</source>
          <target state="translated">Но чтобы правильно реализовать эту логику, вам нужна &lt;strong&gt;дополнительная синхронизация&lt;/strong&gt; формы:</target>
        </trans-unit>
        <trans-unit id="701dc0240892c2e16f792b706d048825cd15ef02" translate="yes" xml:space="preserve">
          <source>Differences between HashMap and Hashtable</source>
          <target state="translated">Различия между HashMap и Hashtable</target>
        </trans-unit>
        <trans-unit id="3df089853d91c18fa4e328324d91b136000d4c1a" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;HashMapEntry&lt;/code&gt;s value is &lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;volatile&lt;/a&gt; thereby ensuring fine grain consistency for contended modifications and subsequent reads; each read reflects the most recently completed update</source>
          <target state="translated">Каждое значение &lt;code&gt;HashMapEntry&lt;/code&gt; является &lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;изменчивым,&lt;/a&gt; обеспечивая тем самым высокую согласованность зерна для предполагаемых изменений и последующих чтений; каждое чтение отражает последнее завершенное обновление</target>
        </trans-unit>
        <trans-unit id="74b2e0a75cd7cb287224f128b35087ba9f24b35c" translate="yes" xml:space="preserve">
          <source>Enumerator in &lt;code&gt;Hashtable&lt;/code&gt; is not fail-fast.</source>
          <target state="translated">Перечислитель в &lt;code&gt;Hashtable&lt;/code&gt; не работает быстро.</target>
        </trans-unit>
        <trans-unit id="ada4c28c6e7bcc1c37b1f37cd28e11b4c21a0d85" translate="yes" xml:space="preserve">
          <source>Even iterating over a &lt;code&gt;Hashtable&lt;/code&gt;'s entries (or a &lt;code&gt;HashMap&lt;/code&gt; obtained by &lt;code&gt;Collections.synchronizedMap&lt;/code&gt;) is not thread safe unless you also guard the &lt;code&gt;Map&lt;/code&gt; from being modified through additional synchronization.</source>
          <target state="translated">Даже перебор записей &lt;code&gt;Hashtable&lt;/code&gt; (или &lt;code&gt;HashMap&lt;/code&gt; , полученного с помощью &lt;code&gt;Collections.synchronizedMap&lt;/code&gt; ) не является потокобезопасным, если вы также не защитите &lt;code&gt;Map&lt;/code&gt; от изменения посредством дополнительной синхронизации.</target>
        </trans-unit>
        <trans-unit id="aef57bb24b9645fae322828e390476f8cb44301e" translate="yes" xml:space="preserve">
          <source>FYI, currently,</source>
          <target state="translated">К твоему сведению,</target>
        </trans-unit>
        <trans-unit id="65e3d605f886f039cefd6fcaa6b0600199f9e6cb" translate="yes" xml:space="preserve">
          <source>Fail-safe is relevant within the context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object &quot;structurally&quot;, a concurrent modification exception will be thrown. It is possible for other threads though to invoke &lt;code&gt;set&lt;/code&gt; method since it doesn't modify the collection &quot;structurally&quot;. However, if prior to calling &lt;code&gt;set&lt;/code&gt;, the collection has been modified structurally, &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">Отказоустойчивость актуальна в контексте итераторов. Если для объекта коллекции был создан итератор, и какой-то другой поток пытается модифицировать объект коллекции &amp;laquo;структурно&amp;raquo;, то возникает исключение одновременной модификации. Однако другие потоки могут вызывать метод &lt;code&gt;set&lt;/code&gt; , поскольку он не изменяет коллекцию &amp;laquo;структурно&amp;raquo;. Однако, если до вызова &lt;code&gt;set&lt;/code&gt; , коллекция была изменена структурно, &lt;code&gt;IllegalArgumentException&lt;/code&gt; будет выброшен.</target>
        </trans-unit>
        <trans-unit id="e195bfdae28c7dbd825f2b0cfa215fcc4514276c" translate="yes" xml:space="preserve">
          <source>First and most significant different between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is that, &lt;code&gt;HashMap&lt;/code&gt; is not thread-safe  while &lt;code&gt;Hashtable&lt;/code&gt; is a thread-safe collection.</source>
          <target state="translated">Первое и наиболее существенное различие между &lt;code&gt;Hashtable&lt;/code&gt; и &lt;code&gt;HashMap&lt;/code&gt; заключается в том, что &lt;code&gt;HashMap&lt;/code&gt; не является поточно- &lt;code&gt;Hashtable&lt;/code&gt; а Hashtable является поточно-ориентированным набором.</target>
        </trans-unit>
        <trans-unit id="4c2940247e674a032904e85951f08703d55f1e27" translate="yes" xml:space="preserve">
          <source>For example, compare Java 5 Map iterating:</source>
          <target state="translated">Например,сравните итерацию Java 5 Map:</target>
        </trans-unit>
        <trans-unit id="97aba7dc3fa8453988dd3eaad09f2bfffab2858d" translate="yes" xml:space="preserve">
          <source>For non-threaded apps, use &lt;code&gt;HashMap&lt;/code&gt; since they are otherwise the same in terms of functionality.</source>
          <target state="translated">Для непоточных приложений используйте &lt;code&gt;HashMap&lt;/code&gt; , поскольку в остальном они одинаковы по функциональности.</target>
        </trans-unit>
        <trans-unit id="a864fbe79b123e5b3781c7606dbae5a3c23396a8" translate="yes" xml:space="preserve">
          <source>For threaded apps, you can often get away with ConcurrentHashMap- depends on your performance requirements.</source>
          <target state="translated">Для потоковых приложений,вы часто можете обойтись без ConcurrentHashMap-зависит от ваших требований к производительности.</target>
        </trans-unit>
        <trans-unit id="3df9160472a36ae89d781b3c6ab26022d5640f0e" translate="yes" xml:space="preserve">
          <source>Further reading &lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;What is difference between HashMap and Hashtable in Java?&lt;/a&gt;</source>
          <target state="translated">Дальнейшее чтение В &lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;чем разница между HashMap и Hashtable в Java?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf8d0414df57d55121993c998babc6dc951ab933" translate="yes" xml:space="preserve">
          <source>HashMap and Hashtable both implement java.util.Map interface but there
  are some differences that Java developers must understand to write
  more efficient code. As of the Java 2 platform v1.2, Hashtable class
  was retrofitted to implement the Map interface, making it a member of
  the Java Collections Framework.</source>
          <target state="translated">HashMap и Hashtable реализуют интерфейс java.util.Map,но есть некоторые различия,которые разработчики Java должны понимать,чтобы писать более эффективный код.Начиная с платформы Java 2 версии 1.2,класс Hashtable был модернизирован для реализации интерфейса Map,что сделало его членом Java Collections Framework.</target>
        </trans-unit>
        <trans-unit id="ddadac488e5ff532483d1a91068404f62fc5a825" translate="yes" xml:space="preserve">
          <source>HashMap does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">HashMap не гарантирует,что порядок на карте останется неизменным с течением времени.</target>
        </trans-unit>
        <trans-unit id="eadebb7419f0310830aa9293de3df75d77865879" translate="yes" xml:space="preserve">
          <source>HashMap doesn't guarantee the order in which elements are returned. For HashTable I guess it's the same but I'm not entirely sure, I don't find ressource that clearly state that.</source>
          <target state="translated">HashMap не гарантирует порядок возврата элементов.Для HashTable,наверное,то же самое,но я не совсем уверен,я не нахожу такого источника,который бы ясно указывал на это.</target>
        </trans-unit>
        <trans-unit id="6aedc41f6a22926e230616147632602f9650712c" translate="yes" xml:space="preserve">
          <source>HashMap: It is a class available inside java.util package and it is used to store the element in key and value format.</source>
          <target state="translated">ХэшМэп:Это класс,доступный внутри пакета java.util,который используется для хранения элемента в формате ключа и значения.</target>
        </trans-unit>
        <trans-unit id="a46f2ebc98dcc8b75520890a511e99f853ea5a9c" translate="yes" xml:space="preserve">
          <source>HashMaps gives you freedom of synchronization and debugging is lot more easier</source>
          <target state="translated">HashMaps дает вам свободу синхронизации и отладки намного проще.</target>
        </trans-unit>
        <trans-unit id="78c9bd228fbd8c5d46c4bce0592c89eff91a7d49" translate="yes" xml:space="preserve">
          <source>HashTable and HashMap are member of the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; (since Java 2 platform v1.2, HashTable was retrofitted to implement the Map interface).</source>
          <target state="translated">HashTable и HashMap являются членами &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; (начиная с платформы Java 2 v1.2, HashTable был модернизирован для реализации интерфейса Map).</target>
        </trans-unit>
        <trans-unit id="df229e5af731d7fbb0555f5de0920510f2c0df41" translate="yes" xml:space="preserve">
          <source>HashTable can only contain non-null object as a key or as a value. HashMap can contain one null key and null values.</source>
          <target state="translated">HashTable может содержать только ненулевой объект в качестве ключа или в качестве значения.HashMap может содержать один нулевой ключ и одно нулевое значение.</target>
        </trans-unit>
        <trans-unit id="58a95549c3436ee60ecd7871e7ce42d8ae786e25" translate="yes" xml:space="preserve">
          <source>HashTable is considered legacy code, the documentation advise to use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; in place of Hashtable if a thread-safe highly-concurrent implementation is desired.</source>
          <target state="translated">HashTable считается унаследованным кодом, в документации рекомендуется использовать &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; вместо Hashtable, если требуется многопоточная реализация, ориентированная на многопоточность.</target>
        </trans-unit>
        <trans-unit id="660b9dcb49d86a9b0d8ca2dbc507dfa2ac01bd00" translate="yes" xml:space="preserve">
          <source>HashTable won't allow null keys or null values. Where as HashMap allows one null key, and multiple null values.</source>
          <target state="translated">HashTable не позволяет использовать нулевые ключи или нулевые значения.Где в качестве HashMap разрешает один нулевой ключ и несколько нулевых значений.</target>
        </trans-unit>
        <trans-unit id="22474fbd1e3d38434c362a687e63aec30ae3ab68" translate="yes" xml:space="preserve">
          <source>HashTables are by default synchronized, so it can be used with multiple threads easily. Where as HashMaps are not synchronized by default, so can be used with only single thread.  But you can still convert HashMap to synchronized by using Collections util class's synchronizedMap(Map m) function.</source>
          <target state="translated">HashTables по умолчанию синхронизированы,поэтому их можно легко использовать с несколькими потоками.Там,где HashMaps не синхронизированы по умолчанию,поэтому могут использоваться только с одним потоком.Но Вы все равно можете преобразовать HashMap в синхронизированный с помощью Collections,используя функцию класса synchronizedMap(Map m).</target>
        </trans-unit>
        <trans-unit id="3739cd326e022a0ec2d5f895c0053c82658a5ec3" translate="yes" xml:space="preserve">
          <source>Hashtable: It is a legacy class which is being recognized inside collection framework.</source>
          <target state="translated">Хэшибл:Это унаследованный класс,который признается в рамках коллекции.</target>
        </trans-unit>
        <trans-unit id="3c394da10080138b6474986dd183541c34fb7fc8" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;Java collection cheat sheet&lt;/a&gt; that you will find useful. Notice the gray block contains the legacy class HashTable,Vector and Stack.</source>
          <target state="translated">Вот &lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;шпаргалка по коллекции Java,&lt;/a&gt; которую вы найдете полезной. Обратите внимание, что серый блок содержит устаревшие классы HashTable, Vector и Stack.</target>
        </trans-unit>
        <trans-unit id="0e897a22091a5c72367aa2c68491be56a91daa38" translate="yes" xml:space="preserve">
          <source>Implementations of the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt;&lt;code&gt;ConcurrentMap&lt;/code&gt;&lt;/a&gt; interface (for example &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;) solve some of this by including &lt;strong&gt;thread safe check-then-act semantics&lt;/strong&gt; such as:</source>
          <target state="translated">Реализации интерфейса &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt; &lt;code&gt;ConcurrentMap&lt;/code&gt; &lt;/a&gt; (например, &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; ) решают некоторые из этих проблем, включая &lt;strong&gt;семантику проверки потока-то-действия в потоке,&lt;/strong&gt; такую ​​как:</target>
        </trans-unit>
        <trans-unit id="ef247363dca7947ce18807b023f807375513e571" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5 introduced ConcurrentMap Interface&lt;/a&gt;: &lt;code&gt;ConcurrentHashMap&lt;/code&gt; - a highly concurrent, high-performance &lt;code&gt;ConcurrentMap&lt;/code&gt; implementation backed by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for &lt;code&gt;Hashtable&lt;/code&gt;: in addition to implementing &lt;code&gt;ConcurrentMap&lt;/code&gt;, it supports all of the &quot;legacy&quot; methods peculiar to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">В &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5 представлен интерфейс ConcurrentMap&lt;/a&gt; : &lt;code&gt;ConcurrentHashMap&lt;/code&gt; - высококонкурентная, высокопроизводительная реализация &lt;code&gt;ConcurrentMap&lt;/code&gt; , поддерживаемая хеш-таблицей. Эта реализация никогда не блокируется при выполнении поиска и позволяет клиенту выбирать уровень параллелизма для обновлений. Он предназначен в качестве замены для &lt;code&gt;Hashtable&lt;/code&gt; : помимо реализации &lt;code&gt;ConcurrentMap&lt;/code&gt; , он поддерживает все &amp;laquo;устаревшие&amp;raquo; методы, свойственные &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147cebda6bdb73c5d51fbf40ab2e08956d0ec790" translate="yes" xml:space="preserve">
          <source>In Hashtable there is a function contains(), which is very confusing to use. Because the meaning of contains is slightly deviating. Whether it means contains key or contains  value? tough to understand. Same thing in Maps we have ContainsKey() and ContainsValue() functions, which are very easy to understand.</source>
          <target state="translated">В Hashtable есть функция contains(),которую очень сложно использовать.Потому что значение contains слегка отличается.Содержит ли она ключ или значение? Трудно понять.То же самое в Maps у нас есть функции ContainsKey()и ContainsValue(),которые очень легко понять.</target>
        </trans-unit>
        <trans-unit id="6b511ed6e04d77fc78318a00b4ae9f36a4f5fa39" translate="yes" xml:space="preserve">
          <source>In Java 1.8 we are also promised to be able to construct and access HashMaps like in good old scripting languages:</source>
          <target state="translated">В Java 1.8 нам также обещали,что мы сможем построить и получить доступ к HashMaps,как и в старых добрых скриптовых языках:</target>
        </trans-unit>
        <trans-unit id="cd8c0f0e029d8fe772c617136311a3f6576de97f" translate="yes" xml:space="preserve">
          <source>In Summary there are significant differences between Hashtable and
  HashMap in Java e.g. thread-safety and speed and based upon that only
  use Hashtable if you absolutely need thread-safety, if you are running
  Java 5 consider using ConcurrentHashMap in Java.</source>
          <target state="translated">В заключение,существуют значительные различия между Hashtable и HashMap в Java,например,потокобезопасность и скорость,и,основываясь на этом,использовать Hashtable можно только в том случае,если Вам абсолютно необходима потокобезопасность,если Вы используете Java 5,подумайте об использовании ConcurrentHashMap в Java.</target>
        </trans-unit>
        <trans-unit id="554d6863c43fc3f761b7ff10daaee4fc3bc6661c" translate="yes" xml:space="preserve">
          <source>In addition to what izb said, &lt;code&gt;HashMap&lt;/code&gt; allows null values, whereas the &lt;code&gt;Hashtable&lt;/code&gt; does not.</source>
          <target state="translated">В дополнение к тому, что сказал &lt;code&gt;HashMap&lt;/code&gt; , HashMap допускает нулевые значения, а &lt;code&gt;Hashtable&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="0ecd0ae571aba4721ee2996a4fe36a3db474af69" translate="yes" xml:space="preserve">
          <source>In hashmap you can remove element while iterating, safely. where as it is not possible in hashtables.</source>
          <target state="translated">В хэшмапе вы можете удалять элемент во время итерации,безопасно.где это невозможно в хэш-таблицах.</target>
        </trans-unit>
        <trans-unit id="7fbd74b62c43cd195aee64e1d4b3f8da3aba383f" translate="yes" xml:space="preserve">
          <source>Iterator in &lt;code&gt;HashMap&lt;/code&gt; is fail-fast.</source>
          <target state="translated">Итератор в &lt;code&gt;HashMap&lt;/code&gt; работает быстро.</target>
        </trans-unit>
        <trans-unit id="3481f252a01b24865e53a0d403077fe7c2bfb108" translate="yes" xml:space="preserve">
          <source>Iterator in the &lt;code&gt;HashMap&lt;/code&gt; is  fail-safe while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; is not and throw &lt;code&gt;ConcurrentModificationException&lt;/code&gt; if any other Thread modifies the map structurally  by adding or removing any element except &lt;code&gt;Iterator&lt;/code&gt;'s own &lt;code&gt;remove()&lt;/code&gt;  method. But this is not a guaranteed behavior and will be done by JVM on best effort.</source>
          <target state="translated">Итератор в &lt;code&gt;HashMap&lt;/code&gt; является отказоустойчивым, а перечислитель для &lt;code&gt;Hashtable&lt;/code&gt; - нет, и &lt;code&gt;ConcurrentModificationException&lt;/code&gt; исключение ConcurrentModificationException, если какой-либо другой поток изменяет карту структурно, добавляя или удаляя любой элемент, кроме собственного метода &lt;code&gt;Iterator&lt;/code&gt; &lt;code&gt;remove()&lt;/code&gt; . Но это не гарантированное поведение и будет сделано JVM с максимальной отдачей.</target>
        </trans-unit>
        <trans-unit id="1a2f20d9e57bdf5adc94c3751cd34e64ab8a2d4c" translate="yes" xml:space="preserve">
          <source>Iterators and Enumerations are Fail Safe - reflecting the state at some point since the creation of iterator/enumeration; this allows for simultaneous reads and modifications at the cost of reduced consistency. They do not throw ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time.</source>
          <target state="translated">Итераторы и перечисления Fail Safe-отражают состояние на определенном этапе с момента создания итераторного числа,что позволяет одновременно считывать и модифицировать за счет пониженной согласованности.Они не бросают ConcurrentModificationException.Однако итераторы предназначены для использования только одним потоком одновременно.</target>
        </trans-unit>
        <trans-unit id="254d25f74e4ed95d90db28daea166a6ffd3dd1ff" translate="yes" xml:space="preserve">
          <source>Java Collection Matrix</source>
          <target state="translated">матрица коллекции Java</target>
        </trans-unit>
        <trans-unit id="93f74b798b3d08e2f768288051abb39a0bc5939a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;HashTable&lt;/code&gt; was legacy class before Java Collections Framework (JCF) was introduced and was later retrofitted to implement the &lt;code&gt;Map&lt;/code&gt; interface. So was &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Stack&lt;/code&gt;.</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;HashTable&lt;/code&gt; был унаследованным классом до появления Java Collections Framework (JCF) и позднее был модернизирован для реализации интерфейса &lt;code&gt;Map&lt;/code&gt; . Так было и в &lt;code&gt;Stack&lt;/code&gt; и в стеке .</target>
        </trans-unit>
        <trans-unit id="0449de243fc290a860ccfdc65f8437c895fd81b6" translate="yes" xml:space="preserve">
          <source>Map provides Collection views instead of direct support for iteration
 via Enumeration objects. Collection views greatly enhance the
 expressiveness of the interface, as discussed later in this section.
 Map allows you to iterate over keys, values, or key-value pairs;
 &lt;code&gt;Hashtable&lt;/code&gt; does not provide the third option. Map provides a safe way
 to remove entries in the midst of iteration; &lt;code&gt;Hashtable&lt;/code&gt; did not.
 Finally, Map fixes a minor deficiency in the &lt;code&gt;Hashtable&lt;/code&gt; interface.
 &lt;code&gt;Hashtable&lt;/code&gt; has a method called contains, which returns true if the
 &lt;code&gt;Hashtable&lt;/code&gt; contains a given value. Given its name, you'd expect this
 method to return true if the &lt;code&gt;Hashtable&lt;/code&gt; contained a given key, because
 the key is the primary access mechanism for a &lt;code&gt;Hashtable&lt;/code&gt;. The Map
 interface eliminates this source of confusion by renaming the method
 &lt;code&gt;containsValue&lt;/code&gt;. Also, this improves the interface's consistency &amp;mdash;
 &lt;code&gt;containsValue&lt;/code&gt; parallels &lt;code&gt;containsKey&lt;/code&gt;.</source>
          <target state="translated">Карта обеспечивает представления коллекции вместо прямой поддержки итерации с помощью объектов перечисления. Представления коллекции значительно повышают выразительность интерфейса, как будет обсуждаться далее в этом разделе. Карта позволяет вам перебирать ключи, значения или пары ключ-значение; &lt;code&gt;Hashtable&lt;/code&gt; не предоставляет третий вариант. Карта обеспечивает безопасный способ удаления записей в разгар итерации; &lt;code&gt;Hashtable&lt;/code&gt; нет. Наконец, Map исправляет небольшой недостаток интерфейса &lt;code&gt;Hashtable&lt;/code&gt; . &lt;code&gt;Hashtable&lt;/code&gt; есть метод с названием contains, который возвращает true, если &lt;code&gt;Hashtable&lt;/code&gt; содержит заданное значение. Учитывая его имя, можно ожидать, что этот метод вернет true, если в &lt;code&gt;Hashtable&lt;/code&gt; содержится заданный ключ, потому что ключ является основным механизмом доступа для &lt;code&gt;Hashtable&lt;/code&gt; . Интерфейс Map устраняет этот источник путаницы, переименовывая метод &lt;code&gt;containsValue&lt;/code&gt; . Кроме того, это улучшает согласованность интерфейса - параллели &lt;code&gt;containsKey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09cfe8513ef9f55ce5353dca09be872682455571" translate="yes" xml:space="preserve">
          <source>Maps allows you to iterate and retrieve keys, values, and both key-value pairs as well, Where HashTable don't have all this capability.</source>
          <target state="translated">Карты позволяют выполнять итерацию и извлекать ключи,значения,а также обе пары &quot;ключ-значение&quot;,где HashTable не имеет всех этих возможностей.</target>
        </trans-unit>
        <trans-unit id="75a03fb098b6bc659568b1e29783c07476696b21" translate="yes" xml:space="preserve">
          <source>My small contribution :</source>
          <target state="translated">Мой маленький вклад :</target>
        </trans-unit>
        <trans-unit id="cdb51b953f61763ed033a4d76f1f625c07fe774b" translate="yes" xml:space="preserve">
          <source>My source: &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&lt;/a&gt;</source>
          <target state="translated">Мой источник: &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcd6c2b779cd4727bdfc8b82c43e554e848868f9" translate="yes" xml:space="preserve">
          <source>Note on Some Important Terms:</source>
          <target state="translated">Примечание к некоторым важным условиям:</target>
        </trans-unit>
        <trans-unit id="cc43492870882f3478ca9bc8edfbda8462e1df06" translate="yes" xml:space="preserve">
          <source>Note that HashMap can be synchronized by</source>
          <target state="translated">Обратите внимание,что HashMap может быть синхронизирован посредством</target>
        </trans-unit>
        <trans-unit id="4918d4974fe3cd4755ebe0e20277ccd382fa12f2" translate="yes" xml:space="preserve">
          <source>Note, that a lot of the answers state that Hashtable is synchronised.  &lt;strong&gt;In practice this buys you very little.&lt;/strong&gt;  The synchronization is on the accessor / mutator methods will stop two threads adding or removing from the map concurrently, but in the real world you will often need additional synchronisation.</source>
          <target state="translated">Обратите внимание, что во многих ответах говорится, что Hashtable синхронизирован. &lt;strong&gt;На практике это очень мало тебя покупает.&lt;/strong&gt; Синхронизация по методам доступа / мутатора остановит одновременное добавление или удаление двух потоков из карты, но в реальном мире вам часто потребуется дополнительная синхронизация.</target>
        </trans-unit>
        <trans-unit id="f180d9cd9c023ba8ad54546958cad221aff4883c" translate="yes" xml:space="preserve">
          <source>O(log(n)) for &lt;code&gt;HashMap&lt;/code&gt;&lt;strong&gt;Vs&lt;/strong&gt; O(n) in &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">O (log (n)) для &lt;code&gt;HashMap&lt;/code&gt; &lt;strong&gt;против&lt;/strong&gt; O (n) в &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2600125966cb5ea97c2b8c54e0758c7e46ca74a1" translate="yes" xml:space="preserve">
          <source>Old and classic topic, just want to add this helpful blog that explains this:</source>
          <target state="translated">Старая и классическая тема,просто хочу добавить этот полезный блог,который объясняет это:</target>
        </trans-unit>
        <trans-unit id="249a3a46c2e86414c5539f13f4f1a0225a7d5a6f" translate="yes" xml:space="preserve">
          <source>One more notable difference between Hashtable and HashMap is that because of thread-safety and synchronization Hashtable is much slower
  than HashMap if used in Single threaded environment. So if you don&amp;rsquo;t
  need synchronization and HashMap is only used by one thread, it out
  perform Hashtable in Java.</source>
          <target state="translated">Еще одно заметное отличие между Hashtable и HashMap состоит в том, что из-за безопасности потоков и синхронизации Hashtable намного медленнее, чем HashMap, если используется в однопоточной среде. Поэтому, если вам не нужна синхронизация и HashMap используется только одним потоком, он выполняет Hashtable в Java.</target>
        </trans-unit>
        <trans-unit id="179c0a918e92d97127e98c73349a42a66aa21bd6" translate="yes" xml:space="preserve">
          <source>One of HashMap's subclasses is &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt;, so in the event that you'd want predictable iteration order (which is insertion order by default), you could easily swap out the &lt;code&gt;HashMap&lt;/code&gt; for a &lt;code&gt;LinkedHashMap&lt;/code&gt;.  This wouldn't be as easy if you were using &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">Одним из подклассов HashMap является &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt; , поэтому в случае, если вам нужен предсказуемый порядок итераций (по умолчанию это порядок вставки), вы можете легко заменить &lt;code&gt;HashMap&lt;/code&gt; на &lt;code&gt;LinkedHashMap&lt;/code&gt; . Это было бы не так просто, если бы вы использовали &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1525943ae6179c4dbbe03560c257ffac662fb828" translate="yes" xml:space="preserve">
          <source>One of the major differences between HashMap and Hashtable is that HashMap is non-synchronized whereas Hashtable is synchronized, which
  means Hashtable is thread-safe and can be shared between multiple
  threads but HashMap cannot be shared between multiple threads without
  proper synchronization. Java 5 introduced ConcurrentHashMap which is
  an alternative of Hashtable and provides better scalability than
  Hashtable in Java.Synchronized means only one thread can modify a hash
  table at one point of time. Basically, it means that any thread before
  performing an update on a hashtable will have to acquire a lock on the
  object while others will wait for lock to be released.</source>
          <target state="translated">Одно из главных различий между HashMap и HashMap заключается в том,что HashMap не синхронизирован,в то время как Hashtable синхронизирован,что означает,что Hashtable безопасен для потоков и может быть разделен между несколькими потоками,но HashMap не может быть разделен между несколькими потоками без надлежащей синхронизации.Java 5 ввела ConcurrentHashMap,который является альтернативой Hashtable и обеспечивает лучшую масштабируемость,чем Hashtable в Java.Synchronized,что означает,что только один поток может изменить хэш-таблицу в один момент времени.По сути,это означает,что любой поток перед выполнением обновления на хэш-таблице должен будет получить блокировку на объекте,в то время как другие потоки будут ждать,пока блокировка будет освобождена.</target>
        </trans-unit>
        <trans-unit id="95781641174af3b5c28daa7afb4c768668074452" translate="yes" xml:space="preserve">
          <source>Performance Improvement for &lt;code&gt;HashMap&lt;/code&gt; in Java 8</source>
          <target state="translated">Улучшение производительности для &lt;code&gt;HashMap&lt;/code&gt; в Java 8</target>
        </trans-unit>
        <trans-unit id="fee29654ce34b086768db65a4b25fcd54f9ed463" translate="yes" xml:space="preserve">
          <source>Second important difference between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is performance, since &lt;code&gt;HashMap&lt;/code&gt; is not synchronized it perform better than &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">Второе важное различие между &lt;code&gt;Hashtable&lt;/code&gt; и &lt;code&gt;HashMap&lt;/code&gt; - это производительность, поскольку &lt;code&gt;HashMap&lt;/code&gt; не синхронизируется, он работает лучше, чем &lt;code&gt;Hashtable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b55e592836fe1e61392790c1a6fce30f1803ceb3" translate="yes" xml:space="preserve">
          <source>Separate from the obvious differences discussed extensively in this question, I see the Hashtable as a &quot;manual drive&quot; car where you have better control over the hashing and the HashMap as the &quot;automatic drive&quot; counterpart that will generally perform well.</source>
          <target state="translated">Отдельно от очевидных различий,широко обсуждавшихся в этом вопросе,я вижу Hashtable как &quot;ручной привод&quot; автомобиля,где вы имеете лучший контроль над хешированием и HashMap как контрагент &quot;автоматического привода&quot;,который в целом будет работать хорошо.</target>
        </trans-unit>
        <trans-unit id="b3a738203d70f6090dfcdd1764cf29833f51bb9d" translate="yes" xml:space="preserve">
          <source>Seriously though, you're better off staying away from &lt;code&gt;Hashtable&lt;/code&gt; altogether. For single-threaded apps, you don't need the extra overhead of synchronisation. For highly concurrent apps, the paranoid synchronisation might lead to starvation, deadlocks, or unnecessary garbage collection pauses. Like Tim Howland pointed out, you might use &lt;code&gt;ConcurrentHashMap&lt;/code&gt; instead.</source>
          <target state="translated">Если серьезно, то вам лучше вообще держаться подальше от &lt;code&gt;Hashtable&lt;/code&gt; . Для однопоточных приложений вам не нужны дополнительные издержки синхронизации. Для приложений с высокой степенью параллелизма параноидальная синхронизация может привести к голоданию, взаимоблокировкам или ненужным паузам сбора мусора. Как отметил Тим Хоулэнд, вместо этого вы можете использовать &lt;code&gt;ConcurrentHashMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bdf790b2b1c9d6025dcbecb5bdb37ab2f60d7b4" translate="yes" xml:space="preserve">
          <source>Since synchronization is not an issue for you, I'd recommend &lt;code&gt;HashMap&lt;/code&gt;. If synchronization becomes an issue, you may also look at &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поскольку синхронизация не является для вас проблемой, я бы порекомендовал &lt;code&gt;HashMap&lt;/code&gt; . Если синхронизация становится проблемой, вы также можете посмотреть &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bcb97fa6763fbfe1f0ff48e9f6a9c4dd72d057b" translate="yes" xml:space="preserve">
          <source>Some important points about HashMap and HashTable.
   please read below details.</source>
          <target state="translated">Некоторые важные моменты о HashMap и HashTable.пожалуйста,ознакомьтесь с подробностями ниже.</target>
        </trans-unit>
        <trans-unit id="2773856ae2356cf0a8e12035c63973404b5e1bef" translate="yes" xml:space="preserve">
          <source>Structurally modification means deleting or inserting element which could effectively change the structure of map.</source>
          <target state="translated">Под конструктивной модификацией понимается удаление или вставка элемента,который может эффективно изменить структуру карты.</target>
        </trans-unit>
        <trans-unit id="9ac0930f0753d909c7591e062bf09758da70879f" translate="yes" xml:space="preserve">
          <source>Synchronized means only one thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a &lt;code&gt;Hashtable&lt;/code&gt; will have to acquire a lock on the object while others will wait for lock to be released.</source>
          <target state="translated">Синхронизированный означает, что только один поток может изменить хэш-таблицу в один момент времени. По сути, это означает, что любой поток перед выполнением обновления на &lt;code&gt;Hashtable&lt;/code&gt; должен будет получить блокировку объекта, в то время как другие будут ожидать снятия блокировки.</target>
        </trans-unit>
        <trans-unit id="70e8f2a076a2a427c74c96d2d6f12fe9436a1288" translate="yes" xml:space="preserve">
          <source>Take a look at this chart. It provides comparisons between different data structures along with &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. The comparison is precise, clear and easy to understand.</source>
          <target state="translated">Посмотрите на этот график. Это обеспечивает сравнение между различными структурами данных наряду с &lt;code&gt;HashMap&lt;/code&gt; и &lt;code&gt;Hashtable&lt;/code&gt; . Сравнение точное, понятное и простое для понимания.</target>
        </trans-unit>
        <trans-unit id="9b64a19c6daf91779b3938d649152906ab363b0e" translate="yes" xml:space="preserve">
          <source>The 5 main differences betwen HashMap and Hashtable</source>
          <target state="translated">5 основных отличий между HashMap и Hashtable</target>
        </trans-unit>
        <trans-unit id="072d0888e52948dbd09f33a229cca91be253355a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt; class is roughly equivalent to &lt;code&gt;Hashtable&lt;/code&gt;, except that it is non synchronized and permits nulls. (&lt;code&gt;HashMap&lt;/code&gt; allows null values as key and value whereas &lt;code&gt;Hashtable&lt;/code&gt; doesn't allow &lt;code&gt;null&lt;/code&gt;s).</source>
          <target state="translated">Класс &lt;code&gt;HashMap&lt;/code&gt; примерно эквивалентен классу &lt;code&gt;Hashtable&lt;/code&gt; , за исключением того, что он не синхронизирован и допускает нулевые значения. ( &lt;code&gt;HashMap&lt;/code&gt; допускает нулевые значения как ключ и значение, тогда как &lt;code&gt;Hashtable&lt;/code&gt; не допускает &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0aeaae4475437892ad0e711f1d770aca667a7fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.2&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; and Hashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.0&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt;, both are used to represent a group of objects that are represented in &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair. Each &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair is called &lt;code&gt;Entry&lt;/code&gt; object. The collection of Entries is referred by the object of &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. Keys in a collection must be unique or distinctive. [as they are used to retrieve a mapped value a particular key. values in a collection can be duplicated.]</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.2&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; и Hashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.0&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; , оба используются для представления группы объектов, представленных в паре &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; . Каждая пара &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; называется объектом &lt;code&gt;Entry&lt;/code&gt; . Коллекция записей ссылается на объект &lt;code&gt;HashMap&lt;/code&gt; и &lt;code&gt;Hashtable&lt;/code&gt; . Ключи в коллекции должны быть уникальными или отличительными. [поскольку они используются для получения сопоставленного значения определенного ключа. значения в коллекции могут быть продублированы.]</target>
        </trans-unit>
        <trans-unit id="00dc41b113291633c52fd58000a80e068e3e22e0" translate="yes" xml:space="preserve">
          <source>The HashMap class is roughly equivalent to Hashtable, except that it permits nulls. (HashMap allows null values as key and value whereas
  Hashtable doesn&amp;rsquo;t allow nulls).</source>
          <target state="translated">Класс HashMap примерно эквивалентен классу Hashtable, за исключением того, что он допускает нулевые значения. (HashMap допускает нулевые значения как ключ и значение, тогда как Hashtable не допускает нулевые значения).</target>
        </trans-unit>
        <trans-unit id="f7ecf1afa5b4c9630d2b5dcfbe61d5b627ebd286" translate="yes" xml:space="preserve">
          <source>The Map Interface</source>
          <target state="translated">Интерфейс карты</target>
        </trans-unit>
        <trans-unit id="3676c70892d7c609193fc43d310096bd0df0c6be" translate="yes" xml:space="preserve">
          <source>The iterators returned by Map are fail-fast, if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. &lt;strong&gt;Whereas&lt;/strong&gt; the Enumerations returned by Hashtable's keys and elements methods are not fail-fast.</source>
          <target state="translated">Итераторы, возвращаемые Map, работают быстро, если карта структурно модифицирована в любое время после создания итератора, любым способом, кроме как через собственный метод удаления итератора, итератор сгенерирует исключение &lt;code&gt;ConcurrentModificationException&lt;/code&gt; . Таким образом, перед одновременной модификацией итератор быстро и чисто дает сбой, вместо того, чтобы рисковать произвольным недетерминированным поведением в неопределенное время в будущем. &lt;strong&gt;Принимая&lt;/strong&gt; во &lt;strong&gt;внимание,&lt;/strong&gt; что перечисления, возвращаемые методами ключей и элементов Hashtable, не работают быстро.</target>
        </trans-unit>
        <trans-unit id="e573df66450873c1ddfa83005b4aa24d831fd978" translate="yes" xml:space="preserve">
          <source>The third significant difference between HashMap vs Hashtable is that Iterator in the HashMap is a fail-fast iterator while the
  enumerator for the Hashtable is not and throw
  ConcurrentModificationException if any other Thread modifies the map
  structurally by adding or removing any element except Iterator&amp;rsquo;s own
  remove() method. But this is not a guaranteed behavior and will be
  done by JVM on best effort. This is also an important difference
  between Enumeration and Iterator in Java.</source>
          <target state="translated">Третье существенное различие между HashMap и Hashtable заключается в том, что Iterator в HashMap является итератором, работающим без сбоев, а перечислитель для Hashtable - нет и создает исключение ConcurrentModificationException, если какой-либо другой поток изменяет карту структурно, добавляя или удаляя любой элемент, кроме собственного удаления Iterator ( ) метод. Но это не гарантированное поведение и будет сделано JVM с максимальной отдачей. Это также важное различие между перечислением и итератором в Java.</target>
        </trans-unit>
        <trans-unit id="f56383732ea0646c1b6ccc4780205710d6c51198" translate="yes" xml:space="preserve">
          <source>There are 5 basic differentiations with HashTable and HashMaps.</source>
          <target state="translated">Существует 5 основных дифференциалов с HashTable и HashMaps.</target>
        </trans-unit>
        <trans-unit id="bb1f8a6f6840706e60372d6f2420a010dbd1ffca" translate="yes" xml:space="preserve">
          <source>There are several differences between &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java:</source>
          <target state="translated">Есть несколько различий между &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt; в Java:</target>
        </trans-unit>
        <trans-unit id="5800ffe299a96231836db81f351c861e03ed3697" translate="yes" xml:space="preserve">
          <source>There is many good answer already posted. I'm adding few new points and summarizing it.</source>
          <target state="translated">Уже есть много хороших ответов.Я добавляю несколько новых пунктов и подытоживаю его.</target>
        </trans-unit>
        <trans-unit id="df9315b5c785f8ab9f27801657f7477146067793" translate="yes" xml:space="preserve">
          <source>Third difference on &lt;code&gt;Hashtable&lt;/code&gt; vs &lt;code&gt;HashMap&lt;/code&gt; is that &lt;code&gt;Hashtable&lt;/code&gt; is obsolete class and you should be using &lt;code&gt;ConcurrentHashMap&lt;/code&gt; in place of &lt;code&gt;Hashtable&lt;/code&gt; in Java.</source>
          <target state="translated">Третье отличие &lt;code&gt;Hashtable&lt;/code&gt; от &lt;code&gt;HashMap&lt;/code&gt; состоит в том, что &lt;code&gt;Hashtable&lt;/code&gt; является устаревшим классом, и вы должны использовать &lt;code&gt;ConcurrentHashMap&lt;/code&gt; вместо &lt;code&gt;Hashtable&lt;/code&gt; в Java.</target>
        </trans-unit>
        <trans-unit id="ee9376793d9967bcbf5a7a8c815e756c9c9ccb2c" translate="yes" xml:space="preserve">
          <source>This question is often asked in interview to check whether candidate understands correct usage of collection classes and is aware of alternative solutions available.</source>
          <target state="translated">Этот вопрос часто задают в ходе собеседования,чтобы проверить,понимает ли кандидат правильное использование классов сбора и знает ли он о доступных альтернативных решениях.</target>
        </trans-unit>
        <trans-unit id="247c0322284eae1d1388216cd3162f7e2cc8e631" translate="yes" xml:space="preserve">
          <source>We can make the &lt;code&gt;HashMap&lt;/code&gt; as synchronized by calling this code</source>
          <target state="translated">Мы можем сделать &lt;code&gt;HashMap&lt;/code&gt; синхронизированным, вызвав этот код</target>
        </trans-unit>
        <trans-unit id="c81f8280687b9700ca5bb68ae586570fb7c23f46" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java?</source>
          <target state="translated">Каковы различия между &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt; в Java?</target>
        </trans-unit>
        <trans-unit id="2c8e95a3c2ffb57733e53c253ed60a5636be3523" translate="yes" xml:space="preserve">
          <source>What is the difference between HashMap and HashTable?</source>
          <target state="translated">В чем разница между HashMap и HashTable?</target>
        </trans-unit>
        <trans-unit id="ce3ce0552d057e3c8f06c38c4e4073b98a6a4ac5" translate="yes" xml:space="preserve">
          <source>Which is more efficient for non-threaded applications?</source>
          <target state="translated">Что более эффективно для нечитаемых приложений?</target>
        </trans-unit>
        <trans-unit id="2641089043a1d4d281fa1d792f1ac52e385d9822" translate="yes" xml:space="preserve">
          <source>versus the old Hashtable approach:</source>
          <target state="translated">по сравнению со старым подходом Хэшбэла:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
