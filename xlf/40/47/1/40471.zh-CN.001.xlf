<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/40471">
    <body>
      <group id="40471">
        <trans-unit id="1ffa479b2bc81d3a4bfacc7ab2a3c758037edec2" translate="yes" xml:space="preserve">
          <source>*The aforementioned improvement has not been applied to &lt;code&gt;Hashtable&lt;/code&gt; yet, but only to &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;LinkedHashMap&lt;/code&gt;, and &lt;code&gt;ConcurrentHashMap&lt;/code&gt;.</source>
          <target state="translated">*上述改进尚未应用于 &lt;code&gt;Hashtable&lt;/code&gt; ，仅应用于 &lt;code&gt;HashMap&lt;/code&gt; ， &lt;code&gt;LinkedHashMap&lt;/code&gt; 和 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bebecfc307c9e1b712693d3b764211b8ed5cfb2" translate="yes" xml:space="preserve">
          <source>1) First difference is HashMap is not thread safe While HashTable is ThreadSafe</source>
          <target state="translated">1)第一个区别是HashMap不是线程安全的,而HashTable是线程安全的。</target>
        </trans-unit>
        <trans-unit id="e93948b799e95b7508984d1cffb6e8a3f9844579" translate="yes" xml:space="preserve">
          <source>1) Hashtable and Hashmap implement the java.util.Map interface
2) Both Hashmap and Hashtable is the hash based collection. and working on hashing.
so these are similarity of HashMap and HashTable.</source>
          <target state="translated">1)Hashtable和Hashmap实现了java.util.Map接口 2)Hashmap和HashTable都是基于散列的集合。</target>
        </trans-unit>
        <trans-unit id="ce8ad15ae4892952ca56baaa8baaa429494f2e53" translate="yes" xml:space="preserve">
          <source>1.&lt;code&gt;Hashmap&lt;/code&gt; and &lt;code&gt;HashTable&lt;/code&gt; both store key and value.</source>
          <target state="translated">1. &lt;code&gt;Hashmap&lt;/code&gt; 和 &lt;code&gt;HashTable&lt;/code&gt; 都存储键和值。</target>
        </trans-unit>
        <trans-unit id="ea022165e8aaef91c12ccef2e5123b0265799db7" translate="yes" xml:space="preserve">
          <source>2) HashMap is performance wise better because it is not thread safe. while Hashtable performance wise is not better because it is thread safe. so multiple thread can not access Hashtable at the same time.</source>
          <target state="translated">2)HashMap从性能上看是比较好的,因为它不是线程安全的,而Hashtable从性能上看不是比较好的,因为它是线程安全的。</target>
        </trans-unit>
        <trans-unit id="2a896733be888d07b7cbb8186abb374063e45bdd" translate="yes" xml:space="preserve">
          <source>2.&lt;code&gt;Hashmap&lt;/code&gt; can store one key as &lt;code&gt;null&lt;/code&gt;. &lt;code&gt;Hashtable&lt;/code&gt; can't store &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">2. &lt;code&gt;Hashmap&lt;/code&gt; 可以将一个键存储为 &lt;code&gt;null&lt;/code&gt; 。 &lt;code&gt;Hashtable&lt;/code&gt; 不能存储 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02a8a35731189356741a2efc879bda9c331af5d6" translate="yes" xml:space="preserve">
          <source>3.&lt;code&gt;HashMap&lt;/code&gt; is not synchronized but &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">3. &lt;code&gt;HashMap&lt;/code&gt; 未同步，但 &lt;code&gt;Hashtable&lt;/code&gt; 已同步。</target>
        </trans-unit>
        <trans-unit id="7edecd9abb3471db7df504cd6c5936311ca4fa46" translate="yes" xml:space="preserve">
          <source>4.&lt;code&gt;HashMap&lt;/code&gt; can be synchronized with &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt;</source>
          <target state="translated">4. &lt;code&gt;HashMap&lt;/code&gt; 可以与 &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt; 同步</target>
        </trans-unit>
        <trans-unit id="8772653c67ec1de6492448fff19367167e54b515" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is a legacy class in the jdk that shouldn't be used anymore. Replace usages of it with &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt;. If you don't require thread safety, use &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; which isn't &lt;a href=&quot;http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/concurrent/ThreadSafe.html&quot;&gt;threadsafe&lt;/a&gt; but faster and uses less memory.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt;是jdk中的旧类，不应再使用。 用&lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt;替换它的用法。 如果您不需要线程安全，请使用&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; ，它不是&lt;a href=&quot;http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/concurrent/ThreadSafe.html&quot;&gt;线程安全的，&lt;/a&gt;但速度更快，并且占用的内存更少。</target>
        </trans-unit>
        <trans-unit id="a8212855afbfdfadf4f72d52f3fd51313aab01da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is synchronized, if you are using it in a single thread you can use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, which is an unsynchronized version. Unsynchronized objects are often a little more performant. By the way if multiple threads access a HashMap concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. 
Youn can wrap a unsynchronized map in a synchronized one using :</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt;是同步的，如果在单个线程中使用它，则可以使用&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; ，它是非同步的版本。 不同步的对象通常具有更高的性能。 顺便说一下，如果多个线程同时访问HashMap，并且其中至少一个线程在结构上修改了映射，则必须在外部进行同步。 Youn可以使用以下命令将未同步的映射包装到同步的映射中：</target>
        </trans-unit>
        <trans-unit id="35825761ff3e0e6aae7c813dc0f469fe68798cf4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; is a fail-fast in nature. i.e it throws ConcurrentModificationException if a collection is modified while iterating other than it&amp;rsquo;s own remove() method. Where as &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt;&lt;code&gt;Enumeration&lt;/code&gt;&lt;/a&gt; is fail-safe in nature. It doesn&amp;rsquo;t throw any exceptions if a collection is modified while iterating.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;本质上是一种快速失败的方法。 也就是说，如果在迭代过程中修改了一个集合（而不是它自己的remove（）方法），则抛出ConcurrentModificationException。 其中， &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt; &lt;code&gt;Enumeration&lt;/code&gt; &lt;/a&gt;本质上是故障安全的。 如果在迭代过程中修改了集合，它不会引发任何异常。</target>
        </trans-unit>
        <trans-unit id="6f5224599c22155916dabf87bba49566ddaa6261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows maximum one null key and any number of null values. Where as &lt;code&gt;Hashtable&lt;/code&gt; doesn&amp;rsquo;t allow even a single null key and null value, if the key or value null is then it throws NullPointerException. &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;Example&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 最多允许一个空键和任意数量的空值。 由于 &lt;code&gt;Hashtable&lt;/code&gt; 甚至不允许单个null键和null值，如果key或value为null，则抛出NullPointerException。 &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;例&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a5083b226eeb51dc40cc10003425a58b158f81eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows one null key and multiple null values.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 允许一个空键和多个空值。</target>
        </trans-unit>
        <trans-unit id="669df6fbbd3ba9c388deaba3fc0849ca8f6f2ff6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; both are used to store &lt;em&gt;data in key and value form&lt;/em&gt;. Both are using hashing technique to store unique keys.
But there are many differences between HashMap and Hashtable classes that are given below.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 和 &lt;code&gt;Hashtable&lt;/code&gt; 都用于存储&lt;em&gt;键和值形式的数据&lt;/em&gt; 。 两者都使用哈希技术来存储唯一密钥。 但是，下面给出的HashMap和Hashtable类之间有许多区别。</target>
        </trans-unit>
        <trans-unit id="0ac053a124fba70f26ef444ee7553d0c4785af36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; have significant algorithmic differences as well. No one has mentioned this before so that's why I am bringing it up. &lt;code&gt;HashMap&lt;/code&gt; will construct a hash table with power of two size, increase it dynamically such that you have at most about eight elements (collisions) in any bucket and will stir the elements very well for general element types. However, the &lt;code&gt;Hashtable&lt;/code&gt; implementation provides better and finer control over the hashing if you know what you are doing, namely you can fix the table size using e.g. the closest prime number to your values domain size and this will result in better performance than HashMap i.e. less collisions for some cases.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 和 &lt;code&gt;Hashtable&lt;/code&gt; 也具有明显的算法差异。 之前没有人提到过这，所以这就是我提起它的原因。 &lt;code&gt;HashMap&lt;/code&gt; 将构造一个具有两个大小的幂的哈希表，并对其进行动态增加，以使您在任何存储桶中最多具有大约八个元素（冲突），并且对于常规元素类型，这些元素将非常好地搅动。 但是，如果您知道自己在做什么，则 &lt;code&gt;Hashtable&lt;/code&gt; 实现可对哈希进行更好，更精细的控制，即，您可以使用例如最接近值域大小的素数来固定表大小，这将导致比HashMap更好的性能，即更少在某些情况下发生碰撞。</target>
        </trans-unit>
        <trans-unit id="64a17134b1046d668dd05ac2bc4f97f06a63e76e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; can be synchronized by</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 可以通过以下方式同步</target>
        </trans-unit>
        <trans-unit id="d500b59660957bd4381ff369b93e82d00b9b1f70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 不保证地图的顺序会随着时间的推移保持恒定。</target>
        </trans-unit>
        <trans-unit id="a8747ab7f19811c92ec840fe23f10d94ab4b3af3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; inherits AbstractMap class.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 继承AbstractMap类。</target>
        </trans-unit>
        <trans-unit id="51fbe655ee9bcf724b8cabf41a90881d14820a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is a new class introduced in JDK 1.2.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 是JDK 1.2中引入的新类。</target>
        </trans-unit>
        <trans-unit id="b63a85d53f021a1ae8dd8bdd08fdc18c2b28c4cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is emulated and therefore usable in &lt;code&gt;GWT client code&lt;/code&gt; whereas &lt;code&gt;Hashtable&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 是模拟的，因此可以在 &lt;code&gt;GWT client code&lt;/code&gt; 使用，而 &lt;code&gt;Hashtable&lt;/code&gt; 不是。</target>
        </trans-unit>
        <trans-unit id="8910e4452555bc0eb462a108515a97d9c3f5b62a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is fast.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 很快。</target>
        </trans-unit>
        <trans-unit id="0ac323b983cb93bfa96d446a6acf3e0739d49b02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized whereas &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 是不同步的，而 &lt;code&gt;Hashtable&lt;/code&gt; 是同步的。</target>
        </trans-unit>
        <trans-unit id="15bf5350ece84dd8e38bde89e4f666c4333d494b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized. It is not-thread safe and can't be shared between many threads without proper synchronization code.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 不同步。 它不是线程安全的，没有适当的同步代码就无法在许多线程之间共享。</target>
        </trans-unit>
        <trans-unit id="7eecfc386a9ddceaa10ba8c78194cc8417a8cc62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is traversed by Iterator.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 被Iterator遍历。</target>
        </trans-unit>
        <trans-unit id="8697ca59be21a2145ac021e93da6593a2e482b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; permits null values in it, while &lt;code&gt;Hashtable&lt;/code&gt; doesn't.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 允许其中包含空值，而 &lt;code&gt;Hashtable&lt;/code&gt; 不允许。</target>
        </trans-unit>
        <trans-unit id="ce244b309892513fef48b0c0adb960eea745a513" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt;: An implementation of the &lt;code&gt;Map&lt;/code&gt; interface that uses hash codes to index an array.
&lt;code&gt;Hashtable&lt;/code&gt;: Hi, 1998 called. They want their collections API back.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; ： &lt;code&gt;Map&lt;/code&gt; 接口的实现，该接口使用哈希码为数组建立索引。 &lt;code&gt;Hashtable&lt;/code&gt; ：您好，1998年致电。 他们希望收回自己的收藏夹API。</target>
        </trans-unit>
        <trans-unit id="aea1fdd84192f7fc2e196adf40609942cb1285de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; does not allow &lt;code&gt;null&lt;/code&gt; keys or values.  &lt;code&gt;HashMap&lt;/code&gt; allows one &lt;code&gt;null&lt;/code&gt; key and any number of &lt;code&gt;null&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 不允许使用 &lt;code&gt;null&lt;/code&gt; 键或空值。 &lt;code&gt;HashMap&lt;/code&gt; 允许一个 &lt;code&gt;null&lt;/code&gt; 键和任意数量的 &lt;code&gt;null&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="da40767d527c7d8ee16fe1095a3c28313aaec00a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; doesn't allow any null key or value.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 不允许任何空键或值。</target>
        </trans-unit>
        <trans-unit id="e82d9c21537b4430e511e19537f8747613296279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; inherits Dictionary class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 继承Dictionary类。</target>
        </trans-unit>
        <trans-unit id="473a8e23134d11e4c9e6a5a24f60baccffe8cd5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is &lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;synchronized&lt;/a&gt;, whereas &lt;code&gt;HashMap&lt;/code&gt; is not. This makes &lt;code&gt;HashMap&lt;/code&gt; better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 是&lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;同步的&lt;/a&gt; ，而 &lt;code&gt;HashMap&lt;/code&gt; 不是。 这使 &lt;code&gt;HashMap&lt;/code&gt; 更适合非线程应用程序，因为非同步对象通常比同步对象表现更好。</target>
        </trans-unit>
        <trans-unit id="5f3b80ed3c8119e05343a43fa58d178aa8c248fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is a legacy class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 是一个遗留类。</target>
        </trans-unit>
        <trans-unit id="74522ed93d3ffc34a0d85038cae726b8c4697227" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is considered legacy code. There's nothing about &lt;code&gt;Hashtable&lt;/code&gt; that can't be done using &lt;code&gt;HashMap&lt;/code&gt; or derivations of &lt;code&gt;HashMap&lt;/code&gt;, so for new code, I don't see any justification for going back to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 被认为是遗留代码。 使用 &lt;code&gt;HashMap&lt;/code&gt; 或HashMap的派生无法完成 &lt;code&gt;Hashtable&lt;/code&gt; 的所有操作，因此对于新代码，我看不出有任何理由返回 &lt;code&gt;Hashtable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="582981ade6fd1fb874a7cbaa7d7f669287851433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized and can't be unsynchronized.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 在内部是同步的，不能不同步。</target>
        </trans-unit>
        <trans-unit id="5b50d2071547d1d8f01971f3564947ceb026e758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized. Therefore, it is very much safe to use &lt;code&gt;Hashtable&lt;/code&gt; in multi threaded applications. Where as &lt;code&gt;HashMap&lt;/code&gt; is not internally synchronized. Therefore, it is not safe to use &lt;code&gt;HashMap&lt;/code&gt; in multi threaded applications without external synchronization. You can externally synchronize &lt;code&gt;HashMap&lt;/code&gt; using &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 是内部同步的。 因此，在多线程应用程序中使用 &lt;code&gt;Hashtable&lt;/code&gt; 是非常安全的。 &lt;code&gt;HashMap&lt;/code&gt; 在内部不同步。 因此，在没有外部同步的情况下在多线程应用程序中使用 &lt;code&gt;HashMap&lt;/code&gt; 是不安全的。 您可以使用 &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; 方法从外部同步 &lt;code&gt;HashMap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e63c856b660603f278bb16d5b114de8a3272ed31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is similar to the &lt;code&gt;HashMap&lt;/code&gt; and has a similar interface. It is recommended that you use &lt;code&gt;HashMap&lt;/code&gt;, unless you require support for legacy applications or you need synchronisation, as the &lt;code&gt;Hashtables&lt;/code&gt; methods are synchronised. So in your case as you are not multi-threading, &lt;code&gt;HashMaps&lt;/code&gt; are your best bet.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 与 &lt;code&gt;HashMap&lt;/code&gt; 相似，并且具有相似的接口。 建议您使用 &lt;code&gt;HashMap&lt;/code&gt; ，除非您需要对旧版应用程序的支持或需要同步，因为 &lt;code&gt;Hashtables&lt;/code&gt; 方法已同步。 因此，在您不使用多线程的情况下， &lt;code&gt;HashMaps&lt;/code&gt; 是您的最佳选择。</target>
        </trans-unit>
        <trans-unit id="6eaefd6be9ca644fb4dceef1106f715e6f13ce69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is slow.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 很慢。</target>
        </trans-unit>
        <trans-unit id="ad27eec131dd51571006c484e66faa0226c0bffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized whereas &lt;code&gt;HashMap&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 是同步的，而 &lt;code&gt;HashMap&lt;/code&gt; 不是同步的。</target>
        </trans-unit>
        <trans-unit id="25f83877d4ac62b168713576f58b2770a86b5aad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized, whereas &lt;code&gt;HashMap&lt;/code&gt; isn't. That makes &lt;code&gt;Hashtable&lt;/code&gt; slower than &lt;code&gt;Hashmap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 是同步的，而 &lt;code&gt;HashMap&lt;/code&gt; 不是同步的。 这使得 &lt;code&gt;Hashtable&lt;/code&gt; 比 &lt;code&gt;Hashmap&lt;/code&gt; 慢。</target>
        </trans-unit>
        <trans-unit id="1c596268109b66bf2934f50af140575b7246bd11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized. It is thread-safe and can be shared with many threads.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 已同步。 它是线程安全的，可以与许多线程共享。</target>
        </trans-unit>
        <trans-unit id="7e53d6f6599341af744cd74547e079fc1d2c838b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is traversed by Enumerator and Iterator.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 被Enumerator和Iterator遍历。</target>
        </trans-unit>
        <trans-unit id="006d1c181f3c98522a669dc0abea34770eb93435" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; : if a bucket contains more than 8 nodes, the linked list is transformed into a balanced tree.</source>
          <target state="translated">&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; ：如果存储桶包含8个以上的节点，则链接列表将转换为平衡树。</target>
        </trans-unit>
        <trans-unit id="f9177115bae6161497db808e68ed7cd40b2d6acf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; : when a bucket becomes too small (due to removal or resizing) the tree is converted back to linked list.</source>
          <target state="translated">&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; ：当存储桶太小（由于删除或调整大小）时，树将转换回链接列表。</target>
        </trans-unit>
        <trans-unit id="1000b8e627d741fb5080e9ad2ab05068f01c96cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;Hashtable&lt;/code&gt; in case of hash collisions they store the map entries in linked lists. &lt;strong&gt;From Java8 for &lt;code&gt;HashMap&lt;/code&gt;&lt;/strong&gt; if hash bucket grows beyond a certain threshold, that bucket will switch from &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt;&lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt;&lt;/a&gt;. which improve worst-case performance from O(n) to O(log n). While converting the list to binary tree, hashcode is used as a branching variable. If there are two different hashcodes in the same bucket, one is considered bigger and goes to the right of the tree and other one to the left. But when both the hashcodes are equal, &lt;code&gt;HashMap&lt;/code&gt; assumes that the keys are comparable, and compares the key to determine the direction so that some order can be maintained. It is a good practice to make the keys of &lt;code&gt;HashMap&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;comparable&lt;/a&gt;. On adding entries if bucket size reaches &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; convert linked list of entries to a balanced tree, on removing entries less than &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt;  and at most &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; will reconvert  balanced tree to linked list of entries. &lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;stackpost&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;HashMap&lt;/code&gt; ，如果发生哈希冲突，则将 &lt;code&gt;Hashtable&lt;/code&gt; 存储在链接列表中。&lt;/em&gt; &lt;em&gt;&lt;strong&gt;从Java8 for &lt;code&gt;HashMap&lt;/code&gt; 开始,&lt;/strong&gt;如果哈希存储桶超过某个阈值，该存储桶将从&lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt; &lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt; &lt;/a&gt;切换到平衡树 。&lt;/em&gt; &lt;em&gt;可以将最坏情况下的性能从O（n）提高到O（log n）。&lt;/em&gt; &lt;em&gt;在将列表转换为二叉树时，哈希码用作分支变量。&lt;/em&gt; &lt;em&gt;如果在同一存储桶中有两个不同的哈希码，则将其中一个视为更大，并移至树的右侧，而另一个则移至左侧。&lt;/em&gt; &lt;em&gt;但是，当两个哈希码相等时， &lt;code&gt;HashMap&lt;/code&gt; 假定键是可比较的，并比较键以确定方向，以便可以维持某些顺序。&lt;/em&gt; &lt;em&gt;最好使 &lt;code&gt;HashMap&lt;/code&gt; 的键具有&lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;可比性&lt;/a&gt; 。&lt;/em&gt; &lt;em&gt;如果在存储桶大小达到 &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; 添加条目，则将链接的条目列表转换为平衡树，在删除小于 &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; 且最多为 &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; 的条目时，会将平衡树重新转换为链接的条目列表。&lt;/em&gt; &lt;em&gt;&lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt; ， &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;堆栈后&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0126875eb118b7807444c7f8bd52e3d668a20cba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; &amp;mdash; sometimes called a container &amp;mdash; is simply an object that groups multiple elements into a single unit. &lt;code&gt;Collection&lt;/code&gt;s are used to store, retrieve, manipulate, and communicate aggregate data. A collections framework &lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt; is a unified architecture for representing and manipulating collections.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; （有时称为容器）只是将多个元素组合为一个单元的对象。&lt;/em&gt; &lt;em&gt; &lt;code&gt;Collection&lt;/code&gt; 用于存储，检索，操作和传递聚合数据。&lt;/em&gt; &lt;em&gt;集合框架&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt;是用于表示和操作集合的统一体系结构。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5371f8fa97eb824eece2c3e1f791dbb0a968b11d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HashMap constructs an empty hash table with the default initial capacity &lt;strong&gt;(16)&lt;/strong&gt; and the default load factor (0.75). Where as Hashtable constructs empty hashtable with a default initial capacity &lt;strong&gt;(11)&lt;/strong&gt; and load factor/fill ratio (0.75).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HashMap使用默认的初始容量&lt;strong&gt;（16）&lt;/strong&gt;和默认的加载因子（0.75）构造一个空哈希表。&lt;/em&gt; &lt;em&gt;其中，Hashtable使用默认的初始容量&lt;strong&gt;（11）&lt;/strong&gt;和负载因子/填充比（0.75）构造空的哈希表。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8dd40f98b719540fa3ef0929171c1d3bc9907016" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hashtable is a legacy class introduced in &lt;code&gt;JDK1.0&lt;/code&gt;, which is a subclass of Dictionary class. From &lt;code&gt;JDK1.2&lt;/code&gt; Hashtable is re-engineered to implement the &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;Map interface&lt;/a&gt; to make a member of collection framework. HashMap is a member of Java Collection Framework right from the beginning of its introduction in &lt;code&gt;JDK1.2&lt;/code&gt;. HashMap is the subclass of the AbstractMap class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Hashtable是 &lt;code&gt;JDK1.0&lt;/code&gt; 中引入的旧类，它是Dictionary类的子类。&lt;/em&gt; &lt;em&gt;从 &lt;code&gt;JDK1.2&lt;/code&gt; 起,对 Hashtable进行了重新设计，以实现&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;Map接口&lt;/a&gt;以使其成为集合框架的成员。&lt;/em&gt; &lt;em&gt;从 &lt;code&gt;JDK1.2&lt;/code&gt; 引入HashMap开始，它就是Java Collection Framework的成员。&lt;/em&gt; &lt;em&gt;HashMap是AbstractMap类的子类。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="500218975390156875accb6dbe2f354e3173f3e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a &quot;&lt;code&gt;hash&lt;/code&gt;&lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt;&lt;code&gt;collision&lt;/code&gt;&lt;/a&gt;&quot;, a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;容量是哈希表中存储桶的数量，初始容量只是创建哈希表时的容量。&lt;/em&gt; &lt;em&gt;请注意，哈希表是打开的：在&amp;ldquo; &lt;code&gt;hash&lt;/code&gt; &lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt; &lt;code&gt;collision&lt;/code&gt; &lt;/a&gt; &amp;rdquo;的情况下，单个存储桶会存储多个条目，必须按顺序搜索这些条目。&lt;/em&gt; &lt;em&gt;负载因子是在自动增加其哈希表容量之前允许哈希表获得的满度的度量。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b2906198844595f36fc6fa0dd97c9082d03f289b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Collection-view iteration, Fail-Fast and Fail-Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;收集视图迭代，快速失败和安全&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7914abd8212625a168b15acf6950ab3c15a2effa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Initial capacity and Load factor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;初始容量和负载系数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6993db023d391ae7cbb4cf066cfcb7e989bc8404" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Null Keys And Null Values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;空键和空值&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c20ec51a8964581feeee1ad7fb05fa002cf9687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7511967863d20bb8b4fe1260a05e4cb1bab41336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Structural modification in case of hash collision&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;发生哈希冲突时进行结构修改&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fe1bf3045a21d6736352a953873017484a6bc5ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Superclass, Legacy and Collection Framework member&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;超类，旧版和收集框架成员&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="185ecb719c3e2e537438ec956fe6478e08b5fe09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Synchronized, Thread Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;同步，线程安全&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ce5fccec3d4c3a9b001c5a415252b106c57db67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32a8a99aed109def0e75d162d6deb196e91238da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Like &lt;code&gt;Hashtable&lt;/code&gt; but unlike &lt;code&gt;HashMap&lt;/code&gt;, this class does not allow null to be used as a key or value.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;与 &lt;code&gt;Hashtable&lt;/code&gt; 类似，但与 &lt;code&gt;HashMap&lt;/code&gt; 不同，此类不允许将null用作键或值。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8218937231a3c47bf14d75f244f490d51f3b93e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;范例&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="cebcd49ebbc8d28ef3e1865793fbff6f09d04c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap and HashTable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap和HashTable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c22768d0fd9bc69987104948fcbbae61922d34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46e9a015b499fca6a53da3a15919c4913909cfae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad1ee7e22808c3a788f0a1f004a79a0d59da5d9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt; is like &lt;strong&gt;Hashtable&lt;/strong&gt; but it also accepts key value pair. It allows null for both the keys and the values. Its performance better is better than &lt;code&gt;HashTable&lt;/code&gt;, because it is &lt;code&gt;unsynchronized&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt;类似于&lt;strong&gt;Hashtable，&lt;/strong&gt;但它也接受键值对。 它允许键和值均为null。 它的性能是优于 &lt;code&gt;HashTable&lt;/code&gt; 的 ，因为它是 &lt;code&gt;unsynchronized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a8219969622a494e81fa636ffe2146fe95d705f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hashtable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3df875dc7fbdad1a94f31dde139d3c47b9695e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt; is a data structure that retains values of key-value pair. It doesn&amp;rsquo;t allow null for both the keys and the values. You will get a &lt;code&gt;NullPointerException&lt;/code&gt; if you add null value. It is synchronized. So it comes with its cost. Only one thread can access &lt;strong&gt;HashTable&lt;/strong&gt; at a particular time.</source>
          <target state="translated">&lt;strong&gt;哈希表&lt;/strong&gt;是一种保留键值对值的数据结构。 键和值都不允许为null。 如果添加null值，则将获得 &lt;code&gt;NullPointerException&lt;/code&gt; 。 已同步。 因此，它附带了成本。 在特定时间只有一个线程可以访问&lt;strong&gt;HashTable&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="87f9eccd26b220f3fffdcc16c43e989775ffb9b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Therefore, always stay away from them in new code since there always better alternative in the JCF&lt;/strong&gt; as others had pointed out.</source>
          <target state="translated">&lt;strong&gt;因此，&lt;/strong&gt;由于其他人指出的， &lt;strong&gt;JCF中总是有更好的替代方法，因此请始终远离新代码&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="25d50188019a6203506db4eaf255be67c2575b4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; No, they won't land in 1.8... :(</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;不，他们不会降落在1.8 ... :(</target>
        </trans-unit>
        <trans-unit id="dfb42b9b02e91bb8174c286bcbc7e89091ed670e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;b&gt;NOTE:&lt;/b&gt; The functionality of Enumeration interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;b&gt;注意：&lt;/b&gt;枚举接口重复了Enumeration接口的功能。&lt;/sub&gt; &lt;sub&gt;此外，Iterator添加了可选的remove操作，并且具有较短的方法名称。&lt;/sub&gt; &lt;sub&gt;新实现应优先考虑使用Iterator而不是Enumeration。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="ac2433b57b2a782b71863cba68f09953ec4c0263" translate="yes" xml:space="preserve">
          <source>@See</source>
          <target state="translated">@See</target>
        </trans-unit>
        <trans-unit id="6b37ea03133b5dc642ccd5644d5b2ef41cc8ea38" translate="yes" xml:space="preserve">
          <source>A red&amp;ndash;black tree is a kind of self-balancing binary search tree</source>
          <target state="translated">红黑树是一种自平衡二进制搜索树</target>
        </trans-unit>
        <trans-unit id="084f214b26afe2233736dea659b6712cd361bbee" translate="yes" xml:space="preserve">
          <source>A very common idiom is to &quot;check then put&quot; &amp;mdash; i.e. look for an entry in the &lt;code&gt;Map&lt;/code&gt;, and add it if it does not already exist. This is not in any way an atomic operation whether you use &lt;code&gt;Hashtable&lt;/code&gt; or &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">一个非常常见的习惯用法是&amp;ldquo;先检查然后放&amp;rdquo;-即在 &lt;code&gt;Map&lt;/code&gt; 中查找条目，如果尚不存在，则将其添加。 无论您使用 &lt;code&gt;Hashtable&lt;/code&gt; 还是 &lt;code&gt;HashMap&lt;/code&gt; ,这都不是原子操作。</target>
        </trans-unit>
        <trans-unit id="1ef3449d808edb36ce53bb89ce36fe2cd8e8058d" translate="yes" xml:space="preserve">
          <source>According to Java API Docs, Iterator is always preferred over the Enumeration.</source>
          <target state="translated">根据Java API Docs,Iterator总是比Enumeration要好。</target>
        </trans-unit>
        <trans-unit id="7b526b4ffbef0a933328ce463df2d1cd68dd7c44" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Hashtable&lt;/code&gt; extends the &lt;code&gt;Dictionary&lt;/code&gt; class, which as the &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocs&lt;/a&gt; state, is obsolete and has been replaced by the &lt;code&gt;Map&lt;/code&gt; interface.</source>
          <target state="translated">还请注意， &lt;code&gt;Hashtable&lt;/code&gt; 扩展了 &lt;code&gt;Dictionary&lt;/code&gt; 类，正如&lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocs所&lt;/a&gt;声明的那样，该类已过时，已由 &lt;code&gt;Map&lt;/code&gt; 接口取代。</target>
        </trans-unit>
        <trans-unit id="0f187c58c90f9a43256314abab97119abc44122e" translate="yes" xml:space="preserve">
          <source>An equivalently synchronised &lt;code&gt;HashMap&lt;/code&gt; can be obtained by:</source>
          <target state="translated">可以通过以下方式获得等效同步的 &lt;code&gt;HashMap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e9103e37fff0521b7c39be1ecc0df1aeeea1dd2b" translate="yes" xml:space="preserve">
          <source>Another difference is that iterator in the &lt;code&gt;HashMap&lt;/code&gt; is fail-safe
while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; isn't. If you change the map
while iterating, you'll know.</source>
          <target state="translated">另一个区别是 &lt;code&gt;HashMap&lt;/code&gt; 中的迭代器是故障安全的，而 &lt;code&gt;Hashtable&lt;/code&gt; 的枚举器则不是。 如果您在迭代时更改地图，就会知道。</target>
        </trans-unit>
        <trans-unit id="acee8a439f9e4944ad00c1a48c53ef2a93e9d1fe" translate="yes" xml:space="preserve">
          <source>Another key difference between hashtable and hashmap is that Iterator in the HashMap is  fail-fast  while the enumerator for the Hashtable is not and throw ConcurrentModificationException if any other Thread modifies the map structurally  by adding or removing any element except Iterator's own remove()  method. But this is not a guaranteed behavior and will be done by JVM on best effort.&quot;</source>
          <target state="translated">hashtable和hashMap的另一个关键区别是,HashMap中的Iterator是快速失效的,而HashMap的枚举器则不是,如果除了Iterator自己的remove()方法外,其他任何其他Thread通过添加或删除任何元素来修改映射结构,都会抛出ConcurrentModificationException。但这不是一个保证的行为,将由JVM尽力而为。&quot;</target>
        </trans-unit>
        <trans-unit id="9a3708be3084838c9add3ab49ecf14e2a1b70039" translate="yes" xml:space="preserve">
          <source>Apart from the differences already mentioned, it should be noted that since Java 8, &lt;code&gt;HashMap&lt;/code&gt; dynamically replaces the Nodes (linked list) used in each bucket with TreeNodes (red-black tree), so that even if high hash collisions exist, the worst case &lt;em&gt;when searching&lt;/em&gt; is</source>
          <target state="translated">除了已经提到的差异外，还应注意，自Java 8起， &lt;code&gt;HashMap&lt;/code&gt; 用TreeNodes（红黑树）动态替换每个存储桶中使用的Nodes（链表），因此即使存在高哈希冲突，最坏的情况&lt;em&gt;当搜索&lt;/em&gt;是</target>
        </trans-unit>
        <trans-unit id="835ac593a034529b8d59e5594146aeee9100a895" translate="yes" xml:space="preserve">
          <source>Are Project Coin's collection enhancements going to be in JDK8?</source>
          <target state="translated">Project Coin的收集增强功能会在JDK8中出现吗?</target>
        </trans-unit>
        <trans-unit id="91975686e2264b305fe313101bec221ece54fee0" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized, this makes &lt;code&gt;Hashtable&lt;/code&gt; slightly slower than the &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">由于 &lt;code&gt;Hashtable&lt;/code&gt; 是内部同步的，因此这使 &lt;code&gt;Hashtable&lt;/code&gt; 的速度比 &lt;code&gt;HashMap&lt;/code&gt; 的速度稍慢。</target>
        </trans-unit>
        <trans-unit id="86480f222192a446b1ab808c5920c537dfc97134" translate="yes" xml:space="preserve">
          <source>Based on the info &lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;here&lt;/a&gt;, I'd recommend going with HashMap.  I think the biggest advantage is that Java will prevent you from modifying it while you are iterating over it, unless you do it through the iterator.</source>
          <target state="translated">根据&lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;此处&lt;/a&gt;的信息，我建议您使用HashMap。 我认为最大的好处是Java会阻止您在对其进行迭代时对其进行修改，除非您通过迭代器进行修改。</target>
        </trans-unit>
        <trans-unit id="d0a56f41ce29c24403b973ae8e801eead605fafd" translate="yes" xml:space="preserve">
          <source>Beside all the other important aspects already mentioned here, Collections API (e.g. Map interface) is being modified all the time to conform to the &quot;latest and greatest&quot; additions to Java spec.</source>
          <target state="translated">除了这里已经提到的所有其他重要的方面,Collections API(例如Map接口)也在不断地修改,以符合Java规范中 &quot;最新的、最大的 &quot;补充。</target>
        </trans-unit>
        <trans-unit id="883db36727c6fc674b9af62ca03268fec3a2fc5d" translate="yes" xml:space="preserve">
          <source>Blog by Manish Chhabra</source>
          <target state="translated">博客作者:Manish Chhabra</target>
        </trans-unit>
        <trans-unit id="161ee3e5332fc7ada8de95c3e13e87513aefb405" translate="yes" xml:space="preserve">
          <source>But to correctly implement this logic you need &lt;strong&gt;additional synchronisation&lt;/strong&gt; of the form:</source>
          <target state="translated">但是要正确实现此逻辑，您需要对表单进行&lt;strong&gt;额外的同步&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="701dc0240892c2e16f792b706d048825cd15ef02" translate="yes" xml:space="preserve">
          <source>Differences between HashMap and Hashtable</source>
          <target state="translated">HashMap和Hashtable的区别</target>
        </trans-unit>
        <trans-unit id="3df089853d91c18fa4e328324d91b136000d4c1a" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;HashMapEntry&lt;/code&gt;s value is &lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;volatile&lt;/a&gt; thereby ensuring fine grain consistency for contended modifications and subsequent reads; each read reflects the most recently completed update</source>
          <target state="translated">每个 &lt;code&gt;HashMapEntry&lt;/code&gt; 的值都是&lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;可变的，&lt;/a&gt;从而确保了细微的一致性，以便进行有争议的修改和后续读取。 每次读取均反映最近完成的更新</target>
        </trans-unit>
        <trans-unit id="74b2e0a75cd7cb287224f128b35087ba9f24b35c" translate="yes" xml:space="preserve">
          <source>Enumerator in &lt;code&gt;Hashtable&lt;/code&gt; is not fail-fast.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 中的枚举器不是快速失败的。</target>
        </trans-unit>
        <trans-unit id="ada4c28c6e7bcc1c37b1f37cd28e11b4c21a0d85" translate="yes" xml:space="preserve">
          <source>Even iterating over a &lt;code&gt;Hashtable&lt;/code&gt;'s entries (or a &lt;code&gt;HashMap&lt;/code&gt; obtained by &lt;code&gt;Collections.synchronizedMap&lt;/code&gt;) is not thread safe unless you also guard the &lt;code&gt;Map&lt;/code&gt; from being modified through additional synchronization.</source>
          <target state="translated">甚至遍历 &lt;code&gt;Hashtable&lt;/code&gt; 的条目（或由 &lt;code&gt;Collections.synchronizedMap&lt;/code&gt; 获得的 &lt;code&gt;HashMap&lt;/code&gt; ）也是线程安全的，除非您还防止通过其他同步来修改 &lt;code&gt;Map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aef57bb24b9645fae322828e390476f8cb44301e" translate="yes" xml:space="preserve">
          <source>FYI, currently,</source>
          <target state="translated">参考资料显示,目前。</target>
        </trans-unit>
        <trans-unit id="65e3d605f886f039cefd6fcaa6b0600199f9e6cb" translate="yes" xml:space="preserve">
          <source>Fail-safe is relevant within the context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object &quot;structurally&quot;, a concurrent modification exception will be thrown. It is possible for other threads though to invoke &lt;code&gt;set&lt;/code&gt; method since it doesn't modify the collection &quot;structurally&quot;. However, if prior to calling &lt;code&gt;set&lt;/code&gt;, the collection has been modified structurally, &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">故障安全在迭代器的上下文中是相关的。 如果在集合对象上创建了迭代器，并且其他某个线程尝试&amp;ldquo;结构化&amp;rdquo;修改集合对象，则将引发并发修改异常。 尽管其他线程可能不会调用 &lt;code&gt;set&lt;/code&gt; 方法，因为它不会&amp;ldquo;结构化&amp;rdquo;地修改集合，因此可能会调用set方法。 但是，如果在调用 &lt;code&gt;set&lt;/code&gt; 之前对集合进行了结构性修改，则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e195bfdae28c7dbd825f2b0cfa215fcc4514276c" translate="yes" xml:space="preserve">
          <source>First and most significant different between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is that, &lt;code&gt;HashMap&lt;/code&gt; is not thread-safe  while &lt;code&gt;Hashtable&lt;/code&gt; is a thread-safe collection.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 和 &lt;code&gt;HashMap&lt;/code&gt; 之间的首要差异是， &lt;code&gt;HashMap&lt;/code&gt; 不是线程安全的，而 &lt;code&gt;Hashtable&lt;/code&gt; 是线程安全的集合。</target>
        </trans-unit>
        <trans-unit id="4c2940247e674a032904e85951f08703d55f1e27" translate="yes" xml:space="preserve">
          <source>For example, compare Java 5 Map iterating:</source>
          <target state="translated">例如,对比一下Java 5地图迭代。</target>
        </trans-unit>
        <trans-unit id="97aba7dc3fa8453988dd3eaad09f2bfffab2858d" translate="yes" xml:space="preserve">
          <source>For non-threaded apps, use &lt;code&gt;HashMap&lt;/code&gt; since they are otherwise the same in terms of functionality.</source>
          <target state="translated">对于非线程应用程序，请使用 &lt;code&gt;HashMap&lt;/code&gt; ,因为它们在功能方面是相同的。</target>
        </trans-unit>
        <trans-unit id="a864fbe79b123e5b3781c7606dbae5a3c23396a8" translate="yes" xml:space="preserve">
          <source>For threaded apps, you can often get away with ConcurrentHashMap- depends on your performance requirements.</source>
          <target state="translated">对于线程应用程序,你通常可以用ConcurrentHashMap来解决,这取决于你的性能要求。</target>
        </trans-unit>
        <trans-unit id="3df9160472a36ae89d781b3c6ab26022d5640f0e" translate="yes" xml:space="preserve">
          <source>Further reading &lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;What is difference between HashMap and Hashtable in Java?&lt;/a&gt;</source>
          <target state="translated">进一步阅读&lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;Java中的HashMap和Hashtable有什么区别？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf8d0414df57d55121993c998babc6dc951ab933" translate="yes" xml:space="preserve">
          <source>HashMap and Hashtable both implement java.util.Map interface but there
  are some differences that Java developers must understand to write
  more efficient code. As of the Java 2 platform v1.2, Hashtable class
  was retrofitted to implement the Map interface, making it a member of
  the Java Collections Framework.</source>
          <target state="translated">HashMap和Hashtable都实现了java.util.Map接口,但两者有一些区别,Java开发人员必须了解,才能写出更高效的代码。从Java 2平台v1.2版本开始,Hashtable类被改造成实现了Map接口,使其成为Java集合框架的成员。</target>
        </trans-unit>
        <trans-unit id="ddadac488e5ff532483d1a91068404f62fc5a825" translate="yes" xml:space="preserve">
          <source>HashMap does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">HashMap并不保证地图的顺序会随着时间的推移保持不变。</target>
        </trans-unit>
        <trans-unit id="eadebb7419f0310830aa9293de3df75d77865879" translate="yes" xml:space="preserve">
          <source>HashMap doesn't guarantee the order in which elements are returned. For HashTable I guess it's the same but I'm not entirely sure, I don't find ressource that clearly state that.</source>
          <target state="translated">HashMap并不保证元素返回的顺序。对于HashTable,我想是一样的,但我不完全确定,我没有找到ressource明确说明这一点。</target>
        </trans-unit>
        <trans-unit id="6aedc41f6a22926e230616147632602f9650712c" translate="yes" xml:space="preserve">
          <source>HashMap: It is a class available inside java.util package and it is used to store the element in key and value format.</source>
          <target state="translated">HashMap。它是java.util包内的一个类,用于以键和值格式存储元素。</target>
        </trans-unit>
        <trans-unit id="a46f2ebc98dcc8b75520890a511e99f853ea5a9c" translate="yes" xml:space="preserve">
          <source>HashMaps gives you freedom of synchronization and debugging is lot more easier</source>
          <target state="translated">HashMaps让你可以自由地同步和调试更容易。</target>
        </trans-unit>
        <trans-unit id="78c9bd228fbd8c5d46c4bce0592c89eff91a7d49" translate="yes" xml:space="preserve">
          <source>HashTable and HashMap are member of the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; (since Java 2 platform v1.2, HashTable was retrofitted to implement the Map interface).</source>
          <target state="translated">HashTable和HashMap是&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework的&lt;/a&gt;成员（自Java 2平台v1.2起，对HashTable进行了改进以实现Map接口）。</target>
        </trans-unit>
        <trans-unit id="df229e5af731d7fbb0555f5de0920510f2c0df41" translate="yes" xml:space="preserve">
          <source>HashTable can only contain non-null object as a key or as a value. HashMap can contain one null key and null values.</source>
          <target state="translated">HashTable只能包含非空对象作为键或作为值。HashMap可以包含一个空键和空值。</target>
        </trans-unit>
        <trans-unit id="58a95549c3436ee60ecd7871e7ce42d8ae786e25" translate="yes" xml:space="preserve">
          <source>HashTable is considered legacy code, the documentation advise to use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; in place of Hashtable if a thread-safe highly-concurrent implementation is desired.</source>
          <target state="translated">HashTable被认为是遗留代码，如果需要线程安全的高并发实现，则文档建议使用&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt;代替Hashtable。</target>
        </trans-unit>
        <trans-unit id="660b9dcb49d86a9b0d8ca2dbc507dfa2ac01bd00" translate="yes" xml:space="preserve">
          <source>HashTable won't allow null keys or null values. Where as HashMap allows one null key, and multiple null values.</source>
          <target state="translated">HashTable不允许空键或空值。而HashMap允许一个空键和多个空值。</target>
        </trans-unit>
        <trans-unit id="22474fbd1e3d38434c362a687e63aec30ae3ab68" translate="yes" xml:space="preserve">
          <source>HashTables are by default synchronized, so it can be used with multiple threads easily. Where as HashMaps are not synchronized by default, so can be used with only single thread.  But you can still convert HashMap to synchronized by using Collections util class's synchronizedMap(Map m) function.</source>
          <target state="translated">HashTables默认是同步的,所以它可以很容易地与多个线程一起使用。而HashMaps默认情况下是不同步的,所以只能和单线程一起使用。但是你仍然可以通过使用Collections util类的synchronizedMap(Map m)函数将HashMap转换为synchronized。</target>
        </trans-unit>
        <trans-unit id="3739cd326e022a0ec2d5f895c0053c82658a5ec3" translate="yes" xml:space="preserve">
          <source>Hashtable: It is a legacy class which is being recognized inside collection framework.</source>
          <target state="translated">Hashtable。它是一个遗留类,正在收集框架内部被认可。</target>
        </trans-unit>
        <trans-unit id="3c394da10080138b6474986dd183541c34fb7fc8" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;Java collection cheat sheet&lt;/a&gt; that you will find useful. Notice the gray block contains the legacy class HashTable,Vector and Stack.</source>
          <target state="translated">这是您会发现有用的&lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;Java收集备忘单&lt;/a&gt; 。 请注意，灰色块包含旧类HashTable，Vector和Stack。</target>
        </trans-unit>
        <trans-unit id="0e897a22091a5c72367aa2c68491be56a91daa38" translate="yes" xml:space="preserve">
          <source>Implementations of the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt;&lt;code&gt;ConcurrentMap&lt;/code&gt;&lt;/a&gt; interface (for example &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;) solve some of this by including &lt;strong&gt;thread safe check-then-act semantics&lt;/strong&gt; such as:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt; &lt;code&gt;ConcurrentMap&lt;/code&gt; &lt;/a&gt;接口的实现（例如&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; ）通过包括&lt;strong&gt;线程安全的&amp;ldquo;先检查后行为&amp;rdquo;语义来&lt;/strong&gt;解决其中的一些问题，例如：</target>
        </trans-unit>
        <trans-unit id="ef247363dca7947ce18807b023f807375513e571" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5 introduced ConcurrentMap Interface&lt;/a&gt;: &lt;code&gt;ConcurrentHashMap&lt;/code&gt; - a highly concurrent, high-performance &lt;code&gt;ConcurrentMap&lt;/code&gt; implementation backed by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for &lt;code&gt;Hashtable&lt;/code&gt;: in addition to implementing &lt;code&gt;ConcurrentMap&lt;/code&gt;, it supports all of the &quot;legacy&quot; methods peculiar to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5中引入了ConcurrentMap接口&lt;/a&gt; ： &lt;code&gt;ConcurrentHashMap&lt;/code&gt; -由哈希表支持的高度并发，高性能 &lt;code&gt;ConcurrentMap&lt;/code&gt; 实现。 此实现在执行检索时不会阻塞，并允许客户端选择用于更新的并发级别。 它旨在替代 &lt;code&gt;Hashtable&lt;/code&gt; ：除了实现 &lt;code&gt;ConcurrentMap&lt;/code&gt; 之外 ，它还支持 &lt;code&gt;Hashtable&lt;/code&gt; 特有的所有&amp;ldquo;传统&amp;rdquo;方法。</target>
        </trans-unit>
        <trans-unit id="147cebda6bdb73c5d51fbf40ab2e08956d0ec790" translate="yes" xml:space="preserve">
          <source>In Hashtable there is a function contains(), which is very confusing to use. Because the meaning of contains is slightly deviating. Whether it means contains key or contains  value? tough to understand. Same thing in Maps we have ContainsKey() and ContainsValue() functions, which are very easy to understand.</source>
          <target state="translated">在Hashtable中有一个函数 contains(),使用起来非常混乱。因为 contains的含义略有偏差,到底是包含键的意思还是包含值的意思?到底是包含键还是包含值? 很难理解。同样的,在Maps中我们有containsKey()和containsValue()函数,这两个函数很容易理解。</target>
        </trans-unit>
        <trans-unit id="6b511ed6e04d77fc78318a00b4ae9f36a4f5fa39" translate="yes" xml:space="preserve">
          <source>In Java 1.8 we are also promised to be able to construct and access HashMaps like in good old scripting languages:</source>
          <target state="translated">在Java 1.8中,我们还承诺能够像以前的脚本语言一样构造和访问HashMaps。</target>
        </trans-unit>
        <trans-unit id="cd8c0f0e029d8fe772c617136311a3f6576de97f" translate="yes" xml:space="preserve">
          <source>In Summary there are significant differences between Hashtable and
  HashMap in Java e.g. thread-safety and speed and based upon that only
  use Hashtable if you absolutely need thread-safety, if you are running
  Java 5 consider using ConcurrentHashMap in Java.</source>
          <target state="translated">总而言之,在Java中Hashtable和HashMap有明显的区别,比如线程安全和速度,基于此,只有在绝对需要线程安全的情况下才会使用Hashtable,如果你运行的是Java 5,可以考虑在Java中使用ConcurrentHashMap。</target>
        </trans-unit>
        <trans-unit id="554d6863c43fc3f761b7ff10daaee4fc3bc6661c" translate="yes" xml:space="preserve">
          <source>In addition to what izb said, &lt;code&gt;HashMap&lt;/code&gt; allows null values, whereas the &lt;code&gt;Hashtable&lt;/code&gt; does not.</source>
          <target state="translated">除了izb所说的以外， &lt;code&gt;HashMap&lt;/code&gt; 还允许空值，而 &lt;code&gt;Hashtable&lt;/code&gt; 则不允许。</target>
        </trans-unit>
        <trans-unit id="0ecd0ae571aba4721ee2996a4fe36a3db474af69" translate="yes" xml:space="preserve">
          <source>In hashmap you can remove element while iterating, safely. where as it is not possible in hashtables.</source>
          <target state="translated">在hashmap中,你可以在迭代时安全地删除元素,而在hash表中则不可能。</target>
        </trans-unit>
        <trans-unit id="7fbd74b62c43cd195aee64e1d4b3f8da3aba383f" translate="yes" xml:space="preserve">
          <source>Iterator in &lt;code&gt;HashMap&lt;/code&gt; is fail-fast.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 中的迭代器是快速失败的。</target>
        </trans-unit>
        <trans-unit id="3481f252a01b24865e53a0d403077fe7c2bfb108" translate="yes" xml:space="preserve">
          <source>Iterator in the &lt;code&gt;HashMap&lt;/code&gt; is  fail-safe while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; is not and throw &lt;code&gt;ConcurrentModificationException&lt;/code&gt; if any other Thread modifies the map structurally  by adding or removing any element except &lt;code&gt;Iterator&lt;/code&gt;'s own &lt;code&gt;remove()&lt;/code&gt;  method. But this is not a guaranteed behavior and will be done by JVM on best effort.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 中的 Iterator是故障安全的，而 &lt;code&gt;Hashtable&lt;/code&gt; 的枚举器则不是，并且如果有其他线程通过添加或删除 &lt;code&gt;Iterator&lt;/code&gt; 自己的 &lt;code&gt;remove()&lt;/code&gt; 方法之外的任何元素来结构性地修改映射，则抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 。 但这不是保证的行为，将由JVM尽力而为。</target>
        </trans-unit>
        <trans-unit id="1a2f20d9e57bdf5adc94c3751cd34e64ab8a2d4c" translate="yes" xml:space="preserve">
          <source>Iterators and Enumerations are Fail Safe - reflecting the state at some point since the creation of iterator/enumeration; this allows for simultaneous reads and modifications at the cost of reduced consistency. They do not throw ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time.</source>
          <target state="translated">迭代器和枚举是Fail Safe-反映了迭代器和枚举在创建iteratorenumeration后的某一点上的状态;这允许以降低一致性为代价同时读取和修改。它们不会抛出ConcurrentModificationException。然而,迭代器被设计成一次只能被一个线程使用。</target>
        </trans-unit>
        <trans-unit id="254d25f74e4ed95d90db28daea166a6ffd3dd1ff" translate="yes" xml:space="preserve">
          <source>Java Collection Matrix</source>
          <target state="translated">Java集合矩阵</target>
        </trans-unit>
        <trans-unit id="93f74b798b3d08e2f768288051abb39a0bc5939a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;HashTable&lt;/code&gt; was legacy class before Java Collections Framework (JCF) was introduced and was later retrofitted to implement the &lt;code&gt;Map&lt;/code&gt; interface. So was &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Stack&lt;/code&gt;.</source>
          <target state="translated">请记住，在引入Java Collections Framework（JCF）之前， &lt;code&gt;HashTable&lt;/code&gt; 是旧类，后来进行了改进以实现 &lt;code&gt;Map&lt;/code&gt; 接口。 &lt;code&gt;Vector&lt;/code&gt; 和 &lt;code&gt;Stack&lt;/code&gt; 也是如此 。</target>
        </trans-unit>
        <trans-unit id="0449de243fc290a860ccfdc65f8437c895fd81b6" translate="yes" xml:space="preserve">
          <source>Map provides Collection views instead of direct support for iteration
 via Enumeration objects. Collection views greatly enhance the
 expressiveness of the interface, as discussed later in this section.
 Map allows you to iterate over keys, values, or key-value pairs;
 &lt;code&gt;Hashtable&lt;/code&gt; does not provide the third option. Map provides a safe way
 to remove entries in the midst of iteration; &lt;code&gt;Hashtable&lt;/code&gt; did not.
 Finally, Map fixes a minor deficiency in the &lt;code&gt;Hashtable&lt;/code&gt; interface.
 &lt;code&gt;Hashtable&lt;/code&gt; has a method called contains, which returns true if the
 &lt;code&gt;Hashtable&lt;/code&gt; contains a given value. Given its name, you'd expect this
 method to return true if the &lt;code&gt;Hashtable&lt;/code&gt; contained a given key, because
 the key is the primary access mechanism for a &lt;code&gt;Hashtable&lt;/code&gt;. The Map
 interface eliminates this source of confusion by renaming the method
 &lt;code&gt;containsValue&lt;/code&gt;. Also, this improves the interface's consistency &amp;mdash;
 &lt;code&gt;containsValue&lt;/code&gt; parallels &lt;code&gt;containsKey&lt;/code&gt;.</source>
          <target state="translated">Map提供Collection视图，而不是直接通过Enumeration对象支持迭代。 集合视图极大地增强了接口的表达能力，如本节后面所述。 Map允许您遍历键，值或键-值对； &lt;code&gt;Hashtable&lt;/code&gt; 不提供第三个选项。 Map提供了一种在迭代过程中删除条目的安全方法； &lt;code&gt;Hashtable&lt;/code&gt; 没有。 最后，Map修复了 &lt;code&gt;Hashtable&lt;/code&gt; 界面中的一个小缺陷。 &lt;code&gt;Hashtable&lt;/code&gt; 有一个名为contains的方法，如果 &lt;code&gt;Hashtable&lt;/code&gt; 包含给定值，则该方法返回true。 给定其名称，如果 &lt;code&gt;Hashtable&lt;/code&gt; 包含给定键，则您希望此方法返回true，因为该键是 &lt;code&gt;Hashtable&lt;/code&gt; 的主要访问机制。 Map接口通过重命名方法 &lt;code&gt;containsValue&lt;/code&gt; 消除了这种混乱的根源。 此外，这还改善了接口的一致性&amp;mdash; &lt;code&gt;containsValue&lt;/code&gt; 并行 &lt;code&gt;containsKey&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09cfe8513ef9f55ce5353dca09be872682455571" translate="yes" xml:space="preserve">
          <source>Maps allows you to iterate and retrieve keys, values, and both key-value pairs as well, Where HashTable don't have all this capability.</source>
          <target state="translated">Maps允许你迭代和检索键、值和键值对,而HashTable不具备这些功能。</target>
        </trans-unit>
        <trans-unit id="75a03fb098b6bc659568b1e29783c07476696b21" translate="yes" xml:space="preserve">
          <source>My small contribution :</source>
          <target state="translated">我的小小贡献:</target>
        </trans-unit>
        <trans-unit id="cdb51b953f61763ed033a4d76f1f625c07fe774b" translate="yes" xml:space="preserve">
          <source>My source: &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&lt;/a&gt;</source>
          <target state="translated">我的来源： &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http&lt;/a&gt; ： //javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html</target>
        </trans-unit>
        <trans-unit id="bcd6c2b779cd4727bdfc8b82c43e554e848868f9" translate="yes" xml:space="preserve">
          <source>Note on Some Important Terms:</source>
          <target state="translated">一些重要术语的注意事项。</target>
        </trans-unit>
        <trans-unit id="cc43492870882f3478ca9bc8edfbda8462e1df06" translate="yes" xml:space="preserve">
          <source>Note that HashMap can be synchronized by</source>
          <target state="translated">注意,HashMap可以通过以下方式同步</target>
        </trans-unit>
        <trans-unit id="4918d4974fe3cd4755ebe0e20277ccd382fa12f2" translate="yes" xml:space="preserve">
          <source>Note, that a lot of the answers state that Hashtable is synchronised.  &lt;strong&gt;In practice this buys you very little.&lt;/strong&gt;  The synchronization is on the accessor / mutator methods will stop two threads adding or removing from the map concurrently, but in the real world you will often need additional synchronisation.</source>
          <target state="translated">注意，很多答案都说明Hashtable已同步。 &lt;strong&gt;实际上，这几乎买不到您。&lt;/strong&gt; 同步在访问器/更改器方法上将使两个线程同时停止添加或从映射中删除，但是在现实世界中，您通常需要进行额外的同步。</target>
        </trans-unit>
        <trans-unit id="f180d9cd9c023ba8ad54546958cad221aff4883c" translate="yes" xml:space="preserve">
          <source>O(log(n)) for &lt;code&gt;HashMap&lt;/code&gt;&lt;strong&gt;Vs&lt;/strong&gt; O(n) in &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 的 O（log（n）） &lt;strong&gt;与&lt;/strong&gt; &lt;code&gt;Hashtable&lt;/code&gt; 中的 O（n）。</target>
        </trans-unit>
        <trans-unit id="2600125966cb5ea97c2b8c54e0758c7e46ca74a1" translate="yes" xml:space="preserve">
          <source>Old and classic topic, just want to add this helpful blog that explains this:</source>
          <target state="translated">古老而经典的话题,只是想补充一下这个有用的博客,解释一下。</target>
        </trans-unit>
        <trans-unit id="249a3a46c2e86414c5539f13f4f1a0225a7d5a6f" translate="yes" xml:space="preserve">
          <source>One more notable difference between Hashtable and HashMap is that because of thread-safety and synchronization Hashtable is much slower
  than HashMap if used in Single threaded environment. So if you don&amp;rsquo;t
  need synchronization and HashMap is only used by one thread, it out
  perform Hashtable in Java.</source>
          <target state="translated">Hashtable和HashMap之间的另一个显着差异是，由于具有线程安全性和同步性，如果在单线程环境中使用，则Hashtable的速度要比HashMap慢得多。 因此，如果您不需要同步并且HashMap仅由一个线程使用，则它将在Java中执行Hashtable。</target>
        </trans-unit>
        <trans-unit id="179c0a918e92d97127e98c73349a42a66aa21bd6" translate="yes" xml:space="preserve">
          <source>One of HashMap's subclasses is &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt;, so in the event that you'd want predictable iteration order (which is insertion order by default), you could easily swap out the &lt;code&gt;HashMap&lt;/code&gt; for a &lt;code&gt;LinkedHashMap&lt;/code&gt;.  This wouldn't be as easy if you were using &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">HashMap的子类之一是&lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt; ，因此，如果您需要可预测的迭代顺序（默认情况下为插入顺序），则可以轻松地将 &lt;code&gt;HashMap&lt;/code&gt; 换成 &lt;code&gt;LinkedHashMap&lt;/code&gt; 。 如果您使用的是 &lt;code&gt;Hashtable&lt;/code&gt; ,这将不那么容易。</target>
        </trans-unit>
        <trans-unit id="1525943ae6179c4dbbe03560c257ffac662fb828" translate="yes" xml:space="preserve">
          <source>One of the major differences between HashMap and Hashtable is that HashMap is non-synchronized whereas Hashtable is synchronized, which
  means Hashtable is thread-safe and can be shared between multiple
  threads but HashMap cannot be shared between multiple threads without
  proper synchronization. Java 5 introduced ConcurrentHashMap which is
  an alternative of Hashtable and provides better scalability than
  Hashtable in Java.Synchronized means only one thread can modify a hash
  table at one point of time. Basically, it means that any thread before
  performing an update on a hashtable will have to acquire a lock on the
  object while others will wait for lock to be released.</source>
          <target state="translated">HashMap和Hashtable的主要区别之一是HashMap是非同步的,而Hashtable是同步的,这意味着Hashtable是线程安全的,可以在多个线程之间共享,但HashMap在没有适当的同步的情况下不能在多个线程之间共享。Java 5引入了ConcurrentHashMap,它是Hashtable的替代产品,在Java中提供了比Hashtable更好的可扩展性。基本上,它意味着任何线程在对哈希表进行更新之前,都必须在对象上获取一个锁,而其他线程将等待锁的释放。</target>
        </trans-unit>
        <trans-unit id="95781641174af3b5c28daa7afb4c768668074452" translate="yes" xml:space="preserve">
          <source>Performance Improvement for &lt;code&gt;HashMap&lt;/code&gt; in Java 8</source>
          <target state="translated">Java 8中 &lt;code&gt;HashMap&lt;/code&gt; 的性能改进</target>
        </trans-unit>
        <trans-unit id="fee29654ce34b086768db65a4b25fcd54f9ed463" translate="yes" xml:space="preserve">
          <source>Second important difference between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is performance, since &lt;code&gt;HashMap&lt;/code&gt; is not synchronized it perform better than &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 和 &lt;code&gt;HashMap&lt;/code&gt; 之间的第二个重要区别是性能，因为 &lt;code&gt;HashMap&lt;/code&gt; 不同步，因此其性能优于 &lt;code&gt;Hashtable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b55e592836fe1e61392790c1a6fce30f1803ceb3" translate="yes" xml:space="preserve">
          <source>Separate from the obvious differences discussed extensively in this question, I see the Hashtable as a &quot;manual drive&quot; car where you have better control over the hashing and the HashMap as the &quot;automatic drive&quot; counterpart that will generally perform well.</source>
          <target state="translated">除了这个问题中广泛讨论的明显区别之外,我认为Hashable是 &quot;手动驱动 &quot;的车,在这里你可以更好地控制哈希算法,而HashMap是 &quot;自动驱动 &quot;的对应产品,一般来说,它的性能会很好。</target>
        </trans-unit>
        <trans-unit id="b3a738203d70f6090dfcdd1764cf29833f51bb9d" translate="yes" xml:space="preserve">
          <source>Seriously though, you're better off staying away from &lt;code&gt;Hashtable&lt;/code&gt; altogether. For single-threaded apps, you don't need the extra overhead of synchronisation. For highly concurrent apps, the paranoid synchronisation might lead to starvation, deadlocks, or unnecessary garbage collection pauses. Like Tim Howland pointed out, you might use &lt;code&gt;ConcurrentHashMap&lt;/code&gt; instead.</source>
          <target state="translated">认真地说，最好还是完全远离 &lt;code&gt;Hashtable&lt;/code&gt; 。 对于单线程应用程序，不需要同步的额外开销。 对于高度并发的应用程序，偏执同步可能会导致饥饿，死锁或不必要的垃圾收集暂停。 就像Tim Howland指出的那样，您可以改用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bdf790b2b1c9d6025dcbecb5bdb37ab2f60d7b4" translate="yes" xml:space="preserve">
          <source>Since synchronization is not an issue for you, I'd recommend &lt;code&gt;HashMap&lt;/code&gt;. If synchronization becomes an issue, you may also look at &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于同步对您来说不是问题，所以我建议 &lt;code&gt;HashMap&lt;/code&gt; 。 如果同步成为问题，您还可以查看&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bcb97fa6763fbfe1f0ff48e9f6a9c4dd72d057b" translate="yes" xml:space="preserve">
          <source>Some important points about HashMap and HashTable.
   please read below details.</source>
          <target state="translated">关于HashMap和HashTable的一些注意事项,请阅读以下内容。</target>
        </trans-unit>
        <trans-unit id="2773856ae2356cf0a8e12035c63973404b5e1bef" translate="yes" xml:space="preserve">
          <source>Structurally modification means deleting or inserting element which could effectively change the structure of map.</source>
          <target state="translated">结构上的修改是指删除或插入可以有效改变地图结构的元素。</target>
        </trans-unit>
        <trans-unit id="9ac0930f0753d909c7591e062bf09758da70879f" translate="yes" xml:space="preserve">
          <source>Synchronized means only one thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a &lt;code&gt;Hashtable&lt;/code&gt; will have to acquire a lock on the object while others will wait for lock to be released.</source>
          <target state="translated">同步意味着只有一个线程可以在某个时间点修改哈希表。 基本上，这意味着在对 &lt;code&gt;Hashtable&lt;/code&gt; 执行更新之前，任何线程都必须获取对象的锁，而其他线程将等待释放锁。</target>
        </trans-unit>
        <trans-unit id="70e8f2a076a2a427c74c96d2d6f12fe9436a1288" translate="yes" xml:space="preserve">
          <source>Take a look at this chart. It provides comparisons between different data structures along with &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. The comparison is precise, clear and easy to understand.</source>
          <target state="translated">看一下这张图。 它提供了 &lt;code&gt;HashMap&lt;/code&gt; 和 &lt;code&gt;Hashtable&lt;/code&gt; 以及不同数据结构之间的比较。 比较是准确，清晰和易于理解的。</target>
        </trans-unit>
        <trans-unit id="9b64a19c6daf91779b3938d649152906ab363b0e" translate="yes" xml:space="preserve">
          <source>The 5 main differences betwen HashMap and Hashtable</source>
          <target state="translated">HashMap和Hashtable的5大区别</target>
        </trans-unit>
        <trans-unit id="072d0888e52948dbd09f33a229cca91be253355a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt; class is roughly equivalent to &lt;code&gt;Hashtable&lt;/code&gt;, except that it is non synchronized and permits nulls. (&lt;code&gt;HashMap&lt;/code&gt; allows null values as key and value whereas &lt;code&gt;Hashtable&lt;/code&gt; doesn't allow &lt;code&gt;null&lt;/code&gt;s).</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 类与 &lt;code&gt;Hashtable&lt;/code&gt; 大致等效，除了它是不同步的并且允许为null之外。 （ &lt;code&gt;HashMap&lt;/code&gt; 允许将null值用作键和值，而 &lt;code&gt;Hashtable&lt;/code&gt; 不允许 &lt;code&gt;null&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0aeaae4475437892ad0e711f1d770aca667a7fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.2&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; and Hashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.0&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt;, both are used to represent a group of objects that are represented in &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair. Each &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair is called &lt;code&gt;Entry&lt;/code&gt; object. The collection of Entries is referred by the object of &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. Keys in a collection must be unique or distinctive. [as they are used to retrieve a mapped value a particular key. values in a collection can be duplicated.]</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.2&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt;和Hashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.0&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt;都用于表示以 &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; 对表示的一组对象。 每对 &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; 对都称为 &lt;code&gt;Entry&lt;/code&gt; 对象。 条目的集合由 &lt;code&gt;HashMap&lt;/code&gt; 和 &lt;code&gt;Hashtable&lt;/code&gt; 的对象引用。 集合中的键必须唯一或独特。 [因为它们用于检索特定键的映射值。 集合中的值可以重复。]</target>
        </trans-unit>
        <trans-unit id="00dc41b113291633c52fd58000a80e068e3e22e0" translate="yes" xml:space="preserve">
          <source>The HashMap class is roughly equivalent to Hashtable, except that it permits nulls. (HashMap allows null values as key and value whereas
  Hashtable doesn&amp;rsquo;t allow nulls).</source>
          <target state="translated">HashMap类大致上与Hashtable等效，除了它允许空值。 （HashMap允许将空值用作键和值，而Hashtable不允许空值）。</target>
        </trans-unit>
        <trans-unit id="f7ecf1afa5b4c9630d2b5dcfbe61d5b627ebd286" translate="yes" xml:space="preserve">
          <source>The Map Interface</source>
          <target state="translated">地图界面</target>
        </trans-unit>
        <trans-unit id="3676c70892d7c609193fc43d310096bd0df0c6be" translate="yes" xml:space="preserve">
          <source>The iterators returned by Map are fail-fast, if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. &lt;strong&gt;Whereas&lt;/strong&gt; the Enumerations returned by Hashtable's keys and elements methods are not fail-fast.</source>
          <target state="translated">Map返回的迭代器是快速失败的，如果在创建迭代器后的任何时候都对结构进行了结构修改，则除了通过迭代器自己的remove方法之外，该迭代器将抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 。 因此，面对并发修改，迭代器会快速干净地失败，而不会在未来的不确定时间内冒任意，不确定的行为的风险。 &lt;strong&gt;而&lt;/strong&gt; Hashtable的keys和elements方法返回的枚举并不是快速失败的。</target>
        </trans-unit>
        <trans-unit id="e573df66450873c1ddfa83005b4aa24d831fd978" translate="yes" xml:space="preserve">
          <source>The third significant difference between HashMap vs Hashtable is that Iterator in the HashMap is a fail-fast iterator while the
  enumerator for the Hashtable is not and throw
  ConcurrentModificationException if any other Thread modifies the map
  structurally by adding or removing any element except Iterator&amp;rsquo;s own
  remove() method. But this is not a guaranteed behavior and will be
  done by JVM on best effort. This is also an important difference
  between Enumeration and Iterator in Java.</source>
          <target state="translated">HashMap与Hashtable之间的第三个重要区别是，HashMap中的Iterator是一个快速失败的迭代器，而Hashtable的枚举器则不是，如果其他线程通过添加或删除Iterator自己的remove（ ） 方法。 但这不是保证的行为，将由JVM尽力而为。 这也是Java中Enumeration和Iterator之间的重要区别。</target>
        </trans-unit>
        <trans-unit id="f56383732ea0646c1b6ccc4780205710d6c51198" translate="yes" xml:space="preserve">
          <source>There are 5 basic differentiations with HashTable and HashMaps.</source>
          <target state="translated">与HashTable和HashMaps有5个基本区别。</target>
        </trans-unit>
        <trans-unit id="bb1f8a6f6840706e60372d6f2420a010dbd1ffca" translate="yes" xml:space="preserve">
          <source>There are several differences between &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java:</source>
          <target state="translated">Java中的&lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt;之间有一些区别：</target>
        </trans-unit>
        <trans-unit id="5800ffe299a96231836db81f351c861e03ed3697" translate="yes" xml:space="preserve">
          <source>There is many good answer already posted. I'm adding few new points and summarizing it.</source>
          <target state="translated">有很多好的答案已经贴出来了。我补充了几个新的点,总结了一下。</target>
        </trans-unit>
        <trans-unit id="df9315b5c785f8ab9f27801657f7477146067793" translate="yes" xml:space="preserve">
          <source>Third difference on &lt;code&gt;Hashtable&lt;/code&gt; vs &lt;code&gt;HashMap&lt;/code&gt; is that &lt;code&gt;Hashtable&lt;/code&gt; is obsolete class and you should be using &lt;code&gt;ConcurrentHashMap&lt;/code&gt; in place of &lt;code&gt;Hashtable&lt;/code&gt; in Java.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 与 &lt;code&gt;HashMap&lt;/code&gt; 的第三个区别是 &lt;code&gt;Hashtable&lt;/code&gt; 是过时的类，您应该在Java中使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 代替 &lt;code&gt;Hashtable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee9376793d9967bcbf5a7a8c815e756c9c9ccb2c" translate="yes" xml:space="preserve">
          <source>This question is often asked in interview to check whether candidate understands correct usage of collection classes and is aware of alternative solutions available.</source>
          <target state="translated">这个问题在面试中经常被问到,目的是检查考生是否了解收集类的正确使用方法,是否知道有其他的解决方案。</target>
        </trans-unit>
        <trans-unit id="247c0322284eae1d1388216cd3162f7e2cc8e631" translate="yes" xml:space="preserve">
          <source>We can make the &lt;code&gt;HashMap&lt;/code&gt; as synchronized by calling this code</source>
          <target state="translated">我们可以通过调用以下代码使 &lt;code&gt;HashMap&lt;/code&gt; 同步</target>
        </trans-unit>
        <trans-unit id="c81f8280687b9700ca5bb68ae586570fb7c23f46" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java?</source>
          <target state="translated">Java中的&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt;有什么区别？</target>
        </trans-unit>
        <trans-unit id="2c8e95a3c2ffb57733e53c253ed60a5636be3523" translate="yes" xml:space="preserve">
          <source>What is the difference between HashMap and HashTable?</source>
          <target state="translated">HashMap和HashTable有什么区别?</target>
        </trans-unit>
        <trans-unit id="ce3ce0552d057e3c8f06c38c4e4073b98a6a4ac5" translate="yes" xml:space="preserve">
          <source>Which is more efficient for non-threaded applications?</source>
          <target state="translated">非线程应用哪个更有效?</target>
        </trans-unit>
        <trans-unit id="2641089043a1d4d281fa1d792f1ac52e385d9822" translate="yes" xml:space="preserve">
          <source>versus the old Hashtable approach:</source>
          <target state="translated">与旧的Hashtable方法相比。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
