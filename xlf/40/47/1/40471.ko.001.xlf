<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/40471">
    <body>
      <group id="40471">
        <trans-unit id="1ffa479b2bc81d3a4bfacc7ab2a3c758037edec2" translate="yes" xml:space="preserve">
          <source>*The aforementioned improvement has not been applied to &lt;code&gt;Hashtable&lt;/code&gt; yet, but only to &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;LinkedHashMap&lt;/code&gt;, and &lt;code&gt;ConcurrentHashMap&lt;/code&gt;.</source>
          <target state="translated">* 상기 개선 사항은 아직 &lt;code&gt;Hashtable&lt;/code&gt; 에는 적용되지 않았지만 &lt;code&gt;HashMap&lt;/code&gt; , &lt;code&gt;LinkedHashMap&lt;/code&gt; 및 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 에만 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="0bebecfc307c9e1b712693d3b764211b8ed5cfb2" translate="yes" xml:space="preserve">
          <source>1) First difference is HashMap is not thread safe While HashTable is ThreadSafe</source>
          <target state="translated">1) 첫 번째 차이점은 HashMap은 스레드 안전이 아니며 HashTable은 ThreadSafe입니다</target>
        </trans-unit>
        <trans-unit id="e93948b799e95b7508984d1cffb6e8a3f9844579" translate="yes" xml:space="preserve">
          <source>1) Hashtable and Hashmap implement the java.util.Map interface
2) Both Hashmap and Hashtable is the hash based collection. and working on hashing.
so these are similarity of HashMap and HashTable.</source>
          <target state="translated">1) Hashtable과 Hashmap은 java.util.Map 인터페이스를 구현합니다. 2) Hashmap과 Hashtable은 모두 해시 기반 컬렉션입니다. 해싱 작업. HashMap과 HashTable의 유사점입니다.</target>
        </trans-unit>
        <trans-unit id="ce8ad15ae4892952ca56baaa8baaa429494f2e53" translate="yes" xml:space="preserve">
          <source>1.&lt;code&gt;Hashmap&lt;/code&gt; and &lt;code&gt;HashTable&lt;/code&gt; both store key and value.</source>
          <target state="translated">1. &lt;code&gt;Hashmap&lt;/code&gt; 과 &lt;code&gt;HashTable&lt;/code&gt; 은 키와 값을 모두 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ea022165e8aaef91c12ccef2e5123b0265799db7" translate="yes" xml:space="preserve">
          <source>2) HashMap is performance wise better because it is not thread safe. while Hashtable performance wise is not better because it is thread safe. so multiple thread can not access Hashtable at the same time.</source>
          <target state="translated">2) HashMap은 스레드 안전하지 않기 때문에 성능면에서 더 좋습니다. 스레드 안전하기 때문에 해시 테이블 성능이 현명하지 않습니다. 여러 스레드가 동시에 Hashtable에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a896733be888d07b7cbb8186abb374063e45bdd" translate="yes" xml:space="preserve">
          <source>2.&lt;code&gt;Hashmap&lt;/code&gt; can store one key as &lt;code&gt;null&lt;/code&gt;. &lt;code&gt;Hashtable&lt;/code&gt; can't store &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">2. &lt;code&gt;Hashmap&lt;/code&gt; 은 하나의 키를 &lt;code&gt;null&lt;/code&gt; 로 저장할 수 있습니다. &lt;code&gt;Hashtable&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 을 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="02a8a35731189356741a2efc879bda9c331af5d6" translate="yes" xml:space="preserve">
          <source>3.&lt;code&gt;HashMap&lt;/code&gt; is not synchronized but &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">3. &lt;code&gt;HashMap&lt;/code&gt; 은 동기화되지 않지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="7edecd9abb3471db7df504cd6c5936311ca4fa46" translate="yes" xml:space="preserve">
          <source>4.&lt;code&gt;HashMap&lt;/code&gt; can be synchronized with &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt;</source>
          <target state="translated">4. &lt;code&gt;HashMap&lt;/code&gt; 은 &lt;code&gt;Collection.SyncronizedMap(map)&lt;/code&gt; 과 동기화 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8772653c67ec1de6492448fff19367167e54b515" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is a legacy class in the jdk that shouldn't be used anymore. Replace usages of it with &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt;. If you don't require thread safety, use &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; which isn't &lt;a href=&quot;http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/concurrent/ThreadSafe.html&quot;&gt;threadsafe&lt;/a&gt; but faster and uses less memory.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; 은 더 이상 사용해서는 안되는 jdk의 레거시 클래스입니다. 사용법을 &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; 으로 바꾸십시오 . 스레드 안전성이 필요하지 않은 경우 스레드 안전성은 아니지만 더 빠르고 메모리를 덜 사용하는 &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a8212855afbfdfadf4f72d52f3fd51313aab01da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; is synchronized, if you are using it in a single thread you can use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, which is an unsynchronized version. Unsynchronized objects are often a little more performant. By the way if multiple threads access a HashMap concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. 
Youn can wrap a unsynchronized map in a synchronized one using :</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;HashTable&lt;/a&gt; 은 동기화되며 단일 스레드에서 사용하는 경우 동기화되지 않은 버전 인 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; 을 사용할 수 있습니다. 동기화되지 않은 객체는 종종 약간 더 성능이 좋습니다. 그런데 여러 스레드가 동시에 HashMap에 액세스하고 스레드 중 하나 이상이 맵을 구조적으로 수정하는 경우 외부 적으로 동기화해야합니다. 다음을 사용하여 동기화되지 않은 맵을 동기화 된 맵으로 랩핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35825761ff3e0e6aae7c813dc0f469fe68798cf4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; is a fail-fast in nature. i.e it throws ConcurrentModificationException if a collection is modified while iterating other than it&amp;rsquo;s own remove() method. Where as &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt;&lt;code&gt;Enumeration&lt;/code&gt;&lt;/a&gt; is fail-safe in nature. It doesn&amp;rsquo;t throw any exceptions if a collection is modified while iterating.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 는 본질적으로 빠른 실패입니다. 즉, 자체 remove () 메소드 이외의 반복을 수행하는 동안 컬렉션을 수정하면 ConcurrentModificationException이 발생합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html&quot;&gt; &lt;code&gt;Enumeration&lt;/code&gt; &lt;/a&gt; 이 본질적으로 페일 세이프 인 경우 반복하는 동안 컬렉션이 수정되면 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f5224599c22155916dabf87bba49566ddaa6261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows maximum one null key and any number of null values. Where as &lt;code&gt;Hashtable&lt;/code&gt; doesn&amp;rsquo;t allow even a single null key and null value, if the key or value null is then it throws NullPointerException. &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;Example&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 최대 하나의 널 키와 임의의 수의 널 값을 허용합니다. &lt;code&gt;Hashtable&lt;/code&gt; 이 단일 null 키와 null 값도 허용하지 않는 경우 키 또는 값이 null이면 NullPointerException이 발생합니다. &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/31243387/5081877&quot;&gt;예&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a5083b226eeb51dc40cc10003425a58b158f81eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; allows one null key and multiple null values.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 하나의 null 키와 여러 null 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="669df6fbbd3ba9c388deaba3fc0849ca8f6f2ff6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; both are used to store &lt;em&gt;data in key and value form&lt;/em&gt;. Both are using hashing technique to store unique keys.
But there are many differences between HashMap and Hashtable classes that are given below.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 과 &lt;code&gt;Hashtable&lt;/code&gt; 은 모두 &lt;em&gt;키와 값 형식으로 데이터&lt;/em&gt; 를 저장하는 데 사용됩니다. 둘 다 고유 키를 저장하기 위해 해싱 기술을 사용하고 있습니다. 그러나 아래에 주어진 HashMap 클래스와 Hashtable 클래스에는 많은 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac053a124fba70f26ef444ee7553d0c4785af36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt; have significant algorithmic differences as well. No one has mentioned this before so that's why I am bringing it up. &lt;code&gt;HashMap&lt;/code&gt; will construct a hash table with power of two size, increase it dynamically such that you have at most about eight elements (collisions) in any bucket and will stir the elements very well for general element types. However, the &lt;code&gt;Hashtable&lt;/code&gt; implementation provides better and finer control over the hashing if you know what you are doing, namely you can fix the table size using e.g. the closest prime number to your values domain size and this will result in better performance than HashMap i.e. less collisions for some cases.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 과 &lt;code&gt;Hashtable&lt;/code&gt; 은 알고리즘에 큰 차이가 있습니다. 아무도 이것을 전에 언급하지 않았기 때문에 내가 그것을 제기하는 이유입니다. &lt;code&gt;HashMap&lt;/code&gt; 은 두 가지 크기의 해시 테이블을 구성하고 모든 버킷에 최대 약 8 개의 요소 (충돌)를 갖도록 동적으로 늘리고 일반 요소 유형에 대해 요소를 잘 저어줍니다. 그러나 &lt;code&gt;Hashtable&lt;/code&gt; 구현은 수행중인 작업을 알고 있다면 해싱을보다 잘 제어 할 수 있습니다. 즉, 값을 도메인 값에 가장 가까운 소수를 사용하여 테이블 크기를 수정할 수 있으므로 HashMap보다 성능이 향상됩니다. 경우에 따라 충돌.</target>
        </trans-unit>
        <trans-unit id="64a17134b1046d668dd05ac2bc4f97f06a63e76e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; can be synchronized by</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="d500b59660957bd4381ff369b93e82d00b9b1f70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 맵 순서가 시간이 지남에 따라 일정하게 유지된다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8747ab7f19811c92ec840fe23f10d94ab4b3af3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; inherits AbstractMap class.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 AbstractMap 클래스를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="51fbe655ee9bcf724b8cabf41a90881d14820a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is a new class introduced in JDK 1.2.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 JDK 1.2에 도입 된 새로운 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b63a85d53f021a1ae8dd8bdd08fdc18c2b28c4cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is emulated and therefore usable in &lt;code&gt;GWT client code&lt;/code&gt; whereas &lt;code&gt;Hashtable&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 에뮬레이트되어 &lt;code&gt;GWT client code&lt;/code&gt; 에서 사용할 수 있지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8910e4452555bc0eb462a108515a97d9c3f5b62a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is fast.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 이 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="0ac323b983cb93bfa96d446a6acf3e0739d49b02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized whereas &lt;code&gt;Hashtable&lt;/code&gt; is synchronized.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 동기화되지 않지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="15bf5350ece84dd8e38bde89e4f666c4333d494b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is non synchronized. It is not-thread safe and can't be shared between many threads without proper synchronization code.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 이 동기화되지 않았습니다. 스레드 안전하지 않으며 적절한 동기화 코드가 없으면 많은 스레드간에 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7eecfc386a9ddceaa10ba8c78194cc8417a8cc62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; is traversed by Iterator.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 Iterator에 의해 순회됩니다.</target>
        </trans-unit>
        <trans-unit id="8697ca59be21a2145ac021e93da6593a2e482b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt; permits null values in it, while &lt;code&gt;Hashtable&lt;/code&gt; doesn't.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 null 값을 허용하지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 null 값을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce244b309892513fef48b0c0adb960eea745a513" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HashMap&lt;/code&gt;: An implementation of the &lt;code&gt;Map&lt;/code&gt; interface that uses hash codes to index an array.
&lt;code&gt;Hashtable&lt;/code&gt;: Hi, 1998 called. They want their collections API back.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; : 해시 코드를 사용하여 배열을 인덱싱하는 &lt;code&gt;Map&lt;/code&gt; 인터페이스 구현입니다. &lt;code&gt;Hashtable&lt;/code&gt; : 1998 년 안녕하세요. 그들은 컬렉션 API를 다시 원합니다.</target>
        </trans-unit>
        <trans-unit id="aea1fdd84192f7fc2e196adf40609942cb1285de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; does not allow &lt;code&gt;null&lt;/code&gt; keys or values.  &lt;code&gt;HashMap&lt;/code&gt; allows one &lt;code&gt;null&lt;/code&gt; key and any number of &lt;code&gt;null&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 키 또는 값을 허용하지 않습니다. &lt;code&gt;HashMap&lt;/code&gt; 은 하나의 &lt;code&gt;null&lt;/code&gt; 키와 임의의 수의 &lt;code&gt;null&lt;/code&gt; 값을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="da40767d527c7d8ee16fe1095a3c28313aaec00a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; doesn't allow any null key or value.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 은 null 키 또는 값을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e82d9c21537b4430e511e19537f8747613296279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; inherits Dictionary class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 은 Dictionary 클래스를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="473a8e23134d11e4c9e6a5a24f60baccffe8cd5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is &lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;synchronized&lt;/a&gt;, whereas &lt;code&gt;HashMap&lt;/code&gt; is not. This makes &lt;code&gt;HashMap&lt;/code&gt; better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 &lt;a href=&quot;https://stackoverflow.com/questions/1085709/what-does-synchronized-mean&quot;&gt;동기화&lt;/a&gt; 되지 않지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 동기화 됩니다. 동기화되지 않은 객체는 일반적으로 동기화 된 객체보다 성능이 우수하므로 스레드되지 않은 응용 프로그램에 대해 &lt;code&gt;HashMap&lt;/code&gt; 이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5f3b80ed3c8119e05343a43fa58d178aa8c248fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is a legacy class.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 은 레거시 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="74522ed93d3ffc34a0d85038cae726b8c4697227" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is considered legacy code. There's nothing about &lt;code&gt;Hashtable&lt;/code&gt; that can't be done using &lt;code&gt;HashMap&lt;/code&gt; or derivations of &lt;code&gt;HashMap&lt;/code&gt;, so for new code, I don't see any justification for going back to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 은 레거시 코드로 간주됩니다. &lt;code&gt;HashMap&lt;/code&gt; 또는 HashMap 파생을 사용하여 수행 할 수없는 &lt;code&gt;Hashtable&lt;/code&gt; 에 대해서는 아무것도 없으므로 새 코드의 경우 &lt;code&gt;Hashtable&lt;/code&gt; 으로 돌아가는 데 대한 정당성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="582981ade6fd1fb874a7cbaa7d7f669287851433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized and can't be unsynchronized.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 은 내부적으로 동기화되며 동기화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b50d2071547d1d8f01971f3564947ceb026e758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized. Therefore, it is very much safe to use &lt;code&gt;Hashtable&lt;/code&gt; in multi threaded applications. Where as &lt;code&gt;HashMap&lt;/code&gt; is not internally synchronized. Therefore, it is not safe to use &lt;code&gt;HashMap&lt;/code&gt; in multi threaded applications without external synchronization. You can externally synchronize &lt;code&gt;HashMap&lt;/code&gt; using &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 은 내부적으로 동기화됩니다. 따라서 다중 스레드 응용 프로그램에서 &lt;code&gt;Hashtable&lt;/code&gt; 을 사용하는 것이 매우 안전합니다. &lt;code&gt;HashMap&lt;/code&gt; 이 내부적으로 동기화되지 않은 곳. 따라서 외부 동기화없이 다중 스레드 응용 프로그램에서 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하는 것은 안전하지 않습니다. &lt;code&gt;Collections.synchronizedMap()&lt;/code&gt; 메서드를 사용하여 &lt;code&gt;HashMap&lt;/code&gt; 을 외부에서 동기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e63c856b660603f278bb16d5b114de8a3272ed31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is similar to the &lt;code&gt;HashMap&lt;/code&gt; and has a similar interface. It is recommended that you use &lt;code&gt;HashMap&lt;/code&gt;, unless you require support for legacy applications or you need synchronisation, as the &lt;code&gt;Hashtables&lt;/code&gt; methods are synchronised. So in your case as you are not multi-threading, &lt;code&gt;HashMaps&lt;/code&gt; are your best bet.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 은 &lt;code&gt;HashMap&lt;/code&gt; 과 유사하며 유사한 인터페이스를 가지고 있습니다. &lt;code&gt;Hashtables&lt;/code&gt; 메소드가 동기화되므로 레거시 애플리케이션에 대한 지원이 필요하거나 동기화가 필요한 경우가 아니라면 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하는 것이 좋습니다. 따라서 멀티 스레딩이 아닌 경우 &lt;code&gt;HashMaps&lt;/code&gt; 가 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6eaefd6be9ca644fb4dceef1106f715e6f13ce69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is slow.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 이 느립니다.</target>
        </trans-unit>
        <trans-unit id="ad27eec131dd51571006c484e66faa0226c0bffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized whereas &lt;code&gt;HashMap&lt;/code&gt; is not.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 동기화되지 않지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="25f83877d4ac62b168713576f58b2770a86b5aad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized, whereas &lt;code&gt;HashMap&lt;/code&gt; isn't. That makes &lt;code&gt;Hashtable&lt;/code&gt; slower than &lt;code&gt;Hashmap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 은 동기화되지 않지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 동기화됩니다. 그러면 &lt;code&gt;Hashtable&lt;/code&gt; 이 &lt;code&gt;Hashmap&lt;/code&gt; 보다 느려집니다.</target>
        </trans-unit>
        <trans-unit id="1c596268109b66bf2934f50af140575b7246bd11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is synchronized. It is thread-safe and can be shared with many threads.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 이 동기화되었습니다. 스레드 안전하고 많은 스레드와 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e53d6f6599341af744cd74547e079fc1d2c838b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hashtable&lt;/code&gt; is traversed by Enumerator and Iterator.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 은 열거 자와 반복자가 통과합니다.</target>
        </trans-unit>
        <trans-unit id="006d1c181f3c98522a669dc0abea34770eb93435" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; : if a bucket contains more than 8 nodes, the linked list is transformed into a balanced tree.</source>
          <target state="translated">&lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; : 버킷에 8 개 이상의 노드가 포함 된 경우 연결된 목록이 균형 트리로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f9177115bae6161497db808e68ed7cd40b2d6acf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; : when a bucket becomes too small (due to removal or resizing) the tree is converted back to linked list.</source>
          <target state="translated">&lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; : 버킷이 너무 작아지면 (제거 또는 크기 조정으로 인해) 트리가 연결된 목록으로 다시 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1000b8e627d741fb5080e9ad2ab05068f01c96cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;Hashtable&lt;/code&gt; in case of hash collisions they store the map entries in linked lists. &lt;strong&gt;From Java8 for &lt;code&gt;HashMap&lt;/code&gt;&lt;/strong&gt; if hash bucket grows beyond a certain threshold, that bucket will switch from &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt;&lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt;&lt;/a&gt;. which improve worst-case performance from O(n) to O(log n). While converting the list to binary tree, hashcode is used as a branching variable. If there are two different hashcodes in the same bucket, one is considered bigger and goes to the right of the tree and other one to the left. But when both the hashcodes are equal, &lt;code&gt;HashMap&lt;/code&gt; assumes that the keys are comparable, and compares the key to determine the direction so that some order can be maintained. It is a good practice to make the keys of &lt;code&gt;HashMap&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;comparable&lt;/a&gt;. On adding entries if bucket size reaches &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; convert linked list of entries to a balanced tree, on removing entries less than &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt;  and at most &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; will reconvert  balanced tree to linked list of entries. &lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;stackpost&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;HashMap&lt;/code&gt; , 해시 충돌의 경우 &lt;code&gt;Hashtable&lt;/code&gt; 은 링크 된 목록에 맵 항목을 저장합니다.&lt;/em&gt; &lt;em&gt;해시 버킷이 특정 임계 값을 초과하여 증가하는 경우 &lt;strong&gt; &lt;code&gt;HashMap&lt;/code&gt; 용 Java8&lt;/strong&gt; 에서 해당 버킷은 &lt;a href=&quot;http://openjdk.java.net/jeps/180&quot;&gt; &lt;code&gt;linked list of entries to a balanced tree&lt;/code&gt; &lt;/a&gt; 됩니다.&lt;/em&gt; &lt;em&gt;최악의 성능을 O (n)에서 O (log n)로 향상시킵니다.&lt;/em&gt; &lt;em&gt;목록을 이진 트리로 변환하는 동안 해시 코드는 분기 변수로 사용됩니다.&lt;/em&gt; &lt;em&gt;동일한 버킷에 두 개의 다른 해시 코드가있는 경우 하나는 더 큰 것으로 간주되어 트리의 오른쪽으로 가고 다른 하나는 왼쪽으로갑니다.&lt;/em&gt; &lt;em&gt;그러나 두 해시 코드가 같으면 &lt;code&gt;HashMap&lt;/code&gt; 은 키를 비교할 수 있다고 가정하고 키를 비교하여 방향을 결정하여 일부 순서를 유지할 수 있습니다.&lt;/em&gt; &lt;em&gt; &lt;code&gt;HashMap&lt;/code&gt; 의 키를 &lt;a href=&quot;https://stackoverflow.com/a/31244596/5081877&quot;&gt;비슷한&lt;/a&gt; 것으로 만드는 것이 좋습니다.&lt;/em&gt; &lt;em&gt;버킷 크기가 &lt;code&gt;TREEIFY_THRESHOLD = 8&lt;/code&gt; 도달하면 항목을 추가하면 연결된 항목 목록을 균형 트리로 변환하고, &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; 보다 작고 최대 &lt;code&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt; 항목을 제거하면 균형 트리가 연결된 항목 목록으로 다시 변환됩니다.&lt;/em&gt; &lt;em&gt;&lt;sup&gt;&lt;a href=&quot;http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/HashMap.java#l244&quot;&gt;Java 8 SRC&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/a/43911638/5081877&quot;&gt;스택 포스트&lt;/a&gt;&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0126875eb118b7807444c7f8bd52e3d668a20cba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; &amp;mdash; sometimes called a container &amp;mdash; is simply an object that groups multiple elements into a single unit. &lt;code&gt;Collection&lt;/code&gt;s are used to store, retrieve, manipulate, and communicate aggregate data. A collections framework &lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt; is a unified architecture for representing and manipulating collections.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;컨테이너라고도하는 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/intro/index.html&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 은 단순히 여러 요소를 단일 단위로 그룹화하는 객체입니다.&lt;/em&gt; &lt;em&gt; &lt;code&gt;Collection&lt;/code&gt; 은 집계 데이터를 저장, 검색, 조작 및 통신하는 데 사용됩니다.&lt;/em&gt; &lt;em&gt;컬렉션 프레임 워크 &lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_collections_framework&quot;&gt;W&lt;/a&gt;&lt;/sup&gt; 는 컬렉션을 나타내고 조작하기위한 통합 아키텍처입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5371f8fa97eb824eece2c3e1f791dbb0a968b11d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HashMap constructs an empty hash table with the default initial capacity &lt;strong&gt;(16)&lt;/strong&gt; and the default load factor (0.75). Where as Hashtable constructs empty hashtable with a default initial capacity &lt;strong&gt;(11)&lt;/strong&gt; and load factor/fill ratio (0.75).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HashMap은 기본 초기 용량 &lt;strong&gt;(16)&lt;/strong&gt; 과 기본로드 팩터 (0.75)로 빈 해시 테이블을 구성합니다.&lt;/em&gt; &lt;em&gt;Hashtable은 기본 초기 용량 &lt;strong&gt;(11)&lt;/strong&gt; 과로드 팩터 / 채우기 비율 (0.75)로 빈 해시 테이블을 구성합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8dd40f98b719540fa3ef0929171c1d3bc9907016" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Hashtable is a legacy class introduced in &lt;code&gt;JDK1.0&lt;/code&gt;, which is a subclass of Dictionary class. From &lt;code&gt;JDK1.2&lt;/code&gt; Hashtable is re-engineered to implement the &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;Map interface&lt;/a&gt; to make a member of collection framework. HashMap is a member of Java Collection Framework right from the beginning of its introduction in &lt;code&gt;JDK1.2&lt;/code&gt;. HashMap is the subclass of the AbstractMap class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Hashtable은 &lt;code&gt;JDK1.0&lt;/code&gt; 에 도입 된 레거시 클래스이며 Dictionary 클래스의 하위 클래스입니다.&lt;/em&gt; &lt;em&gt; &lt;code&gt;JDK1.2&lt;/code&gt; 부터 Hashtable은 컬렉션 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html&quot;&gt;인터페이스&lt;/a&gt; 의 멤버를 만들기 위해 Map 인터페이스 를 구현하도록 리엔지니어링되었습니다.&lt;/em&gt; &lt;em&gt;HashMap은 &lt;code&gt;JDK1.2&lt;/code&gt; 의 도입 초기부터 Java Collection Framework의 멤버입니다.&lt;/em&gt; &lt;em&gt;HashMap은 AbstractMap 클래스의 서브 클래스입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="500218975390156875accb6dbe2f354e3173f3e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a &quot;&lt;code&gt;hash&lt;/code&gt;&lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt;&lt;code&gt;collision&lt;/code&gt;&lt;/a&gt;&quot;, a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;용량은 해시 테이블의 버킷 수이며 초기 용량은 단순히 해시 테이블이 생성 될 때의 용량입니다.&lt;/em&gt; &lt;em&gt;해시 테이블은 열려 있습니다. &quot; &lt;code&gt;hash&lt;/code&gt; &lt;a href=&quot;http://www.algolist.net/Data_structures/Hash_table/Chaining&quot;&gt; &lt;code&gt;collision&lt;/code&gt; &lt;/a&gt; &quot;의 경우 단일 버킷은 여러 항목을 저장하며이 항목은 순차적으로 검색해야합니다.&lt;/em&gt; &lt;em&gt;로드 팩터는 용량이 자동으로 증가하기 전에 해시 테이블이 얼마나 가득 찼는 지 측정합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b2906198844595f36fc6fa0dd97c9082d03f289b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Collection-view iteration, Fail-Fast and Fail-Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;콜렉션-뷰 반복, 페일-페스트 및 페일-세이프&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7914abd8212625a168b15acf6950ab3c15a2effa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Initial capacity and Load factor&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;초기 용량 및 부하 계수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6993db023d391ae7cbb4cf066cfcb7e989bc8404" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Null Keys And Null Values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;널 키와 널 값&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c20ec51a8964581feeee1ad7fb05fa002cf9687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7511967863d20bb8b4fe1260a05e4cb1bab41336" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Structural modification in case of hash collision&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;해시 충돌의 경우 구조 수정&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fe1bf3045a21d6736352a953873017484a6bc5ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Superclass, Legacy and Collection Framework member&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;수퍼 클래스, 레거시 및 컬렉션 프레임 워크 멤버&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="185ecb719c3e2e537438ec956fe6478e08b5fe09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;laquo;&lt;/strong&gt;&lt;strong&gt;Synchronized, Thread Safe&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;&lt;/strong&gt; &lt;strong&gt;동기화 된 스레드 안전&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ce5fccec3d4c3a9b001c5a415252b106c57db67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Hashtable:&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32a8a99aed109def0e75d162d6deb196e91238da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Like &lt;code&gt;Hashtable&lt;/code&gt; but unlike &lt;code&gt;HashMap&lt;/code&gt;, this class does not allow null to be used as a key or value.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;Hashtable&lt;/code&gt; 과 유사하지만 &lt;code&gt;HashMap&lt;/code&gt; 과 달리이 클래스는 null을 키 또는 값으로 사용할 수 없습니다.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8218937231a3c47bf14d75f244f490d51f3b93e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt; :</source>
          <target state="translated">&lt;strong&gt;예&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="cebcd49ebbc8d28ef3e1865793fbff6f09d04c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap and HashTable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;해시 맵 및 해시 테이블&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c22768d0fd9bc69987104948fcbbae61922d34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46e9a015b499fca6a53da3a15919c4913909cfae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad1ee7e22808c3a788f0a1f004a79a0d59da5d9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HashMap&lt;/strong&gt; is like &lt;strong&gt;Hashtable&lt;/strong&gt; but it also accepts key value pair. It allows null for both the keys and the values. Its performance better is better than &lt;code&gt;HashTable&lt;/code&gt;, because it is &lt;code&gt;unsynchronized&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;HashMap&lt;/strong&gt; 은 &lt;strong&gt;Hashtable&lt;/strong&gt; 과 비슷하지만 키 값 쌍도 허용합니다. 키와 값 모두에 대해 널을 허용합니다. &lt;code&gt;unsynchronized&lt;/code&gt; 않기 때문에 &lt;code&gt;HashTable&lt;/code&gt; 보다 성능이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9a8219969622a494e81fa636ffe2146fe95d705f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hashtable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3df875dc7fbdad1a94f31dde139d3c47b9695e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hashtable&lt;/strong&gt; is a data structure that retains values of key-value pair. It doesn&amp;rsquo;t allow null for both the keys and the values. You will get a &lt;code&gt;NullPointerException&lt;/code&gt; if you add null value. It is synchronized. So it comes with its cost. Only one thread can access &lt;strong&gt;HashTable&lt;/strong&gt; at a particular time.</source>
          <target state="translated">&lt;strong&gt;해시 테이블&lt;/strong&gt; 은 키-값 쌍의 값을 유지하는 데이터 구조입니다. 키와 값 모두에 대해 널을 허용하지 않습니다. null 값을 추가하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다. 동기화되었습니다. 따라서 비용이 발생합니다. 특정 시간에 하나의 스레드 만 &lt;strong&gt;HashTable&lt;/strong&gt; 에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87f9eccd26b220f3fffdcc16c43e989775ffb9b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Therefore, always stay away from them in new code since there always better alternative in the JCF&lt;/strong&gt; as others had pointed out.</source>
          <target state="translated">&lt;strong&gt;따라서&lt;/strong&gt; 다른 사람들이 지적했듯이 &lt;strong&gt;JCF에는 항상 더 나은 대안이 있기 때문에 항상 새 코드에서 멀리하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="25d50188019a6203506db4eaf255be67c2575b4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; No, they won't land in 1.8... :(</source>
          <target state="translated">&lt;strong&gt;업데이트 :&lt;/strong&gt; 아니요, 1.8에 착륙하지 않습니다 ... :(</target>
        </trans-unit>
        <trans-unit id="dfb42b9b02e91bb8174c286bcbc7e89091ed670e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;b&gt;NOTE:&lt;/b&gt; The functionality of Enumeration interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;b&gt;참고 :&lt;/b&gt; 열거 인터페이스의 기능은 Iterator 인터페이스에 의해 복제됩니다.&lt;/sub&gt; &lt;sub&gt;또한 Iterator는 선택적 제거 작업을 추가하고 메소드 이름이 더 짧습니다.&lt;/sub&gt; &lt;sub&gt;새로운 구현에서는 열거 자보다 반복자를 사용하는 것이 좋습니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="ac2433b57b2a782b71863cba68f09953ec4c0263" translate="yes" xml:space="preserve">
          <source>@See</source>
          <target state="translated">@See</target>
        </trans-unit>
        <trans-unit id="6b37ea03133b5dc642ccd5644d5b2ef41cc8ea38" translate="yes" xml:space="preserve">
          <source>A red&amp;ndash;black tree is a kind of self-balancing binary search tree</source>
          <target state="translated">빨간색 검정색 트리는 일종의 자체 균형 이진 검색 트리입니다.</target>
        </trans-unit>
        <trans-unit id="084f214b26afe2233736dea659b6712cd361bbee" translate="yes" xml:space="preserve">
          <source>A very common idiom is to &quot;check then put&quot; &amp;mdash; i.e. look for an entry in the &lt;code&gt;Map&lt;/code&gt;, and add it if it does not already exist. This is not in any way an atomic operation whether you use &lt;code&gt;Hashtable&lt;/code&gt; or &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">매우 일반적인 관용구는 &quot;확인 후 입력&quot;입니다. 즉, &lt;code&gt;Map&lt;/code&gt; 에서 항목을 찾아서 존재하지 않는 경우 추가합니다. &lt;code&gt;Hashtable&lt;/code&gt; 을 사용하든 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하든 이것은 원자 연산이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1ef3449d808edb36ce53bb89ce36fe2cd8e8058d" translate="yes" xml:space="preserve">
          <source>According to Java API Docs, Iterator is always preferred over the Enumeration.</source>
          <target state="translated">Java API Docs에 따르면 반복자보다 항상 반복자가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="7b526b4ffbef0a933328ce463df2d1cd68dd7c44" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Hashtable&lt;/code&gt; extends the &lt;code&gt;Dictionary&lt;/code&gt; class, which as the &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocs&lt;/a&gt; state, is obsolete and has been replaced by the &lt;code&gt;Map&lt;/code&gt; interface.</source>
          <target state="translated">또한 &lt;code&gt;Hashtable&lt;/code&gt; 은 &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/Dictionary.html&quot;&gt;Javadocs&lt;/a&gt; 상태로서 더 이상 사용되지 않고 &lt;code&gt;Map&lt;/code&gt; 인터페이스로 대체 된 &lt;code&gt;Dictionary&lt;/code&gt; 클래스를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="0f187c58c90f9a43256314abab97119abc44122e" translate="yes" xml:space="preserve">
          <source>An equivalently synchronised &lt;code&gt;HashMap&lt;/code&gt; can be obtained by:</source>
          <target state="translated">동등하게 동기화 된 &lt;code&gt;HashMap&lt;/code&gt; 은 다음을 통해 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9103e37fff0521b7c39be1ecc0df1aeeea1dd2b" translate="yes" xml:space="preserve">
          <source>Another difference is that iterator in the &lt;code&gt;HashMap&lt;/code&gt; is fail-safe
while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; isn't. If you change the map
while iterating, you'll know.</source>
          <target state="translated">또 다른 차이점은 &lt;code&gt;HashMap&lt;/code&gt; 의 이터레이터는 페일 세이프 인 반면 &lt;code&gt;Hashtable&lt;/code&gt; 의 열거자는 그렇지 않습니다. 반복하는 동안지도를 변경하면 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acee8a439f9e4944ad00c1a48c53ef2a93e9d1fe" translate="yes" xml:space="preserve">
          <source>Another key difference between hashtable and hashmap is that Iterator in the HashMap is  fail-fast  while the enumerator for the Hashtable is not and throw ConcurrentModificationException if any other Thread modifies the map structurally  by adding or removing any element except Iterator's own remove()  method. But this is not a guaranteed behavior and will be done by JVM on best effort.&quot;</source>
          <target state="translated">해시 테이블과 해시 맵의 또 다른 주요 차이점은 HashMap의 반복자는 실패하지 않고 해시 테이블의 열거자는 그렇지 않고 반복자가 자체 remove () 메소드를 제외한 요소를 추가하거나 제거하여 다른 스레드가 맵을 구조적으로 수정하는 경우 ConcurrentModificationException을 발생시키는 것입니다. 그러나 이것은 보장 된 동작이 아니며 최선의 노력으로 JVM에 의해 수행 될 것입니다. &quot;</target>
        </trans-unit>
        <trans-unit id="9a3708be3084838c9add3ab49ecf14e2a1b70039" translate="yes" xml:space="preserve">
          <source>Apart from the differences already mentioned, it should be noted that since Java 8, &lt;code&gt;HashMap&lt;/code&gt; dynamically replaces the Nodes (linked list) used in each bucket with TreeNodes (red-black tree), so that even if high hash collisions exist, the worst case &lt;em&gt;when searching&lt;/em&gt; is</source>
          <target state="translated">이미 언급 한 차이점 외에, Java 8부터 &lt;code&gt;HashMap&lt;/code&gt; 은 각 버킷에 사용 된 노드 (링크 된 목록)를 TreeNodes (빨간색 검은 색 트리)로 동적으로 대체하므로 높은 해시 충돌이 존재하더라도 최악의 경우입니다. &lt;em&gt;검색 할 때&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="835ac593a034529b8d59e5594146aeee9100a895" translate="yes" xml:space="preserve">
          <source>Are Project Coin's collection enhancements going to be in JDK8?</source>
          <target state="translated">Project Coin의 수집 기능 향상이 JDK8에 있습니까?</target>
        </trans-unit>
        <trans-unit id="91975686e2264b305fe313101bec221ece54fee0" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Hashtable&lt;/code&gt; is internally synchronized, this makes &lt;code&gt;Hashtable&lt;/code&gt; slightly slower than the &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 이 내부적으로 동기화되므로 &lt;code&gt;Hashtable&lt;/code&gt; 이 &lt;code&gt;HashMap&lt;/code&gt; 보다 약간 느려집니다.</target>
        </trans-unit>
        <trans-unit id="86480f222192a446b1ab808c5920c537dfc97134" translate="yes" xml:space="preserve">
          <source>Based on the info &lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;here&lt;/a&gt;, I'd recommend going with HashMap.  I think the biggest advantage is that Java will prevent you from modifying it while you are iterating over it, unless you do it through the iterator.</source>
          <target state="translated">&lt;a href=&quot;http://www.jguru.com/faq/view.jsp?EID=430247&quot;&gt;here&lt;/a&gt; 정보를 기반으로 HashMap을 사용하는 것이 좋습니다. 가장 큰 장점은 반복기를 통해 수행하지 않는 한 Java가 반복하는 동안 Java가 수정하지 못하게한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d0a56f41ce29c24403b973ae8e801eead605fafd" translate="yes" xml:space="preserve">
          <source>Beside all the other important aspects already mentioned here, Collections API (e.g. Map interface) is being modified all the time to conform to the &quot;latest and greatest&quot; additions to Java spec.</source>
          <target state="translated">여기에 이미 언급 된 다른 모든 중요한 측면 외에도 Collections API (예 : Map 인터페이스)는 Java 사양에 대한 &quot;최신 및 가장 큰&quot;추가 사항을 준수하도록 항상 수정되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="883db36727c6fc674b9af62ca03268fec3a2fc5d" translate="yes" xml:space="preserve">
          <source>Blog by Manish Chhabra</source>
          <target state="translated">Manish Chhabra의 블로그</target>
        </trans-unit>
        <trans-unit id="161ee3e5332fc7ada8de95c3e13e87513aefb405" translate="yes" xml:space="preserve">
          <source>But to correctly implement this logic you need &lt;strong&gt;additional synchronisation&lt;/strong&gt; of the form:</source>
          <target state="translated">그러나이 논리를 올바르게 구현하려면 다음 양식을 &lt;strong&gt;추가로 동기화&lt;/strong&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="701dc0240892c2e16f792b706d048825cd15ef02" translate="yes" xml:space="preserve">
          <source>Differences between HashMap and Hashtable</source>
          <target state="translated">HashMap과 Hashtable의 차이점</target>
        </trans-unit>
        <trans-unit id="3df089853d91c18fa4e328324d91b136000d4c1a" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;HashMapEntry&lt;/code&gt;s value is &lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;volatile&lt;/a&gt; thereby ensuring fine grain consistency for contended modifications and subsequent reads; each read reflects the most recently completed update</source>
          <target state="translated">각 &lt;code&gt;HashMapEntry&lt;/code&gt; 의 값은 &lt;a href=&quot;https://stackoverflow.com/a/47695757/5081877&quot;&gt;변동성이&lt;/a&gt; 있으므로 수정 된 수정 및 후속 읽기에 대한 세밀한 일관성을 보장합니다. 각 읽기는 가장 최근에 완료된 업데이트를 반영합니다</target>
        </trans-unit>
        <trans-unit id="74b2e0a75cd7cb287224f128b35087ba9f24b35c" translate="yes" xml:space="preserve">
          <source>Enumerator in &lt;code&gt;Hashtable&lt;/code&gt; is not fail-fast.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 의 열거자는 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ada4c28c6e7bcc1c37b1f37cd28e11b4c21a0d85" translate="yes" xml:space="preserve">
          <source>Even iterating over a &lt;code&gt;Hashtable&lt;/code&gt;'s entries (or a &lt;code&gt;HashMap&lt;/code&gt; obtained by &lt;code&gt;Collections.synchronizedMap&lt;/code&gt;) is not thread safe unless you also guard the &lt;code&gt;Map&lt;/code&gt; from being modified through additional synchronization.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 의 항목 (또는 &lt;code&gt;Collections.synchronizedMap&lt;/code&gt; 에서 얻은 &lt;code&gt;HashMap&lt;/code&gt; )을 반복해도 추가 동기화를 통해 &lt;code&gt;Map&lt;/code&gt; 이 수정되는 것을 방지하지 않으면 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aef57bb24b9645fae322828e390476f8cb44301e" translate="yes" xml:space="preserve">
          <source>FYI, currently,</source>
          <target state="translated">참고로 현재</target>
        </trans-unit>
        <trans-unit id="65e3d605f886f039cefd6fcaa6b0600199f9e6cb" translate="yes" xml:space="preserve">
          <source>Fail-safe is relevant within the context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object &quot;structurally&quot;, a concurrent modification exception will be thrown. It is possible for other threads though to invoke &lt;code&gt;set&lt;/code&gt; method since it doesn't modify the collection &quot;structurally&quot;. However, if prior to calling &lt;code&gt;set&lt;/code&gt;, the collection has been modified structurally, &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">페일 세이프는 이터레이터와 관련이 있습니다. 컬렉션 객체에 반복자가 만들어졌고 다른 스레드가 컬렉션 객체를 &quot;구조적으로&quot;수정하려고하면 동시 수정 예외가 발생합니다. 컬렉션을 &quot;구조적으로&quot;수정하지 않기 때문에 다른 스레드가 &lt;code&gt;set&lt;/code&gt; 메소드를 호출 할 수 있습니다. 그러나 &lt;code&gt;set&lt;/code&gt; 호출하기 전에 컬렉션이 구조적으로 수정 된 경우 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e195bfdae28c7dbd825f2b0cfa215fcc4514276c" translate="yes" xml:space="preserve">
          <source>First and most significant different between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is that, &lt;code&gt;HashMap&lt;/code&gt; is not thread-safe  while &lt;code&gt;Hashtable&lt;/code&gt; is a thread-safe collection.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 과 &lt;code&gt;HashMap&lt;/code&gt; 의 가장 중요한 차이점은 &lt;code&gt;HashMap&lt;/code&gt; 은 스레드로부터 안전하지 않지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 스레드로부터 안전하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c2940247e674a032904e85951f08703d55f1e27" translate="yes" xml:space="preserve">
          <source>For example, compare Java 5 Map iterating:</source>
          <target state="translated">예를 들어, Java 5 Map 반복을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="97aba7dc3fa8453988dd3eaad09f2bfffab2858d" translate="yes" xml:space="preserve">
          <source>For non-threaded apps, use &lt;code&gt;HashMap&lt;/code&gt; since they are otherwise the same in terms of functionality.</source>
          <target state="translated">스레드되지 않은 앱의 경우 기능면에서 동일하므로 &lt;code&gt;HashMap&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a864fbe79b123e5b3781c7606dbae5a3c23396a8" translate="yes" xml:space="preserve">
          <source>For threaded apps, you can often get away with ConcurrentHashMap- depends on your performance requirements.</source>
          <target state="translated">스레드 응용 프로그램의 경우 성능 요구 사항에 따라 ConcurrentHashMap을 사용하여 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3df9160472a36ae89d781b3c6ab26022d5640f0e" translate="yes" xml:space="preserve">
          <source>Further reading &lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;What is difference between HashMap and Hashtable in Java?&lt;/a&gt;</source>
          <target state="translated">더 읽기 &lt;a href=&quot;http://javarevisited.blogspot.in/2010/10/difference-between-hashmap-and.html&quot;&gt;Java에서 HashMap과 Hashtable의 차이점은 무엇입니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf8d0414df57d55121993c998babc6dc951ab933" translate="yes" xml:space="preserve">
          <source>HashMap and Hashtable both implement java.util.Map interface but there
  are some differences that Java developers must understand to write
  more efficient code. As of the Java 2 platform v1.2, Hashtable class
  was retrofitted to implement the Map interface, making it a member of
  the Java Collections Framework.</source>
          <target state="translated">HashMap과 Hashtable은 모두 java.util.Map 인터페이스를 구현하지만보다 효율적인 코드를 작성하려면 Java 개발자가 이해해야 할 몇 가지 차이점이 있습니다. Java 2 플랫폼 v1.2부터 Hashtable 클래스는 Map 인터페이스를 구현하도록 개량되어 Java Collections Framework의 멤버가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ddadac488e5ff532483d1a91068404f62fc5a825" translate="yes" xml:space="preserve">
          <source>HashMap does not guarantee that the order of the map will remain constant over time.</source>
          <target state="translated">HashMap은 맵 순서가 시간이 지남에 따라 일정하게 유지된다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eadebb7419f0310830aa9293de3df75d77865879" translate="yes" xml:space="preserve">
          <source>HashMap doesn't guarantee the order in which elements are returned. For HashTable I guess it's the same but I'm not entirely sure, I don't find ressource that clearly state that.</source>
          <target state="translated">HashMap은 요소가 반환되는 순서를 보장하지 않습니다. HashTable의 경우에는 같지만 완전히 확실하지는 않지만 명확하게 설명하는 리소스를 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="6aedc41f6a22926e230616147632602f9650712c" translate="yes" xml:space="preserve">
          <source>HashMap: It is a class available inside java.util package and it is used to store the element in key and value format.</source>
          <target state="translated">HashMap : java.util 패키지에서 사용 가능한 클래스이며 키 및 값 형식으로 요소를 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a46f2ebc98dcc8b75520890a511e99f853ea5a9c" translate="yes" xml:space="preserve">
          <source>HashMaps gives you freedom of synchronization and debugging is lot more easier</source>
          <target state="translated">HashMaps는 동기화의 자유를 제공하고 디버깅이 훨씬 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="78c9bd228fbd8c5d46c4bce0592c89eff91a7d49" translate="yes" xml:space="preserve">
          <source>HashTable and HashMap are member of the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt; (since Java 2 platform v1.2, HashTable was retrofitted to implement the Map interface).</source>
          <target state="translated">HashTable 및 HashMap은 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework의&lt;/a&gt; 멤버입니다 (Java 2 플랫폼 v1.2 이후 HashTable은 맵 인터페이스를 구현하기 위해 개량되었습니다).</target>
        </trans-unit>
        <trans-unit id="df229e5af731d7fbb0555f5de0920510f2c0df41" translate="yes" xml:space="preserve">
          <source>HashTable can only contain non-null object as a key or as a value. HashMap can contain one null key and null values.</source>
          <target state="translated">HashTable은 널이 아닌 오브젝트 만 키 또는 값으로 포함 할 수 있습니다. HashMap은 하나의 널 키와 널 값을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a95549c3436ee60ecd7871e7ce42d8ae786e25" translate="yes" xml:space="preserve">
          <source>HashTable is considered legacy code, the documentation advise to use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; in place of Hashtable if a thread-safe highly-concurrent implementation is desired.</source>
          <target state="translated">HashTable은 레거시 코드로 간주되며, 스레드 안전성이 높은 동시 구현이 필요한 경우 Hashtable 대신 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="660b9dcb49d86a9b0d8ca2dbc507dfa2ac01bd00" translate="yes" xml:space="preserve">
          <source>HashTable won't allow null keys or null values. Where as HashMap allows one null key, and multiple null values.</source>
          <target state="translated">HashTable은 null 키 또는 null 값을 허용하지 않습니다. HashMap은 하나의 null 키와 여러 null 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="22474fbd1e3d38434c362a687e63aec30ae3ab68" translate="yes" xml:space="preserve">
          <source>HashTables are by default synchronized, so it can be used with multiple threads easily. Where as HashMaps are not synchronized by default, so can be used with only single thread.  But you can still convert HashMap to synchronized by using Collections util class's synchronizedMap(Map m) function.</source>
          <target state="translated">해시 테이블은 기본적으로 동기화되므로 여러 스레드에서 쉽게 사용할 수 있습니다. HashMap은 기본적으로 동기화되지 않으므로 단일 스레드로만 사용할 수 있습니다. 그러나 Collections util 클래스의 synchronizedMap (Map m) 함수를 사용하여 여전히 HashMap을 동기화 된 것으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3739cd326e022a0ec2d5f895c0053c82658a5ec3" translate="yes" xml:space="preserve">
          <source>Hashtable: It is a legacy class which is being recognized inside collection framework.</source>
          <target state="translated">Hashtable : 컬렉션 프레임 워크 내에서 인식되는 레거시 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3c394da10080138b6474986dd183541c34fb7fc8" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;Java collection cheat sheet&lt;/a&gt; that you will find useful. Notice the gray block contains the legacy class HashTable,Vector and Stack.</source>
          <target state="translated">다음은 유용한 &lt;a href=&quot;http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html&quot;&gt;Java 콜렉션 치트 시트&lt;/a&gt; 입니다. 회색 블록에는 레거시 클래스 HashTable, Vector 및 Stack이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e897a22091a5c72367aa2c68491be56a91daa38" translate="yes" xml:space="preserve">
          <source>Implementations of the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt;&lt;code&gt;ConcurrentMap&lt;/code&gt;&lt;/a&gt; interface (for example &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;) solve some of this by including &lt;strong&gt;thread safe check-then-act semantics&lt;/strong&gt; such as:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentMap.html&quot;&gt; &lt;code&gt;ConcurrentMap&lt;/code&gt; &lt;/a&gt; 인터페이스 (예 : &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; )의 구현은 다음 과 같은 &lt;strong&gt;스레드 안전 점검-동작 시맨틱&lt;/strong&gt; 을 포함하여이 중 일부를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="ef247363dca7947ce18807b023f807375513e571" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5 introduced ConcurrentMap Interface&lt;/a&gt;: &lt;code&gt;ConcurrentHashMap&lt;/code&gt; - a highly concurrent, high-performance &lt;code&gt;ConcurrentMap&lt;/code&gt; implementation backed by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for &lt;code&gt;Hashtable&lt;/code&gt;: in addition to implementing &lt;code&gt;ConcurrentMap&lt;/code&gt;, it supports all of the &quot;legacy&quot; methods peculiar to &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes5.html&quot;&gt;Java 5에는 ConcurrentMap Interface&lt;/a&gt; : &lt;code&gt;ConcurrentHashMap&lt;/code&gt; - 해시 테이블을 기반으로 한 고성능 &lt;code&gt;ConcurrentMap&lt;/code&gt; 구현이 도입되었습니다. 이 구현은 검색을 수행 할 때 절대 차단하지 않으며 클라이언트가 업데이트의 동시성 수준을 선택할 수 있도록합니다. &lt;code&gt;Hashtable&lt;/code&gt; 의 드롭 인 대체를 목적으로합니다. &lt;code&gt;ConcurrentMap&lt;/code&gt; 을 구현할뿐만 아니라 &lt;code&gt;Hashtable&lt;/code&gt; 특유의 모든 &quot;레거시&quot;메소드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="147cebda6bdb73c5d51fbf40ab2e08956d0ec790" translate="yes" xml:space="preserve">
          <source>In Hashtable there is a function contains(), which is very confusing to use. Because the meaning of contains is slightly deviating. Whether it means contains key or contains  value? tough to understand. Same thing in Maps we have ContainsKey() and ContainsValue() functions, which are very easy to understand.</source>
          <target state="translated">Hashtable에는 contains () 함수가 있습니다. 포함의 의미가 약간 어긋나 기 때문입니다. 키 또는 값을 포함하는지 여부 이해하기 어렵다. Maps에서 우리는 ContainsKey () 및 ContainsValue () 함수를 가지고 있으며 이해하기 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="6b511ed6e04d77fc78318a00b4ae9f36a4f5fa39" translate="yes" xml:space="preserve">
          <source>In Java 1.8 we are also promised to be able to construct and access HashMaps like in good old scripting languages:</source>
          <target state="translated">Java 1.8에서 우리는 또한 좋은 오래된 스크립팅 언어에서와 같이 HashMaps를 구성하고 액세스 할 수 있다고 약속했습니다.</target>
        </trans-unit>
        <trans-unit id="cd8c0f0e029d8fe772c617136311a3f6576de97f" translate="yes" xml:space="preserve">
          <source>In Summary there are significant differences between Hashtable and
  HashMap in Java e.g. thread-safety and speed and based upon that only
  use Hashtable if you absolutely need thread-safety, if you are running
  Java 5 consider using ConcurrentHashMap in Java.</source>
          <target state="translated">요약하면 Java의 Hashtable과 HashMap 사이에는 스레드 안전성과 속도가 크게 다르며 스레드 안전성이 절대적으로 필요한 경우 Hashtable 만 사용한다는 점에 따라 Java 5를 실행하는 경우 Java에서 ConcurrentHashMap을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="554d6863c43fc3f761b7ff10daaee4fc3bc6661c" translate="yes" xml:space="preserve">
          <source>In addition to what izb said, &lt;code&gt;HashMap&lt;/code&gt; allows null values, whereas the &lt;code&gt;Hashtable&lt;/code&gt; does not.</source>
          <target state="translated">izb가 말한 것 외에도 &lt;code&gt;HashMap&lt;/code&gt; 은 null 값을 허용하지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ecd0ae571aba4721ee2996a4fe36a3db474af69" translate="yes" xml:space="preserve">
          <source>In hashmap you can remove element while iterating, safely. where as it is not possible in hashtables.</source>
          <target state="translated">해시 맵에서 반복하면서 요소를 안전하게 제거 할 수 있습니다. 해시 테이블에서는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="7fbd74b62c43cd195aee64e1d4b3f8da3aba383f" translate="yes" xml:space="preserve">
          <source>Iterator in &lt;code&gt;HashMap&lt;/code&gt; is fail-fast.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 의 반복기는 실패 속도가 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="3481f252a01b24865e53a0d403077fe7c2bfb108" translate="yes" xml:space="preserve">
          <source>Iterator in the &lt;code&gt;HashMap&lt;/code&gt; is  fail-safe while the enumerator for the &lt;code&gt;Hashtable&lt;/code&gt; is not and throw &lt;code&gt;ConcurrentModificationException&lt;/code&gt; if any other Thread modifies the map structurally  by adding or removing any element except &lt;code&gt;Iterator&lt;/code&gt;'s own &lt;code&gt;remove()&lt;/code&gt;  method. But this is not a guaranteed behavior and will be done by JVM on best effort.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 의 열거자는 Hashtable 의 페일 세이프 인 반면 Hashtable 의 열거자는 그렇지 않으며 &lt;code&gt;Iterator&lt;/code&gt; 의 자체 &lt;code&gt;remove()&lt;/code&gt; 메소드를 제외한 다른 요소를 추가하거나 제거하여 다른 스레드가 맵을 구조적으로 수정하면 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생시킵니다. 그러나 이것은 보장 된 동작이 아니며 최선의 노력으로 JVM이 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1a2f20d9e57bdf5adc94c3751cd34e64ab8a2d4c" translate="yes" xml:space="preserve">
          <source>Iterators and Enumerations are Fail Safe - reflecting the state at some point since the creation of iterator/enumeration; this allows for simultaneous reads and modifications at the cost of reduced consistency. They do not throw ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time.</source>
          <target state="translated">이터레이터와 열거는 페일 세이프입니다-이터레이터 / 열거를 생성 한 이후 어느 시점에서 상태를 반영합니다. 따라서 일관성이 떨어지지 만 동시에 읽고 수정할 수 있습니다. ConcurrentModificationException을 발생시키지 않습니다. 그러나 반복자는 한 번에 하나의 스레드 만 사용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="254d25f74e4ed95d90db28daea166a6ffd3dd1ff" translate="yes" xml:space="preserve">
          <source>Java Collection Matrix</source>
          <target state="translated">자바 컬렉션 매트릭스</target>
        </trans-unit>
        <trans-unit id="93f74b798b3d08e2f768288051abb39a0bc5939a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;HashTable&lt;/code&gt; was legacy class before Java Collections Framework (JCF) was introduced and was later retrofitted to implement the &lt;code&gt;Map&lt;/code&gt; interface. So was &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Stack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashTable&lt;/code&gt; 은 JCF (Java Collections Framework)가 도입되기 이전의 레거시 클래스였으며 나중에 &lt;code&gt;Map&lt;/code&gt; 인터페이스를 구현하도록 개조되었습니다. &lt;code&gt;Vector&lt;/code&gt; 와 &lt;code&gt;Stack&lt;/code&gt; 도 마찬가지였습니다.</target>
        </trans-unit>
        <trans-unit id="0449de243fc290a860ccfdc65f8437c895fd81b6" translate="yes" xml:space="preserve">
          <source>Map provides Collection views instead of direct support for iteration
 via Enumeration objects. Collection views greatly enhance the
 expressiveness of the interface, as discussed later in this section.
 Map allows you to iterate over keys, values, or key-value pairs;
 &lt;code&gt;Hashtable&lt;/code&gt; does not provide the third option. Map provides a safe way
 to remove entries in the midst of iteration; &lt;code&gt;Hashtable&lt;/code&gt; did not.
 Finally, Map fixes a minor deficiency in the &lt;code&gt;Hashtable&lt;/code&gt; interface.
 &lt;code&gt;Hashtable&lt;/code&gt; has a method called contains, which returns true if the
 &lt;code&gt;Hashtable&lt;/code&gt; contains a given value. Given its name, you'd expect this
 method to return true if the &lt;code&gt;Hashtable&lt;/code&gt; contained a given key, because
 the key is the primary access mechanism for a &lt;code&gt;Hashtable&lt;/code&gt;. The Map
 interface eliminates this source of confusion by renaming the method
 &lt;code&gt;containsValue&lt;/code&gt;. Also, this improves the interface's consistency &amp;mdash;
 &lt;code&gt;containsValue&lt;/code&gt; parallels &lt;code&gt;containsKey&lt;/code&gt;.</source>
          <target state="translated">Map은 Enumeration 객체를 통한 반복을 직접 지원하는 대신 Collection보기를 제공합니다. 컬렉션 뷰는이 섹션의 뒷부분에서 설명하는 것처럼 인터페이스의 표현성을 크게 향상시킵니다. 맵을 사용하면 키, 값 또는 키-값 쌍을 반복 할 수 있습니다. &lt;code&gt;Hashtable&lt;/code&gt; 은 세 번째 옵션을 제공하지 않습니다. 맵은 반복 중에 항목을 안전하게 제거 할 수있는 방법을 제공합니다. &lt;code&gt;Hashtable&lt;/code&gt; 은 그렇지 않았다. 마지막으로, Map은 &lt;code&gt;Hashtable&lt;/code&gt; 인터페이스의 사소한 결함을 수정합니다. &lt;code&gt;Hashtable&lt;/code&gt; 에는 contains라는 메소드가 있으며, &lt;code&gt;Hashtable&lt;/code&gt; 에 지정된 값이 있으면 true를 리턴합니다. 키가 &lt;code&gt;Hashtable&lt;/code&gt; 의 기본 액세스 메커니즘이기 때문에 이름이 주어지면 &lt;code&gt;Hashtable&lt;/code&gt; 에 주어진 키가 포함되어 있으면이 메소드가 true를 반환 할 것으로 예상됩니다. Map 인터페이스는 &lt;code&gt;containsValue&lt;/code&gt; 메소드의 이름을 바꾸어 이러한 혼란의 원인을 제거합니다. 또한 인터페이스의 일관성을 향상시킵니다. &lt;code&gt;containsValue&lt;/code&gt; parallels &lt;code&gt;containsKey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09cfe8513ef9f55ce5353dca09be872682455571" translate="yes" xml:space="preserve">
          <source>Maps allows you to iterate and retrieve keys, values, and both key-value pairs as well, Where HashTable don't have all this capability.</source>
          <target state="translated">맵을 사용하면 키, 값 및 두 키-값 쌍을 반복하고 검색 할 수 있습니다. 여기서 HashTable에이 기능이 모두 없습니다.</target>
        </trans-unit>
        <trans-unit id="75a03fb098b6bc659568b1e29783c07476696b21" translate="yes" xml:space="preserve">
          <source>My small contribution :</source>
          <target state="translated">나의 작은 기여 :</target>
        </trans-unit>
        <trans-unit id="cdb51b953f61763ed033a4d76f1f625c07fe774b" translate="yes" xml:space="preserve">
          <source>My source: &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&lt;/a&gt;</source>
          <target state="translated">내 출처 : &lt;a href=&quot;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&quot;&gt;http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcd6c2b779cd4727bdfc8b82c43e554e848868f9" translate="yes" xml:space="preserve">
          <source>Note on Some Important Terms:</source>
          <target state="translated">몇 가지 중요한 용어에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="cc43492870882f3478ca9bc8edfbda8462e1df06" translate="yes" xml:space="preserve">
          <source>Note that HashMap can be synchronized by</source>
          <target state="translated">HashMap은 다음을 통해 동기화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4918d4974fe3cd4755ebe0e20277ccd382fa12f2" translate="yes" xml:space="preserve">
          <source>Note, that a lot of the answers state that Hashtable is synchronised.  &lt;strong&gt;In practice this buys you very little.&lt;/strong&gt;  The synchronization is on the accessor / mutator methods will stop two threads adding or removing from the map concurrently, but in the real world you will often need additional synchronisation.</source>
          <target state="translated">많은 답변은 Hashtable이 동기화되었음을 나타냅니다. &lt;strong&gt;실제로 이것은 당신을 거의 사지 않습니다.&lt;/strong&gt; 접근자는 접근 자 / 뮤 테이터 메소드에서 동기화되어 맵에서 동시에 두 개의 스레드를 추가하거나 제거하지 않지만 실제 환경에서는 종종 추가 동기화가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f180d9cd9c023ba8ad54546958cad221aff4883c" translate="yes" xml:space="preserve">
          <source>O(log(n)) for &lt;code&gt;HashMap&lt;/code&gt;&lt;strong&gt;Vs&lt;/strong&gt; O(n) in &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 의 &lt;code&gt;HashMap&lt;/code&gt; &lt;strong&gt;Vs&lt;/strong&gt; O (n)에 대한 O (log (n))</target>
        </trans-unit>
        <trans-unit id="2600125966cb5ea97c2b8c54e0758c7e46ca74a1" translate="yes" xml:space="preserve">
          <source>Old and classic topic, just want to add this helpful blog that explains this:</source>
          <target state="translated">구식과 고전적인 주제, 다음을 설명하는 유용한 블로그를 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="249a3a46c2e86414c5539f13f4f1a0225a7d5a6f" translate="yes" xml:space="preserve">
          <source>One more notable difference between Hashtable and HashMap is that because of thread-safety and synchronization Hashtable is much slower
  than HashMap if used in Single threaded environment. So if you don&amp;rsquo;t
  need synchronization and HashMap is only used by one thread, it out
  perform Hashtable in Java.</source>
          <target state="translated">Hashtable과 HashMap의 또 다른 두드러진 차이점은 스레드 안전성과 동기화로 인해 단일 스레드 환경에서 사용되는 경우 Hashtable이 HashMap보다 훨씬 느리다는 것입니다. 따라서 동기화가 필요하지 않고 HashMap이 하나의 스레드에서만 사용되는 경우 Java에서 Hashtable을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="179c0a918e92d97127e98c73349a42a66aa21bd6" translate="yes" xml:space="preserve">
          <source>One of HashMap's subclasses is &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt;, so in the event that you'd want predictable iteration order (which is insertion order by default), you could easily swap out the &lt;code&gt;HashMap&lt;/code&gt; for a &lt;code&gt;LinkedHashMap&lt;/code&gt;.  This wouldn't be as easy if you were using &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">HashMap의 서브 클래스 중 하나는 &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/LinkedHashMap.html&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt; 이므로 예측 가능한 반복 순서 (기본적으로 삽입 순서)를 원할 경우 &lt;code&gt;LinkedHashMap&lt;/code&gt; 에 대해 &lt;code&gt;HashMap&lt;/code&gt; 을 쉽게 교체 할 수 있습니다. &lt;code&gt;Hashtable&lt;/code&gt; 을 사용하는 경우 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1525943ae6179c4dbbe03560c257ffac662fb828" translate="yes" xml:space="preserve">
          <source>One of the major differences between HashMap and Hashtable is that HashMap is non-synchronized whereas Hashtable is synchronized, which
  means Hashtable is thread-safe and can be shared between multiple
  threads but HashMap cannot be shared between multiple threads without
  proper synchronization. Java 5 introduced ConcurrentHashMap which is
  an alternative of Hashtable and provides better scalability than
  Hashtable in Java.Synchronized means only one thread can modify a hash
  table at one point of time. Basically, it means that any thread before
  performing an update on a hashtable will have to acquire a lock on the
  object while others will wait for lock to be released.</source>
          <target state="translated">HashMap과 Hashtable의 주요 차이점 중 하나는 HashMap이 동기화되지 않고 Hashtable이 동기화된다는 것입니다. 이는 Hashtable이 스레드로부터 안전하고 여러 스레드간에 공유 될 수 있지만 HashMap은 적절한 동기화없이 여러 스레드간에 공유 될 수 없음을 의미합니다. Java 5는 Hashtable의 대안이며 Java의 Hashtable보다 더 나은 확장 성을 제공하는 ConcurrentHashMap을 도입했습니다. 기본적으로 해시 테이블에서 업데이트를 수행하기 전에 모든 스레드가 객체에 대한 잠금을 획득해야하고 다른 스레드는 잠금이 해제 될 때까지 대기해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="95781641174af3b5c28daa7afb4c768668074452" translate="yes" xml:space="preserve">
          <source>Performance Improvement for &lt;code&gt;HashMap&lt;/code&gt; in Java 8</source>
          <target state="translated">Java 8에서 &lt;code&gt;HashMap&lt;/code&gt; 의 성능 향상</target>
        </trans-unit>
        <trans-unit id="fee29654ce34b086768db65a4b25fcd54f9ed463" translate="yes" xml:space="preserve">
          <source>Second important difference between &lt;code&gt;Hashtable&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; is performance, since &lt;code&gt;HashMap&lt;/code&gt; is not synchronized it perform better than &lt;code&gt;Hashtable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 과 &lt;code&gt;HashMap&lt;/code&gt; 의 두 번째 중요한 차이점은 성능입니다. &lt;code&gt;HashMap&lt;/code&gt; 은 동기화되지 않기 때문에 &lt;code&gt;Hashtable&lt;/code&gt; 보다 성능이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b55e592836fe1e61392790c1a6fce30f1803ceb3" translate="yes" xml:space="preserve">
          <source>Separate from the obvious differences discussed extensively in this question, I see the Hashtable as a &quot;manual drive&quot; car where you have better control over the hashing and the HashMap as the &quot;automatic drive&quot; counterpart that will generally perform well.</source>
          <target state="translated">이 질문에서 광범위하게 논의 된 명백한 차이점과는 별도로, 해시 테이블을 해시를보다 잘 제어 할 수있는 &quot;수동 드라이브&quot;자동차로, HashMap을 일반적으로 잘 수행하는 &quot;자동 드라이브&quot;대응 업체로 본다.</target>
        </trans-unit>
        <trans-unit id="b3a738203d70f6090dfcdd1764cf29833f51bb9d" translate="yes" xml:space="preserve">
          <source>Seriously though, you're better off staying away from &lt;code&gt;Hashtable&lt;/code&gt; altogether. For single-threaded apps, you don't need the extra overhead of synchronisation. For highly concurrent apps, the paranoid synchronisation might lead to starvation, deadlocks, or unnecessary garbage collection pauses. Like Tim Howland pointed out, you might use &lt;code&gt;ConcurrentHashMap&lt;/code&gt; instead.</source>
          <target state="translated">그러나 진심으로, &lt;code&gt;Hashtable&lt;/code&gt; 에서 멀리 떨어져있는 것이 좋습니다. 단일 스레드 앱의 경우 동기화 오버 헤드가 추가로 필요하지 않습니다. 동시성이 높은 앱의 경우 편집증 동기화로 인해 기아, 교착 상태 또는 불필요한 가비지 수집 일시 중지가 발생할 수 있습니다. Tim Howland가 지적한 것처럼 대신 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bdf790b2b1c9d6025dcbecb5bdb37ab2f60d7b4" translate="yes" xml:space="preserve">
          <source>Since synchronization is not an issue for you, I'd recommend &lt;code&gt;HashMap&lt;/code&gt;. If synchronization becomes an issue, you may also look at &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동기화는 문제가되지 않으므로 &lt;code&gt;HashMap&lt;/code&gt; 을 권장합니다. 동기화가 문제가되면 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt; &lt;code&gt;ConcurrentHashMap&lt;/code&gt; &lt;/a&gt; 도 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bcb97fa6763fbfe1f0ff48e9f6a9c4dd72d057b" translate="yes" xml:space="preserve">
          <source>Some important points about HashMap and HashTable.
   please read below details.</source>
          <target state="translated">HashMap 및 HashTable에 대한 몇 가지 중요한 사항. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2773856ae2356cf0a8e12035c63973404b5e1bef" translate="yes" xml:space="preserve">
          <source>Structurally modification means deleting or inserting element which could effectively change the structure of map.</source>
          <target state="translated">구조적으로 수정하는 것은 맵의 구조를 효과적으로 변경할 수있는 요소를 삭제하거나 삽입하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9ac0930f0753d909c7591e062bf09758da70879f" translate="yes" xml:space="preserve">
          <source>Synchronized means only one thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a &lt;code&gt;Hashtable&lt;/code&gt; will have to acquire a lock on the object while others will wait for lock to be released.</source>
          <target state="translated">동기화는 한 시점에서 하나의 스레드 만 해시 테이블을 수정할 수 있음을 의미합니다. 기본적으로 &lt;code&gt;Hashtable&lt;/code&gt; 에서 업데이트를 수행하기 전에 모든 스레드가 객체에 대한 잠금을 획득해야하고 다른 스레드는 잠금이 해제 될 때까지 대기해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="70e8f2a076a2a427c74c96d2d6f12fe9436a1288" translate="yes" xml:space="preserve">
          <source>Take a look at this chart. It provides comparisons between different data structures along with &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. The comparison is precise, clear and easy to understand.</source>
          <target state="translated">이 차트를 살펴보십시오. &lt;code&gt;HashMap&lt;/code&gt; 및 &lt;code&gt;Hashtable&lt;/code&gt; 과 함께 다른 데이터 구조를 비교합니다. 비교는 정확하고 명확하며 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="9b64a19c6daf91779b3938d649152906ab363b0e" translate="yes" xml:space="preserve">
          <source>The 5 main differences betwen HashMap and Hashtable</source>
          <target state="translated">HashMap과 Hashtable 간의 5 가지 주요 차이점</target>
        </trans-unit>
        <trans-unit id="072d0888e52948dbd09f33a229cca91be253355a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt; class is roughly equivalent to &lt;code&gt;Hashtable&lt;/code&gt;, except that it is non synchronized and permits nulls. (&lt;code&gt;HashMap&lt;/code&gt; allows null values as key and value whereas &lt;code&gt;Hashtable&lt;/code&gt; doesn't allow &lt;code&gt;null&lt;/code&gt;s).</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 클래스는 동기화되지 않고 널을 허용한다는 점을 제외하고 &lt;code&gt;Hashtable&lt;/code&gt; 과 거의 동일합니다. &lt;code&gt;HashMap&lt;/code&gt; 은 null 값을 키와 값으로 허용하지만 &lt;code&gt;Hashtable&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0aeaae4475437892ad0e711f1d770aca667a7fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HashMap&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.2&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; and Hashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt;&lt;code&gt;JDK1.0&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;&lt;/sup&gt;, both are used to represent a group of objects that are represented in &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair. Each &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; pair is called &lt;code&gt;Entry&lt;/code&gt; object. The collection of Entries is referred by the object of &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;Hashtable&lt;/code&gt;. Keys in a collection must be unique or distinctive. [as they are used to retrieve a mapped value a particular key. values in a collection can be duplicated.]</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.2&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; 및 Hashtable &lt;sup&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;em&gt; &lt;code&gt;JDK1.0&lt;/code&gt; &lt;/em&gt;&lt;/a&gt;&lt;/sup&gt; 은 모두 &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; 쌍으로 표시되는 오브젝트 그룹을 나타내는 데 사용됩니다. 각 &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; 쌍을 &lt;code&gt;Entry&lt;/code&gt; 객체라고합니다. 엔트리 콜렉션은 &lt;code&gt;HashMap&lt;/code&gt; 및 &lt;code&gt;Hashtable&lt;/code&gt; 의 오브젝트에 의해 참조됩니다. 컬렉션의 키는 고유하거나 고유해야합니다. [매핑 된 값을 특정 키로 검색하는 데 사용됩니다. 컬렉션의 값을 복제 할 수 있습니다.]</target>
        </trans-unit>
        <trans-unit id="00dc41b113291633c52fd58000a80e068e3e22e0" translate="yes" xml:space="preserve">
          <source>The HashMap class is roughly equivalent to Hashtable, except that it permits nulls. (HashMap allows null values as key and value whereas
  Hashtable doesn&amp;rsquo;t allow nulls).</source>
          <target state="translated">HashMap 클래스는 null을 허용한다는 점을 제외하고 Hashtable과 거의 동일합니다. HashMap은 null 값을 키와 값으로 허용하고 Hashtable은 null을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7ecf1afa5b4c9630d2b5dcfbe61d5b627ebd286" translate="yes" xml:space="preserve">
          <source>The Map Interface</source>
          <target state="translated">지도 인터페이스</target>
        </trans-unit>
        <trans-unit id="3676c70892d7c609193fc43d310096bd0df0c6be" translate="yes" xml:space="preserve">
          <source>The iterators returned by Map are fail-fast, if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. &lt;strong&gt;Whereas&lt;/strong&gt; the Enumerations returned by Hashtable's keys and elements methods are not fail-fast.</source>
          <target state="translated">반복자가 자체 remove 메소드를 제외하고 어떤 방식 으로든 반복자가 작성된 후 언제라도 맵이 구조적으로 수정되면 Map이 리턴 한 반복자는 실패가 빠릅니다. 반복자는 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생 시킵니다. 따라서 동시 수정에 직면하여 반복자는 미래에 결정되지 않은 시간에 임의의 비 결정적 동작을 위험에 빠뜨리기보다는 신속하고 깨끗하게 실패합니다. Hashtable의 키 및 요소 메소드가 리턴 한 열거는 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e573df66450873c1ddfa83005b4aa24d831fd978" translate="yes" xml:space="preserve">
          <source>The third significant difference between HashMap vs Hashtable is that Iterator in the HashMap is a fail-fast iterator while the
  enumerator for the Hashtable is not and throw
  ConcurrentModificationException if any other Thread modifies the map
  structurally by adding or removing any element except Iterator&amp;rsquo;s own
  remove() method. But this is not a guaranteed behavior and will be
  done by JVM on best effort. This is also an important difference
  between Enumeration and Iterator in Java.</source>
          <target state="translated">HashMap과 Hashtable의 세 번째 중요한 차이점은 HashMap의 Iterator는 페일 패스트 반복자이며 Hashtable의 열거자는 그렇지 않으며 다른 Thread가 Iterator의 자체 제거를 제외한 다른 요소를 추가하거나 제거하여 구조적으로 맵을 수정하면 ConcurrentModificationException을 발생시킵니다. ) 방법. 그러나 이것은 보장 된 동작이 아니며 최선의 노력으로 JVM이 수행합니다. 이것은 또한 Java에서 열거와 반복자의 중요한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="f56383732ea0646c1b6ccc4780205710d6c51198" translate="yes" xml:space="preserve">
          <source>There are 5 basic differentiations with HashTable and HashMaps.</source>
          <target state="translated">HashTable과 HashMaps에는 5 가지 기본 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1f8a6f6840706e60372d6f2420a010dbd1ffca" translate="yes" xml:space="preserve">
          <source>There are several differences between &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java:</source>
          <target state="translated">Java에서 &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;http://java.sun.com/javase/7/docs/api/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt; 간에는 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5800ffe299a96231836db81f351c861e03ed3697" translate="yes" xml:space="preserve">
          <source>There is many good answer already posted. I'm adding few new points and summarizing it.</source>
          <target state="translated">이미 게시 된 좋은 답변이 많이 있습니다. 몇 가지 새로운 포인트를 추가하고 요약합니다.</target>
        </trans-unit>
        <trans-unit id="df9315b5c785f8ab9f27801657f7477146067793" translate="yes" xml:space="preserve">
          <source>Third difference on &lt;code&gt;Hashtable&lt;/code&gt; vs &lt;code&gt;HashMap&lt;/code&gt; is that &lt;code&gt;Hashtable&lt;/code&gt; is obsolete class and you should be using &lt;code&gt;ConcurrentHashMap&lt;/code&gt; in place of &lt;code&gt;Hashtable&lt;/code&gt; in Java.</source>
          <target state="translated">&lt;code&gt;Hashtable&lt;/code&gt; 과 &lt;code&gt;HashMap&lt;/code&gt; 의 세 번째 차이점은 &lt;code&gt;Hashtable&lt;/code&gt; 이 사용되지 않는 클래스이므로 Java에서 &lt;code&gt;Hashtable&lt;/code&gt; 대신 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 을 사용해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee9376793d9967bcbf5a7a8c815e756c9c9ccb2c" translate="yes" xml:space="preserve">
          <source>This question is often asked in interview to check whether candidate understands correct usage of collection classes and is aware of alternative solutions available.</source>
          <target state="translated">이 질문은 종종 후보자가 수집 클래스의 올바른 사용법을 이해하고 사용 가능한 대체 솔루션을 알고 있는지 확인하기 위해 인터뷰에서 요청됩니다.</target>
        </trans-unit>
        <trans-unit id="247c0322284eae1d1388216cd3162f7e2cc8e631" translate="yes" xml:space="preserve">
          <source>We can make the &lt;code&gt;HashMap&lt;/code&gt; as synchronized by calling this code</source>
          <target state="translated">이 코드를 호출하여 &lt;code&gt;HashMap&lt;/code&gt; 을 동기화 된 것으로 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c81f8280687b9700ca5bb68ae586570fb7c23f46" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt; in Java?</source>
          <target state="translated">Java에서 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Hashtable.html&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt; 의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2c8e95a3c2ffb57733e53c253ed60a5636be3523" translate="yes" xml:space="preserve">
          <source>What is the difference between HashMap and HashTable?</source>
          <target state="translated">HashMap과 HashTable의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ce3ce0552d057e3c8f06c38c4e4073b98a6a4ac5" translate="yes" xml:space="preserve">
          <source>Which is more efficient for non-threaded applications?</source>
          <target state="translated">스레드되지 않은 응용 프로그램에 더 효과적인 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2641089043a1d4d281fa1d792f1ac52e385d9822" translate="yes" xml:space="preserve">
          <source>versus the old Hashtable approach:</source>
          <target state="translated">기존 해시 테이블 접근 방식과 비교 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
