<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/409286">
    <body>
      <group id="409286">
        <trans-unit id="593a02a118c1f362caa2e58db6d6664e3f576b7f" translate="yes" xml:space="preserve">
          <source>(Unless you are likely to change the timezone of your servers)</source>
          <target state="translated">(A menos que sea probable que cambie la zona horaria de sus servidores)</target>
        </trans-unit>
        <trans-unit id="d27bbad1be4b90f3efb7c75a4b43f6fa388fae5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;datetime&lt;/code&gt; = application supports 1 timezone (for both inserting and selecting)</source>
          <target state="translated">&lt;code&gt;datetime&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = la aplicaci&amp;oacute;n admite 1 zona horaria (tanto para insertar como para seleccionar)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="20905d1d1b479330793c32af9ed0fa9beb9adb03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; = application supports any timezone (for both inserting and selecting)</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = la aplicaci&amp;oacute;n admite cualquier zona horaria (tanto para insertar como para seleccionar)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="349a08ae5d6ed4659b0bcd3ec7c70e280bab22c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;2016 +&lt;/em&gt;: what I advise is to set your Mysql timezone to UTC and use DATETIME:</source>
          <target state="translated">&lt;em&gt;2016 +&lt;/em&gt; : lo que aconsejo es configurar su zona horaria Mysql en UTC y usar DATETIME:</target>
        </trans-unit>
        <trans-unit id="331d547d2d77f302ef10428b2a9addf2ef86e968" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This answer is only for putting some highlight on the flexibility and ease of timestamps when it comes to time zones , it is not covering any other differences like the &lt;a href=&quot;https://stackoverflow.com/a/45632196/5407848&quot;&gt;column size or range or fraction&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta respuesta es solo para resaltar la flexibilidad y la facilidad de las marcas de tiempo cuando se trata de zonas horarias, no cubre ninguna otra diferencia como el &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/45632196/5407848&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tama&amp;ntilde;o de&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;columna, el rango o la fracci&amp;oacute;n&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8d39d205db25f2106a7af756b95fdfef76c9718" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The main differences:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Las principales diferencias:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34da79ccaf9b8c0d6c96a398c7de54c386c7c5d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is that [.fraction]?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; es esa [.fracci&amp;oacute;n]?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ccacfe5d1464a272d0161bc29e81b58fd87fa55" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TIMESTAMP&lt;/code&gt; requires 4 bytes, whereas a &lt;code&gt;DATETIME&lt;/code&gt; requires 8 bytes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;TIMESTAMP&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; requiere 4 bytes, mientras que un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;DATETIME&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; requiere 8 bytes.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f86f9e143c43e826773e4340f28d06abfa21196" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;timestamp&lt;/code&gt; field is a special case of the &lt;code&gt;datetime&lt;/code&gt; field. You can create &lt;code&gt;timestamp&lt;/code&gt; columns to have special properties; it can be set to update itself on either create and/or update.</source>
          <target state="translated">Un campo de &lt;code&gt;timestamp&lt;/code&gt; es un caso especial del campo de &lt;code&gt;datetime&lt;/code&gt; . Puede crear columnas de &lt;code&gt;timestamp&lt;/code&gt; para tener propiedades especiales; se puede configurar para actualizarse en crear y / o actualizar.</target>
        </trans-unit>
        <trans-unit id="23afe721d17e7bce6561ecac0c0767557c18f3e2" translate="yes" xml:space="preserve">
          <source>A DATETIME or TIMESTAMP value can include a trailing fractional
seconds part in up to microseconds (6 digits) precision. In
particular, any fractional part in a value inserted into a DATETIME
or TIMESTAMP column is stored rather than discarded. This is of course optional.</source>
          <target state="translated">Un valor de DATETIME o TIMESTAMP puede incluir una parte de segundos fraccionarios de arrastre con una precisión de hasta microsegundos (6 dígitos).En particular,cualquier parte fraccionaria de un valor insertado en una columna de HORA DE LA CITA o HORA DEL MOMENTO se almacena en lugar de ser descartada.Esto es,por supuesto,opcional.</target>
        </trans-unit>
        <trans-unit id="105e72149319d74d06cd9e179968cd6895c674de" translate="yes" xml:space="preserve">
          <source>A great example of DATETIME being used where TIMESTAMP should have been used is in Facebook, where their servers are never quite sure what time stuff happened across time zones. Once I was having a conversation in which the time said I was replying to messages before the message was actually sent. (This, of course, could also have been caused by bad time zone translation in the messaging software if the times were being posted rather than synchronized.)</source>
          <target state="translated">Un gran ejemplo de DATETIME siendo usado donde TIMESTAMP debería haber sido usado es en Facebook,donde sus servidores nunca están muy seguros de qué cosas de tiempo ocurrieron a través de las zonas horarias.Una vez tuve una conversación en la que la hora decía que estaba respondiendo a los mensajes antes de que el mensaje fuera enviado.(Esto,por supuesto,también podría haber sido causado por una mala traducción de la zona horaria en el software de mensajería si las horas estaban siendo publicadas en lugar de sincronizadas).</target>
        </trans-unit>
        <trans-unit id="ac1d2a76e849b1b5833ee66f2036219c73ed4239" translate="yes" xml:space="preserve">
          <source>Additionally:</source>
          <target state="translated">Additionally:</target>
        </trans-unit>
        <trans-unit id="a1f945cbe8c29cec65da8e8eab6c4e28b4f16229" translate="yes" xml:space="preserve">
          <source>All localised time format available here:
&lt;a href=&quot;https://docs.angularjs.org/api/ng/filter/date&quot;&gt;https://docs.angularjs.org/api/ng/filter/date&lt;/a&gt;</source>
          <target state="translated">Todos los formatos de hora localizados disponibles aqu&amp;iacute;: &lt;a href=&quot;https://docs.angularjs.org/api/ng/filter/date&quot;&gt;https://docs.angularjs.org/api/ng/filter/date&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="03f4ab0cfb5116acacf82c79980bbc4c1538ca3f" translate="yes" xml:space="preserve">
          <source>Another difference between Timestamp and Datetime is in Timestamp you can't default value to NULL.</source>
          <target state="translated">Otra diferencia entre la marca de tiempo y la fecha y hora es que en la marca de tiempo no puedes poner el valor por defecto en NULL.</target>
        </trans-unit>
        <trans-unit id="8649432b65d482601d32ced47b86cec528e6f13e" translate="yes" xml:space="preserve">
          <source>Another thing worth considering:</source>
          <target state="translated">Otra cosa que vale la pena considerar:</target>
        </trans-unit>
        <trans-unit id="7e4bc976d9f0aa9df498da0d674146848c45e317" translate="yes" xml:space="preserve">
          <source>Any recent front-end framework (Angular 1/2, react, Vue,...) can easily and automatically convert your UTC datetime to local time.</source>
          <target state="translated">Cualquier marco reciente (Angular 12,reaccionar,Vue,...)puede fácil y automáticamente convertir su fecha y hora UTC a la hora local.</target>
        </trans-unit>
        <trans-unit id="1f02b723ecb30f7a7b86943f5693d1a105ed169a" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/datetime.html&quot;&gt;mentioned&lt;/a&gt; in the MySQL documentation:</source>
          <target state="translated">Como se &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/datetime.html&quot;&gt;menciona&lt;/a&gt; en la documentaci&amp;oacute;n de MySQL:</target>
        </trans-unit>
        <trans-unit id="30a7616be2ba7d64b9561fa7bcf55829ad69bc78" translate="yes" xml:space="preserve">
          <source>As a plus, in the case of a migration of the database to a system with another timezone, I would feel more confident using timestamps. Not to say possible issues when calculating differences between two moments with a sumer time change in between and needing a precision of 1 hour or less.</source>
          <target state="translated">Como ventaja,en el caso de una migración de la base de datos a un sistema con otra zona horaria,me sentiría más seguro utilizando las marcas de tiempo.Por no decir posibles problemas al calcular las diferencias entre dos momentos con un cambio de tiempo sumario entre ellos y que necesitan una precisión de 1 hora o menos.</target>
        </trans-unit>
        <trans-unit id="75c9379a28896ce9890676a1ef0ca87e210c0b0c" translate="yes" xml:space="preserve">
          <source>Beware of timestamp changing when you do a UPDATE statement on a table.  If you have a table with columns 'Name' (varchar), 'Age' (int), and 'Date_Added' (timestamp) and you run the following DML statement</source>
          <target state="translated">Ten cuidado con el cambio de fecha y hora cuando hagas una declaración de actualización en una mesa.Si tienes una tabla con las columnas 'Nombre' (varchar),'Edad' (int),y 'Fecha_Añadida' (marca de tiempo)y ejecutas la siguiente sentencia DML</target>
        </trans-unit>
        <trans-unit id="048fad409fc302137354247e34dd35f44fb43704" translate="yes" xml:space="preserve">
          <source>But like scronide said it does have a lower limit of the year 1970. It's great for anything that might happen in the future though ;)</source>
          <target state="translated">Pero como dijo Scronide,tiene un límite inferior del año 1970.Es genial para cualquier cosa que pueda suceder en el futuro,sin embargo ;)</target>
        </trans-unit>
        <trans-unit id="0b3bafc7f7ed6d1609b9c2c4fd043e820e24cc01" translate="yes" xml:space="preserve">
          <source>By default, the current time zone for each connection is the server's time. The time zone can be set on a per-connection basis, as described in &lt;em&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en//time-zone-support.html&quot;&gt;MySQL Server Time Zone Support&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Por defecto, la zona horaria actual para cada conexi&amp;oacute;n es la hora del servidor. La zona horaria se puede establecer por conexi&amp;oacute;n, como se describe en &lt;em&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en//time-zone-support.html&quot;&gt;Soporte de zona horaria del servidor MySQL&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="46e754d5823f336c6879ab95356aa5286d30a861" translate="yes" xml:space="preserve">
          <source>Comparison between DATETIME, TIMESTAMP and DATE</source>
          <target state="translated">Comparación entre FECHA,HORA y FECHA</target>
        </trans-unit>
        <trans-unit id="dfa016c1ac5a15d6be12e485338468f1d8936cd6" translate="yes" xml:space="preserve">
          <source>Consider setting a timestamp by a user to a server in New York, for an appointment in Sanghai. Now when the user connects in Sanghai, he accesses the same appointment timestamp from a mirrored server in Tokyo. He will see the appointment in Tokyo time, offset from the original New York time.</source>
          <target state="translated">Considere la posibilidad de establecer una marca de tiempo por un usuario a un servidor en Nueva York,para una cita en Sanghai.Ahora,cuando el usuario se conecta en Sanghai,accede a la misma marca de tiempo de la cita desde un servidor espejo en Tokio.Verá la cita en la hora de Tokio,compensada con la hora original de Nueva York.</target>
        </trans-unit>
        <trans-unit id="36abbe8686064b87032b977c64e9037a1ab43ae2" translate="yes" xml:space="preserve">
          <source>Contrary to what one might think, DATETIME is &lt;strong&gt;FASTER&lt;/strong&gt; THAN TIMESTAMP,
&lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&quot;&gt;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&lt;/a&gt;</source>
          <target state="translated">Al contrario de lo que uno podr&amp;iacute;a pensar, DATETIME es &lt;strong&gt;M&amp;Aacute;S R&amp;Aacute;PIDO&lt;/strong&gt; QUE TIMESTAMP, &lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&quot;&gt;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with -myisam /&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cd06d5b91f44e6c7d8bb5a9e4b6c53eb080b994" translate="yes" xml:space="preserve">
          <source>DATETIME can now be &lt;strong&gt;automatically&lt;/strong&gt; set to the current time value &lt;a href=&quot;https://stackoverflow.com/questions/168736/how-do-you-set-a-default-value-for-a-mysql-datetime-column/10603198#10603198&quot;&gt;How do you set a default value for a MySQL Datetime column?&lt;/a&gt;</source>
          <target state="translated">DATETIME ahora se puede configurar &lt;strong&gt;autom&amp;aacute;ticamente&lt;/strong&gt; en el valor de hora actual &lt;a href=&quot;https://stackoverflow.com/questions/168736/how-do-you-set-a-default-value-for-a-mysql-datetime-column/10603198#10603198&quot;&gt;&amp;iquest;C&amp;oacute;mo se configura un valor predeterminado para una columna MySQL Datetime?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bb751509c73535fc71ab28078b2a2cd7cff076c" translate="yes" xml:space="preserve">
          <source>DATETIME is constant while TIMESTAMP is effected by the time_zone setting.</source>
          <target state="translated">DATETIME es constante mientras que TIMESTAMP es afectado por el ajuste de la zona horaria.</target>
        </trans-unit>
        <trans-unit id="e606ed7f8ffdfa79456bda0bab96b69794b076de" translate="yes" xml:space="preserve">
          <source>Depends on application, really.</source>
          <target state="translated">Depende de la aplicación,en realidad.</target>
        </trans-unit>
        <trans-unit id="793dba92e4fad48f46012613b16dac7b1259878a" translate="yes" xml:space="preserve">
          <source>Example with AngularJs</source>
          <target state="translated">Ejemplo con AngularJs</target>
        </trans-unit>
        <trans-unit id="b632b31f3430f0f42e92741a8e59ca31ba0a5461" translate="yes" xml:space="preserve">
          <source>For all this reasons, I choose UTC &amp;amp; timestamp fields where posible. And I avoid headaches ;)</source>
          <target state="translated">Por todas estas razones, elijo los campos UTC y marca de tiempo cuando sea posible. Y evito dolores de cabeza;)</target>
        </trans-unit>
        <trans-unit id="6b6dd3a87f08f57887386997d7393798f29857fa" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;user&lt;/code&gt; table with a &lt;strong&gt;REGISTRATION DATE&lt;/strong&gt; field. In that &lt;code&gt;user&lt;/code&gt; table, if you want to know the last logged in time of a particular user, go with a field of &lt;strong&gt;timestamp&lt;/strong&gt; type so that the field gets updated.</source>
          <target state="translated">Por ejemplo, considere una tabla de &lt;code&gt;user&lt;/code&gt; con un campo &lt;strong&gt;FECHA DE REGISTRO&lt;/strong&gt; . En esa tabla de &lt;code&gt;user&lt;/code&gt; , si desea conocer la &amp;uacute;ltima hora de inicio de sesi&amp;oacute;n de un usuario en particular, vaya con un campo de tipo de &lt;strong&gt;marca&lt;/strong&gt; de &lt;strong&gt;tiempo&lt;/strong&gt; para que el campo se actualice.</target>
        </trans-unit>
        <trans-unit id="4911c2a3fb22efedb0166e219e1c072fdeeb59f1" translate="yes" xml:space="preserve">
          <source>For more details you can read the blog post &lt;em&gt;&lt;a href=&quot;http://codebucket.co.in/timestamp-vs-datetime/&quot;&gt;Timestamp Vs Datetime &lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, puede leer la publicaci&amp;oacute;n del blog &lt;em&gt;&lt;a href=&quot;http://codebucket.co.in/timestamp-vs-datetime/&quot;&gt;Timestamp Vs Datetime&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dc856e5e23919033bd72ab59467477a0e61ba03c" translate="yes" xml:space="preserve">
          <source>For your clients comfort you want to show them the times based on their preferred time zones without making them doing the math and convert the time to their meaningful timezone. all you need is to change the timezone and all your application code will be the same.&lt;em&gt;(Actually you should always define the timezone at the start of the application, or request processing in case of PHP applications)&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para la comodidad de sus clientes, desea mostrarles las horas en funci&amp;oacute;n de sus zonas horarias preferidas sin hacer que hagan los c&amp;aacute;lculos y convertir la hora a su zona horaria significativa. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;todo lo que necesita es cambiar la zona horaria y todo el c&amp;oacute;digo de su aplicaci&amp;oacute;n ser&amp;aacute; el mismo. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(En realidad, siempre debe definir la zona horaria al inicio de la aplicaci&amp;oacute;n, o solicitar el procesamiento en caso de aplicaciones PHP)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64e254cfc8fee4a9ead40861b1246312894ba70c" translate="yes" xml:space="preserve">
          <source>From my experiences, if you want a date field in which insertion happens only once and you don't want to have any update or any other action on that particular field, go with &lt;strong&gt;date time&lt;/strong&gt;.</source>
          <target state="translated">Seg&amp;uacute;n mi experiencia, si desea un campo de fecha en el que la inserci&amp;oacute;n se realice solo una vez y no desea tener ninguna actualizaci&amp;oacute;n u otra acci&amp;oacute;n en ese campo en particular, vaya con la &lt;strong&gt;fecha y hora&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1dbdfeac2373ec7aa37785a932e7c4d2c25cbb" translate="yes" xml:space="preserve">
          <source>Here are some cases that will make you regret using &lt;code&gt;datetime&lt;/code&gt; and wish that you stored your data in timestamps.</source>
          <target state="translated">Estos son algunos casos que har&amp;aacute;n que te arrepientas de usar &lt;code&gt;datetime&lt;/code&gt; y deseen almacenar tus datos en marcas de tiempo.</target>
        </trans-unit>
        <trans-unit id="2da35bc820a81a1cb5374406c62ccc9e358ccf59" translate="yes" xml:space="preserve">
          <source>I almost always prefer timestamps rather than datetime fields, because timestamps include the timezone implicitly. So, since the moment that the app will be accessed from users from different time zones and you want them to see dates and times in their local timezone, this field type makes it pretty easy to do it than if the data were saved in datetime fields.</source>
          <target state="translated">Casi siempre prefiero los sellos de tiempo en lugar de los campos de fecha y hora,porque los sellos de tiempo incluyen la zona horaria implícitamente.Por lo tanto,desde el momento en que la aplicación será accedida por usuarios de diferentes zonas horarias y quieres que vean las fechas y horas en su zona horaria local,este tipo de campo hace que sea bastante fácil hacerlo que si los datos se guardaran en campos de fecha y hora.</target>
        </trans-unit>
        <trans-unit id="a5cd89f5ee8f947b442b15a5e503fefe94df935b" translate="yes" xml:space="preserve">
          <source>I always use DATETIME fields for anything other than row metadata (date created or modified).</source>
          <target state="translated">Siempre utilizo los campos DATETIME para cualquier cosa que no sean metadatos de filas (fecha de creación o modificación).</target>
        </trans-unit>
        <trans-unit id="a678e945f8d1f6465d392193c4faf6646c4cece9" translate="yes" xml:space="preserve">
          <source>I always use a Unix timestamp, simply to maintain sanity when dealing with a lot of datetime information, especially when performing adjustments for timezones, adding/subtracting dates, and the like. When comparing timestamps, this excludes the complicating factors of timezone and allows you to spare resources in your server side processing (Whether it be application code or database queries) in that you make use of light weight arithmetic rather then heavier date-time add/subtract functions.</source>
          <target state="translated">Siempre utilizo una marca de tiempo Unix,simplemente para mantener la cordura cuando se trata de una gran cantidad de información de fecha y hora,especialmente cuando se realizan ajustes de zonas horarias,sumas y restas de fechas,y similares.Cuando se comparan las marcas de tiempo,esto excluye los factores complicados de la zona horaria y permite ahorrar recursos en el procesamiento del lado del servidor (ya sea código de aplicación o consultas a bases de datos),ya que se utiliza una aritmética ligera en lugar de las funciones de suma y resta de fecha y hora más pesadas.</target>
        </trans-unit>
        <trans-unit id="206c1f2009ec676fc4a9eec50d54024944901e95" translate="yes" xml:space="preserve">
          <source>I found unsurpassed usefulness in TIMESTAMP's ability to auto update itself based on the current time without the use of unnecessary triggers. That's just me though, although TIMESTAMP is UTC like it was said.</source>
          <target state="translated">Encontré una utilidad insuperable en la capacidad de TIMESTAMP de auto-actualizarse en base a la hora actual sin el uso de disparadores innecesarios.Pero eso es sólo para mí,aunque TIMESTAMP es UTC como se dijo.</target>
        </trans-unit>
        <trans-unit id="d570a1bc95ba8702c39af942cff99df7742bb2be" translate="yes" xml:space="preserve">
          <source>I like a Unix timestamp, because you can convert to numbers and just worry about the number. Plus you add/subtract and get durations, etc. Then convert the result to Date in whatever format. This code finds out how much time in minutes passed between a timestamp from a document, and the current time.</source>
          <target state="translated">Me gusta la marca de tiempo de Unix,porque puedes convertir a números y preocuparte por el número.Además,sumas,restas y obtienes duraciones,etc.Luego conviertes el resultado a Date en cualquier formato.Este código averigua cuánto tiempo en minutos pasó entre una marca de tiempo de un documento y la hora actual.</target>
        </trans-unit>
        <trans-unit id="cf4a40b7b0f9f34fbb16456724075a43d2ce0f45" translate="yes" xml:space="preserve">
          <source>I make this decision on a semantic base.</source>
          <target state="translated">Tomo esta decisión sobre una base semántica.</target>
        </trans-unit>
        <trans-unit id="5ef7e671798c6131c697e0f63b12c62ab2bfa381" translate="yes" xml:space="preserve">
          <source>I prefer using timestamp so to keep everything in one common raw format and format the data in PHP code or in your SQL query. There are instances where it comes in handy in your code to keep everything in plain seconds.</source>
          <target state="translated">Prefiero usar la marca de tiempo para mantener todo en un formato común en bruto y formatear los datos en código PHP o en su consulta SQL.Hay casos en los que es útil en su código para mantener todo en segundos.</target>
        </trans-unit>
        <trans-unit id="e23b06243c6572b6cfb0e3cffcf474b9fa8522b8" translate="yes" xml:space="preserve">
          <source>I recommend using &lt;strong&gt;neither&lt;/strong&gt; a DATETIME or a TIMESTAMP field.  If you want to represent a specific day as a whole (like a birthday), then use a DATE type, but if you're being more specific than that, you're probably interested in recording an actual moment as opposed to a unit of time (day,week,month,year).  Instead of using a DATETIME or TIMESTAMP, use a BIGINT, and simply store the number of milliseconds since the epoch (System.currentTimeMillis() if you're using Java).  This has several advantages:</source>
          <target state="translated">Recomiendo &lt;strong&gt;no&lt;/strong&gt; usar un campo DATETIME o TIMESTAMP. Si desea representar un d&amp;iacute;a espec&amp;iacute;fico como un todo (como un cumplea&amp;ntilde;os), use un tipo de FECHA, pero si est&amp;aacute; siendo m&amp;aacute;s espec&amp;iacute;fico que eso, probablemente est&amp;eacute; interesado en registrar un momento real en lugar de una unidad de tiempo (d&amp;iacute;a, semana, mes, a&amp;ntilde;o). En lugar de usar un DATETIME o TIMESTAMP, use un BIGINT y simplemente almacene el n&amp;uacute;mero de milisegundos desde la &amp;eacute;poca (System.currentTimeMillis () si est&amp;aacute; usando Java). Esto tiene varias ventajas:</target>
        </trans-unit>
        <trans-unit id="32b22a379070f7ef416fd882ae9907f4cafcabff" translate="yes" xml:space="preserve">
          <source>I stopped using &lt;code&gt;datetime&lt;/code&gt; in my applications after facing many problems and bugs related to time zones. &lt;strong&gt;IMHO using &lt;code&gt;timestamp&lt;/code&gt; is better than &lt;code&gt;datetime&lt;/code&gt; in most of the cases&lt;/strong&gt;.</source>
          <target state="translated">Dej&amp;eacute; de usar &lt;code&gt;datetime&lt;/code&gt; en mis aplicaciones despu&amp;eacute;s de enfrentar muchos problemas y errores relacionados con las zonas horarias. &lt;strong&gt;En mi humilde opini&amp;oacute;n, el uso de la &lt;code&gt;timestamp&lt;/code&gt; es mejor que la &lt;code&gt;datetime&lt;/code&gt; y hora en la mayor&amp;iacute;a de los casos&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3e0f03321593d604ad3daae773b9b9de690bc1" translate="yes" xml:space="preserve">
          <source>I use a datetime field when the date/time can be set and changed arbitrarily. For example when a user can save later change appointments.</source>
          <target state="translated">Utilizo un campo de fecha y hora cuando la fecha y hora puede ser fijada y cambiada arbitrariamente.Por ejemplo,cuando un usuario puede guardar más tarde las citas de cambio.</target>
        </trans-unit>
        <trans-unit id="8b5833e1a61fb755b21f93ca6d1707ba3c9eb38b" translate="yes" xml:space="preserve">
          <source>I use a timestamp when I need to record a (more or less) fixed point in time. For example when a record was inserted into the database or when some user action took place.</source>
          <target state="translated">Utilizo una marca de tiempo cuando necesito registrar un punto (más o menos)fijo en el tiempo.Por ejemplo,cuando se inserta un registro en la base de datos o cuando se produce alguna acción del usuario.</target>
        </trans-unit>
        <trans-unit id="f86d1b7817db590f627374a0bcb90e6b5ff9a671" translate="yes" xml:space="preserve">
          <source>I would always use a Unix timestamp when working with MySQL and PHP. The main reason for this being the the default &lt;a href=&quot;http://uk3.php.net/manual/en/function.date.php&quot;&gt;date&lt;/a&gt; method in PHP uses a timestamp as the parameter, so there would be no parsing needed.</source>
          <target state="translated">Siempre usar&amp;iacute;a una marca de tiempo Unix cuando trabaje con MySQL y PHP. La raz&amp;oacute;n principal de esto es que el m&amp;eacute;todo de &lt;a href=&quot;http://uk3.php.net/manual/en/function.date.php&quot;&gt;fecha&lt;/a&gt; predeterminado en PHP usa una marca de tiempo como par&amp;aacute;metro, por lo que no ser&amp;iacute;a necesario analizar.</target>
        </trans-unit>
        <trans-unit id="e9364c12edb1f9c9f5ec70d22a2e2dd682193867" translate="yes" xml:space="preserve">
          <source>I'm working with PHP on the server side.</source>
          <target state="translated">Estoy trabajando con PHP en el lado del servidor.</target>
        </trans-unit>
        <trans-unit id="a45ff0bb3a329fa67ebd8832f5d0546cb7f2251d" translate="yes" xml:space="preserve">
          <source>I've converted my answer into article so more people can find this useful, &lt;em&gt;&lt;a href=&quot;http://www.tech-recipes.com/rx/22599/mysql-datetime-vs-timestamp-data-type/&quot;&gt;MySQL: Datetime Versus Timestamp Data Types&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">He convertido mi respuesta en un art&amp;iacute;culo para que m&amp;aacute;s personas puedan encontrar esto &amp;uacute;til, &lt;em&gt;&lt;a href=&quot;http://www.tech-recipes.com/rx/22599/mysql-datetime-vs-timestamp-data-type/&quot;&gt;MySQL: Tipos de datos de fecha y hora y fecha y hora&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="31489a4469658ad39dd5d8120b54ba1d823877db" translate="yes" xml:space="preserve">
          <source>If you are creating the table from &lt;a href=&quot;http://en.wikipedia.org/wiki/PhpMyAdmin&quot;&gt;phpMyAdmin&lt;/a&gt; the default setting will update the &lt;strong&gt;timestamp&lt;/strong&gt; field when a row update happens. If your timestamp filed is not updating with row update, you can use the following query to make a &lt;strong&gt;timestamp&lt;/strong&gt; field get auto updated.</source>
          <target state="translated">Si est&amp;aacute; creando la tabla desde &lt;a href=&quot;http://en.wikipedia.org/wiki/PhpMyAdmin&quot;&gt;phpMyAdmin,&lt;/a&gt; la configuraci&amp;oacute;n predeterminada actualizar&amp;aacute; el campo de &lt;strong&gt;marca de tiempo&lt;/strong&gt; cuando se &lt;strong&gt;realice&lt;/strong&gt; una actualizaci&amp;oacute;n de fila. Si su marca de tiempo archivada no se actualiza con la actualizaci&amp;oacute;n de fila, puede usar la siguiente consulta para hacer que un campo de &lt;strong&gt;marca de tiempo&lt;/strong&gt; se actualice autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="9b1bb522d65d67e7cdbb1d7601b2e95f9a523514" translate="yes" xml:space="preserve">
          <source>If you meant that you want to decide between using a UNIX timestamp or a native MySQL datetime field, go with the native format. You can do calculations within MySQL that way 
&lt;code&gt;(&quot;SELECT DATE_ADD(my_datetime, INTERVAL 1 DAY)&quot;)&lt;/code&gt; and it is simple to change the format of the value to a UNIX timestamp &lt;code&gt;(&quot;SELECT UNIX_TIMESTAMP(my_datetime)&quot;)&lt;/code&gt; when you query the record if you want to operate on it with PHP.</source>
          <target state="translated">Si quer&amp;iacute;a decir que desea decidir entre usar una marca de tiempo UNIX o un campo de fecha y hora nativo de MySQL, vaya con el formato nativo. Puede hacer c&amp;aacute;lculos dentro de MySQL de esa manera &lt;code&gt;(&quot;SELECT DATE_ADD(my_datetime, INTERVAL 1 DAY)&quot;)&lt;/code&gt; y es simple cambiar el formato del valor a una marca de tiempo UNIX &lt;code&gt;(&quot;SELECT UNIX_TIMESTAMP(my_datetime)&quot;)&lt;/code&gt; cuando consulta el registro si quieres operarlo con PHP.</target>
        </trans-unit>
        <trans-unit id="ffcc29ae487aa623bebb0ee1e8f86561c675d52d" translate="yes" xml:space="preserve">
          <source>If you're building an application, you never know how your data might have to be used down the line. If you wind up having to, say, compare a bunch of records in your data set, with, say, a bunch of items from a third-party API, and say, put them in chronological order, you'll be happy to have Unix timestamps for your rows. Even if you decide to use MySQL timestamps, store a Unix timestamp as insurance.</source>
          <target state="translated">Si estás construyendo una aplicación,nunca sabes cómo tus datos podrían tener que ser utilizados en el futuro.Si terminas teniendo que,por ejemplo,comparar un montón de registros en tu conjunto de datos,con,por ejemplo,un montón de elementos de una API de terceros,y,por ejemplo,ponerlos en orden cronológico,estarás contento de tener marcas de tiempo Unix para tus filas.Incluso si decides usar marcas de tiempo de MySQL,guarda una marca de tiempo de Unix como seguro.</target>
        </trans-unit>
        <trans-unit id="c7995d4761522909b7214e1601ee4a9bbe7b4a1f" translate="yes" xml:space="preserve">
          <source>In &quot;bigger&quot; database terms, &lt;code&gt;timestamp&lt;/code&gt; has a couple of special-case triggers on it.</source>
          <target state="translated">En t&amp;eacute;rminos de base de datos &quot;m&amp;aacute;s grandes&quot;, la &lt;code&gt;timestamp&lt;/code&gt; tiene un par de disparadores de casos especiales.</target>
        </trans-unit>
        <trans-unit id="2b0d5700a614a6da306f30adf05aaca5b64dbbf1" translate="yes" xml:space="preserve">
          <source>In MySQL 5 and above, &lt;strong&gt;TIMESTAMP&lt;/strong&gt; values are converted from the current time zone to UTC for storage, and converted back from UTC to the current time zone for retrieval. (This occurs only for the TIMESTAMP data type, and &lt;em&gt;not&lt;/em&gt; for other types such as DATETIME.)</source>
          <target state="translated">En MySQL 5 y superior, los valores &lt;strong&gt;TIMESTAMP&lt;/strong&gt; se convierten de la zona horaria actual a UTC para el almacenamiento, y se vuelven a convertir de UTC a la zona horaria actual para su recuperaci&amp;oacute;n. (Esto ocurre solo para el tipo de datos TIMESTAMP, y &lt;em&gt;no&lt;/em&gt; para otros tipos como DATETIME).</target>
        </trans-unit>
        <trans-unit id="6e195894f50db5526afc2ab1bf4e1d5658cbea95" translate="yes" xml:space="preserve">
          <source>In my case, I set UTC as a time zone for everything: the system, the database server, etc. every time that I can. If my customer requires another time zone, then I configure it on the app.</source>
          <target state="translated">En mi caso,establecí la UTC como zona horaria para todo:el sistema,el servidor de la base de datos,etc.cada vez que puedo.Si mi cliente requiere otra zona horaria,entonces la configuro en la aplicación.</target>
        </trans-unit>
        <trans-unit id="7b0a223418a395464ae8da509f57c18c6c1d324c" translate="yes" xml:space="preserve">
          <source>In short</source>
          <target state="translated">En resumen...</target>
        </trans-unit>
        <trans-unit id="998430940a1cf51fc5ec051819a568638be1a42b" translate="yes" xml:space="preserve">
          <source>In simpler words: &lt;strong&gt;If I have a database in Australia, and take a dump of that database to synchronize/populate a database in America, then the TIMESTAMP would update to reflect the real time of the event in the new time zone, while DATETIME would still reflect the time of the event in the au time zone&lt;/strong&gt;.</source>
          <target state="translated">En palabras m&amp;aacute;s simples: &lt;strong&gt;si tengo una base de datos en Australia y tomo un volcado de esa base de datos para sincronizar / llenar una base de datos en Estados Unidos, entonces TIMESTAMP se actualizar&amp;aacute; para reflejar el tiempo real del evento en la nueva zona horaria, mientras que DATETIME todav&amp;iacute;a reflejan la hora del evento en la zona horaria au&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="880e081828ff1887a05d731a268374d23ecff5d5" translate="yes" xml:space="preserve">
          <source>It can keep track across different timezones, so if you need to display a relative time for instance, UTC time is what you would want.</source>
          <target state="translated">Puede hacer un seguimiento a través de diferentes zonas horarias,así que si necesitas mostrar una hora relativa,por ejemplo,la hora UTC es lo que querrías.</target>
        </trans-unit>
        <trans-unit id="a41918ecbc3f538d35b22cc423624607a058a62e" translate="yes" xml:space="preserve">
          <source>It is worth noting in MySQL you can use something along the lines of the below when creating your table columns:</source>
          <target state="translated">Vale la pena señalar que en MySQL se puede utilizar algo parecido a lo siguiente al crear las columnas de la tabla:</target>
        </trans-unit>
        <trans-unit id="e551a0a9f5cec988bad0e24f623506d90ef7f587" translate="yes" xml:space="preserve">
          <source>MySQL Date/Time data types reference</source>
          <target state="translated">Referencia a los tipos de datos de MySQL DateTime</target>
        </trans-unit>
        <trans-unit id="ca1edfc72a341b43b90b702098e1f76bdd4e6abc" translate="yes" xml:space="preserve">
          <source>MySQL Storage Requirements reference</source>
          <target state="translated">Referencia de los requisitos de almacenamiento de MySQL</target>
        </trans-unit>
        <trans-unit id="6a4d8a0f46ff5193d118cc038fb1704445a83d9a" translate="yes" xml:space="preserve">
          <source>No timezone issues.  There's been some insightful comments on here on what happens with timezones with the different data types.  But is this common knowledge, and will your co-workers all take the time to learn it?  On the other hand, it's pretty hard to mess up changing a BigINT into a java.util.Date.  Using a BIGINT causes a lot of issues with timezones to fall by the wayside.</source>
          <target state="translated">No hay problemas de zona horaria.Ha habido algunos comentarios perspicaces sobre lo que pasa con las zonas horarias con los diferentes tipos de datos.Pero,¿es esto de conocimiento común,y sus compañeros de trabajo se tomarán el tiempo para aprenderlo? Por otra parte,es bastante difícil de estropear el cambio de un BigINT en un java.util.Date.Usar un BIGINT causa muchos problemas con las zonas horarias.</target>
        </trans-unit>
        <trans-unit id="c435dd392d33aad96f73d02a6a3f30f54ccc0a19" translate="yes" xml:space="preserve">
          <source>No worries about ranges or precision.  You don't have to worry about what being cut short by future date ranges (TIMESTAMP only goes to 2038).</source>
          <target state="translated">No hay que preocuparse por los rangos o la precisión.No tienes que preocuparte por lo que se acorte por rangos de fechas futuras (TIMESTAMP sólo va hasta el 2038).</target>
        </trans-unit>
        <trans-unit id="91545e23ede1ee1fd22dcf98f82ebe9134aa6fe6" translate="yes" xml:space="preserve">
          <source>Note: default connection timezone is the server timezone, but this can (should) be changed per session (see &lt;code&gt;SET time_zone = ...&lt;/code&gt;).</source>
          <target state="translated">Nota: la zona horaria de conexi&amp;oacute;n predeterminada es la zona horaria del servidor, pero esto puede (deber&amp;iacute;a) cambiarse por sesi&amp;oacute;n (consulte &lt;code&gt;SET time_zone = ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="db07d9be995e80601a3b13b3376307c58b5426b7" translate="yes" xml:space="preserve">
          <source>On the other hand, for values that represent system time like payment transactions, table modifications or logging, always use timestamps. The system will not be affected by moving the server to another time zone, or when comparing between servers in different timezones.</source>
          <target state="translated">Por otra parte,para los valores que representan la hora del sistema,como las transacciones de pago,las modificaciones de tablas o el registro,utilice siempre marcas de tiempo.El sistema no se verá afectado por el traslado del servidor a otra zona horaria,o cuando se comparen servidores en diferentes zonas horarias.</target>
        </trans-unit>
        <trans-unit id="ba1d189b28f2abf9d56261768ea0e3c3b0ad4737" translate="yes" xml:space="preserve">
          <source>Reference taken from this Article:</source>
          <target state="translated">Referencia tomada de este artículo:</target>
        </trans-unit>
        <trans-unit id="8b05b05f99d45086cfec2bd40e0912d41a40c935" translate="yes" xml:space="preserve">
          <source>Should I use the datetime or timestamp data type in MySQL</source>
          <target state="translated">¿Debería usar el tipo de datos de fecha y hora en MySQL</target>
        </trans-unit>
        <trans-unit id="045177b57f199536798f7602f5e2b8d9dcff5e1f" translate="yes" xml:space="preserve">
          <source>So for values that represent user time like an appointment or a schedule, datetime is better. It allows the user to control the exact date and time desired, regardless of the server settings. The set time is the set time, not affected by the server's time zone, the user's time zone, or by changes in the way daylight savings time is calculated (yes it does change).</source>
          <target state="translated">Así que para los valores que representan el tiempo del usuario como una cita o un horario,la hora de la fecha es mejor.Permite al usuario controlar la fecha y hora exacta deseada,independientemente de la configuración del servidor.La hora establecida es la hora fijada,no se ve afectada por la zona horaria del servidor,la zona horaria del usuario o por los cambios en la forma de calcular el horario de verano (sí que cambia).</target>
        </trans-unit>
        <trans-unit id="73a5a457c16ecd2093862684ea7c13eae5a14ea1" translate="yes" xml:space="preserve">
          <source>So it only matters when you have &amp;mdash; or may in the future have &amp;mdash; synchronized clusters across time zones.</source>
          <target state="translated">Por lo tanto, solo es importante cuando tiene, o puede tener en el futuro tener, cl&amp;uacute;steres sincronizados en todas las zonas horarias.</target>
        </trans-unit>
        <trans-unit id="1653f1ba6251a7f548790a533e1efa888bef4509" translate="yes" xml:space="preserve">
          <source>So suppose you are in USA and getting data from a server which has a time zone of USA. Then you will get the date and time according to the USA time zone. The timestamp data type column always get updated automatically when its row gets updated. So it can be useful to track when a particular row was updated last time.</source>
          <target state="translated">Así que supongamos que estás en EE.UU.y obtienes datos de un servidor que tiene una zona horaria de EE.UU.Entonces obtendrás la fecha y la hora según la zona horaria de EE.UU.La columna del tipo de datos de la marca de tiempo siempre se actualiza automáticamente cuando su fila se actualiza.Por lo tanto,puede ser útil para rastrear cuándo se actualizó una fila en particular la última vez.</target>
        </trans-unit>
        <trans-unit id="eb10daa25dc60f8b1daad8f8e387e8e83eaf144b" translate="yes" xml:space="preserve">
          <source>So, to summarize, I value this advantages of timestamp:</source>
          <target state="translated">Así que,para resumir,valoro las ventajas de la marca de tiempo:</target>
        </trans-unit>
        <trans-unit id="ada52d888ccf16d2711b8a6377768a782af5c30e" translate="yes" xml:space="preserve">
          <source>Sources:</source>
          <target state="translated">Sources:</target>
        </trans-unit>
        <trans-unit id="77f90354221d8a67dd1969d6e644c499a0514a52" translate="yes" xml:space="preserve">
          <source>TIMESTAMP also affected by different TIME ZONE related setting.
DATETIME is constant.</source>
          <target state="translated">El TIMESTAMP también se ve afectado por diferentes ajustes relacionados con la ZONA HORARIA.La HORA es constante.</target>
        </trans-unit>
        <trans-unit id="c94a072eac65be71cfc849f9037072f6247474bd" translate="yes" xml:space="preserve">
          <source>TIMESTAMP internally converted current time zone to UTC for storage, and during retrieval converted back to the current time zone.
DATETIME can not do this.</source>
          <target state="translated">TIMESTAMP convirtió internamente la zona horaria actual a UTC para el almacenamiento,y durante la recuperación se convirtió de nuevo a la zona horaria actual.DATETIME no puede hacer esto.</target>
        </trans-unit>
        <trans-unit id="dacee252d7b14073e849682cd79a8a03ac04c316" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is 4 bytes Vs 8 bytes for DATETIME.</source>
          <target state="translated">TIMESTAMP es 4 bytes contra 8 bytes para DATETIME.</target>
        </trans-unit>
        <trans-unit id="a410814a3011c5943a3034941f92663affe3da22" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is always in UTC (that is, elapsed seconds since 1970-01-01, in UTC), and your MySQL server auto-converts it to the date/time for the connection timezone. In the long-term, TIMESTAMP is the way to go because you know your temporal data will always be in UTC. For example, you won't screw your dates up if you migrate to a different server or if you change the timezone settings on your server.</source>
          <target state="translated">TIMESTAMP está siempre en UTC (es decir,los segundos transcurridos desde 1970-01-01,en UTC),y su servidor MySQL lo convierte automáticamente a la fecha y hora de la zona horaria de conexión.A largo plazo,TIMESTAMP es el camino a seguir porque sabes que tus datos temporales siempre estarán en UTC.Por ejemplo,no arruinarás tus fechas si migras a un servidor diferente o si cambias la configuración de la zona horaria en tu servidor.</target>
        </trans-unit>
        <trans-unit id="e8ac59d0c9ad21fe5948cec9369a8f0b45667f55" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is four bytes vs eight bytes for DATETIME.</source>
          <target state="translated">TIMESTAMP es cuatro bytes contra ocho bytes para DATETIME.</target>
        </trans-unit>
        <trans-unit id="5d4df6053b746ece86d95685245755662b29cc96" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is still limited to 1970-2038</source>
          <target state="translated">TIMESTAMP está todavía limitado a 1970-2038</target>
        </trans-unit>
        <trans-unit id="f9eb6fe6031fa5a60529bcb98828a895865741b2" translate="yes" xml:space="preserve">
          <source>TIMESTAMP supported range:
&amp;lsquo;1970-01-01 00:00:01&amp;prime; UTC to &amp;lsquo;2038-01-19 03:14:07&amp;prime; UTC
DATETIME supported range:
&amp;lsquo;1000-01-01 00:00:00&amp;prime; to &amp;lsquo;9999-12-31 23:59:59&amp;prime;</source>
          <target state="translated">Rango admitido por TIMESTAMP: '1970-01-01 00:00:01' UTC a '2038-01-19 03:14:07' UTC DATETIME rango admitido: '1000-01-01 00:00:00' a '9999 -12-31 23:59:59 &amp;prime;</target>
        </trans-unit>
        <trans-unit id="1e8cfe79f87e9cf415a34e5da6160ec0183062d4" translate="yes" xml:space="preserve">
          <source>TIMESTAMP used to track changes to records, and update every time when the record is changed.
DATETIME used to store specific and static value which is not affected by any changes in records.</source>
          <target state="translated">TIMESTAMP se utiliza para rastrear los cambios en los registros,y actualizar cada vez que se cambia el registro.DATETIME utilizado para almacenar un valor específico y estático que no se ve afectado por ningún cambio en los registros.</target>
        </trans-unit>
        <trans-unit id="f5f7ca32f1c995965b4caae3c7b57bf8c446174e" translate="yes" xml:space="preserve">
          <source>The DATETIME type is used when you need values that contain both date and time information. MySQL retrieves and displays DATETIME values in &amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo; format. The supported range is &amp;rsquo;1000-01-01 00:00:00&amp;prime; to &amp;rsquo;9999-12-31 23:59:59&amp;prime;.</source>
          <target state="translated">El tipo DATETIME se usa cuando necesita valores que contienen informaci&amp;oacute;n de fecha y hora. MySQL recupera y muestra los valores DATETIME en formato 'AAAA-MM-DD HH: MM: SS'. El rango admitido es '1000-01-01 00:00:00' a '9999-12-31 23:59:59'.</target>
        </trans-unit>
        <trans-unit id="d995c3fc457d2a486d56301383483a0c59cd6c55" translate="yes" xml:space="preserve">
          <source>The DATETIME type is used when you need values that contain both date and time information. MySQL retrieves and displays DATETIME values in 'YYYY-MM-DD HH:MM:SS' format. The supported range is '1000-01-01 00:00:00' to '9999-12-31 23:59:59'.</source>
          <target state="translated">El tipo DATETIME se utiliza cuando se necesitan valores que contengan información tanto de fecha como de hora.MySQL recupera y muestra los valores de DATETIME en formato 'YYYY-MM-DD HH:MM:SS'.El rango soportado es de '1000-01-01 00:00:00' a '9999-12-31 23:59:59'.</target>
        </trans-unit>
        <trans-unit id="d1d182272c9e749c480b203f44a7403a8e892e56" translate="yes" xml:space="preserve">
          <source>The TIMESTAMP data type has a range of &amp;rsquo;1970-01-01 00:00:01&amp;prime; UTC to &amp;rsquo;2038-01-09 03:14:07&amp;prime; UTC. It has varying properties, depending on the MySQL version and the SQL mode the server is running in.</source>
          <target state="translated">El tipo de datos TIMESTAMP tiene un rango de '1970-01-01 00:00:01' UTC a '2038-01-09 03:14:07' UTC. Tiene diferentes propiedades, seg&amp;uacute;n la versi&amp;oacute;n de MySQL y el modo SQL en el que se ejecuta el servidor.</target>
        </trans-unit>
        <trans-unit id="451a1b7a95752b8704aa14620a0ff8e1af0081b8" translate="yes" xml:space="preserve">
          <source>The TIMESTAMP data type has a range of '1970-01-01 00:00:01' UTC to '2038-01-09 03:14:07' UTC. It has varying properties, depending on the MySQL version and the SQL mode the server is running in.</source>
          <target state="translated">El tipo de datos de TIMESTAMP tiene un rango de '1970-01-01 00:00:01' UTC a '2038-01-09 03:14:07' UTC.Tiene varias propiedades,dependiendo de la versión de MySQL y el modo SQL en el que se ejecuta el servidor.</target>
        </trans-unit>
        <trans-unit id="5dbacf6cd847f9d41776bc72041128127e5dd977" translate="yes" xml:space="preserve">
          <source>The below examples show how the &lt;code&gt;TIMESTAMP&lt;/code&gt; date type changed the values after changing the &lt;code&gt;time-zone to 'america/new_york'&lt;/code&gt; where &lt;code&gt;DATETIME&lt;/code&gt;is unchanged.</source>
          <target state="translated">Los siguientes ejemplos muestran c&amp;oacute;mo el tipo de fecha &lt;code&gt;TIMESTAMP&lt;/code&gt; cambi&amp;oacute; los valores despu&amp;eacute;s de cambiar la &lt;code&gt;time-zone to 'america/new_york'&lt;/code&gt; donde &lt;code&gt;DATETIME&lt;/code&gt; no cambia.</target>
        </trans-unit>
        <trans-unit id="6e0ed57105ef0f58a736d7ff36ae9c629f9e488a" translate="yes" xml:space="preserve">
          <source>The main difference is that DATETIME is constant while TIMESTAMP is affected by the &lt;code&gt;time_zone&lt;/code&gt; setting.</source>
          <target state="translated">La principal diferencia es que DATETIME es constante mientras que TIMESTAMP se ve afectado por la configuraci&amp;oacute;n de &lt;code&gt;time_zone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2f50d2734b460f0fadb92162062e81c8ec1ffbb" translate="yes" xml:space="preserve">
          <source>The major difference is</source>
          <target state="translated">La mayor diferencia es</target>
        </trans-unit>
        <trans-unit id="c26db8d70224fe926b15eb61a7302596d74d511e" translate="yes" xml:space="preserve">
          <source>The timestamp data type stores date and time, but in UTC format, not in the current timezone format as datetime does. And when you fetch data, timestamp again converts that into the current timezone time.</source>
          <target state="translated">El tipo de datos de marca de tiempo almacena la fecha y la hora,pero en formato UTC,no en el formato de zona horaria actual como lo hace la fecha y la hora.Y cuando buscas datos,el sello de tiempo vuelve a convertirlo en la hora de la zona horaria actual.</target>
        </trans-unit>
        <trans-unit id="cf32d1d08b4bc2bc4010812ed8c9ae1f696d2151" translate="yes" xml:space="preserve">
          <source>Third-party tool integration.  By using an integer, it's trivial for 3rd party tools (e.g. EclipseLink) to interface with the database.  Not every third-party tool is going to have the same understanding of a &quot;datetime&quot; as MySQL does.  Want to try and figure out in Hibernate whether you should use a java.sql.TimeStamp or java.util.Date object if you're using these custom data types?  Using your base data types make's use with 3rd-party tools trivial.</source>
          <target state="translated">Integración de herramientas de terceros.Al utilizar un número entero,es trivial que las herramientas de terceros (por ejemplo,EclipseLink)se conecten a la base de datos.No todas las herramientas de terceros van a tener el mismo entendimiento de una &quot;fecha-hora&quot; como lo tiene MySQL.¿Quieres intentar averiguar en Hibernación si debes usar un objeto java.sql.TimeStamp o java.util.Date si estás usando estos tipos de datos personalizados? Usar los tipos de datos de tu base hace que el uso con herramientas de terceros sea trivial.</target>
        </trans-unit>
        <trans-unit id="10c80400b73324c73575938e491d735cda350d3b" translate="yes" xml:space="preserve">
          <source>This issue is closely related how you should store a money value (i.e. $1.99) in a database.  Should you use a Decimal, or the database's Money type, or worst of all a Double? All 3 of these options are terrible, for many of the same reasons listed above.  The solution is to store the value of money in cents using BIGINT, and then convert cents to dollars when you display the value to the user.  The database's job is to store data, and NOT to intrepret that data.  All these fancy data-types you see in databases(especially Oracle) add little, and start you down the road to vendor lock-in.</source>
          <target state="translated">Este tema está estrechamente relacionado con la forma en que se debe almacenar un valor monetario (es decir,1,99 dólares)en una base de datos.¿Debería usar un decimal,o el tipo de dinero de la base de datos,o peor aún un doble? Las tres opciones son terribles,por muchas de las mismas razones mencionadas anteriormente.La solución es almacenar el valor del dinero en centavos usando BIGINT,y luego convertir los centavos en dólares cuando se muestra el valor al usuario.El trabajo de la base de datos es almacenar los datos,y NO interpretar esos datos.Todos estos tipos de datos de lujo que se ven en las bases de datos (especialmente en Oracle)añaden poco,y te inician en el camino hacia el bloqueo de los vendedores.</target>
        </trans-unit>
        <trans-unit id="7209c28d9c054e86435df0e23a3343e8a1f40ced" translate="yes" xml:space="preserve">
          <source>This will update the time at each instance you modify a row and is sometimes very helpful for stored last edit information. This only works with timestamp, not datetime however.</source>
          <target state="translated">Esto actualizará la hora en cada instancia en la que modificas una fila y a veces es muy útil para almacenar la última información editada.Sin embargo,esto sólo funciona con la marca de tiempo,no con la hora de la fecha.</target>
        </trans-unit>
        <trans-unit id="04cfc0761251068bf684bad9ba6e3db23f02b537" translate="yes" xml:space="preserve">
          <source>Timestamps are also lighter on the database and indexed faster.</source>
          <target state="translated">Las marcas de tiempo también son más ligeras en la base de datos y se indexan más rápido.</target>
        </trans-unit>
        <trans-unit id="39b7c7fd16c84befdb2fbc7842a2f1b007beb800" translate="yes" xml:space="preserve">
          <source>Timestamps in MySQL are generally used to track changes to records, and are often updated every time the record is changed. If you want to store a specific value you should use a datetime field.</source>
          <target state="translated">Las marcas de tiempo en MySQL se utilizan generalmente para rastrear los cambios en los registros,y a menudo se actualizan cada vez que se cambia el registro.Si desea almacenar un valor específico,debe utilizar un campo de fecha y hora.</target>
        </trans-unit>
        <trans-unit id="0cdbc16fb39ccae8f270c66140498641e37ffbff" translate="yes" xml:space="preserve">
          <source>To get the current Unix timestamp in PHP, just do &lt;code&gt;time();&lt;/code&gt;</source>
          <target state="translated">Para obtener la marca de tiempo actual de Unix en PHP, solo haga &lt;code&gt;time();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cd063cd0d9b6c24ab996012840118b6a4b97e0b" translate="yes" xml:space="preserve">
          <source>Using datetimes without the timezone means that your application is dealing with only 1 timezone, however timestamps give you the benefits of &lt;code&gt;datetime&lt;/code&gt; plus the flexibility of showing the same exact point of time in different timezones.</source>
          <target state="translated">El uso de la fecha y hora sin la zona horaria significa que su aplicaci&amp;oacute;n solo tiene 1 zona horaria, sin embargo, las marcas de tiempo le brindan los beneficios de la &lt;code&gt;datetime&lt;/code&gt; y la flexibilidad de mostrar el mismo punto exacto en diferentes zonas horarias.</target>
        </trans-unit>
        <trans-unit id="6679d8851bfecb41edd8ddf8dff3f76a03f04b74" translate="yes" xml:space="preserve">
          <source>What the right one is depends entirely on what you want to do.</source>
          <target state="translated">Lo que es correcto depende enteramente de lo que quieras hacer.</target>
        </trans-unit>
        <trans-unit id="15e16ae2b3038140af7aae3650d4e538db2056d5" translate="yes" xml:space="preserve">
          <source>When you ask what is the time ? and the answer comes as something like '2019-02-05 21:18:30', that is not completed, not defined answer because it lacks another part, in which timezone  ? Washington ? Moscow ? Beijing ?</source>
          <target state="translated">Cuando preguntas qué hora es? y la respuesta viene como algo como '2019-02-05 21:18:30',eso no se completa,no se define la respuesta porque le falta otra parte,en qué zona horaria? ¿Washington? ¿Moscú? ¿Pekín?</target>
        </trans-unit>
        <trans-unit id="0b3ff16b336587556b1fa0fdb27cf08aee358bed" translate="yes" xml:space="preserve">
          <source>Would you recommend using a &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;datetime&lt;/a&gt; or a &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;timestamp&lt;/a&gt; field, and why (using MySQL)?</source>
          <target state="translated">&amp;iquest;Recomendar&amp;iacute;a usar un campo de &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;fecha&lt;/a&gt; y hora o una &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;marca de tiempo&lt;/a&gt; , y por qu&amp;eacute; (usando MySQL)?</target>
        </trans-unit>
        <trans-unit id="99ccf3adb5db0d31246743ae82d394360ce5b265" translate="yes" xml:space="preserve">
          <source>You avoid vendor lock-in.  Pretty much every database supports integers in the relatively similar fashion.  Suppose you want to move to another database.  Do you want to worry about the differences between MySQL's DATETIME values and how Oracle defines them?  Even among different versions of MySQL, TIMESTAMPS have a different level of precision.  It was only just recently that MySQL supported milliseconds in the timestamps.</source>
          <target state="translated">Evitas el encierro de los vendedores.Casi todas las bases de datos soportan números enteros de forma relativamente similar.Supongamos que quieres pasar a otra base de datos.¿Quiere preocuparse por las diferencias entre los valores de DATETIME de MySQL y cómo los define Oracle? Incluso entre las diferentes versiones de MySQL,los TIMESTAMPS tienen un nivel de precisión diferente.Sólo recientemente MySQL soportaba milisegundos en los timestamps.</target>
        </trans-unit>
        <trans-unit id="8b4895f794a8283459ca4a088274ede5b50f7a7f" translate="yes" xml:space="preserve">
          <source>You're quite likely to hit the lower limit on TIMESTAMPs in general use -- e.g. storing birthdate.</source>
          <target state="translated">Es muy probable que se llegue al límite inferior de los TIMESTAMPs de uso general-por ejemplo,almacenar la fecha de nacimiento.</target>
        </trans-unit>
        <trans-unit id="fe7b915adc41c235ae2019a5d63666bcb6f784aa" translate="yes" xml:space="preserve">
          <source>a INDEX's on Datetime   - &lt;a href=&quot;https://stackoverflow.com/questions/4013301/mysql-datetime-index-is-not-working&quot;&gt;Does not work&lt;/a&gt;</source>
          <target state="translated">un &amp;Iacute;NDICE sobre fecha y hora: &lt;a href=&quot;https://stackoverflow.com/questions/4013301/mysql-datetime-index-is-not-working&quot;&gt;no funciona&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c058c66e16779f3e5d87b80818f4e54711ee832a" translate="yes" xml:space="preserve">
          <source>a INDEX's on Timestamp  - works</source>
          <target state="translated">un índice de la marca de tiempo-funciona</target>
        </trans-unit>
        <trans-unit id="14c88ff2f0e7f0d7d01802892756e11f40be03b1" translate="yes" xml:space="preserve">
          <source>and in MySQL do &lt;code&gt;SELECT UNIX_TIMESTAMP();&lt;/code&gt;.</source>
          <target state="translated">y en MySQL hacer &lt;code&gt;SELECT UNIX_TIMESTAMP();&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bef63f4643b53c0e6c20553bb1f0543b403021b5" translate="yes" xml:space="preserve">
          <source>easy migrations between time zones</source>
          <target state="translated">migraciones fáciles entre zonas horarias</target>
        </trans-unit>
        <trans-unit id="7ae8438fcf4f03e1bbb55d35dceda8efa0bd317f" translate="yes" xml:space="preserve">
          <source>look at this &lt;a href=&quot;https://stackoverflow.com/questions/95183/how-does-one-create-an-index-on-the-date-part-of-datetime-field-in-mysql&quot;&gt;post to see problems with Datetime indexing&lt;/a&gt;</source>
          <target state="translated">mira esta &lt;a href=&quot;https://stackoverflow.com/questions/95183/how-does-one-create-an-index-on-the-date-part-of-datetime-field-in-mysql&quot;&gt;publicaci&amp;oacute;n para ver problemas con la indexaci&amp;oacute;n de fecha y hora&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="944e5c03bdda873f2d9a030910c0d94089a1d341" translate="yes" xml:space="preserve">
          <source>no worry about dates in/out a summer time period</source>
          <target state="translated">no se preocupe por las fechas en un período de tiempo de verano</target>
        </trans-unit>
        <trans-unit id="68c2634f494de50ae1701c5c57288cb89cec17cd" translate="yes" xml:space="preserve">
          <source>pretty easy to calculate diferences (just subtract both timestamps)</source>
          <target state="translated">bastante fácil de calcular las diferencias (sólo hay que restar las dos marcas de tiempo)</target>
        </trans-unit>
        <trans-unit id="d38547cfd2b4a24917f0893ead653bf6ef1602f3" translate="yes" xml:space="preserve">
          <source>ready to use on international (multi time zone) apps</source>
          <target state="translated">listo para su uso en aplicaciones internacionales (multizona horaria)</target>
        </trans-unit>
        <trans-unit id="18f605dfe1380d283d7c7607e5798ee1e187bbce" translate="yes" xml:space="preserve">
          <source>then every single value in your 'Date_Added' column would be changed to the current timestamp.</source>
          <target state="translated">entonces cada valor de la columna &quot;Fecha_Añadida&quot; se cambiaría a la marca de tiempo actual.</target>
        </trans-unit>
        <trans-unit id="9b99af1d5f813e03b16069c39a0d4de32de49280" translate="yes" xml:space="preserve">
          <source>you accept data from different clients around the world, each of them inserts the time in his timezone.</source>
          <target state="translated">aceptas datos de diferentes clientes alrededor del mundo,cada uno de ellos inserta la hora en su zona horaria.</target>
        </trans-unit>
        <trans-unit id="a1900144dd02e0b44d98690cdbca12f939cbf4a9" translate="yes" xml:space="preserve">
          <source>you changed the country you stay in, and continue your work of maintaining the data while seeing it in a different timezone (without changing the actual data).</source>
          <target state="translated">cambiaste el país en el que te encuentras,y continuas tu trabajo de mantener los datos mientras los ves en una zona horaria diferente (sin cambiar los datos reales).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
