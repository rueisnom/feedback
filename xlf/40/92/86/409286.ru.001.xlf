<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/409286">
    <body>
      <group id="409286">
        <trans-unit id="593a02a118c1f362caa2e58db6d6664e3f576b7f" translate="yes" xml:space="preserve">
          <source>(Unless you are likely to change the timezone of your servers)</source>
          <target state="translated">(Если только вы,скорее всего,не измените часовой пояс ваших серверов).</target>
        </trans-unit>
        <trans-unit id="d27bbad1be4b90f3efb7c75a4b43f6fa388fae5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;datetime&lt;/code&gt; = application supports 1 timezone (for both inserting and selecting)</source>
          <target state="translated">&lt;code&gt;datetime&lt;/code&gt; = приложение поддерживает 1 часовой пояс (как для вставки, так и для выбора)</target>
        </trans-unit>
        <trans-unit id="20905d1d1b479330793c32af9ed0fa9beb9adb03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; = application supports any timezone (for both inserting and selecting)</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; = приложение поддерживает любой часовой пояс (как для вставки, так и для выбора)</target>
        </trans-unit>
        <trans-unit id="349a08ae5d6ed4659b0bcd3ec7c70e280bab22c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;2016 +&lt;/em&gt;: what I advise is to set your Mysql timezone to UTC and use DATETIME:</source>
          <target state="translated">&lt;em&gt;2016 +&lt;/em&gt; : я советую установить часовой пояс Mysql на UTC и использовать DATETIME:</target>
        </trans-unit>
        <trans-unit id="331d547d2d77f302ef10428b2a9addf2ef86e968" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This answer is only for putting some highlight on the flexibility and ease of timestamps when it comes to time zones , it is not covering any other differences like the &lt;a href=&quot;https://stackoverflow.com/a/45632196/5407848&quot;&gt;column size or range or fraction&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Этот ответ только для того, чтобы подчеркнуть гибкость и простоту временных отметок, когда речь идет о часовых поясах, он не охватывает никаких других различий, таких как &lt;a href=&quot;https://stackoverflow.com/a/45632196/5407848&quot;&gt;размер столбца, диапазон или дробь&lt;/a&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8d39d205db25f2106a7af756b95fdfef76c9718" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The main differences:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Основные отличия:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34da79ccaf9b8c0d6c96a398c7de54c386c7c5d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is that [.fraction]?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что это [.fraction]?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ccacfe5d1464a272d0161bc29e81b58fd87fa55" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TIMESTAMP&lt;/code&gt; requires 4 bytes, whereas a &lt;code&gt;DATETIME&lt;/code&gt; requires 8 bytes.</source>
          <target state="translated">&lt;code&gt;TIMESTAMP&lt;/code&gt; требует 4 байта, тогда как &lt;code&gt;DATETIME&lt;/code&gt; требует 8 байтов.</target>
        </trans-unit>
        <trans-unit id="6f86f9e143c43e826773e4340f28d06abfa21196" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;timestamp&lt;/code&gt; field is a special case of the &lt;code&gt;datetime&lt;/code&gt; field. You can create &lt;code&gt;timestamp&lt;/code&gt; columns to have special properties; it can be set to update itself on either create and/or update.</source>
          <target state="translated">Поле &lt;code&gt;timestamp&lt;/code&gt; является частным случаем поля &lt;code&gt;datetime&lt;/code&gt; . Вы можете создавать столбцы &lt;code&gt;timestamp&lt;/code&gt; чтобы иметь специальные свойства; это может быть установлено, чтобы обновить себя или создать и / или обновить.</target>
        </trans-unit>
        <trans-unit id="23afe721d17e7bce6561ecac0c0767557c18f3e2" translate="yes" xml:space="preserve">
          <source>A DATETIME or TIMESTAMP value can include a trailing fractional
seconds part in up to microseconds (6 digits) precision. In
particular, any fractional part in a value inserted into a DATETIME
or TIMESTAMP column is stored rather than discarded. This is of course optional.</source>
          <target state="translated">Значение DATETIME (ВРЕМЯ ДАТЫ)или TIMESTAMP (ВРЕМЯ УСТАНОВКИ)может включать в себя часть,измеряемую в дробных секундах с точностью до микросекунд (6 цифр).В частности,любая дробная часть в значении,вставленном в столбец ВРЕМЯ ДАТЫ или ВРЕМЕНИ,сохраняется,а не выбрасывается.Это,конечно,необязательно.</target>
        </trans-unit>
        <trans-unit id="105e72149319d74d06cd9e179968cd6895c674de" translate="yes" xml:space="preserve">
          <source>A great example of DATETIME being used where TIMESTAMP should have been used is in Facebook, where their servers are never quite sure what time stuff happened across time zones. Once I was having a conversation in which the time said I was replying to messages before the message was actually sent. (This, of course, could also have been caused by bad time zone translation in the messaging software if the times were being posted rather than synchronized.)</source>
          <target state="translated">Отличный пример использования DATETIME,где должен был использоваться TIMESTAMP,-в Facebook,где их серверы никогда не уверены в том,что случилось во времени в часовых поясах.Однажды у меня был разговор,в котором время говорило,что я отвечал на сообщения до того,как они действительно были отправлены.(Это,конечно,также могло быть вызвано плохим переводом через часовой пояс в программном обеспечении для обмена сообщениями,если бы время не синхронизировалось).</target>
        </trans-unit>
        <trans-unit id="ac1d2a76e849b1b5833ee66f2036219c73ed4239" translate="yes" xml:space="preserve">
          <source>Additionally:</source>
          <target state="translated">Additionally:</target>
        </trans-unit>
        <trans-unit id="a1f945cbe8c29cec65da8e8eab6c4e28b4f16229" translate="yes" xml:space="preserve">
          <source>All localised time format available here:
&lt;a href=&quot;https://docs.angularjs.org/api/ng/filter/date&quot;&gt;https://docs.angularjs.org/api/ng/filter/date&lt;/a&gt;</source>
          <target state="translated">Весь локализованный формат времени доступен здесь: &lt;a href=&quot;https://docs.angularjs.org/api/ng/filter/date&quot;&gt;https://docs.angularjs.org/api/ng/filter/date&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="03f4ab0cfb5116acacf82c79980bbc4c1538ca3f" translate="yes" xml:space="preserve">
          <source>Another difference between Timestamp and Datetime is in Timestamp you can't default value to NULL.</source>
          <target state="translated">Другая разница между Timestamp и Datetime заключается в том,что в Timestamp вы не можете установить значение по умолчанию NULL.</target>
        </trans-unit>
        <trans-unit id="8649432b65d482601d32ced47b86cec528e6f13e" translate="yes" xml:space="preserve">
          <source>Another thing worth considering:</source>
          <target state="translated">Еще одна вещь,заслуживающая внимания:</target>
        </trans-unit>
        <trans-unit id="7e4bc976d9f0aa9df498da0d674146848c45e317" translate="yes" xml:space="preserve">
          <source>Any recent front-end framework (Angular 1/2, react, Vue,...) can easily and automatically convert your UTC datetime to local time.</source>
          <target state="translated">Любой современный фреймворк (Угол 12,реакция,Vue,...)может легко и автоматически конвертировать UTC-дату в местное время.</target>
        </trans-unit>
        <trans-unit id="1f02b723ecb30f7a7b86943f5693d1a105ed169a" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/datetime.html&quot;&gt;mentioned&lt;/a&gt; in the MySQL documentation:</source>
          <target state="translated">Как &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/datetime.html&quot;&gt;упомянуто&lt;/a&gt; в документации MySQL:</target>
        </trans-unit>
        <trans-unit id="30a7616be2ba7d64b9561fa7bcf55829ad69bc78" translate="yes" xml:space="preserve">
          <source>As a plus, in the case of a migration of the database to a system with another timezone, I would feel more confident using timestamps. Not to say possible issues when calculating differences between two moments with a sumer time change in between and needing a precision of 1 hour or less.</source>
          <target state="translated">В качестве плюса,в случае миграции базы данных на систему с другим часовым поясом,я бы чувствовал себя более уверенно,используя временные метки.Не говоря уже о возможных проблемах при вычислении разницы между двумя моментами с изменением времени сумеречного сдвига между ними и необходимостью точности 1 час или меньше.</target>
        </trans-unit>
        <trans-unit id="75c9379a28896ce9890676a1ef0ca87e210c0b0c" translate="yes" xml:space="preserve">
          <source>Beware of timestamp changing when you do a UPDATE statement on a table.  If you have a table with columns 'Name' (varchar), 'Age' (int), and 'Date_Added' (timestamp) and you run the following DML statement</source>
          <target state="translated">Остерегайтесь изменения временных меток,когда вы делаете оператор UPDATE на таблице.Если у вас есть таблица со столбцами 'Имя' (varchar),'Возраст' (int)и 'Дата_Добавленная' (timestamp)и вы запускаете следующий оператор DML</target>
        </trans-unit>
        <trans-unit id="048fad409fc302137354247e34dd35f44fb43704" translate="yes" xml:space="preserve">
          <source>But like scronide said it does have a lower limit of the year 1970. It's great for anything that might happen in the future though ;)</source>
          <target state="translated">Но,как сказал Скронид,у него есть нижний предел 1970 года.Хотя это здорово для всего,что может случиться в будущем ;)</target>
        </trans-unit>
        <trans-unit id="0b3bafc7f7ed6d1609b9c2c4fd043e820e24cc01" translate="yes" xml:space="preserve">
          <source>By default, the current time zone for each connection is the server's time. The time zone can be set on a per-connection basis, as described in &lt;em&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en//time-zone-support.html&quot;&gt;MySQL Server Time Zone Support&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">По умолчанию текущим часовым поясом для каждого соединения является время сервера. Часовой пояс может быть установлен для каждого соединения отдельно, как описано в &lt;em&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en//time-zone-support.html&quot;&gt;разделе Поддержка&lt;/a&gt;&lt;/em&gt; часовых поясов &lt;em&gt;MySQL Server&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="46e754d5823f336c6879ab95356aa5286d30a861" translate="yes" xml:space="preserve">
          <source>Comparison between DATETIME, TIMESTAMP and DATE</source>
          <target state="translated">Сравнение ДАТЫ,ВРЕМЕНИ и ДАТЫ</target>
        </trans-unit>
        <trans-unit id="dfa016c1ac5a15d6be12e485338468f1d8936cd6" translate="yes" xml:space="preserve">
          <source>Consider setting a timestamp by a user to a server in New York, for an appointment in Sanghai. Now when the user connects in Sanghai, he accesses the same appointment timestamp from a mirrored server in Tokyo. He will see the appointment in Tokyo time, offset from the original New York time.</source>
          <target state="translated">Рассмотрим возможность установки метки времени пользователем на сервер в Нью-Йорке для встречи в Санхае.Теперь,когда пользователь подключается в Санхае,он получает доступ к той же метке времени встречи с зеркалированного сервера в Токио.Он увидит время встречи в Токио,смещенное от первоначального времени Нью-Йорка.</target>
        </trans-unit>
        <trans-unit id="36abbe8686064b87032b977c64e9037a1ab43ae2" translate="yes" xml:space="preserve">
          <source>Contrary to what one might think, DATETIME is &lt;strong&gt;FASTER&lt;/strong&gt; THAN TIMESTAMP,
&lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&quot;&gt;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&lt;/a&gt;</source>
          <target state="translated">Вопреки тому, что можно подумать, DATETIME &lt;strong&gt;БЫСТРЕЕ,&lt;/strong&gt; ЧЕМ TIMESTAMP, &lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&quot;&gt;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with -myisam /&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cd06d5b91f44e6c7d8bb5a9e4b6c53eb080b994" translate="yes" xml:space="preserve">
          <source>DATETIME can now be &lt;strong&gt;automatically&lt;/strong&gt; set to the current time value &lt;a href=&quot;https://stackoverflow.com/questions/168736/how-do-you-set-a-default-value-for-a-mysql-datetime-column/10603198#10603198&quot;&gt;How do you set a default value for a MySQL Datetime column?&lt;/a&gt;</source>
          <target state="translated">DATETIME теперь можно &lt;strong&gt;автоматически&lt;/strong&gt; установить на текущее значение времени. &lt;a href=&quot;https://stackoverflow.com/questions/168736/how-do-you-set-a-default-value-for-a-mysql-datetime-column/10603198#10603198&quot;&gt;Как установить значение по умолчанию для столбца MySQL Datetime?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bb751509c73535fc71ab28078b2a2cd7cff076c" translate="yes" xml:space="preserve">
          <source>DATETIME is constant while TIMESTAMP is effected by the time_zone setting.</source>
          <target state="translated">ДАТЕТИКА является постоянной,в то время как ВРЕМЕННАЯ УСТАНОВКА производится установкой time_zone.</target>
        </trans-unit>
        <trans-unit id="e606ed7f8ffdfa79456bda0bab96b69794b076de" translate="yes" xml:space="preserve">
          <source>Depends on application, really.</source>
          <target state="translated">Зависит от приложения,правда.</target>
        </trans-unit>
        <trans-unit id="793dba92e4fad48f46012613b16dac7b1259878a" translate="yes" xml:space="preserve">
          <source>Example with AngularJs</source>
          <target state="translated">Пример с угловыми Js</target>
        </trans-unit>
        <trans-unit id="b632b31f3430f0f42e92741a8e59ca31ba0a5461" translate="yes" xml:space="preserve">
          <source>For all this reasons, I choose UTC &amp;amp; timestamp fields where posible. And I avoid headaches ;)</source>
          <target state="translated">По всем этим причинам я выбираю поля UTC и отметки времени, где это возможно. И я избегаю головных болей;)</target>
        </trans-unit>
        <trans-unit id="6b6dd3a87f08f57887386997d7393798f29857fa" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;user&lt;/code&gt; table with a &lt;strong&gt;REGISTRATION DATE&lt;/strong&gt; field. In that &lt;code&gt;user&lt;/code&gt; table, if you want to know the last logged in time of a particular user, go with a field of &lt;strong&gt;timestamp&lt;/strong&gt; type so that the field gets updated.</source>
          <target state="translated">Например, рассмотрим &lt;code&gt;user&lt;/code&gt; таблицу с полем &lt;strong&gt;ДАТА РЕГИСТРАЦИИ&lt;/strong&gt; . В этой &lt;code&gt;user&lt;/code&gt; таблице, если вы хотите узнать время последнего входа определенного пользователя, укажите поле типа &lt;strong&gt;отметки времени,&lt;/strong&gt; чтобы оно обновлялось.</target>
        </trans-unit>
        <trans-unit id="4911c2a3fb22efedb0166e219e1c072fdeeb59f1" translate="yes" xml:space="preserve">
          <source>For more details you can read the blog post &lt;em&gt;&lt;a href=&quot;http://codebucket.co.in/timestamp-vs-datetime/&quot;&gt;Timestamp Vs Datetime &lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Для более подробной информации вы можете прочитать в блоге &lt;em&gt;&lt;a href=&quot;http://codebucket.co.in/timestamp-vs-datetime/&quot;&gt;Timestamp Vs Datetime&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dc856e5e23919033bd72ab59467477a0e61ba03c" translate="yes" xml:space="preserve">
          <source>For your clients comfort you want to show them the times based on their preferred time zones without making them doing the math and convert the time to their meaningful timezone. all you need is to change the timezone and all your application code will be the same.&lt;em&gt;(Actually you should always define the timezone at the start of the application, or request processing in case of PHP applications)&lt;/em&gt;</source>
          <target state="translated">Для удобства ваших клиентов вы хотите показать им время в зависимости от предпочитаемых часовых поясов, не заставляя их делать математику, и переводить время в значимый часовой пояс. все, что вам нужно, это изменить часовой пояс, и все ваши коды приложений будут одинаковыми. &lt;em&gt;(На самом деле вы всегда должны определять часовой пояс в начале приложения или обработку запросов в случае PHP-приложений)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64e254cfc8fee4a9ead40861b1246312894ba70c" translate="yes" xml:space="preserve">
          <source>From my experiences, if you want a date field in which insertion happens only once and you don't want to have any update or any other action on that particular field, go with &lt;strong&gt;date time&lt;/strong&gt;.</source>
          <target state="translated">Исходя из моего опыта, если вам нужно поле даты, в которое вставка происходит только один раз, и вы не хотите обновлять или выполнять какие-либо другие действия в этом конкретном поле, выберите &lt;strong&gt;дату и время&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1dbdfeac2373ec7aa37785a932e7c4d2c25cbb" translate="yes" xml:space="preserve">
          <source>Here are some cases that will make you regret using &lt;code&gt;datetime&lt;/code&gt; and wish that you stored your data in timestamps.</source>
          <target state="translated">Вот несколько случаев, которые заставят вас сожалеть об использовании &lt;code&gt;datetime&lt;/code&gt; и времени и пожелать, чтобы вы сохранили свои данные в метках времени.</target>
        </trans-unit>
        <trans-unit id="2da35bc820a81a1cb5374406c62ccc9e358ccf59" translate="yes" xml:space="preserve">
          <source>I almost always prefer timestamps rather than datetime fields, because timestamps include the timezone implicitly. So, since the moment that the app will be accessed from users from different time zones and you want them to see dates and times in their local timezone, this field type makes it pretty easy to do it than if the data were saved in datetime fields.</source>
          <target state="translated">Я почти всегда предпочитаю метки времени,а не поля даты,потому что метки времени неявно включают часовой пояс.Итак,с того момента,как к приложению будут обращаться пользователи из разных часовых поясов,и вы хотите,чтобы они видели даты и время в своем локальном часовом поясе,этот тип поля делает это довольно простым,чем если бы данные были сохранены в полях даты.</target>
        </trans-unit>
        <trans-unit id="a5cd89f5ee8f947b442b15a5e503fefe94df935b" translate="yes" xml:space="preserve">
          <source>I always use DATETIME fields for anything other than row metadata (date created or modified).</source>
          <target state="translated">Я всегда использую поля DATETIME для чего-либо,кроме метаданных строк (дата создания или изменения).</target>
        </trans-unit>
        <trans-unit id="a678e945f8d1f6465d392193c4faf6646c4cece9" translate="yes" xml:space="preserve">
          <source>I always use a Unix timestamp, simply to maintain sanity when dealing with a lot of datetime information, especially when performing adjustments for timezones, adding/subtracting dates, and the like. When comparing timestamps, this excludes the complicating factors of timezone and allows you to spare resources in your server side processing (Whether it be application code or database queries) in that you make use of light weight arithmetic rather then heavier date-time add/subtract functions.</source>
          <target state="translated">Я всегда использую временную метку Unix,просто для поддержания здравого смысла при работе с большим количеством информации о дате,особенно при выполнении корректировок для часовых поясов,суммировании дат и т.п.При сравнении меток времени это исключает усложняющие факторы часового пояса и позволяет вам экономить ресурсы при обработке серверной стороны (будь то код приложения или запросы к базе данных)в том,что вы используете легкую арифметику,а не более тяжелые функции вычитания даты и времени.</target>
        </trans-unit>
        <trans-unit id="206c1f2009ec676fc4a9eec50d54024944901e95" translate="yes" xml:space="preserve">
          <source>I found unsurpassed usefulness in TIMESTAMP's ability to auto update itself based on the current time without the use of unnecessary triggers. That's just me though, although TIMESTAMP is UTC like it was said.</source>
          <target state="translated">Я нашел непревзойденную полезность в возможности TIMESTAMP автоматически обновлять себя на основе текущего времени без использования ненужных триггеров.Однако,это только я,хотя TIMESTAMP-это UTC,как и было сказано.</target>
        </trans-unit>
        <trans-unit id="d570a1bc95ba8702c39af942cff99df7742bb2be" translate="yes" xml:space="preserve">
          <source>I like a Unix timestamp, because you can convert to numbers and just worry about the number. Plus you add/subtract and get durations, etc. Then convert the result to Date in whatever format. This code finds out how much time in minutes passed between a timestamp from a document, and the current time.</source>
          <target state="translated">Мне нравится Unix-тампа времени,потому что вы можете преобразовывать в числа и просто беспокоиться о номере.Плюс к этому,вы можете производить сложение,получать длительность и т.д.Затем конвертируете результат в Date в любом формате.Этот код узнает,сколько времени в минутах прошло между отметкой времени из документа и текущим временем.</target>
        </trans-unit>
        <trans-unit id="cf4a40b7b0f9f34fbb16456724075a43d2ce0f45" translate="yes" xml:space="preserve">
          <source>I make this decision on a semantic base.</source>
          <target state="translated">Я принимаю это решение на семантической основе.</target>
        </trans-unit>
        <trans-unit id="5ef7e671798c6131c697e0f63b12c62ab2bfa381" translate="yes" xml:space="preserve">
          <source>I prefer using timestamp so to keep everything in one common raw format and format the data in PHP code or in your SQL query. There are instances where it comes in handy in your code to keep everything in plain seconds.</source>
          <target state="translated">Я предпочитаю использовать метку времени,чтобы сохранить все в одном общем необработанном формате и отформатировать данные в PHP-коде или в вашем SQL-запросе.Есть случаи,когда пригодится в вашем коде,чтобы все хранить в считанные секунды.</target>
        </trans-unit>
        <trans-unit id="e23b06243c6572b6cfb0e3cffcf474b9fa8522b8" translate="yes" xml:space="preserve">
          <source>I recommend using &lt;strong&gt;neither&lt;/strong&gt; a DATETIME or a TIMESTAMP field.  If you want to represent a specific day as a whole (like a birthday), then use a DATE type, but if you're being more specific than that, you're probably interested in recording an actual moment as opposed to a unit of time (day,week,month,year).  Instead of using a DATETIME or TIMESTAMP, use a BIGINT, and simply store the number of milliseconds since the epoch (System.currentTimeMillis() if you're using Java).  This has several advantages:</source>
          <target state="translated">Я рекомендую использовать &lt;strong&gt;ни&lt;/strong&gt; поле DATETIME, ни поле TIMESTAMP. Если вы хотите представить конкретный день в целом (например, день рождения), тогда используйте тип DATE, но если вы более конкретны, вам, вероятно, будет интересно записать фактический момент, а не единицу измерения. время (день, неделя, месяц, год). Вместо использования DATETIME или TIMESTAMP, используйте BIGINT и просто сохраняйте количество миллисекунд с начала эпохи (System.currentTimeMillis (), если вы используете Java). Это имеет несколько преимуществ:</target>
        </trans-unit>
        <trans-unit id="32b22a379070f7ef416fd882ae9907f4cafcabff" translate="yes" xml:space="preserve">
          <source>I stopped using &lt;code&gt;datetime&lt;/code&gt; in my applications after facing many problems and bugs related to time zones. &lt;strong&gt;IMHO using &lt;code&gt;timestamp&lt;/code&gt; is better than &lt;code&gt;datetime&lt;/code&gt; in most of the cases&lt;/strong&gt;.</source>
          <target state="translated">Я перестал использовать &lt;code&gt;datetime&lt;/code&gt; в своих приложениях после того, как столкнулся со многими проблемами и ошибками, связанными с часовыми поясами. &lt;strong&gt;ИМХО в большинстве случаев использовать &lt;code&gt;timestamp&lt;/code&gt; лучше, чем &lt;code&gt;datetime&lt;/code&gt; время&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3e0f03321593d604ad3daae773b9b9de690bc1" translate="yes" xml:space="preserve">
          <source>I use a datetime field when the date/time can be set and changed arbitrarily. For example when a user can save later change appointments.</source>
          <target state="translated">Я использую поле даты,когда дата может быть установлена и изменена произвольно.Например,когда пользователь может сохранить позднее измененное время.</target>
        </trans-unit>
        <trans-unit id="8b5833e1a61fb755b21f93ca6d1707ba3c9eb38b" translate="yes" xml:space="preserve">
          <source>I use a timestamp when I need to record a (more or less) fixed point in time. For example when a record was inserted into the database or when some user action took place.</source>
          <target state="translated">Я использую временную метку,когда мне нужно записать (более или менее)фиксированную точку во времени.Например,когда запись была вставлена в БД или когда произошло какое-либо действие пользователя.</target>
        </trans-unit>
        <trans-unit id="f86d1b7817db590f627374a0bcb90e6b5ff9a671" translate="yes" xml:space="preserve">
          <source>I would always use a Unix timestamp when working with MySQL and PHP. The main reason for this being the the default &lt;a href=&quot;http://uk3.php.net/manual/en/function.date.php&quot;&gt;date&lt;/a&gt; method in PHP uses a timestamp as the parameter, so there would be no parsing needed.</source>
          <target state="translated">Я всегда использовал бы метку времени Unix при работе с MySQL и PHP. Основной причиной этого является то, что метод &lt;a href=&quot;http://uk3.php.net/manual/en/function.date.php&quot;&gt;даты&lt;/a&gt; по умолчанию в PHP использует метку времени в качестве параметра, поэтому анализ не требуется.</target>
        </trans-unit>
        <trans-unit id="e9364c12edb1f9c9f5ec70d22a2e2dd682193867" translate="yes" xml:space="preserve">
          <source>I'm working with PHP on the server side.</source>
          <target state="translated">Я работаю с PHP на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="a45ff0bb3a329fa67ebd8832f5d0546cb7f2251d" translate="yes" xml:space="preserve">
          <source>I've converted my answer into article so more people can find this useful, &lt;em&gt;&lt;a href=&quot;http://www.tech-recipes.com/rx/22599/mysql-datetime-vs-timestamp-data-type/&quot;&gt;MySQL: Datetime Versus Timestamp Data Types&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Я преобразовал свой ответ в статью, чтобы больше людей могли найти это полезным, &lt;em&gt;&lt;a href=&quot;http://www.tech-recipes.com/rx/22599/mysql-datetime-vs-timestamp-data-type/&quot;&gt;MySQL: типы данных Datetime и Timestamp&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="31489a4469658ad39dd5d8120b54ba1d823877db" translate="yes" xml:space="preserve">
          <source>If you are creating the table from &lt;a href=&quot;http://en.wikipedia.org/wiki/PhpMyAdmin&quot;&gt;phpMyAdmin&lt;/a&gt; the default setting will update the &lt;strong&gt;timestamp&lt;/strong&gt; field when a row update happens. If your timestamp filed is not updating with row update, you can use the following query to make a &lt;strong&gt;timestamp&lt;/strong&gt; field get auto updated.</source>
          <target state="translated">Если вы создаете таблицу из &lt;a href=&quot;http://en.wikipedia.org/wiki/PhpMyAdmin&quot;&gt;phpMyAdmin,&lt;/a&gt; настройка по умолчанию обновит поле &lt;strong&gt;метки времени,&lt;/strong&gt; когда произойдет обновление строки. Если ваше поле с &lt;strong&gt;отметкой&lt;/strong&gt; времени не обновляется с обновлением строки, вы можете использовать следующий запрос, чтобы поле &lt;strong&gt;отметки времени&lt;/strong&gt; автоматически обновлялось.</target>
        </trans-unit>
        <trans-unit id="9b1bb522d65d67e7cdbb1d7601b2e95f9a523514" translate="yes" xml:space="preserve">
          <source>If you meant that you want to decide between using a UNIX timestamp or a native MySQL datetime field, go with the native format. You can do calculations within MySQL that way 
&lt;code&gt;(&quot;SELECT DATE_ADD(my_datetime, INTERVAL 1 DAY)&quot;)&lt;/code&gt; and it is simple to change the format of the value to a UNIX timestamp &lt;code&gt;(&quot;SELECT UNIX_TIMESTAMP(my_datetime)&quot;)&lt;/code&gt; when you query the record if you want to operate on it with PHP.</source>
          <target state="translated">Если вы имели в виду, что хотите выбрать между использованием метки времени UNIX или собственного поля даты и времени MySQL, перейдите к собственному формату. Вы можете выполнять вычисления в MySQL таким образом &lt;code&gt;(&quot;SELECT DATE_ADD(my_datetime, INTERVAL 1 DAY)&quot;)&lt;/code&gt; и просто изменить формат значения на метку времени UNIX &lt;code&gt;(&quot;SELECT UNIX_TIMESTAMP(my_datetime)&quot;)&lt;/code&gt; когда вы запрашиваете запись если вы хотите работать с ним с помощью PHP.</target>
        </trans-unit>
        <trans-unit id="ffcc29ae487aa623bebb0ee1e8f86561c675d52d" translate="yes" xml:space="preserve">
          <source>If you're building an application, you never know how your data might have to be used down the line. If you wind up having to, say, compare a bunch of records in your data set, with, say, a bunch of items from a third-party API, and say, put them in chronological order, you'll be happy to have Unix timestamps for your rows. Even if you decide to use MySQL timestamps, store a Unix timestamp as insurance.</source>
          <target state="translated">Если вы создаете приложение,никогда не знаешь,как ваши данные могут быть использованы в дальнейшем.Если вам,скажем,придется сравнить кучу записей в вашем наборе данных с,скажем,кучей элементов из стороннего API,и,скажем,расположить их в хронологическом порядке,то вы будете рады иметь метки времени Unix для ваших строк.Даже если вы решите использовать метки времени MySQL,храните их Unix как страховку.</target>
        </trans-unit>
        <trans-unit id="c7995d4761522909b7214e1601ee4a9bbe7b4a1f" translate="yes" xml:space="preserve">
          <source>In &quot;bigger&quot; database terms, &lt;code&gt;timestamp&lt;/code&gt; has a couple of special-case triggers on it.</source>
          <target state="translated">В &amp;laquo;больших&amp;raquo; терминах базы данных &lt;code&gt;timestamp&lt;/code&gt; содержит пару триггеров особого случая.</target>
        </trans-unit>
        <trans-unit id="2b0d5700a614a6da306f30adf05aaca5b64dbbf1" translate="yes" xml:space="preserve">
          <source>In MySQL 5 and above, &lt;strong&gt;TIMESTAMP&lt;/strong&gt; values are converted from the current time zone to UTC for storage, and converted back from UTC to the current time zone for retrieval. (This occurs only for the TIMESTAMP data type, and &lt;em&gt;not&lt;/em&gt; for other types such as DATETIME.)</source>
          <target state="translated">В MySQL 5 и выше значения &lt;strong&gt;TIMESTAMP&lt;/strong&gt; преобразуются из текущего часового пояса в UTC для хранения и преобразуются обратно из UTC в текущий часовой пояс для извлечения. (Это происходит только для типа данных TIMESTAMP, а &lt;em&gt;не&lt;/em&gt; для других типов, таких как DATETIME.)</target>
        </trans-unit>
        <trans-unit id="6e195894f50db5526afc2ab1bf4e1d5658cbea95" translate="yes" xml:space="preserve">
          <source>In my case, I set UTC as a time zone for everything: the system, the database server, etc. every time that I can. If my customer requires another time zone, then I configure it on the app.</source>
          <target state="translated">В моем случае я устанавливаю UTC в качестве часового пояса для всего:системы,сервера базы данных и т.д.каждый раз,когда могу.Если моему клиенту требуется другой часовой пояс,то я настраиваю его в приложении.</target>
        </trans-unit>
        <trans-unit id="7b0a223418a395464ae8da509f57c18c6c1d324c" translate="yes" xml:space="preserve">
          <source>In short</source>
          <target state="translated">Короче говоря</target>
        </trans-unit>
        <trans-unit id="998430940a1cf51fc5ec051819a568638be1a42b" translate="yes" xml:space="preserve">
          <source>In simpler words: &lt;strong&gt;If I have a database in Australia, and take a dump of that database to synchronize/populate a database in America, then the TIMESTAMP would update to reflect the real time of the event in the new time zone, while DATETIME would still reflect the time of the event in the au time zone&lt;/strong&gt;.</source>
          <target state="translated">Проще говоря: &lt;strong&gt;если у меня есть база данных в Австралии, и я сделаю дамп этой базы данных для синхронизации / заполнения базы данных в Америке, TIMESTAMP обновится, чтобы отразить реальное время события в новом часовом поясе, в то время как DATETIME будет по-прежнему отражать время события в часовом поясе au&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="880e081828ff1887a05d731a268374d23ecff5d5" translate="yes" xml:space="preserve">
          <source>It can keep track across different timezones, so if you need to display a relative time for instance, UTC time is what you would want.</source>
          <target state="translated">Он может отслеживать различные часовые пояса,так что если вам нужно отобразить относительное время,например,UTC время-это то,что вы хотели бы.</target>
        </trans-unit>
        <trans-unit id="a41918ecbc3f538d35b22cc423624607a058a62e" translate="yes" xml:space="preserve">
          <source>It is worth noting in MySQL you can use something along the lines of the below when creating your table columns:</source>
          <target state="translated">Стоит отметить,что в MySQL при создании столбцов таблицы вы можете использовать что-нибудь из ряда вон выходящее:</target>
        </trans-unit>
        <trans-unit id="e551a0a9f5cec988bad0e24f623506d90ef7f587" translate="yes" xml:space="preserve">
          <source>MySQL Date/Time data types reference</source>
          <target state="translated">Ссылка на типы данных MySQL DateTime</target>
        </trans-unit>
        <trans-unit id="ca1edfc72a341b43b90b702098e1f76bdd4e6abc" translate="yes" xml:space="preserve">
          <source>MySQL Storage Requirements reference</source>
          <target state="translated">Ссылка на требования к хранилищу MySQL</target>
        </trans-unit>
        <trans-unit id="6a4d8a0f46ff5193d118cc038fb1704445a83d9a" translate="yes" xml:space="preserve">
          <source>No timezone issues.  There's been some insightful comments on here on what happens with timezones with the different data types.  But is this common knowledge, and will your co-workers all take the time to learn it?  On the other hand, it's pretty hard to mess up changing a BigINT into a java.util.Date.  Using a BIGINT causes a lot of issues with timezones to fall by the wayside.</source>
          <target state="translated">Никаких проблем с часовым поясом.Здесь были некоторые проницательные комментарии о том,что происходит с таймзонами с различными типами данных.Но является ли это общеизвестным знанием,и все ли ваши коллеги найдут время,чтобы узнать это? С другой стороны,довольно трудно испортить изменение BigINT в java.util.Date.Использование BIGINT приводит к тому,что многие проблемы с таймзонами выпадают на обочину.</target>
        </trans-unit>
        <trans-unit id="c435dd392d33aad96f73d02a6a3f30f54ccc0a19" translate="yes" xml:space="preserve">
          <source>No worries about ranges or precision.  You don't have to worry about what being cut short by future date ranges (TIMESTAMP only goes to 2038).</source>
          <target state="translated">Не беспокойтесь о диапазонах или точности.Вам не нужно беспокоиться о том,что будет сокращено к будущим диапазонам дат (ВРЕМЕННАЯ СТЕПЕНЬ идет только на 2038 год).</target>
        </trans-unit>
        <trans-unit id="91545e23ede1ee1fd22dcf98f82ebe9134aa6fe6" translate="yes" xml:space="preserve">
          <source>Note: default connection timezone is the server timezone, but this can (should) be changed per session (see &lt;code&gt;SET time_zone = ...&lt;/code&gt;).</source>
          <target state="translated">Примечание: часовой пояс соединения по умолчанию - часовой пояс сервера, но его можно (нужно) изменить за сеанс (см. &lt;code&gt;SET time_zone = ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="db07d9be995e80601a3b13b3376307c58b5426b7" translate="yes" xml:space="preserve">
          <source>On the other hand, for values that represent system time like payment transactions, table modifications or logging, always use timestamps. The system will not be affected by moving the server to another time zone, or when comparing between servers in different timezones.</source>
          <target state="translated">С другой стороны,для значений,представляющих системное время,таких как платежные транзакции,изменение таблиц или протоколирование,всегда используйте временные метки.Перемещение сервера в другой часовой пояс или сравнение между серверами в разных часовых поясах не повлияет на работу системы.</target>
        </trans-unit>
        <trans-unit id="ba1d189b28f2abf9d56261768ea0e3c3b0ad4737" translate="yes" xml:space="preserve">
          <source>Reference taken from this Article:</source>
          <target state="translated">Ссылка взята из этой статьи:</target>
        </trans-unit>
        <trans-unit id="8b05b05f99d45086cfec2bd40e0912d41a40c935" translate="yes" xml:space="preserve">
          <source>Should I use the datetime or timestamp data type in MySQL</source>
          <target state="translated">Должен ли я использовать тип данных &quot;дата&quot; или &quot;время&quot; в MySQL.</target>
        </trans-unit>
        <trans-unit id="045177b57f199536798f7602f5e2b8d9dcff5e1f" translate="yes" xml:space="preserve">
          <source>So for values that represent user time like an appointment or a schedule, datetime is better. It allows the user to control the exact date and time desired, regardless of the server settings. The set time is the set time, not affected by the server's time zone, the user's time zone, or by changes in the way daylight savings time is calculated (yes it does change).</source>
          <target state="translated">Поэтому для значений,которые представляют время пользователя,таких как встреча или расписание,дата лучше.Это позволяет пользователю контролировать точную дату и время,независимо от настроек сервера.Установленное время-это установленное время,на которое не влияют часовой пояс сервера,часовой пояс пользователя или изменения в способе расчета летнего времени (да,оно меняется).</target>
        </trans-unit>
        <trans-unit id="73a5a457c16ecd2093862684ea7c13eae5a14ea1" translate="yes" xml:space="preserve">
          <source>So it only matters when you have &amp;mdash; or may in the future have &amp;mdash; synchronized clusters across time zones.</source>
          <target state="translated">Так что это имеет значение, только если у вас есть - или, возможно, в будущем - синхронизированные кластеры по часовым поясам.</target>
        </trans-unit>
        <trans-unit id="1653f1ba6251a7f548790a533e1efa888bef4509" translate="yes" xml:space="preserve">
          <source>So suppose you are in USA and getting data from a server which has a time zone of USA. Then you will get the date and time according to the USA time zone. The timestamp data type column always get updated automatically when its row gets updated. So it can be useful to track when a particular row was updated last time.</source>
          <target state="translated">Так что предположим,что вы находитесь в США и получаете данные с сервера,который имеет часовой пояс США.Затем вы получите дату и время в соответствии с часовым поясом США.Столбец типа данных временных меток всегда обновляется автоматически при обновлении его строки.Поэтому может быть полезно отследить,когда определенный ряд был обновлен в прошлый раз.</target>
        </trans-unit>
        <trans-unit id="eb10daa25dc60f8b1daad8f8e387e8e83eaf144b" translate="yes" xml:space="preserve">
          <source>So, to summarize, I value this advantages of timestamp:</source>
          <target state="translated">Итак,подытоживая,я ценю это преимущество временной метки:</target>
        </trans-unit>
        <trans-unit id="ada52d888ccf16d2711b8a6377768a782af5c30e" translate="yes" xml:space="preserve">
          <source>Sources:</source>
          <target state="translated">Sources:</target>
        </trans-unit>
        <trans-unit id="77f90354221d8a67dd1969d6e644c499a0514a52" translate="yes" xml:space="preserve">
          <source>TIMESTAMP also affected by different TIME ZONE related setting.
DATETIME is constant.</source>
          <target state="translated">ВРЕМЕННАЯ УСТАНОВКА также зависит от различных настроек,связанных с зоной времени.ДАТЕТИКА является постоянной.</target>
        </trans-unit>
        <trans-unit id="c94a072eac65be71cfc849f9037072f6247474bd" translate="yes" xml:space="preserve">
          <source>TIMESTAMP internally converted current time zone to UTC for storage, and during retrieval converted back to the current time zone.
DATETIME can not do this.</source>
          <target state="translated">TIMESTAMP внутренне преобразовывает текущий часовой пояс в UTC для хранения,а во время извлечения преобразует обратно в текущий часовой пояс.DATETIME не может этого сделать.</target>
        </trans-unit>
        <trans-unit id="dacee252d7b14073e849682cd79a8a03ac04c316" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is 4 bytes Vs 8 bytes for DATETIME.</source>
          <target state="translated">TIMESTAMP-это 4 байта Vs 8 байт для DATETIME.</target>
        </trans-unit>
        <trans-unit id="a410814a3011c5943a3034941f92663affe3da22" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is always in UTC (that is, elapsed seconds since 1970-01-01, in UTC), and your MySQL server auto-converts it to the date/time for the connection timezone. In the long-term, TIMESTAMP is the way to go because you know your temporal data will always be in UTC. For example, you won't screw your dates up if you migrate to a different server or if you change the timezone settings on your server.</source>
          <target state="translated">TIMESTAMP всегда находится в UTC (т.е.истекшие секунды с 1970-01-01,в UTC),и твой MySQL-сервер автоматически преобразует его в дату часового пояса подключения.В долгосрочной перспективе TIMESTAMP-это путь,потому что ты знаешь,что твои временные данные всегда будут в UTC.Например,вы не испортите свои даты,если перейдете на другой сервер или измените настройки часового пояса на вашем сервере.</target>
        </trans-unit>
        <trans-unit id="e8ac59d0c9ad21fe5948cec9369a8f0b45667f55" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is four bytes vs eight bytes for DATETIME.</source>
          <target state="translated">TIMESTAMP-это четыре байта против восьми байтов для DATETIME.</target>
        </trans-unit>
        <trans-unit id="5d4df6053b746ece86d95685245755662b29cc96" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is still limited to 1970-2038</source>
          <target state="translated">ТИМЕСТАМП по-прежнему ограничен 1970-2038 гг.</target>
        </trans-unit>
        <trans-unit id="f9eb6fe6031fa5a60529bcb98828a895865741b2" translate="yes" xml:space="preserve">
          <source>TIMESTAMP supported range:
&amp;lsquo;1970-01-01 00:00:01&amp;prime; UTC to &amp;lsquo;2038-01-19 03:14:07&amp;prime; UTC
DATETIME supported range:
&amp;lsquo;1000-01-01 00:00:00&amp;prime; to &amp;lsquo;9999-12-31 23:59:59&amp;prime;</source>
          <target state="translated">Диапазон поддерживаемых TIMESTAMP: '1970-01-01 00:00:01' UTC до '2038-01-19 03:14:07' DTC СРОК ПОСТАВКИ UTC: '1000-01-01 00:00:00' до '9999 -12-31 23:59:59 &amp;prime;</target>
        </trans-unit>
        <trans-unit id="1e8cfe79f87e9cf415a34e5da6160ec0183062d4" translate="yes" xml:space="preserve">
          <source>TIMESTAMP used to track changes to records, and update every time when the record is changed.
DATETIME used to store specific and static value which is not affected by any changes in records.</source>
          <target state="translated">TIMESTAMP используется для отслеживания изменений в записях,и обновляется каждый раз при изменении записи.DATETIME используется для хранения специфического и статического значения,на которое не влияют никакие изменения в записях.</target>
        </trans-unit>
        <trans-unit id="f5f7ca32f1c995965b4caae3c7b57bf8c446174e" translate="yes" xml:space="preserve">
          <source>The DATETIME type is used when you need values that contain both date and time information. MySQL retrieves and displays DATETIME values in &amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo; format. The supported range is &amp;rsquo;1000-01-01 00:00:00&amp;prime; to &amp;rsquo;9999-12-31 23:59:59&amp;prime;.</source>
          <target state="translated">Тип DATETIME используется, когда вам нужны значения, которые содержат как дату, так и время. MySQL извлекает и отображает значения DATETIME в формате &amp;laquo;ГГГГ-ММ-ДД ЧЧ: ММ: СС&amp;raquo;. Поддерживаемый диапазон: от 1000-01-01 от 00:00:00 до 9999-12-31 23:59:59.</target>
        </trans-unit>
        <trans-unit id="d995c3fc457d2a486d56301383483a0c59cd6c55" translate="yes" xml:space="preserve">
          <source>The DATETIME type is used when you need values that contain both date and time information. MySQL retrieves and displays DATETIME values in 'YYYY-MM-DD HH:MM:SS' format. The supported range is '1000-01-01 00:00:00' to '9999-12-31 23:59:59'.</source>
          <target state="translated">Тип DATETIME используется,когда вам нужны значения,содержащие информацию как о дате,так и о времени.MySQL извлекает и отображает значения DATETIME в формате 'YYYY-MM-DD HH:MM:SS'.Поддерживается диапазон от '1000-01-01 00:00:00' до '9999-12-31 23:59:59'.</target>
        </trans-unit>
        <trans-unit id="d1d182272c9e749c480b203f44a7403a8e892e56" translate="yes" xml:space="preserve">
          <source>The TIMESTAMP data type has a range of &amp;rsquo;1970-01-01 00:00:01&amp;prime; UTC to &amp;rsquo;2038-01-09 03:14:07&amp;prime; UTC. It has varying properties, depending on the MySQL version and the SQL mode the server is running in.</source>
          <target state="translated">Тип данных TIMESTAMP имеет диапазон от '1970-01-01 00:00:01' UTC до '2038-01-09 03:14:07' UTC. Он имеет различные свойства в зависимости от версии MySQL и режима SQL, в котором работает сервер.</target>
        </trans-unit>
        <trans-unit id="451a1b7a95752b8704aa14620a0ff8e1af0081b8" translate="yes" xml:space="preserve">
          <source>The TIMESTAMP data type has a range of '1970-01-01 00:00:01' UTC to '2038-01-09 03:14:07' UTC. It has varying properties, depending on the MySQL version and the SQL mode the server is running in.</source>
          <target state="translated">Тип данных TIMESTAMP имеет диапазон от '1970-01-01 00:00:01' UTC до '2038-01-09 03:14:07' UTC.Он имеет различные свойства,в зависимости от версии MySQL и режима SQL,в котором работает сервер.</target>
        </trans-unit>
        <trans-unit id="5dbacf6cd847f9d41776bc72041128127e5dd977" translate="yes" xml:space="preserve">
          <source>The below examples show how the &lt;code&gt;TIMESTAMP&lt;/code&gt; date type changed the values after changing the &lt;code&gt;time-zone to 'america/new_york'&lt;/code&gt; where &lt;code&gt;DATETIME&lt;/code&gt;is unchanged.</source>
          <target state="translated">Приведенные ниже примеры показывают, как тип даты &lt;code&gt;TIMESTAMP&lt;/code&gt; изменил значения после изменения &lt;code&gt;time-zone to 'america/new_york'&lt;/code&gt; где &lt;code&gt;DATETIME&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="6e0ed57105ef0f58a736d7ff36ae9c629f9e488a" translate="yes" xml:space="preserve">
          <source>The main difference is that DATETIME is constant while TIMESTAMP is affected by the &lt;code&gt;time_zone&lt;/code&gt; setting.</source>
          <target state="translated">Основным отличием является то, что DATETIME является постоянным, в то время как TIMESTAMP зависит от настройки &lt;code&gt;time_zone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2f50d2734b460f0fadb92162062e81c8ec1ffbb" translate="yes" xml:space="preserve">
          <source>The major difference is</source>
          <target state="translated">Главное отличие состоит в том,что</target>
        </trans-unit>
        <trans-unit id="c26db8d70224fe926b15eb61a7302596d74d511e" translate="yes" xml:space="preserve">
          <source>The timestamp data type stores date and time, but in UTC format, not in the current timezone format as datetime does. And when you fetch data, timestamp again converts that into the current timezone time.</source>
          <target state="translated">Тип данных метки времени хранит дату и время,но в формате UTC,а не в текущем формате часового пояса,как это делает дата.И когда вы получаете данные,метка времени снова преобразует их в текущее время часового пояса.</target>
        </trans-unit>
        <trans-unit id="cf32d1d08b4bc2bc4010812ed8c9ae1f696d2151" translate="yes" xml:space="preserve">
          <source>Third-party tool integration.  By using an integer, it's trivial for 3rd party tools (e.g. EclipseLink) to interface with the database.  Not every third-party tool is going to have the same understanding of a &quot;datetime&quot; as MySQL does.  Want to try and figure out in Hibernate whether you should use a java.sql.TimeStamp or java.util.Date object if you're using these custom data types?  Using your base data types make's use with 3rd-party tools trivial.</source>
          <target state="translated">Интеграция сторонних инструментов.Использование целого числа является тривиальным для сторонних инструментов (например,EclipseLink)для взаимодействия с базой данных.Не каждый сторонний инструмент будет иметь такое же понимание &quot;времени&quot;,как и MySQL.Хотите попробовать и выяснить в Hibernate,следует ли вам использовать java.sql.TimeStamp или java.util.Date объект,если вы используете эти пользовательские типы данных? Используя базовые типы данных,используйте их со сторонними инструментами тривиально.</target>
        </trans-unit>
        <trans-unit id="10c80400b73324c73575938e491d735cda350d3b" translate="yes" xml:space="preserve">
          <source>This issue is closely related how you should store a money value (i.e. $1.99) in a database.  Should you use a Decimal, or the database's Money type, or worst of all a Double? All 3 of these options are terrible, for many of the same reasons listed above.  The solution is to store the value of money in cents using BIGINT, and then convert cents to dollars when you display the value to the user.  The database's job is to store data, and NOT to intrepret that data.  All these fancy data-types you see in databases(especially Oracle) add little, and start you down the road to vendor lock-in.</source>
          <target state="translated">Этот вопрос тесно связан с тем,как следует хранить стоимость денег (т.е.$1.99)в базе данных.Должны ли вы использовать десятичную цифру,или тип Денег в базе данных,или,что хуже всего,двойную величину? Все 3 из этих вариантов ужасны по многим из вышеперечисленных причин.Решение заключается в том,чтобы хранить стоимость денег в центах,используя BIGINT,а затем конвертировать центы в доллары,когда вы показываете стоимость пользователю.Работа базы данных заключается в хранении данных,а не в их интерпретации.Все эти причудливые типы данных,которые вы видите в базах данных (особенно в Oracle),мало что добавляют,и начинают вас вниз по дороге,чтобы закрепить продавца.</target>
        </trans-unit>
        <trans-unit id="7209c28d9c054e86435df0e23a3343e8a1f40ced" translate="yes" xml:space="preserve">
          <source>This will update the time at each instance you modify a row and is sometimes very helpful for stored last edit information. This only works with timestamp, not datetime however.</source>
          <target state="translated">Это будет обновлять время в каждом случае,когда вы изменяете строку,и иногда очень полезно для сохранения информации о последнем редактировании.Однако это работает только с меткой времени,а не с датой.</target>
        </trans-unit>
        <trans-unit id="04cfc0761251068bf684bad9ba6e3db23f02b537" translate="yes" xml:space="preserve">
          <source>Timestamps are also lighter on the database and indexed faster.</source>
          <target state="translated">Штампы времени также легче попадают в базу данных и индексируются быстрее.</target>
        </trans-unit>
        <trans-unit id="39b7c7fd16c84befdb2fbc7842a2f1b007beb800" translate="yes" xml:space="preserve">
          <source>Timestamps in MySQL are generally used to track changes to records, and are often updated every time the record is changed. If you want to store a specific value you should use a datetime field.</source>
          <target state="translated">Временные метки в MySQL обычно используются для отслеживания изменений в записях,и часто обновляются каждый раз при изменении записи.Если вы хотите сохранить определенное значение,используйте поле даты.</target>
        </trans-unit>
        <trans-unit id="0cdbc16fb39ccae8f270c66140498641e37ffbff" translate="yes" xml:space="preserve">
          <source>To get the current Unix timestamp in PHP, just do &lt;code&gt;time();&lt;/code&gt;</source>
          <target state="translated">Чтобы получить текущую метку времени Unix в PHP, просто сделайте &lt;code&gt;time();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cd063cd0d9b6c24ab996012840118b6a4b97e0b" translate="yes" xml:space="preserve">
          <source>Using datetimes without the timezone means that your application is dealing with only 1 timezone, however timestamps give you the benefits of &lt;code&gt;datetime&lt;/code&gt; plus the flexibility of showing the same exact point of time in different timezones.</source>
          <target state="translated">Использование datetime без часового пояса означает, что ваше приложение имеет дело только с 1 часовым поясом, однако временные метки дают вам преимущества &lt;code&gt;datetime&lt;/code&gt; плюс гибкость показа одного и того же точного момента времени в разных часовых поясах.</target>
        </trans-unit>
        <trans-unit id="6679d8851bfecb41edd8ddf8dff3f76a03f04b74" translate="yes" xml:space="preserve">
          <source>What the right one is depends entirely on what you want to do.</source>
          <target state="translated">То,что правильно,полностью зависит от того,что ты хочешь сделать.</target>
        </trans-unit>
        <trans-unit id="15e16ae2b3038140af7aae3650d4e538db2056d5" translate="yes" xml:space="preserve">
          <source>When you ask what is the time ? and the answer comes as something like '2019-02-05 21:18:30', that is not completed, not defined answer because it lacks another part, in which timezone  ? Washington ? Moscow ? Beijing ?</source>
          <target state="translated">Когда вы спрашиваете,какое время ? и ответ приходит как-то вроде '2019-02-05 21:18:30',то это не завершено,не определен ответ,потому что в нем отсутствует другая часть,в каком часовом поясе ? Вашингтон ? Москва ? Пекин ?</target>
        </trans-unit>
        <trans-unit id="0b3ff16b336587556b1fa0fdb27cf08aee358bed" translate="yes" xml:space="preserve">
          <source>Would you recommend using a &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;datetime&lt;/a&gt; or a &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;timestamp&lt;/a&gt; field, and why (using MySQL)?</source>
          <target state="translated">Вы бы порекомендовали использовать поле &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;datetime&lt;/a&gt; или &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;timestamp&lt;/a&gt; и почему (используя MySQL)?</target>
        </trans-unit>
        <trans-unit id="99ccf3adb5db0d31246743ae82d394360ce5b265" translate="yes" xml:space="preserve">
          <source>You avoid vendor lock-in.  Pretty much every database supports integers in the relatively similar fashion.  Suppose you want to move to another database.  Do you want to worry about the differences between MySQL's DATETIME values and how Oracle defines them?  Even among different versions of MySQL, TIMESTAMPS have a different level of precision.  It was only just recently that MySQL supported milliseconds in the timestamps.</source>
          <target state="translated">Ты избегаешь блокировки поставщиков.Практически каждая база данных поддерживает целые числа относительно схожим образом.Предположим,вы хотите перейти к другой базе данных.Вы хотите беспокоиться о различиях между значениями DATETIME в MySQL и тем,как их определяет Oracle? Даже среди различных версий MySQL,TIMESTAMPS имеют разный уровень точности.Только недавно MySQL поддерживал миллисекунды в метках времени.</target>
        </trans-unit>
        <trans-unit id="8b4895f794a8283459ca4a088274ede5b50f7a7f" translate="yes" xml:space="preserve">
          <source>You're quite likely to hit the lower limit on TIMESTAMPs in general use -- e.g. storing birthdate.</source>
          <target state="translated">Вполне вероятно,что вы попали в нижний предел ВРЕМЕННЫХ УСТАНОВКИ в общем пользовании-например,хранение даты рождения.</target>
        </trans-unit>
        <trans-unit id="fe7b915adc41c235ae2019a5d63666bcb6f784aa" translate="yes" xml:space="preserve">
          <source>a INDEX's on Datetime   - &lt;a href=&quot;https://stackoverflow.com/questions/4013301/mysql-datetime-index-is-not-working&quot;&gt;Does not work&lt;/a&gt;</source>
          <target state="translated">Индекс на Datetime - &lt;a href=&quot;https://stackoverflow.com/questions/4013301/mysql-datetime-index-is-not-working&quot;&gt;не работает&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c058c66e16779f3e5d87b80818f4e54711ee832a" translate="yes" xml:space="preserve">
          <source>a INDEX's on Timestamp  - works</source>
          <target state="translated">&quot;ИНДЕКС&quot; на &quot;Таймэмп&quot;-работает.</target>
        </trans-unit>
        <trans-unit id="14c88ff2f0e7f0d7d01802892756e11f40be03b1" translate="yes" xml:space="preserve">
          <source>and in MySQL do &lt;code&gt;SELECT UNIX_TIMESTAMP();&lt;/code&gt;.</source>
          <target state="translated">и в MySQL сделайте &lt;code&gt;SELECT UNIX_TIMESTAMP();&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="bef63f4643b53c0e6c20553bb1f0543b403021b5" translate="yes" xml:space="preserve">
          <source>easy migrations between time zones</source>
          <target state="translated">лёгкие миграции между часовыми поясами</target>
        </trans-unit>
        <trans-unit id="7ae8438fcf4f03e1bbb55d35dceda8efa0bd317f" translate="yes" xml:space="preserve">
          <source>look at this &lt;a href=&quot;https://stackoverflow.com/questions/95183/how-does-one-create-an-index-on-the-date-part-of-datetime-field-in-mysql&quot;&gt;post to see problems with Datetime indexing&lt;/a&gt;</source>
          <target state="translated">посмотрите на этот &lt;a href=&quot;https://stackoverflow.com/questions/95183/how-does-one-create-an-index-on-the-date-part-of-datetime-field-in-mysql&quot;&gt;пост, чтобы увидеть проблемы с индексацией Datetime&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="944e5c03bdda873f2d9a030910c0d94089a1d341" translate="yes" xml:space="preserve">
          <source>no worry about dates in/out a summer time period</source>
          <target state="translated">не беспокойтесь о свиданиях в летний период.</target>
        </trans-unit>
        <trans-unit id="68c2634f494de50ae1701c5c57288cb89cec17cd" translate="yes" xml:space="preserve">
          <source>pretty easy to calculate diferences (just subtract both timestamps)</source>
          <target state="translated">довольно легко вычислить расхождения (просто вычитайте обе временные метки)</target>
        </trans-unit>
        <trans-unit id="d38547cfd2b4a24917f0893ead653bf6ef1602f3" translate="yes" xml:space="preserve">
          <source>ready to use on international (multi time zone) apps</source>
          <target state="translated">готовые к использованию на международных (мульти часовых поясах)приложениях</target>
        </trans-unit>
        <trans-unit id="18f605dfe1380d283d7c7607e5798ee1e187bbce" translate="yes" xml:space="preserve">
          <source>then every single value in your 'Date_Added' column would be changed to the current timestamp.</source>
          <target state="translated">то каждое значение в столбце 'Date_Added' будет изменено на текущую метку времени.</target>
        </trans-unit>
        <trans-unit id="9b99af1d5f813e03b16069c39a0d4de32de49280" translate="yes" xml:space="preserve">
          <source>you accept data from different clients around the world, each of them inserts the time in his timezone.</source>
          <target state="translated">вы принимаете данные от разных клиентов по всему миру,каждый из них вставляет время в свой часовой пояс.</target>
        </trans-unit>
        <trans-unit id="a1900144dd02e0b44d98690cdbca12f939cbf4a9" translate="yes" xml:space="preserve">
          <source>you changed the country you stay in, and continue your work of maintaining the data while seeing it in a different timezone (without changing the actual data).</source>
          <target state="translated">вы изменили страну,в которой находитесь,и продолжаете работу по сохранению данных,видя их в другом часовом поясе (без изменения фактических данных).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
