<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/409286">
    <body>
      <group id="409286">
        <trans-unit id="593a02a118c1f362caa2e58db6d6664e3f576b7f" translate="yes" xml:space="preserve">
          <source>(Unless you are likely to change the timezone of your servers)</source>
          <target state="translated">(서버 시간대를 변경할 가능성이 없다면)</target>
        </trans-unit>
        <trans-unit id="d27bbad1be4b90f3efb7c75a4b43f6fa388fae5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;datetime&lt;/code&gt; = application supports 1 timezone (for both inserting and selecting)</source>
          <target state="translated">&lt;code&gt;datetime&lt;/code&gt; = 응용 프로그램은 1 개의 시간대를 지원합니다 (삽입 및 선택 모두)</target>
        </trans-unit>
        <trans-unit id="20905d1d1b479330793c32af9ed0fa9beb9adb03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; = application supports any timezone (for both inserting and selecting)</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; = 응용 프로그램은 모든 시간대를 지원합니다 (삽입 및 선택 모두)</target>
        </trans-unit>
        <trans-unit id="349a08ae5d6ed4659b0bcd3ec7c70e280bab22c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;2016 +&lt;/em&gt;: what I advise is to set your Mysql timezone to UTC and use DATETIME:</source>
          <target state="translated">&lt;em&gt;2016 +&lt;/em&gt; : MySQL 시간대를 UTC로 설정하고 DATETIME을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="331d547d2d77f302ef10428b2a9addf2ef86e968" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This answer is only for putting some highlight on the flexibility and ease of timestamps when it comes to time zones , it is not covering any other differences like the &lt;a href=&quot;https://stackoverflow.com/a/45632196/5407848&quot;&gt;column size or range or fraction&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 답변은 시간대와 관련하여 타임 스탬프의 유연성과 용이성에 중점을두기위한 것이며 &lt;a href=&quot;https://stackoverflow.com/a/45632196/5407848&quot;&gt;열 크기, 범위 또는 분수&lt;/a&gt; 와 같은 다른 차이점은 다루지 않습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8d39d205db25f2106a7af756b95fdfef76c9718" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The main differences:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;주요 차이점 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34da79ccaf9b8c0d6c96a398c7de54c386c7c5d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is that [.fraction]?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[.fraction]은 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ccacfe5d1464a272d0161bc29e81b58fd87fa55" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TIMESTAMP&lt;/code&gt; requires 4 bytes, whereas a &lt;code&gt;DATETIME&lt;/code&gt; requires 8 bytes.</source>
          <target state="translated">&lt;code&gt;TIMESTAMP&lt;/code&gt; 에는 4 바이트가 필요하지만 &lt;code&gt;DATETIME&lt;/code&gt; 에는 8 바이트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6f86f9e143c43e826773e4340f28d06abfa21196" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;timestamp&lt;/code&gt; field is a special case of the &lt;code&gt;datetime&lt;/code&gt; field. You can create &lt;code&gt;timestamp&lt;/code&gt; columns to have special properties; it can be set to update itself on either create and/or update.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 필드는 &lt;code&gt;datetime&lt;/code&gt; 필드의 특수한 경우입니다. &lt;code&gt;timestamp&lt;/code&gt; 열을 만들어 특별한 속성을 가질 수 있습니다. 작성 및 / 또는 업데이트시 자체적으로 업데이트되도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23afe721d17e7bce6561ecac0c0767557c18f3e2" translate="yes" xml:space="preserve">
          <source>A DATETIME or TIMESTAMP value can include a trailing fractional
seconds part in up to microseconds (6 digits) precision. In
particular, any fractional part in a value inserted into a DATETIME
or TIMESTAMP column is stored rather than discarded. This is of course optional.</source>
          <target state="translated">DATETIME 또는 TIMESTAMP 값은 소수점 이하 초 부분을 최대 마이크로 초 (6 자리) 정밀도로 포함 할 수 있습니다. 특히 DATETIME 또는 TIMESTAMP 열에 삽입 된 값의 소수 부분은 버리지 않고 저장됩니다. 이것은 물론 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="105e72149319d74d06cd9e179968cd6895c674de" translate="yes" xml:space="preserve">
          <source>A great example of DATETIME being used where TIMESTAMP should have been used is in Facebook, where their servers are never quite sure what time stuff happened across time zones. Once I was having a conversation in which the time said I was replying to messages before the message was actually sent. (This, of course, could also have been caused by bad time zone translation in the messaging software if the times were being posted rather than synchronized.)</source>
          <target state="translated">TIMESTAMP가 사용 된 곳에서 사용되는 DATETIME의 좋은 예는 Facebook에서 서버가 시간대 전체에서 발생한 시간을 확실하게 알 수없는 Facebook입니다. 한때 나는 대화가 있었는데 메시지가 실제로 전송되기 전에 메시지에 답장을했다. 물론 시간이 동기화되지 않고 게시 된 경우 메시징 소프트웨어의 시간대 변환이 잘못되어 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac1d2a76e849b1b5833ee66f2036219c73ed4239" translate="yes" xml:space="preserve">
          <source>Additionally:</source>
          <target state="translated">Additionally:</target>
        </trans-unit>
        <trans-unit id="a1f945cbe8c29cec65da8e8eab6c4e28b4f16229" translate="yes" xml:space="preserve">
          <source>All localised time format available here:
&lt;a href=&quot;https://docs.angularjs.org/api/ng/filter/date&quot;&gt;https://docs.angularjs.org/api/ng/filter/date&lt;/a&gt;</source>
          <target state="translated">현지화 된 모든 시간 형식은 여기 ( &lt;a href=&quot;https://docs.angularjs.org/api/ng/filter/date&quot;&gt;https://docs.angularjs.org/api/ng/filter/date)에서&lt;/a&gt; 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03f4ab0cfb5116acacf82c79980bbc4c1538ca3f" translate="yes" xml:space="preserve">
          <source>Another difference between Timestamp and Datetime is in Timestamp you can't default value to NULL.</source>
          <target state="translated">Timestamp와 Datetime의 또 다른 차이점은 Timestamp에서 기본값을 NULL로 설정할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8649432b65d482601d32ced47b86cec528e6f13e" translate="yes" xml:space="preserve">
          <source>Another thing worth considering:</source>
          <target state="translated">고려해야 할 또 다른 사항 :</target>
        </trans-unit>
        <trans-unit id="7e4bc976d9f0aa9df498da0d674146848c45e317" translate="yes" xml:space="preserve">
          <source>Any recent front-end framework (Angular 1/2, react, Vue,...) can easily and automatically convert your UTC datetime to local time.</source>
          <target state="translated">최근 프런트 엔드 프레임 워크 (Angular 1/2, react, Vue, ...)를 사용하면 UTC 날짜 시간을 현지 시간으로 쉽고 자동으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f02b723ecb30f7a7b86943f5693d1a105ed169a" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/datetime.html&quot;&gt;mentioned&lt;/a&gt; in the MySQL documentation:</source>
          <target state="translated">MySQL 문서에서 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/datetime.html&quot;&gt;언급했듯이&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="30a7616be2ba7d64b9561fa7bcf55829ad69bc78" translate="yes" xml:space="preserve">
          <source>As a plus, in the case of a migration of the database to a system with another timezone, I would feel more confident using timestamps. Not to say possible issues when calculating differences between two moments with a sumer time change in between and needing a precision of 1 hour or less.</source>
          <target state="translated">또한 다른 시간대의 시스템으로 데이터베이스를 마이그레이션하는 경우 타임 스탬프를 사용하는 것이 더 자신감이 있습니다. Sumer 시간이 변경되어 1 시간 이하의 정밀도가 필요한 두 순간 간의 차이를 계산할 때 가능한 문제는 말할 것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="75c9379a28896ce9890676a1ef0ca87e210c0b0c" translate="yes" xml:space="preserve">
          <source>Beware of timestamp changing when you do a UPDATE statement on a table.  If you have a table with columns 'Name' (varchar), 'Age' (int), and 'Date_Added' (timestamp) and you run the following DML statement</source>
          <target state="translated">테이블에서 UPDATE 문을 수행 할 때 타임 스탬프 변경에주의하십시오. 'Name'(varchar), 'Age'(int) 및 'Date_Added'(timestamp) 열이있는 테이블이 있고 다음 DML 문을 실행하는 경우</target>
        </trans-unit>
        <trans-unit id="048fad409fc302137354247e34dd35f44fb43704" translate="yes" xml:space="preserve">
          <source>But like scronide said it does have a lower limit of the year 1970. It's great for anything that might happen in the future though ;)</source>
          <target state="translated">그러나 scronide는 1970 년의 하한선이 있다고 말했듯이 미래에도 일어날 수있는 모든 것에 아주 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="0b3bafc7f7ed6d1609b9c2c4fd043e820e24cc01" translate="yes" xml:space="preserve">
          <source>By default, the current time zone for each connection is the server's time. The time zone can be set on a per-connection basis, as described in &lt;em&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en//time-zone-support.html&quot;&gt;MySQL Server Time Zone Support&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">기본적으로 각 연결의 현재 시간대는 서버의 시간입니다. &lt;em&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en//time-zone-support.html&quot;&gt;MySQL 서버 시간대 지원에&lt;/a&gt;&lt;/em&gt; 설명 된대로 시간대는 연결별로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46e754d5823f336c6879ab95356aa5286d30a861" translate="yes" xml:space="preserve">
          <source>Comparison between DATETIME, TIMESTAMP and DATE</source>
          <target state="translated">DATETIME, TIMESTAMP 및 DATE 비교</target>
        </trans-unit>
        <trans-unit id="dfa016c1ac5a15d6be12e485338468f1d8936cd6" translate="yes" xml:space="preserve">
          <source>Consider setting a timestamp by a user to a server in New York, for an appointment in Sanghai. Now when the user connects in Sanghai, he accesses the same appointment timestamp from a mirrored server in Tokyo. He will see the appointment in Tokyo time, offset from the original New York time.</source>
          <target state="translated">상하이에서의 약속을 위해 사용자가 뉴욕의 서버에 타임 스탬프를 설정하는 것을 고려하십시오. 이제 사용자가 상해에 연결하면 도쿄의 미러 서버에서 동일한 약속 시간 소인에 액세스합니다. 그는 원래 뉴욕 시간과 오프셋 된 도쿄 시간의 약속을 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="36abbe8686064b87032b977c64e9037a1ab43ae2" translate="yes" xml:space="preserve">
          <source>Contrary to what one might think, DATETIME is &lt;strong&gt;FASTER&lt;/strong&gt; THAN TIMESTAMP,
&lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&quot;&gt;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&lt;/a&gt;</source>
          <target state="translated">생각하는 것과 달리 DATETIME은 TIMESTAMP보다 &lt;strong&gt;빠릅니다&lt;/strong&gt; . &lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&quot;&gt;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with -myisam /&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cd06d5b91f44e6c7d8bb5a9e4b6c53eb080b994" translate="yes" xml:space="preserve">
          <source>DATETIME can now be &lt;strong&gt;automatically&lt;/strong&gt; set to the current time value &lt;a href=&quot;https://stackoverflow.com/questions/168736/how-do-you-set-a-default-value-for-a-mysql-datetime-column/10603198#10603198&quot;&gt;How do you set a default value for a MySQL Datetime column?&lt;/a&gt;</source>
          <target state="translated">DATETIME을 현재 시간 값 &lt;strong&gt;으로 자동&lt;/strong&gt; 설정할 수 있습니다 &lt;a href=&quot;https://stackoverflow.com/questions/168736/how-do-you-set-a-default-value-for-a-mysql-datetime-column/10603198#10603198&quot;&gt;. MySQL Datetime 열의 기본값을 어떻게 설정합니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bb751509c73535fc71ab28078b2a2cd7cff076c" translate="yes" xml:space="preserve">
          <source>DATETIME is constant while TIMESTAMP is effected by the time_zone setting.</source>
          <target state="translated">DATETIME은 일정하며 TIMESTAMP는 time_zone 설정에 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="e606ed7f8ffdfa79456bda0bab96b69794b076de" translate="yes" xml:space="preserve">
          <source>Depends on application, really.</source>
          <target state="translated">실제로 응용 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="793dba92e4fad48f46012613b16dac7b1259878a" translate="yes" xml:space="preserve">
          <source>Example with AngularJs</source>
          <target state="translated">AngularJs 예제</target>
        </trans-unit>
        <trans-unit id="b632b31f3430f0f42e92741a8e59ca31ba0a5461" translate="yes" xml:space="preserve">
          <source>For all this reasons, I choose UTC &amp;amp; timestamp fields where posible. And I avoid headaches ;)</source>
          <target state="translated">이 모든 이유로, 가능한 UTC 및 타임 스탬프 필드를 선택합니다. 그리고 나는 두통을 피한다.)</target>
        </trans-unit>
        <trans-unit id="6b6dd3a87f08f57887386997d7393798f29857fa" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;user&lt;/code&gt; table with a &lt;strong&gt;REGISTRATION DATE&lt;/strong&gt; field. In that &lt;code&gt;user&lt;/code&gt; table, if you want to know the last logged in time of a particular user, go with a field of &lt;strong&gt;timestamp&lt;/strong&gt; type so that the field gets updated.</source>
          <target state="translated">예를 들어, &lt;strong&gt;REGISTRATION DATE&lt;/strong&gt; 필드가있는 &lt;code&gt;user&lt;/code&gt; 테이블을 고려하십시오. 해당 &lt;code&gt;user&lt;/code&gt; 테이블에서 특정 사용자의 마지막 로그인 시간을 알고 싶다면 필드가 업데이트되도록 &lt;strong&gt;타임 스탬프&lt;/strong&gt; 유형 필드로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="4911c2a3fb22efedb0166e219e1c072fdeeb59f1" translate="yes" xml:space="preserve">
          <source>For more details you can read the blog post &lt;em&gt;&lt;a href=&quot;http://codebucket.co.in/timestamp-vs-datetime/&quot;&gt;Timestamp Vs Datetime &lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">자세한 내용은 블로그 게시물 &lt;em&gt;&lt;a href=&quot;http://codebucket.co.in/timestamp-vs-datetime/&quot;&gt;Timestamp Vs Datetime을 참조하십시오&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dc856e5e23919033bd72ab59467477a0e61ba03c" translate="yes" xml:space="preserve">
          <source>For your clients comfort you want to show them the times based on their preferred time zones without making them doing the math and convert the time to their meaningful timezone. all you need is to change the timezone and all your application code will be the same.&lt;em&gt;(Actually you should always define the timezone at the start of the application, or request processing in case of PHP applications)&lt;/em&gt;</source>
          <target state="translated">고객의 편의를 위해 수학을 수행하지 않고 원하는 시간대를 기준으로 시간을 표시하고 시간을 의미있는 시간대로 변환하려고합니다. 시간대를 변경하기 만하면 모든 응용 프로그램 코드가 동일합니다. &lt;em&gt;(실제로 응용 프로그램을 시작할 때 시간대를 정의하거나 PHP 응용 프로그램의 경우 처리를 요청해야합니다)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64e254cfc8fee4a9ead40861b1246312894ba70c" translate="yes" xml:space="preserve">
          <source>From my experiences, if you want a date field in which insertion happens only once and you don't want to have any update or any other action on that particular field, go with &lt;strong&gt;date time&lt;/strong&gt;.</source>
          <target state="translated">내 경험에 따르면 삽입이 한 번만 발생하는 날짜 필드를 원하고 특정 필드에 대한 업데이트 또는 다른 작업을 원하지 않는 경우 &lt;strong&gt;date time으로&lt;/strong&gt; 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="6d1dbdfeac2373ec7aa37785a932e7c4d2c25cbb" translate="yes" xml:space="preserve">
          <source>Here are some cases that will make you regret using &lt;code&gt;datetime&lt;/code&gt; and wish that you stored your data in timestamps.</source>
          <target state="translated">다음은 &lt;code&gt;datetime&lt;/code&gt; 을 사용하여 후회하고 데이터를 타임 스탬프에 저장하기를 원하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="2da35bc820a81a1cb5374406c62ccc9e358ccf59" translate="yes" xml:space="preserve">
          <source>I almost always prefer timestamps rather than datetime fields, because timestamps include the timezone implicitly. So, since the moment that the app will be accessed from users from different time zones and you want them to see dates and times in their local timezone, this field type makes it pretty easy to do it than if the data were saved in datetime fields.</source>
          <target state="translated">타임 스탬프에는 표준 시간대가 암시 적으로 포함되므로 날짜 / 시간 필드보다는 타임 스탬프를 항상 선호합니다. 따라서 다른 시간대의 사용자가 앱을 액세스하고 현지 시간대로 날짜와 시간을 보려는 순간이 필드 유형을 사용하면 데이터가 날짜 시간 필드에 저장된 경우보다 쉽게 ​​수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5cd89f5ee8f947b442b15a5e503fefe94df935b" translate="yes" xml:space="preserve">
          <source>I always use DATETIME fields for anything other than row metadata (date created or modified).</source>
          <target state="translated">항상 행 메타 데이터 (생성 또는 수정 된 날짜) 이외의 다른 용도로 DATETIME 필드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a678e945f8d1f6465d392193c4faf6646c4cece9" translate="yes" xml:space="preserve">
          <source>I always use a Unix timestamp, simply to maintain sanity when dealing with a lot of datetime information, especially when performing adjustments for timezones, adding/subtracting dates, and the like. When comparing timestamps, this excludes the complicating factors of timezone and allows you to spare resources in your server side processing (Whether it be application code or database queries) in that you make use of light weight arithmetic rather then heavier date-time add/subtract functions.</source>
          <target state="translated">나는 항상 시간대를 조정하거나 날짜를 더하거나 뺄 때 등 많은 날짜 시간 정보를 다룰 때 정신을 유지하기 위해 항상 유닉스 타임 스탬프를 사용합니다. 타임 스탬프를 비교할 때, 이는 시간대의 복잡한 요소를 배제하고 서버 측 처리 (응용 프로그램 코드 또는 데이터베이스 쿼리 여부)에서 리소스를 여분으로 사용하는 것이 아니라 날짜-시간 더하기 / 빼기보다 가벼운 산술을 사용할 수 있도록합니다. 기능.</target>
        </trans-unit>
        <trans-unit id="206c1f2009ec676fc4a9eec50d54024944901e95" translate="yes" xml:space="preserve">
          <source>I found unsurpassed usefulness in TIMESTAMP's ability to auto update itself based on the current time without the use of unnecessary triggers. That's just me though, although TIMESTAMP is UTC like it was said.</source>
          <target state="translated">불필요한 트리거를 사용하지 않고 현재 시간을 기반으로 자동 업데이트하는 TIMESTAMP 기능에서 탁월한 유용성을 발견했습니다. 비록 TIMESTAMP가 UTC처럼 말했지만 그것은 단지 나입니다.</target>
        </trans-unit>
        <trans-unit id="d570a1bc95ba8702c39af942cff99df7742bb2be" translate="yes" xml:space="preserve">
          <source>I like a Unix timestamp, because you can convert to numbers and just worry about the number. Plus you add/subtract and get durations, etc. Then convert the result to Date in whatever format. This code finds out how much time in minutes passed between a timestamp from a document, and the current time.</source>
          <target state="translated">나는 숫자로 변환하고 숫자에 대해 걱정할 수 있기 때문에 유닉스 타임 스탬프를 좋아합니다. 또한 추가 / 빼기 및 지속 시간 등을 얻은 다음 결과를 형식에 관계없이 Date로 변환하십시오. 이 코드는 문서의 타임 스탬프와 현재 시간 사이의 시간 (분)을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cf4a40b7b0f9f34fbb16456724075a43d2ce0f45" translate="yes" xml:space="preserve">
          <source>I make this decision on a semantic base.</source>
          <target state="translated">나는이 결정을 시맨틱 기반으로한다.</target>
        </trans-unit>
        <trans-unit id="5ef7e671798c6131c697e0f63b12c62ab2bfa381" translate="yes" xml:space="preserve">
          <source>I prefer using timestamp so to keep everything in one common raw format and format the data in PHP code or in your SQL query. There are instances where it comes in handy in your code to keep everything in plain seconds.</source>
          <target state="translated">타임 스탬프를 사용하여 모든 것을 하나의 공통 원시 형식으로 유지하고 데이터를 PHP 코드 또는 SQL 쿼리로 형식화합니다. 모든 것을 평범한 초 안에 유지하기 위해 코드에서 편리한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e23b06243c6572b6cfb0e3cffcf474b9fa8522b8" translate="yes" xml:space="preserve">
          <source>I recommend using &lt;strong&gt;neither&lt;/strong&gt; a DATETIME or a TIMESTAMP field.  If you want to represent a specific day as a whole (like a birthday), then use a DATE type, but if you're being more specific than that, you're probably interested in recording an actual moment as opposed to a unit of time (day,week,month,year).  Instead of using a DATETIME or TIMESTAMP, use a BIGINT, and simply store the number of milliseconds since the epoch (System.currentTimeMillis() if you're using Java).  This has several advantages:</source>
          <target state="translated">DATETIME 또는 TIMESTAMP 필드를 사용 &lt;strong&gt;하지 않는&lt;/strong&gt; 것이 좋습니다. 특정 날짜를 전체 생일 (예 : 생일)로 나타내려면 DATE 유형을 사용하십시오. 그러나 그보다 더 구체적인 경우에는 단위가 아닌 실제 순간을 기록하는 데 관심이있을 것입니다. 시간 (일, 주, 월, 년). DATETIME 또는 TIMESTAMP를 사용하는 대신 BIGINT를 사용하고 신기원 이후의 시간 (밀리 초)을 저장하십시오 (Java를 사용하는 경우 System.currentTimeMillis ()). 여기에는 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32b22a379070f7ef416fd882ae9907f4cafcabff" translate="yes" xml:space="preserve">
          <source>I stopped using &lt;code&gt;datetime&lt;/code&gt; in my applications after facing many problems and bugs related to time zones. &lt;strong&gt;IMHO using &lt;code&gt;timestamp&lt;/code&gt; is better than &lt;code&gt;datetime&lt;/code&gt; in most of the cases&lt;/strong&gt;.</source>
          <target state="translated">표준 시간대와 관련된 많은 문제와 버그에 직면 한 후 응용 프로그램에서 &lt;code&gt;datetime&lt;/code&gt; 사용을 중단했습니다. &lt;strong&gt;대부분의 경우 &lt;code&gt;timestamp&lt;/code&gt; 사용하는 IMHO가 &lt;code&gt;datetime&lt;/code&gt; 보다 낫습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3e0f03321593d604ad3daae773b9b9de690bc1" translate="yes" xml:space="preserve">
          <source>I use a datetime field when the date/time can be set and changed arbitrarily. For example when a user can save later change appointments.</source>
          <target state="translated">날짜 / 시간을 임의로 설정하고 변경할 수있는 날짜 / 시간 필드를 사용합니다. 예를 들어, 사용자가 나중에 변경 약속을 저장할 수있는 경우.</target>
        </trans-unit>
        <trans-unit id="8b5833e1a61fb755b21f93ca6d1707ba3c9eb38b" translate="yes" xml:space="preserve">
          <source>I use a timestamp when I need to record a (more or less) fixed point in time. For example when a record was inserted into the database or when some user action took place.</source>
          <target state="translated">고정 된 특정 시점을 기록해야 할 때 타임 스탬프를 사용합니다. 예를 들어 레코드가 데이터베이스에 삽입되었거나 일부 사용자 작업이 발생한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="f86d1b7817db590f627374a0bcb90e6b5ff9a671" translate="yes" xml:space="preserve">
          <source>I would always use a Unix timestamp when working with MySQL and PHP. The main reason for this being the the default &lt;a href=&quot;http://uk3.php.net/manual/en/function.date.php&quot;&gt;date&lt;/a&gt; method in PHP uses a timestamp as the parameter, so there would be no parsing needed.</source>
          <target state="translated">MySQL과 PHP로 작업 할 때는 항상 Unix 타임 스탬프를 사용합니다. PHP에서 기본 &lt;a href=&quot;http://uk3.php.net/manual/en/function.date.php&quot;&gt;날짜&lt;/a&gt; 메소드가되는 주요 이유는 타임 스탬프를 매개 변수로 사용하므로 구문 분석이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9364c12edb1f9c9f5ec70d22a2e2dd682193867" translate="yes" xml:space="preserve">
          <source>I'm working with PHP on the server side.</source>
          <target state="translated">서버 측에서 PHP로 작업하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45ff0bb3a329fa67ebd8832f5d0546cb7f2251d" translate="yes" xml:space="preserve">
          <source>I've converted my answer into article so more people can find this useful, &lt;em&gt;&lt;a href=&quot;http://www.tech-recipes.com/rx/22599/mysql-datetime-vs-timestamp-data-type/&quot;&gt;MySQL: Datetime Versus Timestamp Data Types&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">더 많은 사람들이이 유용한 &lt;em&gt;&lt;a href=&quot;http://www.tech-recipes.com/rx/22599/mysql-datetime-vs-timestamp-data-type/&quot;&gt;MySQL을&lt;/a&gt;&lt;/em&gt; 찾을 수 있도록 내 답변을 기사로 변환했습니다 &lt;em&gt;. Datetime vs. Timestamp Data Types&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="31489a4469658ad39dd5d8120b54ba1d823877db" translate="yes" xml:space="preserve">
          <source>If you are creating the table from &lt;a href=&quot;http://en.wikipedia.org/wiki/PhpMyAdmin&quot;&gt;phpMyAdmin&lt;/a&gt; the default setting will update the &lt;strong&gt;timestamp&lt;/strong&gt; field when a row update happens. If your timestamp filed is not updating with row update, you can use the following query to make a &lt;strong&gt;timestamp&lt;/strong&gt; field get auto updated.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/PhpMyAdmin&quot;&gt;phpMyAdmin&lt;/a&gt; 에서 테이블을 생성하는 경우 기본 설정은 행 업데이트가 발생할 때 &lt;strong&gt;타임 스탬프&lt;/strong&gt; 필드를 업데이트합니다. 제출 된 타임 스탬프가 행 업데이트로 업데이트되지 않는 경우 다음 쿼리를 사용하여 &lt;strong&gt;타임 스탬프&lt;/strong&gt; 필드가 자동 업데이트되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1bb522d65d67e7cdbb1d7601b2e95f9a523514" translate="yes" xml:space="preserve">
          <source>If you meant that you want to decide between using a UNIX timestamp or a native MySQL datetime field, go with the native format. You can do calculations within MySQL that way 
&lt;code&gt;(&quot;SELECT DATE_ADD(my_datetime, INTERVAL 1 DAY)&quot;)&lt;/code&gt; and it is simple to change the format of the value to a UNIX timestamp &lt;code&gt;(&quot;SELECT UNIX_TIMESTAMP(my_datetime)&quot;)&lt;/code&gt; when you query the record if you want to operate on it with PHP.</source>
          <target state="translated">UNIX 타임 스탬프 또는 기본 MySQL 날짜 / 시간 필드를 사용하려는 경우 기본 형식을 사용하십시오. MySQL 내에서 그런 식으로 계산을 수행 할 수 있으며 &lt;code&gt;(&quot;SELECT DATE_ADD(my_datetime, INTERVAL 1 DAY)&quot;)&lt;/code&gt; 레코드를 쿼리 할 때 값 형식을 UNIX 타임 스탬프 &lt;code&gt;(&quot;SELECT UNIX_TIMESTAMP(my_datetime)&quot;)&lt;/code&gt; 로 변경하는 것이 간단합니다. PHP로 작업하고 싶다면.</target>
        </trans-unit>
        <trans-unit id="ffcc29ae487aa623bebb0ee1e8f86561c675d52d" translate="yes" xml:space="preserve">
          <source>If you're building an application, you never know how your data might have to be used down the line. If you wind up having to, say, compare a bunch of records in your data set, with, say, a bunch of items from a third-party API, and say, put them in chronological order, you'll be happy to have Unix timestamps for your rows. Even if you decide to use MySQL timestamps, store a Unix timestamp as insurance.</source>
          <target state="translated">응용 프로그램을 구축하는 경우 데이터를 어떻게 사용해야하는지 전혀 모릅니다. 예를 들어 데이터 세트의 여러 레코드를 타사 API의 여러 항목과 비교하고 시간순으로 정렬 해야하는 경우 기꺼이해야합니다. 행에 대한 유닉스 타임 스탬프. MySQL 타임 스탬프를 사용하기로 결정하더라도 Unix 타임 스탬프를 보험으로 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="c7995d4761522909b7214e1601ee4a9bbe7b4a1f" translate="yes" xml:space="preserve">
          <source>In &quot;bigger&quot; database terms, &lt;code&gt;timestamp&lt;/code&gt; has a couple of special-case triggers on it.</source>
          <target state="translated">&quot;더 큰&quot;데이터베이스 용어에서 &lt;code&gt;timestamp&lt;/code&gt; 에는 몇 가지 특수한 경우에 대한 트리거가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0d5700a614a6da306f30adf05aaca5b64dbbf1" translate="yes" xml:space="preserve">
          <source>In MySQL 5 and above, &lt;strong&gt;TIMESTAMP&lt;/strong&gt; values are converted from the current time zone to UTC for storage, and converted back from UTC to the current time zone for retrieval. (This occurs only for the TIMESTAMP data type, and &lt;em&gt;not&lt;/em&gt; for other types such as DATETIME.)</source>
          <target state="translated">MySQL 5 이상에서 &lt;strong&gt;TIMESTAMP&lt;/strong&gt; 값은 저장을 위해 현재 시간대에서 UTC로 변환되고 검색을 위해 UTC에서 현재 시간대로 다시 변환됩니다. (이는 TIMESTAMP 데이터 유형에만 발생하며 DATETIME과 같은 다른 유형에는 발생 &lt;em&gt;하지 않습니다&lt;/em&gt; .)</target>
        </trans-unit>
        <trans-unit id="6e195894f50db5526afc2ab1bf4e1d5658cbea95" translate="yes" xml:space="preserve">
          <source>In my case, I set UTC as a time zone for everything: the system, the database server, etc. every time that I can. If my customer requires another time zone, then I configure it on the app.</source>
          <target state="translated">필자의 경우 UTC는 가능한 한 시스템, 데이터베이스 서버 등 모든 시간대를 UTC로 설정했습니다. 고객에게 다른 시간대가 필요한 경우 앱에서 시간대를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="7b0a223418a395464ae8da509f57c18c6c1d324c" translate="yes" xml:space="preserve">
          <source>In short</source>
          <target state="translated">한마디로</target>
        </trans-unit>
        <trans-unit id="998430940a1cf51fc5ec051819a568638be1a42b" translate="yes" xml:space="preserve">
          <source>In simpler words: &lt;strong&gt;If I have a database in Australia, and take a dump of that database to synchronize/populate a database in America, then the TIMESTAMP would update to reflect the real time of the event in the new time zone, while DATETIME would still reflect the time of the event in the au time zone&lt;/strong&gt;.</source>
          <target state="translated">간단히 말해서 : &lt;strong&gt;호주에 데이터베이스가 있고 미국에서 데이터베이스를 동기화 / 채우기 위해 해당 데이터베이스를 덤프하면 TIMESTAMP는 새 시간대의 이벤트 실시간을 반영하도록 업데이트되지만 DATETIME은 여전히 au 시간대의 이벤트 시간을 반영합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="880e081828ff1887a05d731a268374d23ecff5d5" translate="yes" xml:space="preserve">
          <source>It can keep track across different timezones, so if you need to display a relative time for instance, UTC time is what you would want.</source>
          <target state="translated">다른 시간대를 추적 할 수 있으므로 예를 들어 상대 시간을 표시 해야하는 경우 UTC 시간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a41918ecbc3f538d35b22cc423624607a058a62e" translate="yes" xml:space="preserve">
          <source>It is worth noting in MySQL you can use something along the lines of the below when creating your table columns:</source>
          <target state="translated">MySQL에서는 테이블 열을 만들 때 아래 줄을 따라 무언가를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e551a0a9f5cec988bad0e24f623506d90ef7f587" translate="yes" xml:space="preserve">
          <source>MySQL Date/Time data types reference</source>
          <target state="translated">MySQL 날짜 / 시간 데이터 형식 참조</target>
        </trans-unit>
        <trans-unit id="ca1edfc72a341b43b90b702098e1f76bdd4e6abc" translate="yes" xml:space="preserve">
          <source>MySQL Storage Requirements reference</source>
          <target state="translated">MySQL 스토리지 요구 사항 참조</target>
        </trans-unit>
        <trans-unit id="6a4d8a0f46ff5193d118cc038fb1704445a83d9a" translate="yes" xml:space="preserve">
          <source>No timezone issues.  There's been some insightful comments on here on what happens with timezones with the different data types.  But is this common knowledge, and will your co-workers all take the time to learn it?  On the other hand, it's pretty hard to mess up changing a BigINT into a java.util.Date.  Using a BIGINT causes a lot of issues with timezones to fall by the wayside.</source>
          <target state="translated">시간대 문제가 없습니다. 데이터 유형이 다른 시간대에서 발생하는 일에 대한 통찰력있는 의견이 있습니다. 그러나이 상식은 무엇입니까? 동료가 배우는 데 시간이 걸리나요? 반면에 BigINT를 java.util.Date로 변경하는 것은 엉망입니다. BIGINT를 사용하면 시간대와 관련된 많은 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c435dd392d33aad96f73d02a6a3f30f54ccc0a19" translate="yes" xml:space="preserve">
          <source>No worries about ranges or precision.  You don't have to worry about what being cut short by future date ranges (TIMESTAMP only goes to 2038).</source>
          <target state="translated">범위 나 정밀도에 대해 걱정할 필요가 없습니다. 미래의 날짜 범위로 인해 시간이 단축되는 것에 대해 걱정할 필요가 없습니다 (TIMESTAMP는 2038로만 진행됨).</target>
        </trans-unit>
        <trans-unit id="91545e23ede1ee1fd22dcf98f82ebe9134aa6fe6" translate="yes" xml:space="preserve">
          <source>Note: default connection timezone is the server timezone, but this can (should) be changed per session (see &lt;code&gt;SET time_zone = ...&lt;/code&gt;).</source>
          <target state="translated">참고 : 기본 연결 시간대는 서버 시간대이지만 세션마다 변경할 수 있습니다 ( &lt;code&gt;SET time_zone = ...&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="db07d9be995e80601a3b13b3376307c58b5426b7" translate="yes" xml:space="preserve">
          <source>On the other hand, for values that represent system time like payment transactions, table modifications or logging, always use timestamps. The system will not be affected by moving the server to another time zone, or when comparing between servers in different timezones.</source>
          <target state="translated">반면 지불 트랜잭션, 테이블 수정 또는 로깅과 같은 시스템 시간을 나타내는 값에는 항상 타임 스탬프를 사용하십시오. 서버를 다른 시간대로 이동하거나 다른 시간대의 서버를 비교해도 시스템에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba1d189b28f2abf9d56261768ea0e3c3b0ad4737" translate="yes" xml:space="preserve">
          <source>Reference taken from this Article:</source>
          <target state="translated">이 기사에서 가져온 참조 :</target>
        </trans-unit>
        <trans-unit id="8b05b05f99d45086cfec2bd40e0912d41a40c935" translate="yes" xml:space="preserve">
          <source>Should I use the datetime or timestamp data type in MySQL</source>
          <target state="translated">MySQL에서 datetime 또는 timestamp 데이터 형식을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="045177b57f199536798f7602f5e2b8d9dcff5e1f" translate="yes" xml:space="preserve">
          <source>So for values that represent user time like an appointment or a schedule, datetime is better. It allows the user to control the exact date and time desired, regardless of the server settings. The set time is the set time, not affected by the server's time zone, the user's time zone, or by changes in the way daylight savings time is calculated (yes it does change).</source>
          <target state="translated">따라서 약속 또는 일정과 같은 사용자 시간을 나타내는 값의 경우 날짜 시간이 더 좋습니다. 사용자는 서버 설정에 관계없이 원하는 정확한 날짜와 시간을 제어 할 수 있습니다. 설정 시간은 서버 시간대, 사용자 시간대 또는 일광 절약 시간 계산 방식의 변경 (예 : 변경)의 영향을받지 않는 설정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="73a5a457c16ecd2093862684ea7c13eae5a14ea1" translate="yes" xml:space="preserve">
          <source>So it only matters when you have &amp;mdash; or may in the future have &amp;mdash; synchronized clusters across time zones.</source>
          <target state="translated">따라서 시간대에 따라 클러스터를 동기화했거나 향후 동기화해야 할 때만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="1653f1ba6251a7f548790a533e1efa888bef4509" translate="yes" xml:space="preserve">
          <source>So suppose you are in USA and getting data from a server which has a time zone of USA. Then you will get the date and time according to the USA time zone. The timestamp data type column always get updated automatically when its row gets updated. So it can be useful to track when a particular row was updated last time.</source>
          <target state="translated">따라서 미국에 있고 시간대가 미국인 서버에서 데이터를 얻는다고 가정하십시오. 그러면 미국 시간대에 따라 날짜와 시간이 표시됩니다. 타임 스탬프 데이터 형식 열은 행이 업데이트 될 때 항상 자동으로 업데이트됩니다. 따라서 마지막에 특정 행이 업데이트 된시기를 추적하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb10daa25dc60f8b1daad8f8e387e8e83eaf144b" translate="yes" xml:space="preserve">
          <source>So, to summarize, I value this advantages of timestamp:</source>
          <target state="translated">요약하면 타임 스탬프의 장점을 다음과 같이 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ada52d888ccf16d2711b8a6377768a782af5c30e" translate="yes" xml:space="preserve">
          <source>Sources:</source>
          <target state="translated">Sources:</target>
        </trans-unit>
        <trans-unit id="77f90354221d8a67dd1969d6e644c499a0514a52" translate="yes" xml:space="preserve">
          <source>TIMESTAMP also affected by different TIME ZONE related setting.
DATETIME is constant.</source>
          <target state="translated">TIMESTAMP는 또한 다른 TIME ZONE 관련 설정의 영향을받습니다. DATETIME은 일정합니다.</target>
        </trans-unit>
        <trans-unit id="c94a072eac65be71cfc849f9037072f6247474bd" translate="yes" xml:space="preserve">
          <source>TIMESTAMP internally converted current time zone to UTC for storage, and during retrieval converted back to the current time zone.
DATETIME can not do this.</source>
          <target state="translated">TIMESTAMP는 저장을 위해 내부적으로 현재 시간대를 UTC로 변환하고 검색하는 동안 현재 시간대로 다시 변환합니다. DATETIME은이 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dacee252d7b14073e849682cd79a8a03ac04c316" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is 4 bytes Vs 8 bytes for DATETIME.</source>
          <target state="translated">TIMESTAMP는 DATETIME 동안 4 바이트 대 8 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="a410814a3011c5943a3034941f92663affe3da22" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is always in UTC (that is, elapsed seconds since 1970-01-01, in UTC), and your MySQL server auto-converts it to the date/time for the connection timezone. In the long-term, TIMESTAMP is the way to go because you know your temporal data will always be in UTC. For example, you won't screw your dates up if you migrate to a different server or if you change the timezone settings on your server.</source>
          <target state="translated">TIMESTAMP는 항상 UTC이며 (즉, 1970-01-01 이후 UTC로 경과 한 초), MySQL 서버는이를 연결 시간대의 날짜 / 시간으로 자동 변환합니다. 장기적으로 TIMESTAMP는 시간 데이터가 항상 UTC로 표시되기 때문에 갈 길입니다. 예를 들어, 다른 서버로 마이그레이션하거나 서버의 시간대 설정을 변경해도 날짜가 정해지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8ac59d0c9ad21fe5948cec9369a8f0b45667f55" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is four bytes vs eight bytes for DATETIME.</source>
          <target state="translated">TIMESTAMP는 DATETIME의 경우 4 바이트 대 8 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="5d4df6053b746ece86d95685245755662b29cc96" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is still limited to 1970-2038</source>
          <target state="translated">TIMESTAMP는 여전히 1970-2038로 제한됩니다</target>
        </trans-unit>
        <trans-unit id="f9eb6fe6031fa5a60529bcb98828a895865741b2" translate="yes" xml:space="preserve">
          <source>TIMESTAMP supported range:
&amp;lsquo;1970-01-01 00:00:01&amp;prime; UTC to &amp;lsquo;2038-01-19 03:14:07&amp;prime; UTC
DATETIME supported range:
&amp;lsquo;1000-01-01 00:00:00&amp;prime; to &amp;lsquo;9999-12-31 23:59:59&amp;prime;</source>
          <target state="translated">TIMESTAMP 지원 범위 : '1970-01-01 00:00:01'UTC ~ '2038-01-19 03:14:07'UTC DATETIME 지원 범위 : '1000-01-01 00:00:00'~ '9999 -12-31 23:59:59 &amp;prime;</target>
        </trans-unit>
        <trans-unit id="1e8cfe79f87e9cf415a34e5da6160ec0183062d4" translate="yes" xml:space="preserve">
          <source>TIMESTAMP used to track changes to records, and update every time when the record is changed.
DATETIME used to store specific and static value which is not affected by any changes in records.</source>
          <target state="translated">TIMESTAMP는 레코드 변경 사항을 추적하고 레코드가 변경 될 때마다 업데이트하는 데 사용됩니다. DATETIME은 레코드 변경에 영향을받지 않는 특정 정적 값을 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f7ca32f1c995965b4caae3c7b57bf8c446174e" translate="yes" xml:space="preserve">
          <source>The DATETIME type is used when you need values that contain both date and time information. MySQL retrieves and displays DATETIME values in &amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo; format. The supported range is &amp;rsquo;1000-01-01 00:00:00&amp;prime; to &amp;rsquo;9999-12-31 23:59:59&amp;prime;.</source>
          <target state="translated">DATETIME 유형은 날짜 및 시간 정보가 모두 포함 된 값이 필요할 때 사용됩니다. MySQL은 'YYYY-MM-DD HH : MM : SS'형식으로 DATETIME 값을 검색하고 표시합니다. 지원되는 범위는 '1000-01-01 00:00:00'~ '9999-12-31 23:59:59'입니다.</target>
        </trans-unit>
        <trans-unit id="d995c3fc457d2a486d56301383483a0c59cd6c55" translate="yes" xml:space="preserve">
          <source>The DATETIME type is used when you need values that contain both date and time information. MySQL retrieves and displays DATETIME values in 'YYYY-MM-DD HH:MM:SS' format. The supported range is '1000-01-01 00:00:00' to '9999-12-31 23:59:59'.</source>
          <target state="translated">DATETIME 유형은 날짜 및 시간 정보가 모두 포함 된 값이 필요할 때 사용됩니다. MySQL은 'YYYY-MM-DD HH : MM : SS'형식으로 DATETIME 값을 검색하고 표시합니다. 지원되는 범위는 '1000-01-01 00:00:00'~ '9999-12-31 23:59:59'입니다.</target>
        </trans-unit>
        <trans-unit id="d1d182272c9e749c480b203f44a7403a8e892e56" translate="yes" xml:space="preserve">
          <source>The TIMESTAMP data type has a range of &amp;rsquo;1970-01-01 00:00:01&amp;prime; UTC to &amp;rsquo;2038-01-09 03:14:07&amp;prime; UTC. It has varying properties, depending on the MySQL version and the SQL mode the server is running in.</source>
          <target state="translated">TIMESTAMP 데이터 유형의 UTC 범위는 '1970-01-01 00:00:01'UTC에서 '2038-01-09 03:14:07'UTC입니다. MySQL 버전과 서버가 실행중인 SQL 모드에 따라 다양한 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="451a1b7a95752b8704aa14620a0ff8e1af0081b8" translate="yes" xml:space="preserve">
          <source>The TIMESTAMP data type has a range of '1970-01-01 00:00:01' UTC to '2038-01-09 03:14:07' UTC. It has varying properties, depending on the MySQL version and the SQL mode the server is running in.</source>
          <target state="translated">TIMESTAMP 데이터 유형의 범위는 '1970-01-01 00:00:01'UTC에서 '2038-01-09 03:14:07'UTC입니다. MySQL 버전과 서버가 실행중인 SQL 모드에 따라 다양한 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbacf6cd847f9d41776bc72041128127e5dd977" translate="yes" xml:space="preserve">
          <source>The below examples show how the &lt;code&gt;TIMESTAMP&lt;/code&gt; date type changed the values after changing the &lt;code&gt;time-zone to 'america/new_york'&lt;/code&gt; where &lt;code&gt;DATETIME&lt;/code&gt;is unchanged.</source>
          <target state="translated">아래 예제는 &lt;code&gt;time-zone to 'america/new_york'&lt;/code&gt; 변경 한 후 &lt;code&gt;TIMESTAMP&lt;/code&gt; 날짜 유형이 값을 어떻게 변경했는지 보여줍니다. 여기서 &lt;code&gt;DATETIME&lt;/code&gt; 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e0ed57105ef0f58a736d7ff36ae9c629f9e488a" translate="yes" xml:space="preserve">
          <source>The main difference is that DATETIME is constant while TIMESTAMP is affected by the &lt;code&gt;time_zone&lt;/code&gt; setting.</source>
          <target state="translated">주요 차이점은 DATETIME은 일정하고 TIMESTAMP는 &lt;code&gt;time_zone&lt;/code&gt; 설정의 영향을받는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b2f50d2734b460f0fadb92162062e81c8ec1ffbb" translate="yes" xml:space="preserve">
          <source>The major difference is</source>
          <target state="translated">가장 큰 차이점은</target>
        </trans-unit>
        <trans-unit id="c26db8d70224fe926b15eb61a7302596d74d511e" translate="yes" xml:space="preserve">
          <source>The timestamp data type stores date and time, but in UTC format, not in the current timezone format as datetime does. And when you fetch data, timestamp again converts that into the current timezone time.</source>
          <target state="translated">타임 스탬프 데이터 형식은 날짜 및 시간을 저장하지만 datetime처럼 현재 시간대 형식이 아닌 UTC 형식으로 저장합니다. 그리고 데이터를 가져올 때 타임 스탬프는 다시 현재 시간대 시간으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="cf32d1d08b4bc2bc4010812ed8c9ae1f696d2151" translate="yes" xml:space="preserve">
          <source>Third-party tool integration.  By using an integer, it's trivial for 3rd party tools (e.g. EclipseLink) to interface with the database.  Not every third-party tool is going to have the same understanding of a &quot;datetime&quot; as MySQL does.  Want to try and figure out in Hibernate whether you should use a java.sql.TimeStamp or java.util.Date object if you're using these custom data types?  Using your base data types make's use with 3rd-party tools trivial.</source>
          <target state="translated">타사 도구 통합. 정수를 사용하면 써드 파티 도구 (예 : EclipseLink)가 데이터베이스와 인터페이스하는 것이 쉽지 않습니다. 모든 타사 도구가 MySQL과 &quot;날짜 / 시간&quot;을 동일하게 이해하는 것은 아닙니다. 이러한 사용자 정의 데이터 유형을 사용하는 경우 java.sql.TimeStamp 또는 java.util.Date 객체를 사용해야하는지 Hibernate에서 알아 내고 싶습니까? 기본 데이터 유형을 사용하면 타사 도구를 사소하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c80400b73324c73575938e491d735cda350d3b" translate="yes" xml:space="preserve">
          <source>This issue is closely related how you should store a money value (i.e. $1.99) in a database.  Should you use a Decimal, or the database's Money type, or worst of all a Double? All 3 of these options are terrible, for many of the same reasons listed above.  The solution is to store the value of money in cents using BIGINT, and then convert cents to dollars when you display the value to the user.  The database's job is to store data, and NOT to intrepret that data.  All these fancy data-types you see in databases(especially Oracle) add little, and start you down the road to vendor lock-in.</source>
          <target state="translated">이 문제는 데이터베이스에 돈 값 (예 : $ 1.99)을 저장하는 방법과 밀접한 관련이 있습니다. Decimal 또는 데이터베이스의 Money 유형을 사용해야합니까 아니면 최악의 Double을 사용해야합니까? 이러한 옵션 중 세 가지 모두 위에 나열된 여러 가지 이유로 끔찍합니다. 해결책은 BIGINT를 사용하여 돈의 가치를 센트로 저장 한 다음 사용자에게 가치를 표시 할 때 센트를 달러로 변환하는 것입니다. 데이터베이스의 임무는 데이터를 저장하고 해당 데이터를 해석하지 않는 것입니다. 데이터베이스 (특히 Oracle)에서 볼 수있는이 모든 멋진 데이터 유형은 거의 추가되지 않으며 벤더 잠금을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7209c28d9c054e86435df0e23a3343e8a1f40ced" translate="yes" xml:space="preserve">
          <source>This will update the time at each instance you modify a row and is sometimes very helpful for stored last edit information. This only works with timestamp, not datetime however.</source>
          <target state="translated">이렇게하면 각 인스턴스에서 행을 수정하는 시간이 업데이트되고 마지막 편집 정보를 저장하는 데 매우 유용합니다. 그러나 datetime이 아닌 timestamp에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="04cfc0761251068bf684bad9ba6e3db23f02b537" translate="yes" xml:space="preserve">
          <source>Timestamps are also lighter on the database and indexed faster.</source>
          <target state="translated">타임 스탬프도 데이터베이스에서 더 가벼워지고 더 빠르게 색인됩니다.</target>
        </trans-unit>
        <trans-unit id="39b7c7fd16c84befdb2fbc7842a2f1b007beb800" translate="yes" xml:space="preserve">
          <source>Timestamps in MySQL are generally used to track changes to records, and are often updated every time the record is changed. If you want to store a specific value you should use a datetime field.</source>
          <target state="translated">MySQL의 타임 스탬프는 일반적으로 레코드 변경 사항을 추적하는 데 사용되며 종종 레코드가 변경 될 때마다 업데이트됩니다. 특정 값을 저장하려면 날짜 시간 필드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cdbc16fb39ccae8f270c66140498641e37ffbff" translate="yes" xml:space="preserve">
          <source>To get the current Unix timestamp in PHP, just do &lt;code&gt;time();&lt;/code&gt;</source>
          <target state="translated">PHP에서 현재 유닉스 타임 스탬프를 얻으려면 &lt;code&gt;time();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cd063cd0d9b6c24ab996012840118b6a4b97e0b" translate="yes" xml:space="preserve">
          <source>Using datetimes without the timezone means that your application is dealing with only 1 timezone, however timestamps give you the benefits of &lt;code&gt;datetime&lt;/code&gt; plus the flexibility of showing the same exact point of time in different timezones.</source>
          <target state="translated">시간대없이 날짜 / 시간을 사용한다는 것은 응용 프로그램이 하나의 시간대 만 처리한다는 것을 의미하지만 타임 스탬프는 &lt;code&gt;datetime&lt;/code&gt; 의 이점과 다른 시간대에서 동일한 정확한 시점을 표시 할 수있는 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6679d8851bfecb41edd8ddf8dff3f76a03f04b74" translate="yes" xml:space="preserve">
          <source>What the right one is depends entirely on what you want to do.</source>
          <target state="translated">올바른 것은 전적으로 원하는 것에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="15e16ae2b3038140af7aae3650d4e538db2056d5" translate="yes" xml:space="preserve">
          <source>When you ask what is the time ? and the answer comes as something like '2019-02-05 21:18:30', that is not completed, not defined answer because it lacks another part, in which timezone  ? Washington ? Moscow ? Beijing ?</source>
          <target state="translated">당신은 시간이 언제 물어볼 때? 그리고 대답은 '2019-02-05 21:18:30'과 같이 나타납니다. 완료되지 않고 정의되지 않은 대답은 다른 부분이 없기 때문에 어떤 시간대에 있습니까? 워싱턴? 모스크바? 베이징 ?</target>
        </trans-unit>
        <trans-unit id="0b3ff16b336587556b1fa0fdb27cf08aee358bed" translate="yes" xml:space="preserve">
          <source>Would you recommend using a &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;datetime&lt;/a&gt; or a &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;timestamp&lt;/a&gt; field, and why (using MySQL)?</source>
          <target state="translated">&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;datetime&lt;/a&gt; 또는 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;timestamp&lt;/a&gt; 필드를 사용하는 것이 좋으며 왜 MySQL을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="99ccf3adb5db0d31246743ae82d394360ce5b265" translate="yes" xml:space="preserve">
          <source>You avoid vendor lock-in.  Pretty much every database supports integers in the relatively similar fashion.  Suppose you want to move to another database.  Do you want to worry about the differences between MySQL's DATETIME values and how Oracle defines them?  Even among different versions of MySQL, TIMESTAMPS have a different level of precision.  It was only just recently that MySQL supported milliseconds in the timestamps.</source>
          <target state="translated">벤더 잠금을 피하십시오. 거의 모든 데이터베이스는 비교적 비슷한 방식으로 정수를 지원합니다. 다른 데이터베이스로 이동한다고 가정하십시오. MySQL의 DATETIME 값과 Oracle이 어떻게 정의하는지의 차이점에 대해 걱정하고 싶습니까? 다른 버전의 MySQL 중에서도 TIMESTAMPS의 정밀도는 다릅니다. 최근에야 MySQL이 타임 스탬프에서 밀리 초를 지원했습니다.</target>
        </trans-unit>
        <trans-unit id="8b4895f794a8283459ca4a088274ede5b50f7a7f" translate="yes" xml:space="preserve">
          <source>You're quite likely to hit the lower limit on TIMESTAMPs in general use -- e.g. storing birthdate.</source>
          <target state="translated">생년월일 저장과 같이 일반적으로 사용되는 TIMESTAMP의 하한에 도달 할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="fe7b915adc41c235ae2019a5d63666bcb6f784aa" translate="yes" xml:space="preserve">
          <source>a INDEX's on Datetime   - &lt;a href=&quot;https://stackoverflow.com/questions/4013301/mysql-datetime-index-is-not-working&quot;&gt;Does not work&lt;/a&gt;</source>
          <target state="translated">Datetime의 INDEX- &lt;a href=&quot;https://stackoverflow.com/questions/4013301/mysql-datetime-index-is-not-working&quot;&gt;작동하지 않습니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c058c66e16779f3e5d87b80818f4e54711ee832a" translate="yes" xml:space="preserve">
          <source>a INDEX's on Timestamp  - works</source>
          <target state="translated">INDEX의 타임 스탬프-작동</target>
        </trans-unit>
        <trans-unit id="14c88ff2f0e7f0d7d01802892756e11f40be03b1" translate="yes" xml:space="preserve">
          <source>and in MySQL do &lt;code&gt;SELECT UNIX_TIMESTAMP();&lt;/code&gt;.</source>
          <target state="translated">MySQL에서는 &lt;code&gt;SELECT UNIX_TIMESTAMP();&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bef63f4643b53c0e6c20553bb1f0543b403021b5" translate="yes" xml:space="preserve">
          <source>easy migrations between time zones</source>
          <target state="translated">시간대 간 쉬운 마이그레이션</target>
        </trans-unit>
        <trans-unit id="7ae8438fcf4f03e1bbb55d35dceda8efa0bd317f" translate="yes" xml:space="preserve">
          <source>look at this &lt;a href=&quot;https://stackoverflow.com/questions/95183/how-does-one-create-an-index-on-the-date-part-of-datetime-field-in-mysql&quot;&gt;post to see problems with Datetime indexing&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/95183/how-does-one-create-an-index-on-the-date-part-of-datetime-field-in-mysql&quot;&gt;Datetime 인덱싱 관련 문제를 보려면&lt;/a&gt; 이 게시물을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="944e5c03bdda873f2d9a030910c0d94089a1d341" translate="yes" xml:space="preserve">
          <source>no worry about dates in/out a summer time period</source>
          <target state="translated">여름철에 날짜 / 시간에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="68c2634f494de50ae1701c5c57288cb89cec17cd" translate="yes" xml:space="preserve">
          <source>pretty easy to calculate diferences (just subtract both timestamps)</source>
          <target state="translated">차이를 계산하기가 매우 쉽습니다 (두 타임 스탬프를 빼기 만하면됩니다)</target>
        </trans-unit>
        <trans-unit id="d38547cfd2b4a24917f0893ead653bf6ef1602f3" translate="yes" xml:space="preserve">
          <source>ready to use on international (multi time zone) apps</source>
          <target state="translated">국제 (다중 시간대) 앱에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="18f605dfe1380d283d7c7607e5798ee1e187bbce" translate="yes" xml:space="preserve">
          <source>then every single value in your 'Date_Added' column would be changed to the current timestamp.</source>
          <target state="translated">'Date_Added'열의 모든 단일 값이 현재 타임 스탬프로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="9b99af1d5f813e03b16069c39a0d4de32de49280" translate="yes" xml:space="preserve">
          <source>you accept data from different clients around the world, each of them inserts the time in his timezone.</source>
          <target state="translated">전 세계 여러 고객의 데이터를 수락하며 각 고객은 자신의 시간대에 시간을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="a1900144dd02e0b44d98690cdbca12f939cbf4a9" translate="yes" xml:space="preserve">
          <source>you changed the country you stay in, and continue your work of maintaining the data while seeing it in a different timezone (without changing the actual data).</source>
          <target state="translated">귀하는 귀하가 거주하는 국가를 변경했으며 실제 시간대를 변경하지 않고 다른 시간대에서 보는 동안 데이터 유지 보수 작업을 계속합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
