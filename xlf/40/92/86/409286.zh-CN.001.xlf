<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/409286">
    <body>
      <group id="409286">
        <trans-unit id="593a02a118c1f362caa2e58db6d6664e3f576b7f" translate="yes" xml:space="preserve">
          <source>(Unless you are likely to change the timezone of your servers)</source>
          <target state="translated">除非你有可能改变你的服务器的时间区)。</target>
        </trans-unit>
        <trans-unit id="d27bbad1be4b90f3efb7c75a4b43f6fa388fae5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;datetime&lt;/code&gt; = application supports 1 timezone (for both inserting and selecting)</source>
          <target state="translated">&lt;code&gt;datetime&lt;/code&gt; =应用程序支持1个时区（用于插入和选择）</target>
        </trans-unit>
        <trans-unit id="20905d1d1b479330793c32af9ed0fa9beb9adb03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; = application supports any timezone (for both inserting and selecting)</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; =应用程序支持任何时区（用于插入和选择）</target>
        </trans-unit>
        <trans-unit id="349a08ae5d6ed4659b0bcd3ec7c70e280bab22c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;2016 +&lt;/em&gt;: what I advise is to set your Mysql timezone to UTC and use DATETIME:</source>
          <target state="translated">&lt;em&gt;2016 +&lt;/em&gt; ：我建议您将Mysql时区设置为UTC并使用DATETIME：</target>
        </trans-unit>
        <trans-unit id="331d547d2d77f302ef10428b2a9addf2ef86e968" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This answer is only for putting some highlight on the flexibility and ease of timestamps when it comes to time zones , it is not covering any other differences like the &lt;a href=&quot;https://stackoverflow.com/a/45632196/5407848&quot;&gt;column size or range or fraction&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;该答案仅是为了突出时区的灵活性和时间戳的易用性，而没有涵盖&lt;a href=&quot;https://stackoverflow.com/a/45632196/5407848&quot;&gt;列大小，范围或分数之&lt;/a&gt;类的任何其他差异。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8d39d205db25f2106a7af756b95fdfef76c9718" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The main differences:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;主要区别：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34da79ccaf9b8c0d6c96a398c7de54c386c7c5d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is that [.fraction]?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;那是什么[.fraction]？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ccacfe5d1464a272d0161bc29e81b58fd87fa55" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TIMESTAMP&lt;/code&gt; requires 4 bytes, whereas a &lt;code&gt;DATETIME&lt;/code&gt; requires 8 bytes.</source>
          <target state="translated">&lt;code&gt;TIMESTAMP&lt;/code&gt; 需要4个字节，而 &lt;code&gt;DATETIME&lt;/code&gt; 需要8个字节。</target>
        </trans-unit>
        <trans-unit id="6f86f9e143c43e826773e4340f28d06abfa21196" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;timestamp&lt;/code&gt; field is a special case of the &lt;code&gt;datetime&lt;/code&gt; field. You can create &lt;code&gt;timestamp&lt;/code&gt; columns to have special properties; it can be set to update itself on either create and/or update.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 字段是 &lt;code&gt;datetime&lt;/code&gt; 时间字段的特例。 您可以创建 &lt;code&gt;timestamp&lt;/code&gt; 列以具有特殊属性。 可以将其设置为在创建和/或更新时自行更新。</target>
        </trans-unit>
        <trans-unit id="23afe721d17e7bce6561ecac0c0767557c18f3e2" translate="yes" xml:space="preserve">
          <source>A DATETIME or TIMESTAMP value can include a trailing fractional
seconds part in up to microseconds (6 digits) precision. In
particular, any fractional part in a value inserted into a DATETIME
or TIMESTAMP column is stored rather than discarded. This is of course optional.</source>
          <target state="translated">一个DATETIME或TIMESTAMP值可以包含一个尾随的小数秒部分,精度最高为微秒(6位数)。特别是,插入到DATETIME或TIMESTAMP列的值中的任何小数部分都会被存储而不是丢弃。这当然是可选的。</target>
        </trans-unit>
        <trans-unit id="105e72149319d74d06cd9e179968cd6895c674de" translate="yes" xml:space="preserve">
          <source>A great example of DATETIME being used where TIMESTAMP should have been used is in Facebook, where their servers are never quite sure what time stuff happened across time zones. Once I was having a conversation in which the time said I was replying to messages before the message was actually sent. (This, of course, could also have been caused by bad time zone translation in the messaging software if the times were being posted rather than synchronized.)</source>
          <target state="translated">一个很好的例子是在Facebook中使用了DATETIME,而TIMESTAMP本该使用的是DATETIME,他们的服务器永远无法确定跨时区的时间。有一次,我在进行对话时,时间显示我在回复消息之前就已经回复了。(当然,这也可能是由于消息软件中的时区翻译不好造成的,如果时间是发布的,而不是同步的的话。)</target>
        </trans-unit>
        <trans-unit id="ac1d2a76e849b1b5833ee66f2036219c73ed4239" translate="yes" xml:space="preserve">
          <source>Additionally:</source>
          <target state="translated">Additionally:</target>
        </trans-unit>
        <trans-unit id="a1f945cbe8c29cec65da8e8eab6c4e28b4f16229" translate="yes" xml:space="preserve">
          <source>All localised time format available here:
&lt;a href=&quot;https://docs.angularjs.org/api/ng/filter/date&quot;&gt;https://docs.angularjs.org/api/ng/filter/date&lt;/a&gt;</source>
          <target state="translated">此处提供所有本地化的时间格式： &lt;a href=&quot;https://docs.angularjs.org/api/ng/filter/date&quot;&gt;https&lt;/a&gt; ： //docs.angularjs.org/api/ng/filter/date</target>
        </trans-unit>
        <trans-unit id="03f4ab0cfb5116acacf82c79980bbc4c1538ca3f" translate="yes" xml:space="preserve">
          <source>Another difference between Timestamp and Datetime is in Timestamp you can't default value to NULL.</source>
          <target state="translated">Timestamp和Datetime的另一个区别是,在Timestamp中,你不能默认值为NULL。</target>
        </trans-unit>
        <trans-unit id="8649432b65d482601d32ced47b86cec528e6f13e" translate="yes" xml:space="preserve">
          <source>Another thing worth considering:</source>
          <target state="translated">另一个值得考虑的事情。</target>
        </trans-unit>
        <trans-unit id="7e4bc976d9f0aa9df498da0d674146848c45e317" translate="yes" xml:space="preserve">
          <source>Any recent front-end framework (Angular 1/2, react, Vue,...) can easily and automatically convert your UTC datetime to local time.</source>
          <target state="translated">任何最近的前端框架(Angular 12、react、Vue...........)都可以轻松自动将你的UTC日期时间转换为本地时间。</target>
        </trans-unit>
        <trans-unit id="1f02b723ecb30f7a7b86943f5693d1a105ed169a" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/datetime.html&quot;&gt;mentioned&lt;/a&gt; in the MySQL documentation:</source>
          <target state="translated">如MySQL文档中所述：</target>
        </trans-unit>
        <trans-unit id="30a7616be2ba7d64b9561fa7bcf55829ad69bc78" translate="yes" xml:space="preserve">
          <source>As a plus, in the case of a migration of the database to a system with another timezone, I would feel more confident using timestamps. Not to say possible issues when calculating differences between two moments with a sumer time change in between and needing a precision of 1 hour or less.</source>
          <target state="translated">作为一个补充,在数据库迁移到另一个时区系统的情况下,我觉得使用时间戳会更有信心。更不用说在计算两个时刻之间的差值时可能出现的问题了,因为这两个时刻之间的时间变化需要1小时或更小的精度。</target>
        </trans-unit>
        <trans-unit id="75c9379a28896ce9890676a1ef0ca87e210c0b0c" translate="yes" xml:space="preserve">
          <source>Beware of timestamp changing when you do a UPDATE statement on a table.  If you have a table with columns 'Name' (varchar), 'Age' (int), and 'Date_Added' (timestamp) and you run the following DML statement</source>
          <target state="translated">注意当你在表上执行UPDATE语句时,时间戳会发生变化。如果你有一个表的列 &quot;Name&quot;(varchar)、&quot;Age&quot;(int)和 &quot;Date_Added&quot;(timestamp),并且你运行以下DML语句</target>
        </trans-unit>
        <trans-unit id="048fad409fc302137354247e34dd35f44fb43704" translate="yes" xml:space="preserve">
          <source>But like scronide said it does have a lower limit of the year 1970. It's great for anything that might happen in the future though ;)</source>
          <target state="translated">但正如scronide所说,它确实有1970年的下限。这对于未来可能发生的任何事情来说都是很好的;)</target>
        </trans-unit>
        <trans-unit id="0b3bafc7f7ed6d1609b9c2c4fd043e820e24cc01" translate="yes" xml:space="preserve">
          <source>By default, the current time zone for each connection is the server's time. The time zone can be set on a per-connection basis, as described in &lt;em&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en//time-zone-support.html&quot;&gt;MySQL Server Time Zone Support&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">默认情况下，每个连接的当前时区是服务器的时间。 可以在每个连接的基础上设置时区，如&lt;em&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en//time-zone-support.html&quot;&gt;MySQL服务器时区支持中所述&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="46e754d5823f336c6879ab95356aa5286d30a861" translate="yes" xml:space="preserve">
          <source>Comparison between DATETIME, TIMESTAMP and DATE</source>
          <target state="translated">DATETIME、TIMESTAMP和DATE之间的比较</target>
        </trans-unit>
        <trans-unit id="dfa016c1ac5a15d6be12e485338468f1d8936cd6" translate="yes" xml:space="preserve">
          <source>Consider setting a timestamp by a user to a server in New York, for an appointment in Sanghai. Now when the user connects in Sanghai, he accesses the same appointment timestamp from a mirrored server in Tokyo. He will see the appointment in Tokyo time, offset from the original New York time.</source>
          <target state="translated">考虑用户在纽约的服务器上设置一个时间戳,在上海的预约时间戳。现在当用户在桑海连接时,他从东京的镜像服务器上访问同样的预约时间戳。他将看到东京时间的预约,与原来的纽约时间相抵。</target>
        </trans-unit>
        <trans-unit id="36abbe8686064b87032b977c64e9037a1ab43ae2" translate="yes" xml:space="preserve">
          <source>Contrary to what one might think, DATETIME is &lt;strong&gt;FASTER&lt;/strong&gt; THAN TIMESTAMP,
&lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&quot;&gt;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&lt;/a&gt;</source>
          <target state="translated">与人们可能想到的相反，DATETIME比时间戳更&lt;strong&gt;快速&lt;/strong&gt; ， &lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&quot;&gt;http&lt;/a&gt; ： &lt;strong&gt;//gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with&lt;/strong&gt; -myisam /</target>
        </trans-unit>
        <trans-unit id="8cd06d5b91f44e6c7d8bb5a9e4b6c53eb080b994" translate="yes" xml:space="preserve">
          <source>DATETIME can now be &lt;strong&gt;automatically&lt;/strong&gt; set to the current time value &lt;a href=&quot;https://stackoverflow.com/questions/168736/how-do-you-set-a-default-value-for-a-mysql-datetime-column/10603198#10603198&quot;&gt;How do you set a default value for a MySQL Datetime column?&lt;/a&gt;</source>
          <target state="translated">现在可以将DATETIME &lt;strong&gt;自动&lt;/strong&gt;设置为当前时间值。 &lt;a href=&quot;https://stackoverflow.com/questions/168736/how-do-you-set-a-default-value-for-a-mysql-datetime-column/10603198#10603198&quot;&gt;如何为MySQL Datetime列设置默认值？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bb751509c73535fc71ab28078b2a2cd7cff076c" translate="yes" xml:space="preserve">
          <source>DATETIME is constant while TIMESTAMP is effected by the time_zone setting.</source>
          <target state="translated">DATETIME是常数,而TIMESTAMP受时区设置的影响。</target>
        </trans-unit>
        <trans-unit id="e606ed7f8ffdfa79456bda0bab96b69794b076de" translate="yes" xml:space="preserve">
          <source>Depends on application, really.</source>
          <target state="translated">要看应用,真的。</target>
        </trans-unit>
        <trans-unit id="793dba92e4fad48f46012613b16dac7b1259878a" translate="yes" xml:space="preserve">
          <source>Example with AngularJs</source>
          <target state="translated">使用AngularJs的例子</target>
        </trans-unit>
        <trans-unit id="b632b31f3430f0f42e92741a8e59ca31ba0a5461" translate="yes" xml:space="preserve">
          <source>For all this reasons, I choose UTC &amp;amp; timestamp fields where posible. And I avoid headaches ;)</source>
          <target state="translated">由于所有这些原因，我在可能的地方选择UTC和时间戳字段。 而且我避免头痛;）</target>
        </trans-unit>
        <trans-unit id="6b6dd3a87f08f57887386997d7393798f29857fa" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;user&lt;/code&gt; table with a &lt;strong&gt;REGISTRATION DATE&lt;/strong&gt; field. In that &lt;code&gt;user&lt;/code&gt; table, if you want to know the last logged in time of a particular user, go with a field of &lt;strong&gt;timestamp&lt;/strong&gt; type so that the field gets updated.</source>
          <target state="translated">例如，考虑一个带有&lt;strong&gt;REGISTRATION DATE&lt;/strong&gt;字段的 &lt;code&gt;user&lt;/code&gt; 表。 在该 &lt;code&gt;user&lt;/code&gt; 表中，如果您想知道特定用户的上次登录时间，请使用&lt;strong&gt;时间戳&lt;/strong&gt;类型的字段，以便该字段得到更新。</target>
        </trans-unit>
        <trans-unit id="4911c2a3fb22efedb0166e219e1c072fdeeb59f1" translate="yes" xml:space="preserve">
          <source>For more details you can read the blog post &lt;em&gt;&lt;a href=&quot;http://codebucket.co.in/timestamp-vs-datetime/&quot;&gt;Timestamp Vs Datetime &lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">有关更多详细信息，请阅读博客文章&lt;em&gt;&lt;a href=&quot;http://codebucket.co.in/timestamp-vs-datetime/&quot;&gt;Timestamp Vs Datetime&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc856e5e23919033bd72ab59467477a0e61ba03c" translate="yes" xml:space="preserve">
          <source>For your clients comfort you want to show them the times based on their preferred time zones without making them doing the math and convert the time to their meaningful timezone. all you need is to change the timezone and all your application code will be the same.&lt;em&gt;(Actually you should always define the timezone at the start of the application, or request processing in case of PHP applications)&lt;/em&gt;</source>
          <target state="translated">为了让您的客户感到舒适，您想根据他们的首选时区向他们显示时间，而无需让他们进行数学运算并将时间转换为有意义的时区。 您所需要做的就是更改时区，所有应用程序代码都将相同。 &lt;em&gt;（实际上，您应该始终在应用程序启动时定义时区，或者在PHP应用程序的情况下请求处理）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64e254cfc8fee4a9ead40861b1246312894ba70c" translate="yes" xml:space="preserve">
          <source>From my experiences, if you want a date field in which insertion happens only once and you don't want to have any update or any other action on that particular field, go with &lt;strong&gt;date time&lt;/strong&gt;.</source>
          <target state="translated">根据我的经验，如果您希望只在其中插入一次的日期字段，并且不想对该特定字段进行任何更新或任何其他操作，请选择&lt;strong&gt;date time&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d1dbdfeac2373ec7aa37785a932e7c4d2c25cbb" translate="yes" xml:space="preserve">
          <source>Here are some cases that will make you regret using &lt;code&gt;datetime&lt;/code&gt; and wish that you stored your data in timestamps.</source>
          <target state="translated">在某些情况下，您可能会后悔使用 &lt;code&gt;datetime&lt;/code&gt; 并希望将数据存储在时间戳中。</target>
        </trans-unit>
        <trans-unit id="2da35bc820a81a1cb5374406c62ccc9e358ccf59" translate="yes" xml:space="preserve">
          <source>I almost always prefer timestamps rather than datetime fields, because timestamps include the timezone implicitly. So, since the moment that the app will be accessed from users from different time zones and you want them to see dates and times in their local timezone, this field type makes it pretty easy to do it than if the data were saved in datetime fields.</source>
          <target state="translated">我几乎总是喜欢时间戳而不是日期时间字段,因为时间戳隐含了时区。因此,因为当用户从不同的时区访问应用程序的时候,你希望他们看到的日期和时间是在当地的时区,这种字段类型比起保存在日期时间字段中的数据更容易做到。</target>
        </trans-unit>
        <trans-unit id="a5cd89f5ee8f947b442b15a5e503fefe94df935b" translate="yes" xml:space="preserve">
          <source>I always use DATETIME fields for anything other than row metadata (date created or modified).</source>
          <target state="translated">除了行元数据(创建或修改日期)之外,我总是使用DATETIME字段。</target>
        </trans-unit>
        <trans-unit id="a678e945f8d1f6465d392193c4faf6646c4cece9" translate="yes" xml:space="preserve">
          <source>I always use a Unix timestamp, simply to maintain sanity when dealing with a lot of datetime information, especially when performing adjustments for timezones, adding/subtracting dates, and the like. When comparing timestamps, this excludes the complicating factors of timezone and allows you to spare resources in your server side processing (Whether it be application code or database queries) in that you make use of light weight arithmetic rather then heavier date-time add/subtract functions.</source>
          <target state="translated">我总是使用Unix时间戳,只是为了在处理大量的日期时间信息时保持理智,特别是在执行时区调整、加减日期等操作时。当比较时间戳的时候,这排除了时间区的复杂因素,让你可以在服务器端处理时(不管是应用程序代码还是数据库查询)节省资源,因为你可以使用轻量级的算术,而不是使用较重的日期时间加减函数。</target>
        </trans-unit>
        <trans-unit id="206c1f2009ec676fc4a9eec50d54024944901e95" translate="yes" xml:space="preserve">
          <source>I found unsurpassed usefulness in TIMESTAMP's ability to auto update itself based on the current time without the use of unnecessary triggers. That's just me though, although TIMESTAMP is UTC like it was said.</source>
          <target state="translated">我发现TIMESTAMP的功能是无与伦比的,它可以根据当前时间自动更新,无需使用不必要的触发器。不过这只是我的看法,虽然TIMESTAMP是UTC,但就像上面说的那样。</target>
        </trans-unit>
        <trans-unit id="d570a1bc95ba8702c39af942cff99df7742bb2be" translate="yes" xml:space="preserve">
          <source>I like a Unix timestamp, because you can convert to numbers and just worry about the number. Plus you add/subtract and get durations, etc. Then convert the result to Date in whatever format. This code finds out how much time in minutes passed between a timestamp from a document, and the current time.</source>
          <target state="translated">我喜欢Unix的时间戳,因为你可以转换为数字,只需要担心数字就可以了。再加上你可以加减法,得到持续时间等。然后将结果转换为Date,不管是什么格式,都可以。这段代码可以找出文档中的时间戳和当前时间之间的时间间隔,以分钟为单位。</target>
        </trans-unit>
        <trans-unit id="cf4a40b7b0f9f34fbb16456724075a43d2ce0f45" translate="yes" xml:space="preserve">
          <source>I make this decision on a semantic base.</source>
          <target state="translated">我做这个决定是有语义基础的。</target>
        </trans-unit>
        <trans-unit id="5ef7e671798c6131c697e0f63b12c62ab2bfa381" translate="yes" xml:space="preserve">
          <source>I prefer using timestamp so to keep everything in one common raw format and format the data in PHP code or in your SQL query. There are instances where it comes in handy in your code to keep everything in plain seconds.</source>
          <target state="translated">我更喜欢使用时间戳,这样可以把所有的东西都保持在一个通用的原始格式中,并在PHP代码或SQL查询中格式化数据。在某些情况下,在你的代码中,它在你的代码中很有用,可以把所有的东西都保留在普通的秒数中。</target>
        </trans-unit>
        <trans-unit id="e23b06243c6572b6cfb0e3cffcf474b9fa8522b8" translate="yes" xml:space="preserve">
          <source>I recommend using &lt;strong&gt;neither&lt;/strong&gt; a DATETIME or a TIMESTAMP field.  If you want to represent a specific day as a whole (like a birthday), then use a DATE type, but if you're being more specific than that, you're probably interested in recording an actual moment as opposed to a unit of time (day,week,month,year).  Instead of using a DATETIME or TIMESTAMP, use a BIGINT, and simply store the number of milliseconds since the epoch (System.currentTimeMillis() if you're using Java).  This has several advantages:</source>
          <target state="translated">我建议不要使用DATETIME或TIMESTAMP字段。 如果要表示一个特定的一天（例如生日），请使用DATE类型，但是如果要更具体一些，则可能有兴趣记录实际时刻而不是单位时间（天，周，月，年）。 而不是使用DATETIME或TIMESTAMP，而使用BIGINT，只需存储自历元以来的毫秒数（如果使用Java，则为System.currentTimeMillis（））。 这有几个优点：</target>
        </trans-unit>
        <trans-unit id="32b22a379070f7ef416fd882ae9907f4cafcabff" translate="yes" xml:space="preserve">
          <source>I stopped using &lt;code&gt;datetime&lt;/code&gt; in my applications after facing many problems and bugs related to time zones. &lt;strong&gt;IMHO using &lt;code&gt;timestamp&lt;/code&gt; is better than &lt;code&gt;datetime&lt;/code&gt; in most of the cases&lt;/strong&gt;.</source>
          <target state="translated">在遇到许多与时区有关的问题和错误之后，我停止在应用程序中使用 &lt;code&gt;datetime&lt;/code&gt; 。 &lt;strong&gt;在大多数情况下，使用 &lt;code&gt;timestamp&lt;/code&gt; IMHO优于 &lt;code&gt;datetime&lt;/code&gt; 时间&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac3e0f03321593d604ad3daae773b9b9de690bc1" translate="yes" xml:space="preserve">
          <source>I use a datetime field when the date/time can be set and changed arbitrarily. For example when a user can save later change appointments.</source>
          <target state="translated">当日期时间可以被设置和任意更改时,我使用了一个日期时间字段。例如,当用户可以保存以后更改预约时。</target>
        </trans-unit>
        <trans-unit id="8b5833e1a61fb755b21f93ca6d1707ba3c9eb38b" translate="yes" xml:space="preserve">
          <source>I use a timestamp when I need to record a (more or less) fixed point in time. For example when a record was inserted into the database or when some user action took place.</source>
          <target state="translated">当我需要记录一个(或多或少)固定时间点时,我使用时间戳。例如,当一条记录被插入到数据库中时,或者是用户的某个动作发生时。</target>
        </trans-unit>
        <trans-unit id="f86d1b7817db590f627374a0bcb90e6b5ff9a671" translate="yes" xml:space="preserve">
          <source>I would always use a Unix timestamp when working with MySQL and PHP. The main reason for this being the the default &lt;a href=&quot;http://uk3.php.net/manual/en/function.date.php&quot;&gt;date&lt;/a&gt; method in PHP uses a timestamp as the parameter, so there would be no parsing needed.</source>
          <target state="translated">在使用MySQL和PHP时，我总是会使用Unix时间戳。 这样做的主要原因是PHP中默认的&lt;a href=&quot;http://uk3.php.net/manual/en/function.date.php&quot;&gt;date&lt;/a&gt;方法使用时间戳作为参数，因此不需要解析。</target>
        </trans-unit>
        <trans-unit id="e9364c12edb1f9c9f5ec70d22a2e2dd682193867" translate="yes" xml:space="preserve">
          <source>I'm working with PHP on the server side.</source>
          <target state="translated">我在服务器端使用的是PHP。</target>
        </trans-unit>
        <trans-unit id="a45ff0bb3a329fa67ebd8832f5d0546cb7f2251d" translate="yes" xml:space="preserve">
          <source>I've converted my answer into article so more people can find this useful, &lt;em&gt;&lt;a href=&quot;http://www.tech-recipes.com/rx/22599/mysql-datetime-vs-timestamp-data-type/&quot;&gt;MySQL: Datetime Versus Timestamp Data Types&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">我已经将答案转换成文章，以便更多人可以找到有用的&lt;em&gt;&lt;a href=&quot;http://www.tech-recipes.com/rx/22599/mysql-datetime-vs-timestamp-data-type/&quot;&gt;MySQL：Datetime与Timestamp数据类型&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="31489a4469658ad39dd5d8120b54ba1d823877db" translate="yes" xml:space="preserve">
          <source>If you are creating the table from &lt;a href=&quot;http://en.wikipedia.org/wiki/PhpMyAdmin&quot;&gt;phpMyAdmin&lt;/a&gt; the default setting will update the &lt;strong&gt;timestamp&lt;/strong&gt; field when a row update happens. If your timestamp filed is not updating with row update, you can use the following query to make a &lt;strong&gt;timestamp&lt;/strong&gt; field get auto updated.</source>
          <target state="translated">如果要通过&lt;a href=&quot;http://en.wikipedia.org/wiki/PhpMyAdmin&quot;&gt;phpMyAdmin&lt;/a&gt;创建表，则默认设置将在发生行更新时更新&lt;strong&gt;时间戳&lt;/strong&gt;字段。 如果您的&lt;strong&gt;时间戳&lt;/strong&gt;字段未使用行更新进行更新，则可以使用以下查询使&lt;strong&gt;时间戳&lt;/strong&gt;字段自动更新。</target>
        </trans-unit>
        <trans-unit id="9b1bb522d65d67e7cdbb1d7601b2e95f9a523514" translate="yes" xml:space="preserve">
          <source>If you meant that you want to decide between using a UNIX timestamp or a native MySQL datetime field, go with the native format. You can do calculations within MySQL that way 
&lt;code&gt;(&quot;SELECT DATE_ADD(my_datetime, INTERVAL 1 DAY)&quot;)&lt;/code&gt; and it is simple to change the format of the value to a UNIX timestamp &lt;code&gt;(&quot;SELECT UNIX_TIMESTAMP(my_datetime)&quot;)&lt;/code&gt; when you query the record if you want to operate on it with PHP.</source>
          <target state="translated">如果您想在使用UNIX时间戳还是使用本机MySQL日期时间字段之间做出选择，请使用本机格式。 您可以通过这种方式在MySQL中进行计算 &lt;code&gt;(&quot;SELECT DATE_ADD(my_datetime, INTERVAL 1 DAY)&quot;)&lt;/code&gt; 并且在查询记录时将值的格式更改为UNIX时间戳 &lt;code&gt;(&quot;SELECT UNIX_TIMESTAMP(my_datetime)&quot;)&lt;/code&gt; 。如果要使用PHP对其进行操作。</target>
        </trans-unit>
        <trans-unit id="ffcc29ae487aa623bebb0ee1e8f86561c675d52d" translate="yes" xml:space="preserve">
          <source>If you're building an application, you never know how your data might have to be used down the line. If you wind up having to, say, compare a bunch of records in your data set, with, say, a bunch of items from a third-party API, and say, put them in chronological order, you'll be happy to have Unix timestamps for your rows. Even if you decide to use MySQL timestamps, store a Unix timestamp as insurance.</source>
          <target state="translated">如果你正在构建一个应用程序,你永远不知道你的数据可能要如何使用。如果你最终不得不将数据集中的一堆记录与第三方API中的一堆项目进行比较,比如说,将它们按时间顺序排列,你会很乐意为你的行存储Unix时间戳。即使你决定使用MySQL时间戳,也要存储一个Unix时间戳作为保险。</target>
        </trans-unit>
        <trans-unit id="c7995d4761522909b7214e1601ee4a9bbe7b4a1f" translate="yes" xml:space="preserve">
          <source>In &quot;bigger&quot; database terms, &lt;code&gt;timestamp&lt;/code&gt; has a couple of special-case triggers on it.</source>
          <target state="translated">用&amp;ldquo;更大&amp;rdquo;的数据库术语来说， &lt;code&gt;timestamp&lt;/code&gt; 有几个特殊情况的触发器。</target>
        </trans-unit>
        <trans-unit id="2b0d5700a614a6da306f30adf05aaca5b64dbbf1" translate="yes" xml:space="preserve">
          <source>In MySQL 5 and above, &lt;strong&gt;TIMESTAMP&lt;/strong&gt; values are converted from the current time zone to UTC for storage, and converted back from UTC to the current time zone for retrieval. (This occurs only for the TIMESTAMP data type, and &lt;em&gt;not&lt;/em&gt; for other types such as DATETIME.)</source>
          <target state="translated">在MySQL 5及更高版本中， &lt;strong&gt;TIMESTAMP&lt;/strong&gt;值从当前时区转换为UTC以进行存储，并从UTC转换回当前时区以进行检索。 （这仅发生在TIMESTAMP数据类型上， &lt;em&gt;而不发生&lt;/em&gt;在其他类型上，例如DATETIME。）</target>
        </trans-unit>
        <trans-unit id="6e195894f50db5526afc2ab1bf4e1d5658cbea95" translate="yes" xml:space="preserve">
          <source>In my case, I set UTC as a time zone for everything: the system, the database server, etc. every time that I can. If my customer requires another time zone, then I configure it on the app.</source>
          <target state="translated">在我的情况下,我每次都会把UTC设置为时区:系统、数据库服务器等。如果我的客户需要另一个时区,我就会在应用程序中配置它。</target>
        </trans-unit>
        <trans-unit id="7b0a223418a395464ae8da509f57c18c6c1d324c" translate="yes" xml:space="preserve">
          <source>In short</source>
          <target state="translated">简而言之</target>
        </trans-unit>
        <trans-unit id="998430940a1cf51fc5ec051819a568638be1a42b" translate="yes" xml:space="preserve">
          <source>In simpler words: &lt;strong&gt;If I have a database in Australia, and take a dump of that database to synchronize/populate a database in America, then the TIMESTAMP would update to reflect the real time of the event in the new time zone, while DATETIME would still reflect the time of the event in the au time zone&lt;/strong&gt;.</source>
          <target state="translated">用简单的话来说： &lt;strong&gt;如果我在澳大利亚有一个数据库，并转储该数据库以在美国同步/填充数据库，则TIMESTAMP将更新以反映新时区的事件实时，而DATETIME会仍然反映事件在时区的时间&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="880e081828ff1887a05d731a268374d23ecff5d5" translate="yes" xml:space="preserve">
          <source>It can keep track across different timezones, so if you need to display a relative time for instance, UTC time is what you would want.</source>
          <target state="translated">它可以追踪不同的时区,所以如果你需要显示相对时间,比如说UTC时间就是你想要的。</target>
        </trans-unit>
        <trans-unit id="a41918ecbc3f538d35b22cc423624607a058a62e" translate="yes" xml:space="preserve">
          <source>It is worth noting in MySQL you can use something along the lines of the below when creating your table columns:</source>
          <target state="translated">值得注意的是,在MySQL中,在创建表列的时候,你可以使用下面这样的方法。</target>
        </trans-unit>
        <trans-unit id="e551a0a9f5cec988bad0e24f623506d90ef7f587" translate="yes" xml:space="preserve">
          <source>MySQL Date/Time data types reference</source>
          <target state="translated">MySQL DateTime数据类型参考</target>
        </trans-unit>
        <trans-unit id="ca1edfc72a341b43b90b702098e1f76bdd4e6abc" translate="yes" xml:space="preserve">
          <source>MySQL Storage Requirements reference</source>
          <target state="translated">MySQL存储需求参考</target>
        </trans-unit>
        <trans-unit id="6a4d8a0f46ff5193d118cc038fb1704445a83d9a" translate="yes" xml:space="preserve">
          <source>No timezone issues.  There's been some insightful comments on here on what happens with timezones with the different data types.  But is this common knowledge, and will your co-workers all take the time to learn it?  On the other hand, it's pretty hard to mess up changing a BigINT into a java.util.Date.  Using a BIGINT causes a lot of issues with timezones to fall by the wayside.</source>
          <target state="translated">不存在时区问题。这里有一些关于不同数据类型的时区问题的精辟评论。但是这些常识,你的同事们都会花时间去学习吗?另一方面,把BIGINT改成java.utilite.Date是相当难的。使用BIGINT会导致很多关于时序的问题落下帷幕。</target>
        </trans-unit>
        <trans-unit id="c435dd392d33aad96f73d02a6a3f30f54ccc0a19" translate="yes" xml:space="preserve">
          <source>No worries about ranges or precision.  You don't have to worry about what being cut short by future date ranges (TIMESTAMP only goes to 2038).</source>
          <target state="translated">无需担心范围或精度问题。您不必担心未来的日期范围会被缩短(TIMESTAMP只到2038年)。</target>
        </trans-unit>
        <trans-unit id="91545e23ede1ee1fd22dcf98f82ebe9134aa6fe6" translate="yes" xml:space="preserve">
          <source>Note: default connection timezone is the server timezone, but this can (should) be changed per session (see &lt;code&gt;SET time_zone = ...&lt;/code&gt;).</source>
          <target state="translated">注意：默认连接时区是服务器时区，但是可以（应该）在每个会话中更改它（请参阅 &lt;code&gt;SET time_zone = ...&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="db07d9be995e80601a3b13b3376307c58b5426b7" translate="yes" xml:space="preserve">
          <source>On the other hand, for values that represent system time like payment transactions, table modifications or logging, always use timestamps. The system will not be affected by moving the server to another time zone, or when comparing between servers in different timezones.</source>
          <target state="translated">另一方面,对于代表系统时间的值,如支付事务、表修改或日志记录等,一定要使用时间戳。将服务器移到其他时区,或者在不同时区的服务器之间进行比较时,系统不会受到影响。</target>
        </trans-unit>
        <trans-unit id="ba1d189b28f2abf9d56261768ea0e3c3b0ad4737" translate="yes" xml:space="preserve">
          <source>Reference taken from this Article:</source>
          <target state="translated">参考文献摘自本条。</target>
        </trans-unit>
        <trans-unit id="8b05b05f99d45086cfec2bd40e0912d41a40c935" translate="yes" xml:space="preserve">
          <source>Should I use the datetime or timestamp data type in MySQL</source>
          <target state="translated">我应该在MySQL中使用日期时间戳数据类型还是时间戳数据类型?</target>
        </trans-unit>
        <trans-unit id="045177b57f199536798f7602f5e2b8d9dcff5e1f" translate="yes" xml:space="preserve">
          <source>So for values that represent user time like an appointment or a schedule, datetime is better. It allows the user to control the exact date and time desired, regardless of the server settings. The set time is the set time, not affected by the server's time zone, the user's time zone, or by changes in the way daylight savings time is calculated (yes it does change).</source>
          <target state="translated">所以,对于代表用户时间的值,比如约会或日程表,datetime比较好。它可以让用户控制所需的准确日期和时间,不受服务器设置的影响。设定的时间就是设定好的时间,不受服务器的时区、用户的时区、或夏令时的计算方式的变化影响(没错,它确实会变化)。</target>
        </trans-unit>
        <trans-unit id="73a5a457c16ecd2093862684ea7c13eae5a14ea1" translate="yes" xml:space="preserve">
          <source>So it only matters when you have &amp;mdash; or may in the future have &amp;mdash; synchronized clusters across time zones.</source>
          <target state="translated">因此，只有在跨时区拥有或将来有同步集群时，才有意义。</target>
        </trans-unit>
        <trans-unit id="1653f1ba6251a7f548790a533e1efa888bef4509" translate="yes" xml:space="preserve">
          <source>So suppose you are in USA and getting data from a server which has a time zone of USA. Then you will get the date and time according to the USA time zone. The timestamp data type column always get updated automatically when its row gets updated. So it can be useful to track when a particular row was updated last time.</source>
          <target state="translated">所以,假设你在美国,从一个美国时区的服务器上获取数据。那么你将根据美国时区得到日期和时间。时间戳数据类型的列总是在其行被更新时自动更新。因此,它可以用来追踪某一行最后一次更新的时间。</target>
        </trans-unit>
        <trans-unit id="eb10daa25dc60f8b1daad8f8e387e8e83eaf144b" translate="yes" xml:space="preserve">
          <source>So, to summarize, I value this advantages of timestamp:</source>
          <target state="translated">所以,总结一下,我看重的是时间戳的这个优点。</target>
        </trans-unit>
        <trans-unit id="ada52d888ccf16d2711b8a6377768a782af5c30e" translate="yes" xml:space="preserve">
          <source>Sources:</source>
          <target state="translated">Sources:</target>
        </trans-unit>
        <trans-unit id="77f90354221d8a67dd1969d6e644c499a0514a52" translate="yes" xml:space="preserve">
          <source>TIMESTAMP also affected by different TIME ZONE related setting.
DATETIME is constant.</source>
          <target state="translated">TIMESTAMP也会受到不同时区相关设置的影响。DATETIME是常数。</target>
        </trans-unit>
        <trans-unit id="c94a072eac65be71cfc849f9037072f6247474bd" translate="yes" xml:space="preserve">
          <source>TIMESTAMP internally converted current time zone to UTC for storage, and during retrieval converted back to the current time zone.
DATETIME can not do this.</source>
          <target state="translated">TIMESTAMP内部将当前时区转换为UTC存储,并在检索时转换回当前时区。DATETIME不能这样做。</target>
        </trans-unit>
        <trans-unit id="dacee252d7b14073e849682cd79a8a03ac04c316" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is 4 bytes Vs 8 bytes for DATETIME.</source>
          <target state="translated">TIMESTAMP为4个字节,而DATETIME为8个字节。</target>
        </trans-unit>
        <trans-unit id="a410814a3011c5943a3034941f92663affe3da22" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is always in UTC (that is, elapsed seconds since 1970-01-01, in UTC), and your MySQL server auto-converts it to the date/time for the connection timezone. In the long-term, TIMESTAMP is the way to go because you know your temporal data will always be in UTC. For example, you won't screw your dates up if you migrate to a different server or if you change the timezone settings on your server.</source>
          <target state="translated">TIMESTAMP始终是以UTC为单位(即从1970-01-01-01起,以UTC为单位),你的MySQL服务器会自动将其转换为连接时间区的日期时间。从长远来看,TIMESTAMP是最佳选择,因为你知道你的时间数据永远是UTC。例如,如果你迁移到不同的服务器,或者改变服务器上的时区设置,你就不会把你的日期搞砸了。</target>
        </trans-unit>
        <trans-unit id="e8ac59d0c9ad21fe5948cec9369a8f0b45667f55" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is four bytes vs eight bytes for DATETIME.</source>
          <target state="translated">TIMESTAMP为4个字节,而DATETIME为8个字节。</target>
        </trans-unit>
        <trans-unit id="5d4df6053b746ece86d95685245755662b29cc96" translate="yes" xml:space="preserve">
          <source>TIMESTAMP is still limited to 1970-2038</source>
          <target state="translated">TIMESTAMP仍然限于1970年至2038年。</target>
        </trans-unit>
        <trans-unit id="f9eb6fe6031fa5a60529bcb98828a895865741b2" translate="yes" xml:space="preserve">
          <source>TIMESTAMP supported range:
&amp;lsquo;1970-01-01 00:00:01&amp;prime; UTC to &amp;lsquo;2038-01-19 03:14:07&amp;prime; UTC
DATETIME supported range:
&amp;lsquo;1000-01-01 00:00:00&amp;prime; to &amp;lsquo;9999-12-31 23:59:59&amp;prime;</source>
          <target state="translated">支持的TIMESTAMP范围：'1970-01-01 00:00:01'UTC至'2038-01-19 03:14:07'UTC DATETIME支持的范围：'1000-01-01 00:00:00'至'9999 -12-31 23:59:59&amp;prime;</target>
        </trans-unit>
        <trans-unit id="1e8cfe79f87e9cf415a34e5da6160ec0183062d4" translate="yes" xml:space="preserve">
          <source>TIMESTAMP used to track changes to records, and update every time when the record is changed.
DATETIME used to store specific and static value which is not affected by any changes in records.</source>
          <target state="translated">TIMESTAMP用于跟踪记录的变化,并在每次记录变化时更新。DATETIME用于存储特定的静态值,不受记录变化的影响。</target>
        </trans-unit>
        <trans-unit id="f5f7ca32f1c995965b4caae3c7b57bf8c446174e" translate="yes" xml:space="preserve">
          <source>The DATETIME type is used when you need values that contain both date and time information. MySQL retrieves and displays DATETIME values in &amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo; format. The supported range is &amp;rsquo;1000-01-01 00:00:00&amp;prime; to &amp;rsquo;9999-12-31 23:59:59&amp;prime;.</source>
          <target state="translated">当您需要同时包含日期和时间信息的值时，将使用DATETIME类型。 MySQL检索并以'YYYY-MM-DD HH：MM：SS'格式显示DATETIME值。 支持的范围是'1000-01-01 00:00:00'至'9999-12-31 23:59:59'。</target>
        </trans-unit>
        <trans-unit id="d995c3fc457d2a486d56301383483a0c59cd6c55" translate="yes" xml:space="preserve">
          <source>The DATETIME type is used when you need values that contain both date and time information. MySQL retrieves and displays DATETIME values in 'YYYY-MM-DD HH:MM:SS' format. The supported range is '1000-01-01 00:00:00' to '9999-12-31 23:59:59'.</source>
          <target state="translated">DATETIME类型用于需要同时包含日期和时间信息的值时。MySQL以'YYY-MM-DD HH:MM:SS'格式检索和显示DATETIME值。支持的范围是'1000-01-01-01 00:00:00:00'到'9999-12-31 23:59:59:59'。</target>
        </trans-unit>
        <trans-unit id="d1d182272c9e749c480b203f44a7403a8e892e56" translate="yes" xml:space="preserve">
          <source>The TIMESTAMP data type has a range of &amp;rsquo;1970-01-01 00:00:01&amp;prime; UTC to &amp;rsquo;2038-01-09 03:14:07&amp;prime; UTC. It has varying properties, depending on the MySQL version and the SQL mode the server is running in.</source>
          <target state="translated">TIMESTAMP数据类型的UTC范围为'1970-01-01 00:00:01'UTC至'2038-01-09 03:14:07'UTC。 它具有不同的属性，具体取决于运行服务器的MySQL版本和SQL模式。</target>
        </trans-unit>
        <trans-unit id="451a1b7a95752b8704aa14620a0ff8e1af0081b8" translate="yes" xml:space="preserve">
          <source>The TIMESTAMP data type has a range of '1970-01-01 00:00:01' UTC to '2038-01-09 03:14:07' UTC. It has varying properties, depending on the MySQL version and the SQL mode the server is running in.</source>
          <target state="translated">TIMESTAMP数据类型的范围是'1970-01-01-01 00:00:00:01'UTC到'2038-01-09 03:14:07'UTC。它有不同的属性,取决于服务器运行的MySQL版本和SQL模式。</target>
        </trans-unit>
        <trans-unit id="5dbacf6cd847f9d41776bc72041128127e5dd977" translate="yes" xml:space="preserve">
          <source>The below examples show how the &lt;code&gt;TIMESTAMP&lt;/code&gt; date type changed the values after changing the &lt;code&gt;time-zone to 'america/new_york'&lt;/code&gt; where &lt;code&gt;DATETIME&lt;/code&gt;is unchanged.</source>
          <target state="translated">下面的示例显示在将 &lt;code&gt;DATETIME&lt;/code&gt; 保持不变的 &lt;code&gt;time-zone to 'america/new_york'&lt;/code&gt; 更改为&amp;ldquo; america / new_york&amp;rdquo;后， &lt;code&gt;TIMESTAMP&lt;/code&gt; 日期类型如何更改值。</target>
        </trans-unit>
        <trans-unit id="6e0ed57105ef0f58a736d7ff36ae9c629f9e488a" translate="yes" xml:space="preserve">
          <source>The main difference is that DATETIME is constant while TIMESTAMP is affected by the &lt;code&gt;time_zone&lt;/code&gt; setting.</source>
          <target state="translated">主要区别在于DATETIME是常数，而TIMESTAMP受 &lt;code&gt;time_zone&lt;/code&gt; 设置影响。</target>
        </trans-unit>
        <trans-unit id="b2f50d2734b460f0fadb92162062e81c8ec1ffbb" translate="yes" xml:space="preserve">
          <source>The major difference is</source>
          <target state="translated">主要的区别在于</target>
        </trans-unit>
        <trans-unit id="c26db8d70224fe926b15eb61a7302596d74d511e" translate="yes" xml:space="preserve">
          <source>The timestamp data type stores date and time, but in UTC format, not in the current timezone format as datetime does. And when you fetch data, timestamp again converts that into the current timezone time.</source>
          <target state="translated">时间戳数据类型存储日期和时间,但以UTC格式存储,而不是像datetime那样以当前时区格式存储。而当你获取数据时,timestamp会再次将其转换为当前时区时间。</target>
        </trans-unit>
        <trans-unit id="cf32d1d08b4bc2bc4010812ed8c9ae1f696d2151" translate="yes" xml:space="preserve">
          <source>Third-party tool integration.  By using an integer, it's trivial for 3rd party tools (e.g. EclipseLink) to interface with the database.  Not every third-party tool is going to have the same understanding of a &quot;datetime&quot; as MySQL does.  Want to try and figure out in Hibernate whether you should use a java.sql.TimeStamp or java.util.Date object if you're using these custom data types?  Using your base data types make's use with 3rd-party tools trivial.</source>
          <target state="translated">第三方工具的集成。通过使用一个整数,第三方工具(如EclipseLink)与数据库的接口是很简单的。不是每一个第三方工具都会像MySQL那样对 &quot;datetime &quot;有同样的理解。想在Hibernate中尝试一下,如果你使用这些自定义数据类型,你应该使用java.sql.TimeStamp还是java.util.Date对象?使用你的基础数据类型,可以让第三方工具的使用变得简单易行。</target>
        </trans-unit>
        <trans-unit id="10c80400b73324c73575938e491d735cda350d3b" translate="yes" xml:space="preserve">
          <source>This issue is closely related how you should store a money value (i.e. $1.99) in a database.  Should you use a Decimal, or the database's Money type, or worst of all a Double? All 3 of these options are terrible, for many of the same reasons listed above.  The solution is to store the value of money in cents using BIGINT, and then convert cents to dollars when you display the value to the user.  The database's job is to store data, and NOT to intrepret that data.  All these fancy data-types you see in databases(especially Oracle) add little, and start you down the road to vendor lock-in.</source>
          <target state="translated">这个问题与你应该如何在数据库中存储一个货币值(即1.99美元)密切相关。你应该使用十进制,还是数据库的Money类型,或者最糟糕的是使用Double?这3个选项都很糟糕,原因和上面列出的许多相同。解决的办法是使用BIGINT将钱的值存储为美分,然后在显示给用户时将美分转换为美元。数据库的工作是存储数据,而不是解释数据。你在数据库中看到的所有这些花哨的数据类型(尤其是Oracle)都不会增加什么,而且会让你在厂商锁定的道路上开始走下去。</target>
        </trans-unit>
        <trans-unit id="7209c28d9c054e86435df0e23a3343e8a1f40ced" translate="yes" xml:space="preserve">
          <source>This will update the time at each instance you modify a row and is sometimes very helpful for stored last edit information. This only works with timestamp, not datetime however.</source>
          <target state="translated">这将在你每次修改一行时更新时间,有时对存储的最后一次编辑信息非常有用。但这只适用于时间戳,而不是日期时间戳。</target>
        </trans-unit>
        <trans-unit id="04cfc0761251068bf684bad9ba6e3db23f02b537" translate="yes" xml:space="preserve">
          <source>Timestamps are also lighter on the database and indexed faster.</source>
          <target state="translated">时间戳在数据库中也更轻,索引速度更快。</target>
        </trans-unit>
        <trans-unit id="39b7c7fd16c84befdb2fbc7842a2f1b007beb800" translate="yes" xml:space="preserve">
          <source>Timestamps in MySQL are generally used to track changes to records, and are often updated every time the record is changed. If you want to store a specific value you should use a datetime field.</source>
          <target state="translated">MySQL中的时间戳一般是用来跟踪记录的变化,通常在记录每次变化时都会更新。如果你想存储一个特定的值,你应该使用日期时间字段。</target>
        </trans-unit>
        <trans-unit id="0cdbc16fb39ccae8f270c66140498641e37ffbff" translate="yes" xml:space="preserve">
          <source>To get the current Unix timestamp in PHP, just do &lt;code&gt;time();&lt;/code&gt;</source>
          <target state="translated">要获得PHP中当前的Unix时间戳，只需执行 &lt;code&gt;time();&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cd063cd0d9b6c24ab996012840118b6a4b97e0b" translate="yes" xml:space="preserve">
          <source>Using datetimes without the timezone means that your application is dealing with only 1 timezone, however timestamps give you the benefits of &lt;code&gt;datetime&lt;/code&gt; plus the flexibility of showing the same exact point of time in different timezones.</source>
          <target state="translated">使用不带时区的datetimes意味着您的应用程序仅处理1个时区，但是时间戳为您提供了 &lt;code&gt;datetime&lt;/code&gt; 的好处，以及在不同时区中显示相同精确时间点的灵活性。</target>
        </trans-unit>
        <trans-unit id="6679d8851bfecb41edd8ddf8dff3f76a03f04b74" translate="yes" xml:space="preserve">
          <source>What the right one is depends entirely on what you want to do.</source>
          <target state="translated">什么是正确的,完全取决于你想做什么。</target>
        </trans-unit>
        <trans-unit id="15e16ae2b3038140af7aae3650d4e538db2056d5" translate="yes" xml:space="preserve">
          <source>When you ask what is the time ? and the answer comes as something like '2019-02-05 21:18:30', that is not completed, not defined answer because it lacks another part, in which timezone  ? Washington ? Moscow ? Beijing ?</source>
          <target state="translated">当你问时间是什么时候? 答案是'2019-02-05 21:18:30',这是不完整的,没有定义的答案,因为它缺乏另一部分,在哪个时区?华盛顿?莫斯科?北京?</target>
        </trans-unit>
        <trans-unit id="0b3ff16b336587556b1fa0fdb27cf08aee358bed" translate="yes" xml:space="preserve">
          <source>Would you recommend using a &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;datetime&lt;/a&gt; or a &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;timestamp&lt;/a&gt; field, and why (using MySQL)?</source>
          <target state="translated">您是否建议使用&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;日期&lt;/a&gt; &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.0/en/datetime.html&quot;&gt;时间&lt;/a&gt;或时间戳字段？为什么（使用MySQL）？</target>
        </trans-unit>
        <trans-unit id="99ccf3adb5db0d31246743ae82d394360ce5b265" translate="yes" xml:space="preserve">
          <source>You avoid vendor lock-in.  Pretty much every database supports integers in the relatively similar fashion.  Suppose you want to move to another database.  Do you want to worry about the differences between MySQL's DATETIME values and how Oracle defines them?  Even among different versions of MySQL, TIMESTAMPS have a different level of precision.  It was only just recently that MySQL supported milliseconds in the timestamps.</source>
          <target state="translated">你可以避免供应商的锁定。几乎所有的数据库都以相对类似的方式支持整数。假设你想转移到另一个数据库。你是否要担心MySQL的DATETIME值和Oracle如何定义它们之间的差异?即使在不同版本的MySQL中,TIMESTAMPS的精度也是不同的。直到最近,MySQL才支持时间戳中的毫秒数。</target>
        </trans-unit>
        <trans-unit id="8b4895f794a8283459ca4a088274ede5b50f7a7f" translate="yes" xml:space="preserve">
          <source>You're quite likely to hit the lower limit on TIMESTAMPs in general use -- e.g. storing birthdate.</source>
          <target state="translated">你很可能会在一般使用中触及TIMESTAMP的下限 ----例如存储出生日期。</target>
        </trans-unit>
        <trans-unit id="fe7b915adc41c235ae2019a5d63666bcb6f784aa" translate="yes" xml:space="preserve">
          <source>a INDEX's on Datetime   - &lt;a href=&quot;https://stackoverflow.com/questions/4013301/mysql-datetime-index-is-not-working&quot;&gt;Does not work&lt;/a&gt;</source>
          <target state="translated">日期时间的索引- &lt;a href=&quot;https://stackoverflow.com/questions/4013301/mysql-datetime-index-is-not-working&quot;&gt;不起作用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c058c66e16779f3e5d87b80818f4e54711ee832a" translate="yes" xml:space="preserve">
          <source>a INDEX's on Timestamp  - works</source>
          <target state="translated">a INDEX的时间戳上的索引----有效</target>
        </trans-unit>
        <trans-unit id="14c88ff2f0e7f0d7d01802892756e11f40be03b1" translate="yes" xml:space="preserve">
          <source>and in MySQL do &lt;code&gt;SELECT UNIX_TIMESTAMP();&lt;/code&gt;.</source>
          <target state="translated">在MySQL中执行 &lt;code&gt;SELECT UNIX_TIMESTAMP();&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bef63f4643b53c0e6c20553bb1f0543b403021b5" translate="yes" xml:space="preserve">
          <source>easy migrations between time zones</source>
          <target state="translated">轻松实现时区之间的迁移</target>
        </trans-unit>
        <trans-unit id="7ae8438fcf4f03e1bbb55d35dceda8efa0bd317f" translate="yes" xml:space="preserve">
          <source>look at this &lt;a href=&quot;https://stackoverflow.com/questions/95183/how-does-one-create-an-index-on-the-date-part-of-datetime-field-in-mysql&quot;&gt;post to see problems with Datetime indexing&lt;/a&gt;</source>
          <target state="translated">看看这篇&lt;a href=&quot;https://stackoverflow.com/questions/95183/how-does-one-create-an-index-on-the-date-part-of-datetime-field-in-mysql&quot;&gt;文章，看看日期时间索引问题&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="944e5c03bdda873f2d9a030910c0d94089a1d341" translate="yes" xml:space="preserve">
          <source>no worry about dates in/out a summer time period</source>
          <target state="translated">夏日无忧</target>
        </trans-unit>
        <trans-unit id="68c2634f494de50ae1701c5c57288cb89cec17cd" translate="yes" xml:space="preserve">
          <source>pretty easy to calculate diferences (just subtract both timestamps)</source>
          <target state="translated">很容易计算出差异(减去两个时间戳就可以了</target>
        </trans-unit>
        <trans-unit id="d38547cfd2b4a24917f0893ead653bf6ef1602f3" translate="yes" xml:space="preserve">
          <source>ready to use on international (multi time zone) apps</source>
          <target state="translated">可在国际(多时区)应用程序中使用</target>
        </trans-unit>
        <trans-unit id="18f605dfe1380d283d7c7607e5798ee1e187bbce" translate="yes" xml:space="preserve">
          <source>then every single value in your 'Date_Added' column would be changed to the current timestamp.</source>
          <target state="translated">那么您的'Date_Added'列中的每一个值都会被更改为当前的时间戳。</target>
        </trans-unit>
        <trans-unit id="9b99af1d5f813e03b16069c39a0d4de32de49280" translate="yes" xml:space="preserve">
          <source>you accept data from different clients around the world, each of them inserts the time in his timezone.</source>
          <target state="translated">你接受来自世界各地不同客户的数据,每个人都会在他的时间区中插入时间。</target>
        </trans-unit>
        <trans-unit id="a1900144dd02e0b44d98690cdbca12f939cbf4a9" translate="yes" xml:space="preserve">
          <source>you changed the country you stay in, and continue your work of maintaining the data while seeing it in a different timezone (without changing the actual data).</source>
          <target state="translated">你改变了你所停留的国家,在不同的时间区(不改变实际数据的情况下)继续维护数据的工作。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
