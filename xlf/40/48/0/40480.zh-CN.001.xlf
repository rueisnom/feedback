<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/40480">
    <body>
      <group id="40480">
        <trans-unit id="679ac82a1b80b565bd19565ec122a565572f35a9" translate="yes" xml:space="preserve">
          <source>&quot;String&quot; Objects appear to be a good &lt;strong&gt;counter-example&lt;/strong&gt; to the urban legend saying that &quot;Objects are passed by reference&quot;:</source>
          <target state="translated">&amp;ldquo;字符串&amp;rdquo;对象似乎是城市传奇的一个很好的&lt;strong&gt;反例&lt;/strong&gt; ，它说&amp;ldquo;对象通过引用传递&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="d88ecdddf8b9e6ef14e68530529dc23d4ff6b148" translate="yes" xml:space="preserve">
          <source>&quot;by value&quot; is the only way in java to pass a parameter to a method</source>
          <target state="translated">&quot;by value &quot;是java中传递参数给方法的唯一方式。</target>
        </trans-unit>
        <trans-unit id="ac7bea48c9f3e3c013ee3b9ca43c1cd4255ba9c6" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Account account1&amp;rdquo; is the type and name of the reference variable, &amp;ldquo;=&amp;rdquo; is the assignment operator, &amp;ldquo;new&amp;rdquo; asks for the required amount of space from the system. The constructor to the right of keyword new which creates the object is called implicitly by the keyword new. Address of the created object(result of right variable, which is an expression) is assigned to the left variable (which is a reference variable with a name and a type specified) using the assign operator. &amp;ldquo;new Account()&amp;rdquo; is called &amp;ldquo;class instance creation expression&amp;rdquo;.</source>
          <target state="translated">&amp;ldquo; Account account1&amp;rdquo;是引用变量的类型和名称，&amp;ldquo; =&amp;rdquo;是赋值运算符，&amp;ldquo; new&amp;rdquo;从系统中请求所需的空间量。 关键字new右边的用于创建对象的构造函数由关键字new隐式调用。 使用assign运算符将创建对象的地址（右边变量的结果，它是一个表达式）分配给左边变量（这是一个具有名称和类型的参考变量）。 &amp;ldquo; new Account（）&amp;rdquo;被称为&amp;ldquo;类实例创建表达式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="94aa2ba0bb8a675b61aef491a803f4a9834f2892" translate="yes" xml:space="preserve">
          <source>(I say essentially because Java pointers aren't direct addresses, but it's easiest to think of them that way)</source>
          <target state="translated">(我说本质上是因为Java指针不是直接的地址,但这样想最容易让人联想到它们)</target>
        </trans-unit>
        <trans-unit id="4deb5f3c7a0f51652194597de3c850eb67417a51" translate="yes" xml:space="preserve">
          <source>/**
  This 'Pass By Value has a feeling of 'Pass By Reference'</source>
          <target state="translated">/***这个 &quot;通过值 &quot;有一种 &quot;通过参考 &quot;的感觉。</target>
        </trans-unit>
        <trans-unit id="9aadafd84fb3481ea6953e7000de351b550c282f" translate="yes" xml:space="preserve">
          <source>/**
 * 
 * Pass By Value
 *
 */</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d699180ecfe5b34c3e0bc840eb47751e4372814" translate="yes" xml:space="preserve">
          <source>223 gets PUSHd to the stack.</source>
          <target state="translated">223得到PUSHd到堆栈。</target>
        </trans-unit>
        <trans-unit id="6446e71ace78a7a3a0a5710cd60edb392c5f7798" translate="yes" xml:space="preserve">
          <source>223 gets copied to one of the CPU registers.</source>
          <target state="translated">223被复制到CPU的一个寄存器中。</target>
        </trans-unit>
        <trans-unit id="b89be71dff7edaa9c74d2426c943f820435958da" translate="yes" xml:space="preserve">
          <source>47 PUSHd to the stack.</source>
          <target state="translated">47 PUSHd到堆栈。</target>
        </trans-unit>
        <trans-unit id="29eebea6f72ba92d2ef802d866c3af082d2c6911" translate="yes" xml:space="preserve">
          <source>47 gets copied to one of the CPU registers</source>
          <target state="translated">47被复制到CPU的一个寄存器中。</target>
        </trans-unit>
        <trans-unit id="35f6cb5f76dc39cccdd22e4f4ed75145651bad22" translate="yes" xml:space="preserve">
          <source>5 gets PUSHd to the stack.</source>
          <target state="translated">5得到PUSHd到堆栈。</target>
        </trans-unit>
        <trans-unit id="bd53eeaa13917b9c1cd0ffee5c08d5548f0f975f" translate="yes" xml:space="preserve">
          <source>5 gets copied to one of the CPU registers (ie. EAX).</source>
          <target state="translated">5被复制到CPU的一个寄存器(即EAX)。</target>
        </trans-unit>
        <trans-unit id="669fc2a12114e17f53bf6a6eea0a996b3e52e4db" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;Java is also mentioned&lt;/a&gt;. Here is the short summary:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;还提到了Java&lt;/a&gt; 。 这是简短的摘要：</target>
        </trans-unit>
        <trans-unit id="44522a95088af6ee8afeac1924a88cbdb726d3ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a = b&lt;/code&gt; makes a new assignment to the reference &lt;code&gt;a&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;f&lt;/code&gt;, of the object whose its attribute is &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a = b&lt;/code&gt; 对属性为 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 的对象的引用 &lt;code&gt;a&lt;/code&gt; &lt;strong&gt;而不是&lt;/strong&gt; &lt;code&gt;f&lt;/code&gt; 进行新赋值。</target>
        </trans-unit>
        <trans-unit id="dc8f4e638edf822f721d61b825c182734c0569b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; will change the attribute of the object that reference &lt;code&gt;c&lt;/code&gt; points to it, and it's same object that reference &lt;code&gt;f&lt;/code&gt; points to it.</source>
          <target state="translated">&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; 会更改引用 &lt;code&gt;c&lt;/code&gt; 指向它的对象的属性，并且它是引用 &lt;code&gt;f&lt;/code&gt; 指向它的对象。</target>
        </trans-unit>
        <trans-unit id="14cac2530311a23fb072c9ef26feba713000c665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;someDog&lt;/code&gt; is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 42)</source>
          <target state="translated">&lt;code&gt;someDog&lt;/code&gt; 跟随它指向的 &lt;code&gt;Dog&lt;/code&gt; （地址为42的Dog对象）</target>
        </trans-unit>
        <trans-unit id="1e1295aabf56bdb60aa6cdd4c585a17ef60d34fd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Did &lt;code&gt;myDog&lt;/code&gt; change?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;我的 &lt;code&gt;myDog&lt;/code&gt; 变了吗？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f5e57136a5902e29d33131a3a28391b65ae5a66" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Master&lt;/em&gt;: Grasshopper, No.</source>
          <target state="translated">&lt;em&gt;主人&lt;/em&gt; ：蚱hopper，没有</target>
        </trans-unit>
        <trans-unit id="b89440cba42f99210f8524ad856b1d7e2968203e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Student&lt;/em&gt;: Master, does this mean that Java is pass-by-reference?</source>
          <target state="translated">&lt;em&gt;学生&lt;/em&gt; ：硕士，这是否意味着Java是按引用传递的？</target>
        </trans-unit>
        <trans-unit id="e9026cb4dbf68f5a89f59e77b991a00db2fad347" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;This value is actually COPIED and given to the method&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;该值实际上已复制并提供给方法&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="eac8606431b898a08bfa815724043bf24baea91c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A variable holds the bits that tell the JVM how to get to the referenced Object in memory (Heap).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;变量包含一些位，这些位告诉JVM如何获取内存中的引用对象（堆）。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee963e4f98e2321319006e78120a5c33385ffa8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All parameters to methods are passed &quot;by value&quot;&lt;/strong&gt;. In other words,
  values of parameter variables in a method are copies of the invoker
  specified as arguments.</source>
          <target state="translated">&lt;strong&gt;方法的所有参数都&amp;ldquo;按值&amp;rdquo;传递&lt;/strong&gt; 。 换句话说，方法中参数变量的值是指定为参数的调用程序的副本。</target>
        </trans-unit>
        <trans-unit id="d0c0ba2ae2424364bf0a5b15f58afb340e72d7df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ allows Pass-by-reference&lt;/strong&gt; by declaring a reference parameter using the &quot;&amp;amp;&quot; character (which happens to be the same character used to indicate &quot;the address of a variable&quot; in both C and C++). For example, if we pass in a pointer by reference, the parameter and the argument are not just pointing to the same object. Rather, they are the same variable. If one gets set to a different address or to null, so does the other.</source>
          <target state="translated">&lt;strong&gt;C ++通过&lt;/strong&gt;使用&amp;ldquo;＆&amp;rdquo;字符（在C和C ++中恰好与用于表示&amp;ldquo;变量的地址&amp;rdquo;的字符相同）声明引用参数， &lt;strong&gt;从而允许通过引用&lt;/strong&gt; 。 例如，如果我们按引用传递指针，则参数和参数不仅指向同一对象。 相反，它们是相同的变量。 如果将一个设置为其他地址或设置为null，则另一个设置也将设置为null。</target>
        </trans-unit>
        <trans-unit id="250414fd453c52d7a94d41cac5720b0bf6770e9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编辑2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e432c6162816f0458b741aeccb3b66bf810d917a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编辑3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3b32f3bc0cf8e132bab93bdb849247ffeab0402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编辑4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eee5a199ee48a34a0cc9134ad8533202fc7fcb52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;范例1：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba5182d053766559c8a796587cc6e079b0edece9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;范例2：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87994c9ddef100c712273600d84d2680b1176fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;范例3：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f029fd8a8bc2187006a97a36768f3a9a0f4c6825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;范例4：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46619b51e67a75935bc9ceedee2a6019b4258008" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Java creates and stores objects:&lt;/strong&gt; When we create an object we store the object&amp;rsquo;s address in a reference variable. Let's analyze the following statement.</source>
          <target state="translated">&lt;strong&gt;Java如何创建和存储对象：&lt;/strong&gt;创建对象时，我们将对象的地址存储在引用变量中。 让我们分析以下语句。</target>
        </trans-unit>
        <trans-unit id="8522a877bd114b6f39cde66fbd073f0156a79129" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Java only references are passed and are passed by value:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在Java中，仅传递引用，并按值传递：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fb07fd2faf3d430de82df4b1196a7157526121c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java doesn't pass method arguments by reference; it passes them by value.&lt;/strong&gt; I will use example from &lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;this site&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Java不会通过引用传递方法参数。&lt;/strong&gt; &lt;strong&gt;它通过价值传递它们。&lt;/strong&gt; 我将使用&lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;此站点的&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="f8710d2de84f7d70df19d71411b10789671cf77e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is Pass-by-value&lt;/strong&gt;, but allows us to emulate pass be reference by passing a Java reference (i.e. a pointer) by value. Meaning it passes a copy of the Java reference. &lt;strong&gt;&lt;em&gt;EDIT&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;: since someone made a comment about this, let me explain. Before C, several (but not all) earlier languages like FORTRAN and COBOL supported PBR, but C did not. In order to change the values of variables inside functions, C programmers emulated PBR by passing pointers to variables into functions. Languages inspired by C, such as Java, borrowed this idea and continue to emulate PBR as C did.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Java是按值传递&lt;/strong&gt; ，但允许我们&lt;strong&gt;通过按值&lt;/strong&gt;传递Java引用（即指针）来模拟传递被引用。 意味着它传递了Java参考的副本。 &lt;strong&gt;&lt;em&gt;编辑&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;：由于有人对此发表评论，让我解释一下。&lt;/em&gt; &lt;em&gt;在C之前，FORTRAN和COBOL等几种（但不是全部）较早的语言支持PBR，但C不支持。&lt;/em&gt; &lt;em&gt;为了更改函数内部变量的值，C程序员通过将指向变量的指针传递到函数中来模拟PBR。&lt;/em&gt; &lt;em&gt;受C启发的语言（例如Java）借鉴了这一思想，并像C一样继续模仿PBR。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="539967da6afd5b4c7cf196939fd0d2173148d5e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is always pass by value, not pass by reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java总是按值传递，而不是按引用传递&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daf65d846a847f4224f37e5964ce49e033a6516e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;请注意，anotherReferenceToTheSamePersonObject箭头指向对象而不是变量人！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82bf5f83e99ffaf8561e8e28fe3ef14c8cc29ecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;On this line 'pass-by-value' goes into the play...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在这条线上，&amp;ldquo;传递价值&amp;rdquo;成为了舞台。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f82acf071fee6ab2a7abd0313bbf60fe384f861" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (also called pass by address) means that a copy of the address of the actual parameter is stored&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;按引用传递（也称为按地址传递）表示存储实际参数的地址副本&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="24f93d53f1599b4ac1080cabfb887cfff18610ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference&lt;/strong&gt;--There is no copy of the reference. Single reference is shared by both the caller and the function being called. Any changes to the reference or the Object's data are reflected in the caller's scope.</source>
          <target state="translated">&lt;strong&gt;通过引用&lt;/strong&gt;传递-没有引用的副本。 调用者和被调用函数都共享单个引用。 对引用或对象数据的任何更改都会反映在调用者的作用域中。</target>
        </trans-unit>
        <trans-unit id="a7a81b026c4fc8d49d09f4de01c114901f7c0d8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value means that you are making a copy in memory of the actual parameter's value that is passed in. This is a copy of the contents of the actual parameter&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;按值传递表示您正在复制传入的实际参数值在内存中。这是实际参数内容的副本&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="5501243b5acfe1576d19283bdb0a2ab76d3504bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing a reference by value&lt;/strong&gt;--Changes to the reference are not reflected in the caller's scope, but the changes to the object are. This is because the reference is copied, but the both the original and the copy refer to the same object.</source>
          <target state="translated">&lt;strong&gt;按值传递引用&lt;/strong&gt; -引用的更改不会反映在调用方的作用域中，但对象的更改会反映在调用方的作用域中。 这是因为引用已复制，但是原始副本和副本都引用同一对象。</target>
        </trans-unit>
        <trans-unit id="d128a624743e2f0a142ea51104871088ef3baab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Result&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f28b5e99d681d23b2424be728e4d14ac53de034" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation.&lt;/strong&gt; The definition of pass-by-reference was</source>
          <target state="translated">&lt;strong&gt;您可以遵循引用来调用方法或访问所引用对象的字段这一事实与对话完全无关。&lt;/strong&gt; 引用传递的定义是</target>
        </trans-unit>
        <trans-unit id="155adcfa1e1a2d90f9b1663c701b8baa445db69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The reference values (often just references) are pointers to these objects&lt;/strong&gt;, and a special null reference, which refers to no object.</source>
          <target state="translated">&lt;strong&gt;引用值（通常只是引用）是指向这些对象的指针&lt;/strong&gt; ，还有一个特殊的null引用，它不引用任何对象。</target>
        </trans-unit>
        <trans-unit id="c6c7f19df18b6b50e6865d7508209d9363946c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you'll just smile :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这将使您对Java的实际工作方式有一些见解，以至于在下一次有关Java通过引用传递或通过值传递的讨论中，您只会笑:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a57a48f1825e5c9fb8aafac2b685e4eb2761f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the value of the argument?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;该论点的价值是什么？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f32da0f05cfb43b8594e1350dffac69d7279c2e" translate="yes" xml:space="preserve">
          <source>A String Object, holds characters by an array declared &lt;strong&gt;final&lt;/strong&gt; that can't be modified.
Only the address of the Object might be replaced by another using &quot;new&quot;. 
Using &quot;new&quot; to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.</source>
          <target state="translated">字符串对象，通过声明为&lt;strong&gt;final&lt;/strong&gt;的数组保存字符，该数组不能修改。 只有对象的地址可以用&amp;ldquo; new&amp;rdquo;替换为另一个。 使用&amp;ldquo;新&amp;rdquo;来更新变量，将不会从外部访问对象，因为变量最初是通过值传递并复制的。</target>
        </trans-unit>
        <trans-unit id="5cadb13ab1a3063435130babe3e0bd30a1122a5f" translate="yes" xml:space="preserve">
          <source>A few points:</source>
          <target state="translated">有几点。</target>
        </trans-unit>
        <trans-unit id="a6487d11fc0e1086219982c44902ad61a1998227" translate="yes" xml:space="preserve">
          <source>A method local variable -&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;- is created and then comes the magic in line #6:</source>
          <target state="translated">方法局部变量&lt;em&gt;-anotherReferenceToTheSamePersonObject-&lt;/em&gt;已创建，然后出现在第6行魔术中：</target>
        </trans-unit>
        <trans-unit id="939671d12f121c636331468aedcb607655b0467d" translate="yes" xml:space="preserve">
          <source>A new Person Object is created in line #2, stored in memory, and the variable &lt;em&gt;person&lt;/em&gt; is given the reference to the Person object. That is, its address. Let's say 3bad086a.</source>
          <target state="translated">在第2行中创建一个新的Person对象，并将其存储在内存中，然后为变量&lt;em&gt;person&lt;/em&gt;提供对Person对象的引用。 即是它的地址。 假设3bad086a。</target>
        </trans-unit>
        <trans-unit id="6cb5cc922e3e7afc89e697c3a55b40eccd85c7e8" translate="yes" xml:space="preserve">
          <source>A picture is worth a thousand words:</source>
          <target state="translated">一张照片胜过千言万语。</target>
        </trans-unit>
        <trans-unit id="7890ee11943cdb236a4c3b5ce7b9f732f716679f" translate="yes" xml:space="preserve">
          <source>A reference is always a value when represented, no matter what language you use.</source>
          <target state="translated">引用的时候,无论用什么语言,都是一种价值的代表,无论你用什么语言,都是一种参考。</target>
        </trans-unit>
        <trans-unit id="9f8832ae6457f58e3904c76f8d5c2aa49f842301" translate="yes" xml:space="preserve">
          <source>After: a = 2, b = 3</source>
          <target state="translated">后:a=2,b=3</target>
        </trans-unit>
        <trans-unit id="ec423d5a41945c4f52f7be0ea48ac07e83fd86ae" translate="yes" xml:space="preserve">
          <source>Although an object&amp;rsquo;s reference is passed by value, a method can still interact with the referenced object by calling its public methods using the copy of the object&amp;rsquo;s reference. Since the reference stored in the parameter is a copy of the reference that was passed as an argument, the parameter in the called method and the argument in the calling method refer to the same object in memory.</source>
          <target state="translated">尽管对象的引用是按值传递的，但是方法仍然可以通过使用对象引用的副本调用其公共方法来与所引用的对象进行交互。 由于存储在参数中的引用是作为参数传递的引用的副本，因此被调用方法中的参数和调用方法中的参数引用内存中的同一对象。</target>
        </trans-unit>
        <trans-unit id="b65974e5bb87a60e0a3ebacd86b70b176a71aea4" translate="yes" xml:space="preserve">
          <source>An array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.</source>
          <target state="translated">数组是一个对象,所以它也会进入堆中。那么数组中的对象呢?它们有自己的堆空间,每个对象的地址都在数组里面。</target>
        </trans-unit>
        <trans-unit id="9bf2ce1dceef2dc96a821885bc168afbf5d4d9a1" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;on the subject of pass-by-value&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;关于价值传递的主题&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="753dfa9513c7de7c01e5a4ee8e20f57993151233" translate="yes" xml:space="preserve">
          <source>And now that reverseArray method is over, its reference variables(array1 and array2) are gone. Which means we now only have the two reference variables in main method array1 and array2 which point to c and b arrays respectively. No reference variable is pointing to object (array) a. So it is eligible for garbage collection.</source>
          <target state="translated">现在反向Array方法结束了,它的引用变量(数组1和数组2)没有了。这意味着我们现在只有主方法中的数组1和数组2这两个引用变量分别指向c和b的数组。没有引用变量指向对象(数组)a,所以它有资格进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="1427090bc2dee2db920c7dcba2e93785a6f9fced" translate="yes" xml:space="preserve">
          <source>And towards the end of the same section he makes a broader statement about java being only pass by value and never pass by reference.</source>
          <target state="translated">而在同一节的结尾处,他做了一个更广泛的声明,说java只是通过价值传递,永远不会通过参考。</target>
        </trans-unit>
        <trans-unit id="7ccd274eb97af58443d0d98f31f8165d44df954a" translate="yes" xml:space="preserve">
          <source>Anyway, I noticed a comment by &lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;dhackner&lt;/a&gt; in an older post, who made a balloon analogy which I really liked. So much so that I decided to glue together some clip-art to make a set of cartoons to illustrate the point.</source>
          <target state="translated">无论如何，我注意到&lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;dhackner&lt;/a&gt;在较旧的帖子中发表了评论，他做出了我非常喜欢的气球类比。 如此之多，以至于我决定将一些剪贴画粘合在一起，制作出一系列动画片来说明这一点。</target>
        </trans-unit>
        <trans-unit id="7a6f63a9fa8ba00d31fa864a81af348461e2059d" translate="yes" xml:space="preserve">
          <source>As expected output will be:</source>
          <target state="translated">如预期的产出将是:</target>
        </trans-unit>
        <trans-unit id="9e95da2bd7af315b2113d39a70608c332bc48d91" translate="yes" xml:space="preserve">
          <source>As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:</source>
          <target state="translated">据我所知,Java只知道按值调用。这意味着对于基元数据类型,你将使用一个副本,而对于对象,你将使用对象的引用的副本。然而我认为有一些隐患;例如,这将无法工作。</target>
        </trans-unit>
        <trans-unit id="d05f320102345bc58ddfdf1478a148fed340e361" translate="yes" xml:space="preserve">
          <source>As many people mentioned it before, &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Java is always pass-by-value&lt;/a&gt;</source>
          <target state="translated">正如许多人之前提到的， &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Java始终是按价值传递的&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd4f600b4ca0e57b260d865e338eb632ae21d0de" translate="yes" xml:space="preserve">
          <source>As was explained in previous answers, in Java you're passing a pointer to the array as a value into &lt;code&gt;getValues&lt;/code&gt;. That is enough, because the method then modifies the array element, and by convention you're expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn't necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.</source>
          <target state="translated">正如前面的答案所解释的，在Java中，您正在将指向数组的指针作为值传递给 &lt;code&gt;getValues&lt;/code&gt; 。 这就足够了，因为该方法随后会修改数组元素，并且按照惯例，您期望元素0包含返回值。 显然，您可以通过其他方式执行此操作，例如，结构化代码以使其不必要，或者构造可以包含返回值或允许其设置的类。 但是上面的C ++中提供给您的简单模式在Java中不可用。</target>
        </trans-unit>
        <trans-unit id="8d7366694d78adcdb573e21740168952ff60eb6a" translate="yes" xml:space="preserve">
          <source>As we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is &lt;code&gt;0x100234&lt;/code&gt; (we don't know the actual JVM internal value, this is just an example) .</source>
          <target state="translated">众所周知，它将在堆中创建一个对象，并将参考值返回给t。 例如，假设t的值为 &lt;code&gt;0x100234&lt;/code&gt; （我们不知道实际的JVM内部值，这只是一个示例）。</target>
        </trans-unit>
        <trans-unit id="430da7a13966f26ff5a4c5e2f81b52ff90b0253b" translate="yes" xml:space="preserve">
          <source>As you call &lt;code&gt;modifyReference(Foo c)&lt;/code&gt; method, a reference &lt;code&gt;c&lt;/code&gt; is created and assigned the object with attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">当您调用 &lt;code&gt;modifyReference(Foo c)&lt;/code&gt; 方法时，将创建引用 &lt;code&gt;c&lt;/code&gt; 并为该对象分配属性 &lt;code&gt;&quot;f&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa285e6edfa6d99016592271e8d0555fae43569f" translate="yes" xml:space="preserve">
          <source>As you call the method &lt;code&gt;changeReference&lt;/code&gt;, the reference &lt;code&gt;a&lt;/code&gt; will be assigned the object which is passed as an argument.</source>
          <target state="translated">调用方法 &lt;code&gt;changeReference&lt;/code&gt; 时 ，将为引用 &lt;code&gt;a&lt;/code&gt; 分配对象，该对象作为参数传递。</target>
        </trans-unit>
        <trans-unit id="108085f3bb0f4209a639200317b9f008aaf21dab" translate="yes" xml:space="preserve">
          <source>Back when I studied compilers-in the 90's, I used the first edition of the book from 1986 which pre-dated Java by about 9 or 10 years. However, I just ran across a copy of the &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;2nd Eddition&lt;/a&gt; from 2007 &lt;strong&gt;which actually mentions Java!&lt;/strong&gt; Section 1.6.6 labeled &quot;Parameter Passing Mechanisms&quot; describes parameter passing pretty nicely. Here is an excerpt under the heading &quot;Call-by-value&quot; which mentions Java:</source>
          <target state="translated">当我在90年代研究编译器时，我使用了1986年的第一版书，它比Java早了9到10年。 但是，我遇到了2007年&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;第二版&lt;/a&gt;的副本， &lt;strong&gt;其中实际上提到了Java！&lt;/strong&gt; 标有&amp;ldquo;参数传递机制&amp;rdquo;的第1.6.6节很好地描述了参数传递。 以下是&amp;ldquo;按值调用&amp;rdquo;标题下的摘录，其中提到了Java：</target>
        </trans-unit>
        <trans-unit id="2a5566bd96317aa68aedfcd4ec8973cfbf92a199" translate="yes" xml:space="preserve">
          <source>Basically, reassigning Object parameters doesn't affect the argument, e.g.,</source>
          <target state="translated">基本上,重新分配对象参数并不影响参数,例如:。</target>
        </trans-unit>
        <trans-unit id="1b0434b117ced506f4e292880cee2d016b9caf22" translate="yes" xml:space="preserve">
          <source>Before: a = 2, b = 3</source>
          <target state="translated">前:a=2,b=3</target>
        </trans-unit>
        <trans-unit id="687e81922c00310f84049051118a03dc31fabaae" translate="yes" xml:space="preserve">
          <source>Both &quot;&lt;em&gt;person&lt;/em&gt;&quot; and &quot;&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;&quot; hold the same value of 3bad086a.</source>
          <target state="translated">&amp;ldquo; &lt;em&gt;person&lt;/em&gt; &amp;rdquo;和&amp;ldquo; &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; &amp;rdquo;都具有相同的值3bad086a。</target>
        </trans-unit>
        <trans-unit id="2689caac6d3ec6ddc37d1cac015f4e8ae4e22c88" translate="yes" xml:space="preserve">
          <source>Both variables have IDENTICAL COPIES of the reference and they both refer to the same Person Object, the SAME Object on the Heap and NOT A COPY.</source>
          <target state="translated">这两个变量都有引用的IDENTICAL COPIES,而且它们都引用了同一个Person对象,即Heap上的相同对象,而不是COPY。</target>
        </trans-unit>
        <trans-unit id="e9170e035719274989ed5cf55b194f253b0ee3eb" translate="yes" xml:space="preserve">
          <source>But from this example, we can understand that it is infact pass by value only,
  keeping in mind that here we are passing the reference as the value.
  ie: reference is passed by value.
  That's why are able to change and still it holds true after the local scope.
  But we cannot change the actual reference outside the original scope.
  what that means is demonstrated by next example of PassByValueObjectCase2.</source>
          <target state="translated">但从这个例子中,我们可以理解,实际上它只是通过值传递,记住这里我们是把引用作为值传递。这就是为什么能够改变,并且在本地范围后仍然保持真实。但我们不能在原来的作用域之外改变实际的引用,这意味着什么呢?</target>
        </trans-unit>
        <trans-unit id="006ecf4b1a9cc9edb60404b2fb553d2bccdff314" translate="yes" xml:space="preserve">
          <source>C++ pass by reference example:</source>
          <target state="translated">C++通过引用的例子。</target>
        </trans-unit>
        <trans-unit id="83514ce69e30402f75b91daf4e42e15d62db4d49" translate="yes" xml:space="preserve">
          <source>Check the comment on line #5</source>
          <target state="translated">请查看第5行的评论</target>
        </trans-unit>
        <trans-unit id="ce636731102296dcc967f8d443bba701fa39128c" translate="yes" xml:space="preserve">
          <source>Crash course on stack/heap before we get to the Java implementation:
Values go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria.
Memory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.</source>
          <target state="translated">在我们进入Java实现之前,先上一节关于堆栈堆的速成课程。值在堆中有序地进入和离开堆,就像食堂里的盘子堆一样。堆中的内存(也被称为动态内存)是杂乱无章的。JVM只是在它能找到的地方找到空间,并在使用它的变量不再需要的时候释放出来。</target>
        </trans-unit>
        <trans-unit id="9a4330ec3ed061c85b3e0b082e1656ec35e5d3df" translate="yes" xml:space="preserve">
          <source>Creates new Point object</source>
          <target state="translated">创建新的点对象</target>
        </trans-unit>
        <trans-unit id="1926dd5e7c03bbf781269e3b1f10a918298da01a" translate="yes" xml:space="preserve">
          <source>Creates new Point reference and initialize that reference to &lt;em&gt;point (refer to)&lt;/em&gt; on previously created Point object.</source>
          <target state="translated">创建新的Point引用，并将该引用初始化&lt;em&gt;为&lt;/em&gt;先前创建的Point对象上的&lt;em&gt;point（引用）&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="91a5cb67c9d537c081e9f8cf1bbc2d3e758ce171" translate="yes" xml:space="preserve">
          <source>Creating two different Point object with two different reference associated.</source>
          <target state="translated">创建两个不同的Point对象,并关联两个不同的引用。</target>
        </trans-unit>
        <trans-unit id="b0dda1bfba52f041403c7023d96d1d341ad3c077" translate="yes" xml:space="preserve">
          <source>Data in memory has a &lt;strong&gt;Location&lt;/strong&gt; and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a &lt;strong&gt;Name&lt;/strong&gt; to certain &lt;strong&gt;Location&lt;/strong&gt; (aka variable), but when compiling the code, the assembler simply replaces &lt;strong&gt;Name&lt;/strong&gt; with the designated location just like your browser replaces domain names with IP addresses.</source>
          <target state="translated">内存中的数据有一个&lt;strong&gt;位置，&lt;/strong&gt;并且在该位置有一个值（字节，字或其他内容）。 在Assembly中，我们有一个方便的解决方案，可以将&lt;strong&gt;Name&lt;/strong&gt;赋予特定的&lt;strong&gt;位置&lt;/strong&gt; （又名变量），但是在编译代码时，汇编程序只是将&lt;strong&gt;Name&lt;/strong&gt;替换为指定的位置，就像您的浏览器将域名替换为IP地址一样。</target>
        </trans-unit>
        <trans-unit id="bfb16cd1cd030c8e69601029c768549e17aa7047" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">声明一个名为 &lt;code&gt;b&lt;/code&gt; 的引用，类型为 &lt;code&gt;Foo&lt;/code&gt; ,并为其分配一个具有属性 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 的类型为 &lt;code&gt;Foo&lt;/code&gt; 的新对象。</target>
        </trans-unit>
        <trans-unit id="0bb0f2661240daa3e654c2b942a4228aef7a6a44" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">声明类型为 &lt;code&gt;Foo&lt;/code&gt; 的名为 &lt;code&gt;f&lt;/code&gt; 的引用，并为其分配属性为 &lt;code&gt;&quot;f&quot;&lt;/code&gt; 的类型为 &lt;code&gt;Foo&lt;/code&gt; 的新对象。</target>
        </trans-unit>
        <trans-unit id="cd9950fdb8d7858353a3702108602c9648dd0e68" translate="yes" xml:space="preserve">
          <source>Does this sound strange and confusing? Let's consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. &lt;code&gt;void foo(int x)&lt;/code&gt; passes an int by value. &lt;code&gt;void foo(int *x)&lt;/code&gt; is a function that does not want an &lt;code&gt;int a&lt;/code&gt;, but a pointer to an int: &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt;. One would use this with the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to pass a variable address.</source>
          <target state="translated">这听起来很奇怪并且令人困惑吗？ 让我们考虑一下C如何实现按引用传递和按值传递。 在C语言中，默认约定是按值传递。 &lt;code&gt;void foo(int x)&lt;/code&gt; 通过值传递一个int值。 &lt;code&gt;void foo(int *x)&lt;/code&gt; 是一个不需要 &lt;code&gt;int a&lt;/code&gt; 的函数，而是一个指向int的指针： &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt; 。 可以将其与 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符一起使用以传递变量地址。</target>
        </trans-unit>
        <trans-unit id="b5854bdd57360320e24b9397418a212d3b8b3fc1" translate="yes" xml:space="preserve">
          <source>Don't try this but person==anotherReferenceToTheSamePersonObject would be true.</source>
          <target state="translated">不要尝试这个,但是person===anotherReferenceToTheSamePersonObject会是true。</target>
        </trans-unit>
        <trans-unit id="207ba28fc5d0fc3ff8e2b02914c001bb5bb368b5" translate="yes" xml:space="preserve">
          <source>Down to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).</source>
          <target state="translated">归根结底,在技术上是不可能在任何语言中传递给任何东西的引用而不代表它(当它立即变成一个值时)。</target>
        </trans-unit>
        <trans-unit id="438f74e42d1fb68f2c51553f32173992bba966c9" translate="yes" xml:space="preserve">
          <source>First of all, we need to understand what pass by value and pass by reference are.</source>
          <target state="translated">首先,我们需要了解什么是通过价值传递和通过引用。</target>
        </trans-unit>
        <trans-unit id="9e5aff39fe5953d4740386d14bbfaa42a906a8b9" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;What's the difference between passing by reference vs. passing by value?&lt;/a&gt;</source>
          <target state="translated">首先， &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;按引用传递与按值传递有什么区别？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e0065a83f42a57a3911225215a70e9b907a2bbc" translate="yes" xml:space="preserve">
          <source>Flow of the program:</source>
          <target state="translated">程序的流程。</target>
        </trans-unit>
        <trans-unit id="0dfdb0b2fd7037984e97ec60ea513d8d5b9e3dd0" translate="yes" xml:space="preserve">
          <source>For objects, the pass by value is the value of &lt;em&gt;the reference to the object&lt;/em&gt;.</source>
          <target state="translated">对于对象，按值传递是&lt;em&gt;对对象的引用&lt;/em&gt;的值。</target>
        </trans-unit>
        <trans-unit id="5c00717c1eeb06ca14fc62309936f50e756db581" translate="yes" xml:space="preserve">
          <source>For primitive arguments (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, etc.), the pass by value is &lt;em&gt;the actual value&lt;/em&gt; of the primitive (for example, 3).</source>
          <target state="translated">对于基本参数（ &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; 等），按值传递是基本参数&lt;em&gt;的实际值&lt;/em&gt; （例如3）。</target>
        </trans-unit>
        <trans-unit id="d717d5e3b868b30355b36493393d4dedba688590" translate="yes" xml:space="preserve">
          <source>From here scope of &lt;code&gt;tricky&lt;/code&gt; method is gone and you don't have access any more to the references: &lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;temp&lt;/code&gt;. &lt;strong&gt;But important note is that everything you do with these references when they are 'in life' will permanently affect object on which they are &lt;em&gt;point&lt;/em&gt; to.&lt;/strong&gt;</source>
          <target state="translated">从这里开始， &lt;code&gt;tricky&lt;/code&gt; 方法的范围就消失了，您将无法再访问以下引用： &lt;code&gt;arg1&lt;/code&gt; ， &lt;code&gt;arg2&lt;/code&gt; ， &lt;code&gt;temp&lt;/code&gt; 。 &lt;strong&gt;但重要的一点是，当这些引用&amp;ldquo;存在&amp;rdquo;时，您所做的一切都会永久性地影响它们所&lt;em&gt;指向的&lt;/em&gt;对象。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ee364d2560bc79a19a4c72624692c7755f4443f" translate="yes" xml:space="preserve">
          <source>From here, through Point object life, you will access to that object through pnt1
 reference. So we can say that in Java you manipulate object through its reference.</source>
          <target state="translated">从这里开始,通过Point对象的生命,你将通过pnt1引用来访问该对象。所以我们可以说,在Java中,你可以通过它的引用来操纵对象。</target>
        </trans-unit>
        <trans-unit id="2c8076e66b55ab8aeac61f85404367064fccd996" translate="yes" xml:space="preserve">
          <source>From the method side, a reference of type &lt;code&gt;Foo&lt;/code&gt; with a name &lt;code&gt;a&lt;/code&gt; is declared and it's initially assigned &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">从方法方面，声明了名称为 &lt;code&gt;a&lt;/code&gt; 的类型为 &lt;code&gt;Foo&lt;/code&gt; 的引用，并将其初始分配为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fb62bec2c3a15680c7c08a655906f2b1d75ef3f" translate="yes" xml:space="preserve">
          <source>Getting an outside of the box view, let's look at Assembly or some low level memory management. At the CPU level a &lt;em&gt;reference&lt;/em&gt; to anything immediately becomes a &lt;em&gt;value&lt;/em&gt; if it gets written to memory or to one of the CPU registers. (That is why &lt;em&gt;pointer&lt;/em&gt; is a good definition. It is a value, which has a purpose at the same time).</source>
          <target state="translated">进入框视图的外部，让我们看一下Assembly或一些低级的内存管理。 在CPU级别，如果将任何内容写入内存或其中一个CPU寄存器，则对任何内容的&lt;em&gt;引用&lt;/em&gt;都会立即成为一个&lt;em&gt;值&lt;/em&gt; 。 （这就是为什么&lt;em&gt;指针&lt;/em&gt;是一个好的定义。它是一个值，同时具有目的）。</target>
        </trans-unit>
        <trans-unit id="a09f4f73a25672b2d71176498d77cdaf4f9d5f33" translate="yes" xml:space="preserve">
          <source>He goes on to make the same point regarding objects . . .</source>
          <target state="translated">他继续就物体提出同样的观点.。</target>
        </trans-unit>
        <trans-unit id="dcab7f73c798d9959b167db93301f1b793cb10fc" translate="yes" xml:space="preserve">
          <source>Here is another example that will help you understand the difference (&lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;the classic swap example&lt;/a&gt;):</source>
          <target state="translated">这是另一个示例，可以帮助您了解不同之处（ &lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;经典的swap示例&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="095229be47d5e504de9b8c6e3f105270472a7db4" translate="yes" xml:space="preserve">
          <source>Here, you first create new &lt;code&gt;temp&lt;/code&gt; Point reference which will &lt;em&gt;point&lt;/em&gt; on same place like &lt;code&gt;arg1&lt;/code&gt; reference. Then you move reference &lt;code&gt;arg1&lt;/code&gt; to &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;arg2&lt;/code&gt; reference.
Finally &lt;code&gt;arg2&lt;/code&gt; will &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">在这里，您首先创建新的 &lt;code&gt;temp&lt;/code&gt; 点参考，该参考点将&lt;em&gt;指向&lt;/em&gt;与 &lt;code&gt;arg1&lt;/code&gt; 参考相同的位置。 然后，将参考 &lt;code&gt;arg1&lt;/code&gt; 移动到&lt;em&gt;指向&lt;/em&gt;与 &lt;code&gt;arg2&lt;/code&gt; 参考相同的位置。 最终 &lt;code&gt;arg2&lt;/code&gt; 将&lt;em&gt;指向&lt;/em&gt; &lt;code&gt;temp&lt;/code&gt; 一样的位置。</target>
        </trans-unit>
        <trans-unit id="64169e4a61bae86f469a92b3cfc4bae9c3a53858" translate="yes" xml:space="preserve">
          <source>Hopefully this will help.</source>
          <target state="translated">希望这能帮到你。</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">它是如何工作的</target>
        </trans-unit>
        <trans-unit id="e5beaeff3bbae8257639b2987a7f67bd9d85c384" translate="yes" xml:space="preserve">
          <source>However you could make a wrapper for String like this which would make it able to use it with Strings:</source>
          <target state="translated">但是,你可以为String做一个像这样的包装器,这样就可以让它和Strings一起使用。</target>
        </trans-unit>
        <trans-unit id="26dd9ac7a210ba6a96d874cf5c6e8374ed5dbcf2" translate="yes" xml:space="preserve">
          <source>However, I've seen a couple of blog posts (for example, &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this blog&lt;/a&gt;) that claim that it isn't.</source>
          <target state="translated">但是，我已经看到一些博客文章（例如&lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this blog&lt;/a&gt; ）声称不是。</target>
        </trans-unit>
        <trans-unit id="ec1be69fa319cc52b285a8bee8c6a7f04ee9e1f8" translate="yes" xml:space="preserve">
          <source>I always think of it as &quot;pass by copy&quot;. It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.</source>
          <target state="translated">我一直认为它是 &quot;通过复制&quot;。不管是基元还是引用,它都是值的拷贝。如果它是一个基元,那么它就是值的位的副本,如果它是一个对象,那么它就是引用的副本。</target>
        </trans-unit>
        <trans-unit id="69f13178ffc91e81d12909e0fab0a089bbad804f" translate="yes" xml:space="preserve">
          <source>I always thought Java was &lt;strong&gt;pass-by-reference&lt;/strong&gt;.</source>
          <target state="translated">我一直认为Java是&lt;strong&gt;通过引用传递的&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="efd75827ae1611bf4e22af1ec1d50ca7541b3557" translate="yes" xml:space="preserve">
          <source>I can't believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term &lt;em&gt;call by sharing&lt;/em&gt; (also known as &lt;em&gt;call by object-sharing&lt;/em&gt; and &lt;em&gt;call by object&lt;/em&gt;) for this specific case of &quot;call by value where the value is a reference&quot;.</source>
          <target state="translated">我不敢相信没有人提到过芭芭拉&amp;middot;里斯科夫（Barbara Liskov）。 当她在1974年设计CLU时，也遇到了相同的术语问题，她针对&amp;ldquo;按值调用，其中值是参考&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="aeaec84d031aa5cb38d5557cf7de3f76bf7cafb0" translate="yes" xml:space="preserve">
          <source>I don't think I understand the distinction they're making.</source>
          <target state="translated">我想我不明白他们在做什么区别。</target>
        </trans-unit>
        <trans-unit id="d5405762999d453eb212ccf6bcc5f6125f900230" translate="yes" xml:space="preserve">
          <source>I feel like arguing about &quot;pass-by-reference vs pass-by-value&quot; is not super-helpful.</source>
          <target state="translated">我觉得争论 &quot;按参照系传递VS按价值传递 &quot;并不是超级有用。</target>
        </trans-unit>
        <trans-unit id="da328c30116bfb1c498c3407693d22ba90f3115c" translate="yes" xml:space="preserve">
          <source>I have created a thread devoted to these kind of questions for &lt;em&gt;any&lt;/em&gt; programming languages &lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">我为&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;这里的&lt;/a&gt; &lt;em&gt;任何&lt;/em&gt;编程语言创建了一个专门针对此类问题的线程。</target>
        </trans-unit>
        <trans-unit id="be8f8168e2402a238a9976383c81f993f3a3e74e" translate="yes" xml:space="preserve">
          <source>I have seen posts on this topic which describe the low level implementation of parameter passing in Java, which I think is great and very helpful because it makes an abstract idea concrete. However, to me the question is more about &lt;strong&gt;the behavior described in the language specification&lt;/strong&gt; than about the technical implementation of the behavior. This is an exerpt from the &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification, section 8.4.1&lt;/a&gt; :</source>
          <target state="translated">我看过有关此主题的文章，这些文章描述了Java中参数传递的低级实现，我认为这很好并且非常有帮助，因为它使抽象概念具体化。 但是，对我来说，问题更多&lt;strong&gt;的是语言规范中描述的行为，而&lt;/strong&gt;不是行为的技术实现。 这是&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java语言规范第8.4.1节&lt;/a&gt;的摘录：</target>
        </trans-unit>
        <trans-unit id="cb7305997ab86247b2a49056cbf4e89230b9f222" translate="yes" xml:space="preserve">
          <source>I hope this settles the debate, but probably won't.</source>
          <target state="translated">我希望这能解决这场辩论,但可能不会。</target>
        </trans-unit>
        <trans-unit id="d415e610e2056093f16e0b12b5086931ca855762" translate="yes" xml:space="preserve">
          <source>I hope you understand now how passing objects as arguments works in Java :)</source>
          <target state="translated">我希望你现在明白了在Java中传递对象作为参数的工作原理:)</target>
        </trans-unit>
        <trans-unit id="53b25f35c0f07624c3ab774845793894e9df085c" translate="yes" xml:space="preserve">
          <source>I just noticed you referenced &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;my article&lt;/a&gt;.</source>
          <target state="translated">我只是注意到您引用了&lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;我的文章&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2935658c6ca5dd052a7a1348a0e9a0f71fe8584b" translate="yes" xml:space="preserve">
          <source>I might be a little obsessed with this post. Probably because I feel that the makers of Java inadvertently spread misinformation. If instead of using the word &quot;reference&quot; for pointers they had used something else, say 
dingleberry, there would've been no problem. You could say, &quot;Java passes dingleberries by value and not by reference&quot;, and nobody would be confused. (Hence forth, when referencing pass by reference vs value, I shall refer to references as dinglebarries.)</source>
          <target state="translated">我可能对这个帖子有些痴迷。可能是因为我觉得Java的制作者无意中传播了错误信息。如果他们没有用 &quot;引用 &quot;这个词来做指针,而是用别的东西,比如说dingleberry,那就不会有问题了。你可以说,&quot;Java通过值而不是引用来传递dingleberries&quot;,这样就不会有人感到困惑了。(因此,当引用通过引用与值传递时,我将把引用称为dinglebarries)。</target>
        </trans-unit>
        <trans-unit id="dbf80c5168a8cdece318ecb980f6dc4582312bc0" translate="yes" xml:space="preserve">
          <source>I think the difference between the two models is very subtle and unless you've done programming where you actually used pass-by-reference, it's easy to miss where two models differ.</source>
          <target state="translated">我认为这两种模式的区别是非常微妙的,除非你做过实际使用过通过参考的编程,否则很容易错过两种模式的不同之处。</target>
        </trans-unit>
        <trans-unit id="051719f18cca69c8321cf2db575cbe7c3c8fc918" translate="yes" xml:space="preserve">
          <source>I thought I'd contribute this answer to add more details from the Specifications.</source>
          <target state="translated">我想我把这个答案贡献出来,补充一下《规范》中的细节。</target>
        </trans-unit>
        <trans-unit id="02668452fdc578abe59e37b1d267b95f2c167d43" translate="yes" xml:space="preserve">
          <source>I will explain this in steps:</source>
          <target state="translated">我将分步解释。</target>
        </trans-unit>
        <trans-unit id="7e24c4c25b98f1916d4e52df7af6eeb891b2b203" translate="yes" xml:space="preserve">
          <source>If Java had pass-by-reference semantics, the &lt;code&gt;foo&lt;/code&gt; method we defined above would have changed where &lt;code&gt;myDog&lt;/code&gt; was pointing when it assigned &lt;code&gt;someDog&lt;/code&gt; on line BBB.</source>
          <target state="translated">如果Java具有按引用传递语义，那么我们在上面定义的 &lt;code&gt;foo&lt;/code&gt; 方法将改变 &lt;code&gt;someDog&lt;/code&gt; 在BBB行上分配someDog所指向的位置。</target>
        </trans-unit>
        <trans-unit id="6697d56d6fde5f640c216d07a963f93b03bd1f54" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits contain the value of the primitive data type itself, That's why if we change the value of header inside the method then it does not reflect the changes outside.</source>
          <target state="translated">如果它是一个基元数据类型,这些位包含了基元数据类型本身的值,这就是为什么如果我们在方法内部改变了头的值,那么它不会反映出外部的变化。</target>
        </trans-unit>
        <trans-unit id="79742ec00dad7a7b993ddfde20c405582b74811d" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits will contain the value of the primitive data type itself.</source>
          <target state="translated">如果是基元数据类型,这些位将包含基元数据类型本身的值。</target>
        </trans-unit>
        <trans-unit id="f0283f6b09b05e1b1e2ef39baf027825432d4169" translate="yes" xml:space="preserve">
          <source>If it's an Object the bits will contain the value of the address that tells the JVM how to get to the Object.</source>
          <target state="translated">如果它是一个对象,位将包含告诉JVM如何到达该对象的地址值。</target>
        </trans-unit>
        <trans-unit id="8a2c1b22c98b47861f2f787055fd5f2fa95e5b32" translate="yes" xml:space="preserve">
          <source>If it's an object data type like &lt;strong&gt;Foo foo=new Foo()&lt;/strong&gt; then in this case copy of the address of the object passes like file shortcut  , suppose we have a text file &lt;strong&gt;abc.txt&lt;/strong&gt; at &lt;strong&gt;C:\desktop&lt;/strong&gt; and suppose we make shortcut of the same file and put this inside &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; so when you access the file from &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; and write &lt;strong&gt;'Stack Overflow'&lt;/strong&gt; and close the file and again you open the file from shortcut then you write &lt;strong&gt;' is the largest online community for programmers to learn'&lt;/strong&gt; then total file change will be &lt;strong&gt;'Stack Overflow is the largest online community for programmers to learn'&lt;/strong&gt; which means it doesn't matter from where you open the file , each time we were accessing the same file , here we can assume &lt;strong&gt;Foo&lt;/strong&gt; as a file and suppose foo stored at &lt;strong&gt;123hd7h&lt;/strong&gt;(original address like &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; ) address and &lt;strong&gt;234jdid&lt;/strong&gt;(copied address like &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; which actually contains the original address of the file inside) ..
So for better understanding make shortcut file and feel..</source>
          <target state="translated">如果它是像&lt;strong&gt;Foo foo = new Foo（）&lt;/strong&gt;这样的对象数据类型，那么在这种情况下，对象地址的副本通过文件&lt;strong&gt;shortit&lt;/strong&gt;传递，假设我们在&lt;strong&gt;C：\ desktop&lt;/strong&gt;处有一个文本文件&lt;strong&gt;abc.txt&lt;/strong&gt; ，并且假设我们将相同的文件，并将其放在&lt;strong&gt;C：\ desktop \ abc-shortcut中，&lt;/strong&gt;因此当您从&lt;strong&gt;C：\ desktop \ abc.txt&lt;/strong&gt;访问文件并写入&lt;strong&gt;&amp;ldquo; Stack Overflow&amp;rdquo;&lt;/strong&gt;并关闭文件，然后再次从快捷方式打开文件时，写&lt;strong&gt;&amp;ldquo;是最大的供程序员学习的在线社区&amp;rdquo;，&lt;/strong&gt;那么总文件更改将是&lt;strong&gt;&amp;ldquo;堆栈溢出是最大的供程序员学习的在线社区&amp;rdquo;&lt;/strong&gt; ，这意味着每次我们访问文件时，从何处打开文件都无所谓相同的文件，在这里我们可以假设&lt;strong&gt;Foo&lt;/strong&gt;为文件，并假设foo存储在&lt;strong&gt;123hd7h&lt;/strong&gt; （原始地址，例如&lt;strong&gt;C：\ desktop \ abc.txt&lt;/strong&gt; ）地址和&lt;strong&gt;234jdid&lt;/strong&gt; （复制的地址，例如&lt;strong&gt;C：\ desktop \ abc-shortcut）中&lt;/strong&gt; ，实际上包含里面的文件的原始地址）..因此为了更好的理解，使快捷文件和感觉..</target>
        </trans-unit>
        <trans-unit id="d09449cf7c49c0bb34af69bedb5138b6a6cf6571" translate="yes" xml:space="preserve">
          <source>If we pass the value of array1 reference variable as an argument to the reverseArray method, a reference variable is created in the method and that reference variable starts pointing to the same array (a).</source>
          <target state="translated">如果我们将数组1参考变量的值作为参数传递给reverseArray方法,则在该方法中创建一个参考变量,该参考变量开始指向同一个数组(a)。</target>
        </trans-unit>
        <trans-unit id="111cce0df4d6a3eea4ae694172e96a48fec02a36" translate="yes" xml:space="preserve">
          <source>If we return value of reference variable array2 as the return value of method reverseArray and assign this value to reference variable array1 in main method, array1 in main will start pointing to array c.</source>
          <target state="translated">如果我们将参考变量array2的值作为方法reverseArray的返回值,并将此值分配给主方法中的参考变量array1,那么主方法中的array1将开始指向数组c。</target>
        </trans-unit>
        <trans-unit id="cdd0e1a5c0a10b05b85a4f05bf0c8857fb0dc54a" translate="yes" xml:space="preserve">
          <source>If we want to call a method/function/procedure with Foo's value, there are a few possible way to pass the variable to the method, depending on the &lt;strong&gt;language&lt;/strong&gt; and its several method invocation modes:</source>
          <target state="translated">如果要使用Foo的值调用方法/函数/过程，则有几种方法可以将变量传递给方法，具体取决于&lt;strong&gt;语言&lt;/strong&gt;及其几种方法调用模式：</target>
        </trans-unit>
        <trans-unit id="ae7787cfc8ddd2039110866a573a0e2714e49edb" translate="yes" xml:space="preserve">
          <source>If you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output &lt;code&gt;changevalue&lt;/code&gt;,   which is updated in the function.</source>
          <target state="translated">如果使用引用f更改函数中的任何内容，它将修改对象的现有内容。 这就是为什么我们得到输出 &lt;code&gt;changevalue&lt;/code&gt; 的原因 ，该值在函数中进行了更新。</target>
        </trans-unit>
        <trans-unit id="fe4914949893eeb60b019dffcc6cea87be8dcc83" translate="yes" xml:space="preserve">
          <source>If you didn't get it then just trust me and remember that it's better to say that &lt;strong&gt;Java is pass by value&lt;/strong&gt;. Well, &lt;strong&gt;pass by reference value&lt;/strong&gt;. Oh well, even better is &lt;strong&gt;&lt;em&gt;pass-by-copy-of-the-variable-value! ;)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">如果您没有得到它，那就请相信我，并记住，最好说&lt;strong&gt;Java是通过价值传递的&lt;/strong&gt; 。 好吧， &lt;strong&gt;通过参考值&lt;/strong&gt; 。 哦，更好的方法是&lt;strong&gt;&lt;em&gt;通过变量值的复制！&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;;）&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d76bdbeace9817e06089a031711671ab9b1f87b3" translate="yes" xml:space="preserve">
          <source>If you say, &quot;Java is pass-by-whatever (reference/value)&quot;, in either case, you're not provide a complete answer. Here's some additional information that will hopefully aid in understanding what's happening in memory.</source>
          <target state="translated">如果你说 &quot;Java是通过-whatever(referencevalue)&quot;,无论哪种情况,你都没有提供一个完整的答案。下面是一些补充信息,希望能帮助你理解内存中发生的事情。</target>
        </trans-unit>
        <trans-unit id="2864474958a88d28e0e852e593201018ce309c3a" translate="yes" xml:space="preserve">
          <source>In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.</source>
          <target state="translated">在C++、Ada、Pascal和其他支持通过引用传递的语言中,你实际上可以改变传递的变量。</target>
        </trans-unit>
        <trans-unit id="cd1ab35d296b25bfeeda42a17c0845735976d063" translate="yes" xml:space="preserve">
          <source>In C++: &lt;strong&gt;Note: Bad code - memory leaks!&lt;/strong&gt;  But it demonstrates the point.</source>
          <target state="translated">在C ++中： &lt;strong&gt;注意：错误代码-内存泄漏！&lt;/strong&gt; 但这说明了这一点。</target>
        </trans-unit>
        <trans-unit id="70a7832950563eb1e68d730cfc8633aecba50e12" translate="yes" xml:space="preserve">
          <source>In Java,</source>
          <target state="translated">在Java中。</target>
        </trans-unit>
        <trans-unit id="ee32c40f3e465ae5371086558cba52983a8a32d8" translate="yes" xml:space="preserve">
          <source>In Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.</source>
          <target state="translated">在Java中,所有的参数都是按值传递的,也就是说,分配方法参数对调用者来说是不可见的。</target>
        </trans-unit>
        <trans-unit id="ea4a661eaa255681fb44e9a0ceb260d8c9521fd5" translate="yes" xml:space="preserve">
          <source>In Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. &lt;strong&gt;Modifying the object referenced by the variable is a different concept entirely.&lt;/strong&gt;</source>
          <target state="translated">在Java中，修改变量意味着重新分配它。 在Java中，如果您在方法中重新分配了变量，则调用者将不会注意到该变量。 &lt;strong&gt;修改变量引用的对象完全是一个不同的概念。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ec57628bd6a19cc372e0d82956fbc9926fe31cc" translate="yes" xml:space="preserve">
          <source>In addition to what was mentioned in Example3 (PassByValueObjectCase1.java),  we cannot change the actual reference outside the original scope.&quot;</source>
          <target state="translated">除了例3(PassByValueObjectCase1.java)中提到的内容外,我们不能改变原始范围外的实际引用。&quot;</target>
        </trans-unit>
        <trans-unit id="bf42410ba453a42ec3533408e27e6dbcc281e995" translate="yes" xml:space="preserve">
          <source>In call-by-reference evaluation (also referred to as
  pass-by-reference), a function receives an implicit reference to a
  variable used as argument, rather than a copy of its value. This
  typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">在按引用调用评估（也称为传递引用）中，函数接收对用作参数的变量的隐式引用，而不是其值的副本。 通常，这意味着该函数可以修改（即分配给）用作参数的变量，该变量将被其调用者看到。</target>
        </trans-unit>
        <trans-unit id="8b7b4cb1ed7c07a761b7c04a976a8f1ba04382e4" translate="yes" xml:space="preserve">
          <source>In call-by-value, the actual parameter is evaluated (if it is an
  expression) or copied (if it is a variable). The value is placed in
  the location belonging to the corresponding formal parameter of the
  called procedure. &lt;strong&gt;This method is used in C and Java, and is a common
  option in C++ , as well as in most other languages.&lt;/strong&gt;</source>
          <target state="translated">在按值调用中，将对实际参数求值（如果它是一个表达式）或将其复制（如果它是一个变量）。 该值放置在属于被调用过程的相应形式参数的位置。 &lt;strong&gt;此方法用在C和Java中，是C ++和大多数其他语言中的常用选项。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80cff4aaaefaebbc2f88f5d26ae6ac275dc4f40b" translate="yes" xml:space="preserve">
          <source>In call-by-value, the argument expression is evaluated, and the
  resulting value is bound to the corresponding variable in the function [...]. 
  If the function or procedure is able to assign values to its
  parameters, only its local copy is assigned [...].</source>
          <target state="translated">在逐值调用中,对参数表达式进行评价,并将得到的值绑定到函数中的相应变量[...]。如果函数或过程能够为其参数赋值,则只为其本地拷贝赋值[...]。</target>
        </trans-unit>
        <trans-unit id="bd4f5299b140615753485c299e8a2e77b0c5997f" translate="yes" xml:space="preserve">
          <source>In case of Objects, this is the same: 
Object variables are pointers (buckets) holding only Object&amp;rsquo;s &lt;strong&gt;address&lt;/strong&gt; that was created using the &quot;new&quot; keyword, and are copied like primitive types.</source>
          <target state="translated">对于对象，这是相同的：对象变量是仅保存使用&amp;ldquo; new&amp;rdquo;关键字创建的对象&lt;strong&gt;地址的&lt;/strong&gt;指针（存储桶），并且像原始类型一样被复制。</target>
        </trans-unit>
        <trans-unit id="fc3d33069def51ed42a9766ed121449803b82259" translate="yes" xml:space="preserve">
          <source>In effect, using a method, you will never be able, to update the value of a String passed as argument:</source>
          <target state="translated">实际上,使用一个方法,你将永远无法更新作为参数传递的String值。</target>
        </trans-unit>
        <trans-unit id="80da013ae7fbb0cb942c6b9e18118975ac88e298" translate="yes" xml:space="preserve">
          <source>In every cases above a value - a &lt;strong&gt;copy&lt;/strong&gt; of an existing value - has been created, it is now upto the receiving method to handle it. When you write &quot;Foo&quot; inside the method, it is either read out from EAX, or automatically  &lt;strong&gt;dereferenced&lt;/strong&gt;, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a &lt;em&gt;reference&lt;/em&gt; is a &lt;em&gt;value&lt;/em&gt; when represented, because a reference is a value that has to be processed (at language level).</source>
          <target state="translated">在上述每种情况下，都会创建一个值-现有值的&lt;strong&gt;副本&lt;/strong&gt; -现在由接收方法来处理它。 当您在方法内部编写&amp;ldquo; Foo&amp;rdquo;时，它是从EAX中读出，还是被自动&lt;strong&gt;取消引用&lt;/strong&gt; ，或者被双重取消引用，该过程取决于语言的工作方式和/或Foo的类型。 对于开发人员来说，这是隐藏的，直到她规避了取消引用的过程。 因此， &lt;em&gt;引用&lt;/em&gt;是表示时的&lt;em&gt;值&lt;/em&gt; ，因为引用是必须处理的值（在语言级别）。</target>
        </trans-unit>
        <trans-unit id="58d4de45900cd3a103d99c18d12234d5bb3d377d" translate="yes" xml:space="preserve">
          <source>In general, Java has primitive types (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, etc) that are passed directly by value. Then Java has objects (everything that derives from &lt;code&gt;java.lang.Object&lt;/code&gt;). Objects are actually always handled through a reference (a reference being a pointer that you can't touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.</source>
          <target state="translated">通常，Java具有通过值直接传递的原始类型（ &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;bool&lt;/code&gt; ， &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 等）。 然后，Java具有对象（所有从 &lt;code&gt;java.lang.Object&lt;/code&gt; 派生的对象）。 实际上，对象总是通过引用（引用是您无法触摸的指针）来处理的。 这意味着实际上，对象是通过引用传递的，因为引用通常并不有趣。 但是，这确实意味着您无法更改指向哪个对象，因为引用本身是通过值传递的。</target>
        </trans-unit>
        <trans-unit id="45cfc45c3c6f01b610517a50ecd3388655190ac5" translate="yes" xml:space="preserve">
          <source>In java everything is reference, so when you have something like:
    &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; Java does following:</source>
          <target state="translated">在Java中，所有内容都是参考，因此当您有类似内容时： &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; Java执行以下操作：</target>
        </trans-unit>
        <trans-unit id="b73ac48cac4cc50104187760bd5de00365a5e1fd" translate="yes" xml:space="preserve">
          <source>In line #4 you can listen to the sound of silence</source>
          <target state="translated">在第4行,你可以听到沉默的声音。</target>
        </trans-unit>
        <trans-unit id="f876ee91061153b58472e3caad886db2830e5e6c" translate="yes" xml:space="preserve">
          <source>In pascal, parameters passed-by-reference are called &quot;var parameters&quot;. In the procedure setToNil below, please note the keyword 'var' which precedes the parameter 'ptr'. When a pointer is passed to this procedure, it will be passed &lt;strong&gt;by reference&lt;/strong&gt;. Note the behavior: when this procedure sets ptr to nil (that's pascal speak for NULL), it will set the argument to nil--you can't do that in Java.</source>
          <target state="translated">在pascal中，按引用传递的参数称为&amp;ldquo; var参数&amp;rdquo;。 在下面的过程setToNil中，请注意在参数&amp;ldquo; ptr&amp;rdquo;之前的关键字&amp;ldquo; var&amp;rdquo;。 当指针传递给该过程时，它将&lt;strong&gt;通过reference&lt;/strong&gt;传递。 请注意行为：当此过程将ptr设置为nil（pascal表示NULL）时，它将把参数设置为nil －在Java中不能这样做。</target>
        </trans-unit>
        <trans-unit id="0e25ccb4e75ab4aec689df71744743c33feb9136" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;tricky&lt;/code&gt; method:</source>
          <target state="translated">在 &lt;code&gt;tricky&lt;/code&gt; 方法中：</target>
        </trans-unit>
        <trans-unit id="556c40767e22c9d0e16c7d2e8fd66f4fc3765ab3" translate="yes" xml:space="preserve">
          <source>In the C++ example below I'm passing a &lt;strong&gt;pointer&lt;/strong&gt; to a null terminated string &lt;strong&gt;by reference&lt;/strong&gt;. And in the Java example below I'm passing a Java reference to a String (again, the same as a pointer to a String) by value. Notice the output in the comments.</source>
          <target state="translated">在下面的C ++示例中，我&lt;strong&gt;通过引用&lt;/strong&gt;将&lt;strong&gt;指针&lt;/strong&gt;传递&lt;strong&gt;给以&lt;/strong&gt; null结尾的字符串。 在下面的Java示例中，我按值传递了对String的Java引用（再次与指向String的指针相同）。 注意注释中的输出。</target>
        </trans-unit>
        <trans-unit id="eaf8d1084a66af0ad2274ebc5bf33bd05b487e6a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;Fifi&lt;/code&gt; is the dog's name after call to &lt;code&gt;foo(aDog)&lt;/code&gt; because the object's name was set inside of &lt;code&gt;foo(...)&lt;/code&gt;. Any operations that &lt;code&gt;foo&lt;/code&gt; performs on &lt;code&gt;d&lt;/code&gt; are such that, for all practical purposes, they are performed on &lt;code&gt;aDog&lt;/code&gt;, but it is &lt;strong&gt;not&lt;/strong&gt; possible to change the value of the variable &lt;code&gt;aDog&lt;/code&gt; itself.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;Fifi&lt;/code&gt; 是调用 &lt;code&gt;foo(aDog)&lt;/code&gt; 之后的狗的名字，因为该对象的名称是在 &lt;code&gt;foo(...)&lt;/code&gt; 内部设置的。 &lt;code&gt;foo&lt;/code&gt; 在 &lt;code&gt;d&lt;/code&gt; 上执行的任何操作，实际上都是在 &lt;code&gt;aDog&lt;/code&gt; 上执行的，但无法更改变量 &lt;code&gt;aDog&lt;/code&gt; 本身的值。</target>
        </trans-unit>
        <trans-unit id="e5f1d7ec3ad0697448f7bd1694b6d4a13eec5e90" translate="yes" xml:space="preserve">
          <source>In the case of primitive types, Java behaviour is simple: 
The value is copied in another instance of the primitive type.</source>
          <target state="translated">对于基元类型,Java的行为很简单。值被复制到基元类型的另一个实例中。</target>
        </trans-unit>
        <trans-unit id="a522d3c2682539ae850f96edab1cea9361d6e16b" translate="yes" xml:space="preserve">
          <source>In the example above &lt;code&gt;aDog.getName()&lt;/code&gt; will still return &lt;code&gt;&quot;Max&quot;&lt;/code&gt;. The value &lt;code&gt;aDog&lt;/code&gt; within &lt;code&gt;main&lt;/code&gt; is not changed in the function &lt;code&gt;foo&lt;/code&gt; with the &lt;code&gt;Dog&lt;/code&gt;&lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; as the object reference is passed by value. If it were passed by reference, then the &lt;code&gt;aDog.getName()&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt; would return &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; after the call to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;aDog.getName()&lt;/code&gt; 仍将返回 &lt;code&gt;&quot;Max&quot;&lt;/code&gt; 。 &lt;code&gt;main&lt;/code&gt; 中的值 &lt;code&gt;aDog&lt;/code&gt; 不会在功能 &lt;code&gt;foo&lt;/code&gt; 中用 &lt;code&gt;Dog&lt;/code&gt; &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; 更改，因为对象引用是通过值传递的。 如果通过引用传递，则 &lt;code&gt;main&lt;/code&gt; 中的 &lt;code&gt;aDog.getName()&lt;/code&gt; 在对 &lt;code&gt;foo&lt;/code&gt; 的调用之后将返回 &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2767cb995f4a551872be17db0731dc32b9631113" translate="yes" xml:space="preserve">
          <source>In the following (please don't try to compile/execute this...):</source>
          <target state="translated">在下面(请不要尝试编译执行这个...)。</target>
        </trans-unit>
        <trans-unit id="3cc72807c6aa2f7787bc1d2e01e7b1a38a8163b3" translate="yes" xml:space="preserve">
          <source>In the image below you can see we have two reference variables(These are called pointers in C/C++, and I think that term makes it easier to understand this feature.) in the main method. Primitive and reference variables are kept in stack memory(left side in images below). array1 and array2 reference variables &quot;point&quot; (as C/C++ programmers call it) or reference to a and b arrays respectively, which are objects (values these reference variables hold are addresses of objects) in heap memory (right side in images below).</source>
          <target state="translated">在下图中,你可以看到在主方法中,我们有两个引用变量(在CC++中称为指针,我认为这个词更容易理解这个特性。)。原始变量和引用变量保存在堆栈内存中(下图左侧),数组1和数组2引用变量分别 &quot;点&quot;(CC++程序员称之为 &quot;点&quot;)或引用到a和b的数组,这些数组是堆栈内存中的对象(这些引用变量持有的值是对象的地址)(下图右侧)。</target>
        </trans-unit>
        <trans-unit id="1db423d4e50678143cbe574c1553ab77c64d2ec7" translate="yes" xml:space="preserve">
          <source>Is Java “pass-by-reference” or “pass-by-value”</source>
          <target state="translated">Java是 &quot;按参考传递 &quot;还是 &quot;按值传递&quot;</target>
        </trans-unit>
        <trans-unit id="da12241a17ef14fa43fa2b4e3155933518c0d4e0" translate="yes" xml:space="preserve">
          <source>It goes like this:</source>
          <target state="translated">事情是这样的。</target>
        </trans-unit>
        <trans-unit id="98f312d82b1864aed2fd685327b3e2e9e1d88ca2" translate="yes" xml:space="preserve">
          <source>It's perfectly valid to &lt;em&gt;follow&lt;/em&gt; an address and change what's at the end of it; that does not change the variable, however.</source>
          <target state="translated">&lt;em&gt;跟随&lt;/em&gt;地址并更改地址末尾是完全有效的； 但这不会更改变量。</target>
        </trans-unit>
        <trans-unit id="f5635fa4e11fcd1915675b96d22971357494e751" translate="yes" xml:space="preserve">
          <source>Java always passes arguments &lt;em&gt;by value&lt;/em&gt;, NOT by reference.</source>
          <target state="translated">Java总是&lt;em&gt;按值&lt;/em&gt;传递参数，而不是按引用传递参数。</target>
        </trans-unit>
        <trans-unit id="1e1d0bd5765a75bcdfc28bab135f3be439234c61" translate="yes" xml:space="preserve">
          <source>Java arguments are &lt;strong&gt;all passed by value&lt;/strong&gt; (the reference is copied when used by the method) :</source>
          <target state="translated">Java参数均按&lt;strong&gt;值传递&lt;/strong&gt; （该方法使用该引用时，该引用将被复制）：</target>
        </trans-unit>
        <trans-unit id="d45e3643eb2a0c3cfaa96ee1ba516a58b305181b" translate="yes" xml:space="preserve">
          <source>Java has only pass by value. A very simple example to validate this.</source>
          <target state="translated">Java只有通过值来传递。一个非常简单的例子来验证。</target>
        </trans-unit>
        <trans-unit id="703fb214de1457e7f2c05c6d4fec19e41f4cb320" translate="yes" xml:space="preserve">
          <source>Java is a call by value</source>
          <target state="translated">Java是一个按值调用</target>
        </trans-unit>
        <trans-unit id="3acd670af680bc110c036092f510ce1f098fa3fb" translate="yes" xml:space="preserve">
          <source>Java is always &lt;strong&gt;pass-by-value&lt;/strong&gt;. Unfortunately, when we pass the value of an object, we are passing the &lt;em&gt;reference&lt;/em&gt; to it.  This is confusing to beginners.</source>
          <target state="translated">Java总是&lt;strong&gt;按值传递&lt;/strong&gt; 。 不幸的是，当我们传递一个对象的值时，我们正在传递对该对象的&lt;em&gt;引用&lt;/em&gt; 。 这使初学者感到困惑。</target>
        </trans-unit>
        <trans-unit id="d999ec799d7d7e3e79463bd37bb62eacf6e25b10" translate="yes" xml:space="preserve">
          <source>Java is always pass by value, with no exceptions, &lt;strong&gt;ever&lt;/strong&gt;.</source>
          <target state="translated">Java总是按值传递，没有例外。</target>
        </trans-unit>
        <trans-unit id="bffa033db8f0f65b32ac37222c7fbfe326862449" translate="yes" xml:space="preserve">
          <source>Java is pass by value according to the Java Language Specification:</source>
          <target state="translated">根据Java语言规范,Java是按值传递的。</target>
        </trans-unit>
        <trans-unit id="5d5b05490570ab7df7923106ad5234571b0ba144" translate="yes" xml:space="preserve">
          <source>Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you'll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45192a707a26fe3bb2f92c6fbcb126e95a6e9b0e" translate="yes" xml:space="preserve">
          <source>Java only has the two types of passing: by value for built-in types, and by value of the pointer for object types.</source>
          <target state="translated">Java只有两种传递方式:对于内置类型,按值传递;对于对象类型,按指针值传递。</target>
        </trans-unit>
        <trans-unit id="529efc0a206bb877a5914af86dac2e005794eacf" translate="yes" xml:space="preserve">
          <source>Java pass &quot;a Java reference&quot; by value example</source>
          <target state="translated">Java通过值传递 &quot;一个Java引用 &quot;的例子</target>
        </trans-unit>
        <trans-unit id="3a23cc46246cbf17c3306653ed35fc739dd92303" translate="yes" xml:space="preserve">
          <source>Java passes it parameters by value</source>
          <target state="translated">Java通过值传递它的参数</target>
        </trans-unit>
        <trans-unit id="93f3aa9ad265f6adfea081d81b4ce0f2dd3364f2" translate="yes" xml:space="preserve">
          <source>Java passes references by value.</source>
          <target state="translated">Java通过值传递引用。</target>
        </trans-unit>
        <trans-unit id="866018b39b9f976d7a4fda32831571acb3fe531a" translate="yes" xml:space="preserve">
          <source>Java passes references to objects by value.</source>
          <target state="translated">Java通过值传递对对象的引用。</target>
        </trans-unit>
        <trans-unit id="cb688bcbe4d4a31366fbbe80d020a8f8c54e722d" translate="yes" xml:space="preserve">
          <source>Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, you cannot change where that pointer points.</source>
          <target state="translated">Java的工作原理和C语言完全一样,你可以分配一个指针,将指针传给一个方法,跟随该方法中的指针,改变被指向的数据。但是,你不能改变那个指针指向哪里。</target>
        </trans-unit>
        <trans-unit id="c3ceb58d38297bd42517df14fa453efa53f2e920" translate="yes" xml:space="preserve">
          <source>Just to show the contrast, compare the following &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C++&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; snippets:</source>
          <target state="translated">为了显示对比，请比较以下&lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C ++&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java代码&lt;/a&gt;段：</target>
        </trans-unit>
        <trans-unit id="76eed6720175d9c487a151ea0ec369ca6ff2bea0" translate="yes" xml:space="preserve">
          <source>Keeping in mind that &lt;code&gt;myDog&lt;/code&gt; is a &lt;em&gt;pointer&lt;/em&gt;, and not an actual &lt;code&gt;Dog&lt;/code&gt;, the answer is NO. &lt;code&gt;myDog&lt;/code&gt; still has the value 42; it's still pointing to the original &lt;code&gt;Dog&lt;/code&gt; (but note that because of line &quot;AAA&quot;, its name is now &quot;Max&quot; - still the same Dog; &lt;code&gt;myDog&lt;/code&gt;'s value has not changed.)</source>
          <target state="translated">请记住， &lt;code&gt;myDog&lt;/code&gt; 是&lt;em&gt;指针&lt;/em&gt; ，而不是实际的 &lt;code&gt;Dog&lt;/code&gt; ，答案是否定的。 &lt;code&gt;myDog&lt;/code&gt; 仍然具有值42； 它仍指向原始的 &lt;code&gt;Dog&lt;/code&gt; （但请注意，由于行&amp;ldquo; AAA&amp;rdquo;，其名称现在为&amp;ldquo; Max&amp;rdquo;-仍是同 &lt;code&gt;myDog&lt;/code&gt; Dog； myDog的值未更改。）</target>
        </trans-unit>
        <trans-unit id="2671b77ed672eeae8e1bb043ed9cddaa3c26b00f" translate="yes" xml:space="preserve">
          <source>Let me explain this through an &lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;example&lt;/a&gt;:</source>
          <target state="translated">让我通过一个&lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;例子&lt;/a&gt;解释一下：</target>
        </trans-unit>
        <trans-unit id="1769d859356c9306da11a136d37d7bc840e8173d" translate="yes" xml:space="preserve">
          <source>Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference</source>
          <target state="translated">下面我试着用四个例子来解释一下我的理解。Java是按值传递,而不是按引用传递</target>
        </trans-unit>
        <trans-unit id="667ee93519391efd5ef048789e42e4cd7eb32ed7" translate="yes" xml:space="preserve">
          <source>Let's consider reference types, the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;Java Virtual Machine Specification&lt;/a&gt; states</source>
          <target state="translated">让我们考虑引用类型， &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;Java虚拟机规范&lt;/a&gt;指出</target>
        </trans-unit>
        <trans-unit id="017c2442a73e3b150be4f8d7101d3d565a83f364" translate="yes" xml:space="preserve">
          <source>Let's understand step by step:</source>
          <target state="translated">我们来一步步了解一下。</target>
        </trans-unit>
        <trans-unit id="5685f4b4e04daf5f5c1aa0517659cc4fb4246e59" translate="yes" xml:space="preserve">
          <source>Lets say we have a variable Foo, its &lt;strong&gt;Location&lt;/strong&gt; is at the 47th byte in memory and its &lt;strong&gt;Value&lt;/strong&gt; is 5. We have another variable &lt;strong&gt;Ref2Foo&lt;/strong&gt; which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two &lt;strong&gt;Values&lt;/strong&gt;.
If you use them as references then to reach to &lt;code&gt;5&lt;/code&gt; we have to travel:</source>
          <target state="translated">假设我们有一个变量Foo，它的&lt;strong&gt;位置&lt;/strong&gt;在内存中的第47个字节处，其值为5。我们还有另一个变量&lt;strong&gt;Ref2Foo&lt;/strong&gt; ，它在内存中的第223个字节处，其值为47。此Ref2Foo可能是一个技术变量，不是由程序明确创建的。 如果仅查看5和47而没有其他任何信息，则只会看到两个&lt;strong&gt;Values&lt;/strong&gt; 。 如果您将它们用作参考，则到达 &lt;code&gt;5&lt;/code&gt; 点我们必须旅行：</target>
        </trans-unit>
        <trans-unit id="d50fff30ab03bcac896614280d7ce79d010333b1" translate="yes" xml:space="preserve">
          <source>Like so:</source>
          <target state="translated">像这样。</target>
        </trans-unit>
        <trans-unit id="1cfac11915904016eed201cd17895ef142e7298c" translate="yes" xml:space="preserve">
          <source>Likewise:</source>
          <target state="translated">Likewise:</target>
        </trans-unit>
        <trans-unit id="5cd871265dfcea1f716cd6d1540a0775e084af34" translate="yes" xml:space="preserve">
          <source>Naturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.</source>
          <target state="translated">当然,通过价值传递对象的参照物看起来很像(而且在实践中与)通过参照物传递对象是无法区分的。</target>
        </trans-unit>
        <trans-unit id="74a399506f2951a7b197ec01ea8e798ce4122914" translate="yes" xml:space="preserve">
          <source>Next in the &lt;code&gt;tricky&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;tricky&lt;/code&gt; 方法中的下一个</target>
        </trans-unit>
        <trans-unit id="4c7f2f0ce70a51c735ee73784fc914a2704fd44b" translate="yes" xml:space="preserve">
          <source>Nitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only &lt;em&gt;pass-by-reference&lt;/em&gt;.</source>
          <target state="translated">细微地考虑细节，即使是通过引用传递的语言也会将值传递给函数，但是那些函数知道必须将其用于解引用目的。 这种&amp;ldquo;按值传递引用&amp;rdquo;对程序员而言只是隐藏的，因为它实际上是无用的，并且术语仅是&amp;ldquo; &lt;em&gt;按引用传递&amp;rdquo;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f39a1496ed9448598fdec7fa441d4eb247a6d515" translate="yes" xml:space="preserve">
          <source>No new instances of Person are created.</source>
          <target state="translated">不创建新的Person实例。</target>
        </trans-unit>
        <trans-unit id="5a3c28a6866958ddbd72e8e5bfcca8b47c170a56" translate="yes" xml:space="preserve">
          <source>No, it's not pass by reference.</source>
          <target state="translated">不,它不是通过参考的。</target>
        </trans-unit>
        <trans-unit id="a2c2fa354963a9acfa4e9abfc392a844ec4c593d" translate="yes" xml:space="preserve">
          <source>Note: I am not pasting the code for &lt;code&gt;private class Student&lt;/code&gt;. The class definition for &lt;code&gt;Student&lt;/code&gt; is same as Example3.</source>
          <target state="translated">注意：我没有粘贴 &lt;code&gt;private class Student&lt;/code&gt; 的代码。 &lt;code&gt;Student&lt;/code&gt; 的类定义与Example3相同。</target>
        </trans-unit>
        <trans-unit id="922f6a86dea64e63a3edc02c1877ce2a3c46981e" translate="yes" xml:space="preserve">
          <source>Now feel free to hate me but note that given this &lt;strong&gt;there is no difference between passing primitive data types and Objects&lt;/strong&gt; when talking about method arguments.</source>
          <target state="translated">现在可以恨我，但请注意，鉴于此&lt;strong&gt;，&lt;/strong&gt;在谈论方法参数时&lt;strong&gt;，传递原始数据类型和对象之间没有区别&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="69d2ccd64b25d43c28b50000e4e7f2b5a02a3236" translate="yes" xml:space="preserve">
          <source>Now let's think about what happens outside the method:</source>
          <target state="translated">现在我们来思考一下方法之外的事情。</target>
        </trans-unit>
        <trans-unit id="ff38daeae639f963939233f6e3fdce27295e1cf5" translate="yes" xml:space="preserve">
          <source>Now think of what an Object's reference/variable does/is:</source>
          <target state="translated">现在想想一个对象的参考变量是什么?</target>
        </trans-unit>
        <trans-unit id="0e2ffb2ff2a00fd086483aeae2222dbc11a4d2c8" translate="yes" xml:space="preserve">
          <source>Now we have passed Foo to the method:</source>
          <target state="translated">现在我们把Foo传给了方法。</target>
        </trans-unit>
        <trans-unit id="a68e19abd4296329735454d01ddb1f100edde052" translate="yes" xml:space="preserve">
          <source>Of course you can cut it short and just say that  &lt;strong&gt;Java is pass-by-value!&lt;/strong&gt;</source>
          <target state="translated">当然，您可以简而言之，只是说&lt;strong&gt;Java是按价值传递的！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25bdd3d54506e9fcb400bfa35ebbf005d8293eb" translate="yes" xml:space="preserve">
          <source>Okay. First off, local primitives go on the stack. So this code:</source>
          <target state="translated">好的 首先,本地基元要放在堆栈上。所以这段代码:</target>
        </trans-unit>
        <trans-unit id="8e109f9696197d944923c2e8918140789af777d2" translate="yes" xml:space="preserve">
          <source>One String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier &lt;code&gt;hisName&lt;/code&gt;, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call &lt;code&gt;shout()&lt;/code&gt;: a new stack frame is created and a new identifier, &lt;code&gt;name&lt;/code&gt; is created and assigned the address of the already-existing String.</source>
          <target state="translated">创建了一个字符串，并在堆中为其分配了空间，并将该字符串的地址存储在堆栈中，并 &lt;code&gt;hisName&lt;/code&gt; 指定了标识符hisName ，因为第二个字符串的地址与第一个字符串相同，因此不会创建新的字符串并且没有分配新的堆空间，但是在堆栈上创建了一个新的标识符。 然后我们调用 &lt;code&gt;shout()&lt;/code&gt; ：创建一个新的堆栈框架，并创建一个新的标识符， &lt;code&gt;name&lt;/code&gt; ，并为其分配已经存在的String的地址。</target>
        </trans-unit>
        <trans-unit id="e9fbef27678eb892ee44cd57611d9c038d5ddbb8" translate="yes" xml:space="preserve">
          <source>Or from wikipedia, &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;on the subject of pass-by-reference&lt;/a&gt;</source>
          <target state="translated">或来自维基百科， &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;关于通过引用的主题&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89050305305bcda692140fffe8f7276e92d157fe" translate="yes" xml:space="preserve">
          <source>Pass By Value</source>
          <target state="translated">通过价值</target>
        </trans-unit>
        <trans-unit id="7a52d2d617a0327ba951584e0dd74a3b60d0e2ee" translate="yes" xml:space="preserve">
          <source>Pass by value means the called functions' parameter will be a copy of
  the callers' passed argument.</source>
          <target state="translated">通过值传递意味着被调用函数的参数将是调用者传递参数的副本。</target>
        </trans-unit>
        <trans-unit id="b05d82b9afa13c63a41c110afc8f23afc15f5eb7" translate="yes" xml:space="preserve">
          <source>Passing by reference means the called functions' parameter will be the
  same as the callers' passed argument (not the value, but the identity
  - the variable itself).</source>
          <target state="translated">通过引用传递意味着被调用函数的参数将与调用者传递的参数相同(不是值,而是身份--变量本身)。</target>
        </trans-unit>
        <trans-unit id="cc7d7eee18bf03fb193a57aacc259b0ecd56568e" translate="yes" xml:space="preserve">
          <source>Passing references to arrays, instead of the array objects themselves, makes sense for performance reasons. Because everything in Java is passed by value, if array objects were passed,
a copy of each element would be passed. For large arrays, this would waste time and consume
considerable storage for the copies of the elements.</source>
          <target state="translated">传递对数组的引用,而不是数组对象本身,从性能上来说是有意义的。因为Java中的所有东西都是通过值传递的,如果传递数组对象,那么就会传递每个元素的副本。对于大型数组来说,这样做会浪费时间,而且会消耗大量的存储来复制元素的副本。</target>
        </trans-unit>
        <trans-unit id="8cfedebc2d3a9442c6efa9728f78e57e537d2cba" translate="yes" xml:space="preserve">
          <source>Primitive values are also defined in the Java Virtual Machine Specification, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;here&lt;/a&gt;. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).</source>
          <target state="translated">原始值也在Java虚拟机规范（ &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;此处）中定义&lt;/a&gt; 。 类型的值是相应的整数或浮点值，已正确编码（8、16、32、64等位）。</target>
        </trans-unit>
        <trans-unit id="20eebab5a449d25f5d3973bfc691fbe91ed1dda9" translate="yes" xml:space="preserve">
          <source>Primitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.</source>
          <target state="translated">Primitive wrapper类和Strings是不可变的,所以任何使用这些类型的例子都不会和其他类型对象一样。</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="45c34d3cd3e583ca8c9f01b7fd4364b4be14d83e" translate="yes" xml:space="preserve">
          <source>References &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; are &lt;strong&gt;passed by value&lt;/strong&gt; to the tricky method, which means that now yours references &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; have their &lt;code&gt;copies&lt;/code&gt; named &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;.So &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;arg1&lt;/code&gt;&lt;em&gt;points&lt;/em&gt; to the same object. (Same for the &lt;code&gt;pnt2&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;)</source>
          <target state="translated">引用 &lt;code&gt;pnt1&lt;/code&gt; 和 &lt;code&gt;pnt2&lt;/code&gt; &lt;strong&gt;通过值传递&lt;/strong&gt;给棘手的方法，这意味着现在您的引用 &lt;code&gt;pnt1&lt;/code&gt; 和 &lt;code&gt;pnt2&lt;/code&gt; 的 &lt;code&gt;copies&lt;/code&gt; 名为 &lt;code&gt;arg1&lt;/code&gt; 和 &lt;code&gt;arg2&lt;/code&gt; ,因此 &lt;code&gt;pnt1&lt;/code&gt; 和 &lt;code&gt;arg1&lt;/code&gt; &lt;em&gt;指向&lt;/em&gt;同一对象。 （与 &lt;code&gt;pnt2&lt;/code&gt; 和 &lt;code&gt;arg2&lt;/code&gt; 相同）</target>
        </trans-unit>
        <trans-unit id="bf00fec3f22ea28e6b86a2ef752102c2e7ecb750" translate="yes" xml:space="preserve">
          <source>Second, we need to know what Java uses in its method invocations. The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification&lt;/a&gt; states</source>
          <target state="translated">其次，我们需要知道Java在其方法调用中使用了什么。 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java语言规范&lt;/a&gt;规定</target>
        </trans-unit>
        <trans-unit id="d6c9ce881b6078a8902ba5543f51a3b0d775b3fa" translate="yes" xml:space="preserve">
          <source>Several people have written comments which seem to indicate that either they are not looking at my examples or they don't get the c++ example. Not sure where the disconnect is, but guessing the c++ example is not clear. I'm posting the same example in pascal because I think pass-by-reference looks cleaner in pascal, but I could be wrong. I might just be confusing people more; I hope not.</source>
          <target state="translated">有几个人写了评论,似乎说明要么没看我的例子,要么就是没看懂C++的例子。不知道是哪里脱节了,但猜测c++的例子不清楚。我把同样的例子贴在pascal中,因为我认为pascal中的逐次引用看起来更干净,但我可能错了。我可能只是混淆了大家,但愿不是。</target>
        </trans-unit>
        <trans-unit id="26c0ca793e8f7074d3f8c82877440040dbf9523b" translate="yes" xml:space="preserve">
          <source>So</source>
          <target state="translated">So</target>
        </trans-unit>
        <trans-unit id="ff40a96c97ebf788e8cecb055d7af4f991b2166d" translate="yes" xml:space="preserve">
          <source>So after executing method &lt;code&gt;tricky&lt;/code&gt;, when you return to &lt;code&gt;main&lt;/code&gt;, you have this situation:</source>
          <target state="translated">因此，在执行方法 &lt;code&gt;tricky&lt;/code&gt; ，返回到 &lt;code&gt;main&lt;/code&gt; 时 ，会遇到以下情况：</target>
        </trans-unit>
        <trans-unit id="7ef4027a6bbd3300b48fbef4e07ab82867158511" translate="yes" xml:space="preserve">
          <source>So how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java &lt;strong&gt;never&lt;/strong&gt; provides direct access to the values of &lt;em&gt;objects themselves&lt;/em&gt;, in &lt;em&gt;any&lt;/em&gt; circumstances. The only access to objects is through a &lt;em&gt;reference&lt;/em&gt; to that object. Because Java objects are &lt;em&gt;always&lt;/em&gt; accessed through a reference, rather than directly, it is common to talk about fields and variables &lt;em&gt;and method arguments&lt;/em&gt; as being &lt;em&gt;objects&lt;/em&gt;, when pedantically they are only &lt;em&gt;references to objects&lt;/em&gt;. &lt;strong&gt;The confusion stems from this (strictly speaking, incorrect) change in nomenclature.&lt;/strong&gt;</source>
          <target state="translated">那么，如何使所有人对此感到困惑，以为Java是通过引用传递的呢，还是认为他们有一个Java充当引用传递的示例呢？ 关键在于，在&lt;em&gt;任何&lt;/em&gt;情况下，Java &lt;strong&gt;都不&lt;/strong&gt;提供对&lt;em&gt;对象本身&lt;/em&gt;的值的直接访问。 对对象的唯一访问是通过对该对象的&lt;em&gt;引用&lt;/em&gt; 。 因为Java对象&lt;em&gt;总是&lt;/em&gt;通过引用而不是直接访问来访问，所以通常将字段和变量&lt;em&gt;以及方法参数&lt;/em&gt;称为&lt;em&gt;对象&lt;/em&gt; ，而在学究上它们仅&lt;em&gt;是对象的引用&lt;/em&gt; 。 &lt;strong&gt;混淆源于命名上的这种变化（严格来说是不正确的）。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49f6e297927d971ba38fa95bec79322b3f55ffe8" translate="yes" xml:space="preserve">
          <source>So if you have &lt;code&gt;doSomething(foo)&lt;/code&gt; and &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; the two Foos have copied &lt;em&gt;references&lt;/em&gt; that point to the same objects.</source>
          <target state="translated">因此，如果您有 &lt;code&gt;doSomething(foo)&lt;/code&gt; 和 &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; 则两个Foos复制了指向相同对象的&lt;em&gt;引用&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b4e3120f9e0ef1963e36854a84df92466e8bd5c" translate="yes" xml:space="preserve">
          <source>So in short and in Java's own terminology, Java is &lt;em&gt;pass-by-value&lt;/em&gt; where &lt;em&gt;value&lt;/em&gt; can be: either a &lt;strong&gt;real value&lt;/strong&gt; or a &lt;strong&gt;value&lt;/strong&gt; that is a representation of a &lt;strong&gt;reference&lt;/strong&gt;.</source>
          <target state="translated">因此，简而言之，用Java自己的术语来说，Java是&lt;em&gt;按值传递，&lt;/em&gt;其中&lt;em&gt;值&lt;/em&gt;可以是： &lt;strong&gt;实值&lt;/strong&gt;或表示&lt;strong&gt;引用的值&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="634936d81c1689fe91adca4c5ee1e8fd9d96a1ad" translate="yes" xml:space="preserve">
          <source>So it assigns (or binds) the value of the argument to the corresponding parameter variable.</source>
          <target state="translated">所以它将参数的值分配(或绑定)到相应的参数变量。</target>
        </trans-unit>
        <trans-unit id="f4945724933ec9be2092b5806b370216861c5eeb" translate="yes" xml:space="preserve">
          <source>So let's write all the things we have done at once now.</source>
          <target state="translated">所以,我们现在就把自己做的事情一次性写出来吧。</target>
        </trans-unit>
        <trans-unit id="9a181e916502cbb03b3332b929a47423efcc6e84" translate="yes" xml:space="preserve">
          <source>So now, completely execution of program will be:</source>
          <target state="translated">所以现在,完全执行程序将。</target>
        </trans-unit>
        <trans-unit id="2a27627ea047cda38b06899780beb9ed096f3a7d" translate="yes" xml:space="preserve">
          <source>So you can't change the reference that gets passed in.</source>
          <target state="translated">所以,你不能改变被传入的引用。</target>
        </trans-unit>
        <trans-unit id="866237ea6abd1c73ce2cd72c6c84fc4749c1fab7" translate="yes" xml:space="preserve">
          <source>So you're just passing 3bad086a that it's the value of the reference.</source>
          <target state="translated">所以,你只是通过3bad086a说是参考的价值。</target>
        </trans-unit>
        <trans-unit id="20fd78625a8ef72411c2e7f9cc21dcf94a034a8f" translate="yes" xml:space="preserve">
          <source>So, if we say</source>
          <target state="translated">所以,如果我们说</target>
        </trans-unit>
        <trans-unit id="90e7e6de17ceea609c89967f7448b462eff52e91" translate="yes" xml:space="preserve">
          <source>So, value, reference? You say &quot;potato&quot;.</source>
          <target state="translated">那么,价值,参考?你说的是 &quot;土豆&quot;。</target>
        </trans-unit>
        <trans-unit id="daa39b66ef2d8fde4dcb582dccfc4335693ba86f" translate="yes" xml:space="preserve">
          <source>So, what gets passed in when you call a method? If you pass in an object, what you're actually passing in is the address of the object. Some might say the &quot;value&quot; of the address, and some say it's just a reference to the object. This is the genesis of the holy war between &quot;reference&quot; and &quot;value&quot; proponents. What you call it isn't as important as that you understand that what's getting passed in is the address to the object.</source>
          <target state="translated">那么,当你调用一个方法时,会传入什么?如果你传入一个对象,你实际上传入的是对象的地址。有人可能说是地址的 &quot;值&quot;,也有人说只是对象的引用。这就是 &quot;引用 &quot;和 &quot;值 &quot;的拥护者之间的圣战的起源。你叫它什么并不重要,重要的是你要明白,传进来的是对象的地址。</target>
        </trans-unit>
        <trans-unit id="f804721f9a225c83f9f775159b5195bbbe96d25c" translate="yes" xml:space="preserve">
          <source>So, when calling a method</source>
          <target state="translated">所以,在调用方法时</target>
        </trans-unit>
        <trans-unit id="ee33b63e4d6f38a1051e9487d652448deba03bf9" translate="yes" xml:space="preserve">
          <source>Some excerpts from &lt;strong&gt;&quot;THE Java Programming Language&quot;&lt;/strong&gt; by Ken Arnold, &lt;strong&gt;James Gosling (the guy who invented Java)&lt;/strong&gt;, and David Holmes, chapter 2, section 2.6.5</source>
          <target state="translated">Ken Arnold， &lt;strong&gt;James Gosling（发明Java的人）&lt;/strong&gt;和David Holmes的&lt;strong&gt;&amp;ldquo; THE Java Programming Language&amp;rdquo;&lt;/strong&gt;摘录，第2章，第2.6.5节</target>
        </trans-unit>
        <trans-unit id="94b891247159e943febc8cc22cd31a1491a1cb74" translate="yes" xml:space="preserve">
          <source>Some people say primitive types and 'String' are 'pass by value'
  and objects are 'pass by reference'.</source>
          <target state="translated">有人说基元类型和'String'是'通过值传递',对象是'通过引用传递'。</target>
        </trans-unit>
        <trans-unit id="ae7f019ce2b7e1139c2214fe199d7dfbfd4ace30" translate="yes" xml:space="preserve">
          <source>Sometimes Java can give the illusion of pass by reference. Let's see how it works by using the example below:</source>
          <target state="translated">有时候,Java会给人一种通过引用传递的错觉。让我们通过下面的例子来看看它是如何工作的。</target>
        </trans-unit>
        <trans-unit id="523c67e3005e1319a95db986a92e473eccf87a79" translate="yes" xml:space="preserve">
          <source>Sometimes you want to use the same pattern in Java, but you can't; at least not directly. Instead you could do something like this:</source>
          <target state="translated">有时你想在Java中使用同样的模式,但你不能;至少不能直接使用。相反,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="aa1ec5d7dc80c372add31e690fc9b6adfcbed953" translate="yes" xml:space="preserve">
          <source>Step one please erase from your mind that word that starts with 'p' &quot;_ _ _ _ _ _ _&quot;, especially if you come from other programming languages. Java and 'p' cannot be written in the same book, forum, or even txt.</source>
          <target state="translated">第一步,请从你的脑海中抹去以'p'开头的单词&quot;___________&quot;,尤其是如果你来自其他编程语言的人。Java和'p'不能写在同一本书、论坛,甚至是txt中。</target>
        </trans-unit>
        <trans-unit id="e060e28388e7368925caf9e91796e5aa4d2b1720" translate="yes" xml:space="preserve">
          <source>Step two remember that when you pass an Object into a method you're passing the Object reference and not the Object itself.</source>
          <target state="translated">第二步 记住,当你把一个对象传入一个方法时,你是在传入对象引用,而不是对象本身。</target>
        </trans-unit>
        <trans-unit id="6207dc3dd0572f9c051d767720eb5104f3fb4f3c" translate="yes" xml:space="preserve">
          <source>Strict &lt;em&gt;pass-by-value&lt;/em&gt; is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller's view) and a few languages allows to modify the Value of the reference itself.</source>
          <target state="translated">严格&lt;em&gt;的值传递&lt;/em&gt;也是没有用的，这意味着每次调用以数组为参数的方法时，都必须复制100 MB的数组，因此Java不能严格地值传递。 每种语言都将传递对该巨大数组的引用（作为值），并且如果该数组可以在方法内部进行局部更改，或者采用该方法（如Java），则可以采用写时复制机制； （调用者的视图）和几种语言允许修改引用本身的值。</target>
        </trans-unit>
        <trans-unit id="f14bbbb986af6b74a6c4b3c0e5664a7de3e563b7" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;code&gt;Dog&lt;/code&gt; object resides at memory address 42. This means we pass 42 to the method.</source>
          <target state="translated">假设 &lt;code&gt;Dog&lt;/code&gt; 对象位于内存地址42。这意味着我们将42传递给该方法。</target>
        </trans-unit>
        <trans-unit id="8d27872f4e15932b79d2264d4a0cddb9e2521238" translate="yes" xml:space="preserve">
          <source>Take this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; is called by &lt;code&gt;foo(a)&lt;/code&gt;, where the compiler itself knows that it is a reference and the address of the non-reference &lt;code&gt;a&lt;/code&gt; should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.</source>
          <target state="translated">将其带到C ++，我们有参考。 引用基本上是（在这种情况下）语法糖，它隐藏了等式的指针部分： &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; 由 &lt;code&gt;foo(a)&lt;/code&gt; 调用，其中编译器本身知道它是引用，而非地址是参考 &lt;code&gt;a&lt;/code&gt; 应该被传递。 在Java中，所有引用对象的变量实际上都是引用类型，实际上在大多数意图和目的下都强制通过引用进行调用，而没有C ++提供的精细控制（和复杂性）。</target>
        </trans-unit>
        <trans-unit id="1f5466dbc044f44594c32f9e6b1b8a7351767c72" translate="yes" xml:space="preserve">
          <source>That's the reason only Java developers have issue with this. They look at the word &quot;reference&quot; and think they know exactly what that means, so they don't even bother to consider the opposing argument.</source>
          <target state="translated">这就是只有Java开发者才会有问题的原因。他们看了 &quot;参考 &quot;这个词,就认为自己很清楚这个词的意思,所以他们甚至懒得去考虑相反的论点。</target>
        </trans-unit>
        <trans-unit id="c94098a38907257d1a6a763b38d1468647d923f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;Java Language Specification&lt;/a&gt; also states</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;Java语言规范&lt;/a&gt;还指出</target>
        </trans-unit>
        <trans-unit id="079b195af1fa053069e0e9a1be334e5b752f52b4" translate="yes" xml:space="preserve">
          <source>The Java Spec says that everything in Java is pass-by-value. There is no such thing as &quot;pass-by-reference&quot; in Java.</source>
          <target state="translated">Java Spec说,Java中的所有东西都是按值传递的。在Java中没有 &quot;逐值传递 &quot;这种东西。</target>
        </trans-unit>
        <trans-unit id="fd7bc25c7313046e736eb3d62b656f193458641b" translate="yes" xml:space="preserve">
          <source>The Java programming language &lt;strong&gt;does not pass objects by reference; it&lt;/strong&gt;&lt;strong&gt;passes object references by value&lt;/strong&gt;. Because two copies of the same
  reference refer to the same actual object, changes made through one
  reference variable are visible through the other. There is exactly one
  parameter passing mode-&lt;strong&gt;pass by value&lt;/strong&gt;-and that helps keep things
  simple.</source>
          <target state="translated">Java编程语言&lt;strong&gt;不会通过引用传递对象。&lt;/strong&gt; &lt;strong&gt;它&lt;/strong&gt; &lt;strong&gt;按值传递对象引用&lt;/strong&gt; 。 由于相同引用的两个副本引用了相同的实际对象，因此通过一个引用变量进行的更改将通过另一个变量可见。 仅有一种参数传递模式- &lt;strong&gt;按值&lt;/strong&gt;传递-有助于简化操作。</target>
        </trans-unit>
        <trans-unit id="ea546a9da3076dcf69d6a878525afaefa3c2665d" translate="yes" xml:space="preserve">
          <source>The behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object).
Object's &lt;strong&gt;content/members&lt;/strong&gt; might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference.</source>
          <target state="translated">该行为可能与基本类型有所不同：因为复制的对象变量包含相同的地址（指向相同的对象）。 对象的&lt;strong&gt;内容/成员&lt;/strong&gt;可能仍可以在方法中进行修改，然后在外部进行访问，从而产生一种幻想，即（包含的）对象本身是通过引用传递的。</target>
        </trans-unit>
        <trans-unit id="f6f95a7e89d7fa53f741a6006a73b3f53dbfe98a" translate="yes" xml:space="preserve">
          <source>The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.</source>
          <target state="translated">上面的changeName函数永远无法修改传递的引用的实际内容(位值)。换句话说,changeName不能使Person引用到另一个对象。</target>
        </trans-unit>
        <trans-unit id="d43a36b01a5a36e6a4fed6f955af9bd89a90e8e2" translate="yes" xml:space="preserve">
          <source>The crux of the matter is that the word &lt;em&gt;reference&lt;/em&gt; in the expression &quot;pass by reference&quot; means something completely different from the usual meaning of the word &lt;em&gt;reference&lt;/em&gt; in Java.</source>
          <target state="translated">问题的症结在于表达式&amp;ldquo; by reference&amp;rdquo;中的&amp;ldquo;引用&amp;rdquo;一词的含义与Java中&amp;ldquo;引用&amp;rdquo;一词的通常含义完全不同。</target>
        </trans-unit>
        <trans-unit id="d6413d6c252fab8253fe8c316fa9f97b12f5c04a" translate="yes" xml:space="preserve">
          <source>The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.</source>
          <target state="translated">区别,或许只是我记忆中的方式,因为我以前的印象和原帖中的一样,是这样的。Java总是通过值来传递。Java中的所有对象(在Java中,除了基元之外的任何东西)都是引用。这些引用都是通过值传递的。</target>
        </trans-unit>
        <trans-unit id="e90dc2a7bcee6387a6415dbc06ec56f2e174cf42" translate="yes" xml:space="preserve">
          <source>The key to understanding this is that something like</source>
          <target state="translated">要理解这一点的关键是,像</target>
        </trans-unit>
        <trans-unit id="c870634849690af62ce95dbaaffd653c3bdc1132" translate="yes" xml:space="preserve">
          <source>The output of this program is:</source>
          <target state="translated">这个程序的输出是:</target>
        </trans-unit>
        <trans-unit id="914b3110e6efe55bce5c55f82df6a7638d0fa6d6" translate="yes" xml:space="preserve">
          <source>The term &quot;reference&quot; is a overloaded with two separate meanings. In Java it simply means a pointer, but in the context of &quot;Pass-by-reference&quot; it means a handle to the original variable which was passed in.</source>
          <target state="translated">术语 &quot;引用 &quot;是一个重载,有两个不同的含义。在Java中,它只是指一个指针,但在 &quot;通过引用 &quot;的上下文中,它指的是传入的原始变量的句柄。</target>
        </trans-unit>
        <trans-unit id="d685aec290065c3d070420033a198dff8941ecc8" translate="yes" xml:space="preserve">
          <source>The value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (&lt;code&gt;new ...&lt;/code&gt;) all resolve to a reference type value.</source>
          <target state="translated">参数（某种引用类型）的值是指向对象的指针。 请注意，变量，具有引用类型返回类型的方法的调用以及实例创建表达式（ &lt;code&gt;new ...&lt;/code&gt; ）都将解析为引用类型的值。</target>
        </trans-unit>
        <trans-unit id="b9723eb7fef6befdaac82e1c6cd7ab277e54545d" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; holding the address of the Object is passed to the function in line #3.</source>
          <target state="translated">持有对象地址的变量&lt;em&gt;人员&lt;/em&gt;将在第3行中传递给函数。</target>
        </trans-unit>
        <trans-unit id="9a827a692a5c5bbbe054c83be9d12f395ddfae3c" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; is created in line #1 and it's null at the beginning.</source>
          <target state="translated">变量&lt;em&gt;person&lt;/em&gt;是在第1行中创建的，开头是null。</target>
        </trans-unit>
        <trans-unit id="d211d018025495720be4d35b0fb0e965174108f6" translate="yes" xml:space="preserve">
          <source>The variable/reference &lt;em&gt;person&lt;/em&gt; is copied bit-by-bit and passed to &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; inside the function.</source>
          <target state="translated">变量/参考对象被逐位复制，并传递给&lt;em&gt;函数&lt;/em&gt;内部的&lt;em&gt;另一个ReferenceToTheSamePersonObject&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6a7f9ad555d80ee9f46a19d1dc4de44b454dbba" translate="yes" xml:space="preserve">
          <source>There are already great answers that cover this. I wanted to make a small contribution by sharing a &lt;strong&gt;very simple example&lt;/strong&gt; (which will compile) contrasting the behaviors between Pass-by-reference in c++ and Pass-by-value in Java.</source>
          <target state="translated">已经有很好的答案可以解决这个问题。 我想通过分享一个&lt;strong&gt;非常简单的示例&lt;/strong&gt; （将进行编译）做出一点贡献，以&lt;strong&gt;比较&lt;/strong&gt; c ++中的&amp;ldquo;按引用传递&amp;rdquo;和Java中的&amp;ldquo;按值传递&amp;rdquo;之间的行为。</target>
        </trans-unit>
        <trans-unit id="dfab606767515e58a1e6d064ffb7613d99a953bf" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;strong&gt;reference types&lt;/strong&gt;: class types, array types,
  and interface types. &lt;strong&gt;Their values are references to dynamically
  created class instances, arrays, or class instances or arrays that
  implement interfaces, respectively.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;引用类型有三种&lt;/strong&gt; ：类类型，数组类型和接口类型。 &lt;strong&gt;它们的值分别引用动态创建的类实例，数组或实现接口的类实例或数组。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa2284d9a49a58f0919e69504baa39d271367e04" translate="yes" xml:space="preserve">
          <source>There's the key.</source>
          <target state="translated">关键就在这里。</target>
        </trans-unit>
        <trans-unit id="e1f460dd17e5cf9708ba41d056ae77c8a33b5f05" translate="yes" xml:space="preserve">
          <source>Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.</source>
          <target state="translated">把引用参数看作是传递进来的变量的别名。当这个别名被分配时,被传递进来的变量也是如此。</target>
        </trans-unit>
        <trans-unit id="d3a442ecb80bc2357c8302e2cfa37890d9a8f934" translate="yes" xml:space="preserve">
          <source>This happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.</source>
          <target state="translated">出现这种情况是因为iA和iB是新的本地引用变量,它们的值与传递的引用相同(它们分别指向a和b)。所以,试图改变iA或iB的引用,只会在本地范围内改变,而不会在这个方法之外。</target>
        </trans-unit>
        <trans-unit id="5eefcb95db3d521d55f45ddd3a85d502cf4cdc4f" translate="yes" xml:space="preserve">
          <source>This is how jump-tables work.</source>
          <target state="translated">这就是跳表的工作原理。</target>
        </trans-unit>
        <trans-unit id="6bf397e1d5e88f4359962543f1564d72392aa1a0" translate="yes" xml:space="preserve">
          <source>This section of the book has a great explanation of parameter passing in Java and of the distinction between pass-by-reference and pass-by-value and it's by the creator of Java. I would encourage anyone to read it, especially if you're still not convinced.</source>
          <target state="translated">这本书的这一部分对Java中的参数传递有一个很好的解释,以及通过引用传递和通过值传递的区别,这本书的作者是Java的创造者。我鼓励大家都去读一读,特别是如果你还不相信的话。</target>
        </trans-unit>
        <trans-unit id="f6f7ba733b2534ecc1ea818cdddfaf4dcf24537c" translate="yes" xml:space="preserve">
          <source>This typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">通常，这意味着该函数可以修改（即分配给）用作参数的变量，该变量将被其调用者看到。</target>
        </trans-unit>
        <trans-unit id="a24fd574548676d8a5fdf4e5d5e866b85294afa6" translate="yes" xml:space="preserve">
          <source>This will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:</source>
          <target state="translated">这将填充Hello World,而不是World Hello,因为在交换函数中,你使用的是copy,这对主中的引用没有影响。但如果你的对象不是不可更改的,你可以改变它,比如说。</target>
        </trans-unit>
        <trans-unit id="e505e393bf5f01ebb5d9bfa9244eb4fa82d49415" translate="yes" xml:space="preserve">
          <source>This will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:</source>
          <target state="translated">这将在命令行中填充Hello World。如果你把StringBuffer改成String,它将只生成Hello,因为String是不可更改的。比如说</target>
        </trans-unit>
        <trans-unit id="ecc09e1b426d0f3bbdde2b52d1275b4a9684b1cb" translate="yes" xml:space="preserve">
          <source>To make a long story short, &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; objects have some very peculiar properties.</source>
          <target state="translated">简而言之， &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt;对象具有一些非常特殊的属性。</target>
        </trans-unit>
        <trans-unit id="d8f2d10c7283892fc482b2460252534f2c951f8f" translate="yes" xml:space="preserve">
          <source>To understand this more clearly, consider the following example:</source>
          <target state="translated">为了更清楚地理解这一点,可以考虑下面的例子。</target>
        </trans-unit>
        <trans-unit id="4a3568015b17ba4456e0d1ce2a6b83da248a6190" translate="yes" xml:space="preserve">
          <source>Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-reference&amp;mdash;all arguments are passed by value. A method call can pass two types of values to a method&amp;mdash;copies of primitive values (e.g., values of int and double) and copies of references to objects.</source>
          <target state="translated">与某些其他语言不同，Java不允许您在按值传递和按引用传递之间进行选择-所有参数均按值传递。 方法调用可以将两种类型的值传递给方法：原始值的副本（例如，int和double的值）和对对象的引用的副本。</target>
        </trans-unit>
        <trans-unit id="8379236c60a3ff28075f90353d681fa71cd1a5aa" translate="yes" xml:space="preserve">
          <source>Usually in Java &lt;em&gt;reference&lt;/em&gt; means a a &lt;em&gt;reference to an object&lt;/em&gt;. But the technical terms &lt;em&gt;pass by reference/value&lt;/em&gt; from programming language theory is talking about a &lt;em&gt;reference to the memory cell holding the variable&lt;/em&gt;, which is something completely different.</source>
          <target state="translated">通常在Java中&lt;em&gt;引用&lt;/em&gt;是指&lt;em&gt;对对象的引用&lt;/em&gt; 。 但是编程语言理论中&lt;em&gt;引用/值传递&lt;/em&gt;的技术术语是&lt;em&gt;指对持有变量的存储单元&lt;/em&gt;的&lt;em&gt;引用&lt;/em&gt; ，这是完全不同的。</target>
        </trans-unit>
        <trans-unit id="189b909d14e035d9439146930c7bf76ee3ba35f1" translate="yes" xml:space="preserve">
          <source>We have another reference variable in reverseArray method (array2) that points to an array c. If we were to say</source>
          <target state="translated">我们在reverseArray方法(array2)中还有一个引用变量指向数组c。</target>
        </trans-unit>
        <trans-unit id="df89229a206448022bc5ed3d58cbdd5121102868" translate="yes" xml:space="preserve">
          <source>What happens?</source>
          <target state="translated">怎么了?</target>
        </trans-unit>
        <trans-unit id="2721876ca410fad542be9395684b871758604935" translate="yes" xml:space="preserve">
          <source>What is the explanation?</source>
          <target state="translated">是什么解释?</target>
        </trans-unit>
        <trans-unit id="c6c48753b57b8c36067f08152d304ac38b370fa1" translate="yes" xml:space="preserve">
          <source>What that means, is when you have</source>
          <target state="translated">这意味着什么,是当你有</target>
        </trans-unit>
        <trans-unit id="b82d13a18500a976024ec3aaa69437e0d2e0bcb9" translate="yes" xml:space="preserve">
          <source>When a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.</source>
          <target state="translated">当一个方法修改一个基元类型的参数时,参数的变化对调用方法中的原始参数值没有影响。</target>
        </trans-unit>
        <trans-unit id="47a4b97547a431dafab08418cf4ef38d6006e62e" translate="yes" xml:space="preserve">
          <source>When it comes to objects, objects themselves cannot be passed to methods. So we pass the address of the object which is held in the reference variable.</source>
          <target state="translated">当涉及到对象时,对象本身是不能传递给方法的。所以我们要传递对象的地址,这个对象的地址被保存在引用变量中。</target>
        </trans-unit>
        <trans-unit id="42a98879de2bf7e9712995f5e8ec5b041e9c310b" translate="yes" xml:space="preserve">
          <source>When passing arguments to a method &lt;strong&gt;you ARE NOT passing the reference variable, but a copy of the bits in the reference variable&lt;/strong&gt;. Something like this: 3bad086a. 3bad086a represents a way to get to the passed object.</source>
          <target state="translated">当将参数传递给方法时， &lt;strong&gt;您不是传递参考变量，而是传递参考变量中位的副本&lt;/strong&gt; 。 像这样：3bad086a。 3bad086a表示一种获取传递的对象的方法。</target>
        </trans-unit>
        <trans-unit id="26b0a49f4378f6ec3b7ac0d3ca02eabd027e1846" translate="yes" xml:space="preserve">
          <source>When passing reference t to the function it will not directly pass the actual reference value of object test,  but it will create a copy of t and then pass it to the function. Since it is &lt;strong&gt;passing by value&lt;/strong&gt;, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was &lt;code&gt;0x100234&lt;/code&gt;, both t and f will have the same value and hence they will point to the same object.</source>
          <target state="translated">将引用t传递给函数时，它不会直接传递对象测试的实际参考值，而是会创建t的副本，然后将其传递给函数。 由于它&lt;strong&gt;按值传递&lt;/strong&gt; ，因此它传递变量的副本，而不是变量的实际引用。 因为我们说过t的值为 &lt;code&gt;0x100234&lt;/code&gt; ，所以t和f将具有相同的值，因此它们将指向相同的对象。</target>
        </trans-unit>
        <trans-unit id="db86d10509b05e8bc49df8c7cd3d9cada5dd82ab" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables, each of the declared type, before execution of the body of
  the method or constructor.&lt;/strong&gt; The Identifier that appears in the
  DeclaratorId may be used as a simple name in the body of the method or
  constructor to refer to the formal parameter.</source>
          <target state="translated">调用方法或构造函数时（第15.12节）， &lt;strong&gt;实际参数表达式的值会在执行方法或构造函数的主体之前，初始化每个声明类型的新创建的参数变量。&lt;/strong&gt; 出现在DeclaratorId中的标识符可用作方法或构造函数主体中的简单名称，以引用形式参数。</target>
        </trans-unit>
        <trans-unit id="8b67851b479dc283a6f950e2733c899590974221" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables&lt;/strong&gt;, each of the declared type, before execution of the body of
  the method or constructor.</source>
          <target state="translated">调用方法或构造函数时（第15.12节）， &lt;strong&gt;实际参数表达式的值会&lt;/strong&gt;在执行方法或构造函数的主体之前， &lt;strong&gt;初始化&lt;/strong&gt;每个声明类型的&lt;strong&gt;新创建的参数变量&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d221d1e03c75efd20f3411a07f7d84f428d8be4" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the actual argument expressions initialize newly created parameter variables&lt;/strong&gt;, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;formal parameter&lt;/a&gt;.</source>
          <target state="translated">调用方法或构造函数时（第15.12节）， &lt;strong&gt;实际参数表达式的值会&lt;/strong&gt;在执行方法或构造函数的主体之前， &lt;strong&gt;初始化&lt;/strong&gt;每个声明类型的&lt;strong&gt;新创建的参数变量&lt;/strong&gt; 。 出现在DeclaratorId中的标识符可以用作方法或构造函数主体中的简单名称，以引用&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;形式参数&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aee34f3d95b06bea3cb4049aac2fc385dba277b" translate="yes" xml:space="preserve">
          <source>When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are against the word &quot;pointer&quot;. Whatever. Just know that the address of the object goes on the stack.</source>
          <target state="translated">当你声明并实例化一个对象时。实际的对象会在堆上。堆上有什么?就是对象在堆上的地址。C++程序员会把它称为指针,但有些Java开发者反对 &quot;指针 &quot;这个词。管它呢。只要知道对象的地址在堆上就可以了。</target>
        </trans-unit>
        <trans-unit id="28b1f1b3dfbb6a4aedcea3dba4b14239a6b023ba" translate="yes" xml:space="preserve">
          <source>Which means, java creates a copy of the passed parameters before executing a method. Like most people who studied compilers in college, I used &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;&quot;The Dragon Book&quot;&lt;/a&gt; which is &lt;strong&gt;THE&lt;/strong&gt; compilers book. It has a good description of &quot;Call-by-value&quot; and &quot;Call-by-Reference&quot; in Chapter 1. The Call-by-value description matches up with Java Specs exactly.</source>
          <target state="translated">这意味着，java在执行方法之前创建了传递的参数的副本。 像大多数在大学学习编译器的人一样，我使用了&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;《 The Dragon Book》&lt;/a&gt;这本编译器书。 在第1章中对&amp;ldquo;按值调用&amp;rdquo;和&amp;ldquo;按引用调用&amp;rdquo;有很好的描述。&amp;ldquo;按值调用&amp;rdquo;描述与Java规范完全匹配。</target>
        </trans-unit>
        <trans-unit id="0dcbcbf7f981b706be204f899221bd4d6394bba1" translate="yes" xml:space="preserve">
          <source>Will this throw a &lt;code&gt;NullPointerException&lt;/code&gt;? No, because it only passes a copy of the reference. 
In the case of passing by reference, it could have thrown a &lt;code&gt;NullPointerException&lt;/code&gt;, as seen below:</source>
          <target state="translated">这会抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 吗？ 不可以，因为它仅传递参考的副本。 在通过引用传递的情况下，它可能抛出 &lt;code&gt;NullPointerException&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="a28f32f5173460812904146e506dc73421a481d8" translate="yes" xml:space="preserve">
          <source>You always pass a copy of the bits of the value of the reference!</source>
          <target state="translated">你总是通过一个副本的比特值的参考值!</target>
        </trans-unit>
        <trans-unit id="a3dc507f44237c76ec4ef1ec8e4c68370d0b3167" translate="yes" xml:space="preserve">
          <source>You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:</source>
          <target state="translated">在Java中,你永远不能通过引用传递,其中一个明显的方法就是当你想从一个方法调用中返回多个值时。考虑一下下面这段C++中的代码。</target>
        </trans-unit>
        <trans-unit id="02c7b73324c917e7dbe1ca63e76c51d7ead60641" translate="yes" xml:space="preserve">
          <source>You could also assign value of array2 in main to array1. array1 would start pointing to b.</source>
          <target state="translated">你也可以将main中的数组2的值分配给数组1,数组1开始指向b。</target>
        </trans-unit>
        <trans-unit id="6b4f593c12270cbc6715abff6481a0a796758bb7" translate="yes" xml:space="preserve">
          <source>You should note that when the parameter is an object reference, it is
  the object reference-not the object itself-that is &lt;strong&gt;passed &quot;by value&quot;&lt;/strong&gt;.</source>
          <target state="translated">您应该注意，当参数是对象引用时，是&lt;strong&gt;&amp;ldquo;按值&amp;rdquo;传递的&lt;/strong&gt;是对象引用而不是对象本身。</target>
        </trans-unit>
        <trans-unit id="fc75d6d2c095fd5d227713114c34ed1913a0b634" translate="yes" xml:space="preserve">
          <source>You're passing the value of the reference and not the reference itself (and not the object).</source>
          <target state="translated">你传递的是引用的值,而不是引用本身(而不是对象)。</target>
        </trans-unit>
        <trans-unit id="e412d3eb76b9c511737b2f188cf28aa0a3b15e42" translate="yes" xml:space="preserve">
          <source>a new &lt;code&gt;Dog&lt;/code&gt; is created. Let's say he's at address 74</source>
          <target state="translated">创建了一条新的 &lt;code&gt;Dog&lt;/code&gt; 。 假设他在地址74</target>
        </trans-unit>
        <trans-unit id="fb3668ea3a8369fdbba52413c9d814f6e3ed4702" translate="yes" xml:space="preserve">
          <source>all bind the value of a reference to a &lt;code&gt;String&lt;/code&gt; instance to the method's newly created parameter, &lt;code&gt;param&lt;/code&gt;. This is exactly what the definition of pass-by-value describes. As such, &lt;strong&gt;Java is pass-by-value&lt;/strong&gt;.</source>
          <target state="translated">全部将对 &lt;code&gt;String&lt;/code&gt; 实例的引用的值绑定到该方法的新创建参数 &lt;code&gt;param&lt;/code&gt; 。 这正是值传递定义的描述。 因此， &lt;strong&gt;Java是按值传递&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c38907cfcadbaccdbfd358b9d0106488c0111a7" translate="yes" xml:space="preserve">
          <source>at line &quot;AAA&quot;</source>
          <target state="translated">在 &quot;AAA &quot;行</target>
        </trans-unit>
        <trans-unit id="f93c76dfe98a248d087f8423725428bab806588d" translate="yes" xml:space="preserve">
          <source>at line &quot;BBB&quot;</source>
          <target state="translated">在 &quot;BBB &quot;行</target>
        </trans-unit>
        <trans-unit id="48a51572765a96c5528d9b97e645d1cb1d8ca215" translate="yes" xml:space="preserve">
          <source>at line &quot;CCC&quot;</source>
          <target state="translated">在 &quot;CCC &quot;行</target>
        </trans-unit>
        <trans-unit id="5b6a04bdcab2545757147311bdd9dcec1526a1b4" translate="yes" xml:space="preserve">
          <source>edit: i believe this is also the reason to use StringBuffer when it comes to &quot;adding&quot; two Strings because you can modifie the original object which u can't with immutable objects like String is.</source>
          <target state="translated">edit:我相信这也是使用StringBuffer来 &quot;添加 &quot;两个Strings的原因,因为你可以修改原始对象,而像String这样的不可变对象是无法修改的。</target>
        </trans-unit>
        <trans-unit id="de6d9b079fecccb2b44d0540cd59d6982bd1a708" translate="yes" xml:space="preserve">
          <source>if the Method were defined as</source>
          <target state="translated">如果该方法被定义为</target>
        </trans-unit>
        <trans-unit id="c0b841e19d194bfe513d4d90839ad8c2b89afe31" translate="yes" xml:space="preserve">
          <source>in case 1. and 2. if you change Foo (&lt;code&gt;Foo = 9&lt;/code&gt;) it only affects local scope as you have a copy of the Value. From inside the method we cannot even determine where in memory the original Foo was located.</source>
          <target state="translated">在情况1和情况2中。如果更改Foo（ &lt;code&gt;Foo = 9&lt;/code&gt; ），则仅会影响本地范围，因为您拥有Value的副本。 从方法内部，我们甚至无法确定原始Foo在内存中的位置。</target>
        </trans-unit>
        <trans-unit id="1865b6df13986dcf11d66c36aeef32061892ca5b" translate="yes" xml:space="preserve">
          <source>in case 3. and 4. if you use default language constructs and change Foo (&lt;code&gt;Foo = 11&lt;/code&gt;), it could change Foo globally (depends on the language, ie. Java or like Pascal's &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt;&lt;strong&gt;var m&lt;/strong&gt;&lt;code&gt;: integer);&lt;/code&gt;). However if the language allows you to circumvent the dereference process, you can change &lt;code&gt;47&lt;/code&gt;, say to &lt;code&gt;49&lt;/code&gt;. At that point Foo seems to have been changed if you read it, because you have changed the &lt;strong&gt;local pointer&lt;/strong&gt; to it. And if you were to modify this Foo inside the method (&lt;code&gt;Foo = 12&lt;/code&gt;) you will probably FUBAR the execution of the program (aka. segfault) because you will write to a different memory than expected, you can even modify an area that is destined to hold executable program and writing to it will modify running code (Foo is now not at &lt;code&gt;47&lt;/code&gt;). BUT Foo's value of &lt;code&gt;47&lt;/code&gt; did not change globally, only the one inside the method, because &lt;code&gt;47&lt;/code&gt; was also a copy to the method.</source>
          <target state="translated">在情况3和情况4中。如果使用默认语言构造并更改Foo（ &lt;code&gt;Foo = 11&lt;/code&gt; ），则可能会全局更改Foo（取决于语言，即Java或类似Pascal的 &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt; &lt;strong&gt;var m&lt;/strong&gt; &lt;code&gt;: integer);&lt;/code&gt; ）。 但是，如果该语言允许您规避取消引用过程，则可以将 &lt;code&gt;47&lt;/code&gt; 更改为 &lt;code&gt;49&lt;/code&gt; 。 那时，如果您读了Foo，似乎已经更改了，因为您已经更改了&lt;strong&gt;指向&lt;/strong&gt;它的&lt;strong&gt;本地指针&lt;/strong&gt; 。 而且，如果您要在方法内部修改此Foo（ &lt;code&gt;Foo = 12&lt;/code&gt; ），则可能会执行FUBAR程序（也就是segfault），因为您将写入与预期不同的内存，甚至可以修改指定区域保留可执行程序并对其进行写入将修改正在运行的代码（Foo现在不在 &lt;code&gt;47&lt;/code&gt; 处 ）。 但是Boo Foo的 &lt;code&gt;47&lt;/code&gt; 值并没有全局变化，只是方法内部的值变化了，因为 &lt;code&gt;47&lt;/code&gt; 也是该方法的副本。</target>
        </trans-unit>
        <trans-unit id="dd97dfe75334fc4ae374b64905b80db5da6f0246" translate="yes" xml:space="preserve">
          <source>in case 5. and 6. if you modify &lt;code&gt;223&lt;/code&gt; inside the method it creates the same mayhem as in 3. or 4. (a pointer, pointing to a now bad value, that is again used as a pointer) but this is still a local problem, as 223 was &lt;strong&gt;copied&lt;/strong&gt;. However if you are able to dereference &lt;code&gt;Ref2Foo&lt;/code&gt; (that is &lt;code&gt;223&lt;/code&gt;), reach to and modify the pointed value &lt;code&gt;47&lt;/code&gt;, say, to &lt;code&gt;49&lt;/code&gt;, it will affect Foo &lt;strong&gt;globally&lt;/strong&gt;, because in this case the methods got a copy of &lt;code&gt;223&lt;/code&gt;  but the referenced &lt;code&gt;47&lt;/code&gt; exists only once, and changing that to &lt;code&gt;49&lt;/code&gt; will lead every &lt;code&gt;Ref2Foo&lt;/code&gt; double-dereferencing to a wrong value.</source>
          <target state="translated">在情况5和情况6中。如果您在方法内部修改 &lt;code&gt;223&lt;/code&gt; ，则会创建与3.或4中相同的混乱状态（一个指针，指向一个现在不好的值，该指针再次用作指针），但这仍然是本地问题，因为223被&lt;strong&gt;复制&lt;/strong&gt; 。 但是，如果您能够取消引用 &lt;code&gt;Ref2Foo&lt;/code&gt; （即 &lt;code&gt;223&lt;/code&gt; ），则达到并修改指针值 &lt;code&gt;47&lt;/code&gt; ，例如，将其更改为 &lt;code&gt;49&lt;/code&gt; ，将&lt;strong&gt;全局&lt;/strong&gt;影响Foo，因为在这种情况下，方法获得了 &lt;code&gt;223&lt;/code&gt; 的副本，但引用的 &lt;code&gt;47&lt;/code&gt; 存在仅将其更改为 &lt;code&gt;49&lt;/code&gt; 将导致每个 &lt;code&gt;Ref2Foo&lt;/code&gt; 双重引用都错误地返回一个值。</target>
        </trans-unit>
        <trans-unit id="ea582fe2290fa53002694c7ca06cb1d90981b239" translate="yes" xml:space="preserve">
          <source>in reverseArray method, it will make a change in array a.</source>
          <target state="translated">在reverseArray方法中,它将对数组a进行修改。</target>
        </trans-unit>
        <trans-unit id="84dd6095c9c7186e7a49f24a310118598e04da82" translate="yes" xml:space="preserve">
          <source>in reverseArray method, then the reference variable array1 in method reverseArray would stop pointing to array a and start pointing to array c (Dotted line in second image).</source>
          <target state="translated">方法中的reverseArray方法中的参考变量array1将停止指向数组a,而开始指向数组c(第二张图中的虚线)。</target>
        </trans-unit>
        <trans-unit id="d97fae11a419e6a12bc3edb13062dc19c09875c0" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;not&lt;/em&gt; a Dog; it's actually a &lt;em&gt;pointer&lt;/em&gt; to a Dog.</source>
          <target state="translated">&lt;em&gt;不是&lt;/em&gt;狗 它实际上是&lt;em&gt;指向&lt;/em&gt;狗的&lt;em&gt;指针&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="b39623476b2f81bd70a4ff62eb5267bce22738e1" translate="yes" xml:space="preserve">
          <source>let's look at what's happening.</source>
          <target state="translated">让我们来看看发生了什么。</target>
        </trans-unit>
        <trans-unit id="cf3a9617ac647d82c56f77cf9e8ae2169d187941" translate="yes" xml:space="preserve">
          <source>name= Fido</source>
          <target state="translated">名称=Fido</target>
        </trans-unit>
        <trans-unit id="dcf9d3f64bd4525093b6cb2a29ebf7e8b0769c96" translate="yes" xml:space="preserve">
          <source>name= Maxx</source>
          <target state="translated">名称=Maxx</target>
        </trans-unit>
        <trans-unit id="ea4bd0e3bb9e113c03dc6f25c82ed0880ff1e2b7" translate="yes" xml:space="preserve">
          <source>output of java PassByCopy:</source>
          <target state="translated">java PassByCopy.com的输出。</target>
        </trans-unit>
        <trans-unit id="38b2369b273631468a9a5a2e59b5d466d9ec4e32" translate="yes" xml:space="preserve">
          <source>results in this:</source>
          <target state="translated">结果是这样的。</target>
        </trans-unit>
        <trans-unit id="015c3de73f8f17655e3dba14c211482d8731c15c" translate="yes" xml:space="preserve">
          <source>someDog is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 74)</source>
          <target state="translated">someDog跟随它指向的 &lt;code&gt;Dog&lt;/code&gt; （地址为74的Dog对象）</target>
        </trans-unit>
        <trans-unit id="e52ae0c10562272d36f12c255484e6e511e5858a" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 42) is asked to change his name to Max</source>
          <target state="translated">那只 &lt;code&gt;Dog&lt;/code&gt; （地址为42的那只狗 ）被要求将他的名字改成Max</target>
        </trans-unit>
        <trans-unit id="7444c7540aa94d77adc3ade05581aa22935938f0" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 74) is asked to change his name to Rowlf</source>
          <target state="translated">那只 &lt;code&gt;Dog&lt;/code&gt; （地址为74的那只狗 ）被要求将他的名字改成Rowlf</target>
        </trans-unit>
        <trans-unit id="a28fea2db09c1001f61be42d428ec193c0c8fe83" translate="yes" xml:space="preserve">
          <source>the parameter &lt;code&gt;someDog&lt;/code&gt; is set to the value 42</source>
          <target state="translated">参数 &lt;code&gt;someDog&lt;/code&gt; 设置为值42</target>
        </trans-unit>
        <trans-unit id="05ed7faac6636fc4d3a902712b65ab43bb7a5b80" translate="yes" xml:space="preserve">
          <source>then, we return</source>
          <target state="translated">那么,我们回到</target>
        </trans-unit>
        <trans-unit id="49280f2d918fc694c452825a7629c4f082161d51" translate="yes" xml:space="preserve">
          <source>using methods from the object given as parameter will alter the
object as the references point to
the original objects. (if that
method itself alters some values)</source>
          <target state="translated">使用给定对象中的方法作为参数将改变对象,因为引用指向原始对象。(如果该方法本身改变了一些值)</target>
        </trans-unit>
        <trans-unit id="d8b3d65782447afeffa2d99acee97cbf42b98ecf" translate="yes" xml:space="preserve">
          <source>we assign the parameter &lt;code&gt;someDog&lt;/code&gt; to 74</source>
          <target state="translated">我们将参数 &lt;code&gt;someDog&lt;/code&gt; 分配给74</target>
        </trans-unit>
        <trans-unit id="b5086d2ae6b0cb0d15f1111f65e03a674960103f" translate="yes" xml:space="preserve">
          <source>will print out &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; instead of &lt;code&gt;null&lt;/code&gt;. The reason this works is because &lt;code&gt;bar&lt;/code&gt; is a copy of the value of &lt;code&gt;baz&lt;/code&gt;, which is just a reference to &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt;. If it were the actual reference itself, then &lt;code&gt;foo&lt;/code&gt; would have redefined &lt;code&gt;baz&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">将打印出 &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; 而不是 &lt;code&gt;null&lt;/code&gt; 。 之所以起作用，是因为 &lt;code&gt;bar&lt;/code&gt; 是 &lt;code&gt;baz&lt;/code&gt; 值的副本，而baz只是对 &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; 的引用。 。 如果它是实际的引用本身，那么 &lt;code&gt;foo&lt;/code&gt; 会将 &lt;code&gt;baz&lt;/code&gt; 重新定义为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f07948ada1b914ebc3731995719969a1b588a36" translate="yes" xml:space="preserve">
          <source>you're essentially passing the &lt;em&gt;address&lt;/em&gt; of the created &lt;code&gt;Dog&lt;/code&gt; object to the &lt;code&gt;foo&lt;/code&gt; method.</source>
          <target state="translated">您实际上是将创建的 &lt;code&gt;Dog&lt;/code&gt; 对象的&lt;em&gt;地址&lt;/em&gt;传递给 &lt;code&gt;foo&lt;/code&gt; 方法。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
