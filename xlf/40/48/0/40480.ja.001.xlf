<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/40480">
    <body>
      <group id="40480">
        <trans-unit id="679ac82a1b80b565bd19565ec122a565572f35a9" translate="yes" xml:space="preserve">
          <source>&quot;String&quot; Objects appear to be a good &lt;strong&gt;counter-example&lt;/strong&gt; to the urban legend saying that &quot;Objects are passed by reference&quot;:</source>
          <target state="translated">「文字列」オブジェクトは、「オブジェクトは参照によって渡される」という都市の伝説に対する良い&lt;strong&gt;反例の&lt;/strong&gt;ように見えます。</target>
        </trans-unit>
        <trans-unit id="d88ecdddf8b9e6ef14e68530529dc23d4ff6b148" translate="yes" xml:space="preserve">
          <source>&quot;by value&quot; is the only way in java to pass a parameter to a method</source>
          <target state="translated">&quot;by value &quot;は、javaではパラメータをメソッドに渡す唯一の方法です。</target>
        </trans-unit>
        <trans-unit id="ac7bea48c9f3e3c013ee3b9ca43c1cd4255ba9c6" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Account account1&amp;rdquo; is the type and name of the reference variable, &amp;ldquo;=&amp;rdquo; is the assignment operator, &amp;ldquo;new&amp;rdquo; asks for the required amount of space from the system. The constructor to the right of keyword new which creates the object is called implicitly by the keyword new. Address of the created object(result of right variable, which is an expression) is assigned to the left variable (which is a reference variable with a name and a type specified) using the assign operator. &amp;ldquo;new Account()&amp;rdquo; is called &amp;ldquo;class instance creation expression&amp;rdquo;.</source>
          <target state="translated">「アカウントaccount1」は参照変数のタイプと名前、「=」は代入演算子、「new」はシステムに必要な容量を要求します。 オブジェクトを作成するキーワードnewの右側にあるコンストラクターは、キーワードnewによって暗黙的に呼び出されます。 作成されたオブジェクトのアドレス（式である右側の変数の結果）は、代入演算子を使用して左側の変数（名前と型が指定された参照変数）に割り当てられます。 「new Account（）」は「クラスインスタンス作成式」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="94aa2ba0bb8a675b61aef491a803f4a9834f2892" translate="yes" xml:space="preserve">
          <source>(I say essentially because Java pointers aren't direct addresses, but it's easiest to think of them that way)</source>
          <target state="translated">(Java ポインタは直接アドレスではないので、本質的にと言いますが、そのように考えるのが一番簡単です)</target>
        </trans-unit>
        <trans-unit id="4deb5f3c7a0f51652194597de3c850eb67417a51" translate="yes" xml:space="preserve">
          <source>/**
  This 'Pass By Value has a feeling of 'Pass By Reference'</source>
          <target state="translated">/**この'Pass By Value'は'Pass By Reference'のような感じがします。</target>
        </trans-unit>
        <trans-unit id="9aadafd84fb3481ea6953e7000de351b550c282f" translate="yes" xml:space="preserve">
          <source>/**
 * 
 * Pass By Value
 *
 */</source>
          <target state="translated">***パス・バイ・バリュー******パス・バイ・バリュー</target>
        </trans-unit>
        <trans-unit id="2d699180ecfe5b34c3e0bc840eb47751e4372814" translate="yes" xml:space="preserve">
          <source>223 gets PUSHd to the stack.</source>
          <target state="translated">223はスタックにPUSHされる</target>
        </trans-unit>
        <trans-unit id="6446e71ace78a7a3a0a5710cd60edb392c5f7798" translate="yes" xml:space="preserve">
          <source>223 gets copied to one of the CPU registers.</source>
          <target state="translated">223はCPUレジスタの1つにコピーされます。</target>
        </trans-unit>
        <trans-unit id="b89be71dff7edaa9c74d2426c943f820435958da" translate="yes" xml:space="preserve">
          <source>47 PUSHd to the stack.</source>
          <target state="translated">47スタックにPUSHd。</target>
        </trans-unit>
        <trans-unit id="29eebea6f72ba92d2ef802d866c3af082d2c6911" translate="yes" xml:space="preserve">
          <source>47 gets copied to one of the CPU registers</source>
          <target state="translated">47 は CPU レジスタの 1 つにコピーされます。</target>
        </trans-unit>
        <trans-unit id="35f6cb5f76dc39cccdd22e4f4ed75145651bad22" translate="yes" xml:space="preserve">
          <source>5 gets PUSHd to the stack.</source>
          <target state="translated">5はスタックにPUSHされる。</target>
        </trans-unit>
        <trans-unit id="bd53eeaa13917b9c1cd0ffee5c08d5548f0f975f" translate="yes" xml:space="preserve">
          <source>5 gets copied to one of the CPU registers (ie. EAX).</source>
          <target state="translated">5 は、CPU レジスタの 1 つ(EAX など)にコピーされます。</target>
        </trans-unit>
        <trans-unit id="669fc2a12114e17f53bf6a6eea0a996b3e52e4db" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;Java is also mentioned&lt;/a&gt;. Here is the short summary:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;Javaについても触れてい&lt;/a&gt;ます。 ここに短い要約があります：</target>
        </trans-unit>
        <trans-unit id="44522a95088af6ee8afeac1924a88cbdb726d3ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a = b&lt;/code&gt; makes a new assignment to the reference &lt;code&gt;a&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;f&lt;/code&gt;, of the object whose its attribute is &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a = b&lt;/code&gt; は、属性が &lt;code&gt;&quot;b&quot;&lt;/code&gt; であるオブジェクトの、 &lt;code&gt;f&lt;/code&gt; では&lt;strong&gt;なく&lt;/strong&gt;参照aに新しい割り当てを行います。</target>
        </trans-unit>
        <trans-unit id="dc8f4e638edf822f721d61b825c182734c0569b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; will change the attribute of the object that reference &lt;code&gt;c&lt;/code&gt; points to it, and it's same object that reference &lt;code&gt;f&lt;/code&gt; points to it.</source>
          <target state="translated">&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; を参照するオブジェクトの属性を変更します。また、 &lt;code&gt;f&lt;/code&gt; を参照するオブジェクトと同じオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="14cac2530311a23fb072c9ef26feba713000c665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;someDog&lt;/code&gt; is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 42)</source>
          <target state="translated">&lt;code&gt;someDog&lt;/code&gt; は、それが指す &lt;code&gt;Dog&lt;/code&gt; （アドレス42のDogオブジェクト）に追従します。</target>
        </trans-unit>
        <trans-unit id="1e1295aabf56bdb60aa6cdd4c585a17ef60d34fd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Did &lt;code&gt;myDog&lt;/code&gt; change?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;myDog&lt;/code&gt; は変わりましたか？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f5e57136a5902e29d33131a3a28391b65ae5a66" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Master&lt;/em&gt;: Grasshopper, No.</source>
          <target state="translated">&lt;em&gt;マスター&lt;/em&gt; ：バッタ、いいえ</target>
        </trans-unit>
        <trans-unit id="b89440cba42f99210f8524ad856b1d7e2968203e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Student&lt;/em&gt;: Master, does this mean that Java is pass-by-reference?</source>
          <target state="translated">&lt;em&gt;学生&lt;/em&gt; ：マスター、これはJavaが参照渡しであることを意味しますか？</target>
        </trans-unit>
        <trans-unit id="e9026cb4dbf68f5a89f59e77b991a00db2fad347" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;This value is actually COPIED and given to the method&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;この値は実際にはコピーされ、メソッドに渡され&lt;/em&gt;&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="eac8606431b898a08bfa815724043bf24baea91c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A variable holds the bits that tell the JVM how to get to the referenced Object in memory (Heap).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;変数は、メモリ（ヒープ）内の参照されるオブジェクトに到達する方法をJVMに指示するビットを保持します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee963e4f98e2321319006e78120a5c33385ffa8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All parameters to methods are passed &quot;by value&quot;&lt;/strong&gt;. In other words,
  values of parameter variables in a method are copies of the invoker
  specified as arguments.</source>
          <target state="translated">&lt;strong&gt;メソッドへのすべてのパラメーターは「値によって」渡されます&lt;/strong&gt; 。 つまり、メソッドのパラメータ変数の値は、引数として指定された呼び出し元のコピーです。</target>
        </trans-unit>
        <trans-unit id="d0c0ba2ae2424364bf0a5b15f58afb340e72d7df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ allows Pass-by-reference&lt;/strong&gt; by declaring a reference parameter using the &quot;&amp;amp;&quot; character (which happens to be the same character used to indicate &quot;the address of a variable&quot; in both C and C++). For example, if we pass in a pointer by reference, the parameter and the argument are not just pointing to the same object. Rather, they are the same variable. If one gets set to a different address or to null, so does the other.</source>
          <target state="translated">&lt;strong&gt;C ++では&lt;/strong&gt; 、「＆」文字（CとC ++の両方で「変数のアドレス」を示すために使用される文字と同じ文字）を使用して参照パラメーターを宣言すること&lt;strong&gt;により、参照渡しを許可&lt;/strong&gt;しています。 たとえば、ポインターを参照渡しする場合、パラメーターと引数は同じオブジェクトを指しているだけではありません。 むしろ、それらは同じ変数です。 一方が別のアドレスまたはnullに設定された場合、もう一方も設定されます。</target>
        </trans-unit>
        <trans-unit id="250414fd453c52d7a94d41cac5720b0bf6770e9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;編集2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e432c6162816f0458b741aeccb3b66bf810d917a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;編集3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3b32f3bc0cf8e132bab93bdb849247ffeab0402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;編集4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eee5a199ee48a34a0cc9134ad8533202fc7fcb52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例1：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba5182d053766559c8a796587cc6e079b0edece9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例2：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87994c9ddef100c712273600d84d2680b1176fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例3：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f029fd8a8bc2187006a97a36768f3a9a0f4c6825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例4：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46619b51e67a75935bc9ceedee2a6019b4258008" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Java creates and stores objects:&lt;/strong&gt; When we create an object we store the object&amp;rsquo;s address in a reference variable. Let's analyze the following statement.</source>
          <target state="translated">&lt;strong&gt;Javaがオブジェクトを作成して保存する方法：オブジェクト&lt;/strong&gt;を作成するとき、オブジェクトのアドレスを参照変数に保存します。 次のステートメントを分析してみましょう。</target>
        </trans-unit>
        <trans-unit id="8522a877bd114b6f39cde66fbd073f0156a79129" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Java only references are passed and are passed by value:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Javaでは参照のみが渡され、値によって渡されます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fb07fd2faf3d430de82df4b1196a7157526121c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java doesn't pass method arguments by reference; it passes them by value.&lt;/strong&gt; I will use example from &lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;this site&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Javaは参照によってメソッド引数を渡しません。&lt;/strong&gt; &lt;strong&gt;値で渡します。&lt;/strong&gt; &lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;このサイトの&lt;/a&gt;例を使用します 。</target>
        </trans-unit>
        <trans-unit id="f8710d2de84f7d70df19d71411b10789671cf77e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is Pass-by-value&lt;/strong&gt;, but allows us to emulate pass be reference by passing a Java reference (i.e. a pointer) by value. Meaning it passes a copy of the Java reference. &lt;strong&gt;&lt;em&gt;EDIT&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;: since someone made a comment about this, let me explain. Before C, several (but not all) earlier languages like FORTRAN and COBOL supported PBR, but C did not. In order to change the values of variables inside functions, C programmers emulated PBR by passing pointers to variables into functions. Languages inspired by C, such as Java, borrowed this idea and continue to emulate PBR as C did.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Javaは値&lt;/strong&gt;渡しですが、値によってJava参照（つまり、ポインター）を渡すことにより、参照渡しをエミュレートできます。 つまり、Java参照のコピーを渡します。 &lt;strong&gt;&lt;em&gt;編集&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;：誰かがこれについてコメントしたので、説明しましょう。&lt;/em&gt; &lt;em&gt;Cより前は、FORTRANやCOBOLなどの以前のいくつかの言語（すべてではない）がPBRをサポートしていましたが、Cはサポートしていませんでした。&lt;/em&gt; &lt;em&gt;関数内の変数の値を変更するために、Cプログラマーは変数へのポインターを関数に渡すことによってPBRをエミュレートしました。&lt;/em&gt; &lt;em&gt;JavaなどのCに触発された言語はこのアイデアを取り入れ、Cと同じようにPBRをエミュレートし続けます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="539967da6afd5b4c7cf196939fd0d2173148d5e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is always pass by value, not pass by reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Javaは常に参照渡しではなく、値渡しです&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daf65d846a847f4224f37e5964ce49e033a6516e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;anotherReferenceToTheSamePersonObject矢印は、変数personではなく、Objectに向けられていることに注意してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82bf5f83e99ffaf8561e8e28fe3ef14c8cc29ecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;On this line 'pass-by-value' goes into the play...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;この行では、「値渡し」が登場します...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f82acf071fee6ab2a7abd0313bbf60fe384f861" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (also called pass by address) means that a copy of the address of the actual parameter is stored&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;参照渡し（アドレス渡しとも呼ばれる）は、実際のパラメーターのアドレスのコピーが保管されることを意味します&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="24f93d53f1599b4ac1080cabfb887cfff18610ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference&lt;/strong&gt;--There is no copy of the reference. Single reference is shared by both the caller and the function being called. Any changes to the reference or the Object's data are reflected in the caller's scope.</source>
          <target state="translated">&lt;strong&gt;参照&lt;/strong&gt;渡し&lt;strong&gt;-参照&lt;/strong&gt;のコピーはありません。 単一の参照は、呼び出し元と呼び出される関数の両方で共有されます。 参照またはオブジェクトのデータへの変更は、呼び出し元のスコープに反映されます。</target>
        </trans-unit>
        <trans-unit id="a7a81b026c4fc8d49d09f4de01c114901f7c0d8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value means that you are making a copy in memory of the actual parameter's value that is passed in. This is a copy of the contents of the actual parameter&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;値渡しとは、渡される実際のパラメーターの値のコピーをメモリに作成することを意味します。これは、実際のパラメーターの内容のコピーです&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="5501243b5acfe1576d19283bdb0a2ab76d3504bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing a reference by value&lt;/strong&gt;--Changes to the reference are not reflected in the caller's scope, but the changes to the object are. This is because the reference is copied, but the both the original and the copy refer to the same object.</source>
          <target state="translated">&lt;strong&gt;参照を値で&lt;/strong&gt;渡す-参照への変更は呼び出し元のスコープには反映されませんが、オブジェクトへの変更は反映されます。 これは、参照はコピーされますが、元のオブジェクトとコピーの両方が同じオブジェクトを参照しているためです。</target>
        </trans-unit>
        <trans-unit id="d128a624743e2f0a142ea51104871088ef3baab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Result&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f28b5e99d681d23b2424be728e4d14ac53de034" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation.&lt;/strong&gt; The definition of pass-by-reference was</source>
          <target state="translated">&lt;strong&gt;参照に従ってメソッドを呼び出したり、参照されたオブジェクトのフィールドにアクセスしたりできるという事実は、会話とはまったく関係ありません。&lt;/strong&gt; 参照渡しの定義は</target>
        </trans-unit>
        <trans-unit id="155adcfa1e1a2d90f9b1663c701b8baa445db69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The reference values (often just references) are pointers to these objects&lt;/strong&gt;, and a special null reference, which refers to no object.</source>
          <target state="translated">&lt;strong&gt;参照値（多くの場合、参照のみ）は、これらのオブジェクトへのポインタ&lt;/strong&gt;であり、 &lt;strong&gt;オブジェクト&lt;/strong&gt;を参照しない特別なnull参照です。</target>
        </trans-unit>
        <trans-unit id="c6c7f19df18b6b50e6865d7508209d9363946c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you'll just smile :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これは、参照渡しまたは値渡しのJavaに関する次のディスカッションで微笑む点まで、Javaが実際にどのように機能するかについての洞察を提供します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a57a48f1825e5c9fb8aafac2b685e4eb2761f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the value of the argument?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;議論の価値は何ですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f32da0f05cfb43b8594e1350dffac69d7279c2e" translate="yes" xml:space="preserve">
          <source>A String Object, holds characters by an array declared &lt;strong&gt;final&lt;/strong&gt; that can't be modified.
Only the address of the Object might be replaced by another using &quot;new&quot;. 
Using &quot;new&quot; to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.</source>
          <target state="translated">文字列オブジェクト。変更できない&lt;strong&gt;final&lt;/strong&gt;と宣言された配列によって文字を保持します。 「new」を使用して、オブジェクトのアドレスのみを別のアドレスに置き換えることができます。 「新規」を使用して変数を更新すると、変数は最初に値で渡されてコピーされたため、オブジェクトに外部からアクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="5cadb13ab1a3063435130babe3e0bd30a1122a5f" translate="yes" xml:space="preserve">
          <source>A few points:</source>
          <target state="translated">いくつかのポイント。</target>
        </trans-unit>
        <trans-unit id="a6487d11fc0e1086219982c44902ad61a1998227" translate="yes" xml:space="preserve">
          <source>A method local variable -&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;- is created and then comes the magic in line #6:</source>
          <target state="translated">メソッドローカル変数&lt;em&gt;-anotherReferenceToTheSamePersonObject-&lt;/em&gt;が作成され、マジックが6行目に&lt;em&gt;追加&lt;/em&gt;されます。</target>
        </trans-unit>
        <trans-unit id="939671d12f121c636331468aedcb607655b0467d" translate="yes" xml:space="preserve">
          <source>A new Person Object is created in line #2, stored in memory, and the variable &lt;em&gt;person&lt;/em&gt; is given the reference to the Person object. That is, its address. Let's say 3bad086a.</source>
          <target state="translated">新しいPersonオブジェクトが行＃2で作成され、メモリに格納され、変数&lt;em&gt;person&lt;/em&gt;にPersonオブジェクトへの参照が与えられます。 つまり、そのアドレスです。 3bad086aとしましょう。</target>
        </trans-unit>
        <trans-unit id="6cb5cc922e3e7afc89e697c3a55b40eccd85c7e8" translate="yes" xml:space="preserve">
          <source>A picture is worth a thousand words:</source>
          <target state="translated">百聞は一見に如かず。</target>
        </trans-unit>
        <trans-unit id="7890ee11943cdb236a4c3b5ce7b9f732f716679f" translate="yes" xml:space="preserve">
          <source>A reference is always a value when represented, no matter what language you use.</source>
          <target state="translated">参照は、どのような言語を使用していても、表現されたときには常に値となります。</target>
        </trans-unit>
        <trans-unit id="9f8832ae6457f58e3904c76f8d5c2aa49f842301" translate="yes" xml:space="preserve">
          <source>After: a = 2, b = 3</source>
          <target state="translated">後:a=2、b=3</target>
        </trans-unit>
        <trans-unit id="ec423d5a41945c4f52f7be0ea48ac07e83fd86ae" translate="yes" xml:space="preserve">
          <source>Although an object&amp;rsquo;s reference is passed by value, a method can still interact with the referenced object by calling its public methods using the copy of the object&amp;rsquo;s reference. Since the reference stored in the parameter is a copy of the reference that was passed as an argument, the parameter in the called method and the argument in the calling method refer to the same object in memory.</source>
          <target state="translated">オブジェクトの参照は値で渡されますが、メソッドはオブジェクトの参照のコピーを使用してそのパブリックメソッドを呼び出すことにより、参照されるオブジェクトと対話できます。 パラメータに格納された参照は、引数として渡された参照のコピーであるため、呼び出されたメソッドのパラメータと呼び出しメソッドの引数は、メモリ内の同じオブジェクトを参照します。</target>
        </trans-unit>
        <trans-unit id="b65974e5bb87a60e0a3ebacd86b70b176a71aea4" translate="yes" xml:space="preserve">
          <source>An array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.</source>
          <target state="translated">配列はオブジェクトですから、ヒープ上にも行きます。配列の中のオブジェクトはどうでしょうか?それぞれのオブジェクトのアドレスは配列の中に入ります。</target>
        </trans-unit>
        <trans-unit id="9bf2ce1dceef2dc96a821885bc168afbf5d4d9a1" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;on the subject of pass-by-value&lt;/a&gt;</source>
          <target state="translated">そして&lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;、値渡しの問題について&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="753dfa9513c7de7c01e5a4ee8e20f57993151233" translate="yes" xml:space="preserve">
          <source>And now that reverseArray method is over, its reference variables(array1 and array2) are gone. Which means we now only have the two reference variables in main method array1 and array2 which point to c and b arrays respectively. No reference variable is pointing to object (array) a. So it is eligible for garbage collection.</source>
          <target state="translated">そして、reverseArrayメソッドが終わったので、その参照変数(array1とarray2)がなくなってしまいました。つまり、メインメソッドの array1 と array2 には、それぞれ c と b の配列を指す 2 つの参照変数しかありません。参照変数がオブジェクト(配列)aを指していないので、ガベージコレクションの対象になります。</target>
        </trans-unit>
        <trans-unit id="1427090bc2dee2db920c7dcba2e93785a6f9fced" translate="yes" xml:space="preserve">
          <source>And towards the end of the same section he makes a broader statement about java being only pass by value and never pass by reference.</source>
          <target state="translated">そして、同じセクションの最後の方で、彼はjavaは値でしか渡さず、参照では絶対に渡さないということについて、より広範な声明を出しています。</target>
        </trans-unit>
        <trans-unit id="7ccd274eb97af58443d0d98f31f8165d44df954a" translate="yes" xml:space="preserve">
          <source>Anyway, I noticed a comment by &lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;dhackner&lt;/a&gt; in an older post, who made a balloon analogy which I really liked. So much so that I decided to glue together some clip-art to make a set of cartoons to illustrate the point.</source>
          <target state="translated">とにかく、私は以前の投稿で&lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;dhackner&lt;/a&gt;からのコメントに気づきました。 そのため、私はいくつかのクリップアートを一緒に接着して、ポイントを説明するための漫画のセットを作ることにしました。</target>
        </trans-unit>
        <trans-unit id="7a6f63a9fa8ba00d31fa864a81af348461e2059d" translate="yes" xml:space="preserve">
          <source>As expected output will be:</source>
          <target state="translated">予想通りの出力になります。</target>
        </trans-unit>
        <trans-unit id="9e95da2bd7af315b2113d39a70608c332bc48d91" translate="yes" xml:space="preserve">
          <source>As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:</source>
          <target state="translated">私が知っている限りでは、Javaは値による呼び出ししか知りません。つまり、プリミティブなデータ型の場合はコピーを使用し、オブジェクトの場合はオブジェクトへの参照のコピーを使用することになります。しかし、これにはいくつかの落とし穴があると思います。</target>
        </trans-unit>
        <trans-unit id="d05f320102345bc58ddfdf1478a148fed340e361" translate="yes" xml:space="preserve">
          <source>As many people mentioned it before, &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Java is always pass-by-value&lt;/a&gt;</source>
          <target state="translated">以前に多くの人々が言及したように、 &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Javaは常に値渡しです&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd4f600b4ca0e57b260d865e338eb632ae21d0de" translate="yes" xml:space="preserve">
          <source>As was explained in previous answers, in Java you're passing a pointer to the array as a value into &lt;code&gt;getValues&lt;/code&gt;. That is enough, because the method then modifies the array element, and by convention you're expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn't necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.</source>
          <target state="translated">以前の回答で説明したように、Javaでは配列へのポインターを値として &lt;code&gt;getValues&lt;/code&gt; に渡します。 メソッドは配列要素を変更するため、これで十分です。慣例として、要素0には戻り値が含まれると想定しています。 明らかに、これを他の方法で行うことができます。たとえば、コードを構造化してこれを必要としないようにしたり、戻り値を格納したり、戻り値を設定したりできるクラスを構築したりできます。 ただし、上記のC ++で使用できる単純なパターンはJavaでは使用できません。</target>
        </trans-unit>
        <trans-unit id="8d7366694d78adcdb573e21740168952ff60eb6a" translate="yes" xml:space="preserve">
          <source>As we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is &lt;code&gt;0x100234&lt;/code&gt; (we don't know the actual JVM internal value, this is just an example) .</source>
          <target state="translated">ご存知のように、ヒープ内にオブジェクトを作成し、参照値をtに返します。 たとえば、tの値が &lt;code&gt;0x100234&lt;/code&gt; であるとします（実際のJVM内部値はわかりません。これは単なる例です）。</target>
        </trans-unit>
        <trans-unit id="430da7a13966f26ff5a4c5e2f81b52ff90b0253b" translate="yes" xml:space="preserve">
          <source>As you call &lt;code&gt;modifyReference(Foo c)&lt;/code&gt; method, a reference &lt;code&gt;c&lt;/code&gt; is created and assigned the object with attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modifyReference(Foo c)&lt;/code&gt; メソッドを呼び出すと、参照 &lt;code&gt;c&lt;/code&gt; が作成され、属性 &lt;code&gt;&quot;f&quot;&lt;/code&gt; のオブジェクトが割り当てられます。</target>
        </trans-unit>
        <trans-unit id="fa285e6edfa6d99016592271e8d0555fae43569f" translate="yes" xml:space="preserve">
          <source>As you call the method &lt;code&gt;changeReference&lt;/code&gt;, the reference &lt;code&gt;a&lt;/code&gt; will be assigned the object which is passed as an argument.</source>
          <target state="translated">メソッド &lt;code&gt;changeReference&lt;/code&gt; を呼び出すと、参照 &lt;code&gt;a&lt;/code&gt; には、引数として渡されるオブジェクトが割り当てられます。</target>
        </trans-unit>
        <trans-unit id="108085f3bb0f4209a639200317b9f008aaf21dab" translate="yes" xml:space="preserve">
          <source>Back when I studied compilers-in the 90's, I used the first edition of the book from 1986 which pre-dated Java by about 9 or 10 years. However, I just ran across a copy of the &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;2nd Eddition&lt;/a&gt; from 2007 &lt;strong&gt;which actually mentions Java!&lt;/strong&gt; Section 1.6.6 labeled &quot;Parameter Passing Mechanisms&quot; describes parameter passing pretty nicely. Here is an excerpt under the heading &quot;Call-by-value&quot; which mentions Java:</source>
          <target state="translated">90年代にコンパイラを研究していた頃、私は1986年の本の初版を使用しました。 しかし、 &lt;strong&gt;実際にはJavaについて言及している&lt;/strong&gt; 2007年の&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;第2&lt;/a&gt;版のコピーを見つけました&lt;strong&gt;。&lt;/strong&gt; 「パラメータの受け渡しメカニズム」というラベルの付いたセクション1.6.6は、パラメータの受け渡しについて非常にうまく説明しています。 以下は、Javaについて言及する「値による呼び出し」という見出しの下の抜粋です。</target>
        </trans-unit>
        <trans-unit id="2a5566bd96317aa68aedfcd4ec8973cfbf92a199" translate="yes" xml:space="preserve">
          <source>Basically, reassigning Object parameters doesn't affect the argument, e.g.,</source>
          <target state="translated">基本的にObjectのパラメータを再割り当てしても引数には影響しません。</target>
        </trans-unit>
        <trans-unit id="1b0434b117ced506f4e292880cee2d016b9caf22" translate="yes" xml:space="preserve">
          <source>Before: a = 2, b = 3</source>
          <target state="translated">前:a=2、b=3</target>
        </trans-unit>
        <trans-unit id="687e81922c00310f84049051118a03dc31fabaae" translate="yes" xml:space="preserve">
          <source>Both &quot;&lt;em&gt;person&lt;/em&gt;&quot; and &quot;&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;&quot; hold the same value of 3bad086a.</source>
          <target state="translated">「 &lt;em&gt;person&lt;/em&gt; 」と「 &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; 」はどちらも同じ3bad086aの値を保持しています。</target>
        </trans-unit>
        <trans-unit id="2689caac6d3ec6ddc37d1cac015f4e8ae4e22c88" translate="yes" xml:space="preserve">
          <source>Both variables have IDENTICAL COPIES of the reference and they both refer to the same Person Object, the SAME Object on the Heap and NOT A COPY.</source>
          <target state="translated">どちらの変数も参照の IDENTICAL COPIES を持ち、どちらも同じ Person オブジェクト、ヒープ上の SAME オブジェクトを参照しており、NOT A COPY を参照しています。</target>
        </trans-unit>
        <trans-unit id="e9170e035719274989ed5cf55b194f253b0ee3eb" translate="yes" xml:space="preserve">
          <source>But from this example, we can understand that it is infact pass by value only,
  keeping in mind that here we are passing the reference as the value.
  ie: reference is passed by value.
  That's why are able to change and still it holds true after the local scope.
  But we cannot change the actual reference outside the original scope.
  what that means is demonstrated by next example of PassByValueObjectCase2.</source>
          <target state="translated">しかし、この例からは、ここでは参照を値として渡していることを念頭に置いて、実際には値のみで渡されていることが理解できます。つまり、参照は値で渡されているのです。これが何を意味するかは、次の PassByValueObjectCase2 の例で示されています。</target>
        </trans-unit>
        <trans-unit id="006ecf4b1a9cc9edb60404b2fb553d2bccdff314" translate="yes" xml:space="preserve">
          <source>C++ pass by reference example:</source>
          <target state="translated">参照例によるC++のパス。</target>
        </trans-unit>
        <trans-unit id="83514ce69e30402f75b91daf4e42e15d62db4d49" translate="yes" xml:space="preserve">
          <source>Check the comment on line #5</source>
          <target state="translated">5行目のコメントをチェック</target>
        </trans-unit>
        <trans-unit id="ce636731102296dcc967f8d443bba701fa39128c" translate="yes" xml:space="preserve">
          <source>Crash course on stack/heap before we get to the Java implementation:
Values go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria.
Memory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.</source>
          <target state="translated">Javaの実装に入る前に、スタックヒープのクラッシュコースです。カフェテリアの皿のスタックのように、値は整然とスタックの上に乗ったり降りたりします。ヒープ内のメモリ(ダイナミックメモリとしても知られています)は、行き当たりばったりで無秩序です。JVMは可能な限りスペースを見つけ、それを使用する変数が不要になると、それを解放します。</target>
        </trans-unit>
        <trans-unit id="9a4330ec3ed061c85b3e0b082e1656ec35e5d3df" translate="yes" xml:space="preserve">
          <source>Creates new Point object</source>
          <target state="translated">新しい Point オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="1926dd5e7c03bbf781269e3b1f10a918298da01a" translate="yes" xml:space="preserve">
          <source>Creates new Point reference and initialize that reference to &lt;em&gt;point (refer to)&lt;/em&gt; on previously created Point object.</source>
          <target state="translated">新しいPoint参照を作成し、その参照を以前に作成したPointオブジェクトの&lt;em&gt;ポイント（参照）&lt;/em&gt;に初期化します。</target>
        </trans-unit>
        <trans-unit id="91a5cb67c9d537c081e9f8cf1bbc2d3e758ce171" translate="yes" xml:space="preserve">
          <source>Creating two different Point object with two different reference associated.</source>
          <target state="translated">2つの異なる参照を関連付けた2つの異なるPointオブジェクトの作成</target>
        </trans-unit>
        <trans-unit id="b0dda1bfba52f041403c7023d96d1d341ad3c077" translate="yes" xml:space="preserve">
          <source>Data in memory has a &lt;strong&gt;Location&lt;/strong&gt; and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a &lt;strong&gt;Name&lt;/strong&gt; to certain &lt;strong&gt;Location&lt;/strong&gt; (aka variable), but when compiling the code, the assembler simply replaces &lt;strong&gt;Name&lt;/strong&gt; with the designated location just like your browser replaces domain names with IP addresses.</source>
          <target state="translated">メモリ内のデータには&lt;strong&gt;場所が&lt;/strong&gt;あり、その場所には値（バイト、ワードなど）があります。 アセンブリでは、特定の&lt;strong&gt;場所&lt;/strong&gt; （別名変数）に&lt;strong&gt;名前&lt;/strong&gt;を付ける便利なソリューションがありますが、コードをコンパイルするとき、ブラウザがドメイン名をIPアドレスに置き換えるのと同じように、アセンブラは&lt;strong&gt;名前&lt;/strong&gt;を指定された場所に置き換えるだけです。</target>
        </trans-unit>
        <trans-unit id="bfb16cd1cd030c8e69601029c768549e17aa7047" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;Foo&lt;/code&gt; の &lt;code&gt;b&lt;/code&gt; という名前の参照を宣言し、それに属性 &lt;code&gt;&quot;b&quot;&lt;/code&gt; を持つタイプ &lt;code&gt;Foo&lt;/code&gt; の新しいオブジェクトを割り当てます。</target>
        </trans-unit>
        <trans-unit id="0bb0f2661240daa3e654c2b942a4228aef7a6a44" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 型の &lt;code&gt;f&lt;/code&gt; という名前の参照を宣言し、それに属性 &lt;code&gt;&quot;f&quot;&lt;/code&gt; を持つ &lt;code&gt;Foo&lt;/code&gt; 型の新しいオブジェクトを割り当てます。</target>
        </trans-unit>
        <trans-unit id="cd9950fdb8d7858353a3702108602c9648dd0e68" translate="yes" xml:space="preserve">
          <source>Does this sound strange and confusing? Let's consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. &lt;code&gt;void foo(int x)&lt;/code&gt; passes an int by value. &lt;code&gt;void foo(int *x)&lt;/code&gt; is a function that does not want an &lt;code&gt;int a&lt;/code&gt;, but a pointer to an int: &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt;. One would use this with the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to pass a variable address.</source>
          <target state="translated">これは奇妙で混乱しているように聞こえますか？ Cが参照渡しと値渡しをどのように実装するかを考えてみましょう。 Cでは、デフォルトの規則は値渡しです。 &lt;code&gt;void foo(int x)&lt;/code&gt; は、intを値で渡します。 &lt;code&gt;void foo(int *x)&lt;/code&gt; は、 &lt;code&gt;int a&lt;/code&gt; を必要としない関数ですが、 intへのポインター： &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt; です。 これを &lt;code&gt;&amp;amp;&lt;/code&gt; 演算子と共に使用して、変数アドレスを渡します。</target>
        </trans-unit>
        <trans-unit id="b5854bdd57360320e24b9397418a212d3b8b3fc1" translate="yes" xml:space="preserve">
          <source>Don't try this but person==anotherReferenceToTheSamePersonObject would be true.</source>
          <target state="translated">これを試してはいけませんが、person==anotherReferenceToTheSamePersonObjectは真になります。</target>
        </trans-unit>
        <trans-unit id="207ba28fc5d0fc3ff8e2b02914c001bb5bb368b5" translate="yes" xml:space="preserve">
          <source>Down to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).</source>
          <target state="translated">核心に迫ると、どんな言語でも、それを表現せずに何かへの参照を渡すことは技術的に不可能です(すぐに値になる場合)。</target>
        </trans-unit>
        <trans-unit id="438f74e42d1fb68f2c51553f32173992bba966c9" translate="yes" xml:space="preserve">
          <source>First of all, we need to understand what pass by value and pass by reference are.</source>
          <target state="translated">まず、値によるパスと参照によるパスとは何かを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="9e5aff39fe5953d4740386d14bbfaa42a906a8b9" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;What's the difference between passing by reference vs. passing by value?&lt;/a&gt;</source>
          <target state="translated">まず、 &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;参照渡しと値渡しの違いは何ですか？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e0065a83f42a57a3911225215a70e9b907a2bbc" translate="yes" xml:space="preserve">
          <source>Flow of the program:</source>
          <target state="translated">プログラムの流れ。</target>
        </trans-unit>
        <trans-unit id="0dfdb0b2fd7037984e97ec60ea513d8d5b9e3dd0" translate="yes" xml:space="preserve">
          <source>For objects, the pass by value is the value of &lt;em&gt;the reference to the object&lt;/em&gt;.</source>
          <target state="translated">オブジェクトの場合、値渡し&lt;em&gt;はオブジェクトへの参照&lt;/em&gt;の値です。</target>
        </trans-unit>
        <trans-unit id="5c00717c1eeb06ca14fc62309936f50e756db581" translate="yes" xml:space="preserve">
          <source>For primitive arguments (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, etc.), the pass by value is &lt;em&gt;the actual value&lt;/em&gt; of the primitive (for example, 3).</source>
          <target state="translated">プリミティブ引数（ &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; など）の場合、値渡しはプリミティブの&lt;em&gt;実際の値&lt;/em&gt;です（たとえば、3）。</target>
        </trans-unit>
        <trans-unit id="d717d5e3b868b30355b36493393d4dedba688590" translate="yes" xml:space="preserve">
          <source>From here scope of &lt;code&gt;tricky&lt;/code&gt; method is gone and you don't have access any more to the references: &lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;temp&lt;/code&gt;. &lt;strong&gt;But important note is that everything you do with these references when they are 'in life' will permanently affect object on which they are &lt;em&gt;point&lt;/em&gt; to.&lt;/strong&gt;</source>
          <target state="translated">ここから、 &lt;code&gt;tricky&lt;/code&gt; メソッドのスコープがなくなり、参照（ &lt;code&gt;arg1&lt;/code&gt; 、 &lt;code&gt;arg2&lt;/code&gt; 、 &lt;code&gt;temp&lt;/code&gt; )にアクセスできなくなります。 &lt;strong&gt;ただし、重要な注意点は、これらの参照が「存続」しているときにこれらの参照で行うすべてのことは、参照先のオブジェクトに永続的に影響を与えることです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ee364d2560bc79a19a4c72624692c7755f4443f" translate="yes" xml:space="preserve">
          <source>From here, through Point object life, you will access to that object through pnt1
 reference. So we can say that in Java you manipulate object through its reference.</source>
          <target state="translated">ここからPointのオブジェクトライフを通して、そのオブジェクトにpnt1の参照を通してアクセスすることになります。つまり、Javaでは、その参照を介してオブジェクトを操作することになります。</target>
        </trans-unit>
        <trans-unit id="2c8076e66b55ab8aeac61f85404367064fccd996" translate="yes" xml:space="preserve">
          <source>From the method side, a reference of type &lt;code&gt;Foo&lt;/code&gt; with a name &lt;code&gt;a&lt;/code&gt; is declared and it's initially assigned &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">メソッド側から、名前が &lt;code&gt;a&lt;/code&gt; の &lt;code&gt;Foo&lt;/code&gt; 型の参照が宣言され、最初に &lt;code&gt;null&lt;/code&gt; が割り当てられます 。</target>
        </trans-unit>
        <trans-unit id="7fb62bec2c3a15680c7c08a655906f2b1d75ef3f" translate="yes" xml:space="preserve">
          <source>Getting an outside of the box view, let's look at Assembly or some low level memory management. At the CPU level a &lt;em&gt;reference&lt;/em&gt; to anything immediately becomes a &lt;em&gt;value&lt;/em&gt; if it gets written to memory or to one of the CPU registers. (That is why &lt;em&gt;pointer&lt;/em&gt; is a good definition. It is a value, which has a purpose at the same time).</source>
          <target state="translated">ボックスビューの外に出て、アセンブリまたはいくつかの低レベルのメモリ管理を見てみましょう。 CPUレベルでは、メモリまたはCPUレジスタの1つに書き込まれると、何かへの&lt;em&gt;参照&lt;/em&gt;はすぐに&lt;em&gt;値&lt;/em&gt;になり&lt;em&gt;ます&lt;/em&gt; 。 （それが&lt;em&gt;ポインター&lt;/em&gt;が適切な定義である理由です。それは同時に目的を持つ値です）。</target>
        </trans-unit>
        <trans-unit id="a09f4f73a25672b2d71176498d77cdaf4f9d5f33" translate="yes" xml:space="preserve">
          <source>He goes on to make the same point regarding objects . . .</source>
          <target state="translated">彼は物体についても同じことを言い続けている.</target>
        </trans-unit>
        <trans-unit id="dcab7f73c798d9959b167db93301f1b793cb10fc" translate="yes" xml:space="preserve">
          <source>Here is another example that will help you understand the difference (&lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;the classic swap example&lt;/a&gt;):</source>
          <target state="translated">違いを理解するのに役立つ別の例を次に示します（ &lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;クラシックスワップの例&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="095229be47d5e504de9b8c6e3f105270472a7db4" translate="yes" xml:space="preserve">
          <source>Here, you first create new &lt;code&gt;temp&lt;/code&gt; Point reference which will &lt;em&gt;point&lt;/em&gt; on same place like &lt;code&gt;arg1&lt;/code&gt; reference. Then you move reference &lt;code&gt;arg1&lt;/code&gt; to &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;arg2&lt;/code&gt; reference.
Finally &lt;code&gt;arg2&lt;/code&gt; will &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">ここでは、最初に、 &lt;code&gt;arg1&lt;/code&gt; 参照のように同じ場所を&lt;em&gt;指す&lt;/em&gt;新しい &lt;code&gt;temp&lt;/code&gt; ポイント参照を作成します。 次に、参照 &lt;code&gt;arg1&lt;/code&gt; を移動して、 &lt;code&gt;arg2&lt;/code&gt; 参照と同じ場所を&lt;em&gt;指し示し&lt;/em&gt;ます。 最後に、 &lt;code&gt;arg2&lt;/code&gt; は &lt;code&gt;temp&lt;/code&gt; と同じ場所を&lt;em&gt;指し&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="64169e4a61bae86f469a92b3cfc4bae9c3a53858" translate="yes" xml:space="preserve">
          <source>Hopefully this will help.</source>
          <target state="translated">願わくば、これが役に立つことを願っています。</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">どのように動作するか</target>
        </trans-unit>
        <trans-unit id="e5beaeff3bbae8257639b2987a7f67bd9d85c384" translate="yes" xml:space="preserve">
          <source>However you could make a wrapper for String like this which would make it able to use it with Strings:</source>
          <target state="translated">しかし、このようにStringのラッパーを作ることで、Stringと一緒に使えるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="26dd9ac7a210ba6a96d874cf5c6e8374ed5dbcf2" translate="yes" xml:space="preserve">
          <source>However, I've seen a couple of blog posts (for example, &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this blog&lt;/a&gt;) that claim that it isn't.</source>
          <target state="translated">ただし、そうではないと主張するいくつかのブログ投稿（たとえば、 &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;このブログ&lt;/a&gt; ）を目にしました。</target>
        </trans-unit>
        <trans-unit id="ec1be69fa319cc52b285a8bee8c6a7f04ee9e1f8" translate="yes" xml:space="preserve">
          <source>I always think of it as &quot;pass by copy&quot;. It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.</source>
          <target state="translated">私はいつも「パス・バイ・コピー」と考えています。プリミティブでもリファレンスでも、値のコピーです。プリミティブの場合は値のビットのコピーであり、オブジェクトの場合は参照のコピーです。</target>
        </trans-unit>
        <trans-unit id="69f13178ffc91e81d12909e0fab0a089bbad804f" translate="yes" xml:space="preserve">
          <source>I always thought Java was &lt;strong&gt;pass-by-reference&lt;/strong&gt;.</source>
          <target state="translated">Javaは&lt;strong&gt;参照渡しである&lt;/strong&gt;といつも思っていました。</target>
        </trans-unit>
        <trans-unit id="efd75827ae1611bf4e22af1ec1d50ca7541b3557" translate="yes" xml:space="preserve">
          <source>I can't believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term &lt;em&gt;call by sharing&lt;/em&gt; (also known as &lt;em&gt;call by object-sharing&lt;/em&gt; and &lt;em&gt;call by object&lt;/em&gt;) for this specific case of &quot;call by value where the value is a reference&quot;.</source>
          <target state="translated">まだ誰もバーバラ・リスコフについて言及していないとは信じられません。 1974年にCLUを設計したとき、彼女はこれと同じ用語の問題に遭遇し、「値による呼び出しによる値による呼び出し」というこの特定のケースについて&lt;em&gt;、&lt;/em&gt; &lt;em&gt;共有による呼び出し（オブジェクト共有&lt;/em&gt; &lt;em&gt;による呼び出し&lt;/em&gt;および&lt;em&gt;オブジェクトによる呼び出しと&lt;/em&gt;も呼ばれる）を発明しました。参照」。</target>
        </trans-unit>
        <trans-unit id="aeaec84d031aa5cb38d5557cf7de3f76bf7cafb0" translate="yes" xml:space="preserve">
          <source>I don't think I understand the distinction they're making.</source>
          <target state="translated">彼らが言っている区別が理解できていないと思う。</target>
        </trans-unit>
        <trans-unit id="d5405762999d453eb212ccf6bcc5f6125f900230" translate="yes" xml:space="preserve">
          <source>I feel like arguing about &quot;pass-by-reference vs pass-by-value&quot; is not super-helpful.</source>
          <target state="translated">パス・バイ・リファレンス vs パス・バイ・バリュー」の議論は超参考にならないような気がします。</target>
        </trans-unit>
        <trans-unit id="da328c30116bfb1c498c3407693d22ba90f3115c" translate="yes" xml:space="preserve">
          <source>I have created a thread devoted to these kind of questions for &lt;em&gt;any&lt;/em&gt; programming languages &lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;ここで&lt;/a&gt;は&lt;em&gt;、&lt;/em&gt;プログラミング言語に関するこの種の質問に特化したスレッドを作成しました。</target>
        </trans-unit>
        <trans-unit id="be8f8168e2402a238a9976383c81f993f3a3e74e" translate="yes" xml:space="preserve">
          <source>I have seen posts on this topic which describe the low level implementation of parameter passing in Java, which I think is great and very helpful because it makes an abstract idea concrete. However, to me the question is more about &lt;strong&gt;the behavior described in the language specification&lt;/strong&gt; than about the technical implementation of the behavior. This is an exerpt from the &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification, section 8.4.1&lt;/a&gt; :</source>
          <target state="translated">Javaでのパラメーターの受け渡しの低レベルの実装について説明しているこのトピックに関する投稿を見てきました。これは、抽象的なアイデアを具体化するため、非常に役立ち、非常に役立ちます。 しかし、私にとっての問題は&lt;strong&gt;、動作&lt;/strong&gt;の技術的な実装についてではなく&lt;strong&gt;、言語仕様に記述されている動作について&lt;/strong&gt;です。 これは、 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java言語仕様のセクション8.4.1&lt;/a&gt;からの抜粋です。</target>
        </trans-unit>
        <trans-unit id="cb7305997ab86247b2a49056cbf4e89230b9f222" translate="yes" xml:space="preserve">
          <source>I hope this settles the debate, but probably won't.</source>
          <target state="translated">これで議論が決着するといいが、おそらく決着しないだろう。</target>
        </trans-unit>
        <trans-unit id="d415e610e2056093f16e0b12b5086931ca855762" translate="yes" xml:space="preserve">
          <source>I hope you understand now how passing objects as arguments works in Java :)</source>
          <target state="translated">オブジェクトを引数として渡すことがJavaでどのように動作するか理解していただけたと思います :)</target>
        </trans-unit>
        <trans-unit id="53b25f35c0f07624c3ab774845793894e9df085c" translate="yes" xml:space="preserve">
          <source>I just noticed you referenced &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;my article&lt;/a&gt;.</source>
          <target state="translated">あなたが&lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;私の記事&lt;/a&gt;を参照していることに気づきました。</target>
        </trans-unit>
        <trans-unit id="2935658c6ca5dd052a7a1348a0e9a0f71fe8584b" translate="yes" xml:space="preserve">
          <source>I might be a little obsessed with this post. Probably because I feel that the makers of Java inadvertently spread misinformation. If instead of using the word &quot;reference&quot; for pointers they had used something else, say 
dingleberry, there would've been no problem. You could say, &quot;Java passes dingleberries by value and not by reference&quot;, and nobody would be confused. (Hence forth, when referencing pass by reference vs value, I shall refer to references as dinglebarries.)</source>
          <target state="translated">私はこの投稿に少し執着しているのかもしれません。おそらく、Javaのメーカーがうっかり誤報を広めてしまったような気がするからです。もし、ポインタに &quot;参照 &quot;という言葉を使わずに、他の何か、例えばディングルベリーという言葉を使っていれば、何の問題もなかったでしょう。Javaはdingleberryを参照ではなく値で渡す」と言えば、誰も混乱しなかったでしょう。(以降、参照によるパスと値によるパスを比較する際には、参照をディングルベリーと呼ぶことにします)。</target>
        </trans-unit>
        <trans-unit id="dbf80c5168a8cdece318ecb980f6dc4582312bc0" translate="yes" xml:space="preserve">
          <source>I think the difference between the two models is very subtle and unless you've done programming where you actually used pass-by-reference, it's easy to miss where two models differ.</source>
          <target state="translated">2つのモデルの違いは非常に微妙で、実際にパスバイレファレンスを使ったプログラミングをしたことがない限り、2つのモデルの違いがどこにあるのか見落としがちだと思います。</target>
        </trans-unit>
        <trans-unit id="051719f18cca69c8321cf2db575cbe7c3c8fc918" translate="yes" xml:space="preserve">
          <source>I thought I'd contribute this answer to add more details from the Specifications.</source>
          <target state="translated">仕様書から詳細を追加するために、この回答を投稿しようと思いました。</target>
        </trans-unit>
        <trans-unit id="02668452fdc578abe59e37b1d267b95f2c167d43" translate="yes" xml:space="preserve">
          <source>I will explain this in steps:</source>
          <target state="translated">順を追って説明していきます。</target>
        </trans-unit>
        <trans-unit id="7e24c4c25b98f1916d4e52df7af6eeb891b2b203" translate="yes" xml:space="preserve">
          <source>If Java had pass-by-reference semantics, the &lt;code&gt;foo&lt;/code&gt; method we defined above would have changed where &lt;code&gt;myDog&lt;/code&gt; was pointing when it assigned &lt;code&gt;someDog&lt;/code&gt; on line BBB.</source>
          <target state="translated">Javaに参照渡しのセマンティクスがあった場合、上で定義した &lt;code&gt;foo&lt;/code&gt; メソッドは、 &lt;code&gt;myDog&lt;/code&gt; がBBB行に &lt;code&gt;someDog&lt;/code&gt; を割り当てたときにポイントしていた場所を変更することになります。</target>
        </trans-unit>
        <trans-unit id="6697d56d6fde5f640c216d07a963f93b03bd1f54" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits contain the value of the primitive data type itself, That's why if we change the value of header inside the method then it does not reflect the changes outside.</source>
          <target state="translated">プリミティブデータ型の場合、これらのビットにはプリミティブデータ型自体の値が含まれていますので、メソッド内でヘッダの値を変更しても、外部での変更は反映されません。</target>
        </trans-unit>
        <trans-unit id="79742ec00dad7a7b993ddfde20c405582b74811d" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits will contain the value of the primitive data type itself.</source>
          <target state="translated">プリミティブデータ型の場合、これらのビットにはプリミティブデータ型自体の値が格納されます。</target>
        </trans-unit>
        <trans-unit id="f0283f6b09b05e1b1e2ef39baf027825432d4169" translate="yes" xml:space="preserve">
          <source>If it's an Object the bits will contain the value of the address that tells the JVM how to get to the Object.</source>
          <target state="translated">それがオブジェクトである場合、ビットには、オブジェクトへのアクセス方法をJVMに伝えるアドレスの値が含まれます。</target>
        </trans-unit>
        <trans-unit id="8a2c1b22c98b47861f2f787055fd5f2fa95e5b32" translate="yes" xml:space="preserve">
          <source>If it's an object data type like &lt;strong&gt;Foo foo=new Foo()&lt;/strong&gt; then in this case copy of the address of the object passes like file shortcut  , suppose we have a text file &lt;strong&gt;abc.txt&lt;/strong&gt; at &lt;strong&gt;C:\desktop&lt;/strong&gt; and suppose we make shortcut of the same file and put this inside &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; so when you access the file from &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; and write &lt;strong&gt;'Stack Overflow'&lt;/strong&gt; and close the file and again you open the file from shortcut then you write &lt;strong&gt;' is the largest online community for programmers to learn'&lt;/strong&gt; then total file change will be &lt;strong&gt;'Stack Overflow is the largest online community for programmers to learn'&lt;/strong&gt; which means it doesn't matter from where you open the file , each time we were accessing the same file , here we can assume &lt;strong&gt;Foo&lt;/strong&gt; as a file and suppose foo stored at &lt;strong&gt;123hd7h&lt;/strong&gt;(original address like &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; ) address and &lt;strong&gt;234jdid&lt;/strong&gt;(copied address like &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; which actually contains the original address of the file inside) ..
So for better understanding make shortcut file and feel..</source>
          <target state="translated">それが&lt;strong&gt;Foo foo = new Foo（）の&lt;/strong&gt;ようなオブジェクトデータタイプの場合、この場合、オブジェクトのアドレスのコピーはfile shortcutのように渡されます&lt;strong&gt;。C：\ desktopに&lt;/strong&gt;テキストファイル&lt;strong&gt;abc.txt&lt;/strong&gt;があり、次のショートカットを作成するとします。同じファイルを&lt;strong&gt;C：\ desktop \ abc-shortcut内に&lt;/strong&gt;配置して、 &lt;strong&gt;C：\ desktop \ abc.txt&lt;/strong&gt;からファイルにアクセスし、 &lt;strong&gt;「Stack Overflow」&lt;/strong&gt;と書き込んでファイルを閉じ、もう一度ショートカットからファイルを開くと、次のようになります。 &lt;strong&gt;「プログラマーが学習する最大のオンラインコミュニティーである」と&lt;/strong&gt;書く&lt;strong&gt;と、&lt;/strong&gt;ファイルの変更の合計&lt;strong&gt;は「Stack Overflowがプログラマーが学習する最大のオンラインコミュニティー」&lt;/strong&gt;となります。つまり、アクセスするたびに、ファイルをどこから開いてもかまいません。同じファイル、ここでは&lt;strong&gt;Foo&lt;/strong&gt;をファイルと想定して、fooが&lt;strong&gt;123hd7h&lt;/strong&gt; （ &lt;strong&gt;C：\ desktop \ abc.txtの&lt;/strong&gt;ような元のアドレス）のアドレスと&lt;strong&gt;234jdid&lt;/strong&gt; （ &lt;strong&gt;C：\ desktop \ abc-shortcutの&lt;/strong&gt;ようなコピーされたアドレスに実際に含まれている）に格納されているとします。内部のファイルの元のアドレス）..理解を深めるために、ショートカットファイルを作成して感じてください。</target>
        </trans-unit>
        <trans-unit id="d09449cf7c49c0bb34af69bedb5138b6a6cf6571" translate="yes" xml:space="preserve">
          <source>If we pass the value of array1 reference variable as an argument to the reverseArray method, a reference variable is created in the method and that reference variable starts pointing to the same array (a).</source>
          <target state="translated">reverseArrayメソッドの引数にarray1の参照変数の値を渡すと、メソッド内に参照変数が作成され、その参照変数は同じ配列(a)を指し始めます。</target>
        </trans-unit>
        <trans-unit id="111cce0df4d6a3eea4ae694172e96a48fec02a36" translate="yes" xml:space="preserve">
          <source>If we return value of reference variable array2 as the return value of method reverseArray and assign this value to reference variable array1 in main method, array1 in main will start pointing to array c.</source>
          <target state="translated">reverseArrayメソッドの戻り値として参照変数array2の値を返し、この値をmainメソッド内の参照変数array1に代入すると、main内のarray1は配列cを指し始めることになります。</target>
        </trans-unit>
        <trans-unit id="cdd0e1a5c0a10b05b85a4f05bf0c8857fb0dc54a" translate="yes" xml:space="preserve">
          <source>If we want to call a method/function/procedure with Foo's value, there are a few possible way to pass the variable to the method, depending on the &lt;strong&gt;language&lt;/strong&gt; and its several method invocation modes:</source>
          <target state="translated">Fooの値を使用してメソッド/関数/プロシージャを呼び出す場合、 &lt;strong&gt;言語&lt;/strong&gt;とそのいくつかのメソッド呼び出しモードに応じて、変数をメソッドに渡す方法がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="ae7787cfc8ddd2039110866a573a0e2714e49edb" translate="yes" xml:space="preserve">
          <source>If you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output &lt;code&gt;changevalue&lt;/code&gt;,   which is updated in the function.</source>
          <target state="translated">リファレンスfを使用して関数の何かを変更すると、オブジェクトの既存の内容が変更されます。 そのため、関数で更新される出力 &lt;code&gt;changevalue&lt;/code&gt; を取得しました。</target>
        </trans-unit>
        <trans-unit id="fe4914949893eeb60b019dffcc6cea87be8dcc83" translate="yes" xml:space="preserve">
          <source>If you didn't get it then just trust me and remember that it's better to say that &lt;strong&gt;Java is pass by value&lt;/strong&gt;. Well, &lt;strong&gt;pass by reference value&lt;/strong&gt;. Oh well, even better is &lt;strong&gt;&lt;em&gt;pass-by-copy-of-the-variable-value! ;)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">うまくいかなかった場合は、私を信頼して、 &lt;strong&gt;Javaは値渡しである&lt;/strong&gt;と言ったほうがよいことを思い出してください。 さて、 &lt;strong&gt;参照値&lt;/strong&gt;で&lt;strong&gt;渡します&lt;/strong&gt; 。 まあ、 &lt;strong&gt;&lt;em&gt;変数値のコピーによる受け渡し&lt;/em&gt;&lt;/strong&gt;はさらに優れてい&lt;strong&gt;&lt;em&gt;ます！&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;;）&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d76bdbeace9817e06089a031711671ab9b1f87b3" translate="yes" xml:space="preserve">
          <source>If you say, &quot;Java is pass-by-whatever (reference/value)&quot;, in either case, you're not provide a complete answer. Here's some additional information that will hopefully aid in understanding what's happening in memory.</source>
          <target state="translated">もし、「Javaはパス・バイ・ワッチェバー(参照値)」と言うならば、どちらの場合も完全な答えを提供していないことになります。ここでは、メモリで何が起こっているのかを理解するのに役立つ情報をいくつか追加しておきます。</target>
        </trans-unit>
        <trans-unit id="2864474958a88d28e0e852e593201018ce309c3a" translate="yes" xml:space="preserve">
          <source>In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.</source>
          <target state="translated">C++やAda、Pascalなどの参照渡しをサポートする言語では、実際に渡された変数を変更することができます。</target>
        </trans-unit>
        <trans-unit id="cd1ab35d296b25bfeeda42a17c0845735976d063" translate="yes" xml:space="preserve">
          <source>In C++: &lt;strong&gt;Note: Bad code - memory leaks!&lt;/strong&gt;  But it demonstrates the point.</source>
          <target state="translated">C ++の場合： &lt;strong&gt;注：不正なコード-メモリリーク！&lt;/strong&gt; しかし、それは要点を示しています。</target>
        </trans-unit>
        <trans-unit id="70a7832950563eb1e68d730cfc8633aecba50e12" translate="yes" xml:space="preserve">
          <source>In Java,</source>
          <target state="translated">Javaでは。</target>
        </trans-unit>
        <trans-unit id="ee32c40f3e465ae5371086558cba52983a8a32d8" translate="yes" xml:space="preserve">
          <source>In Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.</source>
          <target state="translated">Javaでは、すべてのパラメータは値で渡されます。つまり、メソッドの引数を代入することは呼び出し元からは見えません。</target>
        </trans-unit>
        <trans-unit id="ea4a661eaa255681fb44e9a0ceb260d8c9521fd5" translate="yes" xml:space="preserve">
          <source>In Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. &lt;strong&gt;Modifying the object referenced by the variable is a different concept entirely.&lt;/strong&gt;</source>
          <target state="translated">Javaでは、変数を変更することは、変数を再割り当てすることを意味します。 Javaでは、メソッド内で変数を再割り当てした場合、呼び出し元に気付かれません。 &lt;strong&gt;変数が参照するオブジェクトの変更は、まったく別の概念です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ec57628bd6a19cc372e0d82956fbc9926fe31cc" translate="yes" xml:space="preserve">
          <source>In addition to what was mentioned in Example3 (PassByValueObjectCase1.java),  we cannot change the actual reference outside the original scope.&quot;</source>
          <target state="translated">例3(PassByValueObjectCase1.java)で述べたことに加えて、実際の参照を元のスコープ外で変更することはできません。&quot;</target>
        </trans-unit>
        <trans-unit id="bf42410ba453a42ec3533408e27e6dbcc281e995" translate="yes" xml:space="preserve">
          <source>In call-by-reference evaluation (also referred to as
  pass-by-reference), a function receives an implicit reference to a
  variable used as argument, rather than a copy of its value. This
  typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">参照渡しの評価（参照渡しとも呼ばれる）では、関数は、値のコピーではなく、引数として使用される変数への暗黙的な参照を受け取ります。 これは通常、関数が引数として使用される変数（呼び出し元から見えるもの）を変更（つまり、割り当て）できることを意味します。</target>
        </trans-unit>
        <trans-unit id="8b7b4cb1ed7c07a761b7c04a976a8f1ba04382e4" translate="yes" xml:space="preserve">
          <source>In call-by-value, the actual parameter is evaluated (if it is an
  expression) or copied (if it is a variable). The value is placed in
  the location belonging to the corresponding formal parameter of the
  called procedure. &lt;strong&gt;This method is used in C and Java, and is a common
  option in C++ , as well as in most other languages.&lt;/strong&gt;</source>
          <target state="translated">値による呼び出しでは、実際のパラメーターが評価されるか（式の場合）、またはコピーされます（変数の場合）。 値は、呼び出されたプロシージャの対応する仮パラメーターに属する場所に配置されます。 &lt;strong&gt;このメソッドはCおよびJavaで使用され、C ++や他のほとんどの言語で一般的なオプションです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80cff4aaaefaebbc2f88f5d26ae6ac275dc4f40b" translate="yes" xml:space="preserve">
          <source>In call-by-value, the argument expression is evaluated, and the
  resulting value is bound to the corresponding variable in the function [...]. 
  If the function or procedure is able to assign values to its
  parameters, only its local copy is assigned [...].</source>
          <target state="translated">call-by-valueでは、引数式が評価され、結果の値は関数内の対応する変数にバインドされます[...]。関数やプロシージャがパラメータに値を代入できる場合、そのローカルコピーだけが代入されます[...]。</target>
        </trans-unit>
        <trans-unit id="bd4f5299b140615753485c299e8a2e77b0c5997f" translate="yes" xml:space="preserve">
          <source>In case of Objects, this is the same: 
Object variables are pointers (buckets) holding only Object&amp;rsquo;s &lt;strong&gt;address&lt;/strong&gt; that was created using the &quot;new&quot; keyword, and are copied like primitive types.</source>
          <target state="translated">オブジェクトの場合も同様です。オブジェクト変数は、「new」キーワードを使用して作成されたオブジェクトの&lt;strong&gt;アドレス&lt;/strong&gt;のみを保持するポインター（バケット）であり、プリミティブ型のようにコピーされます。</target>
        </trans-unit>
        <trans-unit id="fc3d33069def51ed42a9766ed121449803b82259" translate="yes" xml:space="preserve">
          <source>In effect, using a method, you will never be able, to update the value of a String passed as argument:</source>
          <target state="translated">事実上、メソッドを使用して、引数として渡された文字列の値を更新することはできません。</target>
        </trans-unit>
        <trans-unit id="80da013ae7fbb0cb942c6b9e18118975ac88e298" translate="yes" xml:space="preserve">
          <source>In every cases above a value - a &lt;strong&gt;copy&lt;/strong&gt; of an existing value - has been created, it is now upto the receiving method to handle it. When you write &quot;Foo&quot; inside the method, it is either read out from EAX, or automatically  &lt;strong&gt;dereferenced&lt;/strong&gt;, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a &lt;em&gt;reference&lt;/em&gt; is a &lt;em&gt;value&lt;/em&gt; when represented, because a reference is a value that has to be processed (at language level).</source>
          <target state="translated">いずれの場合も、値-既存の値の&lt;strong&gt;コピー&lt;/strong&gt; -が作成され、それを処理するのは受信側のメソッドです。 メソッド内で &quot;Foo&quot;を書き込むと、EAXから読み取られるか、自動的に&lt;strong&gt;逆参照される&lt;/strong&gt;か、二重逆参照されます。プロセスは、言語の動作方法やFooのタイプによって決まります。 これは、逆参照プロセスを回避するまで、開発者から隠されています。 つまり、 &lt;em&gt;参照&lt;/em&gt;は（言語レベルで）処理する必要がある値であるため、参照は表現されたときの値です。</target>
        </trans-unit>
        <trans-unit id="58d4de45900cd3a103d99c18d12234d5bb3d377d" translate="yes" xml:space="preserve">
          <source>In general, Java has primitive types (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, etc) that are passed directly by value. Then Java has objects (everything that derives from &lt;code&gt;java.lang.Object&lt;/code&gt;). Objects are actually always handled through a reference (a reference being a pointer that you can't touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.</source>
          <target state="translated">一般に、Javaには、 &lt;code&gt;bool&lt;/code&gt; によって直接渡されるプリミティブ型（ &lt;code&gt;int&lt;/code&gt; 、 bool 、 &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; など）があります。 その場合、Javaにはオブジェクト（ &lt;code&gt;java.lang.Object&lt;/code&gt; から派生するすべてのもの）があります。 オブジェクトは、実際には常に参照（参照できないポインタ）を通じて処理されます。 つまり、参照は通常は対象外なので、実際にはオブジェクトは参照によって渡されます。 ただし、参照自体が値で渡されるため、どのオブジェクトがポイントされているかを変更することはできません。</target>
        </trans-unit>
        <trans-unit id="45cfc45c3c6f01b610517a50ecd3388655190ac5" translate="yes" xml:space="preserve">
          <source>In java everything is reference, so when you have something like:
    &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; Java does following:</source>
          <target state="translated">Javaではすべてが参照であるため、次のような場合： &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; Javaは次のことを行います。</target>
        </trans-unit>
        <trans-unit id="b73ac48cac4cc50104187760bd5de00365a5e1fd" translate="yes" xml:space="preserve">
          <source>In line #4 you can listen to the sound of silence</source>
          <target state="translated">4行目では静寂の音を聞くことができます。</target>
        </trans-unit>
        <trans-unit id="f876ee91061153b58472e3caad886db2830e5e6c" translate="yes" xml:space="preserve">
          <source>In pascal, parameters passed-by-reference are called &quot;var parameters&quot;. In the procedure setToNil below, please note the keyword 'var' which precedes the parameter 'ptr'. When a pointer is passed to this procedure, it will be passed &lt;strong&gt;by reference&lt;/strong&gt;. Note the behavior: when this procedure sets ptr to nil (that's pascal speak for NULL), it will set the argument to nil--you can't do that in Java.</source>
          <target state="translated">Pascalでは、参照によって渡されるパラメーターは「varパラメーター」と呼ばれます。 以下の手順setToNilでは、パラメータ「ptr」の前にあるキーワード「var」に注意してください。 ポインタがこのプロシージャに渡さ&lt;strong&gt;れると、参照によって&lt;/strong&gt;渡さ&lt;strong&gt;れます&lt;/strong&gt; 。 動作に注意してください。このプロシージャがptrをnilに設定すると（パスカルはNULLを意味します）、引数をnilに設定します。Javaではそれを実行できません。</target>
        </trans-unit>
        <trans-unit id="0e25ccb4e75ab4aec689df71744743c33feb9136" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;tricky&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;tricky&lt;/code&gt; 方法では：</target>
        </trans-unit>
        <trans-unit id="556c40767e22c9d0e16c7d2e8fd66f4fc3765ab3" translate="yes" xml:space="preserve">
          <source>In the C++ example below I'm passing a &lt;strong&gt;pointer&lt;/strong&gt; to a null terminated string &lt;strong&gt;by reference&lt;/strong&gt;. And in the Java example below I'm passing a Java reference to a String (again, the same as a pointer to a String) by value. Notice the output in the comments.</source>
          <target state="translated">以下のC ++の例では、nullで終了する文字列への&lt;strong&gt;ポインタ&lt;/strong&gt;を&lt;strong&gt;参照&lt;/strong&gt;渡ししてい&lt;strong&gt;ます&lt;/strong&gt; 。 そして、以下のJavaの例では、文字列へのJava参照（これも文字列へのポインタと同じ）を値で渡しています。 コメントの出力に注意してください。</target>
        </trans-unit>
        <trans-unit id="eaf8d1084a66af0ad2274ebc5bf33bd05b487e6a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;Fifi&lt;/code&gt; is the dog's name after call to &lt;code&gt;foo(aDog)&lt;/code&gt; because the object's name was set inside of &lt;code&gt;foo(...)&lt;/code&gt;. Any operations that &lt;code&gt;foo&lt;/code&gt; performs on &lt;code&gt;d&lt;/code&gt; are such that, for all practical purposes, they are performed on &lt;code&gt;aDog&lt;/code&gt;, but it is &lt;strong&gt;not&lt;/strong&gt; possible to change the value of the variable &lt;code&gt;aDog&lt;/code&gt; itself.</source>
          <target state="translated">上記の例では、オブジェクトの名前が &lt;code&gt;foo(...)&lt;/code&gt; 内に設定されているため、 &lt;code&gt;foo(aDog)&lt;/code&gt; を呼び出した後の &lt;code&gt;Fifi&lt;/code&gt; は犬の名前です 。 &lt;code&gt;foo&lt;/code&gt; が &lt;code&gt;d&lt;/code&gt; に対して実行する操作は、すべての実用的な目的のために、 &lt;code&gt;aDog&lt;/code&gt; に対して実行されますが、変数 &lt;code&gt;aDog&lt;/code&gt; 自体の値を変更することは&lt;strong&gt;できません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5f1d7ec3ad0697448f7bd1694b6d4a13eec5e90" translate="yes" xml:space="preserve">
          <source>In the case of primitive types, Java behaviour is simple: 
The value is copied in another instance of the primitive type.</source>
          <target state="translated">プリミティブ型の場合、Javaの動作は単純です。値はプリミティブ型の別のインスタンスにコピーされます。</target>
        </trans-unit>
        <trans-unit id="a522d3c2682539ae850f96edab1cea9361d6e16b" translate="yes" xml:space="preserve">
          <source>In the example above &lt;code&gt;aDog.getName()&lt;/code&gt; will still return &lt;code&gt;&quot;Max&quot;&lt;/code&gt;. The value &lt;code&gt;aDog&lt;/code&gt; within &lt;code&gt;main&lt;/code&gt; is not changed in the function &lt;code&gt;foo&lt;/code&gt; with the &lt;code&gt;Dog&lt;/code&gt;&lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; as the object reference is passed by value. If it were passed by reference, then the &lt;code&gt;aDog.getName()&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt; would return &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; after the call to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;aDog.getName()&lt;/code&gt; は引き続き &lt;code&gt;&quot;Max&quot;&lt;/code&gt; を返します。 オブジェクト参照は値で渡されるため、 &lt;code&gt;aDog&lt;/code&gt; 内の値aDogは、 &lt;code&gt;Dog&lt;/code&gt; &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; を含む関数 &lt;code&gt;foo&lt;/code&gt; では変更されません。 参照によって渡された場合、 &lt;code&gt;main&lt;/code&gt; &lt;code&gt;aDog.getName()&lt;/code&gt; は &lt;code&gt;foo&lt;/code&gt; の呼び出し後に &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2767cb995f4a551872be17db0731dc32b9631113" translate="yes" xml:space="preserve">
          <source>In the following (please don't try to compile/execute this...):</source>
          <target state="translated">以下のように(これをコンパイルして実行しようとしないでください...)。</target>
        </trans-unit>
        <trans-unit id="3cc72807c6aa2f7787bc1d2e01e7b1a38a8163b3" translate="yes" xml:space="preserve">
          <source>In the image below you can see we have two reference variables(These are called pointers in C/C++, and I think that term makes it easier to understand this feature.) in the main method. Primitive and reference variables are kept in stack memory(left side in images below). array1 and array2 reference variables &quot;point&quot; (as C/C++ programmers call it) or reference to a and b arrays respectively, which are objects (values these reference variables hold are addresses of objects) in heap memory (right side in images below).</source>
          <target state="translated">下の画像では、メインメソッドの中に2つの参照変数(CC++ではポインタと呼ばれていますが、その方がわかりやすいと思います)があるのがわかります。プリミティブ変数と参照変数はスタックメモリ(下の画像では左側)に保持されています。配列1と配列2の参照変数は、ヒープメモリ(下の画像では右側)にあるオブジェクト(これらの参照変数が保持する値はオブジェクトのアドレス)であるaとbの配列をそれぞれ「ポイント」(CC++のプログラマはそう呼んでいます)または参照しています。</target>
        </trans-unit>
        <trans-unit id="1db423d4e50678143cbe574c1553ab77c64d2ec7" translate="yes" xml:space="preserve">
          <source>Is Java “pass-by-reference” or “pass-by-value”</source>
          <target state="translated">Javaは &quot;参照渡し &quot;か &quot;値渡し &quot;か?</target>
        </trans-unit>
        <trans-unit id="da12241a17ef14fa43fa2b4e3155933518c0d4e0" translate="yes" xml:space="preserve">
          <source>It goes like this:</source>
          <target state="translated">このようになります。</target>
        </trans-unit>
        <trans-unit id="98f312d82b1864aed2fd685327b3e2e9e1d88ca2" translate="yes" xml:space="preserve">
          <source>It's perfectly valid to &lt;em&gt;follow&lt;/em&gt; an address and change what's at the end of it; that does not change the variable, however.</source>
          <target state="translated">住所を&lt;em&gt;フォローして&lt;/em&gt; 、住所の最後にあるものを変更する&lt;em&gt;こと&lt;/em&gt;は完全に有効です。 ただし、変数は変更されません。</target>
        </trans-unit>
        <trans-unit id="f5635fa4e11fcd1915675b96d22971357494e751" translate="yes" xml:space="preserve">
          <source>Java always passes arguments &lt;em&gt;by value&lt;/em&gt;, NOT by reference.</source>
          <target state="translated">Javaは常に参照ではなく、 &lt;em&gt;値によって&lt;/em&gt;引数を渡します。</target>
        </trans-unit>
        <trans-unit id="1e1d0bd5765a75bcdfc28bab135f3be439234c61" translate="yes" xml:space="preserve">
          <source>Java arguments are &lt;strong&gt;all passed by value&lt;/strong&gt; (the reference is copied when used by the method) :</source>
          <target state="translated">Java引数は&lt;strong&gt;すべて値で渡されます&lt;/strong&gt; （メソッドが使用するときに参照がコピーされます）。</target>
        </trans-unit>
        <trans-unit id="d45e3643eb2a0c3cfaa96ee1ba516a58b305181b" translate="yes" xml:space="preserve">
          <source>Java has only pass by value. A very simple example to validate this.</source>
          <target state="translated">Javaには値によるパスしかありません。これを検証するための非常に簡単な例です。</target>
        </trans-unit>
        <trans-unit id="703fb214de1457e7f2c05c6d4fec19e41f4cb320" translate="yes" xml:space="preserve">
          <source>Java is a call by value</source>
          <target state="translated">Javaは値による呼び出し</target>
        </trans-unit>
        <trans-unit id="3acd670af680bc110c036092f510ce1f098fa3fb" translate="yes" xml:space="preserve">
          <source>Java is always &lt;strong&gt;pass-by-value&lt;/strong&gt;. Unfortunately, when we pass the value of an object, we are passing the &lt;em&gt;reference&lt;/em&gt; to it.  This is confusing to beginners.</source>
          <target state="translated">Javaは常に&lt;strong&gt;値渡しです&lt;/strong&gt; 。 残念ながら、オブジェクトの値を渡すと、そのオブジェクトへの&lt;em&gt;参照&lt;/em&gt;が渡されます。 これは初心者には混乱します。</target>
        </trans-unit>
        <trans-unit id="d999ec799d7d7e3e79463bd37bb62eacf6e25b10" translate="yes" xml:space="preserve">
          <source>Java is always pass by value, with no exceptions, &lt;strong&gt;ever&lt;/strong&gt;.</source>
          <target state="translated">Javaは常に例外なく、常に値渡しです。</target>
        </trans-unit>
        <trans-unit id="bffa033db8f0f65b32ac37222c7fbfe326862449" translate="yes" xml:space="preserve">
          <source>Java is pass by value according to the Java Language Specification:</source>
          <target state="translated">JavaはJava言語仕様書に基づいて値で渡されます。</target>
        </trans-unit>
        <trans-unit id="5d5b05490570ab7df7923106ad5234571b0ba144" translate="yes" xml:space="preserve">
          <source>Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you'll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!</source>
          <target state="translated">Javaが値渡し型なのは、メソッド内で参照されるオブジェクトをいくらでも変更できるからですが、どんなに頑張っても、何があっても同じオブジェクトを参照し続ける(p______ではなく)渡された変数を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="45192a707a26fe3bb2f92c6fbcb126e95a6e9b0e" translate="yes" xml:space="preserve">
          <source>Java only has the two types of passing: by value for built-in types, and by value of the pointer for object types.</source>
          <target state="translated">Javaでは、組み込み型の場合は値による渡し、オブジェクト型の場合はポインタの値による渡しの2種類しかありません。</target>
        </trans-unit>
        <trans-unit id="529efc0a206bb877a5914af86dac2e005794eacf" translate="yes" xml:space="preserve">
          <source>Java pass &quot;a Java reference&quot; by value example</source>
          <target state="translated">Javaは値の例で &quot;Java参照 &quot;を渡す</target>
        </trans-unit>
        <trans-unit id="3a23cc46246cbf17c3306653ed35fc739dd92303" translate="yes" xml:space="preserve">
          <source>Java passes it parameters by value</source>
          <target state="translated">Javaはそれに値でパラメータを渡します。</target>
        </trans-unit>
        <trans-unit id="93f3aa9ad265f6adfea081d81b4ce0f2dd3364f2" translate="yes" xml:space="preserve">
          <source>Java passes references by value.</source>
          <target state="translated">Javaは値で参照を渡します。</target>
        </trans-unit>
        <trans-unit id="866018b39b9f976d7a4fda32831571acb3fe531a" translate="yes" xml:space="preserve">
          <source>Java passes references to objects by value.</source>
          <target state="translated">Javaは値でオブジェクトへの参照を渡します。</target>
        </trans-unit>
        <trans-unit id="cb688bcbe4d4a31366fbbe80d020a8f8c54e722d" translate="yes" xml:space="preserve">
          <source>Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, you cannot change where that pointer points.</source>
          <target state="translated">JavaはC言語と全く同じように動作します。 ポインタを代入し、そのポインタをメソッドに渡し、メソッド内のポインタをたどって、指し示したデータを変更することができます。しかし、そのポインタが指す場所を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="c3ceb58d38297bd42517df14fa453efa53f2e920" translate="yes" xml:space="preserve">
          <source>Just to show the contrast, compare the following &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C++&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; snippets:</source>
          <target state="translated">コントラストを示すために、次の&lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C ++&lt;/a&gt;と&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Javaの&lt;/a&gt;スニペットを比較します。</target>
        </trans-unit>
        <trans-unit id="76eed6720175d9c487a151ea0ec369ca6ff2bea0" translate="yes" xml:space="preserve">
          <source>Keeping in mind that &lt;code&gt;myDog&lt;/code&gt; is a &lt;em&gt;pointer&lt;/em&gt;, and not an actual &lt;code&gt;Dog&lt;/code&gt;, the answer is NO. &lt;code&gt;myDog&lt;/code&gt; still has the value 42; it's still pointing to the original &lt;code&gt;Dog&lt;/code&gt; (but note that because of line &quot;AAA&quot;, its name is now &quot;Max&quot; - still the same Dog; &lt;code&gt;myDog&lt;/code&gt;'s value has not changed.)</source>
          <target state="translated">&lt;code&gt;myDog&lt;/code&gt; は&lt;em&gt;ポインタ&lt;/em&gt;であり、実際の &lt;code&gt;Dog&lt;/code&gt; ではないことに注意して 、答えはNOです。 &lt;code&gt;myDog&lt;/code&gt; の値はまだ42です。 それはまだ元の &lt;code&gt;Dog&lt;/code&gt; を指しています（ただし、「AAA」という行があるため、その名前は「Max」に変わります-それでも同じDog; &lt;code&gt;myDog&lt;/code&gt; の値は変更されていません。）</target>
        </trans-unit>
        <trans-unit id="2671b77ed672eeae8e1bb043ed9cddaa3c26b00f" translate="yes" xml:space="preserve">
          <source>Let me explain this through an &lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;例&lt;/a&gt;を通してこれを説明しましょう：</target>
        </trans-unit>
        <trans-unit id="1769d859356c9306da11a136d37d7bc840e8173d" translate="yes" xml:space="preserve">
          <source>Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference</source>
          <target state="translated">4つの例を参考にして、私の理解を説明してみます。Javaは値渡しであり、参照渡しではない</target>
        </trans-unit>
        <trans-unit id="667ee93519391efd5ef048789e42e4cd7eb32ed7" translate="yes" xml:space="preserve">
          <source>Let's consider reference types, the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;Java Virtual Machine Specification&lt;/a&gt; states</source>
          <target state="translated">参照型について考えてみましょう&lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;。JavaVirtual Machine仕様に&lt;/a&gt;は、</target>
        </trans-unit>
        <trans-unit id="017c2442a73e3b150be4f8d7101d3d565a83f364" translate="yes" xml:space="preserve">
          <source>Let's understand step by step:</source>
          <target state="translated">一歩一歩理解していきましょう。</target>
        </trans-unit>
        <trans-unit id="5685f4b4e04daf5f5c1aa0517659cc4fb4246e59" translate="yes" xml:space="preserve">
          <source>Lets say we have a variable Foo, its &lt;strong&gt;Location&lt;/strong&gt; is at the 47th byte in memory and its &lt;strong&gt;Value&lt;/strong&gt; is 5. We have another variable &lt;strong&gt;Ref2Foo&lt;/strong&gt; which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two &lt;strong&gt;Values&lt;/strong&gt;.
If you use them as references then to reach to &lt;code&gt;5&lt;/code&gt; we have to travel:</source>
          <target state="translated">変数Fooがあり、その&lt;strong&gt;場所&lt;/strong&gt;がメモリの47番目のバイトにあり、その&lt;strong&gt;値&lt;/strong&gt;が5であるとします。別の変数&lt;strong&gt;Ref2Foo&lt;/strong&gt;がメモリの223番目のバイトにあり、その値は47になります。このRef2Fooは技術変数である可能性があります、プログラムによって明示的に作成されたものではありません。 他の情報なしで5と47を見ると、2つの&lt;strong&gt;値&lt;/strong&gt;しか表示されません。 それらを参照として使用する場合、 &lt;code&gt;5&lt;/code&gt; に到達するために移動する必要があります。</target>
        </trans-unit>
        <trans-unit id="d50fff30ab03bcac896614280d7ce79d010333b1" translate="yes" xml:space="preserve">
          <source>Like so:</source>
          <target state="translated">そうだな</target>
        </trans-unit>
        <trans-unit id="1cfac11915904016eed201cd17895ef142e7298c" translate="yes" xml:space="preserve">
          <source>Likewise:</source>
          <target state="translated">Likewise:</target>
        </trans-unit>
        <trans-unit id="5cd871265dfcea1f716cd6d1540a0775e084af34" translate="yes" xml:space="preserve">
          <source>Naturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.</source>
          <target state="translated">当然のことながら、オブジェクトへの参照を値で渡すことは、オブジェクトを参照で渡すことと非常に似ています(実際には区別がつきません)。</target>
        </trans-unit>
        <trans-unit id="74a399506f2951a7b197ec01ea8e798ce4122914" translate="yes" xml:space="preserve">
          <source>Next in the &lt;code&gt;tricky&lt;/code&gt; method</source>
          <target state="translated">次に &lt;code&gt;tricky&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="4c7f2f0ce70a51c735ee73784fc914a2704fd44b" translate="yes" xml:space="preserve">
          <source>Nitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only &lt;em&gt;pass-by-reference&lt;/em&gt;.</source>
          <target state="translated">取るに足らない詳細については気にしないでください。参照渡しを行う言語でも値を関数に渡しますが、これらの関数は逆参照の目的で値を使用する必要があることを認識しています。 この参照としての値&lt;em&gt;渡し&lt;/em&gt;は、実際には役に立たず、用語は&lt;em&gt;参照渡し&lt;/em&gt;のみであるため、プログラマーから単に隠されています。</target>
        </trans-unit>
        <trans-unit id="f39a1496ed9448598fdec7fa441d4eb247a6d515" translate="yes" xml:space="preserve">
          <source>No new instances of Person are created.</source>
          <target state="translated">Person の新しいインスタンスは作成されません。</target>
        </trans-unit>
        <trans-unit id="5a3c28a6866958ddbd72e8e5bfcca8b47c170a56" translate="yes" xml:space="preserve">
          <source>No, it's not pass by reference.</source>
          <target state="translated">いや、参考にしても通らない。</target>
        </trans-unit>
        <trans-unit id="a2c2fa354963a9acfa4e9abfc392a844ec4c593d" translate="yes" xml:space="preserve">
          <source>Note: I am not pasting the code for &lt;code&gt;private class Student&lt;/code&gt;. The class definition for &lt;code&gt;Student&lt;/code&gt; is same as Example3.</source>
          <target state="translated">注： &lt;code&gt;private class Student&lt;/code&gt; コードを貼り付けていません。 &lt;code&gt;Student&lt;/code&gt; のクラス定義はExample3と同じです。</target>
        </trans-unit>
        <trans-unit id="922f6a86dea64e63a3edc02c1877ce2a3c46981e" translate="yes" xml:space="preserve">
          <source>Now feel free to hate me but note that given this &lt;strong&gt;there is no difference between passing primitive data types and Objects&lt;/strong&gt; when talking about method arguments.</source>
          <target state="translated">ここで私を嫌いにしてください。ただし、メソッドの引数について話すとき&lt;strong&gt;、プリミティブデータ型とオブジェクトを渡すことには違いがないことに&lt;/strong&gt;注意してください。</target>
        </trans-unit>
        <trans-unit id="69d2ccd64b25d43c28b50000e4e7f2b5a02a3236" translate="yes" xml:space="preserve">
          <source>Now let's think about what happens outside the method:</source>
          <target state="translated">では、メソッドの外で何が起こるのかを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="ff38daeae639f963939233f6e3fdce27295e1cf5" translate="yes" xml:space="preserve">
          <source>Now think of what an Object's reference/variable does/is:</source>
          <target state="translated">次に、オブジェクトの参照変数が何をするかを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="0e2ffb2ff2a00fd086483aeae2222dbc11a4d2c8" translate="yes" xml:space="preserve">
          <source>Now we have passed Foo to the method:</source>
          <target state="translated">これでFooをメソッドに渡しました。</target>
        </trans-unit>
        <trans-unit id="a68e19abd4296329735454d01ddb1f100edde052" translate="yes" xml:space="preserve">
          <source>Of course you can cut it short and just say that  &lt;strong&gt;Java is pass-by-value!&lt;/strong&gt;</source>
          <target state="translated">もちろん、短くすることもでき、 &lt;strong&gt;Javaは値渡しです！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25bdd3d54506e9fcb400bfa35ebbf005d8293eb" translate="yes" xml:space="preserve">
          <source>Okay. First off, local primitives go on the stack. So this code:</source>
          <target state="translated">そうですか まず最初に、ローカルプリミティブはスタック上に置かれます。だからこのコードは</target>
        </trans-unit>
        <trans-unit id="8e109f9696197d944923c2e8918140789af777d2" translate="yes" xml:space="preserve">
          <source>One String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier &lt;code&gt;hisName&lt;/code&gt;, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call &lt;code&gt;shout()&lt;/code&gt;: a new stack frame is created and a new identifier, &lt;code&gt;name&lt;/code&gt; is created and assigned the address of the already-existing String.</source>
          <target state="translated">1つの文字列が作成され、そのスペースがヒープに割り当てられます &lt;code&gt;hisName&lt;/code&gt; 番目の文字列のアドレスは最初の文字列と同じであるため、文字列へのアドレスはスタックに格納され、 hisNameという識別子が与えられます。新しい文字列は作成されません。また、新しいヒープ領域は割り当てられませんが、新しい識別子がスタックに作成されます。 次に、 &lt;code&gt;shout()&lt;/code&gt; を呼び出します。新しいスタックフレームが作成され、新しい識別子 &lt;code&gt;name&lt;/code&gt; が作成されて、既存の文字列のアドレスが割り当てられます。</target>
        </trans-unit>
        <trans-unit id="e9fbef27678eb892ee44cd57611d9c038d5ddbb8" translate="yes" xml:space="preserve">
          <source>Or from wikipedia, &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;on the subject of pass-by-reference&lt;/a&gt;</source>
          <target state="translated">または、Wikipassから、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;参照渡しについて&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89050305305bcda692140fffe8f7276e92d157fe" translate="yes" xml:space="preserve">
          <source>Pass By Value</source>
          <target state="translated">パスバイバリュー</target>
        </trans-unit>
        <trans-unit id="7a52d2d617a0327ba951584e0dd74a3b60d0e2ee" translate="yes" xml:space="preserve">
          <source>Pass by value means the called functions' parameter will be a copy of
  the callers' passed argument.</source>
          <target state="translated">値で渡すということは、呼び出された関数のパラメータが呼び出し側の渡された引数のコピーになることを意味します。</target>
        </trans-unit>
        <trans-unit id="b05d82b9afa13c63a41c110afc8f23afc15f5eb7" translate="yes" xml:space="preserve">
          <source>Passing by reference means the called functions' parameter will be the
  same as the callers' passed argument (not the value, but the identity
  - the variable itself).</source>
          <target state="translated">参照で渡すということは、呼び出された関数のパラメータが呼び出し元の渡された引数と同じになることを意味します(値ではなく、同一性-変数そのもの)。</target>
        </trans-unit>
        <trans-unit id="cc7d7eee18bf03fb193a57aacc259b0ecd56568e" translate="yes" xml:space="preserve">
          <source>Passing references to arrays, instead of the array objects themselves, makes sense for performance reasons. Because everything in Java is passed by value, if array objects were passed,
a copy of each element would be passed. For large arrays, this would waste time and consume
considerable storage for the copies of the elements.</source>
          <target state="translated">配列オブジェクト自体ではなく、配列への参照を渡すことは、パフォーマンス上の理由から理にかなっています。Javaのすべてのものは値で渡されるので、配列オブジェクトが渡されると、各要素のコピーが渡されることになります。大きな配列の場合、これは時間を浪費し、要素のコピーのためにかなりのストレージを消費します。</target>
        </trans-unit>
        <trans-unit id="8cfedebc2d3a9442c6efa9728f78e57e537d2cba" translate="yes" xml:space="preserve">
          <source>Primitive values are also defined in the Java Virtual Machine Specification, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;here&lt;/a&gt;. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).</source>
          <target state="translated">プリミティブ値は、Java仮想マシン仕様（ &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;こちら）&lt;/a&gt;でも定義されています。 タイプの値は、適切にエンコードされた対応する整数値または浮動小数点値です（8、16、32、64などのビット）。</target>
        </trans-unit>
        <trans-unit id="20eebab5a449d25f5d3973bfc691fbe91ed1dda9" translate="yes" xml:space="preserve">
          <source>Primitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.</source>
          <target state="translated">プリミティブなラッパークラスや文字列は不変なので、これらの型を使用した例は他の型オブジェクトと同じようには動作しません。</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="45c34d3cd3e583ca8c9f01b7fd4364b4be14d83e" translate="yes" xml:space="preserve">
          <source>References &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; are &lt;strong&gt;passed by value&lt;/strong&gt; to the tricky method, which means that now yours references &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; have their &lt;code&gt;copies&lt;/code&gt; named &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;.So &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;arg1&lt;/code&gt;&lt;em&gt;points&lt;/em&gt; to the same object. (Same for the &lt;code&gt;pnt2&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;)</source>
          <target state="translated">参照 &lt;code&gt;pnt1&lt;/code&gt; と &lt;code&gt;pnt2&lt;/code&gt; は、トリッキーなメソッドに&lt;strong&gt;値で渡されます&lt;/strong&gt; 。つまり、参照 &lt;code&gt;pnt1&lt;/code&gt; と &lt;code&gt;pnt2&lt;/code&gt; は、 &lt;code&gt;arg1&lt;/code&gt; および &lt;code&gt;arg2&lt;/code&gt; という名前の &lt;code&gt;copies&lt;/code&gt; 持っています。 &lt;code&gt;pnt1&lt;/code&gt; 、 pnt1と &lt;code&gt;arg1&lt;/code&gt; は同じオブジェクトを&lt;em&gt;指し&lt;/em&gt;ます。 （ &lt;code&gt;pnt2&lt;/code&gt; と &lt;code&gt;arg2&lt;/code&gt; も同じ）</target>
        </trans-unit>
        <trans-unit id="bf00fec3f22ea28e6b86a2ef752102c2e7ecb750" translate="yes" xml:space="preserve">
          <source>Second, we need to know what Java uses in its method invocations. The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification&lt;/a&gt; states</source>
          <target state="translated">次に、Javaがそのメソッド呼び出しで何を使用するかを知る必要があります。 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java言語仕様に&lt;/a&gt;は、</target>
        </trans-unit>
        <trans-unit id="d6c9ce881b6078a8902ba5543f51a3b0d775b3fa" translate="yes" xml:space="preserve">
          <source>Several people have written comments which seem to indicate that either they are not looking at my examples or they don't get the c++ example. Not sure where the disconnect is, but guessing the c++ example is not clear. I'm posting the same example in pascal because I think pass-by-reference looks cleaner in pascal, but I could be wrong. I might just be confusing people more; I hope not.</source>
          <target state="translated">何人かの人がコメントを書いていますが、それは私の例を見ていないか、あるいは c++の例を理解していないことを示しているようです。どこが切り離されているのかはわかりませんが、c++の例はよくわかりません。同じ例を pascal で投稿しているのは、pascal での参照渡しの方がきれいに見えると思うからですが、間違っているかもしれません。私は人々をさらに混乱させているかもしれませんが、そうでないことを願っています。</target>
        </trans-unit>
        <trans-unit id="26c0ca793e8f7074d3f8c82877440040dbf9523b" translate="yes" xml:space="preserve">
          <source>So</source>
          <target state="translated">So</target>
        </trans-unit>
        <trans-unit id="ff40a96c97ebf788e8cecb055d7af4f991b2166d" translate="yes" xml:space="preserve">
          <source>So after executing method &lt;code&gt;tricky&lt;/code&gt;, when you return to &lt;code&gt;main&lt;/code&gt;, you have this situation:</source>
          <target state="translated">したがって、メソッド &lt;code&gt;tricky&lt;/code&gt; を実行した後、 &lt;code&gt;main&lt;/code&gt; に戻ると、次のような状況になります。</target>
        </trans-unit>
        <trans-unit id="7ef4027a6bbd3300b48fbef4e07ab82867158511" translate="yes" xml:space="preserve">
          <source>So how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java &lt;strong&gt;never&lt;/strong&gt; provides direct access to the values of &lt;em&gt;objects themselves&lt;/em&gt;, in &lt;em&gt;any&lt;/em&gt; circumstances. The only access to objects is through a &lt;em&gt;reference&lt;/em&gt; to that object. Because Java objects are &lt;em&gt;always&lt;/em&gt; accessed through a reference, rather than directly, it is common to talk about fields and variables &lt;em&gt;and method arguments&lt;/em&gt; as being &lt;em&gt;objects&lt;/em&gt;, when pedantically they are only &lt;em&gt;references to objects&lt;/em&gt;. &lt;strong&gt;The confusion stems from this (strictly speaking, incorrect) change in nomenclature.&lt;/strong&gt;</source>
          <target state="translated">それで、誰もがこれによってまったく混乱し、Javaが参照渡しであると信じたり、Javaが参照渡しとして機能する例があると考えたりするのはどうしてでしょうか。 重要な点は、 &lt;em&gt;どのよう&lt;/em&gt;な状況において&lt;em&gt;も&lt;/em&gt; 、Javaが&lt;em&gt;オブジェクト自体&lt;/em&gt;の値に直接アクセスする&lt;strong&gt;こと&lt;/strong&gt;は&lt;strong&gt;決してないということ&lt;/strong&gt;です。 オブジェクトへの唯一のアクセスは、そのオブジェクトへの&lt;em&gt;参照&lt;/em&gt;を介したものです。 Javaオブジェクトは直接ではなく&lt;em&gt;常に&lt;/em&gt;参照を介してアクセスされるため、フィールドや変数&lt;em&gt;、メソッドの引数&lt;/em&gt;を&lt;em&gt;オブジェクト&lt;/em&gt;である&lt;em&gt;と説明&lt;/em&gt;することはよくあり&lt;em&gt;ます&lt;/em&gt; 。 &lt;strong&gt;混乱は、命名法のこの（厳密には、正しくない）変更に起因します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49f6e297927d971ba38fa95bec79322b3f55ffe8" translate="yes" xml:space="preserve">
          <source>So if you have &lt;code&gt;doSomething(foo)&lt;/code&gt; and &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; the two Foos have copied &lt;em&gt;references&lt;/em&gt; that point to the same objects.</source>
          <target state="translated">したがって、 &lt;code&gt;doSomething(foo)&lt;/code&gt; と &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; 、2つのFoosは同じオブジェクトを指す&lt;em&gt;参照&lt;/em&gt;をコピーし&lt;em&gt;て&lt;/em&gt;います。</target>
        </trans-unit>
        <trans-unit id="7b4e3120f9e0ef1963e36854a84df92466e8bd5c" translate="yes" xml:space="preserve">
          <source>So in short and in Java's own terminology, Java is &lt;em&gt;pass-by-value&lt;/em&gt; where &lt;em&gt;value&lt;/em&gt; can be: either a &lt;strong&gt;real value&lt;/strong&gt; or a &lt;strong&gt;value&lt;/strong&gt; that is a representation of a &lt;strong&gt;reference&lt;/strong&gt;.</source>
          <target state="translated">つまり、簡単に言うと、Java自体の用語では、Javaは&lt;em&gt;値渡しです&lt;/em&gt; 。 &lt;em&gt;値&lt;/em&gt;は、 &lt;strong&gt;実際の値&lt;/strong&gt;か、 &lt;strong&gt;参照を&lt;/strong&gt;表す&lt;strong&gt;値の&lt;/strong&gt;いずれかです。</target>
        </trans-unit>
        <trans-unit id="634936d81c1689fe91adca4c5ee1e8fd9d96a1ad" translate="yes" xml:space="preserve">
          <source>So it assigns (or binds) the value of the argument to the corresponding parameter variable.</source>
          <target state="translated">つまり、引数の値を対応するパラメータ変数に代入(またはバインド)します。</target>
        </trans-unit>
        <trans-unit id="f4945724933ec9be2092b5806b370216861c5eeb" translate="yes" xml:space="preserve">
          <source>So let's write all the things we have done at once now.</source>
          <target state="translated">ということで、今までやってきたことを一気に書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="9a181e916502cbb03b3332b929a47423efcc6e84" translate="yes" xml:space="preserve">
          <source>So now, completely execution of program will be:</source>
          <target state="translated">これで、完全にプログラムの実行が可能になりました。</target>
        </trans-unit>
        <trans-unit id="2a27627ea047cda38b06899780beb9ed096f3a7d" translate="yes" xml:space="preserve">
          <source>So you can't change the reference that gets passed in.</source>
          <target state="translated">だから、渡された参照を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="866237ea6abd1c73ce2cd72c6c84fc4749c1fab7" translate="yes" xml:space="preserve">
          <source>So you're just passing 3bad086a that it's the value of the reference.</source>
          <target state="translated">3bad086aに参照の値であることを渡しているだけなんですね。</target>
        </trans-unit>
        <trans-unit id="20fd78625a8ef72411c2e7f9cc21dcf94a034a8f" translate="yes" xml:space="preserve">
          <source>So, if we say</source>
          <target state="translated">ということで、仮に</target>
        </trans-unit>
        <trans-unit id="90e7e6de17ceea609c89967f7448b462eff52e91" translate="yes" xml:space="preserve">
          <source>So, value, reference? You say &quot;potato&quot;.</source>
          <target state="translated">だから、価値、参照?ポテト」って言うんですね。</target>
        </trans-unit>
        <trans-unit id="daa39b66ef2d8fde4dcb582dccfc4335693ba86f" translate="yes" xml:space="preserve">
          <source>So, what gets passed in when you call a method? If you pass in an object, what you're actually passing in is the address of the object. Some might say the &quot;value&quot; of the address, and some say it's just a reference to the object. This is the genesis of the holy war between &quot;reference&quot; and &quot;value&quot; proponents. What you call it isn't as important as that you understand that what's getting passed in is the address to the object.</source>
          <target state="translated">では、メソッドを呼び出すときに何が渡されるのでしょうか?オブジェクトを渡す場合、実際に渡されるのはオブジェクトのアドレスです。アドレスの「値」と言う人もいるでしょうし、オブジェクトへの参照だと言う人もいます。これが、「参照」と「値」の支持者の間の聖戦の始まりです。何と呼ぶかは、渡されるものがオブジェクトへのアドレスであることを理解しているかどうかほど重要ではありません。</target>
        </trans-unit>
        <trans-unit id="f804721f9a225c83f9f775159b5195bbbe96d25c" translate="yes" xml:space="preserve">
          <source>So, when calling a method</source>
          <target state="translated">そのため、メソッドを呼び出すときに</target>
        </trans-unit>
        <trans-unit id="ee33b63e4d6f38a1051e9487d652448deba03bf9" translate="yes" xml:space="preserve">
          <source>Some excerpts from &lt;strong&gt;&quot;THE Java Programming Language&quot;&lt;/strong&gt; by Ken Arnold, &lt;strong&gt;James Gosling (the guy who invented Java)&lt;/strong&gt;, and David Holmes, chapter 2, section 2.6.5</source>
          <target state="translated">Ken Arnold、 &lt;strong&gt;James Gosling（Javaを発明した人）&lt;/strong&gt; 、およびDavid Holmesによる&lt;strong&gt;「THE Javaプログラミング言語」&lt;/strong&gt; 、第2章、セクション2.6.5からの抜粋</target>
        </trans-unit>
        <trans-unit id="94b891247159e943febc8cc22cd31a1491a1cb74" translate="yes" xml:space="preserve">
          <source>Some people say primitive types and 'String' are 'pass by value'
  and objects are 'pass by reference'.</source>
          <target state="translated">プリミティブ型や'String'は「値による渡し」、オブジェクトは「参照による渡し」と言う人がいますが、これは「値による渡し」ではなく「参照による渡し」です。</target>
        </trans-unit>
        <trans-unit id="ae7f019ce2b7e1139c2214fe199d7dfbfd4ace30" translate="yes" xml:space="preserve">
          <source>Sometimes Java can give the illusion of pass by reference. Let's see how it works by using the example below:</source>
          <target state="translated">Javaは時々、参照によるパス・バイ・リファレンスのような錯覚を起こすことがあります。以下の例を使って、どのように動作するのか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="523c67e3005e1319a95db986a92e473eccf87a79" translate="yes" xml:space="preserve">
          <source>Sometimes you want to use the same pattern in Java, but you can't; at least not directly. Instead you could do something like this:</source>
          <target state="translated">Javaで同じパターンを使いたいと思うこともあるでしょうが、少なくとも直接はできません。代わりに、次のようなことをすることができます。</target>
        </trans-unit>
        <trans-unit id="aa1ec5d7dc80c372add31e690fc9b6adfcbed953" translate="yes" xml:space="preserve">
          <source>Step one please erase from your mind that word that starts with 'p' &quot;_ _ _ _ _ _ _&quot;, especially if you come from other programming languages. Java and 'p' cannot be written in the same book, forum, or even txt.</source>
          <target state="translated">ステップ1 'p'で始まる単語「_______」を頭の中から消してください、特に他のプログラミング言語から来た場合は。Javaと'p'は、同じ本やフォーラム、さらにはtxtにも書けません。</target>
        </trans-unit>
        <trans-unit id="e060e28388e7368925caf9e91796e5aa4d2b1720" translate="yes" xml:space="preserve">
          <source>Step two remember that when you pass an Object into a method you're passing the Object reference and not the Object itself.</source>
          <target state="translated">ステップ 2 オブジェクトをメソッドに渡すときは、オブジェクト自体ではなくオブジェクトの参照を渡すことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="6207dc3dd0572f9c051d767720eb5104f3fb4f3c" translate="yes" xml:space="preserve">
          <source>Strict &lt;em&gt;pass-by-value&lt;/em&gt; is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller's view) and a few languages allows to modify the Value of the reference itself.</source>
          <target state="translated">厳密な&lt;em&gt;値渡し&lt;/em&gt;も無意味です。つまり、配列を引数としてメソッドを呼び出すたびに100Mバイトの配列をコピーする必要があるため、Javaを厳密に値渡しすることはできません。 すべての言語はこの巨大な配列への参照を（値として）渡し、その配列をメソッド内でローカルに変更できる場合はコピーオンライトメカニズムを使用するか、（Javaのように）メソッドが配列をグローバルに（呼び出し元のビュー）およびいくつかの言語では、参照自体の値を変更できます。</target>
        </trans-unit>
        <trans-unit id="f14bbbb986af6b74a6c4b3c0e5664a7de3e563b7" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;code&gt;Dog&lt;/code&gt; object resides at memory address 42. This means we pass 42 to the method.</source>
          <target state="translated">&lt;code&gt;Dog&lt;/code&gt; オブジェクトがメモリアドレス42に存在するとします。これは、メソッドに42を渡すことを意味します。</target>
        </trans-unit>
        <trans-unit id="8d27872f4e15932b79d2264d4a0cddb9e2521238" translate="yes" xml:space="preserve">
          <source>Take this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; is called by &lt;code&gt;foo(a)&lt;/code&gt;, where the compiler itself knows that it is a reference and the address of the non-reference &lt;code&gt;a&lt;/code&gt; should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.</source>
          <target state="translated">これをC ++に持っていけば、リファレンスがあります。 参照は、基本的に（このコンテキストでは）方程式のポインター部分を隠す構文糖です： &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; は &lt;code&gt;foo(a)&lt;/code&gt; によって呼び出され、コンパイラー自体がそれが参照であり、非参照 &lt;code&gt;a&lt;/code&gt; を渡す必要があります。 Javaでは、オブジェクトを参照するすべての変数は実際には参照型であり、事実上、C ++などの細かい制御（および複雑さ）なしで、ほとんどの意図および目的のために参照による呼び出しを強制します。</target>
        </trans-unit>
        <trans-unit id="1f5466dbc044f44594c32f9e6b1b8a7351767c72" translate="yes" xml:space="preserve">
          <source>That's the reason only Java developers have issue with this. They look at the word &quot;reference&quot; and think they know exactly what that means, so they don't even bother to consider the opposing argument.</source>
          <target state="translated">これがJava開発者だけが問題にしている理由です。彼らは「参照」という言葉を見て、その意味を正確に知っていると思っているので、わざわざ反論を考えようともしません。</target>
        </trans-unit>
        <trans-unit id="c94098a38907257d1a6a763b38d1468647d923f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;Java Language Specification&lt;/a&gt; also states</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;Java言語仕様&lt;/a&gt;には、</target>
        </trans-unit>
        <trans-unit id="079b195af1fa053069e0e9a1be334e5b752f52b4" translate="yes" xml:space="preserve">
          <source>The Java Spec says that everything in Java is pass-by-value. There is no such thing as &quot;pass-by-reference&quot; in Java.</source>
          <target state="translated">Javaの仕様では、Javaではすべてのものが値渡しであるとされています。Javaには「参照渡し」などというものはありません。</target>
        </trans-unit>
        <trans-unit id="fd7bc25c7313046e736eb3d62b656f193458641b" translate="yes" xml:space="preserve">
          <source>The Java programming language &lt;strong&gt;does not pass objects by reference; it&lt;/strong&gt;&lt;strong&gt;passes object references by value&lt;/strong&gt;. Because two copies of the same
  reference refer to the same actual object, changes made through one
  reference variable are visible through the other. There is exactly one
  parameter passing mode-&lt;strong&gt;pass by value&lt;/strong&gt;-and that helps keep things
  simple.</source>
          <target state="translated">Javaプログラミング言語&lt;strong&gt;はオブジェクトを参照渡ししません。&lt;/strong&gt; &lt;strong&gt;オブジェクト参照を値&lt;/strong&gt; &lt;strong&gt;で&lt;/strong&gt; &lt;strong&gt;渡します&lt;/strong&gt; 。 同じ参照の2つのコピーは同じ実際のオブジェクトを参照するため、1つの参照変数を介して行われた変更は、他の参照変数を介して表示されます。 正確に1つのパラメーター受け渡しモード（ &lt;strong&gt;値による&lt;/strong&gt;受け渡し）があり、物事を単純に保つのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="ea546a9da3076dcf69d6a878525afaefa3c2665d" translate="yes" xml:space="preserve">
          <source>The behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object).
Object's &lt;strong&gt;content/members&lt;/strong&gt; might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference.</source>
          <target state="translated">動作は、プリミティブ型とは異なるように見える場合があります。コピーされたオブジェクト変数には、（同じオブジェクトへの）同じアドレスが含まれているためです。 オブジェクトの&lt;strong&gt;コンテンツ/メンバー&lt;/strong&gt;は、メソッド内で変更され、後で外部にアクセスする可能性があります。これにより、（含む）オブジェクト自体が参照によって渡されたように見えます。</target>
        </trans-unit>
        <trans-unit id="f6f95a7e89d7fa53f741a6006a73b3f53dbfe98a" translate="yes" xml:space="preserve">
          <source>The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.</source>
          <target state="translated">上記のchangeName関数は、渡された参照の実際の内容(ビット値)を変更することはできません。言い換えれば、changeName は Person person を別の Object を参照させることはできません。</target>
        </trans-unit>
        <trans-unit id="d43a36b01a5a36e6a4fed6f955af9bd89a90e8e2" translate="yes" xml:space="preserve">
          <source>The crux of the matter is that the word &lt;em&gt;reference&lt;/em&gt; in the expression &quot;pass by reference&quot; means something completely different from the usual meaning of the word &lt;em&gt;reference&lt;/em&gt; in Java.</source>
          <target state="translated">問題の核心は、「参照渡し」という表現の参照という言葉は、Javaの&lt;em&gt;参照&lt;/em&gt;という言葉の通常の意味とはまったく異なるものを意味するということです。</target>
        </trans-unit>
        <trans-unit id="d6413d6c252fab8253fe8c316fa9f97b12f5c04a" translate="yes" xml:space="preserve">
          <source>The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.</source>
          <target state="translated">区別というか、私が元のポスターと同じ印象を受けていたので覚えている方法はこれです。Javaは常に値で渡されます。Javaのすべてのオブジェクト(Javaでは、プリミティブ以外のもの)は参照です。これらの参照は値で渡されます。</target>
        </trans-unit>
        <trans-unit id="e90dc2a7bcee6387a6415dbc06ec56f2e174cf42" translate="yes" xml:space="preserve">
          <source>The key to understanding this is that something like</source>
          <target state="translated">これを理解する上で重要なのは</target>
        </trans-unit>
        <trans-unit id="c870634849690af62ce95dbaaffd653c3bdc1132" translate="yes" xml:space="preserve">
          <source>The output of this program is:</source>
          <target state="translated">このプログラムの出力は</target>
        </trans-unit>
        <trans-unit id="914b3110e6efe55bce5c55f82df6a7638d0fa6d6" translate="yes" xml:space="preserve">
          <source>The term &quot;reference&quot; is a overloaded with two separate meanings. In Java it simply means a pointer, but in the context of &quot;Pass-by-reference&quot; it means a handle to the original variable which was passed in.</source>
          <target state="translated">参照」という用語は、2つの異なる意味を持つオーバーロードです。Javaでは単にポインタを意味しますが、&quot;Pass-by-reference &quot;の文脈では、渡された元の変数のハンドルを意味します。</target>
        </trans-unit>
        <trans-unit id="d685aec290065c3d070420033a198dff8941ecc8" translate="yes" xml:space="preserve">
          <source>The value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (&lt;code&gt;new ...&lt;/code&gt;) all resolve to a reference type value.</source>
          <target state="translated">（ある参照型の）引数の値は、オブジェクトへのポインターです。 変数、参照型の戻り値の型を持つメソッドの呼び出し、およびインスタンス作成式（ &lt;code&gt;new ...&lt;/code&gt; ）はすべて参照型の値に解決されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b9723eb7fef6befdaac82e1c6cd7ab277e54545d" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; holding the address of the Object is passed to the function in line #3.</source>
          <target state="translated">Objectのアドレスを保持する変数&lt;em&gt;person&lt;/em&gt;は、3行目の関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="9a827a692a5c5bbbe054c83be9d12f395ddfae3c" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; is created in line #1 and it's null at the beginning.</source>
          <target state="translated">変数&lt;em&gt;person&lt;/em&gt;は行＃1で作成され、最初はnullです。</target>
        </trans-unit>
        <trans-unit id="d211d018025495720be4d35b0fb0e965174108f6" translate="yes" xml:space="preserve">
          <source>The variable/reference &lt;em&gt;person&lt;/em&gt; is copied bit-by-bit and passed to &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; inside the function.</source>
          <target state="translated">変数/参照&lt;em&gt;者&lt;/em&gt;はビット&lt;em&gt;ごとにコピーさ&lt;/em&gt;れ、関数内の&lt;em&gt;別のReferenceToTheSamePersonObjectに&lt;/em&gt;渡されます。</target>
        </trans-unit>
        <trans-unit id="a6a7f9ad555d80ee9f46a19d1dc4de44b454dbba" translate="yes" xml:space="preserve">
          <source>There are already great answers that cover this. I wanted to make a small contribution by sharing a &lt;strong&gt;very simple example&lt;/strong&gt; (which will compile) contrasting the behaviors between Pass-by-reference in c++ and Pass-by-value in Java.</source>
          <target state="translated">これをカバーする素晴らしい答えがすでにあります。 私は、C ++での参照渡しとJavaでの値渡しの間の動作を対比する&lt;strong&gt;非常に単純な例&lt;/strong&gt; （コンパイルされる）を共有することで、小さな貢献をしたいと思っていました。</target>
        </trans-unit>
        <trans-unit id="dfab606767515e58a1e6d064ffb7613d99a953bf" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;strong&gt;reference types&lt;/strong&gt;: class types, array types,
  and interface types. &lt;strong&gt;Their values are references to dynamically
  created class instances, arrays, or class instances or arrays that
  implement interfaces, respectively.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;参照&lt;/strong&gt;型には、クラス型、配列型、インターフェース型の3種類があります。 &lt;strong&gt;それらの値は、動的に作成されたクラスインスタンス、配列、またはインターフェイスを実装するクラスインスタンスまたは配列への参照です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa2284d9a49a58f0919e69504baa39d271367e04" translate="yes" xml:space="preserve">
          <source>There's the key.</source>
          <target state="translated">そこに鍵があります。</target>
        </trans-unit>
        <trans-unit id="e1f460dd17e5cf9708ba41d056ae77c8a33b5f05" translate="yes" xml:space="preserve">
          <source>Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.</source>
          <target state="translated">参照パラメータは、渡された変数のエイリアスと考えてください。そのエイリアスが代入されると、渡された変数も代入されます。</target>
        </trans-unit>
        <trans-unit id="d3a442ecb80bc2357c8302e2cfa37890d9a8f934" translate="yes" xml:space="preserve">
          <source>This happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.</source>
          <target state="translated">これは、iAとiBが新しいローカル参照変数で、渡された参照と同じ値を持つからです(それぞれaとbを指しています)。したがって、iA または iB の参照を変更しようとしても、ローカルスコープ内でのみ変更され、このメソッドの外部では変更されません。</target>
        </trans-unit>
        <trans-unit id="5eefcb95db3d521d55f45ddd3a85d502cf4cdc4f" translate="yes" xml:space="preserve">
          <source>This is how jump-tables work.</source>
          <target state="translated">これがジャンプテーブルの仕組みです。</target>
        </trans-unit>
        <trans-unit id="6bf397e1d5e88f4359962543f1564d72392aa1a0" translate="yes" xml:space="preserve">
          <source>This section of the book has a great explanation of parameter passing in Java and of the distinction between pass-by-reference and pass-by-value and it's by the creator of Java. I would encourage anyone to read it, especially if you're still not convinced.</source>
          <target state="translated">この本のこのセクションでは、Javaにおけるパラメータの渡し方や、参照渡しと値渡しの区別についての素晴らしい説明があり、Javaの生みの親によるものです。特にあなたがまだ納得できない場合は、誰でも読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f6f7ba733b2534ecc1ea818cdddfaf4dcf24537c" translate="yes" xml:space="preserve">
          <source>This typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">これは通常、関数が引数として使用される変数（呼び出し元から見えるもの）を変更（つまり、割り当て）できることを意味します。</target>
        </trans-unit>
        <trans-unit id="a24fd574548676d8a5fdf4e5d5e866b85294afa6" translate="yes" xml:space="preserve">
          <source>This will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:</source>
          <target state="translated">スワップ関数では、メインの参照に影響を与えないコピーを使用するため、これはHello WorldではなくHello Worldを入力します。しかし、オブジェクトが不変ではない場合は、例えばこれを変更することができます。</target>
        </trans-unit>
        <trans-unit id="e505e393bf5f01ebb5d9bfa9244eb4fa82d49415" translate="yes" xml:space="preserve">
          <source>This will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:</source>
          <target state="translated">これはコマンドライン上でHello Worldを表示します。StringBufferをStringに変更すると、Stringは不変なのでHelloだけが生成されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ecc09e1b426d0f3bbdde2b52d1275b4a9684b1cb" translate="yes" xml:space="preserve">
          <source>To make a long story short, &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; objects have some very peculiar properties.</source>
          <target state="translated">簡単に言えば、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt;オブジェクトにはいくつかの非常に独特な特性があります。</target>
        </trans-unit>
        <trans-unit id="d8f2d10c7283892fc482b2460252534f2c951f8f" translate="yes" xml:space="preserve">
          <source>To understand this more clearly, consider the following example:</source>
          <target state="translated">これをより明確に理解するために、次のような例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4a3568015b17ba4456e0d1ce2a6b83da248a6190" translate="yes" xml:space="preserve">
          <source>Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-reference&amp;mdash;all arguments are passed by value. A method call can pass two types of values to a method&amp;mdash;copies of primitive values (e.g., values of int and double) and copies of references to objects.</source>
          <target state="translated">他の一部の言語とは異なり、Javaでは値渡しと参照渡しのどちらかを選択できません。すべての引数は値で渡されます。 メソッド呼び出しは、プリミティブ値のコピー（intやdoubleの値など）とオブジェクトへの参照のコピーの2種類の値をメソッドに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8379236c60a3ff28075f90353d681fa71cd1a5aa" translate="yes" xml:space="preserve">
          <source>Usually in Java &lt;em&gt;reference&lt;/em&gt; means a a &lt;em&gt;reference to an object&lt;/em&gt;. But the technical terms &lt;em&gt;pass by reference/value&lt;/em&gt; from programming language theory is talking about a &lt;em&gt;reference to the memory cell holding the variable&lt;/em&gt;, which is something completely different.</source>
          <target state="translated">通常、Java &lt;em&gt;参照で&lt;/em&gt;は&lt;em&gt;、オブジェクトへの&lt;/em&gt; &lt;em&gt;参照を&lt;/em&gt;意味&lt;em&gt;します&lt;/em&gt; 。 しかし、専門用語は、プログラミング言語理論からの&lt;em&gt;参照/値によって渡され&lt;/em&gt; &lt;em&gt;、変数を保持するメモリセルへの参照&lt;/em&gt;について話している。これは、まったく異なるものです。</target>
        </trans-unit>
        <trans-unit id="189b909d14e035d9439146930c7bf76ee3ba35f1" translate="yes" xml:space="preserve">
          <source>We have another reference variable in reverseArray method (array2) that points to an array c. If we were to say</source>
          <target state="translated">reverseArrayメソッド(array2)に配列cを指す別の参照変数があります。</target>
        </trans-unit>
        <trans-unit id="df89229a206448022bc5ed3d58cbdd5121102868" translate="yes" xml:space="preserve">
          <source>What happens?</source>
          <target state="translated">どうなるの?</target>
        </trans-unit>
        <trans-unit id="2721876ca410fad542be9395684b871758604935" translate="yes" xml:space="preserve">
          <source>What is the explanation?</source>
          <target state="translated">説明はどうなっているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="c6c48753b57b8c36067f08152d304ac38b370fa1" translate="yes" xml:space="preserve">
          <source>What that means, is when you have</source>
          <target state="translated">それが何を意味するかというと、あなたが</target>
        </trans-unit>
        <trans-unit id="b82d13a18500a976024ec3aaa69437e0d2e0bcb9" translate="yes" xml:space="preserve">
          <source>When a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.</source>
          <target state="translated">メソッドがプリミティブ型パラメータを変更する場合、パラメータの変更は、呼び出し元のメソッドの元の引数値には影響しません。</target>
        </trans-unit>
        <trans-unit id="47a4b97547a431dafab08418cf4ef38d6006e62e" translate="yes" xml:space="preserve">
          <source>When it comes to objects, objects themselves cannot be passed to methods. So we pass the address of the object which is held in the reference variable.</source>
          <target state="translated">オブジェクトに関しては、オブジェクト自体をメソッドに渡すことができません。そこで、参照変数に保持されているオブジェクトのアドレスを渡します。</target>
        </trans-unit>
        <trans-unit id="42a98879de2bf7e9712995f5e8ec5b041e9c310b" translate="yes" xml:space="preserve">
          <source>When passing arguments to a method &lt;strong&gt;you ARE NOT passing the reference variable, but a copy of the bits in the reference variable&lt;/strong&gt;. Something like this: 3bad086a. 3bad086a represents a way to get to the passed object.</source>
          <target state="translated">メソッドに引数を渡すとき&lt;strong&gt;、参照変数を渡すのではなく、参照変数のビットのコピーを渡します&lt;/strong&gt; 。 このようなもの：3bad086a。 3bad086aは、渡されたオブジェクトに到達する方法を表します。</target>
        </trans-unit>
        <trans-unit id="26b0a49f4378f6ec3b7ac0d3ca02eabd027e1846" translate="yes" xml:space="preserve">
          <source>When passing reference t to the function it will not directly pass the actual reference value of object test,  but it will create a copy of t and then pass it to the function. Since it is &lt;strong&gt;passing by value&lt;/strong&gt;, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was &lt;code&gt;0x100234&lt;/code&gt;, both t and f will have the same value and hence they will point to the same object.</source>
          <target state="translated">参照tを関数に渡す場合、オブジェクトテストの実際の参照値を直接渡しませんが、tのコピーを作成してから関数に渡します。 &lt;strong&gt;値渡しな&lt;/strong&gt;ので、実際の参照ではなく、変数のコピーを渡します。 tの値が &lt;code&gt;0x100234&lt;/code&gt; であると述べたので、tとfは同じ値を持ち、したがって同じオブジェクトを指します。</target>
        </trans-unit>
        <trans-unit id="db86d10509b05e8bc49df8c7cd3d9cada5dd82ab" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables, each of the declared type, before execution of the body of
  the method or constructor.&lt;/strong&gt; The Identifier that appears in the
  DeclaratorId may be used as a simple name in the body of the method or
  constructor to refer to the formal parameter.</source>
          <target state="translated">メソッドまたはコンストラクターが呼び出されると（&amp;sect;15.12）、 &lt;strong&gt;実際の引数式の値は、メソッドまたはコンストラクターの本体の実行前に、新しく宣言された型のパラメーター変数を初期化します。&lt;/strong&gt; DeclaratorIdに表示される識別子は、メソッドまたはコンストラクターの本体で単純な名前として使用して、仮パラメーターを参照できます。</target>
        </trans-unit>
        <trans-unit id="8b67851b479dc283a6f950e2733c899590974221" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables&lt;/strong&gt;, each of the declared type, before execution of the body of
  the method or constructor.</source>
          <target state="translated">メソッドまたはコンストラクターが呼び出されると（&amp;sect;15.12）、 &lt;strong&gt;実際の引数式の値&lt;/strong&gt;は、メソッドまたはコンストラクターの本体を実行する前に、 &lt;strong&gt;新しく作成されたパラメーター変数&lt;/strong&gt; （宣言された型のそれぞれ）を&lt;strong&gt;初期化します&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d221d1e03c75efd20f3411a07f7d84f428d8be4" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the actual argument expressions initialize newly created parameter variables&lt;/strong&gt;, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;formal parameter&lt;/a&gt;.</source>
          <target state="translated">メソッドまたはコンストラクターが呼び出されると（&amp;sect;15.12）、 &lt;strong&gt;実際の引数式の値&lt;/strong&gt;は、メソッドまたはコンストラクターの本体を実行する前に、 &lt;strong&gt;新しく作成されたパラメーター変数&lt;/strong&gt; （宣言された型のそれぞれ）を&lt;strong&gt;初期化します&lt;/strong&gt; 。 DeclaratorIdに表示される識別子は、メソッドまたはコンストラクターの本体で単純な名前として使用して、 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;仮パラメーター&lt;/a&gt;を参照できます 。</target>
        </trans-unit>
        <trans-unit id="9aee34f3d95b06bea3cb4049aac2fc385dba277b" translate="yes" xml:space="preserve">
          <source>When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are against the word &quot;pointer&quot;. Whatever. Just know that the address of the object goes on the stack.</source>
          <target state="translated">オブジェクトを宣言してインスタンス化すると 実際のオブジェクトはヒープ上に行きます。スタックには何があるのでしょうか?ヒープ上のオブジェクトのアドレスです。C++のプログラマーはこれをポインタと呼ぶが、Javaの開発者の中には「ポインタ」という言葉に反対する人もいる。どうでもいいことです。ただ、オブジェクトのアドレスがスタック上にあることを知っておいてください。</target>
        </trans-unit>
        <trans-unit id="28b1f1b3dfbb6a4aedcea3dba4b14239a6b023ba" translate="yes" xml:space="preserve">
          <source>Which means, java creates a copy of the passed parameters before executing a method. Like most people who studied compilers in college, I used &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;&quot;The Dragon Book&quot;&lt;/a&gt; which is &lt;strong&gt;THE&lt;/strong&gt; compilers book. It has a good description of &quot;Call-by-value&quot; and &quot;Call-by-Reference&quot; in Chapter 1. The Call-by-value description matches up with Java Specs exactly.</source>
          <target state="translated">つまり、Javaはメソッドを実行する前に、渡されたパラメーターのコピーを作成します。 大学でコンパイラを学んだほとんどの人と同じように、私はコンパイラ&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;ブックである「ドラゴンブック」&lt;/a&gt;を使用しました。 第1章の「値による呼び出し」と「参照による呼び出し」の説明は適切です。値による呼び出しの説明は、Java仕様と完全に一致しています。</target>
        </trans-unit>
        <trans-unit id="0dcbcbf7f981b706be204f899221bd4d6394bba1" translate="yes" xml:space="preserve">
          <source>Will this throw a &lt;code&gt;NullPointerException&lt;/code&gt;? No, because it only passes a copy of the reference. 
In the case of passing by reference, it could have thrown a &lt;code&gt;NullPointerException&lt;/code&gt;, as seen below:</source>
          <target state="translated">これは &lt;code&gt;NullPointerException&lt;/code&gt; をスローしますか？ いいえ、参照のコピーのみを渡すためです。 参照渡しの場合、次のように &lt;code&gt;NullPointerException&lt;/code&gt; がスローされた可能性があります。</target>
        </trans-unit>
        <trans-unit id="a28f32f5173460812904146e506dc73421a481d8" translate="yes" xml:space="preserve">
          <source>You always pass a copy of the bits of the value of the reference!</source>
          <target state="translated">あなたは常に参照の値のビットのコピーを渡します!</target>
        </trans-unit>
        <trans-unit id="a3dc507f44237c76ec4ef1ec8e4c68370d0b3167" translate="yes" xml:space="preserve">
          <source>You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:</source>
          <target state="translated">Javaでは決して参照で渡すことはできませんが、明らかな方法の1つは、メソッド呼び出しから複数の値を返したい場合です。C++の次のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="02c7b73324c917e7dbe1ca63e76c51d7ead60641" translate="yes" xml:space="preserve">
          <source>You could also assign value of array2 in main to array1. array1 would start pointing to b.</source>
          <target state="translated">また、main の array2 の値を array1 に代入することもできます。</target>
        </trans-unit>
        <trans-unit id="6b4f593c12270cbc6715abff6481a0a796758bb7" translate="yes" xml:space="preserve">
          <source>You should note that when the parameter is an object reference, it is
  the object reference-not the object itself-that is &lt;strong&gt;passed &quot;by value&quot;&lt;/strong&gt;.</source>
          <target state="translated">パラメータがオブジェクト参照の場合、 &lt;strong&gt;「値渡し」&lt;/strong&gt;で&lt;strong&gt;渡さ&lt;/strong&gt;れるのはオブジェクト自体ではなくオブジェクト参照であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fc75d6d2c095fd5d227713114c34ed1913a0b634" translate="yes" xml:space="preserve">
          <source>You're passing the value of the reference and not the reference itself (and not the object).</source>
          <target state="translated">参照の値を渡しているのであって、参照そのものではない(オブジェクトではない)。</target>
        </trans-unit>
        <trans-unit id="e412d3eb76b9c511737b2f188cf28aa0a3b15e42" translate="yes" xml:space="preserve">
          <source>a new &lt;code&gt;Dog&lt;/code&gt; is created. Let's say he's at address 74</source>
          <target state="translated">新しい &lt;code&gt;Dog&lt;/code&gt; が作成されます。 彼が住所74にいるとしましょう</target>
        </trans-unit>
        <trans-unit id="fb3668ea3a8369fdbba52413c9d814f6e3ed4702" translate="yes" xml:space="preserve">
          <source>all bind the value of a reference to a &lt;code&gt;String&lt;/code&gt; instance to the method's newly created parameter, &lt;code&gt;param&lt;/code&gt;. This is exactly what the definition of pass-by-value describes. As such, &lt;strong&gt;Java is pass-by-value&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; インスタンスへの参照の値はすべて、メソッドの新しく作成されたパラメーター &lt;code&gt;param&lt;/code&gt; にバインドされます。 これは、正確に値渡しの定義が説明するものです。 そのため、 &lt;strong&gt;Javaは値渡しです&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c38907cfcadbaccdbfd358b9d0106488c0111a7" translate="yes" xml:space="preserve">
          <source>at line &quot;AAA&quot;</source>
          <target state="translated">行 &quot;AAA &quot;で</target>
        </trans-unit>
        <trans-unit id="f93c76dfe98a248d087f8423725428bab806588d" translate="yes" xml:space="preserve">
          <source>at line &quot;BBB&quot;</source>
          <target state="translated">行目「BBB」で</target>
        </trans-unit>
        <trans-unit id="48a51572765a96c5528d9b97e645d1cb1d8ca215" translate="yes" xml:space="preserve">
          <source>at line &quot;CCC&quot;</source>
          <target state="translated">行目「CCC」で</target>
        </trans-unit>
        <trans-unit id="5b6a04bdcab2545757147311bdd9dcec1526a1b4" translate="yes" xml:space="preserve">
          <source>edit: i believe this is also the reason to use StringBuffer when it comes to &quot;adding&quot; two Strings because you can modifie the original object which u can't with immutable objects like String is.</source>
          <target state="translated">edit:これが2つの文字列を &quot;追加 &quot;するときにStringBufferを使う理由でもあると思います。</target>
        </trans-unit>
        <trans-unit id="de6d9b079fecccb2b44d0540cd59d6982bd1a708" translate="yes" xml:space="preserve">
          <source>if the Method were defined as</source>
          <target state="translated">メソッドが以下のように定義されている場合</target>
        </trans-unit>
        <trans-unit id="c0b841e19d194bfe513d4d90839ad8c2b89afe31" translate="yes" xml:space="preserve">
          <source>in case 1. and 2. if you change Foo (&lt;code&gt;Foo = 9&lt;/code&gt;) it only affects local scope as you have a copy of the Value. From inside the method we cannot even determine where in memory the original Foo was located.</source>
          <target state="translated">ケース1.と2.でFoo（ &lt;code&gt;Foo = 9&lt;/code&gt; ）を変更すると、値のコピーがあるため、ローカルスコープにのみ影響します。 メソッドの内部からは、元のFooがメモリ内のどこにあったかさえ特定できません。</target>
        </trans-unit>
        <trans-unit id="1865b6df13986dcf11d66c36aeef32061892ca5b" translate="yes" xml:space="preserve">
          <source>in case 3. and 4. if you use default language constructs and change Foo (&lt;code&gt;Foo = 11&lt;/code&gt;), it could change Foo globally (depends on the language, ie. Java or like Pascal's &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt;&lt;strong&gt;var m&lt;/strong&gt;&lt;code&gt;: integer);&lt;/code&gt;). However if the language allows you to circumvent the dereference process, you can change &lt;code&gt;47&lt;/code&gt;, say to &lt;code&gt;49&lt;/code&gt;. At that point Foo seems to have been changed if you read it, because you have changed the &lt;strong&gt;local pointer&lt;/strong&gt; to it. And if you were to modify this Foo inside the method (&lt;code&gt;Foo = 12&lt;/code&gt;) you will probably FUBAR the execution of the program (aka. segfault) because you will write to a different memory than expected, you can even modify an area that is destined to hold executable program and writing to it will modify running code (Foo is now not at &lt;code&gt;47&lt;/code&gt;). BUT Foo's value of &lt;code&gt;47&lt;/code&gt; did not change globally, only the one inside the method, because &lt;code&gt;47&lt;/code&gt; was also a copy to the method.</source>
          <target state="translated">ケース3と4の場合。デフォルトの言語構成を使用してFoo（ &lt;code&gt;Foo = 11&lt;/code&gt; ）を変更すると、Fooがグローバルに変更される可能性があります（JavaやPascalの &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt; &lt;strong&gt;var m&lt;/strong&gt; &lt;code&gt;: integer);&lt;/code&gt; ）。 ただし、言語で間接参照プロセスを回避できる場合は、 &lt;code&gt;47&lt;/code&gt; を &lt;code&gt;49&lt;/code&gt; に変更できます。 その時点でFooを読んだ場合、Fooは&lt;strong&gt;ローカルポインター&lt;/strong&gt;を変更しているため、変更されているようです。 そして、メソッド内でこのFooを変更する場合（ &lt;code&gt;Foo = 12&lt;/code&gt; ）は、プログラム（別名segfault）の実行をFUBARするため、予想とは異なるメモリに書き込むため、宛先が指定されている領域を変更することもできます。実行可能プログラムを保持し、それに書き込むと、実行中のコードが変更されます（Fooは &lt;code&gt;47&lt;/code&gt; ではありません）。 ただし、 &lt;code&gt;47&lt;/code&gt; もメソッドのコピーであるため、Fooの値 &lt;code&gt;47&lt;/code&gt; はグローバルに変化せず、メソッド内の値のみが変化しました。</target>
        </trans-unit>
        <trans-unit id="dd97dfe75334fc4ae374b64905b80db5da6f0246" translate="yes" xml:space="preserve">
          <source>in case 5. and 6. if you modify &lt;code&gt;223&lt;/code&gt; inside the method it creates the same mayhem as in 3. or 4. (a pointer, pointing to a now bad value, that is again used as a pointer) but this is still a local problem, as 223 was &lt;strong&gt;copied&lt;/strong&gt;. However if you are able to dereference &lt;code&gt;Ref2Foo&lt;/code&gt; (that is &lt;code&gt;223&lt;/code&gt;), reach to and modify the pointed value &lt;code&gt;47&lt;/code&gt;, say, to &lt;code&gt;49&lt;/code&gt;, it will affect Foo &lt;strong&gt;globally&lt;/strong&gt;, because in this case the methods got a copy of &lt;code&gt;223&lt;/code&gt;  but the referenced &lt;code&gt;47&lt;/code&gt; exists only once, and changing that to &lt;code&gt;49&lt;/code&gt; will lead every &lt;code&gt;Ref2Foo&lt;/code&gt; double-dereferencing to a wrong value.</source>
          <target state="translated">ケース5.と6.の場合、メソッド内で &lt;code&gt;223&lt;/code&gt; を変更すると、3。または4.と同じ騒乱が発生します（ポインターは、現在は不正な値を指し、ポインターとして再び使用されます）。 223が&lt;strong&gt;コピーさ&lt;/strong&gt;れたため、ローカルの問題。 ただし、 &lt;code&gt;Ref2Foo&lt;/code&gt; （つまり &lt;code&gt;223&lt;/code&gt; ）を逆参照でき、指定された値 &lt;code&gt;47&lt;/code&gt; に到達して変更できる場合、たとえば &lt;code&gt;49&lt;/code&gt; に変更すると、Fooに&lt;strong&gt;グローバル&lt;/strong&gt;に影響します。この場合、メソッドは &lt;code&gt;223&lt;/code&gt; のコピーを取得しますが、参照される &lt;code&gt;47&lt;/code&gt; は存在するためです。一度だけ、それを &lt;code&gt;49&lt;/code&gt; に変更すると、すべての &lt;code&gt;Ref2Foo&lt;/code&gt; の二重逆参照が誤った値につながります。</target>
        </trans-unit>
        <trans-unit id="ea582fe2290fa53002694c7ca06cb1d90981b239" translate="yes" xml:space="preserve">
          <source>in reverseArray method, it will make a change in array a.</source>
          <target state="translated">reverseArrayメソッドで、配列aを変更します。</target>
        </trans-unit>
        <trans-unit id="84dd6095c9c7186e7a49f24a310118598e04da82" translate="yes" xml:space="preserve">
          <source>in reverseArray method, then the reference variable array1 in method reverseArray would stop pointing to array a and start pointing to array c (Dotted line in second image).</source>
          <target state="translated">とすると、reverseArrayメソッドの参照変数array1は配列aを指していたのをやめて、配列cを指し始めることになります(2枚目の画像の点線)。</target>
        </trans-unit>
        <trans-unit id="d97fae11a419e6a12bc3edb13062dc19c09875c0" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;not&lt;/em&gt; a Dog; it's actually a &lt;em&gt;pointer&lt;/em&gt; to a Dog.</source>
          <target state="translated">犬ではあり&lt;em&gt;ません&lt;/em&gt; 。 それは実際には犬への&lt;em&gt;ポインター&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="b39623476b2f81bd70a4ff62eb5267bce22738e1" translate="yes" xml:space="preserve">
          <source>let's look at what's happening.</source>
          <target state="translated">何が起きているのか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="cf3a9617ac647d82c56f77cf9e8ae2169d187941" translate="yes" xml:space="preserve">
          <source>name= Fido</source>
          <target state="translated">名前はFido</target>
        </trans-unit>
        <trans-unit id="dcf9d3f64bd4525093b6cb2a29ebf7e8b0769c96" translate="yes" xml:space="preserve">
          <source>name= Maxx</source>
          <target state="translated">名前=マックス</target>
        </trans-unit>
        <trans-unit id="ea4bd0e3bb9e113c03dc6f25c82ed0880ff1e2b7" translate="yes" xml:space="preserve">
          <source>output of java PassByCopy:</source>
          <target state="translated">java PassByCopyの出力。</target>
        </trans-unit>
        <trans-unit id="38b2369b273631468a9a5a2e59b5d466d9ec4e32" translate="yes" xml:space="preserve">
          <source>results in this:</source>
          <target state="translated">という結果になります。</target>
        </trans-unit>
        <trans-unit id="015c3de73f8f17655e3dba14c211482d8731c15c" translate="yes" xml:space="preserve">
          <source>someDog is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 74)</source>
          <target state="translated">someDogは、それが指す &lt;code&gt;Dog&lt;/code&gt; （アドレス74のDogオブジェクト）の後に続きます。</target>
        </trans-unit>
        <trans-unit id="e52ae0c10562272d36f12c255484e6e511e5858a" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 42) is asked to change his name to Max</source>
          <target state="translated">その &lt;code&gt;Dog&lt;/code&gt; （アドレス42にいる犬 ）は自分の名前をMaxに変更するように求められます</target>
        </trans-unit>
        <trans-unit id="7444c7540aa94d77adc3ade05581aa22935938f0" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 74) is asked to change his name to Rowlf</source>
          <target state="translated">その &lt;code&gt;Dog&lt;/code&gt; （アドレス74にいる犬 ）は名前をRowlfに変更するように求められます</target>
        </trans-unit>
        <trans-unit id="a28fea2db09c1001f61be42d428ec193c0c8fe83" translate="yes" xml:space="preserve">
          <source>the parameter &lt;code&gt;someDog&lt;/code&gt; is set to the value 42</source>
          <target state="translated">パラメータ &lt;code&gt;someDog&lt;/code&gt; は値42に設定されます</target>
        </trans-unit>
        <trans-unit id="05ed7faac6636fc4d3a902712b65ab43bb7a5b80" translate="yes" xml:space="preserve">
          <source>then, we return</source>
          <target state="translated">とすると</target>
        </trans-unit>
        <trans-unit id="49280f2d918fc694c452825a7629c4f082161d51" translate="yes" xml:space="preserve">
          <source>using methods from the object given as parameter will alter the
object as the references point to
the original objects. (if that
method itself alters some values)</source>
          <target state="translated">パラメータとして与えられたオブジェクトからメソッドを使用すると、参照が元のオブジェクトを指すようにオブジェクトを変更します。(そのメソッド自体がいくつかの値を変更する場合)</target>
        </trans-unit>
        <trans-unit id="d8b3d65782447afeffa2d99acee97cbf42b98ecf" translate="yes" xml:space="preserve">
          <source>we assign the parameter &lt;code&gt;someDog&lt;/code&gt; to 74</source>
          <target state="translated">パラメータ &lt;code&gt;someDog&lt;/code&gt; を74に割り当てます</target>
        </trans-unit>
        <trans-unit id="b5086d2ae6b0cb0d15f1111f65e03a674960103f" translate="yes" xml:space="preserve">
          <source>will print out &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; instead of &lt;code&gt;null&lt;/code&gt;. The reason this works is because &lt;code&gt;bar&lt;/code&gt; is a copy of the value of &lt;code&gt;baz&lt;/code&gt;, which is just a reference to &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt;. If it were the actual reference itself, then &lt;code&gt;foo&lt;/code&gt; would have redefined &lt;code&gt;baz&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; と印字されます &lt;code&gt;null&lt;/code&gt; の代わりに。 これが機能する理由は、 &lt;code&gt;bar&lt;/code&gt; が &lt;code&gt;baz&lt;/code&gt; の値のコピーであるためです。これは、 &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; への参照にすぎません。 。 それ自体が実際の参照である場合、 &lt;code&gt;foo&lt;/code&gt; は &lt;code&gt;baz&lt;/code&gt; を &lt;code&gt;null&lt;/code&gt; に再定義します 。</target>
        </trans-unit>
        <trans-unit id="4f07948ada1b914ebc3731995719969a1b588a36" translate="yes" xml:space="preserve">
          <source>you're essentially passing the &lt;em&gt;address&lt;/em&gt; of the created &lt;code&gt;Dog&lt;/code&gt; object to the &lt;code&gt;foo&lt;/code&gt; method.</source>
          <target state="translated">基本的に、作成した &lt;code&gt;Dog&lt;/code&gt; オブジェクトの&lt;em&gt;アドレス&lt;/em&gt;を &lt;code&gt;foo&lt;/code&gt; メソッドに渡します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
