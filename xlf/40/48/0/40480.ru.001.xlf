<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/40480">
    <body>
      <group id="40480">
        <trans-unit id="679ac82a1b80b565bd19565ec122a565572f35a9" translate="yes" xml:space="preserve">
          <source>&quot;String&quot; Objects appear to be a good &lt;strong&gt;counter-example&lt;/strong&gt; to the urban legend saying that &quot;Objects are passed by reference&quot;:</source>
          <target state="translated">&amp;laquo;Строковые&amp;raquo; объекты кажутся хорошим &lt;strong&gt;контрпримером&lt;/strong&gt; к городской легенде о том, что &amp;laquo;объекты передаются по ссылке&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="d88ecdddf8b9e6ef14e68530529dc23d4ff6b148" translate="yes" xml:space="preserve">
          <source>&quot;by value&quot; is the only way in java to pass a parameter to a method</source>
          <target state="translated">&quot;по значению&quot;-это единственный способ в java передать параметр методу.</target>
        </trans-unit>
        <trans-unit id="ac7bea48c9f3e3c013ee3b9ca43c1cd4255ba9c6" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Account account1&amp;rdquo; is the type and name of the reference variable, &amp;ldquo;=&amp;rdquo; is the assignment operator, &amp;ldquo;new&amp;rdquo; asks for the required amount of space from the system. The constructor to the right of keyword new which creates the object is called implicitly by the keyword new. Address of the created object(result of right variable, which is an expression) is assigned to the left variable (which is a reference variable with a name and a type specified) using the assign operator. &amp;ldquo;new Account()&amp;rdquo; is called &amp;ldquo;class instance creation expression&amp;rdquo;.</source>
          <target state="translated">&amp;laquo;Account account1&amp;raquo; - это тип и имя ссылочной переменной, &amp;laquo;=&amp;raquo; - оператор присваивания, &amp;laquo;new&amp;raquo; запрашивает необходимый объем пространства в системе. Конструктор справа от ключевого слова new, который создает объект, неявно вызывается ключевым словом new. Адрес созданного объекта (результат правой переменной, которая является выражением) присваивается левой переменной (которая является ссылочной переменной с указанным именем и типом) с помощью оператора assign. &amp;laquo;New Account ()&amp;raquo; называется &amp;laquo;выражением создания экземпляра класса&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="94aa2ba0bb8a675b61aef491a803f4a9834f2892" translate="yes" xml:space="preserve">
          <source>(I say essentially because Java pointers aren't direct addresses, but it's easiest to think of them that way)</source>
          <target state="translated">(Я говорю в основном потому,что Java указатели не являются прямыми адресами,но проще всего о них так думать).</target>
        </trans-unit>
        <trans-unit id="4deb5f3c7a0f51652194597de3c850eb67417a51" translate="yes" xml:space="preserve">
          <source>/**
  This 'Pass By Value has a feeling of 'Pass By Reference'</source>
          <target state="translated">/**У этого &quot;Pass By Value&quot; есть ощущение &quot;Pass By Reference&quot;.</target>
        </trans-unit>
        <trans-unit id="9aadafd84fb3481ea6953e7000de351b550c282f" translate="yes" xml:space="preserve">
          <source>/**
 * 
 * Pass By Value
 *
 */</source>
          <target state="translated">/****Pass By Value**</target>
        </trans-unit>
        <trans-unit id="2d699180ecfe5b34c3e0bc840eb47751e4372814" translate="yes" xml:space="preserve">
          <source>223 gets PUSHd to the stack.</source>
          <target state="translated">223 доставляет PUSHd в стопку.</target>
        </trans-unit>
        <trans-unit id="6446e71ace78a7a3a0a5710cd60edb392c5f7798" translate="yes" xml:space="preserve">
          <source>223 gets copied to one of the CPU registers.</source>
          <target state="translated">223 копируется в один из регистров ЦПУ.</target>
        </trans-unit>
        <trans-unit id="b89be71dff7edaa9c74d2426c943f820435958da" translate="yes" xml:space="preserve">
          <source>47 PUSHd to the stack.</source>
          <target state="translated">47 PUSHd к стопке.</target>
        </trans-unit>
        <trans-unit id="29eebea6f72ba92d2ef802d866c3af082d2c6911" translate="yes" xml:space="preserve">
          <source>47 gets copied to one of the CPU registers</source>
          <target state="translated">47 копируется в один из регистров процессора.</target>
        </trans-unit>
        <trans-unit id="35f6cb5f76dc39cccdd22e4f4ed75145651bad22" translate="yes" xml:space="preserve">
          <source>5 gets PUSHd to the stack.</source>
          <target state="translated">Пятеро доставляет PUSHd в стопку.</target>
        </trans-unit>
        <trans-unit id="bd53eeaa13917b9c1cd0ffee5c08d5548f0f975f" translate="yes" xml:space="preserve">
          <source>5 gets copied to one of the CPU registers (ie. EAX).</source>
          <target state="translated">5 копируется в один из регистров процессора (т.е.EAX).</target>
        </trans-unit>
        <trans-unit id="669fc2a12114e17f53bf6a6eea0a996b3e52e4db" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;Java is also mentioned&lt;/a&gt;. Here is the short summary:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028&quot;&gt;Ява также упоминается&lt;/a&gt; . Вот краткое резюме:</target>
        </trans-unit>
        <trans-unit id="44522a95088af6ee8afeac1924a88cbdb726d3ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a = b&lt;/code&gt; makes a new assignment to the reference &lt;code&gt;a&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;f&lt;/code&gt;, of the object whose its attribute is &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a = b&lt;/code&gt; делает новое назначение для ссылки &lt;code&gt;a&lt;/code&gt; , а &lt;strong&gt;не&lt;/strong&gt; &lt;code&gt;f&lt;/code&gt; , объекта, его атрибутом которого является &lt;code&gt;&quot;b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc8f4e638edf822f721d61b825c182734c0569b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; will change the attribute of the object that reference &lt;code&gt;c&lt;/code&gt; points to it, and it's same object that reference &lt;code&gt;f&lt;/code&gt; points to it.</source>
          <target state="translated">&lt;code&gt;c.setAttribute(&quot;c&quot;);&lt;/code&gt; изменит атрибут объекта, на который указывает ссылка &lt;code&gt;c&lt;/code&gt; , и тот же объект, на который указывает ссылка &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14cac2530311a23fb072c9ef26feba713000c665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;someDog&lt;/code&gt; is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 42)</source>
          <target state="translated">&lt;code&gt;someDog&lt;/code&gt; сопровождается &lt;code&gt;Dog&lt;/code&gt; он указывает (объект &lt;code&gt;Dog&lt;/code&gt; по адресу 42)</target>
        </trans-unit>
        <trans-unit id="1e1295aabf56bdb60aa6cdd4c585a17ef60d34fd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Did &lt;code&gt;myDog&lt;/code&gt; change?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;myDog&lt;/code&gt; изменился?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f5e57136a5902e29d33131a3a28391b65ae5a66" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Master&lt;/em&gt;: Grasshopper, No.</source>
          <target state="translated">&lt;em&gt;Мастер&lt;/em&gt; : Кузнечик, №</target>
        </trans-unit>
        <trans-unit id="b89440cba42f99210f8524ad856b1d7e2968203e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Student&lt;/em&gt;: Master, does this mean that Java is pass-by-reference?</source>
          <target state="translated">&lt;em&gt;Ученик&lt;/em&gt; : Магистр, означает ли это, что Java передается по ссылке?</target>
        </trans-unit>
        <trans-unit id="e9026cb4dbf68f5a89f59e77b991a00db2fad347" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;This value is actually COPIED and given to the method&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Это значение фактически копируется и передается методу&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="eac8606431b898a08bfa815724043bf24baea91c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A variable holds the bits that tell the JVM how to get to the referenced Object in memory (Heap).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Переменная содержит биты, которые сообщают JVM, как добраться до указанного объекта в памяти (Heap).&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee963e4f98e2321319006e78120a5c33385ffa8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All parameters to methods are passed &quot;by value&quot;&lt;/strong&gt;. In other words,
  values of parameter variables in a method are copies of the invoker
  specified as arguments.</source>
          <target state="translated">&lt;strong&gt;Все параметры в методы передаются &amp;laquo;по значению&amp;raquo;&lt;/strong&gt; . Другими словами, значения переменных параметров в методе являются копиями инициатора, указанного в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="d0c0ba2ae2424364bf0a5b15f58afb340e72d7df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ allows Pass-by-reference&lt;/strong&gt; by declaring a reference parameter using the &quot;&amp;amp;&quot; character (which happens to be the same character used to indicate &quot;the address of a variable&quot; in both C and C++). For example, if we pass in a pointer by reference, the parameter and the argument are not just pointing to the same object. Rather, they are the same variable. If one gets set to a different address or to null, so does the other.</source>
          <target state="translated">&lt;strong&gt;C ++ допускает передачу по ссылке&lt;/strong&gt; , объявляя ссылочный параметр с помощью символа &amp;laquo;&amp;amp;&amp;raquo; (который является тем же символом, который используется для обозначения &amp;laquo;адреса переменной&amp;raquo; как в C, так и в C ++). Например, если мы передаем указатель по ссылке, параметр и аргумент не просто указывают на один и тот же объект. Скорее, это одна и та же переменная. Если один из них настроен на другой адрес или на ноль, то и другой.</target>
        </trans-unit>
        <trans-unit id="250414fd453c52d7a94d41cac5720b0bf6770e9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;РЕДАКТИРОВАТЬ 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e432c6162816f0458b741aeccb3b66bf810d917a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;РЕДАКТИРОВАТЬ 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3b32f3bc0cf8e132bab93bdb849247ffeab0402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;РЕДАКТИРОВАТЬ 4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eee5a199ee48a34a0cc9134ad8533202fc7fcb52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример 1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba5182d053766559c8a796587cc6e079b0edece9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример 2:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87994c9ddef100c712273600d84d2680b1176fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример 3:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f029fd8a8bc2187006a97a36768f3a9a0f4c6825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример 4:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46619b51e67a75935bc9ceedee2a6019b4258008" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Java creates and stores objects:&lt;/strong&gt; When we create an object we store the object&amp;rsquo;s address in a reference variable. Let's analyze the following statement.</source>
          <target state="translated">&lt;strong&gt;Как Java создает и сохраняет объекты:&lt;/strong&gt; когда мы создаем объект, мы сохраняем адрес объекта в ссылочной переменной. Давайте проанализируем следующее утверждение.</target>
        </trans-unit>
        <trans-unit id="8522a877bd114b6f39cde66fbd073f0156a79129" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In Java only references are passed and are passed by value:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;В Java только ссылки передаются и передаются по значению:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fb07fd2faf3d430de82df4b1196a7157526121c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java doesn't pass method arguments by reference; it passes them by value.&lt;/strong&gt; I will use example from &lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;this site&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Java не передает аргументы метода по ссылке;&lt;/strong&gt; &lt;strong&gt;он передает их по значению.&lt;/strong&gt; Я буду использовать пример с &lt;a href=&quot;http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html&quot;&gt;этого сайта&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f8710d2de84f7d70df19d71411b10789671cf77e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is Pass-by-value&lt;/strong&gt;, but allows us to emulate pass be reference by passing a Java reference (i.e. a pointer) by value. Meaning it passes a copy of the Java reference. &lt;strong&gt;&lt;em&gt;EDIT&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;: since someone made a comment about this, let me explain. Before C, several (but not all) earlier languages like FORTRAN and COBOL supported PBR, but C did not. In order to change the values of variables inside functions, C programmers emulated PBR by passing pointers to variables into functions. Languages inspired by C, such as Java, borrowed this idea and continue to emulate PBR as C did.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Java является Pass-by-value&lt;/strong&gt; , но позволяет нам эмулировать pass be reference, передавая Java-ссылку (т.е. указатель) по значению. Это означает, что он передает копию ссылки Java. &lt;strong&gt;&lt;em&gt;РЕДАКТИРОВАТЬ&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;: так как кто-то сделал комментарий по этому поводу, позвольте мне объяснить.&lt;/em&gt; &lt;em&gt;До C некоторые (но не все) более ранние языки, такие как FORTRAN и COBOL, поддерживали PBR, но C - нет.&lt;/em&gt; &lt;em&gt;Чтобы изменить значения переменных внутри функций, программисты на C эмулировали PBR, передавая указатели на переменные в функции.&lt;/em&gt; &lt;em&gt;Языки, вдохновленные C, такие как Java, заимствовали эту идею и продолжают эмулировать PBR, как и C.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="539967da6afd5b4c7cf196939fd0d2173148d5e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java is always pass by value, not pass by reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java всегда передается по значению, а не по ссылке&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daf65d846a847f4224f37e5964ce49e033a6516e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обратите внимание, что стрелки anotherReferenceToTheSamePersonObject направлены к объекту, а не к переменной person!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82bf5f83e99ffaf8561e8e28fe3ef14c8cc29ecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;On this line 'pass-by-value' goes into the play...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;В этой строке &amp;laquo;передача по значению&amp;raquo; входит в игру ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f82acf071fee6ab2a7abd0313bbf60fe384f861" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference (also called pass by address) means that a copy of the address of the actual parameter is stored&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Передача по ссылке (также называемая передачей по адресу) означает, что копия адреса фактического параметра сохраняется&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="24f93d53f1599b4ac1080cabfb887cfff18610ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by reference&lt;/strong&gt;--There is no copy of the reference. Single reference is shared by both the caller and the function being called. Any changes to the reference or the Object's data are reflected in the caller's scope.</source>
          <target state="translated">Передача &lt;strong&gt;по ссылке&lt;/strong&gt; - Копия ссылки отсутствует. Одиночная ссылка разделяется как вызывающей, так и вызываемой функцией. Любые изменения в ссылке или данных объекта отражаются в области действия вызывающей стороны.</target>
        </trans-unit>
        <trans-unit id="a7a81b026c4fc8d49d09f4de01c114901f7c0d8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pass by value means that you are making a copy in memory of the actual parameter's value that is passed in. This is a copy of the contents of the actual parameter&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Передача по значению означает, что вы делаете копию в памяти фактического значения параметра, которое передается. Это копия содержимого фактического параметра&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5501243b5acfe1576d19283bdb0a2ab76d3504bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing a reference by value&lt;/strong&gt;--Changes to the reference are not reflected in the caller's scope, but the changes to the object are. This is because the reference is copied, but the both the original and the copy refer to the same object.</source>
          <target state="translated">&lt;strong&gt;Передача ссылки по значению -&lt;/strong&gt; Изменения в ссылке не отражаются в области видимости вызывающего, но изменения в объекте есть. Это потому, что ссылка копируется, но и оригинал, и копия ссылаются на один и тот же объект.</target>
        </trans-unit>
        <trans-unit id="d128a624743e2f0a142ea51104871088ef3baab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Result&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f28b5e99d681d23b2424be728e4d14ac53de034" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation.&lt;/strong&gt; The definition of pass-by-reference was</source>
          <target state="translated">&lt;strong&gt;Тот факт, что вы можете следовать по ссылке, чтобы вызвать метод или получить доступ к полю объекта, на который есть ссылка, совершенно не имеет отношения к беседе.&lt;/strong&gt; Определение передачи по ссылке было</target>
        </trans-unit>
        <trans-unit id="155adcfa1e1a2d90f9b1663c701b8baa445db69b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The reference values (often just references) are pointers to these objects&lt;/strong&gt;, and a special null reference, which refers to no object.</source>
          <target state="translated">&lt;strong&gt;Ссылочные значения (часто просто ссылки) являются указателями на эти объекты&lt;/strong&gt; и специальной нулевой ссылкой, которая не ссылается ни на один объект.</target>
        </trans-unit>
        <trans-unit id="c6c7f19df18b6b50e6865d7508209d9363946c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you'll just smile :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Это даст вам некоторое представление о том, как на самом деле работает Java, до такой степени, что при следующем обсуждении передачи Java по ссылке или по значению вы просто улыбнетесь :-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a57a48f1825e5c9fb8aafac2b685e4eb2761f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the value of the argument?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Какова ценность аргумента?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f32da0f05cfb43b8594e1350dffac69d7279c2e" translate="yes" xml:space="preserve">
          <source>A String Object, holds characters by an array declared &lt;strong&gt;final&lt;/strong&gt; that can't be modified.
Only the address of the Object might be replaced by another using &quot;new&quot;. 
Using &quot;new&quot; to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.</source>
          <target state="translated">String Object, содержит символы в массиве, объявленном как &lt;strong&gt;final,&lt;/strong&gt; который нельзя изменить. Только адрес объекта может быть заменен другим, используя &amp;laquo;новый&amp;raquo;. Использование &amp;laquo;new&amp;raquo; для обновления переменной не позволит получить доступ к объекту извне, поскольку переменная изначально была передана по значению и скопирована.</target>
        </trans-unit>
        <trans-unit id="5cadb13ab1a3063435130babe3e0bd30a1122a5f" translate="yes" xml:space="preserve">
          <source>A few points:</source>
          <target state="translated">Несколько пунктов:</target>
        </trans-unit>
        <trans-unit id="a6487d11fc0e1086219982c44902ad61a1998227" translate="yes" xml:space="preserve">
          <source>A method local variable -&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;- is created and then comes the magic in line #6:</source>
          <target state="translated">Локальная переменная метода - &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; - создается, а затем появляется волшебство в строке # 6:</target>
        </trans-unit>
        <trans-unit id="939671d12f121c636331468aedcb607655b0467d" translate="yes" xml:space="preserve">
          <source>A new Person Object is created in line #2, stored in memory, and the variable &lt;em&gt;person&lt;/em&gt; is given the reference to the Person object. That is, its address. Let's say 3bad086a.</source>
          <target state="translated">Новый объект Person создается в строке # 2, сохраняется в памяти, а переменной &lt;em&gt;person&lt;/em&gt; дается ссылка на объект Person. То есть его адрес. Допустим, 3bad086a.</target>
        </trans-unit>
        <trans-unit id="6cb5cc922e3e7afc89e697c3a55b40eccd85c7e8" translate="yes" xml:space="preserve">
          <source>A picture is worth a thousand words:</source>
          <target state="translated">Картина стоит тысячи слов:</target>
        </trans-unit>
        <trans-unit id="7890ee11943cdb236a4c3b5ce7b9f732f716679f" translate="yes" xml:space="preserve">
          <source>A reference is always a value when represented, no matter what language you use.</source>
          <target state="translated">Ссылка-это всегда значение,когда она представлена,независимо от того,какой язык вы используете.</target>
        </trans-unit>
        <trans-unit id="9f8832ae6457f58e3904c76f8d5c2aa49f842301" translate="yes" xml:space="preserve">
          <source>After: a = 2, b = 3</source>
          <target state="translated">После:a=2,b=3</target>
        </trans-unit>
        <trans-unit id="ec423d5a41945c4f52f7be0ea48ac07e83fd86ae" translate="yes" xml:space="preserve">
          <source>Although an object&amp;rsquo;s reference is passed by value, a method can still interact with the referenced object by calling its public methods using the copy of the object&amp;rsquo;s reference. Since the reference stored in the parameter is a copy of the reference that was passed as an argument, the parameter in the called method and the argument in the calling method refer to the same object in memory.</source>
          <target state="translated">Хотя ссылка на объект передается по значению, метод все же может взаимодействовать с указанным объектом, вызывая его открытые методы, используя копию ссылки на объект. Поскольку ссылка, сохраненная в параметре, является копией ссылки, переданной в качестве аргумента, параметр в вызываемом методе и аргумент в вызывающем методе ссылаются на один и тот же объект в памяти.</target>
        </trans-unit>
        <trans-unit id="b65974e5bb87a60e0a3ebacd86b70b176a71aea4" translate="yes" xml:space="preserve">
          <source>An array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.</source>
          <target state="translated">Массив-это объект,поэтому он также попадает в кучу.А как же объекты в массиве? Они получают собственное пространство кучи,и адрес каждого объекта попадает внутрь массива.</target>
        </trans-unit>
        <trans-unit id="9bf2ce1dceef2dc96a821885bc168afbf5d4d9a1" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;on the subject of pass-by-value&lt;/a&gt;</source>
          <target state="translated">И &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_value#Call_by_value&quot;&gt;на предмет передачи по стоимости&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="753dfa9513c7de7c01e5a4ee8e20f57993151233" translate="yes" xml:space="preserve">
          <source>And now that reverseArray method is over, its reference variables(array1 and array2) are gone. Which means we now only have the two reference variables in main method array1 and array2 which point to c and b arrays respectively. No reference variable is pointing to object (array) a. So it is eligible for garbage collection.</source>
          <target state="translated">И теперь,когда метод reverseArray закончен,его ссылочные переменные (array1 и array2)исчезли.То есть теперь в массиве главного метода array1 и массиве array2 есть только две ссылочные переменные,которые указывают на массивы c и b соответственно.Ни одна из ссылочных переменных не указывает на объект (массив)a.Значит,она пригодна для сбора мусора.</target>
        </trans-unit>
        <trans-unit id="1427090bc2dee2db920c7dcba2e93785a6f9fced" translate="yes" xml:space="preserve">
          <source>And towards the end of the same section he makes a broader statement about java being only pass by value and never pass by reference.</source>
          <target state="translated">А в конце того же раздела он делает более широкое заявление о том,что java проходит только по значению и никогда не проходит по ссылке.</target>
        </trans-unit>
        <trans-unit id="7ccd274eb97af58443d0d98f31f8165d44df954a" translate="yes" xml:space="preserve">
          <source>Anyway, I noticed a comment by &lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;dhackner&lt;/a&gt; in an older post, who made a balloon analogy which I really liked. So much so that I decided to glue together some clip-art to make a set of cartoons to illustrate the point.</source>
          <target state="translated">Во всяком случае, я заметил комментарий &lt;a href=&quot;https://stackoverflow.com/users/208457/dhackner&quot;&gt;Дхакнера&lt;/a&gt; в старом посте, который сделал аналогию с воздушным шаром, которая мне очень понравилась. Настолько, что я решил склеить несколько клипов, чтобы сделать набор мультфильмов, чтобы проиллюстрировать это.</target>
        </trans-unit>
        <trans-unit id="7a6f63a9fa8ba00d31fa864a81af348461e2059d" translate="yes" xml:space="preserve">
          <source>As expected output will be:</source>
          <target state="translated">Как и ожидалось,результат будет:</target>
        </trans-unit>
        <trans-unit id="9e95da2bd7af315b2113d39a70608c332bc48d91" translate="yes" xml:space="preserve">
          <source>As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:</source>
          <target state="translated">Насколько я знаю,Ява знает звонок только по значению.Это означает,что для примитивных типов данных вы будете работать с копией,а для объектов-с копией ссылки на объекты.Однако я думаю,что есть некоторые подводные камни;например,это не сработает:</target>
        </trans-unit>
        <trans-unit id="d05f320102345bc58ddfdf1478a148fed340e361" translate="yes" xml:space="preserve">
          <source>As many people mentioned it before, &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Java is always pass-by-value&lt;/a&gt;</source>
          <target state="translated">Как уже упоминали многие люди, &lt;a href=&quot;http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm&quot;&gt;Java всегда передается по значению&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd4f600b4ca0e57b260d865e338eb632ae21d0de" translate="yes" xml:space="preserve">
          <source>As was explained in previous answers, in Java you're passing a pointer to the array as a value into &lt;code&gt;getValues&lt;/code&gt;. That is enough, because the method then modifies the array element, and by convention you're expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn't necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.</source>
          <target state="translated">Как было объяснено в предыдущих ответах, в Java вы передаете указатель на массив как значение в &lt;code&gt;getValues&lt;/code&gt; . Этого достаточно, потому что метод затем модифицирует элемент массива, и по соглашению вы ожидаете, что элемент 0 будет содержать возвращаемое значение. Очевидно, что вы можете сделать это другими способами, такими как структурирование вашего кода, так что в этом нет необходимости, или создание класса, который может содержать возвращаемое значение или разрешить его установку. Но простой шаблон, доступный вам в C ++ выше, недоступен в Java.</target>
        </trans-unit>
        <trans-unit id="8d7366694d78adcdb573e21740168952ff60eb6a" translate="yes" xml:space="preserve">
          <source>As we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is &lt;code&gt;0x100234&lt;/code&gt; (we don't know the actual JVM internal value, this is just an example) .</source>
          <target state="translated">Как мы все знаем, он создаст объект в куче и вернет значение ссылки обратно в t. Например, предположим, что значение t равно &lt;code&gt;0x100234&lt;/code&gt; (мы не знаем фактическое внутреннее значение JVM, это только пример).</target>
        </trans-unit>
        <trans-unit id="430da7a13966f26ff5a4c5e2f81b52ff90b0253b" translate="yes" xml:space="preserve">
          <source>As you call &lt;code&gt;modifyReference(Foo c)&lt;/code&gt; method, a reference &lt;code&gt;c&lt;/code&gt; is created and assigned the object with attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">Когда вы вызываете &lt;code&gt;modifyReference(Foo c)&lt;/code&gt; , создается ссылка &lt;code&gt;c&lt;/code&gt; , которой назначается объект с атрибутом &lt;code&gt;&quot;f&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa285e6edfa6d99016592271e8d0555fae43569f" translate="yes" xml:space="preserve">
          <source>As you call the method &lt;code&gt;changeReference&lt;/code&gt;, the reference &lt;code&gt;a&lt;/code&gt; will be assigned the object which is passed as an argument.</source>
          <target state="translated">Когда вы вызываете метод &lt;code&gt;changeReference&lt;/code&gt; , ссылке &lt;code&gt;a&lt;/code&gt; будет присвоен объект, который передается в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="108085f3bb0f4209a639200317b9f008aaf21dab" translate="yes" xml:space="preserve">
          <source>Back when I studied compilers-in the 90's, I used the first edition of the book from 1986 which pre-dated Java by about 9 or 10 years. However, I just ran across a copy of the &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;2nd Eddition&lt;/a&gt; from 2007 &lt;strong&gt;which actually mentions Java!&lt;/strong&gt; Section 1.6.6 labeled &quot;Parameter Passing Mechanisms&quot; describes parameter passing pretty nicely. Here is an excerpt under the heading &quot;Call-by-value&quot; which mentions Java:</source>
          <target state="translated">Еще в 90-е годы, когда я изучал компиляторы, я использовал первое издание книги 1986 года, которое предшествовало Java примерно на 9 или 10 лет. Тем не менее, я только что натолкнулся на копию 2- &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/B009TGD06W&quot;&gt;го Eddition&lt;/a&gt; от 2007 года, в &lt;strong&gt;которой фактически упоминается Java!&lt;/strong&gt; Раздел 1.6.6, озаглавленный &amp;laquo;Механизмы передачи параметров&amp;raquo;, описывает передачу параметров довольно красиво. Вот выдержка под заголовком &amp;laquo;Call-by-value&amp;raquo;, в которой упоминается Java:</target>
        </trans-unit>
        <trans-unit id="2a5566bd96317aa68aedfcd4ec8973cfbf92a199" translate="yes" xml:space="preserve">
          <source>Basically, reassigning Object parameters doesn't affect the argument, e.g.,</source>
          <target state="translated">В принципе,переназначение параметров объекта не влияет на аргумент,например,</target>
        </trans-unit>
        <trans-unit id="1b0434b117ced506f4e292880cee2d016b9caf22" translate="yes" xml:space="preserve">
          <source>Before: a = 2, b = 3</source>
          <target state="translated">До:a=2,b=3</target>
        </trans-unit>
        <trans-unit id="687e81922c00310f84049051118a03dc31fabaae" translate="yes" xml:space="preserve">
          <source>Both &quot;&lt;em&gt;person&lt;/em&gt;&quot; and &quot;&lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt;&quot; hold the same value of 3bad086a.</source>
          <target state="translated">И &quot; &lt;em&gt;person&lt;/em&gt; &quot;, и &quot; &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; &quot; содержат одно и то же значение 3bad086a.</target>
        </trans-unit>
        <trans-unit id="2689caac6d3ec6ddc37d1cac015f4e8ae4e22c88" translate="yes" xml:space="preserve">
          <source>Both variables have IDENTICAL COPIES of the reference and they both refer to the same Person Object, the SAME Object on the Heap and NOT A COPY.</source>
          <target state="translated">Обе переменные имеют ИДЕНТИЧЕСКИЕ КОПИИ ссылки,и обе они относятся к одному и тому же Объекту Человека,Объекту SAME на куче и НЕ КОПИИ.</target>
        </trans-unit>
        <trans-unit id="e9170e035719274989ed5cf55b194f253b0ee3eb" translate="yes" xml:space="preserve">
          <source>But from this example, we can understand that it is infact pass by value only,
  keeping in mind that here we are passing the reference as the value.
  ie: reference is passed by value.
  That's why are able to change and still it holds true after the local scope.
  But we cannot change the actual reference outside the original scope.
  what that means is demonstrated by next example of PassByValueObjectCase2.</source>
          <target state="translated">Но из этого примера можно понять,что речь идет только о воздействии,передаваемом по значению,имея в виду,что здесь в качестве значения передается ссылка,т.е.ссылка передается по значению.Поэтому она может изменяться и остается верной после локального диапазона.Но мы не можем изменить реальную ссылку за пределами оригинальной области видимости.что это значит,демонстрирует следующий пример PassByValueObjectCase2.</target>
        </trans-unit>
        <trans-unit id="006ecf4b1a9cc9edb60404b2fb553d2bccdff314" translate="yes" xml:space="preserve">
          <source>C++ pass by reference example:</source>
          <target state="translated">С++проходит по ссылке:</target>
        </trans-unit>
        <trans-unit id="83514ce69e30402f75b91daf4e42e15d62db4d49" translate="yes" xml:space="preserve">
          <source>Check the comment on line #5</source>
          <target state="translated">Проверьте комментарий на строке #5</target>
        </trans-unit>
        <trans-unit id="ce636731102296dcc967f8d443bba701fa39128c" translate="yes" xml:space="preserve">
          <source>Crash course on stack/heap before we get to the Java implementation:
Values go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria.
Memory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.</source>
          <target state="translated">Крэш-курс на стековой куче,прежде чем мы доберемся до реализации Java:Ценности идут по стопке в хорошем порядке,как стопка тарелок в кафетерии.Память в куче (также известная как динамическая память)бессистемна и неорганизована.JVM просто находит место везде,где он может,и освобождает его как переменные,которые используют его больше не нужны.</target>
        </trans-unit>
        <trans-unit id="9a4330ec3ed061c85b3e0b082e1656ec35e5d3df" translate="yes" xml:space="preserve">
          <source>Creates new Point object</source>
          <target state="translated">Создает новый объект Точка</target>
        </trans-unit>
        <trans-unit id="1926dd5e7c03bbf781269e3b1f10a918298da01a" translate="yes" xml:space="preserve">
          <source>Creates new Point reference and initialize that reference to &lt;em&gt;point (refer to)&lt;/em&gt; on previously created Point object.</source>
          <target state="translated">Создает новую ссылку на точку и инициализирует эту ссылку на &lt;em&gt;точку (&lt;/em&gt; ссылку &lt;em&gt;)&lt;/em&gt; на ранее созданный объект Point.</target>
        </trans-unit>
        <trans-unit id="91a5cb67c9d537c081e9f8cf1bbc2d3e758ce171" translate="yes" xml:space="preserve">
          <source>Creating two different Point object with two different reference associated.</source>
          <target state="translated">Создание двух разных объектов Точка с двумя разными ссылками,связанными.</target>
        </trans-unit>
        <trans-unit id="b0dda1bfba52f041403c7023d96d1d341ad3c077" translate="yes" xml:space="preserve">
          <source>Data in memory has a &lt;strong&gt;Location&lt;/strong&gt; and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a &lt;strong&gt;Name&lt;/strong&gt; to certain &lt;strong&gt;Location&lt;/strong&gt; (aka variable), but when compiling the code, the assembler simply replaces &lt;strong&gt;Name&lt;/strong&gt; with the designated location just like your browser replaces domain names with IP addresses.</source>
          <target state="translated">Данные в памяти имеют &lt;strong&gt;местоположение,&lt;/strong&gt; и в этом месте есть значение (байт, слово, что угодно). В Assembly у нас есть удобное решение для присвоения &lt;strong&gt;имени&lt;/strong&gt; определенному &lt;strong&gt;местоположению&lt;/strong&gt; (иначе называемой переменной), но при компиляции кода ассемблер просто заменяет &lt;strong&gt;имя&lt;/strong&gt; указанным местоположением, подобно тому, как ваш браузер заменяет доменные имена на IP-адреса.</target>
        </trans-unit>
        <trans-unit id="bfb16cd1cd030c8e69601029c768549e17aa7047" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">Объявление ссылки с именем &lt;code&gt;b&lt;/code&gt; типа &lt;code&gt;Foo&lt;/code&gt; и присвоение ей нового объекта типа &lt;code&gt;Foo&lt;/code&gt; с атрибутом &lt;code&gt;&quot;b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb0f2661240daa3e654c2b942a4228aef7a6a44" translate="yes" xml:space="preserve">
          <source>Declaring a reference named &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt; and assign it a new object of type &lt;code&gt;Foo&lt;/code&gt; with an attribute &lt;code&gt;&quot;f&quot;&lt;/code&gt;.</source>
          <target state="translated">Объявление ссылки с именем &lt;code&gt;f&lt;/code&gt; типа &lt;code&gt;Foo&lt;/code&gt; и присвоение ей нового объекта типа &lt;code&gt;Foo&lt;/code&gt; с атрибутом &lt;code&gt;&quot;f&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd9950fdb8d7858353a3702108602c9648dd0e68" translate="yes" xml:space="preserve">
          <source>Does this sound strange and confusing? Let's consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. &lt;code&gt;void foo(int x)&lt;/code&gt; passes an int by value. &lt;code&gt;void foo(int *x)&lt;/code&gt; is a function that does not want an &lt;code&gt;int a&lt;/code&gt;, but a pointer to an int: &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt;. One would use this with the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to pass a variable address.</source>
          <target state="translated">Это звучит странно и сбивает с толку? Давайте рассмотрим, как C реализует передачу по ссылке и передачу по значению. В С соглашением по умолчанию является передача по значению. &lt;code&gt;void foo(int x)&lt;/code&gt; передает int по значению. &lt;code&gt;void foo(int *x)&lt;/code&gt; - это функция, которая не хочет &lt;code&gt;int a&lt;/code&gt; , но указывает на int: &lt;code&gt;foo(&amp;amp;a)&lt;/code&gt; . Можно использовать это с оператором &lt;code&gt;&amp;amp;&lt;/code&gt; для передачи адреса переменной.</target>
        </trans-unit>
        <trans-unit id="b5854bdd57360320e24b9397418a212d3b8b3fc1" translate="yes" xml:space="preserve">
          <source>Don't try this but person==anotherReferenceToTheSamePersonObject would be true.</source>
          <target state="translated">Не пытайтесь,но человек==anotherReferenceToTheSamePersonObject будет правдой.</target>
        </trans-unit>
        <trans-unit id="207ba28fc5d0fc3ff8e2b02914c001bb5bb368b5" translate="yes" xml:space="preserve">
          <source>Down to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).</source>
          <target state="translated">Вниз по ядру технически невозможно передать ссылку на что-либо на любом языке,не представив ее (когда она сразу становится значением).</target>
        </trans-unit>
        <trans-unit id="438f74e42d1fb68f2c51553f32173992bba966c9" translate="yes" xml:space="preserve">
          <source>First of all, we need to understand what pass by value and pass by reference are.</source>
          <target state="translated">Прежде всего,нам нужно понять,что такое передача по значению и передача по ссылке.</target>
        </trans-unit>
        <trans-unit id="9e5aff39fe5953d4740386d14bbfaa42a906a8b9" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;What's the difference between passing by reference vs. passing by value?&lt;/a&gt;</source>
          <target state="translated">Во-первых, в &lt;a href=&quot;https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value&quot;&gt;чем разница между передачей по ссылке и передачей по значению?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e0065a83f42a57a3911225215a70e9b907a2bbc" translate="yes" xml:space="preserve">
          <source>Flow of the program:</source>
          <target state="translated">Поток программы:</target>
        </trans-unit>
        <trans-unit id="0dfdb0b2fd7037984e97ec60ea513d8d5b9e3dd0" translate="yes" xml:space="preserve">
          <source>For objects, the pass by value is the value of &lt;em&gt;the reference to the object&lt;/em&gt;.</source>
          <target state="translated">Для объектов передача по значению является значением &lt;em&gt;ссылки на объект&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5c00717c1eeb06ca14fc62309936f50e756db581" translate="yes" xml:space="preserve">
          <source>For primitive arguments (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, etc.), the pass by value is &lt;em&gt;the actual value&lt;/em&gt; of the primitive (for example, 3).</source>
          <target state="translated">Для аргументов примитива ( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; и т. Д.) Передача по значению является &lt;em&gt;фактическим значением&lt;/em&gt; примитива (например, 3).</target>
        </trans-unit>
        <trans-unit id="d717d5e3b868b30355b36493393d4dedba688590" translate="yes" xml:space="preserve">
          <source>From here scope of &lt;code&gt;tricky&lt;/code&gt; method is gone and you don't have access any more to the references: &lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, &lt;code&gt;temp&lt;/code&gt;. &lt;strong&gt;But important note is that everything you do with these references when they are 'in life' will permanently affect object on which they are &lt;em&gt;point&lt;/em&gt; to.&lt;/strong&gt;</source>
          <target state="translated">Отсюда исчезает &lt;code&gt;tricky&lt;/code&gt; метод, и у вас больше нет доступа к ссылкам: &lt;code&gt;arg1&lt;/code&gt; , &lt;code&gt;arg2&lt;/code&gt; , &lt;code&gt;temp&lt;/code&gt; . &lt;strong&gt;Но важно отметить, что все, что вы делаете с этими ссылками, когда они &amp;laquo;в жизни&amp;raquo;, будет постоянно влиять на объект, на который они &lt;em&gt;указывают&lt;/em&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ee364d2560bc79a19a4c72624692c7755f4443f" translate="yes" xml:space="preserve">
          <source>From here, through Point object life, you will access to that object through pnt1
 reference. So we can say that in Java you manipulate object through its reference.</source>
          <target state="translated">Отсюда,через Point object life,вы получите доступ к этому объекту через ссылку pnt1.Так что можно сказать,что в Java вы манипулируете объектом через его ссылку.</target>
        </trans-unit>
        <trans-unit id="2c8076e66b55ab8aeac61f85404367064fccd996" translate="yes" xml:space="preserve">
          <source>From the method side, a reference of type &lt;code&gt;Foo&lt;/code&gt; with a name &lt;code&gt;a&lt;/code&gt; is declared and it's initially assigned &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Со стороны метода объявляется ссылка типа &lt;code&gt;Foo&lt;/code&gt; с именем &lt;code&gt;a&lt;/code&gt; , и ей изначально присваивается значение &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb62bec2c3a15680c7c08a655906f2b1d75ef3f" translate="yes" xml:space="preserve">
          <source>Getting an outside of the box view, let's look at Assembly or some low level memory management. At the CPU level a &lt;em&gt;reference&lt;/em&gt; to anything immediately becomes a &lt;em&gt;value&lt;/em&gt; if it gets written to memory or to one of the CPU registers. (That is why &lt;em&gt;pointer&lt;/em&gt; is a good definition. It is a value, which has a purpose at the same time).</source>
          <target state="translated">Получив внешний вид коробки, давайте посмотрим на сборку или некоторое низкоуровневое управление памятью. На уровне ЦП &lt;em&gt;ссылка&lt;/em&gt; на что-либо сразу становится &lt;em&gt;значением,&lt;/em&gt; если оно записывается в память или в один из регистров ЦП. (Вот почему &lt;em&gt;указатель&lt;/em&gt; является хорошим определением. Это значение, которое одновременно имеет цель).</target>
        </trans-unit>
        <trans-unit id="a09f4f73a25672b2d71176498d77cdaf4f9d5f33" translate="yes" xml:space="preserve">
          <source>He goes on to make the same point regarding objects . . .</source>
          <target state="translated">Далее он делает то же самое в отношении объектов ...</target>
        </trans-unit>
        <trans-unit id="dcab7f73c798d9959b167db93301f1b793cb10fc" translate="yes" xml:space="preserve">
          <source>Here is another example that will help you understand the difference (&lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;the classic swap example&lt;/a&gt;):</source>
          <target state="translated">Вот еще один пример, который поможет вам понять разницу ( &lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;классический пример обмена&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="095229be47d5e504de9b8c6e3f105270472a7db4" translate="yes" xml:space="preserve">
          <source>Here, you first create new &lt;code&gt;temp&lt;/code&gt; Point reference which will &lt;em&gt;point&lt;/em&gt; on same place like &lt;code&gt;arg1&lt;/code&gt; reference. Then you move reference &lt;code&gt;arg1&lt;/code&gt; to &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;arg2&lt;/code&gt; reference.
Finally &lt;code&gt;arg2&lt;/code&gt; will &lt;em&gt;point&lt;/em&gt; to the same place like &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">Здесь вы сначала создаете новую &lt;code&gt;temp&lt;/code&gt; ссылку Point, которая будет &lt;em&gt;указывать&lt;/em&gt; на то же место, что и ссылка &lt;code&gt;arg1&lt;/code&gt; . Затем вы перемещаете ссылку &lt;code&gt;arg1&lt;/code&gt; так, чтобы она &lt;em&gt;указывала&lt;/em&gt; на то же место, что и ссылка &lt;code&gt;arg2&lt;/code&gt; . Наконец, &lt;code&gt;arg2&lt;/code&gt; будет &lt;em&gt;указывать&lt;/em&gt; на то же место, что и &lt;code&gt;temp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64169e4a61bae86f469a92b3cfc4bae9c3a53858" translate="yes" xml:space="preserve">
          <source>Hopefully this will help.</source>
          <target state="translated">Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">Как это работает</target>
        </trans-unit>
        <trans-unit id="e5beaeff3bbae8257639b2987a7f67bd9d85c384" translate="yes" xml:space="preserve">
          <source>However you could make a wrapper for String like this which would make it able to use it with Strings:</source>
          <target state="translated">Однако вы можете сделать такую обертку для String,которая позволит использовать ее со Strings:</target>
        </trans-unit>
        <trans-unit id="26dd9ac7a210ba6a96d874cf5c6e8374ed5dbcf2" translate="yes" xml:space="preserve">
          <source>However, I've seen a couple of blog posts (for example, &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;this blog&lt;/a&gt;) that claim that it isn't.</source>
          <target state="translated">Тем не менее, я видел пару постов в блоге (например, &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;этот блог&lt;/a&gt; ), которые утверждают, что это не так.</target>
        </trans-unit>
        <trans-unit id="ec1be69fa319cc52b285a8bee8c6a7f04ee9e1f8" translate="yes" xml:space="preserve">
          <source>I always think of it as &quot;pass by copy&quot;. It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.</source>
          <target state="translated">Я всегда думаю об этом,как о &quot;мимо копии&quot;.Это копия значения,будь то примитивное или ссылочное.Если это примитив,то это копия битов,которые являются значением,а если это Объект,то это копия ссылки.</target>
        </trans-unit>
        <trans-unit id="69f13178ffc91e81d12909e0fab0a089bbad804f" translate="yes" xml:space="preserve">
          <source>I always thought Java was &lt;strong&gt;pass-by-reference&lt;/strong&gt;.</source>
          <target state="translated">Я всегда думал, что Java была &lt;strong&gt;по ссылке&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="efd75827ae1611bf4e22af1ec1d50ca7541b3557" translate="yes" xml:space="preserve">
          <source>I can't believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term &lt;em&gt;call by sharing&lt;/em&gt; (also known as &lt;em&gt;call by object-sharing&lt;/em&gt; and &lt;em&gt;call by object&lt;/em&gt;) for this specific case of &quot;call by value where the value is a reference&quot;.</source>
          <target state="translated">Я не могу поверить, что никто еще не упомянул Барбару Лисков. Когда она разработала CLU в 1974 году, она столкнулась с той же проблемой терминологии, и она изобрела термин &lt;em&gt;вызов путем разделения&lt;/em&gt; (также известный как &lt;em&gt;вызов посредством совместного использования объекта&lt;/em&gt; и &lt;em&gt;вызов по объекту&lt;/em&gt; ) для этого конкретного случая &amp;laquo;вызов по значению, где значение равно ссылка&quot;.</target>
        </trans-unit>
        <trans-unit id="aeaec84d031aa5cb38d5557cf7de3f76bf7cafb0" translate="yes" xml:space="preserve">
          <source>I don't think I understand the distinction they're making.</source>
          <target state="translated">Не думаю,что понимаю,как они различают.</target>
        </trans-unit>
        <trans-unit id="d5405762999d453eb212ccf6bcc5f6125f900230" translate="yes" xml:space="preserve">
          <source>I feel like arguing about &quot;pass-by-reference vs pass-by-value&quot; is not super-helpful.</source>
          <target state="translated">Мне кажется,что спорить о &quot;pass-by-reference vs pass-by-value&quot; не очень-то полезно.</target>
        </trans-unit>
        <trans-unit id="da328c30116bfb1c498c3407693d22ba90f3115c" translate="yes" xml:space="preserve">
          <source>I have created a thread devoted to these kind of questions for &lt;em&gt;any&lt;/em&gt; programming languages &lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Я создал ветку, посвященную этим вопросам для &lt;em&gt;любых&lt;/em&gt; языков программирования &lt;a href=&quot;https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be8f8168e2402a238a9976383c81f993f3a3e74e" translate="yes" xml:space="preserve">
          <source>I have seen posts on this topic which describe the low level implementation of parameter passing in Java, which I think is great and very helpful because it makes an abstract idea concrete. However, to me the question is more about &lt;strong&gt;the behavior described in the language specification&lt;/strong&gt; than about the technical implementation of the behavior. This is an exerpt from the &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification, section 8.4.1&lt;/a&gt; :</source>
          <target state="translated">Я видел посты на эту тему, которые описывают низкоуровневую реализацию передачи параметров в Java, что я считаю замечательным и очень полезным, потому что оно делает абстрактную идею конкретной. Однако для меня вопрос скорее &lt;strong&gt;в поведении, описанном в спецификации языка,&lt;/strong&gt; чем в технической реализации поведения. Это выдержка из &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;спецификации языка Java, раздел 8.4.1&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb7305997ab86247b2a49056cbf4e89230b9f222" translate="yes" xml:space="preserve">
          <source>I hope this settles the debate, but probably won't.</source>
          <target state="translated">Надеюсь,это уладит дебаты,но,скорее всего,не уладит.</target>
        </trans-unit>
        <trans-unit id="d415e610e2056093f16e0b12b5086931ca855762" translate="yes" xml:space="preserve">
          <source>I hope you understand now how passing objects as arguments works in Java :)</source>
          <target state="translated">Надеюсь,теперь вы понимаете,как работает передача объектов в качестве аргументов в Java :)</target>
        </trans-unit>
        <trans-unit id="53b25f35c0f07624c3ab774845793894e9df085c" translate="yes" xml:space="preserve">
          <source>I just noticed you referenced &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;my article&lt;/a&gt;.</source>
          <target state="translated">Я только заметил, что вы ссылались на &lt;a href=&quot;http://javadude.com/articles/passbyvalue.htm&quot;&gt;мою статью&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2935658c6ca5dd052a7a1348a0e9a0f71fe8584b" translate="yes" xml:space="preserve">
          <source>I might be a little obsessed with this post. Probably because I feel that the makers of Java inadvertently spread misinformation. If instead of using the word &quot;reference&quot; for pointers they had used something else, say 
dingleberry, there would've been no problem. You could say, &quot;Java passes dingleberries by value and not by reference&quot;, and nobody would be confused. (Hence forth, when referencing pass by reference vs value, I shall refer to references as dinglebarries.)</source>
          <target state="translated">Возможно,я немного одержим этим постом.Наверное,потому,что я чувствую,что создатели Java непреднамеренно распространяют дезинформацию.Если бы вместо слова &quot;ссылка&quot; для указателей они использовали что-то другое,скажем,бруснику,то не было бы никаких проблем.Можно было бы сказать:&quot;Java передает бруснику по значению,а не по ссылке&quot;,и никто бы не запутался.(Следовательно,вчетвером,при ссылке на передачу по ссылке против значения,я буду ссылаться на ссылки как на бруснику).</target>
        </trans-unit>
        <trans-unit id="dbf80c5168a8cdece318ecb980f6dc4582312bc0" translate="yes" xml:space="preserve">
          <source>I think the difference between the two models is very subtle and unless you've done programming where you actually used pass-by-reference, it's easy to miss where two models differ.</source>
          <target state="translated">Я думаю,что разница между двумя моделями очень тонкая,и если вы не занимались программированием там,где вы на самом деле использовали передачу по ссылке,то легко пропустить то,где две модели отличаются друг от друга.</target>
        </trans-unit>
        <trans-unit id="051719f18cca69c8321cf2db575cbe7c3c8fc918" translate="yes" xml:space="preserve">
          <source>I thought I'd contribute this answer to add more details from the Specifications.</source>
          <target state="translated">Я решил внести этот ответ,чтобы добавить больше подробностей из Спецификации.</target>
        </trans-unit>
        <trans-unit id="02668452fdc578abe59e37b1d267b95f2c167d43" translate="yes" xml:space="preserve">
          <source>I will explain this in steps:</source>
          <target state="translated">Я объясню это пошагово:</target>
        </trans-unit>
        <trans-unit id="7e24c4c25b98f1916d4e52df7af6eeb891b2b203" translate="yes" xml:space="preserve">
          <source>If Java had pass-by-reference semantics, the &lt;code&gt;foo&lt;/code&gt; method we defined above would have changed where &lt;code&gt;myDog&lt;/code&gt; was pointing when it assigned &lt;code&gt;someDog&lt;/code&gt; on line BBB.</source>
          <target state="translated">Если бы у Java была семантика передачи по ссылке, то определенный выше метод &lt;code&gt;foo&lt;/code&gt; изменился бы там, куда указывал &lt;code&gt;myDog&lt;/code&gt; , когда он назначил &lt;code&gt;someDog&lt;/code&gt; в строке BBB.</target>
        </trans-unit>
        <trans-unit id="6697d56d6fde5f640c216d07a963f93b03bd1f54" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits contain the value of the primitive data type itself, That's why if we change the value of header inside the method then it does not reflect the changes outside.</source>
          <target state="translated">Если это примитивный тип данных,то эти биты содержат значение самого примитивного типа данных,поэтому если внутри метода изменить значение заголовка,то оно не отражает изменения снаружи.</target>
        </trans-unit>
        <trans-unit id="79742ec00dad7a7b993ddfde20c405582b74811d" translate="yes" xml:space="preserve">
          <source>If it's a primitive data type these bits will contain the value of the primitive data type itself.</source>
          <target state="translated">Если это примитивный тип данных,то эти биты будут содержать значение самого примитивного типа данных.</target>
        </trans-unit>
        <trans-unit id="f0283f6b09b05e1b1e2ef39baf027825432d4169" translate="yes" xml:space="preserve">
          <source>If it's an Object the bits will contain the value of the address that tells the JVM how to get to the Object.</source>
          <target state="translated">Если это Объект,то биты будут содержать значение адреса,которое говорит JVM,как добраться до Объекта.</target>
        </trans-unit>
        <trans-unit id="8a2c1b22c98b47861f2f787055fd5f2fa95e5b32" translate="yes" xml:space="preserve">
          <source>If it's an object data type like &lt;strong&gt;Foo foo=new Foo()&lt;/strong&gt; then in this case copy of the address of the object passes like file shortcut  , suppose we have a text file &lt;strong&gt;abc.txt&lt;/strong&gt; at &lt;strong&gt;C:\desktop&lt;/strong&gt; and suppose we make shortcut of the same file and put this inside &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; so when you access the file from &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; and write &lt;strong&gt;'Stack Overflow'&lt;/strong&gt; and close the file and again you open the file from shortcut then you write &lt;strong&gt;' is the largest online community for programmers to learn'&lt;/strong&gt; then total file change will be &lt;strong&gt;'Stack Overflow is the largest online community for programmers to learn'&lt;/strong&gt; which means it doesn't matter from where you open the file , each time we were accessing the same file , here we can assume &lt;strong&gt;Foo&lt;/strong&gt; as a file and suppose foo stored at &lt;strong&gt;123hd7h&lt;/strong&gt;(original address like &lt;strong&gt;C:\desktop\abc.txt&lt;/strong&gt; ) address and &lt;strong&gt;234jdid&lt;/strong&gt;(copied address like &lt;strong&gt;C:\desktop\abc-shortcut&lt;/strong&gt; which actually contains the original address of the file inside) ..
So for better understanding make shortcut file and feel..</source>
          <target state="translated">Если это тип данных объекта, такой как &lt;strong&gt;Foo, foo = new Foo (),&lt;/strong&gt; то в этом случае копия адреса объекта проходит как ярлык файла, предположим, что у нас есть текстовый файл &lt;strong&gt;abc.txt&lt;/strong&gt; в &lt;strong&gt;C: \ desktop,&lt;/strong&gt; и предположим, что мы сделали ярлык тот же файл и поместите его в &lt;strong&gt;C: \ desktop \ abc-ярлык,&lt;/strong&gt; чтобы при доступе к файлу из &lt;strong&gt;C: \ desktop \ abc.txt&lt;/strong&gt; и записи &lt;strong&gt;&amp;laquo;Переполнение стека&amp;raquo;&lt;/strong&gt; и закрытии файла снова открывался файл из ярлыка, затем вы напишите &lt;strong&gt;&amp;laquo;это самое большое онлайн-сообщество для изучения программистами&amp;raquo;,&lt;/strong&gt; тогда общее изменение файла будет &lt;strong&gt;&amp;laquo;Stack Overflow&amp;raquo; это самое большое онлайн-сообщество для обучения программистов &amp;raquo;,&lt;/strong&gt; что означает, что не имеет значения, откуда вы открываете файл, каждый раз, когда мы обращались к нему. тот же файл, здесь мы можем принять &lt;strong&gt;Foo&lt;/strong&gt; как файл и предположить, что foo хранится по адресу &lt;strong&gt;123hd7h&lt;/strong&gt; (исходный адрес, такой как &lt;strong&gt;C: \ desktop \ abc.txt&lt;/strong&gt; ), и &lt;strong&gt;234jdid&lt;/strong&gt; (скопированный адрес, такой как &lt;strong&gt;C: \ desktop \ abc-shortcut,&lt;/strong&gt; который на самом деле содержит оригинальный адрес файла внутри) .. Так что для лучшего понимания сделайте ярлык файла и почувствуйте ..</target>
        </trans-unit>
        <trans-unit id="d09449cf7c49c0bb34af69bedb5138b6a6cf6571" translate="yes" xml:space="preserve">
          <source>If we pass the value of array1 reference variable as an argument to the reverseArray method, a reference variable is created in the method and that reference variable starts pointing to the same array (a).</source>
          <target state="translated">Если в качестве аргумента передать в метод reverseArray значение переменной-справки массива 1,то в этом методе создается переменная-справка и эта переменная-справка начинает указывать на один и тот же массив (a).</target>
        </trans-unit>
        <trans-unit id="111cce0df4d6a3eea4ae694172e96a48fec02a36" translate="yes" xml:space="preserve">
          <source>If we return value of reference variable array2 as the return value of method reverseArray and assign this value to reference variable array1 in main method, array1 in main will start pointing to array c.</source>
          <target state="translated">Если в качестве возвращаемого значения метода reverseArray вернуть значение массива ссылочной переменной array2 и в основном методе присвоить это значение массиву ссылочной переменной array1,то массив1 в основном начнет указывать на массив c.</target>
        </trans-unit>
        <trans-unit id="cdd0e1a5c0a10b05b85a4f05bf0c8857fb0dc54a" translate="yes" xml:space="preserve">
          <source>If we want to call a method/function/procedure with Foo's value, there are a few possible way to pass the variable to the method, depending on the &lt;strong&gt;language&lt;/strong&gt; and its several method invocation modes:</source>
          <target state="translated">Если мы хотим вызвать метод / функцию / процедуру со значением Foo, есть несколько возможных способов передачи переменной в метод, в зависимости от &lt;strong&gt;языка&lt;/strong&gt; и нескольких режимов вызова метода:</target>
        </trans-unit>
        <trans-unit id="ae7787cfc8ddd2039110866a573a0e2714e49edb" translate="yes" xml:space="preserve">
          <source>If you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output &lt;code&gt;changevalue&lt;/code&gt;,   which is updated in the function.</source>
          <target state="translated">Если вы измените что-либо в функции, используя ссылку f, это изменит существующее содержимое объекта. Вот почему мы получили выходное значение &lt;code&gt;changevalue&lt;/code&gt; , которое обновляется в функции.</target>
        </trans-unit>
        <trans-unit id="fe4914949893eeb60b019dffcc6cea87be8dcc83" translate="yes" xml:space="preserve">
          <source>If you didn't get it then just trust me and remember that it's better to say that &lt;strong&gt;Java is pass by value&lt;/strong&gt;. Well, &lt;strong&gt;pass by reference value&lt;/strong&gt;. Oh well, even better is &lt;strong&gt;&lt;em&gt;pass-by-copy-of-the-variable-value! ;)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">Если вы не получили его, просто поверьте мне и помните, что лучше сказать, что &lt;strong&gt;Java передается по значению&lt;/strong&gt; . Ну, &lt;strong&gt;перейдите по ссылке&lt;/strong&gt; . Ну что ж, еще лучше &lt;strong&gt;&lt;em&gt;передать значение переменной!&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;;)&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d76bdbeace9817e06089a031711671ab9b1f87b3" translate="yes" xml:space="preserve">
          <source>If you say, &quot;Java is pass-by-whatever (reference/value)&quot;, in either case, you're not provide a complete answer. Here's some additional information that will hopefully aid in understanding what's happening in memory.</source>
          <target state="translated">Если вы скажете:&quot;Java-это пассивно (ссылочное значение)&quot;,в любом случае вы не дадите полного ответа.Вот некоторая дополнительная информация,которая,как мы надеемся,поможет понять,что происходит в памяти.</target>
        </trans-unit>
        <trans-unit id="2864474958a88d28e0e852e593201018ce309c3a" translate="yes" xml:space="preserve">
          <source>In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.</source>
          <target state="translated">В C++,Ada,Pascal и других языках,поддерживающих передачу по ссылке,на самом деле можно изменить передаваемую переменную.</target>
        </trans-unit>
        <trans-unit id="cd1ab35d296b25bfeeda42a17c0845735976d063" translate="yes" xml:space="preserve">
          <source>In C++: &lt;strong&gt;Note: Bad code - memory leaks!&lt;/strong&gt;  But it demonstrates the point.</source>
          <target state="translated">В C ++: &lt;strong&gt;Примечание: плохой код - утечки памяти!&lt;/strong&gt; Но это демонстрирует суть.</target>
        </trans-unit>
        <trans-unit id="70a7832950563eb1e68d730cfc8633aecba50e12" translate="yes" xml:space="preserve">
          <source>In Java,</source>
          <target state="translated">На Яве,</target>
        </trans-unit>
        <trans-unit id="ee32c40f3e465ae5371086558cba52983a8a32d8" translate="yes" xml:space="preserve">
          <source>In Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.</source>
          <target state="translated">В Java все параметры передаются по значению,т.е.назначение аргумента метода не видно вызывающему абоненту.</target>
        </trans-unit>
        <trans-unit id="ea4a661eaa255681fb44e9a0ceb260d8c9521fd5" translate="yes" xml:space="preserve">
          <source>In Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. &lt;strong&gt;Modifying the object referenced by the variable is a different concept entirely.&lt;/strong&gt;</source>
          <target state="translated">В Java изменение переменной означает ее переназначение. В Java, если вы переназначите переменную в методе, она останется незамеченной для вызывающей стороны. &lt;strong&gt;Модификация объекта, на который ссылается переменная, совершенно другая концепция.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ec57628bd6a19cc372e0d82956fbc9926fe31cc" translate="yes" xml:space="preserve">
          <source>In addition to what was mentioned in Example3 (PassByValueObjectCase1.java),  we cannot change the actual reference outside the original scope.&quot;</source>
          <target state="translated">В дополнение к тому,что было упомянуто в примере3 (PassByValueObjectCase1.java),мы не можем изменить фактическую ссылку за пределами исходной области видимости&quot;.</target>
        </trans-unit>
        <trans-unit id="bf42410ba453a42ec3533408e27e6dbcc281e995" translate="yes" xml:space="preserve">
          <source>In call-by-reference evaluation (also referred to as
  pass-by-reference), a function receives an implicit reference to a
  variable used as argument, rather than a copy of its value. This
  typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">При оценке по ссылке (также называемой передачей по ссылке) функция получает неявную ссылку на переменную, используемую в качестве аргумента, а не копию ее значения. Как правило, это означает, что функция может изменять (то есть назначать) переменную, используемую в качестве аргумента - то, что будет видно вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="8b7b4cb1ed7c07a761b7c04a976a8f1ba04382e4" translate="yes" xml:space="preserve">
          <source>In call-by-value, the actual parameter is evaluated (if it is an
  expression) or copied (if it is a variable). The value is placed in
  the location belonging to the corresponding formal parameter of the
  called procedure. &lt;strong&gt;This method is used in C and Java, and is a common
  option in C++ , as well as in most other languages.&lt;/strong&gt;</source>
          <target state="translated">В вызове по значению фактический параметр оценивается (если это выражение) или копируется (если это переменная). Значение помещается в местоположение, принадлежащее соответствующему формальному параметру вызываемой процедуры. &lt;strong&gt;Этот метод используется в C и Java и является распространенным вариантом в C ++, а также в большинстве других языков.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80cff4aaaefaebbc2f88f5d26ae6ac275dc4f40b" translate="yes" xml:space="preserve">
          <source>In call-by-value, the argument expression is evaluated, and the
  resulting value is bound to the corresponding variable in the function [...]. 
  If the function or procedure is able to assign values to its
  parameters, only its local copy is assigned [...].</source>
          <target state="translated">При вызове по значению вычисляется выражение аргумента,а результирующее значение привязывается к соответствующей переменной в функции [...].Если функция или процедура может присваивать значения своим параметрам,то [...]присваивается только ее локальная копия.</target>
        </trans-unit>
        <trans-unit id="bd4f5299b140615753485c299e8a2e77b0c5997f" translate="yes" xml:space="preserve">
          <source>In case of Objects, this is the same: 
Object variables are pointers (buckets) holding only Object&amp;rsquo;s &lt;strong&gt;address&lt;/strong&gt; that was created using the &quot;new&quot; keyword, and are copied like primitive types.</source>
          <target state="translated">В случае объектов это тоже самое: переменные объекта - это указатели (сегменты), содержащие только &lt;strong&gt;адрес&lt;/strong&gt; объекта, который был создан с использованием ключевого слова &amp;laquo;new&amp;raquo;, и копируются как примитивные типы.</target>
        </trans-unit>
        <trans-unit id="fc3d33069def51ed42a9766ed121449803b82259" translate="yes" xml:space="preserve">
          <source>In effect, using a method, you will never be able, to update the value of a String passed as argument:</source>
          <target state="translated">По сути,используя метод,вы никогда не сможете обновить значение строки,переданной в качестве аргумента:</target>
        </trans-unit>
        <trans-unit id="80da013ae7fbb0cb942c6b9e18118975ac88e298" translate="yes" xml:space="preserve">
          <source>In every cases above a value - a &lt;strong&gt;copy&lt;/strong&gt; of an existing value - has been created, it is now upto the receiving method to handle it. When you write &quot;Foo&quot; inside the method, it is either read out from EAX, or automatically  &lt;strong&gt;dereferenced&lt;/strong&gt;, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a &lt;em&gt;reference&lt;/em&gt; is a &lt;em&gt;value&lt;/em&gt; when represented, because a reference is a value that has to be processed (at language level).</source>
          <target state="translated">В каждом случае выше значения - &lt;strong&gt;копия&lt;/strong&gt; существующего значения - была создана, теперь это должен получить метод для обработки. Когда вы пишете &amp;laquo;Foo&amp;raquo; внутри метода, он либо считывается из EAX, либо автоматически &lt;strong&gt;разыменовывается&lt;/strong&gt; , либо разыменовывается дважды, процесс зависит от того, как работает язык и / или от того, что диктует тип Foo. Это скрыто от разработчика, пока она не обходит процесс разыменования. Таким образом, &lt;em&gt;ссылка&lt;/em&gt; - это &lt;em&gt;значение,&lt;/em&gt; когда оно представлено, потому что ссылка - это значение, которое должно быть обработано (на уровне языка).</target>
        </trans-unit>
        <trans-unit id="58d4de45900cd3a103d99c18d12234d5bb3d377d" translate="yes" xml:space="preserve">
          <source>In general, Java has primitive types (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, etc) that are passed directly by value. Then Java has objects (everything that derives from &lt;code&gt;java.lang.Object&lt;/code&gt;). Objects are actually always handled through a reference (a reference being a pointer that you can't touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.</source>
          <target state="translated">В общем, Java имеет примитивные типы ( &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; и т. Д.), Которые передаются непосредственно по значению. Тогда у Java есть объекты (все, что происходит от &lt;code&gt;java.lang.Object&lt;/code&gt; ). Объекты на самом деле всегда обрабатываются с помощью ссылки (ссылка - это указатель, который вы не можете коснуться). Это означает, что, по сути, объекты передаются по ссылке, так как ссылки обычно не интересны. Это, однако, означает, что вы не можете изменить объект, на который указывает объект, так как сама ссылка передается по значению.</target>
        </trans-unit>
        <trans-unit id="45cfc45c3c6f01b610517a50ecd3388655190ac5" translate="yes" xml:space="preserve">
          <source>In java everything is reference, so when you have something like:
    &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; Java does following:</source>
          <target state="translated">В Java все ссылки, поэтому, когда у вас есть что-то вроде: &lt;code&gt;Point pnt1 = new Point(0,0);&lt;/code&gt; Java делает следующее:</target>
        </trans-unit>
        <trans-unit id="b73ac48cac4cc50104187760bd5de00365a5e1fd" translate="yes" xml:space="preserve">
          <source>In line #4 you can listen to the sound of silence</source>
          <target state="translated">В четвертой строке вы можете слушать звук тишины...</target>
        </trans-unit>
        <trans-unit id="f876ee91061153b58472e3caad886db2830e5e6c" translate="yes" xml:space="preserve">
          <source>In pascal, parameters passed-by-reference are called &quot;var parameters&quot;. In the procedure setToNil below, please note the keyword 'var' which precedes the parameter 'ptr'. When a pointer is passed to this procedure, it will be passed &lt;strong&gt;by reference&lt;/strong&gt;. Note the behavior: when this procedure sets ptr to nil (that's pascal speak for NULL), it will set the argument to nil--you can't do that in Java.</source>
          <target state="translated">В паскале параметры, передаваемые по ссылке, называются &amp;laquo;параметрами вар&amp;raquo;. В процедуре setToNil ниже обратите внимание на ключевое слово &amp;laquo;var&amp;raquo;, которое предшествует параметру &amp;laquo;ptr&amp;raquo;. Когда указатель передается этой процедуре, он передается &lt;strong&gt;по ссылке&lt;/strong&gt; . Обратите внимание на поведение: когда эта процедура устанавливает ptr в nil (это говорит на паскале для NULL), она устанавливает аргумент в nil - вы не можете сделать это в Java.</target>
        </trans-unit>
        <trans-unit id="0e25ccb4e75ab4aec689df71744743c33feb9136" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;tricky&lt;/code&gt; method:</source>
          <target state="translated">В &lt;code&gt;tricky&lt;/code&gt; методе:</target>
        </trans-unit>
        <trans-unit id="556c40767e22c9d0e16c7d2e8fd66f4fc3765ab3" translate="yes" xml:space="preserve">
          <source>In the C++ example below I'm passing a &lt;strong&gt;pointer&lt;/strong&gt; to a null terminated string &lt;strong&gt;by reference&lt;/strong&gt;. And in the Java example below I'm passing a Java reference to a String (again, the same as a pointer to a String) by value. Notice the output in the comments.</source>
          <target state="translated">В приведенном ниже примере C ++ я передаю &lt;strong&gt;указатель&lt;/strong&gt; на завершенную нулем строку &lt;strong&gt;по ссылке&lt;/strong&gt; . И в приведенном ниже примере с Java я передаю ссылку Java на строку (опять же, как указатель на строку) по значению. Обратите внимание на вывод в комментариях.</target>
        </trans-unit>
        <trans-unit id="eaf8d1084a66af0ad2274ebc5bf33bd05b487e6a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;Fifi&lt;/code&gt; is the dog's name after call to &lt;code&gt;foo(aDog)&lt;/code&gt; because the object's name was set inside of &lt;code&gt;foo(...)&lt;/code&gt;. Any operations that &lt;code&gt;foo&lt;/code&gt; performs on &lt;code&gt;d&lt;/code&gt; are such that, for all practical purposes, they are performed on &lt;code&gt;aDog&lt;/code&gt;, but it is &lt;strong&gt;not&lt;/strong&gt; possible to change the value of the variable &lt;code&gt;aDog&lt;/code&gt; itself.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;Fifi&lt;/code&gt; - это имя собаки после вызова &lt;code&gt;foo(aDog)&lt;/code&gt; поскольку имя объекта было установлено внутри &lt;code&gt;foo(...)&lt;/code&gt; . Любые операции, которые &lt;code&gt;foo&lt;/code&gt; выполняет на &lt;code&gt;d&lt;/code&gt; , таковы, что для всех практических целей они выполняются на &lt;code&gt;aDog&lt;/code&gt; , но невозможно изменить значение самой переменной &lt;code&gt;aDog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5f1d7ec3ad0697448f7bd1694b6d4a13eec5e90" translate="yes" xml:space="preserve">
          <source>In the case of primitive types, Java behaviour is simple: 
The value is copied in another instance of the primitive type.</source>
          <target state="translated">В случае с примитивными типами,поведение Java простое:Значение копируется в другой экземпляр примитивного типа.</target>
        </trans-unit>
        <trans-unit id="a522d3c2682539ae850f96edab1cea9361d6e16b" translate="yes" xml:space="preserve">
          <source>In the example above &lt;code&gt;aDog.getName()&lt;/code&gt; will still return &lt;code&gt;&quot;Max&quot;&lt;/code&gt;. The value &lt;code&gt;aDog&lt;/code&gt; within &lt;code&gt;main&lt;/code&gt; is not changed in the function &lt;code&gt;foo&lt;/code&gt; with the &lt;code&gt;Dog&lt;/code&gt;&lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; as the object reference is passed by value. If it were passed by reference, then the &lt;code&gt;aDog.getName()&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt; would return &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; after the call to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;aDog.getName()&lt;/code&gt; будет по-прежнему возвращать &lt;code&gt;&quot;Max&quot;&lt;/code&gt; . Значение &lt;code&gt;aDog&lt;/code&gt; в &lt;code&gt;main&lt;/code&gt; не изменяется в функции &lt;code&gt;foo&lt;/code&gt; с помощью &lt;code&gt;Dog&lt;/code&gt; &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; ,так как ссылка на объект передается по значению. Если бы он был передан по ссылке, &lt;code&gt;aDog.getName()&lt;/code&gt; в &lt;code&gt;main&lt;/code&gt; вернул бы &lt;code&gt;&quot;Fifi&quot;&lt;/code&gt; после вызова &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2767cb995f4a551872be17db0731dc32b9631113" translate="yes" xml:space="preserve">
          <source>In the following (please don't try to compile/execute this...):</source>
          <target state="translated">В следующем (пожалуйста,не пытайтесь это скомпилировать...):</target>
        </trans-unit>
        <trans-unit id="3cc72807c6aa2f7787bc1d2e01e7b1a38a8163b3" translate="yes" xml:space="preserve">
          <source>In the image below you can see we have two reference variables(These are called pointers in C/C++, and I think that term makes it easier to understand this feature.) in the main method. Primitive and reference variables are kept in stack memory(left side in images below). array1 and array2 reference variables &quot;point&quot; (as C/C++ programmers call it) or reference to a and b arrays respectively, which are objects (values these reference variables hold are addresses of objects) in heap memory (right side in images below).</source>
          <target state="translated">На рисунке ниже видны две ссылочные переменные (в CC++они называются указателями,и я думаю,что этот термин облегчает понимание этой особенности)в основном методе.Примитивная и ссылочная переменные хранятся в стековой памяти (слева на рисунках ниже).Ссылочные переменные array1 и array2 &quot;указывают&quot; (как это называют CC++программисты)или ссылаются на массивы a и b соответственно,которые являются объектами (значения,которые держат эти ссылочные переменные,являются адресами объектов)в памяти кучи (справа на рисунках ниже).</target>
        </trans-unit>
        <trans-unit id="1db423d4e50678143cbe574c1553ab77c64d2ec7" translate="yes" xml:space="preserve">
          <source>Is Java “pass-by-reference” or “pass-by-value”</source>
          <target state="translated">Является ли Java &quot;pass-by-reference&quot; или &quot;pass-by-value&quot;.</target>
        </trans-unit>
        <trans-unit id="da12241a17ef14fa43fa2b4e3155933518c0d4e0" translate="yes" xml:space="preserve">
          <source>It goes like this:</source>
          <target state="translated">Вот так:</target>
        </trans-unit>
        <trans-unit id="98f312d82b1864aed2fd685327b3e2e9e1d88ca2" translate="yes" xml:space="preserve">
          <source>It's perfectly valid to &lt;em&gt;follow&lt;/em&gt; an address and change what's at the end of it; that does not change the variable, however.</source>
          <target state="translated">Совершенно верно &lt;em&gt;следовать&lt;/em&gt; за адресом и менять то, что в конце; это не меняет переменную, однако.</target>
        </trans-unit>
        <trans-unit id="f5635fa4e11fcd1915675b96d22971357494e751" translate="yes" xml:space="preserve">
          <source>Java always passes arguments &lt;em&gt;by value&lt;/em&gt;, NOT by reference.</source>
          <target state="translated">Java всегда передает аргументы &lt;em&gt;по значению&lt;/em&gt; , а не по ссылке.</target>
        </trans-unit>
        <trans-unit id="1e1d0bd5765a75bcdfc28bab135f3be439234c61" translate="yes" xml:space="preserve">
          <source>Java arguments are &lt;strong&gt;all passed by value&lt;/strong&gt; (the reference is copied when used by the method) :</source>
          <target state="translated">Все аргументы Java &lt;strong&gt;передаются по значению&lt;/strong&gt; (ссылка используется при использовании метода):</target>
        </trans-unit>
        <trans-unit id="d45e3643eb2a0c3cfaa96ee1ba516a58b305181b" translate="yes" xml:space="preserve">
          <source>Java has only pass by value. A very simple example to validate this.</source>
          <target state="translated">Ява проходит только по значению.Очень простой пример для подтверждения этого.</target>
        </trans-unit>
        <trans-unit id="703fb214de1457e7f2c05c6d4fec19e41f4cb320" translate="yes" xml:space="preserve">
          <source>Java is a call by value</source>
          <target state="translated">Java-это вызов по значению</target>
        </trans-unit>
        <trans-unit id="3acd670af680bc110c036092f510ce1f098fa3fb" translate="yes" xml:space="preserve">
          <source>Java is always &lt;strong&gt;pass-by-value&lt;/strong&gt;. Unfortunately, when we pass the value of an object, we are passing the &lt;em&gt;reference&lt;/em&gt; to it.  This is confusing to beginners.</source>
          <target state="translated">Java всегда &lt;strong&gt;передается по значению&lt;/strong&gt; . К сожалению, когда мы передаем значение объекта, мы передаем &lt;em&gt;ссылку&lt;/em&gt; на него. Это сбивает с толку новичков.</target>
        </trans-unit>
        <trans-unit id="d999ec799d7d7e3e79463bd37bb62eacf6e25b10" translate="yes" xml:space="preserve">
          <source>Java is always pass by value, with no exceptions, &lt;strong&gt;ever&lt;/strong&gt;.</source>
          <target state="translated">Java всегда передается по значению, без исключений, &lt;strong&gt;никогда&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bffa033db8f0f65b32ac37222c7fbfe326862449" translate="yes" xml:space="preserve">
          <source>Java is pass by value according to the Java Language Specification:</source>
          <target state="translated">Java передается по значению в соответствии со спецификацией языка Java:</target>
        </trans-unit>
        <trans-unit id="5d5b05490570ab7df7923106ad5234571b0ba144" translate="yes" xml:space="preserve">
          <source>Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you'll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!</source>
          <target state="translated">Java передается по значению,потому что внутри метода вы можете модифицировать ссылающийся Объект сколько угодно,но как бы вы ни старались,вы никогда не сможете изменить передаваемую переменную,которая будет продолжать ссылаться (не p______)тот же самый Объект,несмотря ни на что!</target>
        </trans-unit>
        <trans-unit id="45192a707a26fe3bb2f92c6fbcb126e95a6e9b0e" translate="yes" xml:space="preserve">
          <source>Java only has the two types of passing: by value for built-in types, and by value of the pointer for object types.</source>
          <target state="translated">Java имеет только два типа передачи:по значению для встроенных типов и по значению указателя для типов объектов.</target>
        </trans-unit>
        <trans-unit id="529efc0a206bb877a5914af86dac2e005794eacf" translate="yes" xml:space="preserve">
          <source>Java pass &quot;a Java reference&quot; by value example</source>
          <target state="translated">Java передает &quot;ссылку на Java&quot; на примере значения.</target>
        </trans-unit>
        <trans-unit id="3a23cc46246cbf17c3306653ed35fc739dd92303" translate="yes" xml:space="preserve">
          <source>Java passes it parameters by value</source>
          <target state="translated">Java передаёт ей параметры по значению</target>
        </trans-unit>
        <trans-unit id="93f3aa9ad265f6adfea081d81b4ce0f2dd3364f2" translate="yes" xml:space="preserve">
          <source>Java passes references by value.</source>
          <target state="translated">Java передает ссылки по значению.</target>
        </trans-unit>
        <trans-unit id="866018b39b9f976d7a4fda32831571acb3fe531a" translate="yes" xml:space="preserve">
          <source>Java passes references to objects by value.</source>
          <target state="translated">Java передает ссылки на объекты по значению.</target>
        </trans-unit>
        <trans-unit id="cb688bcbe4d4a31366fbbe80d020a8f8c54e722d" translate="yes" xml:space="preserve">
          <source>Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, you cannot change where that pointer points.</source>
          <target state="translated">Java работает точно так же,как C.Вы можете назначить указатель,передать указатель методу,следовать указателю в методе и изменить данные,на которые был указан указатель.Однако,вы не можете изменить,куда указатель указывает.</target>
        </trans-unit>
        <trans-unit id="c3ceb58d38297bd42517df14fa453efa53f2e920" translate="yes" xml:space="preserve">
          <source>Just to show the contrast, compare the following &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C++&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; snippets:</source>
          <target state="translated">Чтобы показать контраст, сравните следующие фрагменты &lt;a href=&quot;https://en.wikipedia.org/wiki/C++&quot;&gt;C ++&lt;/a&gt; и &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="76eed6720175d9c487a151ea0ec369ca6ff2bea0" translate="yes" xml:space="preserve">
          <source>Keeping in mind that &lt;code&gt;myDog&lt;/code&gt; is a &lt;em&gt;pointer&lt;/em&gt;, and not an actual &lt;code&gt;Dog&lt;/code&gt;, the answer is NO. &lt;code&gt;myDog&lt;/code&gt; still has the value 42; it's still pointing to the original &lt;code&gt;Dog&lt;/code&gt; (but note that because of line &quot;AAA&quot;, its name is now &quot;Max&quot; - still the same Dog; &lt;code&gt;myDog&lt;/code&gt;'s value has not changed.)</source>
          <target state="translated">Помня, что &lt;code&gt;myDog&lt;/code&gt; - это &lt;em&gt;указатель&lt;/em&gt; , а не настоящая &lt;code&gt;Dog&lt;/code&gt; , ответ НЕТ. &lt;code&gt;myDog&lt;/code&gt; все еще имеет значение 42; он по-прежнему указывает на исходный &lt;code&gt;Dog&lt;/code&gt; (но обратите внимание, что из-за строки &amp;laquo;AAA&amp;raquo; его имя теперь &amp;laquo;Max&amp;raquo; - все тот же Dog; значение &lt;code&gt;myDog&lt;/code&gt; не изменилось.)</target>
        </trans-unit>
        <trans-unit id="2671b77ed672eeae8e1bb043ed9cddaa3c26b00f" translate="yes" xml:space="preserve">
          <source>Let me explain this through an &lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;example&lt;/a&gt;:</source>
          <target state="translated">Позвольте мне объяснить это на &lt;a href=&quot;https://stackoverflow.com/a/9404727/597657&quot;&gt;примере&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1769d859356c9306da11a136d37d7bc840e8173d" translate="yes" xml:space="preserve">
          <source>Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference</source>
          <target state="translated">Позвольте мне попытаться объяснить свое понимание с помощью четырех примеров.Java-это проходная величина,а не проходная ссылка.</target>
        </trans-unit>
        <trans-unit id="667ee93519391efd5ef048789e42e4cd7eb32ed7" translate="yes" xml:space="preserve">
          <source>Let's consider reference types, the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;Java Virtual Machine Specification&lt;/a&gt; states</source>
          <target state="translated">Давайте рассмотрим ссылочные типы, состояния &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4&quot;&gt;спецификации виртуальной машины Java&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="017c2442a73e3b150be4f8d7101d3d565a83f364" translate="yes" xml:space="preserve">
          <source>Let's understand step by step:</source>
          <target state="translated">Давайте поймем шаг за шагом:</target>
        </trans-unit>
        <trans-unit id="5685f4b4e04daf5f5c1aa0517659cc4fb4246e59" translate="yes" xml:space="preserve">
          <source>Lets say we have a variable Foo, its &lt;strong&gt;Location&lt;/strong&gt; is at the 47th byte in memory and its &lt;strong&gt;Value&lt;/strong&gt; is 5. We have another variable &lt;strong&gt;Ref2Foo&lt;/strong&gt; which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two &lt;strong&gt;Values&lt;/strong&gt;.
If you use them as references then to reach to &lt;code&gt;5&lt;/code&gt; we have to travel:</source>
          <target state="translated">Допустим, у нас есть переменная Foo, ее &lt;strong&gt;Location&lt;/strong&gt; находится на 47-м байте в памяти, а ее &lt;strong&gt;значение&lt;/strong&gt; равно 5. У нас есть другая переменная &lt;strong&gt;Ref2Foo,&lt;/strong&gt; которая на 223-м байте в памяти, и ее значение будет 47. Этот Ref2Foo может быть технической переменной , явно не созданный программой. Если вы просто посмотрите на 5 и 47 без какой-либо другой информации, вы увидите только два &lt;strong&gt;значения&lt;/strong&gt; . Если вы используете их в качестве ссылок, то для достижения &lt;code&gt;5&lt;/code&gt; мы должны путешествовать:</target>
        </trans-unit>
        <trans-unit id="d50fff30ab03bcac896614280d7ce79d010333b1" translate="yes" xml:space="preserve">
          <source>Like so:</source>
          <target state="translated">Нравится:</target>
        </trans-unit>
        <trans-unit id="1cfac11915904016eed201cd17895ef142e7298c" translate="yes" xml:space="preserve">
          <source>Likewise:</source>
          <target state="translated">Likewise:</target>
        </trans-unit>
        <trans-unit id="5cd871265dfcea1f716cd6d1540a0775e084af34" translate="yes" xml:space="preserve">
          <source>Naturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.</source>
          <target state="translated">Естественно,что передача значения по ссылке на объект очень похожа (и на практике неотличима от нее)на передачу объекта по ссылке.</target>
        </trans-unit>
        <trans-unit id="74a399506f2951a7b197ec01ea8e798ce4122914" translate="yes" xml:space="preserve">
          <source>Next in the &lt;code&gt;tricky&lt;/code&gt; method</source>
          <target state="translated">Далее в &lt;code&gt;tricky&lt;/code&gt; методе</target>
        </trans-unit>
        <trans-unit id="4c7f2f0ce70a51c735ee73784fc914a2704fd44b" translate="yes" xml:space="preserve">
          <source>Nitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only &lt;em&gt;pass-by-reference&lt;/em&gt;.</source>
          <target state="translated">Не обращая внимания на незначительные детали, даже языки, которые передают по ссылке, передадут значения в функции, но эти функции знают, что они должны использовать его для разыменования. Эта передача-ссылка-как-значение просто скрыта от программиста, потому что она практически бесполезна, а терминология - только &lt;em&gt;передача по ссылке&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f39a1496ed9448598fdec7fa441d4eb247a6d515" translate="yes" xml:space="preserve">
          <source>No new instances of Person are created.</source>
          <target state="translated">Новые экземпляры &quot;Человека&quot; не создаются.</target>
        </trans-unit>
        <trans-unit id="5a3c28a6866958ddbd72e8e5bfcca8b47c170a56" translate="yes" xml:space="preserve">
          <source>No, it's not pass by reference.</source>
          <target state="translated">Нет,это не проходит мимо отсылки.</target>
        </trans-unit>
        <trans-unit id="a2c2fa354963a9acfa4e9abfc392a844ec4c593d" translate="yes" xml:space="preserve">
          <source>Note: I am not pasting the code for &lt;code&gt;private class Student&lt;/code&gt;. The class definition for &lt;code&gt;Student&lt;/code&gt; is same as Example3.</source>
          <target state="translated">Примечание: я не вставляю код для &lt;code&gt;private class Student&lt;/code&gt; . Определение класса для &lt;code&gt;Student&lt;/code&gt; такое же, как Example3.</target>
        </trans-unit>
        <trans-unit id="922f6a86dea64e63a3edc02c1877ce2a3c46981e" translate="yes" xml:space="preserve">
          <source>Now feel free to hate me but note that given this &lt;strong&gt;there is no difference between passing primitive data types and Objects&lt;/strong&gt; when talking about method arguments.</source>
          <target state="translated">Теперь не стесняйтесь ненавидеть меня, но обратите внимание, что, учитывая это, &lt;strong&gt;нет разницы между передачей примитивных типов данных и объектов&lt;/strong&gt; при обсуждении аргументов метода.</target>
        </trans-unit>
        <trans-unit id="69d2ccd64b25d43c28b50000e4e7f2b5a02a3236" translate="yes" xml:space="preserve">
          <source>Now let's think about what happens outside the method:</source>
          <target state="translated">Теперь давайте подумаем о том,что происходит вне метода:</target>
        </trans-unit>
        <trans-unit id="ff38daeae639f963939233f6e3fdce27295e1cf5" translate="yes" xml:space="preserve">
          <source>Now think of what an Object's reference/variable does/is:</source>
          <target state="translated">А теперь подумайте о том,что делает эталонная переменная Объекта:</target>
        </trans-unit>
        <trans-unit id="0e2ffb2ff2a00fd086483aeae2222dbc11a4d2c8" translate="yes" xml:space="preserve">
          <source>Now we have passed Foo to the method:</source>
          <target state="translated">Теперь мы передали Фу методу:</target>
        </trans-unit>
        <trans-unit id="a68e19abd4296329735454d01ddb1f100edde052" translate="yes" xml:space="preserve">
          <source>Of course you can cut it short and just say that  &lt;strong&gt;Java is pass-by-value!&lt;/strong&gt;</source>
          <target state="translated">Конечно, вы можете сократить его и просто сказать, что &lt;strong&gt;Java передается по значению!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25bdd3d54506e9fcb400bfa35ebbf005d8293eb" translate="yes" xml:space="preserve">
          <source>Okay. First off, local primitives go on the stack. So this code:</source>
          <target state="translated">Хорошо.Во-первых,местные примитивисты идут по стопке.Итак,этот код:</target>
        </trans-unit>
        <trans-unit id="8e109f9696197d944923c2e8918140789af777d2" translate="yes" xml:space="preserve">
          <source>One String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier &lt;code&gt;hisName&lt;/code&gt;, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call &lt;code&gt;shout()&lt;/code&gt;: a new stack frame is created and a new identifier, &lt;code&gt;name&lt;/code&gt; is created and assigned the address of the already-existing String.</source>
          <target state="translated">Одна строка создается и пространство для нее выделяется в куче, а адрес строки сохраняется в стеке и получает идентификатор &lt;code&gt;hisName&lt;/code&gt; , поскольку адрес второй строки совпадает с первым, новая строка не создается. и новое пространство кучи не выделяется, но в стеке создается новый идентификатор. Затем мы вызываем &lt;code&gt;shout()&lt;/code&gt; : создается новый кадр стека и создается новый идентификатор, &lt;code&gt;name&lt;/code&gt; и присваивается адрес уже существующей строки.</target>
        </trans-unit>
        <trans-unit id="e9fbef27678eb892ee44cd57611d9c038d5ddbb8" translate="yes" xml:space="preserve">
          <source>Or from wikipedia, &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;on the subject of pass-by-reference&lt;/a&gt;</source>
          <target state="translated">Или из википедии, &lt;a href=&quot;http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference&quot;&gt;на тему передачи по ссылке&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89050305305bcda692140fffe8f7276e92d157fe" translate="yes" xml:space="preserve">
          <source>Pass By Value</source>
          <target state="translated">Пройти по значению</target>
        </trans-unit>
        <trans-unit id="7a52d2d617a0327ba951584e0dd74a3b60d0e2ee" translate="yes" xml:space="preserve">
          <source>Pass by value means the called functions' parameter will be a copy of
  the callers' passed argument.</source>
          <target state="translated">Передача по значению означает,что параметр вызываемой функции будет копией переданного аргумента вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="b05d82b9afa13c63a41c110afc8f23afc15f5eb7" translate="yes" xml:space="preserve">
          <source>Passing by reference means the called functions' parameter will be the
  same as the callers' passed argument (not the value, but the identity
  - the variable itself).</source>
          <target state="translated">Передача по ссылке означает,что параметр вызываемой функции будет таким же,как и переданный аргумент вызывающего абонента (не значение,а идентификатор-сама переменная).</target>
        </trans-unit>
        <trans-unit id="cc7d7eee18bf03fb193a57aacc259b0ecd56568e" translate="yes" xml:space="preserve">
          <source>Passing references to arrays, instead of the array objects themselves, makes sense for performance reasons. Because everything in Java is passed by value, if array objects were passed,
a copy of each element would be passed. For large arrays, this would waste time and consume
considerable storage for the copies of the elements.</source>
          <target state="translated">Передача ссылок на массивы,а не на сами объекты массива,имеет смысл из соображений производительности.Потому что в Java все передается по значению,если бы передавались объекты-массивы,то передавалась бы копия каждого элемента.В случае больших массивов это будет тратить время и потребляет значительное количество памяти для хранения копий элементов.</target>
        </trans-unit>
        <trans-unit id="8cfedebc2d3a9442c6efa9728f78e57e537d2cba" translate="yes" xml:space="preserve">
          <source>Primitive values are also defined in the Java Virtual Machine Specification, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;here&lt;/a&gt;. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).</source>
          <target state="translated">Примитивные значения также определены в Спецификации виртуальной машины Java, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3&quot;&gt;здесь&lt;/a&gt; . Значением типа является соответствующее целочисленное значение или значение с плавающей запятой, кодированное соответствующим образом (8, 16, 32, 64 и т. Д. Биты).</target>
        </trans-unit>
        <trans-unit id="20eebab5a449d25f5d3973bfc691fbe91ed1dda9" translate="yes" xml:space="preserve">
          <source>Primitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.</source>
          <target state="translated">Примитивные оберточные классы и строки неизменны,поэтому любой пример использования этих типов не будет работать так же,как другие типизированные объекты.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="45c34d3cd3e583ca8c9f01b7fd4364b4be14d83e" translate="yes" xml:space="preserve">
          <source>References &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; are &lt;strong&gt;passed by value&lt;/strong&gt; to the tricky method, which means that now yours references &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;pnt2&lt;/code&gt; have their &lt;code&gt;copies&lt;/code&gt; named &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;.So &lt;code&gt;pnt1&lt;/code&gt; and &lt;code&gt;arg1&lt;/code&gt;&lt;em&gt;points&lt;/em&gt; to the same object. (Same for the &lt;code&gt;pnt2&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt;)</source>
          <target state="translated">Ссылки &lt;code&gt;pnt1&lt;/code&gt; и &lt;code&gt;pnt2&lt;/code&gt; &lt;strong&gt;по значению передаются&lt;/strong&gt; в хитрый метод, что означает, что теперь ваши ссылки &lt;code&gt;pnt1&lt;/code&gt; и &lt;code&gt;pnt2&lt;/code&gt; имеют свои &lt;code&gt;copies&lt;/code&gt; именами &lt;code&gt;arg1&lt;/code&gt; и &lt;code&gt;arg2&lt;/code&gt; . &lt;code&gt;pnt1&lt;/code&gt; и &lt;code&gt;arg1&lt;/code&gt; &lt;em&gt;указывают&lt;/em&gt; на один и тот же объект. (То же самое для &lt;code&gt;pnt2&lt;/code&gt; и &lt;code&gt;arg2&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bf00fec3f22ea28e6b86a2ef752102c2e7ecb750" translate="yes" xml:space="preserve">
          <source>Second, we need to know what Java uses in its method invocations. The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Java Language Specification&lt;/a&gt; states</source>
          <target state="translated">Во-вторых, нам нужно знать, что Java использует в своих вызовах методов. &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1&quot;&gt;Спецификация языка Java&lt;/a&gt; заявляет</target>
        </trans-unit>
        <trans-unit id="d6c9ce881b6078a8902ba5543f51a3b0d775b3fa" translate="yes" xml:space="preserve">
          <source>Several people have written comments which seem to indicate that either they are not looking at my examples or they don't get the c++ example. Not sure where the disconnect is, but guessing the c++ example is not clear. I'm posting the same example in pascal because I think pass-by-reference looks cleaner in pascal, but I could be wrong. I might just be confusing people more; I hope not.</source>
          <target state="translated">Несколько человек написали комментарии,которые,похоже,указывают на то,что либо они не смотрят на мои примеры,либо они не понимают пример с++.Не знаю,где отключение,но догадка о примере с++не понятна.Я пишу тот же пример в pascal,потому что думаю,что pass-by-reference выглядит чище в pascal,но я могу ошибаться.Возможно,я просто больше сбиваю людей с толку,надеюсь,что нет.</target>
        </trans-unit>
        <trans-unit id="26c0ca793e8f7074d3f8c82877440040dbf9523b" translate="yes" xml:space="preserve">
          <source>So</source>
          <target state="translated">So</target>
        </trans-unit>
        <trans-unit id="ff40a96c97ebf788e8cecb055d7af4f991b2166d" translate="yes" xml:space="preserve">
          <source>So after executing method &lt;code&gt;tricky&lt;/code&gt;, when you return to &lt;code&gt;main&lt;/code&gt;, you have this situation:</source>
          <target state="translated">Таким образом, после выполнения метода &lt;code&gt;tricky&lt;/code&gt; , когда вы возвращаетесь в &lt;code&gt;main&lt;/code&gt; , у вас возникает такая ситуация:</target>
        </trans-unit>
        <trans-unit id="7ef4027a6bbd3300b48fbef4e07ab82867158511" translate="yes" xml:space="preserve">
          <source>So how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java &lt;strong&gt;never&lt;/strong&gt; provides direct access to the values of &lt;em&gt;objects themselves&lt;/em&gt;, in &lt;em&gt;any&lt;/em&gt; circumstances. The only access to objects is through a &lt;em&gt;reference&lt;/em&gt; to that object. Because Java objects are &lt;em&gt;always&lt;/em&gt; accessed through a reference, rather than directly, it is common to talk about fields and variables &lt;em&gt;and method arguments&lt;/em&gt; as being &lt;em&gt;objects&lt;/em&gt;, when pedantically they are only &lt;em&gt;references to objects&lt;/em&gt;. &lt;strong&gt;The confusion stems from this (strictly speaking, incorrect) change in nomenclature.&lt;/strong&gt;</source>
          <target state="translated">Так почему же это может смущать любого, кто верит, что Java передается по ссылке, или думает, что у него есть пример того, как Java действует как передача по ссылке? Ключевым моментом является то, что Java &lt;strong&gt;никогда не&lt;/strong&gt; обеспечивает прямого доступа к значениям самих &lt;em&gt;объектов&lt;/em&gt; &lt;em&gt;ни&lt;/em&gt; при &lt;em&gt;каких&lt;/em&gt; обстоятельствах. Единственный доступ к объектам - через &lt;em&gt;ссылку&lt;/em&gt; на этот объект. Поскольку доступ к объектам Java &lt;em&gt;всегда&lt;/em&gt; осуществляется через ссылку, а не напрямую, обычно говорят о полях, переменных &lt;em&gt;и аргументах методов&lt;/em&gt; как об &lt;em&gt;объектах&lt;/em&gt; , когда педантично они являются только &lt;em&gt;ссылками на объекты&lt;/em&gt; . &lt;strong&gt;Путаница проистекает из этого (строго говоря, неверного) изменения в номенклатуре.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49f6e297927d971ba38fa95bec79322b3f55ffe8" translate="yes" xml:space="preserve">
          <source>So if you have &lt;code&gt;doSomething(foo)&lt;/code&gt; and &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; the two Foos have copied &lt;em&gt;references&lt;/em&gt; that point to the same objects.</source>
          <target state="translated">Поэтому, если у вас есть &lt;code&gt;doSomething(foo)&lt;/code&gt; и &lt;code&gt;public void doSomething(Foo foo) { .. }&lt;/code&gt; два Foos скопировали &lt;em&gt;ссылки&lt;/em&gt; , указывающие на одни и те же объекты.</target>
        </trans-unit>
        <trans-unit id="7b4e3120f9e0ef1963e36854a84df92466e8bd5c" translate="yes" xml:space="preserve">
          <source>So in short and in Java's own terminology, Java is &lt;em&gt;pass-by-value&lt;/em&gt; where &lt;em&gt;value&lt;/em&gt; can be: either a &lt;strong&gt;real value&lt;/strong&gt; or a &lt;strong&gt;value&lt;/strong&gt; that is a representation of a &lt;strong&gt;reference&lt;/strong&gt;.</source>
          <target state="translated">Короче говоря, и в собственной терминологии Java, Java является &lt;em&gt;передачей по значению,&lt;/em&gt; где &lt;em&gt;значением&lt;/em&gt; может быть: либо &lt;strong&gt;реальное значение,&lt;/strong&gt; либо &lt;strong&gt;значение&lt;/strong&gt; , представляющее &lt;strong&gt;ссылку&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="634936d81c1689fe91adca4c5ee1e8fd9d96a1ad" translate="yes" xml:space="preserve">
          <source>So it assigns (or binds) the value of the argument to the corresponding parameter variable.</source>
          <target state="translated">Таким образом,он присваивает (или связывает)значение аргумента соответствующей переменной параметра.</target>
        </trans-unit>
        <trans-unit id="f4945724933ec9be2092b5806b370216861c5eeb" translate="yes" xml:space="preserve">
          <source>So let's write all the things we have done at once now.</source>
          <target state="translated">Так что давайте теперь напишем все,что мы сделали за один раз.</target>
        </trans-unit>
        <trans-unit id="9a181e916502cbb03b3332b929a47423efcc6e84" translate="yes" xml:space="preserve">
          <source>So now, completely execution of program will be:</source>
          <target state="translated">Так что теперь,полное выполнение программы будет:</target>
        </trans-unit>
        <trans-unit id="2a27627ea047cda38b06899780beb9ed096f3a7d" translate="yes" xml:space="preserve">
          <source>So you can't change the reference that gets passed in.</source>
          <target state="translated">Так что ты не можешь изменить ссылку,которая передается.</target>
        </trans-unit>
        <trans-unit id="866237ea6abd1c73ce2cd72c6c84fc4749c1fab7" translate="yes" xml:space="preserve">
          <source>So you're just passing 3bad086a that it's the value of the reference.</source>
          <target state="translated">Значит,вы просто передаете 3bad086a,что это значение ссылки.</target>
        </trans-unit>
        <trans-unit id="20fd78625a8ef72411c2e7f9cc21dcf94a034a8f" translate="yes" xml:space="preserve">
          <source>So, if we say</source>
          <target state="translated">Итак,если мы скажем.</target>
        </trans-unit>
        <trans-unit id="90e7e6de17ceea609c89967f7448b462eff52e91" translate="yes" xml:space="preserve">
          <source>So, value, reference? You say &quot;potato&quot;.</source>
          <target state="translated">Значит,ценность,ссылка? Ты говоришь &quot;картошка&quot;.</target>
        </trans-unit>
        <trans-unit id="daa39b66ef2d8fde4dcb582dccfc4335693ba86f" translate="yes" xml:space="preserve">
          <source>So, what gets passed in when you call a method? If you pass in an object, what you're actually passing in is the address of the object. Some might say the &quot;value&quot; of the address, and some say it's just a reference to the object. This is the genesis of the holy war between &quot;reference&quot; and &quot;value&quot; proponents. What you call it isn't as important as that you understand that what's getting passed in is the address to the object.</source>
          <target state="translated">Итак,что передается,когда ты называешь метод? Если вы передаете объект,то,что вы на самом деле передаете,это адрес объекта.Кто-то может сказать &quot;значение&quot; адреса,а кто-то сказать,что это просто ссылка на объект.Это генезис священной войны между сторонниками &quot;ссылки&quot; и &quot;значения&quot;.То,что вы называете,не так важно,как то,что вы понимаете,передается в виде адреса к объекту.</target>
        </trans-unit>
        <trans-unit id="f804721f9a225c83f9f775159b5195bbbe96d25c" translate="yes" xml:space="preserve">
          <source>So, when calling a method</source>
          <target state="translated">Итак,при вызове метода</target>
        </trans-unit>
        <trans-unit id="ee33b63e4d6f38a1051e9487d652448deba03bf9" translate="yes" xml:space="preserve">
          <source>Some excerpts from &lt;strong&gt;&quot;THE Java Programming Language&quot;&lt;/strong&gt; by Ken Arnold, &lt;strong&gt;James Gosling (the guy who invented Java)&lt;/strong&gt;, and David Holmes, chapter 2, section 2.6.5</source>
          <target state="translated">Некоторые выдержки из &lt;strong&gt;&amp;laquo;Языка программирования Java&amp;raquo;&lt;/strong&gt; Кена Арнольда, &lt;strong&gt;Джеймса Гослинга (парня, который изобрел Java)&lt;/strong&gt; и Дэвида Холмса, глава 2, раздел 2.6.5</target>
        </trans-unit>
        <trans-unit id="94b891247159e943febc8cc22cd31a1491a1cb74" translate="yes" xml:space="preserve">
          <source>Some people say primitive types and 'String' are 'pass by value'
  and objects are 'pass by reference'.</source>
          <target state="translated">Некоторые говорят,что примитивные типы,а &quot;строка&quot;-это &quot;передача по значению&quot;,а объекты-это &quot;передача по ссылке&quot;.</target>
        </trans-unit>
        <trans-unit id="ae7f019ce2b7e1139c2214fe199d7dfbfd4ace30" translate="yes" xml:space="preserve">
          <source>Sometimes Java can give the illusion of pass by reference. Let's see how it works by using the example below:</source>
          <target state="translated">Иногда Java может давать иллюзию прохождения по ссылке.Давайте посмотрим,как это работает на примере ниже:</target>
        </trans-unit>
        <trans-unit id="523c67e3005e1319a95db986a92e473eccf87a79" translate="yes" xml:space="preserve">
          <source>Sometimes you want to use the same pattern in Java, but you can't; at least not directly. Instead you could do something like this:</source>
          <target state="translated">Иногда вы хотите использовать один и тот же шаблон в Java,но не можете;по крайней мере,не напрямую.Вместо этого вы можете сделать что-то подобное:</target>
        </trans-unit>
        <trans-unit id="aa1ec5d7dc80c372add31e690fc9b6adfcbed953" translate="yes" xml:space="preserve">
          <source>Step one please erase from your mind that word that starts with 'p' &quot;_ _ _ _ _ _ _&quot;, especially if you come from other programming languages. Java and 'p' cannot be written in the same book, forum, or even txt.</source>
          <target state="translated">Шаг первый,пожалуйста,сотрите из памяти то слово,которое начинается с 'p' &quot;______&quot;,особенно если вы пришли с других языков программирования.Java и 'p' не могут быть написаны в одной и той же книге,форуме или даже в тексте.</target>
        </trans-unit>
        <trans-unit id="e060e28388e7368925caf9e91796e5aa4d2b1720" translate="yes" xml:space="preserve">
          <source>Step two remember that when you pass an Object into a method you're passing the Object reference and not the Object itself.</source>
          <target state="translated">Шаг второй-запомните,что когда вы передаете Объект в метод,вы передаете ссылку на Объект,а не на сам Объект.</target>
        </trans-unit>
        <trans-unit id="6207dc3dd0572f9c051d767720eb5104f3fb4f3c" translate="yes" xml:space="preserve">
          <source>Strict &lt;em&gt;pass-by-value&lt;/em&gt; is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller's view) and a few languages allows to modify the Value of the reference itself.</source>
          <target state="translated">Строгая &lt;em&gt;передача по значению&lt;/em&gt; также бесполезна, это будет означать, что 100-мегабайтный массив должен копироваться каждый раз, когда мы вызываем метод с массивом в качестве аргумента, поэтому Java не может строго передаваться по значению. Каждый язык передает ссылку на этот огромный массив (в качестве значения) и использует механизм копирования при записи, если этот массив может быть изменен локально внутри метода, или позволяет методу (как это делает Java) изменять массив глобально (из представление вызывающего абонента) и несколько языков позволяет изменять значение самой ссылки.</target>
        </trans-unit>
        <trans-unit id="f14bbbb986af6b74a6c4b3c0e5664a7de3e563b7" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;code&gt;Dog&lt;/code&gt; object resides at memory address 42. This means we pass 42 to the method.</source>
          <target state="translated">Предположим, что объект &lt;code&gt;Dog&lt;/code&gt; находится по адресу памяти 42. Это означает, что мы передаем 42 методу.</target>
        </trans-unit>
        <trans-unit id="8d27872f4e15932b79d2264d4a0cddb9e2521238" translate="yes" xml:space="preserve">
          <source>Take this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; is called by &lt;code&gt;foo(a)&lt;/code&gt;, where the compiler itself knows that it is a reference and the address of the non-reference &lt;code&gt;a&lt;/code&gt; should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.</source>
          <target state="translated">Отнесите это на C ++, и у нас есть ссылки. Ссылки в основном (в этом контексте) синтаксический сахар, который скрывает указатель части уравнения: &lt;code&gt;void foo(int &amp;amp;x)&lt;/code&gt; вызывается &lt;code&gt;foo(a)&lt;/code&gt; , где сам компилятор знает, что это ссылка и адрес не Ссылка должна быть пройдена. В Java все переменные, ссылающиеся на объекты, на самом деле относятся к ссылочному типу, фактически вызывая вызов по ссылке для большинства целей и задач без детального контроля (и сложности), предоставляемого, например, C ++.</target>
        </trans-unit>
        <trans-unit id="1f5466dbc044f44594c32f9e6b1b8a7351767c72" translate="yes" xml:space="preserve">
          <source>That's the reason only Java developers have issue with this. They look at the word &quot;reference&quot; and think they know exactly what that means, so they don't even bother to consider the opposing argument.</source>
          <target state="translated">Это причина,по которой только Java-разработчики имеют проблемы с этим.Они смотрят на слово &quot;ссылка&quot; и думают,что точно знают,что это значит,поэтому даже не утруждают себя рассмотрением противоположного аргумента.</target>
        </trans-unit>
        <trans-unit id="c94098a38907257d1a6a763b38d1468647d923f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;Java Language Specification&lt;/a&gt; also states</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1&quot;&gt;Спецификация языка Java&lt;/a&gt; также заявляет</target>
        </trans-unit>
        <trans-unit id="079b195af1fa053069e0e9a1be334e5b752f52b4" translate="yes" xml:space="preserve">
          <source>The Java Spec says that everything in Java is pass-by-value. There is no such thing as &quot;pass-by-reference&quot; in Java.</source>
          <target state="translated">В Java Spec сказано,что все в Java проходит мимо.В Java нет такой вещи,как &quot;pass-by-reference&quot;.</target>
        </trans-unit>
        <trans-unit id="fd7bc25c7313046e736eb3d62b656f193458641b" translate="yes" xml:space="preserve">
          <source>The Java programming language &lt;strong&gt;does not pass objects by reference; it&lt;/strong&gt;&lt;strong&gt;passes object references by value&lt;/strong&gt;. Because two copies of the same
  reference refer to the same actual object, changes made through one
  reference variable are visible through the other. There is exactly one
  parameter passing mode-&lt;strong&gt;pass by value&lt;/strong&gt;-and that helps keep things
  simple.</source>
          <target state="translated">Язык программирования Java &lt;strong&gt;не передает объекты по ссылке;&lt;/strong&gt; &lt;strong&gt;он&lt;/strong&gt; &lt;strong&gt;передает ссылки на объекты по значению&lt;/strong&gt; . Поскольку две копии одной и той же ссылки ссылаются на один и тот же фактический объект, изменения, внесенные через одну ссылочную переменную, видны через другую. Существует ровно один способ &lt;strong&gt;передачи параметров&lt;/strong&gt; - &lt;strong&gt;передача по значению&lt;/strong&gt; - и это помогает упростить процесс.</target>
        </trans-unit>
        <trans-unit id="ea546a9da3076dcf69d6a878525afaefa3c2665d" translate="yes" xml:space="preserve">
          <source>The behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object).
Object's &lt;strong&gt;content/members&lt;/strong&gt; might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference.</source>
          <target state="translated">Поведение может отличаться от примитивных типов: поскольку скопированная переменная объекта содержит один и тот же адрес (для одного и того же объекта). &lt;strong&gt;Содержимое / члены&lt;/strong&gt; объекта все еще могут быть изменены внутри метода и позднее доступны снаружи, создавая иллюзию, что сам (содержащий) объект был передан по ссылке.</target>
        </trans-unit>
        <trans-unit id="f6f95a7e89d7fa53f741a6006a73b3f53dbfe98a" translate="yes" xml:space="preserve">
          <source>The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.</source>
          <target state="translated">Функция changeName,описанная выше,никогда не сможет изменить фактическое содержимое (значения битов)переданной ссылки.Другими словами changeName не может заставить человека ссылаться на другой объект.</target>
        </trans-unit>
        <trans-unit id="d43a36b01a5a36e6a4fed6f955af9bd89a90e8e2" translate="yes" xml:space="preserve">
          <source>The crux of the matter is that the word &lt;em&gt;reference&lt;/em&gt; in the expression &quot;pass by reference&quot; means something completely different from the usual meaning of the word &lt;em&gt;reference&lt;/em&gt; in Java.</source>
          <target state="translated">Суть дела в том, что слово &amp;laquo; &lt;em&gt;ссылка&amp;raquo;&lt;/em&gt; в выражении &amp;laquo;передача по ссылке&amp;raquo; означает нечто совершенно отличное от обычного значения слова &amp;laquo; &lt;em&gt;ссылка&amp;raquo;&lt;/em&gt; в Java.</target>
        </trans-unit>
        <trans-unit id="d6413d6c252fab8253fe8c316fa9f97b12f5c04a" translate="yes" xml:space="preserve">
          <source>The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.</source>
          <target state="translated">Различие,или,возможно,просто то,как я помню,как я был под тем же впечатлением,что и оригинальный плакат,это то,что я помню:Java всегда проходит по значению.Все объекты(в Java,всё что угодно,кроме примитивов)в Java являются ссылками.Эти ссылки передаются по значению.</target>
        </trans-unit>
        <trans-unit id="e90dc2a7bcee6387a6415dbc06ec56f2e174cf42" translate="yes" xml:space="preserve">
          <source>The key to understanding this is that something like</source>
          <target state="translated">Ключ к пониманию этого в том,что что-то вроде</target>
        </trans-unit>
        <trans-unit id="c870634849690af62ce95dbaaffd653c3bdc1132" translate="yes" xml:space="preserve">
          <source>The output of this program is:</source>
          <target state="translated">Вывод этой программы:</target>
        </trans-unit>
        <trans-unit id="914b3110e6efe55bce5c55f82df6a7638d0fa6d6" translate="yes" xml:space="preserve">
          <source>The term &quot;reference&quot; is a overloaded with two separate meanings. In Java it simply means a pointer, but in the context of &quot;Pass-by-reference&quot; it means a handle to the original variable which was passed in.</source>
          <target state="translated">Термин &quot;ссылка&quot; является перегруженным двумя отдельными значениями.На Java он просто означает указатель,а в контексте &quot;Pass-by-reference&quot;-хэндл к исходной переменной,в которую он был передан.</target>
        </trans-unit>
        <trans-unit id="d685aec290065c3d070420033a198dff8941ecc8" translate="yes" xml:space="preserve">
          <source>The value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (&lt;code&gt;new ...&lt;/code&gt;) all resolve to a reference type value.</source>
          <target state="translated">Значением аргумента (некоторого ссылочного типа) является указатель на объект. Обратите внимание, что переменная, вызов метода с возвращаемым типом ссылочного типа и выражение создания экземпляра ( &lt;code&gt;new ...&lt;/code&gt; ) разрешаются в значение ссылочного типа.</target>
        </trans-unit>
        <trans-unit id="b9723eb7fef6befdaac82e1c6cd7ab277e54545d" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; holding the address of the Object is passed to the function in line #3.</source>
          <target state="translated">Переменная &lt;em&gt;person,&lt;/em&gt; содержащая адрес объекта, передается функции в строке # 3.</target>
        </trans-unit>
        <trans-unit id="9a827a692a5c5bbbe054c83be9d12f395ddfae3c" translate="yes" xml:space="preserve">
          <source>The variable &lt;em&gt;person&lt;/em&gt; is created in line #1 and it's null at the beginning.</source>
          <target state="translated">Переменная &lt;em&gt;person&lt;/em&gt; создается в строке # 1 и в начале имеет значение null.</target>
        </trans-unit>
        <trans-unit id="d211d018025495720be4d35b0fb0e965174108f6" translate="yes" xml:space="preserve">
          <source>The variable/reference &lt;em&gt;person&lt;/em&gt; is copied bit-by-bit and passed to &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; inside the function.</source>
          <target state="translated">Переменная / эталонное &lt;em&gt;лицо&lt;/em&gt; копируется побитно и передается в &lt;em&gt;anotherReferenceToTheSamePersonObject&lt;/em&gt; внутри функции.</target>
        </trans-unit>
        <trans-unit id="a6a7f9ad555d80ee9f46a19d1dc4de44b454dbba" translate="yes" xml:space="preserve">
          <source>There are already great answers that cover this. I wanted to make a small contribution by sharing a &lt;strong&gt;very simple example&lt;/strong&gt; (which will compile) contrasting the behaviors between Pass-by-reference in c++ and Pass-by-value in Java.</source>
          <target state="translated">Уже есть отличные ответы, которые охватывают это. Я хотел внести небольшой вклад, поделившись &lt;strong&gt;очень простым примером&lt;/strong&gt; (который будет скомпилирован), сравнивающим поведение между передачей по ссылке в c ++ и передачей по значению в Java.</target>
        </trans-unit>
        <trans-unit id="dfab606767515e58a1e6d064ffb7613d99a953bf" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;strong&gt;reference types&lt;/strong&gt;: class types, array types,
  and interface types. &lt;strong&gt;Their values are references to dynamically
  created class instances, arrays, or class instances or arrays that
  implement interfaces, respectively.&lt;/strong&gt;</source>
          <target state="translated">Существует три типа &lt;strong&gt;ссылочных типов&lt;/strong&gt; : &lt;strong&gt;типы&lt;/strong&gt; классов, типы массивов и типы интерфейсов. &lt;strong&gt;Их значения являются ссылками на динамически создаваемые экземпляры классов, массивы или экземпляры классов или массивы, которые реализуют интерфейсы соответственно.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa2284d9a49a58f0919e69504baa39d271367e04" translate="yes" xml:space="preserve">
          <source>There's the key.</source>
          <target state="translated">Вот ключ.</target>
        </trans-unit>
        <trans-unit id="e1f460dd17e5cf9708ba41d056ae77c8a33b5f05" translate="yes" xml:space="preserve">
          <source>Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.</source>
          <target state="translated">Считайте параметры ссылки псевдонимами передаваемой переменной.Когда этот псевдоним присваивается,то и переменная,которая была передана внутрь.</target>
        </trans-unit>
        <trans-unit id="d3a442ecb80bc2357c8302e2cfa37890d9a8f934" translate="yes" xml:space="preserve">
          <source>This happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.</source>
          <target state="translated">Это происходит потому,что iA и iB-новые локальные переменные ссылок,которые имеют одинаковое значение переданных ссылок (они указывают на a и b соответственно).Таким образом,попытка изменить ссылки в iA или iB будет изменяться только в локальной области видимости,а не вне этого метода.</target>
        </trans-unit>
        <trans-unit id="5eefcb95db3d521d55f45ddd3a85d502cf4cdc4f" translate="yes" xml:space="preserve">
          <source>This is how jump-tables work.</source>
          <target state="translated">Вот как работают прыжковые столы.</target>
        </trans-unit>
        <trans-unit id="6bf397e1d5e88f4359962543f1564d72392aa1a0" translate="yes" xml:space="preserve">
          <source>This section of the book has a great explanation of parameter passing in Java and of the distinction between pass-by-reference and pass-by-value and it's by the creator of Java. I would encourage anyone to read it, especially if you're still not convinced.</source>
          <target state="translated">В этом разделе книги дается отличное объяснение передачи параметров на Java и разницы между передачей по ссылке и передачей по значению,и это делает создатель Java.Я бы рекомендовал прочитать ее любому,особенно если вы все еще не уверены.</target>
        </trans-unit>
        <trans-unit id="f6f7ba733b2534ecc1ea818cdddfaf4dcf24537c" translate="yes" xml:space="preserve">
          <source>This typically means that the function can modify (i.e. assign to) the
  variable used as argument&amp;mdash;something that will be seen by its caller.</source>
          <target state="translated">Как правило, это означает, что функция может изменять (то есть назначать) переменную, используемую в качестве аргумента - то, что будет видно вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="a24fd574548676d8a5fdf4e5d5e866b85294afa6" translate="yes" xml:space="preserve">
          <source>This will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:</source>
          <target state="translated">Это будет заполнять Hello World,а не World Hello,потому что в функции подкачки вы используете копии,которые не влияют на ссылки в основном.Но если ваши объекты не являются неизменными,вы можете изменить их,например:</target>
        </trans-unit>
        <trans-unit id="e505e393bf5f01ebb5d9bfa9244eb4fa82d49415" translate="yes" xml:space="preserve">
          <source>This will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:</source>
          <target state="translated">В командной строке будет написано &quot;Hello World&quot;.Если вы измените StringBuffer на String,то получите только Hello,потому что строка является неизменной.Например:</target>
        </trans-unit>
        <trans-unit id="ecc09e1b426d0f3bbdde2b52d1275b4a9684b1cb" translate="yes" xml:space="preserve">
          <source>To make a long story short, &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; objects have some very peculiar properties.</source>
          <target state="translated">Короче говоря, у объектов &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; есть некоторые очень специфические свойства.</target>
        </trans-unit>
        <trans-unit id="d8f2d10c7283892fc482b2460252534f2c951f8f" translate="yes" xml:space="preserve">
          <source>To understand this more clearly, consider the following example:</source>
          <target state="translated">Чтобы понять это более четко,рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="4a3568015b17ba4456e0d1ce2a6b83da248a6190" translate="yes" xml:space="preserve">
          <source>Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-reference&amp;mdash;all arguments are passed by value. A method call can pass two types of values to a method&amp;mdash;copies of primitive values (e.g., values of int and double) and copies of references to objects.</source>
          <target state="translated">В отличие от некоторых других языков, Java не позволяет выбирать между передачей по значению и передачей по ссылке - все аргументы передаются по значению. Вызов метода может передавать в метод два типа значений: копии примитивных значений (например, значений типа int и double) и копии ссылок на объекты.</target>
        </trans-unit>
        <trans-unit id="8379236c60a3ff28075f90353d681fa71cd1a5aa" translate="yes" xml:space="preserve">
          <source>Usually in Java &lt;em&gt;reference&lt;/em&gt; means a a &lt;em&gt;reference to an object&lt;/em&gt;. But the technical terms &lt;em&gt;pass by reference/value&lt;/em&gt; from programming language theory is talking about a &lt;em&gt;reference to the memory cell holding the variable&lt;/em&gt;, which is something completely different.</source>
          <target state="translated">Обычно в Java &lt;em&gt;ссылка&lt;/em&gt; означает &lt;em&gt;ссылку на объект&lt;/em&gt; . Но технические термины, &lt;em&gt;передаваемые по ссылке / значению&lt;/em&gt; из теории языка программирования, говорят о &lt;em&gt;ссылке на ячейку памяти, содержащую переменную&lt;/em&gt; , что является чем-то совершенно другим.</target>
        </trans-unit>
        <trans-unit id="189b909d14e035d9439146930c7bf76ee3ba35f1" translate="yes" xml:space="preserve">
          <source>We have another reference variable in reverseArray method (array2) that points to an array c. If we were to say</source>
          <target state="translated">В методе reverseArray (массив 2)у нас есть еще одна ссылочная переменная,указывающая на массив c.Если бы мы сказали</target>
        </trans-unit>
        <trans-unit id="df89229a206448022bc5ed3d58cbdd5121102868" translate="yes" xml:space="preserve">
          <source>What happens?</source>
          <target state="translated">Что случилось?</target>
        </trans-unit>
        <trans-unit id="2721876ca410fad542be9395684b871758604935" translate="yes" xml:space="preserve">
          <source>What is the explanation?</source>
          <target state="translated">Каково объяснение?</target>
        </trans-unit>
        <trans-unit id="c6c48753b57b8c36067f08152d304ac38b370fa1" translate="yes" xml:space="preserve">
          <source>What that means, is when you have</source>
          <target state="translated">Это значит,что когда у тебя</target>
        </trans-unit>
        <trans-unit id="b82d13a18500a976024ec3aaa69437e0d2e0bcb9" translate="yes" xml:space="preserve">
          <source>When a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.</source>
          <target state="translated">Когда метод изменяет параметр примитивного типа,изменение этого параметра не влияет на исходное значение аргумента в вызывающем методе.</target>
        </trans-unit>
        <trans-unit id="47a4b97547a431dafab08418cf4ef38d6006e62e" translate="yes" xml:space="preserve">
          <source>When it comes to objects, objects themselves cannot be passed to methods. So we pass the address of the object which is held in the reference variable.</source>
          <target state="translated">Когда речь идет об объектах,сами объекты не могут быть переданы методам.Поэтому мы передаем адрес объекта,который содержится в переменной ссылок.</target>
        </trans-unit>
        <trans-unit id="42a98879de2bf7e9712995f5e8ec5b041e9c310b" translate="yes" xml:space="preserve">
          <source>When passing arguments to a method &lt;strong&gt;you ARE NOT passing the reference variable, but a copy of the bits in the reference variable&lt;/strong&gt;. Something like this: 3bad086a. 3bad086a represents a way to get to the passed object.</source>
          <target state="translated">При передаче аргументов методу &lt;strong&gt;вы НЕ передаете ссылочную переменную, а копируете биты в ссылочной переменной&lt;/strong&gt; . Как то так: 3bad086a. 3bad086a представляет способ добраться до пропущенного объекта.</target>
        </trans-unit>
        <trans-unit id="26b0a49f4378f6ec3b7ac0d3ca02eabd027e1846" translate="yes" xml:space="preserve">
          <source>When passing reference t to the function it will not directly pass the actual reference value of object test,  but it will create a copy of t and then pass it to the function. Since it is &lt;strong&gt;passing by value&lt;/strong&gt;, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was &lt;code&gt;0x100234&lt;/code&gt;, both t and f will have the same value and hence they will point to the same object.</source>
          <target state="translated">При передаче ссылки t в функцию она не будет напрямую передавать фактическое значение ссылки объекта test, но создаст копию t и затем передаст ее функции. Поскольку он &lt;strong&gt;передается по значению&lt;/strong&gt; , он передает копию переменной, а не фактическую ссылку на нее. Поскольку мы сказали, что значение t было &lt;code&gt;0x100234&lt;/code&gt; , и t, и f будут иметь одинаковое значение, и, следовательно, они будут указывать на один и тот же объект.</target>
        </trans-unit>
        <trans-unit id="db86d10509b05e8bc49df8c7cd3d9cada5dd82ab" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables, each of the declared type, before execution of the body of
  the method or constructor.&lt;/strong&gt; The Identifier that appears in the
  DeclaratorId may be used as a simple name in the body of the method or
  constructor to refer to the formal parameter.</source>
          <target state="translated">Когда метод или конструктор вызывают (&amp;sect;15.12), &lt;strong&gt;значения фактических выражений аргумента инициализируют вновь созданные переменные параметра, каждый из объявленного типа, перед выполнением тела метода или конструктора.&lt;/strong&gt; Идентификатор, который появляется в DeclaratorId, может использоваться как простое имя в теле метода или конструктора для ссылки на формальный параметр.</target>
        </trans-unit>
        <trans-unit id="8b67851b479dc283a6f950e2733c899590974221" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the
  actual argument expressions initialize newly created parameter
  variables&lt;/strong&gt;, each of the declared type, before execution of the body of
  the method or constructor.</source>
          <target state="translated">Когда метод или конструктор вызывается (&amp;sect;15.12), &lt;strong&gt;значения фактических выражений аргумента инициализируют вновь созданные переменные параметра&lt;/strong&gt; , каждый из объявленного типа, перед выполнением тела метода или конструктора.</target>
        </trans-unit>
        <trans-unit id="2d221d1e03c75efd20f3411a07f7d84f428d8be4" translate="yes" xml:space="preserve">
          <source>When the method or constructor is invoked (&amp;sect;15.12), &lt;strong&gt;the values of the actual argument expressions initialize newly created parameter variables&lt;/strong&gt;, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;formal parameter&lt;/a&gt;.</source>
          <target state="translated">Когда метод или конструктор вызывается (&amp;sect;15.12), &lt;strong&gt;значения фактических выражений аргумента инициализируют вновь созданные переменные параметра&lt;/strong&gt; , каждый из объявленного типа, перед выполнением тела метода или конструктора. Идентификатор, который появляется в DeclaratorId, может использоваться как простое имя в теле метода или конструктора для ссылки на &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1&quot;&gt;формальный параметр&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9aee34f3d95b06bea3cb4049aac2fc385dba277b" translate="yes" xml:space="preserve">
          <source>When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are against the word &quot;pointer&quot;. Whatever. Just know that the address of the object goes on the stack.</source>
          <target state="translated">Когда вы объявляете и конкретизируете объект.Фактический объект попадает в кучу.Что попадает в стопку? Адрес объекта на куче.Программисты на Си++назвали бы это указателем,но некоторые Java-разработчики против слова &quot;указатель&quot;.Неважно.Просто знайте,что адрес объекта идет по стеку.</target>
        </trans-unit>
        <trans-unit id="28b1f1b3dfbb6a4aedcea3dba4b14239a6b023ba" translate="yes" xml:space="preserve">
          <source>Which means, java creates a copy of the passed parameters before executing a method. Like most people who studied compilers in college, I used &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;&quot;The Dragon Book&quot;&lt;/a&gt; which is &lt;strong&gt;THE&lt;/strong&gt; compilers book. It has a good description of &quot;Call-by-value&quot; and &quot;Call-by-Reference&quot; in Chapter 1. The Call-by-value description matches up with Java Specs exactly.</source>
          <target state="translated">Это означает, что java создает копию переданных параметров перед выполнением метода. Как и большинство людей, которые изучали компиляторы в колледже, я использовал &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201100886&quot;&gt;&amp;laquo;Книгу Дракона&amp;raquo;,&lt;/a&gt; которая является Книгой компиляторов. В главе 1 есть хорошее описание &amp;laquo;Call-by-value&amp;raquo; и &amp;laquo;Call-by-Reference&amp;raquo;. Описание Call-by-value точно соответствует спецификациям Java.</target>
        </trans-unit>
        <trans-unit id="0dcbcbf7f981b706be204f899221bd4d6394bba1" translate="yes" xml:space="preserve">
          <source>Will this throw a &lt;code&gt;NullPointerException&lt;/code&gt;? No, because it only passes a copy of the reference. 
In the case of passing by reference, it could have thrown a &lt;code&gt;NullPointerException&lt;/code&gt;, as seen below:</source>
          <target state="translated">Будет ли это генерировать &lt;code&gt;NullPointerException&lt;/code&gt; ? Нет, потому что он передает только копию ссылки. В случае передачи по ссылке он мог вызвать &lt;code&gt;NullPointerException&lt;/code&gt; , как показано ниже:</target>
        </trans-unit>
        <trans-unit id="a28f32f5173460812904146e506dc73421a481d8" translate="yes" xml:space="preserve">
          <source>You always pass a copy of the bits of the value of the reference!</source>
          <target state="translated">Вы всегда передаете копию битов значения ссылки!</target>
        </trans-unit>
        <trans-unit id="a3dc507f44237c76ec4ef1ec8e4c68370d0b3167" translate="yes" xml:space="preserve">
          <source>You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:</source>
          <target state="translated">Вы никогда не можете пройти по ссылке в Java,и один из способов,который очевиден,это когда вы хотите вернуть более одного значения из вызова метода.Рассмотрим следующий бит кода на Си++:</target>
        </trans-unit>
        <trans-unit id="02c7b73324c917e7dbe1ca63e76c51d7ead60641" translate="yes" xml:space="preserve">
          <source>You could also assign value of array2 in main to array1. array1 would start pointing to b.</source>
          <target state="translated">Также можно присвоить массиву 1 значение array2 в основном.array1 начнет указывать на b.</target>
        </trans-unit>
        <trans-unit id="6b4f593c12270cbc6715abff6481a0a796758bb7" translate="yes" xml:space="preserve">
          <source>You should note that when the parameter is an object reference, it is
  the object reference-not the object itself-that is &lt;strong&gt;passed &quot;by value&quot;&lt;/strong&gt;.</source>
          <target state="translated">Вы должны заметить, что когда параметр является ссылкой на объект, &lt;strong&gt;передается &amp;laquo;по значению&amp;raquo;&lt;/strong&gt; ссылка на объект, а не на сам объект.</target>
        </trans-unit>
        <trans-unit id="fc75d6d2c095fd5d227713114c34ed1913a0b634" translate="yes" xml:space="preserve">
          <source>You're passing the value of the reference and not the reference itself (and not the object).</source>
          <target state="translated">Вы передаете значение ссылки,а не саму ссылку (и не объект).</target>
        </trans-unit>
        <trans-unit id="e412d3eb76b9c511737b2f188cf28aa0a3b15e42" translate="yes" xml:space="preserve">
          <source>a new &lt;code&gt;Dog&lt;/code&gt; is created. Let's say he's at address 74</source>
          <target state="translated">новая &lt;code&gt;Dog&lt;/code&gt; создана. Допустим, он по адресу 74</target>
        </trans-unit>
        <trans-unit id="fb3668ea3a8369fdbba52413c9d814f6e3ed4702" translate="yes" xml:space="preserve">
          <source>all bind the value of a reference to a &lt;code&gt;String&lt;/code&gt; instance to the method's newly created parameter, &lt;code&gt;param&lt;/code&gt;. This is exactly what the definition of pass-by-value describes. As such, &lt;strong&gt;Java is pass-by-value&lt;/strong&gt;.</source>
          <target state="translated">все привязывают значение ссылки на экземпляр &lt;code&gt;String&lt;/code&gt; к вновь созданному параметру метода, &lt;code&gt;param&lt;/code&gt; . Это именно то, что описывает определение передачи по значению. Таким образом, &lt;strong&gt;Java передается по значению&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8c38907cfcadbaccdbfd358b9d0106488c0111a7" translate="yes" xml:space="preserve">
          <source>at line &quot;AAA&quot;</source>
          <target state="translated">на линии &quot;ААА&quot;</target>
        </trans-unit>
        <trans-unit id="f93c76dfe98a248d087f8423725428bab806588d" translate="yes" xml:space="preserve">
          <source>at line &quot;BBB&quot;</source>
          <target state="translated">на линии &quot;ВВВ&quot;</target>
        </trans-unit>
        <trans-unit id="48a51572765a96c5528d9b97e645d1cb1d8ca215" translate="yes" xml:space="preserve">
          <source>at line &quot;CCC&quot;</source>
          <target state="translated">в строке &quot;CCC&quot;</target>
        </trans-unit>
        <trans-unit id="5b6a04bdcab2545757147311bdd9dcec1526a1b4" translate="yes" xml:space="preserve">
          <source>edit: i believe this is also the reason to use StringBuffer when it comes to &quot;adding&quot; two Strings because you can modifie the original object which u can't with immutable objects like String is.</source>
          <target state="translated">Редактирование:Я считаю,что это также является причиной использования StringBuffer,когда дело доходит до &quot;добавления&quot; двух строк,потому что вы можете модифицировать исходный объект,который вы не можете с неизменяемыми объектами,такими как строка есть.</target>
        </trans-unit>
        <trans-unit id="de6d9b079fecccb2b44d0540cd59d6982bd1a708" translate="yes" xml:space="preserve">
          <source>if the Method were defined as</source>
          <target state="translated">если бы Метод был определен как</target>
        </trans-unit>
        <trans-unit id="c0b841e19d194bfe513d4d90839ad8c2b89afe31" translate="yes" xml:space="preserve">
          <source>in case 1. and 2. if you change Foo (&lt;code&gt;Foo = 9&lt;/code&gt;) it only affects local scope as you have a copy of the Value. From inside the method we cannot even determine where in memory the original Foo was located.</source>
          <target state="translated">в случаях 1. и 2. если вы измените Foo ( &lt;code&gt;Foo = 9&lt;/code&gt; ), это повлияет только на локальную область, поскольку у вас есть копия значения. Изнутри метода мы даже не можем определить, где в памяти находился оригинальный Foo.</target>
        </trans-unit>
        <trans-unit id="1865b6df13986dcf11d66c36aeef32061892ca5b" translate="yes" xml:space="preserve">
          <source>in case 3. and 4. if you use default language constructs and change Foo (&lt;code&gt;Foo = 11&lt;/code&gt;), it could change Foo globally (depends on the language, ie. Java or like Pascal's &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt;&lt;strong&gt;var m&lt;/strong&gt;&lt;code&gt;: integer);&lt;/code&gt;). However if the language allows you to circumvent the dereference process, you can change &lt;code&gt;47&lt;/code&gt;, say to &lt;code&gt;49&lt;/code&gt;. At that point Foo seems to have been changed if you read it, because you have changed the &lt;strong&gt;local pointer&lt;/strong&gt; to it. And if you were to modify this Foo inside the method (&lt;code&gt;Foo = 12&lt;/code&gt;) you will probably FUBAR the execution of the program (aka. segfault) because you will write to a different memory than expected, you can even modify an area that is destined to hold executable program and writing to it will modify running code (Foo is now not at &lt;code&gt;47&lt;/code&gt;). BUT Foo's value of &lt;code&gt;47&lt;/code&gt; did not change globally, only the one inside the method, because &lt;code&gt;47&lt;/code&gt; was also a copy to the method.</source>
          <target state="translated">в случаях 3. и 4. если вы используете языковые конструкции по умолчанию и изменяете Foo ( &lt;code&gt;Foo = 11&lt;/code&gt; ), это может изменить Foo глобально (зависит от языка, т. е. Java или как &lt;code&gt;procedure findMin(x, y, z: integer;&lt;/code&gt; Паскаля findMin (x, y, z: integer); &lt;strong&gt;var m&lt;/strong&gt; &lt;code&gt;: integer);&lt;/code&gt; ). Однако, если язык позволяет обойти процесс разыменования, вы можете изменить &lt;code&gt;47&lt;/code&gt; , скажем, на &lt;code&gt;49&lt;/code&gt; . В этот момент кажется, что Foo изменился, если вы прочитали его, потому что вы изменили &lt;strong&gt;локальный указатель&lt;/strong&gt; на него. И если бы вы изменили этот Foo внутри метода ( &lt;code&gt;Foo = 12&lt;/code&gt; ), вы, вероятно, FUBAR запустили выполнение программы (aka. Segfault), потому что вы будете писать в память, отличную от ожидаемой, вы даже можете изменить область, которая предназначена хранение исполняемой программы и ее запись изменят выполняемый код (Foo теперь не в &lt;code&gt;47&lt;/code&gt; ). НО значение Foo &lt;code&gt;47&lt;/code&gt; не изменилось глобально, только то, что было внутри метода, потому что &lt;code&gt;47&lt;/code&gt; также было копией метода.</target>
        </trans-unit>
        <trans-unit id="dd97dfe75334fc4ae374b64905b80db5da6f0246" translate="yes" xml:space="preserve">
          <source>in case 5. and 6. if you modify &lt;code&gt;223&lt;/code&gt; inside the method it creates the same mayhem as in 3. or 4. (a pointer, pointing to a now bad value, that is again used as a pointer) but this is still a local problem, as 223 was &lt;strong&gt;copied&lt;/strong&gt;. However if you are able to dereference &lt;code&gt;Ref2Foo&lt;/code&gt; (that is &lt;code&gt;223&lt;/code&gt;), reach to and modify the pointed value &lt;code&gt;47&lt;/code&gt;, say, to &lt;code&gt;49&lt;/code&gt;, it will affect Foo &lt;strong&gt;globally&lt;/strong&gt;, because in this case the methods got a copy of &lt;code&gt;223&lt;/code&gt;  but the referenced &lt;code&gt;47&lt;/code&gt; exists only once, and changing that to &lt;code&gt;49&lt;/code&gt; will lead every &lt;code&gt;Ref2Foo&lt;/code&gt; double-dereferencing to a wrong value.</source>
          <target state="translated">в случаях 5. и 6. Если вы измените &lt;code&gt;223&lt;/code&gt; внутри метода, он создаст тот же хаос, что и в 3. или 4. (указатель, указывающий на неверное значение, которое снова используется в качестве указателя), но это все еще локальная проблема, так как 223 было &lt;strong&gt;скопировано&lt;/strong&gt; . Однако, если вы сможете разыменовать &lt;code&gt;Ref2Foo&lt;/code&gt; (то есть &lt;code&gt;223&lt;/code&gt; ), достигнуть и изменить указанное значение &lt;code&gt;47&lt;/code&gt; , скажем, на &lt;code&gt;49&lt;/code&gt; , это повлияет на Foo &lt;strong&gt;глобально&lt;/strong&gt; , потому что в этом случае методы получили копию &lt;code&gt;223&lt;/code&gt; , но ссылка &lt;code&gt;47&lt;/code&gt; существует только один раз, и изменение этого значения на &lt;code&gt;49&lt;/code&gt; приведет к каждому двойному разыменованию &lt;code&gt;Ref2Foo&lt;/code&gt; к неправильному значению.</target>
        </trans-unit>
        <trans-unit id="ea582fe2290fa53002694c7ca06cb1d90981b239" translate="yes" xml:space="preserve">
          <source>in reverseArray method, it will make a change in array a.</source>
          <target state="translated">в методе reverseArray изменит массив a.</target>
        </trans-unit>
        <trans-unit id="84dd6095c9c7186e7a49f24a310118598e04da82" translate="yes" xml:space="preserve">
          <source>in reverseArray method, then the reference variable array1 in method reverseArray would stop pointing to array a and start pointing to array c (Dotted line in second image).</source>
          <target state="translated">в методе reverseArray,тогда ссылочная переменная array1 в методе reverseArray переставала бы указывать на массив a и начинала бы указывать на массив c (пунктирная линия на втором изображении).</target>
        </trans-unit>
        <trans-unit id="d97fae11a419e6a12bc3edb13062dc19c09875c0" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;not&lt;/em&gt; a Dog; it's actually a &lt;em&gt;pointer&lt;/em&gt; to a Dog.</source>
          <target state="translated">&lt;em&gt;не&lt;/em&gt; собака; это на самом деле &lt;em&gt;указатель&lt;/em&gt; на собаку.</target>
        </trans-unit>
        <trans-unit id="b39623476b2f81bd70a4ff62eb5267bce22738e1" translate="yes" xml:space="preserve">
          <source>let's look at what's happening.</source>
          <target state="translated">давайте посмотрим,что происходит.</target>
        </trans-unit>
        <trans-unit id="cf3a9617ac647d82c56f77cf9e8ae2169d187941" translate="yes" xml:space="preserve">
          <source>name= Fido</source>
          <target state="translated">имя=Фидо</target>
        </trans-unit>
        <trans-unit id="dcf9d3f64bd4525093b6cb2a29ebf7e8b0769c96" translate="yes" xml:space="preserve">
          <source>name= Maxx</source>
          <target state="translated">имя=Макс</target>
        </trans-unit>
        <trans-unit id="ea4bd0e3bb9e113c03dc6f25c82ed0880ff1e2b7" translate="yes" xml:space="preserve">
          <source>output of java PassByCopy:</source>
          <target state="translated">вывод java PassByCopy:</target>
        </trans-unit>
        <trans-unit id="38b2369b273631468a9a5a2e59b5d466d9ec4e32" translate="yes" xml:space="preserve">
          <source>results in this:</source>
          <target state="translated">приводит к этому:</target>
        </trans-unit>
        <trans-unit id="015c3de73f8f17655e3dba14c211482d8731c15c" translate="yes" xml:space="preserve">
          <source>someDog is followed to the &lt;code&gt;Dog&lt;/code&gt; it points to (the &lt;code&gt;Dog&lt;/code&gt; object at address 74)</source>
          <target state="translated">SomeDog следует за &lt;code&gt;Dog&lt;/code&gt; он указывает (объект &lt;code&gt;Dog&lt;/code&gt; по адресу 74)</target>
        </trans-unit>
        <trans-unit id="e52ae0c10562272d36f12c255484e6e511e5858a" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 42) is asked to change his name to Max</source>
          <target state="translated">этого &lt;code&gt;Dog&lt;/code&gt; (тот, что по адресу 42) попросили сменить имя на Макса</target>
        </trans-unit>
        <trans-unit id="7444c7540aa94d77adc3ade05581aa22935938f0" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;Dog&lt;/code&gt; (the one at address 74) is asked to change his name to Rowlf</source>
          <target state="translated">этого &lt;code&gt;Dog&lt;/code&gt; (тот, что по адресу 74) попросили сменить имя на Rowlf</target>
        </trans-unit>
        <trans-unit id="a28fea2db09c1001f61be42d428ec193c0c8fe83" translate="yes" xml:space="preserve">
          <source>the parameter &lt;code&gt;someDog&lt;/code&gt; is set to the value 42</source>
          <target state="translated">для параметра &lt;code&gt;someDog&lt;/code&gt; установлено значение 42</target>
        </trans-unit>
        <trans-unit id="05ed7faac6636fc4d3a902712b65ab43bb7a5b80" translate="yes" xml:space="preserve">
          <source>then, we return</source>
          <target state="translated">затем мы возвращаемся</target>
        </trans-unit>
        <trans-unit id="49280f2d918fc694c452825a7629c4f082161d51" translate="yes" xml:space="preserve">
          <source>using methods from the object given as parameter will alter the
object as the references point to
the original objects. (if that
method itself alters some values)</source>
          <target state="translated">использование методов из объекта,заданного в качестве параметра,изменит объект,поскольку ссылки на исходные объекты будут указывать на него.(если этот метод сам изменяет некоторые значения).</target>
        </trans-unit>
        <trans-unit id="d8b3d65782447afeffa2d99acee97cbf42b98ecf" translate="yes" xml:space="preserve">
          <source>we assign the parameter &lt;code&gt;someDog&lt;/code&gt; to 74</source>
          <target state="translated">мы присваиваем параметру &lt;code&gt;someDog&lt;/code&gt; значение 74</target>
        </trans-unit>
        <trans-unit id="b5086d2ae6b0cb0d15f1111f65e03a674960103f" translate="yes" xml:space="preserve">
          <source>will print out &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; instead of &lt;code&gt;null&lt;/code&gt;. The reason this works is because &lt;code&gt;bar&lt;/code&gt; is a copy of the value of &lt;code&gt;baz&lt;/code&gt;, which is just a reference to &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt;. If it were the actual reference itself, then &lt;code&gt;foo&lt;/code&gt; would have redefined &lt;code&gt;baz&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">распечатает &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; вместо &lt;code&gt;null&lt;/code&gt; . Причина, по которой это работает, заключается в том, что &lt;code&gt;bar&lt;/code&gt; является копией значения &lt;code&gt;baz&lt;/code&gt; , которое является просто ссылкой на &lt;code&gt;&quot;Hah!&quot;&lt;/code&gt; , Если бы это была сама фактическая ссылка, то &lt;code&gt;foo&lt;/code&gt; переопределило бы &lt;code&gt;baz&lt;/code&gt; на &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f07948ada1b914ebc3731995719969a1b588a36" translate="yes" xml:space="preserve">
          <source>you're essentially passing the &lt;em&gt;address&lt;/em&gt; of the created &lt;code&gt;Dog&lt;/code&gt; object to the &lt;code&gt;foo&lt;/code&gt; method.</source>
          <target state="translated">вы по существу передаете &lt;em&gt;адрес&lt;/em&gt; созданного объекта &lt;code&gt;Dog&lt;/code&gt; методу &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
